<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>克拉克拉(KilaKila)：大规模实时计算平台架构实战 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10250459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10250459.html</guid>
<description>&lt;p&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont685409.i0.7b0f5d4bJuPctr&quot;&gt;克拉克拉(KilaKila)：大规模实时计算平台架构实战&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一、产品背景：&lt;br/&gt;克拉克拉（KilaKila）是国内专注二次元、主打年轻用户的娱乐互动内容社区软件。KilaKila推出互动语音直播、短视频配音、对话小说等功能，满足当下年轻用户个性化、碎片化的文娱需求。App用户等级体系作为克拉克拉社区化打造的核心业务，在增强社区活跃度、提高产品留存方面起到至关重要的作用。随着业务规模增长，海量用户行为日志实时采集与计算的瓶颈也日益突出，由于单台服务器的处理能力有限，海量数据分析需要分布式计算模型来替代。通过技术调研与架构选型，最终解决方案采用基于阿里云日志服务（Log Service）与 开源技术Storm为组合的基础架构。&lt;/p&gt;
&lt;p&gt;二、实时日志采集：&lt;br/&gt;LogHub 支持客户端、网页、协议、SDK/API等多种日志无损采集方式，所有采集方式均基于Restful API实现，除此之外也可以通过API/SDK实现新的采集方式。对于克拉克拉来说，业务日志会实时输出到本地服务器，通过在日志服务器部署Logtail，即可完成日志的无丢失采集。因业务场景不同，对日志可以根据不同的Topic进行分类，从而满足不同业务的个性化计算需求。此外，LogHup可通过配置自带的投递服务，将海量日志同步到数据仓库中永久存储。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_1&quot; src=&quot;https://yqfile.alicdn.com/32108906ced0e4f9a2b0bdfcc2d6e470d2ed70be.png&quot; alt=&quot;_1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图一：日志采集流程图&lt;/p&gt;
&lt;p&gt;通过Logtail来采集Nginx上用户行为的日志到Logstore只需要简单配置相应日志所在的机器组和日志的绝对路径，其从日志落盘服务器到采集工作的完成控制在1秒内。同时Logstore支持多功能的日志检索服务，可以为后续明确用户行为提供快捷的查询服务。其中我们将不同topic的日志存储在不同的Logstore中，供后续不同业务有针对性的实时消费。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_2&quot; src=&quot;https://yqfile.alicdn.com/2a601bd8c5d713006527e27c30042e3fc0b54118.png&quot; alt=&quot;_2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图二：克拉克拉topic日志结构图&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_3&quot; src=&quot;https://yqfile.alicdn.com/612a4a78cb6028e08a85e897038a8112ca55fa87.png&quot; alt=&quot;_3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图三：日志检索&lt;/p&gt;
&lt;p&gt;三、实时业务场景：&lt;br/&gt;为满足克拉克拉用户社区目标，该业务主要针对APP用户在直播、小说、视频三大业务线100多种行为场景下完成用户经验值的实时计算，也就是数据值的增删改查。在实时计算层，克拉克拉选择了Storm开源的分布式实时大数据处理框架，而阿里云日志服务对于Storm有着非常好的兼容与支持。&lt;br/&gt;&lt;img title=&quot;_4&quot; src=&quot;https://yqfile.alicdn.com/843ff9fb80aaabab3bbb61f7e10f4a3822364658.png&quot; alt=&quot;_4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图四：克拉克拉实时计算框架&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_5&quot; src=&quot;https://yqfile.alicdn.com/2be1a24f413cfa542f0918637a88443218d4d373.png&quot; alt=&quot;_5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图五：LogHup 与 Storm关系&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;上图中红色虚线框中就是LogHub Storm Spout，每个Storm Topology会有一组Spout，同组内的Spout共同负责读取Logstore中全部数据。不同Topology中的Spout相互不干扰。每个Topology需要选择唯一的LogHub Consume Group名字来相互标识，同一 Topology内的Spout通过 Consumer Library来完成负载均衡和自动failover。Spout从LogHub中实时读取数据之后，发送至Topology中的Bolt节点，定期保存消费完成位置作为checkpoint到LogHub服务端。&lt;/p&gt;
&lt;p&gt;四、实时数据存储&lt;br/&gt;克拉克拉实时计算框架中存在诸多数据缓存、永久存储等场景需求。面对该问题，克拉克拉采用了阿里云OTS组件方案。OTS也称为表格存储（Table Store）是阿里云自研的NoSQL多模型数据库，提供海量结构化数据存储以及快速的查询和分析服务。表格存储的分布式存储和强大的索引引擎能够提供PB级存储、千万TPS以及毫秒级延迟的服务能力。通过使用OTS所提供的Java SDK开发包实现了Storm计算过程中所涉及到的数据存储需求。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_6&quot; src=&quot;https://yqfile.alicdn.com/4e698d5ceb424cce189b1d4f7fb23726b1611c3e.png&quot; alt=&quot;_6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图六：克拉克拉OTS存储示例&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;五、项目总结&lt;br/&gt;该项目以实时性和数据的精确度作为评判指标，所面临的挑战主要是用户行为的高并发，平均每秒百万级别的用户计算量；而针对不同的Logstore的日志处理量将会达到用户计算量的十倍左右。通过基于阿里云日志服务、OTS表格存储组件所搭建的克拉克拉实时计算平台综合能力表现良好，符合产品业务预期。&lt;br/&gt;六、未来展望&lt;br/&gt;以Storm为计算中心的框架虽可满足克拉克拉业务诉求，但相关项目研发效率还可进一步提升。对此，后续将重点调研阿里云另一个高效实时计算组件Blink。Blink 是阿里云实时计算方案，基于开源的Apache Flink。 该技术方案的最大亮点是通过SQL脚本语言来代替现有Java语言所开发的计算逻辑。从研发效率上来讲，SQL脚本更容易上手且运维成本更低，相信到时公司整体实时计算框架的性能将会得到显著的提升。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/685409?utm_content=g_1000036523&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。　　&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 07:55:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>克拉克拉(KilaKila)：大规模实时计算平台架构实战 一、产品背景：克拉克拉（KilaKila）是国内专注二次元、主打年轻用户的娱乐互动内容社区软件。KilaKila推出互动语音直播、短视频配音、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10250459.html</dc:identifier>
</item>
<item>
<title>Bighead Fighter - Boarding the Peak of the Beast - 冰热夏夜</title>
<link>http://www.cnblogs.com/brxy-21/p/10250434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brxy-21/p/10250434.html</guid>
<description>&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;Contact: Tom&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt highlight&quot; data-group=&quot;1-0&quot;&gt;Contact number: +6045823657&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;2-0&quot;&gt;Contact: zpg9y8@163.com&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;“Bighead Fighter - Boarding the Peak of the Beast” respects and protects the personal privacy of all users using the service.In order to provide you with more accurate and personalized services, “Bighead Fighter - Boarding the Peak of the Beast” will use and disclose your personal information in accordance with the provisions of this privacy policy.But “Bighead Fighter - Boarding the Peak of the Beast” will treat this information with a high degree of diligence and due diligence.Except as otherwise provided in this privacy policy, “Bighead Fighter - Boarding the Peak of the Beast” will not disclose or provide such information to third parties without your prior permission.“Bighead Fighter - Boarding the Peak of the Beast” will update this privacy policy from time to time.When you agree to the service usage agreement of “Bighead Fighter - Boarding the Peak of the Beast”, you will be deemed to have agreed to all contents of this privacy policy.This privacy policy is an integral part of the service usage agreement of “Bighead Fighter - Boarding the Peak of the Beast”.&lt;br/&gt;1. Scope of application&lt;br/&gt;A) when you register the account of “Bighead Fighter - Boarding the Peak of the Beast”, you provide the personal registration information required by “Bighead Fighter - Boarding the Peak of the Beast”;&lt;br/&gt;B) “Bighead Fighter - Boarding the Peak of the Beast” legally gets user personal data from business partners.&lt;br/&gt;You understand and agree that the following information is not applicable to this privacy policy:&lt;br/&gt;A) the keyword information you enter when using the search service provided by “Bighead Fighter - Boarding the Peak of the Beast”;&lt;br/&gt;B) the information data collected by you in “Bighead Fighter - Boarding the Peak of the Beast”, including but not limited to activities, transaction information and evaluation details;&lt;br/&gt;C) act in violation of the law or the rules of “Bighead Fighter - Boarding the Peak of the Beast” and the measures already taken against you by “Bighead Fighter - Boarding the Peak of the Beast”.?&lt;/p&gt;
&lt;p&gt;2. Use of information&lt;br/&gt;A) &amp;lt; Crazy Gobang game - classic &amp;gt; won't come to any irrelevant third party to provide, sell, rent, share or trade your personal information, unless get your permission in advance, or the third party and &amp;lt; Crazy Gobang game - classic &amp;gt; (&amp;lt; Crazy Gobang game - classic &amp;gt; affiliates) alone or together to provide the service for you, and at the end of the service, it will be banned from access to be able to access all the information including its before.&lt;br/&gt;B) “Bighead Fighter - Boarding the Peak of the Beast” will not allow any third party to collect, edit, sell or disseminate your personal information by any means.Any “Bighead Fighter - Boarding the Peak of the Beast” platform user engaging in the above activities, as soon as found, “Bighead Fighter - Boarding the Peak of the Beast” has the right to immediately terminate the service agreement with that user.&lt;br/&gt;C) for the purpose of service users, &amp;lt; Crazy Gobang game - classic &amp;gt; possible through the use of your personal information, provide you with the information you have interested in, including but not limited to sent you product and service information, or with the &amp;lt; Crazy Gobang game - classic &amp;gt; partners share information so that they send you information about its products and services, which need your prior consent).&lt;br/&gt;3. Information disclosure&lt;br/&gt;Under the following circumstances, “Bighead Fighter - Boarding the Peak of the Beast” will disclose your personal information in whole or in part according to your personal wishes or legal provisions:&lt;br/&gt;A) disclose to a third party with your prior consent;&lt;br/&gt;B) share your personal information with third parties to provide the products and services you require;&lt;br/&gt;C) disclose to a third party or to an administrative or judicial institution in accordance with the relevant provisions of the law or the requirements of the administrative or judicial authorities;&lt;br/&gt;D) if you violate relevant laws and regulations of China or the service agreement of AnimalEntertainment&amp;gt; or relevant rules, you need to disclose to a third party;&lt;br/&gt;E) if you are the qualified complainant of intellectual property and have filed a complaint, you should disclose it to the complainant at the request of the complainant so that both parties can handle possible rights disputes;&lt;br/&gt;F) in a transaction created on the platform “Bighead Fighter - Boarding the Peak of the Beast”, if either party of the transaction performs or partially fulfills the transaction obligation and makes a request for disclosure, “Bighead Fighter - Boarding the Peak of the Beast” has the right to provide the user with necessary information such as contact information of the other party of the transaction to facilitate the completion of the transaction or the settlement of disputes.&lt;br/&gt;G) other disclosures deemed appropriate by laws, regulations or website policies.&lt;/p&gt;
&lt;p&gt;4. Information storage and exchange&lt;br/&gt;The information and data collected by “Bighead Fighter - Boarding the Peak of the Beast” will be stored on the servers of “Bighead Fighter - Boarding the Peak of the Beast” and/or its affiliates, which may be transmitted to your country, region or overseas where “Bighead Fighter - Boarding the Peak of the Beast” is collected and accessed, stored and displayed.&lt;br/&gt;5. Use of cookies&lt;br/&gt;A) if you do not reject cookies, “Bighead Fighter - Boarding the Peak of the Beast” will set or fetch cookies on your computer&lt;br/&gt;, so that you can log in or use the services or features of the “Bighead Fighter - Boarding the Peak of the Beast” platform that relies on cookies.“Bighead Fighter - Boarding the Peak of the Beast” USES cookies to provide you with more thoughtful personalized services, including promotional services.B) you have the option to accept or reject cookies.You can reject cookies by modifying your browser Settings.But if you choose to reject cookies, you may not be able to log in or use the network service or function “Bighead Fighter - Boarding the Peak of the Beast” that relies on cookies.&lt;br/&gt;C) information obtained through cookies set by “Bighead Fighter - Boarding the Peak of the Beast” will apply to this policy.&lt;br/&gt;6. Information security&lt;br/&gt;A) “Bighead Fighter - Boarding the Peak of the Beast” accounts have security protection function. Please keep your user name and password information properly.“Bighead Fighter - Boarding the Peak of the Beast” will ensure your information is not lost, abused or altered by security measures such as encrypting user passwords.Despite the aforementioned security measures, please note that there is no &quot;perfect security measures&quot; on the information network.&lt;br/&gt;B) when using the network service “Bighead Fighter - Boarding the Peak of the Beast”, you will inevitably disclose your personal information, such as contact information or postal address, to the other party or potential transaction partner.Please protect your personal information and provide it to others only if necessary.If you find that your personal information has been compromised, especially the username and password of “Bighead Fighter - Boarding the Peak of the Beast”, please contact the customer service of “Bighead Fighter - Boarding the Peak of the Beast” immediately, so that “Bighead Fighter - Boarding the Peak of the Beast” can take corresponding measures.&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 07:51:00 +0000</pubDate>
<dc:creator>冰热夏夜</dc:creator>
<og:description>Contact: Tom Contact number: +6045823657 Contact: zpg9y8@163.com “Bighead Fighter - Boarding the Pea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brxy-21/p/10250434.html</dc:identifier>
</item>
<item>
<title>JavaScript--获取页面盒子中鼠标相对于盒子上、左边框的坐标 - 笑苍茫</title>
<link>http://www.cnblogs.com/WangYujie1994/p/10249060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WangYujie1994/p/10249060.html</guid>
<description>&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562037/201901/1562037-20190110113804652-543431297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;外层边框是浏览器边框，内部盒子是页面的一个盒子，绿点是盒子中鼠标的位置。鼠标相对盒子边框的坐标=页面中（注意不是浏览器）鼠标坐标-盒子相对于浏览器边框的偏移量&lt;/p&gt;


&lt;p&gt;第一步：求浏览器边框位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;x=element.offsetLeft;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;y=element.offsetTop;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;************样式表*******************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;style&amp;gt;
&lt;span&gt; 3&lt;/span&gt;             *&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                padding: 0px;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                margin: 0px;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            body {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                height: 2000px;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            #box{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                border: 1px solid black;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                margin: 100px;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                width: 400px;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                height: 400px;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &amp;lt;/style&amp;gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;************网页主体*******************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;21&lt;/span&gt;         &amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;************JS代码*******************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &amp;lt;script&amp;gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取盒子边框相当于浏览器边框的距离&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; box=document.getElementById('box'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26 &lt;/span&gt;          &lt;span&gt;  var x=box.offsetLeft;
27             var y=box.offsetTop;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            console.log(x);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            console.log(y);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;31&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;第二步：求鼠标在页面中的位置&lt;/p&gt;
&lt;p&gt;鼠标在页面中的位置：&lt;/p&gt;
&lt;p&gt;e.PageX  e.PageY ----------&amp;gt;鼠标在整个文档中的位置&lt;/p&gt;
&lt;p&gt;e.ClientX  e.ClientY ---------&amp;gt;鼠标在整个浏览器中的位置&lt;/p&gt;
&lt;p&gt;上面二者的区别在于文档中有没有滚动条，如果有滚动条，则两个不一样，没有滚动条的情况下，二者没有区别。在本文要求中，需要使用e.PageX  e.PageY&lt;/p&gt;
&lt;p&gt;不过，e.PageX  e.PageY有浏览器兼容性问题，从IE9以后才支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;e.PageX=e.ClientX+滚动条滚动距离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;e.PageY=e.ClientY+滚动条滚动距离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;滚动条滚动距离也具有浏览器兼容问题，浏览器兼容问题解决如下：&lt;/p&gt;
&lt;p&gt;2.1 滚动条的滚动距离的兼容问题&lt;/p&gt;
&lt;p&gt;一般求滚动条滚动距离有两种方式，如下：&lt;/p&gt;
&lt;p&gt;第一种：&lt;/p&gt;
&lt;p&gt;scroll_x=document.body.scrollLeft&lt;/p&gt;
&lt;p&gt;scroll_y=document.body.scrollTop&lt;/p&gt;
&lt;p&gt;第二种：&lt;/p&gt;
&lt;p&gt;scroll_x=document.documentElement.scrollLeft;&lt;/p&gt;
&lt;p&gt;scroll_y=document.documentElement.scrollTop;&lt;/p&gt;
&lt;p&gt;但是发现使用第一种方式，获得的滚动条滚动距离一直是0。&lt;/p&gt;
&lt;p&gt;查资料发现是DTD的问题。&lt;/p&gt;
&lt;p&gt;页面指定了DTD，即指定了DOCTYPE时，使用document.documentElement.scrollTop。&lt;/p&gt;
&lt;p&gt;页面没有DTD，即没指定DOCTYPE时，使用document.body.scrollTop。&lt;br/&gt;当然，针对上述问题，本文做了如下调整：&lt;/p&gt;
&lt;p&gt;//滚动条滚动距离&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var scroll_x=document.body.scrollLeft || document.documentElement.scrollLeft;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;var scroll_y=document.body.scrollTop || document.documentElement.scrollTop;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2e.PageX  e.PageY有浏览器兼容性问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;var page_x=e.pageX || e.clientX + scroll_x;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var page_y=e.pageY || e.clientY + scroll_y;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步和第一步做差，即能得到获取页面盒子中鼠标相对于盒子上、左边框的坐标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html lang=&quot;en&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;         &amp;lt;style&amp;gt;
&lt;span&gt; 7&lt;/span&gt;             *&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                padding: 0px;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                margin: 0px;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            body {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                height: 2000px;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            #box{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                border: 1px solid black;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                margin: 100px;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                width: 400px;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                height: 400px;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &amp;lt;/style&amp;gt;
&lt;span&gt;21&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt;24&lt;/span&gt;         &amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;span&gt;25&lt;/span&gt;         &amp;lt;script&amp;gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取盒子边框相当于浏览器边框的距离&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; box=document.getElementById('box'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; box_x=&lt;span&gt;box.offsetLeft;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; box_y=&lt;span&gt;box.offsetTop;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;滚动条滚动距离&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;          &lt;span&gt;var&lt;/span&gt; scroll_x=document.body.scrollLeft ||&lt;span&gt; document.documentElement.scrollLeft;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;          &lt;span&gt;var&lt;/span&gt; scroll_y=document.body.scrollTop ||&lt;span&gt; document.documentElement.scrollTop;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;          
&lt;span&gt;35&lt;/span&gt;          
&lt;span&gt;36&lt;/span&gt;          
&lt;span&gt;37&lt;/span&gt;          
&lt;span&gt;38&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标点击事件&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;          document.onclick=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;e.pageX  e.pageY坐标&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;              &lt;span&gt;var&lt;/span&gt; page_x=e.pageX || e.clientX +&lt;span&gt; scroll_x;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;              &lt;span&gt;var&lt;/span&gt; page_y=e.pageY || e.clientY +&lt;span&gt; scroll_y;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对坐标&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;              &lt;span&gt;var&lt;/span&gt; x=page_x -&lt;span&gt; box_x;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;              &lt;span&gt;var&lt;/span&gt; y=page_y -&lt;span&gt; box_y;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;             console.log(x);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;             console.log(y);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;50&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;51&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 10 Jan 2019 07:45:00 +0000</pubDate>
<dc:creator>笑苍茫</dc:creator>
<og:description>分析： 外层边框是浏览器边框，内部盒子是页面的一个盒子，绿点是盒子中鼠标的位置。鼠标相对盒子边框的坐标=页面中（注意不是浏览器）鼠标坐标-盒子相对于浏览器边框的偏移量 第一步：求浏览器边框位置 x=e</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WangYujie1994/p/10249060.html</dc:identifier>
</item>
<item>
<title>二叉树中和为某一值的路径 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/10250306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/10250306.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;32.083766608897&quot;&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;题目：二叉树中和为某一值的路径 &lt;/span&gt;&lt;/h3&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从&lt;br/&gt;树的根结点开始往下一直到叶结点所经过的结点形成一条路径。&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;预备知识&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h-3&quot;&gt;&lt;span&gt;前序遍历（递归 非递归）&lt;/span&gt;&lt;/h4&gt;
&lt;h4 id=&quot;hoj&quot;&gt;&lt;span&gt;Oj&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-preorder-traversal/&quot;&gt;https://leetcode-cn.com/problems/binary-tree-preorder-traversal/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;h-4&quot;&gt;&lt;span&gt;代码&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs php&quot; readability=&quot;10&quot;&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Integer&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;pre(root, &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; void pre(TreeNode root, &lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;){&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (root == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;.add(root.val);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (root.left != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;pre(root.left, &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (root.right != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;pre(root.right, &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;);&lt;br/&gt;}       &lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、从根节点开始遍历，说明他是前序遍历&lt;/p&gt;
&lt;p&gt;2、到达叶节点不是目标值，要回退元素，其实是一个栈结构&lt;/p&gt;
&lt;p&gt;3、树的问题大部分是递归问题&lt;/p&gt;
&lt;h3 id=&quot;hoj-1&quot;&gt;&lt;span&gt;Oj&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;amp;tqId=11177&amp;amp;tPage=2&amp;amp;rp=2&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot;&gt;https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;amp;tqId=11177&amp;amp;tPage=2&amp;amp;rp=2&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-6&quot;&gt;&lt;span&gt;代码&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;hljs kotlin&quot; readability=&quot;12&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.ArrayList;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TreeNode&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;int &lt;span class=&quot;hljs-keyword&quot;&gt;val&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;TreeNode left = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;TreeNode right = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; TreeNode(int &lt;span class=&quot;hljs-keyword&quot;&gt;val&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;val&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;val&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindPath(TreeNode root,int target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (root == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;){&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; lists;&lt;br/&gt;}&lt;br/&gt;list.add(root.&lt;span class=&quot;hljs-keyword&quot;&gt;val&lt;/span&gt;);&lt;br/&gt;target -= root.&lt;span class=&quot;hljs-keyword&quot;&gt;val&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (target == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; root.right == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.left == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;){&lt;br/&gt;lists.add(new ArrayList&amp;lt;&amp;gt;(list));&lt;br/&gt;}&lt;br/&gt;FindPath(root.left, target);&lt;br/&gt;FindPath(root.right, target);&lt;br/&gt;list.remove(list.size() - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; lists;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 10 Jan 2019 07:35:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>题目：二叉树中和为某一值的路径 描述 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 预备知识 前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenzhuantou/p/10250306.html</dc:identifier>
</item>
<item>
<title>Docker系列08—搭建使用私有docker registry - alonghub</title>
<link>http://www.cnblogs.com/along21/p/10249001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/10249001.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;strong&gt;本文收录于&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; href=&quot;http://www.cnblogs.com/along21/p/9006829.html&quot;&gt;&lt;span&gt;Linux 系统化学习系列文章总目录&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1&lt;span&gt;、了解&lt;/span&gt;&lt;span&gt;Docker Registry&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;strong&gt;1.1 &lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;registry &lt;span&gt;用于保存&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt; &lt;span&gt;镜像，包括镜像的层次结构和元数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;启动容器时，&lt;/span&gt;docker daemon&lt;span&gt;会试图从本地获取相关的镜像；本地镜像不存在时，其将从&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;中下载该镜像并保存到本地；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;拉取镜像时，如果不知道&lt;/span&gt;registry&lt;span&gt;仓库地址，默认从&lt;/span&gt;&lt;span&gt;Docker Hub&lt;/span&gt;&lt;span&gt;搜索拉取镜像&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;1.2 &lt;span&gt;分类&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Sponsor Registry&lt;span&gt;：第三方的&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;，供客户和&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;社区使用；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;mirror Registry&lt;span&gt;：第三方的&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;，只让客户使用；如&lt;/span&gt;&lt;span&gt;docker cn&lt;/span&gt;&lt;span&gt;和阿里云的镜像加速器；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;vendor Registry&lt;span&gt;：服务商的&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;，由发布&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;镜像的供应商提供的&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;；如红帽提供的专有的，收费提供；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;private Registry&lt;span&gt;：通过设有防火墙和额外的安全层的私有实体提供的&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;；自建的&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;，在本地搭建&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;，节省带宽&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;1.3 registry&lt;span&gt;组成（&lt;/span&gt;&lt;span&gt;repository&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;（1）Repository&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;由特定的&lt;/span&gt;docker&lt;span&gt;镜像的所有迭代版本组成的镜像仓库；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个&lt;/span&gt;registry&lt;span&gt;中可以存在多个&lt;/span&gt;&lt;span&gt;repository&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;
&lt;ul&gt;&lt;li&gt; repository&lt;span&gt;可分为&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;顶层仓库&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;用户仓库&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;用户仓库名称格式为&lt;/span&gt;“&lt;span&gt;用户名&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;仓库名&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个仓库可以包含多个&lt;/span&gt;Tag&lt;span&gt;（标签），每个标签对应一个镜像&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）Index&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;维护用户账户、镜像的校验以及公共命名空间的信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;相当于为&lt;/span&gt;registry&lt;span&gt;提供了一个完成用户认证等功能的检索接口&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;1.4 &lt;span&gt;拉取上传仓库镜像&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）拉取镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker pull &amp;lt;registry&amp;gt;[:&amp;lt;port&amp;gt;]/[&amp;lt;namespace&amp;gt;/]&amp;lt;name&amp;gt;:&amp;lt;tag&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; registry&lt;span&gt;：仓库服务器地址：不指定默认是&lt;/span&gt;&lt;span&gt;docker hub&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; port&lt;span&gt;：端口；默认是&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;，因为是&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;协议&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; namespace&lt;span&gt;：名称空间，指是哪个用户的仓库，如果是顶层仓库，可省&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; name&lt;span&gt;：仓库名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; tag&lt;span&gt;：标签名；默认是&lt;/span&gt;&lt;span&gt;latest&lt;/span&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）上传镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker push [OPTIONS] NAME[:TAG]
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;1.5 &lt;span&gt;知名&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;仓库&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　　　例：&lt;/span&gt;docker pull quay.io/coreos/flannel:v0.10.0-amd64&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　博主前面的文章已经详细介绍过，从第三方的&lt;/span&gt;registry &lt;span&gt;上传拉取镜像了；这篇就是详细讲解如果搭建私有&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt; &lt;span&gt;，并在私有&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;上传拉取镜像了。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2&lt;span&gt;、搭建私有仓库&lt;/span&gt; &lt;span&gt;distribution&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;2.1 distribution &lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;docker&lt;span&gt;提供的开源&lt;/span&gt;&lt;span&gt;Registry&lt;/span&gt;&lt;span&gt;，但是很简单，只能作为存储镜像的仓库，没有额外的功能；如管理页面等&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.2 &lt;span&gt;安装启动&lt;/span&gt; &lt;span&gt;distribution&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;两种方案安装，我采用的是方案&lt;/span&gt;2&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;2.2.1 &lt;span&gt;方案&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：使用&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;安装（直接从&lt;/span&gt;&lt;span&gt;extras&lt;/span&gt; &lt;span&gt;源中下载安装）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 ~]# yum info docker-distribution
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
可安装的软件包
名称    ：docker-distribution
架构    ：x86_64
版本    ：2.6.2
发布    ：2.git48294d9.el7
大小    ：3.5 M
源    ：extras/7/x86_64
简介    ： Docker toolset to pack, ship, store, and deliver content
网址    ：https://github.com/docker/distribution
协议    ： ASL 2.0
描述    ： Docker toolset to pack, ship, store, and deliver content
[root@docker2 ~]# yum -y install docker-distribution
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;2.2.2 &lt;span&gt;方案&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：拉取镜像，作为容器安装&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）拉取镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 ~]# docker pull registry:2.6.2
2.6.2: Pulling from library/registry
d6a5679aa3cf: Pull complete 
ad0eac849f8f: Pull complete 
2261ba058a15: Pull complete 
f296fda86f10: Pull complete 
bcd4a541795b: Pull complete 
Digest: sha256:5a156ff125e5a12ac7fdec2b90b7e2ae5120fa249cf62248337b6d04abc574c8
Status: Downloaded newer image for registry:2.6.2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）启动&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt; &lt;span&gt;容器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 ~]# docker run --name registry -p 5000:5000 -v /data/registry:/var/lib/registry -d registry:2.6.2 
a43f802e737eba89879a4dc02562b38e0042db981f9bdb91782b453f0bac4119
[root@docker2 ~]# docker port registry 
5000/tcp -&amp;gt; 0.0.0.0:5000
[root@docker2 ~]# ss -nutlp |grep 5000
tcp    LISTEN     0      128      :::5000                 :::*                   users:((&quot;docker-proxy&quot;,pid=4901,fd=4))
[root@docker2 ~]# docker inspect -f {{.&quot;Mounts&quot;}} registry
[{bind  /data/registry /var/lib/registry   true rprivate}]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; -p 5000:5000&lt;span&gt;：将容器中的&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;端口，暴露在宿主机的&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;端口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; -v /data/registry:/var/lib/registry&lt;span&gt;：指定宿主机存储的位置为&lt;/span&gt; &lt;span&gt;/data/registry&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; -d&lt;span&gt;：后台运行容器&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;2.3 &lt;span&gt;从私有仓库上传下载镜像&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;2.3.1 &lt;span&gt;将本地的镜像上传到私有仓库&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）先将本地仓库打上合适的标签&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# docker tag busybox:latest 192.168.10.102:5000/busybox:v0.1
[root@docker1 ~]# docker image ls
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
192.168.10.102:5000/busybox   v0.1                758ec7f3a1ee        13 days ago         1.15 MB
busybox                       latest              758ec7f3a1ee        13 days ago         1.15 MB
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）尝试删除镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# docker push 192.168.10.102:5000/busybox:v0.1 
The push refers to a repository [192.168.10.102:5000/busybox]
Get https://192.168.10.102:5000/v1/_ping: http: server gave HTTP response to HTTPS client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上传镜像失败；原因：&lt;/span&gt;docker &lt;span&gt;上传下载默认只支持&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;协议，搭建的私有仓库是&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;协议。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）修改重启&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# vim /etc/docker/daemon.json
{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],
  &quot;insecure-registries&quot;: [&quot;192.168.10.102:5000&quot;]
}
[root@docker1 ~]# systemctl restart docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：就是将私有仓库认证为安全仓库：&lt;/span&gt;&quot;insecure-registries&quot;: [&quot;&quot;]&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）再次上传镜像，成功&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# docker push 192.168.10.102:5000/busybox:v0.1 
The push refers to a repository [192.168.10.102:5000/busybox]
23bc2b70b201: Pushed 
v0.1: digest: sha256:cbcde3595079b1f7a6b046e96e7547fe786d5c2c8eba678bc260161bc01b8dbe size: 527
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）在私有仓库的服务器上验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 ~]# ls /data/registry/docker/registry/v2/
blobs  repositories
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;6&lt;span&gt;）从私有仓库拉取镜像，先删除再拉取&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# docker rmi 192.168.10.102:5000/busybox:v0.1 
Untagged: 192.168.10.102:5000/busybox:v0.1
Untagged: 192.168.10.102:5000/busybox@sha256:cbcde3595079b1f7a6b046e96e7547fe786d5c2c8eba678bc260161bc01b8dbe
[root@docker1 ~]# docker image ls
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
busybox                  latest              758ec7f3a1ee        2 weeks ago         1.15 MB
[root@docker1 ~]# docker pull 192.168.10.102:5000/busybox:v0.1
v0.1: Pulling from busybox
Digest: sha256:cbcde3595079b1f7a6b046e96e7547fe786d5c2c8eba678bc260161bc01b8dbe
Status: Downloaded newer image for 192.168.10.102:5000/busybox:v0.1
[root@docker1 ~]# docker image ls
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
192.168.10.102:5000/busybox   v0.1                758ec7f3a1ee        2 weeks ago         1.15 MB
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;3&lt;span&gt;、安装搭建私有仓库&lt;/span&gt; &lt;span&gt;Harbor&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;3.1 &lt;span&gt;认识&lt;/span&gt; &lt;span&gt;Harbor&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.1.1 Harbor &lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt; Harbor gitlab&lt;span&gt;项目地址：&lt;/span&gt;&lt;a href=&quot;https://github.com/goharbor/harbor&quot;&gt;&lt;span&gt;https://github.com/goharbor/harbor&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; Harbor&lt;span&gt;是一个&lt;/span&gt;&lt;strong&gt;&lt;span&gt;开源的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可信云本机注册表项目，用于存储，签名和扫描内容。&lt;/span&gt;Harbor&lt;span&gt;通过添加用户通常需要的功能（如安全性，身份和管理）来&lt;/span&gt;&lt;strong&gt;&lt;span&gt;扩展开源&lt;/span&gt;Docker Distribution&lt;/strong&gt;&lt;span&gt;。使注册表更接近构建和运行环境可以提高图像传输效率。&lt;/span&gt;Harbor&lt;span&gt;支持在注册表之间复制映像，还提供高级安全功能，如用户管理，访问控制和活动审计。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; Harbour&lt;span&gt;由&lt;/span&gt;&lt;span&gt;Cloud Native Computing Foundation&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;strong&gt;CNCF&lt;/strong&gt;&lt;span&gt;）托管。如果您是一个希望帮助塑造云原生技术发展的组织，请考虑加入&lt;/span&gt;CNCF&lt;span&gt;。有关谁参与以及&lt;/span&gt;&lt;span&gt;Harbour&lt;/span&gt;&lt;span&gt;如何扮演角色的详细信息，请阅读&lt;/span&gt;&lt;span&gt;CNCF&lt;/span&gt; &lt;span&gt;公告。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;3.1.2 Harbor &lt;span&gt;特征&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt; &lt;strong&gt;&lt;span&gt;云本机注册表&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;Harbour &lt;span&gt;支持容器映像和&lt;/span&gt;&lt;span&gt;Helm&lt;/span&gt;&lt;span&gt;图表，可用作云本机环境（如容器运行时和业务流程平台）的注册表。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;基于角色的访问控制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：用户和存储库通过&lt;/span&gt;“&lt;span&gt;项目&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;进行组织，用户可以对项目下的图像拥有不同的权限。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;基于策略的映像复制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可以基于具有多个过滤器（存储库，标记和标签）的策略在多个注册表实例之间复制（同步）映像。如果遇到任何错误，&lt;/span&gt;Harbor&lt;span&gt;将自动重试进行复制。非常适合负载平衡，高可用性，多数据中心，混合和多云场景。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;漏洞扫描&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;Harbor&lt;span&gt;定期扫描图像并警告用户漏洞。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;LDAP / AD&lt;span&gt;支持&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;Harbor&lt;span&gt;与现有企业&lt;/span&gt;&lt;span&gt;LDAP / AD&lt;/span&gt;&lt;span&gt;集成以进行用户身份验证和管理，并支持将&lt;/span&gt;&lt;span&gt;LDAP&lt;/span&gt;&lt;span&gt;组导入&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt;&lt;span&gt;并为其分配适当的项目角色。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;图像删除和垃圾收集&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可以删除图像，并可以回收它们的空间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;公证&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可以确保图像的真实性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;图形用户门户&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：用户可以轻松浏览，搜索存储库和管理项目。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;审计&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：跟踪存储库的所有操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;RESTful API&lt;/strong&gt;&lt;span&gt;：适用于大多数管理操作的&lt;/span&gt;RESTful API&lt;span&gt;，易于与外部系统集成。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;&lt;span&gt;易于部署&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提供在线和离线安装程序。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;3.1.3 harbor &lt;span&gt;配置参数&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）参数介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;配置参数位于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;文件&lt;/span&gt;harbor.cfg&lt;/strong&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;② &lt;span&gt;在&lt;/span&gt;&lt;span&gt;harbor.cfg&lt;/span&gt;&lt;span&gt;中有两类参数，必需参数和可选参数。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; required&lt;span&gt;参数：需要在配置文件中设置这些参数。如果用户更新它们&lt;/span&gt;&lt;span&gt;harbor.cfg&lt;/span&gt;&lt;span&gt;并运行&lt;/span&gt;&lt;span&gt;install.sh&lt;/span&gt;&lt;span&gt;脚本以重新安装&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt;&lt;span&gt;，它们将生效。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;可选参数：这些参数对于更新是可选的，即用户可以将它们保留为默认值，并在启动&lt;/span&gt;Harbour&lt;span&gt;后在&lt;/span&gt;&lt;span&gt;Web Portal&lt;/span&gt;&lt;span&gt;上更新它们。如果它们已经启用&lt;/span&gt;&lt;span&gt;harbor.cfg&lt;/span&gt;&lt;span&gt;，它们只会在首次启动&lt;/span&gt;&lt;span&gt;Harbour&lt;/span&gt;&lt;span&gt;时生效。&lt;/span&gt;&lt;span&gt;harbor.cfg&lt;/span&gt;&lt;span&gt;将忽略对这些参数的后续更新。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;③ &lt;span&gt;注意：如果您选择通过&lt;/span&gt;&lt;span&gt;Portal&lt;/span&gt;&lt;span&gt;设置这些参数，请务必在&lt;/span&gt;&lt;span&gt;Harbour&lt;/span&gt;&lt;span&gt;启动后立即执行此操作。特别是，您必须在&lt;/span&gt;&lt;span&gt;Harbour&lt;/span&gt;&lt;span&gt;中注册或创建任何新用户之前设置所需的&lt;/span&gt;&lt;span&gt;auth_mode&lt;/span&gt;&lt;span&gt;。当系统中有用户时（除默认管理员用户外），&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;无法更改&lt;/span&gt;&lt;span&gt;auth_mode&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;④ &lt;span&gt;请注意，至少需要更改&lt;/span&gt;&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;属性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）必需参数&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;strong&gt;hostname&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;目标主机的主机名，用于访问&lt;/span&gt;Portal&lt;span&gt;和注册表服务。它应该是目标计算机的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址或完全限定的域名（&lt;/span&gt;&lt;span&gt;FQDN&lt;/span&gt;&lt;span&gt;），例如，&lt;/span&gt;&lt;span&gt;192.168.1.10&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;reg.yourdomain.com&lt;/span&gt;&lt;span&gt;。不要使用&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;作为主机名&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;外部客户端需要访问注册表服务！&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;ui_url_protocol :&lt;/strong&gt;( http&lt;span&gt;或&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;默认为&lt;/span&gt;http&lt;/strong&gt;&lt;span&gt;）用于访问&lt;/span&gt;Portal&lt;span&gt;和令牌&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;通知服务的协议。如果启用了公证，则此参数必须为&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;。默认情况下，这是&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;。要设置&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;协议，请参阅使用&lt;/span&gt;&lt;span&gt;HTTPS&lt;/span&gt;&lt;span&gt;访问配置&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;db_password&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;用于&lt;/span&gt;db_auth&lt;span&gt;的&lt;/span&gt;&lt;span&gt;PostgreSQL&lt;/span&gt;&lt;strong&gt;&lt;span&gt;数据库的&lt;/span&gt;root&lt;span&gt;密码&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。更改此密码以用于任何生产用途！&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;max_job_workers :&lt;/strong&gt;(&lt;span&gt;默认值为&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;）作业服务中的最大复制工作者数。对于每个映像复制作业，工作程序将存储库的所有标记同步到远程目标。增加此数量可以在系统中实现更多并发复制作业。但是，由于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;每个工作者都消耗一定量的网络&lt;/span&gt;/ CPU / IO&lt;span&gt;资源&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，请根据主机的硬件资源仔细选择该属性的值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;customize_crt&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（&lt;/span&gt;on or off. &lt;strong&gt;Default is on&lt;/strong&gt;&lt;span&gt;），如果此属性&lt;/span&gt;on&lt;span&gt;，在准备脚本创建注册表的令牌生成&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;验证私钥和根证书。当外部源提供密钥和根证书时，将此属性设置为&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;。有关详细信息，请参阅自定义密钥和港口令牌服务证书。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;ssl_cert&lt;span&gt;：&lt;/span&gt;&lt;span&gt;SSL&lt;/span&gt;&lt;span&gt;证书的路径&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，仅在协议设置为&lt;/span&gt;https&lt;span&gt;时应用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;ssl_cert_key&lt;span&gt;：&lt;/span&gt;&lt;span&gt;SSL&lt;/span&gt;&lt;span&gt;密钥的路径&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，仅在协议设置为&lt;/span&gt;https&lt;span&gt;时应用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;secretkey_path&lt;/strong&gt;&lt;span&gt;：用于加密或解密复制策略中远程注册表密码的密钥路径。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;log_rotate_count&lt;/strong&gt;&lt;span&gt;：日志文件在被删除之前会被轮换&lt;/span&gt;log_rotate_count&lt;span&gt;次。如果&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，则删除旧版本而不是旋转。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;log_rotate_size&lt;/strong&gt;&lt;span&gt;：仅当日志文件大于&lt;/span&gt;log_rotate_size&lt;span&gt;字节时才会轮换日志文件。如果大小后跟&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;，则假定大小以千字节为单位。如果使用&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;，则大小以兆字节为单位，如果使用&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;，则大小为千兆字节。尺寸&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;，尺寸&lt;/span&gt;&lt;span&gt;100k&lt;/span&gt;&lt;span&gt;，尺寸&lt;/span&gt;&lt;span&gt;100M&lt;/span&gt;&lt;span&gt;和尺寸&lt;/span&gt;&lt;span&gt;100G&lt;/span&gt;&lt;span&gt;都是有效的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;http_proxy&lt;/strong&gt;&lt;span&gt;：为&lt;/span&gt;Clair&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;代理，例如&lt;/span&gt;&lt;span&gt;http://my.proxy.com:3128&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;https_proxy&lt;/strong&gt;&lt;span&gt;：为&lt;/span&gt;Clair&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;代理，例如&lt;/span&gt;&lt;span&gt;http://my.proxy.com:3128&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;no_proxy&lt;/strong&gt;&lt;span&gt;：为&lt;/span&gt;Clair&lt;span&gt;配置无代理，例如&lt;/span&gt;&lt;span&gt;127.0.0.1,localhost,core,registry&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）可选参数&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;电子邮件设置&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;Harbor&lt;span&gt;需要这些参数才能向用户发送&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;密码重置&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;电子邮件，并且仅在需要该功能时才需要。另外，请注意，在默认情况下&lt;/span&gt;&lt;span&gt;SSL&lt;/span&gt;&lt;span&gt;连接时没有启用&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;如果你的&lt;/span&gt;&lt;span&gt;SMTP&lt;/span&gt;&lt;span&gt;服务器需要&lt;/span&gt;&lt;span&gt;SSL&lt;/span&gt;&lt;span&gt;，但不支持&lt;/span&gt;&lt;span&gt;STARTTLS&lt;/span&gt;&lt;span&gt;，那么你应该通过设置启用&lt;/span&gt;&lt;span&gt;SSL email_ssl = TRUE&lt;/span&gt;&lt;span&gt;。如果电子邮件服务器使用自签名证书或不受信任证书，则设置&lt;/span&gt;&lt;span&gt;email_insecure = true&lt;/span&gt;
&lt;ul&gt;&lt;li&gt; email_server = smtp.mydomain.com&lt;/li&gt;
&lt;li&gt; email_server_port = 25&lt;/li&gt;
&lt;li&gt; email_identity =&lt;/li&gt;
&lt;li&gt; email_username = sample_admin@mydomain.com&lt;/li&gt;
&lt;li&gt; email_password = abc&lt;/li&gt;
&lt;li&gt; email_from = admin sample_admin@mydomain.com&lt;/li&gt;
&lt;li&gt; email_ssl = false&lt;/li&gt;
&lt;li&gt; email_insecure = false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;harbor_admin_password&lt;span&gt;：管理员的初始密码&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。此密码仅在&lt;/span&gt;Harbor&lt;span&gt;首次启动时生效。之后，将忽略此设置，并且应在&lt;/span&gt;&lt;span&gt;Portal&lt;/span&gt;&lt;span&gt;中设置管理员密码。请注意，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;默认用户名&lt;/span&gt;/&lt;span&gt;密码为&lt;/span&gt;&lt;span&gt;admin / Harbor12345&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;auth_mode&lt;/strong&gt;&lt;span&gt;：使用的身份验证类型。默认情况下，它是&lt;/span&gt;&lt;strong&gt;db_auth&lt;/strong&gt;&lt;span&gt;，即凭据存储在数据库中。对于&lt;/span&gt;LDAP&lt;span&gt;身份验证，请将其设置为&lt;/span&gt;&lt;span&gt;ldap_auth&lt;/span&gt;&lt;span&gt;。重要信息：从现有&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt;&lt;span&gt;实例升级时，必须确保在启动新版本的&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt;&lt;span&gt;之前&lt;/span&gt;&lt;span&gt;auth_mode&lt;/span&gt;&lt;span&gt;相同&lt;/span&gt;&lt;span&gt;harbor.cfg&lt;/span&gt;&lt;span&gt;。否则，用户可能无法在升级后登录。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_url&lt;span&gt;：&lt;/span&gt;&lt;span&gt;LDAP&lt;/span&gt;&lt;span&gt;端点&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;（例如&lt;/span&gt;&lt;span&gt;ldaps://ldap.mydomain.com&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;仅在&lt;/span&gt;&lt;span&gt;auth_mode&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;ldap_auth&lt;/span&gt;&lt;span&gt;时使用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_searchdn&lt;span&gt;：具有搜索&lt;/span&gt;&lt;span&gt;LDAP / AD&lt;/span&gt;&lt;span&gt;服务器权限的用户的&lt;/span&gt;&lt;span&gt;DN&lt;/span&gt;&lt;span&gt;（例如&lt;/span&gt;&lt;span&gt;uid=admin,ou=people,dc=mydomain,dc=com&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_search_pwd&lt;span&gt;：&lt;/span&gt;&lt;span&gt;ldap_searchdn&lt;/span&gt;&lt;span&gt;指定的用户密码。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_basedn&lt;span&gt;：查找用户的基本&lt;/span&gt;&lt;span&gt;DN&lt;/span&gt;&lt;span&gt;，例如&lt;/span&gt;&lt;span&gt;ou=people,dc=mydomain,dc=com&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;仅在&lt;/span&gt;&lt;span&gt;auth_mode&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;ldap_auth&lt;/span&gt;&lt;span&gt;时使用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_filter&lt;span&gt;：用于查找用户的搜索过滤器，例如&lt;/span&gt;&lt;span&gt;(objectClass=person)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_uid&lt;span&gt;：用于在&lt;/span&gt;&lt;span&gt;LDAP&lt;/span&gt;&lt;span&gt;搜索期间匹配用户的属性，它可以是&lt;/span&gt;&lt;span&gt;uid&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;cn&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;email&lt;/span&gt;&lt;span&gt;或其他属性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_scope&lt;span&gt;：搜索用户的范围，&lt;/span&gt;&lt;span&gt;0-LDAP_SCOPE_BASE&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;1-LDAP_SCOPE_ONELEVEL&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;2-LDAP_SCOPE_SUBTREE&lt;/span&gt;&lt;span&gt;。默认值为&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_timeout&lt;span&gt;：连接&lt;/span&gt;&lt;span&gt;LDAP&lt;/span&gt;&lt;span&gt;服务器时超时（以秒为单位）。默认值为&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_verify_cert&lt;span&gt;：验证来自&lt;/span&gt;&lt;span&gt;LDAP&lt;/span&gt;&lt;span&gt;服务器的证书。默认为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_group_basedn&lt;span&gt;：在&lt;/span&gt;&lt;span&gt;LDAP / AD&lt;/span&gt;&lt;span&gt;中查找组的基本&lt;/span&gt;&lt;span&gt;dn&lt;/span&gt;&lt;span&gt;，例如&lt;/span&gt;&lt;span&gt;ou=group,dc=mydomain,dc=com&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_group_filter&lt;span&gt;：搜索&lt;/span&gt;&lt;span&gt;LDAP / AD&lt;/span&gt;&lt;span&gt;组的过滤器，例如&lt;/span&gt;&lt;span&gt;objectclass=group&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_group_gid&lt;span&gt;：用于命名&lt;/span&gt;&lt;span&gt;LDAP / AD&lt;/span&gt;&lt;span&gt;组的属性，它可以是&lt;/span&gt;&lt;span&gt;cn&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; ldap_group_scope&lt;span&gt;：搜索&lt;/span&gt;&lt;span&gt;ldap&lt;/span&gt;&lt;span&gt;组的范围。&lt;/span&gt;&lt;span&gt;0-LDAP_SCOPE_BASE&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;1-LDAP_SCOPE_ONELEVEL&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;2-LDAP_SCOPE_SUBTREE&lt;/span&gt;&lt;span&gt;。默认值为&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; self_registration :( &lt;span&gt;打开或关闭。默认打开）启用&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;禁用用户注册他&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;她自己的能力。禁用时，新用户只能由管理员用户创建，只有管理员用户可以在&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt;&lt;span&gt;中创建新用户。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;注意：当&lt;/span&gt;&lt;span&gt;auth_mode&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;ldap_auth&lt;/span&gt;&lt;span&gt;时，始终禁用自注册功能，并忽略此标志。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; token_expiration&lt;span&gt;：令牌服务创建的令牌的到期时间（以分钟为单位），默认为&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;分钟。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; project_creation_restriction&lt;span&gt;：用于控制用户有权创建项目的标志。默认情况下，每个人都可以创建一个项目，设置为&lt;/span&gt;&lt;span&gt;“adminonly”&lt;/span&gt;&lt;span&gt;，这样只有管理员才能创建项目。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）配置存储后端（可选）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认情况下，&lt;/span&gt;Harbor&lt;span&gt;将图像存储在本地文件系统中。在生产环境中，您可以考虑使用其他存储后端而不是本地文件系统，如&lt;/span&gt;&lt;span&gt;S3&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;OpenStack Swift&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Ceph&lt;/span&gt;&lt;span&gt;等。这些参数是注册表的配置。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; registry_storage_provider_name&lt;span&gt;：注册表的存储提供程序名称，可以是&lt;/span&gt;&lt;span&gt;filesystem&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;s3&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;gcs&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;azure&lt;/span&gt;&lt;span&gt;等。默认为&lt;/span&gt;&lt;span&gt;filesystem&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; registry_storage_provider_config&lt;span&gt;：存储提供程序配置的逗号分隔&lt;/span&gt;&lt;span&gt;“key&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;value”&lt;/span&gt;&lt;span&gt;对，例如&lt;/span&gt;&lt;span&gt;“key1&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;value2”&lt;/span&gt;&lt;span&gt;。默认为空字符串。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; registry_custom_ca_bundle&lt;span&gt;：自定义根&lt;/span&gt;&lt;span&gt;ca&lt;/span&gt;&lt;span&gt;证书的路径，它将注入到注册表和图表存储库容器的信任库中。当用户使用自签名证书托管内部存储时，通常需要这样做。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;例如，如果使用&lt;/span&gt;Openstack Swift&lt;span&gt;作为存储后端，则参数可能如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
registry_storage_provider_name = swift
registry_storage_provider_config = “ username：admin，password：ADMIN_PASS，authurl：http：// keystone_addr：35357 / v3 / aut
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：有关注册表存储后端的详细信息，请参阅&lt;/span&gt;“ &lt;a href=&quot;https://docs.docker.com/registry/configuration/&quot;&gt;&lt;span&gt;注册表配置参考&lt;/span&gt;”&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3.2 &lt;span&gt;安装主机的先决条件&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.2.1 &lt;span&gt;硬件&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;资源&lt;/th&gt;
&lt;th&gt;容量&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;最小2 CPU&lt;/td&gt;
&lt;td&gt;4 CPU是首选&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;最小4GB&lt;/td&gt;
&lt;td&gt;8GB是首选&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;磁盘&lt;/td&gt;
&lt;td&gt;最小40GB&lt;/td&gt;
&lt;td&gt;160GB是首选&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h4&gt;&lt;strong&gt;3.2.2 &lt;span&gt;软件&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;软件&lt;/th&gt;
&lt;th&gt;版&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.2941176470588&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;2.7或更高版本&lt;/td&gt;
&lt;td&gt;请注意，您可能必须在Linux发行版（Gentoo，Arch）上安装Python，默认情况下不安装Python解释器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.5546218487395&quot;&gt;&lt;td&gt;Docker engine&lt;/td&gt;
&lt;td&gt;版本1.10或更高版本&lt;/td&gt;
&lt;td&gt;有关安装说明，请参阅：&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot; rel=&quot;nofollow&quot;&gt;https&lt;/a&gt;：&lt;a href=&quot;https://docs.docker.com/engine/installation/&quot; rel=&quot;nofollow&quot;&gt;//docs.docker.com/engine/installation/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.6666666666667&quot;&gt;&lt;td&gt;Docker Compose&lt;/td&gt;
&lt;td&gt;版本1.6.0或更高版本&lt;/td&gt;
&lt;td&gt;有关安装说明，请参阅：&lt;a href=&quot;https://docs.docker.com/compose/install/&quot; rel=&quot;nofollow&quot;&gt;https&lt;/a&gt;：&lt;a href=&quot;https://docs.docker.com/compose/install/&quot; rel=&quot;nofollow&quot;&gt;//docs.docker.com/compose/install/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Openssl&lt;/td&gt;
&lt;td&gt;最新的是首选&lt;/td&gt;
&lt;td&gt;为Harbor生成证书和密钥&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h4&gt;&lt;strong&gt;3.2.3 &lt;span&gt;网络端口&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;端口&lt;/th&gt;
&lt;th&gt;协议&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;443&lt;/td&gt;
&lt;td&gt;HTTPS&lt;/td&gt;
&lt;td&gt;Harbor门户和核心API将接受此端口上的https协议请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4443&lt;/td&gt;
&lt;td&gt;HTTPS&lt;/td&gt;
&lt;td&gt;只有在启用“公证”时才需要连接到Dock的Docker Content Trust服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;Harbor端口和核心API将接受此端口上的http协议请求&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h4&gt;&lt;strong&gt;3.2.4 &lt;span&gt;添加一块&lt;/span&gt;&lt;span&gt;50G&lt;/span&gt; &lt;span&gt;新硬盘（如果磁盘足够，可忽略）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;博主也是太长时间没有进行硬盘添加的操作了，熟悉一遍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）查询添加的磁盘的名字&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ fdisk -l
Disk /dev/sdb: 53.7 GB, 53687091200 bytes, 104857600 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）对磁盘进行分区&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ fdisk /dev/sdb
Command (m for help): m
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Using default response p
Partition number (1-4, default 1): 
First sector (2048-104857599, default 2048): 
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-104857599, default 104857599): 
Using default value 104857599
Partition 1 of type Linux and of size 50 GiB is set
Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）磁盘文件格式化&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ [root@centos7-1 ~]# mkfs.ext3 /dev/sdb1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）挂载磁盘&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ vim /etc/fstab    设为开机自动挂载
/dev/sdb1               /data                   ext3    defaults        0 0
$ mount -a   挂载磁盘
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@centos7-1 ~]# df -h /data
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb1        50G   52M   47G   1% /data
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.2.5 &lt;span&gt;安装&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;编排工具&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;Docker Compose&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;方案&lt;/span&gt;1&lt;span&gt;：直接&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 ~]# yum -y install docker-compose
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;方案&lt;/span&gt;2&lt;span&gt;：在&lt;/span&gt;&lt;span&gt;GitHub&lt;/span&gt;&lt;span&gt;上选择自己需要的版本下载安装&lt;/span&gt;&lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;&lt;span&gt;https://github.com/docker/compose/releases&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ curl -L https://github.com/docker/compose/releases/download/1.23.2/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-compose
$ chmod +x /usr/local/bin/docker-compose
$ docker-compose version
docker-compose version 1.23.2, build 1110ad01
docker-py version: 3.6.0
CPython version: 3.6.7
OpenSSL version: OpenSSL 1.1.0f  25 May 2017
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.4 &lt;span&gt;安装搭建&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.4.1 &lt;span&gt;下载&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt; &lt;span&gt;安装包&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;资源可以下载的很慢，我已经将&lt;/span&gt;1.7.1&lt;span&gt;版本放入我的网盘了，需要的私聊&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 ~]# wget https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.1.tgz
[root@docker2 ~]# tar -C /data/ -xvf harbor-offline-installer-v1.7.1.tgz
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.4.2 &lt;span&gt;配置&lt;/span&gt;&lt;span&gt;Harbor&lt;/span&gt; &lt;span&gt;服务&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）修改&lt;/span&gt;&lt;span&gt;harbor.cfg&lt;/span&gt; &lt;span&gt;配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 ~]# cd /data/harbor/
[root@docker2 harbor]# grep &quot;^[^#]&quot; harbor.cfg 
_version = 1.7.0
hostname = docker2
ui_url_protocol = http
max_job_workers = 2 
customize_crt = on
ssl_cert = /data/cert/server.crt
ssl_cert_key = /data/cert/server.key
secretkey_path = /data
admiral_url = NA
log_rotate_count = 50
log_rotate_size = 200M
http_proxy =
https_proxy =
no_proxy = 127.0.0.1,localhost,core,registry
email_identity = 
email_server = smtp.mydomain.com
email_server_port = 25
email_username = sample_admin@mydomain.com
email_password = abc
email_from = admin &amp;lt;sample_admin@mydomain.com&amp;gt;
email_ssl = false
email_insecure = false
harbor_admin_password = Harbor12345
auth_mode = db_auth
ldap_url = ldaps://ldap.mydomain.com
ldap_basedn = ou=people,dc=mydomain,dc=com
ldap_uid = uid 
ldap_scope = 2 
ldap_timeout = 5
ldap_verify_cert = true
ldap_group_basedn = ou=group,dc=mydomain,dc=com
ldap_group_filter = objectclass=group
ldap_group_gid = cn
ldap_group_scope = 2
self_registration = on
token_expiration = 30
project_creation_restriction = everyone
db_host = postgresql
db_password = along
db_port = 5432
db_user = postgres
redis_host = redis
redis_port = 6379
redis_password = along
redis_db_index = 1,2,3
clair_db_host = postgresql
clair_db_password = along
clair_db_port = 5432
clair_db_username = postgres
clair_db = postgres
clair_updaters_interval = 12
uaa_endpoint = uaa.mydomain.org
uaa_clientid = id
uaa_clientsecret = secret
uaa_verify_cert = true
uaa_ca_cert = /path/to/ca.pem
registry_storage_provider_name = filesystem
registry_storage_provider_config =
registry_custom_ca_bundle =
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;主要修改了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　hostname&lt;span&gt;：主机名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　max_job_workers&lt;span&gt;：最大&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;数，小于等于自己服务器的硬件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）定义&lt;/span&gt;&lt;span&gt;docker-compose.yml&lt;/span&gt; &lt;span&gt;文件（可省略）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;docker-compose.yml &lt;span&gt;文件是&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt; &lt;span&gt;编排时，对容器的一些操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ports:&lt;/p&gt;
&lt;p&gt;      - 80:80&lt;/p&gt;
&lt;p&gt;      - 443:443&lt;/p&gt;
&lt;p&gt;      - 4443:4443&lt;/p&gt;
&lt;p&gt;② &lt;span&gt;众多存储器路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;volumes:&lt;/p&gt;
&lt;p&gt;      - /data/registry:/storage:z&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在生产环境中，尽量将容器的存储卷定义在空间较为充足的磁盘；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自己根据实际情况进行修改；&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;3.4.3 &lt;span&gt;安装启动&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 harbor]# ./install.sh 

[Step 0]: checking installation environment ...

Note: docker version: 18.03.1

Note: docker-compose version: 1.23.2

[Step 1]: loading Harbor images ...
Loaded image: goharbor/registry-photon:v2.6.2-v1.7.1
Loaded image: goharbor/harbor-migrator:v1.7.1
Loaded image: goharbor/harbor-adminserver:v1.7.1
Loaded image: goharbor/harbor-core:v1.7.1
Loaded image: goharbor/harbor-log:v1.7.1
Loaded image: goharbor/harbor-jobservice:v1.7.1
Loaded image: goharbor/notary-server-photon:v0.6.1-v1.7.1
Loaded image: goharbor/clair-photon:v2.0.7-v1.7.1
Loaded image: goharbor/harbor-portal:v1.7.1
Loaded image: goharbor/harbor-db:v1.7.1
Loaded image: goharbor/redis-photon:v1.7.1
Loaded image: goharbor/nginx-photon:v1.7.1
Loaded image: goharbor/harbor-registryctl:v1.7.1
Loaded image: goharbor/notary-signer-photon:v0.6.1-v1.7.1
Loaded image: goharbor/chartmuseum-photon:v0.7.1-v1.7.1


[Step 2]: preparing environment ...
Generated and saved secret to file: /data/secretkey
Generated configuration file: ./common/config/nginx/nginx.conf
Generated configuration file: ./common/config/adminserver/env
Generated configuration file: ./common/config/core/env
Generated configuration file: ./common/config/registry/config.yml
Generated configuration file: ./common/config/db/env
Generated configuration file: ./common/config/jobservice/env
Generated configuration file: ./common/config/jobservice/config.yml
Generated configuration file: ./common/config/log/logrotate.conf
Generated configuration file: ./common/config/registryctl/env
Generated configuration file: ./common/config/core/app.conf
Generated certificate, key file: ./common/config/core/private_key.pem, cert file: ./common/config/registry/root.crt
The configuration files are ready, please use docker-compose to start the service.


[Step 3]: checking existing instance of Harbor ...


[Step 4]: starting Harbor ...
Creating network &quot;harbor_harbor&quot; with the default driver
Creating harbor-log ... done
Creating registry           ... done
Creating harbor-db          ... done
Creating registryctl        ... done
Creating harbor-adminserver ... done
Creating redis              ... done
Creating harbor-core        ... done
Creating harbor-portal      ... done
Creating harbor-jobservice  ... done
Creating nginx              ... done

✔ ----Harbor has been installed and started successfully.----

Now you should be able to visit the admin portal at http://docker2. 
For more details, please visit https://github.com/goharbor/harbor .
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.4.3 &lt;span&gt;安装后验证&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）打开了一些端口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 harbor]# ss -nutlp |grep docker
tcp    LISTEN     0      128    127.0.0.1:1514                  *:*                   users:((&quot;docker-proxy&quot;,pid=1440,fd=4))
tcp    LISTEN     0      128      :::80                   :::*                   users:((&quot;docker-proxy&quot;,pid=2204,fd=4))
tcp    LISTEN     0      128      :::443                  :::*                   users:((&quot;docker-proxy&quot;,pid=2192,fd=4))
tcp    LISTEN     0      128      :::4443                 :::*                   users:((&quot;docker-proxy&quot;,pid=2181,fd=4))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt;&lt;span&gt;实际就是启动了一些&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 ~]# docker ps
CONTAINER ID        IMAGE                                    COMMAND                  CREATED             STATUS                 PORTS                                                              NAMES
def22a8eeb9a        goharbor/nginx-photon:v1.7.1             &quot;nginx -g 'daemon of…&quot;   2 hours ago         Up 2 hours (healthy)   0.0.0.0:80-&amp;gt;80/tcp, 0.0.0.0:443-&amp;gt;443/tcp, 0.0.0.0:4443-&amp;gt;4443/tcp   nginx
a410a38479fa        goharbor/harbor-portal:v1.7.1            &quot;nginx -g 'daemon of…&quot;   2 hours ago         Up 2 hours (healthy)   80/tcp                                                             harbor-portal
e25f87eb80db        goharbor/harbor-jobservice:v1.7.1        &quot;/harbor/start.sh&quot;       2 hours ago         Up 2 hours                                                                                harbor-jobservice
2be7211535a2        goharbor/harbor-core:v1.7.1              &quot;/harbor/start.sh&quot;       2 hours ago         Up 2 hours (healthy)                                                                      harbor-core
26681dde1dec        goharbor/harbor-db:v1.7.1                &quot;/entrypoint.sh post…&quot;   2 hours ago         Up 2 hours (healthy)   5432/tcp                                                           harbor-db
80f592176896        goharbor/harbor-registryctl:v1.7.1       &quot;/harbor/start.sh&quot;       2 hours ago         Up 2 hours (healthy)                                                                      registryctl
def7f9892e46        goharbor/redis-photon:v1.7.1             &quot;docker-entrypoint.s…&quot;   2 hours ago         Up 2 hours             6379/tcp                                                           redis
9af874368813        goharbor/registry-photon:v2.6.2-v1.7.1   &quot;/entrypoint.sh /etc…&quot;   2 hours ago         Up 2 hours (healthy)   5000/tcp                                                           registry
0f7156ac62f7        goharbor/harbor-adminserver:v1.7.1       &quot;/harbor/start.sh&quot;       2 hours ago         Up 2 hours (healthy)                                                                      harbor-adminserver
3e45524ef1f0        goharbor/harbor-log:v1.7.1               &quot;/bin/sh -c /usr/loc…&quot;   2 hours ago         Up 2 hours (healthy)   127.0.0.1:1514-&amp;gt;10514/tcp                                          harbor-log
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;4&lt;span&gt;、使用&lt;/span&gt; &lt;span&gt;Harbor&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;4.1 &lt;span&gt;Harbor 页面基础操作&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;（1）网页登录http://192.168.130.102&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190110134648755-1182541033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （2）登录harbor 后一些简单的操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190110134708612-782458528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）用户管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190110134725324-717113206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：密码要有一定的复杂度&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）邮件配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190110134802032-189906033.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）新建一个项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190110134821891-1940716747.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;4.2 &lt;span&gt;上传下载镜像到&lt;/span&gt; &lt;span&gt;Harbor&lt;/span&gt; &lt;span&gt;仓库&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）修改&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;配置，添加&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt;&lt;span&gt;仓库为新人地址&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# cat /etc/docker/daemon.json 
{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],
  &quot;insecure-registries&quot;: [&quot;192.168.10.102:5000&quot;],
  &quot;insecure-registries&quot;: [&quot;docker2:80&quot;]
}
[root@docker1 ~]# systemctl restart docker
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）把要上传的镜像打上合适的标签&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# docker tag busybox:latest docker2:80/demo/busybox:v0.1
[root@docker1 ~]# docker tag nginx:1.14-alpine docker2:80/demo/nginx:v0.1
[root@docker1 ~]# docker tag nginx:1.14 docker2:80/demo/nginx:v0.2
[root@docker1 ~]# docker image ls
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
docker2:80/demo/nginx         v0.2                3f55d5bb33f3        11 days ago         109 MB
docker2:80/demo/busybox       v0.1                758ec7f3a1ee        2 weeks ago         1.15 MB
docker2:80/demo/nginx         v0.1                c5b6f731fbc0        2 weeks ago         17.7 MB
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）登录&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt;&lt;span&gt;仓库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# docker login docker2:80
Username: admin
Password: 
Login Succeeded
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）上传镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# docker push docker2:80/demo/busybox:v0.1 
The push refers to a repository [docker2:80/demo/busybox]
23bc2b70b201: Pushed 
v0.1: digest: sha256:cbcde3595079b1f7a6b046e96e7547fe786d5c2c8eba678bc260161bc01b8dbe size: 527
[root@docker1 ~]# docker push docker2:80/demo/nginx  #如果不知道tag，会把这个镜像的所有tag都上传
The push refers to a repository [docker2:80/demo/nginx]
59b059d445c1: Layer already exists 
0246bb21855f: Layer already exists 
42acf078bf60: Layer already exists 
7bff100f35cb: Layer already exists 
v0.1: digest: sha256:438d8080098025e9983f253af806c1d1aa6b48be2ef1913991dab506bb3d4f72 size: 1153
6959f2c2a244: Pushed 
06eb7a5682d6: Pushed 
7b4e562e58dc: Pushed 
v0.2: digest: sha256:1313a52e3fd1718b1c36822cefa0e51950654004dcf12b08affb3067e02c6d9c size: 948
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）在&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt; &lt;span&gt;上验证上传成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190110135026468-1482450299.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;6&lt;span&gt;）拉取&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt; &lt;span&gt;中的镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker1 ~]# docker rmi docker2:80/demo/busybox:v0.1 
Untagged: docker2:80/demo/busybox:v0.1
Untagged: docker2:80/demo/busybox@sha256:cbcde3595079b1f7a6b046e96e7547fe786d5c2c8eba678bc260161bc01b8dbe
[root@docker1 ~]# docker image ls docker2:80/demo/busybox:v0.1
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
[root@docker1 ~]# docker pull docker2:80/demo/busybox:v0.1 
v0.1: Pulling from demo/busybox
Digest: sha256:cbcde3595079b1f7a6b046e96e7547fe786d5c2c8eba678bc260161bc01b8dbe
Status: Downloaded newer image for docker2:80/demo/busybox:v0.1
[root@docker1 ~]# docker image ls docker2:80/demo/busybox:v0.1
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
docker2:80/demo/busybox   v0.1                758ec7f3a1ee        2 weeks ago         1.15 MB
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;7&lt;span&gt;）在&lt;/span&gt;&lt;span&gt;harbor web&lt;/span&gt;&lt;span&gt;页面可以进行很多实用的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：给镜像打标、复制镜像、删除镜像等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190110135055640-1462710915.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;4.3 &lt;span&gt;控制&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt; &lt;span&gt;服务&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;harbor &lt;span&gt;安装路径下，使用&lt;/span&gt;&lt;span&gt;docker-compose&lt;/span&gt; &lt;span&gt;命令对&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt; &lt;span&gt;进行控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）暂停&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 harbor]# docker-compose pause
Pausing harbor-log         ... done
Pausing harbor-adminserver ... done
Pausing registry           ... done
Pausing redis              ... done
Pausing registryctl        ... done
Pausing harbor-db          ... done
Pausing harbor-core        ... done
Pausing harbor-jobservice  ... done
Pausing harbor-portal      ... done
Pausing nginx              ... done
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）关闭&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 harbor]# docker-compose stop
Stopping nginx              ... done
Stopping harbor-portal      ... done
Stopping harbor-jobservice  ... done
Stopping harbor-core        ... done
Stopping harbor-db          ... done
Stopping registryctl        ... done
Stopping redis              ... done
Stopping registry           ... done
Stopping harbor-adminserver ... done
Stopping harbor-log         ... done
[root@docker2 harbor]# ss -nutl
Netid State      Recv-Q Send-Q     Local Address:Port                    Peer Address:Port              
tcp   LISTEN     0      128                    *:22                                 *:* 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）开启&lt;/span&gt;&lt;span&gt;harbor&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker2 harbor]# docker-compose start
Starting log         ... done
Starting registry    ... done
Starting registryctl ... done
Starting postgresql  ... done
Starting adminserver ... done
Starting core        ... done
Starting portal      ... done
Starting redis       ... done
Starting jobservice  ... done
Starting proxy       ... done
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 10 Jan 2019 07:05:00 +0000</pubDate>
<dc:creator>alonghub</dc:creator>
<og:description>本文收录于Linux 系统化学习系列文章总目录 1、了解Docker Registry 1.1 介绍 registry 用于保存docker 镜像，包括镜像的层次结构和元数据。 启动容器时，docke</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/10249001.html</dc:identifier>
</item>
<item>
<title>DirectX11--实现一个3D魔方(3) - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/10247018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/10247018.html</guid>
<description>&lt;p&gt;(2019/1/9 09:23)上一章我们主要讲述了魔方的旋转，这个旋转真是有毒啊，搞完这个部分搭键鼠操作不到半天应该就可以搭完了吧...&lt;/p&gt;
&lt;p&gt;(2019/1/9 21:25)啊，真香&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190110143221231-1976181376.png&quot;/&gt;&lt;br/&gt;有人发这张图片问我写魔方的目的是不是这个。。。噗&lt;/p&gt;
&lt;p&gt;现在光是键鼠相关的代码也搭了400行左右。。其中键盘相关的调用真的是毫无技术可言，重点实现基本上都被鼠标给耽搁了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/Rubik-Cube&quot;&gt;Github项目--魔方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对了，在此之前你可以去了解一下我这里所使用的摄像机、碰撞检测、鼠标拾取相关模块的实现：&lt;/p&gt;
&lt;p&gt;最后日常安利一波本人正在编写的DX11教程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;键盘操作使用的是&lt;code&gt;DXTK&lt;/code&gt;经过修改的&lt;code&gt;Keyboard&lt;/code&gt;库。&lt;/p&gt;
&lt;p&gt;因为之前说过，&lt;code&gt;Rubik::RotateX&lt;/code&gt;函数在响应了来自键盘的输入后，就会进入自动旋转模式，此时的键盘输入将不会响应。因此整个函数实现起来就是这么暴力：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::KeyInput()
{
    Keyboard::State keyState = mKeyboard-&amp;gt;GetState();
    mKeyboardTracker.Update(keyState);

    //
    // 整个魔方旋转
    //

    // 公式x
    if (mKeyboardTracker.IsKeyPressed(Keyboard::Up))
    {
        mRubik.RotateX(3, XM_PIDIV2);
        return;
    }
    
    // ...

    //
    // 双层旋转
    //

    // 公式r
    if (keyState.IsKeyDown(Keyboard::LeftControl) &amp;amp;&amp;amp; mKeyboardTracker.IsKeyPressed(Keyboard::I))
    {
        mRubik.RotateX(-2, XM_PIDIV2);
        return;
    }
    
    // ...


    //
    // 单层旋转
    //

    // 公式R
    if (mKeyboardTracker.IsKeyPressed(Keyboard::I))
    {
        mRubik.RotateX(2, XM_PIDIV2);
        return;
    }

    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我列个表格来描述键盘的36种操作，就当做说明书来看吧：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;36&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Up&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;整个魔方按x轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Down&lt;/td&gt;
&lt;td&gt;x'&lt;/td&gt;
&lt;td&gt;整个魔方按x轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Left&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;整个魔方按y轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Right&lt;/td&gt;
&lt;td&gt;y'&lt;/td&gt;
&lt;td&gt;整个魔方按y轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Pg Up&lt;/td&gt;
&lt;td&gt;z'&lt;/td&gt;
&lt;td&gt;整个魔方按z轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Pg Down&lt;/td&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;td&gt;整个魔方按z轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;--------&lt;/td&gt;
&lt;td&gt;----&lt;/td&gt;
&lt;td&gt;------------------------&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+I&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;右面两层按x轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+K&lt;/td&gt;
&lt;td&gt;r'&lt;/td&gt;
&lt;td&gt;右面两层按x轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+J&lt;/td&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;顶面两层按y轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+L&lt;/td&gt;
&lt;td&gt;u'&lt;/td&gt;
&lt;td&gt;顶面两层按y轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+U&lt;/td&gt;
&lt;td&gt;f'&lt;/td&gt;
&lt;td&gt;正面两层按z轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+O&lt;/td&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;正面两层按z轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;--------&lt;/td&gt;
&lt;td&gt;----&lt;/td&gt;
&lt;td&gt;------------------------&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+W&lt;/td&gt;
&lt;td&gt;l'&lt;/td&gt;
&lt;td&gt;左面两层按x轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+S&lt;/td&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;左面两层按x轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+A&lt;/td&gt;
&lt;td&gt;d'&lt;/td&gt;
&lt;td&gt;底面两层按y轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+D&lt;/td&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;底面两层按y轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+Q&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;背面两层按z轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LCtrl+E&lt;/td&gt;
&lt;td&gt;b'&lt;/td&gt;
&lt;td&gt;背面两层按z轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;--------&lt;/td&gt;
&lt;td&gt;----&lt;/td&gt;
&lt;td&gt;------------------------&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;右面两层按x轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;R'&lt;/td&gt;
&lt;td&gt;右面两层按x轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;顶面两层按y轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;U'&lt;/td&gt;
&lt;td&gt;顶面两层按y轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;F'&lt;/td&gt;
&lt;td&gt;正面两层按z轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;正面两层按z轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;--------&lt;/td&gt;
&lt;td&gt;----&lt;/td&gt;
&lt;td&gt;------------------------&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;右面两层按x轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;M'&lt;/td&gt;
&lt;td&gt;右面两层按x轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;顶面两层按y轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;E'&lt;/td&gt;
&lt;td&gt;顶面两层按y轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;S'&lt;/td&gt;
&lt;td&gt;正面两层按z轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;正面两层按z轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;--------&lt;/td&gt;
&lt;td&gt;----&lt;/td&gt;
&lt;td&gt;------------------------&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;L'&lt;/td&gt;
&lt;td&gt;右面两层按x轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;右面两层按x轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;D'&lt;/td&gt;
&lt;td&gt;顶面两层按y轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;顶面两层按y轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;正面两层按z轴逆时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;B'&lt;/td&gt;
&lt;td&gt;正面两层按z轴顺时针旋转&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;鼠标操作用的是&lt;code&gt;DXTK&lt;/code&gt;经过修改的&lt;code&gt;Mouse&lt;/code&gt;库&lt;/p&gt;
&lt;p&gt;鼠标相关的实现难度远比键盘复杂多了，我主要分三个部分来讲：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;立方体的拾取与判断拾取到的立方体表面&lt;/li&gt;
&lt;li&gt;根据拖动方向判断旋转轴&lt;/li&gt;
&lt;li&gt;鼠标在不同的操作阶段对应的处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在此之前，我先讲讲在这个项目加的一点点私货&lt;/p&gt;
&lt;h2 id=&quot;鼠标的轻微抖动效果&quot;&gt;鼠标的轻微抖动效果&lt;/h2&gt;
&lt;p&gt;首先来看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/01/10/FOlrFI.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个效果的实现比较简单，现在我使用的是第三人称摄像机。现规定以游戏窗口中心为0偏移点，那么偏离中心做左右移动会产生绕中心以Y轴旋转，而做上下移动产生绕中心以X轴旋转。&lt;/p&gt;
&lt;p&gt;相关代码的实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::MouseInput(float dt)
{
    Mouse::State mouseState = mMouse-&amp;gt;GetState();
    // ...

    // 获取子类
    auto cam3rd = dynamic_cast&amp;lt;ThirdPersonCamera*&amp;gt;(mCamera.get());

    // ******************
    // 第三人称摄像机的操作
    //

    // 绕物体旋转，添加轻微抖动
    cam3rd-&amp;gt;SetRotationX(XM_PIDIV2 * 0.6f + (mouseState.y - mClientHeight / 2) *  0.0001f);
    cam3rd-&amp;gt;SetRotationY(-XM_PIDIV4 + (mouseState.x - mClientWidth / 2) * 0.0001f);
    cam3rd-&amp;gt;Approach(-mouseState.scrollWheelValue / 120 * 1.0f);

    // 更新观察矩阵
    mCamera-&amp;gt;UpdateViewMatrix();
    mBasicEffect.SetViewMatrix(mCamera-&amp;gt;GetViewXM());

    // 重置滚轮值
    mMouse-&amp;gt;ResetScrollWheelValue();
    
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;立方体的拾取与判断拾取到的立方体表面&quot;&gt;立方体的拾取与判断拾取到的立方体表面&lt;/h2&gt;
&lt;p&gt;现在要先判断鼠标点击拾取到哪个立方体，考虑到我们能拾取到的立方体都是可以看到的，这也说明它们的深度值肯定是最小的。因此，我们的&lt;code&gt;Rubik::HitCube&lt;/code&gt;函数实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;DirectX::XMINT3 Rubik::HitCube(Ray ray, float * pDist) const
{
    BoundingOrientedBox box(XMFLOAT3(), XMFLOAT3(1.0f, 1.0f, 1.0f), XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f));
    BoundingOrientedBox transformedBox;
    XMINT3 res = XMINT3(-1, -1, -1);
    float dist, minDist = FLT_MAX;

    // 优先拾取暴露在外的立方体(同时也是距离摄像机最近的)
    for (int i = 0; i &amp;lt; 3; ++i)
    {
        for (int j = 0; j &amp;lt; 3; ++j)
        {
            for (int k = 0; k &amp;lt; 3; ++k)
            {
                box.Transform(transformedBox, mCubes[i][j][k].GetWorldMatrix());
                if (ray.Hit(transformedBox, &amp;amp;dist) &amp;amp;&amp;amp; dist &amp;lt; minDist)
                {
                    minDist = dist;
                    res = XMINT3(i, j, k);
                }
            }
        }
    }
    if (pDist)
        *pDist = (minDist == FLT_MAX ? 0.0f : minDist);
        
    return res;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的函数会遍历所有的立方体，找出深度最小且拾取到的立方体的索引值，通过&lt;code&gt;pDist&lt;/code&gt;可以返回射线起始点到目标立方体表面的最小距离。这个信息非常有用，稍后我们会提到。&lt;/p&gt;
&lt;p&gt;对了，如果没有拾取到立方体呢？我们可以利用屏幕空白的地方，在拖动这些地方的时候会带动整个魔方的旋转。&lt;/p&gt;
&lt;h2 id=&quot;根据拖动方向判断旋转轴&quot;&gt;根据拖动方向判断旋转轴&lt;/h2&gt;
&lt;p&gt;首先给出魔方旋转轴的枚举：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;enum RubikRotationAxis {
    RubikRotationAxis_X,    // 绕X轴旋转
    RubikRotationAxis_Y,    // 绕Y轴旋转
    RubikRotationAxis_Z,    // 绕Z轴旋转
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在让我们再看一眼魔方：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190110130903601-1318247750.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;界面中可以看到魔方的面有+X面，+Y面和-Z面。&lt;/p&gt;
&lt;p&gt;在我们拾取到立方体后，我们还要根据这两个信息来确定旋转轴：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当前具体是拾取到立方体的哪个面&lt;/li&gt;
&lt;li&gt;当前鼠标的拖动方向&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这又是一个十分细的问题。其中-X面和-Z面在屏幕上是对称关系，代码实现可以做镜像处理，但是+Y面的操作跟其它两个面又有一些差别。&lt;/p&gt;
&lt;h3 id=&quot;鼠标落在立方体的-z面&quot;&gt;鼠标落在立方体的-Z面&lt;/h3&gt;
&lt;p&gt;现在我们只讨论拾取到立方体索引&lt;code&gt;[2][2][0]&lt;/code&gt;的情况，鼠标落在了该立方体白色的表面上。我们只是知道鼠标拾取到当前立方体上，那怎么做才能知道它现在拾取的是其中的-Z面呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Rubik::HitCube&lt;/code&gt;函数不仅返回了拾取到的立方体索引，还有射线击中立方体表面的最短距离。我们知道-Z面的所有顶点的z值在不产生旋转的情况下都会为-3，因此我们只需要将得到的 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 值带入射线方程 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{p}=\mathbf{e}+t\mathbf{d}\)&lt;/span&gt; 中，判断求得的 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{p}\)&lt;/span&gt; 其中的z分量是否为3，如果是，那说明当前鼠标拾取的是该立方体的-Z面。&lt;/p&gt;
&lt;p&gt;接下来就是要讨论用鼠标拖动魔方会产生怎么样的旋转问题了。我们还需要确定当前的拖动会让哪一层魔方旋转(或者说绕什么轴旋转)。以下图为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190110130239248-1400563104.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图的X轴和Y轴对应的是屏幕坐标系，坐标轴的原点为我鼠标刚点击时的落点，通过两条虚线，可以将鼠标的拖动方向划分为四个部分，对应魔方旋转的四种情况。其中屏幕坐标系的主+X(-X)拖动方向会使得魔方的+Y面做逆(顺)时针旋转，而屏幕坐标系的主+Y(-Y)拖动方向会使得魔方的+X面做逆(顺)时针旋转。&lt;/p&gt;
&lt;p&gt;我们可以将这些情况进行简单归类，即当X方向的瞬时位移量比Y方向的大时，魔方的+Y面就会绕Y轴进行旋转，反之则是魔方的+X面绕X轴进行旋转。&lt;/p&gt;
&lt;p&gt;这里先把&lt;code&gt;GameApp&lt;/code&gt;中所有与鼠标操作相关的新增成员先列出来，后面我就不再重复：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//
// 鼠标操作控制
//
    
int mClickPosX, mClickPosY;                 // 初次点击时鼠标位置
float mSlideDelay;                          // 拖动延迟响应时间 
float mCurrDelay;                           // 当前延迟时间
bool mDirectionLocked;                      // 方向锁
RubikRotationAxis mCurrRotationAxis;        // 当前鼠标拖动时的旋转轴
int mSlidePos;                              // 当前鼠标拖动的层数索引，3为整个魔方&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mSlidePos&lt;/code&gt;和&lt;code&gt;mCurrRotationAxis&lt;/code&gt;用于保留判断旋转轴和层数的结果，以保证后续旋转的一致性。&lt;/p&gt;
&lt;p&gt;核心判断方法如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 判断当前主要是垂直操作还是水平操作
bool isVertical = abs(dx) &amp;lt; abs(dy);
// 当前鼠标操纵的是-Z面，根据操作类型决定旋转轴
if (pos.z == 0 &amp;amp;&amp;amp; fabs((ray.origin.z + dist * ray.direction.z) - (-3.0f)) &amp;lt; 1e-5f)
{
    mSlidePos = isVertical ? pos.x : pos.y;
    mCurrRotationAxis = isVertical ? RubikRotationAxis_X : RubikRotationAxis_Y;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pos&lt;/code&gt;为鼠标拾取到的立方体索引。&lt;/p&gt;
&lt;h3 id=&quot;鼠标落在立方体的x面&quot;&gt;鼠标落在立方体的+X面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190110130330319-475357958.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们拾取到了索引为&lt;code&gt;[2][2][0]&lt;/code&gt;立方体的+X面，该表面所有顶点的x值在不旋转的情况下为3。当鼠标拖动时的X偏移量比Y的大时，会使得魔方的+Y面绕Y轴做旋转，反之则使得魔方的-X面绕X轴做旋转。&lt;/p&gt;
&lt;p&gt;这部分的判断如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 当前鼠标操纵的是+X面，根据操作类型决定旋转轴
if (pos.x == 2 &amp;amp;&amp;amp; fabs((ray.origin.x + dist * ray.direction.x) - 3.0f) &amp;lt; 1e-5f)
{
    mSlidePos = isVertical ? pos.z : pos.y;
    mCurrRotationAxis = isVertical ? RubikRotationAxis_Z : RubikRotationAxis_Y;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;鼠标落在立方体的y面&quot;&gt;鼠标落在立方体的+Y面&lt;/h3&gt;
&lt;p&gt;之前+X面和-Z面在屏幕中是对称的，处理过程基本上差不多。但是处理+Y面的情况又不一样了，先看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190110125848104-684144911.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在的虚线按垂直和水平方向划分成四个拖动区域。当鼠标在屏幕坐标系拖动时，如果X的瞬时偏移量和Y的符号是一致的（划分虚线的右下区域和左上区域）， 魔方的-Z面会绕Z轴旋转；如果异号（划分虚线的左下区域和右上区域），魔方的+X面会绕X轴旋转。&lt;/p&gt;
&lt;p&gt;然后就是魔方+Y面的顶点在不产生旋转的情况下y值恒为3，因此这部分的判断逻辑如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 当前鼠标操纵的是+Y面，要判断平移变化量dx和dy的符号来决定旋转方向
if (pos.y == 2 &amp;amp;&amp;amp; fabs((ray.origin.y + dist * ray.direction.y) - 3.0f) &amp;lt; 1e-5f)
{
    // 判断异号
    bool diffSign = ((dx &amp;amp; 0x80000000) != (dy &amp;amp; 0x80000000));
    mSlidePos = diffSign ? pos.x : pos.z;
    mCurrRotationAxis = diffSign ? RubikRotationAxis_X : RubikRotationAxis_Z;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;鼠标没有拾取到魔方&quot;&gt;鼠标没有拾取到魔方&lt;/h3&gt;
&lt;p&gt;前面我们一直都是在讨论鼠标拾取到魔方的立方体产生了单层旋转的情况。现在我们还想让整个魔方进行旋转，可以依靠拖动游戏界面的空白区域来实现，按下图的方式划分成两片区域：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190110131147440-352165359.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要在魔方区域外拖动，且水平偏移量比垂直的大，就会产生绕Y轴的旋转。在窗口左（右）半部分产生了主垂直拖动则会绕X（Z）轴旋转。&lt;/p&gt;
&lt;p&gt;整个拾取部分的判断如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 找到当前鼠标点击的方块索引
Ray ray = Ray::ScreenToRay(*mCamera, (float)mouseState.x, (float)mouseState.y);
float dist;
XMINT3 pos = mRubik.HitCube(ray, &amp;amp;dist);

// 判断当前主要是垂直操作还是水平操作
bool isVertical = abs(dx) &amp;lt; abs(dy);
// 当前鼠标操纵的是-Z面，根据操作类型决定旋转轴
if (pos.z == 0 &amp;amp;&amp;amp; fabs((ray.origin.z + dist * ray.direction.z) - (-3.0f)) &amp;lt; 1e-5f)
{
    mSlidePos = isVertical ? pos.x : pos.y;
    mCurrRotationAxis = isVertical ? RubikRotationAxis_X : RubikRotationAxis_Y;
}
// 当前鼠标操纵的是+X面，根据操作类型决定旋转轴
else if (pos.x == 2 &amp;amp;&amp;amp; fabs((ray.origin.x + dist * ray.direction.x) - 3.0f) &amp;lt; 1e-5f)
{
    mSlidePos = isVertical ? pos.z : pos.y;
    mCurrRotationAxis = isVertical ? RubikRotationAxis_Z : RubikRotationAxis_Y;
}
// 当前鼠标操纵的是+Y面，要判断平移变化量dx和dy的符号来决定旋转方向
else if (pos.y == 2 &amp;amp;&amp;amp; fabs((ray.origin.y + dist * ray.direction.y) - 3.0f) &amp;lt; 1e-5f)
{
    // 判断异号
    bool diffSign = ((dx &amp;amp; 0x80000000) != (dy &amp;amp; 0x80000000));
    mSlidePos = diffSign ? pos.x : pos.z;
    mCurrRotationAxis = diffSign ? RubikRotationAxis_X : RubikRotationAxis_Z;
}
// 当前鼠标操纵的是空白地区，则对整个魔方旋转
else
{
    mSlidePos = 3;
    // 水平操作是Y轴旋转
    if (!isVertical)
    {
        mCurrRotationAxis = RubikRotationAxis_Y;
    }
    // 屏幕左半部分的垂直操作是X轴旋转
    else if (mouseState.x &amp;lt; mClientWidth / 2)
    {
        mCurrRotationAxis = RubikRotationAxis_X;
    }
    // 屏幕右半部分的垂直操作是Z轴旋转
    else
    {
        mCurrRotationAxis = RubikRotationAxis_Z;
    }
}           &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;鼠标在不同的操作阶段对应的处理&quot;&gt;鼠标在不同的操作阶段对应的处理&lt;/h2&gt;
&lt;p&gt;鼠标拖动魔方旋转可以分为三个阶段：鼠标初次点击、鼠标产生拖动、鼠标刚释放。&lt;/p&gt;
&lt;h3 id=&quot;确定拖动方向&quot;&gt;确定拖动方向&lt;/h3&gt;
&lt;p&gt;在鼠标初次点击的时候不一定会产生偏移量，但我们必须要在这个时候判断鼠标是在做垂直拖动还是竖直拖动来确定当前的旋转轴，以限制魔方的旋转。&lt;/p&gt;
&lt;p&gt;现在要考虑这样一个情况，我鼠标在初次点击魔方时可能会因为手抖或者鼠标不稳产生了一个以下方向为主的瞬时移动，然后程序判断我现在在做向下的拖动，但实际情况却是我需要向右方向拖动鼠标，程序却只允许我上下拖动。这就十分尴尬了。&lt;/p&gt;
&lt;p&gt;由于鼠标的拖动过程相对程序的运行会比较缓慢，我们可以给程序加上一个延迟判断。比如说我现在可以根据鼠标初次点击后的0.05s内产生的累计垂直/水平偏移量来判断此时是水平拖动还是竖直拖动。&lt;/p&gt;
&lt;p&gt;此外，一旦确定这段时间内产生了偏移值，必须要加上方向锁，防止后续又重新判断旋转方向。&lt;/p&gt;
&lt;p&gt;这部分代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 此时未确定旋转方向
if (!mDirectionLocked)
{
    // 此时未记录点击位置
    if (mClickPosX == -1 &amp;amp;&amp;amp; mClickPosY == -1)
    {
        // 初次点击
        if (mMouseTracker.leftButton == Mouse::ButtonStateTracker::PRESSED)
        {
            // 记录点击位置
            mClickPosX = mouseState.x;
            mClickPosY = mouseState.y;
        }
    }
    
    // 仅当记录了点击位置才进行更新
    if (mClickPosX != -1 &amp;amp;&amp;amp; mClickPosY != -1)
        mCurrDelay += dt;
    // 未到达滑动延迟时间则结束
    if (mCurrDelay &amp;lt; mSlideDelay)
        return;

    // 未产生运动则不上锁
    if (abs(dx) == abs(dy))
        return;

    // 开始上方向锁
    mDirectionLocked = true;
    // 更新累积的位移变化量
    dx = mouseState.x - mClickPosX;
    dy = mouseState.y - mClickPosY;
    
    // 找到当前鼠标点击的方块索引
    Ray ray = Ray::ScreenToRay(*mCamera, (float)mouseState.x, (float)mouseState.y);
    // ...剩余部分就是上面的代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拖动时更新魔方状态&quot;&gt;拖动时更新魔方状态&lt;/h3&gt;
&lt;p&gt;这部分实现就比较简单了。只要鼠标左键按下，且确认方向锁，就可以进行魔方的旋转。&lt;/p&gt;
&lt;p&gt;如果是绕X轴的旋转，鼠标向右移动和向上移动都会产生顺时针旋转。&lt;br/&gt;如果是绕Y轴的旋转，只有鼠标向左移动才会产生顺时针旋转。&lt;br/&gt;如果是绕Z轴的旋转，鼠标向左移动和向上移动都会产生顺时针旋转。&lt;/p&gt;
&lt;p&gt;这里的Rotate函数最后一个参数必须要传递&lt;code&gt;true&lt;/code&gt;以告诉内部不要进行预旋转操作。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 上了方向锁才能进行旋转
if (mDirectionLocked)
{
    // 进行旋转
    switch (mCurrRotationAxis)
    {
    case RubikRotationAxis_X: mRubik.RotateX(mSlidePos, (dx - dy) * 0.008f, true); break;
    case RubikRotationAxis_Y: mRubik.RotateY(mSlidePos, -dx * 0.008f, true); break;
    case RubikRotationAxis_Z: mRubik.RotateZ(mSlidePos, (-dx - dy) * 0.008f, true); break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拖动完成后的操作&quot;&gt;拖动完成后的操作&lt;/h3&gt;
&lt;p&gt;完成拖动后，需要恢复方向锁和滑动延迟，并且鼠标刚释放时产生的偏移我们直接丢掉。现在Rotate函数仅用于发送进行预旋转的命令：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 鼠标左键是否点击
if (mouseState.leftButton)
{
    // ...
}
// 鼠标刚释放
else if (mMouseTracker.leftButton == Mouse::ButtonStateTracker::RELEASED)
{
    // 释放方向锁
    mDirectionLocked = false;
    // 滑动延迟归零
    mCurrDelay = 0.0f;
    // 坐标移出屏幕
    mClickPosX = mClickPosY = -1;
    // 发送完成指令，进行预旋转
    switch (mCurrRotationAxis)
    {
    case RubikRotationAxis_X: mRubik.RotateX(mSlidePos, 0.0f); break;
    case RubikRotationAxis_Y: mRubik.RotateY(mSlidePos, 0.0f); break;
    case RubikRotationAxis_Z: mRubik.RotateZ(mSlidePos, 0.0f); break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终鼠标拖动的效果如下：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/01/10/FOrN5V.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;键盘的效果如下：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/01/10/FOr5KH.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此魔方的一些核心实现就讲的差不多了。最后无非就是功能上的堆叠了。到现在写魔方的实现用了2天工时，博客也差不多2天。&lt;/p&gt;
&lt;p&gt;这一章也写了快500行内容，比代码还多。&lt;/p&gt;
&lt;p&gt;未完待续。。。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/Rubik-Cube&quot;&gt;Github项目--魔方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 06:40:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 (2019/1/9 09:23)上一章我们主要讲述了魔方的旋转，这个旋转真是有毒啊，搞完这个部分搭键鼠操作不到半天应该就可以搭完了吧... (2019/1/9 21:25)啊，真香 有人发这张图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/10247018.html</dc:identifier>
</item>
<item>
<title>Spring Boot 之发送邮件 - 静默虚空</title>
<link>http://www.cnblogs.com/jingmoxukong/p/10249093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingmoxukong/p/10249093.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Spring Boot 收发邮件最简便方式是通过 &lt;code&gt;spring-boot-starter-mail&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring-boot-starter-mail 本质上是使用 JavaMail(javax.mail)。如果想对 JavaMail 有进一步了解，可以参考：&lt;a href=&quot;https://github.com/dunwu/notes/blob/master/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/javastack/javalib/javamail.md&quot;&gt;JavaMail 使用小结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;
&lt;p&gt;Spring Framework 提供了一个使用 &lt;code&gt;JavaMailSender&lt;/code&gt; 接口发送电子邮件的简单抽象，这是发送邮件的核心 API。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaMailSender&lt;/code&gt; 接口提供的 API 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dunwu.test.upcdn.net/snap/20190110111102.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;Spring Boot 为 &lt;code&gt;JavaMailSender&lt;/code&gt; 提供了自动配置以及启动器模块。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;spring.mail.host&lt;/code&gt; 和相关库（由 spring-boot-starter-mail 定义）可用，则 Spring Boot 会创建默认 &lt;code&gt;JavaMailSender&lt;/code&gt;（如果不存在）。可以通过 &lt;code&gt;spring.mail&lt;/code&gt; 命名空间中的配置项进一步自定义发件人。&lt;br/&gt;特别是，某些默认超时值是无限的，您可能希望更改它以避免线程被无响应的邮件服务器阻塞，如以下示例所示：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=3000
spring.mail.properties.mail.smtp.writetimeout=5000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用 JNDI 中的现有会话配置 &lt;code&gt;JavaMailSender&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.mail.jndi-name=mail/Session&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下为 Spring Boot 关于 Mail 的配置：&lt;/p&gt;
&lt;p&gt;有关更多详细信息，请参阅 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java&quot;&gt;&lt;code&gt;MailProperties&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# Email (MailProperties)
spring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.
spring.mail.host= # SMTP server host. For instance, `smtp.example.com`.
spring.mail.jndi-name= # Session JNDI name. When set, takes precedence over other Session settings.
spring.mail.password= # Login password of the SMTP server.
spring.mail.port= # SMTP server port.
spring.mail.properties.*= # Additional JavaMail Session properties.
spring.mail.protocol=smtp # Protocol used by the SMTP server.
spring.mail.test-connection=false # Whether to test that the mail server is available on startup.
spring.mail.username= # Login user of the SMTP server.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战&quot;&gt;实战&lt;/h2&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;

  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.dozermapper&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dozer-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;6.4.0&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置邮件属性&quot;&gt;配置邮件属性&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;src/main/resources&lt;/code&gt; 目录下添加 &lt;code&gt;application-163.properties&lt;/code&gt; 配置文件，内容如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.mail.host = smtp.163.com
spring.mail.username = xxxxxx
spring.mail.password = xxxxxx
spring.mail.properties.mail.smtp.auth = true
spring.mail.properties.mail.smtp.starttls.enable = true
spring.mail.properties.mail.smtp.starttls.required = true
spring.mail.default-encoding = UTF-8

mail.domain = 163.com
mail.from = ${spring.mail.username}@${mail.domain}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：需替换有效的 &lt;code&gt;spring.mail.username&lt;/code&gt;、&lt;code&gt;spring.mail.password&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;application-163.properties&lt;/code&gt; 配置文件表示使用 163 邮箱时的配置，为了使之生效，需要通过 &lt;code&gt;spring.profiles.active = 163&lt;/code&gt; 来激活它。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;src/main/resources&lt;/code&gt; 目录下添加 &lt;code&gt;application.properties&lt;/code&gt; 配置文件，内容如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.profiles.active = 163&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;java-代码&quot;&gt;Java 代码&lt;/h3&gt;
&lt;p&gt;首先，需要读取部分配置属性，方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

@Validated
@Component
@ConfigurationProperties(prefix = &quot;mail&quot;)
public class MailProperties {
    private String domain;
    private String from;

    public String getDomain() {
        return domain;
    }

    public void setDomain(String domain) {
        this.domain = domain;
    }

    public String getFrom() {
        return from;
    }

    public void setFrom(String from) {
        this.from = from;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，定义一个邮件参数实体类（使用 lombok 简化了 getter、setter）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.Data;
import java.util.Date;

@Data
public class MailDTO {
    private String from;
    private String replyTo;
    private String[] to;
    private String[] cc;
    private String[] bcc;
    private Date sentDate;
    private String subject;
    private String text;
    private String[] filenames;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，实现发送邮件的功能接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.github.dozermapper.core.Mapper;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import javax.mail.MessagingException;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import java.io.IOException;

@Service
public class MailService {

    private final Logger log = LoggerFactory.getLogger(this.getClass());

    @Autowired
    private MailProperties mailProperties;

    @Autowired
    private JavaMailSender javaMailSender;

    @Autowired
    private Mapper mapper;

    public void sendSimpleMailMessage(MailDTO mailDTO) {
        SimpleMailMessage simpleMailMessage = mapper.map(mailDTO, SimpleMailMessage.class);
        if (StringUtils.isEmpty(mailDTO.getFrom())) {
            mailDTO.setFrom(mailProperties.getFrom());
        }
        javaMailSender.send(simpleMailMessage);
    }

    public void sendMimeMessage(MailDTO mailDTO) {

        MimeMessage mimeMessage = javaMailSender.createMimeMessage();
        MimeMessageHelper messageHelper;
        try {
            messageHelper = new MimeMessageHelper(mimeMessage, true);

            if (StringUtils.isEmpty(mailDTO.getFrom())) {
                messageHelper.setFrom(mailProperties.getFrom());
            }
            messageHelper.setTo(mailDTO.getTo());
            messageHelper.setSubject(mailDTO.getSubject());

            mimeMessage = messageHelper.getMimeMessage();
            MimeBodyPart mimeBodyPart = new MimeBodyPart();
            mimeBodyPart.setContent(mailDTO.getText(), &quot;text/html;charset=UTF-8&quot;);

            // 描述数据关系
            MimeMultipart mm = new MimeMultipart();
            mm.setSubType(&quot;related&quot;);
            mm.addBodyPart(mimeBodyPart);

            // 添加邮件附件
            for (String filename : mailDTO.getFilenames()) {
                MimeBodyPart attachPart = new MimeBodyPart();
                try {
                    attachPart.attachFile(filename);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                mm.addBodyPart(attachPart);
            }
            mimeMessage.setContent(mm);
            mimeMessage.saveChanges();

        } catch (MessagingException e) {
            e.printStackTrace();
        }

        javaMailSender.send(mimeMessage);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;完整示例&quot;&gt;完整示例&lt;/h2&gt;
&lt;p&gt;完整示例：&lt;a href=&quot;https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/lib/sbe-lib-mail&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先替换配置 &lt;code&gt;application-${profile}.properties&lt;/code&gt; 中的 &lt;code&gt;spring.mail.username(发件人邮箱)&lt;/code&gt; 、&lt;code&gt;spring.mail.password(发件人邮箱密码)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后在 &lt;code&gt;io.github.dunwu.springboot.MailServiceTests&lt;/code&gt; 中替换 &lt;code&gt;TO(收件人)&lt;/code&gt;、&lt;code&gt;CC(抄送人)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;io.github.dunwu.springboot.MailServiceTests&lt;/code&gt; 以测试邮件收发。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;引申和引用&quot;&gt;引申和引用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;引申&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 06:26:00 +0000</pubDate>
<dc:creator>静默虚空</dc:creator>
<og:description>Spring Boot 之发送邮件 &lt;! TOC depthFrom:2 depthTo:3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingmoxukong/p/10249093.html</dc:identifier>
</item>
<item>
<title>论一个程序员的自我修养-从一张图片说起 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10249547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10249547.html</guid>
<description>&lt;h2 id=&quot;故事起源&quot;&gt;故事起源&lt;/h2&gt;
&lt;p&gt;本来今天想写.NET Core实战之CMS系统第十五篇文章的。哈，奈何今天在新生命人脉群里面看到石头哥分享的一张图片，然后大家就议论了起来，不过我看的很懵逼，这图什么意思啊？当一个朋友讲述了这个图片背后的故事的时候，瞬间泪奔了！先上图，第一眼看很平淡，一个苦逼程序猿在加班，旁边那个是布娃娃吗？反正我第一眼看就觉得是布娃娃！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190110134451531-387911918.png&quot; alt=&quot;1547090181521&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10249547.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10249547.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序猿加班，为什么配图文字说“孩子他妈说，以后可不能让他当程序猿”呢？&lt;/p&gt;
&lt;p&gt;这时候这个说说的作者就发话了，通过它了解到，故事是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;这个图，是我今天在手机上翻到的，qq里的那年今日。我记得好像是一天吃完晚饭，石头带着一凡回公司继续加班干活，嫂子去哪忘记了。石头就把一凡往电脑旁边一放，继续干活。配图的文字好像是我加的，忘记了！&lt;/p&gt;
&lt;p&gt;啊 ，我想起来了！ 配图的文字是这么回事： 当时嫂子带孩子来公司 我们在旁边逗孩子 然后我说了一句 我说石头开发这么厉害 将来一凡也一定很牛逼（大体这个意思） 然后嫂子就说了“以后可不能让他当程序员啊 不行”哈哈哈 然后我就记住了 ！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;短短的两段话，道出了一个有责任心，有事业心，又受人尊敬而又幸福的程序员，但单从图的角度来说却又是个“坑娃”的程序员——大石头（也就是今天文章的主角）！&lt;/p&gt;
&lt;h2 id=&quot;为什么这样说呢&quot;&gt;为什么这样说呢？&lt;/h2&gt;
&lt;p&gt;作为程序猿你可以为了事业心责任心选择晚上加班完成任务上线而又无怨无悔（可能还没有加班费）！&lt;/p&gt;
&lt;p&gt;作为程序猿你加班的时候老婆孩子居然能够来陪你加班不可谓不幸福！&lt;/p&gt;
&lt;p&gt;作为程序猿你在老婆有事出去让你带一会娃的时候，居然把那么点大的小孩随手丢在办公桌上（看图，感觉天还那么冷）然后继续工作，不可谓不实力演绎“坑娃”这个词！&lt;/p&gt;
&lt;p&gt;作为程序猿，手下人跟你关系这么融洽，又说你技术这么好（从逗你家娃这点可以看出）足以看出你不可谓不受人尊敬，而又让手下人信服的好领导（技术过关，为人随和，团队氛围很好）！&lt;/p&gt;
&lt;p&gt;作为程序猿你还想怎样？其实我想说这应该是程序猿的必备素养！因为我们程序员只会跟电脑打交道，沟通能力稍微弱点，很多时候不善于表达！但我们却是一类有责任心，默默无闻，眼里容不得半点沙子（Error/Bug）而又努力付出的一类人！大石头的同事发的他的这张图恰恰折射出了我们这类猿！&lt;/p&gt;
&lt;h2 id=&quot;介绍下大石头&quot;&gt;介绍下大石头&lt;/h2&gt;
&lt;p&gt;大石头是谁？我跟他认识的时间虽然不长，大概有小半年的时间，但是却被他的为人以及技术所折服！&lt;/p&gt;
&lt;h3 id=&quot;大石头的博客&quot;&gt;大石头的博客&lt;/h3&gt;
&lt;p&gt;他的博客地址：“&lt;a href=&quot;https://www.cnblogs.com/nnhy/&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/nnhy/&lt;/a&gt;” ！如果你进入他的博客的话第一眼看到的就是“物联网、大数据”！没错？一百亿小数据的实时计算平台也只是他随手建立起的一套基于.Net/.Net Core的小数据实时处理计算平台!这篇文章记录了他的经验，如果你想看的话可以点这里《&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/Data.html&quot;&gt;100亿小数据实时计算平台（大数据系列目录）&lt;/a&gt;》！&lt;br/&gt;他深耕物联网领域多年，在他们的新生命团队中自研了嵌入式操作系统，主要应用于智能家居、物联网、工业自动化控制等领域。在网络通讯这块也是有颇多建树！&lt;br/&gt;他的博客里面太多太多的经验分享，由于石头哥不善写作，因此每篇文章都是寥寥几段话，但却道尽了实际项目中的宝贵经验！有兴趣的自己去他的博客看一番吧，保证有所收获！&lt;/p&gt;
&lt;p&gt;当然，在大石头的博客里面还写过一些列的自述，想进一步了解的请移步《&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/Money1.html&quot;&gt;赚钱的这些年（上）苦逼&lt;/a&gt;》&lt;/p&gt;
&lt;h3 id=&quot;大石头的开源项目&quot;&gt;大石头的开源项目&lt;/h3&gt;
&lt;p&gt;大石头（对外大石头一直讲述一定要宣称时新生命团队，因为这是新生命团队的成果）的开源项目很多，最著名而又广为我们所熟知的就是X组件了！&lt;br/&gt;国内地址：&lt;a href=&quot;http://git.newlifex.com/NewLife/X&quot; class=&quot;uri&quot;&gt;http://git.newlifex.com/NewLife/X&lt;/a&gt;&lt;br/&gt;国外地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; class=&quot;uri&quot;&gt;https://github.com/NewLifeX/X&lt;/a&gt;&lt;br/&gt;这个组件里面包含的东西可真不少，包括日志、数据库、网络、RPC、序列化、缓存、Windows服务、多线程等模块，支持.Net Framework/.netstandard/Mono。&lt;br/&gt;2002~2018，成千上万兄弟们努力的见证！&lt;br/&gt;国内文档中心：&lt;a href=&quot;http://doc.newlifex.com/&quot; class=&quot;uri&quot;&gt;http://doc.newlifex.com/&lt;/a&gt;&lt;br/&gt;国外文档中心：&lt;a href=&quot;https://newlifex.github.io/XDoc/%E7%BB%84%E4%BB%B6%E5%90%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86&quot; class=&quot;uri&quot;&gt;https://newlifex.github.io/XDoc/组件各组成部分&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;核心库-newlife.core&quot;&gt;核心库 NewLife.Core&lt;/h4&gt;
&lt;p&gt;核心组件，支撑其它所有组件。 主要功能包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;日志&lt;/strong&gt; 统一ILog接口，内置控制台、文本文件、WinForm控件和网络日志等实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络&lt;/strong&gt; 单点最高84.5万长连接&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RPC&lt;/strong&gt; 单点最高处理能力2256万tps&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存&lt;/strong&gt; 统一ICache接口，内置MemoryCache、Redis、DbCache实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全&lt;/strong&gt; AES/DES/RC4/RSA/DSA/CRC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多线程&lt;/strong&gt; 定时调度TimerX&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反射&lt;/strong&gt; 快速反射、脚本引擎ScriptEngine&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列化&lt;/strong&gt; Binary/Json/Xml&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务代理&lt;/strong&gt; Windows服务、守护、监控&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;数据中间件-newlife.xcode&quot;&gt;数据中间件 [NewLife.XCode]&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NewLifeX/X/tree/master/XCode&quot;&gt;NewLife.XCode&lt;/a&gt;XCode是一个超越了ORM范围的映射组件，除了对象到关系数据库的映射外，还有到网络和其它二进制形式等的映射，所以称之为数据映射组件。&lt;br/&gt;XCode具有哪些优势？&lt;br/&gt;采用最好的分页算法，高效处理海量数据。&lt;br/&gt;先进的多级缓存思想，保证最出色的性能。&lt;br/&gt;化繁为简，容易上手。&lt;br/&gt;抽象实体结构，支持多数据库的正向反向工程。&lt;br/&gt;总的来说，最好的分页算法保证基本操作不犯错，化繁为简和多级缓存的设计保证XCode在性能上永无止境，所以，XCode的最大优势就是性能！&lt;/p&gt;
&lt;h4 id=&quot;newlife.redis&quot;&gt;NewLife.Redis&lt;/h4&gt;
&lt;p&gt;NewLife.Redis 是一个Redis客户端组件，以高性能处理大数据实时计算为目标。&lt;br/&gt;Redis协议基础实现Redis/RedisClient位于X组件，本库为扩展实现，主要增加列表结构、哈希结构、队列等高级功能。&lt;br/&gt;源码： &lt;a href=&quot;https://github.com/NewLifeX/NewLife.Redis&quot; class=&quot;uri&quot;&gt;https://github.com/NewLifeX/NewLife.Redis&lt;/a&gt;&lt;br/&gt;在ZTO大数据实时计算广泛应用，200多个Redis实例稳定工作一年多，每天处理近1亿包裹数据，日均调用量80亿次；低延迟，Get/Set操作平均耗时200~600us（含往返网络通信）；大吞吐，自带连接池，最大支持1000并发；高性能，支持二进制序列化！如果想继续学习这个Redis组件的话可以参考我的这篇文章《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9941208.html&quot;&gt;Redis基本使用及百亿数据量中的使用技巧分享（附视频地址及观看指南）&lt;/a&gt;》&lt;/p&gt;
&lt;h4 id=&quot;newlife.cube&quot;&gt;NewLife.Cube&lt;/h4&gt;
&lt;p&gt;魔方 是一个基于 ASP.NET MVC 的 用户权限管理平台，可作为各种信息管理系统的基础框架。&lt;/p&gt;
&lt;p&gt;源码： &lt;a href=&quot;https://github.com/NewLifeX/NewLife.Cube&quot; class=&quot;uri&quot;&gt;https://github.com/NewLifeX/NewLife.Cube&lt;/a&gt; 演示：&lt;a href=&quot;http://cube.newlifex.com/&quot;&gt;http://cube.newlifex.com&lt;/a&gt; &lt;a href=&quot;http://git.newlifex.com/Stone/CubeDemo&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;国内文档中心：&lt;a href=&quot;http://doc.newlifex.com/&quot; class=&quot;uri&quot;&gt;http://doc.newlifex.com/&lt;/a&gt;&lt;br/&gt;国外文档中心：&lt;a href=&quot;https://newlifex.github.io/XDoc/&quot; class=&quot;uri&quot;&gt;https://newlifex.github.io/XDoc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具有如下特性（目前正在全面重写成.NET Core版本）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通用权限管理，用户、角色、菜单、权限，支持控制器Action权限控制&lt;/li&gt;
&lt;li&gt;多数据库，支持 &lt;code&gt;SQLite / Sql Server / Oracle / MySql / SqlCe / Access&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;免部署，系统自动创建数据库表结构，以及初始化数据，无需人工干涉&lt;/li&gt;
&lt;li&gt;强大的视图引擎，支持子项目视图重写父项目相同位置视图，任意覆盖修改默认界面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个X组件简直就是一个百宝箱，里面包含了各种各样的好用的组件！而且现在已经全民啊支持Core了！当然他们还有很多的开源项目我这里就不一一列出来了！具体的你们可以自行前往查看！&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;大石头恰恰折射出我们这类人——程序猿（有想私聊他的可以加入他的QQ群1600800,如果想进石头哥的人脉微信群的话，可以加我的微信：jkingzhu备注“大石头”我拉你进去！）！一个有责任心而又不善于表达的一类人！我们不善于言辞确能在电脑前夸夸其谈！我们头脑简单却又心思缜密，不放过一个Bug！我们能三五好友玩耍一天也能电脑前呆坐一天甚至忘记吃饭/忘记喝口水！我们都是同类猿！&lt;/p&gt;
&lt;p&gt;最后附上石头哥的一张图，愿我们“不忘初心，砥砺前行”！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190110134450977-512389206.png&quot; alt=&quot;1547098969436&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 05:46:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>故事起源 本来今天想写.NET Core实战之CMS系统第十五篇文章的。哈，奈何今天在新生命人脉群里面看到石头哥分享的一张图片，然后大家就议论了起来，不过我看的很懵逼，这图什么意思啊？当一个朋友讲述了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10249547.html</dc:identifier>
</item>
<item>
<title>Java面向对象概述及三大特征（封装，继承和多态） - 冰湖一角</title>
<link>http://www.cnblogs.com/bingyimeiling/p/10232605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingyimeiling/p/10232605.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、面向对象思想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java是面向对象的高级语言，对于Java语言来说，万事万物皆对象！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它的基本思想是使用类，对象，继承，封装，消息等基本概念进行程序设计。面向对象程序的最小单元是类，类代表了客观世界中具有某一特征的一类事物，封装了这类事物所具有的属性和行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;span&gt;类定义=成员变量（属性）+方法（行为）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向对象程序设计与人类的思维习惯一致，比如希望完成“兔子吃草&quot;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190110101305736-1756621701.jpg&quot; alt=&quot;&quot; width=&quot;49&quot; height=&quot;34&quot;/&gt;这件事：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在面向过程的程序设计里，一切以函数为中心，则会用如下语句来表达：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;吃（兔子，草）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在面向对象程序设计里，一切以对象为中心，则会用如下语句来表达：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;兔子.吃（草）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对比这两条语句可以看出，面向对象语句更接近自然语言语法，主谓宾一目了然。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、类与对象的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　类是对象的抽象，对象则是类的实例，一个类可以生成多个对象。对一个类定义而言，包含三种最常见的成员：构造器、成员变量和方法，而构造器是一个类创建对象的根本途径，如果一个类没有构造器则无法创建实例。因此，如果程序员没有为一个类创建构造器，则系统会为该类提供一个默认无参的构造器。下面定义一个简单的Person类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个成员变量：姓名和年龄&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个say方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(String content){
        System.out.println(content);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　定义类之后就可以通过Person p = new Person()来创建对象了，Person对象赋给了p变量，它们在内存中的存储示意图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190109205543152-1169571284.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、面向对象的三个基本特征（封装，继承和多态）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 封装是指将对象的实现细节隐藏起来，对外提供公共访问方法，将对象的功能暴露出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适当的封装可以让程式码更容易理解与维护，也加强了程序代码的安全性。最终目的是实现模块设计的”高内聚低耦合“。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，如何实现java的封装呢？首先来看一下java的访问控制级别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java提供了4个访问控制级别，由小到大如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190109211619078-836433906.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190109212416733-365798043.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图可以得出，实现一个类封装的步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;♦ &lt;/span&gt;修改属性的可见性（访问级别）来限制对属性的访问（一般限制为private），例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String name;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;span&gt;♦&lt;/span&gt;  对每个值属性提供对外的公共方法访问，也就是创建一对赋值取值的方法，用于对私有属性的访问，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge(){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName(){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;采用 &lt;span&gt;this&lt;/span&gt; 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突，&lt;span&gt;this&lt;/span&gt;指当前对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，一个类定义时，一般用private修饰成员变量，public修饰成员方法。获取成员变量应该用对象.get变量名()而不是&lt;span&gt;对象.成员变量名&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、继承&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们生活中有很多继承的例子：如兔子属于动物的一种，兔子有一般动物的特征及行为，在java语言里可以说兔子继承动物，兔子是子类，动物是父类；学生和老师都属于人类，有人的一般特性，所以在java语言里可以说学生和老师继承人类。所以继承需要符合的关系是：is-a，父类更通用，子类更具体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190110115249450-2012350540.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 继承是指子类可以复用父类的属性和方法，Java的继承是单继承，每个子类只有一个直接父类。Java的继承通过&lt;span&gt;extends&lt;/span&gt;关键字实现，实现继承的类称为子类，被继承的类称为父类（基类或超类）。Java继承语法格式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;修饰符 &lt;span&gt;class&lt;/span&gt; SubClass &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SuperClass{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类定义部分      &lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　需要注意的是 Java 不支持多继承，但支持多重继承。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190110115152739-608546112.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　子类包含与父类同名方法的现象称为&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;&lt;span&gt;重写&lt;/span&gt;&lt;span&gt;，也称为&lt;span&gt;方法覆盖&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　方法的重写要遵循“两大两小一大”规则，“两同”即方法名相同、形参列表相同；“两小”指子类方法返回值类型应该比父类方法返回值类型要小或相等，子类方法声明抛出的异常应该比父类方法声明抛出的异常类要小或相等；“一大”指子类方法的访问权限应比父类方法的访问权限更大或相等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、多态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　多态是指子类对象可以直接赋给父类变量（父类引用指向子类对象），但运行时依然表现出子类的行为特征，也就是说，同一类型的对象在执行同一个方法时，可能表现出多种行为特征。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　  多态存在的三个必要条件&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;继承&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;重写&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;父类引用指向子类对象&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　比如：&lt;span class=&quot;typ&quot;&gt;Parent &lt;span class=&quot;pln&quot;&gt;p &lt;span class=&quot;pun&quot;&gt;= &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;new &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Child&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面举一个多态的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
      show(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Cat());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以 Cat 对象调用 show 方法&lt;/span&gt;
      show(&lt;span&gt;new&lt;/span&gt; Dog());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以 Dog 对象调用 show 方法&lt;/span&gt;
&lt;span&gt;                
      Animal a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cat();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向上转型  &lt;/span&gt;
      a.eat();               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用的是 Cat 的 eat&lt;/span&gt;
      Cat c = (Cat)a;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向下转型  &lt;/span&gt;
      c.work();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用的是 Cat 的 work&lt;/span&gt;
&lt;span&gt;  }  
            
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(Animal a)  {
      a.eat();  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (a &lt;span&gt;instanceof&lt;/span&gt; Cat)  {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 猫做的事情 &lt;/span&gt;
            Cat c =&lt;span&gt; (Cat)a;  
            c.work();  
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (a &lt;span&gt;instanceof&lt;/span&gt; Dog) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 狗做的事情 &lt;/span&gt;
            Dog c =&lt;span&gt; (Dog)a;  
            c.work();  
        }  
    }  
}
 
&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {  
    &lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat();  
}  
  
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {  
        System.out.println(&lt;/span&gt;&quot;吃鱼&quot;&lt;span&gt;);  
    }  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {  
        System.out.println(&lt;/span&gt;&quot;抓老鼠&quot;&lt;span&gt;);  
    }  
}  
  
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {  
        System.out.println(&lt;/span&gt;&quot;吃骨头&quot;&lt;span&gt;);  
    }  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {  
        System.out.println(&lt;/span&gt;&quot;看家&quot;&lt;span&gt;);  
    }  
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;执行以上程序，输出结果为：

吃鱼
抓老鼠
吃骨头
看家
吃鱼
抓老鼠&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎关注微信公众号【Java典籍】，收看更多Java技术干货！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt; ▼长按下图↓↓↓二维码识别关注&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190109201610986-215386546.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 04:46:00 +0000</pubDate>
<dc:creator>冰湖一角</dc:creator>
<og:description>一、面向对象思想 Java是面向对象的高级语言，对于Java语言来说，万事万物皆对象！ 它的基本思想是使用类，对象，继承，封装，消息等基本概念进行程序设计。面向对象程序的最小单元是类，类代表了客观世界</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bingyimeiling/p/10232605.html</dc:identifier>
</item>
<item>
<title>SpringCloud系列——SSO 单点登录 - huanzi-qch</title>
<link>http://www.cnblogs.com/huanzi-qch/p/10249227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huanzi-qch/p/10249227.html</guid>
<description>&lt;h2&gt;　　前言&lt;/h2&gt;
&lt;p&gt;　　作为分布式项目，单点登录是必不可少的，文本基于之前的的博客（猛戳：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huanzi-qch/p/10142395.html&quot; target=&quot;_blank&quot;&gt;SpringCloud系列——Zuul 动态路由&lt;/a&gt;，&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huanzi-qch/p/10239888.html&quot; target=&quot;_blank&quot;&gt;SpringBoot系列——Redis&lt;/a&gt;）记录Zuul配合Redis实现一个简单的sso单点登录实例&lt;/p&gt;
&lt;p&gt;　　sso单点登录思路：&lt;/p&gt;
&lt;p&gt;　　1、访问分布式系统的任意请求，被Zuul的Filter拦截过滤&lt;/p&gt;
&lt;p&gt;　　2、在run方法里实现过滤规则：cookie有令牌accessToken且作为key存在于Redis，或者访问的是登录页面、登录请求则放行&lt;/p&gt;
&lt;p&gt;　　3、否则，将重定向到sso-server的登录页面且原先的请求路径作为一个参数；response.sendRedirect(&quot;http://localhost:10010/sso-server/sso/loginPage?url=&quot; + url);&lt;/p&gt;
&lt;p&gt;　　4、登录成功，sso-server生成accessToken，并作为key（用户名+时间戳，这里只是demo，正常项目的令牌应该要更为复杂）存到Redis，value值存用户id作为value（或者直接存储可暴露的部分用户信息也行）设置过期时间（我这里设置3分钟）；设置cookie：new Cookie(&quot;accessToken&quot;,accessToken);，设置maxAge(60*3);、path(&quot;/&quot;);&lt;/p&gt;
&lt;p&gt;　　5、sso-server单点登录服务负责校验用户信息、获取用户信息、操作Redis缓存，提供接口，在eureka上注册&lt;/p&gt;

&lt;h2&gt;　　代码编写&lt;/h2&gt;
&lt;h3&gt;　　sso-server&lt;/h3&gt;
&lt;p&gt;　　首先我们创建一个单点登录服务sso-server，并在eureka上注册（创建项目请参考之前的SpringCloud系列博客跟 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huanzi-qch/p/10239888.html&quot; target=&quot;_blank&quot;&gt;SpringBoot系列——Redis&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110111418596-1142289189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　login.html&lt;/p&gt;
&lt;p&gt;　　我们这里需要用到页面，要先maven引入thymeleaf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-thymeleaf&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns:th&lt;/span&gt;&lt;span&gt;=&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登录页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;/sso-server/sso/login&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; th:value&lt;/span&gt;&lt;span&gt;=&quot;${url}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        用户名：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        密码：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;登录&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提供如下接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@EnableEurekaClient
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SsoServerApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(SsoServerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringRedisTemplate template;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断key是否存在
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/redis/hasKey/{key}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean hasKey(@PathVariable(&quot;key&quot;&lt;span&gt;) String key) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; template.hasKey(key);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 校验用户名密码，成功则返回通行令牌（这里写死huanzi/123456）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/sso/checkUsernameAndPassword&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String checkUsernameAndPassword(String username, String password) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通行令牌&lt;/span&gt;
        String flag = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;huanzi&quot;.equals(username) &amp;amp;&amp;amp; &quot;123456&quot;&lt;span&gt;.equals(password)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名+时间戳（这里只是demo，正常项目的令牌应该要更为复杂）&lt;/span&gt;
            flag = username +&lt;span&gt; System.currentTimeMillis();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;令牌作为key，存用户id作为value（或者直接存储可暴露的部分用户信息也行）设置过期时间（我这里设置3分钟）&lt;/span&gt;
            template.opsForValue().set(flag, &quot;1&quot;, (&lt;span&gt;long&lt;/span&gt;) (3 * 60&lt;span&gt;), TimeUnit.SECONDS);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 跳转登录页面
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/sso/loginPage&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ModelAndView loginPage(String url) {
        ModelAndView modelAndView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ModelAndView(&quot;login&quot;&lt;span&gt;);
        modelAndView.addObject(&lt;/span&gt;&quot;url&quot;&lt;span&gt;, url);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 页面登录
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/sso/login&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String login(HttpServletResponse response, String username, String password, String url) {
        String check &lt;/span&gt;=&lt;span&gt; checkUsernameAndPassword(username, password);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.isEmpty(check)) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Cookie cookie &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cookie(&quot;accessToken&quot;&lt;span&gt;, check);
                cookie.setMaxAge(&lt;/span&gt;60 * 3&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置域
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                cookie.setDomain(&quot;huanzi.cn&quot;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置访问路径&lt;/span&gt;
                cookie.setPath(&quot;/&quot;&lt;span&gt;);
                response.addCookie(cookie);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重定向到原先访问的页面&lt;/span&gt;
&lt;span&gt;                response.sendRedirect(url);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;登录失败&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　zuul-server&lt;/h3&gt;
&lt;p&gt;　　引入feign，用于调用sso-server服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; feign &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-openfeign&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建SsoFeign.java接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@FeignClient(name = &quot;sso-server&quot;, path = &quot;/&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SsoFeign {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断key是否存在
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;redis/hasKey/{key}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean hasKey(@PathVariable(&quot;key&quot;&lt;span&gt;) String key);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动类加入@EnableFeignClients注解，否则启动会报错，无法注入SsoFeign对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableZuulProxy
@EnableEurekaClient
@EnableFeignClients
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZuulServerApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ZuulServerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AccessFilter accessFilter() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AccessFilter();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改AccessFilter过滤逻辑，注入feign接口，用于调用sso-server检查Redis，修改run方法的过滤逻辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Zuul过滤器，实现了路由检查
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccessFilter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ZuulFilter {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SsoFeign ssoFeign;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过int值来定义过滤器的执行顺序
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; filterOrder() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; PreDecoration之前运行&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; PRE_DECORATION_FILTER_ORDER - 1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型：
     * public static final String ERROR_TYPE = &quot;error&quot;;
     * public static final String POST_TYPE = &quot;post&quot;;
     * public static final String PRE_TYPE = &quot;pre&quot;;
     * public static final String ROUTE_TYPE = &quot;route&quot;;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String filterType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; PRE_TYPE;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 过滤器的具体逻辑
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object run() {
        RequestContext ctx &lt;/span&gt;=&lt;span&gt; RequestContext.getCurrentContext();
        HttpServletRequest request &lt;/span&gt;=&lt;span&gt; ctx.getRequest();
        HttpServletResponse response &lt;/span&gt;=&lt;span&gt; ctx.getResponse();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问路径&lt;/span&gt;
        String url =&lt;span&gt; request.getRequestURL().toString();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从cookie里面取值（Zuul丢失Cookie的解决方案：&lt;/span&gt;&lt;span&gt;https://blog.csdn.net/lindan1984/article/details/79308396&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;
        String accessToken = request.getParameter(&quot;accessToken&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Cookie cookie : request.getCookies()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;accessToken&quot;&lt;span&gt;.equals(cookie.getName())) {
                accessToken &lt;/span&gt;=&lt;span&gt; cookie.getValue();
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤规则：cookie有令牌且存在于Redis，或者访问的是登录页面、登录请求则放行&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (url.contains(&quot;sso-server/sso/loginPage&quot;) || url.contains(&quot;sso-server/sso/login&quot;) || (!StringUtils.isEmpty(accessToken) &amp;amp;&amp;amp;&lt;span&gt; ssoFeign.hasKey(accessToken))) {
            ctx.setSendZuulResponse(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            ctx.setResponseStatusCode(&lt;/span&gt;200&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            ctx.setSendZuulResponse(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            ctx.setResponseStatusCode(&lt;/span&gt;401&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重定向到登录页面&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                response.sendRedirect(&lt;/span&gt;&quot;http://localhost:10010/sso-server/sso/loginPage?url=&quot; +&lt;span&gt; url);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回一个boolean类型来判断该过滤器是否要执行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldFilter() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改配置文件，映射sso-server代理路径，超时时间与丢失cookie的解决&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
zuul.routes.sso-server.path=/sso-server/**&lt;span&gt;
zuul&lt;/span&gt;.routes.sso-server.service-id=sso-&lt;span&gt;server


zuul&lt;/span&gt;.host.&lt;span&gt;socket&lt;/span&gt;-timeout-millis=&lt;span&gt;60000&lt;/span&gt;&lt;span&gt;
zuul&lt;/span&gt;.host.&lt;span&gt;connect&lt;/span&gt;-timeout-millis=&lt;span&gt;10000&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Zuul丢失Cookie的解决方案：https://blog.csdn.net/lindan1984/article/details/79308396&lt;/span&gt;
zuul.sensitive-headers=
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　测试效果&lt;/h2&gt;
&lt;p&gt;　　启动eureka、zuul-server、sso-server、config-server、myspringboot、springdatajpa（由两个应用组成，实现了ribbon负载均衡），&lt;span&gt;记得启动我们的RabbitMQ服务和Redis服务！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110114826142-1122186552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　刚开始，没有cookie且无Redis的情况下，浏览器访问 http://localhost:10010/myspringboot/feign/ribbon，被zuul-server拦截重定向到sso-server登录页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110115042268-801569546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110115501878-1495911057.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　开始登录校验，为了方便演示，我将密码的type改成text&lt;/p&gt;
&lt;p&gt;　　登录失败，返回提示语&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110120052977-1768462849.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　登录成功，重定向到之前的请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110120201029-1145102004.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　cookie的值，以及过期时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110120315739-777209532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3分钟后我们再次访问 http://localhost:10010/myspringboot/feign/ribbon，cookie、Redis失效，需要从新登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110120459318-1283913206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110120558640-1752946098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1353055/201901/1353055-20190110120443863-625026707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 　　后记&lt;/h2&gt;
&lt;p&gt;　　sso单点登录就记录到这里，这里只是实现了单机版的sso，以后在进行升级吧。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;问题报错&lt;/span&gt;：我们在sso-server设置cookie后，在zuul-server的run方法里获取不到设置的cookie，去浏览器查看，cookie没有设置成功，Zuul丢失Cookie&lt;/p&gt;
&lt;p&gt;　　解决方案：Zuul丢失Cookie的解决方案：&lt;a href=&quot;https://blog.csdn.net/lindan1984/article/details/79308396&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/lindan1984/article/details/79308396&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 04:11:00 +0000</pubDate>
<dc:creator>huanzi-qch</dc:creator>
<og:description>前言 作为分布式项目，单点登录是必不可少的，文本基于之前的的博客（猛戳：SpringCloud系列——Zuul 动态路由，SpringBoot系列——Redis）记录Zuul配合Redis实现一个简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huanzi-qch/p/10249227.html</dc:identifier>
</item>
</channel>
</rss>