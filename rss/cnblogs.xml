<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Appium+Python之生成html测试报告 - 丹姐blog</title>
<link>http://www.cnblogs.com/ZoeLiang/p/10217601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZoeLiang/p/10217601.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;思考：测试用例执行后，如何生成一个直观漂亮的测试报告呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;分析&lt;/span&gt;：&lt;/span&gt;1.unittest单元测试框架本身带有一个textTestRunner类，可以生成txt文本格式的测试报告，但是页面不够直观&lt;/p&gt;
&lt;p&gt;           2.我们可以导入第三方库，比如常用的HTMLTestRunner类，可以生成html格式测试报告&lt;/p&gt;
&lt;p&gt;　　　3.首先去下载HTMLTestRunner_PY3.py脚本（我这里采用Python3.7），然后放置在Python3.7路径下的Lib目录下，使用时需要导入（即import  HTMLTestRunner_PY3）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码示例如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例化测试套件&lt;/span&gt;
     suite =&lt;span&gt; unittest.TestSuite()
     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载测试用例&lt;/span&gt;
     suite.addTest(TestCase(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成测试报告&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择指定时间格式&lt;/span&gt;
    timestr = time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d%H%M%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, time.localtime(time.time()))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义测试报告存放路径和报告名称&lt;/span&gt;
    Report =&lt;span&gt; os.path.join(
        PATH(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E://testing_code/code/SmartSiteTestScript/report/test_report_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) +&lt;span&gt;
        timestr &lt;/span&gt;+
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    with open(Report, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        runner &lt;/span&gt;=&lt;span&gt; HTMLTestRunner_PY3.HTMLTestRunner(stream=&lt;/span&gt;&lt;span&gt;f, &lt;br/&gt;verbosity&lt;/span&gt;=2,&lt;br/&gt;title=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXXX自动化测试报告&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;br/&gt;description=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行人：丹姐&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) &lt;br/&gt;runner.run(suite) &lt;/span&gt;&lt;span&gt;    #&lt;/span&gt;&lt;span&gt; 关闭测试报告&lt;/span&gt; &lt;br/&gt;f.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;在测试报告名中显示时间：（引入time包）  timestr=time.strftime(&quot;%Y-%m-%d-%H_%M_%S&quot;,time.localtime(time.time()))&lt;/p&gt;
&lt;p&gt;time.time():获取当前时间戳&lt;/p&gt;
&lt;p&gt;time.ctime():获取当前时间的字符串&lt;/p&gt;
&lt;p&gt;time.localtime()：当前时间的struct_time形式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;time.strftime(&quot;%Y-%m-%d-%H_%M_%S&quot;,time.localtime()):获取特定格式的时间，通常用这个&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;TestSuite是个容器，往里面用addTest()添加测试用例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;Report定义报告保存的路径以及文件名&lt;/p&gt;
&lt;p&gt;open() 函数用于打开一个文件，创建一个 &lt;span class=&quot;marked&quot;&gt;file 对象，相关的方法才可以调用它进行读写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;pln&quot;&gt;语法：open&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;pln&quot;&gt;name&lt;span class=&quot;pun&quot;&gt;[, &lt;span class=&quot;pln&quot;&gt;mode&lt;span class=&quot;pun&quot;&gt;[, &lt;span class=&quot;pln&quot;&gt;buffering&lt;span class=&quot;pun&quot;&gt;]])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name : 一个包含了你要访问的文件名称的字符串值&lt;/li&gt;
&lt;li&gt;mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)&lt;/li&gt;
&lt;li&gt;buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489168/201901/1489168-20190103233555990-1148192120.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里常用的为 open(Report,'wb')：以二进制形式打开文件Report&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt;runner定义测试报告格式&lt;strong&gt;，&lt;/strong&gt;stream定义报告写入的二进制文件，title为报告的标题，description为报告的说明，runner.run()用来运行测试case,&lt;strong&gt;注意最后用f.close()将文件关闭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;verbosity表示测试结果的信息复杂度，有三个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0 (静默模式): 你只能获得总的测试用例数和总的结果 比如 总共100个 失败20 成功80&lt;/li&gt;
&lt;li&gt;1 (默认模式): 非常类似静默模式 只是在每个成功的用例前面有个“.” 每个失败的用例前面有个 “F”&lt;/li&gt;
&lt;li&gt;2 (详细模式):测试结果会显示每个测试用例的所有相关的信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试报告效果图如下所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489168/201901/1489168-20190103230813067-2090165916.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 03 Jan 2019 15:42:00 +0000</pubDate>
<dc:creator>丹姐blog</dc:creator>
<og:description>思考：测试用例执行后，如何生成一个直观漂亮的测试报告呢？ 分析：1.unittest单元测试框架本身带有一个textTestRunner类，可以生成txt文本格式的测试报告，但是页面不够直观 2.我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZoeLiang/p/10217601.html</dc:identifier>
</item>
<item>
<title>Perl基础速成 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10217597.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10217597.html</guid>
<description>&lt;p&gt;本文是针对没有Perl基础，但想用perl一行式命令取代grep/awk/sed的人，用于速学Perl基础知识。&lt;/p&gt;
&lt;p&gt;Perl一行式系列文章：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9512185.html#blogperloneline&quot;&gt;Perl一行式程序&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;perl的-e选项&quot;&gt;perl的-e选项&lt;/h2&gt;
&lt;p&gt;perl命令的&lt;strong&gt;-e选项&lt;/strong&gt;后可以书写表达式，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e 'print &quot;hello world\n&quot;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Perl中的函数调用经常可以省略括号，所以&lt;code&gt;print &quot;hello world\n&quot;&lt;/code&gt;表示的是&lt;code&gt;print(&quot;hello world\n&quot;)&lt;/code&gt;，但并非总是可以省略括号，一般来说只要不是自己定义的函数，都可以省略括号，除非少数出现歧义的情况。&lt;/p&gt;
&lt;p&gt;在unix下&lt;strong&gt;建议使用单引号包围&lt;/strong&gt;&lt;code&gt;perl -e&lt;/code&gt;的表达式，在windows下建议使用双引号包围表达式。本文所有操作都是在Linux下操作的。&lt;/p&gt;
&lt;p&gt;如果表达式中有多个语句，各语句之间使用分号&quot;;&quot;隔开。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e 'print &quot;hello&quot;;print &quot;world&quot;.&quot;\n&quot;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，上面使用了点号&quot;.&quot;来连接两个字符串。&lt;/p&gt;
&lt;p&gt;稍后会解释另一个表达式选项&quot;-E&quot;，它和&quot;-e&quot;功能几乎一样，唯一不同的是&quot;-E&quot;会自动启用一些高版本的功能。&lt;/p&gt;

&lt;h2 id=&quot;printprintfsay和sprintf&quot;&gt;print、printf、say和sprintf&lt;/h2&gt;
&lt;p&gt;Perl中的&lt;strong&gt;print函数不会自动换行，所以需要手动加上&quot;\n&quot;来换行&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e 'print &quot;hello world&quot;'
perl -e 'print &quot;hello world\n&quot;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Perl中的&lt;strong&gt;say()函数&lt;/strong&gt;会自动换行，用法和print完全一致。但要使用say，需要使用use指定版本号高于5.010，。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e 'use 5.010;say &quot;hello world&quot;'
hello world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;strong&gt;&quot;-E&quot;选项&lt;/strong&gt;替换&quot;-e&quot;，可以省略版本的指定，因为&quot;-E&quot;自动启用高版本功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -E 'say &quot;hello world&quot;'
hello world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Perl也支持&lt;strong&gt;printf函数&lt;/strong&gt;，语法格式是&lt;code&gt;printf &quot;format_string&quot;,expr,...&lt;/code&gt;。想必看本文的人都知道如何使用printf，所以只给个简单示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e 'printf &quot;hello %s\n&quot;, &quot;Perl&quot;'
hello Perl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;sprintf()函数&lt;/strong&gt;表示按照printf的方式进行格式化，然后保存起来。保存起来的内容可以赋值给变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '$a = sprintf &quot;hello %s\n&quot;, &quot;Perl&quot;;print &quot;$a&quot;'
hello Perl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面将格式化后的字符串&lt;code&gt;helloPerl\n&lt;/code&gt;保存到了变量&lt;code&gt;$a&lt;/code&gt;中，然后print输出了变量&quot;$a&quot;。&lt;/p&gt;

&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;
&lt;p&gt;Perl中声明变量x需要使用&lt;code&gt;$x&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$x = &quot;abc&quot;
$y = 33
($x,$y)=(&quot;abc&quot;,33)
${var} = 333  # 加大括号是标准写法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一行式命令中的变量使用示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e '$a=&quot;hello world&quot;;print &quot;$a\n&quot;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Perl中变量赋值时，总是会先计算右边的结果，再赋值给左边的变量。所以，变量交换非常方便：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;($var1,$var2)=($var2,$var1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于一行式Perl程序，变量可以无须事先声明直接使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e 'print $a + 1,&quot;\n&quot;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要判断变量是否已经定义，可以使用&lt;code&gt;defined($var)&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e 'if(defined($a)){print $a,&quot;\n&quot;}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不带任何修饰的变量是全局变量，如果想要定义为局部变量，可以在变量前加上&lt;code&gt;my&lt;/code&gt;。my是一个函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;my $a = &quot;abc&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于Perl一行式程序来说，几乎不需要考虑my。但及少数情况下需要使用大括号或其它语句块的时候，可以使用my来声明局部变量，出了语句块范围变量就失效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $a = 33;
        {
            my $a = &quot;abc&quot;;
            print $a,&quot;\n&quot;;
        }
        print $a,&quot;\n&quot;;'&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;数值字符串和反斜线序列&quot;&gt;数值、字符串和反斜线序列&lt;/h2&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;4 + 3              # 7
3.12 + 3.22        # 6.34
&quot;4abc&quot; + &quot;3xyz&quot;    # 7
&quot;abc&quot; + &quot;3xyz&quot;     # 3
&quot;1.2abc&quot; + &quot;3.1x&quot;  # 4.3
1..6            # 1 2 3 4 5 6
1.2..6.4        # 1 2 3 4 5 6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要解释下上面的几行语句。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数值和字符串之间的转换取决于做什么运算。例如加法表示数学运算，会让字符串转换成数值&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;浮点数和整数之间的转换仍然取决于所处的环境，在需要整数的时候浮点数会直接截断成整数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;字符串使用单引号或双引号包围，此外，Perl中也有反引号，这3种引用和shell中的单、双、反引号类似。：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;双引号表示弱引用，变量可以在双引号中进行内容替换&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;单引号表示强引用，内部不会进行变量替换，反斜线序列也会失效
&lt;ul&gt;&lt;li&gt;在unix下的perl一行式程序中因为一般使用单引号包围-e表达式，所以一行式perl中单引号比较少用&lt;/li&gt;
&lt;li&gt;如果非要使用单引号，可以考虑使用q()来引用，见下文对q、qq和qx的解释&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;反引号表示执行操作系统命令并取得命令的输出结果，需要记住的是它自带尾随换行符(除非所执行命令就没有带尾随换行)。例如&lt;code&gt;$a = `date +%F %T`&lt;/code&gt;、&lt;code&gt;$files = `ls /root`&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$ perl -e '$a = `date +&quot;%F %T&quot;`;print $a'
2019-01-03 19:55:32&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Perl中有以下几个常见的反斜线序列:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;\n
\r
\t
\l    # 将下个字母转换为小写
\L    # 将后面的多个字母都转换为小写，直到遇到\E
\u    # 将下个字母转换为大写
\U    # 将后面的多个字母都转换为大写，直到遇到\E
\Q    # 和\E之间的所有字符都强制当作字面符号
\E    # \L、\U和\Q的结束符号&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字符串连接需要使用&quot;.&quot;，例如&lt;code&gt;&quot;abc&quot;.&quot;def&quot;&lt;/code&gt;等价于&lt;code&gt;&quot;abcdef&quot;&lt;/code&gt;。字符串重复次数可以使用小写字母x，例如&lt;code&gt;&quot;a&quot; x 3&lt;/code&gt;得到&lt;code&gt;&quot;aaa&quot;&lt;/code&gt;，&lt;code&gt;&quot;abc&quot; x 2&lt;/code&gt;得到&lt;code&gt;abcabc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Perl中&lt;strong&gt;数值和字符、字符串&lt;/strong&gt;都支持自增、自减操作。相关示例参见&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9536582.html&quot;&gt;Perl中的自增、自减操作&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;qqq和qx&quot;&gt;q、qq和qx&lt;/h3&gt;
&lt;p&gt;在Perl中，引号不一定非要写成符号，可以使用&lt;strong&gt;q()来表示单引号、qq()来表示双引号、qx()表示反引号&lt;/strong&gt;。其中这里的括号可以替换成其它成对的符号，例如&lt;code&gt;qq{}、qq//、qq%%&lt;/code&gt;都是可以的。&lt;/p&gt;
&lt;p&gt;使用q类型的引用可以避免在shell中一行式Perl程序的引号转义问题。&lt;/p&gt;
&lt;p&gt;例如，在一行式Perl中想要保留单引号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e &quot;print q(abc'd)&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;p&gt;Perl中的数组本质上是一个列表(对于Perl一行式命令，可以将列表等价于数组)，要声明数组，使用&lt;code&gt;@&lt;/code&gt;符号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@arr = (&quot;Perl&quot;, &quot;Python&quot;, &quot;Shell&quot;)
@{arr} = (1,2,3)  # 加上大括号是标准的写法
@empty = ()       # 空数组&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;书写列表时，字符串需要使用引号包围，逗号分隔各个元素。还可以使用qw()来写列表，不需要再使用逗号分隔元素，而是使用空格，且每个元素都默认以单引号的方式包围。所以下面是等价的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@arr = qw(Perl Python Shell abc\ndef)
@arr = ('Perl','Python','Shell,'abc\ndef')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对于一行式的perl命令，变量和数组可以直接使用而无需事先声明&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数组可以直接放在双引号中输出，默认输出的时候是用空格分隔各元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '@arr=qw(Perl Python Shell);print &quot;@arr\n&quot;'
Perl Python Shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要取数组中的某个元素，使用&lt;code&gt;$&lt;/code&gt;符号。第一个元素&lt;code&gt;$arr[0]&lt;/code&gt;，第二个元素&lt;code&gt;$arr[1]&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '@arr=qw(Perl Python Shell);print &quot;$arr[1]\n&quot;'
Python&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组&lt;code&gt;$#arr&lt;/code&gt;或&lt;code&gt;$#{arr}&lt;/code&gt;表示数组的最后一个数组索引值，所以数组元素个数等于该值加1。&lt;/p&gt;
&lt;p&gt;如果想要直接取得数组的个数，将数组赋值给一个变量或者使用scalar()函数即可。这涉及到Perl的上下文知识，不是本文内容，所以记住即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        @arr = qw(Shell Perl PHP);
        $num = @arr;print &quot;$num\n&quot;;
        print scalar @arr,&quot;\n&quot;;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组的索引可以是负数，-1表示最后一个元素，-2表示倒数第二个元素。所以&lt;code&gt;$arr[-1]&lt;/code&gt;等价于&lt;code&gt;$arr[$#arr]&lt;/code&gt;，都是最后一个元素。&lt;/p&gt;

&lt;h3 id=&quot;数组切片&quot;&gt;数组切片&lt;/h3&gt;
&lt;p&gt;数组支持切片功能，切片操作使用&lt;code&gt;@&lt;/code&gt;符号，切片操作会返回一个新的列表(数组)。切片时同一个元素可以出现多次，且顺序随意，这比其它语言的切片要自由的多。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@arr = qw(Perl Python Shell Ruby PHP)
@arr[0]   # 取第一个元素形成一个新列表
@arr[1,1,0,-2]  # 取两次第2个元素，一次第1个元素，一次倒数第2个元素形成新列表
@arr[1..3]  # 以序列的方式取第2到第4个元素形成新列表&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        @arr=qw(Perl Python Shell Ruby PHP);
        print &quot;@arr[1,1,0,-2]\n&quot;'
Python Python Perl Ruby&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要取从第2个到倒数第2个元素，可以使用这种切片方式&lt;code&gt;@arr[1..$#{arr}-1]&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '@arr=qw(Perl Python Shell Ruby PHP);
        print &quot;@arr[1..$#{arr}-1]\n&quot;'
Python Shell Ruby&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;操作数组相关函数&quot;&gt;操作数组相关函数&lt;/h3&gt;
&lt;p&gt;数组可以使用&lt;strong&gt;pop/push函数&lt;/strong&gt;来移除、追加最尾部的一个元素，使用&lt;strong&gt;shift/unshift函数&lt;/strong&gt;移除、插入首部第一个元素。如果想要操作中间某个元素，可以使用&lt;strong&gt;splice()函数&lt;/strong&gt;。这些函数的用法参见：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9511949.html#blog111&quot;&gt;增、删数组元素&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，还有sort()、reverse()函数，在Perl中sort太过强大，不适合在这里展开解释，所以记住它可以用来排序列表(数组)做简单使用即可。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        @arr=qw(Perl Python Shell Ruby PHP);
        @arr1 = sort @arr;
        print &quot;@arr1\n&quot;'
PHP Perl Python Ruby Shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于sort还需注意的是，它不是在原地排序的，而是生成一个排序后的新列表，原数组中元素的顺序并不会受排序的影响。所以需要将这个新列表赋值给另一个数组变量才能得到排序后的结果，正如上面的示例一样。&lt;/p&gt;
&lt;p&gt;但也有技巧可以直接输出排序后的结果，而且这个技巧非常有用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
         @arr=qw(Perl Python Shell Ruby PHP);
         print &quot;@{ [ sort @arr ] }\n&quot;'
PHP Perl Python Ruby Shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这属于Perl的高级技巧，这里大致解释一下。它分成2个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一部分是&lt;code&gt;[]&lt;/code&gt;，它表示构造一个匿名列表，匿名列表的内容可以来自于字面元素，也可以来自函数的结果或者表达式的结果，正如上面是将sort函数排序的结果构造成匿名列表；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;第二部分是&lt;code&gt;@{xxx}&lt;/code&gt;，它表示将列表xxx引用进行解除，然后可以插入到双引号中进行输出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，当想要&lt;strong&gt;将某个操作的结果直接输出&lt;/strong&gt;时，就可以采取这种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@{ [ something you do ] }&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;遍历数组&quot;&gt;遍历数组&lt;/h3&gt;
&lt;p&gt;要遍历数组，可以使用for、foreach、each，当然也可以使用while，只不过使用for/foreach/each要更方便。关于for/foreach/each/while详细的内容，见后文。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# foreach遍历数组
perl -e '
        @arr=qw(Perl Python Shell Ruby PHP);
        foreach $i (@arr){print &quot;$i\n&quot;}'

# for遍历数组：元素存在性测试遍历法
perl -e '
        @arr=qw(Perl Python Shell Ruby PHP);
        for $i (@arr){print &quot;$i\n&quot;}'

# for遍历数组：索引遍历法
perl -e '
        @arr=qw(Perl Python Shell Ruby PHP);
        for($i=0; $i&amp;lt;=$#arr; $i++){print &quot;$arr[$i]\n&quot;}'

# each遍历数组：key/value遍历
perl -e '
        @arr=qw(Perl Python Shell Ruby PHP);
        while (($index, $value) = each(@arr)){
            print &quot;$index: $value\n&quot;
        }'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;必须注意的是，Perl中for/foreach以元素存在性测试遍历时，控制变量&lt;code&gt;$i&lt;/code&gt;是各个元素的引用，而不是复制各个元素再赋值给&lt;code&gt;$i&lt;/code&gt;，所以在遍历过程中修改&lt;code&gt;$i&lt;/code&gt;的值会直接修改原数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        @arr=qw(Perl Python Shell Ruby PHP);
        for $i (@arr){$i = $i.&quot;X&quot;};  # 为每个元素加尾随字符&quot;X&quot;
        print &quot;@arr\n&quot;'
PerlX PythonX ShellX RubyX PHPX&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;split和join函数&quot;&gt;split()和join()函数&lt;/h2&gt;
&lt;p&gt;join()用于将列表连接成字符串，split()用于将字符串分割成列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;join $sep,$list
split /pattern_sep/,$string,limit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细用法和示例参见：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9655273.html#blog1546504311&quot;&gt;Perl处理数据(一)：s替换、split和join&lt;/a&gt;。下面是两个简单示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print join &quot;--&quot;,a,b,c,d,e;   # 输出&quot;a--b--c--d--e&quot;

$str=&quot;abc:def::1234:xyz&quot;;
@list = split /:/,$str;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的字符串分割后将有5个元素：abc,def,空,1234,xyz。&lt;/p&gt;

&lt;h2 id=&quot;hash关联数组&quot;&gt;hash(关联数组)&lt;/h2&gt;
&lt;p&gt;Perl也支持hash数据结构，hash结构中key/value一一映射，和Shell中的关联数组是一个概念。&lt;/p&gt;
&lt;p&gt;在Perl中，无论是数组还是hash结构，本质都是列表。所以下面的列表数据可以认为是数组，也可以认为是hash，关键在于它赋值给什么类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&quot;name&quot;,&quot;longshuai&quot;,&quot;age&quot;,23)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Perl中，数组类型使用&lt;code&gt;@&lt;/code&gt;前缀表示，hash类型则使用&lt;code&gt;%&lt;/code&gt;前缀表示。&lt;/p&gt;
&lt;p&gt;所以，下面的表示hash结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%Person = (&quot;name&quot;,&quot;longshuai&quot;,&quot;age&quot;,23)
%Person = qw(name longshuai age 23)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;列表作为hash结构时，每两个元素组成一个key/value对&lt;/strong&gt;，其中key部分必须是字符串类型。所以上面的hash结构表示的映射关系为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%Person = (
        name =&amp;gt; &quot;longshuai&quot;,
        age  =&amp;gt; 23,
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，上面使用胖箭头&lt;code&gt;=&amp;gt;&lt;/code&gt;的写法在Perl中是允许且推荐的，它是元素分隔符逗号的另一种表示方式，且使用胖箭头更能展现一一对应的关系。在使用胖箭头的写法时，如果key是符合命名规范的，可以省略key的引号(因为它是字符串，正常情况下是应该加引号包围的)，正如上面所写的格式。&lt;/p&gt;
&lt;p&gt;hash数据&lt;strong&gt;不能在双引号中进行内容替换&lt;/strong&gt;，可以直接输出它，但直接输出时hash的元素是紧挨在一起的，这表示hash的字符串化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        %hash = qw(name longshuai age 23);
        print &quot;%hash&quot;,&quot;\n&quot;'
%hash

$ perl -e '
        %hash = qw(name longshuai age 23);
        print %hash,&quot;\n&quot;'
age23namelongshuai&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从hash中取元素使用&lt;code&gt;$&lt;/code&gt;表示，如&lt;code&gt;$hash{KEY}&lt;/code&gt;，从hash中切片使用&lt;code&gt;@&lt;/code&gt;表示，如&lt;code&gt;@hash{KEY1,KEY2}&lt;/code&gt;这和数组是一样的。&lt;strong&gt;虽然hash类型本身不能在双引号中进行内容替换，但hash取值或者hash切片可以在双引号中替换&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        print &quot;$hash{name}&quot;,&quot;\n&quot;'
longshuai

$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        print &quot;@hash{name,name,age,age}&quot;,&quot;\n&quot;'
longshuai longshuai 23 23&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;hash相关函数&quot;&gt;hash相关函数&lt;/h3&gt;
&lt;p&gt;主要有keys()、values()、exists()和delete()。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;keys()返回hash结构中所有key组成的列表。例如&lt;code&gt;keys %hash&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;values()则返回hash结构中所有value组成的列表。例如&lt;code&gt;values %hash&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;exists()用来检测hash结构中元素是否存在。例如&lt;code&gt;exists $hash{KEY}&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;delete()用来删除hash中的一个元素。例如&lt;code&gt;delete $hash{KEY}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是keys和values函数的示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        print &quot;keys:\n&quot;;
        print keys %hash,&quot;\n&quot;;
        print &quot;values:\n&quot;;
        print values %hash,&quot;\n&quot;;'
keys:
agename
values:
23longshuai&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来不是很爽，所以赋值给数组再来输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        @keys = keys %hash;
        @values = values %hash;
        print &quot;=========\n&quot;;
        print &quot;@keys\n&quot;;
        print &quot;=========\n&quot;;
        print &quot;@values\n&quot;;'
=========
age name
=========
23 longshuai&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何知道hash结构中有多少个key/value对&lt;/strong&gt;？是否记得将数组(列表)赋值给一个变量时，得到的就是它的个数？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        $nums = keys %hash;
        print &quot;$nums\n&quot;;'
2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要直接输出个数而不是先赋值给变量，可以&lt;strong&gt;对一个列表使用函数scalar()，它会强制让Perl将列表当作标量(变量)&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        print scalar keys %hash,&quot;\n&quot;;'
2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何排序hash结构？只需对keys的结果应用sort/reverse函数，再进行遍历输出即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        for $key (sort keys %hash){
            print &quot;$key =&amp;gt; $hash{$key}\n&quot;;
        }'
age =&amp;gt; 23
name =&amp;gt; longshuai&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;遍历hash&quot;&gt;遍历hash&lt;/h3&gt;
&lt;p&gt;要遍历hash结构，可以使用while + each或者for/foreach遍历hash的key或value。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 使用while + each
$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        while(($key,$value) = each %hash){
                print &quot;$key =&amp;gt; $value&quot;,&quot;\n&quot;
        }'
name =&amp;gt; longshuai
age =&amp;gt; 23

# 使用for或foreach去遍历keys或values
$ perl -e '
        %hash = (name=&amp;gt;&quot;longshuai&quot;,age=&amp;gt;23);
        for $key (keys %hash){
                print &quot;$key =&amp;gt; $hash{$key}&quot;,&quot;\n&quot;
        }'
age =&amp;gt; 23
name =&amp;gt; longshuai&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;默认变量_argv_&quot;&gt;默认变量$_、@ARGV、@_&lt;/h2&gt;
&lt;p&gt;在Perl中，有一个非常特殊的变量&lt;code&gt;$_&lt;/code&gt;，它表示默认变量。&lt;/p&gt;
&lt;p&gt;当没有为函数指定参数时、表达式中需要变量但却没给定时都会使用这个默认变量&lt;code&gt;$_&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e '$_=&quot;abc\n&quot;;print'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;print函数没有给参数，所以默认输出&lt;code&gt;$_&lt;/code&gt;的内容。&lt;/p&gt;
&lt;p&gt;再例如，for/foreach的遍历行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for $i (@arr){print &quot;$i\n&quot;}
for (@arr){print &quot;$_\n&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;for本该需要一个控制变量指向&lt;code&gt;@arr&lt;/code&gt;中每个元素，但如果没有给定，则使用默认变量&lt;code&gt;$_&lt;/code&gt;作为控制变量。&lt;/p&gt;
&lt;p&gt;用到默认变量的地方很多，没法列出所有使用&lt;code&gt;$_&lt;/code&gt;的情况。所以简单地总结是：只要某些操作需要参数但却没有给定的时候，就可以使用&lt;code&gt;$_&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$_&lt;/code&gt;是对于标量变量而言的默认变量。对于需要列表/数组的时候，默认变量不再是&lt;code&gt;$_&lt;/code&gt;，而是&lt;code&gt;@ARGV&lt;/code&gt;或&lt;code&gt;@_&lt;/code&gt;：在自定义子程序(函数)内部，默认变量是&lt;code&gt;@_&lt;/code&gt;，在自定义子程序外部，默认变量是&lt;code&gt;@ARGV&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $name = shift;
        $age = shift;
        print &quot;$name:$age\n&quot;' longshuai 23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认数组(列表)变量对一行式perl命令来说可能遇不上，所以了解一下足以，只要能在需要的时候看懂即可。&lt;/p&gt;

&lt;h2 id=&quot;布尔值判断&quot;&gt;布尔值判断&lt;/h2&gt;
&lt;p&gt;在Perl中，真假的判断很简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数值0为假，其它所有数值为真&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;字符串空&quot;&quot;为假，字符串&quot;0&quot;为假，其它所有字符串为真(例如&quot;00&quot;为真)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;空列表、空数组、undef、未定义的变量、数组等为假&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意，Perl中没有true和false的关键字，如果强制写true/false，它们可能会被当作字符串，而字符串为真，所以它们都表示真。例如下面的两行，if的测试对象都认为是字符串而返回真。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e &quot;if(true){print &quot;aaaa\n&quot;}&quot;
perl -e &quot;if(false){print &quot;aaaa\n&quot;}&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;大小比较操作&quot;&gt;大小比较操作&lt;/h2&gt;
&lt;p&gt;Perl的比较操作符和bash完全相反。数值比较采用符号，字符串比较采用字母。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;数值     字符串      意义
-----------------------------
==       eq        相等
!=       ne        不等
&amp;lt;        lt        小于
&amp;gt;        gt        大于
&amp;lt;=       le        小于或等于
&amp;gt;=       ge        大于或等于
&amp;lt;=&amp;gt;      cmp       返回值-1/0/1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一个&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;和&lt;code&gt;cmp&lt;/code&gt;用于比较两边的数值/字符串并返回状态码-1/0/1：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小于则返回-1&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;等于则返回0&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;大于则返回1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;，如果比较的双方有一方不是数值，该操作符将返回undef。&lt;/p&gt;
&lt;p&gt;几个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;35 != 30 + 5       # false
35 == 35.0         # true
'35' eq '35.0'     # false(str compare)
'fred' lt 'bay'    # false
'fred' lt 'free'   # true
'red' eq 'red'     # true
'red' eq 'Red'     # false
' ' gt ''          # true
10&amp;lt;=&amp;gt;20            # -1
20&amp;lt;=&amp;gt;20            # 0
30&amp;lt;=&amp;gt;20            # 1&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;逻辑运算&quot;&gt;逻辑运算&lt;/h2&gt;
&lt;p&gt;Perl支持逻辑与(&lt;code&gt;and &amp;amp;&amp;amp;&lt;/code&gt;)、逻辑或(&lt;code&gt;or ||&lt;/code&gt;)、逻辑非(&lt;code&gt;not !&lt;/code&gt;)运算，还支持一个额外的&lt;code&gt;//&lt;/code&gt;操作。它们都会短路计算。&lt;/p&gt;
&lt;p&gt;符号类型的逻辑操作&lt;code&gt;&amp;amp;&amp;amp; || ! //&lt;/code&gt;优先级很高，为了保险，符号两边的表达式应当使用括号包围。关键字类型的逻辑操作优先级很低，不需要使用括号包围。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;($a &amp;gt; $b) &amp;amp;&amp;amp; ($a &amp;lt; $c)
$a &amp;gt; $b and $a &amp;lt; $c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Perl的短路计算非常特别，它返回的是最后运算的表达式的值。也就是说，它有返回值，通过返回值可以判断短路计算的布尔逻辑是真还是假。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果这个返回值对应的布尔值为真，则整个短路计算自然为真&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果这个返回值对应的布尔值为假，则整个短路计算自然为假&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，这个返回值既保证短路计算的结果不改变，又能得到返回值。这个返回值有时候很有用，例如，可以通过逻辑或的操作来设置默认值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name = $myname || &quot;malongshuai&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的语句中，如果&lt;code&gt;$myname&lt;/code&gt;为真，则&lt;code&gt;$name&lt;/code&gt;被赋值为&lt;code&gt;$myname&lt;/code&gt;，如果&lt;code&gt;$myname&lt;/code&gt;为假，则赋值为&quot;malongshuai&quot;。&lt;/p&gt;
&lt;p&gt;但上面有一种特殊的情况，如果&lt;code&gt;$myname&lt;/code&gt;已经定义了，且其值为数值0或字符串&quot;0&quot;，它也返回假。&lt;/p&gt;
&lt;p&gt;这和预期有所冲突，这时可以使用&lt;code&gt;//&lt;/code&gt;来替代&lt;code&gt;||&lt;/code&gt;。&lt;code&gt;//&lt;/code&gt;表示只要左边的内容已经定义了就返回真，而无论左边的内容代表的布尔值是真还是假。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name = $myname // &quot;malongshuai&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，就算&lt;code&gt;$myname&lt;/code&gt;的值为0，&lt;code&gt;$name&lt;/code&gt;也会赋值为0而不是&quot;malongshuai&quot;。&lt;/p&gt;

&lt;h2 id=&quot;流程控制&quot;&gt;流程控制&lt;/h2&gt;

&lt;h3 id=&quot;ifunless和三目运算逻辑&quot;&gt;if、unless和三目运算逻辑&lt;/h3&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# if语句
if(TEST){
    ...
} elsif {
    ...
} else{
    ...
}

# unless语句
unless(TEST){
    ...
}

# 三目运算符
expression ? if_true : if_false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;if表示TEST为真的时候，执行后面的语句块，否则执行elsif或else语句块。&lt;/p&gt;
&lt;p&gt;unless则相反，TEST为假的时候，执行后面的语句块。也就是等价于&lt;code&gt;if(!TEST)&lt;/code&gt;。unless也有else/elsif块，但基本不会用，因为可以转换成if语句。&lt;/p&gt;
&lt;p&gt;注意TEST部分，只要它的结果在布尔逻辑上是真，就表示真。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(&quot;abc&quot;){}  # 真
if(0){}      # 假
if(0 &amp;gt; 1){}  # 假&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;where和until循环&quot;&gt;where和until循环&lt;/h3&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while(CONDITION){
    commands;
}

until(CONDITION){
    commands;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Perl的until和其它某些语言的until循环有所不同，Perl的until循环，内部的commands主体可能一次也不会执行，因为Perl会先进行条件判断，当条件为假时就执行，如果第一次判断就为真，则直接退出until。&lt;/p&gt;

&lt;h3 id=&quot;for和foreach循环&quot;&gt;for和foreach循环&lt;/h3&gt;
&lt;p&gt;Perl中的for循环和Bash Shell类似，都支持两种风格的for：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# (1).C语言风格的for
for(expr1;expr2;expr3){...}
for($i=0;$i&amp;lt;100;$i++){...}

# (2).元素存在性测试的for
for $i (LIST){...}

# (3).元素存在性测试的for等价于foreach
foreach $i (LIST){...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于第一种for语法(即C语言风格的for)，3个部分都可以省略，但分号不能省略：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;省略第一部分expr1表示不做初始化&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;省略第二部分expr2表示不设置条件，意味着可能会无限循环&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;省略第三部分expr3表示不做任何操作，可能也会无限循环&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如下面将3个部分全都省略，将会无限循环：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for(;;){
    print &quot;never stop&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于(2)和(3)的元素存在性测试的循环，用来迭代遍历列表，每次迭代过程中通过控制遍历&lt;code&gt;$i&lt;/code&gt;引用当前被迭代的元素。注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;$i&lt;/code&gt;是引用被迭代的元素，而不是复制列表中被迭代的元素然后赋值给&lt;code&gt;$i&lt;/code&gt;，这意味着迭代过程中修改&lt;code&gt;$i&lt;/code&gt;会直接影响元素列表数据&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$i&lt;/code&gt;可以省略，省略时使用默认变量&lt;code&gt;$_&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$i&lt;/code&gt;在遍历结束后，会恢复为遍历开始之前的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        @arr = qw(Perl Shell Python Ruby PHP);
        for (@arr){
                $_ = $_.&quot;x&quot;;
        }
        print &quot;@arr\n&quot;'
Perlx Shellx Pythonx Rubyx PHPx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面没有显式指定控制变量，所以采用默认变量&lt;code&gt;$_&lt;/code&gt;。且在迭代过程中为每个&lt;code&gt;$_&lt;/code&gt;都连接了一个尾随字符&quot;x&quot;，它会直接修改元素数组。&lt;/p&gt;

&lt;h3 id=&quot;表达式形式的流程控制语句&quot;&gt;表达式形式的流程控制语句&lt;/h3&gt;
&lt;p&gt;Perl支持单表达式后面加流程控制符。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;command OPERATOR CONDITION;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print &quot;true.\n&quot; if $m &amp;gt; $n;
print &quot;true.\n&quot; unless $m &amp;gt; $n;
print &quot;true.\n&quot; while $m &amp;gt; $n;
print &quot;true.\n&quot; until $m &amp;gt; $n;
print &quot;$_\n&quot; for @arr;
print &quot;$_\n&quot; foreach @arr;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;书写时，很多时候会分行并缩进控制符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print &quot;true.\n&quot;    # 注意没有分号结尾
    if $m &amp;gt; $n;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改写的方式几个注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;控制符左边只能用一个命令。除非使用do语句块，参见下面解释的do语句块&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;for/foreach的时候，不能自定义控制变量，只能使用默认的$_&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;while或until循环的时候，因为要退出循环，只能将退出循环的条件放进前面的命令中
&lt;ul&gt;&lt;li&gt;例如：&lt;code&gt;print &quot;abc&quot;,($n += 2) while $n &amp;lt; 10;&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print &quot;abc&quot;,($n += 2) until $n &amp;gt; 10;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;改写的方式不能满足需求时，可以使用普通的流程结构。&lt;/p&gt;

&lt;h3 id=&quot;大括号运行一次的语句块&quot;&gt;大括号：运行一次的语句块&lt;/h3&gt;
&lt;p&gt;使用大括号包围一段语句，这些语句就属于这个语句块。这个语句块其实是一个循环块结构，只不过它只循环一次。语句块有自己的范围，例如可以将变量定义为局部变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $a = 33;
        {
            my $a = &quot;abc&quot;;
            print $a,&quot;\n&quot;;
        }
        print $a,&quot;\n&quot;;'&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;do语句块&quot;&gt;do语句块&lt;/h3&gt;
&lt;p&gt;do语句块结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;do {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;do语句块像是匿名函数一样，没有名称，给定一个语句块，直接执行。do语句块的返回值是最后一个执行的语句的返回值。&lt;/p&gt;
&lt;p&gt;例如，if-elsif-else分支结构赋值的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if($gender eq &quot;male&quot;){
    $name=&quot;Malongshuai&quot;;
} elsif ($gender eq &quot;female&quot;){
    $name=&quot;Gaoxiaofang&quot;;
} else {
    $name=&quot;RenYao&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改写成do语句块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name=do{
    if($gender eq &quot;male&quot;){&quot;Malongshuai&quot;}
    elsif($gender eq &quot;female&quot;) {&quot;Gaoxiaofang&quot;}
    else {&quot;RenYao&quot;}
};     # 注意结尾的分号&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面说过，表达式形式的流程控制语句控制符左边只能是一个命令。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print $_+1,&quot;\n&quot;;print $_+2,&quot;\n&quot; if $_&amp;gt;3;

# 等价于下面两条语句：
print $_+1,&quot;\n&quot;;
print $_+2,&quot;\n&quot; if $_&amp;gt;3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用do语句块，可以将多个语句组合并当作一个语句。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;do{print $a+1,&quot;\n&quot;;print $a+2,&quot;\n&quot;} if $a&amp;gt;3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;do{}&lt;/code&gt;中有自己的作用域范围，可以声明属于自己范围内的局部变量。&lt;/p&gt;
&lt;p&gt;不要把do和大括号搞混了，大括号是被解释的语句块范围的语法符号，可以用来标记自己的作用域范围。但&lt;code&gt;do{}&lt;/code&gt;是语句，是被执行的语句块，也有自己的作用域范围。&lt;/p&gt;

&lt;h3 id=&quot;lastnextredocontinue&quot;&gt;last/next/redo/continue&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;last相当于其它语言里的break关键字，用于退出当前循环块&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(for/foreach/while/until/执行一次的语句块都属于循环块)，注意是只退出当前层次的循环，不会退出外层循环&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;next相当于其它语言里的continue关键字，用于跳入下一次迭代。同样只作用于当前层次的循环&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;redo用于跳转到当前循环层次的顶端，所以本次迭代中曾执行过的语句可能会再次执行&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;continue表示每轮循环的主体执行完之后，都执行另一段代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;熟悉sed的人肯定很容易理解这里redo和continue的作用。sed默认情况下会输出每一行被处理后的内容，这是因为它有一个和这里continue一样的逻辑，在perl命令的&quot;-p&quot;选项也一样，到时候会解释这个continue的逻辑。sed的&quot;-D&quot;选项则是处理后立即回到sed表达式的顶端再次对模式空间进行处理，直到模式空间没有内容，这实现的是redo的逻辑。&lt;/p&gt;

&lt;h2 id=&quot;beginend语句块&quot;&gt;BEGIN/END语句块&lt;/h2&gt;
&lt;p&gt;Perl像awk一样，也有BEGIN和END语句块，功能和awk是一样的。实际上Perl除了BEGIN/END，还有CHECK、INIT和UNITCHECK语句块，不过对于一行式Perl程序，BEGIN/END就足够了。&lt;/p&gt;

&lt;h2 id=&quot;perl命令行参数和argv&quot;&gt;Perl命令行参数和ARGV&lt;/h2&gt;
&lt;p&gt;perl命令行的参数存放在数组ARGV(@ARGV)中，所以可以访问&lt;code&gt;$ARGV[n]&lt;/code&gt;、遍历，甚至修改命令行参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e 'print &quot;@ARGV\n&quot;' first second
first second&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难看出，&lt;code&gt;@ARGV&lt;/code&gt;数组是从-e表达式之后才开始收集的。&lt;/p&gt;
&lt;p&gt;其实ARGV数组有点特别，如果参数中有被读取的文件参数，那么每开始读一个文件，这个文件就从ARGV数组中剔除。所以，在程序编译期间(BEGIN语句块)，ARGV数组中包含了完整的参数列表，处理第一个参数文件时，ARGV数组中包含了除此文件之外的其它参数列表，处理第二个参数文件时，ARGV数组中继续剔除这个文件参数。&lt;/p&gt;
&lt;p&gt;例如，perl一行式命令中，&quot;-p&quot;选项会输出参数文件的每一行被处理后的数据，也就是说它会读取参数文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ echo aaaa &amp;gt; a.txt
$ echo bbbb &amp;gt; b.txt
$ perl -pe '
        BEGIN{
            print &quot;in BEGIN:\n&quot;;
            print &quot;@ARGV\n&quot;
            }
        print &quot;in argv file: @ARGV\n&quot;;
        END{
            print &quot;in END:\n&quot;;
            print &quot;@ARGV\n&quot;
        }
' a.txt b.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;in BEGIN:
a.txt b.txt
in argv file: b.txt
aaaa
in argv file:
bbbb
in END:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，除了ARGV数组&lt;code&gt;@ARGV&lt;/code&gt;，还有一个ARGV变量&lt;code&gt;$ARGV&lt;/code&gt;，它表示当前正在被读取的参数文件。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ echo aaaa &amp;gt; a.txt
$ echo bbbb &amp;gt; b.txt
$ perl -pe '
        BEGIN{
            print &quot;in BEGIN:\n&quot;;
            print &quot;@ARGV\n&quot;
            }
        print &quot;reading me: $ARGV\n&quot;;
' a.txt b.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;in BEGIN:
a.txt b.txt
reading me: a.txt
aaaa
reading me: b.txt
bbbb&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;和shell交互执行shell命令&quot;&gt;和shell交互：执行shell命令&lt;/h2&gt;
&lt;p&gt;perl可以直接执行shell中的命令方式有3种，但这里只介绍两种：反引号(或qx)、system()函数。&lt;/p&gt;

&lt;h3 id=&quot;反引号&quot;&gt;反引号&lt;/h3&gt;
&lt;p&gt;反引号&lt;code&gt;`COMMAND`&lt;/code&gt;或 &lt;code&gt;qx(COMMAND)&lt;/code&gt;的方式是执行shell命令COMMAND后，将COMMAND的输出结果保存下来作为返回值，它可以赋值给变量，也可以插入到某个地方。就像shell中的反引号是一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e '$datetime = qx(date +&quot;%F %T&quot;);print $datetime'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，反引号执行的结果中一般都会保留尾随换行符(除非像printf一样明确不给尾随换行符)，所以在print这些变量的时候，可以不用指定&quot;\n&quot;。或者为了保持同意，使用chomp()或chop()函数操作变量，去掉最后一个字符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $datetime = qx(date +&quot;%F %T&quot;);
        chop $datetime;    # 或chomp $datetime
        print &quot;$datetime\n&quot;;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以更简便一些，直接在赋值语句上chop或chomp：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        chop($datetime = qx(date +&quot;%F %T&quot;));
        print &quot;$datetime\n&quot;;'&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;system&quot;&gt;system()&lt;/h3&gt;
&lt;p&gt;第二种和shell交互的方式是system()函数。&lt;strong&gt;它会直接输出所执行的命令，而不是将命令的结果作为返回值&lt;/strong&gt;。所以，system()函数不应该赋值给变量。&lt;/p&gt;
&lt;p&gt;system()要执行的命令部分需要使用引号包围。而对于一行式perl程序来说，直接使用引号是一个难题，所以可以考虑使用qq()、q()的方式。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        system q(date +&quot;%F %T&quot;);'
2019-01-03 20:18:34&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一定想要将system()的结果赋值给变量，得到的赋值结果是system()的返回值，而它的返回值表示的是命令是否成功调用(严格地说是wait()的返回值)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $datetime = system q(date +&quot;%F %T&quot;);
        print &quot;$datetime\n&quot;;'
2019-01-03 20:23:21
0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以使用shell的管道、重定向等功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myname=&quot;Malongshuai&quot;;
system &quot;echo $myname &amp;gt;/tmp/a.txt&quot;;
system &quot;cat &amp;lt;1.pl&quot;;
system 'find . -type f -name &quot;*.pl&quot; -print0 | xargs -0 -i ls -l {}';
system 'sleep 30 &amp;amp;';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;system()的用法其实很复杂，如果上面简单使用单引号包围无法解决问题时，可以参考&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9691714.html&quot;&gt;Perl和操作系统交互(一)：system、exec和反引号&lt;/a&gt;，这里面对system()的参数做了非常透彻的分析。&lt;/p&gt;

&lt;h2 id=&quot;和shell交互向perl命令行传递来自shell的数据&quot;&gt;和shell交互：向perl命令行传递来自shell的数据&lt;/h2&gt;
&lt;p&gt;对于一行式命令，可能会想要将shell的变量、shell中命令的执行结果通过变量传递给perl命令。本人收集了几种方式，也许不全，但应该足够应付所有情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：通过环境变量&lt;code&gt;$ENV{VAR}&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;perl程序在运行时，会自动注册一个hash结构&lt;code&gt;%ENV&lt;/code&gt;，它收集来自shell的环境变量。例如读取shell的PATH环境变量、查看当前所使用的SHELL。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e 'print &quot;$ENV{PATH}\n&quot;'
$ perl -e 'print &quot;$ENV{SHELL}\n&quot;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，想要获取shell的变量，可以先将其导出为环境变量，再从&lt;code&gt;%ENV&lt;/code&gt;中获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ export name=&quot;longshuai&quot;
$ perl -e 'print &quot;$ENV{name}\n&quot;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式二：将perl -e 'xxxx'的单引号拆开重组，直接将需要被shell解析的东西暴露给shell去解释&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ name=longshuai
$ perl -e 'print &quot;'$name'\n&quot;'
longshuai&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面分成三部分&lt;code&gt;'print &quot;'&lt;/code&gt;是一部分，&lt;code&gt;$name&lt;/code&gt;是一部分，它没有被任何引号包围，所以直接暴露给shell进行变量替换，&lt;code&gt;'\n&quot;'&lt;/code&gt;是最后一部分。&lt;/p&gt;
&lt;p&gt;这种方式需要对shell的引号解析非常熟练，对sed来说这种写法有时候是必要的，因为这是sed和shell交互的唯一方式，但对于perl命令行来说，没有必要这样写，因为可读性太差，且很难写，一般人真的不容易写不来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式三：将变量放入参数位置，使其收集到ARGV数组中，然后在perl表达式中shift这些数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ name=longshuai
$ age=23
$ perl -e '
        $name = shift;
        $age = shift;
        print &quot;$name,$age\n&quot;' $name $age
longshuai,23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面的shift没有给定参数，所以shift会使用默认变量。由于shift期待的操作对象是一个数组(列表)，且不是在子程序内部(子程序内部表示在sub语句块内)，所以使用默认数组&lt;code&gt;@ARGV&lt;/code&gt;。也就说上面的代码等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $name = shift @ARGV;
        $age = shift @ARGV;
        print &quot;$name,$age\n&quot;' $name $age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式四：使用perl -s选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;perl的-s选项允许解析&lt;code&gt;--&lt;/code&gt;之后的&lt;code&gt;-xxx=yyy&lt;/code&gt;格式的开关选项。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e 'xxxxx' -- -name=abc -age=23 a.txt b.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;--&lt;/code&gt;之后的参数，它们本该会被收集到ARGV中，但如果开启了-s选项，这些参数部分如果是&lt;code&gt;-xxx=yyy&lt;/code&gt;格式的，则被解析成perl的变量&lt;code&gt;$xxx&lt;/code&gt;并赋值为yyy，而那些不是&lt;code&gt;-xxx=yyy&lt;/code&gt;格式的参数则被收集到ARGV数组中。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -se '
        print &quot;ARGV: @ARGV\n&quot;;
        print &quot;NAME &amp;amp; AGE: $name,$age\n&quot;;
        ' -- -name=&quot;longshuai&quot; -age=23 abc def
ARGV: abc def
NAME &amp;amp; AGE: longshuai,23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面传递的参数是&lt;code&gt;-name=&quot;longshuai&quot; -age=23 abc def&lt;/code&gt;，因为开启了-s选项，所以解析了两个perl变量&lt;code&gt;$name=longshuai $age=23&lt;/code&gt;，另外两个&lt;code&gt;bac def&lt;/code&gt;则被收集到ARGV数组中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式五：杜绝使用shell，完全替代为perl。在perl中反引号或qx()也支持运行shell程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ name=longshuai
$ perl -e '
        $name = qx(echo \$name);
        print &quot;name in perl: $name&quot;'
name in perl: longshuai

$ perl -e '
        $time = qx(date +&quot;%T&quot;);
        print &quot;time in perl: $time&quot;'
time in perl: 19:52:39&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面&lt;code&gt;qx(echo \$name)&lt;/code&gt;的反斜线不可少，否则&lt;code&gt;$name&lt;/code&gt;会被perl解析，转义后才可以保留$符号被shell解析。&lt;/p&gt;

&lt;h2 id=&quot;perl读写文件&quot;&gt;Perl读写文件&lt;/h2&gt;
&lt;p&gt;一行式perl程序的重头戏自然是处理文本数据，所以有必要解释下Perl是如何读、写数据的。&lt;/p&gt;

&lt;h3 id=&quot;读取标准输入stdin&quot;&gt;读取标准输入&amp;lt;STDIN&amp;gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;符号表示从标准输入中读取内容，如果没有，则等待输入。&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;读取到的结果中，一般来说都会自带换行符(除非发生意外，或EOF异常)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '$name=&amp;lt;STDIN&amp;gt;;print &quot;your name is: $name&quot;;'
longshuai     # 这是我输入的内容
your name is: longshuai   # 这是输出的内容&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为读取的是标准输入，所以来源可以是shell的管道、输入重定向等等。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ echo &quot;longshuai&quot; | perl -e '$name=&amp;lt;STDIN&amp;gt;;print &quot;yourname is: $name&quot;;'
your name is: longshuai&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在比如，判断行是否为空行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $line=&amp;lt;STDIN&amp;gt;;
        if($line eq &quot;\n&quot;){
            print &quot;blank line\n&quot;;
        } else {
            print &quot;not blank: $line&quot;
        }'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;每次只读取一行，遇到换行符就结束此次读取。使用while循环可以继续向后读取，或者将其放在一个需要列表的地方，也会一次性读取所有内容保存到列表中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 每次只读一行
$ echo -e &quot;abc\ndef&quot; | perl -e '$line=&amp;lt;STDIN&amp;gt;;print $line;'
abc

# 每次迭代一行
$ echo -e &quot;abc\ndef&quot; | perl -e 'while(&amp;lt;STDIN&amp;gt;){print}'
abc
def

# 一次性读取所有行保存在一个列表中
$ echo -e &quot;abc\ndef&quot; | perl -e 'print &amp;lt;STDIN&amp;gt;'
abc
def&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外需要注意的是，如果将&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;显示保存在一个数组中，因为输出双引号包围的数组各元素是自带空格分隔的，所以换行符会和空格合并导致不整齐。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ echo -e &quot;abc\ndef&quot; | perl -e '@arr=&amp;lt;STDIN&amp;gt;;print &quot;@arr&quot;'
abc
 def&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法是执行一下chomp()或chop()操作，然后在输出时手动指定换行符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ echo -e &quot;abc\ndef&quot; | perl -e '@arr=&amp;lt;STDIN&amp;gt;;chomp @a;print &quot;@arr\n&quot;'
abc def&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;读取文件输入&quot;&gt;读取文件输入&amp;lt;&amp;gt;&lt;/h3&gt;
&lt;p&gt;使用两个尖括号符号&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;表示读取来自文件的输入，例如从命令行参数&lt;code&gt;@ARGV&lt;/code&gt;中传递文件作为输入源。这个符号被称为&quot;钻石操作符&quot;。&lt;/p&gt;
&lt;p&gt;例如读取并输出/etc/passwd和/etc/shadow文件，只需将它们放在表达式的后面即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        while(&amp;lt;&amp;gt;){
            print $_;  # 使用默认变量
        }' /etc/passwd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以直接在perl程序中指定ARGV数组让&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;读取，是否还记得&lt;code&gt;$ARGV&lt;/code&gt;变量表示的是当前正在读取的文件？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e '@ARGV=qw(/etc/passwd);while(&amp;lt;&amp;gt;){print}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，只需要&lt;code&gt;while(&amp;lt;&amp;gt;)&lt;/code&gt;中一次次的读完所有行就可以。但有时候会想要在循环内部继续读取下一行，就像sed的n和N命令、awk的next命令一样。这时可以单独在循环内部使用&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;，表示继续读取一行。&lt;/p&gt;
&lt;p&gt;例如，下面的代码表示读取每一行，但如果行首以字符串abc开头，则马上读取下一行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl -e '
        while(&amp;lt;&amp;gt;){
            if($_ =~ /^abc/){
                &amp;lt;&amp;gt;;
            }
            ...
        }'&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;文件句柄&quot;&gt;文件句柄&lt;/h3&gt;
&lt;p&gt;其实&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;是两个特殊的文件读取方式。如果想要以最普通的方式读取文件，需要打开文件句柄，然后使用&lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;读取对应文件的数据。&lt;/p&gt;
&lt;p&gt;打开文件以供读取的方式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open FH, &quot;&amp;lt;&quot;, &quot;/tmp/a.log&quot;
open $fh, &quot;/tmp/a.log&quot;     # 与上面等价&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件句柄名一般使用大写字母(如FH)或者直接使用变量(如$fh)。&lt;/p&gt;
&lt;p&gt;然后读取即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while(&amp;lt;FH&amp;gt;){...}
while(&amp;lt;$fh&amp;gt;){...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e 'open FH,&quot;/etc/passwd&quot;;while(&amp;lt;FH&amp;gt;){print}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了打开文件句柄以供读取，还可以打开文件句柄以供写入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open FH1,&quot;&amp;gt;&quot;,&quot;/tmp/a.log&quot;;   # 以覆盖写入的方式打开文件/tmp/a.log
open FH2,&quot;&amp;gt;&amp;gt;&quot;,&quot;/tmp/a.log&quot;;  # 以追加写入的方式打开文件/tmp/a.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要写入数据到文件，直接使用print、say、printf即可，只不过需要在这些函数的第一个参数位上指定输出的目标。默认目标为STDOUT，也就是标准输出。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print FH1,&quot;hello world\n&quot;;
say   FH,&quot;hello world\n&quot;;
printf FH1,&quot;hello world\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在向文件句柄写入数据时，如果使用的是变量形式的文件句柄，那么print/say/printf可能会无法区分这个变量是文件句柄还是要输出的内容。所以，应当使用&lt;code&gt;{$fh}&lt;/code&gt;的形式避免歧义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print {$fh},&quot;hello world\n&quot;;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;正则表达式匹配和替换&quot;&gt;正则表达式匹配和替换&lt;/h2&gt;
&lt;p&gt;本文通篇都不会深入解释Perl正则，因为内容太多了，而且我已经写好了一篇从0基础到深入掌握Perl正则的文章&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9648439.html&quot;&gt;Perl正则表达式超详细教程&lt;/a&gt;以及&lt;code&gt;s///&lt;/code&gt;替换的文章&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9655273.html&quot;&gt;Perl的s替换命令&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于学习perl一行式程序来说，无需专门去学习Perl正则，会基础正则和扩展正则足以。虽不用专门学Perl正则，但有必要知道Perl的正则是如何书写的。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;str =~ m/reg/&lt;/code&gt;符号表示要用右边的正则表达式对左边的数据进行匹配。正则表达式的书写方式为&lt;code&gt;m//&lt;/code&gt;或&lt;code&gt;s///&lt;/code&gt;，前者表示匹配，后者表示替换。关于&lt;code&gt;m//&lt;/code&gt;或&lt;code&gt;s///&lt;/code&gt;，其中斜线可以替换为其它符号，规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;双斜线可以替换为任意其它对应符号，例如对称的括号类，&lt;code&gt;m()&lt;/code&gt;、&lt;code&gt;m{}&lt;/code&gt;、&lt;code&gt;s()()&lt;/code&gt;、&lt;code&gt;s{}{}&lt;/code&gt;、&lt;code&gt;s&amp;lt;&amp;gt;&amp;lt;&amp;gt;&lt;/code&gt;、&lt;code&gt;s[][]&lt;/code&gt;，相同的标点类，&lt;code&gt;m!!&lt;/code&gt;，&lt;code&gt;m%%&lt;/code&gt;、&lt;code&gt;s!!!&lt;/code&gt;、&lt;code&gt;s###&lt;/code&gt;、&lt;code&gt;s%%%&lt;/code&gt;等等&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;只有当m模式采用双斜线的时候，可以省略m字母，即&lt;code&gt;//&lt;/code&gt;等价于&lt;code&gt;m//&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果正则表达式中出现了和分隔符相同的字符，可以转义表达式中的符号，但更建议换分隔符，例如&lt;code&gt;/http:\/\//&lt;/code&gt;转换成&lt;code&gt;m%http://%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以要匹配/替换内容，有以下两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方式一：使用&lt;code&gt;data =~ m/reg/&lt;/code&gt;、&lt;code&gt;data =~ s/reg/rep/&lt;/code&gt;，可以明确指定要对data对应的内容进行正则匹配或替换&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;方式二：直接&lt;code&gt;/reg/&lt;/code&gt;、&lt;code&gt;s/reg/rep/&lt;/code&gt;，因为省略了参数，所以使用默认参数变量，它等价于&lt;code&gt;$_ =~ m/reg/&lt;/code&gt;、&lt;code&gt;$_ =~ s/reg/rep/&lt;/code&gt;，也就是对&lt;code&gt;$_&lt;/code&gt;保存的内容进行正则匹配/替换&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;匹配&quot;&gt;匹配&lt;/h3&gt;
&lt;p&gt;Perl中匹配操作返回的是匹配成功与否，成功则返回真，匹配不成功则返回假。当然，Perl提供了特殊变量允许访问匹配到的内容，甚至匹配内容之前的数据、匹配内容之后的数据都提供了相关变量以便访问。见下面的示例。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.匹配给定字符串内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $name = &quot;hello gaoxiaofang&quot;;
        if ($name =~ m/gao/){
            print &quot;matched\n&quot;;
        }'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，直接将字符串拿来匹配：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;hello gaoxiaofang&quot; =~ m/gao/;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.匹配来自管道的每一行内容，匹配成功的行则输出&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while (&amp;lt;STDIN&amp;gt;){
    chomp;
    print &quot;$_ was matched 'gao'\n&quot; if /gao/;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面使用了默认的参数变量&lt;code&gt;$_&lt;/code&gt;，它表示while迭代的每一行数据；上面还简写正则匹配方式&lt;code&gt;/gao/&lt;/code&gt;，它等价于&lt;code&gt;$_ =~ m/gao/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下是执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ echo -e &quot;malongshuai\ngaoxiaofang&quot; | perl -e &quot;
        while (&amp;lt;STDIN&amp;gt;){
        chomp;
        print qq(\$_ was matched 'gao'\n) if /gao/;
        }&quot;
gaoxiaofang was matched 'gao'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.匹配文件中每行数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while (&amp;lt;&amp;gt;){
    chomp;
    if(/gao/){
        print &quot;$_ was matched 'gao'\n&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;替换&quot;&gt;替换&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;s///&lt;/code&gt;替换操作是原地生效的，会直接影响原始数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str = &quot;ma xiaofang or ma longshuai&quot;;
$str =~ s/ma/gao/g;
print &quot;$str\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;s///&lt;/code&gt;的返回值是替换成功的次数，没有替换成功返回值为0。所以，&lt;code&gt;s///&lt;/code&gt;自身可以当作布尔值进行判断，如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(s/reg/rep/){
    print &quot;$_\n&quot;;
}

print &quot;$_\n&quot; if s/reg/rep/

while(s/reg/rep/){
        ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要直接输出替换后得到的字符串，可以加上&lt;code&gt;r&lt;/code&gt;修饰符，这时它不再返回替换成功的次数，而是直接返回替换后的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ perl -e '
        $str = &quot;ma xiaofang or ma longshuai&quot;;
        print $str =~ s/ma/gao/gr,&quot;\n&quot;;'
gao xiaofang or gao longshuai&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 03 Jan 2019 15:41:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>本文是针对没有Perl基础，但想用perl一行式命令取代grep/awk/sed的人，用于速学Perl基础知识。 Perl一行式系列文章：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10217597.html</dc:identifier>
</item>
<item>
<title>常见爬虫/BOT对抗技术介绍（一） - THISISPAN</title>
<link>http://www.cnblogs.com/panxuejun/p/10217590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panxuejun/p/10217590.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/330611/201901/330611-20190103233656052-304603441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;爬虫，是大家获取互联网公开数据的有效手段。爬虫、反爬虫技术、反-反爬虫技术随着互联网的不断发展，也在不断发展更新， 本文简要介绍现代的爬虫/BOT对抗技术，如有疏漏，多谢指正！&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;1.1 Robots.txt&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Robots.txt是一个古老的爬虫协议文件，他的位置位于域名根目录下。譬如&lt;a href=&quot;https://link.jianshu.com/?t=http://example.com/robots.txt&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;http://example.com/robots.txt&lt;/a&gt; 。 严格来讲Robots.txt并不算一个反爬虫技术，而是一个由爬虫遵守的协议。它通过几个简单的命令告知遵守Robots.txt的爬虫哪些可以被爬取，哪些不能。一般的搜索引擎爬虫会遵守这个协议，而对于上升到爬虫技术对抗的层次来说，这个文件毫无意义。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.2 IP层/网络层&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;网络层是反爬虫技术涉及到的最下层，再下的链路层信息在IP报文的传输过程中会被三层交换机丢弃，没有任何意义。IP报文带有的最重要的信息就是IP请求的来源地址， 来源地址极难（近乎不可能）伪造的特性， 使得这个字段成为反爬虫策略中最重要的字段。 封杀IP/IP段是网站可以执行的最严厉的惩罚。由于国内的ISP大量的使用了NAT技术，导致大量用户共用IP的情况越来越多， 内容提供方在做IP封杀时会越来越谨慎， 因为这样做会导致极高的误杀率，以至影响正常用户的网站访问。 但是即使如此， 源IP也是反爬虫策略中最为核心的数据，反爬策略的执行动作一般都要围绕源IP进行。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.3 HTTP层&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;HTTP协议层有几个有趣的HTTP头，它们是制定反爬虫策略的常用数据。&lt;/p&gt;
&lt;h5&gt;1.3.1 X-Forwarded-For&lt;/h5&gt;
&lt;p&gt;X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。 Squid 缓存代理服务器的开发人员最早引入了这一HTTP头字段，并由IETF在HTTP头字段标准化草案中正式提出。&lt;br/&gt;XFF头由普通HTTP代理服务器添加， 在用户通过普通HTTP代理访问网站时， 用户的IP地址会被添加到这个头中。 一些新手程序员在写代码时，往往会把这个的IP地址当做用户的真实IP地址使用，从而被爬虫利用。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.3.2 Referer&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;Referer是浏览器在页面跳转时带入的HTTP头，指示用户上一个页面的URL， 一般来说，网站90%以上的流量应该带有Referer头， 在一些常见的反爬策略中， 大量的不带Referer头的源IP请求会触发&quot;要求输入验证码&quot;策略。&lt;/p&gt;
&lt;h5&gt;&lt;strong&gt;1.3.3 User-Agent&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;User-Agent 是一个古老的HTTP头，指示用户浏览器的版本、操作系统等基本信息， UserAgent伪装已经在其他的文章里有过充分的讨论，故本文不再赘述。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4 应用层/浏览器层&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;在HTTP层之上是应用层，HTTP层上的数据最终会交由浏览器或者APP去渲染、执行。 本文重点讨论基于现代浏览器的应用层反爬、及反反爬技术。&lt;/p&gt;
&lt;h5&gt;&lt;strong&gt;1.4.1 应用层反爬虫/BOT技术简介&lt;/strong&gt;&lt;/h5&gt;
&lt;h5&gt;1.4.1.1 验证码&lt;/h5&gt;
&lt;p&gt;验证码（CAPTCHA）是一种古老而有效的方式，用来判别请求方是否是人类。从最初的简单数字验证码、到后来的中文验证码，到现代的图片验证码， 验证码是应用层最普遍，也最核心的爬虫对抗技术。 对于一些简单的数字、字母验证码， 随着近几年机器学习、神经网络的快速发展，已经近乎于无效。有人训练出基于LSTM的模型可以达到80~90%的识别正确率。 对于图片验证码， 也有灰产专门用人工打码平台来处理，所以单凭验证码很难有效处理爬虫问题， 过多的验证码也会导致正常用户的体验受到影响。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.2 JS渲染(Ajax / SPA)&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;众所周知， Ajax技术在2004年左右开始迅速发展，成为重要的浏览器端技术， 也让爬虫从静态爬虫转化为动态爬虫。 从此，爬取网站的数据不再是简单的一个HTTP请求， 然后解析HTML页面就可以了。大量的网站使用ajax来构建网站前端，也使得解析数据变得越来越困难。 在网站完全不设防的状态，爬虫也不止需要解析HTML页面， 亦需要解析Ajax接口返回的数据。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.3 接口加密与JS混淆&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;一般Ajax接口返回的是一个JSON/XML数据格式，除了给爬虫工程师制造一点点的麻烦以外，并没有任何的反爬虫作用，  只需一点点的前端逆向能力（利用Chrome Debug工具， 找到网络请求），就可以找到ajax接口，并通过对应的库解析出数据。但是如果前端通过JS混淆、并把ajax接口通过token进行加密的话，事情就变得比较麻烦了。 这种做法的思路是， ajax接口除了正常的HTTP请求参数外，额外还要接受一个Token参数，这个token参数是前端的js脚本通过其他的参数加密出来的， 它可能是xor、md5、或者是sha256等等。参数可以是用户名、ip、cookies的sessionid、甚至是用户的操作流程（支付宝的做法）再加上前端把js的函数调用层层嵌套、隐藏、 再加上js脚本混淆，令破解者无法方便的逆向出token计算的流程， 就可以达到一定的反爬目的。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.4 数据混淆&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;爬虫的目的是获取到有效的数据。对于许多应用来说，获取到错误的数据往往比获取不到数据更加致命。（想象一下比价网站拿到的都是错误数据的场景）。这个思路的核心就是，当爬虫命中反爬规则之后，使用错误的数据代替正确的数据返回给爬虫， 这种方式非常隐蔽，又可以对对手造成足够的麻烦， 可以说非常的猥琐、也相当的有效。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.5 行为分析&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;用户的操作轨迹与爬虫的操作轨迹是不同的。举个例子， 在电商网站上，用户可能会浏览100个或者更多相似的商品，最终选择一个进行下单。而爬虫的行为可能是浏览100000个商品，且它们之间彼此关联度很低， 最终也不会有任何购买动作。从这个维度来说，就可以判断出这个请求来源是客户还是爬虫。 结合其他的反爬手段，就可以对爬虫造成有效干扰。低级的行为分析基于规则，高级的行为分析基于机器学习。 对于用户操作比较多的网站来讲，是一种很可靠的反爬手段。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.6 存储跟踪与flash Storage&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;Cookies是众所周知的浏览器保持状态的一种机制。 除了Cookies，现代的浏览器还支持localStorage。以目前国内用户的使用习惯，绝大多数用户不会设置拒绝Cookies保持。所以，拒绝Cookies跟踪的客户端可以认为就是爬虫。通过Cookies，就可以跟踪用户的行为轨迹。 除此之外，如果用户使用浏览器模拟技术，一定在每次请求时会清空Cookies。 Cookies被清空之后，我们仍然有机会使用flash来继续跟踪用户。今天的(2017年)Flash确实是一个夕阳技术，但仍然保持极高的市场占用率，在PC端，90%以上的国内视频网站依然采用flash作为播放器的客户端。所以，一个以PC端流量为主的网站，可以使用flash来进行用户跟踪。值得高兴的是，在flash插件中，通过Capabilities.serverString可以获取到非常多的系统信息，包括操作系统、语言、系统分辨率、DPI等等等等。这些系统信息与JS上下文、UserAgent、用户访问日志进行一起分析，就可以判断是否是伪装为爬虫的浏览器。举个例子，如果是正常的用户， 从flash、js上下文、useragent拿到的参数应该是一致的，而如果伪造过UA（不那么高明的伪造），则肯定会有纰漏。正所谓一个谎言需要用十个谎言去掩盖。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.7 navigator对象&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;浏览器中的window.navigator对象保持了很多的操作系统、浏览器信息。navigator对象的信息配合Useragent、flash，可以用来判断是否是伪装浏览器。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.8 假链陷阱&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;假链陷阱作为反爬手段，多见于半静态网站。 它的思路主要是构建一个不可见的a标签， 如果爬虫跟踪所有的页面链接，势必会掉到构造好的陷阱，导致爬虫命中反爬策略。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.9 浏览器指纹&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;浏览器指纹技术常用于客户端跟踪及反机器人的场景。核心思路是， 不同浏览器、操作系统、以及操作系统环境，会使得canvas的同一绘图操作流程产生不同的结果。如果是相同的运行环境，同一套Canvas操作流程会产生相同的结果。 浏览器指纹的优势是不需要浏览器保持本地状态，即可跟踪浏览器。  由于国内特色的Ghost系统安装，这种方式的误杀率并不低，&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.1.10 JS引擎指纹&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;这种思路是，不同的JS引擎在执行相同的JS语句时，会有不同的结果。 举个例子来说，eval.toString().length，在Safari浏览器中的结果是 37 , 在IE中是39 , 在Chrome 中的结果是33. 通过判断JS引擎的动作和UserAgent中声称的浏览器类型，可以判断是否是伪造浏览器。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.4.2 应用层反反爬虫/BOT方案简介&lt;/strong&gt;&lt;/h3&gt;
&lt;h5&gt;1.4.2.1 前端逆向&lt;/h5&gt;
&lt;p&gt;前端逆向，就是利用前端所有代码、数据都是暴露给客户端的特点， 通过分析HTML、JS等源码来获取数据的技术。 常用的前端逆向工具就是Chrome Debug 工具。前端逆向分析通常用来分析那些动态渲染的网站。 如果分析透彻，可以避免使用浏览器模拟的方式来进行爬取。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.2.2 浏览器模拟&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;浏览器模拟指利用真实的浏览器去请求、执行页面和脚本。应用场景是爬取带有复杂JS和接口加密的网站、也被BOT用于复杂网站。常见的浏览器模拟框架有Selenium WebDriver、 PhatomJS。 Selenium 是通过浏览器的debug接口进行浏览器的远程操控API。PhantomJS是一个嵌入了浏览器内核的js渲染服务，这种技术可以用来对抗动态渲染和接口加密。所有的渲染和加密过程都由浏览器内核完成。 高级的做法是用CEF(Chrome Embedded Framework)进行二次开发。通过二次开发CEF，可以获得很强的灵活性， 比如在页面加载之前劫持JS对象、用C++代码hook native js api等等。这种技术的主要劣势是低下的性能。 与纯粹的HTTP请求代码来说， 这种方案要多吃50~500倍的CPU。 也就是说， 它的效率要下降数十倍到数百倍左右。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.2.2 字符识别&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;光学字符识别（OCR）用于对抗简单的数字、字母验证码。初级的OCR基于模板。高级的字符识别基于神经网络，比如[这个项目]，它基于LSTM模型，可以提供更好的识别率。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.2.4 行为模拟&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;行为模拟是指在爬虫和BOT的过程中，有意的留下Cookie，并请求一些与需要爬取数据无关的接口或者做一些动作，用来模拟一般用户的动作， 用于对抗行为分析。 在BOT场景下，这种方式也用来模拟用户的活跃度和留存率。 一般来说，行为模拟的主要依据来源于前端逆向的工作， 破解者需要确定究竟有哪些HTML元素和用户行为事件被网站所关注，并针对性的做出想要模拟的行为。 大多数情况下，爬虫的行为模拟是请求某个日志上报接口， 而一些比较特殊的网站（比如支付宝）， 用户行为数据附着在请求普通接口的参数中，并经过高度混淆。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.2.6 打码平台&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;打码平台用来对抗强度比较高的验证码和人机验证方案。正常的验证码流程是，由网站生成一张图片传递给用户，用户输入这张图片的信息传回网站，完成人机验证。 破解者通过对接打码平台，将用户识别信息的环节放到打码平台去做，打码平台组织一群专职人员，进行验证码的识别工作，并传回爬虫，完成验证码的识别工作。高级的打码平台还会利用这些海量的打码数据进行模型训练。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;1.4.2.7 JS Hook&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;这种方式主要用来对抗js上下文的跟踪和分析。做法是，在页面加载前，通过替换JS上下文的对象，将JS上下文中的对象和方法替换掉。 例如，将window.screen对象替换， 使网站的js代码获取到替换后的屏幕分辨率。 JS Hook一般在CEF二次开发中实现，也可以通过劫持普通浏览器的流量完成js hook。&lt;/p&gt;



&lt;h3&gt;&lt;strong&gt;2.1 代理服务器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对于爬虫的客户端编程来说，利用代理服务器进行源IP更改，是最简单易行的方式。 代理服务器分为HTTP代理和Socks代理两类。HTTP又分为HTTP和HTTPS代理， Socks又分为Socks4和Socks5两类。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;2.2.1 HTTP代理&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;HTTP代理是一种常见的代理服务类型。常用80、8080端口， 它的协议在RFC 7230 中定义。  对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。 根据XFF头部的添加与否， 分为普通代理和高匿代理两类。 普通代理会把请求方的源IP添加在HTTP请求头， 而高匿代理不会。对于服务端程序员来说，通过XFF头判断用户的源IP来源是一种十分 Too Young , sometimes naive 的行为，因为服务端完全没有能力判断这个XFF头是由请求方伪造的，还是由代理服务器添加的。 网上流传的一些Java代码，会首先判断XFF头，如果有则将XFF头作为源IP处理，这种方式基本没有任何反爬虫作用。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;2.2.2 Socks代理&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;SOCKS是另外一种常见的代理服务。SOCKS是&quot;SOCKetS&quot;的&lt;a href=&quot;https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;缩写&lt;/a&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/SOCKS#endnote_abbr&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;[1]&lt;/a&gt;。这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到版本4。最新协议是版本5，与前一版本相比，增加支持&lt;a href=&quot;https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;UDP&lt;/a&gt;、验证，以及&lt;a href=&quot;https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/IPv6&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;IPv6&lt;/a&gt;。根据&lt;a href=&quot;https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;OSI模型&lt;/a&gt;，SOCKS是&lt;a href=&quot;https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;会话层&lt;/a&gt;的协议，位于&lt;a href=&quot;https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%B1%82&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;表示层&lt;/a&gt;与&lt;a href=&quot;https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;传输层&lt;/a&gt;之间。 也就是说，Socks通过TCP连接作为隧道进行代理。 Socks代理中，Socks5代理最为常见。&lt;/p&gt;

&lt;p&gt;接下来我会介绍其他的的IP层反-反爬虫方案。&lt;/p&gt;
&lt;p&gt;目录如下&lt;/p&gt;
&lt;p&gt;2.2 VPN&lt;br/&gt;2.3.1 简单 VPN&lt;br/&gt;2.3.2 混合网络VPN&lt;/p&gt;
&lt;p&gt;2.3 VPS&lt;br/&gt;2.4 单机PPP拨号&lt;br/&gt;2.5 并发PPP拨号&lt;/p&gt;
&lt;p&gt;三、并发PPP连接技术简介&lt;br/&gt;3.1 PPP协议栈简单介绍&lt;br/&gt;3.2 PPP连接和ADSL的关系&lt;br/&gt;3.3 城域网技术简介&lt;br/&gt;3.4 并发PPP连接方案的适用范围&lt;br/&gt;3.5 国内并发PPP连接服务提供商&lt;/p&gt;
&lt;p&gt;四、Linux路由&lt;br/&gt;4.1 Linux基础路由简介&lt;br/&gt;4.2 Linux高级路由简介&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;综上所述，使用代理IP是解决反扒机制的最佳解决方案，也是最简单有效的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为此，我个人研发了一款代理IP池项目，现欢迎大家内测体验~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传送门：www.2808proxy.com&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决爬虫的IP源问题。&lt;/p&gt;

</description>
<pubDate>Thu, 03 Jan 2019 15:38:00 +0000</pubDate>
<dc:creator>THISISPAN</dc:creator>
<og:description>爬虫，是大家获取互联网公开数据的有效手段。爬虫、反爬虫技术、反-反爬虫技术随着互联网的不断发展，也在不断发展更新， 本文简要介绍现代的爬虫/BOT对抗技术，如有疏漏，多谢指正！ 一、反爬虫/BOT技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/panxuejun/p/10217590.html</dc:identifier>
</item>
<item>
<title>使用if语句时应注意的问题（初学者） - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10217437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10217437.html</guid>
<description>&lt;p&gt;（1）在三种形式的if语句中，在if关键字之后均为表达式。该表达式通常是逻辑表达式或关系表达式，但也可以是其他表达式，如赋值表达式等，甚至也可以是一个变量。&lt;/p&gt;
&lt;p&gt;例：if(a=5)语句；&lt;/p&gt;
&lt;p&gt;       if(b)语句；&lt;/p&gt;
&lt;p&gt;只要表达式的值为非零，即为“真”。&lt;/p&gt;
&lt;p&gt;比较：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a=&lt;span&gt;b)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a==&lt;span&gt;b)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注;若if后的a==5输入成a=5，则输出结果永远为真。&lt;/p&gt;
&lt;p&gt;如何避免：将a==5改为5==a（习惯上的改变，这只是一个例子）&lt;/p&gt;
&lt;p&gt;（2）在if语句中，条件判断表达式必须用括号括起来，在语句之后必须加分号。&lt;/p&gt;
&lt;p&gt;（3）在if语句的三种形式中，所有的语句应为单个语句，如果想要在满足条件时执行一组（多个语句），则必须把这一组语句用{}括起来组成一个复合语句。但要注意的是在}后不能再加；号。（建议单个语句也用{}括起来，方便以后插入新语句）&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a&amp;gt;&lt;span&gt;b)
    {
        a&lt;/span&gt;++&lt;span&gt;;
        b&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        a&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        b&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d,%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a,b);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补例1：写一个程序完成下列功能：&lt;/p&gt;
&lt;p&gt;1、输入一个分数score；&lt;/p&gt;
&lt;p&gt;2、score&amp;lt;60　　　　　　输出E&lt;/p&gt;
&lt;p&gt;3、60&amp;lt;=score&amp;lt;70             输出D&lt;/p&gt;
&lt;p&gt;4、70&amp;lt;=score&amp;lt;80　　　  输出C&lt;/p&gt;
&lt;p&gt;5、80&amp;lt;=score&amp;lt;90             输出B&lt;/p&gt;
&lt;p&gt;6、90&amp;lt;=score 　　　　　输出A&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; score;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input a score\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;score);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(score&amp;lt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The score is E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((score&amp;gt;&lt;span&gt;60&lt;/span&gt; || score==&lt;span&gt;60&lt;/span&gt;)&amp;amp;&amp;amp;score&amp;lt;&lt;span&gt;70&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The score is D &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((score&amp;gt;&lt;span&gt;70&lt;/span&gt; || score==&lt;span&gt;70&lt;/span&gt;)&amp;amp;&amp;amp;score&amp;lt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The score is C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((score&amp;gt;&lt;span&gt;80&lt;/span&gt; || score==&lt;span&gt;80&lt;/span&gt;)&amp;amp;&amp;amp;score&amp;lt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;)
    { 
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The score is B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(score&amp;gt;&lt;span&gt;90&lt;/span&gt;||score==&lt;span&gt;90&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The score is A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补例2：输入3个数a,b,c,要求按由小到大的顺序输出。&lt;/p&gt;
&lt;p&gt;提示：if　　a&amp;gt;b　　将a和b互换；&lt;/p&gt;
&lt;p&gt;　　   if　　a&amp;gt;c　　将a和c互换；&lt;/p&gt;
&lt;p&gt;　　   if　　b&amp;gt;c　　将b和c互换；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b,c,temp;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input three numbers\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;&lt;span&gt;c);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a&amp;gt;&lt;span&gt;b)
    {
        temp&lt;/span&gt;=&lt;span&gt;a;
        a&lt;/span&gt;=&lt;span&gt;b;
        b&lt;/span&gt;=&lt;span&gt;temp;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a&amp;gt;&lt;span&gt;c)
    {
        temp&lt;/span&gt;=&lt;span&gt;a;
        a&lt;/span&gt;=&lt;span&gt;c;
        c&lt;/span&gt;=&lt;span&gt;temp;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b&amp;gt;&lt;span&gt;c)
    {
        temp&lt;/span&gt;=&lt;span&gt;b;
        b&lt;/span&gt;=&lt;span&gt;c;
        c&lt;/span&gt;=&lt;span&gt;temp;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d %d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a,b,c);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 03 Jan 2019 15:16:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>（1）在三种形式的if语句中，在if关键字之后均为表达式。该表达式通常是逻辑表达式或关系表达式，但也可以是其他表达式，如赋值表达式等，甚至也可以是一个变量。 例：if(a=5)语句； if(b)语句；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10217437.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.2 基础知识(四) URL重写中间件 - 热敷哥</title>
<link>http://www.cnblogs.com/refuge/p/10213596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refuge/p/10213596.html</guid>
<description>&lt;p&gt;说到URL重写就不得不提URL重定向.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;URL重定向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;URL重定向是客户端操作,指示客户端访问另一个地址的资源.这需要往返服务器,并且当客户端对资源发出请求时,返回客户端的重定向URL会出现在浏览器的地址栏中.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190103121529630-617427056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将请求重定向到不同的URL时,可指示重定向是永久的还是临时的.如果是永久的,则使用&quot;301&quot;状态码.收到&quot;301&quot;状态码时,客户端可能会缓存.如果是临时的,则使用&quot;302&quot;状态码,以使客户端将来不应存储和重用重定向URL.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;新建一个WebAPI项目;新增一个 TestController 控制器;在 Startup 类的 Configure 方法中增加如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            ...other codes
            &lt;/span&gt;&lt;span&gt;var options = new RewriteOptions();
       &lt;span&gt;     //options.AddRedirect(&quot;^redirect/(.*)&quot;, &quot;api/test&quot;);//默认状态码为 302&lt;/span&gt;
            options.AddRedirect(&quot;^redirect/(.*)&quot;, &quot;api/test&quot;, 301);
            app.UseRewriter(options);

            app.Run(async context =&amp;gt;
                {
                    //注意重定向和重写URL两种情况下,浏览器地址栏和页面显示的 URL 的区别.
                    await context.Response.WriteAsync($&quot;URL:{context.Request.Path + context.Request.QueryString}&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
                });&lt;/span&gt;

            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动该项目,在浏览器地址栏输入 : https://localhost:44303/redirect/123 后,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190103124030100-1671418801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看出,客户端一共请求了两次,浏览器地址栏变成了重定向的URL.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;URL重写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190103121837843-774502886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;URL重写是服务器端操作.重写URL不需要往返服务器,重写的URL也不会返回客户端,也不会出现在浏览器地址栏.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            ...other codes

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RewriteOptions();
            &lt;span&gt;options.AddRewrite(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;^rewrite/(.*)&quot;, &quot;api/test&quot;, true)&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写URL,false/true 表示如果当前规则适用,是否跳过其他重写规则.           &lt;/span&gt;
&lt;span&gt;            app.UseRewriter(options);

            app.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意重定向和重写URL两种情况下,浏览器地址栏和页面显示的 URL 的区别.&lt;/span&gt;
                    &lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;URL:{context.Request.Path + context.Request.QueryString}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                });

            app.UseMvc();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在浏览器地址栏输入 : https://localhost:44303/rewrite/1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190103202643022-1707267280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RewriteOptions 类型提供了一个 &lt;strong&gt;Add&lt;/strong&gt; 方法,接收一个委托.当请求地址符合一个规则后,方法传递的委托便会执行.这里以修改 reContext.Result 的值为例.示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            {
                RewriteOptions options &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RewriteOptions();
                options.AddRewrite(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^rewrite*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;).&lt;span&gt;Add(reContext =&amp;gt;
                {
                    reContext.Result =&lt;/span&gt;&lt;span&gt;&lt;span&gt; RuleResult.EndResponse;
                });&lt;/span&gt;
                app.UseRewriter(options);
                app.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; context =&amp;gt; { &lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(context.Request.Path +&lt;span&gt; context.Request.QueryString); });
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有请求地址符合规则时才会执行  app.Run(async context =&amp;gt; { await context.Response.WriteAsync(context.Request.Path + context.Request.QueryString); })  这句代码.&lt;/p&gt;
&lt;p&gt;测试图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190103214900768-1248908324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到,上面的请求不符合规则,页面上什么都没显示;&lt;/p&gt;
&lt;p&gt;下面的请求符合规则,页面显示出了重写后的请求路径. &lt;/p&gt;

&lt;p&gt;上面所有重写的示例中,重写的规则都是写在代码里面的,而ASP.NET Core 还提供了从文件中读取规则的方式.&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建一个文件夹 Rule ,添加一个 IISUrlRewrite.xml 文件,内容如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rewrite&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;MyIISUrlRewrite&quot;&lt;/span&gt;&lt;span&gt; stopProcessing&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;match &lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;=&quot;^rewrite/(.*)&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;还 没发现 appendQueryString = false 和 true 的区别&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;     
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Rewrite&quot;&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&quot;api/values/{R:1}&quot;&lt;/span&gt;&lt;span&gt; appendQueryString&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rewrite&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改 Configure 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            ......
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RewriteOptions();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法一:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;using (StreamReader sr = File.OpenText(Path.Combine(env.ContentRootPath, @&quot;Rule\IISUrlRewrite.xml&quot;)))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    options.AddIISUrlRewrite(sr);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    app.UseRewriter(options);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法二:&lt;/span&gt;
            var fileProvider = &lt;span&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(env.ContentRootPath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Rule&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            options.AddIISUrlRewrite(fileProvider, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IISUrlRewrite.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            app.UseRewriter(options);


            app.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(context.Request.Path +&lt;span&gt; context.Request.QueryString);
                });

            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图就不上了.&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 虽然还没用 ASP.NET Core 开发过任何项目,但是我觉得下面这种重写和重定向的方法或许会是用得最多的,因为它足够灵活.&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyRule : IRule
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以自定义构造函数,做一些验证
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public MyRule(string extension, string newPath)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (string.IsNullOrEmpty(extension))
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        throw new ArgumentException(nameof(extension));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (!Regex.IsMatch(extension, @&quot;^rewrite*&quot;))
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        throw new ArgumentException(&quot;Invalid extension&quot;, nameof(extension));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (!Regex.IsMatch(newPath, @&quot;(/[A-Za-z0-9]+)+?&quot;))
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        throw new ArgumentException(&quot;Invalid path&quot;, nameof(newPath));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    _extension = extension;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    _newPath = new PathString(newPath);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private readonly string _extension;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private readonly PathString _newPath;&lt;/span&gt;

        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _extension;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _newPath;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyRule(&lt;span&gt;string&lt;/span&gt; extension, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; newPath)
        {
            _extension &lt;/span&gt;=&lt;span&gt; extension;
            _newPath &lt;/span&gt;=&lt;span&gt; newPath;
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ApplyRule(RewriteContext context)
        {
            HttpRequest request &lt;/span&gt;=&lt;span&gt; context.HttpContext.Request;
            HttpResponse response &lt;/span&gt;=&lt;span&gt; context.HttpContext.Response;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以重写&lt;/span&gt;
            request.Path = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathString(_newPath);
            context.Result &lt;/span&gt;=&lt;span&gt; RuleResult.SkipRemainingRules;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以重定向
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (request.Path.Value.EndsWith(_extension, StringComparison.OrdinalIgnoreCase))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    response.StatusCode = StatusCodes.Status302Found;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    context.Result = RuleResult.EndResponse;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    response.Headers[HeaderNames.Location] = _newPath;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseHsts();
            }

&lt;span&gt;            RewriteOptions options &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new RewriteOptions();
            options.Add(new MyRule(&quot;rewrite&quot;,&quot;/api/test&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;));
            app.UseRewriter(options);&lt;/span&gt;

            app.UseHttpsRedirection();
            app.UseMvc();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 03 Jan 2019 15:15:00 +0000</pubDate>
<dc:creator>热敷哥</dc:creator>
<og:description>说到URL重写就不得不提URL重定向. URL重定向 URL重定向是客户端操作,指示客户端访问另一个地址的资源.这需要往返服务器,并且当客户端对资源发出请求时,返回客户端的重定向URL会出现在浏览器的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refuge/p/10213596.html</dc:identifier>
</item>
<item>
<title>工厂方法 Factory Method - _清风明月</title>
<link>http://www.cnblogs.com/blackteeth/p/10217509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blackteeth/p/10217509.html</guid>
<description>&lt;p&gt;背景：有一个应用框架，它可以向用户显示多个文档。在这个框架中，两个主要的抽象是类Application和Document.这两个类都是抽象的。客户必须通过它们的子类来做与举替应用相关的实现。&lt;/p&gt;
&lt;p&gt;分析：因为被实例化的特定Document子类是与特定应用相关的，所iApplication类不可能预测到那个Document子类将被实例化一一Application类仅直到一个新的文档何时应被创建，而不知道哪一种Document将被创建。这就&lt;span class=&quot;fontstyle0&quot;&gt;产生了一个尴尬的局面框架必须实例化类，但是它只知道不能被实例化的抽象类。&lt;br/&gt;&lt;/span&gt; 延迟实例化一一工厂方法：&lt;/p&gt;
&lt;p&gt;工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。&lt;/p&gt;
&lt;p&gt;需求：使用框架开发一款Word应用程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FactoryMethod
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文档抽象类，定义了文档的一般操作接口
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Document
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Open();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Close();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Save();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Revert();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   
&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FactoryMethod
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文档生产工厂，定义了生产文档的接口
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Document CreateDocument();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FactoryMethod
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Word:Document
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Close()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;关闭了一个Word文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Open()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开了一个Word文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Revert()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;恢复了一个Word文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Save()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;保存了一个Word文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FactoryMethod
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WordApp : Application
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Document CreateDocument()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Word();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FactoryMethod
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Application app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WordApp();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Document doc =&lt;span&gt; app.CreateDocument();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            doc.Open();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            doc.Revert();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            doc.Save();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            doc.Close();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/750720/201901/750720-20190103223211818-109919378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 新的需求：使用现有框架再开发一款Excel和PowerPoint应用程序。&lt;/p&gt;
&lt;p&gt;分析：方法一：分别增加对应的工厂子类和产品子类即可。&lt;/p&gt;
&lt;p&gt;方法二：参数化工厂，根据工厂接收的不同参数，返回不同的产品。（本人比较懒，这种方法要修改很现有多代码，放弃）&lt;/p&gt;
&lt;p&gt;方法三：使用泛型。&lt;/p&gt;
&lt;p&gt;这里我就采用泛型了，泛型的好处是不言而喻的，一次编写，永久使用，再多的产品使用这一个模板工厂就可以了。而且也不需要改变原有代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FactoryMethod
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; App&amp;lt;T&amp;gt; : Application &lt;span&gt;where&lt;/span&gt; T : Document,&lt;span&gt;new&lt;/span&gt;&lt;span&gt;() 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Document CreateDocument()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FactoryMethod
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Excel:Document
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Close()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;关闭了一个Excel文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Open()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开了一个Excel文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Revert()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;恢复了一个Excel文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Save()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;保存了一个Excel文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FactoryMethod
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PPT:Document
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Close()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;关闭了一个PPT文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Open()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开了一个PPT文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Revert()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;恢复了一个PPT文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Save()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;保存了一个PPT文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/750720/201901/750720-20190103231715393-1651744263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考资料《Design Patterns》&lt;/p&gt;
</description>
<pubDate>Thu, 03 Jan 2019 15:15:00 +0000</pubDate>
<dc:creator>_清风明月</dc:creator>
<og:description>背景：有一个应用框架，它可以向用户显示多个文档。在这个框架中，两个主要的抽象是类Application和Document.这两个类都是抽象的。客户必须通过它们的子类来做与举替应用相关的实现。 分析：因</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blackteeth/p/10217509.html</dc:identifier>
</item>
<item>
<title>2018北京交通大学区块链技术讲座 - BCSpark</title>
<link>http://www.cnblogs.com/BCSpark/p/10217441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BCSpark/p/10217441.html</guid>
<description>&lt;p&gt;BC Spark&lt;span&gt;致力于推进区块链技术和开源运动的融合，以一流高校为核心，建立起具有全球影响力的开发者社区。&lt;/span&gt;为了加深技术人才对区块链技术的了解和参与度，「北京交通大学软件学院&lt;span&gt;」联合「&lt;/span&gt;BC Spark&lt;span&gt;社区」「链得得」，发起「&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;交通大学区块链技术讲座」，为在校学生、开发者普及区块链知识，宣传区块链技术，打开了解区块链理论与行业最新实践的大门，深度参与到优秀区块链开源项目的学习和实践中去，为区块链行业输送新鲜血液。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1492406/201901/1492406-20190103225354138-584790589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 03 Jan 2019 14:56:00 +0000</pubDate>
<dc:creator>BCSpark</dc:creator>
<og:description>BC Spark致力于推进区块链技术和开源运动的融合，以一流高校为核心，建立起具有全球影响力的开发者社区。为了加深技术人才对区块链技术的了解和参与度，「北京交通大学软件学院」联合「BC Spark社区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BCSpark/p/10217441.html</dc:identifier>
</item>
<item>
<title>python爬虫常见面试题（一） - 天意凉</title>
<link>http://www.cnblogs.com/tianyiliang/p/10212951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianyiliang/p/10212951.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　之所以在这里写下python爬虫常见面试题及解答，一是用作笔记，方便日后回忆；二是给自己一个和大家交流的机会，互相学习、进步，希望不正之处大家能给予指正；三是我也是互联网寒潮下岗的那批人之一，为了找工作而做准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、题目部分&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;1-python中常用的数据结构有哪些请简要介绍一下&quot; data-source-line=&quot;2&quot;&gt;1、python中常用的数据结构有哪些？请简要介绍一下。&lt;/h5&gt;
&lt;h5 id=&quot;2-简要描述python中单引号-双引号-三引号的区别&quot; data-source-line=&quot;4&quot;&gt;2、简要描述python中单引号、双引号、三引号的区别。&lt;/h5&gt;
&lt;h5 id=&quot;3-如何在一个function里设置一个全局的变量&quot; data-source-line=&quot;6&quot;&gt;3、如何在一个function里设置一个全局的变量。&lt;/h5&gt;
&lt;h5 id=&quot;4-python里面如何拷贝一个对象赋值-浅拷贝-深拷贝的区别&quot; data-source-line=&quot;8&quot;&gt;4、python里面如何拷贝一个对象？（赋值、浅拷贝、深拷贝的区别）&lt;/h5&gt;
&lt;h5 id=&quot;5-如果custname字符串的编码格式为uft-8如何将custname的内容转化为gb18030的字符串&quot; data-source-line=&quot;10&quot;&gt;5、如果custname字符串的编码格式为uft-8,如何将custname的内容转化为gb18030的字符串？&lt;/h5&gt;
&lt;h5 id=&quot;6-请写出一段python代码实现删除list中的重复元素&quot; data-source-line=&quot;12&quot;&gt;6、请写出一段python代码实现删除list中的重复元素。&lt;/h5&gt;
&lt;h5 id=&quot;7-这两个参数是什么意思args和kwargs&quot; data-source-line=&quot;14&quot;&gt;7、这两个参数是什么意思？&lt;em&gt;args和 &lt;/em&gt;kwargs。&lt;/h5&gt;
&lt;h5 id=&quot;8&quot; data-source-line=&quot;16&quot;&gt;8、&lt;/h5&gt;
&lt;h5 id=&quot;1统计如下list单词及其出现的次数&quot; data-source-line=&quot;17&quot;&gt;（1）统计如下list单词及其出现的次数。&lt;/h5&gt;
&lt;p data-source-line=&quot;18&quot;&gt;a=['apple', 'banana', 'apple', 'tomato', 'orange', 'apple', 'banana', 'watermeton']&lt;/p&gt;
&lt;h5 id=&quot;2给列表中的字典排序例如有如下list对象&quot; data-source-line=&quot;20&quot;&gt;（2）给列表中的字典排序：例如有如下list对象：&lt;/h5&gt;
&lt;p data-source-line=&quot;21&quot;&gt;alist=[{&quot;name&quot;:&quot;a&quot;, &quot;age&quot;:20}, {&quot;name&quot;:&quot;b&quot;, &quot;age&quot;:30}, {&quot;name&quot;:&quot;c&quot;, &quot;age&quot;:25}] 将alist中的元素按照age从小到大排序。&lt;/p&gt;
&lt;h5 id=&quot;3写出下列代码的运行结果&quot; data-source-line=&quot;23&quot;&gt;（3）写出下列代码的运行结果&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = 1
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(a):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     a = 2
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;fun(a)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(a):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     a.append(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;fun(a)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lily&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;  
&lt;span&gt;4&lt;/span&gt; p1 =&lt;span&gt; Person()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; p2 =&lt;span&gt; Person()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; p1.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p1.name)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p2.name)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(Person.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、解答部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：以下答案，均为google后结合自己学所知识回答，可能会有不正确的地方，错误之处希望大家帮我指正出来，谢谢。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;1-python中常用的数据结构有哪些请简要介绍一下&quot; data-source-line=&quot;2&quot;&gt;1、python中常用的数据结构有哪些？请简要介绍一下。&lt;/h5&gt;
&lt;p&gt;python中常见的数据结构有：列表(list)，字典(dict)，元组(tuple)，字符串(string)，集合(set)，数字（int或long或float。。。）等。&lt;/p&gt;
&lt;p&gt;其中，列表，元祖和字符串可以统一归为序列类，即这三种数据结构中的元素是有序的。比如，他们都有索引（下标）操作，还有切片、相加和长度(len)，最大值(max)，最小值(min)操作。这是他们的共同点。&lt;/p&gt;
&lt;p&gt;补充：python中常见的数据结构可以统称为容器（container）。序列（如列表和元组）、映射（如字典）以及集合（set）是三类主要的容器。&lt;/p&gt;
&lt;p&gt;另外，关于这个问题，面试官很容易引出另一个问题：&lt;strong&gt;python中的哪些数据类型是可变的，哪些是不可变的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，可变/不可变是针对该对象所指向的内存中的值是否可变来判断的。如可变类型的数据类型有列表和字典。不可变类型的数据类型有字符串，元组，集合，数字。&lt;/p&gt;
&lt;p&gt;就举个最简单的数字的例子，python中有小整数池的概念，即[-5,256]范围内的整数，python解释器对他们做了特殊处理，都放在内存中的固定位置，不会因为你的操作二发生变化。&lt;/p&gt;
&lt;p&gt;现在：a = 1 ，然后我们又重新对a赋值，a = 2，在重新赋值的过程中，整数1所对应的内存地址没有和数字的大小都没有发生变化，还在内存中的固定位置。整数2也是如此。变化的是a的指针（这里引用C中的概念）从指向数字1变成数字2。a对象指向的内存中的值没有发生变化，因此数字是不可变类型的数据类型。字符串，集合也是同理。&lt;/p&gt;
&lt;h5 id=&quot;2-简要描述python中单引号-双引号-三引号的区别&quot; data-source-line=&quot;4&quot;&gt;2、简要描述python中单引号、双引号、三引号的区别。&lt;/h5&gt;
&lt;p&gt; 首先，单引号和双引号在使用时基本上没有什么区别，唯一需要注意的是：当字符串中有单引号时，最好在外面使用双引号；当有双引号时，最好在外面使用单引号。&lt;/p&gt;
&lt;p&gt;三引号一般不常用，除了用来做注释之外，还可以用来打印多行字符串。特殊用途，是可以打印多行字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;i
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;love
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;you&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;特殊功能,可以直接打印多行内容,而前面两种情况需要显示输入\n才能换行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;i
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;love
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; you
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而单引号和双引号如果想要实现上面的效果，需要加上换行符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i\nlove\nyou&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;3-如何在一个function里设置一个全局的变量&quot; data-source-line=&quot;6&quot;&gt;3、如何在一个function里设置一个全局的变量。&lt;/h5&gt;
&lt;p&gt;先说概念，全局变量是指定义在函数外部的变量。全局变量的作用域为全局。&lt;/p&gt;
&lt;p&gt;局部变量是指定义在函数内部的变量。局部变量的作用域为函数内，除了函数就无效了。&lt;/p&gt;
&lt;p&gt;这里举个例子，如果把函数比作国家，那么全局就是全球，全局变量好比是阿拉伯数字，每个国家都认识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，根据定义可以知道，在函数内部是无法定义一个全局变量的，只能做到修改已经定义的全局变量。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;4-python里面如何拷贝一个对象赋值-浅拷贝-深拷贝的区别&quot; data-source-line=&quot;8&quot;&gt;4、python里面如何拷贝一个对象？（赋值、浅拷贝、深拷贝的区别）&lt;/h5&gt;
&lt;p&gt;在python中如何拷贝一个对象是需要根据具体的需求来定的。&lt;/p&gt;
&lt;p&gt;（1）赋值：其实就是对象的引用。相当于C的指针，修改了其中一个对象，另一个跟着改变。注意对于不可变对象而言，如果修改了其中一个对象，就相当于修改它的指针指向，另一个对象是不会跟着变化的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] # a是一个可变对象
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; b =&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; a =&lt;span&gt; a.pop()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(b) # 修改了a，b也跟着变
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;当a为不可变对象时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = 1
&lt;span&gt;2&lt;/span&gt; b =&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; a = 2
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;('b = {}'.format(b))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;


&lt;p&gt;（2）浅拷贝：拷贝父对象，但是不会拷贝父对象的子对象。（具体的方法有：b = copy.copy(a)，切片如b = a[1:4]）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = {1: [1, 2, 3&lt;span&gt;]}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; b =&lt;span&gt; a.copy()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, b)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; a[1].append(4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(a, b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
{1: [1, 2, 3]} {1: [1, 2, 3&lt;span&gt;]}
{&lt;/span&gt;1: [1, 2, 3, 4]} {1: [1, 2, 3, 4]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当a为不可变对象时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TEST_STRING&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; b =&lt;span&gt; copy.copy(a)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, b)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; a =&lt;span&gt; a.lower()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(a, b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;TEST_STRING TEST_STRING
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; test_string TEST_STRING
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （3）深拷贝：完全拷贝了父对象和子对象（具体的方法有：b = copy.deepcopy(a)）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; a = {1: [1, 2, 3&lt;span&gt;]}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; b =&lt;span&gt; copy.deepcopy(a)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, b)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; a[1].append(4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(a, b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {1: [1, 2, 3]} {1: [1, 2, 3&lt;span&gt;]}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {1: [1, 2, 3, 4]} {1: [1, 2, 3]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当a为不可变对象时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TEST_STRING&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; b =&lt;span&gt; copy.deepcopy(a)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, b)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; a =&lt;span&gt; a.lower()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(a, b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;TEST_STRING TEST_STRING
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; test_string TEST_STRING
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是图解：&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;b = a: &lt;/strong&gt;赋值引用，a 和 b 都指向同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1269458/201901/1269458-20190103124715093-1584730793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、b = a.copy():&lt;/strong&gt; 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1269458/201901/1269458-20190103124746645-1105480764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、b = copy.deepcopy(a):&lt;/strong&gt; 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1269458/201901/1269458-20190103131159349-386234751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;（1）当对象为不可变类型时，不论是赋值，浅拷贝还是深拷贝，那么改变其中一个值时，另一个都是不会跟着变化的。&lt;/p&gt;
&lt;p&gt;（2）当对象为可变对象时，如果是赋值和浅拷贝，那么改变其中任意一个值，那么另一个会跟着发生变化的；如果是深拷贝，是不会跟着发生改变的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;啊，这一题答案真的是好长啊，累到掉渣！歇会儿。。。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;5-如果custname字符串的编码格式为uft-8如何将custname的内容转化为gb18030的字符串&quot; data-source-line=&quot;10&quot;&gt;5、如果custname字符串的编码格式为uft-8,如何将custname的内容转化为gb18030的字符串？&lt;/h5&gt;
&lt;p&gt;先将custname编码格式转换为unicode，在转换为gb18030。即custname.decode('utf-8').encode('gb18030')。&lt;/p&gt;
&lt;p&gt;注意：unicode编码是一种二进制编码，是转换编码的中间桥梁。比如需要将utf-8转换为gbk，那么就需要先转换为unicode（decode），再转为gbk（encode）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1269458/201901/1269458-20190103180536050-1531112958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;6-请写出一段python代码实现删除list中的重复元素&quot; data-source-line=&quot;12&quot;&gt;6、请写出一段python代码实现删除list中的重复元素。&lt;/h5&gt;
&lt;p&gt;两种方法：&lt;/p&gt;
&lt;p&gt;（1）利用字典的fromkeys来自动过滤重复值&lt;/p&gt;
&lt;p&gt;（2）利用集合set的特性，元素是非重复的&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = [1, 2, 3, 4, 5, 2, 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1(a):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     a =&lt;span&gt; list(set(a))
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; fun1(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = [1, 2, 3, 4, 5, 2, 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1(a):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     b =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     b =&lt;span&gt; b.fromkeys(a)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     c =&lt;span&gt; list(b.keys())
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; c = fun1(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;7-这两个参数是什么意思args和kwargs&quot; data-source-line=&quot;14&quot;&gt;7、这两个参数是什么意思？&lt;em&gt;args和 &lt;/em&gt;kwargs。&lt;/h5&gt;
&lt;p&gt;首先，我想说的是*args和**kwargs并不是必须这样写，只有前面的*和**才是必须的。你可以写成*var和**vars。而写成*args和**kwargs只是约定俗称的一个命名规定。&lt;/p&gt;
&lt;p&gt;*args和**kwargs主要用于函数定义，你可以将不定量的参数传递给一个函数。其中，&lt;code&gt;*args&lt;/code&gt; 是用来发送一个非键值对的可变数量的参数列表给一个函数；&lt;code&gt;**kwargs&lt;/code&gt; 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函数里处理带名字的参数, 你应该使用&lt;code&gt;**kwargs&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; import_args(test, *&lt;span&gt;args):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, test)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;other param&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, item)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; import_args(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里传递了3个参数，按位置传参，'123'为test传参，'hello'和'2019'为*args传参，这里传了2个参数。&lt;/p&gt;
&lt;p&gt;注意，看下面的*args的另一种用法：用来解压数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; import_args(test, *&lt;span&gt;args):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, test)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;other param&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, item)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; args = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; import_args(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, *args)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; param1 123
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;other param hello
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; other param 2019
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码和上面的效果是一样的，但是这里第8行的*args和第1行的*args可是不一样的。第一行是表示函数可以接受不定数量的非键值对的参数，用来传参使用的。第八行是用来解压列表&lt;/p&gt;
&lt;p&gt;['hello', '2019'&lt;span&gt;]的每一项数据的，用来解压参数的。这是*args的两种用法，也可说是*的两种用法，因为args是可变的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来说说**kwargs。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; import_kwargs(test, **&lt;span&gt;kwargs):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, test)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; kwargs.items():
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key, value)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; d = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 26&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; import_kwargs(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, **d)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;**kwargs用来传递带键值对的参数，而**也是用来解压字典容器内的参数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; param1 123
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;name jack
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; age 26
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;strong&gt;*args和**kwargs都是用于函数中传递参数的，*args传递的是非键值对的参数，**kwargs传递的是带键值对的参数，如果还有普通参数需要传递，那么应该先传递普通的参数。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;8&quot; data-source-line=&quot;16&quot;&gt;8、&lt;/h5&gt;
&lt;h5 id=&quot;1统计如下list单词及其出现的次数&quot; data-source-line=&quot;17&quot;&gt;（1）统计如下list单词及其出现的次数。&lt;/h5&gt;
&lt;p data-source-line=&quot;18&quot;&gt;a=['apple', 'banana', 'apple', 'tomato', 'orange', 'apple', 'banana', 'watermeton']&lt;/p&gt;
&lt;p data-source-line=&quot;18&quot;&gt;方法一：&lt;/p&gt;
&lt;p data-source-line=&quot;18&quot;&gt;利用字典。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tomato&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;watermeton&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; dic =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     dic[key] = dic.get(key, 0) + 1
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(dic)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tomato&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;watermeton&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;利用python的collections包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Counter
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; a = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tomato&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;watermeton&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; d =&lt;span&gt; Counter(a)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(d)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Counter({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tomato&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;watermeton&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1})  # 是一个类似字典的结构
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;2给列表中的字典排序例如有如下list对象&quot; data-source-line=&quot;20&quot;&gt;（2）给列表中的字典排序：例如有如下list对象：&lt;/h5&gt;
&lt;p data-source-line=&quot;21&quot;&gt;alist=[{&quot;name&quot;:&quot;a&quot;, &quot;age&quot;:20}, {&quot;name&quot;:&quot;b&quot;, &quot;age&quot;:30}, {&quot;name&quot;:&quot;c&quot;, &quot;age&quot;:25}] 将alist中的元素按照age从小到大排序。&lt;/p&gt;
&lt;p data-source-line=&quot;21&quot;&gt;利用list的内建函数，list.sort()来进行排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; alist = [{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 20}, {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 30}, {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 25&lt;span&gt;}]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; alist.sort(key=&lt;span&gt;lambda&lt;/span&gt; x: x[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(alist)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一种效率很高的排序方法。&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 20}, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 25}, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 30}]
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;3写出下列代码的运行结果&quot; data-source-line=&quot;23&quot;&gt;（3）写出下列代码的运行结果&lt;/h5&gt;
&lt;p&gt;第一段代码的运行结果为：1&lt;/p&gt;
&lt;p&gt;分析，在函数外面定义了一个全局变量a为1，在函数内部定义了一个局部变量a为2。局部变量在离开函数后就失效了。&lt;/p&gt;
&lt;p&gt;所以，结果为全局变量的a的值。如果在a=2之前加上global a，声明为全局变量，那么结果为2。&lt;/p&gt;
&lt;p&gt;第二段代码的运行结果为：[1]&lt;/p&gt;
&lt;p&gt;这是因为，将a传入到function中，这相当于对a进行赋值引用。由于a是可变类型的，所以在函数内部修改a的时候，外部的全局变量a也跟着变化。&lt;/p&gt;
&lt;p&gt;第三段代码的运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;Bob
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Lily
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; Lily
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上。&lt;/p&gt;

</description>
<pubDate>Thu, 03 Jan 2019 14:49:00 +0000</pubDate>
<dc:creator>天意凉</dc:creator>
<og:description>前言 之所以在这里写下python爬虫常见面试题及解答，一是用作笔记，方便日后回忆；二是给自己一个和大家交流的机会，互相学习、进步，希望不正之处大家能给予指正；三是我也是互联网寒潮下岗的那批人之一，为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianyiliang/p/10212951.html</dc:identifier>
</item>
<item>
<title>数据分析入门-05-数据分析武器库：模型空间概述·数据分析模型 - Faddy</title>
<link>http://www.cnblogs.com/data-analyst-qjj/p/10217311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/data-analyst-qjj/p/10217311.html</guid>
<description>
&lt;h3&gt;来，先复习一下,什么是建模&lt;/h3&gt;
&lt;p&gt;昨天介绍了模型本质是对现实对象的抽象描述以及附带的一整套抽象的方法;建模本质上就是建立现实对象和模型的一种映射关系.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxHM5FK7SaXsoOkrvKeCaaATWt1d4EmyZazf4mrblCYEF5h25icm4hoKTXueYdX4T4MuE2SNjurqStA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5609756097560976&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1025&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;今天我们走进模型空间,看看里面最重要的是什么&lt;/h3&gt;
&lt;p&gt;我们先来看看我们平时接触最多的&lt;/p&gt;
&lt;p&gt;感觉很高大上的&lt;/p&gt;
&lt;p&gt;商业模型是什么?&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;比如拿我们都知道的swot分析来看. 百科定义:SWOT分析法，即态势分析法，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。 运用这种方法，可以对研究对象所处的情景进行全面、系统、准确的研究，从而根据研究结果制定相应的发展战略、计划以及对策等。SWOT分析法常常被用于制定集团发展战略和分析竞争对手情况，在战略分析中，它是最常用的方法之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种框架分析工具本质是一个分类方式;首先分类了内部和外部,其次分类了优势/劣势,机会和威胁， 分类本是一种定类测量,相当于测量了俩个数字,一类叫做0,一类叫做1;&lt;/p&gt;
&lt;p&gt;接下来,我们需要了解一些关于测量理论的基础知识.有助于理解这类模型本质都是测量。&lt;/p&gt;
&lt;p&gt;一般可以将数据类型的度量分为四种：定类，定序，定距，和定比，这四种类型是从低到高的递进关系，高级的类型可以用低级类型的分析方法来分析，而反过来却不行，理解下面这些类型对于后面学习统计分析方法尤为重要。1、定类变量 定类就是将给数据定义一个类别。这种数据类型将所研究的对象分类，也即只能决定研究对象是同类抑或不同类。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例如把性别分成男女两类；把动物分成哺乳类和爬行类等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、 定序变量 定序变量是将同一个类别下的对象分一个次序，即变量的值能把研究对象排列高低或大小，具有＞与＜的数学特质。它是比定类变量层次更高的变量，因此也具有定类变量的特质，即区分类别（＝，≠）。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;例如文化程度可以分为大学、高中、初中、小学、文盲；工厂规模可以分为大、中、小；年龄可以分为老、中、青。这些变量的值，既可以区分异同，也可以区别研究对象的高低或大小。 注意！各个定序变量的值之间没有确切的间隔距离。比如大学究竟比高中高出多少，大学与高中之间的距离和初中与小学之间的距离是否相等，通常是没有确切的尺度来测量的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、 定距变量 定距变量是区别同一类别下个案中等级次序及其距离的变量。它除了包括定序变量的特性外，还能确切测量同一类别各个案高低、大小次序之间的距离，因而具有加与减的数学特质。但是，定距变量没有一个真正的零点。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;，摄氏温度这一定距变量说明，摄氏40度比30度高10度，摄氏30度比20度又高10度，它们之间高出的距离相等，而摄氏零度并不是没有温度。 注意！定距变量各类别之间的距离，只能加减而不能乘除或倍数的形式来说明它们之间的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.、定比变量 定比变量是区别同一类别个案中等级次序及其距离的变量。定比变量除了具有定距变量的特性外，还具有一个真正的零点，因而它具有乘与除（×、÷）的数学特质。例如年龄和收入这两个变量，固然是定距变量，同时又是定比变量，因为其零点是绝对的，可以作乘除的运算。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如A月收入是60元，而B是30元，我们可以算出前者是后者的两倍。智力商数这个变量是定距变量，但不是定比变量，因为其0分只具有相对的意义，不是绝对的或固定的，不能说某人的智商是0分就是没有智力；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从这里我们可以看出,很多学科所谓的模型 只是对研究对象的定类测量,另外再加一些经验性的描述而已.这些模型非常依赖主观经验,可重复性和可操纵性都难以对我们的目标产生量级上的效率提升.大数据一部分很重要的意义就是让过去一些无法精确测量的对象变得可精确测量,从而可以引入数学工具解决.这部分是我们今天的重点,关于数学模型空间.&lt;/p&gt;
&lt;h3&gt;接下进入正题,我们来看一下模型空间的具体内容&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7Uqn6ZMiaCO1ibvLLCR9vbFbp0Jmm6Kp5jK2pbuFqswjQonSd4lREtH5PBw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.4186413902053712&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;需要说明的是对模型空间的分类,是非常有主观色彩的,我也是斟酌再三之后选取了这样的角度,以期望不遗漏人类在大多数方面积累的智慧成果.&lt;/p&gt;
&lt;h2&gt;关于人类先天共识模型--图像&lt;/h2&gt;
&lt;p&gt;在生活场景中,我们可以很容易被一幅生动的图像打动,却很难(也不愿意)被逻辑说服.&lt;/p&gt;
&lt;p&gt;这个模型空间内重要是最新的心理学和认知科学的一些研究成果。&lt;/p&gt;
&lt;p&gt; 所以我们在表达我们的成果的时候,往往还要进行一次映射,将抽象成果 映射为 图形样式,方便模型的传播和理解. 从这个角度来看,关于可视化探索的一些工作也是格外有意义的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7Uq00QskmtbeF2caSsvJxP9rsZn1XlKiaPPaHL49lBAw5YwnuVpPCRiahqA/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.9187358916478555&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;关于有助于认识对象的模型&lt;/h2&gt;
&lt;p&gt;这个模型空间内部主要是各种我们已知的系统和定义的概念。以生物学和物理学为主要内容。&lt;/p&gt;
&lt;p&gt;这部分本质为了方便我们寻找同构问题&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;例如我们用生物的进化论 类比的去理解人类社会的竞争. 我们用漏斗这个图形,类比商品转化的过程.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是需要注意的是 寻找同构对象,一方面方便了我们理解对象,也会引导我们忽略对象的一部分特征.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;比如:我们拿人类社会的发展 类比进化论的时候,忽略了一个重要事实,我们可以基因编辑,从而大大影响自然选择.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;关于价值探讨的模型&lt;/h2&gt;
&lt;p&gt;这个类别里也沉淀了,人类的大量的思辨智慧,从柏拉图到奥古斯丁,从阿圭那到康德,从笛卡尔到休谟,从加缪到沃格林等等,这些伟大如斯的人终其一生都一直在探索一个永恒的问题:人何以为人. 这部分也很值得我们去学习,但不是今天的重点,以后有机会可以给大家做一个简单介绍.&lt;/p&gt;
&lt;h2&gt;关于方法论模型&lt;/h2&gt;
&lt;p&gt;这部分本质上可以概括为对因果关系的探索.分类问题和标记问题也可以理解为&quot;果&quot;单一的因果问题. 对因果关系的探索存在俩个极端. 1.科学:对正确/稳定可复现的极致追求 2.工程:以完成目标为核心,重视经验的积累.这个时候出现了一种调和方案--数据分析,我们既不能全靠经验,这样太依赖个人和运气.我们也不能什么事情都做个科学实验,等做完了黄花菜都凉了.&lt;/p&gt;
&lt;p&gt;接下来主要给大家介绍数据分析对于探索因果关系的一些方式.这也是我们做数据分析主要进行的工作.&lt;/p&gt;
&lt;p&gt;对因果关系的探索分为充分性和必要性俩个方向.充分性就是如果A,那么一定B;必要性是说我们知道了B的很多特征C,有多大可能性认为A可以推断出B. 主要通过三种方式:1 计算各种系数 2 画散点图 3 画散点图矩阵 4 做线性回归 5 概率估计 (关于相关性和因果性关系又可以写7篇文章了,现实世界中，可以近似的认为 相关性约等于因果关系，或者相关性至少可以为我们寻找因果关系提供一点启发)&lt;/p&gt;
&lt;h3&gt;用Python进行相关性分析.&lt;/h3&gt;
&lt;p&gt;画散点图 方法如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7UqGuicuENibBsqU11ffR6Y9CRsL8opjzUyvickW6tLpUM8icBQwq8wnl6wicg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.6638141809290954&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;
&lt;p&gt;画散点图矩阵的方法 如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7UqogutTBjB0eydjowLzP2OnZSUn92rAeA8jcCYzs0ZIXCunueteBcekA/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.8913907284768212&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;计算系数&lt;/h3&gt;
&lt;p&gt;pearson（皮尔逊）相关系数要求样本满足正态分布&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;两个变量之间的皮尔逊相关系数定义为两个变量之间的协方差和标准差的商，其值介于-1与1之间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7UqjeL9pZG3Tm0FOQsLZfQ7OJ9bq8fIJ15L6JrOfI3qZnhbB5icJiaR6M1g/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.8188010899182562&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Sperman秩相关系数 皮尔森相关系数主要用于服从正太分布的连续变量，对于不服从正太分布的变量，分类关联性可采用Sperman秩相关系数，也称 等级相关系数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7UqGKrd6aLdyRBPY4EwOyJEAmDbZODpbicmddQyFsavmTktP66D9SjiaZJA/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.8110119047619048&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;通过机器学习的方式探索因果模型&lt;/h3&gt;
&lt;p&gt;这部分我们会介绍一些最流行的机器学习模型类型。这也是我们发现相关性的一种武器. 监督学习:监督学习算法是基于一组标记数据进行预测的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;比如，历史销售数据可以来预测未来的销售价格。应用监督学习算法，我们需要一个包含标签的训练数据集。我们可以使用这个训练数据集去训练我们的模型，从而得到一个从输入数据到输出期望数据之间的映射函数。 这个模型的推断作用是从一个数据集中学习出一种模式，可以让这个模型适应新的数据，也就是说去预测一些没有看到过的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分类：当数据被用于预测一个分类时，监督学习算法也可以称为是一种分类算法。比如，我们的一张图片可以被分类标记为狗或者猫。如果我们的分类标签只有两个类别，那么我们也把这个分类称之为二分类问题。当我们需要分类的东西超过两个类别的时候，这个模型就是一个多分类模型了。 回归：当我们预测的值是一个连续值时，这个问题就变成了一个回归问题。 预测：这是根据过去和现在的一些历史数据，来预测将来的数据。最常用的一个领域就是趋势分析。比如，我们可以根现在和过去几年的销售额来预测下一年的销售额。&lt;/p&gt;
&lt;h3&gt;关于机器学习的模型&lt;/h3&gt;
&lt;p&gt;　监督学习主要包括用于分类和用于回归的模型：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分类：线性分类器（如LR)、支持向量机（SVM）、朴素贝叶斯（NB）、K近邻（KNN）、决策树（DT）、集成模型（RF/GDBT等）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;回归：线性回归、支持向量机（SVM）、K近邻（KNN）、回归树（DT）、集成模型（ExtraTrees/RF/GDBT）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关于各个模型的关系和选取原则可以参考下面图片.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7UqDVflyHF2m0fYbyP6LOf14aE9drvT66ANtLCegbsbd9szKRahCKhWgg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.5603576751117735&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;最后总结一下&lt;/h3&gt;
&lt;p&gt;对模型空间做了一个综述,着重介绍了因果关系探索的一些数学模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7UqQsYsqVgwbZMDTLZr0ic0NAgz2piaAgwiaUBhCufN4K4J4BlZ1bIr6Ga6Q/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.528957528957529&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1295&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;讲个小故事~关于测量~一米等于多少.&lt;/h3&gt;
&lt;p&gt;1791年，著名科学家拉格朗日，当选为法国度量衡委员会主席。在他全力推动下，一项影响了全世界的长度单位——米浮出水面。法国相关当局规定：把经过巴黎的地球子午线，也就是经线长的四千万分之一定义为1米。通俗地说，l米是从地球北极到赤道距离的一千万分之一，1791年3月25日（距今227年），法国国民议会决定采纳了只基于一个长度基本单位“米”的计量制度。现在全球通用的国际长度单位米，则由此规定而来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7Uq1ic79kmhOnsdnuXUhKDL9TkJ6ibWU0kic0tynz8YW5C5T54U9ibL0ATjlg/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;352&quot; data-backw=&quot;556&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_png/8cAQrzhGgxGakFNicsHLUsv7piblg9f7Uq1ic79kmhOnsdnuXUhKDL9TkJ6ibWU0kic0tynz8YW5C5T54U9ibL0ATjlg/0?wx_fmt=png&quot; data-ratio=&quot;0.6339754816112084&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;
&lt;p&gt;剩下的问题是如何测量地球子午线的长度了?那可是200年前,没有飞机,没有核动力航母,于是拿破仑真的派了俩队人一队去北极,一队去秘鲁.....开始了测赤道....7年之后俩队人返回测得了结果是57422toise(法国当时长度单位).&lt;/p&gt;
&lt;p&gt;人类为了量化一个对象,有多努力.....&lt;/p&gt;

</description>
<pubDate>Thu, 03 Jan 2019 14:23:00 +0000</pubDate>
<dc:creator>Faddy</dc:creator>
<og:description>知识的精华是模型，模型的精华是因果。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/data-analyst-qjj/p/10217311.html</dc:identifier>
</item>
<item>
<title>2018 总结，2019 计划 - zhangmiao14</title>
<link>http://www.cnblogs.com/zhangmiao14/p/10217300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmiao14/p/10217300.html</guid>
<description>&lt;div readability=&quot;65&quot;&gt;

&lt;h2 id=&quot;2018总结&quot;&gt;2018总结&lt;/h2&gt;
&lt;p&gt;先看了一下自己2018年的计划：&lt;/p&gt;
&lt;pre&gt;
&lt;code data-origin=&quot;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;　 1.每三个月看一本书 　　2.学习UI设计 　　3.继续完成2017年的小应用 　　4.今年想要学习Kotlin知识 　　5.学习一下微信小程序 　　6.写博文 　　7.继续自学绘画 　　8.锻炼身体 　　9.旅游 &amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&quot;&gt;　  1.每三个月看一本书
　　2.学习UI设计
　　3.继续完成2017年的小应用
　　4.今年想要学习Kotlin知识
　　5.学习一下微信小程序
　　6.写博文
　　7.继续自学绘画
　　8.锻炼身体
　　9.旅游
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面一点一点来总结：&lt;/p&gt;
&lt;h4 id=&quot;读书&quot;&gt;读书&lt;/h4&gt;
&lt;p&gt;完成阅读完的书单如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code data-origin=&quot;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;《Android开发精要》 《聪明人用方格笔记本》 《番茄工作法图解》 《如懿传》 《一个叫欧维的男人决定去死》 《把小日子放进手账里》 《Java核心技术卷一》 《红楼梦之林如海重生》 《旅行手账完全指南》 &amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&quot;&gt;《Android开发精要》
《聪明人用方格笔记本》
《番茄工作法图解》
《如懿传》
《一个叫欧维的男人决定去死》
《把小日子放进手账里》
《Java核心技术卷一》
《红楼梦之林如海重生》
《旅行手账完全指南》
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2本技术书，2本关于学习方法的书，2本生活的书，3本小说。还有一个《代码整洁之道》还在阅读，没有阅读完毕。&lt;br/&gt;技术书阅读较少，计划的书单也没有完成，2019年需要加强书籍阅读。&lt;br/&gt;技术书的阅读比较缓慢，有时候看到书籍的一个段落，需要细细研读才能明白作者的意思，阅读完也容易忘记，今年阅读书籍都写了读书笔记，将书籍中重要的部分摘记下来， 2019 年打算将之前阅读过的书籍进行重读，再次记录。&lt;/p&gt;
&lt;h4 id=&quot;ui-、-kotlin-与微信小程序的学习&quot;&gt;UI 、 Kotlin 与微信小程序的学习&lt;/h4&gt;
&lt;p&gt;这块的知识 2018 年没有完成，在 2018 年中旬的时候感觉自己时间有限，想要学习了解的东西又多，决定选择出最应该放精力的方面，将 UI 与微信小程序的学习决定进行押后， Kotlin 是没有学习，2019 年计划继续。&lt;/p&gt;
&lt;h4 id=&quot;完成小应用&quot;&gt;完成小应用&lt;/h4&gt;
&lt;p&gt;应用有完成，但是感觉应用界面丑、用户交互也不友好，所以没有发布到市场上去，下半年重新写了一个《今天吃什么》的应用，写完了，测试了一下，但是没有发布到市场上去。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/622972/201901/622972-20190103221922559-1761559425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;写博文&quot;&gt;写博文&lt;/h4&gt;
&lt;p&gt;从2018年1月到2018年12月写了博文33篇，2017年写了31篇，多写了2篇。2月份和5月份没有文章输出，还是要坚持每个月输出。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/622972/201901/622972-20190103221623349-960674140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;绘画&quot;&gt;绘画&lt;/h4&gt;
&lt;p&gt;2018年绘画13副，计划是周末绘画一副，但是没有做到，相比较2017年也好一些，绘画还是要坚持。附上一张 2018 的最后一张画&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/622972/201901/622972-20190103221841340-1064064908.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;锻炼身体&quot;&gt;锻炼身体&lt;/h4&gt;
&lt;p&gt;2018年锻炼身体有点三天打鱼两天晒网，今天想起来练就练一下，懒就不练了，没有持之以恒。&lt;/p&gt;
&lt;h4 id=&quot;旅游&quot;&gt;旅游&lt;/h4&gt;
&lt;p&gt;2018年去了好多地方，4月份清明节去了广州玩了一天，去了白云山，越秀公园，白马市场；&lt;br/&gt;6月份去了澳门转，买个相机还有护肤品之类的；&lt;br/&gt;9月份去了珠海的外伶仃岛；&lt;br/&gt;9月中秋节去了珠海的古元美术馆和石溪公园；&lt;br/&gt;12月份去了广州和高中同学玩了一下，去了西汉南越王博物馆、陈氏书院、越秀公园。&lt;br/&gt;旅游基本都是珠海附近的地方，也很好玩。&lt;/p&gt;
&lt;h4 id=&quot;2018-github-平时提交&quot;&gt;2018 Github 平时提交&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/622972/201901/622972-20190103221657927-1449383434.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;比 2017 年提交的次数要多，前半年提交次数少，后半年多但是也不够密集，还有一周都没有任何提交的时候，需要注意。&lt;br/&gt;2018 年 Github 上主要是读书笔记、小应用代码、简单的开源库的提交。&lt;/p&gt;
&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;
&lt;p&gt;2018年前半年都在看 Android 的黑马课程，看完视频课程之后，其实有点不知道自己要干嘛，看视频的时候天天想着要早点看完，每周都有动力，看完之后反而不知道要干嘛，所以想了一些时间，决定不管干什么，先看书，就开始有一搭没一搭的看书，技术书很厚也很难看，所以看得很慢，博客也基本是关于读书笔记的，感觉下半年的收获没有上半年的多，可能就是因为没有计划，也没有动力的缘故，容易自我松散，看了一些关于学习方法的书，如《聪明人用方格笔记本》、《番茄工作法图解》，感觉作者的说法很对，但是不容易坚持，到头来感觉还是列计划比较合适自己。&lt;/p&gt;
&lt;h2 id=&quot;2019-计划&quot;&gt;2019 计划&lt;/h2&gt;
&lt;p&gt;今年的计划和 2018 年的计划区别不大，还是学习和生活两方面。2019 年即将毕业 3 年，打算 2019 在 GitHub 上整合一个 Android 的完备知识体系，将自己之前写过的博客整理在一起，对 Android 的知识进行查缺补漏，出一套整体的文章，也方便自己查阅与学习新的技术。&lt;/p&gt;
&lt;pre&gt;
&lt;code data-origin=&quot;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt; 1.读书 《代码整洁之道》 《程序员修炼之道》 《深入理解 Android 卷一》 《 Java 多线程编程核心技术》 《图解 HTTP 》 重读 《 Android 开发艺术探索》 《 Android 进阶之光》 《 Android 进阶解密》 《 Android 源码设计模式解析与实战》 《深入探索 Android 热修复技术原理》 《 Android 插件化开发指南》 2.今年想要学习 Kotlin 知识 3.Android 完备的知识体系文章 4.了解学习架构师的知识 5.继续学习绘画 6.锻炼身体 7.旅游 想去桂林，啦啦啦。 8.找个副业 赚不赚钱先不说，今年想尝试一下。 &amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&quot;&gt;    1.读书
        《代码整洁之道》
        《程序员修炼之道》
        《深入理解 Android 卷一》
        《 Java 多线程编程核心技术》
        《图解 HTTP 》
        重读 《 Android 开发艺术探索》
        《 Android 进阶之光》
        《 Android 进阶解密》
        《 Android 源码设计模式解析与实战》
        《深入探索 Android 热修复技术原理》
        《 Android 插件化开发指南》
    2.今年想要学习 Kotlin 知识
    3.Android 完备的知识体系文章
    4.了解学习架构师的知识
    5.继续学习绘画
    6.锻炼身体
    7.旅游
        想去桂林，啦啦啦。
    8.找个副业
        赚不赚钱先不说，今年想尝试一下。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2019-年-1-月-~-2019-年-6-月&quot;&gt;2019 年 1 月 ~ 2019 年 6 月&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;《代码整洁之道》&lt;/li&gt;
&lt;li&gt;重读《 Android 开发艺术探索》&lt;/li&gt;
&lt;li&gt;Android 的知识体系文章&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;2019-年-7-月&quot;&gt;2019 年 7 月&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;学习 Kotlin 知识&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;2019-年-8-月&quot;&gt;2019 年 8 月&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;LeetCode 每日一题&lt;/li&gt;
&lt;li&gt;数据结构 &amp;amp; 算法&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;2019-年-9-月&quot;&gt;2019 年 9 月&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;《 Java 多线程编程核心技术》&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;2019-年-10-月---2019-年-11-月&quot;&gt;2019 年 10 月 - 2019 年 11 月&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;《图解 HTTP 》&lt;/li&gt;
&lt;li&gt;了解学习架构师的知识&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;2019-年-12-月&quot;&gt;2019 年 12 月&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;《程序员修炼之道》&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 03 Jan 2019 14:20:00 +0000</pubDate>
<dc:creator>zhangmiao14</dc:creator>
<og:description>2018 总结，2019 计划 2018总结 先看了一下自己2018年的计划： 1.每三个月看一本书 2.学习UI设计 3.继续完成2017年的小应用 4.今年想要学习Kotlin知识 5.学习一下微</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmiao14/p/10217300.html</dc:identifier>
</item>
</channel>
</rss>