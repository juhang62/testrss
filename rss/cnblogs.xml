<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用ctypes调用系统C API函数需要注意的问题，函数参数中有指针或结构体的情况下最好不要修改argtypes - YinKaisheng</title>
<link>http://www.cnblogs.com/Yinkaisheng/p/10955468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yinkaisheng/p/10955468.html</guid>
<description>&lt;p&gt;有人向我反应，在代码里同时用我的python模块&lt;a href=&quot;https://github.com/yinkaisheng/Python-UIAutomation-for-Windows&quot; target=&quot;_blank&quot;&gt;uiautomation&lt;/a&gt;和其它另一个模块后，脚本运行时会报错，但单独使用任意一个模块时都是正常的，没有错误。&lt;a href=&quot;https://github.com/yinkaisheng/Python-UIAutomation-for-Windows/issues/65&quot; target=&quot;_blank&quot;&gt;issue链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我用一个例子来演示下这个问题是如何出现的。&lt;/p&gt;
&lt;p&gt;假设我需要写一个module，这个module需要提供获取当前鼠标光标下窗口句柄的功能，这需要调用系统C API来实现。&lt;/p&gt;
&lt;p&gt;实现如下：&lt;/p&gt;
&lt;p&gt;module1.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!python3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ctypes
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ctypes.wintypes


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; POINT(ctypes.Structure):
    _fields_ &lt;/span&gt;= [(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ctypes.wintypes.LONG),
                (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ctypes.wintypes.LONG)]


ctypes.windll.user32.WindowFromPoint.argtypes &lt;/span&gt;=&lt;span&gt; (POINT, )
ctypes.windll.user32.WindowFromPoint.restype &lt;/span&gt;=&lt;span&gt; ctypes.c_void_p

ctypes.windll.user32.GetCursorPos.argtypes &lt;/span&gt;=&lt;span&gt; (ctypes.POINTER(POINT), )


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; WindowFromPoint(x, y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ctypes.windll.user32.WindowFromPoint(POINT(x, y))


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; GetCursorPos():
    point &lt;/span&gt;=&lt;span&gt; POINT(0, 0)
    ctypes.windll.user32.GetCursorPos(ctypes.byref(point))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; point.x, point.y


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; WindowFromCursor():
    x, y &lt;/span&gt;=&lt;span&gt; GetCursorPos()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; WindowFromPoint(x, y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的代码如下&lt;/p&gt;
&lt;p&gt;test.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!python3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; module1


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the handle under cursor is&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, module1.WindowFromCursor())


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
the handle under cursor &lt;span&gt;is&lt;/span&gt; 1839250
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这时复制一份module1.py，重命名为module2.py，他们的代码是完全一样的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在test.py同时调用这两个module，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!python3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; module1
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; module2


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the handle under cursor is&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, module1.WindowFromCursor())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the handle under cursor is&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, module2.WindowFromCursor())


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行就会报错了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ctypes.ArgumentError: argument 1: &amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TypeError&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;: expected LP_POINT instance instead of pointer to POINT
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但分开单独调用任一个模块就是正常的，不会出错。&lt;/p&gt;

&lt;p&gt;这是因为，module1，module2调用的同一个C函数，在设置&lt;span&gt;argtypes的时候，后面的修改会覆盖前面的设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; module1
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; module2&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;后，C函数中的POINT参数必须是module2.POINT才是合法的。&lt;/p&gt;
&lt;p&gt;在用module1调用时，传入的参数类型是module1.POINT，运行时就会报错了。&lt;/p&gt;
&lt;p&gt;这种错误应该只有在参数中有结构体或结构体指针时才会出现。&lt;/p&gt;
&lt;p&gt;假设module1, module2分别是两个人写，你又要同时用这两个module，只要有一个module设置了argtypes，运行时可能就会出错。&lt;/p&gt;

&lt;p&gt;解决方法是，在module1, module2中注释两行代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ctypes.windll.user32.WindowFromPoint.argtypes = (POINT, )&lt;/span&gt;
ctypes.windll.user32.WindowFromPoint.restype =&lt;span&gt; ctypes.c_void_p

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ctypes.windll.user32.GetCursorPos.argtypes = (ctypes.POINTER(POINT), )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要修改argtypes，再运行test.py就不会报错了。&lt;/p&gt;
&lt;p&gt;作为库的作者，需要主要一下，最好不要设置系统C函数的argtypes。&lt;/p&gt;

</description>
<pubDate>Fri, 31 May 2019 07:27:00 +0000</pubDate>
<dc:creator>YinKaisheng</dc:creator>
<og:description>有人向我反应，在代码里同时用我的python模块uiautomation和其它另一个模块后，脚本运行时会报错，但单独使用任意一个模块时都是正常的，没有错误。issue链接 我用一个例子来演示下这个问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yinkaisheng/p/10955468.html</dc:identifier>
</item>
<item>
<title>关于vue中node_modules中第三方模块的修改使用 - Yogic</title>
<link>http://www.cnblogs.com/yogic/p/10955428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yogic/p/10955428.html</guid>
<description>&lt;p&gt;最近用vue在做一个项目，github用上找了一个日历插件，intall到了本项目中，配好以后发现插件的样式风格和项目总体风格相差较大，所以就像这个改一下插件风格，&lt;/p&gt;
&lt;p&gt;第一种方法：我直接在父组件中将style标签的scoped的属性去掉了，在父组件中直接写了想要的样式，重叠样式全部！important，结果确实生效了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1134925/201905/1134925-20190531145428060-438071762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二种方法：本想这个要是样式这么改，还有路可走；要是插件的底层方法呢，如果有对外开发的修改入口还行，要是没有，可咋办，于是想着能不能直接去改下这个插件，这样直接一锤子到底，　　　&lt;/p&gt;
&lt;p&gt;　　　　　　在node_modules中直接找到了这个插件，查阅了这&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1134925/201905/1134925-20190531145930037-600335643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚开始直接啥也没管，直接改了src下的文件死活不生效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1134925/201905/1134925-20190531150653038-403360008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后看了下这个插件的package.json；一看，靠，原来主文件，是dist目录下的index.js；这个是已经打好的用于生产环境的包，我改的src下的测试环境的文件，当然无效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1134925/201905/1134925-20190531151000653-64510220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;怎么办才能有效呢，当然是重新打包，问题的关键是怎样在node_modules下在这个插件下重新build，查了这个插件下，根本没有这个插件的node_modules依赖（插一句git文件到github时node_moudles文件是忽略的），所以在插件下直接npm run build各种报错，&lt;/p&gt;
&lt;p&gt;后来想了下，我把这个插件包拷出来，然后vs打开，不是没有node_modules依赖吗，有package.json。直接npm install ;这样的package.json里面的标写的依赖全部安装，然后有了依赖，这时去改这个插件src下的文件；&lt;/p&gt;
&lt;p&gt;改好所有的一切后直接npm run build;重新生成了新的dist 下的index.js；把这个新生成的index.js拷贝覆盖到原来那个项目下对应的位置，覆盖，这样最后的效果妥妥额成功了！哈哈哈！！！&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1134925/201905/1134925-20190531152042483-142422027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　总结一下：&lt;/h2&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div readability=&quot;22.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　&lt;span&gt;　可以看下要修改的node_modules项目中的package.json，里面会有一个属性，类似：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;code class=&quot;language-text&quot;&gt;　　　　　　&quot;main&quot;: &quot;dist/index.min.js&quot;,&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　　　表示的是该项目的入口文件，我们日常开发的项目中引用的其实就是这一个文件，若是直接改这个index.min.js，重启一下就能生效。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　　　PS： 不过一般入口文件都是打包后的js，很难直接改，都是改src目录下的文件后重新build。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　　　--------------------问题的关键是怎样在node_modules下在这个插件下build，查了这个插件下根本没有这个插件的node_modules依赖，所以在插件下直接npm run build各种报错，解决方法是拷贝出来改好后直接去覆盖，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　　　--------------------一般不建议这么干，太暴力了，另外团队协助时，其他队友和服务器上的代码不能保持一致&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


</description>
<pubDate>Fri, 31 May 2019 07:22:00 +0000</pubDate>
<dc:creator>Yogic</dc:creator>
<og:description>最近用vue在做一个项目，github用上找了一个日历插件，intall到了本项目中，配好以后发现插件的样式风格和项目总体风格相差较大，所以就像这个改一下插件风格， 第一种方法：我直接在父组件中将st</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yogic/p/10955428.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Zuul API服务网关之请求路由 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/10955333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/10955333.html</guid>
<description>&lt;h2 id=&quot;一zuul-介绍&quot;&gt;一、Zuul 介绍&lt;/h2&gt;
&lt;p&gt;​ 通过前几篇文章的介绍，我们了解了Spring Cloud Eureka 如何搭建注册中心，Spring Cloud Ribbon 如何做负载均衡，Spring Cloud Hystrix 断路器如何保护我们的服务，以防止雪崩效应的出现，Spring Cloud Feign进行声明式服务调用都有哪些应用，相比Ribbon和Hystrix都有哪些改善。可以说，以上几个组件都是搭建一套微服务架构所必须的。通过以上思路，能够梳理出下面这种基础架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190531150653519-1101189755.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在此架构中，我们的服务集群是内部&lt;code&gt;ServiceA&lt;/code&gt; 和 &lt;code&gt;ServiceB&lt;/code&gt;，他们都会向Eureka Server集群进行注册与订阅服务。而&lt;code&gt;OpenService&lt;/code&gt;是一个对外的Restful API 服务，它通过F5，Nginx等网络设备或工具软件实现对各个微服务的路由与负载，公开给外部客户端调用&lt;/p&gt;
&lt;p&gt;​ 那么上述的架构存在什么问题呢？从&lt;code&gt;运维&lt;/code&gt;的角度来看，当客户端单机某个功能的时候往往会发出一些请求到后端，这些请求通过F5，Nginx等设施的路由和负载均衡分配后，被转发到各个不同的实例上，而为了让这些设施能够正确的路由与分发请求，运维人员需要手动维护这些&lt;code&gt;实例列表&lt;/code&gt;，当系统规模增大的时候，这些看似简单的维护回变得越来越不可取。 从&lt;code&gt;开发&lt;/code&gt;的角度来看，为了保证服务的安全性，我们需要在调用内部接口的时候，加一层&lt;code&gt;过滤&lt;/code&gt;的功能，比如&lt;code&gt;权限&lt;/code&gt;的校验，用户&lt;code&gt;登陆状态&lt;/code&gt;的校验等；同时为了防止客户端在请求时被篡改等安全方面的考虑，还会有一些签名机制的存在。&lt;/p&gt;
&lt;p&gt;​ 正是由于上述架构存在的问题，&lt;code&gt;API网关&lt;/code&gt;被提出，API网关更像是一个智能的应用服务器，它的定义类似于设计模式中的外观模式，它就像是一个门面的角色，结婚时候女方亲属堵门时候的角色，我去参加婚礼当伴郎的时候去村子里面见新娘，女方亲属会把鞋子藏起来，有可能藏在屋子里有可能藏在身上，这得需要你自己去寻找，找到了鞋子之后，你才能够给新娘穿上才能正式的会见家长。API网关真正实现的功能有&lt;code&gt;请求路由&lt;/code&gt;，&lt;code&gt;负载均衡&lt;/code&gt;，&lt;code&gt;校验过滤&lt;/code&gt;，&lt;code&gt;请求转发的熔断机制&lt;/code&gt;，&lt;code&gt;服务的聚合&lt;/code&gt;等一系列功能。&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;Spring Cloud Zuul&lt;/code&gt;通过与&lt;code&gt;Spring Cloud Euerka&lt;/code&gt;进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有的微服务的实例信息。者可以通过使用Zuul来创建各种校验过滤器，然后指定哪些规则的请求需要执行校验逻辑，只有通过校验的才会被路由到具体的微服务接口。下面我们就来搭建一下Spring Cloud Zuul服务网关&lt;/p&gt;
&lt;h2 id=&quot;二构建spring-cloud-zuul网关&quot;&gt;二、构建Spring Cloud Zuul网关&lt;/h2&gt;
&lt;p&gt;​ 下面我们就来实际搭建一下Zuul网关，来体会一下网关实际的用处&lt;/p&gt;
&lt;h3 id=&quot;构建网关&quot;&gt;构建网关&lt;/h3&gt;
&lt;p&gt;​ 在实现各种API网关服务的高级功能之前，我们先来启动一下前几章搭建好的服务&lt;code&gt;server-provider&lt;/code&gt;，&lt;code&gt;feign-consumer&lt;/code&gt;，&lt;code&gt;eureka-server&lt;/code&gt;，虽然之前我们一直将feign-consumer视为消费者，但是在实际情况下，每个服务既时服务消费者，也是服务提供者，之前我们访问的http://localhost:9001/feign-consumer等一系列接口就是它提供的服务。这里就来介绍一下详细的构建过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个Spring Boot功能，命名为api-gateway，并在Pom.xml文件中引入如下内容&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.3.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.api.gateway&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;api-gateway&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;api-gateway&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-zuul&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.3.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;Brixton.SR5&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;对于spring-cloud-starter-zuul 依赖，可以通过查看依赖配置了解到，它不仅包含了Netflix Zuul的核心依赖zuul-core，还包括了下面这些网关的重要依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190531150726673-1605455948.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;spring-cloud-starter-hystrix: 该依赖用在网关服务中实现对微服务转发时候的保护机制，通过线程隔离和断路器，防止因为微服务故障引发的雪崩效应&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spring-cloud-starter-ribbon: 该依赖用在实现网关服务进行负载均衡和请求重试&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spring-cloud-starter-actuactor: 该依赖用来提供常规的微服务管理端点。另外，Spring Cloud Zuul 中还特别提供了/routes端点来返回当前的路由规则&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在ApiGatewayApplication 主入口中添加&lt;code&gt;@EnableZuulProxy&lt;/code&gt;注解开启服务网关功能&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @EnableZuulProxy
    @SpringBootApplication
    public class ApiGatewayApplication {

        public static void main(String[] args) {
            SpringApplication.run(ApiGatewayApplication.class, args);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在application.properties 中配置Zuul应用的基础信息，包括应用名，端口号，具体如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;  spring.application.name=api-gateway
  server.port=5555&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;请求路由&quot;&gt;请求路由&lt;/h3&gt;
&lt;p&gt;​ 下面，我们通过一个简单的示例来为上面构建的网关增加请求路由的功能，为了演示请求路由的功能，我们先将之前的Eureka服务注册中心和微服务应用都启动起来。观察下面的服务列表，可以看到两个微服务应用已经注册成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190531150737517-1669272959.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;传统路由方式&quot;&gt;传统路由方式&lt;/h4&gt;
&lt;p&gt;​ 使用&lt;code&gt;Spring Cloud Zuul&lt;/code&gt;实现路由功能非常简单，只需要对api-gateway服务增加一些关于路由的配置规则，就能实现传统路由方式&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;  zuul.routes.api-a-url.path=/api-a-url/**
  # 映射具体的url路径
  zuul.routes.api-a-url.url=http://localhost:8080/&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;该配置定义了发往API网关服务的请求中，所有符合/api-a-url/&lt;/strong&gt; 规则的访问都将被路由转发到 http://localhost:8080 的地址上，也就是说，当我们访问http://localhost:5555/api-a-url/hello 的时候，API网关服务会将该请求路由到http://localhost:8080/hello 提供的微服务接口中。其中，配置属性zuul.routes.api-a-url.path 中的api-a-url部分为路由的名字，可以任意定义，但是一组path和url映射关系的路由名要相同**&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;面向服务的路由&quot;&gt;面向服务的路由&lt;/h4&gt;
&lt;p&gt;​ 很显然，传统的配置方式对我们来说并不友好，他同样需要运维人员花费大量的时间维护各个路由path 和url的关系。为了解决这个问题，Spring Cloud Zuul实现了与Spring Cloud Eureka的无缝衔接，我们可以让路由的path不是映射具体的url，而是让它&lt;code&gt;映射到具体的服务&lt;/code&gt;，而具体的url则交给Eureka的服务发现机制去自动维护&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为了实现与Eureka的整合，我们需要在api-gateway的pom.xml中引入&lt;code&gt;spring-cloud-starter-eureka&lt;/code&gt;依赖&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在api-gateway服务中对应的application.properties文件中加入如下代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;  zuul.routes.api-a.path=/api-a/**
  zuul.routes.api-a.serviceId=server-provider
 
  zuul.routes.api-b.path=/api-b/**
  zuul.routes.api-b.serviceId=feign-consumer
  
  eureka.client.service-url.defaultZone=http://localhost:1111/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;针对我们之前准备的两个微服务应用&lt;code&gt;server-provider&lt;/code&gt;和&lt;code&gt;feign-consumer&lt;/code&gt;，在上面的配置中分别定义了api-a 和 api-b 的路由来映射它们。然后这个api-gateway的默认注册中心是默认注册中心地址&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;完成上述配置后，我们可以将四个服务启动起来，分别是&lt;code&gt;eureka-server&lt;/code&gt;, &lt;code&gt;server-provider&lt;/code&gt;, &lt;code&gt;feign-consumer&lt;/code&gt;, &lt;code&gt;api-gateway&lt;/code&gt;服务，启动完毕，会在eureka-server信息面板中看到多了一个&lt;code&gt;api-gateway&lt;/code&gt;网关服务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190531150755407-245164756.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;http://localhost:5555/api-a/hello: 这个接口符合 &lt;code&gt;/api-a/**&lt;/code&gt;的规则，由api-a 路由负责转发，该路由映射的serviceId 为 &lt;code&gt;server-provider&lt;/code&gt;，所以最终&lt;code&gt;/hello&lt;/code&gt;请求会被发送到&lt;code&gt;server-provider&lt;/code&gt;服务的某个实例上去&lt;/li&gt;
&lt;li&gt;http://localhost:9001/api-b/feign-consumer: 这个接口符合 &lt;code&gt;/api-b/**&lt;/code&gt;的规则，由api-b 进行路由转发，实际的地址由Eureka负责映射，该路由的serviceId是&lt;code&gt;feign-consumer&lt;/code&gt;, 所以最终 &lt;code&gt;/feign-consumer&lt;/code&gt; 请求会被路由到 &lt;code&gt;feign-consumer&lt;/code&gt; 服务上。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;请求过滤&quot;&gt;请求过滤&lt;/h3&gt;
&lt;p&gt;​ 在实现了请求路由功能之后，我们的微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了，但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都有一定限制。为了实现客户端请求的安全校验和权限控制，&lt;strong&gt;最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。但是，这样的方法并不可取，因为同一个系统中会有很多校验逻辑相同的情况，最好的方法是将这些校验逻辑剥离出去，构成一个独立的服务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 对于上面这种问题，更好的做法是通过前置的网关服务来完成非业务性质的校验。为了在API网关中实现对客户端请求的校验，我们将继续介绍Spring Cloud Zuul的另外一个核心功能：&lt;code&gt;请求过滤&lt;/code&gt;，实现方法比较简单，我们只需要继承&lt;code&gt;ZuulFilter&lt;/code&gt;抽象类并实现它定义的4个抽象函数即可&lt;/p&gt;
&lt;p&gt;​ 下面的代码定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查&lt;code&gt;HttpServletRequest&lt;/code&gt;中是否带有&lt;code&gt;accessToken&lt;/code&gt;参数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public class AccessFilter extends ZuulFilter {

      private static Logger log = LoggerFactory.getLogger(AccessFilter.class);

      /**
       * 过滤器的执行时序
       * @return
       */
      @Override
      public String filterType() {
          return &quot;pre&quot;;
      }

      /**
       * 过滤器的执行顺序
       * @return
       */
      @Override
      public int filterOrder() {
          return 0;
      }

      /**
       * 判断过滤器是否应该执行
       * @return
       */
      @Override
      public boolean shouldFilter() {
          return true;
      }

      /**
       * 过滤器的具体执行逻辑
       * @return
       */
      @Override
      public Object run() {
          RequestContext rc = RequestContext.getCurrentContext();
          HttpServletRequest request = rc.getRequest();
          log.info(&quot;send {} request to {}&quot;, request.getMethod(),request.getRequestURL().toString());

          String accessToken = request.getParameter(&quot;accessToken&quot;);
          if(null == accessToken){
              log.warn(&quot;access token is null&quot;);
              rc.setResponseStatusCode(401);
              rc.setSendZuulResponse(false);
          }
          log.info(&quot;access token ok&quot;);
          return null;
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;在上面实现的过滤器代码中，我们通过继承ZuulFilter 抽象类并重写了四个方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;filterType : 过滤器类型，它决定过滤器的请求在哪个生命周期中执行，这里定义为pre，意思是在请求前执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;filterOrder : 过滤器的执行顺序，当请求在一个阶段存在多个过滤器时，需要根据方法的返回值来判断过滤器的执行顺序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shouldFilter: 过滤器是否需要执行，这里直接返回true，因为该过滤器对所有的请求都生效&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;run: 过滤器的具体逻辑，这里我们通过rc.setResponseStatusCode(401)设置失效的标志，rc.setSendZuulResponse(false)令Zuul过滤该请求&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的Bean才能启动该过滤器。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @EnableZuulProxy
    @SpringBootApplication
    public class ApiGatewayApplication {

        public static void main(String[] args) {
            SpringApplication.run(ApiGatewayApplication.class, args);
        }

        @Bean
        public AccessFilter filter(){
            return new AccessFilter();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在对&lt;code&gt;api-gateway&lt;/code&gt;服务完成了上面的改造之后，我们可以重新启动它，并发起下面的请求，对上面的过滤器做一个验证&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入 http://localhost:5555/api-a/hello : 返回 401错误&lt;/li&gt;
&lt;li&gt;输入 http://localhost:5555/api-a/hello?accessToken=token，正确路由到&lt;code&gt;server-provider&lt;/code&gt;的/hello 接口，并返回Hello World。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​ 到这里，对于API网关的快速入门示例就搭建完成了，通过对Spring Cloud Zuul 网关的搭建，我们能认知到网关的重要性，可以总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;它作为系统的统一入口， 屏蔽了系统内部各个微服务的细节。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;它可以与服务治理框架结合，实现自动化的服务实例维护以及负载均衡的路由转发。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;它可以实现接口权限校验与微服务业务逻辑的解耦。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过服务网关中的过滤器， 在各生命周期中去校验请求的内容， 将原本在对外服务层做的校验前移， 保证了微服务的无状态性， 同时降低了微服务的测试难度， 让服务本身更集中关注业务逻辑的处理。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三路由详解&quot;&gt;三、路由详解&lt;/h2&gt;
&lt;p&gt;​ 在上面快速入门的请求路由示例中，我们对&lt;code&gt;Spring Cloud zuul&lt;/code&gt;中的两类路由功能已经做了简单的介绍，在本节中，将详细再介绍&lt;code&gt;Spring Cloud Zuul&lt;/code&gt;的路由功能&lt;/p&gt;
&lt;h4 id=&quot;传统路由配置&quot;&gt;传统路由配置&lt;/h4&gt;
&lt;p&gt;​ 所谓的传统路由配置就是不依赖于服务发现的机制下，通过配置文件中具体指定每个路由表达式与服务实例关系来实现API网关对外部请求的路由。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单实例配置：&lt;/strong&gt; 通过&lt;code&gt;zuul.routes.&amp;lt;route&amp;gt;.path&lt;/code&gt;与&lt;code&gt;zuul.routes.&amp;lt;route&amp;gt;.url&lt;/code&gt;参数对的方式进行配置，例如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;  zuul.routes.api-a-url.path=/api-a-url/**
  # 映射具体的url路径
  zuul.routes.api-a-url.url=http://localhost:8080/&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;该实例配置实现了/api-a-url/&lt;/strong&gt; 规则的请求路径转发到http://localhost:8080/ 地址的路由规则**&lt;/p&gt;
&lt;p&gt;比如，当一个请求http://localhost:5555/api-a-url/hello 被发送到API网关之后，由于/api-a-url/能够被配置类映射到，所以API网关会进行转发，转发到http://localhost:8080/hello 上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;多实例配置：&lt;/strong&gt; 通过&lt;code&gt;zuul.routes.&amp;lt;route&amp;gt;.path&lt;/code&gt; 与 &lt;code&gt;zuul.routes.&amp;lt;route&amp;gt;.serviceId&lt;/code&gt;参数对的方式进行配置，例如&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;  zuul.routes.api-a-url.path=/api-a-url/**
  zuul.routes.api-a-url.service-id=api-a-url
  ribbon.eureka.enabled=false
  api-a-url.ribbon.listOfServers=http://localhost:8080/, http://localhost:8081&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;该配置实现了对符合/api-a-url/&lt;/strong&gt; 规则的请求路径转发到 http://localhost:8080/ 和 http://localhost:8081两个实例地址的路由规则。它的配置方式与服务路由的配置方式一样，都采用了zuul.routes..path 与 zuul.routes..serviceId参数对的映射方式，只是这里的serviceId 是由手工命名的服务名称，配合 ribbon.listOfServers 参数实现服务与实例的维护。由于列表中有 8080 和 8081 两个实例，所以还需要ribbon 进行负载均衡的配置，因为Zuul 默认带有Ribbon，所以就可以直接使用**&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ribbon.eureka.enabled&lt;/code&gt; : 由于&lt;code&gt;zuul.routes.&amp;lt;route&amp;gt;.serviceId&lt;/code&gt; 指的是具体的服务名称，默认情况下ribbon 会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false, 否则 配置 的serviceId获取不到对应实例的清单&lt;/p&gt;
&lt;p&gt;&lt;code&gt;api-a-url.ribbon.listOfServers&lt;/code&gt;: 该参数内容与&lt;code&gt;zuul.routes.&amp;lt;route&amp;gt;.serviceid&lt;/code&gt;的配置相对应， 开头的user-service 对应了serviceId的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。&lt;/p&gt;
&lt;h4 id=&quot;服务路由配置&quot;&gt;服务路由配置&lt;/h4&gt;
&lt;p&gt;​ 对于服务路由，我们在上面的文字中已经讨论过，&lt;code&gt;Spring Cloud Zuul&lt;/code&gt;通过与&lt;code&gt;Spring Cloud eureka&lt;/code&gt;的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，不再需要像传统的方式指定服务的具体url地址，而是可以&lt;strong&gt;通过指定服务的名称&lt;/strong&gt;来配置，比如下面的例子就能很好说明：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;  zuul.routes.api-a.path=/api-a/**
  zuul.routes.api-a.serviceId=server-provider&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;zuul.routes..serviceId 中的serviceId 就是需要映射的具体服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于面向服务的配置，除了使用path 和 serviceId 的配置外，还有一种更简便的配置方式：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;    zuul.routes.api-a=/api-a/**&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面的这种配置方式使用了 zuul.routes.=的配置方式，与上面的 path 和 serviceId 共同使用的方式等价&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;默认路由规则&quot;&gt;默认路由规则&lt;/h5&gt;
&lt;p&gt;​ 由于默认情况下所有Eureka上的服务都会被Zuul&lt;code&gt;自动&lt;/code&gt;地创建映射关系来进行路由，这会使得一些我们不希望对外开放的服务也能被外部访问到，这个时候我们就需要屏蔽一些外部访问的服务&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;    zuul.ignored-services=*&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用zuul.ignored-services 参数来设置一个服务名匹配表达式来定义不自动创建路由的规则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;路径匹配&quot;&gt;路径匹配&lt;/h5&gt;
&lt;p&gt;​ 还记得我们上面配置过的 &lt;code&gt;/api-a/**&lt;/code&gt;吗？ 后面的 ** 代表什么意思呢？其实这是一种路由匹配风格，路由匹配路径表达式采用Ant风格定义，具体如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;匹配任意单个字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配任意数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;匹配任意数量的字符，支持多级目录&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;通过如下的示例，可以让你参考使用&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;/api-a/?&lt;/td&gt;
&lt;td&gt;它可以匹配/api-a/之后拼接的一个单个字符的路径，比如/api-a/b, /api-a/c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;/api-a/*&lt;/td&gt;
&lt;td&gt;它可以匹配/api-a/之后拼接的任意字符，但是不能跨层访问，比如可以访问到/api-a/bbb,/api-a/ccc,但是不能访问到/api-a/b/a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;/api-a/**&lt;/td&gt;
&lt;td&gt;它可以访问任意路径，比如 /api-a/bbb, /api-a/bbb/aaa, /api-a/ccc/bbb/aaa&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​&lt;/p&gt;
&lt;h5 id=&quot;properties文件-无法保证匹配顺序&quot;&gt;properties文件 无法保证匹配顺序&lt;/h5&gt;
&lt;p&gt;​ 例如我因为版本上线，需要在properties文件中重新配置一下路由的路径，我第一个路由的路径是&lt;code&gt;/api-a/**&lt;/code&gt;，对应的服务是&lt;code&gt;api-a&lt;/code&gt;， 我第二个路由的路径是&lt;code&gt;/api-a-pro/pro/**&lt;/code&gt;，对应的服务是&lt;code&gt;api-a-pro&lt;/code&gt;相当于第二个路径是第一个路径的子集，这样就无法保证映射的顺序，也就是说 properties 配置的内容无法保证有序性，所以为了避免这种情况，采用YAML文件来配置，能够解决上述问题&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;        zuul:
            routes:
                api-a-pro:
                    path: /api-a-pro/pro/**
                    serviceId: api-a-pro
                api-a:
                    path: /api-a/**
                    serviceId: api-a&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意： &lt;code&gt;:&lt;/code&gt;右边必须要有一个空格，这个yaml文件的书写规范&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;忽略表达式&quot;&gt;忽略表达式&lt;/h5&gt;
&lt;p&gt;​ 通过path参数定义的Ant表达式已经能够完成API网关上的路由规则配置功能，但是为了更细粒度和更为灵活的配置路由规则，zuul还提供了一个忽略表达式参数&lt;code&gt;zuul.ignored.patterns&lt;/code&gt;，该参数可以用来设置不希望被API网关进行路由的URL表达式&lt;/p&gt;
&lt;p&gt;比如，以上述示例为基础，如果不希望&lt;code&gt;/hello&lt;/code&gt;接口被路由，那么我们可以这样设置&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 过滤请求
zuul.ignored-patterns=/**/hello/**
zuul.routes.api-a.path=/api-a/**
zuul.routes.api-a.serviceId=server-provider&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么启动程序，访问http://localhost:5555/api-a/hello?accessToken=true，在api-gateway 的console 控制台上会显示如下信息&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; WARN 28605 --- [io-5555-exec-10] o.s.c.n.z.f.pre.PreDecorationFilter      : No route found for uri: /api-a/hello&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;路由前缀&quot;&gt;路由前缀&lt;/h5&gt;
&lt;p&gt;​ 为了方便全局地为路由规则增加前缀信息，Zuul提供了&lt;code&gt;zuul.prefix&lt;/code&gt;参数来进行设置。比如，希望为网关上的路由规则都增加/api 前缀，那么我们可以在配置文件中增加配置： &lt;code&gt;zuul.prefix=/api&lt;/code&gt;。另外，对于代理前缀会默认从路径中移除，我们可以通过设置&lt;code&gt;zuul.stripPrefix=false&lt;/code&gt;来关闭该移除代理前缀的动作，也可以通过&lt;code&gt;zuul.routes.&amp;lt;route&amp;gt;.strip-prefix=true&lt;/code&gt; 来对指定路由关闭移除代理前缀的动作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190531150831637-966721348.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;本地跳转&quot;&gt;本地跳转&lt;/h5&gt;
&lt;p&gt;​ 在实现的API网关的路由功能中，还支持forward形式的服务端跳转配置。实现方式也比较简单，直接在&lt;code&gt;forward:/xxx&lt;/code&gt; 请求路径就可以了。下述这种方式就实现了服务跳转。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;zuul.routes.api-b.path=/api/b/**
zuul.routes.api-b.url=forward:/local&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过http://localhost:5555/api/b/** 的请求会被转发到 http://localhost:5555/local/**，下面进行简单验证。需要在&lt;code&gt;api-gateway&lt;/code&gt; 中创建一个HelloController，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class HelloController {

    @RequestMapping(&quot;/local/hello&quot;)
    public String hello(){
        return &quot;Hello World Local&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;cookie与头信息&quot;&gt;Cookie与头信息&lt;/h5&gt;
&lt;p&gt;​ 默认情况下，Spring Cloud Zuul 在请求路由时，会过滤掉HTTP请求头信息中的一些敏感信息，用来防止它们被传递到下游的服务器。默认的敏感头信息通过&lt;code&gt;zuul.sensitiveHeaders&lt;/code&gt;参数定义，包括Cookie、Set-Cookie、Authorization 三个属性。&lt;/p&gt;
&lt;p&gt;有两种方式，一种是对全局的设置方式，但是这种设置方式比较暴力，不推荐&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;zuul.sensitiveHeaders=&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一种方式是对指定的服务开启自定义敏感头，这种方式比较推荐&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 方法一： 对指定路由开启自定义敏感头
zuul.routes.&amp;lt;router&amp;gt;.customSensitiveHeaders=true
# 方法二： 将指定路由的敏感头设置为空
zuul.routes.&amp;lt;router&amp;gt;.sensitiveHeaders=&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;hystrix-和-ribbon-支持&quot;&gt;Hystrix 和 Ribbon 支持&lt;/h5&gt;
&lt;p&gt;​ 点开pom.xml看到spring-cloud-starter-zuul的起步依赖中包括&lt;code&gt;spring-cloud-starter-hystrix&lt;/code&gt;和 &lt;code&gt;spring-cloud-starter-ribbon&lt;/code&gt;的依赖，所以Zuul天生就有线程隔离和断路器的自我保护功能。但是有一点需要注意：当使用path与url的映射关系来配置路由的时候，对于路由转发请求不会采用&lt;strong&gt;HystrixCommand&lt;/strong&gt;来包装，所以没有线程隔离和断路器保护。所以我们在使用zuul的时候尽量使用path 和 service的组合来进行配置。&lt;/p&gt;
&lt;p&gt;在使用Zuul网关的时候，可以通过Hystrix和Ribbon的参数来调整路由请求的各种超时时间配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds&lt;/strong&gt;:该参数用来设置API网关中转发路由请求的HystrixCommand超时时间，单位为毫秒。当路由转发的请求时间大于配置的时间之后。Hystrix会将该执行该命令标记为TIMEOUT并抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
    &quot;timestamp&quot;: 1559269203828,
    &quot;status&quot;: 500,
    &quot;error&quot;: &quot;Internal Server Error&quot;,
    &quot;exception&quot;: &quot;com.netflix.zuul.exception.ZuulException&quot;,
    &quot;message&quot;: &quot;TIMEOUT&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ribbon.ReadTimeout&lt;/strong&gt; 和 &lt;strong&gt;ribbon.SocketTimeout&lt;/strong&gt; ，一个是ribbon的读取超时时间，一个是ribbon的socket连接超时时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ribbon.ConnectTimeout&lt;/strong&gt; 表示用来转发请求的时候，创建链接的超时时间。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;如果ribbon.ConnectTimeout的配置时间大于hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 的时间，就表示为连接还未建立的情况下就被熔断，不会触发重试机制，直接返回 TIMEOUT 的超时信息。&lt;/p&gt;
&lt;p&gt;如果ribbon.ReadTimeout的配置时间小于hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 的超时时间，此时若路由请求的处理时间超过该配置值且依赖服务的请求还未响应的时候，会自动进行重试路由请求。如果还没有路由到的话，会返回NUMBEROF_RETRIES_NEXTSERVER_EXCEEDED 错误。&lt;/p&gt;
&lt;p&gt;如果大于的话，会直接返回TIMEOUT超时信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过上文的描述我们知道，在ribbon.ReadTimeout 超时时间小于hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds的超时时间的话，会自动进行请求的重试，我们可以通过下面的配置，禁用请求重试机制&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 全局关闭请求重试机制
zuul.retryable=false 
# 指定路由关闭请求重试机制
zuul.routes.&amp;lt;route&amp;gt;.retryable=false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章来源：&lt;/p&gt;
&lt;p&gt;《Spring Cloud 微服务实战》&lt;/p&gt;
&lt;p&gt;https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.1.0.RELEASE/multi/multi__router_and_filter_zuul.html&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 07:09:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>[TOC] 一、Zuul 介绍 ​ 通过前几篇文章的介绍，我们了解了Spring Cloud Eureka 如何搭建注册中心，Spring Cloud Ribbon 如何做负载均衡，Spring Cl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/10955333.html</dc:identifier>
</item>
<item>
<title>多媒体开发（10）：从视频中提取图片 - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10955304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10955304.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：提取视频中的图片吗？那很简单，播放视频再截图就行啦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;播放视频再截图的做法，当然也可以。但是，手动地截图会太累而且无法保证准确度，特别是需要反复提取图片时，或者需要提取“105秒那一瞬间的美女图片”时，或者我需要每秒出一张图片时，那有别的办法吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文介绍，如何使用FFmpeg实现从视频中提取图片的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般使用FFmpeg的方式，有两种，一种是使用FFmpeg的命令（也就是调用ffmpeg这个程序），另一种是调用FFmpeg的库文件。这里小程同样从命令行以及代码调用这两种方式，进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;一使用ffmpeg命令来解决问题&quot;&gt;（一）使用FFmpeg命令来解决问题&lt;/h3&gt;
&lt;p&gt;在安装FFmpeg后，打个命令就可以实现这个功能。对于FFmpeg的安装或调试，之前介绍过。&lt;/p&gt;
&lt;p&gt;提取图片可以这样，比如：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ffmpeg -ss 00:00:5 -i moments.mp4 -vframes 1 -f image2 -y a.png&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参数的意思是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ss表示开始提取图片的时间点，既可以用时分秒格式，也可以是多少秒。
如果使用到这个参数，那应该把它作为第一个参数，因为可以让FFmpeg提速。

i表示输入文件，就是视频文件。
vframes表示拿多少帧，也就是多少张图片。注意，这个参数要放在-i参数之后。
f表示提取出来的图片的格式。
y表示覆盖已有同名的图片。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比如，可以这样：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ffmpeg -i xxx.mp4 -r 1 -y -f image2 -t 5 -s 240*320 pc%3d.jpg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参数的意思是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;r表示每秒提取图片的帧数，即帧率，默认是25fps，上面设置为一秒拿一张图。
t表现持续提取多少秒，也可以用时分秒的格式来表示。
s表出来的图片的尺寸。
3%d表示以001、002这样的格式来命名输出的图片。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;小白：那么说，如果我发现视频某个时间点有美女的话，那我就可以用ss从这个时间点再前一点，然后用t来持续提取5秒，或者用vframes来提取几十张，那就准没漏了！也就是这样：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ffmpeg -ss 10 -t 5 -r 1 -i Movie-1.mp4 -f image2 -y pc-temp/image%3d.jpg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：看，这是提取到的美女图：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/ffmeg%E5%BA%94%E7%94%A8-%E4%BB%8E%E8%A7%86%E9%A2%91%E4%B8%AD%E6%8F%90%E5%8F%96%E5%9B%BE%E7%89%87/%E6%8F%90%E5%8F%96%E7%9A%84%E5%9B%BE%E7%89%871.jpeg&quot; alt=&quot;提取的图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一方面，你在提取到若干成图片后，有可能想把这些图片编码成视频，这时同样可以借助FFmpeg命令来完成。需要注意，图片变成视频，是需要视频编码器的，所以在安装FFmpeg时需要把视频编码器也带上（比如x264），这个小程在之前有所介绍。&lt;/p&gt;
&lt;p&gt;把图片编码成视频的命令是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ffmpeg -f image2 -i img%3d.jpg test.mp4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;img%d表示以&quot;img001&quot;, &quot;img002&quot;这种命名的文件（也就是之前提取出来的图片），按顺序使用。注意f参数要在i参数之前。&lt;/p&gt;
&lt;p&gt;你可能觉得mp4格式没有gif格式通用，于是又有了把mp4转成gif动态图的需求，这时还是可以敲打ffmpeg命令：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ffmpeg -i hello.mp4 hello.gif&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然这只是简单地把mp4转成gif，你也可以加上分辨率、码率之类的参数来控制，这里不细说。&lt;/p&gt;
&lt;h3 id=&quot;二写代码调用ffmpeg库来解决问题&quot;&gt;（二）写代码调用FFmpeg库来解决问题&lt;/h3&gt;
&lt;p&gt;通过写代码调用FFmpeg库的方式来提取图片，并且保存成24bit的位图。&lt;/p&gt;
&lt;p&gt;小程先贴上演示代码，再在后面做一些解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;libavcodec/avcodec.h&quot;
#include &quot;libavformat/avformat.h&quot;
#include &quot;libswscale/swscale.h&quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

typedef struct {
    unsigned int filesize;
    unsigned short reserved1;
    unsigned short reserved2;
    unsigned int dataoffset;
}BITMAP_FILE_HEADER;

typedef struct {
    unsigned int infosize;
    int width;
    int height;
    unsigned short planecount;
    unsigned short bitcount;
    unsigned int compressiontype;
    unsigned int imagedatasize;
    int xpixpermeter;
    int ypixpermeter;
    unsigned int colorusedcount;
    unsigned int colorimportantcount;
}BITMAP_INFO;

void extractpicture(const char* filepath) {
    av_register_all();
    av_log_set_level(AV_LOG_DEBUG);
    AVFormatContext* formatContext = avformat_alloc_context();
    int status = 0;
    int success = 0;
    int videostreamidx = -1;
    AVCodecContext* codecContext = NULL;
    status = avformat_open_input(&amp;amp;formatContext, filepath, NULL, NULL);
    if (status == 0) {
        status = avformat_find_stream_info(formatContext, NULL);
        if (status &amp;gt;= 0) {
            for (int i = 0; i &amp;lt; formatContext-&amp;gt;nb_streams; i ++) {
                if (formatContext-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO) {
                    videostreamidx = i;
                    break;
                }
            }
            if (videostreamidx &amp;gt; -1) {
                codecContext = formatContext-&amp;gt;streams[videostreamidx]-&amp;gt;codec;
                AVCodec* codec = avcodec_find_decoder(codecContext-&amp;gt;codec_id);
                if (codec) {
                    status = avcodec_open2(codecContext, codec, NULL);
                    if (status == 0) {
                        success = 1;
                    }
                }
            }
        }
        else {
            av_log(NULL, AV_LOG_DEBUG, &quot;avformat_find_stream_info error\n&quot;);
        }
    }
    if (success) {
        av_dump_format(formatContext, 0, filepath, 0);
        int gotframe = 0;
        AVFrame* frame = av_frame_alloc();
        int decodelen = 0;
        int limitcount = 10;
        int pcindex = 0;
        unsigned char* rgbdata = (unsigned char*)malloc(avpicture_get_size(AV_PIX_FMT_RGB24, codecContext-&amp;gt;width, codecContext-&amp;gt;height));
        AVFrame* rgbframe = av_frame_alloc();
        avpicture_fill((AVPicture*)rgbframe, rgbdata, AV_PIX_FMT_RGB24, codecContext-&amp;gt;width, codecContext-&amp;gt;height);
        struct SwsContext* swscontext = sws_getContext(codecContext-&amp;gt;width, codecContext-&amp;gt;height, codecContext-&amp;gt;pix_fmt, 
                codecContext-&amp;gt;width, codecContext-&amp;gt;height, AV_PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);
        while (pcindex &amp;lt; limitcount) {
            AVPacket packet;
            av_init_packet( &amp;amp;packet );
            status = av_read_frame(formatContext, &amp;amp;packet);
            if (status &amp;lt; 0) {
                if (status == AVERROR_EOF) {
                    av_log(NULL, AV_LOG_DEBUG, &quot;read end for file\n&quot;);
                }
                else {
                    av_log(NULL, AV_LOG_DEBUG, &quot;av_read_frame error\n&quot;);
                }
                av_packet_unref(&amp;amp;packet);
                break;  
            }
            else {
                if (packet.stream_index == videostreamidx) {
                    decodelen = avcodec_decode_video2(codecContext, frame, &amp;amp;gotframe, &amp;amp;packet);
                    if (decodelen &amp;gt; 0 &amp;amp;&amp;amp; gotframe) {
                        frame-&amp;gt;data[0] = frame-&amp;gt;data[0] + frame-&amp;gt;linesize[0] * (codecContext-&amp;gt;height - 1);
                        frame-&amp;gt;data[1] = frame-&amp;gt;data[1] + frame-&amp;gt;linesize[1] * (codecContext-&amp;gt;height / 2 - 1);
                        frame-&amp;gt;data[2] = frame-&amp;gt;data[2] + frame-&amp;gt;linesize[2] * (codecContext-&amp;gt;height / 2 - 1);
                        frame-&amp;gt;linesize[0] *= -1;
                        frame-&amp;gt;linesize[1] *= -1;
                        frame-&amp;gt;linesize[2] *= -1;
                        sws_scale(swscontext, frame-&amp;gt;data, frame-&amp;gt;linesize, 0, 
                                codecContext-&amp;gt;height, rgbframe-&amp;gt;data, rgbframe-&amp;gt;linesize);  
                        char filename[12] = {0};
                        sprintf(filename, &quot;pc%03d.bmp&quot;, ++ pcindex);
                        FILE* file = fopen(filename, &quot;wb&quot;);
                        if (file) {
                            int pixcount = codecContext-&amp;gt;width * codecContext-&amp;gt;height;
                            BITMAP_FILE_HEADER fileheader = {0};
                            fileheader.filesize = 2+sizeof(BITMAP_FILE_HEADER)+sizeof(BITMAP_INFO)+pixcount * 3;
                            fileheader.dataoffset = 0x36;
                            BITMAP_INFO bmpinfo = {0};
                            bmpinfo.infosize = sizeof(BITMAP_INFO);
                            bmpinfo.width = codecContext-&amp;gt;width;
                            bmpinfo.height = codecContext-&amp;gt;height;
                            bmpinfo.planecount = 1;
                            bmpinfo.bitcount = 24;
                            bmpinfo.xpixpermeter = 5000;
                            bmpinfo.ypixpermeter = 5000;
                            unsigned short ftype = 0x4d42;
                            fwrite(&amp;amp;ftype, sizeof ftype, 1, file);
                            fwrite(&amp;amp;fileheader, sizeof fileheader, 1, file);
                            fwrite(&amp;amp;bmpinfo, sizeof bmpinfo, 1, file);
                            fwrite(rgbframe-&amp;gt;data[0], pixcount*3, 1, file);
                            fclose(file);
                        }
                    }
                }
            } 
            av_packet_unref(&amp;amp;packet);
        }
        av_frame_free(&amp;amp;rgbframe);
        free(rgbdata);
        av_frame_free(&amp;amp;frame);
        sws_freeContext(swscontext);
    }
    avformat_free_context(formatContext);
}

int main(int argc, char *argv[])
{
    extractpicture(&quot;moments.mp4&quot;);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序演示了把解码后的图片数据保存成位图的过程。如果有需要可以做更多的修改，比如av_seek_frame到适当的位置再开始解码与保存位图，也可以控制多少帧后保存一张位图，等等。&lt;/li&gt;
&lt;li&gt;av_register_all注册“所有”，所有的编解码器、muxer与demuxer等等（前提是configure编译时有enable，才会真正使用到），这一步是关键的初始化工作，没有这一步，FFmpeg很可能不能如期工作。&lt;/li&gt;
&lt;li&gt;avformat_open_input打开输入。“输入”是一个抽象，这里具体成文件。这一步之后，就获得了一些文件格式信息。&lt;/li&gt;
&lt;li&gt;avformat_find_stream_info查找流的信息。多媒体数据由流组成，这一步就是获取媒体格式信息，有可能比较耗时。这一步后，流使用的编解码器被确定下来。&lt;/li&gt;
&lt;li&gt;avcodec_find_decoder找到解码器。&lt;/li&gt;
&lt;li&gt;avcodec_open2打开解码器。&lt;/li&gt;
&lt;li&gt;av_read_frame读取一个packet，未解码。&lt;/li&gt;
&lt;li&gt;avcodec_decode_video2解码一个视频帧。&lt;/li&gt;
&lt;li&gt;sws_getContext获取并初始化一个SwsContext场景，swscontext不仅可以缩放图片，还可以转换颜色布局。&lt;/li&gt;
&lt;li&gt;sws_scale缩放或转换。&lt;/li&gt;
&lt;li&gt;在调用sws_scale之前，对frame-&amp;gt;data跟frame-&amp;gt;linesize做的处理，是为了调整坐标系，让图片适合位图的坐标系（从下往上，从左往右），这样转换出来的位图才不会颠倒。&lt;/li&gt;
&lt;li&gt;这里选择的是24位的位图（没有调色板），在写入rgb数据前，先把文件头与位图信息写好。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此，在视频中提取图片的实现，就介绍完毕了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结一下，本文从直接使用ffmpeg命令行，以及写代码调用FFmpeg库文件的两种方式入手，介绍了如何实现从视频中提取图片的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E9%80%BB%E8%BE%91%E9%A2%98/%E9%80%BB2.png&quot; alt=&quot;right&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 07:03:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>小白：提取视频中的图片吗？那很简单，播放视频再截图就行啦。 播放视频再截图的做法，当然也可以。但是，手动地截图会太累而且无法保证准确度，特别是需要反复提取图片时，或者需要提取“105秒那一瞬间的美女图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/freeself/p/10955304.html</dc:identifier>
</item>
<item>
<title>【WEB基础】HTML &amp; CSS 基础入门（10）布局与定位 - 青衫烟雨客</title>
<link>http://www.cnblogs.com/nnzhang/p/10955097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnzhang/p/10955097.html</guid>
<description>&lt;h2&gt;块级元素和行内元素&lt;/h2&gt;
&lt;p&gt;HTML里的元素可以分为块级元素和行内元素两大类：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;🅰块级元素：&lt;/strong&gt;&lt;/span&gt;块级元素典型特点就是它要独占一行，它后面跟随的其它元素都会被挤到下一行，可以将块级元素理解为一个矩形容器，有自己的宽度和高度。比如：&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;hi&amp;gt;&amp;lt;form&amp;gt;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;等都是块级元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;🅱行内元素：&lt;/strong&gt;&lt;/span&gt;行内元素与块级元素相反，在宽度允许的情况下，一行可以容纳多个行内元素，它没有固定形状，无法设置高度与宽度。比如：&amp;lt;span&amp;gt;&amp;lt;a&amp;gt;&amp;lt;input&amp;gt;&amp;lt;img&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;em&amp;gt;等都是行内元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;相互转换：&lt;/strong&gt;&lt;/span&gt;我们可以使用display:inline将块级元素转换为行内元素，可以使用display:block将行内元素转换为块级元素。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为每个元素加上不同的背景色加以区分&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        div &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#00FFFF&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        span &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #66FF33&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        strong &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#CC9900&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        p &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#CC99FF&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        a &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#ADFF2F&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        #p1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;inline&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #span1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;块元素div独占一行&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;块元素p独占一行&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;行内元素span&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;行内元素a&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;行内元素strong&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;p1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;块元素p转换为行内元素&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;span1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;行内元素span转换为块级元素,独占一行&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190531142102508-1179186314.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;流动布局&lt;/h2&gt;
&lt;p&gt;流动布局就是元素按照正常文档流自上而下的排列，所有元素按先后顺序逐行往下排序，块级元素独占一行，行内元素在每行中按照从左到右的顺序依次排列。流动布局是网页默认的显示规则。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为每个元素加上不同的背景色加以区分&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        div &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#00FFFF&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        span &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #66FF33&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        strong &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#CC9900&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        p &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#CC99FF&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        i &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#ADFF2F&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        em &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; 
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#D19275&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; 
            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将em转换为块级元素&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;正常文档流，按先后顺序依次排列&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;div块级元素（独占一行）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;span1行内元素&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strong行内元素&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;p块级元素（独占一行）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;i行内元素&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;em行内元素(转换为块级元素，独占一行)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190531142414331-152447782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;浮动布局&lt;/h2&gt;
&lt;p&gt;浮动布局是利用CSS完成网页布局最重要的方式，使用极其灵活多变，这里仅说明基本的概念，要熟练掌握还需多看、多练。在上面的流动布局我们了解到以div为首的块级元素会独占一行，在网页布局中，最常用的就是div，通常把div当做一个盒子，再来把一个个div盒子进行排列。但是div独占一行，我们想在一行并列放置两个、甚至三个div盒子怎么办呢？浮动就可以完成这个事情。看个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #outside &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;外层div样式&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;280px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;160px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#F0E68C&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1px solid red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #div1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;div1样式，不浮动&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2px dashed red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #div2 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;div2样式，左浮动&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;120px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;60px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置左浮动&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #div3 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;div3样式，右浮动&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置右浮动&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;outside&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;外层div&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;div1未设置浮动，独占一行&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;div2左浮动,设置了宽和高&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;div3右浮动&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190531142459576-1491732329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的例子定义了4个div元素，【outside】是最外层div，可以理解为一个大盒子里面放三个小盒子，为显示直观，每个div都设置了边距和背景。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;▶div1未设置浮动&lt;/span&gt;，它在大盒子里面独占一行，为它设置了红色的虚线边框，设置了边距。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;▶div2设置了&lt;strong&gt;左浮动&lt;/strong&gt;&lt;/span&gt;，填充了绿色背景，设置了宽和高，此时div2不在独占一行，而是按照设置的宽度和高度靠左显示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;▶div3设置了&lt;strong&gt;右浮动&lt;/strong&gt;&lt;/span&gt;，填充了红色背景，没有设置宽和高，此时div3会根据里面的内容确定其尺寸，然后靠右显示，同样不在独占一行。&lt;/p&gt;
&lt;h2&gt;定位布局&lt;/h2&gt;
&lt;p&gt;浮动布局比较灵活，不易控制。定位布局相对而言较易使用，当然，在实际开发中，往往是两者配合使用，以满足布局的个性需求。定位布局主要是通过为&lt;strong&gt;【position】&lt;/strong&gt;属性设置不同的值来完成布局的。该值主要有以下三种：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、值fixed（固定定位）&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;以浏览器为基准，指定定位元素与浏览器4条边的距离完成定位，分别通过top、bottom、left和right这四个属性的设置来完成。其实，这4个属性未必全部都需要设置，只需要设置top和left即可。当元素设置了固定定位，如果页面过长出现滚动条，它也不会随滚动条的滚动而移动。&lt;/p&gt;
&lt;p&gt; 示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #div1
        &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;220px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;600px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#DDA0DD&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #div2
        &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置元素为固定定位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;与浏览器顶部边框距离40px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;150px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;与浏览器左部边框距离150px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;120px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#DAA520&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;div1:未定位&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;第二行&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;第三行&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;第四行&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;div2：设置固定定位，距离浏览器上边框40px,左边框150px&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190531145034830-2088495500.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、值relative（相对定位）：&lt;/strong&gt;&lt;/span&gt;以需定位元素按正常文档流所在位置为参照，然后使定位元素相对于它在原本的正常文档流的位置偏移指定的距离。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        div&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将三个div设置相同的边距、边框和尺寸&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2px dashed red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;34px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将三个div设置不同的背景&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        #div1&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#98FB98&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #div2&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#87CEEB&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置相对定位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;30px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #div3&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#FF00FF&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一个盒子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第二个盒子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第三个盒子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190531142743575-22456441.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、值absolute（绝对定位）：&lt;/strong&gt;&lt;/span&gt;绝对定位的元素是相对于离它最近的一个已定位的父元素为参照进行定位的（默认是body）。下面的示例有两个div，可以理解为父盒子和子盒子，父盒子设置绝对定位，以body为参照设置位置。子盒子也是绝对定位，以父盒子为定位参照。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #father&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;外层父盒子&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
          height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 170px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
          background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; orange&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
          position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;绝对定位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;30px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;顶部距离body上边框30px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;左侧距离body左边框50px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #son&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;里层盒子&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
          height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 80px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
          background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; pink&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
          position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;绝对定位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;顶部距离父盒子上边框40px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;60px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;左侧距离父盒子左边框60px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;father&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;son&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190531142950561-1133064250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在图上加上点注释看得会更清楚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190531143032206-569925575.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;------------------&lt;/em&gt;-------- &lt;/span&gt;END &lt;em&gt;------------------&lt;/em&gt;--------&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 06:53:00 +0000</pubDate>
<dc:creator>青衫烟雨客</dc:creator>
<og:description>块级元素和行内元素 HTML里的元素可以分为块级元素和行内元素两大类： 🅰块级元素：块级元素典型特点就是它要独占一行，它后面跟随的其它元素都会被挤到下一行，可以将块级元素理解为一个矩形</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nnzhang/p/10955097.html</dc:identifier>
</item>
<item>
<title>JavaScript 系列--JavaScript一些奇淫技巧的实现方法（二）数字格式化 1234567890转1,234,567,890；argruments 对象(类数组)转换成数组 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10955182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10955182.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前写了一篇文章：&lt;span&gt;JavaScript 系列--JavaScript一些奇淫技巧的实现方法（一）简短的sleep函数，获取时间戳&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mwcxs.top/page/746.html&quot;&gt;https://www.mwcxs.top/page/746.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍了sleep函数和获取时间戳的方法。接下来我们来介绍数字格式化1234567890 --&amp;gt; 1,234,567,890&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、数字格式化 1234567890 --&amp;gt; 1,234,567,890&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、普通版&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;优点：自我感觉比网上写的一堆 for循环 还有 if-else 判断的逻辑更加清晰直白。&lt;br/&gt;缺点：太普通&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、进阶版&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;优点：把 JS 的 API 玩的了如指掌&lt;br/&gt;缺点：不好理解&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、正则版&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;formatNumber(&lt;span class=&quot;hljs-params&quot;&gt;str){
    &lt;span class=&quot;hljs-keyword&quot;&gt;return str.replace(/(?!^)(?=(\d{3})+$)/g,&lt;span class=&quot;hljs-string&quot;&gt;',')
}
formatNumber(&lt;span class=&quot;hljs-string&quot;&gt;&quot;1234567890&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看看正则的分析：&lt;/p&gt;
&lt;p&gt;（1）/(?!^)(?=(\d{3})+\b)/g：匹配的这个位置不能是开头(?!^)&lt;/p&gt;
&lt;p&gt;（2）(\d{3})+：必须是1个或者多个的3个连续数字&lt;/p&gt;
&lt;p&gt;优点：代码少，简洁。&lt;/p&gt;
&lt;p&gt;缺点：正则表达式的位置匹配很重要，可以参考这个：&lt;a href=&quot;https://www.mwcxs.top/page/587.html&quot;&gt;https://www.mwcxs.top/page/587.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、API版本&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1234567890).toLocaleString(&lt;span class=&quot;hljs-string&quot;&gt;'en-us');
(1234567890).toLocaleString();
1234567890..toLocaleString();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能还不知道 &lt;code&gt;JavaScript&lt;/code&gt; 的 &lt;code&gt;toLocaleString&lt;/code&gt; 还可以这么玩。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;123456789..toLocaleString(&lt;span class=&quot;hljs-string&quot;&gt;'zh-hans-cn-u-nu-hanidec',{useGrouping: &lt;span class=&quot;hljs-literal&quot;&gt;false}); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以使用Intl对象，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Intl 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比，数字格式化，日期和时间格式化。Collator，NumberFormat 和 DateTimeFormat 对象的构造函数是 Intl 对象的属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-built_in&quot;&gt;Intl.NumberFormat().format(&lt;span class=&quot;hljs-number&quot;&gt;1234567890) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：简单粗暴，直接调用api&lt;/p&gt;
&lt;p&gt;缺点：&lt;a href=&quot;https://caniuse.com/#search=Intl&quot;&gt;Intl兼容性&lt;/a&gt;不太好，不过 toLocaleString的话 IE6 都支持&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端知识点：Intl对象 和 toLocaleString的方法。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、argruments 对象(类数组)转换成数组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那什么是类数组？就是跟数组很像，但是他是对象，格式像数组所以叫类数组。比如：{0:a,1:b,2:c,length:3}，按照数组下标排序的对象，还有一个length的属性，有时候我们需要这种对象能调用数组下的一个方法，这时候就需要把把类数组转化成真正的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、普通版&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var makeArray = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;arr){
    &lt;span class=&quot;hljs-keyword&quot;&gt;var res = [];
    &lt;span class=&quot;hljs-keyword&quot;&gt;if(arr != &lt;span class=&quot;hljs-literal&quot;&gt;null){
        &lt;span class=&quot;hljs-keyword&quot;&gt;var i = arr.length;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if(i == &lt;span class=&quot;hljs-literal&quot;&gt;null || &lt;span class=&quot;hljs-keyword&quot;&gt;typeof arr == &lt;span class=&quot;hljs-string&quot;&gt;&quot;string&quot;) res[&lt;span class=&quot;hljs-number&quot;&gt;0] = arr;
        &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;while(i){res[--i] = arr[i];}
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return res;
};
&lt;span class=&quot;hljs-keyword&quot;&gt;var obj = {&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-string&quot;&gt;'a',&lt;span class=&quot;hljs-number&quot;&gt;1:&lt;span class=&quot;hljs-string&quot;&gt;'b',&lt;span class=&quot;hljs-number&quot;&gt;2:&lt;span class=&quot;hljs-string&quot;&gt;'c',length:&lt;span class=&quot;hljs-number&quot;&gt;3};
makeArray(obj);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：通用版本，没有任何兼容性问题&lt;br/&gt;缺点：暂时没有啥缺点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、进阶版&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;大家用过最常用的方法，至于为什么可以这么用，很多人估计也是一知半解，要搞清为什么里面的原因，我们还是从规范和源码说起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;slice.call&lt;/code&gt; 的作用原理&lt;/strong&gt;就是，利用 &lt;code&gt;call&lt;/code&gt;，将 &lt;code&gt;slice&lt;/code&gt; 的方法作用于 &lt;code&gt;arrayLike&lt;/code&gt;，&lt;code&gt;slice&lt;/code&gt; 的两个参数为空，&lt;code&gt;slice&lt;/code&gt; 内部解析使得 &lt;code&gt;arguments.lengt&lt;/code&gt; 等于0的时候 相当于处理 &lt;code&gt;slice(0)&lt;/code&gt; ： 即选择整个数组，&lt;code&gt;slice&lt;/code&gt; 方法内部没有强制判断必须是 &lt;code&gt;Array&lt;/code&gt; 类型，&lt;code&gt;slice&lt;/code&gt; 返回的是新建的数组（使用循环取值）”，所以这样就实现了类数组到数组的转化，&lt;code&gt;call&lt;/code&gt; 这个神奇的方法、&lt;code&gt;slice&lt;/code&gt; 的处理缺一不可。&lt;/p&gt;
&lt;p&gt;直接看 &lt;code&gt;slice&lt;/code&gt; 怎么实现的吧。其实就是将 &lt;code&gt;array-like&lt;/code&gt; 对象通过下标操作放进了新的 &lt;code&gt;Array&lt;/code&gt; 里面，下面是源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;优点：最常用的版本，兼容性强。&lt;/p&gt;
&lt;p&gt;缺点：ie 低版本，无法处理 dom 集合的 slice call 转数组。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、ES6版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Array.from&lt;/code&gt;, 值需要对象有 &lt;code&gt;length&lt;/code&gt; 属性, 就可以转换成数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var arr = &lt;span class=&quot;hljs-built_in&quot;&gt;Array.from(&lt;span class=&quot;hljs-built_in&quot;&gt;arguments);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩展运算符&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var args = [...arguments];&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt; 中的扩展运算符...也能将某些数据结构转换成数组，这种数据结构必须有便利器接口。&lt;/p&gt;
&lt;p&gt;优点：直接使用内置 API，简单易维护&lt;br/&gt;缺点：兼容性，使用 babel 的 profill 转化可能使代码变多，文件包变大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端知识点：slice 方法的具体原理&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;【注：我是saucxs，也叫songEagle，松宝写代码，文章首发于sau交流学习社区（https://www.mwcxs.top），关注我们每天阅读更多精彩内容】&lt;/p&gt;

&lt;/blockquote&gt;
</description>
<pubDate>Fri, 31 May 2019 06:45:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>一、前言 之前写了一篇文章：JavaScript 系列--JavaScript一些奇淫技巧的实现方法（一）简短的sleep函数，获取时间戳 https://www.mwcxs.top/page/746</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chengxs/p/10955182.html</dc:identifier>
</item>
<item>
<title>机器学习框架ML.NET学习笔记【7】人物图片颜值判断 - seabluescn</title>
<link>http://www.cnblogs.com/seabluescn/p/10947650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seabluescn/p/10947650.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 这次要解决的问题是输入一张照片，输出人物的颜值数据。&lt;/p&gt;
&lt;p&gt;学习样本来源于华南理工大学发布的SCUT-FBP5500数据集，数据集包括 5500 人，每人按颜值魅力打分，分值在 1 到 5 分之间。其中包括男性、女性、中国人、外国人四个分类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190530093132229-2133345042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SCUT-FBP5500_full.csv文件标记了每个图片人物的颜值打分数据。（我把分值一项乘以了20，变成了满分100分，不影响计算结果）&lt;/p&gt;
&lt;p&gt;整个程序处理流程和前一篇图片分类的基本一致，唯一的区别，分类用的是多元分类算法，这次采用的是回归算法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、源码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 下面是全部代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('28b29124-c0c6-49c8-9718-0b588c0e4571')&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_28b29124-c0c6-49c8-9718-0b588c0e4571&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_28b29124-c0c6-49c8-9718-0b588c0e4571&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('28b29124-c0c6-49c8-9718-0b588c0e4571',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_28b29124-c0c6-49c8-9718-0b588c0e4571&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TensorFlow_ImageClassification
{    

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Assets files download from:&lt;/span&gt;&lt;span&gt;https://gitee.com/seabluescn/ML_Assets&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AssetsFolder = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;D:\StepByStep\Blogs\ML_Assets&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TrainDataFolder = Path.Combine(AssetsFolder, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FaceValueDetection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SCUT-FBP5500&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TrainTagsPath = Path.Combine(AssetsFolder, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FaceValueDetection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SCUT-FBP5500_asia_full.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TestDataFolder = Path.Combine(AssetsFolder, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FaceValueDetection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testimages&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; inceptionPb = Path.Combine(AssetsFolder, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TensorFlow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tensorflow_inception_graph.pb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; imageClassifierZip = Path.Combine(Environment.CurrentDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MLModel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imageClassifier.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置用常量&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ImageNetSettings
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; imageHeight = &lt;span&gt;224&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; imageWidth = &lt;span&gt;224&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; mean = &lt;span&gt;117&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; scale = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; channelsLast = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            TrainAndSaveModel();
            LoadAndPrediction();

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hit any key to finish the app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TrainAndSaveModel()
        {
            MLContext mlContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MLContext(seed: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 1: 准备数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; fulldata = mlContext.Data.LoadFromTextFile&amp;lt;ImageNetData&amp;gt;(path: TrainTagsPath, separatorChar: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, hasHeader: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainTestData = mlContext.Data.TrainTestSplit(fulldata, testFraction: &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainData =&lt;span&gt; trainTestData.TrainSet;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testData =&lt;span&gt; trainTestData.TestSet;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 2：创建学习管道&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; pipeline = mlContext.Transforms.LoadImages(outputColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, imageFolder: TrainDataFolder, inputColumnName: nameof(ImageNetData.ImagePath))
                .Append(mlContext.Transforms.ResizeImages(outputColumnName: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, imageWidth: ImageNetSettings.imageWidth, imageHeight: ImageNetSettings.imageHeight, inputColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                .Append(mlContext.Transforms.ExtractPixels(outputColumnName: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, interleavePixelColors: ImageNetSettings.channelsLast, offsetImage: ImageNetSettings.mean))
                .Append(mlContext.Model.LoadTensorFlowModel(inceptionPb).
                     ScoreTensorFlowModel(outputColumnNames: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;softmax2_pre_activation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, inputColumnNames: &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, addBatchDimensionInput: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
                .Append(mlContext.Regression.Trainers.LbfgsPoissonRegression(labelColumnName: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, featureColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;softmax2_pre_activation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 3：通过训练数据调整模型             &lt;/span&gt;
            ITransformer model =&lt;span&gt; pipeline.Fit(trainData);          

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 4：评估模型           &lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; predictions =&lt;span&gt; model.Transform(testData); 
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metrics = mlContext.Regression.Evaluate(predictions, labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, scoreColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            PrintRegressionMetrics( metrics);          

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;STEP 5：保存模型&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;====== Save model to local file =========&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            mlContext.Model.Save(model, trainData.Schema, imageClassifierZip);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LoadAndPrediction()
        {
            MLContext mlContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MLContext(seed: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load the model&lt;/span&gt;
            ITransformer loadedModel = mlContext.Model.Load(imageClassifierZip, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; modelInputSchema);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make prediction function (input = ImageNetData, output = ImageNetPrediction)&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; predictor = mlContext.Model.CreatePredictionEngine&amp;lt;ImageNetData, ImageNetPrediction&amp;gt;&lt;span&gt;(loadedModel);
            
            DirectoryInfo testdir &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectoryInfo(TestDataFolder);
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; jpgfile &lt;span&gt;in&lt;/span&gt; testdir.GetFiles(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                ImageNetData image &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImageNetData();
                image.ImagePath &lt;/span&gt;=&lt;span&gt; jpgfile.FullName;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pred =&lt;span&gt; predictor.Predict(image);

                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Filename:{jpgfile.Name}:\tPredict Result:{pred.FaceValue}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }       
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageNetData
    {
        [LoadColumn(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ImagePath;

        [LoadColumn(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; Label;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageNetPrediction
    {
        [ColumnName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; FaceValue;
    }   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、数据处理通道&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 2：创建学习管道&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pipeline =&lt;span&gt; mlContext.Transforms.LoadImages(...)
    .Append(mlContext.Transforms.ResizeImages(...)
    .Append(mlContext.Transforms.ExtractPixels(...)
    .Append(mlContext.Model.LoadTensorFlowModel(inceptionPb)
        .ScoreTensorFlowModel(outputColumnNames: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;softmax2_pre_activation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, inputColumnNames: &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, addBatchDimensionInput: &lt;span&gt;true&lt;/span&gt;))    &lt;br/&gt;.Append(mlContext.Regression.Trainers.LbfgsPoissonRegression(labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, featureColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;softmax2_pre_activation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; LoadImages、ResizeImages、ExtractPixels：上篇文章都已经介绍过了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ScoreTensorFlowModel方法把图片像素值转换为图片特征数据，并存储在softmax2_pre_activation列，Label列保存的是颜值数据，通过回归算法形成模型，当输入新的特征数据时就可以得出对应的颜值数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算法采用的是：L-BFGS Poisson Regression （拟牛顿法泊松回归）&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、预测结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在网上找了一些大头照，通过程序进行预测，右侧是预测结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190530095101264-1498286418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;预测结果虽然和我认为的不完全一致，但总体上可以接受，大方向没什么问题，存在偏差主要有以下几个因素：&lt;/p&gt;
&lt;p&gt;1、学习样本的客观性存疑，其打分数据可能是分配给多人打分后汇总的，每个人标准不一致；&lt;/p&gt;
&lt;p&gt;2、被检测图片不是很规范，如尺寸、比例、背景等；&lt;/p&gt;
&lt;p&gt;3、颜值本身就不具备客观性，不存在标准答案，如果我说林心如比如花漂亮，大家肯定都同意，但我如果说古力娜扎比迪丽热巴漂亮，肯定有人不赞成。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、资源获取 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码下载地址：https://github.com/seabluescn/Study_ML.NET&lt;/p&gt;
&lt;p&gt;工程名称：TensorFlow_FaceValueDetection&lt;/p&gt;
&lt;p&gt;资源获取：https://gitee.com/seabluescn/ML_Assets （SCUT-FBP5500）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;点击查看机器学习框架ML.NET学习笔记系列文章目录&quot; href=&quot;https://www.cnblogs.com/seabluescn/p/10904391.html&quot; target=&quot;_blank&quot;&gt;点击查看机器学习框架ML.NET学习笔记系列文章目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 06:45:00 +0000</pubDate>
<dc:creator>seabluescn</dc:creator>
<og:description>一个通过ML.NET实现人脸颜值检测的程序。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seabluescn/p/10947650.html</dc:identifier>
</item>
<item>
<title>mongoDB看这篇就够了 - pubdreamcc</title>
<link>http://www.cnblogs.com/dreamcc/p/10955069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dreamcc/p/10955069.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;hello，小伙伴们，我是 &lt;code&gt;pubdreamcc&lt;/code&gt; ，本篇文章依旧出至于我的 GitHub仓库 &lt;code&gt;node学习教程&lt;/code&gt; ，如果你觉得我写的还不错，欢迎给个 &lt;code&gt;star&lt;/code&gt; ，小伙伴们的 &lt;code&gt;star&lt;/code&gt; 是我持续更新的动力 ！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;node学习教程&lt;a href=&quot;https://github.com/pubdreamcc/Node.js&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装-mongodb&quot;&gt;安装 &lt;code&gt;mongoDB&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;安装这里，我就不详细介绍，大家可以根据官网选择匹配自己电脑系统的版本安装即可。&lt;/p&gt;
&lt;p&gt;mongoDB download地址： &lt;a href=&quot;https://www.mongodb.com/download-center&quot;&gt;download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载下来之后，点击打开直接下一步，下一步就 &lt;code&gt;ok&lt;/code&gt; 了。&lt;/p&gt;
&lt;h2 id=&quot;初体验&quot;&gt;初体验&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;配置环境变量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;安装完成后，会在安装目录下面生成一个 &lt;code&gt;mongoDB&lt;/code&gt; 的文件夹，打开文件夹，进入 &lt;code&gt;bin&lt;/code&gt; 文件夹中，把这里的路径配置成环境变量。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建存储数据库文件 &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在任意盘符根目录下创建一个 &lt;code&gt;data&lt;/code&gt; 目录，用来存放数据库文件。 &lt;code&gt;mongoDB&lt;/code&gt; 会自动把自己安装位置的盘符根目录下的 &lt;code&gt;data&lt;/code&gt; 文件夹作为自己的数据存储目录，这里也可以直接在安装位置所在盘符创建。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动 mongoDB 数据库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果 &lt;code&gt;data&lt;/code&gt; 目录创建在安装位置的盘符根目录下，直接&lt;br/&gt;打开命令行，敲入：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mongod&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是其他位置，则需要指定数据存放的位置:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mongod --dbpath 文件路径&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果看到输出： &lt;code&gt;waiting for connections on port 27017&lt;/code&gt; 说明启动数据库成功。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;连接数据库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再打开一个命令行，敲入 &lt;code&gt;mongo&lt;/code&gt; ，则会默认连接到本地开启的数据库。好了，到这里我们就完成了如何开启一个 &lt;code&gt;mongoDB&lt;/code&gt; 数据库了，接下来只需往数据库里存数据，操作数据即可。&lt;/p&gt;
&lt;h2 id=&quot;mongodb-概念解析&quot;&gt;&lt;code&gt;MongoDB&lt;/code&gt; 概念解析&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;mongodb&lt;/code&gt;中有三个基本核心的概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;文档&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它们之间是逐层包含的关系，一个集合可以包含多个文档，一个数据库可以有多个集合，下面听我逐一道来：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;文档&lt;/code&gt; ： 文档是一个键值(&lt;code&gt;key-value&lt;/code&gt;)对(即&lt;code&gt;BSON&lt;/code&gt;)，本质类似于&lt;code&gt;json&lt;/code&gt;对象 的键值对。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{&quot;name&quot;:&quot;pubdreamcc&quot;, &quot;age&quot;: 24}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;集合&lt;/code&gt;：集合就是 MongoDB 文档组，实质上就是包含多个对象的数组。&lt;/p&gt;
&lt;p&gt;比如，我们可以将以下不同数据结构的文档插入到集合中：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{&quot;name&quot;:&quot;pubdreamcc&quot;}
{&quot;name&quot;:&quot;pubdreamcc1&quot;,&quot;name&quot;:&quot;pubdreamcc2&quot;}
{&quot;name&quot;:&quot;pubdreamcc3&quot;,&quot;name&quot;:&quot;pubdreamcc4&quot;,&quot;num&quot;:5}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;数据库（dataBase）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里的数据库概念同 关系型数据库中的数据库概念一致，数据库可以包含多个集合。&lt;/p&gt;
&lt;p&gt;下面给出一张图用来表示 &lt;code&gt;mongoDB&lt;/code&gt; 中的一些概念同 &lt;code&gt;SQL&lt;/code&gt; 概念 的 对比，辅助理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1632878/201905/1632878-20190531141550555-1902347207.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mongodb基本操作&quot;&gt;&lt;code&gt;mongoDB&lt;/code&gt;基本操作&lt;/h2&gt;
&lt;p&gt;在刚才我们连接上本地数据库之后，在这个命令行，我们可以进行很多 &lt;code&gt;mongoDB&lt;/code&gt; 提供的增删改查等的基本操作，且听我一一道来。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建数据库 : &lt;code&gt;use 数据库名称&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;如果数据库不存在，则创建数据库，否则切换到指定数据库。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。&lt;/em&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看所有数据库： &lt;code&gt;show dbs&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;删除数据库： &lt;code&gt;db.dropDatabase()&lt;/code&gt;，你可以使用 db 命令查看当前数据库名。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建集合： &lt;code&gt;db.createCollection(集合名称)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看已有集合： &lt;code&gt;show collections&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;删除集合：&lt;code&gt;db.集合名称.drop()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;如果成功删除选定集合，则 &lt;code&gt;drop()&lt;/code&gt; 方法返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;插入文档：&lt;code&gt;db.集合名称.insert(document)&lt;/code&gt;。往指定集合插入文档，文档的数据结构和 &lt;code&gt;JSON&lt;/code&gt; 基本一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更新文档： &lt;code&gt;update()&lt;/code&gt; 方法用于更新已存在的文档，语法格式：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;db.collection.update(
  &amp;lt;query&amp;gt;,
  &amp;lt;update&amp;gt;,
  {
    upsert: &amp;lt;boolean&amp;gt;,
    multi: &amp;lt;boolean&amp;gt;,
    writeConcern: &amp;lt;document&amp;gt;
  }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li&gt;&lt;code&gt;query&lt;/code&gt; : update的查询条件，类似sql update查询内where后面的。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;update&lt;/code&gt; : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;upsert&lt;/code&gt; : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;multi&lt;/code&gt; : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;writeConcern&lt;/code&gt; :可选，抛出异常的级别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;删除文档：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;db.collection.remove(
  &amp;lt;query&amp;gt;,
  &amp;lt;justOne&amp;gt;
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;query&lt;/code&gt; :（可选）删除的文档的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;justOne&lt;/code&gt; : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;writeConcern&lt;/code&gt; :（可选）抛出异常的级别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;删除集合所有数据：&lt;code&gt;db.collection.remove({})&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;查询文档：&lt;code&gt;db.collection.find(query, projection)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;query&lt;/code&gt; ：可选，使用查询操作符指定查询条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;projection&lt;/code&gt; ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;PS&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;如果你需要以易读的方式来读取数据，可以使用 &lt;code&gt;pretty()&lt;/code&gt; 方法，语法格式如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;db.col.find().pretty()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pretty()&lt;/code&gt; 方法以格式化的方式来显示所有文档。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查询一个文档（匹配条件的第一个）：&lt;code&gt;db.collection.findOne()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;node操作mongodb&quot;&gt;Node操作mongoDB&lt;/h2&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;mongoDB&lt;/code&gt; 官方提供的 &lt;code&gt;node mongodb driver&lt;/code&gt; 包 &lt;code&gt;mongoDB&lt;/code&gt; ，这种方法是官方提供的，感兴趣的同学可以去 npm 官网查找文档，这里推荐下面一种方法。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/mongodb&quot;&gt;&lt;code&gt;mongoDB&lt;/code&gt; npm 文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;mongoose&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Mongoose&lt;/code&gt; 是在 &lt;code&gt;node.js&lt;/code&gt; 环境下对 &lt;code&gt;mongodb&lt;/code&gt; 进行便捷操作的对象模型工具。&lt;/p&gt;
&lt;p&gt;官方 &lt;a href=&quot;http://www.nodeclass.com/api/mongoose.html&quot;&gt;api 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面说明下 &lt;code&gt;mongoose&lt;/code&gt; 的具体用法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装 &lt;code&gt;mongoose&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install mongoose&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后，打开mongodb。命令行敲入：&lt;code&gt;mongod&lt;/code&gt;，即可打开 mongodb&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;利用mongoose连接mongodb&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;新建一个js文件，引入mongoose，这里可以参照官网 写的一个 &lt;code&gt;hello world&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const mongoose = require('mongoose')
// 连接数据库
mongoose.connect('mongodb://数据库地址(包括端口号)/数据库名称', (err, ret) =&amp;gt; {
  if (err) {
    console.log('连接失败')
  } else {
    console.log('连接成功')
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就可以连接上数据库了，注意：如果没有指定数据库名称，则默认连接 &lt;code&gt;test&lt;/code&gt; 数据库。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建 &lt;code&gt;Schema&lt;/code&gt; ，设计文档结构&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;Schema&lt;/code&gt; 到底是个什么东西呢，我们在往数据库插入数据之前是不是应该得稍微设计下文档的结构，也就是关系数据库中表的结构啥的，因为有一定的设计才使得数据的完整性，不会产生脏数据，Schema就是用来干这个事情的，我们看下官方的介绍&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Schema&lt;/code&gt; 主要用于定义 &lt;code&gt;MongoDB&lt;/code&gt; 中集合 &lt;code&gt;Collection&lt;/code&gt; 里文档 &lt;code&gt;document&lt;/code&gt; 的结构。&lt;code&gt;mongoose&lt;/code&gt; 对表结构的定义，每个 &lt;code&gt;Schema&lt;/code&gt; 会映射到mongodb中的一个 &lt;code&gt;collection&lt;/code&gt;，&lt;code&gt;Schema&lt;/code&gt; 不具备操作数据库的能力。&lt;/p&gt;
&lt;p&gt;定义&lt;code&gt;Schema&lt;/code&gt;非常简单，指定字段名和类型即可，支持的类型包括以下8种：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String      字符串
Number      数字    
Date        日期
Buffer      二进制
Boolean     布尔值
Mixed       混合类型
ObjectId    对象ID    
Array       数组&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;mongoose.Schema&lt;/code&gt;来调用Schema，然后使用new方法来创建schema&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 引入Schema
const Schema = mongoose.Schema
// 通过 new 创建一个Schema
const userSchema = new Schema({
  // 这里来设计文档的结构，后面插入集合的每一个文档必须是以下指定的结构
  name: {
    type: String,
    required: true //  规定 name 是必须有的字段
  },
  password: {
    type: String,
    required: true
  },
  email: {
    type: String
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上的实例，我们就创建了一个 &lt;code&gt;userSchema&lt;/code&gt; 的架构，规定了每个文档中必须有 &lt;code&gt;name&lt;/code&gt;， &lt;code&gt;password&lt;/code&gt; 字段，且类型为 &lt;code&gt;String&lt;/code&gt;，&lt;code&gt;email&lt;/code&gt; 字段类型为 &lt;code&gt;String&lt;/code&gt;，有或没有都可以。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把 &lt;code&gt;Schema&lt;/code&gt; 发布为 &lt;code&gt;model&lt;/code&gt; （模型）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单说就是&lt;code&gt;model&lt;/code&gt;是由 &lt;code&gt;Schema&lt;/code&gt; 生成的模型，可以对数据库的操作。model的每一个实例（instance）就是一个文档。&lt;/p&gt;
&lt;p&gt;把 Schema 发布为模型只需调用mongoose的 &lt;code&gt;mongoose.model()&lt;/code&gt; 方法即可，&lt;code&gt;mongoose.model()&lt;/code&gt; 接收两个参数，第一个参数表示模型的名称，第二个参数是 Schema，返回值为模型构造函数。这里一定得把第一个参数设置成和 &lt;code&gt;mongoose.model()&lt;/code&gt; 的返回值相同，否则会出错。最后得到的集合名称就为模型名称的小写形式，如果模型名称最后一个字符是字母，则变成复数形式，如果最后一个是数字，则不变，比如：模型名称：&lt;code&gt;User&lt;/code&gt;，得到的集合名称为： &lt;code&gt;users&lt;/code&gt;，模型名称为：&lt;code&gt;User1&lt;/code&gt;， 得到的集合名称为；&lt;code&gt;user1&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 把Schema 发布为模型
const User = mongoose.model('User', userSchema)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;通过模型构造函数，可以对数据库进行一系列增删改查的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，我们经过以上的步骤，最后就可以通过 &lt;code&gt;User&lt;/code&gt; 模型构造函数操作数据库了。&lt;/p&gt;
&lt;h2 id=&quot;mongoose-操作-mongodb&quot;&gt;mongoose 操作 mongoDB&lt;/h2&gt;
&lt;h3 id=&quot;增加数据&quot;&gt;增加数据&lt;/h3&gt;
&lt;p&gt;实例化一个模型构造函数就得到一个具体文档。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const user = new User({
  // 传入具体的数据信息，必须和之前的Schema 配置的结构一致
  name: 'pubdreamcc',
  password: '123456',
  email: '333@pubdreamcc.com' // 可有可无
})

// 通过save()方法持久化存储数据

user.save((err, ret) =&amp;gt; {
  if (err) {
    console.log('保存失败')
  } else {
    console.log('保存成功')
    console.log(ret) // ret 就是刚新增加的文档
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok， 通过上面两步我们就已经保存了一条数据到数据库中了，就是怎么简单。&lt;/p&gt;
&lt;h3 id=&quot;查询数据&quot;&gt;查询数据&lt;/h3&gt;
&lt;p&gt;查询数据这里有好几个 API ， 可以看下 mongoose 的官网：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;find()&lt;/li&gt;
&lt;li&gt;findById()&lt;/li&gt;
&lt;li&gt;findOne()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的用法和之前在控制台 操作mongoDB 数据类似，不清楚的同学可以查看本章第一节知识点： &lt;a href=&quot;https://github.com/pubdreamcc/Node.js/blob/master/%E7%AC%AC%E4%BA%94%E7%AB%A0/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8.md&quot;&gt;mongoDB数据库的使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里选取一个findOne代表&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;User.findOne({name: 'pubdreamcc'}, (err, ret) =&amp;gt; {
  if (err) {
    console.log('查询失败')
  } else {
    console.log(ret) // ret 即为查询出来的那一条文档
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;findOne()&lt;/code&gt; 会查找匹配的第一个文档出来，通常传入一个查找条件（对象），这里是从数据库查找 &lt;code&gt;name&lt;/code&gt; 为 &lt;code&gt;pubdreamcc&lt;/code&gt; 的文档出来。&lt;/p&gt;
&lt;h3 id=&quot;删除数据&quot;&gt;删除数据&lt;/h3&gt;
&lt;p&gt;删除数据同样也有好几个方法，这里参照官网 api ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;remove()&lt;/li&gt;
&lt;li&gt;findOneAndRemove()&lt;/li&gt;
&lt;li&gt;findByIdAndRemove()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用法其实和更新数据，包括前面说到的查找数据类似，&lt;code&gt;remove()&lt;/code&gt; 会删除所有匹配的全部文档，&lt;code&gt;findOneAndRemove()&lt;/code&gt; 会删除匹配的第一个文档，&lt;code&gt;findByIdAndRemove()&lt;/code&gt; 通过唯一的id值删除某一个文档。&lt;/p&gt;
&lt;p&gt;这里选取&lt;code&gt;findByIdAndRemove()&lt;/code&gt; 来说明，其他的小伙伴可以去 &lt;code&gt;mongoose&lt;/code&gt; 官网 &lt;code&gt;api&lt;/code&gt; 查询，我就不再反复说了，用法很简单，大家看一下都懂的。&lt;/p&gt;
&lt;blockquote readability=&quot;3.2857142857143&quot;&gt;
&lt;p&gt;mongoose 官网 api： &lt;a href=&quot;http://mongoosejs.net/docs/api.html#Model&quot;&gt;api document&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;User.findByIdAndRemove('id值', (err, ret) =&amp;gt; {
  if (err) {
    console.log('删除失败')
  } else {
    console.log('删除成功')
    console.log(ret) // ret 即为删除信息反馈对象，包括成功删了几条数据等
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更新数据&quot;&gt;更新数据&lt;/h3&gt;
&lt;p&gt;更新数据也有几个 api 可以供我们使用，我就罗列下，然后也是选取一个加以说明，其他的小伙伴们可以去官网查看 api 即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;findByIdAndUpdate()&lt;/li&gt;
&lt;li&gt;update()&lt;/li&gt;
&lt;li&gt;findOneAndUpdate()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里选取 &lt;code&gt;update()&lt;/code&gt; 来演示下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;User.update({name: 'pubdreamcc'}, {email: '111@pubdreamcc.com'}, (err, ret) =&amp;gt; {
  if (err) {
    console.log('更新失败')
  } else {
    console.log('更新成功')
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;update()&lt;/code&gt; 方法会把所有满足条件的数据都更新，上面我们已经把 &lt;code&gt;name&lt;/code&gt; 为： &lt;code&gt;pubdreamcc&lt;/code&gt; 的所有文档的&lt;code&gt;email&lt;/code&gt; 都修改为 &lt;code&gt;111@pubdreamcc.com&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文也是我查阅相关资料，看了很多mongoDB的资料总结而来，如果有那些地方有差错，欢迎留言评论。&lt;/p&gt;
&lt;p&gt;需要演示的源代码可以去GitHub仓库查看。&lt;/p&gt;
&lt;p&gt;ok，that's all , thank you !&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 06:27:00 +0000</pubDate>
<dc:creator>pubdreamcc</dc:creator>
<og:description>写在前面 hello，小伙伴们，我是 ，本篇文章依旧出至于我的 GitHub仓库 ，如果你觉得我写的还不错，欢迎给个 ，小伙伴们的 是我持续更新的动力 ！ node学习教程 'GitHub' 安装 安</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dreamcc/p/10955069.html</dc:identifier>
</item>
<item>
<title>Android View绘制流程看这篇就够了 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10955062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10955062.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       自定义View、多线程、网络，被认为是Android开发者必须牢固掌握的最基础的三大基本功。Android View的绘制流程原理又是学好自定义View的理论基础，所以掌握好View的绘制原理是Android开发进阶中无法绕过的一道坎。而关乎到原理性的东西往往又让很多初学者感到难以下手，所以真正掌握的人并不多。本文采用非常浅显的语言，从顺着Android源码的思路，对View的整个绘制流程进行近乎“地毯式搜索”般的方式，对其中的关键流程和知识点进行查证和分析，以图让初级程序员都能轻松读懂。本文最大的特点，就是最大限度地向源码要答案，从源码中追流程的来龙去脉，在注释中查功能的点点滴滴，所有的结论都尽量在源码和注释中找根据。&lt;/p&gt;
&lt;p&gt;       为了能对其中的重难点分析透彻，文中贴出了大量的源码依据以及源码中的注释，并对重要的注释进行了翻译和讲解，所以文章会比较长。讲解该知识点的文章普遍都非常长，所以希望读者能够秉承程序员吃苦耐劳的精神，攻克这个难关。本文中的源码是基于API26的，即Android8.0系统版本，主要内容大致如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190528103310149-1836591885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、View绘制的三个流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       我们知道，在自定义View的时候一般需要重写父类的onMeasure()、onLayout()、onDraw()三个方法，来完成视图的展示过程。当然，这三个暴露给开发者重写的方法只不过是整个绘制流程的冰山一角，更多复杂的幕后工作，都让系统给代劳了。一个完整的绘制流程包括measure、layout、draw三个步骤，其中：&lt;/p&gt;
&lt;p&gt;     measure：测量。系统会先根据xml布局文件和代码中对控件属性的设置，来获取或者计算出每个View和ViewGrop的尺寸，并将这些尺寸保存下来。&lt;/p&gt;
&lt;p&gt;     layout：布局。根据测量出的结果以及对应的参数，来确定每一个控件应该显示的位置。&lt;/p&gt;
&lt;p&gt;     draw：绘制。确定好位置后，就将这些控件绘制到屏幕上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、Android视图层次结构简介&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;       在介绍View绘制流程之前，咱们先简单介绍一下Android视图层次结构以及DecorView，因为View的绘制流程的入口和DecorView有着密切的联系。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190518164042396-2093768305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       咱们平时看到的视图，其实存在如上的嵌套关系。上图是针对比较老的Android系统版本中制作的，新的版本中会略有出入，还有一个状态栏，但整体上没变。我们平时在Activity中setContentView(...)中对应的layout内容，对应的是上图中ViewGrop的树状结构，实际上添加到系统中时，会再裹上一层FrameLayout，就是上图中最里面的浅蓝色部分了。&lt;/p&gt;
&lt;p&gt;       这里咱们再通过一个实例来继续查看。AndroidStudio工具中提供了一个布局视察器工具，通过Tools &amp;gt; Android &amp;gt; Layout Inspector可以查看具体某个Activity的布局情况。下图中，左边树状结构对应了右边的可视图，可见DecorView是整个界面的根视图，对应右边的红色框，是整个屏幕的大小。黄色边框为状态栏部分；那个绿色边框中有两个部分，一个是白框中的ActionBar，对应了上图中紫色部分的TitleActionBar部分，即标题栏，平时咱们可以在Activity中将其隐藏掉；另外一个蓝色边框部分，对应上图中最里面的蓝色部分，即ContentView部分。下图中左边有两个蓝色框，上面那个中有个“contain_layout”，这个就是Activity中setContentView中设置的layout.xml布局文件中的最外层父布局，咱们能通过layout布局文件直接完全操控的也就是这一块，当其被add到视图系统中时，会被系统裹上ContentFrameLayout（显然是FrameLayout的子类），这也就是为什么添加layout.xml视图的方法叫setContentView(...)而不叫setView(...)的原因。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190518170653465-864329761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、故事开始的地方&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        如果对Activity的启动流程有一定了解的话，应该知道这个启动过程会在ActivityThread.java类中完成，在启动Activity的过程中，会调用到handleResumeActivity(...)方法，关于视图的绘制过程最初就是从这个方法开始的。&lt;/p&gt;

&lt;p&gt;  1、View绘制起源UML时序图&lt;/p&gt;
&lt;p&gt;       整个调用链如下图所示，直到ViewRootImpl类中的performTraversals()中，才正式开始绘制流程了，所以一般都是以该方法作为正式绘制的源头。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190520105432689-870375609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3.1 View绘制起源UML时序图&lt;/p&gt;

&lt;p&gt;   2、handleResumeActivity()方法&lt;/p&gt;
&lt;p&gt;       在这咱们先大致看看ActivityThread类中的handleResumeActivity方法，咱们这里只贴出关键代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===========ActivityThread.java==========&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleResumeActivity(...) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跟踪代码后发现其初始赋值为mWindow = new PhoneWindow(this, window, activityConfigCallback);&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     r.window =&lt;span&gt; r.activity.getWindow(); 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从PhoneWindow实例中获取DecorView  &lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     View decor =&lt;span&gt; r.window.getDecorView();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跟踪代码后发现，vm值为上述PhoneWindow实例中获取的WindowManager。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     ViewManager wm =&lt;span&gt; a.getWindowManager();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前window的属性，从代码跟踪来看是PhoneWindow窗口的属性&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     WindowManager.LayoutParams l =&lt;span&gt; r.window.getAttributes();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    wm.addView(decor, l);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       上述代码第8行中，ViewManager是一个接口，addView是其中定义个一个空方法，WindowManager是其子类，WindowManagerImpl是WindowManager的实现类（顺便啰嗦一句，这种方式叫做面向接口编程，在父类中定义，在子类中实现，在Java中很常见）。第4行代码中的r.window的值可以根据Activity.java的如下代码得知，其值为PhoneWindow实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===============Activity.java=============&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Window mWindow;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Window getWindow() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mWindow;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; attach(...){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    mWindow = &lt;span&gt;new&lt;/span&gt; PhoneWindow(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, window, activityConfigCallback);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、两个重要参数分析&lt;/p&gt;
&lt;p&gt;       之所以要在这里特意分析handleResumeActivity()方法，除了因为它是整个绘制流程的最初源头外，还有就是addView的两个参数比较重要，它们经过一层一层传递后进入到ViewRootImpl中，在后面分析绘制中要用到。这里再看看这两个参数的相关信息：&lt;/p&gt;
&lt;p&gt;    （1）参数decor&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==========PhoneWindow.java===========
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is the top-level view of the window, containing the window decor.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; DecorView mDecor;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PhoneWindow(...){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    mDecor =&lt;span&gt; (DecorView) preservedWindow.getDecorView();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; View getDecorView() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mDecor;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见decor参数表示的是DecorView实例。注释中也有说明：这是window的顶级视图，包含了window的decor。&lt;/p&gt;
&lt;p&gt;    （2）参数l&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===================Window.java===================
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The current window attributes.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; WindowManager.LayoutParams mWindowAttributes =
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WindowManager.LayoutParams();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; WindowManager.LayoutParams getAttributes() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mWindowAttributes;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==========WindowManager.java的内部类LayoutParams extends ViewGroup.LayoutParams=============&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LayoutParams() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            ......
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==============ViewGroup.java内部类LayoutParams====================&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; LayoutParams(&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该参数表示l的是PhoneWindow的LayoutParams属性，其width和height值均为LayoutParams.MATCH_PARENT。&lt;/p&gt;

&lt;p&gt;        在源码中，WindowPhone和DecorView通过组合方式联系在一起的，而DecorView是整个View体系的根View。在前面handleResumeActivity(...)方法代码片段中，当Actiivity启动后，就通过第14行的addView方法，来间接调用ViewRootImpl类中的performTraversals()，从而实现视图的绘制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、主角登场 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
   无疑，performTraversals()方法是整个过程的主角，它把控着整个绘制的流程。该方法的源码有大约800行，这里咱们仅贴出关键的流程代码，如下所示：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =====================ViewRootImpl.java=================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; performTraversals() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; childWidthMeasureSpec =&lt;span&gt; getRootMeasureSpec(mWidth, lp.width);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; childHeightMeasureSpec =&lt;span&gt; getRootMeasureSpec(mHeight, lp.height);      
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ask host how big it wants to be&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   performLayout(lp, mWidth, mHeight);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;   performDraw();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上述代码中就是一个完成的绘制流程，对应上了第一节中提到的三个步骤：&lt;/p&gt;
&lt;p&gt;      1）performMeasure()：从根节点向下遍历View树，完成所有ViewGroup和View的测量工作，计算出所有ViewGroup和View显示出来需要的高度和宽度；&lt;/p&gt;
&lt;p&gt;      2）performLayout()：从根节点向下遍历View树，完成所有ViewGroup和View的布局计算工作，根据测量出来的宽高及自身属性，计算出所有ViewGroup和View显示在屏幕上的区域；&lt;/p&gt;
&lt;p&gt;      3）performDraw()：从根节点向下遍历View树，完成所有ViewGroup和View的绘制工作，根据布局过程计算出的显示区域，将所有View的当前需显示的内容画到屏幕上。&lt;/p&gt;
&lt;p&gt;咱们后续就是通过对这三个方法来展开研究整个绘制过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、measure过程分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       这三个绘制流程中，measure是最复杂的，这里会花较长的篇幅来分析它。本节会先介绍整个流程中很重要的两个类MeasureSpec和ViewGroup.LayoutParams类，然后介绍ViewRootImpl、View及ViewGroup中测量流程涉及到的重要方法，最后简单梳理DecorView测量的整个流程并链接一个测量实例分析整个测量过程。&lt;/p&gt;

&lt;p&gt;  1、MeasureSpec简介&lt;/p&gt;
&lt;p&gt;       这里咱们直接上源码吧，先直接通过源码和注释认识一下它，如果看不懂也没关系，在后面使用的时候再回头来看看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * A MeasureSpec encapsulates the layout requirements passed from parent to child.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Each MeasureSpec represents a requirement for either the width or the height.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * A MeasureSpec is comprised of a size and a mode. There are three possible
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * modes:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &amp;lt;dl&amp;gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &amp;lt;dt&amp;gt;UNSPECIFIED&amp;lt;/dt&amp;gt;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &amp;lt;dd&amp;gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * The parent has not imposed any constraint on the child. It can be whatever size
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * it wants.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &amp;lt;/dd&amp;gt;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &amp;lt;dt&amp;gt;EXACTLY&amp;lt;/dt&amp;gt;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &amp;lt;dd&amp;gt;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * The parent has determined an exact size for the child. The child is going to be
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * given those bounds regardless of how big it wants to be.
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &amp;lt;/dd&amp;gt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * &amp;lt;dt&amp;gt;AT_MOST&amp;lt;/dt&amp;gt;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &amp;lt;dd&amp;gt;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * The child can be as large as it wants up to the specified size.
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * &amp;lt;/dd&amp;gt;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * &amp;lt;/dl&amp;gt;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * MeasureSpecs are implemented as ints to reduce object allocation. This class
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * is provided to pack and unpack the &amp;amp;lt;size, mode&amp;amp;gt; tuple into the int.
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MeasureSpec {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MODE_SHIFT = 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MODE_MASK  = 0x3 &amp;lt;&amp;lt;&lt;span&gt; MODE_SHIFT;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;         * Measure specification mode: The parent has not imposed any constraint
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;         * on the child. It can be whatever size it wants.
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UNSPECIFIED = 0 &amp;lt;&amp;lt;&lt;span&gt; MODE_SHIFT;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;         * Measure specification mode: The parent has determined an exact size
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;         * for the child. The child is going to be given those bounds regardless
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;         * of how big it wants to be.
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXACTLY     = 1 &amp;lt;&amp;lt;&lt;span&gt; MODE_SHIFT;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;         * Measure specification mode: The child can be as large as it wants up
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;         * to the specified size.
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AT_MOST     = 2 &amp;lt;&amp;lt;&lt;span&gt; MODE_SHIFT;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;        &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;         * Creates a measure specification based on the supplied size and mode.
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;         *...... 
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;         *&lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the measure specification based on size and mode        
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; makeMeasureSpec(@IntRange(from = 0, to = (1 &amp;lt;&amp;lt; MeasureSpec.MODE_SHIFT) - 1) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size,
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                                           @MeasureSpecMode &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mode) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sUseBrokenMakeMeasureSpec) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; size +&lt;span&gt; mode;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; (size &amp;amp; ~MODE_MASK) | (mode &amp;amp;&lt;span&gt; MODE_MASK);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            ......
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;         * Extracts the mode from the supplied measure specification.
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;         *......
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        @MeasureSpecMode
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getMode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; measureSpec) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;noinspection ResourceType&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; (measureSpec &amp;amp;&lt;span&gt; MODE_MASK);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;         * Extracts the size from the supplied measure specification.
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;         *......
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the size in pixels defined in the supplied measure specification
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getSize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; measureSpec) {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; (measureSpec &amp;amp; ~&lt;span&gt;MODE_MASK);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 从这段代码中，咱们可以得到如下的信息：&lt;/p&gt;
&lt;p&gt;    1）MeasureSpec概括了从父布局传递给子view布局要求。每一个MeasureSpec代表了宽度或者高度要求，它由size（尺寸）和mode（模式）组成。&lt;/p&gt;
&lt;p&gt;    2）有三种可能的mode：UNSPECIFIED、EXACTLY、AT_MOST&lt;/p&gt;
&lt;p&gt;    3）UNSPECIFIED：未指定尺寸模式。父布局没有对子view强加任何限制。它可以是任意想要的尺寸。（笔者注：这个在工作中极少碰到，据说一般在系统中才会用到，后续会讲得很少）&lt;/p&gt;
&lt;p&gt;    4）EXACTLY：精确值模式。父布局决定了子view的准确尺寸。子view无论想设置多大的值，都将限定在那个边界内。（笔者注：也就是layout_width属性和layout_height属性为具体的数值，如50dp，或者设置为match_parent，设置为match_parent时也就明确为和父布局有同样的尺寸，所以这里不要以为笔者搞错了。当明确为精确的尺寸后，其也就被给定了一个精确的边界）&lt;/p&gt;
&lt;p&gt;    5）AT_MOST：最大值模式。子view可以一直大到指定的值。（笔者注：也就是其宽高属性设置为wrap_content，那么它的最大值也不会超过父布局给定的值，所以称为最大值模式）&lt;/p&gt;
&lt;p&gt;    6）MeasureSpec被实现为int型来减少对象分配。该类用于将size和mode元组装包和拆包到int中。（笔者注：也就是将size和mode组合或者拆分为int型数据）&lt;/p&gt;
&lt;p&gt;    7）分析代码可知，一个MeasureSpec的模式如下所示，int长度为32位置，高2位表示mode，后30位用于表示size&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190521193635415-455047678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     8）UNSPECIFIED、EXACTLY、AT_MOST这三个mode的示意图如下所示：&lt;/p&gt;
&lt;p&gt;              &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190521194344561-115486598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    9）makeMeasureSpec（int mode，int size）用于将mode和size打包成一个int型的MeasureSpec。&lt;/p&gt;
&lt;p&gt;    10）getSize(int measureSpec)方法用于从指定的measureSpec值中获取其size。&lt;/p&gt;
&lt;p&gt;    11）getMode(int measureSpec)方法用户从指定的measureSpec值中获取其mode。&lt;/p&gt;

&lt;p&gt;  2、ViewGroup.LayoutParams简介&lt;/p&gt;
&lt;p&gt;   该类的源码及注释分析如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;============================ViewGroup.java===============================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * LayoutParams are used by views to tell their parents how they want to be
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * laid out. 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *......
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * The base LayoutParams class just describes how big the view wants to be
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * for both width and height. For each dimension, it can specify one of:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &amp;lt;ul&amp;gt;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &amp;lt;li&amp;gt;FILL_PARENT (renamed MATCH_PARENT in API Level 8 and higher), which
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * means that the view wants to be as big as its parent (minus padding)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &amp;lt;li&amp;gt; WRAP_CONTENT, which means that the view wants to be just big enough
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * to enclose its content (plus padding)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &amp;lt;li&amp;gt; an exact number
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &amp;lt;/ul&amp;gt;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * There are subclasses of LayoutParams for different subclasses of
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * ViewGroup. For example, AbsoluteLayout has its own subclass of
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * LayoutParams which adds an X and Y value.&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * ......
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * @attr ref android.R.styleable#ViewGroup_Layout_layout_height
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * @attr ref android.R.styleable#ViewGroup_Layout_layout_width
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LayoutParams {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;         * Special value for the height or width requested by a View.
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;         * MATCH_PARENT means that the view wants to be as big as its parent,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;         * minus the parent's padding, if any. Introduced in API Level 8.
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MATCH_PARENT = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;         * Special value for the height or width requested by a View.
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;         * WRAP_CONTENT means that the view wants to be just large enough to fit
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;         * its own internal content, taking its own padding into account.
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; WRAP_CONTENT = -2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;         * Information about how wide the view wants to be. Can be one of the
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;         * constants FILL_PARENT (replaced by MATCH_PARENT
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;         * in API Level 8) or WRAP_CONTENT, or an exact size.
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; width;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;         * Information about how tall the view wants to be. Can be one of the
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;         * constants FILL_PARENT (replaced by MATCH_PARENT
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;         * in API Level 8) or WRAP_CONTENT, or an exact size.
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这对其中重要的信息做一些翻译和整理：&lt;/p&gt;
&lt;p&gt;    1）LayoutParams被view用于告诉它们的父布局它们想要怎样被布局。（笔者注：字面意思就是布局参数）&lt;/p&gt;
&lt;p&gt;    2）该LayoutParams基类仅仅描述了view希望宽高有多大。对于每一个宽或者高，可以指定为以下三种值中的一个：MATCH_PARENT,WRAP_CONTENT,an exact number。（笔者注：FILL_PARENT从API8开始已经被MATCH_PARENT取代了，所以下文就只提MATCH_PARENT）&lt;/p&gt;
&lt;p&gt;    3）MATCH_PARENT：意味着该view希望和父布局尺寸一样大，如果父布局有padding，则要减去该padding值。&lt;/p&gt;
&lt;p&gt;    4）WRAP_CONTENT：意味着该view希望其大小为仅仅足够包裹住其内容即可，如果自己有padding，则要加上该padding值。&lt;/p&gt;
&lt;p&gt;    5）对ViewGroup不同的子类，也有相应的LayoutParams子类。 &lt;/p&gt;
&lt;p&gt;    6）其width和height属性对应着layout_width和layout_height属性。&lt;/p&gt;

&lt;p&gt;  3、View测量的基本流程及重要方法分析&lt;/p&gt;
&lt;p&gt;       View体系的测量是从DecorView这个根view开始递归遍历的，而这个View体系树中包含了众多的叶子view和ViewGroup的子类容器。这一小节中会从ViewRootImpl.performMeasure()开始，分析测量的基本流程。&lt;/p&gt;
&lt;p&gt;     （1）ViewRootImpl.performMeasure()方法&lt;/p&gt;
&lt;p&gt;       跟踪源码，进入到performMeasure方法分析，这里仅贴出关键流程代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=============ViewRootImpl.java==============&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; performMeasure(&lt;span&gt;int&lt;/span&gt; childWidthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childHeightMeasureSpec) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;       ......
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;       mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;       ......
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个mView是谁呢？跟踪代码可以找到给它赋值的地方：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;========================ViewRootImpl.java======================&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;       mView =&lt;span&gt; view;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;      mWindowAttributes.copyFrom(attrs);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       看到这里，是不是有些似曾相识呢？在第二节的绘制流程中提到过，这里setView的参数view和attrs是ActivityThread类中addView方法传递过来的，所以咱们这里可以确定mView指的是DecorView了。上述performMeasure()中，其实就是DecorView在执行measure()操作。如果您这存在“mView不是View类型的吗，怎么会指代DecorView作为整个View体系的根view呢”这样的疑惑，那这里就啰嗦一下，DecorView extends FrameLayout extends ViewGroup extends View，通过这个继承链可以看到，DecorView是一个容器，但ViewGroup也是View的子类，View是所有控件的基类，所以这里View类型的mView指代DecorView是没毛病的。&lt;/p&gt;
&lt;p&gt;    （2）View.measure()方法&lt;/p&gt;
&lt;p&gt;       尽管mView就是DecorView，但是由于measure()方法是final型的，View子类都不能重写该方法，所以这里追踪measure()的时候就直接进入到View类中了，这里贴出关键流程代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===========================View.java===============================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * This is called to find out how big a view should be. The parent
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * supplies constraint information in the width and height parameters.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * The actual measurement work of a view is performed in
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onMeasure(int, int)}, called by this method. Therefore, only
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onMeasure(int, int)} can and must be overridden by subclasses.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; widthMeasureSpec Horizontal space requirements as imposed by the
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     *        parent
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; heightMeasureSpec Vertical space requirements as imposed by the
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     *        parent
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #onMeasure(int, int)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; measure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; measure ourselves, this should set the measured dimension flag back&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;      onMeasure(widthMeasureSpec, heightMeasureSpec);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        这里面注释提供了很多信息，这简单翻译并整理一下：&lt;/p&gt;
&lt;p&gt;        1）该方法被调用，用于找出view应该多大。父布局在witdh和height参数中提供了限制信息；&lt;/p&gt;
&lt;p&gt;        2）一个view的实际测量工作是在被本方法所调用的onMeasure(int，int)方法中实现的。所以，只有onMeasure(int,int)可以并且必须被子类重写（笔者注：这里应该指的是，ViewGroup的子类必须重写该方法，才能绘制该容器内的子view。如果是自定义一个子控件，extends View，那么并不是必须重写该方法）；&lt;/p&gt;
&lt;p&gt;        3）参数widthMeasureSpec：父布局加入的水平空间要求；&lt;/p&gt;
&lt;p&gt;        4）参数heightMeasureSpec：父布局加入的垂直空间要求。&lt;/p&gt;
&lt;p&gt;       系统将其定义为一个final方法，可见系统不希望整个测量流程框架被修改。&lt;/p&gt;
&lt;p&gt;    （3）View.onMeasure()方法&lt;/p&gt;
&lt;p&gt;       在上述方法体内看到onMeasure(int,int)方法时，是否有一丝慰藉呢？终于看到咱们最熟悉的身影了，很亲切吧！咱们编写自定义View时，基本上都会重写的方法！咱们看看其源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===========================View.java===============================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * Measure the view and its content to determine the measured width and the
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * measured height. This method is invoked by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #measure(int, int)} and
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * should be overridden by subclasses to provide accurate and efficient
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * measurement of their contents.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &amp;lt;strong&amp;gt;CONTRACT:&amp;lt;/strong&amp;gt; When overriding this method, you
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &amp;lt;em&amp;gt;must&amp;lt;/em&amp;gt; call {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setMeasuredDimension(int, int)} to store the
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * measured width and height of this view. Failure to do so will trigger an
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &amp;lt;code&amp;gt;IllegalStateException&amp;lt;/code&amp;gt;, thrown by
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #measure(int, int)}. Calling the superclass'
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onMeasure(int, int)} is a valid use.
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * The base class implementation of measure defaults to the background size,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * unless a larger size is allowed by the MeasureSpec. Subclasses should
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * override {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onMeasure(int, int)} to provide better measurements of
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * their content.
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * &amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * If this method is overridden, it is the subclass's responsibility to make
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * sure the measured height and width are at least the view's minimum height
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * and width ({&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #getSuggestedMinimumHeight()} and
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #getSuggestedMinimumWidth()}).
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * &amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; widthMeasureSpec horizontal space requirements as imposed by the parent.
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     *                         The requirements are encoded with
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     *                         {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; android.view.View.MeasureSpec}.
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; heightMeasureSpec vertical space requirements as imposed by the parent.
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     *                         The requirements are encoded with
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;     *                         {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; android.view.View.MeasureSpec}.
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #getMeasuredWidth()
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #getMeasuredHeight()
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setMeasuredDimension(int, int)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #getSuggestedMinimumHeight()
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #getSuggestedMinimumWidth()
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; android.view.View.MeasureSpec#getMode(int)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; android.view.View.MeasureSpec#getSize(int)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       函数体内也就一句代码而已，注释却写了这么一大堆，可见这个方法的重要性了。这里翻译和整理一下这些注释：&lt;/p&gt;
&lt;p&gt;      1）测量该view以及它的内容来决定测量的宽度和高度。该方法被measure(int，int)（笔者注：就是前面提到过的那个方法）调用，并且应该被子类重写来提供准确而且有效的对它们的内容的测量。&lt;/p&gt;
&lt;p&gt;      2）当重写该方法时，您必须调用setMeasuredDimension(int,int)来存储该view测量出的宽和高。如果不这样做将会触发IllegalStateException，由measure(int,int)抛出。调用基类的onMeasure(int,int)方法是一个有效的方法。&lt;/p&gt;
&lt;p&gt;      3）测量的基类实现默认为背景的尺寸，除非更大的尺寸被MeasureSpec所允许。子类应该重写onMeasure(int,int)方法来提供对内容更好的测量。&lt;/p&gt;
&lt;p&gt;      4）如果该方法被重写，子类负责确保测量的高和宽至少是该view的mininum高度和mininum宽度值（链接getSuggestedMininumHeight()和getSuggestedMininumWidth()）；&lt;/p&gt;
&lt;p&gt;      5） widthMeasureSpec：父布局加入的水平空间要求。该要求被编码到android.view.View.MeasureSpec中。&lt;/p&gt;
&lt;p&gt;      6）heightMeasureSpec：父布局加入的垂直空间要求。该要求被编码到android.view.View.MeasureSpec中。&lt;/p&gt;
&lt;p&gt;       注释中最后提到了7个方法，这些方法后面会再分析。注释中花了不少的篇幅对该方法进行说明，但读者恐怕对其中的一些信息表示有些懵吧，比如MeasureSpec是什么，mininum高度和mininum宽度值是怎么回事等，MeasureSpec在本节的开头介绍过，可以回头再看看，其它的后面会作进一步的阐述，到时候咱们再回头来看看这些注释。&lt;/p&gt;
&lt;p&gt;        注意：容器类控件都是ViewGroup的子类，如FrameLayout、LinearLayout等，都会重写onMeasure方法，根据自己的特性来进行测量；如果是叶子节点view，即最里层的控件，如TextView等，也可能会重写onMeasure方法，所以当流程走到onMeasure(...)时，流程可能就会切到那些重写的onMeasure()方法中去。最后通过从根View到叶子节点的遍历和递归，最终还是会在叶子view中调用setMeasuredDimension(...)来实现最终的测量。&lt;/p&gt;
&lt;p&gt;    （4）View.setMeasuredDimension()方法&lt;/p&gt;
&lt;p&gt;      继续看setMeasuredDimension方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;This method must be called by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onMeasure(int, int)} to store the
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * measured width and measured height. Failing to do so will trigger an
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * exception at measurement time.&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; measuredWidth The measured width of this view.  May be a complex
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * bit mask as defined by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_SIZE_MASK} and
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_STATE_TOO_SMALL}.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; measuredHeight The measured height of this view.  May be a complex
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * bit mask as defined by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_SIZE_MASK} and
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_STATE_TOO_SMALL}.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMeasuredDimension(&lt;span&gt;int&lt;/span&gt; measuredWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; measuredHeight) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   这里需要重点关注注释中对参数的说明：&lt;/p&gt;
&lt;p&gt;       measuredWidth：该view被测量出宽度值。&lt;/p&gt;
&lt;p&gt;       measuredHeight：该view被测量出的高度值。&lt;/p&gt;
&lt;p&gt;      到这个时候才正式明确提到宽度和高度，通过getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec)，参数由widthMeasureSpec变成了measuredWidth，即由“父布局加入的水平空间要求”转变为了view的宽度，measuredHeigh也是一样。咱们先继续追踪源码分析width的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Returns the suggested minimum width that the view should use. This
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * returns the maximum of the view's minimum width
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * and the background's minimum width
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *  ({&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; android.graphics.drawable.Drawable#getMinimumWidth()}).
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * When being used in {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onMeasure(int, int)}, the caller should still
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * ensure the returned width is within the requirements of the parent.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; The suggested minimum width of the view.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getSuggestedMinimumWidth() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (mBackground == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       这个方法是干嘛用的呢？注释的翻译如下：&lt;/p&gt;
&lt;p&gt;      1）返回建议该view应该使用的最小宽度值。该方法返回了view的最小宽度值和背景的最小宽度值（链接android.graphics.drawable.Drawable#getMinimumWidth()）之间的最大值。&lt;/p&gt;
&lt;p&gt;      2）当在onMeasure(int,int)使用时，调用者应该仍然确保返回的宽度值在父布局的要求之内。&lt;/p&gt;
&lt;p&gt;      3）返回值：view的建议最小宽度值。&lt;/p&gt;
&lt;p&gt;      这其中提到的&quot;mininum width“指的是在xml布局文件中该view的“android:minWidth&quot;属性值，“background's minimum width”值是指“android:background”的宽度。该方法的返回值就是两者之间较大的那一个值，用来作为该view的最小宽度值，现在应该很容易理解了吧,当一个view在layout文件中同时设置了这两个属性时，为了两个条件都满足，自然要选择值大一点的那个了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Utility to return a default size. Uses the supplied size if the
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * MeasureSpec imposed no constraints. Will get larger if allowed
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * by the MeasureSpec.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; size Default size for this view
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; measureSpec Constraints imposed by the parent
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; The size this view should be.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getDefaultSize(&lt;span&gt;int&lt;/span&gt; size, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; measureSpec) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; specMode =&lt;span&gt; MeasureSpec.getMode(measureSpec);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; specSize =&lt;span&gt; MeasureSpec.getSize(measureSpec);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (specMode) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.UNSPECIFIED:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             result =&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.AT_MOST:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.EXACTLY:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             result =&lt;span&gt; specSize;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       通过本节开头的介绍，您应该对MeasureSpec有了一个比较明确的认识了，再看看getDefaultSize(int size，int measureSpec)方法，就很容易理解了。正如其注释中所说，如果父布局没有施加任何限制，即MeasureSpec的mode为UNSPECIFIED，那么返回值为参数中提供的size值。如果父布局施加了限制，则返回的默认尺寸为保存在参数measureSpec中的specSize值。所以到目前为止，需要绘制的宽和高值就被确定下来了。只是，我们还需要明确这两个值最初是从哪里传过来的，后面我们还会顺藤摸瓜，找到这两个尺寸的出处。&lt;/p&gt;
&lt;p&gt;       既然宽度值measuredWidth和高度值measuredHeight已经确定下来，我们继续追踪之前的setMeasuredDimension(int measuredWidth, int measuredHeight)方法，其内部最后调用了如下的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * ......
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; measuredWidth The measured width of this view.  May be a complex
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * bit mask as defined by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_SIZE_MASK} and
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_STATE_TOO_SMALL}.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; measuredHeight The measured height of this view.  May be a complex
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * bit mask as defined by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_SIZE_MASK} and
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MEASURED_STATE_TOO_SMALL}.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMeasuredDimensionRaw(&lt;span&gt;int&lt;/span&gt; measuredWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; measuredHeight) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         mMeasuredWidth =&lt;span&gt; measuredWidth;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         mMeasuredHeight =&lt;span&gt; measuredHeight;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       到目前为止，View中的成员变量mMeasureWidth和mMeasureHeight就被赋值了，这也就意味着，View的测量就结束了。前面讲onMeasure()方法时介绍过，View子类（包括ViewGroup子类）通常会重写onMeasure()，当阅读FrameLayout、LinearLayout、TextView等重写的onMeasure()方法时，会发现它们最终都会调用setMeasuredDimension() 方法，从而完成测量。这里可以对应上前面介绍View.onMeasure()时，翻译注释的第2）点以及setMeasuredDimension()方法的注释说明。&lt;/p&gt;
&lt;p&gt;    （5）getMeasureWidth()方法&lt;/p&gt;
&lt;p&gt;       在View的onMeasure()方法的注释中提到了该方法，这里顺便也介绍一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================View.java==============&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MEASURED_SIZE_MASK = 0x00ffffff&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt; * ......
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; The raw measured width of this view.
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getMeasuredWidth() {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; mMeasuredWidth &amp;amp;&lt;span&gt; MEASURED_SIZE_MASK;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       获取原始的测量宽度值，一般会拿这个方法和layout执行后getWidth()方法做比较。该方法需要在setMeasuredDimension()方法执行后才有效，否则返回值为0。&lt;/p&gt;
&lt;p&gt;    （6）getMeasureHeight()方法&lt;/p&gt;
&lt;p&gt;       在View的onMeasure()方法的注释中提到了该方法，这里顺便也介绍一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================View.java==============&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  * ......
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; The raw measured height of this view.
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getMeasuredHeight() {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; mMeasuredHeight &amp;amp;&lt;span&gt; MEASURED_SIZE_MASK;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       获取原始的测量高度值，一般会拿这个方法和layout执行后getHeight()方法做比较。该方法需要在setMeasuredDimension()方法执行后才有效，否则返回值为0。&lt;/p&gt;

&lt;p&gt;  4、performMeasure()方法中RootMeasureSpec参数来源分析&lt;/p&gt;
&lt;p&gt;       前面讲到getDefaultSize(int size，int measureSpec)方法时提到过，要找到其中measureSpec的来源。事实上，根据View体系的不断往下遍历和递归中，前面流程中传入getDefaultSize()方法中的值是根据上一次的值变动的，所以咱们需要找到最初参数值。根据代码往回看，可以看到前文performTraversals()源码部分第三行和第四行中，该参数的来源。咱们先看看传入performMeasure(int,int)的childWidthMeasureSpec是怎么来的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       getRootMeasureSpec(int,int)方法的完整源码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Figures out the measure spec for the root view in a window based on it's
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * layout params.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; windowSize
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     *            The available width or height of the window
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; rootDimension
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     *            The layout params for one dimension (width or height) of the
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     *            window.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; The measure spec to use to measure the root view.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getRootMeasureSpec(&lt;span&gt;int&lt;/span&gt; windowSize, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rootDimension) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; measureSpec;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (rootDimension) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ViewGroup.LayoutParams.MATCH_PARENT:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Window can't resize. Force root view to be windowSize.&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             measureSpec =&lt;span&gt; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ViewGroup.LayoutParams.WRAP_CONTENT:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Window can resize. Set max size for root view.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             measureSpec =&lt;span&gt; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Window wants to be an exact size. Force root view to be that size.&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             measureSpec =&lt;span&gt; MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; measureSpec;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 照例先翻译一下注释&lt;/p&gt;
&lt;p&gt;      1）基于window的layout params，在window中为root view 找出measure spec。（笔者注：也就是找出DecorView的MeasureSpec，这里的window也就是PhoneWindow了）&lt;/p&gt;
&lt;p&gt;      2）参数windowSize：window的可用宽度和高度值。&lt;/p&gt;
&lt;p&gt;      3）参数rootDimension：window的宽/高的layout param值。&lt;/p&gt;
&lt;p&gt;      4）返回值：返回用于测量root view的MeasureSpec。    &lt;/p&gt;
&lt;p&gt;       如果不清楚LayoutParams类，可以看看本节开头的介绍。在getRootMeasureSpec(int,int)中，MeasureSpec.makeMeasureSpec方法在前面介绍MeasureSpec类的时候提到过，就是将size和mode组合成一个MeasureSpec值。这里我们可以看到ViewGroup.LayoutParam的width/height值和MeasureSpec的mode值存在如下的对应关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190522153353850-1628612895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       我们再继续看看windowSize和rootDimension的实际参数mWidth和lp.width的来历。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===========================ViewRootImpl.java=======================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Rect mWinFrame; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; frame given by window manager.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; performTraversals() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     Rect frame =&lt;span&gt; mWinFrame;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     mWidth =&lt;span&gt; frame.width();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       从源码中对mWinFrame的注释来看，是由WindowManager提供的，该矩形正好是整个屏幕（这里暂时还没有在源码中找到明确的证据，后续找到后再补上）。在文章【&lt;a href=&quot;https://www.jianshu.com/p/58d22426e79e&quot; target=&quot;_blank&quot;&gt;Android图形系统（三）-View绘制流程&lt;/a&gt;】的“2.2 窗口布局阶段”中有提到，WindowManagerService服务计算Activity窗口的大小，并将Activity窗口的大小保存在成员变量mWinFrame中。对Activity窗口大小计算的详情，有兴趣的可以阅读一下大神罗升阳的博文【&lt;a href=&quot;https://blog.csdn.net/Luoshengyang/article/details/8479101&quot; target=&quot;_blank&quot;&gt;Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析&lt;/a&gt;】。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=================================ViewRootImpl.java================================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; WindowManager.LayoutParams mWindowAttributes = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WindowManager.LayoutParams();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    mWindowAttributes.copyFrom(attrs);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; performTraversals() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     ......
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      WindowManager.LayoutParams lp =&lt;span&gt; mWindowAttributes;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     ......     
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       第5行setView方法，在上一节中讲过，其中的参数就是ActivityThread类中传过来的，attrs是PhoneWindow的LayoutParams值，在第三节中就专门讲过这个参数，其width和height属性值均为LayoutParams.MATCH_PARENT。结合getRootMeasureSpec(int windowSize, int rootDimension)方法，可以得出如下结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190522163151435-1032765476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       此时，我们就得到了DecorView的MeasureSpec了，后面的递归操作就是在此基础上不断将测量要求从父布局传递到子view。&lt;/p&gt;

&lt;p&gt;  5、ViewGroup中辅助重写onMeasure的几个重要方法介绍&lt;/p&gt;
&lt;p&gt;        前面我们介绍的很多方法都是View类中提供的，ViewGroup中也提供了一些方法用于辅助ViewGroup子类容器的测量。这里重点介绍三个方法：measureChild(...)、measureChildWithMargins(...)和measureChildWithMargins(...)方法。&lt;/p&gt;
&lt;p&gt;    （1）measureChild()方法和measureChildWithMargins()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;================ViewGroup.java===============&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Ask one of the children of this view to measure itself, taking into
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * account both the MeasureSpec requirements for this view and its padding.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * The heavy lifting is done in getChildMeasureSpec.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; child The child to measure
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parentWidthMeasureSpec The width requirements for this view
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parentHeightMeasureSpec The height requirements for this view
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; measureChild(View child, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; parentWidthMeasureSpec,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; parentHeightMeasureSpec) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; LayoutParams lp =&lt;span&gt; child.getLayoutParams();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childWidthMeasureSpec =&lt;span&gt; getChildMeasureSpec(parentWidthMeasureSpec,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 mPaddingLeft +&lt;span&gt; mPaddingRight, lp.width);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childHeightMeasureSpec =&lt;span&gt; getChildMeasureSpec(parentHeightMeasureSpec,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 mPaddingTop +&lt;span&gt; mPaddingBottom, lp.height);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===================ViewGroup.java===================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Ask one of the children of this view to measure itself, taking into
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * account both the MeasureSpec requirements for this view and its padding
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * and margins. The child must have MarginLayoutParams The heavy lifting is
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * done in getChildMeasureSpec.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; child The child to measure
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parentWidthMeasureSpec The width requirements for this view
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; widthUsed Extra space that has been used up by the parent
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     *        horizontally (possibly by other children of the parent)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parentHeightMeasureSpec The height requirements for this view
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; heightUsed Extra space that has been used up by the parent
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     *        vertically (possibly by other children of the parent)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; measureChildWithMargins(View child,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; parentWidthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; widthUsed,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; parentHeightMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightUsed) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; MarginLayoutParams lp =&lt;span&gt; (MarginLayoutParams) child.getLayoutParams();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childWidthMeasureSpec =&lt;span&gt; getChildMeasureSpec(parentWidthMeasureSpec,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 mPaddingLeft + mPaddingRight + lp.leftMargin +&lt;span&gt; lp.rightMargin
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         +&lt;span&gt; widthUsed, lp.width);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childHeightMeasureSpec =&lt;span&gt; getChildMeasureSpec(parentHeightMeasureSpec,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 mPaddingTop + mPaddingBottom + lp.topMargin +&lt;span&gt; lp.bottomMargin
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         +&lt;span&gt; heightUsed, lp.height);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        对比这两个方法可以发现，它们非常相似，从注释上来看，后者在前者的基础上增加了已经使用的宽高和margin值。其实它们的功能都是一样的，最后都是生成子View的MeasureSpec，并传递给子View继续测量，即最后一句代码child.measure(childWidthMeasureSpec, childHeightMeasureSpec)。一般根据容器自身的需要来选择其中一个，比如，在FrameLayout和LinearLayout中重写的onMeasure方法中调用的就是后者，而AbsoluteLayout中就是间接地调用的前者。而RelativeLayout中，两者都没有调用，而是自己写了一套方法，不过该方法和后者方法仅略有差别，但基本功能还是一样，读者可以自己去看看它们的源码，这里就不贴出来了。&lt;/p&gt;
&lt;p&gt;    （2）getChildMeasureSpec()方法&lt;/p&gt;
&lt;p&gt;       前两个方法中都用到了这个方法，它很重要，它用于将父布局传递来的MeasureSpec和其子view的LayoutParams，整合为一个最有可能的子View的MeasureSpec。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================ViewGroup.java====================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Does the hard part of measureChildren: figuring out the MeasureSpec to
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * pass to a particular child. This method figures out the right MeasureSpec
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * for one dimension (height or width) of one child view.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * The goal is to combine information from our MeasureSpec with the
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * LayoutParams of the child to get the best possible results. For example,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * if the this view knows its size (because its MeasureSpec has a mode of
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * EXACTLY), and the child has indicated in its LayoutParams that it wants
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * to be the same size as the parent, the parent should ask the child to
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * layout given an exact size.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; spec The requirements for this view
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; padding The padding of this view for the current dimension and
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     *        margins, if applicable
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; childDimension How big the child wants to be in the current
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     *        dimension
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; a MeasureSpec integer for the child
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getChildMeasureSpec(&lt;span&gt;int&lt;/span&gt; spec, &lt;span&gt;int&lt;/span&gt; padding, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childDimension) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; specMode =&lt;span&gt; MeasureSpec.getMode(spec);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; specSize =&lt;span&gt; MeasureSpec.getSize(spec);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; size = Math.max(0, specSize -&lt;span&gt; padding);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; resultSize = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; resultMode = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (specMode) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parent has imposed an exact size on us&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.EXACTLY:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (childDimension &amp;gt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 resultSize =&lt;span&gt; childDimension;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.EXACTLY;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to be our size. So be it.&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;                 resultSize =&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.EXACTLY;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.WRAP_CONTENT) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to determine its own size. It can't be
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bigger than us.&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                 resultSize =&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.AT_MOST;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parent has imposed a maximum size on us&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.AT_MOST:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (childDimension &amp;gt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants a specific size... so be it&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;                 resultSize =&lt;span&gt; childDimension;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.EXACTLY;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to be our size, but our size is not fixed.
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Constrain child to not be bigger than us.&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                 resultSize =&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.AT_MOST;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.WRAP_CONTENT) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to determine its own size. It can't be
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bigger than us.&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;                 resultSize =&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.AT_MOST;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parent asked to see how big we want to be&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MeasureSpec.UNSPECIFIED:
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (childDimension &amp;gt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants a specific size... let him have it&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt;                 resultSize =&lt;span&gt; childDimension;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.EXACTLY;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to be our size... find out how big it should
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; be&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;                 resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0&lt;span&gt; : size;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.UNSPECIFIED;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (childDimension ==&lt;span&gt; LayoutParams.WRAP_CONTENT) {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child wants to determine its own size.... find out how
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; big it should be&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;                 resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0&lt;span&gt; : size;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                 resultMode =&lt;span&gt; MeasureSpec.UNSPECIFIED;
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;noinspection ResourceType&lt;/span&gt;
&lt;span&gt;87&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; MeasureSpec.makeMeasureSpec(resultSize, resultMode);
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 咱们依然先翻译和整理一下开头的注释：&lt;/p&gt;
&lt;p&gt;      1）处理measureChildren的困难部分：计算出Measure传递给指定的child。该方法计算出一个子view的宽或高的正确MeasureSpec。&lt;/p&gt;
&lt;p&gt;      2）其目的是组合来自我们MeasureSpec的信息和child的LayoutParams来得到最有可能的结果。比如：如果该view知道它的尺寸（因为它的MeasureSpec的mode为EXACTLY），并且它的child在它的LayoutParams中表示它想和父布局有一样大，那么父布局应该要求该child按照精确的尺寸进行布局。&lt;/p&gt;
&lt;p&gt;      3）参数spec：对该view的要求（笔者注：父布局对当前child的MeasureSpec要求）&lt;/p&gt;
&lt;p&gt;      4）参数padding：该view宽/高的padding和margins值，如果可应用的话。&lt;/p&gt;
&lt;p&gt;      5）参数childDimension：该child在宽/高上希望多大。&lt;/p&gt;
&lt;p&gt;      6）返回：返回该child的MeasureSpec整数。&lt;/p&gt;
&lt;p&gt;       如果明白了前文中对MeasureSpec的介绍后，这一部分的代码应该就容易理解了，specMode的三种值，LayoutParams的width和height的三种值，以及和layout_width、layout_height之间的关对应关系，在文章的开头已经介绍过了，不明白的可以再回头复习一下。specMode和specSize分别是父布局传下来的要求，size的值是父布局尺寸要求减去其padding值，最小不会小于0。代码最后就是将重新得到的mode和size组合生成一个新的MeasureSpec，传递给子View，一直递归下去，该方法也在前面讲过。本段代码重难点就是这里新mode和新size值的确定，specMode和childDimension各有3种值，所以最后会有9种组合。如果对这段代码看不明白的，可以看看笔者对这段代码的解释（width和height同理，这里以width为例）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果specMode的值为MeasureSpec.EXACTLY，即父布局对子view的尺寸要求是一个精确值，这有两种情况，父布局中layout_width属性值被设置为具体值，或者match_parent，它们都被定义为精确值。针对childDimension的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          i）childDimension也为精确值时。它是LayoutParams中width属性，是一个具体值，不包括match_parent情况，这个一定要和MeasureSpec中的精确值EXACTLY区别开来。此时resultSize为childDimension的精确值，resultMode理所当然为MeasureSpec.EXACTLY。这里不知道读者会不会又疑问，如果子View的layout_width值比父布局的大，那这个结论还成立吗？按照我们的经验，似乎不太能理解，因为子view的宽度再怎么样也不会比父布局大。事实上，我们平时经验看到的，是最后布局后绘制出来的结果，而当前步骤为测量值，是有差别的。读者可以自定义一个View，将父布局layout_width设置为100px，该自定义的子view则设置为200px，然后在子view中重写的onMeasure方法中打印出getMeasuredWidth()值看看，其值一定是200。甚至如果子view设置的值超过屏幕尺寸，其打印值也是设置的值。&lt;/p&gt;
&lt;p&gt;        ii）childDimension值为LayoutParams.MATCH_PARENT时。这个容易理解，它的尺寸和父布局一样，也是个精确值，所以resultSize为前面求出的size值，由父布局决定，resultMode为MeasureSpec.EXACTLY。&lt;/p&gt;
&lt;p&gt;        iii）childDimension值为LayoutParams.WRAP_CONTENT时。当子view的layout_width被设置为wrap_content时，即使最后我们肉眼看到屏幕上真正显示出来的控件很小，但在测量时和父布局一样的大小。这一点仍然可以通过打印getMeasuredWidth值来理解。所以一定不要被“经验”所误。所以resultSize值为size大小，resultMode为MeasureSpec.AT_MOST。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果specMode值为MeasureSpec.AT_MOST。其对应于layout_width为wrap_content，此时，我们可以想象到，子View对结果的决定性很大。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        i）childDimension为精确值时。很容易明确specSize为自身的精确值，specMode为MeasureSpec.EXACTLY。&lt;/p&gt;
&lt;p&gt;        ii）childDimension为LayoutParams.MATCH_PARENT时。specSize由父布局决定，为size；specMode为MeasureSpec.AT_MOST。&lt;/p&gt;
&lt;p&gt;        iii）childDimension为LayoutParams.WRAP_CONTENT时。specSize由父布局决定，为size；specMode为MeasureSpec.AT_MOST。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果specMode值为MeasureSpec.UNSPECIFIED。前面说过，平时很少用，一般用在系统中，不过这里还是简单说明一下。这一段有个变量View.sUseZeroUnspecifiedMeasureSpec，它是用于表示当前的目标api是否低于23（对应系统版本为Android M）的，低于23则为true，否则为false。现在系统版本基本上都是Android M及以上的，所以这里该值我们当成false来处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        i）childDimension为精确值时。很容易明确specSize为自身的精确值，specMode为MeasureSpec.EXACTLY。&lt;/p&gt;
&lt;p&gt;        ii）childDimension为LayoutParams.MATCH_PARENT时。specSize由父布局决定，为size；specMode和父布局一样，为MeasureSpec.UNSPECIFIED。&lt;/p&gt;
&lt;p&gt;        iii）childDimension为LayoutParams.WRAP_CONTENT时。specSize由父布局决定，为size；specMode和父布局一样，为MeasureSpec.UNSPECIFIED。&lt;/p&gt;
&lt;p&gt;       这个方法对理解测量时MeasureSpec的传递过程非常重要，并且需要记忆和理解的内容也不是，所以这里花的篇幅比较多。&lt;/p&gt;

&lt;p&gt;       通过这一节，我们介绍了ViewGroup在测量过程中要用到的方法。通过这些方法，我们更加深入理解了测量过程中ViewGroup是如何测量子View的了。&lt;/p&gt;

&lt;p&gt;  6、DecorView测量的大致流程&lt;/p&gt;
&lt;p&gt;       前面我们提到过DecorView的继承链：DecorView extends FrameLayout extends ViewGroup extends View。所以在这个继承过程中一定会有子类重写onMeasure方法，当DecorView第一次调用到measure()方法后，流程就开始切换到重写的onMeasure()中了。我们按照这个继承顺序看看measure流程的相关源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=============DecorView.java=============&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       ......
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onMeasure(widthMeasureSpec, heightMeasureSpec);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;       ......
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=============FrameLayout.java=============&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; getChildCount();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;final&lt;/span&gt; View child =&lt;span&gt; getChildAt(i);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;       ......
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;       ......             
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;   setMeasuredDimension(......)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    ...... }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       第17行中measureChildWithMargins()方法是ViewGroup提供的方法，前面我们介绍过了。从上述FrameLayout中重写的onMeasure方法中可以看到，是先把子view测量完成后，最后才去调用setMeasuredDimension(...)来测量自己的。事实上，整个测量过程就是从子view开始测量，然后一层层往上再测量父布局，直到DecorView为止的。&lt;/p&gt;
&lt;p&gt;       可能到这里有些读者会有个疑问，DecorView中onMeasure方法的参数值是从哪里传过来的呢？呵呵，前面花了很大的篇幅，就在不断地讲它俩，这里再强调啰嗦一次：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=====================ViewRootImpl.java=================&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; performTraversals() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; childWidthMeasureSpec =&lt;span&gt; getRootMeasureSpec(mWidth, lp.width);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; childHeightMeasureSpec =&lt;span&gt; getRootMeasureSpec(mHeight, lp.height);      
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果还是不明白，回过头去再看看这部分的说明吧，这里就不再赘述了。&lt;/p&gt;

&lt;p&gt;  7、DecorView视图树的简易measure流程图&lt;/p&gt;
&lt;p&gt;        到目前为止，DecorView的整个测量流程就接上了，从ViewRootImpl类的performTraversals()开始，经过递归遍历，最后到叶子view测量结束，DecorView视图树的测量就完成了。这里再用一个流程图简单描述一下整个流程：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190527134518936-2000774802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       在这一节的最后，推荐一篇博文，这里面有个非常详细的案例分析，如何一步一步从DecorView开始遍历，到整个View树测量完成，以及如何测量出每个view的宽高值：【&lt;a href=&quot;https://www.jianshu.com/p/5a71014e7b1b?from=singlemessage&quot; target=&quot;_blank&quot;&gt;Android View的绘制流程：https://www.jianshu.com/p/5a71014e7b1b?from=singlemessage&lt;/a&gt;】Measure过程的第4点。认真分析完该实例，一定会对测量过程有个更深刻的认识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、layout过程分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       当measure过程完成后，接下来就会进行layout阶段，即布局阶段。在前面measure的作用是测量每个view的尺寸，而layout的作用是根据前面测量的尺寸以及设置的其它属性值，共同来确定View的位置。&lt;/p&gt;
&lt;p&gt;  1、performLayout方法引出DecorView的布局流程&lt;/p&gt;
&lt;p&gt;       测量完成后，会在ViewRootImpl类的performTraverserals()方法中，开始调用performLayout方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
performLayout(lp, mWidth, mHeight);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       传入该方法的参数我们在上一节中已经分析过了，lp中width和height均为LayoutParams.MATCH_PARENT，mWidth和mHeight分别为屏幕的宽高。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=====================ViewRootImpl.java===================&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; performLayout(WindowManager.LayoutParams lp, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; desiredWindowWidth,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; desiredWindowHeight) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    &lt;span&gt;final&lt;/span&gt; View host =&lt;span&gt; mView;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;    host.layout(0, 0&lt;span&gt;, host.getMeasuredWidth(), host.getMeasuredHeight());
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;   ......
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       mView的值上一节也讲过，就是DecorView，布局流程也是从DecorView开始遍历和递归。&lt;/p&gt;

&lt;p&gt;  2、layout方法正式启动布局流程&lt;/p&gt;
&lt;p&gt;       由于DecorView是一个容器，是ViewGroup子类，所以跟踪代码的时候，实际上是先进入到ViewGroup类中的layout方法中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================ViewGroup.java================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; layout(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!mSuppressLayout &amp;amp;&amp;amp; (mTransition == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;mTransition.isChangingLayout())) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (mTransition != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 mTransition.layoutChange(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.layout(l, t, r, b);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; record the fact that we noop'd it; request layout when transition finishes&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             mLayoutCalledWhileSuppressed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       这是一个final类型的方法，所以自定义 的ViewGroup子类无法重写该方法，可见系统不希望自定义的ViewGroup子类破坏layout流程。继续追踪super.layout方法，又跳转到了View中的layout方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=================View.java================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Assign a size and position to a view and all of its
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * descendants
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;This is the second phase of the layout mechanism.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * (The first is measuring). In this phase, each parent calls
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * layout on all of its children to position them.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * This is typically done using the child measurements
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * that were stored in the measure pass().&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Derived classes should not override this method.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * Derived classes with children should override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * onLayout. In that method, they should
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * call layout on each of their children.&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; l Left position, relative to parent
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t Top position, relative to parent
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; r Right position, relative to parent
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; b Bottom position, relative to parent
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     @SuppressWarnings({&quot;unchecked&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; layout(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; changed = isLayoutModeOptical(mParent) ?
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);  
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (changed || (mPrivateFlags &amp;amp; PFLAG_LAYOUT_REQUIRED) ==&lt;span&gt; PFLAG_LAYOUT_REQUIRED) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            onLayout(changed, l, t, r, b);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            ......
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;         ......
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 先翻译一下注释中对该方法的描述：&lt;/p&gt;
&lt;p&gt;      1）给view和它的所有后代分配尺寸和位置。&lt;/p&gt;
&lt;p&gt;      2）这是布局机制的第二个阶段（第一个阶段是测量）。在这一阶段中，每一个父布局都会对它的子view进行布局来放置它们。一般来说，该过程会使用在测量阶段存储的child测量值。&lt;/p&gt;
&lt;p&gt;      3）派生类不应该重写该方法。有子view的派生类（笔者注：也就是容器类，父布局）应该重写onLayout方法。在重写的onLayout方法中，它们应该为每一子view调用layout方法进行布局。&lt;/p&gt;
&lt;p&gt;      4）参数依次为：Left、Top、Right、Bottom四个点相对父布局的位置。&lt;/p&gt;

&lt;p&gt;  3、setFrame方法真正执行布局任务&lt;/p&gt;
&lt;p&gt;       在上面的方法体中，我们先重点看看setFrame方法。至于setOpticalFrame方法，其中也是调用的setFrame方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=================View.java================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Assign a size and position to this view.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * This is called from layout.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; left Left position, relative to parent
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; top Top position, relative to parent
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; right Right position, relative to parent
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bottom Bottom position, relative to parent
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true if the new size and position are different than the
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     *         previous ones
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * {@hide}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; setFrame(&lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; top, &lt;span&gt;int&lt;/span&gt; right, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bottom) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; changed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (mLeft != left || mRight != right || mTop != top || mBottom !=&lt;span&gt; bottom) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             changed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            ......
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oldWidth = mRight -&lt;span&gt; mLeft;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oldHeight = mBottom -&lt;span&gt; mTop;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; newWidth = right -&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; newHeight = bottom -&lt;span&gt; top;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; sizeChanged = (newWidth != oldWidth) || (newHeight !=&lt;span&gt; oldHeight);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Invalidate our old position&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            invalidate(sizeChanged);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;             mLeft =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             mTop =&lt;span&gt; top;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             mRight =&lt;span&gt; right;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             mBottom =&lt;span&gt; bottom;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            ......
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; changed;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  注释中重要的信息有：&lt;/p&gt;
&lt;p&gt;      1）该方法用于给该view分配尺寸和位置。（笔者注：也就是实际的布局工作是在这里完成的）&lt;/p&gt;
&lt;p&gt;      2）返回值：如果新的尺寸和位置和之前的不同，返回true。（笔者注：也就是该view的位置或大小发生了变化）&lt;/p&gt;
&lt;p&gt;       在方法体中，从第27行开始，对view的四个属性值进行了赋值，即mLeft、mTop、mRight、mBottom四条边界坐标被确定，表明这里完成了对该View的布局。&lt;/p&gt;

&lt;p&gt;  4、onLayout方法让父布局调用对子view的布局&lt;/p&gt;
&lt;p&gt;      再返回到layout方法中，会看到如果view发生了改变，接下来会调用onLayout方法，这和measure调用onMeasure方法类似。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;============View.java============&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Called from layout when this view should
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * assign a size and position to each of its children.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * Derived classes with children should override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * this method and call layout on each of
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * their children.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; changed This is a new size or position for this view
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; left Left position, relative to parent
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; top Top position, relative to parent
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; right Right position, relative to parent
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bottom Bottom position, relative to parent
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onLayout(&lt;span&gt;boolean&lt;/span&gt; changed, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; top, &lt;span&gt;int&lt;/span&gt; right, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bottom) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 先翻译一下关键注释：&lt;/p&gt;
&lt;p&gt;      1）当该view要分配尺寸和位置给它的每一个子view时，该方法会从layout方法中被调用。&lt;/p&gt;
&lt;p&gt;      2）有子view的派生类（笔者注：也就是容器，父布局）应该重写该方法并且为每一个子view调用layout。&lt;/p&gt;
&lt;p&gt;       我们发现这是一个空方法，因为layout过程是父布局容器布局子view的过程，onLayout方法叶子view没有意义，只有ViewGroup才有用。所以，如果当前View是一个容器，那么流程会切到被重写的onLayout方法中。我们先看ViewGroup类中的重写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=============ViewGroup.java===========&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onLayout(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; changed,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;            &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt; b);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       进入到ViewGroup类中发现，该方法被定义为了abstract方法，所以以后凡是直接继承自ViewGroup类的容器，就必须要重写onLayout方法。 事实上，layout流程是绘制流程中必需的过程，而前面讲过的measure流程，其实可以不要，这一点等会再说。&lt;/p&gt;
&lt;p&gt;       咱们先直接进入到DecorView中查看重写的onLayout方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==============DecorView.java================&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onLayout(&lt;span&gt;boolean&lt;/span&gt; changed, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; top, &lt;span&gt;int&lt;/span&gt; right, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bottom) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;      &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onLayout(changed, left, top, right, bottom);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;     ......
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       DecerView继承自FrameLayout，咱们继续到FrameLayout类中重写的onLayout方法看看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;================FrameLayout.java==============&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onLayout(&lt;span&gt;boolean&lt;/span&gt; changed, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; top, &lt;span&gt;int&lt;/span&gt; right, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bottom) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         layoutChildren(left, top, right, bottom, &lt;span&gt;false&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; no force left gravity &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; layoutChildren(&lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; top, &lt;span&gt;int&lt;/span&gt; right, &lt;span&gt;int&lt;/span&gt; bottom, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; forceLeftGravity) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; getChildCount();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;              &lt;span&gt;final&lt;/span&gt; View child =&lt;span&gt; getChildAt(i);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt; (child.getVisibility() !=&lt;span&gt; GONE) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                  &lt;span&gt;final&lt;/span&gt; LayoutParams lp =&lt;span&gt; (LayoutParams) child.getLayoutParams();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; width =&lt;span&gt; child.getMeasuredWidth();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; child.getMeasuredHeight();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                 ......
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                  child.layout(childLeft, childTop, childLeft + width, childTop +&lt;span&gt; height);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       这里仅贴出关键流程的代码，咱们可以看到，这里面也是对每一个child调用layout方法的。如果该child仍然是父布局，会继续递归下去；如果是叶子view，则会走到view的onLayout空方法，该叶子view布局流程走完。另外，我们看到第15行和第16行中，width和height分别来源于measure阶段存储的测量值，如果这里通过其它渠道赋给width和height值，那么measure阶段就不需要了，这也就是我前面提到的，onLayout是必需要实现的（不仅会报错，更重要的是不对子view布局的话，这些view就不会显示了），而measure过程可以不要。当然，肯定是不建议这么做的，采用其它方式很实现我们要的结果。&lt;/p&gt;

&lt;p&gt;  5、DecorView视图树的简易布局流程图&lt;/p&gt;
&lt;p&gt;       如果是前面搞清楚了DecorView视图树的测量流程，那这一节的布局流程也就非常好理解了，咱们这里再简单梳理一下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190527140844001-1305183349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;七、draw过程分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       当layout完成后，就进入到draw阶段了，在这个阶段，会根据layout中确定的各个view的位置将它们画出来。该过程的分析思路和前两个过程类似，如果前面读懂了，那这个流程也就很容易理解了。&lt;/p&gt;
&lt;p&gt;  1、从performDraw方法到draw方法&lt;/p&gt;
&lt;p&gt;       draw过程，自然也是从performTraversals()中的performDraw()方法开始的，咱们从该方法追踪，咱们这里仅贴出关键流程代码，至于其它的逻辑，不是本文的重点，这里就先略过，有兴趣的可以自行研究。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================ViewRootImpl.java=================&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; performDraw() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;boolean&lt;/span&gt; canUseAsync =&lt;span&gt; draw(fullRedrawNeeded);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; draw(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; fullRedrawNeeded) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;drawSoftware(surface, mAttachInfo, xOffset, yOffset,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                        scalingRequired, dirty, surfaceInsets)) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; drawSoftware(......){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      mView.draw(canvas);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       前面我们讲过了，这mView就是DecorView，这样就开始了DecorView视图树的draw流程了。&lt;/p&gt;
&lt;p&gt;  2、DecorView树递归完成“画”流程&lt;/p&gt;
&lt;p&gt;       DecorView类中重写了draw()方法，追踪源码后进入到该部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;================DecorView.java==============&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; draw(Canvas canvas) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;      &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.draw(canvas);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt; (mMenuBackground != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;         mMenuBackground.draw(canvas);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       从这段代码来看， 调用完super.draw后，还画了菜单背景，当然super.draw是咱们关注的重点，这里还做了啥咱们不用太关心。由于FrameLayout和ViewGroup都没有重写该方法，所以就直接进入都了View类中的draw方法了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;====================View.java===================== &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Manually render this view (and all of its children) to the given Canvas.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * The view must have already done a full layout before this function is
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * called.  When implementing a view, implement
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #onDraw(android.graphics.Canvas)} instead of overriding this method.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * If you do need to override this method, call the superclass version.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; canvas The Canvas to which the View is rendered.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @CallSuper
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; draw(Canvas canvas) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;       ......
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         * Draw traversal performs several drawing steps which must be executed
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         * in the appropriate order:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;         *      1. Draw the background
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         *      2. If necessary, save the canvas' layers to prepare for fading
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;         *      3. Draw view's content
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;         *      4. Draw children
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;         *      5. If necessary, draw the fading edges and restore layers
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;         *      6. Draw decorations (scrollbars for instance)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 1, draw the background, if needed&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; saveCount;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;dirtyOpaque) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            drawBackground(canvas);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; skip step 2 &amp;amp; 5 if possible (common case)&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 3, draw the content&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;dirtyOpaque) onDraw(canvas);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 4, draw the children&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        dispatchDraw(canvas);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Step 6, draw decorations (foreground, scrollbars)&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         onDrawForeground(canvas);45&lt;span&gt;         ......
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这段代码描述了draw阶段完成的7个主要步骤，这里咱们先翻译一下其注释：&lt;/p&gt;
&lt;p&gt;      1）手动渲染该view（以及它的所有子view）到给定的画布上。&lt;/p&gt;
&lt;p&gt;      2）在该方法调用之前，该view必须已经完成了全面的布局。当正在实现一个view是，实现onDraw(android.graphics.Cavas)而不是本方法。如果您确实需要重写该方法，调用超类版本。&lt;/p&gt;
&lt;p&gt;      3）参数canvas：将view渲染到的画布。&lt;/p&gt;
&lt;p&gt;      从代码上看，这里做了很多工作，咱们简单说明一下，有助于理解这个“画”工作。&lt;/p&gt;
&lt;p&gt;      1）第一步：画背景。对应我我们在xml布局文件中设置的“android:background”属性，这是整个“画”过程的第一步，这一步是不重点，知道这里干了什么就行。&lt;/p&gt;
&lt;p&gt;      2）第二步：画内容（第2步和第5步只有有需要的时候才用到，这里就跳过）。比如TextView的文字等，这是重点，onDraw方法，后面详细介绍。&lt;/p&gt;
&lt;p&gt;      3）第三步：画子view。dispatchDraw方法用于帮助ViewGroup来递归画它的子view。这也是重点，后面也要详细讲到。&lt;/p&gt;
&lt;p&gt;      4）第四步：画装饰。这里指画滚动条和前景。其实平时的每一个view都有滚动条，只是没有显示而已。同样这也不是重点，知道做了这些事就行。&lt;/p&gt;
&lt;p&gt;       咱们进入onDraw方法看看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=================View.java===============&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;     * Implement this to do your drawing.
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; canvas the canvas on which the background will be drawn
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDraw(Canvas canvas) {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注释中说：实现该方法来做“画”工作。也就是说，具体的view需要重写该方法，来画自己想展示的东西，如文字，线条等。DecorView中重写了该方法，所以流程会走到DecorView中重写的onDraw方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===============DocerView.java==============&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDraw(Canvas c) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onDraw(c);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;       mBackgroundFallback.draw(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, mContentRoot, c, mWindow.mContentParent,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        mStatusColorViewState.view, mNavigationColorViewState.view);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这里调用了onDraw的父类方法，同时第4行还画了自己特定的东西。由于FrameLayout和ViewGroup也没有重写该方法，且View中onDraw为空方法，所以super.onDraw方法其实是啥都没干的。DocerView画完自己的东西，紧接着流程就又走到dispatchDraw方法了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;================View.java===============&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Called by draw to draw the child views. This may be overridden
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * by derived classes to gain control just before its children are drawn
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * (but after its own view has been drawn).
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; canvas the canvas on which to draw the view
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispatchDraw(Canvas canvas) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       先看看注释：被draw方法调用来画子View。该方法可能会被派生类重写来获取控制，这个过程正好在该view的子view被画之前（但在它自己被画完成后）。&lt;/p&gt;
&lt;p&gt;       也就是说当本view被画完之后，就开始要画它的子view了。这个方法也是一个空方法，实际上对于叶子view来说，该方法没有什么意义，因为它没有子view需要画了，而对于ViewGroup来说，就需要重写该方法来画它的子view。&lt;/p&gt;
&lt;p&gt;       在源码中发现，像平时常用的LinearLayout、FrameLayout、RelativeLayout等常用的布局控件，都没有再重写该方法，DecorView中也一样，而是只在ViewGroup中实现了dispatchDraw方法的重写。所以当DecorView执行完onDraw方法后，流程就会切到ViewGroup中的dispatchDraw方法了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=============ViewGroup.java============&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispatchDraw(Canvas canvas) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childrenCount =&lt;span&gt; mChildrenCount;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; View[] children =&lt;span&gt; mChildren;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; childrenCount; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             more |=&lt;span&gt; drawChild(canvas, child, drawingTime);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            ......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        ...... 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       从上述源码片段可以发现，这里其实就是对每一个child执行drawChild操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Draw one child of this View Group. This method is responsible for getting
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * the canvas in the right state. This includes clipping, translating so
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * that the child's scrolled origin is at 0, 0, and applying any animation
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * transformations.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; canvas The canvas on which to draw the child
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; child Who to draw
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; drawingTime The time at which draw is occurring
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; True if an invalidate() was issued
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; drawChild(Canvas canvas, View child, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; drawingTime) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; child.draw(canvas, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, drawingTime);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先翻译注释的内容：&lt;/p&gt;
&lt;p&gt;      1）画当前ViewGroup中的某一个子view。该方法负责在正确的状态下获取画布。这包括了裁剪，移动，以便子view的滚动原点为0、0，以及提供任何动画转换。&lt;/p&gt;
&lt;p&gt;      2）参数drawingTime：“画”动作发生的时间点。&lt;/p&gt;
&lt;p&gt;       继续追踪源码，进入到如下流程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;============View.java===========&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * This method is called by ViewGroup.drawChild() to have each child view draw itself.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * This is where the View specializes rendering behavior based on layer type,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * and hardware acceleration.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; draw(Canvas canvas, ViewGroup parent, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; drawingTime) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      draw(canvas);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      ......
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       注释中说：该方法被ViewGroup.drawChild()方法调用，来让每一个子view画它自己。&lt;/p&gt;
&lt;p&gt;       该方法中，又回到了draw(canvas)方法中了，然后再开始画其子view，这样不断递归下去，直到画完整棵DecorView树。&lt;/p&gt;

&lt;p&gt;  3、DecorView视图树的简易draw流程图&lt;/p&gt;
&lt;p&gt;       针对上述的代码追踪流程，这里梳理了DecorView整个view树的draw过程的关键流程，其中节点比较多，需要耐心分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190527183905535-1898063916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       到目前为止，View的绘制流程就介绍完了。根节点是DecorView，整个View体系就是一棵以DecorView为根的View树，依次通过遍历来完成measure、layout和draw过程。而如果要自定义view，一般都是通过重写onMeasure()，onLayout()，onDraw()来完成要自定义的部分，整个绘制流程也基本上是围绕着这几个核心的地方来展开的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;八、博文参考阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       【&lt;a href=&quot;https://blog.csdn.net/mr_liabill/article/details/49534851&quot; target=&quot;_blank&quot;&gt;Android View视图层次&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;       【&lt;a href=&quot;https://www.jianshu.com/p/a8850e7cbac2&quot; target=&quot;_blank&quot;&gt;Android进阶 - 视图层级实时分析&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;       【&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/16330267&quot; target=&quot;_blank&quot;&gt;Android视图绘制流程完全解析，带你一步步深入了解View(二)&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;       【&lt;a href=&quot;https://www.jianshu.com/p/58d22426e79e&quot; target=&quot;_blank&quot;&gt;Android图形系统（三）-View绘制流程&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;       【&lt;a href=&quot;https://blog.csdn.net/sinat_27154507/article/details/79748010&quot; target=&quot;_blank&quot;&gt;Android View的绘制流程&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;       【&lt;a href=&quot;https://www.jianshu.com/p/5a71014e7b1b?from=singlemessage&quot; target=&quot;_blank&quot;&gt;Android View的绘制流程&lt;/a&gt;】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       本文的篇幅比较长，能看完并且理解也是一件辛苦的事情，笔者学习及写这篇博客，也是花了将近半个月的业余时间来完成的。但是要想超过别人，就是要做一件有一件辛苦但能够成长的事情，时间长了，人与人之间的距离就拉开了。所以，真心希望本文能帮助您理解View的绘制流程，那笔者半个月来的辛苦也就没有白费了。当然，本文肯定存在很多不足之处，希望笔者能不吝赐教，共同进步。&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 06:25:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>自定义View、多线程、网络，被认为是Android开发者必须牢固掌握的最基础的三大基本功。Android View的绘制流程原理又是学好自定义View的理论基础，所以掌握好View的绘制原理是And</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/10955062.html</dc:identifier>
</item>
<item>
<title>如何在ASP.NET Core自定义中间件中读取Request.Body和Response.Body的内容？ - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10954936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10954936.html</guid>
<description>&lt;blockquote readability=&quot;4.3862660944206&quot;&gt;
&lt;p&gt;文章名称： 如何在ASP.NET Core自定义中间件读取Request.Body和Response.Body的内容？&lt;br/&gt;作者： Lamond Lu&lt;br/&gt;地址： &lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10954936.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/10954936.html&lt;/a&gt;&lt;br/&gt;源代码： &lt;a href=&quot;https://github.com/lamondlu/webapi-logger&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/webapi-logger&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190531141331449-314675256.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近在徒手造轮子，编写一个ASP.NET Core的日志监控器，其中用到了自定义中间件读取Request.Body和Response.Body的内容，但是编写过程，并不像想象中的一帆风顺，ASP.NET Core针对Request.Body和Response.Body的几个特殊设计，导致了完成以上功能需要绕一些弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190531141712897-1395535781.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了读取Request.Body和Response.Body的内容，我的实现思路如下：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建一个LoggerMiddleware的中间件，将它放置在项目中间件管道的头部。因为根据ASP.NET Core的中间件管道设计，只有第一个中间件才能获取到原始的请求信息和最终的响应信息。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190531140213549-140760954.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Request.Body和Response.Body属性都是Steram类型， 在LoggerMiddleware中间件的&lt;code&gt;InvokeAsync&lt;/code&gt;方法中，我们可以分别使用&lt;code&gt;StreamReader&lt;/code&gt;读取Request.Body和Response.Body的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据以上思路，我编写了以下代码。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;LoggerMiddleware.cs&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class LoggerMiddleware
    {
        private readonly RequestDelegate _next;

        public LoggerMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var requestReader = new StreamReader(context.Request.Body);

            var requestContent = requestReader.ReadToEnd();
            Console.WriteLine($&quot;Request Body: {requestContent}&quot;);

            await _next(context);

            var responseReader = new StreamReader(context.Response.Body);
            var responseContent = responseReader.ReadToEnd();
            Console.WriteLine($&quot;Response Body: {responseContent}&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Startup.cs&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseMiddleware&amp;lt;LoggerMiddleware&amp;gt;();
            app.UseDeveloperExceptionPage();
        }
        else
        {
            app.UseHsts();
        }

        app.UseHttpsRedirection();
        app.UseMvc();
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里为了测试我创建了一个默认的ASP.NET Core WebApi项目。当运行程序，使用GET方式调用/api/values之后，控制台会返回第一个需要处理的错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.ArgumentException: Stream was not readable.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即ASP.NET Core默认创建的Response.Body属性是不可读的。&lt;/p&gt;
&lt;p&gt;这一点我们可以通过打断点看到Response.Body属性的&lt;code&gt;CanRead&lt;/code&gt;值是false。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这就很糟糕了，ASP.NET Core默认并不想让我们在中间件中直接读取Response.Body中的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里看似的无解，但是我们可以转换一下思路，既然ASP.NET Core默认将Response.Body是不可读的，那么我们就使用一个可读可写的Stream对象将其替换掉。这样当所有中间件都依次执行完之后，我们就可以读取Response.Body的内容了。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task InvokeAsync(HttpContext context)
{
     var requestReader = new StreamReader(context.Request.Body);

     var requestContent = requestReader.ReadToEnd();
     Console.WriteLine($&quot;Request Body: {requestContent}&quot;);

     using (var ms = new MemoryStream())
     {
         context.Response.Body = ms;
         await _next(context);

         context.Response.Body.Position = 0;

         var responseReader = new StreamReader(context.Response.Body);

         var responseContent = responseReader.ReadToEnd();
         Console.WriteLine($&quot;Response Body: {responseContent}&quot;);

         context.Response.Body.Position = 0;
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;读取Response.Body的时候，需要设置Position = 0, 这样是为了重置指针，如果不这样做的话，会导致读取的流不正确。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;这里千万不要用using包裹StreamReader, 因为StreamReader会在读取完Stream内容之后，将Stream关闭，导致后续由于Stream关闭，而不能再次读取Stream中的内容。如果必须使用，请使用StreamReader的以下重载，将leaveOpen参数设置为true, 确保StreamReader对象被销毁的时候不会自动关闭读取的Stream.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;重新启动程序，请求/api/values, 我们就得到的正确的结果。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190531140300106-1718475515.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上代码实现，看似已经能够读取Response.Body的内容了，但是其实还是有问题的。&lt;/p&gt;
&lt;p&gt;回想一下，我们做出以上方案的前提是，当前LoggerMiddleware中间件必须位于中间件管道的头部。&lt;/p&gt;
&lt;p&gt;如果不能保证这个约定, 就会出现问题，因为我们在LoggerMiddleware中间件中将Response.Body属性指向了一个新的可读可写的Stream对象。如果LoggerMiddleware中间件之前的某个中间件中设置过Response.Body, 就会导致这部分设置丢失。&lt;/p&gt;
&lt;p&gt;因此正确的设置方式应该是这样的：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public async Task InvokeAsync(HttpContext context)
    {
        var originalResponseStream = context.Response.Body;

        var requestReader = new StreamReader(context.Request.Body);
        
        var requestContent = requestReader.ReadToEnd();
        Console.WriteLine($&quot;Request Body: {requestContent}&quot;);
        

        using (var ms = new MemoryStream())
        {
            context.Response.Body = ms;
            await _next(context);


            ms.Position = 0;
            var responseReader = new StreamReader(ms);

            var responseContent = responseReader.ReadToEnd();
            Console.WriteLine($&quot;Response Body: {responseContent}&quot;);

            ms.Position = 0;

            await ms.CopyToAsync(originalResponseStream);
            context.Response.Body = originalResponseStream;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里当进入LoggerMiddleware中间件时，我们将之前中间件操作完成之后的Response.Body对象对应的原始Stream, 保存在一个临时变量中&lt;/li&gt;
&lt;li&gt;当LoggerMiddelware中间件的任务完成之后，我们需要将后续产生的Response.Body流追加到原始Stream中，然后将Response.Body对象重置为这个新的Stream。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;至此Repsonse.Body的问题都解决，下面我们再来看一下Request.Body的问题。&lt;/p&gt;

&lt;p&gt;下面我们来请求POST /api/values, Request.Body里面的内容是字符串&quot;123123&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190531140311800-1968934420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务器端返回了400错误， 错误信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A non-empty request body is required.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就很奇怪，为啥请求体是空呢？我们回到中间件部分代码，这里我们在读取完Request.Body中的Stream之后，没有将Stream的指针重置，当前指针已经是Stream的尾部，所以后续ModelBinding的时候，读取不到Stream的内容了。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public async Task InvokeAsync(HttpContext context)
    {
        ...
        var requestReader = new StreamReader(context.Request.Body);
        
        var requestContent = requestReader.ReadToEnd();
        Console.WriteLine($&quot;Request Body: {requestContent}&quot;);
        ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是，这里我们需要采取和Response.Body相同的处理方式，在读取完Request.Body之后，我们需要将Request.Body的Stream指针重置&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public async Task InvokeAsync(HttpContext context)
    {
        ...
        var requestReader = new StreamReader(context.Request.Body);
        
        var requestContent = requestReader.ReadToEnd();
        Console.WriteLine($&quot;Request Body: {requestContent}&quot;);
        context.Request.Body.Position = 0;
        ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;你一定觉着至此问题就解决了，不过ASP.NET Core和你又开了一个玩笑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当你重新请求POST /api/values之后，你会得到以下结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190531140329954-1975657446.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;错误原因：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.NotSupportedException: Specified method is not supported.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译过来就是指定方法不支持。到底不支持啥呢？在代码上打上断点，你会发现Request.Body的CanSeek属性是false, 即Request.Body的Stream, 你是不能随便移动指针的，只能按顺序读取一次，默认不支持反复读取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190531140337200-398026294.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如何解决这个问题呢？&lt;/p&gt;
&lt;p&gt;你可以在使用Request对象中的&lt;code&gt;EnableRewind&lt;/code&gt;或者&lt;code&gt;EnableBuffering&lt;/code&gt;。 这2个方法的作用都是在内存中创建缓冲区存放Request.Body的内容，从而允许反复读取Request.Body的Stream。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;说明： 其实&lt;code&gt;EnableBuffering&lt;/code&gt;方法内部就只直接调用的&lt;code&gt;EnableRewind&lt;/code&gt;方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们修改代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public async Task InvokeAsync(HttpContext context)
    {
        context.Request.EnableBuffering();
        var requestReader = new StreamReader(context.Request.Body);

        var requestContent = requestReader.ReadToEnd();
        Console.WriteLine($&quot;Request Body: {requestContent}&quot;);
        context.Request.Body.Position = 0;


        using (var ms = new MemoryStream())
        {
            context.Response.Body = ms;
            await _next(context);


            ms.Position = 0;
            var responseReader = new StreamReader(ms);

            var responseContent = responseReader.ReadToEnd();
            Console.WriteLine($&quot;Response Body: {responseContent}&quot;);

            ms.Position = 0;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次请求POST /api/values, api请求被正确的处理了。&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 06:17:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>文章名称： 如何在ASP.NET Core自定义中间件读取Request.Body和Response.Body的内容？ 作者： Lamond Lu 地址： https://www.cnblogs.co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/10954936.html</dc:identifier>
</item>
</channel>
</rss>