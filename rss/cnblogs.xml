<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringBoot启动流程分析（一）：SpringApplication类初始化过程 - 超级小小黑</title>
<link>http://www.cnblogs.com/hello-shf/p/10976646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hello-shf/p/10976646.html</guid>
<description>&lt;p&gt;SpringBoot系列文章简介&lt;/p&gt;
&lt;p&gt;SpringBoot源码阅读辅助篇：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11006750.html&quot; target=&quot;_blank&quot;&gt;Spring IoC容器与应用上下文的设计与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot启动流程源码分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/10976646.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（一）：SpringApplication类初始化过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/10992377.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（二）：SpringApplication的run方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11018403.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（三）：SpringApplication的run方法之prepareContext()方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11051476.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（四）：IoC容器的初始化过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11057861.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（五）：SpringBoot自动装配原理实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/11060546.html&quot; target=&quot;_blank&quot;&gt;SpringBoot启动流程分析（六）：IoC容器依赖注入&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;笔者注释版Spring Framework与SpringBoot源码git传送门：请不要吝啬小星星&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/hello-shf/spring-framework-5.0.8.RELEASE.git&quot; target=&quot;_blank&quot;&gt;spring-framework-5.0.8.RELEASE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hello-shf/spring-boot-build.git&quot; target=&quot;_blank&quot;&gt;SpringBoot-2.0.4.RELEASE&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;　　1.1、SpringBoot项目的mian函数&lt;/h2&gt;
&lt;p&gt;　　常规的这个主类如下图所示，我们一般会这样去写。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190604222532156-691893779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在这个类中需要关注的是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@SpringBootApplication&lt;/li&gt;
&lt;li&gt;SpringApplication.run()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　关于 &lt;span class=&quot;cnblogs_code&quot;&gt;@SpringBootApplication&lt;/span&gt; 注解，在后面分析SpringBoot自动装配的章节会展开去分析。&lt;/p&gt;
&lt;p&gt;　　本章节中我们需要关注的就是 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringApplication.run()&lt;/span&gt; 方法。&lt;/p&gt;
&lt;p&gt;　　查看run()方法的实现，如下面代码所示，我们发现其实其首先是创建了 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringApplication&lt;/span&gt; 的实例，然后调用了 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringApplication&lt;/span&gt; 的run()方法，那本章我们关注的就是 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringApplication&lt;/span&gt; 创建实例的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Static helper that can be used to run a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SpringApplication} from the
     * specified sources using default settings and user supplied arguments.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; primarySources the primary sources to load
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args           the application arguments (usually passed from a Java main method)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the running {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ApplicationContext}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt;&lt;span&gt;[] primarySources,
                                                     String[] args) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringApplication(primarySources).run(args);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　1.2、 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringApplication()&lt;/span&gt; 构造方法&lt;/h2&gt;
&lt;p&gt;　　继续查看源码， &lt;span class=&quot;cnblogs_code&quot;&gt;SpringApplication&lt;/span&gt; 实例化过程，首先是进入但参数的构造方法，最终回来到两个参数的构造方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; SpringApplication(Class&amp;lt;?&amp;gt;&lt;span&gt;... primarySources) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, primarySources);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;&lt;span&gt;... primarySources) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.resourceLoader =&lt;span&gt; resourceLoader;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.primarySources = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;(Arrays.asList(primarySources));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;推断应用类型，后面会根据类型初始化对应的环境。常用的一般都是servlet环境&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.webApplicationType =&lt;span&gt; deduceWebApplicationType();//2.2.1
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化classpath下 META-INF/spring.factories中已配置的ApplicationContextInitializer&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));//2.2.2
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化classpath下所有已配置的 ApplicationListener&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));//2.2.3
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据调用栈，推断出 main 方法的类名&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.mainApplicationClass =&lt;span&gt; deduceMainApplicationClass();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 　　1.2.1、deduceWebApplicationType();该方法推断应用的类型。 &lt;span class=&quot;cnblogs_code&quot;&gt;SERVLET REACTIVE NONE&lt;/span&gt; &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;常量值&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String[] WEB_ENVIRONMENT_CLASSES = {&quot;javax.servlet.Servlet&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String REACTIVE_WEB_ENVIRONMENT_CLASS = &quot;org.springframework.&quot;
&lt;span&gt; 6&lt;/span&gt;         + &quot;web.reactive.DispatcherHandler&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String MVC_WEB_ENVIRONMENT_CLASS = &quot;org.springframework.&quot;
&lt;span&gt; 9&lt;/span&gt;         + &quot;web.servlet.DispatcherServlet&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String JERSEY_WEB_ENVIRONMENT_CLASS = &quot;org.glassfish.jersey.server.ResourceConfig&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * 判断 应用的类型
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * NONE: 应用程序不是web应用，也不应该用web服务器去启动
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * SERVLET: 应用程序应作为基于servlet的web应用程序运行，并应启动嵌入式servlet web（tomcat）服务器。
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * REACTIVE: 应用程序应作为 reactive web应用程序运行，并应启动嵌入式 reactive web服务器。
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; WebApplicationType deduceWebApplicationType() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;classpath下必须存在org.springframework.web.reactive.DispatcherHandler&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &amp;amp;&amp;amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &amp;amp;&amp;amp; !ClassUtils.isPresent(JERSEY_WEB_ENVIRONMENT_CLASS, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; WebApplicationType.REACTIVE;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String className : WEB_ENVIRONMENT_CLASSES) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!ClassUtils.isPresent(className, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; WebApplicationType.NONE;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;classpath环境下存在javax.servlet.Servlet或者org.springframework.web.context.ConfigurableWebApplicationContext&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; WebApplicationType.SERVLET;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　返回类型是WebApplicationType的枚举类型， &lt;span class=&quot;cnblogs_code&quot;&gt;WebApplicationType&lt;/span&gt; 有三个枚举，三个枚举的解释如其中注释&lt;/p&gt;
&lt;p&gt;　　具体的判断逻辑如下：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WebApplicationType.REACTIVE  classpath下存在org.springframework.web.reactive.DispatcherHandler&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;WebApplicationType.SERVLET classpath下存在javax.servlet.Servlet或者org.springframework.web.context.ConfigurableWebApplicationContext&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WebApplicationType.NONE 不满足以上条件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;　　1.2.2、 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); &lt;/h3&gt;
&lt;p&gt;　　初始化classpath下 META-INF/spring.factories中已配置的ApplicationContextInitializer。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; getSpringFactoriesInstances(type, &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt;[]{});
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 通过指定的classloader 从META-INF/spring.factories获取指定的Spring的工厂实例
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; type
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parameterTypes
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt;&lt;span&gt; type,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                                                       Class&amp;lt;?&amp;gt;&lt;span&gt;[] parameterTypes, Object... args) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     ClassLoader classLoader =&lt;span&gt; Thread.currentThread().getContextClassLoader();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use names and ensure unique to protect against duplicates
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过指定的classLoader从 META-INF/spring.factories 的资源文件中，
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取 key 为 type.getName() 的 value&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     Set&amp;lt;String&amp;gt; names = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Spring工厂实例&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     List&amp;lt;T&amp;gt; instances =&lt;span&gt; createSpringFactoriesInstances(type, parameterTypes,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            classLoader, args, names);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对Spring工厂实例排序（org.springframework.core.annotation.Order注解指定的顺序）&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    AnnotationAwareOrderComparator.sort(instances);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instances;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　看看 &lt;span class=&quot;cnblogs_code&quot;&gt;getSpringFactoriesInstances&lt;/span&gt; 都干了什么，看源码，有一个方法很重要 &lt;span class=&quot;cnblogs_code&quot;&gt;loadFactoryNames()&lt;/span&gt; 这个方法很重要，这个方法是spring-core中提供的从META-INF/spring.factories中获取指定的类（key）的同一入口方法。&lt;/p&gt;
&lt;p&gt;在这里，获取的是key为 &lt;span class=&quot;cnblogs_code&quot;&gt;org.springframework.context.ApplicationContextInitializer&lt;/span&gt; 的类。&lt;/p&gt;
&lt;p&gt;　　debug看看都获取到了哪些&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190606214803226-673240352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　上面说了，是从classpath下 META-INF/spring.factories中获取，我们验证一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190606220223952-321766434.png&quot; alt=&quot;&quot; width=&quot;1340&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201906/1635748-20190606220205113-514166696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　发现在上图所示的两个工程中找到了debug中看到的6条结果。 &lt;span class=&quot;cnblogs_code&quot;&gt;ApplicationContextInitializer&lt;/span&gt; 是Spring框架的类, 这个类的主要目的就是在   &lt;span class=&quot;cnblogs_code&quot;&gt;ConfigurableApplicationContext&lt;/span&gt; 调用refresh()方法之前，回调这个类的initialize方法。通过  &lt;span class=&quot;cnblogs_code&quot;&gt;ConfigurableApplicationContext&lt;/span&gt; 的实例获取容器的环境Environment，从而实现对配置文件的修改完善等工作。&lt;/p&gt;
&lt;p&gt;　　关于怎么实现自定义的 &lt;span class=&quot;cnblogs_code&quot;&gt;ApplicationContextInitializer&lt;/span&gt; 请看我的另一篇专门介绍该类的&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/10987360.html&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;　　1.2.3、 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); &lt;/h3&gt;
&lt;p&gt;　　初始化classpath下 META-INF/spring.factories中已配置的 ApplicationListener。&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;ApplicationListener&lt;/span&gt; 的加载过程和上面的 &lt;span class=&quot;cnblogs_code&quot;&gt;ApplicationContextInitializer&lt;/span&gt; 类的加载过程是一样的。不多说了，至于 &lt;span class=&quot;cnblogs_code&quot;&gt;ApplicationListener&lt;/span&gt; 是spring的事件监听器，典型的观察者模式，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;ApplicationEvent&lt;/span&gt; 类和 &lt;span class=&quot;cnblogs_code&quot;&gt;ApplicationListener&lt;/span&gt; 接口，可以实现对spring容器全生命周期的监听，当然也可以自定义监听事件。为了梳理springboot的启动流程在这里先不说这个了。后面有时间的话再介绍。&lt;/p&gt;
&lt;p&gt; 　　关于ApplicationContextInitializer的详细介绍请看&amp;lt;&lt;a href=&quot;https://www.cnblogs.com/hello-shf/p/10987360.html&quot; target=&quot;_blank&quot;&gt;SpringBoot之ApplicationContextInitializer的理解和使用&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;　　关于 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringApplication&lt;/span&gt; 类的构造过程，到这里我们就梳理完了。纵观 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringApplication&lt;/span&gt; 类的实例化过程，我们可以看到，合理的利用该类，我们能在spring容器创建之前做一些预备工作，和定制化的需求。&lt;/p&gt;
&lt;p&gt;比如，自定义SpringBoot的Banner，比如自定义事件监听器，再比如在容器refresh之前通过自定义 &lt;span class=&quot;cnblogs_code&quot;&gt;ApplicationContextInitializer&lt;/span&gt; 修改配置一些配置或者获取指定的bean都是可以的。。。&lt;/p&gt;
&lt;p&gt;　　下一节开始分析SpringBoot容器的构建过程，也就是那个大家多少都看过的run();方法。&lt;/p&gt;

&lt;p&gt;　　原创不易，转载请注明出处。&lt;/p&gt;
&lt;p&gt;　　如有错误的地方还请留言指正。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 00:42:00 +0000</pubDate>
<dc:creator>超级小小黑</dc:creator>
<og:description>SpringBoot系列文章简介 SpringBoot源码阅读辅助篇： Spring IoC容器与应用上下文的设计与实现 SpringBoot启动流程源码分析： 笔者注释版Spring Fr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hello-shf/p/10976646.html</dc:identifier>
</item>
<item>
<title>Akka-CQRS（13）- SSL/TLS for gRPC and HTTPS：自签名证书产生和使用 - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/11075240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/11075240.html</guid>
<description>&lt;p&gt;&lt;span&gt;  到现在，我们已经完成了POS平台和前端的网络集成。不过，还是那句话：平台系统的网络安全是至关重要的。前一篇博客里我们尝试实现了gRPC ssl/tls网络连接，但测试时用的证书如何产生始终没有搞清楚。现在akka-http开发的ws同样面临HTTPS的设置和使用问题。所以，特别抽出这篇博文讨论一下数字证书的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在正式的生产环境里数字证书应该是由第三方公证机构CA签发的，我们需要向CA提出申请。数字证书的申请、签发和验证流程&lt;/span&gt;如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 服务⽅ S 向第三⽅方机构CA提交公钥、组织信息、个⼈信息(域名)等资料提出认证申请 (不需要提供私钥）

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) CA 通过各种手段验证申请者所提供信息的真实性，如组织是否存在、 企业是否合法，是否拥有域名的所有权等

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;) 如信息审核通过，CA 会向申请者签发认证文件-&lt;span&gt;证书。 证书包含以下信息:申请者公钥、申请者的组织信息和个⼈信息、签发机构 CA 信息、有效时间、证书序列号等信息的明⽂，同时包含一个签名的产⽣生算法:首先，使用散列函数计算出证书中公开明文信息的信息摘要，然后， 采用 CA 的私钥对信息摘要进⾏加密，这个密⽂就是签名了

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;) 客户端 C 向服务器 S 发出请求时，S 返回证书文件

&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) 客户端 C 读取证书中的相关的明⽂信息，采⽤相同的散列函数计算得到信息摘要， 然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法

&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;) 客户端 C 然后检验证书相关的域名信息、有效时间等信息

&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;) 客户端 C 应内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法

&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;) 内置 CA 对应的证书称为根证书，颁发者和使⽤者相同，用 CA ⾃⼰的私钥签名，即⾃签名证书(此证书中的公钥即为 CA 的公钥，可以使用这个公钥对证书的签名进行校验，⽆需另外⼀份证书)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;服务器端在通信中建立SSL加密渠道过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）客户端 C 发送请求到服务器端 S

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) 服务器端 S 返回证书和公开密钥到 C，公开密钥作为证书的一部分传送

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）客户端 C 检验证书和公开密钥的有效性，如果有效，则⽣成共享密钥并使⽤公开密钥加密发送到服务器端 S

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;) 服务器端 S 使⽤私有密钥解密数据，并用收到的共享密钥加密数据，发送到客户端 C 

&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) 客户端 C 使⽤用共享密钥解密数据

&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;) SSL 加密通信渠道建立 ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;应该说，需要在客户端进行认证的应用场景不多。这种情况需要在客户端存放数字证书。像支付宝和一些银行客户端一般都需要安装证书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，还是回到如何产生自签名证书示范吧。下面是一个标准的用openssl命令产生自签名证书流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在产生证书和密钥的过程中所有系统提问回答要一致。我们先假设密码统一为：123456&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、生成根证书私钥: rootCA.key：  openssl genrsa -des3 -out rootCA.key 2048 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、根证书申请 rootCA.csr：openssl req -new -key rootCA.key -out rootCA.csr&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、用申请rootCA.csr生成根证书 rootCA.crt：openssl x509 -req -days 365 -sha256 -extensions v3_ca -signkey rootCA.key -in rootCA.csr -out rootCA.crt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、pem根证书 rootCA.pem：openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.pem&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、创建⼀个v3.ext⽂件，目的是产生X509 v3证书，主要目的是指定subjectAltName选项：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  authorityKeyIdentifier=&lt;span&gt;keyid,issuer
  basicConstraints&lt;/span&gt;=&lt;span&gt;CA:FALSE
  keyUsage &lt;/span&gt;=&lt;span&gt; digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
  subjectAltName &lt;/span&gt;=&lt;span&gt; @alt_names
  [alt_names]
  DNS.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; =&lt;span&gt; localhost
  IP.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.189&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  
  IP.&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.0.189&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  IP.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;132.232.229.60&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  IP.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;118.24.165.225&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  IP.&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;129.28.108.238&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意subjectAltName，这些都是可以信任的域名或地址。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、构建证书密钥 server.key：openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、用根证书rootCA产生自签证书 server.crt：openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 500 -sha256 -extfile v3.ext&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面这个过程需要不断重复回答同样的问题，很烦。可以用配置文件来一次性产生：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先构建一个ssl.cnf文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  [req]
  prompt &lt;/span&gt;=&lt;span&gt; no
  default_bits &lt;/span&gt;= &lt;span&gt;4096&lt;/span&gt;&lt;span&gt;
  default_md &lt;/span&gt;=&lt;span&gt; sha256
  distinguished_name &lt;/span&gt;=&lt;span&gt; dn
  x509_extensions &lt;/span&gt;=&lt;span&gt; v3_req
  [dn]
  C&lt;/span&gt;=&lt;span&gt;CN
  ST&lt;/span&gt;=&lt;span&gt;GuangDong
  L&lt;/span&gt;=&lt;span&gt;ShenZhen
  O&lt;/span&gt;=&lt;span&gt;Bayakala
  OU&lt;/span&gt;=&lt;span&gt;POS
  CN&lt;/span&gt;=&lt;span&gt;www.bayakala.com
  emailAddress&lt;/span&gt;=&lt;span&gt;admin@localhost
  [v3_req]
  keyUsage&lt;/span&gt;=&lt;span&gt;keyEncipherment, dataEncipherment
  extendedKeyUsage&lt;/span&gt;=&lt;span&gt;serverAuth
  subjectAltName&lt;/span&gt;=&lt;span&gt;@alt_names
  [alt_names]
  DNS.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; =&lt;span&gt; localhost
  IP.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.189&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  
  IP.&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.0.189&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  IP.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;132.232.229.60&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  IP.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;118.24.165.225&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  IP.&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;129.28.108.238&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后：openssl req -new -newkey rsa:2048 -sha1 -days 3650 -nodes -x509 -keyout server.key -out server.crt -config ssl.cnf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个指令同时产生需要的server.crt,server.key。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除aubjectAltName外还要关注CN这个字段，它就是我们经常会遇到系统提问：你确定信任“域名”吗？中这个域名，也就是对外界开放的一个使用了数字证书的域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把crt,key抄写到main/resources目录下，然后在gRPC服务器配置证书：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;trait gRPCServer {
  
  val serverCrtFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(getClass.getClassLoader.getResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server.crt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).getPath)
  val serverKeyFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(getClass.getClassLoader.getResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server.key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).getPath)

  def runServer(service: ServerServiceDefinition): Unit &lt;/span&gt;=&lt;span&gt; {
    val server &lt;/span&gt;=&lt;span&gt; NettyServerBuilder
      .forPort(&lt;/span&gt;&lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)
      .addService(service)
      .useTransportSecurity(serverCrtFile,serverKeyFile)
      .build
      .start
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; make sure our server is stopped when jvm is shut down&lt;/span&gt;
    Runtime.getRuntime.addShutdownHook(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def run(): Unit =&lt;span&gt; {
        server.shutdown()
        server.awaitTermination()
      }
    })
  }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;启动gRPC服务，运作正常。在看看客户端代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    val clientCrtFile = &lt;span&gt;new&lt;/span&gt; File(getClass.getClassLoader.getResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server.crt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).getPath)
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者   val clientCrtFile = new File(getClass.getClassLoader.getResource(&quot;rootCA.pem&quot;).getPath)

&lt;/span&gt;&lt;span&gt;//这样也行 &lt;/span&gt;&lt;span&gt;val clientCrtFile: InputStream = getClass.getClassLoader.getResourceAsStream(&quot;rootCA.pem&quot;)&lt;/span&gt;
&lt;span&gt;
    val sslContextBuilder &lt;/span&gt;=&lt;span&gt; GrpcSslContexts.forClient().trustManager(clientCrtFile)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;build connection channel&lt;/span&gt;
    val channel =&lt;span&gt; NettyChannelBuilder
      .forAddress(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.189&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)
      .negotiationType(NegotiationType.TLS)
      .sslContext(sslContextBuilder.build())
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      .overrideAuthority(&quot;192.168.1.3&quot;)&lt;/span&gt;
      .build()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试连接，gRPC SSL/TLS成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在开始了解一下https证书的配置使用方法吧。看了一下akka-http关于server端HTTPS设置的例子，证书是嵌在HttpsConnectionContext类型里面的。还有就是akka-http使用的https证书格式只支持pkcs12，所以需要把上面用openssl产生的自签名证书server.crt转成server.p12。这个转换又需要先产生证书链certificate-chain chain.pem：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）产生certificate-chain:  cat server.crt rootCA.crt &amp;gt; chain.pem&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) server.crt转换成server.p12: openssl pkcs12 -export -name servercrt -in chain.pem -inkey server.key -out server.p12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https server 测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#imports&lt;/span&gt;
&lt;span&gt;import java.io.InputStream
import java.security.{ SecureRandom, KeyStore }
import javax.net.ssl.{ SSLContext, TrustManagerFactory, KeyManagerFactory }

import akka.actor.ActorSystem
import akka.http.scaladsl.server.{ Route, Directives }
import akka.http.scaladsl.{ ConnectionContext, HttpsConnectionContext, Http }
import akka.stream.ActorMaterializer
import akka.http.scaladsl.Http
import akka.http.scaladsl.server.Directives._

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#imports&lt;/span&gt;


&lt;span&gt;object&lt;/span&gt;&lt;span&gt; HttpsDemo extends App {

  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpSys = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;httpSystem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpMat =&lt;span&gt; ActorMaterializer()
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpEC =&lt;span&gt; httpSys.dispatcher
  

    val password: Array[Char] &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.toCharArray &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do not store passwords in code, read them from somewhere safe!&lt;/span&gt;
&lt;span&gt;
    val ks: KeyStore &lt;/span&gt;= KeyStore.getInstance(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PKCS12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    val keystore: InputStream &lt;/span&gt;= getClass.getClassLoader.getResourceAsStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server.p12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    ks.load(keystore, password)

    val keyManagerFactory: KeyManagerFactory &lt;/span&gt;= KeyManagerFactory.getInstance(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SunX509&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    keyManagerFactory.init(ks, password)

    val tmf: TrustManagerFactory &lt;/span&gt;= TrustManagerFactory.getInstance(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SunX509&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    tmf.init(ks)

    val sslContext: SSLContext &lt;/span&gt;= SSLContext.getInstance(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TLS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    sslContext.init(keyManagerFactory.getKeyManagers, tmf.getTrustManagers, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecureRandom)
    val https: HttpsConnectionContext &lt;/span&gt;=&lt;span&gt; ConnectionContext.https(sslContext)


  val route &lt;/span&gt;= &lt;span&gt;get&lt;/span&gt; { complete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello world!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) }

  val (port, host) &lt;/span&gt;= (&lt;span&gt;50081&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.189&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  val bindingFuture &lt;/span&gt;= Http().bindAndHandle(route,host,port,connectionContext =&lt;span&gt; https)

  println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Https Server running at $host $port. Press any key to exit ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  scala.io.StdIn.readLine()


  bindingFuture.flatMap(_.unbind())
    .onComplete(_ &lt;/span&gt;=&amp;gt;&lt;span&gt; httpSys.terminate())

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;language-html hljs&quot;&gt;用safari连接https://192.168.11.189:50081/, 弹出窗口一堆废话后还是成功连接上了。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 24 Jun 2019 00:42:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<og:description>到现在，我们已经完成了POS平台和前端的网络集成。不过，还是那句话：平台系统的网络安全是至关重要的。前一篇博客里我们尝试实现了gRPC ssl/tls网络连接，但测试时用的证书如何产生始终没有搞清楚。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tiger-xc/p/11075240.html</dc:identifier>
</item>
<item>
<title>Linux下Jenkins与GitHub自动构建NetCore与部署 - HANS许</title>
<link>http://www.cnblogs.com/xuhuale/p/11062293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuhuale/p/11062293.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;今天我们来谈谈NetCore在Linux底下的持续集成与部署。NetCore我就不多介绍了，持续集成用的是Jenkins，源代码管理器用的是GitHub。我们就跟着博文往下走吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;



&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1.Linux环境&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在进行自动构建之前，我们需要一个可以运行的Linux环境，并保证环境安装了&lt;code&gt;NetCoreSDK&lt;/code&gt;,&lt;code&gt;Git&lt;/code&gt;,&lt;code&gt;Jenkins&lt;/code&gt;等环境，那在这边就不多说环境的安装，提供相对应的安装教程，大家按照安装就可以，不过对&lt;code&gt;Jenkins&lt;/code&gt;的安装，我会多啰嗦一句。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;&lt;strong&gt;&lt;span class=&quot;mark&quot;&gt;啰嗦的那一句&lt;/span&gt;&lt;/strong&gt;：&lt;br/&gt;我在安装&lt;code&gt;Jenkins&lt;/code&gt;成功的时候进入网页，网页会一直保持在下面图这个状态，没办法进入到开始页面，那解决办法是：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;Jenkins等待&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g480y40ly1j21hc0r7aal.jpg&quot; alt=&quot;Jenkins等待&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g480y40ly1j21hc0r7aal.jpg&quot;/&gt;&lt;p&gt;Jenkins等待&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;进入到&lt;code&gt;Jenkins&lt;/code&gt;的工作目录&lt;code&gt;/var/lib/jenkins/&lt;/code&gt;修改&lt;code&gt;hudson.model.UpdateCenter.xml&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;http://updates.jenkins-ci.org/update-center.json&lt;/code&gt;修改为&lt;code&gt;http://mirror.xmission.com/jenkins/updates/update-center.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启下&lt;code&gt;Jenkins&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2.Jenkins自动构建&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;

&lt;h5 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h5&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;定时构建&lt;/span&gt;&lt;/h5&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;创建Jenkins项目&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;创建Jenkins项目&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48oug8bdsj216d0l8abp.jpg&quot; alt=&quot;创建Jenkins项目&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48oug8bdsj216d0l8abp.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;配置好自定义工作目录&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;自定义工作目录&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48owilyrwj21680domxt.jpg&quot; alt=&quot;自定义工作目录&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48owilyrwj21680domxt.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;填写源代码路径&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;填写源代码路径&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48oy3efj8j21500izgmd.jpg&quot; alt=&quot;填写源代码路径&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48oy3efj8j21500izgmd.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;配置定时任务&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;配置定时任务&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48oyssyb0j21510lbt9w.jpg&quot; alt=&quot;配置定时任务&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48oyssyb0j21510lbt9w.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;*&lt;/th&gt;
&lt;th&gt;*&lt;/th&gt;
&lt;th&gt;*&lt;/th&gt;
&lt;th&gt;*&lt;/th&gt;
&lt;th&gt;*&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;含义&lt;/td&gt;
&lt;td&gt;分钟&lt;/td&gt;
&lt;td&gt;小时&lt;/td&gt;
&lt;td&gt;日期&lt;/td&gt;
&lt;td&gt;月份&lt;/td&gt;
&lt;td&gt;星期&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;取值范围&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;td&gt;0-23&lt;/td&gt;
&lt;td&gt;1-31&lt;/td&gt;
&lt;td&gt;1-12&lt;/td&gt;
&lt;td&gt;0-7&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;示例&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;每隔15分钟执行一次&lt;/td&gt;
&lt;td&gt;H/15&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;每隔2个小时执行一次&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;H/2&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;每隔3天执行一次&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;H/3&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;每隔3天执行一次(每月的1-15号)&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;1-15/3&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;每周1,3,5执行一次&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;1,3,5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;规则&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;指定时间范围&lt;/td&gt;
&lt;td&gt;a-b&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;指定时间间隔&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;指定变量取值&lt;/td&gt;
&lt;td&gt;a,b,c&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;配置构建命令&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;配置构建命令&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48p0pchmzj212k08yaa2.jpg&quot; alt=&quot;配置构建命令&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48p0pchmzj212k08yaa2.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot;&gt;
&lt;div class=&quot;xiaoshujiang_pre&quot;&gt;
&lt;div class=&quot;nohighlight hljs code_linenums xiaoshujiang_code&quot;&gt;
&lt;ol class=&quot;ol_linenums&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;li_linenum li_list_style&quot;&gt;dotnet restore&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;dotnet build&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;dotnet publish&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;查看构建，并运行NetCore&lt;br/&gt;&lt;span class=&quot;mark&quot;&gt;注意:&lt;/span&gt;&lt;br/&gt;因为你建立的自定义工作目录，对于&quot;jenkins&quot;没有读写权限，所以可能就会导致构建失败，执行下面命令，给Jenkins赋予读写权限。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot;&gt;
&lt;div class=&quot;xiaoshujiang_pre&quot;&gt;
&lt;div class=&quot;nohighlight hljs code_linenums xiaoshujiang_code&quot;&gt;
&lt;ol class=&quot;ol_linenums&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;li_linenum li_list_style&quot;&gt;chown jenkins /ftpfile -R &lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;chmod 777 /ftpfile -R&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;查看构建，并运行NetCore1&quot; src=&quot;https://ws1.sinaimg.cn/mw690/e7485bc3ly1g4bhtk5pnmj20pr0p7q41.jpg&quot; alt=&quot;查看构建，并运行NetCore1&quot; name=&quot;&quot; data-src=&quot;https://ws1.sinaimg.cn/mw690/e7485bc3ly1g4bhtk5pnmj20pr0p7q41.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;查看构建，并运行NetCore2&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48p209noij20qr0fxwf0.jpg&quot; alt=&quot;查看构建，并运行NetCore2&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48p209noij20qr0fxwf0.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;查看构建，并运行NetCore4&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48p209noij20qr0fxwf0.jpg&quot; alt=&quot;查看构建，并运行NetCore4&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g48p209noij20qr0fxwf0.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;

&lt;h5 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h5&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;触发构建&lt;/span&gt;&lt;/h5&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;配置GitHub&lt;br/&gt;针对我们的项目，我们要在自己的项目内添加&lt;code&gt;webhook&lt;/code&gt;，并配置好&lt;code&gt;webhook&lt;/code&gt;的地址。&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_6&quot;&gt;在项目设置中找到&lt;code&gt;webhook&lt;/code&gt;&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;webhook位置&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g493i06ojdj20wu0hf0th.jpg&quot; alt=&quot;webhook位置&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g493i06ojdj20wu0hf0th.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_6&quot;&gt;设置Jenkins的hook地址到刚才添加的&lt;code&gt;webhook&lt;/code&gt;中，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_7&quot;&gt;Jenkins的hook地址为：&lt;code&gt;http://你的地址（端口）/github-webhook&lt;/code&gt;，&lt;strong&gt;当然这个地址应该是外网可以访问的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_6&quot;&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;设置hook地址中&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g493m1ogf0j20vk0m9myh.jpg&quot; alt=&quot;设置hook地址中&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g493m1ogf0j20vk0m9myh.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;Personal access tokens&lt;br/&gt;对于任何第三方访问GitHub的项目，是需要授权的，Jenkins也是一样的，所以我们需要先获取一个&lt;code&gt;accessToken&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进入&lt;code&gt;Settings&lt;/code&gt;页面，找到左边列表的&lt;code&gt;Developer settings&lt;/code&gt;,点击进入，可以看到如下：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;Personal access tokens页面&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g493q4xl1cj20z20a00t4.jpg&quot; alt=&quot;Personal access tokens页面&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g493q4xl1cj20z20a00t4.jpg&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;点击生成，然后勾选&lt;code&gt;,&lt;/code&gt;，保存即可，就可以获得token，顺便说下，token要记下来，不然关闭页面就看不到了。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;生成token&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g493srk6smj20vc0nfabf.jpg&quot; alt=&quot;生成token&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g493srk6smj20vc0nfabf.jpg&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;Jenkins配置&lt;br/&gt;上面的配置完成之后，我们需要返回Jenkins，进行再次设置。为Jenkins添加GitHub服务器。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加GitHub服务器&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;添加GitHub服务器&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494a5x3ouj21h007pglp.jpg&quot; alt=&quot;添加GitHub服务器&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494a5x3ouj21h007pglp.jpg&quot;/&gt;&lt;/span&gt;&lt;br/&gt;2.添加GitHub的凭据，也就我们刚才拿到得accessToken&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;添加凭据1&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494bdv6gzj213i0hzq3g.jpg&quot; alt=&quot;添加凭据1&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494bdv6gzj213i0hzq3g.jpg&quot;/&gt;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;添加凭据2&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494bzjk0cj21660elq3t.jpg&quot; alt=&quot;添加凭据2&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494bzjk0cj21660elq3t.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;Jenkins任务配置&lt;br/&gt;因为我们已经将触发构建的前置步骤都做完了，那接着我们就要去修改之前的定时构建的配置了&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;切换成触发构建&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;切换成触发构建&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494fo3gfaj216o07qt8z.jpg&quot; alt=&quot;切换成触发构建&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494fo3gfaj216o07qt8z.jpg&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;使用密文模式，并添加绑定，选择刚才添加的凭据&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;使用密文模式，并添加绑定，选择刚才添加的凭据&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494ielhk2j216b0g83z5.jpg&quot; alt=&quot;使用密文模式，并添加绑定，选择刚才添加的凭据&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494ielhk2j216b0g83z5.jpg&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;修改代码，上传GitHub&lt;br/&gt;终于我们将之前的定时构建改成了触发构建，也就是我们每次Push代码都会触发构建，接下来我们试下。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提交代码&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;提交代码&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494ljnm88j20ii084glm.jpg&quot; alt=&quot;提交代码&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494ljnm88j20ii084glm.jpg&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;查看Jenkins&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;查看Jenkins&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494nqkfyzj20vj0eawfl.jpg&quot; alt=&quot;查看Jenkins&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494nqkfyzj20vj0eawfl.jpg&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;3.NetCore部署&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;终于的终于，我们把构建这个步骤做好了，那么接下来当然就是要部署我们网站咯。&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;运行NetCore&lt;br/&gt;运行NetCore最简单了，我们只需要在发布后的目录运行&lt;code&gt;dotnet ***.dll&lt;/code&gt;就可以了，当然，前提，你要装CoreSDK。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;运行NetCore&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494w0bmsij20qr0fxwf0.jpg&quot; alt=&quot;运行NetCore&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g494w0bmsij20qr0fxwf0.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;nginx托管&lt;br/&gt;虽然说上面那样已经运行起来，但是由于我们的环境在腾旭云上，要访问可以用nginx进行方向代理下，下面就简单贴下配置就可以了。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot;&gt;
&lt;div class=&quot;xiaoshujiang_pre&quot;&gt;
&lt;div class=&quot;language-javascript hljs code_linenums xiaoshujiang_code&quot;&gt;
&lt;ol class=&quot;ol_linenums&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;li_linenum li_list_style&quot;&gt;server {&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;listen &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;location / {&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;proxy_pass http:&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;proxy_http_version &lt;span class=&quot;hljs-number&quot;&gt;1.1&lt;/span&gt;;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;proxy_set_header Upgrade $http_upgrade;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;proxy_set_header Connection keep-alive;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;proxy_set_header Host $host;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;proxy_cache_bypass $http_upgrade;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;}&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;li class=&quot;li_linenum li_list_style&quot;&gt;}&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;hr class=&quot;code_line_break_hack&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;7.5&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;守护进程&lt;br/&gt;我们已经知道要运行Core，需要使用命令在控制台运行，但是一旦退出了，Core自然就退出了，所以我们在Linux底下需要一个类似IIS的，来托管我们运行Core的进程，守护进程，让其在后台运行，自动重启等等功能，这个就是supervisor&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_3&quot;&gt;supervisors是C/S架构的进程控制系统，可使用户在类UNIX系统中监控、管理进程。常用于管理与某个用户或项目相关的进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;安装教程可以参考开始表格supervisor的链接，同样怎么对于怎么对Core进行守护进程，文章内也有讲，一步一步按照教程来就可以了。不过我这边还是会讲下我在使用supervisor中遇到的坑。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;一开始，我百度了挺多的，发现百度中的文章，对于supervisor的日志文件，很多都说在&lt;code&gt;/etc/log/supervisor/supervisord.log&lt;/code&gt;这个文件内，但其实我去找的时候，发现并没有，查看配置文档，发现默认是在&lt;code&gt;tmp&lt;/code&gt;中，我不知道是centeros 的版本问题，还是supervisor版本问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_4&quot;&gt;还有一个就是，在根据教程走完，配置后，要进行启动时，可能会出现&lt;code&gt;Unlinking stale socket /tmp/supervisor.sock&lt;/code&gt; 这个错误，我们只需要解锁下就可以了&lt;code&gt;unlink /tmp/supervisor.sock&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g49y48i52dj21h20dmt92.jpg&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g49y48i52dj21h20dmt92.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;4.总结一下&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;该篇文章简单介绍了下&lt;code&gt;Linux下Jenkins与GitHub自动构建NetCore与部署&lt;/code&gt;，很多细点我可能没讲出来，我把大大的教程贴出来，按照教程走起，就可以了，这也是我实践过了的，肯定可以用的，非常感谢大大们，然后呢，我也想抛砖引玉下，在我Jenkins构建时有两个问题，不知道谁可以帮我解答下。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;比如我们的解决方案文件&lt;code&gt;.sln&lt;/code&gt;并没有在git项目的根目录下，我们要指定需要构建的解决方案呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;还有一个就是，在命令&lt;code&gt;dotnet publish&lt;/code&gt;我们怎么指定发布到另一个文件夹内呢，我知道有个参数&lt;code&gt;-o|--output &amp;lt;OUTPUT_DIRECTORY&amp;gt;&lt;/code&gt;,我试了下，发现不行 &lt;code&gt;dotnet publish -o /ftpfile/netCore/netCoreJenkins/JenkinsNetCore&lt;/code&gt;,会有以下的错误。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g49xwupzo3j217d03g74a.jpg&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/mw690/e7485bc3ly1g49xwupzo3j217d03g74a.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;最后的最后，我的下一篇文章是《&lt;span class=&quot;mark&quot;&gt;&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.cnblogs.com/xuhuale/p/11072824.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Linux下Jenkins与GitHub自动构建Node项目&lt;/strong&gt;(Vue)&lt;/a&gt;&lt;/span&gt;》，期待0.5下吧。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 00:38:00 +0000</pubDate>
<dc:creator>HANS许</dc:creator>
<og:description>今天我们来谈谈NetCore在Linux底下的持续集成与部署。NetCore我就不多介绍了，持续集成用的是Jenkins，源代码管理器用的是GitHub。我们就跟着博文往下走吧。 1.Linux环境</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuhuale/p/11062293.html</dc:identifier>
</item>
<item>
<title>python-kafka源码解析之socketpair - killianxu</title>
<link>http://www.cnblogs.com/killianxu/p/11075192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/killianxu/p/11075192.html</guid>
<description>&lt;p&gt;socket基本操作包括:&lt;br/&gt;socket()函数创建socket文件描述符,唯一标识一个socket。&lt;br/&gt;bind()函数,将ip:port和socket绑定&lt;br/&gt;listen()函数来监听这个socket,假如客户端connect这个套接字,服务器端就回接收到这个连接请求。&lt;br/&gt;connect()函数用于和服务端建立连接&lt;br/&gt;accept()函数,服务端经过bind和listen,并且客户端connect后,服务端用accept接收这个建立连接的请求。&lt;br/&gt;read()、write()等函数,用于建立连接后的信息交互。&lt;br/&gt;详情参考:&lt;a href=&quot;https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html&quot; target=&quot;_blank&quot;&gt;Linux Socket编程（不限Linux）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;python-kafak中vendor包下socketpair源码如下,返回在127.0.0.1本地连接的两端socket,ssock表示服务端socket,csock表示客户端socket。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pylint: skip-file&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; vendored from https://github.com/mhils/backports.socketpair&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; absolute_import
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; errno
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; _LOCALHOST    = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; _LOCALHOST_V6 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;::1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;socketpair返回本地建立连接的两端socket&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; hasattr(socket, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socketpair&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; socketpair(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=&lt;span&gt;0):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; family == socket.AF_INET: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;ipv4&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             host =&lt;span&gt; _LOCALHOST
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; family == socket.AF_INET6: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;ipv6&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             host =&lt;span&gt; _LOCALHOST_V6
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Only AF_INET and AF_INET6 socket address families &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                              &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;are supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; type !=&lt;span&gt; socket.SOCK_STREAM:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Only SOCK_STREAM socket type is supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; proto !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Only protocol zero is supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We create a connected TCP socket. Note the trick with&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; setblocking(False) that prevents us from having to create a thread.&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         lsock =&lt;span&gt; socket.socket(family, type, proto)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             lsock.bind((host, 0)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;端口0说明由系统动态创建监听端口&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             lsock.listen(min(socket.SOMAXCONN, 128))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;SOMAXCONN定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数,默认值为128，https://jaminzhang.github.io/linux/understand-Linux-backlog-and-somaxconn-kernel-arguments/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; On IPv6, ignore flow_info and scope_id&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             addr, port = lsock.getsockname()[:2]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回这个socket的地址&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             csock =&lt;span&gt; socket.socket(family, type, proto)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 csock.setblocking(False)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置socket为非阻塞模式,非阻塞模式下recv没有收到数据或send数据没有立即发送出去,则会抛出异常，等价于s.settimeout(0.0)。&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 阻塞模式,会等待直到有数据或数据发送出去,等价于s.settimeout(None)&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3&lt;span&gt;, 0):
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                        csock.connect((addr, port))
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; (BlockingIOError, InterruptedError):
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         csock.connect((addr, port))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#连接本地创建的lsock&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; socket.error as e:
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; e.errno !=&lt;span&gt; errno.WSAEWOULDBLOCK:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                             &lt;span&gt;raise&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;                 csock.setblocking(True)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重新设置socket为阻塞模式&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;                 ssock, _ = lsock.accept()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务端socket接收连接返回和特定客户端建立连接后的新socket ssock&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                csock.close()
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;raise&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             lsock.close()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭监听套接字lsock&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (ssock, csock)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回本地互相连接的两端socket&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     socket.socketpair = socketpair
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   其中23行参数为(ip:port),端口0表示端口由操作系统自动选取监听端口;33行参数为backlog，表示服务端连接队列的大小。服务端分为两个队列,一个存放 SYN 的队列（半连接队列）、一个存放已经完成连接的队列（全连接队列）。backlog不能超过内核参数somaxconn,高并发情况下加大连接队列长度需调内核参数somaxconn&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 00:37:00 +0000</pubDate>
<dc:creator>killianxu</dc:creator>
<og:description>本文介绍简单介绍socket的常用函数,并以python-kafka中的源码socketpair为例，来讲解python socket的运用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/killianxu/p/11075192.html</dc:identifier>
</item>
<item>
<title>膨胀、骄傲，程序员转项目经理的原罪 - 妖生</title>
<link>http://www.cnblogs.com/yaoshen/p/11075231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaoshen/p/11075231.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;作者简介：妖生。 坐标合肥，一个普通程序员。十年职业生涯，8年编程。经历了许多事，也有点想法，现在将它们变成文字，书于纸上。如果能帮助到你，那将不胜荣幸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;膨胀、骄傲，程序员转项目经理的原罪&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;一前言谦卑与狂妄&quot;&gt;一、前言：谦卑与狂妄&lt;/h3&gt;
&lt;p&gt;突然就想到这么个主题，回想我在2016下、2017上的时候，确实好像有那么一段时间，有点膨胀，感觉自己无所不能，又太过骄傲，表面谦虚、内心傲气，似乎谁都不放在眼里。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;做管理的没我技术好，做技术的没我会管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在想想，真是可笑啊。&lt;/p&gt;
&lt;p&gt;由己及彼，会不会也有不少做了三五年程序员，做了小组长，突然成为管理者，有了团队里的一些话语权，然后膨胀的呢？&lt;/p&gt;
&lt;p&gt;那么我这样去总结下，能不能给一些正在经历这个阶段的程序员们，甚至非程序员们的小伙伴们，予以一点点启发呢？&lt;/p&gt;
&lt;p&gt;嗯，晚上想就这个话题写篇长文，回忆下我当年的情景，复盘当年，说一说我一些错误的做法，和之后怎样警醒与走出来的。&lt;/p&gt;
&lt;h3 id=&quot;二尊重远与近&quot;&gt;二、尊重：远与近&lt;/h3&gt;
&lt;h4 id=&quot;近之则不逊&quot;&gt;2.1 近之则不逊&lt;/h4&gt;
&lt;p&gt;2015年，金三大潮席卷而来，全国的税务系统都要升级，我也有幸参与了这样的历史性进程。&lt;/p&gt;
&lt;p&gt;我代表安徽的大集中征管税务系统承建商，与金三征管中标商中软公司进行系统对接。赶赴深圳南海，在国家税务总局的信息中心进行征管数据的迁移工作。&lt;/p&gt;
&lt;p&gt;在深圳南海的时候，我带领的小组负责为数据迁移工作作数据校验、数据确认、迁移脚本编写等工作。&lt;/p&gt;
&lt;p&gt;在这样的时刻，安徽基地突然打电话过来，也是当时的项目经理——老赵，打电话对我说，要我负责金三本地保留系统的改造工作。&lt;/p&gt;
&lt;p&gt;我当时一头雾水，满心不爽，不知道为什么这样的工作就落到了我的头上。并且人在深圳，有心无力。所以说话有点冲，说我不知道怎么做，直接就怼了几句。&lt;/p&gt;
&lt;p&gt;老赵忽然说了一句：“如果是XX你会这样跟他说吗？”XX是我们的项目总监。&lt;/p&gt;
&lt;p&gt;我脑子里突然有一道电闪了一下。&lt;/p&gt;
&lt;p&gt;是啊，如果是XX这样跟我说，给我安排这样的任务。我会这样去怼吗？&lt;br/&gt;我是不是就默默接受了？&lt;/p&gt;
&lt;p&gt;我突然想起来，2014年，我与老赵坐在一块，因为某件事，我引用了孔子的一句话：“女子与小人难养也。远之则怨，近之则不逊”。&lt;/p&gt;
&lt;p&gt;老赵赞赏地说，很有道理。&lt;/p&gt;
&lt;p&gt;可是这样的话，我为何说了，却不记得，做不到，无法知行合一呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我对老赵，就是近之则不逊了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我沉默了大概十秒钟，随后对他说：“你放心，我肯定完成任务。没有什么完不成的。”&lt;br/&gt;在转变态度与思路后，我对怎么解决金三本地保留的改造有了切实可行的思路与方法。&lt;/p&gt;
&lt;p&gt;我在电话中将我的想法与老赵沟通后，老赵对我表示了赞赏，“就是要有这种舍我其谁的气势。除了你，没人能搞定。”&lt;/p&gt;
&lt;p&gt;这通电话很长，也在我以后的职业生涯中，对我做事做人的方法进行了一次很大的改造。&lt;/p&gt;
&lt;p&gt;但是在这个故事里我却还是有一点没学到，也是我最近在反思的一个问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我为什么对于别人，总是吝啬于赞赏？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老赵在与我的相处中，一直对我进行鼓励、赞赏，让我有了一次次面对问题的自信，得到了极大的成长。&lt;/p&gt;
&lt;p&gt;遇到这样一个半师半友的领导，何其之幸也。&lt;/p&gt;
&lt;p&gt;这段往事我总结了两个点：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一是与上级相处时可以开玩笑、插科打诨，但是在工作上应该把上级当做上级，给予应有的尊重。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;二是在与下级相处时，应该不吝啬表扬，尤其在现在85后、90后当家的年代，表扬会比批评更能激发他们的工作激情，赋予他们超出当前能力的创造力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;远之则怨&quot;&gt;2.2 远之则怨&lt;/h4&gt;
&lt;p&gt;在2016年的时候，老赵罹患重疾，在长时间病情反复、无法工作的情况下，拿了公司的补偿金，主动离职。&lt;/p&gt;
&lt;p&gt;谁来接替这个项目经理的位置？&lt;/p&gt;
&lt;p&gt;当时其实是有三个人选，一个是运维经理Y，一个是技术经理H，还有一个就是我这个开发经理。&lt;/p&gt;
&lt;p&gt;在H主动退出的情况下，我与Y开始竞争这个职位。&lt;/p&gt;
&lt;p&gt;怎么说呢？我其实一开始并不care这个项目经理的职位。我只想安安静静地做开发，不愿意去做什么项目管理。因为有权利的同时，意味着麻烦。&lt;/p&gt;
&lt;p&gt;如果是技术经理H，也就是我在电子税务局的老搭档坐了项目经理这个职位，我是不想去竞争的。&lt;/p&gt;
&lt;p&gt;但是现在是他退出，我俩竞争，而令我万分不爽的是，在一开始，项目总监X便带了浓烈的主观倾向，他是属意运维经理来坐这个职位的，这样的倾向我后来的判断是八二。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我直接去找了总监X，说出了这样的话：“他何德何能，凭什么做项目经理，拿什么来领导我？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我后来才知道，就在这个竞争的过程中，X找了项目组运维、开发的骨干同事们，一一咨询了对于项目经理这个职位人选的意见。&lt;/p&gt;
&lt;p&gt;或许结果令他大失所望，90%的人都对他属意的人选投了反对票。&lt;/p&gt;
&lt;p&gt;真的是我牛逼？我人缘好吗？我当时真的是这么觉得。&lt;/p&gt;
&lt;p&gt;后来细想，恐怕并不是如此。开发投我可以理解，为什么运维的同事也投我呢？&lt;/p&gt;
&lt;p&gt;我想，是因为这位Y先生不得手下人心吧。在对待客户、对待上级方面，这位运维负责人把自己的工作干得很出色，客户关系维系的很好。&lt;/p&gt;
&lt;p&gt;但是在对待下属方面，我则听到了好几次关于Y的抱怨。&lt;/p&gt;
&lt;p&gt;一位同事说某个工作是他来解决的，处理的很出色，结果Y却跟客户说是Y来解决的，让他心生怨怼。&lt;/p&gt;
&lt;p&gt;另一位同事说他在处理某个线上的紧急问题，一时没解决，结果总监X将Y调了过来，看着他处理，后来事情解决了，而Y在这个过程中什么都没干。导致这位同事觉得 总监X 是不是太信任 Y 了，反而对 Y 敬谢不敏。&lt;/p&gt;
&lt;p&gt;这两位同事在16年已经成长为项目组的骨干员工，也在这次竞争事件中投了 Y 的反对票。&lt;/p&gt;
&lt;p&gt;有时候，其实不是你成功，而是对手打败了自己。用现在流行的话来说，叫 同行衬托 吧。&lt;/p&gt;
&lt;p&gt;我举这两个例子，是觉得这里面有两个点需要去反思和总结的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一是远之则怨，在对待下属时如果为了保持上级的威严，而拉开了距离，则导致互相不了解，很容易产生芥蒂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;二是揽功诿过是领导者的大忌，其实团队做好了事情就是你的功劳，至于是不是你个人解决的有什么关系呢？作为领导者，个人成功，团队失败，其实都是失败者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里面还有一点是我想提出的，就是在职场工作中，如果竞争的机会，要敢于竞争，竞争说明了你的决心。&lt;/p&gt;
&lt;p&gt;我当时找 总监X 的谈话中，还说了这样一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“我觉得如果我来选，我选自己做项目经理。”&lt;br/&gt;“相比他，我肯定会做的更好。”&lt;br/&gt;“如果他来带这个团队，那不用多久，这个团队就要人心散了。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是不是很狂妄？然而真的就是我内心的想法。你要么空降一个项目经理过来，要么就选我。&lt;/p&gt;
&lt;p&gt;有时候在与上级的沟通中，没必要遮掩自己内心的想法。当然，如果你的上级只爱听阿谀谄媚的话，便保留意见，默默前行吧。&lt;/p&gt;
&lt;p&gt;幸而，我觉得我一路遇到的都是贵人。从第一家公司的保总，到神码的斌哥、蔡总、曹工、老赵、总监X，我觉得无比幸运，总是能遇到眼界比你高、愿意提点你的老板、导师、同事与朋友。&lt;/p&gt;
&lt;p&gt;那么回过头来，我对 总监X 说的这番话到底有多大的影响呢？我相信在八二的倾向比重中，得到了两分吧。再加上同事们的支持，最终是我胜出，成了【代】项目经理。&lt;/p&gt;
&lt;p&gt;至于为什么是【代】，呵呵，那便是另外一个故事了。&lt;/p&gt;
&lt;h3 id=&quot;三原罪膨胀与骄傲&quot;&gt;三、原罪：膨胀与骄傲&lt;/h3&gt;
&lt;h4 id=&quot;骄傲无所不能与一天十会&quot;&gt;3.1 骄傲：无所不能与一天十会&lt;/h4&gt;
&lt;p&gt;在成为【代】项目经理后，我开始了马不停蹄的开会生涯。最多的时候，一天十会，感觉什么都要我来拍板。&lt;/p&gt;
&lt;p&gt;2017年，政府开始提出“互联网+”的概念，这便开始了我们开发项目爆发的一年。&lt;/p&gt;
&lt;p&gt;智能办公、大数据、移动APP、数据质量、统一门户、短信平台、外部交换等等。&lt;/p&gt;
&lt;p&gt;从需求到架构，全都是我来主导，业务人才的极度缺乏，导致我陷入了局方的会议大海。&lt;/p&gt;
&lt;p&gt;后来有一位从别的区调过来帮助我的资深业务专家说了一句：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从技术人升上来的管理者可能都有一个毛病，凡事都要亲力亲为。何不放手让下面的人干干呢？说不定干出的效果会超过你想象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是当时的我，并没有把这话听进去。&lt;/p&gt;
&lt;p&gt;在前几天看到雷军的一篇文章，说为什么小米手机干不过华为，甚至远逊于OV呢？一是待遇问题，导致招不到行业最顶尖的人才；二是雷军凡事亲力亲为，哪里的业务不行了，就自己出山撸起袖子干。&lt;/p&gt;
&lt;p&gt;很有感触，何其相似。雷军也是干技术出身的啊。同样做技术出身，还是马化腾够潇洒。&lt;/p&gt;
&lt;p&gt;当然，我自然是比不了大佬的。可是反思下，我真的是这么无所不能吗？&lt;/p&gt;
&lt;p&gt;或许只是我所在的位置，导致我接收的信息足够多，而无法被下面的同事所取代？&lt;/p&gt;
&lt;p&gt;或许并非我的能力太强，只是我的眼界、层次还不够，还没有做好一个管理者的转变。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个好的管理者，应该是大音希声、大象无形，让团队在没有你的情况下，也能按照预定计划稳步前行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;膨胀程序员的原罪&quot;&gt;3.2 膨胀：程序员的原罪&lt;/h4&gt;
&lt;p&gt;在无所不能的这一段时间中，因为开发项目的过多，还有大数据这样新兴技术的项目，从公司层面协调来了一位技术总监，也是我们安徽项目组以前出去的一位同事。暂且叫他 L 吧。&lt;/p&gt;
&lt;p&gt;因为以前共在一个项目组，也算是半熟不生。而我并没有充分意识到怎样去尊敬这样一位技术达人、前辈。&lt;/p&gt;
&lt;p&gt;因为在这个公司，实行的是项目负责制，项目经理掌握着一票否决权。而我，这样一位刚刚上任，新鲜热乎着的【代】项目经理，开始膨胀了。&lt;/p&gt;
&lt;p&gt;在这位 L 前辈研究spark + strom 解决实时仓库问题时，我总是时不时打断了他，喊他去参与大数据的需求会议、去解决APP的流量高峰问题、去参与统一门户的架构设计。&lt;/p&gt;
&lt;p&gt;诚然这一切，都应是技术总负责人应该去参与负责的事情。但是我在请求 L 去解决的时候，未免有些不够尊重。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有时候，你外在不经意的一些表现其实正是你内心想法的一种体现。而人与人的相处，是奇妙而玄幻的。这种看不见、摸不着的气氛是真的会影响彼此的心情与态度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更何况，L 更是将技术人简单、直接的性格放大到极致。&lt;/p&gt;
&lt;p&gt;在某次赴地市的会议上，我与L一起讨论确定了办公系统与外部系统的对接与集成方式后，便借口项目组有事先走了，让 L 留下参与后续与另一家公司的对接。&lt;/p&gt;
&lt;p&gt;这件事直接导致 L 的不满爆发，在几天后的一次微信群的工作安排上直接怼了我，将我拉黑。&lt;/p&gt;
&lt;p&gt;当然，这样的过程都是我后来回忆、反思得出的结论，而我当时是懵逼的。&lt;/p&gt;
&lt;p&gt;为什么？会有这么激烈的回应？我一脸懵逼地请求项目总监X的帮助，才让 L 重新恢复参与了后续的工作。&lt;/p&gt;
&lt;p&gt;我后来想想，这一切好像是偶然发生的，但却也是必然会产生的，如果不是 L ，可能事情不会这么激烈。然而其他没有拉黑我的下属和同事们，是不是其实心里也在怨怼我呢？&lt;/p&gt;
&lt;p&gt;在升上了项目经理之后，我是不是也开始远离初心，“远之则怨”了呢？&lt;/p&gt;
&lt;p&gt;特别是在并非管理序列的上升通道中，突然从技术岗转为了管理岗，从单纯的管事变成了管人，有了财政、生杀大权，怎样消去产生的膨胀与浮躁感呢？&lt;/p&gt;
&lt;p&gt;有时候能力与眼界是位置带来的，但是位置带来的能力不是天生就来的，而是慢慢培养、逐渐形成的。&lt;/p&gt;
&lt;p&gt;我回忆、反思这段往事的时候，觉得我在坐上项目经理的时候，缺失了一名老赵这样的导师，想起他说的一句话：“扶上马，再送一程”。&lt;/p&gt;
&lt;p&gt;在很多公司，其实包括我当时所在的这家公司，也都有项目经理的培养与汇报机制，但是很多时候都沦为了背景色、走过程，是不是哪怕再忙，也该有这么一课呢？&lt;/p&gt;
&lt;p&gt;当然，有可能也并没有什么鸟用。因为纸上得来终觉浅，绝知此事要躬行。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我从这件事后，开始反思，重新整理人事，缩减汇报对象与被汇报对象。分离主要事务、次要事务。有意培养各开发组长的全栈能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，这一切其实都是不够的，甚至在2017下2018上的时候，我开始怠惰，彻底放权，走入了另一个极端。&lt;/p&gt;
&lt;p&gt;而在环境的演变下与艰难的挣扎中，我在2018下半年选择重新投入了技术岗，但是在两年已经极少碰代码的情况下，我能重新拾起，并引领项目组前行吗？&lt;/p&gt;
&lt;p&gt;这是另一个故事了，但是最后想说的是:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;没做到技术总监、架构师，以后还想做技术，别去碰项目经理这个职位，繁杂琐事，耗费精力，徒增烦恼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，这又可以写篇文章了，下一篇就叫《技术人，别做项目经理，有毒！》，哈哈哈。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎加入我的知识星球，扫一扫下方二维码，目前免费哦。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1349401/201906/1349401-20190624083632657-488583590.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 00:37:00 +0000</pubDate>
<dc:creator>妖生</dc:creator>
<og:description>作者简介：妖生。 坐标合肥，一个普通程序员。十年职业生涯，8年编程。经历了许多事，也有点想法，现在将它们变成文字，书于纸上。如果能帮助到你，那将不胜荣幸。 膨胀、骄傲，程序员转项目经理的原罪 [TOC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yaoshen/p/11075231.html</dc:identifier>
</item>
<item>
<title>RPC - 麻雀虽小，五脏俱全 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/11074498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/11074498.html</guid>
<description>&lt;p&gt;&lt;span&gt;说起 RPC （远程过程调用），大家应该不陌生。随着微服务、分布式越来越流行，RPC 应用越来越普遍。常见的 RPC 框架如：Dubbo、gRPC、Thrift 等。本篇文章不是介绍各种 RPC 的使用和对比。而是深入剖析一个 RPC 包含哪些内容。我最近在 Hadoop 的源码，正好把 Hadoop RPC 看完了。感觉 Hadoop 的 RPC 框架设计的还是比价优秀的。Hadoop 作为大数据技术的基石，如果没有一个高性能、高可靠的 RPC 框架，很难支撑上千台服务器规模的集群。因此，本篇文章就以 Hadoop RPC 为例，介绍一个 RPC 框架会涉及的技术。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;架构设计&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;RPC 的架构涉及客户端、网络、服务端三大组件。网络一般使用 socket ，更多的是基于现有的网络框架进行参数的设置达到最优的目的。但是客户端和服务端需要我们自己设计，并且对于分布式框架来说，设计的架构应该有高性能、高可用以及可扩展的特点。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;高性能&lt;/strong&gt;：由于客户端同时发起多个请求，这就要求系统能够快速处理，降低响应延迟。也就是高吞吐、低延迟。从客户端角度来说，由于创建客户端到服务端的连接成本较高。因此可以缓存连接资源，从而实现多个客户端复用相同的连接资源，避免每个客户端都来创建而降低性能；从服务端角度来说，可以启动多线程来并发处理客户端请求。除了多线程，可以采用 Reactor 编程模式，提高多线程并发的性能。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;高可用&lt;/strong&gt;：当我们的服务端挂了，能不能有备用节点继续提供服务。Hadoop 2.x 实现了 NameNode 的高可用。当客户端需要通过 RPC 调用 NameNode 服务的过程中，如果主 NameNode 宕机，那么备用 NameNode 会升级成活动节点。同时会将 RPC 的请求发送的当前活跃的 NameNode，从而继续提供可用的服务，而这个过程对客户端来说是透明的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：一个框架需要不断地优化、不断升级。需要在架构设计时明确不变的需求点，以及可变的需求点，对于可变的需求需要能够有良好的可扩展性。以 RPC 涉及的序列化为例。由于不同序列化框架适用场景不同，因此这需要被当成可变的需求点，应该将其设计成可扩展的，能够容易地支持不同的序列化框架。目前，Hadoop RPC 支持自身的序列化框架（Writable）和 Protoc Buffer。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;设计模式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;设计模式更多地与上面提到的可扩展性相呼应。良好的设计模式可以提高代码复用性、增强可扩展性，同时能够降低 BUG 数量。Hadoop RPC 中涉及的设计模式比较多，大概包括：工厂模式、代理模式、适配器模式、装饰者模式和命令模式等。以代理模式为例，当客户端调用远程方法时，实际上是通过代理，将方法名和参数通过网络发送到服务端。但这个过程对客户端是透明的，对于客户端来说就像调用本地方法一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了设计模式，在工程实践中还应该注意遵循常见的设计原则。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;多线程&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在任何一个系统中多线程都比较常见。通过多线程并发处理，提高系统的吞吐量。在 Hadoop RPC 中，客户端与服务端都用到了多线程技术。客户端开启多线程，每个线程处理一类请求，并且缓存连接资源。服务端也是多线程并发处理客户端的请求，使用 Reactor 编程模式提高并发性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;谈到多线程就不得不提另一个话题 —— 线程安全。Hadoop RPC 中用了不少的技术来保证线程安全，包括：synchronized、concurrent并发包、atomic并发包和 nio 工具包。从优秀框架中学习线程安全，对我们以后并发编程有不少好处。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;序列化与反序列化&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于 RPC 涉及数据在网络上传输，因此需要一个优秀的序列化框架，既能够高效的编码与解码，且编码后的数据大小又尽可能小。不同的序列化框架主要是在编解码效率和编码大小两个主要方面做权衡。Hadoop RPC 目前支持两种序列化框架，一个是 Hadoop 自己实现的 Writable 框架，另一个是 Protocol Buffer。Hadoop RPC 虽然支持 Writable 序列化框架，但还是以 Protocol Buffer 为主。因为 Protocol Buffer 从编解码效率和编码大小方便都是比较优秀的。当然常见的序列化包括 Avro、Kryo 等，有兴趣的读者可以查一下它们之间的性能对比。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一个 RPC 框架，除了包含上面提到比较主要的方面。还有一些其他的方面&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;语言层面&lt;/strong&gt;：利用好 Java 语言的继承、组合、封装、多态等特性。甚至包括泛型、注解等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;代码规范&lt;/strong&gt;：良好的工程实现应该有一个良好的代码规范。在 Hadoop 中，代码风格比较统一，且每个重要的类都有详细的注释，在关键的方法或者属性上也有明确的注释。我在自己的工程中会使用阿里的 Java 代码规约插件，也会为了让自己的代码更规范。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;异常处理&lt;/strong&gt;：对于一个优秀的框架异常处理很关键，什么时候需要抛出异常、抛出什么样的异常以及什么时候需要处理异常。在 RPC 中除了需要处理本地异常还要处理远程服务的异常。因此，在程序中如何优雅的处理异常也是体现一个程序员能力的地方。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;网络编程&lt;/strong&gt;：RCP 中涉及的网络编程一般用 socket，Hadoop RPC 使用的 Reactor 模式的网络编程，并且 Netty 也在使用这种框架。我们有必要会用并且掌握它。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; 这一段写的比较杂，想到哪写到哪。最近有跟朋友聊过在看 RPC 相关的东西，朋友说：“一个 RPC 能够涉及多少东西？值得研究？”。其实我一开始也是这样想的，无非就是客户端将请求序列化，通过网络发给服务端，服务端反序列化调用函数后再返回。但是看了 Hadoop RPC 代码后，我发现这样框架涉及的知识还是特别多的，并且还比较系统，基本上包含了我们平时编程涉及的方方面面。同时它不再是一个单机程序，而是一个 C/S 架构的程序。如果我们有兴趣还可以继续研究他的高可用，从而对分布式应用有更深入的了解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我觉得 RPC 是麻雀虽小五脏俱全。由于它涉及了我们编程的方方面面，所以我想基于 Hadoop RPC 做一个详细的教程，把它涉及的每个重要部分都进行详细的分析，上面提到的内容基本都会涵盖。对于想了解 RPC 的读者，能够感受到一个 RPC 框架更清晰的面貌。对于仅有 Java 基础的读者来说，能够学到编写一个框架所涉及的具体编程技术，同时能够从世界顶级开源项目学到优秀设计和工程经验。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;小结 &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本篇文章主要介绍了 RPC 框架涉及的知识。包括：架构设计、设计模式以及设计原则、多线程并发以及线程安全、序列化框架和一些其他的内容。我觉得学习最好的方式就是从优秀的框架中学习、模仿。好比我们练书法基本都要经过临摹这一步。当然直接看别人的代码确实需求花费更多的时间和经历，并且有时候投入与产出并不成正比。所以，我想把我在 Hadoop RPC 框架中学到的优秀的设计和实现能够整理成教程，以便有兴趣的读者学习。如果有任何建议欢迎与我交流。&lt;span&gt;&lt;em&gt;公众号有福利&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;公众号&lt;strong&gt;「渡码」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201906/1129006-20190610224613682-287034495.png&quot; alt=&quot;&quot; width=&quot;162&quot; height=&quot;161&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 00:27:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>说起 RPC （远程过程调用），大家应该不陌生。随着微服务、分布式越来越流行，RPC 应用越来越普遍。常见的 RPC 框架如：Dubbo、gRPC、Thrift 等。本篇文章不是介绍各种 RPC 的使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/11074498.html</dc:identifier>
</item>
<item>
<title>kubernetes高级之创建只读文件系统以及只读asp.net core容器 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11075201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11075201.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用docker创建只读文件系统&quot;&gt;使用docker创建只读文件系统&lt;/h2&gt;
&lt;p&gt;容器化部署对应用的运维带来了极大的方便,同时也带来一些新的安全问题需要考虑.比如黑客入侵到容器内,对容器内的系统级别或者应用级别文件进行修改,会造成难以估量的损失.(比如修改hosts文件导致dns解析异常,修改web资源导致网站被嵌入广告,后端逻辑被更改导致权限验证失效等,由于是分布式部署,哪些容器内的资源被修改也很难以发现).解决这个问题的办法就是创建创建一个具有只读文件系统的容器.下面介绍使用docker run命令和docker compose来创建具有只读文件系统的容器.&lt;/p&gt;
&lt;h2 id=&quot;使用docker-run命令创建只读文件系统&quot;&gt;使用docker run命令创建只读文件系统&lt;/h2&gt;
&lt;p&gt;比如说要创建一个只读文件系统的redis容器,可以执行以下命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run --read-only redis&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;docker-composeswarm创建只读文件系统&quot;&gt;docker compose/swarm创建只读文件系统&lt;/h2&gt;
&lt;p&gt;yaml编排文件示例如下&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;version: '3.3'
 
services:
  redis:
    image: redis:4.0.1-alpine
    networks:
      - myoverlay
    read_only: true

networks:
  myoverlay:&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;问题:创建只读文件系统看起来很不错,但是实际上往往会有各种各样的问题,比如很多应用要写temp文件或者写日志文件,如果对这样的应用创建只读容器则很可能导致应用无法正常启动.对于需要往固定位置写入日志或者临时文件的应用,可以挂载宿主机的存储卷,虽然容器是只读的,但是挂载的盘仍然是可读写的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建只读的asp.net-core容器&quot;&gt;创建只读的asp.net core容器&lt;/h2&gt;
&lt;p&gt;上面一节我们讲到了创建容器只读文件系统以增加安全性,以及如何解决需要写入日志文件或者临时文件这样常见的问题.我们尝试创建一个只读的asp.net应用时,即便不使用任何log组件(即不写入日志),仍然无法正常启动镜像.解决这个问题其实也非常简单,只需要把环境变量&lt;code&gt;COMPlus_EnableDiagnostics&lt;/code&gt;的值设置为&lt;code&gt;0&lt;/code&gt;即可.&lt;/p&gt;
&lt;pre class=&quot;dockerfile&quot;&gt;
&lt;code&gt;FROM microsoft/dotnet:2.2-aspnetcore-runtime AS base
WORKDIR /app
EXPOSE 52193

FROM microsoft/dotnet:2.2-sdk AS build
WORKDIR /src
COPY . .
WORKDIR &quot;/src&quot;
RUN dotnet build &quot;ReadOnlyTest.csproj&quot; -c Release -o /app

FROM build AS publish
RUN dotnet publish &quot;ReadOnlyTest.csproj&quot; -c Release -o /app

FROM base AS final
WORKDIR /app
ENV DOTNET_RUNNING_IN_CONTAINER=true
ENV DOTNET_CLI_TELEMETRY_OPTOUT=1

ENV COMPlus_EnableDiagnostics=0

COPY --from=publish /app .
ENTRYPOINT [&quot;dotnet&quot;, &quot;ReadOnlyTest.dll&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们对这些环境变量进行简单介绍&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;DOTNET_RUNNING_IN_CONTAINER&lt;/code&gt;值设置为true时则表示应用运行在容器内,方便我们获取程序的运行环境,然后根据环境做出不同决策(比如单元测试的时候,可能要根据项目是运行在windows,linux或者linux容器做出不同的测试策略).当然,你也可以设置其它的环境变量来方便自己使用,比如你键名称设置为&lt;code&gt;IsRunningInDocker&lt;/code&gt;,但是&lt;code&gt;DOTNET_RUNNING_IN_CONTAINER&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;DOTNET_CLI_TELEMETRY_OPTOUT&lt;/code&gt;是否输出遥测信息,如果设置为1则是关闭,这样dotnet.exe就不会向调试窗口输出遥测信息.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;COMPlus_EnableDiagnostics&lt;/code&gt;目前没有找到太多关于这个参数的详细信息,只是查阅资源发现这开启这项配置可以创建只读权限 aspnet 应用程序.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;微软官方基础镜像里还包含一项名称叫作&lt;code&gt;ASPNETCORE_VERSION&lt;/code&gt;的环境变量,我们可以直接读取它,这样使用公共的环境变量一来避免息手动设置和更新的麻烦,二来便于和社区交流(自己定义约束的只能用于内部团队交流)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们如何使用这些环境变量呢,其它可以在程序里面暴露一个helper方法,比如&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;private bool InDocker { get { return Environment.GetEnvironmentVariable(&quot;DOTNET_RUNNING_IN_CONTAINER&quot;) == &quot;true&quot;;} }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以根据实际的需求来使用它.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;上面我们介绍了如何使用docker run命令以及docker-compose创建只读文件系统.然而在kubernetes集群里,我们需要使用k8s的编排方法来创建只读文件系统.那么在k8s里如何创建只读文件系统.其实这里涉及到了另一个高级主题:那就是k8s的安全策略(Pod Security Policies)我们将在下一节介绍它.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 24 Jun 2019 00:12:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 使用docker创建只读文件系统 容器化部署对应用的运维带来了极大的方便,同时也带来一些新的安全问题需要考虑.比如黑客入侵到容器内,对容器内的系统级别或者应用级别文件进行修改,会造成难以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11075201.html</dc:identifier>
</item>
<item>
<title>可落地的DDD(5)-战术设计 - stoneFang</title>
<link>http://www.cnblogs.com/stoneFang/p/11075199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneFang/p/11075199.html</guid>
<description>&lt;p&gt;本篇是DDD的战术篇，也就是关于领域事件、领域对象、聚合根、实体、值对象的讨论。也是DDD系列的完结篇。&lt;br/&gt;这一部分在我们团队争论最多的，也有很多月经贴，比如对资源库的操作应该放在领域服务还是领域对象中。&lt;br/&gt;聚合根应不应该暴露给外部，还是要转成DTO。这些问题我们讨论了大半年，最后大家基本达成了共识，在当前的业务规模下，&lt;br/&gt;这些问题没那么重要，可东可西。不会对代码的质量有啥大的影响。关于DDD的实践，与团队的水平、业务复杂度息息相关。我们的经验并不一定就适用你们团队。我将战术篇的这么多的内容放在了一篇文章中，并且大部分都是引用之前的讨论、总结。&lt;br/&gt;原因还是在于我内心深处并没有觉得战术篇的实践给我们团队带来多么大的改变。战略篇的是我认为更重要的。&lt;/p&gt;
&lt;p&gt;DDD系列文章断断续续也有十来篇了，主要是总结我们团队落地过程遇到的问题和解决方案，算是DDD从学习到落地实践的一个完整的闭环链路，希望对你有所启发。当然这个过程受益最大的肯定是我本人。系统性的思考问题、总结问题、阐述问题是非常有助于提升个人思维能力，朋友们你们也可以尝试一下。&lt;/p&gt;

&lt;p&gt;DDD的出现，是大家对于事务性编程，面向数据库表编程的一个反思，明明软件设计是一个面向对象的设计，需要考虑对象之间的继承、多态、组合。&lt;br/&gt;为什么到实际编码过程中成了过程性的编程，为什么对象只有属性没有方法了，也就是失血模型。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于这几种编程的详细介绍可以参考Martin的《Patterns of Enterprise Application Architecture》Page110&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我个人觉得，DDD的作用有两个，一个是面向业务的，帮助分析业务模型，进行业务建模。另外一个是面向解决域，即代码落地。&lt;br/&gt;即使用一个规范能够反映对象之间的关系，即OO编程。&lt;/p&gt;
&lt;p&gt;目前对DDD研究主要有以下类别&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关于业务分析层面，如何进行概念层面的抽象和设计的方法论&lt;/li&gt;
&lt;li&gt;关于服务划分、代码分层、职责定义的方法论&lt;/li&gt;
&lt;li&gt;DDD框架的讨论，比如&lt;a href=&quot;https://www.jdon.com/jdonframework/app.htm&quot;&gt;jdon&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第3点基本上没怎么广泛的讨论。我认为未来也不会出现什么牛逼的DDD框架能够流行起来。DDD是一种建模方法，是针对不同的业务领域的，&lt;br/&gt;在不同的团队有不同的落地方案，是没办法靠一种框架来约束，来把一件不统一的事情来统一起来。就好比我们面向对象的设计针对问题域，抽象出来了&lt;br/&gt;20多种设计模式。这些设计模式都是指导思想，你不能搞出一种框架，来约束大家使用某种设计模式就基于这种框架扩展，以此来达到代码统一或者降低&lt;br/&gt;编程难度的目的。&lt;/p&gt;
&lt;p&gt;前面的文章主要是比较大的方面，比较适合做整体业务分析。也就是第一个点。今天主要讨论第二点。&lt;/p&gt;
&lt;h2 id=&quot;oo-编程&quot;&gt;OO 编程&lt;/h2&gt;
&lt;p&gt;DDD的代码分层、职责定义本质上就是OO编程。OO的三大基本要素就是继承、多态、组合。这三个是深度抽象的结果。没法指导具体的编程。&lt;br/&gt;于是我们有了设计模式，前辈们针对问题域，总结除了24种设计模式，这样遇到类似的问题时，我们可以使用对应的设计模式去解决问题。&lt;br/&gt;而这些设计模式底层使用到还是继承、多态、组合。&lt;/p&gt;
&lt;p&gt;那有了设计模式了，为什么还要DDD呢？为什么很少看到开源软件用DDD呢？&lt;br/&gt;个人的理解DDD还是面向&lt;strong&gt;企业应用架构&lt;/strong&gt;的，是在众多不确定的业务，系统中提炼出来的一套规范，这样必然是高度抽象的。而开源软件大多是领域比较确定的，比如数据库领域，中间件领域。解决这类问题的系统架构通常会更加复杂以及具有扩展性。&lt;/p&gt;
&lt;p&gt;DDD的工程架构网上有很多，我在之前的文章也提到过，这里不再赘述，看下老马的这个，我觉得非常清晰的展现出来了职责分离&lt;br/&gt;&lt;a href=&quot;https://martinfowler.com/articles/microservice-testing/#conclusion-summary&quot; class=&quot;uri&quot;&gt;https://martinfowler.com/articles/microservice-testing/#conclusion-summary&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190623125957366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们重点看领域一层。&lt;br/&gt;领域包含3点&lt;/p&gt;
&lt;h3 id=&quot;领域服务&quot;&gt;领域服务&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI3MDc1NA==&amp;amp;mid=2247483800&amp;amp;idx=1&amp;amp;sn=ca57d8b7e44229daecdd3a7103eabca6&amp;amp;chksm=ebde35d5dca9bcc3c828e410dcc6629e3f02b5c46007e2358c7ec905a79115c35faeddbc9dae&amp;amp;scene=21#wechat_redirect&quot;&gt;领域对象与领域服务&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;领域对象&quot;&gt;领域对象&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI3MDc1NA==&amp;amp;mid=2247483822&amp;amp;idx=1&amp;amp;sn=85bd5d90da63654e55508b08226afb8b&amp;amp;chksm=ebde35e3dca9bcf500c2f4ee17d01712e7244fabfb9950ff5b8114fc9f9ec314847dbfc11e1b&amp;amp;scene=21#wechat_redirect&quot;&gt;敢于聚合根的激烈讨论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;领域事件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI3MDc1NA==&amp;amp;mid=2247483814&amp;amp;idx=1&amp;amp;sn=ccffe06d80a34f1d7c1349980b8e72cc&amp;amp;chksm=ebde35ebdca9bcfd18a61f02dfd79d6b2e8181dbc1542d623a7e083aaacfbb8b02e7c97ac88a&amp;amp;scene=21#wechat_redirect&quot;&gt;CQRS能解什么问题&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础设施层&quot;&gt;基础设施层&lt;/h3&gt;
&lt;p&gt;为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关注公众号【方丈的寺院】，第一时间收到文章的更新，与方丈一起开始技术修行之路&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190418000000125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Jun 2019 00:10:00 +0000</pubDate>
<dc:creator>stoneFang</dc:creator>
<og:description>摘要 本篇是DDD的战术篇，也就是关于领域事件、领域对象、聚合根、实体、值对象的讨论。也是DDD系列的完结篇。 这一部分在我们团队争论最多的，也有很多月经贴，比如对资源库的操作应该放在领域服务还是领域</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stoneFang/p/11075199.html</dc:identifier>
</item>
<item>
<title>机器学习之决策树原理和sklearn实践 - Fate0729</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/11072556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/11072556.html</guid>
<description>&lt;p&gt;时间：早上八点，地点：婚介所&lt;/p&gt;
&lt;p&gt;‘闺女，我有给你找了个合适的对象，今天要不要见一面？’&lt;/p&gt;
&lt;p&gt;‘多大？’ ‘26岁’&lt;/p&gt;
&lt;p&gt;‘长的帅吗？’ ‘还可以，不算太帅’&lt;/p&gt;
&lt;p&gt;‘工资高吗？’ ‘略高于平均水平’&lt;/p&gt;
&lt;p&gt;‘会写代码吗？’ ‘人家是程序员，代码写的棒着呢！’&lt;/p&gt;
&lt;p&gt;‘好，把他的联系方式发过来吧，我抽空见一面’&lt;/p&gt;
&lt;p&gt;上面的场景描述&lt;strong&gt;摘抄自&amp;lt;百面机器学习&amp;gt;&lt;/strong&gt;，是一个典型的决策树分类问题，通过年龄、长相、工资、是否会编程等特征属性对介绍对象进行是否约会进行分类&lt;/p&gt;
&lt;p&gt;决策树是一种自上而下，对样本数据进行树形分类的过程，由结点和有向边组成，每个结点(叶结点除外)便是一个特征或属性，叶结点表示类别。从顶部根结点开始，所有样本聚在仪器，经过根结点的划分，样本被分到不同的子结点中。再根据子结点的特征进一步划分，直至样本都被分到某一类别(叶子结点)中&lt;/p&gt;

&lt;p&gt;决策树作为最基础、最常见的有监督学习模型，常被用于分类问题和回归问题，将决策树应用集成思想可以得到随机森林、梯度提升决策树等模型。其主要优点是模型具有可读性，分类速度快。决策树的学习通常包括三个步骤：特征选择、决策树的生成和决策树的修剪，下面对特征选择算法进行描述和区别&lt;/p&gt;
&lt;h2 id=&quot;id3---最大信息增益&quot;&gt;2.1 ID3---最大信息增益&lt;/h2&gt;
&lt;p&gt;在信息论与概率统计中，熵（entropy）是表示随机变量不确定性的度量，设X是一个取有限个值的随机变量，其概率分布为：&lt;span class=&quot;math display&quot;&gt;\[P(X=X_i)=P_i (i = 1,2,...,n)\]&lt;/span&gt;,则随机变量X的熵定义为：&lt;span class=&quot;math display&quot;&gt;\[H(X) = -\sum_{i=1}^np_i\log{p_i}\]&lt;/span&gt;表达式中的对数以2为底或以e为底，这时熵的单位分别称作bit或nat,从表达式可以看出X的熵与X的取值无关，所以X的熵也记作&lt;span class=&quot;math inline&quot;&gt;\(H(p)\)&lt;/span&gt;,即&lt;span class=&quot;math display&quot;&gt;\[H(p) = -\sum_{x=1}^np_i\log{p_i}\]&lt;/span&gt;熵取值越大，随机变量的不确定性越大&lt;/p&gt;
&lt;p&gt;条件熵：&lt;/p&gt;
&lt;p&gt;条件熵H(Y|X)表示在已知随机变量X的条件下，随机变量Y的不确定性，随机变量X给定的条件下随机变量Y的条件熵定义为X给定条件下Y的条件概率分布的熵对X的数学期望&lt;span class=&quot;math display&quot;&gt;\[H(Y|X) = \sum_{i=1}^nP(X=X_i)H(Y|X=X_i)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;信息增益：&lt;span class=&quot;math display&quot;&gt;\[g(D,A) = H(D) - H(D|A)\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
data = {
        '年龄':['老','年轻','年轻','年轻','年轻'],
        '长相':['帅','一般','丑','一般','一般'],
        '工资':['高','中等','高','高','低'],
        '写代码':['不会','会','不会','会','不会'],
        '类别':['不见','见','不见','见','不见']}
frame = pd.DataFrame(data,index=['小A','小B','小C','小D','小L'])
print(frame)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    年龄  长相  工资 写代码  类别
小A   老   帅   高  不会  不见
小B  年轻  一般  中等   会   见
小C  年轻   丑   高  不会  不见
小D  年轻  一般   高   会   见
小L  年轻  一般   低  不会  不见&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import math
print(math.log(3/5))
print('H(D):',-3/5 *math.log(3/5,2) - 2/5*math.log(2/5,2))
print('H(D|年龄)',1/5*math.log(1,2)+4/5*(-1/2*math.log(1/2,2)-1/2*math.log(1/2,2)))
print('以同样的方法计算H(D|长相),H(D|工资),H(D|写代码)')
print('H(D|长相)',0.551)
print('H(D|工资)',0.551)
print('H(D|写代码)',0)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;-0.5108256237659907
H(D): 0.9709505944546686
H(D|年龄) 0.8
以同样的方法计算H(D|长相),H(D|工资),H(D|写代码)
H(D|长相) 0.551
H(D|工资) 0.551
H(D|写代码) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算信息增益：g(D,写代码)=0.971最大，可以先按照写代码来拆分决策树&lt;/p&gt;
&lt;h2 id=&quot;c4.5---最大信息增益比&quot;&gt;2.2 C4.5---最大信息增益比&lt;/h2&gt;
&lt;p&gt;以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的问题，使用信息增益比可以对对着问题进行校正，这是特征选择的另一标准&lt;br/&gt;信息增益比定义为其信息增益g(D,A)与训练数据集D关于特征A的值的熵&lt;span class=&quot;math inline&quot;&gt;\(H_A(D)\)&lt;/span&gt;之比：&lt;span class=&quot;math display&quot;&gt;\[g_R(D,A) = \frac{g(D,A)}{H_A(D)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[H_A(D) = -\sum_{i=1}^n\frac{|D_i|}{|D|}\log\frac{|D_i|}{|D|}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;拿上面ID3的例子说明：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[H_年龄(D) = -1/5*math.log(1/5,2)-4/5*math.log(4/5,2)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[g_R(D,年龄) = H_{年龄}(D)/g(D,年龄) = 0.171/0.722 = 0.236 \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;cart----最大基尼指数gini&quot;&gt;2.3 CART----最大基尼指数(Gini)&lt;/h2&gt;
&lt;p&gt;Gini描述的是数据的纯度，与信息熵含义类似,分类问题中，假设有K个类，样本点数据第k类的概率为&lt;span class=&quot;math inline&quot;&gt;\(P_k\)&lt;/span&gt;,则概率分布的基尼指数定义为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Gini(p) = 1- \sum_{k=1}^Kp_k(1-p_k) = 1 - \sum_{k=1}^Kp_{k}^2\]&lt;/span&gt;&lt;br/&gt;对于二分类问题，弱样本点属于第1个类的概率是p,则概率分布的基尼指数为&lt;span class=&quot;math display&quot;&gt;\[Gini(p) = 2p(1-p)\]&lt;/span&gt;,对于给定的样本几何D,其基尼指数为&lt;span class=&quot;math display&quot;&gt;\[Gini(D) = 1 - \sum_{k=1}^K[\frac{|C_k|}{|D|}]^2\]&lt;/span&gt;注意这里&lt;span class=&quot;math inline&quot;&gt;\(C_k\)&lt;/span&gt;是D种属于第k类的样本子集，K是类的个数,如果样本几个D根据特征A是否取某一可能指a被分割成D1和D2两部分，则在特征A的条件下，集合D的基尼指数定义为&lt;span class=&quot;math display&quot;&gt;\[Gini(D,A) = \frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Gini(D|年龄=老)=1/5*（1-1）+4/5*[1-(1/2*1/2+1/2*1/2)] = 0.4\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CART在每一次迭代种选择基尼指数最小的特征及其对应的切分点进行分类&lt;/p&gt;
&lt;h2 id=&quot;id3c4.5与gini的区别&quot;&gt;2.4 ID3、C4.5与Gini的区别&lt;/h2&gt;
&lt;h3 id=&quot;从样本类型角度&quot;&gt;2.4.1 从样本类型角度&lt;/h3&gt;
&lt;p&gt;从样本类型角度，ID3只能处理离散型变量，而C4.5和CART都处理连续性变量，C4.5处理连续性变量时，通过对数据排序之后找到类别不同的分割线作为切割点，根据切分点把连续型数学转换为bool型，从而将连续型变量转换多个取值区间的离散型变量。而对于CART，由于其构建时每次都会对特征进行二值划分，因此可以很好地适合连续性变量。&lt;/p&gt;
&lt;h3 id=&quot;从应用角度&quot;&gt;2.4.2 从应用角度&lt;/h3&gt;
&lt;p&gt;ID3和C4.5只适用于分类任务，而CART既可以用于分类也可以用于回归&lt;/p&gt;
&lt;h3 id=&quot;从实现细节优化等角度&quot;&gt;2.4.3 从实现细节、优化等角度&lt;/h3&gt;
&lt;p&gt;ID3对样本特征缺失值比较敏感，而C4.5和CART可以对缺失值进行不同方式的处理，ID3和C4.5可以在每个结点熵产生出多叉分支，且每个特征在层级之间不会复用，而CART每个结点只会产生两个分支，因此会形成一颗二叉树，且每个特征可以被重复使用；ID3和C4.5通过剪枝来权衡树的准确性和泛化能力，而CART直接利用全部数据发现所有可能的树结构进行对比。&lt;/p&gt;

&lt;h2 id=&quot;为什么要进行剪枝&quot;&gt;3.1 为什么要进行剪枝？&lt;/h2&gt;
&lt;p&gt;对决策树进行剪枝是为了防止过拟合&lt;/p&gt;
&lt;p&gt;根据决策树生成算法通过训练数据集生成了复杂的决策树，导致对于测试数据集出现了过拟合现象，为了解决过拟合，就必须考虑决策树的复杂度，对决策树进行剪枝，剪掉一些枝叶，提升模型的泛化能力&lt;/p&gt;
&lt;p&gt;决策树的剪枝通常由两种方法，预剪枝和后剪枝&lt;/p&gt;
&lt;h2 id=&quot;预剪枝&quot;&gt;3.2 预剪枝&lt;/h2&gt;
&lt;p&gt;预剪枝的核心思想是在树中结点进行扩展之前，先计算当前的划分是否能带来模型泛化能力的提升，如果不能，则不再继续生长子树。此时可能存在不同类别的样本同时存于结点中，按照多数投票的原则判断该结点所属类别。预剪枝对于何时停止决策树的生长有以下几种方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)当树达到一定深度的时候，停止树的生长&lt;/li&gt;
&lt;li&gt;(2)当叶结点数到达某个阈值的时候，停止树的生长&lt;/li&gt;
&lt;li&gt;(3)当到达结点的样本数量少于某个阈值的时候，停止树的生长&lt;/li&gt;
&lt;li&gt;(4)计算每次分裂对测试集的准确度提升，当小于某个阈值的时候，不再继续扩展&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;预剪枝思想直接，算法简单，效率高特点，适合解决大规模问题。但如何准确地估计何时停止树的生长，针对不同问题会有很大差别，需要一定的经验判断。且预剪枝存在一定的局限性，有欠拟合的风险&lt;/p&gt;
&lt;h2 id=&quot;后剪枝&quot;&gt;3.3 后剪枝&lt;/h2&gt;
&lt;p&gt;后剪枝的核心思想是让算法生成一颗完全生长的决策树，然后从底层向上计算是否剪枝。剪枝过程将子树删除，用一个叶结点代替，该结点的类别同样按照多数投票原则进行判断。同样地，后剪枝叶可以通过在测试集上的准确率进行判断，如果剪枝过后的准确率有所提升，则进行剪枝，后剪枝方法通常可以得到泛化能力更强的决策树，但时间开销更大&lt;/p&gt;
&lt;h3 id=&quot;损失函数&quot;&gt;损失函数&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[C_a(T) = \sum_{t=1}^{|T|}N_tH_t(T) + a|T|\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(其中|T|为叶结点个数，N_t为结点t的样本个数，H_t(T)为结点t的信息熵，a|T|为惩罚项，a&amp;gt;=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[C_a(T) = \sum_{t=1}^{|T|}N_tH_t(T) + a|T| = -\sum_{t=1}^{|T|}\sum_{k=1}^KN_{tk}\log \frac{N_{tk}}{N_t} + a|T|\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意：上面的公式中是&lt;span class=&quot;math inline&quot;&gt;\(N_{tk}\log \frac{N_{tk}}{N_t}\)&lt;/span&gt;,而不是&lt;span class=&quot;math inline&quot;&gt;\(\frac{N_{tk}}{N_t} \log \frac{N_{tk}}{N_t}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令：&lt;span class=&quot;math display&quot;&gt;\[C_a(T) = C(T) + a|T|\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(C(T)\)&lt;/span&gt;表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，|T|表示模型复杂度，参数a&amp;gt;=0控制两者的影响力，较大的a促使选择较简单的模型，较小的a促使选择复杂的模型，a=0意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂度&lt;/p&gt;

&lt;h2 id=&quot;需求&quot;&gt;4.1 需求&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;a.使用make_moons(n_samples=10000,noise=0.4)生成一个卫星数据集&lt;/li&gt;
&lt;li&gt;b.使用train_test_split()拆分训练集和测试集&lt;/li&gt;
&lt;li&gt;c.使用交叉验证的网格搜索为DecisionTreeClassifier找到合适的超参数，提示:尝试max_leaf_nodes的多种值&lt;/li&gt;
&lt;li&gt;d.使用超参数对整个训练集进行训练，并测量模型测试集上的性能&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代码实现&quot;&gt;代码实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.datasets import make_moons
import numpy as np
import pandas as pd&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataset = make_moons(n_samples=10000,noise=0.4)
print(type(dataset))
print(dataset)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class 'tuple'&amp;gt;
(array([[ 0.24834453, -0.11160162],
       [-0.34658051, -0.43774172],
       [-0.25009951, -0.80638312],
       ...,
       [ 2.3278198 ,  0.39007769],
       [-0.77964208,  0.68470383],
       [ 0.14500963,  1.35272533]]), array([1, 1, 1, ..., 1, 0, 0], dtype=int64))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataset_array = np.array(dataset[0])
label_array = np.array(dataset[1])
print(dataset_array.shape,label_array.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(10000, 2) (10000,)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 拆分数据集
from sklearn.model_selection import train_test_split
x_train,x_test = train_test_split(dataset_array,test_size=0.2,random_state=42)
print(x_train.shape,x_test.shape)
y_train,y_test = train_test_split(label_array,test_size=0.2,random_state=42)
print(y_train.shape,y_test.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(8000, 2) (2000, 2)
(8000,) (2000,)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 使用交叉验证的网格搜索为DecisionTreeClassifier找到合适的超参数
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import GridSearchCV

decisionTree = DecisionTreeClassifier(criterion='gini')
param_grid = {'max_leaf_nodes': [i for i in range(2,10)]}
gridSearchCV = GridSearchCV(decisionTree,param_grid=param_grid,cv=3,verbose=2)
gridSearchCV.fit(x_train,y_train)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Fitting 3 folds for each of 8 candidates, totalling 24 fits
[CV] max_leaf_nodes=2 ................................................
[CV] ................................. max_leaf_nodes=2, total=   0.0s
[CV] max_leaf_nodes=2 ................................................
[CV] ................................. max_leaf_nodes=2, total=   0.0s
[CV] max_leaf_nodes=2 ................................................
[CV] ................................. max_leaf_nodes=2, total=   0.0s
[CV] max_leaf_nodes=3 ................................................
[CV] ................................. max_leaf_nodes=3, total=   0.0s
[CV] max_leaf_nodes=3 ................................................
[CV] ................................. max_leaf_nodes=3, total=   0.0s
[CV] max_leaf_nodes=3 ................................................
[CV] ................................. max_leaf_nodes=3, total=   0.0s
[CV] max_leaf_nodes=4 ................................................
[CV] ................................. max_leaf_nodes=4, total=   0.0s
[CV] max_leaf_nodes=4 ................................................
[CV] ................................. max_leaf_nodes=4, total=   0.0s
[CV] max_leaf_nodes=4 ................................................
[CV] ................................. max_leaf_nodes=4, total=   0.0s
[CV] max_leaf_nodes=5 ................................................
[CV] ................................. max_leaf_nodes=5, total=   0.0s
[CV] max_leaf_nodes=5 ................................................
[CV] ................................. max_leaf_nodes=5, total=   0.0s
[CV] max_leaf_nodes=5 ................................................
[CV] ................................. max_leaf_nodes=5, total=   0.0s
[CV] max_leaf_nodes=6 ................................................
[CV] ................................. max_leaf_nodes=6, total=   0.0s
[CV] max_leaf_nodes=6 ................................................
[CV] ................................. max_leaf_nodes=6, total=   0.0s
[CV] max_leaf_nodes=6 ................................................
[CV] ................................. max_leaf_nodes=6, total=   0.0s
[CV] max_leaf_nodes=7 ................................................
[CV] ................................. max_leaf_nodes=7, total=   0.0s
[CV] max_leaf_nodes=7 ................................................
[CV] ................................. max_leaf_nodes=7, total=   0.0s
[CV] max_leaf_nodes=7 ................................................
[CV] ................................. max_leaf_nodes=7, total=   0.0s
[CV] max_leaf_nodes=8 ................................................
[CV] ................................. max_leaf_nodes=8, total=   0.0s
[CV] max_leaf_nodes=8 ................................................
[CV] ................................. max_leaf_nodes=8, total=   0.0s
[CV] max_leaf_nodes=8 ................................................
[CV] ................................. max_leaf_nodes=8, total=   0.0s
[CV] max_leaf_nodes=9 ................................................
[CV] ................................. max_leaf_nodes=9, total=   0.0s
[CV] max_leaf_nodes=9 ................................................
[CV] ................................. max_leaf_nodes=9, total=   0.0s
[CV] max_leaf_nodes=9 ................................................
[CV] ................................. max_leaf_nodes=9, total=   0.0s


[Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers.
[Parallel(n_jobs=1)]: Done   1 out of   1 | elapsed:    0.0s remaining:    0.0s
[Parallel(n_jobs=1)]: Done  24 out of  24 | elapsed:    0.0s finished

GridSearchCV(cv=3, error_score='raise-deprecating',
       estimator=DecisionTreeClassifier(class_weight=None, criterion='gini', max_depth=None,
            max_features=None, max_leaf_nodes=None,
            min_impurity_decrease=0.0, min_impurity_split=None,
            min_samples_leaf=1, min_samples_split=2,
            min_weight_fraction_leaf=0.0, presort=False, random_state=None,
            splitter='best'),
       fit_params=None, iid='warn', n_jobs=None,
       param_grid={'max_leaf_nodes': [2, 3, 4, 5, 6, 7, 8, 9]},
       pre_dispatch='2*n_jobs', refit=True, return_train_score='warn',
       scoring=None, verbose=2)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(gridSearchCV.best_params_)
decision_tree = gridSearchCV.best_estimator_&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{'max_leaf_nodes': 4}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 使用测试集对模型进行评估
from sklearn.metrics import accuracy_score
y_prab = gridSearchCV.predict(x_test)
print('accuracy_score:',accuracy_score(y_test,y_prab))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;accuracy_score: 0.8455&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 可视化模型
from sklearn.tree import export_graphviz

export_graphviz(decision_tree,
               out_file='./tree.dot',
               rounded = True,
               filled = True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;生成tree.dot文件，然后使用dot命令&lt;span class=&quot;math display&quot;&gt;\[dot -Tpng tree.dot -o decisontree_moons.png\]&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201906/1117865-20190623140823861-287724396.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;sklearn.tree.decisiontreeclassifier类说明&quot;&gt;5.1 sklearn.tree.DecisionTreeClassifier类说明&lt;/h2&gt;
&lt;h3 id=&quot;decsisiontreeclassifier类参数说明&quot;&gt;5.1.1 DecsisionTreeClassifier类参数说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;criterion&lt;/strong&gt;: 特征选择方式，string,('gini' or 'entropy'),default='gini'&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;splitter&lt;/strong&gt;: 每个结点的拆分策略，('best' or 'random'),string,default='best'&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_depth&lt;/strong&gt;: int,default=None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min_samples_split&lt;/strong&gt;: int,float,default=2,分割前所需的最小样本数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min_samples_leaf&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min_weight_fraction_leaf&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_features&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;random_state&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_leaf_nodes&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min_impurity_decrease&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min_impurity_split&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;class_weight&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;presort&lt;/strong&gt;: bool,default=False,对于小型数据集(几千个以内)设置presort=True通过对数据预处理来加快训练，但对于较大训练集而言，可能会减慢训练速度&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;decisiontreeclassifier属性说明&quot;&gt;5.1.2 DecisionTreeClassifier属性说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;classes_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;feature_importances_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_features_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_classes_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_features_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_outputs_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tree_&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;gridsearchcv类说明&quot;&gt;5.2 GridSearchCV类说明&lt;/h2&gt;
&lt;h3 id=&quot;gridsearchcv参数说明&quot;&gt;5.2.1 GridSearchCV参数说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;estimator&lt;/strong&gt;: 估算器，继承于BaseEstimator&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;param_grid&lt;/strong&gt;: dict,键为参数名，值为该参数需要测试值选项&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scoring&lt;/strong&gt;: default=None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fit_params&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_jobs&lt;/strong&gt;: 设置要并行运行的作业数，取值为None或1，None表示1 job,1表示all processors,default=None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cv&lt;/strong&gt;: 交叉验证的策略数，None或integer,None表示默认3-fold, integer指定“(分层)KFold”中的折叠数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;verbose&lt;/strong&gt;: 输出日志类型&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;gridsearchcv属性说明&quot;&gt;5.2.2 GridSearchCV属性说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;cv_results_&lt;/strong&gt;: dict of numpy(masked) ndarray&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_estimator_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_score_&lt;/strong&gt;: Mean cross-validated score of the best_estimator&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_params_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_index_&lt;/strong&gt;: int,The index (of the ``cv_results_`` arrays) which corresponds to the best candidate parameter setting&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scorer_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_splits_&lt;/strong&gt;: The number of cross-validation splits (folds/iterations)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;refit_time&lt;/strong&gt;: float&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;参考资料:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)&amp;lt;机器学习实战基于Scikit-Learn和TensorFlow&amp;gt;&lt;/li&gt;
&lt;li&gt;(2)&amp;lt;百面机器学习&amp;gt;&lt;/li&gt;
&lt;li&gt;(3)李航&amp;lt;统计学习方法&amp;gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 23 Jun 2019 23:57:00 +0000</pubDate>
<dc:creator>Fate0729</dc:creator>
<og:description>1. 场景描述 时间：早上八点，地点：婚介所 ‘闺女，我有给你找了个合适的对象，今天要不要见一面？’ ‘多大？’ ‘26岁’ ‘长的帅吗？’ ‘还可以，不算太帅’ ‘工资高吗？’ ‘略高于平均水平’</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaobingqianrui/p/11072556.html</dc:identifier>
</item>
<item>
<title>J2SE入门(六)  static五大应用场景 - 工匠初心</title>
<link>http://www.cnblogs.com/LiaHon/p/11075178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiaHon/p/11075178.html</guid>
<description>&lt;p&gt;static和final是两个我们必须掌握的关键字。不同于其他关键字，他们都有多种用法，而且在一定环境下使用，可以提高程序的运行性能，优化程序的结构。上一个章节我们讲了&lt;a href=&quot;https://www.cnblogs.com/LiaHon/p/11071861.html&quot;&gt;final关键字的原理及用法&lt;/a&gt;，本章节我们来了解一下static关键字原理及其用法。&lt;/p&gt;
&lt;h2 id=&quot;一.-static特点&quot;&gt;一. static特点&lt;/h2&gt;
&lt;p&gt;static是一个修饰符，通常用于修饰变量和方法，如开发过程中用到的字典类数据都会用到static来修饰，工具类方法，如Dateutils，Stringutils这类工具方法也会用到static来修饰，那么除了这两种最常用的场景外，是否还有其他场景呢，答案是：有的，总共五种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;static变量&lt;/li&gt;
&lt;li&gt;static方法&lt;/li&gt;
&lt;li&gt;static代码块&lt;/li&gt;
&lt;li&gt;static内部类&lt;/li&gt;
&lt;li&gt;static包内导入&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;static修饰的变量、方法、代码块、内部类在类加载期间就已经完成初始化，存储在Java Heap（JDK7.0之前存储在方法区）中静态存储区，因此static优于对象而存在。&lt;/p&gt;
&lt;p&gt;static修饰的成员（变量、方法）被所有对象所共享，也叫静态变量或静态方法，可直接通过类调用（也建议通过类调用）。&lt;/p&gt;
&lt;h2 id=&quot;二.-static-变量&quot;&gt;二. static 变量&lt;/h2&gt;
&lt;p&gt;static变量随着类的加载而存在，随着类的消失而消失，当类被加载时，就会为静态变量在Java Heap中分配内存空间，可以通过【类.变量名】和【对象.变量名】的方式调用，建议直接使用【类.变量名】的方式，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {
    private String name;

    private static int eyeNum;

    public static int legNum = 2;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public static int getEyeNum() {
        return eyeNum;
    }

    public static void setEyeNum(int eyeNum) {
        Person.eyeNum = eyeNum;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    Person person = new Person();
    person.setEyeNum(25);

    Person person1 = new Person();
    person1.setEyeNum(28);
    System.out.println(person.getEyeNum());//28
    System.out.println(person1.getEyeNum());//28
    
    int legNum = person.legNum;
    System.out.println(legNum);//2
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的例子可以看出静态变量是对所有对象共享，一个对象对其值的改动，直接就会造成另一个对象取值的不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候使用static变量？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为共享变量使用，通常搭配final关键字一起使用，比如我们常用的字典类数据；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private static final String GENERAL_MAN = &quot;man&quot;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;减少对象的创建，比如在类开头的部分，定义Logger方法，用于异常日志采集&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private static Logger LOGGER = LogFactory.getLoggger(MyClass.class);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;始终返回同一变量，比如我们的单例模式。&lt;/p&gt;
&lt;h2 id=&quot;三.-static-方法&quot;&gt;三. static 方法&lt;/h2&gt;
&lt;p&gt;静态方法只能访问静态成员（静态变量、静态方法），而非静态方法既可访问静态方法也可访问非静态方法；因为静态成员优于对象而存在，因此无法调用和对象相关的关键字，如this,super，无法通过关键字访问对象资源。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {
    private String name;    
    private static int eyeNum;    
    public static int legNum = 2;    
    public String getName() {
        return name;    
    }    
    public void setName(String name) {
        this.name = name;    
    }    
    public static int getEyeNum() {
        System.out.println(name);//编译出错，name不可用
        return eyeNum;
    }    
    public static void setEyeNum(int eyeNum) {
        Person.eyeNum = eyeNum;        
        this.name = &quot;&quot;;//编译出错，this不可用
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;什么时候使用static方法？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;static方法一般用于与当前对象无法的工厂方法、工具方法。如Math.sqrt()，Arrays.sort()，StringUtils.isEmpty()等。&lt;/p&gt;
&lt;h2 id=&quot;四.-static-代码块&quot;&gt;四. static 代码块&lt;/h2&gt;
&lt;p&gt;static代码块相对于static变量和static方法来说使用不是那么广泛，但也算是比较常见的用法了，static代码块在加载一个类的时候最先执行，且只执行一次。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Map&amp;lt;String, String&amp;gt; timeTypes;
static {
    timeTypes = new HashMap&amp;lt;&amp;gt;();
    timeTypes.put(&quot;year&quot;, &quot;年&quot;);
    timeTypes.put(&quot;quarter&quot;, &quot;季&quot;);
    timeTypes.put(&quot;month&quot;, &quot;月&quot;);
    timeTypes.put(&quot;day&quot;, &quot;日&quot;);
    System.out.println(&quot;初始化1&quot;);
}
public static void main(String[] args) {
    System.out.println(&quot;初始化2&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;初始化1；

初始化2；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;什么时候使用static代码块？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般在进行初始化操作时，比如读取配置文件信息，获取当前服务器参数等&lt;/p&gt;
&lt;h2 id=&quot;五.-static内部类&quot;&gt;五. static内部类&lt;/h2&gt;
&lt;p&gt;定义一个内部类，加上static，就成为了一个static内部类，static只能修饰内部类，不能修饰顶级类，静态内部类在业务应用系统开发中使用的不多。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StaticCouter {
    private String str0 = &quot;hi&quot;;    //非静态变量    
    private static String str1 = &quot;hello&quot;;  //静态变量   
    static class StaticInnerClass{//静态内部类
        public void getMessage(){
            System.out.println(str0);//编译出错
            System.out.println(str1);
        }
    }    
    class NormalInnerClass{//非静态内部类
        public void getMessage(){
            System.out.println(str0);
            System.out.println(str1);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;静态内部类与非静态内部类有何异同？&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;不需要有指向外部类的引用&lt;/td&gt;
&lt;td&gt;必须通过外部类的new关键字引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;可定义普通变量和方法，也可定义静态变量和方法&lt;/td&gt;
&lt;td&gt;可定义普通变量和方法，不可定义静态变量和方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;可以调用外部类的静态成员，不能调用外部类的普通成员&lt;/td&gt;
&lt;td&gt;可调用外部类的普通成员和静态成员&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    //创建静态内部类实例    
    StaticInnerClass staticInnerClass = new StaticInnerClass();    
    //调用静态内部类方法    
    staticInnerClass.getMessage();    
    //创建静态内部类实例    
    StaticCouter.StaticInnerClass staticInnerClass1 = new staticCouter.StaticInnerClass();    
    //调用静态内部类方法
    staticInnerClass1.getMessage();
    //创建普通内部类实例
    StaticCouter.NormalInnerClass normalInnerClass = new StaticCouter().new NormalInnerClass();
    //调用普通内部类方法
    normalInnerClass.getMessage();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六.-static包内导入&quot;&gt;六. static包内导入&lt;/h2&gt;
&lt;p&gt;这个概念不太好理解，举个例子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    int[] arra = {1,4,5,7};
    Arrays.sort(arra);
    Arrays.asList(arra);
    Arrays.fill(arra, 6);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;static包导入目的就是去掉重复的Arrays类名调用&lt;/p&gt;
&lt;p&gt;通过在顶部引入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import static java.util.Arrays.*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;即可把Arrays类中所有的静态变量，方法，内部类等都引入当前类中，调用时直接调用sort(arra)，asList(arra)，&lt;/p&gt;
&lt;p&gt;java5后引入的，不常用，调用类方法时会比较简单，但可读性不好，慎用。&lt;/p&gt;
&lt;h2 id=&quot;七.-总结&quot;&gt;七. 总结&lt;/h2&gt;
&lt;p&gt;static是java中很常用的一个关键字，使用场景也很多，本文主要介绍了它的五种用法，static变量，static方法，static代码块，static内部类，static包内导入，若有不对之处，请批评指正，望共同进步，谢谢！&lt;/p&gt;
</description>
<pubDate>Sun, 23 Jun 2019 23:53:00 +0000</pubDate>
<dc:creator>工匠初心</dc:creator>
<og:description>static是java中很常用的一个关键字，使用场景也很多，本文主要介绍了它的五种用法，static变量，static方法，static代码块，static内部类，static包内导入，在一定环境下使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LiaHon/p/11075178.html</dc:identifier>
</item>
</channel>
</rss>