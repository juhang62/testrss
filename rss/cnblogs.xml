<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Shell编程_day3--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/10227142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/10227142.html</guid>
<description>
&lt;h2&gt;本节内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. shell流程控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. for语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. while语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. break和continue语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. case语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. shell编程高级实战&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;shell流程控制&lt;/h2&gt;

&lt;p&gt;流程控制是改变程序运行顺序的指令。linux shell有一套自己的流程控制语句，其中包括条件语句(if)，循环语句(for,while)，选择语句(case)。下面我将通过例子介绍下，各个语句使用方法&lt;/p&gt;

&lt;h2&gt;if语句&lt;/h2&gt;

&lt;p&gt;格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
格式：&lt;span&gt;if&lt;/span&gt; list; then list; [ elif list; then list; ] ... [ &lt;span&gt;else&lt;/span&gt; list; ] fi
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1.1 单分支&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; 条件表达式; then&lt;br/&gt;命令&lt;br/&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
N&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $N -gt &lt;span&gt;5&lt;/span&gt;&lt;span&gt; ]; then
　　echo yes
fi

# bash test.sh
yes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1.2 双分支&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; 条件表达式; then
　　命令
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
　　命令
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实例1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
N&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $N -lt &lt;span&gt;5&lt;/span&gt;&lt;span&gt; ]; then
　　echo yes
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
　　echo no
fi

# bash test.sh
no&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实例2：判断crond进程是否正在运行&lt;/p&gt;
&lt;p&gt;-v: 表示取反&lt;/p&gt;
&lt;p&gt;-c: 即count，取代通常的输出，显示行数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
NAME&lt;/span&gt;=&lt;span&gt;crond
NUM&lt;/span&gt;=$(ps aux | grep $NAME | grep -&lt;span&gt;vc grep)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ $NUM -eq &lt;span&gt;1&lt;/span&gt;&lt;span&gt; ]; then
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$NAME running.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$NAME is not running!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实例3：检查主机是否在线&lt;/p&gt;
&lt;p&gt;-c:表示发送几次包&lt;/p&gt;
&lt;p&gt;-w:表示等待时间。当试图检测不可达主机时此选项很有用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ping -c &lt;span&gt;1&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.1&lt;/span&gt; &amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;; then &lt;br/&gt;　　echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NO!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if 语句可以直接对命令状态进行判断，就省去了获取$?这一步！&lt;/p&gt;

&lt;h3&gt;1.3 多分支&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; 条件表达式; then
　　命令
elif 条件表达式; then
　　命令
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
　　命令
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当不确定条件符合哪一个时，就可以把已知条件判断写出来，做相应的处理。&lt;/p&gt;

&lt;p&gt;实例1：&lt;/p&gt;
&lt;p&gt;$1:表示接受用户输入参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
N&lt;/span&gt;=$&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $N -eq &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ]; then
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eq 3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
elif [ $N &lt;/span&gt;-eq &lt;span&gt;5&lt;/span&gt;&lt;span&gt; ]; then
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eq 5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
elif [ $N &lt;/span&gt;-eq &lt;span&gt;8&lt;/span&gt;&lt;span&gt; ]; then
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eq 8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果第一个条件符合就不再向下匹配。&lt;/p&gt;

&lt;h2&gt;shell编程之if语句实战案例&lt;/h2&gt;

&lt;p&gt;需求：&lt;/p&gt;
&lt;p&gt;1. 完成用户输入文件或者目录的自动复制，并可以实现用户指定复制目标位置。&lt;/p&gt;
&lt;p&gt;2. 用户体验佳。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
read &lt;/span&gt;-p &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pls enter a file you want to copy:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; file
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -f $file -o -&lt;span&gt;d $file ];then
        read &lt;/span&gt;-p &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;do you want to copy the $file?(y/n)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; sure&lt;br/&gt;　　　　 confirm=$(echo ${sure} | tr A-Z a-z)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$confirm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ];then
                read &lt;/span&gt;-p &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;where do you want to copy?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; dire
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -&lt;span&gt;d $dire ];then
                        cp &lt;/span&gt;-&lt;span&gt;a $file $dire
                        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the $file copied to $dire&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the $dire is not exists&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                        exit &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                fi
        elif [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$confirm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ];then
                echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bye&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pls input y or n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        fi
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the $file is not exists&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;练习题1：尝试写一个shell简单的计算器，实现加减乘除。&lt;/p&gt;
&lt;p&gt;请输入一个数字： 7&lt;/p&gt;
&lt;p&gt;请输入运算符：+&lt;/p&gt;
&lt;p&gt;请输入第二个数字：7&lt;/p&gt;
&lt;p&gt;7+7=14&lt;/p&gt;

&lt;p&gt;练习题2：输入一个用户，用脚本判断判断该用户是否存在。&lt;/p&gt;

&lt;h2&gt;for语句&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
格式：&lt;span&gt;for&lt;/span&gt; name [ [ &lt;span&gt;in&lt;/span&gt; [ word ... ] ] ; ] &lt;span&gt;do&lt;/span&gt; list ; done
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; 变量名 &lt;span&gt;in&lt;/span&gt; 取值列表; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
　　命令
done&lt;p&gt;或者&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;  for 变量名 in 取值列表&lt;/p&gt;
&lt;p&gt;  do&lt;/p&gt;
&lt;p&gt;　　命令&lt;/p&gt;
&lt;p&gt;  done&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;实例1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; {&lt;span&gt;1&lt;/span&gt;..&lt;span&gt;3&lt;/span&gt;}; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
　　echo $i
done

# bash test.sh
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实例2：计算100以内偶数和&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
sum&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; `seq &lt;span&gt;2&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        let sum&lt;/span&gt;+=$i&lt;span&gt;
done
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$sum&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;shell编程之for语句实战案例&lt;/h2&gt;

&lt;p&gt;需求：&lt;/p&gt;
&lt;p&gt;1. 批量检查当前教室主机是否在线&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
ip&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; {&lt;span&gt;1&lt;/span&gt;..&lt;span&gt;255&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    ping &lt;/span&gt;-c &lt;span&gt;1&lt;/span&gt; -w &lt;span&gt;1&lt;/span&gt; $ip$i &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; [ $? -eq &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ];then
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$ip$i在线！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$ip$i不在线！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    fi

done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 练习题1：计算100以内的奇数和&lt;/p&gt;

&lt;h2&gt;while语句&lt;/h2&gt;

&lt;p&gt;条件为真就进入死循环；条件为假就退出循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
格式：&lt;span&gt;while&lt;/span&gt; list; &lt;span&gt;do&lt;/span&gt; list; done
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt; 条件表达式; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    命令
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实例1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
N&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; [ $N -lt &lt;span&gt;5&lt;/span&gt; ]; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
　　let N&lt;/span&gt;++&lt;span&gt;
　　echo $N
done

# bash test.sh
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当条件表达式为 false 时，终止循环。&lt;/p&gt;

&lt;p&gt;实例2：条件表达式为 true，将会产生死循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; [ &lt;span&gt;1&lt;/span&gt; -eq &lt;span&gt;1&lt;/span&gt; ]; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也可以条件表达式直接用 true：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;死循环有什么作用那？&lt;/p&gt;
&lt;p&gt;可以用来后台运行检测脚本，如下是是一个检测脑裂的脚本&lt;/p&gt;
&lt;p&gt;我们只需要在命令行中输入 nohup bash naolie.sh &amp;amp; 即可在后台持续运行该脚本&lt;/p&gt;
&lt;p&gt;例子1：检测脑裂&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        ip&lt;/span&gt;=`ip a s eth0 | awk -F &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; +&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NR==4{print $3}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; | awk -F &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; | awk -F &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $4}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;`&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        ping &lt;/span&gt;-c &lt;span&gt;3&lt;/span&gt; -i &lt;span&gt;1&lt;/span&gt; -W &lt;span&gt;1&lt;/span&gt; &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.166&lt;/span&gt; &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; [ $? -eq &lt;span&gt;0&lt;/span&gt; ] &amp;amp;&amp;amp; [ $ip = &lt;span&gt;1001&lt;/span&gt;&lt;span&gt; ];then
                echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;happed naolie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;everything is ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        fi
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子2：检测终端数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    num&lt;/span&gt;=`who | wc -&lt;span&gt;l`
    echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前打开终端数量为：$num&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    sleep &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要想使用 while 循环逐行读取 a.txt 文件，有三种方式：&lt;/p&gt;

&lt;p&gt;方式 1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
cat .&lt;/span&gt;/a.txt | &lt;span&gt;while&lt;/span&gt; read LINE; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
　　echo $LINE
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; read LINE; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
　　echo $LINE
done &lt;/span&gt;&amp;lt; ./a.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式3:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
exec &amp;lt; ./&lt;span&gt;a.txt    # 读取文件作为标准输出
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; read LINE; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
　　echo $LINE
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与 while 关联的还有一个 until 语句，它与 while 不同之处在于，是当条件表达式为 false 时才循环，实际使用中比较少，这里不再讲解。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
n&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
until [ $n &lt;/span&gt;-eq &lt;span&gt;5&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        let n&lt;/span&gt;++&lt;span&gt;
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;break和continue语句&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;break 是终止循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;continue 是跳出当前循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例 1：在死循环中，满足条件终止循环&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
N&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    let N&lt;/span&gt;++
        &lt;span&gt;if&lt;/span&gt; [ $N -eq &lt;span&gt;5&lt;/span&gt;&lt;span&gt; ]; then
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        fi
    echo $N
done

# bash test.sh
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;            
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;里面用了 if 判断，并用了 break 语句，它是跳出循环。与其关联的还有一个 continue 语句，它是跳出本次循环。&lt;/p&gt;

&lt;p&gt;示例 2：举例子说明 continue 用法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
N&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; [ $N -lt &lt;span&gt;5&lt;/span&gt; ]; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    let N&lt;/span&gt;++
        &lt;span&gt;if&lt;/span&gt; [ $N -eq &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ]; then
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
        fi
    echo $N
done

# bash test.sh
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当变量&lt;/span&gt; N 等于 3 时，continue 跳过了当前循环，没有执行下面的 echo。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;continue 与 break 语句只能循环语句中使用。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;case语句&lt;/h2&gt;

&lt;p&gt;case 语句一般用于选择性来执行对应部分块命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;case&lt;/span&gt; 模式名    &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
模式 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
　　命令
　　;;
模式 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
　　命令
　　;;
&lt;/span&gt;*&lt;span&gt;)
　　不符合以上模式执行的命令
esac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每个模式必须以右括号结束，命令结尾以双分号结束，最后一个模式不需要添加;;。&lt;/p&gt;

&lt;p&gt;示例1：根据位置参数匹配不同的模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; $&lt;span&gt;1&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
start)
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　;;
stop)
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stop.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　;;
restart)
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;restart.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　;;
&lt;/span&gt;*&lt;span&gt;)
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Usage: $0 {start|stop|restart}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
esac

# bash test.sh
Usage: test.sh {start&lt;/span&gt;|stop|&lt;span&gt;restart}

# bash test.sh start
start.

# bash test.sh stop
stop.

# bash test.sh restart
restart.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实例2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; $&lt;span&gt;1&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;9&lt;/span&gt;&lt;span&gt;])
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match number.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　;;
[a&lt;/span&gt;-&lt;span&gt;z])
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match letter.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　;;
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;|&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--help&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;help&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　;;
&lt;/span&gt;*&lt;span&gt;)
　　echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Input error!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　exit
esac

# bash test.sh &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
match number.

# bash test.sh a
match letter.

# bash test.sh &lt;/span&gt;-&lt;span&gt;h
help

# bash test.sh &lt;/span&gt;--&lt;span&gt;help
help&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模式支持的正则有：*、?、[ ]、[.-.]、|。后面有章节单独讲解 Shell 正则表达式。&lt;/p&gt;

&lt;h2&gt;shell编程高级实战&lt;/h2&gt;

&lt;h3&gt;实战1：写一个猜数字的小游戏&lt;/h3&gt;
&lt;p&gt;要求：&lt;/p&gt;
&lt;p&gt;1. 猜对退出&lt;/p&gt;
&lt;p&gt;2. 数字随机&lt;/p&gt;
&lt;p&gt;3. 使用体验佳&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
clear
num&lt;/span&gt;=&lt;span&gt;`echo $RANDOM`
count&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        let count&lt;/span&gt;++&lt;span&gt;
        read &lt;/span&gt;-p &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pls enter a num you guess:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; guessnum
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ $guessnum -&lt;span&gt;lt $num ]; then
                echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the num is so smaller!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        elif [ $guessnum &lt;/span&gt;-&lt;span&gt;gt $num ];then
                echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the num is so bigger!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        elif [ $guessnum &lt;/span&gt;-&lt;span&gt;eq $num ];then
                echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right!wonderful! &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
                &lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;good bye&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                exit
        fi
done
echo &lt;/span&gt;-e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[36myou guess $count times\033[0m&lt;/span&gt;&lt;span&gt;&quot; #允许对下面列出的加反斜线转义的字符进行解释.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;实战2：检测当前教室在线IP地址&lt;/h3&gt;
&lt;p&gt;要求：&lt;/p&gt;
&lt;p&gt;1.显示美观&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions
ip&lt;/span&gt;=&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; {&lt;span&gt;1&lt;/span&gt;..&lt;span&gt;255&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ping -c &lt;span&gt;1&lt;/span&gt; $ip$i &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt; ;then
                echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$ip$i&lt;/span&gt;&lt;span&gt;&quot;    #-n表示不输出行尾的换行符&lt;/span&gt;&lt;span&gt;
                success
                echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$ip$i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                failure
                echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        fi
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;实战3：检查软件包是否安装&lt;/h3&gt;
&lt;p&gt;要求:&lt;/p&gt;
&lt;p&gt;1.用户输入软件名即可进行查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
read &lt;/span&gt;-p &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pls enter a softname:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; softname
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rpm -q $softname &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt; ;then
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the $softname is already installed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the $softname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; not installed
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 19 Feb 2019 07:23:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>本节内容 1. shell流程控制 2. for语句 3. while语句 4. break和continue语句 5. case语句 6. shell编程高级实战 shell流程控制 流程控制是改变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/10227142.html</dc:identifier>
</item>
<item>
<title>针对 Ocelot 网关的性能测试 - myzony</title>
<link>http://www.cnblogs.com/myzony/p/10401298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myzony/p/10401298.html</guid>
<description>&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;目前我们项目是采用的 Ocelot 作为 API 网关，并且在其基础上结合 IdentityServer4 开发了一套 API 开放平台。由于部分项目是基于 ABP 框架进行开发的，接口的平均 QPS 基本是在 2K~3K /S 左右 (E3 1231 16G)。采用 Ocelot 进行请求转发之后，前端反馈接口调用速度变慢了，也没有太过在意，以为是项目接口的问题，一直在接口上面尝试进行优化。&lt;/p&gt;
&lt;p&gt;极限优化接口后仍然没有显著改善，故针对 Ocelot 的性能进行压力测试，得到的结果也是让我比较惊讶。&lt;/p&gt;
&lt;h2 id=&quot;二准备工作&quot;&gt;二、准备工作&lt;/h2&gt;
&lt;h3 id=&quot;测试项目准备&quot;&gt;2.1 测试项目准备&lt;/h3&gt;
&lt;p&gt;首先新建了一个解决方案，其名字为 &lt;code&gt;OcelotStudy&lt;/code&gt; ，其下面有三个项目，分别是两个 API 项目和一个网关项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201902/1203160-20190219151927182-652947288.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网关项目编写：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为 &lt;code&gt;OcelotStudy&lt;/code&gt; 项目引入 Ocelot 的 NuGet 包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201902/1203160-20190219151939634-313671963.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;OcelotStudy&lt;/code&gt; 项目的 &lt;code&gt;Program.cs&lt;/code&gt; 文件当中显式指定我们网关的监听端口。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;

namespace OcelotStudy
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    // 指定监听端口为 5000
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;()
                        .UseKestrel(x=&amp;gt;x.ListenAnyIP(5000));
                });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;Startup.cs&lt;/code&gt; 类当中注入 Ocelot 的服务，并应用 Ocelot 的中间件。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Ocelot.DependencyInjection;
using Ocelot.Middleware;

namespace OcelotStudy
{
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            // 禁用日志的控制台输出，防止由于线程同步造成的性能损失
            services.AddLogging(op =&amp;gt; op.ClearProviders());
            services.AddMvc();
            services.AddOcelot(new ConfigurationBuilder().AddJsonFile(&quot;Ocelot.json&quot;).Build());
        }

        public async void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            await app.UseOcelot();
            app.UseMvc();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;OcelotStudy&lt;/code&gt; 项目下建立 &lt;code&gt;Ocelot.json&lt;/code&gt; 文件，内容如下。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;ReRoutes&quot;: [
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/api/{everything}&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;DownstreamHostAndPorts&quot;: [
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 6000
        },
        {
          &quot;Host&quot;: &quot;localhost&quot;,
          &quot;Port&quot;: 7000
        }
      ],
      &quot;UpstreamPathTemplate&quot;: &quot;/{everything}&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot;, &quot;Post&quot; ],
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot;
      }
    }
  ],
  &quot;GlobalConfiguration&quot;: {
    // &quot;BaseUrl&quot;: &quot;https://api.yilezhu.cn&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试项目的编写：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个测试项目的监听端口分别为 &lt;code&gt;6000&lt;/code&gt; 与 &lt;code&gt;7000&lt;/code&gt; ，都建立一个 &lt;code&gt;ValuesController&lt;/code&gt; 控制器，返回一个字符串用于输出当前请求的 API 服务器信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ApiService01&lt;/code&gt; 的文件信息：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Mvc;

namespace ApiService01.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class ValuesController : ControllerBase
    {
        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;string&amp;gt; Get()
        {
            return &quot;当前请求的 API 接口是 1 号服务器。&quot;;
        }

        // GET api/values/5
        [HttpGet(&quot;{id}&quot;)]
        public ActionResult&amp;lt;string&amp;gt; Get(int id)
        {
            return &quot;value&quot;;
        }

        // POST api/values
        [HttpPost]
        public void Post([FromBody] string value)
        {
        }

        // PUT api/values/5
        [HttpPut(&quot;{id}&quot;)]
        public void Put(int id, [FromBody] string value)
        {
        }

        // DELETE api/values/5
        [HttpDelete(&quot;{id}&quot;)]
        public void Delete(int id)
        {
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ApiService02&lt;/code&gt; 的文件信息：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Mvc;

namespace ApiService02.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class ValuesController : ControllerBase
    {
        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;string&amp;gt; Get()
        {
            return &quot;当前请求的 API 接口是 2 号服务器。&quot;;
        }

        // GET api/values/5
        [HttpGet(&quot;{id}&quot;)]
        public ActionResult&amp;lt;string&amp;gt; Get(int id)
        {
            return &quot;value&quot;;
        }

        // POST api/values
        [HttpPost]
        public void Post([FromBody] string value)
        {
        }

        // PUT api/values/5
        [HttpPut(&quot;{id}&quot;)]
        public void Put(int id, [FromBody] string value)
        {
        }

        // DELETE api/values/5
        [HttpDelete(&quot;{id}&quot;)]
        public void Delete(int id)
        {
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;他们两个的 &lt;code&gt;Startup.cs&lt;/code&gt; 与 &lt;code&gt;Program.cs&lt;/code&gt; 文件内容基本一致，区别只是监听的端口分别是 &lt;code&gt;6000&lt;/code&gt; 和 &lt;code&gt;7000&lt;/code&gt; 而已。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;

namespace ApiService02
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
                    webBuilder.UseKestrel(x =&amp;gt; x.ListenAnyIP(6000)); // 或者 7000
                });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace ApiService02
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            // 禁用日志的控制台输出，防止由于线程同步造成的性能损失
            services.AddLogging(op =&amp;gt; op.ClearProviders());
            services.AddMvc();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            app.UseRouting(routes =&amp;gt; { routes.MapApplication(); });
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上三个项目都采用 &lt;code&gt;Release&lt;/code&gt; 版本进行发布。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet publish -c Release&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ApiService01 部署在单独的 E3 1231 v3 16G DDR3 服务器。&lt;/p&gt;
&lt;p&gt;ApiService02 部署在单独的 i3-7100 16G DDR4 服务器。&lt;/p&gt;
&lt;p&gt;OcelotStudy 部署在单独的 E3 1231 v3 16G DDR3 服务器。&lt;/p&gt;
&lt;h2 id=&quot;三开始测试&quot;&gt;三、开始测试&lt;/h2&gt;
&lt;p&gt;这里我使用的是 &lt;strong&gt;&lt;a href=&quot;https://github.com/wg/wrk&quot;&gt;WRK&lt;/a&gt;&lt;/strong&gt; 来进行压力测试，OcelotStudy 网关项目的 IP 地址为 &lt;code&gt;172.31.61.41:5000&lt;/code&gt; ，故使用以下命令进行测试。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./wrk -t 10 -c 10000 -d 20s --latency --timeout 3s &quot;http://172.31.61.41:5000/values&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201902/1203160-20190219151953192-702502837.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我将 ApiService01 项目放在网关的服务器，直接调用 ApiService01 的接口，其压力测试情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201902/1203160-20190219152003124-785012670.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四结语&quot;&gt;四、结语&lt;/h2&gt;
&lt;p&gt;最后 Ocelot 的 QPS 结果为：&lt;code&gt;3461.53&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;直接请求 API 接口的 QPS 结果为：&lt;code&gt;38874.50&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样的结果让我感到很意外，不知道是由于 Ocelot 实现机制的原因，还是我的使用方法不对。这样的性能测试结果数据对于 API 网关来说确实不太好看，但也希望今后 Ocelot 能够继续努力。&lt;/p&gt;
&lt;p&gt;如果大家对于我的测试方式有疑问的话，可以在评论区指出，我将按照你所提供的方法再次进行测试。&lt;strong&gt;(PS: 我也不想换啊，多希望是我测错了)&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 07:20:00 +0000</pubDate>
<dc:creator>myzony</dc:creator>
<og:description>一、背景 目前我们项目是采用的 Ocelot 作为 API 网关，并且在其基础上结合 IdentityServer4 开发了一套 API 开放平台。由于部分项目是基于 ABP 框架进行开发的，接口的平</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myzony/p/10401298.html</dc:identifier>
</item>
<item>
<title>Java内存模型JMM 高并发原子性可见性有序性简介 多线程中篇（十） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10401193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10401193.html</guid>
<description>&lt;h3&gt;&lt;span&gt;JVM运行时内存结构回顾&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在JVM相关的介绍中，有说到JAVA运行时的内存结构，简单回顾下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整体结构如下图所示，大致分为五大块&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150914516-1355050672.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_35d&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150915325-1166551198.png&quot; alt=&quot;image_5c6b9b5a_35d&quot; width=&quot;1065&quot; height=&quot;493&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;而对于方法区中的数据，是属于所有线程共享的数据结构&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150916596-1246408886.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_1104&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150917950-143369415.png&quot; alt=&quot;image_5c6b9b5a_1104&quot; width=&quot;658&quot; height=&quot;468&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;而对于虚拟机栈中数据结构，则是线程独有的，被保存在线程私有的内存空间中，所以这部分数据不涉及线程安全的问题&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150918548-135587293.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_3920&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150919185-466718342.png&quot; alt=&quot;image_5c6b9b5a_3920&quot; width=&quot;574&quot; height=&quot;365&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不管是堆还是栈，他们都是保存在主内存中的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;线程堆栈包含正在执行的每个方法的所有局部变量（调用堆栈上的所有方法）。线程只能访问它自己的线程堆栈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。因此，每个线程都有自己的每个局部变量的版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;局部变量可以是基本类型&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;在这种情况下，很显然它完全保留在线程堆栈上&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;局部变量也可以是对象的引用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这种情况下，局部变量本身仍旧是在线程堆栈上，但是所指向的对象本身却是在堆中的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很显然，所有具有对象引用的线程都可以访问堆上的对象，尽管是多个局部变量（引用），但是实际上是同一个对象，所以如果这个对象有成员变量，那么将会出现数据安全问题。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150920624-1435876192.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_7e07&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150922704-1808673815.png&quot; alt=&quot;image_5c6b9b5a_7e07&quot; width=&quot;512&quot; height=&quot;419&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上图所示，两个线程，localVariable1并 localVariable2两个局部变量位于不同的线程，但是同时指向的是Object3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;简单说，从上面可以看得出来，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在Java中所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于多线程的线程安全问题，根本在于共享数据的读写。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;JMM（Java内存模型）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java 内存模型作为JVM的一种抽象内存模型，屏蔽掉各种硬件和操作系统的内存差异，达到跨平台的内存访问效果。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java语言规范定义了一个统一的内存管理模型JMM(Java Memory Model)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不管是堆还是栈，数据都是保存在主存中的，整个的内存，都只是物理内存的一部分，也就是操作系统分配给JVM进程的那一部分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这部分内存按照运行区域的划分规则进行了区域划分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行时内存区域的划分，可以简单理解为空间的分配，比如一个房间多少平，这边用于衣帽间，那边用于卧室，卧室多大，衣帽间多大&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;而对于内存的访问，规定Java内存模型分为主内存，和工作内存；工作内存就是线程私有的部分，主内存是所有的线程所共享的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;每条线程自己的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，所有的工作都是在工作内存这个操作台上，线程并不能直接操作主存，也不能访问其他线程的工作内存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你划分好了区域，比如有的地方用于存放局部变量，有的地方用于存放实例变量，但是这些数据的存取规则是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;换句话说，如何正确有效的进行数据的读取？显然光找好地方存是不行的，怎么存？怎么读？怎么共享？这又是另外的一个很复杂的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如上面的两个线程对于Object3的数据读取顺序、限制都是什么样子的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以内存区域的分块划分和工作内存与主存的交互访问是两个不同的维度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文档如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在对JMM进行介绍之前，先回想下计算机对于数据的读取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据本质上是存放于主存（最终是存放于磁盘）中的，但是计算却又是在CPU中，很显然他们的速度有天壤之别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以在计算机硬件的发展中，出现了缓存（一级缓存、二级缓存），借助于缓存与主存进行数据交互，而且现代计算机中已经不仅仅只是有一个CPU&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个简单的示意图如下&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150923903-1726274706.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_264f&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150924918-863024882.png&quot; alt=&quot;image_5c6b9b5a_264f&quot; width=&quot;605&quot; height=&quot;458&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于访问速度来说，寄存器--缓存--主存  依次递减，但是空间却依次变大&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了缓存，CPU将不再需要频繁的直接从主存中读取数据，性能有了很大程度的提高（当然，如果需要的数据不在缓存中，那么还是需要从主存中去读取数据，是否存在，被称为缓存的命中率，显然，命中率对于CPU效率有很大影响）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在速度提高的同时，很显然，出现了一个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果两个CPU同时对主存中的一个变量x （值为1）进行处理，假设一个执行x+1 另外一个执行x-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果其中一个处理后另一个才开始读取，显然并没有什么问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果最初缓存中都没有数据或者说一个CPU处理过程中还没来得及将缓存写入主存，另一个CPU开始进行处理，那么最后的结果将会是不确定的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这个问题被称为：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;缓存一致性问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说：对于多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于缓存一致性的更多信息可以查阅&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;百度百科&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;缓存一致性（Cache Coherency）入门&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;缓存、缓存算法和缓存框架简介&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总之，多个CPU，大家使用同一个主存，但是各自不同的缓存，自然会有不一致的安全问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;再回到JMM上来，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Java Memory Model&lt;/strong&gt;&lt;/span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网址：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;文中有说到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The Java memory model specifies how the Java virtual machine works with the computer's memory (RAM). The Java virtual machine is a model of a whole computer so this model naturally includes a memory model - AKA the Java memory model.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java内存模型指定Java虚拟机如何与计算机内存(RAM)一起工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java虚拟机是整个计算机的模型，因此这个模型自然包括一个内存模型——也就是Java内存模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于多线程场景下，对于线程私有的数据是本地的，这个无可置疑，但是对于共享数据，前面已经提到，也是“私有的”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为每个线程对于共享数据，都会读取一份拷贝到本地内存中（也是线程私有的内存），所有的工作都是在本地内存这个操作台上进行的，如下图所示 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这本质就是一种&lt;span&gt;&lt;strong&gt;read-modify-write&lt;/strong&gt;&lt;/span&gt;模式，所以必然有线程安全问题的隐患&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150925867-1724715948.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_7c72&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150926857-1086018593.png&quot; alt=&quot;image_5c6b9b5a_7c72&quot; width=&quot;607&quot; height=&quot;449&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;与计算机硬件对于主存数据的访问是不是很相似？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;需要注意的是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;此处的主存并不是像前面硬件架构中的主存（RAM），是一个泛指&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，保存共享数据的地方&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，可能是主存也可能是缓存，总之是操作系统提供的服务，在JMM中可以统一认为是主存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的本地内存，就好似对于CPU来说的缓存一样，很显然，也会有一致性方面的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果两个线程之间不是串行的，必然对于数据处理后的结果会出现不确定性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以JMM规范到底是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;他其实就是JVM内部的内存数据的访问规则，线程进行共享数据读写的一种规则，在JVM内部，多线程就是这么读取数据的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的数据是如何设置到上图中“主存”这个概念中的？本地内存如何具体的与主存进行交互的？这都是操作系统以及JVM底层实现层面的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单纯的对于多线程编程来说，就不用管什么RAM、寄存器、缓存一致性等等问题，就只需要知道：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据分为两部分，共享的位于主存，线程局部的位于私有的工作内存，所有的工作都是在工作内存中进行的，也就意味着有“读取-拷贝-操作-回写”这样一个大致的过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然人家叫做JVM  java虚拟机，自然是五脏俱全，而且如果不能做到统一形式的内存访问模型，还叫什么跨平台？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果把线程类比为CPU，工作内存类比寄存器、缓存，主存类比为RAM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么JMM就相当于解决硬件缓存一致性问题的、类似的一种解决Java多线程读写共享数据的协议规范&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说，如果要设计正确的并发程序，了解Java内存模型非常重要。Java内存模型指定了不同线程如何以及何时可以看到其他线程写入共享变量的值，以及如何在必要时同步对共享变量的访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以再次强调，单纯的从多线程编程的角度看，记住下面这张图就够了！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以再次强调，单纯的从多线程编程的角度看，记住下面这张图就够了！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程局部数据自己独有，共享数据会读取拷贝一份到工作内存，操作后会回写到主存&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150927578-1543547641.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_7c72[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150928674-824203629.png&quot; alt=&quot;image_5c6b9b5a_7c72[1]&quot; width=&quot;607&quot; height=&quot;449&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;换一个说法，可以认为JMM的核心就是用于解决线程安全问题的，而线程安全问题根本就是对于共享数据的操作，所以说JMM对于数据操作的规范要求，本质也就是多线程安全问题的解决方案（缓存一致性也是数据安全的解决方案）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说理解了可能出现问题的原因与场景，就了解了线程安全的问题，了解了问题，才能理解解决方案，那多线程到底有哪些主要的安全问题呢？&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;竞争场景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;线程安全问题的本质就是共享数据的访问，没有共享就没有安全问题，所以说有时干脆一个类中都没有成员变量，也就避免了线程安全问题，但是很显然，这只是个别场景下适合，如果一味如此，就是因噎废食了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果对于数据的访问是串行的，也不会出现问题，因为不存在竞争，但是很显然，随着计算机硬件的升级，多核处理器的出现，并发（并行）是必然，你不能为了安全就牺牲掉性能，也是一种因噎废食&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以换一个说法，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;为何会有线程安全问题？是因为对于共享数据的竞争访问！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常见的两种竞争场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;read-modify-write（读-改-写）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;check-then-act（检查后行动）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;read-modify-write（读-改-写）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;read-modify-write（读-改-写）可以简单地分为三个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;读取数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;修改数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;回写数据&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;很显然，如果多个线程同时进行，将会出现不可预知的后果，假设两个线程，A和B，他们的三个步骤为A1，A2，A3  和 B1，B2，B3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果按照A1，A2，A3，B1，B2，B3 或者 B1，B2，B3，A1，A2，A3的顺序，并不会出现问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果是交叉进行，比如A1，A2，B1，B2，B3，A3，那么就会出现问题，B对数据的写入被覆盖了！&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;check-then-act（检查后行动）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if（x &amp;gt;1）{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//do sth....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x--；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果A线程条件满足后，还没有继续进行，此时B线程开始执行，条件判断后满足继续执行，执行后x的值并不满足条件了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这也是一种常见的线程安全问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很显然，单线程情况下，或者说所有的变量全部都是局部变量的话，不会出现问题，否则就很可能出现问题（线程安全问题并不是必然出现的，长时间不出问题也很可能）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于线程安全的问题主要分为三类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;原子性&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可见性&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;有序性&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;原子 Atomic，意指不可分割，也就是作为一个整体，要么全部执行，要么不会执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于共享变量访问的一个操作，如果对于除了当前执行线程以外的任何线程来说，都是不可分割的，那么就是具有原子性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简言之，对于别的线程而言，他要么看到的是该线程还没有执行的情况，要么就是看到了线程执行后的情况，不会出现执行一半的场景，简言之，其他线程永远不会看到中间结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生活中有一个典型的例子，就是ATM机取款&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管中间有很多的工作，比如账户扣款，ATM吐出钞票等，但是从取钱的角度来看，对于用户却是不可分割的一个过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要么，取钱成功了，要么取款失败了，对于共享变量也就是账户余额来说，要么会减少，要么不变，不会出现钱去了余额不变或者余额减少，但是却没有看到钱的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然是原子操作，既然是不可分割的，那么就是要么做了，要么没做，不会中间被耽搁，最终的结果看起来就好似串行的执行一样，不会出现线程安全问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java中有两种方式实现原子性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一种是使用锁机制，锁具有排他性，也就是说它能够保证一个共享变量在任意一个时刻仅仅被一个线程访问，这就消除了竞争；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;另外一种是借助于处理器提供的专门的CAS指令（compare-and-swap）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Java中，long和double以外的任何类型的变量的写操作都是原子操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是基础类型（byte int short char float boolean）以及引用类型的变量的写操作都是原子的，由Java语言规范规定，JVM实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于long和double，64位长度，如果是在32位机器上，写操作可能分为两个步骤，分别处理高低32位，两个步骤就打破了原子性，可能出现数据安全问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有一点需要注意的是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;原子操作+原子操作，并非仍旧是原子操作&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a=1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b=1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很显然，都是原子操作，但是在a=1执行后，如果此时另外的线程过来读取数据，会读取到a=1，而b却是没设置的中间状态&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;可见性&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，甚至永远也无法读取到这个更新的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是线程安全问题的另外一个表现形式:可见性(Visibility )&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;130.66766096762&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该更新的结果，那么就称这个线程对该共享变量的更新对其他线程可见，否则就称这个线程对该共享变量的更新对其他线程不可见。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;简言之，如果一个线程对共享数据做出了修改，而另外的线程却并没有读取到最新的结果，这是有问题的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据，通常也是不被希望的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么会出现可见性问题？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因为数据本质是要从主存存取的，但是对于线程来说，有了工作内存，这个私有的工作台，也就是read-modify-write模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即使线程正确的处理了结果，但是却没有及时的被其他的线程读取，而别人却读取了错误的结果（旧数据），这是一个很大的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以此处也可以看到，如果仅仅是保障原子性，对于线程安全来说，完全是不够的（有些场景可能足够了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原子性保障了不会读取到中间结果，要么是结束要么是未开始，但是如果操作结束了，这个结果真的就能看到么？所以还需要可见性的保障&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;有序性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;关于有序性，首先要说下重排序的概念，如果不曾有重排序，那么也就不涉及这方面的问题了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如下面两条语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a=1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b=2；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在源代码中是有顺序的，经过编译后形成指令后，也必然是有顺序的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一个线程中从代码执行的角度来看，也总是有先后顺序的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如上面两条语句，a的赋值在前，b的赋值在后，但是实际上，这种顺序是没有保障的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处理器可能并不会完全按照已经形成的指令（目标代码）顺序执行，这种现象就叫做重排序&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;为什么要重排序？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;重排序是对内存访问操作的一种优化，他可以在不影响单线程程序正确性的前提下进行一定的调整，进而提高程序的性能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;但是对于多线程场景下，就可能产生一定的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，重排序导致的问题，也&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不是必然出现的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，编译器进行编译时，处理器进行执行时，都有可能发生重排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先声明几个概念&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;源代码顺序，很明显字面意思就是源代码的顺序&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;程序顺序，源码经过处理后的目标代码顺序（解释后或者JIT编译后的目标代码或者干脆理解成源代码解析后的机器指令）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行顺序，处理器对目标代码执行时的顺序&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;感知顺序，处理器执行了，但是别人看到的并不一定就是你执行的顺序，因为操作后的数据涉及到数据的回写，可能会经过寄存器、缓存等，即使你先计算的a后计算的b，如果b先被写回呢？这就是感知顺序，简单说就是别人看到的结果&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在此基础上，可以将重排序可以分为两种，指令重排序和存储重排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图来自《Java多线程编程实战指南-核心篇》&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150930244-1619236612.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_3147&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150930705-1348379339.png&quot; alt=&quot;image_5c6b9b5a_3147&quot; width=&quot;1141&quot; height=&quot;262&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;编译器可能导致目标代码与源代码顺序不一致；即时编译器JIT和处理器可能导致执行顺序与程序顺序不一致；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存、缓冲器可能导致感知顺序不一致&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;指令重排序&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;不管是程序顺序与源代码顺序不一致还是执行顺序与程序顺序不一致，结果都是指令重排序，因为最终的效果就是源代码与最终被执行的指令顺序不一致&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示，不管是哪一段顺序被重拍了，最终的结果都是最终执行的指令乱序了&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150931381-245328336.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_407e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150932290-2046466003.png&quot; alt=&quot;image_5c6b9b5a_407e&quot; width=&quot;611&quot; height=&quot;215&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ps：Java有两种编译器，一种是Javac静态编译器，将源文件编译为字节码，代码编译阶段运行；JIT是在运行时，动态的将字节码编译为本地机器码（目标代码）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常javac不会进行重排序，而JIT则很可能进行重排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;此处不对为什么要重排序展开，简单说就是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;硬件或者编译器等为了能够更好地执行指令，提高性能，所做出的一定程度的优化，重排序也不是随随便便的就改变了顺序的，它具有一定的规则，叫做貌似串行语义&lt;span&gt;As-if-serial Semantics，也就是从单线程的角度保障不会出现问题，&lt;/span&gt;但是对于多线程就可能出现问题。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;貌似串行语义的规则主要是对于具有数据依赖关系的数据不会进行重排序，没有依赖关系的则可能进行重排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如下面的三条语句，c=a+b；依赖a和b，所以不会与他们进行重排序，但是a和b没有依赖关系，就可能发生重排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a=1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b=2；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c=a+b；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;存储重排序&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;为什么会出现执行一种顺序，而结果的写入是另外的一种顺序？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;前面说过，对于CPU来说并不是直接跟主存交互的，因为速度有天壤之别，所以有多级缓存，有读缓存，其实也有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;写缓存&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了缓存，也就意味着这中间就多了一些步骤，那么就可能即使严格按照指令的顺序执行，但是从结果上看起来却是乱序的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;指令重排序是一种动作，实际发生了，而存储重排序则是一种现象，从结果看出来的一种现象，其实本身并没有在执行上重拍，但是这也可能引起问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;如何保证顺序？&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;119.77791966566&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;貌似串行语义As-if-serial Semantics，只是保障单线程不会出问题，所以有序性保障，可以理解为，将貌似貌似串行语义As-if-serial Semantics扩展到多线程，在多线程中也不会出现问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;换句话说，有序性的保障，就是貌似串行语义在逻辑上看起来，有些必要的地方禁止重排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从底层的角度来看，是借助于处理器提供的相关指令&lt;/span&gt;&lt;span&gt;&lt;strong&gt;内存屏障&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;来实现的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于Java语言本身来说，Java已经帮我们与底层打交道，我们不会直接接触内存屏障指令，java提供的关键字synchronized和volatile，可以达到这个效果，保障有序性（借助于显式锁Lock也是一样的，Lock逻辑与synchronized一致）&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;happens-before 原则&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;关键字volatile和synchronized都可以保证有序性，他们都会告知底层，相关的处理需要保障有序，但是很显然，如果所有的处理都需要主动地去借助于这两个关键字去维护有序，这将是一件繁琐痛苦的事情，而且，也说到了重排序也并不是随意的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java有一个内置的有序规则，也就是说，对于重排序有一个内置的规则实现，你不需要自己去动脑子思考，动手去写代码，有一些有序的保障Java天然存在，简化了你对重排序的设计与思考&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个规则就叫做happens-before 原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果可以从这个原则中推测出来顺序，那么将会对他们进行有序性保障；如果不能推导出来，换句话说不与这些要求相违背，那么就可能会被重排序，JVM不会对有序性进行保障。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序次序规则(Program Order Rule)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可，仍旧可能发生重排序，但是得保证这个前提&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;43&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;管程锁定规则(Monitor Lock Rule)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个unlock操作先行发生于后面对同一个锁的 lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;volatile变量规则(Volatile Variable Rule)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程启动规则(Thread Start Rule)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread对象的start()方法先行发生于此线程的每一个动作。你必须得先启动一个线程才能有后续&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程终止规则(Thread Termination Rule)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程中的所有操作都先行发生于对此线程的终止检测，也就是说所有的操作肯定是要在线程终止之前的，终止之后就不能有操作了，可以通过Thread.join()方法结束、Thread. isAlive()的返回值等手段检测到线程已经终止执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程中断规则(Thread Interruption Rule)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，也就是你得先调用方法，才会产生中断，你不能别人发现中断信号了，你竟然你都还没调用interrupt方法，可以通过Thread.isinterrupted ()方法检测到是否有中断发生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对象终结规则(Finalizer Rule)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个对象的初始化完成(构造函数执行结束)先行发生于它的finalizeO方法的开始，先生后死，这个是必须的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;传递性(Transitivity)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果操作A先行发生于操作B,操作B先行发生于操作C,那就可以得出操作A先行发生于操作C的结论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;再次强调：对于happens-before规则，不需要做任何的同步限制，Java是天然支持的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《深入理解Java虚拟机：JVM高级特性与最佳实践》中有一个例子对于理解该原则有所帮助&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = &lt;span&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getValue() {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; value;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setValue(&lt;span&gt;int&lt;/span&gt; value) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;value = value;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;}&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设两个线程A和B，线程A先（在时间上先）调用了这个对象的setValue（1），接着线程B调用getValue方法，那么B的返回值是多少？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对照着hp原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不是同一个线程，所以不涉及：程序次序规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不涉及同步，所以不涉及：管程锁定规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有volatile关键字，所以不涉及：volatile变量规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有线程的启动，中断，终止，所以不涉及：线程启动规则，线程终止规则，线程中断规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有对象的创建于终结，所以不涉及：对象终结规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更没有涉及到传递性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以一条规则都不满足，所以，尽管线程A在时间上与线程B具有先后顺序，但是，却并不涉及hp原则，也就是有序性并不会保障，所以线程B的数据获取是不安全的！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如的确是先执行了，但是没有及时写入呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;简言之，时间上的先后顺序，并不代表真正的先行发生（hp），而且，先行发生（hp）也并不能说明时间上的先后顺序是什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这也说明，不要被时间先后迷惑，只有真正的有序了，才能保障安全&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;也就是要么满足hp原则了（天然就支持有序了），或者借助于volatile或者synchronized关键字或者显式锁Lock对他们进行保障（显式手动控制有序），才能保障有序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;happens-before是JMM的一个核心概念，因为对于程序员来说，希望一个简单高效最重要的是要易用的，易于理解的编程模型，但是反过来说从编译器和处理器执行的角度来看，自然是希望约束越少越好，没有约束，那么就可以高度优化，很显然两者是矛盾的，一个希望严格、简单、易用，另一个则希望尽可能少的约束；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;happens-before则相当于一个折中后的方案，二者的一个权衡，以上是基本大致的的一个规范，有兴趣的可以深入研究happens-before原则&lt;/strong&gt;&lt;/span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;48.430735930736&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;原子性、可见性、有序性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面说过，原子性保障了要么执行要么不执行，不会出现中间结果，但是即使原子了，不可分割了，但是是否对另外一个可见，是无法保障的，所以需要可见性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而有序性则是另外的线程对当前线程执行看起来的顺序，所以如果都不可见，何谈有序性，所以可见性是有序性的基础&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，有序性对于可见性是有影响的，比如某些操作本来在前，结果是可见的，但是重排序后，被排序到了后面，这就可能导致不可见，比如父线程的操作对子线程是可见的，但是如果有些位置顺序调整了呢？   &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Java内存区域的划分是对于主存的一种划分，存储的划分，而这个主存则是分配给JVM进程的内存空间，而JVM的这部分内存只是物理内存的一部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这部分内存有共享的主存储空间，还有一部分是线程私有的本地内存空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程所用到的所有的变量都位于线程的本地内存中，局部变量本身就在本地内存，而共享变量则会持有一份私有拷贝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程的操作台就是这个本地内存，既不能直接访问主存也不能访问其他线程本地内存，只能借助于主存进行交互&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JMM模型则是对于JVM对于内存访问的一种规范，多线程工作内存与主内存之间的交互原则进行了指示，他是独立于具体物理机器的一种内存存取模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;对于多线程的数据安全问题，三个方面，原子性、可见性、有序性是三个相互协作的方面，不是说保障了任何一个就万事大吉了，另外也并不一定是所有的场景都需要全部都保障才能够线程安全&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如volatile关键字只能保障可见性和有序性以及自身修饰变量的原子性，但是如果是一个代码段却并不能保障原子性，所以是一种弱的同步，而synchronized则可以从三个维度进行保障&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这三个特性也是JMM的核心，对相关的原则进行了规范，所以概括的说什么是JMM？他就只是一个规范概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java通过提供同步机制（synchronized、volatile）关键字借助于编译器、JVM实现，依赖于底层操作系统，对这些规范进行了实现，提供了对于这些特性的一个保障&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反复提到的下面的这个图就是JMM的基础结构，而延展出来的规范特性，就是基于这个结构，并且针对于多线程安全问题提出的一些解决方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要正确的使用提供的同步机制，就能够开发出正确的并发程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下图为结构基础，定义的线程私有数据空间与主存之间的交互原则&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150935455-950546177.png&quot;&gt;&lt;img title=&quot;image_5c6b9b5a_7c72[2]&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190219150939335-1039422725.png&quot; alt=&quot;image_5c6b9b5a_7c72[2]&quot; width=&quot;607&quot; height=&quot;449&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 19 Feb 2019 07:13:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>不得不看的JMM介绍，JMM不同于java运行时内存区域划分，本文从区域划分拓展到JMM，多线程必备的知识点，并且从原子性可见性有序性三个角度深入的分析了JMM的在这几个点涉及的部分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10401193.html</dc:identifier>
</item>
<item>
<title>k8s使用helm打包chart并上传到腾讯云TencentHub - 饭勺oO</title>
<link>http://www.cnblogs.com/fanshaoO/p/10401212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanshaoO/p/10401212.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文只涉及Helm的Chart操作，不会对其他知识进行过多描述。至于安装这块，麻烦自行百度吧，一大堆呢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在容器化的时代，我们很多应用都可以部署在docker，很方便，而再进一步，我们还有工具可以对docker进行编排，Kubernetes就是一个很好的工具。再再进一步，Kubernetes出现了helm，可以将多个服务更好的编排组合成一个应用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Helm&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Helm的作用相当于node.js下的npm，对于应用发布者而言，可以通过Helm打包应用，管理应用依赖关系，管理应用版本并发布应用到软件仓库。&lt;/p&gt;
&lt;p&gt;Helm 是一个命令行下的客户端工具。主要用于 Kubernetes 应用程序 Chart 的创建、打包、发布以及创建和管理本地和远程的 Chart 仓库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Chart&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;chart是helm的应用打包格式。chart是描述相关的一组Kubernetes资源的文件集合。单个chart可能用于部署简单的东西，比如memcached pod，或者一些复杂的东西，比如完整的具有HTTP服务，数据库，缓存等的Web应用程序堆栈。&lt;/p&gt;
&lt;p&gt;使用Helm创建Chart&lt;/p&gt;
&lt;p&gt;windows下使用cmd或者powershell都可以，这里我使用powershell，使用helm create命令创建一个wechat应用的chart。创建的目录结构如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219145902718-1508610559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chart.yaml&lt;/strong&gt;：描述chart的概要信息，name和version是必须项。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219145916461-721566994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;values.yaml&lt;/strong&gt;：chart支持在安装时跟据参数进行定制化配置，values.yaml则提供了这些配置参数的默认值。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219145934630-950819589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;templates目录&lt;/strong&gt;：各类Kubernetes资源的配置模板都放在这里。Helm会将valuees.yaml中的参数值注入模板中，生产标准的YAML配置文件。&lt;/p&gt;
&lt;p&gt;模板是Chart最重要部分，也是helm最强大的地方。模板增加了应用部署的灵活性，能够适用于不同的环境，虽然配置很复杂......&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;templates/NOTES.txt&lt;/strong&gt;：chart的简易使用文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;deployment.yaml，ingress.yaml，service.yaml&lt;/strong&gt;就是我们的模板了，当然我们可以把一个服务的配置模板用一个文件编写，不同的资源配置我们可以用三个横杠---来进行分割。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219150023172-1575045452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;helm采用了GO语法来编写chart，支持变量，对象，函数，流控制等功能。&lt;/p&gt;
&lt;p&gt;templates/_helpers.tpl：定义子模版，在模板中{{ include &quot;wechat.fullname&quot; . }}就是引用子模板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;编写自己的chart&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们编写一个自己的chart，没有那么复杂，只是chart的简单操作。这里我将我们服务两个微信服务（一个后台，一个UI）打包成一个chart。&lt;/p&gt;
&lt;p&gt;对于配置，这里教大家一个偷懒的方式，可以将现成服务的yaml配置直接拉下来，我们是使用腾讯云的容器服务，在已部署的服务中我们可以直接查看它的YAML配置，直接复制下来稍微改动即可。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219150104033-1958079926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我将一个服务的资源配置模板写在一个同一个yaml文件中，同时删除非必需的内容。剩下如下内容。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219150310287-789488131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而后我跟据需要将少数配置进行参数化，将需要参数化配置的内容写在values.yaml中即可。这里我只将iamge和ports进行参数化配置。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219150330290-55436252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219150411640-94315918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ui.yaml的配置同上，基本就算完成了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;将chart上传到TencentHub&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TencentHub上传Helm Chart有两种方式，一种是使用helm打包后网页直接上传chart包，另一种是使用helm命令行工具，使用命令helm push整个chart目录。这里我们选择后者。&lt;/p&gt;
&lt;p&gt;在上传之前我们需要：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.本地 Helm 客户端添加 Tencent Hub 的 repo。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用命令行输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
helm repo add mycharts https://hub.tencentyun.com/charts/mycharts --username myname --password mypassword
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; mycharts 替换为自己仓库的命名空间 (用户名或组织名)&lt;/li&gt;
&lt;li&gt; myname 替换为 Tencent Hub 账号用户名&lt;/li&gt;
&lt;li&gt; mypassword 替换为 Tencent Hub 账号密码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.安装Tencent Hub 的 helm-push 插件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用命令行输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
helm plugin install https://github.com/imroc/helm-push
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成后我们就可以上传Helm Chart了。&lt;/p&gt;
&lt;p&gt;使用命令&lt;/p&gt;
&lt;p&gt;上传文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
helm push ./myapp mycharts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传压缩包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
helm push myapp-1.0.1.tgz mychart 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传成功后在Tencent Hub即可看到我们上传的chart的信息了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190219150733252-1058167362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;结束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;好了，到这就结束了，接下来还有一篇写写腾讯云使用chart部署应用以及.net core使用k8s作为配置中心，如何读取configMap。以及中间遇到的一些坑吧......&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 07:11:00 +0000</pubDate>
<dc:creator>饭勺oO</dc:creator>
<og:description>本文只涉及Helm的Chart操作，不会对其他知识进行过多描述。至于安装这块，麻烦自行百度吧，一大堆呢。 在容器化的时代，我们很多应用都可以部署在docker，很方便，而再进一步，我们还有工具可以对d</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanshaoO/p/10401212.html</dc:identifier>
</item>
<item>
<title>云HBase发布全文索引服务,轻松应对复杂查询 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10401188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10401188.html</guid>
<description>&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont690018.i0.4f7fe5947mII1K&quot;&gt;云HBase发布了“全文索引服务”功能，自2019年01月25日后创建的云HBase实例，可以在控制台免费开启此“全文索引服务”功能。使用此功能可以让用户在HBase之上构建功能更丰富的搜索业务，不再局限于KV简单查询，不再苦恼于设计各种rowkey，不再后怕日益变化的HBase复杂查询业务。“全文索引服务”为云HBase增强查询能力而设计，自动同步数据，用户只需重点关注如何使用强大的检索功能来丰富自己的业务架构。&lt;/p&gt;
&lt;h3 id=&quot;1&quot;&gt;为什么要增强HBase的检索能力&lt;/h3&gt;
&lt;p&gt;我们在使用HBase的时候都会面临一个问题，就是设计HBase的rowkey。可尽管我们工程师是多么的优秀，整理罗列了所有业务检索需求，并裁剪折中了这样那样的业务，缺依然不能设计一个全能的rowkey来满足各种业务查询需求。&lt;br/&gt;例如在某物流管理系统中，我们需要对收件人姓名/手机/地址、寄件人姓名/手机/地址、运单编号/开始时间/结束时间、邮递员姓名/手机等条件，进行任意组合查询。这种复杂查询情况下，HBase原先的KV查询无法满足，尽管我们如何设计rowkey，都不能满足查询条件的任意性。另外，在这些查询中，可能会涉及到姓名/地址/手机号等条件的模糊查询，这也是HBase rowkey不能很好满足的。&lt;br/&gt;又例如在某新零售业务中，需要对商品标题或者描述内容进行关键字查询，在HBase中我们只能使用模糊查询来实现，但模糊查询在HBase中是比较低效的。类似这种标题/描述内容中进行关键字查询业务，比较合适使用分词查询，这个功能HBase都无法提供满足。另外，在新零售查询业务中，为了提高用户体验，经常会提高搜索结果进行分类统计的需求，例如我们在电商网站中，搜索关键字“时尚”，在显示匹配此关键字结果的商品中，按照 衣服、电子、日用等类型进行了分类统计匹配结果，这样用户就可以选择对应的大类进行二次查询，快速查询到用户想要的商品，从而提高了用户体验。像这个功能，HBase也无法满足。&lt;br/&gt;最终为了适应HBase系统的查询特点，对业务做了折中，只保留部分KV查询的业务，其他可以提高用户体验的各种查询业务被全部砍掉了。&lt;/p&gt;
&lt;p&gt;总结下来，我们列出来了几个使用HBase进行查询业务设计时碰到的痛点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无法满足任意条件组合查询&lt;/li&gt;
&lt;li&gt;不能高效支持模糊查询&lt;/li&gt;
&lt;li&gt;不支持关键字分词查询&lt;/li&gt;
&lt;li&gt;不能高效支持多维度的排序/分页&lt;/li&gt;
&lt;li&gt;不能对查询的结果集进行分类统计&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;2&quot;&gt;云HBase全文索引服务，增强HBase检索能力&lt;/h3&gt;
&lt;p&gt;全文索引服务是为了增强HBase查询能力而设计，使得HBase除了强大的KV能力外，更加丰富了它的在复杂条件查询下的能力，具体抽象出来以下几个场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;复杂条件任意查询&lt;/li&gt;
&lt;li&gt;多维度排序&lt;/li&gt;
&lt;li&gt;复杂条件分页&lt;/li&gt;
&lt;li&gt;分词关键字查询&lt;/li&gt;
&lt;li&gt;匹配结果集分类统计&lt;/li&gt;
&lt;li&gt;常用min/max/avg/sum等stats统计&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;云HBase全文索引服务使用简单，只需要DDL阶段建立索引，后续自动进行数据索引同步，架构如下：&lt;br/&gt;&lt;img title=&quot;_&quot; src=&quot;https://yqfile.alicdn.com/db10b72071945600ef010957def10bdc4cc1124f.png&quot; alt=&quot;_&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;3&quot;&gt;和自建的区别&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;云HBase启用全文索引&lt;/th&gt;
&lt;th&gt;自建HBase+indexer+solr&lt;/th&gt;
&lt;th&gt;HBase&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;简单rowkey查询&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;复杂查询&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;索引同步&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;乱序同步&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;———&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;强一致&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;———&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;xml动态列&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;———&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;另外，自建hbase+indexer+solr存在几个bug，导致很多用户反馈的自建这种架构丢数据现象；云HBase对此进行了许多bugfix和改进。&lt;/p&gt;
&lt;h3 id=&quot;4&quot;&gt;如何使用云HBase全文索引服务&lt;/h3&gt;
&lt;p&gt;云HBase全文索引服务的使用，启用此服务后，只需要简单DDL建立索引即可，插入同步无限管理，用户只需关注后续查询要使用HBase api/Solr api进行构建丰富的业务查询即可。下面我们来简单体验下整个流程。&lt;/p&gt;
&lt;h5 id=&quot;5&quot;&gt;开启服务&lt;/h5&gt;
&lt;p&gt;“全文索引服务”属于云HBase的免费扩展服务，自2019年1月25日后创建的云HBase实例控制台，实例左侧点击“全文索引服务”详情页进行服务开启即可，如下：&lt;br/&gt;&lt;img title=&quot;全文索引服务开启页面&quot; src=&quot;https://yqfile.alicdn.com/dbc4486a6bbd94f5bf434a228fe5fd8527fbfa80.png&quot; alt=&quot;全文索引服务开启页面&quot;/&gt;&lt;br/&gt;申请后的如下Solr访问地址以及WebUI连接，如图：&lt;br/&gt;&lt;img title=&quot;开通后页面&quot; src=&quot;https://yqfile.alicdn.com/74ca892dd1f1c964bb913b2547710de7738d9c83.png&quot; alt=&quot;开通后页面&quot;/&gt;&lt;br/&gt;其中solr zk地址即可构造cloud solr client进行访问，此访问客户端自带负载均衡功能。Solr WebUI访问方式与云HBase WebUI访问一致，第一次访问是设置好用户密码与白名单，然后直接点上面的链接即可跳转到Solr的WebUI。&lt;/p&gt;
&lt;h5 id=&quot;6&quot;&gt;建立索引&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;下载索引管理客户端工具&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;wget http://public-hbase.oss-cn-hangzhou.aliyuncs.com/installpackage/solr-7.3.1-ali-1.0.tgz
tar zxvf solr-&lt;span class=&quot;hljs-number&quot;&gt;7.&lt;span class=&quot;hljs-number&quot;&gt;3.&lt;span class=&quot;hljs-number&quot;&gt;1-ali-&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;span class=&quot;hljs-number&quot;&gt;0.tgz&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;修改solr-7.3.1-ali-1.0/bin/solr.in.sh文件的ZK_HOST如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;ZK_HOST=zk1:&lt;span class=&quot;hljs-number&quot;&gt;2181,zk2:&lt;span class=&quot;hljs-number&quot;&gt;2181,zk3:&lt;span class=&quot;hljs-number&quot;&gt;2181/solr&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zk地址即为上图控制台开通全文索引服务后的solr zk访问地址。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建HBase表，开启replication同步机制&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;create  &lt;span class=&quot;hljs-string&quot;&gt;'solrdemo',{NAME=&amp;gt;&lt;span class=&quot;hljs-string&quot;&gt;'info',  REPLICATION_SCOPE=&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;'1'}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;创建Solr表democollection&lt;br/&gt;第一步，修改并上传solrconfig.xml/schema，如果不需要修改，可使用demo默认config进行上传，如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;solr-7.3.1-ali-1.0/bin/solr zk upconfig &lt;span class=&quot;hljs-_&quot;&gt;-d _democonfig  -n democollection_config -z zk1:2181/solr&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步，使用刚上传的配置创建democollection，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;curl &lt;span class=&quot;hljs-string&quot;&gt;&quot;http://hostname:8983/solr/admin/collections?action=CREATE&amp;amp;name=democollection&amp;amp;numShards=1&amp;amp;replicationFactor=1&amp;amp;collection.configName=democollection_config&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中hostname可以使用master3-1中缀的zk hostname进行替换。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置HBase solrdemo表到Solr democollection表的字段映射索引关系&lt;br/&gt;第一步，编辑index_conf.xml配置映射关系，例如：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1.0&quot;&lt;span class=&quot;hljs-meta&quot;&gt;?&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;indexer &lt;span class=&quot;hljs-attr&quot;&gt;table=&lt;span class=&quot;hljs-string&quot;&gt;&quot;solrdemo&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;field &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;name_s&quot; &lt;span class=&quot;hljs-attr&quot;&gt;value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;info:q2&quot; &lt;span class=&quot;hljs-attr&quot;&gt;type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;string&quot;/&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;field &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;age_i&quot; &lt;span class=&quot;hljs-attr&quot;&gt;value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;info:q3&quot; &lt;span class=&quot;hljs-attr&quot;&gt;type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;int&quot;/&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;param &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;update_version_l&quot; &lt;span class=&quot;hljs-attr&quot;&gt;value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;/&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;indexer&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置描述了hbase表solrdemo的 info:q2 info:3 分别映射成solr democollection里面的name_s和age_i 字段。并指定以string解析info:q2 列保存到name_s字段中，以int解析info:q3 保存到age_i中。其中solr collection的name_s、age_i是何种类型，是根据solr collection的配置觉得，默认采用动态类型推断，即根据collection字段的名字后缀判断类型进行存储。常见类型_i、_s、_l、_b、_f、_d分别对应int/string/long/boolean/float/double。当然，用户也可以直接指定字段类型。最后一个update_version_l为固定写法，保存document级别的最新更新时间。&lt;br/&gt;第二步，使用工具将 index_conf.xml 设置关联hbase表solrdemo和solr表democollection的索引映射关系，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;solr-7.3.1-ali-1.0/bin/solr-indexer add  \
     -n demoindex  \
     &lt;span class=&quot;hljs-_&quot;&gt;-f indexer_conf.xml  \
     -c democollection&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此，我们就完成了索引的关系映射，随后正常插入hbase即可，就不需要关心索引同步，它会自动同步hbase solrdemo表的对应字段到solr democollection表的对应字段中。如上例映射如下：&lt;br/&gt;&lt;img title=&quot;77&quot; src=&quot;https://yqfile.alicdn.com/6f405bbd12d3087a068703204df446be78f66cba.png&quot; alt=&quot;77&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，HBase表的rowkey映射到Solr表里面的id字段。&lt;/p&gt;
&lt;h5 id=&quot;7&quot;&gt;查询检索&lt;/h5&gt;
&lt;p&gt;查询较为简单，依然完全兼容开源HBase API和Solr API的操作，根据业务使用solr进行条件查询，结果集中，id字段就是所有符合条件的hbase rowkey，我们只有这个id转换为rowkey，并使用HBase API读取属于这个行的原数据即可。流程图大致如下：&lt;br/&gt;&lt;img title=&quot;用户查询流程&quot; src=&quot;https://yqfile.alicdn.com/25239bc1de9429de96e78289a9d052044e556ed4.png&quot; alt=&quot;用户查询流程&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;8&quot;&gt;展望&lt;/h3&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;索引管理更简单易用&lt;/li&gt;
&lt;li&gt;SQL入口接入全文索引服务&lt;/li&gt;
&lt;li&gt;全文引擎新一代更高效副本机制&lt;/li&gt;
&lt;li data-spm-anchor-id=&quot;a2c4e.11153940.blogcont690018.i1.4f7fe5947mII1K&quot;&gt;除了异步索引，同步索引也会后续支持&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/690018?utm_content=g_1000041853&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 07:09:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>云HBase发布了“全文索引服务”功能，自2019年01月25日后创建的云HBase实例，可以在控制台免费开启此“全文索引服务”功能。使用此功能可以让用户在HBase之上构建功能更丰富的搜索业务，不再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10401188.html</dc:identifier>
</item>
<item>
<title>[翻译 EF Core in Action 1.8] MyFirstEfCoreApp应用程序设置 - liangshiwei</title>
<link>http://www.cnblogs.com/LiangSW/p/10400947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiangSW/p/10400947.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Entityframework Core in action是 &lt;code&gt;Jon P smith&lt;/code&gt; 所著的关于Entityframework Core 书籍。&lt;a href=&quot;https://www.manning.com/books/entity-framework-core-in-action&quot;&gt;原版地址&lt;/a&gt;. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;创建了.Net Core控制应用程序过后,现在可以编写EF Core代码了. 在编写数据库访问代码之前,你需要做两个重要的部分&lt;br/&gt;- EF Core将类映射到数据库中的表&lt;br/&gt;- 应用程序的DbContext,它是用于配置和访问数据库的主类&lt;/p&gt;
&lt;h2 id=&quot;映射到数据库中的类----book和author&quot;&gt;映射到数据库中的类 -- Book和Author&lt;/h2&gt;
&lt;p&gt;EF Core将类映射为数据库中的表. 因此你需要创建一个实体类,或者你已有一个数据库则需要匹配数据库表. 有很多的规则和配置(本书后面会介绍), 图1.4给出了映射到数据库表的实体类的一般格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201902/832799-20190219133128699-2089779371.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是&lt;code&gt;Author&lt;/code&gt;实体类的定义,它的结构与Book类相同,主键遵循EF Core命名约定(参见第6.3.15节). Book类有一个名为AuthorId的属性,EF Core将它视为外键,因为它与Author实体的主键同名&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
    public string WebUrl { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;应用程序中的dbcontext数据库上下文&quot;&gt;应用程序中的DbContext(数据库上下文)&lt;/h2&gt;
&lt;p&gt;另一个重要的部分是应用程序的DBContext. 这是继承自EF Core的DbContext的类. 它包含EF Core配置数据库所需的信息,也是在代码中访问数据库时使用的类(参见 1.9.2节). 图1.5展示了MyFirstEfCoreApp控制台应用使用的DbContext (名为AppDbContext)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832799/201902/832799-20190219142533619-1479719161.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我们的小型示例中,建模的所有细节都是由EF Core完成的,它通过使用约定来解决问题. 你有很多其他方法告诉EF Core数据库模型的配置,这些命令会让这个小示例变的复杂,所以暂时不做介绍. 在第6章和第7章中介绍了所有的配置选择&lt;/p&gt;
&lt;p&gt;本示例中使用了一种方法定义控制台应用程序的DbContext: 覆盖应用程序的DbContext的OnConfiguring方法,提供EF Core需要的数据库类型和连接字符串等其他信息. 这种方法的缺点是它的连接字符串是固定的,不利于单元测试&lt;/p&gt;
&lt;p&gt;在ASP.NET Core应用程序中这是一个问题, 因为在不同的环境: 开发,测试,生产我们会使用不同的数据库. 在第2章中我们将构建一个ASP.NET Core Web应用程序,将会使用一个不同的方式来更改数据库连接字符串(参见2.2.2节)&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 06:38:00 +0000</pubDate>
<dc:creator>liangshiwei</dc:creator>
<og:description>Entity Framework Core in Action Entityframework Core in action是 所著的关于Entityframework Core 书籍。 '原版地址'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LiangSW/p/10400947.html</dc:identifier>
</item>
<item>
<title>Android电量优化全解析 - Coding小僧</title>
<link>http://www.cnblogs.com/tuike/p/10400641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tuike/p/10400641.html</guid>
<description>&lt;p&gt;电量优化一直是个老生常谈的话题，关于这块的文章已经有很多了，最近也在做这块东西，所以结合自己的理解写下这篇文章，如果有啥问题欢迎关注微信公众号“程序员驿站”留言。好了，开始今天的正题，关于这块的论述我按照按照下述结构进行。 &lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113339887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;电量消耗的全过程分析&quot;&gt;电量消耗的全过程分析&lt;/h3&gt;
&lt;p&gt;手机设备会执行各种任务和各种复杂计算，如秀自拍图片上传朋友圈、秀直播等等，为了完成这些设备硬件会快速消耗手机电池电量。很明显，任务处理的越复杂，电量就会消耗的越多和越快，一眨眼的功夫电量就消耗完了，这个时候用户的手机顿时变成个累赘的砖头了，用户就会怀疑谁(哪个app)这么耗电，然后把它卸了！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;写出耗电量低的应用的关键是要透彻理解它的全部过程。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113521235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在电子编程世界，这种硬件消耗电量 来执行任务的过程，叫做超时电流消耗，任何电子编程专业的人都会告诉你，你的设备的各项活动在相同时间内，消耗的电量是不同的。&lt;/p&gt;
&lt;p&gt;比如，很多手机号称待机好几天，这个确实是真的，不过就是使用飞行模式放在家里什么都不干，确实可以甚至可以坚持10多天。但是我们一旦使用它，比如使用蜂窝式无线数据交换(3G4G)、屏幕保持唤醒状态等，手机电量就会很快被消耗掉。&lt;/p&gt;
&lt;p&gt;作为开发者，我们很想知道我的应用执行的哪些任务消耗的电量是最多的？这个问题确实会很棘手。因为电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情（所以很多设备都把这个监测电量的功能阉割掉了）。&lt;/p&gt;
&lt;p&gt;唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗（因为第三方硬件监测的时候是用的自己的供电而不是用的手机的电量）。&lt;/p&gt;
&lt;p&gt;耗电情况，例如：打开屏幕，所有要使用CPU/GPU工作的动作都会唤醒屏幕，都会消耗电量。这和应用程序唤醒设备还不一样。比如使用叫醒闹钟(wake clock)、AlarmManager、JobSchedulerAPI。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113602314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;手机哪些地方最耗电&quot;&gt;手机哪些地方最耗电?&lt;/h3&gt;
&lt;h4 id=&quot;唤醒屏幕&quot;&gt;唤醒屏幕&lt;/h4&gt;
&lt;p&gt;当用户点亮屏幕的时候，意味着系统的各组件要开始进行工作，界面也需要开始执行渲染。&lt;/p&gt;
&lt;p&gt;待机状态的电量消耗:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113622959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用和唤醒屏幕后:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113652795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当设备从休眠状态中，被应用程序唤醒时，可以看到在第一次唤醒时，出现一条电量使用高峰线。&lt;/p&gt;
&lt;h4 id=&quot;cpu唤醒使用&quot;&gt;CPU唤醒使用&lt;/h4&gt;
&lt;p&gt;CUP 唤醒时的高峰线:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113712537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是后续的一些执行的消耗了:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113724495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当工作完成后，设备会主动进行休眠，这非常重要，在不使用或者很少使用的情况下，长时间 保持屏幕唤醒会迅速消耗电池的电量。&lt;/p&gt;
&lt;h4 id=&quot;蜂窝式无线&quot;&gt;蜂窝式无线&lt;/h4&gt;
&lt;p&gt;当设备通过无线网发送数据的时候，为了使用硬件，这里会出现一个唤醒耗电高峰。接下来还 有一个高数值，这是发送数据包消耗的电量，然后接受数据包也会消耗大量电量 也看到一个峰值。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113748316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常情况下，使用3G移动网络传输数据，电量的消耗有三种状态:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Full power：&lt;/strong&gt; 能量最高的状态，移动网络连接被激活，允许设备以最大的传输速率进&lt;br/&gt;行操作。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Low power：&lt;/strong&gt; 一种中间状态，对电量的消耗差不多是 Full power 状态下的 50%。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Standby：&lt;/strong&gt; 最低的状态，没有数据连接需要传输，电量消耗最少。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;battery-historian-电量分析工具的使用&quot;&gt;Battery-Historian 电量分析工具的使用&lt;/h3&gt;
&lt;p&gt;要进行电量优化，我们首先得知道电都消耗到哪里去了，我们可以通过 google 开源的 Battery-Historian 来进行分析。&lt;/p&gt;
&lt;p&gt;工具开源地址: &lt;a href=&quot;https://github.com/google/battery-historian&quot; class=&quot;uri&quot;&gt;https://github.com/google/battery-historian&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;battery-history-工具安装&quot;&gt;Battery History 工具安装&lt;/h4&gt;
&lt;p&gt;根据 gitbub 上面介绍，Battery History&lt;br/&gt;工具的安装有两种方式:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式1：&lt;/strong&gt; 通过安装 Docker 环境来安装。(这种方式很简单，Docker 真心好用)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按照 Docker 网站上的说明安装 Docker Community Edition。&lt;/li&gt;
&lt;li&gt;使用以下命令运行 Battery Historian 镜像:&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker --run -p port_number:9999 gcr.io/android-battery-historian:2.1 --port 9999&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式2&lt;/strong&gt; 通过编译 gitbub 上面的源码来安装。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GO 环境安装:具体可以参考 &lt;strong&gt;Mac os 安装 golang 开发环境&lt;/strong&gt;(&lt;a href=&quot;https://www.jianshu.com/p/79bdd20c46cf&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/79bdd20c46cf&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;安装 git.&lt;/li&gt;
&lt;li&gt;安装 Python。仅支持 python2.7 (&lt;a href=&quot;https://www.python.org/&quot; class=&quot;uri&quot;&gt;https://www.python.org/&lt;/a&gt; )&lt;/li&gt;
&lt;li&gt;安装Java环境&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;下载-battery-historian-源码并且运行&quot;&gt;下载 Battery Historian 源码并且运行&lt;/h4&gt;
&lt;p&gt;输入如下命令行 下载到GOPATH 配置目录下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go get -d -u github.com/google/battery-historian/...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113813252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入到$GOPATH/src/github.com/google/battery-historian目录下方&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd $GOPATH/src/github.com/google/battery-historian&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113827788.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行 Battery Historian&lt;br/&gt;1.执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go run setup.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Compile Javascript files using the Closure compiler&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113845192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;2.接着在执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go run cmd/battery-historian/battery-historian.go [--port &amp;lt;default:9999&amp;gt;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Run Historian on your machine (make sure $PATH contains $GOBIN)&lt;br/&gt;3.登录网址http://localhost:9999查看battery-historian是否运行。&lt;/p&gt;
&lt;p&gt;到此Battery-historian的环境就整好了。&lt;/p&gt;
&lt;h4 id=&quot;电量数据收集&quot;&gt;电量数据收集&lt;/h4&gt;
&lt;p&gt;Android 5.0 及以上的设备, 允许我们通过 adb 命令 dump 出电量使用统计信息。&lt;br/&gt;1.因为电量统计数据是持续的, 会非常大, 统计待测试的 App 之前需要连上设备，因此需要reset(重置)电池数据收集。命令行执行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ adb shell dumpsys batterystats --resetBattery stats reset&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.断开usb连接的测试设备, 操作要测试的App。&lt;/p&gt;
&lt;p&gt;3.重新连接设备, 使用 adb 命令导出相关统计数据:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Android 7.0 及以上执行如下命令:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;adb bugreport &amp;gt; [path/]bugreport.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Android 5.0/ 6.0执行如下命令:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;adb bugreport &amp;gt; [path/]bugreport.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导出的统计数据存储到 bugreport.zip(bugreport.txt), 借助 battery-historian 工具来图形化 展示电池的消耗情况.&lt;/p&gt;
&lt;p&gt;上传 bugreport.zip(bugreport.txt)文件至 &lt;a href=&quot;http://localhost:9999/&quot; class=&quot;uri&quot;&gt;http://localhost:9999&lt;/a&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113920182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;battery-historian电量分析结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219113937702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析指标&quot;&gt;分析指标&lt;/h3&gt;
&lt;p&gt;下图是使用 adb 命令将采集的电量数据上传至 Battery Historian 而得到电量的分析情况。（我们可以通过包名过滤具体应用的耗电情况）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201902191139519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各指标的含义&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;横坐标：&lt;/strong&gt; 横坐标就是一个时间范围，咱们的例子中统计的数据是以重置为起点，获取 bugreport 内容时 刻为终点。我们一共采集了多长时间的数据；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;纵坐标：&lt;/strong&gt; 关键数据点说明如下。&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;battery_level&lt;/td&gt;
&lt;td&gt;电量，可以看出电量的变化&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;plugged&lt;/td&gt;
&lt;td&gt;充电状态，这一栏显示是否进行了充电，以及充电的时间范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;screen&lt;/td&gt;
&lt;td&gt;屏幕是否点亮，这一点可以考虑到睡眠状态和点亮状态下电量的使用信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;top&lt;/td&gt;
&lt;td&gt;该栏显示当前时刻哪个 app 处于最上层，就是当前手机运行的 app，用来判断某个 app 对手机电量的影响，这样也能判断出该 app 的耗电量信息。该栏记录了应用在某 一个时刻启动，以及运行的时间，这对我们比对不同应用对性能的影响有很大的帮助&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;wake_lock&lt;/td&gt;
&lt;td&gt;wake_lock 该属性是记录 wake_lock 模块的工作时间。是否有停止的时候等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;running&lt;/td&gt;
&lt;td&gt;界面的状态，主要判断是否处于 idle 的状态。用来判断无操作状态下电量的消耗&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Job&lt;/td&gt;
&lt;td&gt;后台的工作，比如服务 service 的运行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;data_conn&lt;/td&gt;
&lt;td&gt;数据连接方式的改变，上面的 edge 是说明采用的 gprs 的方式连接网络的。此数据可 以看出手机是使用 2g，3g，4g 还是 wifi 进行数据交换的。这一栏可以看出不同的连 接方式对电量使用的影响&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;status&lt;/td&gt;
&lt;td&gt;电池状态信息，有充电，放电，未充电，已充满，未知等不同状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;phone_signal_strength&lt;/td&gt;
&lt;td&gt;手机信号状态的改变。 这一栏记录手机信号的强弱变化图，依次来判断手机信号对电 量的影响&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;health&lt;/td&gt;
&lt;td&gt;电池健康状态的信息，这个信息一定程度上反映了这块电池使用了多长时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;plug&lt;/td&gt;
&lt;td&gt;充电方式，usb 或者插座，以及显示连接的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Sync&lt;/td&gt;
&lt;td&gt;是否跟后台同步&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;phone_in_call&lt;/td&gt;
&lt;td&gt;是否进行通话&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gps&lt;/td&gt;
&lt;td&gt;gps 是否开启&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;如何进行电量优化&quot;&gt;如何进行电量优化?&lt;/h3&gt;
&lt;p&gt;了解手机关键耗电的地方及分析耗电的工具后。接下来就是我们的核心，如何来进行电量的优 化?首先我们先简单总结汇总一下耗电的相关因素&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;屏幕亮暗相关&lt;/li&gt;
&lt;li&gt;设备 awake,sleep 的切换,尤其是唤醒.&lt;/li&gt;
&lt;li&gt;CPU 运行相关&lt;/li&gt;
&lt;li&gt;网络&lt;/li&gt;
&lt;li&gt;传感器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们都知道屏幕的渲染及 CPU 的运行是耗电的主要因素之一。所以当我们在做内存优化、渲染优化、计算优化的时候，就已然在做电量优化。所以在平时的开发中，我们要注意点滴性能 的优化积累，实际上当我们来做电量分析的时候，也是在找自己挖的坑。所以尽量有意识在项 目的开发过程中尽量少挖坑，这一点是我们在分析其他优化项首先要提到的一个点。&lt;/p&gt;
&lt;h4 id=&quot;监听手机充电状态&quot;&gt;监听手机充电状态&lt;/h4&gt;
&lt;p&gt;我们可以通过下面的代码来获取手机的当前充电状态:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219114007990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;得到充电状态信息之后，我们可以有针对性的对部分代码做优化。比如我们可以判断只有当前 手机为 AC 充电状态时 才去执行一些非常耗电的操作。可以通过下面的方法判断手机当前的充 电状态。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219114022654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们就需要思考，根据具体的业务，考虑将一些不需要及时地和用户交互的操作放到充电 的时候去做。比如：360 手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人 等到云端，从而避免当用户手机低电量时，任然继续进行耗电操作。&lt;/p&gt;
&lt;h4 id=&quot;屏幕唤醒&quot;&gt;屏幕唤醒&lt;/h4&gt;
&lt;p&gt;当 Android 设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止 CPU 的运行，这样可以防 止电池电量掉的快。但有些时候我们需要改变 Android 系统默认的这种状态:比如玩游戏时我 们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要 CPU 一直运行直到任务完成。&lt;/p&gt;
&lt;p&gt;保持屏幕常亮比较好的方式是在 Activity 中使用 FLAG_KEEP_SCREEN_ON 的 Flag。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219114047569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个方法的好处是不像唤醒锁(wake locks)，需要一些特定的权限(permission)。并且能 正确管理不同 app 之间的切换，不用担心无用资源的释放问题。&lt;/p&gt;
&lt;p&gt;另一个方式是在布局文件中使用 android:keepScreenOn 属性:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219114101369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1aWtl,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;android:keepScreenOn = “true”的作用和 FLAG_KEEP_SCREEN_ON 一样，使用代码的好 处是你允许你在需要的地方关闭屏幕。&lt;/p&gt;
&lt;p&gt;注意:一般不需要人为的去掉 FLAG_KEEP_SCREEN_ON 的 flag，windowManager 会管理好程序进入 后台回到前台的的操作。如果确实需要手动清掉常亮的 flag，使用&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219114117895.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以这里我们需要根据自己的 APP 实际情况，根据业务来控制好是否保持屏幕常量。比如 APP 需要支持视频播放。那么在播放的界面需要控制好不熄屏，当退出播放时，当然就没有了 这个设置。&lt;/p&gt;
&lt;h4 id=&quot;wakelock&quot;&gt;WakeLock&lt;/h4&gt;
&lt;p&gt;wake_lock 锁主要是相对系统的休眠而言的，意思就是程序给 CPU 加了这个锁那系统就不会 休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些 问题。&lt;br/&gt;需要使用 PowerManager 这个系统服务的唤醒锁(wake locks)特征来保持 CPU 处于唤醒状 态。唤醒锁允许程序控制宿主设备的电量状态，创建和持有唤醒锁对电池的续航有较大的影 响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。比如在 Acitivity 中就没必要用了。如果需要关闭屏幕，使用上述的 FLAG_KEEP_SCREEN_ON。&lt;/p&gt;
&lt;p&gt;只有一种合理的使用场景，使用后台服务在屏幕关闭情况下 hold 住 CPU 完成一些工作，需要 使用唤醒锁，如果不使用唤醒锁来执行后台服务，不能保证因 CPU 休眠未来的某个时刻任务 会停止，这不是我们想要的。&lt;/p&gt;
&lt;p&gt;唤醒锁可划分并识别为四种用户唤醒锁:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;PARTIAL_WAKE_LOCK&lt;/td&gt;
&lt;td&gt;开启&lt;/td&gt;
&lt;td&gt;关闭&lt;/td&gt;
&lt;td&gt;关闭&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SCREEN_DIM_WAKE_LOCK&lt;/td&gt;
&lt;td&gt;开启&lt;/td&gt;
&lt;td&gt;变暗&lt;/td&gt;
&lt;td&gt;关闭&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SCREEN_BRIGHT_WAKE_LOCK&lt;/td&gt;
&lt;td&gt;开启&lt;/td&gt;
&lt;td&gt;变亮&lt;/td&gt;
&lt;td&gt;关闭&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;FULL_WAKE_LOCK&lt;/td&gt;
&lt;td&gt;开启&lt;/td&gt;
&lt;td&gt;变亮&lt;/td&gt;
&lt;td&gt;变亮&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意:自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用。 应用应使用 FLAG_KEEP_SCREEN_ON。&lt;/p&gt;
&lt;p&gt;1.添加唤醒锁权限:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019021911413698.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.直接使用唤醒锁:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219114150377.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意:在使用该类的时候，必须保证 acquire 和 release 是成对出现的。不然当我们业务已经不需要时， 当 CPU 处于唤醒状态，这个时候就会损耗多余的电量。&lt;/p&gt;
&lt;h4 id=&quot;jobscheduler&quot;&gt;JobScheduler&lt;/h4&gt;
&lt;p&gt;自 Android 5.0 发布以来，JobScheduler 已成为执行后台工作的很好的方式，其工作方式有 利于用户在适当的时机执行正确的事情。应用可以在安排作业的同时允许系统基于内存、电源 和连接情况进行优化。JobSchedule 的宗旨就是把一些不是特别紧急的任务放到更合适的时机 批量处理。这样做有两个好处:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免频繁的唤醒硬件模块，造成不必要的电量消耗。&lt;/li&gt;
&lt;li&gt;避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的&lt;br/&gt;任务消耗电量。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;gps&quot;&gt;GPS&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;选择合适的 Location Provider&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android 系统支持多个 Location Provider:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;GPS_PROVIDER:&lt;/strong&gt; GPS 定位，利用 GPS 芯片通过卫星获得自己的位置信息。定位精准度高，一般在 10 米左右， 耗电量大;但是在室内，GPS 定位基本没用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NETWORK_PROVIDER:&lt;/strong&gt; 网络定位，利用手机基站和 WIFI 节点的地址来大致定位位置，这种定位方式取决于服务器，&lt;br/&gt;即取决于将基站或 WIF 节点信息翻译成位置信息的服务器的能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PASSIVE_PROVIDER:&lt;/strong&gt; 被动定位，就是用现成的，当其他应用使用定位更新了定位信息，系统会保存下来，该应用接 收到消息后直接读取就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果 App 只是需要一个粗略的定位那么就不需要使用 GPS 进行定位，既耗费电量，定位的耗 时也久。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;及时注销定位监听&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在获取到定位之后或者程序处于后台时，注销定位监听，此时监听 GPS 传感器相当于执行 no- op(无操作指令)，用户不会有感知但是却耗电。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多模块使用定位尽量复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个模块使用定位，尽量复用上一次的结果，而不是都重新走定位的过程，节省电量损耗;例 如:在应用启动的时候获取一次定位，保存结果，之后再用到定位的地方都直接去取。&lt;/p&gt;
&lt;h4 id=&quot;传感器&quot;&gt;传感器&lt;/h4&gt;
&lt;p&gt;使用传感器，选择合适的采样率，越高的采样率类型则越费电。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SENSOR_DELAY_NOMAL (200000 微秒)&lt;/li&gt;
&lt;li&gt;SENSOR_DELAY_UI (60000 微秒)&lt;/li&gt;
&lt;li&gt;SENSOR_DELAY_GAME (20000 微秒)&lt;/li&gt;
&lt;li&gt;SENSOR_DELAY_FASTEST (0 微秒)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在后台时注意及时注销传感器监听&lt;/p&gt;
&lt;h4 id=&quot;doze-and-app-standby&quot;&gt;Doze and App Standby&lt;/h4&gt;
&lt;p&gt;最后提这一点，理论上不是电量优化，而是做电量优化要注意的一个坑。Doze and App Standby 是 Android 6.0 以后，提供了两种省电延长电池寿命的功能。&lt;br/&gt;具体可参考 google 官方介绍文档。&lt;/p&gt;
&lt;p&gt;如果大家有什么好的意见或建议，欢迎关注我的公众号“程序员驿站”进行留言，谢谢！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190219114953499.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;扫一扫 关注我的公众号&lt;br/&gt;如果你有好的文章需要和广大网友分享，欢迎投稿，谢谢！&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://github.com/google/battery-historian#wakelock-analysis&quot; class=&quot;uri&quot;&gt;https://github.com/google/battery-historian#wakelock-analysis&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 05:55:00 +0000</pubDate>
<dc:creator>Coding小僧</dc:creator>
<og:description>电量优化一直是个老生常谈的话题，关于这块的文章已经有很多了，最近也在做这块东西，所以结合自己的理解写下这篇文章，如果有啥问题欢迎关注微信公众号“程序员驿站”留言。好了，开始今天的正题，关于这块的论述我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tuike/p/10400641.html</dc:identifier>
</item>
<item>
<title>CSS中盒模型的理解 - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/10400579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/10400579.html</guid>
<description>&lt;p&gt;今天突然看到一篇关于CSS中盒模型的文章，忽然觉得自己竟然遗忘了很多小的地方，所以写一篇文章来记忆一下&lt;/p&gt;
&lt;p&gt;（&lt;span&gt;摘抄于千与千寻写的CSS盒子模型理解，并在自己基础上添加了一些东西，希望更完善，对大家有帮助&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.基本的盒模型知识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CSS css盒子模型 又称框模型 (Box Model) ，包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201902/1459059-20190219132722150-1828089571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了方便大家理解和尝试，我写了一个小Demo放上来方便大家尝试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 显示盒模型   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 盒模型计算规则
        元素框的总宽度 = 元素（element）的width + padding的左边距和右边距的值 + margin的左边距和右边距的值 + border的左右宽度；
        元素框的总高度 = 元素（element）的height + padding的上下边距的值 + margin的上下边距的值 ＋ border的上下宽度。
        元素的总宽度 = 元素（element）的width + padding的左边距和右边距的值 + border的左右宽度；
        元素的总高度 = 元素（element）的height + padding的上下边距的值 ＋ border的上下宽度。
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .box&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 高度和宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yellow&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 边框的宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px solid green&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 内边距 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 外边距&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 此处引入子div只是为了显示content的区域 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .child&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201902/1459059-20190219132946268-1365528031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可以尝试更改一下其中的高度宽度，内边距外边距的值来更加直观的感受盒模型&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.盒模型的合并&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当两个盒模型进行合并时，需要注意一下:&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;当两个上下方向相邻的元素框垂直相遇时，外边距会合并，合并后的外边距的高度等于两个发生合并的外边距中较高的那个边距值&lt;/span&gt;，如图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201902/1459059-20190219133344063-2087066920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然外边距合并其实也有存在的意义，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201902/1459059-20190219133442050-932715601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;特别注意：&lt;span&gt;只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.box-sizing属性介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;box-sizing属性是用户界面属性里的一种，之所以介绍它，是因为这个属性跟盒子模型有关，而且在css reset中有可能会用到它。&lt;/p&gt;
&lt;p&gt;box-sizing : content-box|border-box|inherit;&lt;/p&gt;
&lt;p&gt;(1) content-box ,默认值，可以使设置的宽度和高度值应用到元素的内容框。盒子的width只包含内容。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;即我们所说的标准盒模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　总宽度=margin+border+padding+width&lt;/p&gt;
&lt;p&gt;(2) border-box , 设置的width值其实是除margin外的border+padding+element的总宽度。盒子的width包含border+padding+内容&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;即我们所说的怪异盒模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　总宽度=margin+width&lt;/p&gt;
&lt;p&gt;很多CSS框架，都会对盒子模型的计算方法进行简化。&lt;/p&gt;
&lt;p&gt;(3) inherit , 规定应从父元素继承 box-sizing 属性的值&lt;/p&gt;
&lt;p&gt;关于border-box的使用：&lt;/p&gt;
&lt;p&gt;1 一个box宽度为100%，又想要两边有内间距，这时候用就比较好&lt;br/&gt;2 全局设置 border-box 很好，首先它符合直觉，其次它可以省去一次又一次的加加减减，它还有一个关键作用——让有边框的盒子正常使用百分比宽度。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.实际开发中常遇到的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;margin越界（第一个子元素的margin-top和最后一个子元素的margin-bottom的越界问题）&lt;/p&gt;
&lt;p&gt;以第一个子元素的margin-top 为例：&lt;/p&gt;
&lt;p&gt;当父元素没有边框border时，设置第一个子元素的margin-top值的时候，会出现margin-top值加在父元素上的现象，解决方法有四个：&lt;/p&gt;
&lt;p&gt;（1）给父元素加边框border （副作用）&lt;/p&gt;
&lt;p&gt;（2）给父元素设置padding值  （副作用）&lt;/p&gt;
&lt;p&gt;（3）父元素添加 overflow：hidden （副作用）&lt;/p&gt;
&lt;p&gt;（4）父元素加前置内容生成。（推荐）&lt;/p&gt;
&lt;p&gt;以第四种方法为例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.parent &lt;/span&gt;{&lt;span&gt;
     width &lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
     height &lt;/span&gt;:&lt;span&gt; 500px&lt;/span&gt;;&lt;span&gt;
     background-color &lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;       
}&lt;span&gt;
.parent : before &lt;/span&gt;{&lt;span&gt;
     content &lt;/span&gt;:&lt;span&gt; &quot; &quot;&lt;/span&gt;;&lt;span&gt;
     display &lt;/span&gt;:&lt;span&gt; table&lt;/span&gt;;
}&lt;span&gt;

.child &lt;/span&gt;{&lt;span&gt;
     width &lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
     height &lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
     background-color &lt;/span&gt;:&lt;span&gt; green&lt;/span&gt;;&lt;span&gt;
     margin-top &lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好啦，目前就这些&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 05:43:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>今天突然看到一篇关于CSS中盒模型的文章，忽然觉得自己竟然遗忘了很多小的地方，所以写一篇文章来记忆一下 （摘抄于千与千寻写的CSS盒子模型理解，并在自己基础上添加了一些东西，希望更完善，对大家有帮助）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suihang/p/10400579.html</dc:identifier>
</item>
<item>
<title>SpringSecurity自定义AuthenticationProvider和AuthenticationFilter - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/10400564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/10400564.html</guid>
<description>&lt;h3 id=&quot;authenticationprovider&quot;&gt;AuthenticationProvider&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;默认实现：DaoAuthenticationProvider&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;授权方式提供者，判断授权有效性，用户有效性，在判断用户是否有效性，它依赖于UserDetailsService实例，开发人员可以自定义UserDetailsService的实现。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;additionalAuthenticationChecks方法校验密码有效性&lt;/li&gt;
&lt;li&gt;retrieveUser方法根据用户名获取用户&lt;/li&gt;
&lt;li&gt;createSuccessAuthentication完成授权持久化&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@Component
@Slf4j
public class LindAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {

  @Autowired
  UserDetailsService userDetailsService;

  @Autowired
  private PasswordEncoder passwordEncoder;

  /**
   * 校验密码有效性.
   *
   * @param userDetails    .
   * @param authentication .
   * @throws AuthenticationException .
   */
  @Override
  protected void additionalAuthenticationChecks(
      UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)
      throws AuthenticationException {
    if (authentication.getCredentials() == null) {
      logger.debug(&quot;Authentication failed: no credentials provided&quot;);

      throw new BadCredentialsException(messages.getMessage(
          &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,
          &quot;Bad credentials&quot;));
    }

    String presentedPassword = authentication.getCredentials().toString();

    if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {
      logger.debug(&quot;Authentication failed: password does not match stored value&quot;);

      throw new BadCredentialsException(messages.getMessage(
          &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,
          &quot;Bad credentials&quot;));
    }
  }

  /**
   * 获取用户.
   *
   * @param username       .
   * @param authentication .
   * @return
   * @throws AuthenticationException .
   */
  @Override
  protected UserDetails retrieveUser(
      String username, UsernamePasswordAuthenticationToken authentication)
      throws AuthenticationException {
    UserDetails loadedUser = userDetailsService.loadUserByUsername(username);
    if (loadedUser == null) {
      throw new InternalAuthenticationServiceException(
          &quot;UserDetailsService returned null, which is an interface contract violation&quot;);
    }
    return loadedUser;
  }
}
 /**
   * 授权持久化.
   */
  @Override
  protected Authentication createSuccessAuthentication(Object principal,
                                                       Authentication authentication, UserDetails user) {
    return super.createSuccessAuthentication(principal, authentication, user);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;authenticationfilter&quot;&gt;AuthenticationFilter&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;默认实现：UsernamePasswordAuthenticationFilter&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;授权过滤器，你可以自定义它，并把它添加到默认过滤器前或者后去执行，主要用来到授权的持久化，它可以从请求上下文中获取你的user,password等信息，然后去判断它是否符合规则，最后通过authenticate方法去授权。默认的&lt;code&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt;过滤器，主要判断请求方式是否为post，并且对username和password进行了默认值的处理，总之，在这个过滤器里不会涉及到具体业务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LindUserNameAuthenticationFilter extends AbstractAuthenticationProcessingFilter {

  public LindUserNameAuthenticationFilter() {
    super(new AntPathRequestMatcher(&quot;/login&quot;, &quot;GET&quot;));
  }

  @Override
  public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {
    String username = request.getParameter(&quot;username&quot;);
    String password = request.getParameter(&quot;password&quot;);

    if (username == null) {
      throw new InternalAuthenticationServiceException(&quot;Failed to get the username&quot;);
    }

    if (password == null) {
      throw new InternalAuthenticationServiceException(&quot;Failed to get the password&quot;);
    }

    UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(
        username, password);
    authRequest.setDetails(authenticationDetailsSource.buildDetails(request));
    return this.getAuthenticationManager().authenticate(authRequest);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;userdetialsservice&quot;&gt;UserDetialsService&lt;/h3&gt;
&lt;p&gt;这是一个接口，有默认的实现方式，一般的，我们需要根据业务去重新实现它，比如从你的用户表获取当前授权的用户信息，你需要在UserDetialsService实现类里对用户表进行读取操作；它一般会在AuthenticationProvider里的retrieveUser方法中被使用，这就像面向对象里的模板方法模式一样，springSecurity把检验的步骤设计好了，咱们开发只要根据规则去实现具体细节就好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyUserDetailService implements UserDetailsService {
  @Autowired
  private PasswordEncoder passwordEncoder;

  @Override
  public UserDetails loadUserByUsername(String name) throws UsernameNotFoundException {
    /*
      设置用户和角色需要注意：
      1. commaSeparatedStringToAuthorityList放入角色时需要加前缀ROLE_，而在controller使用时不需要加ROLE_前缀
      2. 放入的是权限时，不能加ROLE_前缀，hasAuthority与放入的权限名称对应即可
    */
    List&amp;lt;UserDetails&amp;gt; userDetailsList = new ArrayList&amp;lt;&amp;gt;();
    userDetailsList.add(User.builder()
        .username(&quot;admin&quot;)
        .password(passwordEncoder.encode(&quot;123&quot;))
        .authorities(AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;read,ROLE_ADMIN&quot;)).build());
    userDetailsList.add(User.builder()
        .username(&quot;user&quot;)
        .password(passwordEncoder.encode(&quot;123&quot;))
        .authorities(AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;read,ROLE_USER&quot;))
        .build());

    //获取用户
    return userDetailsList.stream()
        .filter(o -&amp;gt; o.getUsername().equals(name))
        .findFirst()
        .orElse(null);

  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在websecurityconfig里开启它&quot;&gt;在WebSecurityConfig里开启它&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
  @Autowired
  LindAuthenticationSuccessHandler lindAuthenticationSuccessHandler;

  @Autowired
  LindAuthenticationFailHandler lindAuthenticationFailHandler;
  @Autowired
  LindAuthenticationProvider lindAuthenticationProvider;

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
        .antMatchers(&quot;/&quot;, &quot;/index&quot;).permitAll()
        .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)//按路由授权
        .anyRequest().authenticated()
        .and()
        .formLogin()
        .loginPage(&quot;/login&quot;)
        .defaultSuccessUrl(&quot;/hello&quot;)//默认登录成功后跳转的页面
        .successHandler(lindAuthenticationSuccessHandler)
        .failureHandler(lindAuthenticationFailHandler)
        .permitAll()
        .and()
        .addFilterAt(lindAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class).authorizeRequests().and()
        .logout()
        .permitAll();
  }

  /**
   * 自定义的Filter.
   */
  @Bean
  LindUserNameAuthenticationFilter lindAuthenticationFilter() {
    LindUserNameAuthenticationFilter phoneAuthenticationFilter = new LindUserNameAuthenticationFilter();
    ProviderManager providerManager =
        new ProviderManager(Collections.singletonList(lindAuthenticationProvider));
    phoneAuthenticationFilter.setAuthenticationManager(providerManager);
    phoneAuthenticationFilter.setAuthenticationSuccessHandler(lindAuthenticationSuccessHandler);
    phoneAuthenticationFilter.setAuthenticationFailureHandler(lindAuthenticationFailHandler);
    return phoneAuthenticationFilter;
  }

  /**
   * 密码生成策略.
   *
   * @return
   */
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;认证时执行的顺序&quot;&gt;认证时执行的顺序&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;LindUserNameAuthenticationFilter&lt;/li&gt;
&lt;li&gt;LindAuthenticationProvider.retrieveUser&lt;/li&gt;
&lt;li&gt;LindAuthenticationProvider.additionalAuthenticationChecks&lt;/li&gt;
&lt;li&gt;UserDetailsService&lt;/li&gt;
&lt;li&gt;Authentication&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;springSecurity源码：https://github.com/spring-projects/spring-security&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 05:41:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<og:description>AuthenticationProvider 默认实现：DaoAuthenticationProvider 授权方式提供者，判断授权有效性，用户有效性，在判断用户是否有效性，它依赖于UserDetai</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/10400564.html</dc:identifier>
</item>
<item>
<title>js函数式编程术语总结 - 持续更新 - 悔不当初-s</title>
<link>http://www.cnblogs.com/zk995/p/10400555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zk995/p/10400555.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/shfshanyue/fp-jargon-zh/blob/master/Readme.md&quot;&gt;参考文档1&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.css88.com/archives/7833#lazy-evaluation&quot;&gt;参考文档2&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;函数式编程术语&quot;&gt;&lt;span&gt;函数式编程术语&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h4 id=&quot;高阶函数-higher-order-functions&quot;&gt;&lt;span&gt;高阶函数 Higher-Order Functions&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以函数为参数的函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;返回一个函数的函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;函数的元-arity&quot;&gt;&lt;span&gt;函数的元 Arity&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;比如，一个带有两个参数的函数被称为二元函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;惰性求值-lazy-evaluation&quot;&gt;&lt;span&gt;惰性求值 Lazy evaluation&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;是一种按需求值机制，它会延迟对表达式的求值，直到其需要为止&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;// 设置一个随机数，需要时，才会计算，每次计算都是一个不同的值
const rand = function*() {
  while (1 &amp;lt; 2) {
    yield Math.random()
  }
}
const randIter = rand()
randIter.next() // 每个执行都给出一个随机值，表达式按需求值。&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;偏函数-partial-application&quot;&gt;&lt;span&gt;偏函数 Partial Application&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;即【降元】，将一个 n 元函数转换成一个 n - x 元函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;或者这样理解，通过对【复杂的函数】填充一部分数据来构成一个【简单的函数】&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;柯里化就是通过偏应用函数来实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;function add(a, b,c) {
    return a + b+c;
}
//也可以
var addOne = add.bind(null, 1,2);
console.log(addOne(2));
//也可以
var addTwo = add.bind(null, 1);
console.log(addTwo(3,4));&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;柯里化-currying&quot;&gt;&lt;span&gt;柯里化 Currying&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将一个多参数函数转换成多个单参数函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;也就是将一个 n 元函数转换成 n 个一元函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;const sum = (a, b) =&amp;gt; a + b
const curriedSum = (a) =&amp;gt; (b) =&amp;gt; a + b
curriedSum(40)(2) // 42.
const add2 = curriedSum(2) // (b) =&amp;gt; 2 + b
add2(10) // 12&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自动柯里化-auto-currying&quot;&gt;&lt;span&gt;自动柯里化 Auto Currying&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将多个参数的函数转换为单参数的函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果，给定的参数数量少于正确的参数，则返回一个函数，该函数将获得其余的参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果，函数得到正确数量的参数时，它就会被求值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例，lodash 和 Ramda 都有一个 curry 函数，但 underscore 没有&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;const add = (x, y) =&amp;gt; x + y
const curriedAdd = _.curry(add)
curriedAdd(1, 2) // 3
curriedAdd(1) // (y) =&amp;gt; 1 + y
curriedAdd(1)(2) // 3&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;compose-组合函数&quot;&gt;&lt;span&gt;compose 组合函数&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;概念：它将需要嵌套执行的函数平铺。嵌套执行指的是，一个函数的返回值将作为另一个函数的参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;作用：实现函数式编程中的 pointfree 风格（无参数），使我们专注于【转换】而不是【数据】&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实现：接收多个函数作为参数，从右到左，一个函数的输入为另一个函数的输出&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;意义：编程更精练、算法更清晰、无参数干扰&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;威力：==【任意组合】==&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;缺点：不能直观的看到参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;var compose = function(fun1,fun2){
    return function(val){
        return fun1(fun2(val));
    }
}

var add = function(val){
  return val + &quot;111&quot;;
}

var upperCase = function(val){
  return val.toUpperCase();
}

var double = function(val){
  return val += val;
}
// 无限组合，才是compose的威力所在
var upperCaseThenAdd = compose(add,upperCase);
var doubleThenAdd = compose(double,add);
var addThenAdd = compose(add,add);
var addThenAddThenUpperCase = compose(upperCase,addThenAdd);//注意这个函数，以组合函数addThenAdd作为其参数，很强大，有没有！

console.log(upperCaseThenAdd(&quot;china&quot;));//CHINA111
console.log(doubleThenAdd(&quot;china&quot;));//china111china111
console.log(addThenAdd(&quot;china&quot;));//china111111
console.log(addThenAddThenUpperCase(&quot;china&quot;));//CHINA111111
//改进compose，支持2个以上参数
var compose1 = function(){
  var args = arguments;
  return function(initVal){
    var val = initVal;
    for(key in args){
      val = args[key](val);
    }
    return val;
  }
  
}
var doubleThenUpperCaseThenAddThenAdd = compose1(double,upperCase,add,add);
console.log(doubleThenUpperCaseThenAddThenAdd(&quot;china&quot;));//CHINACHINA111111
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;continuation&quot;&gt;&lt;span&gt;Continuation&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;概念：在一个程序执行的任意时刻，尚未执行的代码称为 Continuation&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;作用：异步请求回调、异步监听回调等&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;//continueFun函数就称为一个Continuation
var addOneAndContinue = function(val,continueFun){
  var val = val + 1;
  return continueFun(val);
}
var mutiply = function(val){
  return val * 5;
}
console.log(addOneAndContinue(100,mutiply));//505&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;纯函数-purity&quot;&gt;&lt;span&gt;纯函数 Purity&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;输出仅由输入决定，不依赖也不修改外部状态，即不产生副作用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;副作用-side-effects&quot;&gt;&lt;span&gt;副作用 Side effects&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果函数与外部可变状态进行交互，则它是有副作用的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;幂等性-idempotent&quot;&gt;&lt;span&gt;幂等性 Idempotent&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;数学中的幂等性&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;foo(x) 将产生与 foo(foo(x))、foo(foo(foo(x))) 等相同的输出&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[二元运算]，它需要三个元素：二元运算符以及该运算符作用的两个变量。如四则运算的加、减、乘、除均属于二元运算。乘法下唯一两个幂等实数为0和1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[一元运算]，例如 ++ ，正+，负-。比如[高斯符号]，它是一个数学符号，形式为方括号[x]，表示不大于x的最大整数，高斯符号是幂等的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;接口的幂等性&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对接口而言，幂等性实际上就是接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的。比如，在App中下订单的时候，点击确认之后，没反应，就又点击了几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[http方法的幂等]，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的（注意，只是服务器状态，和服务器返回状态无关）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;举例&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sh&quot;&gt;
&lt;span&gt;&lt;code&gt;GET /pageX HTTP/1.1是幂等的。连续调用多次，客户端接收到的结果都是一样的：
GET /pageX HTTP/1.1   
GET /pageX HTTP/1.1   
GET /pageX HTTP/1.1   
GET /pageX HTTP/1.1

POST /add_row HTTP/1.1不是幂等的。如果调用多次，就会增加多行记录：
POST /add_row HTTP/1.1
POST /add_row HTTP/1.1   -&amp;gt; Adds a 2nd row
POST /add_row HTTP/1.1   -&amp;gt; Adds a 3rd row

DELETE /idX/delete HTTP/1.1是幂等的，即便是不同请求之间接收到的状态码不一样：
DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 404&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;程序的幂等性&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;概念：一个函数执行多次皆返回相同的结果&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;作用：一个函数被调用多次时，保证内部状态的一致性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对比：和纯函数相比，幂等主要强调多次调用，对内部的状态的影响是一样的（但多次调用返回值可能不同）。而纯函数，主要强调相同的输入，多次调用，输出也相同且无副作用。==纯函数一定是幂等的==&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;意义：在任何可能的情况下通过幂等的操作限制副作用要比不做限制的更新要好得多。确保操作是幂等的，可避免意外的发生&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;//虽然是一个面向对象的例子，但是可以说明问题
var Student = function(name,age){
  this.name = name;
  this.age = age;
};
Student.prototype.delName = function(){
  var response = this.name ? this.name + &quot;已被删除&quot;:&quot;name不存在&quot;;
  this.name = null;
  return response;
}
//对内部的影响是一样的，但是返回值可以不同
var lilei = new Student(&quot;lilei&quot;,19);
console.log(lilei.delName());//lilei已被删除
console.log(lilei.delName());//name不存在
console.log(lilei.delName());//name不存在&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;point-free-风格&quot;&gt;&lt;span&gt;Point-Free 风格&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;定义函数时，不显式地指出函数所带参数。这种风格通常需要柯里化或者高阶函数。也叫 Tacit programming&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;断言函数-predicate&quot;&gt;&lt;span&gt;断言函数 Predicate&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;根据输入返回 true 或 false。通常用在 Array.prototype.filter 的回调函数中。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;const morethenTwo = (a) =&amp;gt; a &amp;gt; 2;
;[1, 2, 3, 4].filter(morethenTwo);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;契约-contracts&quot;&gt;&lt;span&gt;契约 Contracts&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;契约保证了函数或者表达式在运行时的行为。当违反契约时，将抛出一个错误&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;比如数据类型检测&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;const contract = (input) =&amp;gt; {
  if (typeof input === 'number') return true
  throw new Error('Contract Violated: expected int -&amp;gt; int')
}

const addOne = (num) =&amp;gt; contract(num) &amp;amp;&amp;amp; num + 1

addOne(2)
addOne('hello') // Error&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;范畴-category&quot;&gt;&lt;span&gt;范畴 Category&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;【不好理解】&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;范畴是指，对象(object)及它们之间的态射(箭头，箭头可以组合)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在程序中，数据类型作为对象，函数作为态射&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;【一个范畴遵从三个原则】&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;必有一个态射（函数），使得 map 一个对象是它自身&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;态射（函数）必是可组合的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;合成满足结合律。f ? (g ? h) 与 (f ? g) ? h 是等价的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;态射-morphism&quot;&gt;&lt;span&gt;态射 morphism&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;某一范畴中，对象之前的变换关系（一个变形的函数）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;函子-functor范畴学的内容&quot;&gt;&lt;span&gt;函子 functor（范畴学的内容）&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个实现 map 函数的对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在 javascript 中一个常见的函子是 Array,因为它遵守因子的两个准则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一致性 Preserves identity，即范畴的第一个原则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组合性 Composable&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;//一致性
object.map(x =&amp;gt; x) ? object
//组合性
var fun1 = function(x){
  return x+1;
}
var fun2 = function(x){
  return x*x;
}
var res1 = [1,2,3].map(fun1).map(fun2);
var res2 = [1,2,3].map(function(x){
  return fun2(fun1(x));
});
console.log(res1,res2);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;pointed-functor&quot;&gt;&lt;span&gt;Pointed Functor&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个具有 of 函数的对象，它将 任何 单独的值放入其中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ES6增加了 Array.of ，使数组成为一个 Pointed Functor&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;Array.of(1) // [1]&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;引用透明性-referential-transparency&quot;&gt;&lt;span&gt;引用透明性 Referential Transparency&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;定义：一个表达式在程序中可以被它等价的值替换，而不影响结果&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对函数而言：如果函数的返回值只依赖于其输入值，这种特性就称为引用透明性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;==纯函数具有引用透明性==&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;等式推理-equational-reasoning&quot;&gt;&lt;span&gt;等式推理 Equational Reasoning&lt;/span&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;指当应用程序由表达式组成，并且没有副作用时，关于系统的真值可以从各个部分推导出来&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;纯函数式语言的优点之一是易于进行等式推理，通过引用透明度实现，并且能够在所有上下文中用等号替换equals&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;不可变性&quot;&gt;&lt;span&gt;不可变性&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;比如es6中的 const 常量设计&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;匿名函数-lambda&quot;&gt;&lt;span&gt;匿名函数 Lambda&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;匿名函数往往被视作一个值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;匿名函数通常作为高阶函数的参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以把 Lambda 赋值给一个变量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;monad-对象&quot;&gt;&lt;span&gt;Monad 对象&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;拥有 of 和 chain 函数的对象。chain 很像 map， 除了用来铺平嵌套数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例，以数组来实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;//of
Array.of(1,2,3);//[ 1, 2, 3 ]
//chain方法的实现
Array.prototype.chain = function (f) {
  return this.reduce((acc, it) =&amp;gt; acc.concat(f(it)), [])  
};
Array.of('cat,dog', 'fish,bird').chain(s =&amp;gt; s.split(','));//[ &quot;cat&quot;, &quot;dog&quot;, &quot;fish&quot;, &quot;bird&quot; ]&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;comonad-对象&quot;&gt;&lt;span&gt;Comonad 对象&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;拥有 extract 与 extend 函数的对象&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;自同态-endomorphism&quot;&gt;&lt;span&gt;自同态 Endomorphism&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;输入输出是相同类型的函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;// uppercase :: String -&amp;gt; String
const uppercase = (str) =&amp;gt; str.toUpperCase()
// decrement :: Number -&amp;gt; Number
const decrement = (x) =&amp;gt; x - 1&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;applicative-functor&quot;&gt;&lt;span&gt;Applicative Functor&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个拥有 ap 函数的对象&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;同构-isomorphism&quot;&gt;&lt;span&gt;同构 Isomorphism&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不用类型对象的变形，保持结构并且不丢失数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;例如，一个二维坐标既可以表示为数组 [2, 3]，也可以表示为对象 {x: 2, y: 3}&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;// 提供函数在两种类型间互相转换
const pairToCoords = (pair) =&amp;gt; ({x: pair[0], y: pair[1]})
const coordsToPair = (coords) =&amp;gt; [coords.x, coords.y]

console.log(pairToCoords([1, 2]));//{ &quot;x&quot;: 1, &quot;y&quot;: 2 }
console.log(coordsToPair({x: 1, y: 2}));//[ 1, 2 ]&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;setoid-对象&quot;&gt;&lt;span&gt;Setoid 对象&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;定义：拥有 equals 函数的对象。equals 可以用来和其它对象比较。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;Array.prototype.equals = function (arr) {
  const len = this.length
  if (len !== arr.length) {
    return false
  }
  for (let i = 0; i &amp;lt; len; i++) {
    if (this[i] !== arr[i]) {
      return false
    }
  }
  return true
}

;[1, 2].equals([1, 2])   // true
;[1, 2].equals([3, 4])   // false&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;半群-semigroup&quot;&gt;&lt;span&gt;半群 Semigroup&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;定义：一个拥有 concat 函数的对象。concat 可以连接相同类型的两个对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例：比如 Array具有concat方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;foldable-对象&quot;&gt;&lt;span&gt;Foldable 对象&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;定义：一个拥有 reduce 函数的对象，reduce 可以把一种类型的对象转化为另一种类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例：将一个list转为number&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;var sum = [1,2,3,4].reduce(function(total,val){
  return total += val;
})
console.log(sum);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;类型签名-type-signatures&quot;&gt;&lt;span&gt;类型签名 Type Signatures&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一种注释方式&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;//通常 js 会在注释中指出参数与返回值的类型
// functionName :: firstArgType -&amp;gt; secondArgType -&amp;gt; returnType
// add :: Number -&amp;gt; Number -&amp;gt; Number
const add = (x) =&amp;gt; (y) =&amp;gt; x + y
// increment :: Number -&amp;gt; Number
const increment = (x) =&amp;gt; x + 1

//如果函数的参数也是函数，那么这个函数需要用括号括起来。
// call :: (a -&amp;gt; b) -&amp;gt; a -&amp;gt; b
const call = (f) =&amp;gt; (x) =&amp;gt; f(x)

//字符 a, b, c, d 表明参数可以是任意类型。以下版本的 map 的参数 f，把一种类型 a 的数组转化为另一种类型 b 的数组。
// map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]
const map = (f) =&amp;gt; (list) =&amp;gt; list.map(f)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;代数数据类型-algebraic-data-type&quot;&gt;&lt;span&gt;代数数据类型 Algebraic data type&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;由其他类型组合在一起的复合类型。两种常见的代数类型是 sum 和 product&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;联合类型对象-union-type&quot;&gt;&lt;span&gt;联合类型(对象) Union Type&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;定义：连接不同的数据类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;示例：add就是一个联合类型对象，因为js天然支持number和sting求和时，进行自动数据类型转换&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;// add :: (NumOrString, NumOrString) -&amp;gt; NumOrString
const add = (a, b) =&amp;gt; a + b
add(1, 2) // Returns number 3
add('Foo', 2) // Returns string &quot;Foo2&quot;
add('Foo', 'Bar') // Returns string &quot;FooBar&quot;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;product-type&quot;&gt;&lt;span&gt;Product type&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;定义：用一种你可能更熟悉的方式把数据类型联合起来&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;// point :: (Number, Number) -&amp;gt; {x: Number, y: Number}
const point = (x, y) =&amp;gt; ({x: x, y: y})&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sum-类型有时称为联合类型&quot;&gt;&lt;span&gt;Sum 类型（有时称为联合类型 ）&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;是将两种类型的组合合并成另一种类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;之所以被称为 sum ，是因为结果类型中可能的值的数量是输入类型的总和&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;JavaScript 没有这样的类型，但是我们可以使用 Set 来假装&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;span&gt;&lt;code&gt;// 想象一下，在这里我们不能设置只能具有这些值的类型
const bools = new Set([true, false])
const halfTrue = new Set(['half-true'])
// 弱逻辑类型包含 bools 和 halfTrue 值的总和
const weakLogicValues = new Set([...bools, ...halfTrue])&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;option-maybe&quot;&gt;&lt;span&gt;Option | maybe&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Option 是一种sum type ，它有两种情况，Some 或者 None。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Option 对于组合可能不返回值的函数很有用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在其它的一些地方，Option 也称为 Maybe，Some 也称为 Just，None 也称为 Nothing&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 19 Feb 2019 05:40:00 +0000</pubDate>
<dc:creator>悔不当初-s</dc:creator>
<og:description>程序的幂等性，概念：一个函数执行多次皆返回相同的结果。作用：一个函数被调用多次时，保证内部状态的一致性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zk995/p/10400555.html</dc:identifier>
</item>
</channel>
</rss>