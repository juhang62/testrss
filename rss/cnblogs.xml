<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Netty中的装饰者模式 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11242031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11242031.html</guid>
<description>&lt;h3 id=&quot;装饰者的应用&quot;&gt;装饰者的应用&lt;/h3&gt;
&lt;p&gt;所谓装饰者,说白了,目的就是对现有的对象进行增强,&lt;strong&gt;装饰者设计模式最大的优点就是,它在扩展类原有功能的基础上还避免的类爆炸的情况&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;netty中的装饰者模式的应用&quot;&gt;Netty中的装饰者模式的应用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ByteBuf&lt;/code&gt;是netty中重要的数据容器类,我们看它是如何设计的,如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201907/1496926-20190725084121662-1819596093.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到,&lt;code&gt;ByteBuf&lt;/code&gt;的直接实现类有五个,忽略&lt;code&gt;WrappedByteBuf&lt;/code&gt;这个类,其实直接实现类有四个,为什么要忽略掉&lt;code&gt;WrappedByteBuf&lt;/code&gt;呢? 因为是它是&lt;code&gt;ByteBuf&lt;/code&gt;装饰者的基类; 它本身没有任何实现任何功能;&lt;/p&gt;
&lt;p&gt;netty的设计者在设计&lt;code&gt;ByteBuf&lt;/code&gt;的继承体系时,发现上图中的四个直接实现类可能都需要添加新的功能,这俩功能是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不可释放的功能&lt;/li&gt;
&lt;li&gt;简单的泄漏感知的功能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;怎么扩展这个功能呢?&lt;/p&gt;
&lt;p&gt;如果选择继承的话,现有的四个类全部多出两个子类,让子类添加上特定的功能, 虽然解决了问题,但是类的数量出现了爆炸式的增长 从原来的4长到了 4+4*2&lt;/p&gt;
&lt;p&gt;看上面的图,其实netty的设计者选择的处理模式是装饰者模式,只添加了三个类,就达到了同样的效果&lt;/p&gt;
&lt;h4 id=&quot;装饰者的设计套路&quot;&gt;装饰者的设计套路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;添加一个装饰者顶级类,这个类和需要装饰的组件类在继承处于相等的地位
&lt;ul&gt;&lt;li&gt;这个装饰者类并不作任何的构工作,维护着&lt;code&gt;ByteBuf&lt;/code&gt;的引用, 重写的&lt;code&gt;ByteBuf&lt;/code&gt;的所有方法都是用这个引用完成具体的功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; */
class WrappedByteBuf extends ByteBuf {

    protected final ByteBuf buf;

    protected WrappedByteBuf(ByteBuf buf) {
        if (buf == null) {
            throw new NullPointerException(&quot;buf&quot;);
        }
        this.buf = buf;
    }

    @Override
    public final boolean hasMemoryAddress() {
        return buf.hasMemoryAddress();
    }

    @Override
    public final long memoryAddress() {
        return buf.memoryAddress();
    }
...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;具体的装饰者,继承上面的装饰者的顶级类, 在自己的构造函数中接收&lt;code&gt;ByteBuf&lt;/code&gt;的类型的参数,并把它传递给它的父类,用户在装饰者时,会把创建的最上面的四种待装饰的组件类以构造方法的形式传递进去,整个体系就运行起来了, 而且装饰者可以按照自己的需求重写父类的方法, 或者在现在的基础上添加新的方法调用进行增强&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; */
final class UnreleasableByteBuf extends WrappedByteBuf {

    private SwappedByteBuf swappedBuf;

    UnreleasableByteBuf(ByteBuf buf) {
        super(buf instanceof UnreleasableByteBuf ? buf.unwrap() : buf);
    }

    @Override
    public ByteBuf order(ByteOrder endianness) {
        if (endianness == null) {
            throw new NullPointerException(&quot;endianness&quot;);
        }
        if (endianness == order()) {
            return this;
        }

        SwappedByteBuf swappedBuf = this.swappedBuf;
        if (swappedBuf == null) {
            this.swappedBuf = swappedBuf = new SwappedByteBuf(this);
        }
        return swappedBuf;
    }

    @Override
    public ByteBuf asReadOnly() {
        return buf.isReadOnly() ? this : new UnreleasableByteBuf(buf.asReadOnly());
    }

...&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 25 Jul 2019 00:42:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>装饰者的应用 所谓装饰者,说白了,目的就是对现有的对象进行增强, 装饰者设计模式最大的优点就是,它在扩展类原有功能的基础上还避免的类爆炸的情况 Netty中的装饰者模式的应用 是netty中重要的数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11242031.html</dc:identifier>
</item>
<item>
<title>RDB和AOF的区别 - 我是年少的欢喜你</title>
<link>http://www.cnblogs.com/zxs117/p/11242026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxs117/p/11242026.html</guid>
<description>&lt;p&gt;1、前言&lt;/p&gt;
&lt;p&gt;最近在项目中使用到Redis做缓存，方便多个业务进程之间共享数据。由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。&lt;strong&gt;redis提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF持久化（原理是将Reids的操作日志以追加的方式写入文件）&lt;/strong&gt;。那么这两种持久化方式有什么区别呢，改如何选择呢？网上看了大多数都是介绍这两种方式怎么配置，怎么使用，就是没有介绍二者的区别，在什么应用场景下使用。&lt;/p&gt;
&lt;p&gt;2、二者的区别&lt;/p&gt;
&lt;p&gt;RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://img1.tuicool.com/NjYjYvF.png!web?_=6182478&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://img2.tuicool.com/YrqaY3f.png!web?_=6182478&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、二者优缺点&lt;/p&gt;
&lt;p&gt;RDB存在哪些优势呢？&lt;/p&gt;
&lt;p&gt;1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。&lt;/p&gt;
&lt;p&gt;2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。&lt;/p&gt;
&lt;p&gt;3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。&lt;/p&gt;
&lt;p&gt;4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。&lt;/p&gt;
&lt;p&gt;RDB又存在哪些劣势呢？&lt;/p&gt;
&lt;p&gt;1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。&lt;/p&gt;
&lt;p&gt;2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。&lt;/p&gt;
&lt;p&gt;AOF的优势有哪些呢？&lt;/p&gt;
&lt;p&gt;1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。&lt;/p&gt;
&lt;p&gt;2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。&lt;/p&gt;
&lt;p&gt;3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。&lt;/p&gt;
&lt;p&gt;4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。&lt;/p&gt;
&lt;p&gt;AOF的劣势有哪些呢？&lt;/p&gt;
&lt;p&gt;1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。&lt;/p&gt;
&lt;p&gt;2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。&lt;/p&gt;
&lt;p&gt;二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。不过生产环境其实更多都是二者结合使用的。&lt;/p&gt;
&lt;p&gt;4、常用配置&lt;/p&gt;
&lt;p&gt;RDB持久化配置&lt;/p&gt;
&lt;p&gt;Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：&lt;/p&gt;
&lt;p&gt;save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。&lt;/p&gt;
&lt;p&gt;save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。&lt;/p&gt;
&lt;p&gt;save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。&lt;/p&gt;
&lt;p&gt;AOF持久化配置&lt;/p&gt;
&lt;p&gt;在Redis的配置文件中存在三种同步方式，它们分别是：&lt;/p&gt;
&lt;p&gt;appendfsync always     #每次有数据修改发生时都会写入AOF文件。&lt;/p&gt;
&lt;p&gt;appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。&lt;/p&gt;
&lt;p&gt;appendfsync no          #从不同步。高效但是数据不会被持久化。&lt;/p&gt;
&lt;p&gt;5、参考资料&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/jackpk/article/details/30073097&quot; rel=&quot;nofollow&quot;&gt;http://blog.csdn.net/jackpk/article/details/30073097&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jb51.net/article/65264.htm&quot; rel=&quot;nofollow&quot;&gt;http://www.jb51.net/article/65264.htm&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jul 2019 00:40:00 +0000</pubDate>
<dc:creator>我是年少的欢喜你</dc:creator>
<og:description>redis的持久化方式RDB和AOF的区别 redis的持久化方式RDB和AOF的区别 redis的持久化方式RDB和AOF的区别 redis的持久化方式RDB和AOF的区别 1、前言 最近在项目中使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zxs117/p/11242026.html</dc:identifier>
</item>
<item>
<title>前端构造函数、原型、实例对象之间的关系 - 凡斗</title>
<link>http://www.cnblogs.com/shenchanglu/p/11242025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenchanglu/p/11242025.html</guid>
<description>
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;          构造函数：无论是构造函数还是非构造函数，两者并没有实质性的区别；构造函数可以作为普通函数使用，普通函数也可以作为构造函数来用；&lt;span&gt;&lt;code&gt;首字母大小写仅仅是为了在开发中能易于区分他们。&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;          只要通过 new 操作符来调用，那就是作为构造函数使用，此时this指向new出的实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;          如果不通过 new 操作符来调用，那就是作为普通函数使用；此时，在非严格模式下this都指向window&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;         原型：相当于一个模具，用来生产实例对象。js里实现面向对象的方式，也就是说，js就是基于原型的面向对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;         js实例对象 :就是object&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jul 2019 00:39:00 +0000</pubDate>
<dc:creator>凡斗</dc:creator>
<og:description>构造函数：无论是构造函数还是非构造函数，两者并没有实质性的区别；构造函数可以作为普通函数使用，普通函数也可以作为构造函数来用；首字母大小写仅仅是为了在开发中能易于区分他们。 只要通过 new 操作符来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shenchanglu/p/11242025.html</dc:identifier>
</item>
<item>
<title>.net持续集成sonarqube篇之sonarqube基本操作(二) - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11241963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11241963.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;activity界面操作&quot;&gt;Activity界面操作&lt;/h2&gt;
&lt;p&gt;Activity界面主要是对多次构建管理界面,主要是帮助管理员快速了解项目每次构建与以往构建相比问题是增加了还是减少了等指标.由于目前我们仅进行了一次构建,因此没有对比数据,我们再对测试项目进行一次构建.&lt;/p&gt;
&lt;p&gt;构建代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SonarScanner.MSBuild.exe begin /k:&quot;mygetdata&quot; /v:&quot;2.0&quot;
MSBuild.exe /t:Rebuild
SonarScanner.MSBuild.exe end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与前一次构建相比,这里仅仅是把版本号从1.0升到2.0,其它的没有变化.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;以上命令在cmd里执行即可,需要说明的是以上构建没有指定项目名,因此需要在项目的sln或者csproj文件所在的目录下执行.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;需要注意的是,两个构建只要key相同,就会被认为是同一个项目的构建.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;构建完以后,我们把标签切换到&lt;code&gt;overview&lt;/code&gt;标签,可以看到如下图示界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190725080241409-645078555.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到右连连新增加了黄色高亮的统计,这个统计是相对于前一次构建新增bug数量等信息的统计&lt;/p&gt;
&lt;p&gt;我们再把页面切换到Activity界面.可以看到这个页面内容丰富起来了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190725080235584-1210529547.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图标里的线代一次构建.鼠标放到线上便可以看到这次构建的综合信息.如果构建特别多,我们还可以根据日期来过滤,把范围锁定到更小的功范围内.&lt;/p&gt;
&lt;h2 id=&quot;sonarqube-issue界面操作&quot;&gt;Sonarqube issue界面操作&lt;/h2&gt;
&lt;p&gt;Issue界面是管理员管理问题细节的一个重要界面.管理员可以在这个界面根据问题等级,问题解决状态来查看问题,指定问题给特定开发人员解决.同时也是开发人员查看分配给自己问题的重要界面.下面简要介绍一下这个页面的操作.&lt;/p&gt;
&lt;p&gt;打开这个页面如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190725080356776-2126316164.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初看代码密密麻麻,有种不知所措的感觉.这是因为sonarqube默认把所有的有问题代码都显示出来了,我们可以对其进行过滤.&lt;/p&gt;
&lt;p&gt;我们可以看到左侧Bug,Vulnerablity,codesmell都蓝色高亮显示,表示它们处于选中状态,如果我们只想查看bug,则点击一下bug,下面的两项就会取消选中.此时只显示bug级别的问题.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190725080349796-113546353.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面还有问题的严重级别(Severity)可供选择用于过滤.如果想要同时过滤多个条件,按住ctrl键同时点击严重级别的类型即可选择多个.&lt;/p&gt;
&lt;p&gt;下面还有很多可供过滤选择的内容,这里不再一一介绍.&lt;/p&gt;
&lt;p&gt;下面介绍一下关于bug处理的选项.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190725080341253-911780743.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图所示为过滤后的问题界面.每个红框都是一个要处理的问题.点击其中一个红框,便可以进入问题的详细页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190725080335182-1399944733.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成问题链接&quot;&gt;生成问题链接&lt;/h3&gt;
&lt;p&gt;可以看到红框的最右边有一个链子图标,点击便可以生成一个问题链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190725080326794-24480391.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个页面与上面的相比可以看到红框只有一个,便于把问题分享给其它人处理(分享给别人的链接如果包含的要处理的问题太多,别人很难定位到问题),只需要把页面的url复制然后分享给别人即可.&lt;/p&gt;
&lt;h3 id=&quot;更改问题分类&quot;&gt;更改问题分类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190725080319726-1268212494.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图我们可以看到红框下面有很多图标,并有文字描述,通过点击这些图标我们可以更改问题的类型,问题的严重级别,问题的处理情况,指定问题给特定开发者处理,对问题添加评论等.大家可以试一试,这里不再详细描述.&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jul 2019 00:07:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' Activity界面操作 Activity界面主要是对多次构建管理界面,主要是帮助管理员快速了解项目每次构建与以往构建相比问题是增加了还是减少了等指标.由于目前我们仅进行了一次构建,因此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11241963.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 中的管道机制 - hippieZhou</title>
<link>http://www.cnblogs.com/hippieZhou/p/11205573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hippieZhou/p/11205573.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718105721853-511996160.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.5369774919614&quot;&gt;
&lt;p&gt;首先，很感谢在上篇文章 &lt;a href=&quot;https://www.cnblogs.com/hippieZhou/p/11174644.html&quot;&gt;C# 管道式编程&lt;/a&gt; 中给我有小额捐助和点赞的朋友们，感谢你们的支持与肯定。希望我的每一次分享都能让彼此获得一些收获，当然如果我有些地方叙述的不正确或不当，还请不客气的指出。好了，下面进入正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在开始之前，我们需要明确的一个概念是，在 Web 程序中，用户的每次请求流程都是线性的，放在 ASP.NET Core 程序中，都会对应一个 &lt;strong&gt;请求管道（request pipeline）&lt;/strong&gt;，在这个请求管道中，我们可以动态配置各种业务逻辑对应的 &lt;strong&gt;中间件（middleware）&lt;/strong&gt;，从而达到服务端可以针对不同用户做出不同的请求响应。在 ASP.NET Core 中，管道式编程是一个核心且基础的概念，它的很多中间件都是通过 &lt;strong&gt;管道式&lt;/strong&gt; 的方式来最终配置到请求管道中的，所以理解这里面的管道式编程对我们编写更加健壮的 DotNetCore 程序相当重要。&lt;/p&gt;
&lt;h2 id=&quot;剖析管道机制&quot;&gt;剖析管道机制&lt;/h2&gt;
&lt;p&gt;在上面的论述中，我们提到了两个很重要的概念：&lt;strong&gt;请求管道（request pipeline）&lt;/strong&gt; 和 &lt;strong&gt;中间件（middleware）&lt;/strong&gt;。对于它俩的关系，我个人的理解是，首先，请求管道服务于用户，其次，请求管道可以将多个相互独立的业务逻辑模块（即中间件）串联起来，然后服务于用户请求。这样做的好处是可以将业务逻辑层级化，因为在实际的业务场景中，有些业务的处理即相互独立，又依赖于其它的业务操作，各个业务模块之间的关系实际上是动态不固定的。&lt;/p&gt;
&lt;p&gt;下面，我们尝试着来一步步解析 ASP.NET Core 中的管道机制。&lt;/p&gt;
&lt;h3 id=&quot;理论解释&quot;&gt;理论解释&lt;/h3&gt;
&lt;p&gt;首先，我们来看一下官方的图例解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718113742611-1129726883.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中，我们不难看出，当用户发出一起请求后，应用程序都会为其创建一个请求管道，在这个请求管道中，每一个中间件都会按顺序进行处理（可能会执行，也可能不会被执行，取决于具体的业务逻辑），等最后一个中间件处理完毕后请求又会以相反的方向返回给用户最终的处理结果。&lt;/p&gt;
&lt;h3 id=&quot;代码阐释&quot;&gt;代码阐释&lt;/h3&gt;
&lt;p&gt;为了验证上述我们的理论解释，我们开始创建一个 DotNetCore 的控制台项目，然后引用如下包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Microsoft.AspNetCore.App&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;编写如下示例代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    private static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
        Host.CreateDefaultBuilder(args).ConfigureWebHostDefaults(webBuilder =&amp;gt;
        {
            webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
        });
}

public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        // Middleware A
        app.Use(async (context, next) =&amp;gt;
        {
            Console.WriteLine(&quot;A (in)&quot;);
            await next();
            Console.WriteLine(&quot;A (out)&quot;);
        });

        // Middleware B
        app.Use(async (context, next) =&amp;gt;
        {
            Console.WriteLine(&quot;B (in)&quot;);
            await next();
            Console.WriteLine(&quot;B (out)&quot;);
        });

        // Middleware C
        app.Run(async context =&amp;gt;
        {
            Console.WriteLine(&quot;C&quot;);
            await context.Response.WriteAsync(&quot;Hello World from the terminal middleware&quot;);
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码段展示了一个最简单的 ASP.NET Core Web 程序，尝试 F5 运行我们的程序，然后打开浏览器访问 &lt;a href=&quot;http://127.0.0.1:5000&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:5000&lt;/a&gt; 会看到浏览器显示了 Hello World from the terminal middleware 的信息。对应的控制台信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718164837125-868968306.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述示例程序成功验证了我们理论解释中的一些设想，这说明在 Configure 函数中成功构建了一个完成的请求管道，那既然这样，我们就可以将其修改为我们之前使用管道的方式，示例代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.Use(async (context, next) =&amp;gt;
        {
            Console.WriteLine(&quot;A (int)&quot;);
            await next();
            Console.WriteLine(&quot;A (out)&quot;);
        }).Use(async (context, next) =&amp;gt;
        {
            Console.WriteLine(&quot;B (int)&quot;);
            await next();
            Console.WriteLine(&quot;B (out)&quot;);
        }).Run(async context =&amp;gt;
        {
            Console.WriteLine(&quot;C&quot;);
            await context.Response.WriteAsync(&quot;Hello World from the terminal middleware&quot;);
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个方式都能让我们的请求管道正常运行，只是写的方式不同。至于采用哪种方式完全看个人喜好。需要注意的是，最后一个控制台中间件需要最后注册，因为它的处理是单向的，不涉及将用户请求修改后返回。&lt;/p&gt;
&lt;p&gt;同样的，我们也可以对我们的管道中间件进行条件式组装（分叉路由），组装条件可以依据具体的业务场景而定，这里我以路由为条件进行组装，不同的访问路由最终访问的中间件是不一样的，示例代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        // Middleware A
        app.Use(async (context, next) =&amp;gt;
        {
            Console.WriteLine(&quot;A (in)&quot;);
            await next();
            Console.WriteLine(&quot;A (out)&quot;);
        });

        // Middleware B
        app.Map(
                new PathString(&quot;/foo&quot;),
                a =&amp;gt; a.Use(async (context, next) =&amp;gt;
                {
                    Console.WriteLine(&quot;B (in)&quot;);
                    await next();
                    Console.WriteLine(&quot;B (out)&quot;);
                }));

        // Middleware C
        app.Run(async context =&amp;gt;
        {
            Console.WriteLine(&quot;C&quot;);
            await context.Response.WriteAsync(&quot;Hello World from the terminal middleware&quot;);
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们直接访问 &lt;a href=&quot;http://127.0.0.1:5000&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:5000&lt;/a&gt; 时，对应的请求路由输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718165126641-1304030059.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的页面会回显 Hello World from the terminal middleware&lt;/p&gt;
&lt;p&gt;当我们直接访问 &lt;a href=&quot;httP://127.0.0.1:5000/foo&quot; class=&quot;uri&quot;&gt;httP://127.0.0.1:5000/foo&lt;/a&gt; 时，对应的请求路由输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718165143762-364532396.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们尝试查看对应的请求页面，发现对应的页面却是 &lt;strong&gt;HTTP ERROR 404&lt;/strong&gt; ，通过上述输出我们可以找到原因，是由于最后一个注册的终端路由未能成功调用，导致不能返回对应的请求结果。针对这种情况有两种解决方法。&lt;/p&gt;
&lt;p&gt;一种是在我们的 路由B 中直接返回请求结果，示例代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;app.Map(
    new PathString(&quot;/foo&quot;),
    a =&amp;gt; a.Use(async (context, next) =&amp;gt;
    {
        Console.WriteLine(&quot;B (in)&quot;);
        await next();
        await context.Response.WriteAsync(&quot;Hello World from the middleware B&quot;);
        Console.WriteLine(&quot;B (out)&quot;);
    }));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式不太推荐，因为它极易导致业务逻辑的不一致性，违反了 &lt;strong&gt;单一职责原则&lt;/strong&gt; 的思想。&lt;/p&gt;
&lt;p&gt;另一种解决办法是通过路由匹配的方式，示例代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;app.UseWhen(
    context =&amp;gt; context.Request.Path.StartsWithSegments(new PathString(&quot;/foo&quot;)),
    a =&amp;gt; a.Use(async (context, next) =&amp;gt;
    {
        Console.WriteLine(&quot;B (in)&quot;);
        await next();
        Console.WriteLine(&quot;B (out)&quot;);
    }));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过使用 &lt;strong&gt;UseWhen&lt;/strong&gt; 的方式，添加了一个业务中间件对应的业务条件，在该中间件执行完毕后会自动回归到主的请求管道中。最终对应的日志输出入下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718171511115-2107402268.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的，我们也可以自定义一个中间件，示例代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        // app.UseMiddleware&amp;lt;CustomMiddleware&amp;gt;();
        //等价于下述调用方式
        app.UseCustomMiddle();

        // Middleware C
        app.Run(async context =&amp;gt;
        {
            Console.WriteLine(&quot;C&quot;);
            await context.Response.WriteAsync(&quot;Hello World from the terminal middleware&quot;);
        });
    }
}

public class CustomMiddleware
{
    private readonly RequestDelegate _next;
    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext httpContext)
    {
        Console.WriteLine(&quot;CustomMiddleware (in)&quot;);
        await _next.Invoke(httpContext);
        Console.WriteLine(&quot;CustomMiddleware (out)&quot;);
    }
}

public static class CustomMiddlewareExtension
{
    public static IApplicationBuilder UseCustomMiddle(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&amp;lt;CustomMiddleware&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志输出如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718173650349-1330399610.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于 ASP.NET Core 中的自定义中间件都是通过 &lt;strong&gt;依赖注入（DI）&lt;/strong&gt; 的的方式来进行实例化的。所以对应的构造函数，我们是可以注入我们想要的数据类型，不光是 &lt;code&gt;RequestDelegate&lt;/code&gt;；其次，我们自定义的中间件还需要实现一个公有的 &lt;code&gt;public void Invoke(HttpContext httpContext)&lt;/code&gt; 或 &lt;code&gt;public async Task InvokeAsync(HttpContext httpContext)&lt;/code&gt; 的方法，该方法内部主要处理我们的自定义业务，并进行中间件的连接，扮演着 &lt;strong&gt;枢纽中心&lt;/strong&gt; 的角色。&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;由于 ASP.NET Core 是完全开源跨平台的，所以我们可以很容易的在 &lt;a href=&quot;https://github.com/aspnet/AspNetCore&quot;&gt;Github&lt;/a&gt; 上找到其对应的托管仓库。最后，我们可以看一下 ASP.NET Core 官方的一些实现代码。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718175619050-1120899971.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官方开源了内置中间件的全部实现代码，这里我以 &lt;code&gt;健康检查（HeathChecks）&lt;/code&gt; 中间件为例，来验证一下我们上面说的自定义中间件的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201907/749711-20190718181407233-238884345.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过查阅源码，我们可以看出，我们上述自定义的中间件是符合官方的实现标准的。同样的，当我们以后使用某个内置中间件时，如果对其具体实现感兴趣，可以通过这种方式来进行查看。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;当我们对 ASP.NET Core 的请求管道进行中间件配置的时候，有一个地方需要注意一下，就是中间件的配置一定要具体的业务逻辑顺序进行，比如网关配置一定要先于路由配置，结合到代码就是下述示例：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    //......
    app.UseAuthentication();
    //......
    app.UseMvc();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果当我们的中间件顺序配置不当的话，极有可能导致相应的业务出现问题。&lt;/p&gt;
&lt;p&gt;就 ASP.NET Core 的技术架构而言，管道式编程只是其中很小很基础的一部分，整个技术框架设计与实现，用到了很多优秀的技术和架构思想。但是这些高大上的实现都是基于基础技术衍化而来的，所以，基础很重要，只有把基础打扎实了，才不会被技术浪潮所淘汰。&lt;/p&gt;
&lt;p&gt;上述所有内容就是我个人对 ASP.NET Core 中的管道式编程的一些理解和拙见，如果有不正确或不当的地方，还请斧正。&lt;/p&gt;
&lt;p&gt;望共勉！&lt;/p&gt;
&lt;h2 id=&quot;相关参考&quot;&gt;相关参考&lt;/h2&gt;
</description>
<pubDate>Wed, 24 Jul 2019 23:58:00 +0000</pubDate>
<dc:creator>hippieZhou</dc:creator>
<og:description>首先，很感谢在上篇文章 'C 管道式编程' 中给我有小额捐助和点赞的朋友们，感谢你们的支持与肯定。希望我的每一次分享都能让彼此获得一些收获，当然如果我有些地方叙述的不正确或不当，还请不客气的指出。好了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hippieZhou/p/11205573.html</dc:identifier>
</item>
<item>
<title>独享还是共享，你选择哪一种锁？ - Java极客技术</title>
<link>http://www.cnblogs.com/justdojava/p/11212114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justdojava/p/11212114.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw6FIf5Fu0lM7yfOx2FibL3SlFUoxQibVUBicYSbrJTB1Ja7mjZe6GV3Gw5570zrZQbA2IbxntQMRicFbQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.9836065573770492&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;305&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;之前在的文章中已经写了公平锁和非公平锁了，接下来就该介绍第二种锁了，他就是共享锁和独享锁，顾名思义，独享，只能被一个线程 所持有，而共享，就是说可以被多个线程所共有。&lt;/p&gt;
&lt;h2&gt;锁的分类&lt;/h2&gt;
&lt;p&gt;1.公平锁/非公平锁&lt;/p&gt;
&lt;p&gt;2.可重入锁3.独享锁/共享锁4.互斥锁/读写锁5.乐观锁/悲观锁6.分段锁7.偏向锁/轻量级锁/重量级锁8.自旋锁&lt;/p&gt;
&lt;p&gt;之前的第一次分享中我们已经说过了公平锁和非公平锁了，这次我们组要来解析一下这个独享锁和共享锁。&lt;/p&gt;
&lt;h3&gt;独享锁&lt;/h3&gt;
&lt;p&gt;独享锁其实有很多名称的，有人称它为独享锁，有人也称它为独占锁，其实大致上都是一个意思，&lt;/p&gt;
&lt;p&gt;独享锁，只能够被一个线程所持有，&lt;/p&gt;
&lt;p&gt;而他的实例我们之前的公平锁和非公平锁也都说过一次，我们可以再看一下这个实例，&lt;/p&gt;


&lt;h3&gt;ReentrantLock(独享)&lt;/h3&gt;
&lt;p&gt;ReentrantLock是基于AQS来实现的，那什么是AQS呢？&lt;/p&gt;
&lt;p&gt;AQS全称AbstractQueuedSynchronizer,如果说使用翻译软件来看“摘要排队同步器”，但是很多人喜欢称它为抽象队列同步器。 其实叫什么倒是没有那么重要，只要记住英文，这才是最重要的。&lt;/p&gt;

&lt;p&gt;AQS它定义了一套多线程访问共享资源的同步器框架，很多类都是依赖于AQS来比如说我们一会将要介绍的ReentrantLock。&lt;/p&gt;
&lt;p&gt;你看源码&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    查询是否有任何线程正在等待与此锁相关联的给定条件。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    请注意，由于超时和*中断可能随时发生，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    此方法主要用于监视系统状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public boolean hasWaiters(Condition condition) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (condition == null)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new NullPointerException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new IllegalArgumentException(&quot;not owner&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就指明了我们说的ReentrantLock是依赖AQS的，而AQS它是JUC并发包中的一个核心的一个组件。 也是不可或缺的组件。&lt;/p&gt;

&lt;p&gt;AQS解决了子啊实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。&lt;/p&gt;

&lt;p&gt;在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。&lt;/p&gt;

&lt;p&gt;AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。&lt;/p&gt;
&lt;p&gt;咱们可以看一下&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public abstract class AbstractQueuedSynchronizer&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    extends AbstractOwnableSynchronizer&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    implements java.io.Serializable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private static final long serialVersionUID = 7373984972572414691L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而它典型的例子ReentrantLock中：&lt;/p&gt;
&lt;p&gt;使用一个int类型的成员变量state来表示同步状态，当state&amp;gt;0时表示已经获取了锁&lt;/p&gt;
&lt;p&gt;这就是我们之前看的int c = getState()；&lt;/p&gt;
&lt;p&gt;而当c等于0的时候说明当前没有线程占有锁，它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，所以AQS可以确保对state的操作是安全的。&lt;/p&gt;
&lt;p&gt;关于AQS我就解释这么多把，如果想深入了解的可以仔细的研究一下，而在这个ReentrantLock中的源码是这样的&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;它默认是非公平锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public ReentrantLock() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sync = new NonfairSync();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   创建ReentrantLock，公平锁or非公平锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public ReentrantLock(boolean fair) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     sync = fair ? new FairSync() : new NonfairSync();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 而他会分别调用lock方法和unlock方法来释放锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public void lock() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         sync.lock();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public void unlock() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         sync.release(1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是其实他不仅仅是会调用lock和unlock方法，因为我们的线程不可能一点问题没有，如果说进入到了waiting状态，在这个时候如果没有unpark()方法，就没有办法来唤醒他， 所以，也就接踵而至出现了tryLock(),tryLock(long,TimeUnit)来做一些尝试加锁或者说是超市来满足某些特定的场景的需求了。&lt;/p&gt;

&lt;p&gt;ReentrantLock会保证method-body在同一时间只有一个线程在执行这段代码，或者说，同一时刻只有一个线程的lock方法会返回。其余线程会被挂起，直到获取锁。&lt;/p&gt;

&lt;p&gt;从这里我们就能看出，其实ReentrantLock实现的就是一个独占锁的功能：有且只有一个线程获取到锁，其余线程全部挂起，直到该拥有锁的线程释放锁，被挂起的线程被唤醒重新开始竞争锁。&lt;/p&gt;

&lt;p&gt;而在源码中通过AQS来获取独享锁是通过调用acquire方法，其实这个方法是阻塞的,&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*以独占模式获取，忽略中断。通过至少调用tryAcquire实现&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;成功返回。否则线程排队，可能重复阻塞和解除阻塞，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;调用tryAcquire直到成功。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;此方法可用于实现方法lock。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public final void acquire(int arg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            selfInterrupt();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;它通过tryAcquire（由子类Sync实现）尝试获取锁，这也是上面源码中的lock方法的实现步骤&lt;/p&gt;

&lt;p&gt;而没有获取到锁则调用AQS的acquireQueued方法：&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;final boolean acquireQueued(final Node node, int arg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        boolean failed = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            boolean interrupted = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            for (;;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                final Node p = node.predecessor();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    setHead(node);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    p.next = null; // help GC&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    failed = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    return interrupted;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    parkAndCheckInterrupt())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    interrupted = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } finally {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (failed)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                cancelAcquire(node);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段的意思大致就是说 当前驱节点是头节点，并且独占时才返回&lt;/p&gt;
&lt;p&gt;而在下面的if判断中，他会去进行阻塞，而且还要去判断是否打断，如果我们的节点状态是Node.SIGNAL时， 完蛋了，线程将会执行parkAndCheckInterrupt方法，知道有线程release的时候，这时候就会进行一个unpark来循环的去获取锁。 而这个方法通过LockSupport.park(this)将当前的线程挂起到WATING的状态，就需要我们去执行unpark方法了来唤醒他，也就是我说的那个release， 通过这样的一种FIFO机制的等待就实现了LOCK的操作。&lt;/p&gt;

&lt;p&gt;这上面的代码只是进行加锁，但是没有释放锁，如果说我们获得了锁不进行释放，那么很自然的出现一种情况，死锁！&lt;/p&gt;
&lt;p&gt;所以必须要进行一个释放，&lt;/p&gt;
&lt;p&gt;我们来看看内部是怎么释放锁的&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public void unlock()              { sync.release(1); }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public final boolean release(int arg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         if (tryRelease(arg)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             Node h = head;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 unparkSuccessor(h);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             return true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         return false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;unlock方法间接调用AQS的release(1)来完成释放&lt;/p&gt;
&lt;p&gt;tryRelease(int)方法进行了特殊的判定，如果成立则会将head传入unparkSuccessor(Node) 方法中并且返回true，否则返回的就是false。&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public final boolean release(int arg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (tryRelease(arg)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Node h = head;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                unparkSuccessor(h);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;而他在执行了unparkSuccessor方法中的时候，就已经意味着要真正的释放锁了。 这其实就是独享锁进行获取锁和释放锁的一个过程！有兴趣的可以去源码中把注释翻译一下看看。&lt;/p&gt;

&lt;h3&gt;共享锁&lt;/h3&gt;
&lt;p&gt;从我们之前的独享所就能看得出来，独享锁是使用的一个状态来进行锁标记的，共享锁其实也差不多，但是JAVA中有不想定力两个状态，所以区别出现了， 他们的锁状态时不一样的。&lt;/p&gt;

&lt;p&gt;基本的流程是一样的，主要区别在于判断锁获取的条件上，由于是共享锁，也就允许多个线程同时获取，所以同步状态的数量同时的大于1的，如果同步状态为非0，则线程就可以获取锁，只有当同步状态为0时，才说明共享数量的锁已经被全部获取，其余线程只能等待。&lt;/p&gt;

&lt;p&gt;最典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。&lt;/p&gt;

&lt;p&gt;我们来看一下他的获取锁和释放锁的代码体现。&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //获取锁指定离不开这个lock方法，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void lock() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                sync.acquireShared(1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //acquireShared()首先会通过tryAcquireShared()来尝试获取锁。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //如果说获取不到那么他就回去执行  doAcquireShared(arg);直到获取到锁才会返回&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //你看方法名do是不是想到了do-while呢？&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public final void acquireShared(int arg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (tryAcquireShared(arg) &amp;lt; 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                doAcquireShared(arg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // tryAcquireShared()来尝试获取锁。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected int tryAcquireShared(int arg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            throw new UnsupportedOperationException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //只有这个方法获取到锁了才会进行返回&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private void doAcquireShared(int arg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            final Node node = addWaiter(Node.SHARED);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            boolean failed = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                boolean interrupted = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                for (;;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    final Node p = node.predecessor();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (p == head) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        int r = tryAcquireShared(arg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        if (r &amp;gt;= 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            setHeadAndPropagate(node, r);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            p.next = null; // help GC&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            if (interrupted)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                selfInterrupt();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            failed = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        parkAndCheckInterrupt())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        interrupted = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } finally {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (failed)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    cancelAcquire(node);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     //上面的这些方法全部都是在AbstractQueuedSynchronizer中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     //而他通过Sync来调用的acquireShared&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     //而Sync则是继承的AbstractQueuedSynchronizer&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     abstract static class Sync extends AbstractQueuedSynchronizer &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     而他调用的tryAcquireShared则是在ReentrantReadWriteLock中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     protected final int tryAcquireShared(int unused) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 Thread current = Thread.currentThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 //获取状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 int c = getState();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 //如果说锁状态不是0 并且获取锁的线程不是current线程 返回-1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 if (exclusiveCount(c) != 0 &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     getExclusiveOwnerThread() != current)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     return -1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 //统计读锁的次数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 int r = sharedCount(c);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 //若无需等待，并且共享读锁共享次数小于MAX_COUNT，则会把锁的共享次数加一，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 //否则他会去执行fullTryAcquireShared&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 if (!readerShouldBlock() &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     r &amp;lt; MAX_COUNT &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     compareAndSetState(c, c + SHARED_UNIT)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     if (r == 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                         firstReader = current;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                         firstReaderHoldCount = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     } else if (firstReader == current) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                         firstReaderHoldCount++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                         HoldCounter rh = cachedHoldCounter;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                         if (rh == null || rh.tid != getThreadId(current))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                             cachedHoldCounter = rh = readHolds.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                         else if (rh.count == 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                             readHolds.set(rh);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                         rh.count++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     return 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 return fullTryAcquireShared(current);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        /** fullTryAcquireShared()会根据是否需要阻塞等待&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        读取锁的共享计数是否超过限制”等等进行处理。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        如果不需要阻塞等待，并且锁的共享计数没有超过限制，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        则通过CAS尝试获取锁，并返回1。*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      final int fullTryAcquireShared(Thread current) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          /*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           * This code is in part redundant with that in&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           * tryAcquireShared but is simpler overall by not&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           * complicating tryAcquireShared with interactions between&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           * retries and lazily reading hold counts.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          HoldCounter rh = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          for (;;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              int c = getState();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              if (exclusiveCount(c) != 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  if (getExclusiveOwnerThread() != current)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      return -1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  // else we hold the exclusive lock; blocking here&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  // would cause deadlock.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              } else if (readerShouldBlock()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  // Make sure we're not acquiring read lock reentrantly&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  if (firstReader == current) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      // assert firstReaderHoldCount &amp;gt; 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      if (rh == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          rh = cachedHoldCounter;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          if (rh == null || rh.tid != getThreadId(current)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                              rh = readHolds.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                              if (rh.count == 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                  readHolds.remove();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      if (rh.count == 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          return -1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              if (sharedCount(c) == MAX_COUNT)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  throw new Error(&quot;Maximum lock count exceeded&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              if (compareAndSetState(c, c + SHARED_UNIT)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  if (sharedCount(c) == 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      firstReader = current;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      firstReaderHoldCount = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  } else if (firstReader == current) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      firstReaderHoldCount++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      if (rh == null)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          rh = cachedHoldCounter;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      if (rh == null || rh.tid != getThreadId(current))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          rh = readHolds.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      else if (rh.count == 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          readHolds.set(rh);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      rh.count++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      cachedHoldCounter = rh; // cache for release&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  return 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;以上的源码就是共享锁的一个获取锁的过程&lt;/p&gt;
&lt;p&gt;接下来肯定是要进行锁的释放了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unlock()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void unlock() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            sync.releaseShared(1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //和获取锁的过程类似，他首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //则通过doReleaseShared()去释放共享锁。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     public final boolean releaseShared(int arg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (tryReleaseShared(arg)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            doReleaseShared();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //是尝试释放共享锁第一步。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected final boolean tryReleaseShared(int unused) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread current = Thread.currentThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (firstReader == current) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // assert firstReaderHoldCount &amp;gt; 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (firstReaderHoldCount == 1)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                firstReader = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                firstReaderHoldCount--;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            HoldCounter rh = cachedHoldCounter;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (rh == null || rh.tid != getThreadId(current))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                rh = readHolds.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int count = rh.count;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (count &amp;lt;= 1) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                readHolds.remove();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (count &amp;lt;= 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    throw unmatchedUnlockException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            --rh.count;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        for (;;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int c = getState();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int nextc = c - SHARED_UNIT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (compareAndSetState(c, nextc))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // Releasing the read lock has no effect on readers,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // but it may allow waiting writers to proceed if&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // both read and write locks are now free.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                return nextc == 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    //持续执行释放共享锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private void doReleaseShared() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            /*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * Ensure that a release propagates, even if there are other&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * in-progress acquires/releases.  This proceeds in the usual&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * way of trying to unparkSuccessor of head if it needs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * signal. But if it does not, status is set to PROPAGATE to&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * ensure that upon release, propagation continues.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * Additionally, we must loop in case a new node is added&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * while we are doing this. Also, unlike other uses of&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * unparkSuccessor, we need to know if CAS to reset status&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             * fails, if so rechecking.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            for (;;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Node h = head;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (h != null &amp;amp;&amp;amp; h != tail) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    int ws = h.waitStatus;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (ws == Node.SIGNAL) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            continue;            // loop to recheck cases&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        unparkSuccessor(h);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    else if (ws == 0 &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                             !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        continue;                // loop on failed CAS&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (h == head)                   // loop if head changed&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上的代码就是共享锁和非共享锁的源码。需要注意的时候，在这里其实很乱，有些方法是定义在ReentrantReadWriteLock中的， 而有一些方法是定义在AbstractQueuedSynchorizer中的，所以在来回切换看代码的时候尤其要注意，不要出现失误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;独享锁：同时只能有一个线程获得锁。&lt;/p&gt;
&lt;p&gt;共享锁：可以有多个线程同时获得锁。&lt;/p&gt;
&lt;p&gt;关于独享锁和共享锁，你明白了吗？&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Java 极客技术公众号，是由一群热爱 Java 开发的技术人组建成立，专注分享原创、高质量的 Java 文章。&lt;/strong&gt;&lt;strong&gt;如果您觉得我们的文章还不错，请帮忙赞赏、在看、转发支持，鼓励我们分享出更好的文章。 关注公众号，大家可以在公众号后台回复“博客园”，免费获得作者 Java 知识体系/面试必看资料。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4HxcgPDQRiaQcGWmoqB7Fj8MuG51ic0QUXT2Ytq1NRiawzPNfQzjZzAWbv8JfD3ejia1ibvUYQOqFDqIw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;220&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;123&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Jul 2019 23:42:00 +0000</pubDate>
<dc:creator>Java极客技术</dc:creator>
<og:description>之前在的文章中已经写了公平锁和非公平锁了，接下来就该介绍第二种锁了，他就是共享锁和独享锁，顾名思义，独享，只能被一个线程 所持有，而共享，就是说可以被多个线程所共有。 锁的分类 1.公平锁/非公平锁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justdojava/p/11212114.html</dc:identifier>
</item>
<item>
<title>Unity AR Foundation 和 CoreML: 实现手部的检测和追踪 - 陈嘉栋</title>
<link>http://www.cnblogs.com/murongxiaopifu/p/11241913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/murongxiaopifu/p/11241913.html</guid>
<description>&lt;h2&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;Unity的&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Packages/com.unity.xr.arfoundation%401.5/manual/index.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;AR Foundation&lt;/a&gt;通过上层抽象，对ARKit和ARCore这些底层接口进行了封装，从而实现了AR项目的跨平台开发能力。&lt;/p&gt;
&lt;p&gt;而苹果的CoreML是一个可以用来将机器学习模型与iOS平台上的app进行集成的框架。&lt;/p&gt;
&lt;p&gt;本文以及本文结尾处的demo工程，将介绍和演示如何使Unity的AR Foundation与苹果的CoreML一同工作，以实现使用我们的手来和虚拟物体进行交互的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686199/201907/686199-20190725072823546-495866023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Unity AR Foundation手部检测&lt;/p&gt;

&lt;p&gt;本文参考了Gil Nakache的文章，并且所使用的机器学习模型也来自他的文章。在他的那篇文章中，他描述了如何使用Swift在iOS原生平台上实现类似的功能。&lt;/p&gt;
&lt;h3&gt;Version&lt;/h3&gt;
&lt;p&gt;Unity Version: 2018.3.13f1&lt;/p&gt;
&lt;p&gt;Xcode Version: 10.2.1&lt;/p&gt;
&lt;p&gt;The ARFoundation Plugin: 1.5.0-preview.5&lt;/p&gt;
&lt;p&gt;iPhone 7: 12.3.1&lt;/p&gt;

&lt;h2&gt;0x01 实现&lt;/h2&gt;
&lt;h3&gt;导入 AR Foundation Plugin&lt;/h3&gt;
&lt;p&gt;为了方便，我使用了本地pacakge导入的形式。这种实现方式十分简单，只需要修改工程目录下Package文件夹内的manifest.json文件，在manifest.json文件中添加本地package即可。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&quot;com.unity.xr.arfoundation&quot;: &quot;file:../ARPackages/com.unity.xr.arfoundation&quot;, &lt;br/&gt;&quot;com.unity.xr.arkit&quot;: &quot;file:../ARPackages/com.unity.xr.arkit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;导入AR Foundation Package之后，我们就可以在场景中创建一些相关的组件了，比如AR Session、AR Session Origin等等。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-1a1a75c1b6d80843a639fa286422026d_hd.jpg&quot; alt=&quot;&quot; width=&quot;1666&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1666&quot; data-rawheight=&quot;1092&quot; data-original=&quot;https://pic2.zhimg.com/v2-1a1a75c1b6d80843a639fa286422026d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1a1a75c1b6d80843a639fa286422026d_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后在我们的脚本中，监听&lt;code&gt;frameReceived&lt;/code&gt;事件来获取每一帧的数据。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;    if (m_CameraManager != null)
    {
        m_CameraManager.frameReceived += OnCameraFrameReceived;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;使用Swift语言创建一个Unity插件&lt;/h3&gt;
&lt;p&gt;为了使C#语言可以和Swift语言进行交互，我们需要先创建一个Objective-C文件作为桥接。这种方式就是，C#通过&lt;code&gt;[DllImport(&quot;__Internal&quot;)]&lt;/code&gt;来调用一个Objective-C的方法。之后，Objective-C再通过&lt;code&gt;@objc&lt;/code&gt;来调用Swift。引入&lt;code&gt;UnityInterface.h&lt;/code&gt;之后，Swift可以调用&lt;code&gt;UnitySendMessage&lt;/code&gt;方法来向C#传送数据。&lt;/p&gt;
&lt;p&gt;这里有一个&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//github.com/chenjd/Unity-Hello-Swift&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;示例工程&lt;/a&gt;，演示了如何为Unity创建一个使用Swift的原生插件，并且在Unity中打印出“Hello, I’m Swift”。&lt;/p&gt;
&lt;p&gt;本文所使用的Unity-ARFoundation-HandDetection工程，它的plugins文件夹的目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-68789e07a6739adc69538b5f8923db7f_hd.jpg&quot; alt=&quot;&quot; width=&quot;1416&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1416&quot; data-rawheight=&quot;354&quot; data-original=&quot;https://pic4.zhimg.com/v2-68789e07a6739adc69538b5f8923db7f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-68789e07a6739adc69538b5f8923db7f_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，需要注意的是，Unity直接导出的Xcode工程是没有指定Swift版本的。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-6eeab5be460a0ae705c72d7ee87bed92_hd.jpg&quot; alt=&quot;&quot; width=&quot;1460&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;328&quot; data-original=&quot;https://pic3.zhimg.com/v2-6eeab5be460a0ae705c72d7ee87bed92_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6eeab5be460a0ae705c72d7ee87bed92_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，我们需要手动指定一个版本，或者创建一个Unity的脚本来自动设置Swift的版本。&lt;/p&gt;
&lt;h3&gt;导入 mlmodel&lt;/h3&gt;
&lt;p&gt;将HandModel添加到我们的Xcode工程中，之后它会自动生成一个Objective-C model类。但是我希望得到一个Swift的类，因此我们可以在Build Settings/CoreML Model Compiler - Code Generation Language这里将选项从Auto修改为Swift。&lt;/p&gt;
&lt;p&gt;之后，我们会获得一个叫做HandModel的自动生成的Swift类。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-55cdd51322ebc9ca7c0c75c915fffc34_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;592&quot; data-original=&quot;https://pic1.zhimg.com/v2-55cdd51322ebc9ca7c0c75c915fffc34_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-55cdd51322ebc9ca7c0c75c915fffc34_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，如果你不想总是手动添加，同样也可以选择在Unity中创建一个build post processing脚本来自动添加机器学习模型。&lt;/p&gt;
&lt;h3&gt;如何从AR Foundation中获取ARFrame Ptr&lt;/h3&gt;
&lt;p&gt;完成了以上步骤之后，基本的交互框架就已经成型了。接下来，我们就需要使用CoreML来实现手部的检测和追踪的具体功能了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;&lt;span class=&quot;kr&quot;&gt;@objc &lt;span class=&quot;kd&quot;&gt;func &lt;span class=&quot;nf&quot;&gt;startDetection&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;buffer&lt;span class=&quot;p&quot;&gt;: &lt;span class=&quot;n&quot;&gt;CVPixelBuffer&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;p&quot;&gt;-&amp;gt; &lt;span class=&quot;nb&quot;&gt;Bool &lt;span class=&quot;p&quot;&gt;{
    &lt;span class=&quot;c1&quot;&gt;//TODO
    &lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;retainedBuffer &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;buffer
    &lt;span class=&quot;kd&quot;&gt;let &lt;span class=&quot;nv&quot;&gt;imageRequestHandler &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;VNImageRequestHandler&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;cvPixelBuffer&lt;span class=&quot;p&quot;&gt;: &lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;retainedBuffer&lt;span class=&quot;o&quot;&gt;!&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;orientation&lt;span class=&quot;p&quot;&gt;: &lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;kr&quot;&gt;right&lt;span class=&quot;p&quot;&gt;)
    
    &lt;span class=&quot;n&quot;&gt;visionQueue&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;async &lt;span class=&quot;p&quot;&gt;{
        &lt;span class=&quot;k&quot;&gt;do &lt;span class=&quot;p&quot;&gt;{
            &lt;span class=&quot;k&quot;&gt;defer &lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;retainedBuffer &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;kc&quot;&gt;nil &lt;span class=&quot;p&quot;&gt;}
            &lt;span class=&quot;k&quot;&gt;try &lt;span class=&quot;n&quot;&gt;imageRequestHandler&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;perform&lt;span class=&quot;p&quot;&gt;([&lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;predictionRequest&lt;span class=&quot;p&quot;&gt;])
        &lt;span class=&quot;p&quot;&gt;} &lt;span class=&quot;k&quot;&gt;catch &lt;span class=&quot;p&quot;&gt;{
            &lt;span class=&quot;bp&quot;&gt;fatalError&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;Perform Failed:&lt;span class=&quot;se&quot;&gt;\&quot;&lt;span class=&quot;si&quot;&gt;\(&lt;span class=&quot;n&quot;&gt;error&lt;span class=&quot;si&quot;&gt;)&lt;span class=&quot;se&quot;&gt;\&quot;&lt;span class=&quot;s&quot;&gt;&quot;&lt;span class=&quot;p&quot;&gt;)
        &lt;span class=&quot;p&quot;&gt;}
    &lt;span class=&quot;p&quot;&gt;}
    
    &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;kc&quot;&gt;true
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Swift中，我们需要一个&lt;code&gt;CVPixelBuffer&lt;/code&gt;来创建&lt;code&gt;VNImageRequestHandler&lt;/code&gt;以执行手部检测。通常我们需要从ARFrame中来获取它。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;CVPixelBufferRef buffer = frame.capturedImage;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，下一个问题就是如何从Unity的AR Foundation的C#脚本中获取来自ARKit的ARFrame指针，并且将其传递给使用Objective-C和Swift语言的Hand Detection插件。&lt;/p&gt;
&lt;p&gt;在AR Foundation中，我们可以从&lt;code&gt;XRCameraFrame&lt;/code&gt;中获取&lt;code&gt;nativePtr&lt;/code&gt;，它指向一个ARKit的结构，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef &lt;span class=&quot;k&quot;&gt;struct &lt;span class=&quot;n&quot;&gt;UnityXRNativeFrame_1
&lt;span class=&quot;p&quot;&gt;{
    &lt;span class=&quot;kt&quot;&gt;int &lt;span class=&quot;n&quot;&gt;version&lt;span class=&quot;p&quot;&gt;;
    &lt;span class=&quot;kt&quot;&gt;void&lt;span class=&quot;o&quot;&gt;* &lt;span class=&quot;n&quot;&gt;framePtr&lt;span class=&quot;p&quot;&gt;;
&lt;span class=&quot;p&quot;&gt;} &lt;span class=&quot;n&quot;&gt;UnityXRNativeFrame_1&lt;span class=&quot;p&quot;&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且这个&lt;code&gt;framePtr&lt;/code&gt;指向了最新的&lt;code&gt;ARFrame&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体来说，我们可以调用定义在XRCamera​Subsystem的&lt;code&gt;TryGetLatestFrame&lt;/code&gt;方法来获取一个XRCameraFrame实例。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;cameraManager.subsystem.TryGetLatestFrame(cameraParams, out frame)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后将nativePtr从C#传递给Objective-C。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;m_HandDetector.StartDetect(frame.nativePtr);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Objective-C这边，我们会获得一个&lt;code&gt;UnityXRNativeFrame_1&lt;/code&gt;指针并且我们能从其中获取&lt;code&gt;ARFrame&lt;/code&gt;指针。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;    UnityXRNativeFrame_1* unityXRFrame = (UnityXRNativeFrame_1*) ptr;
    ARFrame* frame = (__bridge ARFrame*)unityXRFrame-&amp;gt;framePtr;
    
    CVPixelBufferRef buffer = frame.capturedImage&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦获取了ARFrame，接下来就来到了iOS开发的领域。创建一个VNImageRequestHandler对象并且开始执行手部检测。一旦检测完成，detectionCompleteHandler回调会被调用并且会通过&lt;code&gt;UnitySendMessage&lt;/code&gt;将检测的结果传递给Unity。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;20&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private &lt;span class=&quot;kd&quot;&gt;func &lt;span class=&quot;nf&quot;&gt;detectionCompleteHandler&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;request&lt;span class=&quot;p&quot;&gt;: &lt;span class=&quot;n&quot;&gt;VNRequest&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;error&lt;span class=&quot;p&quot;&gt;: &lt;span class=&quot;n&quot;&gt;Error&lt;span class=&quot;p&quot;&gt;?) &lt;span class=&quot;p&quot;&gt;{
    
    &lt;span class=&quot;n&quot;&gt;DispatchQueue&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;main&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;async &lt;span class=&quot;p&quot;&gt;{
        
        &lt;span class=&quot;k&quot;&gt;if&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;error &lt;span class=&quot;o&quot;&gt;!= &lt;span class=&quot;kc&quot;&gt;nil&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;p&quot;&gt;{
            &lt;span class=&quot;n&quot;&gt;UnitySendMessage&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;callbackTarget&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;OnHandDetecedFromNative&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;span class=&quot;p&quot;&gt;)
            &lt;span class=&quot;bp&quot;&gt;fatalError&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;error&lt;span class=&quot;si&quot;&gt;\(&lt;span class=&quot;n&quot;&gt;error&lt;span class=&quot;si&quot;&gt;)&lt;span class=&quot;s&quot;&gt;&quot;&lt;span class=&quot;p&quot;&gt;)
        &lt;span class=&quot;p&quot;&gt;}
        
        &lt;span class=&quot;k&quot;&gt;guard &lt;span class=&quot;kd&quot;&gt;let &lt;span class=&quot;nv&quot;&gt;observation &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;predictionRequest&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;results&lt;span class=&quot;p&quot;&gt;?.&lt;span class=&quot;bp&quot;&gt;first &lt;span class=&quot;k&quot;&gt;as&lt;span class=&quot;p&quot;&gt;? &lt;span class=&quot;n&quot;&gt;VNPixelBufferObservation &lt;span class=&quot;k&quot;&gt;else &lt;span class=&quot;p&quot;&gt;{
            &lt;span class=&quot;n&quot;&gt;UnitySendMessage&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;callbackTarget&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;OnHandDetecedFromNative&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;span class=&quot;p&quot;&gt;)
            &lt;span class=&quot;bp&quot;&gt;fatalError&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;Unexpected result type from VNCoreMLRequest&quot;&lt;span class=&quot;p&quot;&gt;)
        &lt;span class=&quot;p&quot;&gt;}
        
        &lt;span class=&quot;kd&quot;&gt;let &lt;span class=&quot;nv&quot;&gt;outBuffer &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;observation&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;pixelBuffer
        
        &lt;span class=&quot;k&quot;&gt;guard &lt;span class=&quot;kd&quot;&gt;let &lt;span class=&quot;nv&quot;&gt;point &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;outBuffer&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;searchTopPoint&lt;span class=&quot;p&quot;&gt;() &lt;span class=&quot;k&quot;&gt;else&lt;span class=&quot;p&quot;&gt;{
            &lt;span class=&quot;n&quot;&gt;UnitySendMessage&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;callbackTarget&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;OnHandDetecedFromNative&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;span class=&quot;p&quot;&gt;)
            &lt;span class=&quot;k&quot;&gt;return
        &lt;span class=&quot;p&quot;&gt;}
        
        &lt;span class=&quot;n&quot;&gt;UnitySendMessage&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;kc&quot;&gt;self&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;callbackTarget&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;OnHandDetecedFromNative&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;&lt;span class=&quot;si&quot;&gt;\(&lt;span class=&quot;n&quot;&gt;point&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;x&lt;span class=&quot;si&quot;&gt;)&lt;span class=&quot;s&quot;&gt;,&lt;span class=&quot;si&quot;&gt;\(&lt;span class=&quot;n&quot;&gt;point&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;y&lt;span class=&quot;si&quot;&gt;)&lt;span class=&quot;s&quot;&gt;&quot;&lt;span class=&quot;p&quot;&gt;)
    &lt;span class=&quot;p&quot;&gt;}
&lt;span class=&quot;p&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后我们会获取在viewport空间的position数据。viewport空间是相对于相机标准化的。 viewport的左下角是（0,0）; 右上角是（1,1）。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-2e86789c7a365a9dcdc76d86bad02c60_hd.jpg&quot; alt=&quot;&quot; width=&quot;2104&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2104&quot; data-rawheight=&quot;1032&quot; data-original=&quot;https://pic1.zhimg.com/v2-2e86789c7a365a9dcdc76d86bad02c60_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2e86789c7a365a9dcdc76d86bad02c60_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦我们获取了viewport空间的位置，就可以通过Unity的&lt;code&gt;ViewportToWorldPoint&lt;/code&gt;方法将它从viewport空间转换到world空间。传递给该方法的向量参数中的x、y来自Hand Detection的结果，z值则是距离相机的距离。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;   &lt;span class=&quot;kt&quot;&gt;var &lt;span class=&quot;n&quot;&gt;handPos &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;n&quot;&gt;Vector3&lt;span class=&quot;p&quot;&gt;();
   &lt;span class=&quot;n&quot;&gt;handPos&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;x &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;pos&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;x&lt;span class=&quot;p&quot;&gt;;
   &lt;span class=&quot;n&quot;&gt;handPos&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;y &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;m&quot;&gt;1 &lt;span class=&quot;p&quot;&gt;- &lt;span class=&quot;n&quot;&gt;pos&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;y&lt;span class=&quot;p&quot;&gt;;
   &lt;span class=&quot;n&quot;&gt;handPos&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;z &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;m&quot;&gt;4&lt;span class=&quot;p&quot;&gt;;&lt;span class=&quot;c1&quot;&gt;//m_Cam.nearClipPlane;
&lt;span class=&quot;c1&quot;&gt;   &lt;span class=&quot;kt&quot;&gt;var &lt;span class=&quot;n&quot;&gt;handWorldPos &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;m_Cam&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;ViewportToWorldPoint&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;handPos&lt;span class=&quot;p&quot;&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以在Unity中使用这个世界坐标来创建新的Object，或者是将已有的Object移动到这个世界坐标。换句话说，这个Object的位置会根据手的位置而改变。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-f699d716e84f8c25a9b7143a62c52160_hd.jpg&quot; alt=&quot;&quot; width=&quot;750&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;1334&quot; data-original=&quot;https://pic1.zhimg.com/v2-f699d716e84f8c25a9b7143a62c52160_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f699d716e84f8c25a9b7143a62c52160_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Post Process Build&lt;/h3&gt;
&lt;p&gt;正如上文说过的，我们可以在Unity中写一个C#脚本来自动设置生成的Xcode工程中的一些属性。例如，我们可以设置Xcode工程中Build Setting中的Swift Version属性。我们甚至还可以将机器学习模型添加到Build Phases中，比如添加到Compile Sources Phase。这里我们会使用定义在&lt;code&gt;UnityEditor.iOS.Xcode&lt;/code&gt;命名空间中的PBXProject类。PBXProject类提供了很多有用的方法，例如&lt;code&gt;AddBuildProperty&lt;/code&gt;, &lt;code&gt;SetBuildProperty&lt;/code&gt;, &lt;code&gt;AddSourcesBuildPhase&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;22&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;&lt;span class=&quot;na&quot;&gt;[PostProcessBuild]
&lt;span class=&quot;k&quot;&gt;public &lt;span class=&quot;k&quot;&gt;static &lt;span class=&quot;k&quot;&gt;void &lt;span class=&quot;n&quot;&gt;OnPostProcessBuild&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;BuildTarget &lt;span class=&quot;n&quot;&gt;buildTarget&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;kt&quot;&gt;string &lt;span class=&quot;n&quot;&gt;path&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;p&quot;&gt;{
    &lt;span class=&quot;k&quot;&gt;if&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;buildTarget &lt;span class=&quot;p&quot;&gt;!= &lt;span class=&quot;n&quot;&gt;BuildTarget&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;iOS&lt;span class=&quot;p&quot;&gt;)
    &lt;span class=&quot;p&quot;&gt;{
        &lt;span class=&quot;k&quot;&gt;return&lt;span class=&quot;p&quot;&gt;;
    &lt;span class=&quot;p&quot;&gt;}

    &lt;span class=&quot;kt&quot;&gt;string &lt;span class=&quot;n&quot;&gt;projPath &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;path &lt;span class=&quot;p&quot;&gt;+ &lt;span class=&quot;s&quot;&gt;&quot;/Unity-iPhone.xcodeproj/project.pbxproj&quot;&lt;span class=&quot;p&quot;&gt;;
    
    &lt;span class=&quot;kt&quot;&gt;var &lt;span class=&quot;n&quot;&gt;proj &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;n&quot;&gt;PBXProject&lt;span class=&quot;p&quot;&gt;();
    &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;ReadFromFile&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;projPath&lt;span class=&quot;p&quot;&gt;);
    &lt;span class=&quot;kt&quot;&gt;var &lt;span class=&quot;n&quot;&gt;targetGUID &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;TargetGuidByName&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;Unity-iPhone&quot;&lt;span class=&quot;p&quot;&gt;);

    &lt;span class=&quot;c1&quot;&gt;//set xcode proj properties
&lt;span class=&quot;c1&quot;&gt;    &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;AddBuildProperty&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;targetGUID&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;SWIFT_VERSION&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;4.0&quot;&lt;span class=&quot;p&quot;&gt;);
    &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;SetBuildProperty&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;targetGUID&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;SWIFT_OBJC_BRIDGING_HEADER&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;Libraries/Plugins/iOS/HandDetector/Native/HandDetector.h&quot;&lt;span class=&quot;p&quot;&gt;);
    &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;SetBuildProperty&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;targetGUID&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;SWIFT_OBJC_INTERFACE_HEADER_NAME&quot;&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;&quot;HandDetector-Swift.h&quot;&lt;span class=&quot;p&quot;&gt;);
    &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;SetBuildProperty&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;targetGUID&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;COREML_CODEGEN_LANGUAGE&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;span class=&quot;p&quot;&gt;);
    
    
    &lt;span class=&quot;c1&quot;&gt;//add handmodel to xcode proj build phase.
&lt;span class=&quot;c1&quot;&gt;    &lt;span class=&quot;kt&quot;&gt;var &lt;span class=&quot;n&quot;&gt;buildPhaseGUID &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;AddSourcesBuildPhase&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;targetGUID&lt;span class=&quot;p&quot;&gt;);
    &lt;span class=&quot;kt&quot;&gt;var &lt;span class=&quot;n&quot;&gt;handModelPath &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;Application&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;dataPath &lt;span class=&quot;p&quot;&gt;+ &lt;span class=&quot;s&quot;&gt;&quot;/../CoreML/HandModel.mlmodel&quot;&lt;span class=&quot;p&quot;&gt;;
    &lt;span class=&quot;kt&quot;&gt;var &lt;span class=&quot;n&quot;&gt;fileGUID &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;AddFile&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;handModelPath&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;/HandModel.mlmodel&quot;&lt;span class=&quot;p&quot;&gt;);
    &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;AddFileToBuildSection&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;targetGUID&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;buildPhaseGUID&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;fileGUID&lt;span class=&quot;p&quot;&gt;);
    
    &lt;span class=&quot;n&quot;&gt;proj&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;n&quot;&gt;WriteToFile&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;projPath&lt;span class=&quot;p&quot;&gt;);

&lt;span class=&quot;p&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-31b04b826b42e5c594d957a92e6549c0_hd.jpg&quot; alt=&quot;&quot; width=&quot;1566&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1566&quot; data-rawheight=&quot;740&quot; data-original=&quot;https://pic1.zhimg.com/v2-31b04b826b42e5c594d957a92e6549c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-31b04b826b42e5c594d957a92e6549c0_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;0x02 结论&lt;/h2&gt;
&lt;p&gt;使用Unity中的AR Foundation和CoreML，我们可以让Unity Chan站在我们的手指上。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-d492c591f4a5dc7177f235b6665138f9_hd.jpg&quot; alt=&quot;&quot; width=&quot;750&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;1334&quot; data-original=&quot;https://pic2.zhimg.com/v2-d492c591f4a5dc7177f235b6665138f9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d492c591f4a5dc7177f235b6665138f9_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文简单描述了集成CoreML和AR Foundation的过程。我相信大家可以使用它们作出更有趣的内容。&lt;/p&gt;
&lt;p&gt;这里是文中所使用的demo工程。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/chenjd/Unity-ARFoundation-HandDetection&quot; target=&quot;_blank&quot;&gt;https://github.com/chenjd/Unity-ARFoundation-HandDetection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenjd/Unity-ARFoundation-HandDetection&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Useful Links&lt;/h3&gt;
&lt;p&gt;https://heartbeat.fritz.ai/hand-detection-with-core-ml-and-arkit-f4c8da98e88e&lt;/p&gt;
&lt;p&gt;https://medium.com/@kevinhuyskens/implementing-swift-in-unity-53e0b668f895&lt;/p&gt;
&lt;p&gt;http://chenjd.xyz/2019/07/22/Unity-ARFoundation-CoreML/&lt;/p&gt;

</description>
<pubDate>Wed, 24 Jul 2019 23:30:00 +0000</pubDate>
<dc:creator>陈嘉栋</dc:creator>
<og:description>0x00 前言 Unity的AR Foundation通过上层抽象，对ARKit和ARCore这些底层接口进行了封装，从而实现了AR项目的跨平台开发能力。 而苹果的CoreML是一个可以用来将机器学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/murongxiaopifu/p/11241913.html</dc:identifier>
</item>
<item>
<title>Java面试题 从源码角度分析HashSet实现原理？ - Java蚂蚁</title>
<link>http://www.cnblogs.com/marsitman/p/11215892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsitman/p/11215892.html</guid>
<description>&lt;p&gt;&lt;strong&gt;面试官：请问HashSet有哪些特点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应聘者&lt;/strong&gt;：HashSet实现自set接口，set集合中元素无序且不能重复；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：那么HashSet 如何保证元素不重复？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应聘者&lt;/strong&gt;：因为HashSet底层是基于HashMap实现的，当你new一个HashSet时候，实际上是new了一个map，执行add方法时，实际上调用map的put方法，value始终是PRESENT，所以根据HashMap的一个特性: 将一个key-value对放入HashMap中时，首先根据key的hashCode()返回值决定该Entry的存储位置，如果两个key的hash值相同，那么它们的存储位置相同。如果这个两个key的equalus比较返回true。那么新添加的Entry的value会覆盖原来的Entry的value，key不会覆盖。因此,如果向HashSet中添加一个已经存在的元素，新添加的集合元素不会覆盖原来已有的集合元素；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先来看一下无参的构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public HashSet() {
     map = new HashMap&amp;lt;&amp;gt;();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然，当你new一个HashSet的时候，实际上是new了一个HashMap&lt;/p&gt;
&lt;p&gt;再来看一下add方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
private static final Object PRESENT = new Object();

public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义一个虚拟的Object PRESENT是向map中插入key-value对应的value，因为HashSet中只需要用到key，而HashMap是key-value键值对；所以，向map中添加键值对时，键值对的值固定是PRESENT。&lt;/p&gt;
&lt;p&gt;源码中HashSet的绝大部分方法都是通过调用HashMap的方法来实现的，其他的方法，就请大家自己查阅一下源码吧。&lt;/p&gt;

</description>
<pubDate>Wed, 24 Jul 2019 22:45:00 +0000</pubDate>
<dc:creator>Java蚂蚁</dc:creator>
<og:description>面试官：请问HashSet有哪些特点？ 应聘者：HashSet实现自set接口，set集合中元素无序且不能重复； 面试官：那么HashSet 如何保证元素不重复？ 应聘者：因为HashSet底层是基于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/marsitman/p/11215892.html</dc:identifier>
</item>
<item>
<title>我狠起来连自己都打---如何简单实现Azure resource自动打标签 - RaymondTeng</title>
<link>http://www.cnblogs.com/tenghaohua/p/11192277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tenghaohua/p/11192277.html</guid>
<description>&lt;p&gt;你是否还在为花费大量Azure Resource打标签而烦恼呢？你是否还在因为这样低效的重复劳动而痛苦呢？&lt;/p&gt;
&lt;p&gt;在很长一段时间内，笔者既要做云架构调整，又要做日常系统维护，还要参与各种各样的项目，在这种情况下，如果我还花许多时间在打标签这种小事上，不仅劳累了自己，还会耽误其他更重要的任务。&lt;/p&gt;
&lt;p&gt;作为高级懒人，我们绝对不能够允许这样的情况存在，一切能够自动化的操作绝不能允许自己去手动完成。&lt;/p&gt;
&lt;p&gt;虽然话是这么说，具体打什么样的标签还是要你自己决定的。但是我相信绝大多数企业至少都会打application或者project的标签来进行分类。那基于这种情况，我介绍一种比较讨巧的方法可以让resource自己认爹，但是这种方法目前有几个限制：&lt;/p&gt;
&lt;p&gt;1.不会重复检查已经打好的标签&lt;/p&gt;
&lt;p&gt;2.资源组的标签还是要手动提前打好&lt;/p&gt;
&lt;p&gt;3.所打的标签参照资源所属的资源组&lt;/p&gt;

&lt;p&gt;在这里我们要用到Azure两个服务，一个是azure policy另一个则是经常用到的automation，步骤其实很简单，如下&lt;/p&gt;

&lt;p&gt;1.利用Azure policy中的“Append tag and its default value”， 指定tag Name为application, tag value 为undefined&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1731663/201907/1731663-20190724235200571-1756604248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此之后你所有建立的azure resource 都会在创建之初就带有这个预设的tag&lt;/p&gt;
&lt;p&gt;2.建立资源组时做好tagging&lt;/p&gt;
&lt;p&gt;3. 利用azure automation的runbook去遍历所有带有预设tag的resource, 并将对应的resource group的标签应用在其自身。&lt;/p&gt;
&lt;p&gt;具体runbook sample 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$connectionName&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AzureRunAsConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
try
{

    &lt;/span&gt;&lt;span&gt;$servicePrincipalConnection&lt;/span&gt;=Get-AutomationConnection -Name &lt;span&gt;$connectionName&lt;/span&gt;

    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging in to Azure...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    Add&lt;/span&gt;-&lt;span&gt;AzureRmAccount `
        &lt;/span&gt;-&lt;span&gt;ServicePrincipal `
        &lt;/span&gt;-TenantId &lt;span&gt;$servicePrincipalConnection&lt;/span&gt;&lt;span&gt;.TenantId `
        &lt;/span&gt;-ApplicationId &lt;span&gt;$servicePrincipalConnection&lt;/span&gt;&lt;span&gt;.ApplicationId `
        &lt;/span&gt;-CertificateThumbprint &lt;span&gt;$servicePrincipalConnection&lt;/span&gt;&lt;span&gt;.CertificateThumbprint `
        &lt;/span&gt;-&lt;span&gt;EnvironmentName AzureChinaCloud
 }
catch {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;$servicePrincipalConnection&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$ErrorMessage&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection $connectionName not found.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;$ErrorMessage&lt;/span&gt;&lt;span&gt;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        Write&lt;/span&gt;-Error -Message &lt;span&gt;$_&lt;/span&gt;&lt;span&gt;.Exception
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;$_&lt;/span&gt;&lt;span&gt;.Exception
    }
}

Select&lt;/span&gt;-AzureRmSubscription -&lt;span&gt;Subscription &lt;em&gt;SubscriptionName
&lt;/em&gt;&lt;/span&gt;&lt;span&gt;$Resources&lt;/span&gt; = (Get-azurermresource -Tag @{ Application=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})

&lt;/span&gt;&lt;span&gt;Foreach&lt;/span&gt; (&lt;span&gt;$resource&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$Resources&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;$Rgname&lt;/span&gt; = &lt;span&gt;$resource&lt;/span&gt;&lt;span&gt;.Resourcegroupname

    &lt;/span&gt;&lt;span&gt;$resourceid&lt;/span&gt; = &lt;span&gt;$resource&lt;/span&gt;&lt;span&gt;.resourceId
    &lt;/span&gt;&lt;span&gt;$RGTags&lt;/span&gt; = (Get-AzureRmResourceGroup -Name &lt;span&gt;$Rgname&lt;/span&gt;&lt;span&gt;).Tags

    &lt;/span&gt;&lt;span&gt;$resourcetags&lt;/span&gt; = &lt;span&gt;$resource&lt;/span&gt;&lt;span&gt;.Tags

            &lt;/span&gt;&lt;span&gt;$RGTagFinal&lt;/span&gt; = @&lt;span&gt;{}
            &lt;/span&gt;&lt;span&gt;$RGTagFinal&lt;/span&gt; = &lt;span&gt;$RGTags&lt;/span&gt;                  
                    &lt;span&gt;Foreach&lt;/span&gt; (&lt;span&gt;$resourcetag&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$resourcetags&lt;/span&gt;&lt;span&gt;.GetEnumerator())
                    {
                
                    &lt;/span&gt;&lt;span&gt;If&lt;/span&gt; (&lt;span&gt;$RGTags&lt;/span&gt;.Keys &lt;span&gt;-inotcontains&lt;/span&gt; &lt;span&gt;$resourcetag&lt;/span&gt;&lt;span&gt;.Key)
                        {                        
                                Write&lt;/span&gt;-Output &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                                Write&lt;/span&gt;-Output &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Keydoesn't exist in RG Tags adding to Hash Table&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;$resourcetag&lt;/span&gt;&lt;span&gt;
                                Write&lt;/span&gt;-Output &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                                &lt;span&gt;$RGTagFinal&lt;/span&gt;.Add(&lt;span&gt;$resourcetag&lt;/span&gt;.Key,&lt;span&gt;$resourcetag&lt;/span&gt;&lt;span&gt;.Value)
                        }    

                    }
            Write&lt;/span&gt;-Output &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            Write&lt;/span&gt;-Output &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Applying the following Tags to $($resourceid)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;$RGTagFinal&lt;/span&gt;&lt;span&gt;
            Write&lt;/span&gt;-Output &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;$Settag&lt;/span&gt; = Set-AzureRmResource -ResourceId &lt;span&gt;$resourceid&lt;/span&gt; -Tag &lt;span&gt;$RGTagFinal&lt;/span&gt; -&lt;span&gt;Force

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你的资源比较多并且在各个订阅都有，可以把runbook改用为workflow，并且多一个遍历所有订阅的嵌套。&lt;/p&gt;
&lt;p&gt;另外还有一点，automation 的run as account必须对所有的资源至少拥有可以修改标签的权限。&lt;/p&gt;
&lt;p&gt;这里你可能会说，为什么我们不去遍历所有的resource去自动apply RG的标签呢？想想一下当你的resource数量上千上万的时候，你这个job得run多久。因此简单的一个预设标签作为get-azurermresource 的filter就大大节省去了之后重复多余的标签动作，只需要给新增的resource tagging即可。&lt;/p&gt;

&lt;p&gt;笔者先提供自己的方法作为抛砖引玉，大家可以在此基础上进行一些优化。或者如果有更好的自动标签的方案也欢迎提出交流。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jul 2019 16:10:00 +0000</pubDate>
<dc:creator>RaymondTeng</dc:creator>
<og:description>你是否还在为花费大量Azure Resource打标签而烦恼呢？你是否还在因为这样低效的重复劳动而痛苦呢？ 在很长一段时间内，笔者既要做云架构调整，又要做日常系统维护，还要参与各种各样的项目，在这种情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tenghaohua/p/11192277.html</dc:identifier>
</item>
<item>
<title>Netty中的责任链模式 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11241304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11241304.html</guid>
<description>&lt;p&gt;适用场景:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于一个请求来说,如果有个对象都有机会处理它,而且不明确到底是哪个对象会处理请求时,我们可以考虑使用责任链模式实现它,让请求从链的头部往后移动,直到链上的一个节点成功处理了它为止&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送者不需要知道自己发送的这个请求到底会被哪个对象处理掉,实现了发送者和接受者的解耦&lt;/li&gt;
&lt;li&gt;简化了发送者对象的设计&lt;/li&gt;
&lt;li&gt;可以动态的添加节点和删除节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的请求都从链的头部开始遍历,对性能有损耗&lt;/li&gt;
&lt;li&gt;极差的情况,不保证请求一定会被处理&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;自定义一个责任链&quot;&gt;自定义一个责任链&lt;/h3&gt;
&lt;p&gt;在java中不再存在指针了,如果我们想创建一个链表,只能是在本类中添加本类属性, 因为我们想创建一个链表,所以这是必须的工作&lt;/p&gt;
&lt;p&gt;需要提供set方法,让当前的节点可以设置自己的下一个节点&lt;/p&gt;
&lt;p&gt;处理请求的逻辑,设计成抽象方法,让不同的节点根据自己的需求去实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class Approver {
Approver approver;
String name;
// todo 抽象父类中可以存在构造函数,但是当我们创建子类时,必须要有一个参数的构造函数,
// todo 让子类一个参数的构造函数,来给这个函数初始化
public Approver (String name){
    this.name=name;
}

public abstract void ProcessRequest(PurchaseRequest request);

// 如果当前的处理器处理不了,就会往下传播
public void setApprover( Approver approver){
    this.approver=approver;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PurchaseRequest,需要被处理的请求,根据自己的需要各不相同&lt;/p&gt;
&lt;p&gt;接着就是链表上的不同功能的节点都要实现上面的抽象类&lt;code&gt;Approver&lt;/code&gt;,重写它的抽象方法,添加上他们特定的功能&lt;/p&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 创建出各个节点
    Approver1 approver1 = new Approver1();
    Approver2 approver2 = new Approver2();
    Approver3 approver3 = new Approver3();

    // 设置他们关系
    approver1.setApprover(approver2);
    approver2.setApprover(approver3);

    // 发起请求
    Client client = new Client();
    PurchaseRequest purchaseRequest = client.sendRequest();

    // 处理请求
    tom.ProcessRequest(purchaseRequest);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把请求传递给责任链的第一个节点,她会自动往后传播下去,直到有一个节点成功处理了它&lt;/p&gt;
&lt;h3 id=&quot;netty的责任链设计&quot;&gt;Netty的责任链设计&lt;/h3&gt;
&lt;p&gt;netty的pipeline设计,就采用了责任链设计模式, 底层采用双向链表的数据结构, 将链上的各个处理器串联起来&lt;/p&gt;
&lt;p&gt;客户端每一个请求的到来,netty都认为,pipeline中的所有的处理器都有机会处理它,因此,对于入栈的请求,全部从头节点开始往后传播,一直传播到尾节点(来到尾节点的msg会被释放掉)&lt;/p&gt;
&lt;p&gt;netty的责任链模式中的组件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;责任处理器接口
&lt;ul&gt;&lt;li&gt;pipeline中的处理器都它的具体实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;添加删除责任处理器的接口&lt;/li&gt;
&lt;li&gt;上下文
&lt;ul&gt;&lt;li&gt;通过这个上下文,可以获得需要的数据,属性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;责任终止机制
&lt;ul&gt;&lt;li&gt;pipeline中的每一个节点,都可以终止事件的传播&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;netty的责任处理器接口&quot;&gt;netty的责任处理器接口&lt;/h4&gt;
&lt;p&gt;责任处理器接口, pipeline中的所有的handler的顶级抽象接口,它规定了所有的handler统一要有添加,移除,异常捕获的行为&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ChannelHandler {

// todo 当handler被添加到真实的上下文中,并且准备处理事件时被调用
// todo handler 被添加进去的回调
void handlerAdded(ChannelHandlerContext ctx) throws Exception;

//  todo 是 handler 被移出的后的 回调
void handlerRemoved(ChannelHandlerContext ctx) throws Exception;

@Deprecated
void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;

@Inherited
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Sharable {
    // no value
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;netty对责任处理接口,做了更细粒度的划分, 处理器被分成了两种, 一种是站处理器&lt;code&gt;ChannelInboundHandler&lt;/code&gt;,另一种是出站处理器&lt;code&gt;ChannelOutboundHandler&lt;/code&gt;,这两个接口都继承自&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加删除责任处理器的接口&quot;&gt;添加删除责任处理器的接口&lt;/h4&gt;
&lt;p&gt;netty中所有的处理器最终都在添加在pipeline上,所以,添加删除责任处理器的接口的行为 netty在channelPipeline中的进行了规定&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ChannelPipeline
        extends ChannelInboundInvoker, ChannelOutboundInvoker, Iterable&amp;lt;Entry&amp;lt;String, ChannelHandler&amp;gt;&amp;gt; {

    ChannelPipeline addFirst(String name, ChannelHandler handler);

    ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler);

    ChannelPipeline addLast(String name, ChannelHandler handler);

    ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler);

    ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);

 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;上下文&quot;&gt;上下文&lt;/h4&gt;
&lt;p&gt;pipeline中的handler被封装进了上下文中,如下, 通过上下文,可以轻松拿到当前节点所属的channel, 以及它的线程执行器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// todo AttributeMap -- 让ChannelHandlerContext 可以存储自定义的属性
// todo ChannelInboundInvoker -- 让ChannelHandlerContext 可以进行 InBound事件的传播,读事件,read 或者是  注册事件 active事件
// todo ChannelOutboundInvoker -- 让ChannelHandlerContext 可以传播写事件
public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker {
 
    // todo 获取ChannelHandlerContext所对应的这个Channel对象
    Channel channel();

    // todo 获取事件执行器
    EventExecutor executor();
...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;责任终止机制&quot;&gt;责任终止机制&lt;/h4&gt;
&lt;p&gt;责任终止机制&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在pipeline中的任意一个节点,只要我们不手动的往下传播下去,这个事件就会终止传播在当前节点&lt;/li&gt;
&lt;li&gt;对于入站数据,默认会传递到尾节点,进行回收,如果我们不进行下一步传播,事件就会终止在当前节点,别忘记回收msg&lt;/li&gt;
&lt;li&gt;对于出站数据,用header节点的使用unsafe对象,把数据写会客户端也意味着事件的终止&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;事件的传播&quot;&gt;事件的传播&lt;/h4&gt;
&lt;p&gt;底层事件的传播使用的就是针对链表的操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private AbstractChannelHandlerContext findContextInbound() {
    AbstractChannelHandlerContext ctx = this;
    do {
        ctx = ctx.next;
    } while (!ctx.inbound);
    return ctx;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 24 Jul 2019 14:26:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>适用场景: 对于一个请求来说,如果有个对象都有机会处理它,而且不明确到底是哪个对象会处理请求时,我们可以考虑使用责任链模式实现它,让请求从链的头部往后移动,直到链上的一个节点成功处理了它为止 优点:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11241304.html</dc:identifier>
</item>
</channel>
</rss>