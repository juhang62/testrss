<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用GitHub API上传文件及GitHub做图床 - 阿呜的边城</title>
<link>http://www.cnblogs.com/dev2007/p/13997791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dev2007/p/13997791.html</guid>
<description>&lt;img src=&quot;https://images.shiyueshuyi.xyz/brina-blum-Bb_X4JgSqIM-unsplash.jpg&quot; width=&quot;70%&quot; height=&quot;&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文介绍GitHub API基础及上传文件到仓库API，并应用API将GitHub作为图床&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/rest/overview/resources-in-the-rest-api&quot;&gt;GitHub API官方页面&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;github-api版本&quot;&gt;GitHub API版本&lt;/h2&gt;
&lt;p&gt;当前版本为&lt;code&gt;v3&lt;/code&gt;，官方推荐在请求头中显示添加版本标识。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Accept: application/vnd.github.v3+json
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Postman示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/version.jpg&quot; alt=&quot;api版本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;请求认证&quot;&gt;请求认证&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基础认证|Basic authentication&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;shell示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -u &quot;username&quot; https://api.github.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Postman示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/auth.jpg&quot; alt=&quot;api认证&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;令牌认证|OAuth2 token (sent in a header)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;shell示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -H &quot;Authorization: token OAUTH-TOKEN&quot; https://api.github.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Postman示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/token.jpg&quot; alt=&quot;api token&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;主api，获取所有api&quot;&gt;主API，获取所有API&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;请求API：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;GET https://api.github.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这个API返回常见API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Postman示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/basicapi.jpg&quot; alt=&quot;basic api response&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;公开仓库查询api&quot;&gt;公开仓库查询API&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;请求API:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;GET https://api.github.com/user/repos
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;header：&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;application/vnd.github.v3+json&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Authorization&lt;/td&gt;
&lt;td&gt;token&lt;code&gt;空格&lt;/code&gt;&lt;em&gt;oauth_token&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Postman示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/list_repo.jpg&quot; alt=&quot;list repo&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;仓库创建api&quot;&gt;仓库创建API&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;请求API：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;POST https://api.github.com/user/repos
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;headers：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;请求体|Request body：&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1780821917808&quot;&gt;
&lt;p&gt;name，代表仓库名，必须。其他的可选参数参看&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#create-a-repository-for-the-authenticated-user&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;name&quot;:&quot;imgs&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Postman示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/create_repo.jpg&quot; alt=&quot;create repo&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为仓库上传更新文件api&quot;&gt;为仓库上传/更新文件API&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;请求API：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT https://api.github.com/repos/{user}/imgs/contents/{path}/{filename}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;user：仓库所属用户名&lt;/li&gt;
&lt;li&gt;path：上传文件存放的路径，如果文件夹不存在，会自动创建&lt;/li&gt;
&lt;li&gt;filename：上传的文件名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;请求体|Request body：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;message&quot;: &quot;提交说明&quot;,
  &quot;content&quot;: &quot;base64编码的文件内容&quot;,
  &quot;sha&quot;: &quot;文件的blob sha&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;content：文件内容的base64编码后的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sha：文件更新或删除时必填，先用GET接口查询文件信息，可在响应体中获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Postman示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/upload.jpg&quot; alt=&quot;upload file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;从仓库删除文件api&quot;&gt;从仓库删除文件API&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;请求API：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;DELETE https://api.github.com/repos/{user}/imgs/contents/{path}/{filename}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;user：仓库所属用户名&lt;/li&gt;
&lt;li&gt;path：上传文件存放的路径，如果文件夹不存在，会自动创建&lt;/li&gt;
&lt;li&gt;filename：上传的文件名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;请求体|Request body：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;message&quot;: &quot;提交说明&quot;,
  &quot;sha&quot;: &quot;文件的blob sha&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sha：文件更新或删除时必填，先用GET接口查询文件信息，可在响应体中获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;token的生成&quot;&gt;token的生成&lt;/h2&gt;
&lt;p&gt;token需要在GitHub网站上右上角&lt;code&gt;Settings&lt;/code&gt;中去生成，生成后需要立即保存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击&lt;code&gt;Settings&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/setting.jpg&quot; alt=&quot;setting&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击&lt;code&gt;Developer settings&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/setting2.jpg&quot; alt=&quot;setting2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击&lt;code&gt;Personal access tokens&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/setting3.jpg&quot; alt=&quot;setting3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击&lt;code&gt;Generate new token&lt;/code&gt;，生成token并记录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/setting4.jpg&quot; alt=&quot;setting4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;仓库作为图床&quot;&gt;仓库作为图床&lt;/h2&gt;
&lt;p&gt;仓库要想作为图床，图床的前提是文件内容能外链使用，需要将其作为GitHub Pages才能实现。&lt;/p&gt;
&lt;p&gt;将仓库作为图床的整体操作步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 创建一个仓库，将添加一个index.html&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于我们要将此仓库作为图床，所以虽不需要静态网站相关内容，但为了GitHub能将此仓库识别为GitHub Pages，还是至少需要一个index.html在仓库中。（当然，你也可以找寻一个静态网站模板放进仓库）&lt;/p&gt;
&lt;p&gt;index.html示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width-device-width,initial-scale-1&quot;&amp;gt;
    &amp;lt;title&amp;gt;Images&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/index.jpg&quot; alt=&quot;repo index&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2 将此仓库配置为GitHub Pages&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相关配置可以参看&lt;a href=&quot;https://www.cnblogs.com/dev2007/p/13947333.html&quot;&gt;多项目部署为同一个GitHub Pages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/pages.jpg&quot; alt=&quot;pages&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启GitHub Pages成功后，当前仓库文件就可通过GitHub Pages地址访问，图中示例为&lt;code&gt;https://dev2007.github.io/imgs&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3 将图片上传到仓库中&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;{仓库}/{路径}/{文件名}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/testimg.jpg&quot; alt=&quot;repo img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4 获取图片链接，使用链接&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;链接格式为：https://{Pages域名}/{仓库}/{路径}/{文件名}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例地址：&lt;code&gt;https://dev2007.github.io/imgs/myfolder/panda.png&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.shiyueshuyi.xyz/1110/pagesimg.jpg&quot; alt=&quot;pages img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;5 使用自定义域名，配置好后&lt;code&gt;Pages域名&lt;/code&gt;换为自定义域名即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相关GitHub Pages配置域名，可参看&lt;a href=&quot;https://www.cnblogs.com/dev2007/p/13925740.html&quot;&gt;用GitHub Pages搭建博客（五）&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;6 CDN加速&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以使用Vercel进行加速，可参看&lt;a href=&quot;https://www.cnblogs.com/dev2007/p/13925804.html&quot;&gt;用GitHub Pages搭建博客（六）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;demo图床&quot;&gt;Demo图床&lt;/h2&gt;
&lt;p&gt;最后是我搭建的一个Demo图床，可以访问，后续还将添加网页图片上传功能，欢迎查看：&lt;a href=&quot;https://harbor.shiyueshuyi.xyz&quot;&gt;图床&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的博客：&lt;a href=&quot;https://blog.shiyueshuyi.xyz&quot;&gt;阿呜的边城&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号：&lt;strong&gt;阿呜的编程&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://images.shiyueshuyi.xyz/mp/mp.png&quot; width=&quot;70%&quot; height=&quot;&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;p&gt;&lt;em&gt;题图来源 ：&lt;a href=&quot;https://unsplash.com&quot;&gt;unsplash&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Nov 2020 00:32:00 +0000</pubDate>
<dc:creator>阿呜的边城</dc:creator>
<og:description>本文介绍GitHub API基础及上传文件到仓库API，并应用API将GitHub作为图床 GitHub API官方页面 GitHub API版本 当前版本为v3，官方推荐在请求头中显示添加版本标识。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dev2007/p/13997791.html</dc:identifier>
</item>
<item>
<title>Azure 静态 web 应用集成 Azure 函数 API - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/azure-static-webapp-vue-with-functions.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/azure-static-webapp-vue-with-functions.html</guid>
<description>&lt;p&gt;前几次我们演示了如何通过Azure静态web应用功能发布vue跟blazor的项目(&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/azure-static-webapp-vue.html&quot;&gt;使用 Azure静态web应用+Github全自动部署VUE站点&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/staticwebapp-blazor.html&quot;&gt;使用Azure静态Web应用部署Blazor Webassembly应用&lt;/a&gt;)。但是一个真正的web应用，总是免不了需要后台api服务为前端提供数据或者处理数据的能力。同样前面我们也介绍了Azure函数服务，Azure函数的http trigger可以对http作出响应，可以完美的承当web api的角色。现在Azure静态web应用可以直接集成Azure函数，使得一次发布可以同时发布前端项目（vue、blazor）及后台api服务（azure函数）。&lt;/p&gt;
&lt;h2 id=&quot;新建azure函数&quot;&gt;新建Azure函数&lt;/h2&gt;
&lt;p&gt;上次已经演示过如何发布Blazor项目，这里不在啰嗦，直接找到我们上次的BlazorWebassembly项目的解决方案，添加一个Azure函数。&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/DeQa1x&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/18/DeQa1x.png&quot; alt=&quot;DeQa1x.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;Azure函数使用Http trigger。Http trigger可以对http请求作出响应，可以看成是一个webapi。&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/DeQwjK&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/18/DeQwjK.png&quot; alt=&quot;DeQwjK.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;新建完成之后修改Function1.cs类的代码为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static class Function1
    {
        [FunctionName(&quot;sum&quot;)]
        public static async Task&amp;lt;IActionResult&amp;gt; Run(
            [HttpTrigger(AuthorizationLevel.Function, &quot;get&quot;, &quot;post&quot;, Route = null)] HttpRequest req,
            ILogger log)
        {
            log.LogInformation(&quot;C# HTTP trigger function processed a request.&quot;);

            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
            dynamic data = JsonConvert.DeserializeObject(requestBody);

            int a = data.a;
            int b = data.b;

            int c = a + b;

            return new OkObjectResult(c);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码比较简单，通过读取request的body获取提交的a、b两个值，然后相加之后返回结果。&lt;br/&gt;关于Azure Function的文件参阅&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/azure-functions.html&quot;&gt;使用Azure Functions玩转Serverless&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;修改blazor项目&quot;&gt;修改Blazor项目&lt;/h2&gt;
&lt;p&gt;我们开始修改上次的Blazor Webassembly项目。在首页上放置3个文本框及一个按钮。点击按钮的时候把其中两个文本框的值通过http传递到Azure函数中去得到返回值显示在第三个文本框内。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/&quot;
@inject HttpClient Http

&amp;lt;h1&amp;gt;Azure static web app with functions&amp;lt;/h1&amp;gt;

A:
&amp;lt;input @bind=&quot;a&quot; /&amp;gt;+
B:
&amp;lt;input @bind=&quot;b&quot; /&amp;gt;=
&amp;lt;input @bind=&quot;c&quot; /&amp;gt;
&amp;lt;button @onclick=&quot;sum&quot;&amp;gt;求和&amp;lt;/button&amp;gt;

@code{
    private int a;
    private int b;
    private string c;

    private async Task sum()
    {
        var result = await Http.PostAsJsonAsync(&quot;/api/sum&quot;, new
        {
            A = a,
            B = b
        });
        var sum = await result.Content.ReadAsStringAsync();

        c = sum;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成之后提交代码到github。想要了解Blazor的相关内容请阅读我的其他关于Blazor入门的文章。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kklldog/tag/Blazor/&quot;&gt;tag=Blazor&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置静态web应用&quot;&gt;配置静态web应用&lt;/h2&gt;
&lt;p&gt;打开azure portal，新建一个静态web应用资源，因为前面已经介绍过多次基本的新建过程，这里不在详细介绍。&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/DeQdc6&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/18/DeQdc6.png&quot; alt=&quot;DeQdc6.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;基本配置跟上次发布Blazor Webassembly应用一样，关键的不同在于API位置需要修改为我们上面新建的Azure函数的项目名称。以便Azure能够找到这个目录。配置好之后点击开始创建。&lt;/p&gt;
&lt;h2 id=&quot;运行项目&quot;&gt;运行项目&lt;/h2&gt;
&lt;p&gt;静态web应用资源创建完成后会在github项目上自动添加一个workflow。等待这个workflow显示绿色完成之后就可以正式访问我们的web应用了。&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/DeQDBD&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/18/DeQDBD.png&quot; alt=&quot;DeQDBD.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;点击静态web应用资源的概述目录，找到url地址复制后在浏览器里打开：&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/DeQBnO&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/18/DeQBnO.png&quot; alt=&quot;DeQBnO.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;随便输入几个值，点击求和可以看到得到正确的结果。：）&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;前两次我们演示了通过Azure静态web应用功能发布vue跟Blazor wasm项目。但是他们都是纯静态页面。一般实现一个真正的web应用还需要api服务。Azure静态web应用通过直接对Azure函数的支持简化了项目开发发布流程。我们开发一些简单的项目的时候可以直接使用Azure函数做为api服务，提交代码等待几秒就可以运行了。本来可能需要前后端代码分别部署一次，现在只需要提交一下代码等待几秒就可以运行了。有了云计算程序员真的越来越傻瓜了，笑哭。&lt;/p&gt;
&lt;h2 id=&quot;关注我的公众号一起玩转技术&quot;&gt;关注我的公众号一起玩转技术&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/29/NfQjds.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Nov 2020 17:23:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>前几次我们演示了如何通过Azure静态web应用功能发布vue跟blazor的项目(使用 Azure静态web应用+Github全自动部署VUE站点、使用Azure静态Web应用部署Blazor We</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/azure-static-webapp-vue-with-functions.html</dc:identifier>
</item>
<item>
<title>分布式监控系统之Zabbix基础 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13997582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13997582.html</guid>
<description>&lt;p&gt;　　1、为什么要使用监控系统？&lt;/p&gt;
&lt;p&gt;　　我们知道一个系统不管怎么讲它都会出故障，我们为了保证线上业务的最大化的可用性，通常我们要给关键业务做高可用；做高可用的目的是为了让故障发生时，能够有一个备用的解决方案，将故障转移，从而实现服务的高可用性；那么问题来了，我们怎么知道系统发生了故障或者将要发生故障呢？怎么去把将要发生的故障扼杀在摇篮里呢？这个时候我们就需要用到监控系统；监控系统本质上不是业务系统，没有监控系统，线上业务系统也是可以正常运行的，它的存在主要是方便我们对业务系统的重要指标数据做采集、分析，使得我们能够更加清楚的了解线上系统正处于什么状态，cpu，内存，io等等一系列我们需要关心的点，都可以通过监控系统帮我们监控着，一旦被监控的主机或设备对应指标数据出现异常，能够及时的反馈并通知相关人员，使得我们能够及时的发现问题，从而解决问题；简单讲，监控系统就是辅助我们时时了解线上系统各指标数据，当被监控的主机或设备或服务出现异常时或即将出现异常时，它能够通过即时通信的方式通知管理员（比如发邮件、短信等等），从而使得管理员能够提前知道线上系统处于什么状态，从而针对特定的异常排查原因，修复异常，对即将发生的故障扼杀在摇篮里；&lt;/p&gt;
&lt;p&gt;　　2、zabbix是什么？zabbix组件以及其各组件的作用&lt;/p&gt;
&lt;p&gt;　　zabbix是一个开源的分布式监控系统，它主要有zabbix-server 、zabbix-database、zabbix-web GUI 、zabbix-agent、zabbix-proxy五大组件组成；其中zabbix-server主要提供收集数据、处理数据，并将数据保存在zabbix-database中；zabbix-database主要就是提供存储zabbix系统所需数据的数据存储服务；zabbix-web GUI主要作用是提供配置、展示、管理zabbix监控系统的一个web前端工具，它能将管理员的管理、配置操作通过web接口保存到zabbix-database中，并将zabbix-database中保存的指标数据通过web接口进行展示；zabbix-agent是zabbix的一个专有客户端代理，它主要运行在各个被监控的主机之上，其作用是接受zabbix-server发送的各种采集数据指令，并将采集到的数据通过专有代理zabbix-agent发送或响应给zabbix-server；zabbix-proxy是zabbix的一个服务端代理，主要作用是代理zabbix-server接收各个zabbix-agent发送或响应的指标数据；&lt;/p&gt;
&lt;p&gt;　　3、zabbix架构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201117223345771-149892283.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图主要描述了zabbix监控系统的组件间的工作过程；首先zabbix的配置、管理以及展示都是通过zabbix web GUI这个组件进行的，管理员通过zabbix web GUI把要监控的主机、监控项、触发器等等一系列配置写进zabbix-database，然后zabbix-server到数据库中拿到对应的配置，进行应用；zabbix-server通过配置信息定义的各个信道，去采集对应主机或设备上要监控的指标数据，将采集到的数据进行处理以后存放到数据库，最后通过web GUI到数据库取数据进行展示；&lt;/p&gt;
&lt;p&gt;　　4、zabbix监控系统部署&lt;/p&gt;
&lt;p&gt;　　环境说明&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;角色&lt;/td&gt;
&lt;td&gt;ip地址：端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node01&lt;/td&gt;
&lt;td&gt;zabbix web GUI&lt;/td&gt;
&lt;td&gt;192.168.0.41:80&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node02&lt;/td&gt;
&lt;td&gt;zabbix database&lt;/td&gt;
&lt;td&gt;192.168.0.42:3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;node03&lt;/td&gt;
&lt;td&gt;zabbix-server/zabbix-agent&lt;/td&gt;
&lt;td&gt;192.168.0.43:10051/10050&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;






&lt;p&gt;　　zabbix-database部署&lt;/p&gt;
&lt;p&gt;　　zabbix-databse本质上就是一个数据库服务，zabbix主要支持mysql（或者mariadb）和pgsql，两种数据库系统，我们部署zabbix-database就是部署一个mysql(或mariadb)或pgsql即可；&lt;/p&gt;
&lt;p&gt;　　准备mariadb yum源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# cat /etc/yum.repos.d/mariadb.repo 
[mariadb]
name=mariadb repo
baseurl=https://mirrors.tuna.tsinghua.edu.cn/mariadb/mariadb-10.0.38/yum/centos/7/x86_64/
gpgcheck=0
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装MariaDB-server&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# yum install -y MariaDB-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　添加zabbix-databse.cnf配置到/etc/my.cnf.d/目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# cat /etc/my.cnf.d/zabbix-database.cnf
[mysqld]
bind-address = 0.0.0.0
default-storage-engine = innodb
innodb_file_per_table = on
max_connections = 4096
collation-server = utf8_general_ci
character-set-server = utf8
skip_name_resolve
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动maridb&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# systemctl start mariadb
Failed to start mariadb.service: Unit not found.
[root@node02 ~]# /etc/init.d/mysql start
Starting MariaDB.201117 23:15:28 mysqld_safe Logging to '/var/lib/mysql/node02.test.org.err'.
201117 23:15:28 mysqld_safe Starting mysqld daemon with databases from /var/lib/mysql
 SUCCESS! 
[root@node02 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:3306                                     *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：清华源装的MariaDB-server没有提供unit file，只有一个启动脚本，所以启动时不能用systemctl 方式启动；当然也可以写一个unit file，使用systemctl方式启动；&lt;/p&gt;
&lt;p&gt;　　设置mysql开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# chkconfig --level 3 mysql on
[root@node02 ~]# chkconfig --list mysql

Note: This output shows SysV services only and does not include native
      systemd services. SysV configuration data might be overridden by native
      systemd configuration.

      If you want to list systemd services use 'systemctl list-unit-files'.
      To see services enabled on particular target use
      'systemctl list-dependencies [target]'.

mysql           0:off   1:off   2:on    3:on    4:on    5:on    6:off
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　设置root密码，清除test库和相关账号信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# mysql_secure_installation

NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB
      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!

In order to log into MariaDB to secure it, we'll need the current
password for the root user.  If you've just installed MariaDB, and
you haven't set the root password yet, the password will be blank,
so you should just press enter here.

Enter current password for root (enter for none): 
OK, successfully used password, moving on...

Setting the root password ensures that nobody can log into the MariaDB
root user without the proper authorisation.

Set root password? [Y/n] y
New password: 
Re-enter new password: 
Password updated successfully!
Reloading privilege tables..
 ... Success!


By default, a MariaDB installation has an anonymous user, allowing anyone
to log into MariaDB without having to have a user account created for
them.  This is intended only for testing, and to make the installation
go a bit smoother.  You should remove them before moving into a
production environment.

Remove anonymous users? [Y/n] y
 ... Success!

Normally, root should only be allowed to connect from 'localhost'.  This
ensures that someone cannot guess at the root password from the network.

Disallow root login remotely? [Y/n] y 
 ... Success!

By default, MariaDB comes with a database named 'test' that anyone can
access.  This is also intended only for testing, and should be removed
before moving into a production environment.

Remove test database and access to it? [Y/n] y
 - Dropping test database...
 ... Success!
 - Removing privileges on test database...
 ... Success!

Reloading the privilege tables will ensure that all changes made so far
will take effect immediately.

Reload privilege tables now? [Y/n] y
 ... Success!

Cleaning up...

All done!  If you've completed all of the above steps, your MariaDB
installation should now be secure.

Thanks for using MariaDB!
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建zabbix数据库，并设置默认字符集为utf8&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# mysql -uroot -p
Enter password: 
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 12
Server version: 10.0.38-MariaDB MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; create database zabbix character set utf8 collate utf8_bin;                          
Query OK, 1 row affected (0.00 sec)

MariaDB [(none)]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建zabbix用户，授权允许从192.168.的网络连入管理zabbix数据库，并设置其密码为admin123.com&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; grant all privileges on zabbix.* to zabbix@'192.168.%.%' identified by 'admin123.com';
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到此zabbix-database就准备好了&lt;/p&gt;
&lt;p&gt;　　在node03上安装zabbix-server、zabbix-agent&lt;/p&gt;
&lt;p&gt;　　配置yum源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# cat /etc/yum.repos.d/zabbix.repo 
[zabbix-server]
name=zabbix-server repo
baseurl=https://mirrors.aliyun.com/zabbix/zabbix/4.0/rhel/7/x86_64/
gpgcheck=0

[non-supported]
name=non-supported repo
baseurl=https://mirrors.aliyun.com/zabbix/non-supported/rhel/7/x86_64/
gpgcheck=0
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将zabbix.reop复制到node01&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# scp /etc/yum.repos.d/zabbix.repo node01:/etc/yum.repos.d/
zabbix.repo                                                                   100%  242   165.8KB/s   00:00       
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在node03上安装zabbix-server和zabbix-agent&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# yum install -y zabbix-server-mysql zabbix-agent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果数据库用的是pgsql就安装zabbix-server-pgsql；在zabbix-server上安装agent的主要原因是可以监控zabbix-server自身的一些指标；&lt;/p&gt;
&lt;p&gt;　　使用zabbix用户导入表到zabbix库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -h192.168.0.42 -uzabbix -p zabbix 
Enter password: 
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：查看zabbix库是否有表生成？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# mysql -h192.168.0.42 -uzabbix -padmin123.com zabbix -e 'show tables;'|wc -l
145
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：只要能够统计到对应库下有表的数量，说明我们导入表达操作就没有什么问题，通常这个导入表，会导入很多张表；&lt;/p&gt;
&lt;p&gt;　　配置zabbix-server&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# grep -Ei ^[^#] /etc/zabbix/zabbix_server.conf
ListenPort=10051
LogFile=/var/log/zabbix/zabbix_server.log
LogFileSize=0
PidFile=/var/run/zabbix/zabbix_server.pid
SocketDir=/var/run/zabbix
DBHost=192.168.0.42
DBName=zabbix
DBUser=zabbix
DBPassword=admin123.com
DBPort=3306
SNMPTrapperFile=/var/log/snmptrap/snmptrap.log
Timeout=4
AlertScriptsPath=/usr/lib/zabbix/alertscripts
ExternalScripts=/usr/lib/zabbix/externalscripts
LogSlowQueries=3000
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：配置zabbix-server主要配置连接数据库相关的配置，其他配置可以保持默认即可；&lt;/p&gt;
&lt;p&gt;　　配置zabbix-agent&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# grep -Ei ^[^#] /etc/zabbix/zabbix_agentd.conf
PidFile=/var/run/zabbix/zabbix_agentd.pid
LogFile=/var/log/zabbix/zabbix_agentd.log
LogFileSize=0
Server=127.0.0.1
ListenPort=10050
ListenIP=0.0.0.0
StartAgents=3
ServerActive=127.0.0.1
Hostname=Zabbix server
HostnameItem=system.hostname
Include=/etc/zabbix/zabbix_agentd.d/*.conf
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：zabbix-server主机上的zabbix-agent几乎不用修改配置，保持默认即可；&lt;/p&gt;
&lt;p&gt;　　启动zabbix-server，并将其设置为开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# systemctl start zabbix-server.service
[root@node03 ~]# systemctl enable zabbix-server.service
Created symlink from /etc/systemd/system/multi-user.target.wants/zabbix-server.service to /usr/lib/systemd/system/zabbix-server.service.
[root@node03 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10051                                    *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
LISTEN     0      128                         :::10051                                   :::*                  
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：zabbix-server默认监听10051，请确保10051端口处于正常监听状态即可；到此zabbix-server就配置启动成功；&lt;/p&gt;
&lt;p&gt;　　启动zabbix-agent，并设置开机自启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# systemctl start zabbix-agent.service 
[root@node03 ~]# systemctl enable zabbix-agent.service
Created symlink from /etc/systemd/system/multi-user.target.wants/zabbix-agent.service to /usr/lib/systemd/system/zabbix-agent.service.
[root@node03 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                          *:10051                                    *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
LISTEN     0      128                         :::10051                                   :::*                  
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：请确保10050端口正常监听；&lt;/p&gt;
&lt;p&gt;　　在node01上安装zabbix-web-mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum install -y zabbix-web-mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改时区信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118002028056-1979934334.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：除了修改以上配置可以修改时区以外，我们也可以编辑/etc/php.ini文件，找到date.timezone将其注释去掉，写上对应的时区信息保存退出即可；这两种方式选一种修改就行；&lt;/p&gt;
&lt;p&gt;　　启动httpd，并将其设置为开机自动启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# systemctl start httpd
[root@node01 ~]# systemctl enable httpd
Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.
[root@node01 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                         :::80                                      :::*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：请确保80端口正常监听即可；到此zabbix-web组件就安装配置好了；接下来我们就可以使用浏览器访问zabbix-web服务；&lt;/p&gt;
&lt;p&gt;　　用浏览器访问zabbix-web，进行zabbix安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118002721153-752261202.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118002744541-1430431948.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这里主要是验证环境，要全部是ok状态才可以；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118002852149-400066835.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这里是配置数据库连接相关信息，填写对应数据库相关信息，点击下一步即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118003058931-2047487984.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这里是填写zabbix-server相关信息；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118003239926-295584813.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118003311870-1935937099.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118003346684-350481196.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：默认用户名是Admin密码是zabbix；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201118003435109-549285567.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此zabbix监控系统基础环境就搭建好了；后续我们就可以在这个web页面上做监控配置和管理以及监控数据的展示；&lt;/p&gt;
</description>
<pubDate>Tue, 17 Nov 2020 17:11:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>1、为什么要使用监控系统？ 我们知道一个系统不管怎么讲它都会出故障，我们为了保证线上业务的最大化的可用性，通常我们要给关键业务做高可用；做高可用的目的是为了让故障发生时，能够有一个备用的解决方案，将故</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13997582.html</dc:identifier>
</item>
<item>
<title>【JVM】肝了一周，吐血整理出这份超硬核的JVM笔记（升级版）！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13997552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13997552.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最近，一直有小伙伴让我整理下关于JVM的知识，经过十几天的收集与整理，初版算是整理出来了。希望对大家有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;jdk-是什么？&quot;&gt;JDK 是什么？&lt;/h2&gt;
&lt;p&gt;JDK 是用于支持 Java 程序开发的最小环境。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Java 程序设计语言&lt;/li&gt;
&lt;li&gt;Java 虚拟机&lt;/li&gt;
&lt;li&gt;Java API类库&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jre-是什么？&quot;&gt;JRE 是什么？&lt;/h2&gt;
&lt;p&gt;JRE 是支持 Java 程序运行的标准环境。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Java SE API 子集&lt;/li&gt;
&lt;li&gt;Java 虚拟机&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;java历史版本的特性？&quot;&gt;Java历史版本的特性？&lt;/h2&gt;
&lt;h3 id=&quot;java-version-se-50&quot;&gt;Java Version SE 5.0&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;引入泛型；&lt;/li&gt;
&lt;li&gt;增强循环，可以使用迭代方式；&lt;/li&gt;
&lt;li&gt;自动装箱与自动拆箱；&lt;/li&gt;
&lt;li&gt;类型安全的枚举；&lt;/li&gt;
&lt;li&gt;可变参数；&lt;/li&gt;
&lt;li&gt;静态引入；&lt;/li&gt;
&lt;li&gt;元数据（注解）；&lt;/li&gt;
&lt;li&gt;引入Instrumentation。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;java-version-se-6&quot;&gt;Java Version SE 6&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;支持脚本语言；&lt;/li&gt;
&lt;li&gt;引入JDBC 4.0 API；&lt;/li&gt;
&lt;li&gt;引入Java Compiler API；&lt;/li&gt;
&lt;li&gt;可插拔注解；&lt;/li&gt;
&lt;li&gt;增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持；&lt;/li&gt;
&lt;li&gt;继承Web Services；&lt;/li&gt;
&lt;li&gt;做了很多优化。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;java-version-se-7&quot;&gt;Java Version SE 7&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;switch语句块中允许以字符串作为分支条件；&lt;/li&gt;
&lt;li&gt;在创建泛型对象时应用类型推断；&lt;/li&gt;
&lt;li&gt;在一个语句块中捕获多种异常；&lt;/li&gt;
&lt;li&gt;支持动态语言；&lt;/li&gt;
&lt;li&gt;支持try-with-resources；&lt;/li&gt;
&lt;li&gt;引入Java NIO.2开发包；&lt;/li&gt;
&lt;li&gt;数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；&lt;/li&gt;
&lt;li&gt;钻石型语法；&lt;/li&gt;
&lt;li&gt;null值的自动处理。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;java-8&quot;&gt;Java 8&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;函数式接口&lt;/li&gt;
&lt;li&gt;Lambda表达式&lt;/li&gt;
&lt;li&gt;Stream API&lt;/li&gt;
&lt;li&gt;接口的增强&lt;/li&gt;
&lt;li&gt;时间日期增强API&lt;/li&gt;
&lt;li&gt;重复注解与类型注解&lt;/li&gt;
&lt;li&gt;默认方法与静态方法&lt;/li&gt;
&lt;li&gt;Optional 容器类&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运行时数据区域包括哪些？&quot;&gt;运行时数据区域包括哪些？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;程序计数器&lt;/li&gt;
&lt;li&gt;Java 虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;Java 堆&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;运行时常量池&lt;/li&gt;
&lt;li&gt;直接内存&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;程序计数器（线程私有）&quot;&gt;程序计数器（线程私有）&lt;/h3&gt;
&lt;p&gt;程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。&lt;/p&gt;
&lt;p&gt;由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址；&lt;/li&gt;
&lt;li&gt;如果正在执行的是 Native 方法，这个计数器的值为空。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;程序计数器是唯一一个没有规定任何 OutOfMemoryError 的区域。&lt;/p&gt;
&lt;h3 id=&quot;java-虚拟机栈（线程私有）&quot;&gt;Java 虚拟机栈（线程私有）&lt;/h3&gt;
&lt;p&gt;Java 虚拟机栈（Java Virtual Machine Stacks）是线程私有的，生命周期与线程相同。&lt;br/&gt;虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame），存储&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;局部变量表&lt;/li&gt;
&lt;li&gt;操作栈&lt;/li&gt;
&lt;li&gt;动态链接&lt;/li&gt;
&lt;li&gt;方法出口&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;每一个方法被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/p&gt;
&lt;p&gt;这个区域有两种异常情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度&lt;/li&gt;
&lt;li&gt;OutOfMemoryError：虚拟机栈扩展到无法申请足够的内存时&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本地方法栈（线程私有）&quot;&gt;本地方法栈（线程私有）&lt;/h3&gt;
&lt;p&gt;虚拟机栈为虚拟机执行 Java 方法（字节码）服务。&lt;/p&gt;
&lt;p&gt;本地方法栈（Native Method Stacks）为虚拟机使用到的 Native 方法服务。&lt;/p&gt;
&lt;h3 id=&quot;java-堆（线程共享）&quot;&gt;Java 堆（线程共享）&lt;/h3&gt;
&lt;p&gt;Java 堆（Java Heap）是 Java 虚拟机中内存最大的一块。Java 堆在虚拟机启动时创建，被所有线程共享。&lt;/p&gt;
&lt;p&gt;作用：存放对象实例。垃圾收集器主要管理的就是 Java 堆。Java 堆在物理上可以不连续，只要逻辑上连续即可。&lt;/p&gt;
&lt;h3 id=&quot;方法区（线程共享）&quot;&gt;方法区（线程共享）&lt;/h3&gt;
&lt;p&gt;方法区（Method Area）被所有线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p&gt;
&lt;p&gt;和 Java 堆一样，不需要连续的内存，可以选择固定的大小，更可以选择不实现垃圾收集。&lt;/p&gt;
&lt;h3 id=&quot;运行时常量池&quot;&gt;运行时常量池&lt;/h3&gt;
&lt;p&gt;运行时常量池（Runtime Constant Pool）是方法区的一部分。保存 Class 文件中的符号引用、翻译出来的直接引用。运行时常量池可以在运行期间将新的常量放入池中。&lt;/p&gt;
&lt;h2 id=&quot;java-中对象访问是如何进行的？&quot;&gt;Java 中对象访问是如何进行的？&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object obj =  new  Object();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上述最简单的访问，也会涉及到 Java 栈、Java 堆、方法区这三个最重要内存区域。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object obj
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果出现在方法体中，则上述代码会反映到 Java 栈的本地变量表中，作为 reference 类型数据出现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;new  Object()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反映到 Java 堆中，形成一块存储了 Object 类型所有对象实例数据值的内存。Java堆中还包含对象类型数据的地址信息，这些类型数据存储在方法区中。&lt;/p&gt;
&lt;h2 id=&quot;如何判断对象是否死去？&quot;&gt;如何判断对象是否“死去”？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;引用计数法&lt;/li&gt;
&lt;li&gt;根搜索算法&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;什么是引用计数法？&quot;&gt;什么是引用计数法？&lt;/h2&gt;
&lt;p&gt;给对象添加一个引用计数器，每当有一个地方引用它，计数器就+1,；当引用失效时，计数器就-1；任何时刻计数器都为0的对象就是不能再被使用的。&lt;/p&gt;
&lt;h2 id=&quot;引用计数法的缺点？&quot;&gt;引用计数法的缺点？&lt;/h2&gt;
&lt;p&gt;很难解决对象之间的循环引用问题。&lt;/p&gt;
&lt;h2 id=&quot;什么是根搜索算法？&quot;&gt;什么是根搜索算法？&lt;/h2&gt;
&lt;p&gt;通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012618668.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-的4种引用方式？&quot;&gt;Java 的4种引用方式？&lt;/h2&gt;
&lt;p&gt;在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;强引用 Strong Reference&lt;/li&gt;
&lt;li&gt;软引用 Soft Reference&lt;/li&gt;
&lt;li&gt;弱引用 Weak Reference&lt;/li&gt;
&lt;li&gt;虚引用 Phantom Reference&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;强引用&quot;&gt;强引用&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object obj =  new  Object();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中普遍存在的，像上述的引用。只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。&lt;/p&gt;
&lt;h3 id=&quot;软引用&quot;&gt;软引用&lt;/h3&gt;
&lt;p&gt;用来描述一些还有用，但并非必须的对象。软引用所关联的对象，有在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围，并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存异常。提供了 SoftReference 类实现软引用。&lt;/p&gt;
&lt;h3 id=&quot;弱引用&quot;&gt;弱引用&lt;/h3&gt;
&lt;p&gt;描述非必须的对象，强度比软引用更弱一些，被弱引用关联的对象，只能生存到下一次垃圾收集发生前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。提供了 WeakReference 类来实现弱引用。&lt;/p&gt;
&lt;h3 id=&quot;虚引用&quot;&gt;虚引用&lt;/h3&gt;
&lt;p&gt;一个对象是否有虚引用，完全不会对其生存时间够成影响，也无法通过虚引用来取得一个对象实例。为一个对象关联虚引用的唯一目的，就是希望在这个对象被收集器回收时，收到一个系统通知。提供了 PhantomReference 类来实现虚引用。&lt;/p&gt;
&lt;h2 id=&quot;有哪些垃圾收集算法？&quot;&gt;有哪些垃圾收集算法？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;标记-清除算法&lt;/li&gt;
&lt;li&gt;复制算法&lt;/li&gt;
&lt;li&gt;标记-整理算法&lt;/li&gt;
&lt;li&gt;分代收集算法&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;标记-清除算法（mark-sweep）&quot;&gt;标记-清除算法（Mark-Sweep）&lt;/h2&gt;
&lt;h3 id=&quot;什么是标记-清除算法？&quot;&gt;什么是标记-清除算法？&lt;/h3&gt;
&lt;p&gt;分为标记和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。&lt;/p&gt;
&lt;h3 id=&quot;有什么缺点？&quot;&gt;有什么缺点？&lt;/h3&gt;
&lt;p&gt;效率问题：标记和清除过程的效率都不高。&lt;/p&gt;
&lt;p&gt;空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致，程序分配较大对象时无法找到足够的连续内存，不得不提前出发另一次垃圾收集动作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012631133.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;复制算法（copying）--新生代&quot;&gt;复制算法（Copying）- 新生代&lt;/h2&gt;
&lt;p&gt;将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;p&gt;复制算法使得每次都是针对其中的一块进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。&lt;/p&gt;
&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;将内存缩小为原来的一半。在对象存活率较高时，需要执行较多的复制操作，效率会变低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012644332.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;
&lt;p&gt;商业的虚拟机都采用复制算法来回收新生代。因为新生代中的对象容易死亡，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。每次使用 Eden 和其中的一块 Survivor。&lt;/p&gt;
&lt;p&gt;当回收时，将 Eden 和 Survivor 中还存活的对象一次性拷贝到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。Hotspot 虚拟机默认 Eden 和 Survivor 的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80% + 10%），只有10%的内存是会被“浪费”的。&lt;/p&gt;
&lt;h2 id=&quot;标记-整理算法（mark-compact）-老年代&quot;&gt;标记-整理算法（Mark-Compact）-老年代&lt;/h2&gt;
&lt;p&gt;标记过程仍然与“标记-清除”算法一样，但不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012656257.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分代收集算法&quot;&gt;分代收集算法&lt;/h2&gt;
&lt;p&gt;根据对象的存活周期，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点，采用最适当的收集算法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新生代：每次垃圾收集时会有大批对象死去，只有少量存活，所以选择复制算法，只需要少量存活对象的复制成本就可以完成收集。&lt;/li&gt;
&lt;li&gt;老年代：对象存活率高、没有额外空间对它进行分配担保，必须使用“标记-清理”或“标记-整理”算法进行回收。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;minor-gc-和-full-gc有什么区别？&quot;&gt;Minor GC 和 Full GC有什么区别？&lt;/h2&gt;
&lt;p&gt;Minor GC：新生代 GC，指发生在新生代的垃圾收集动作，因为 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般回收速度较快。&lt;br/&gt;Full GC：老年代 GC，也叫 Major GC，速度一般比 Minor GC 慢 10 倍以上。&lt;/p&gt;
&lt;h2 id=&quot;java-内存&quot;&gt;Java 内存&lt;/h2&gt;
&lt;h3 id=&quot;为什么要将堆内存分区？&quot;&gt;为什么要将堆内存分区？&lt;/h3&gt;
&lt;p&gt;对于一个大型的系统，当创建的对象及方法变量比较多时，即堆内存中的对象比较多，如果逐一分析对象是否该回收，效率很低。分区是为了进行模块化管理，管理不同的对象及变量，以提高 JVM 的执行效率。&lt;/p&gt;
&lt;h3 id=&quot;堆内存分为哪几块？&quot;&gt;堆内存分为哪几块？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Young Generation Space 新生区（也称新生代）&lt;/li&gt;
&lt;li&gt;Tenure Generation Space养老区（也称旧生代）&lt;/li&gt;
&lt;li&gt;Permanent Space 永久存储区&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;分代收集算法-2&quot;&gt;分代收集算法&lt;/h3&gt;
&lt;h4 id=&quot;内存分配有哪些原则？&quot;&gt;内存分配有哪些原则？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;对象优先分配在 Eden&lt;/li&gt;
&lt;li&gt;大对象直接进入老年代&lt;/li&gt;
&lt;li&gt;长期存活的对象将进入老年代&lt;/li&gt;
&lt;li&gt;动态对象年龄判定&lt;/li&gt;
&lt;li&gt;空间分配担保&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;young-generation-space-（采用复制算法）&quot;&gt;Young Generation Space （采用复制算法）&lt;/h4&gt;
&lt;p&gt;主要用来存储新创建的对象，内存较小，垃圾回收频繁。这个区又分为三个区域：一个 Eden Space 和两个 Survivor Space。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当对象在堆创建时，将进入年轻代的Eden Space。&lt;/li&gt;
&lt;li&gt;垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制 Old Gen&lt;/li&gt;
&lt;li&gt;扫描A Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个Old对象，则将其移到Old Gen。&lt;/li&gt;
&lt;li&gt;扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和B Suvivor Space。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Tenure Generation Space（采用标记-整理算法）&lt;/p&gt;
&lt;p&gt;主要用来存储长时间被引用的对象。它里面存放的是经过几次在 Young Generation Space 进行扫描判断过仍存活的对象，内存较大，垃圾回收频率较小。&lt;/p&gt;
&lt;h3 id=&quot;permanent-space&quot;&gt;Permanent Space&lt;/h3&gt;
&lt;p&gt;存储不变的类定义、字节码和常量等。&lt;/p&gt;
&lt;h2 id=&quot;class文件&quot;&gt;Class文件&lt;/h2&gt;
&lt;h3 id=&quot;java虚拟机的平台无关性&quot;&gt;Java虚拟机的平台无关性&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020052601270892.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;class文件的组成？&quot;&gt;Class文件的组成？&lt;/h3&gt;
&lt;p&gt;Class文件是一组以8位字节为基础单位的二进制流，各个数据项目间没有任何分隔符。当遇到8位字节以上空间的数据项时，则会按照高位在前的方式分隔成若干个8位字节进行存储。&lt;/p&gt;
&lt;h3 id=&quot;魔数与class文件的版本&quot;&gt;魔数与Class文件的版本&lt;/h3&gt;
&lt;p&gt;每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的Class文件。OxCAFEBABE。&lt;/p&gt;
&lt;p&gt;接下来是Class文件的版本号：第5,6字节是次版本号（Minor Version），第7,8字节是主版本号（Major Version）。&lt;/p&gt;
&lt;p&gt;使用JDK 1.7编译输出Class文件，格式代码为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020052601272371.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前四个字节为魔数，次版本号是0x0000，主版本号是0x0033，说明本文件是可以被1.7及以上版本的虚拟机执行的文件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;33：JDK1.7&lt;/li&gt;
&lt;li&gt;32：JDK1.6&lt;/li&gt;
&lt;li&gt;31：JDK1.5&lt;/li&gt;
&lt;li&gt;30：JDK1.4&lt;/li&gt;
&lt;li&gt;2F：JDK1.3&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012739123.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;类加载器&quot;&gt;类加载器&lt;/h2&gt;
&lt;h3 id=&quot;类加载器的作用是什么？&quot;&gt;类加载器的作用是什么？&lt;/h3&gt;
&lt;p&gt;类加载器实现类的加载动作，同时用于确定一个类。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，这两个类就不相等。&lt;/p&gt;
&lt;h3 id=&quot;类加载器有哪些？&quot;&gt;类加载器有哪些？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;启动类加载器（Bootstrap ClassLoader）：使用C++实现（仅限于HotSpot），是虚拟机自身的一部分。负责将存放在\lib目录中的类库加载到虚拟机中。其无法被Java程序直接引用。&lt;/li&gt;
&lt;li&gt;扩展类加载器（Extention ClassLoader）由ExtClassLoader实现，负责加载\lib\ext目录中的所有类库，开发者可以直接使用。&lt;/li&gt;
&lt;li&gt;应用程序类加载器（Application ClassLoader）：由APPClassLoader实现。负责加载用户类路径（ClassPath）上所指定的类库。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h2&gt;
&lt;h3 id=&quot;什么是双亲委派模型？&quot;&gt;什么是双亲委派模型？&lt;/h3&gt;
&lt;p&gt;双亲委派模型（Parents Delegation Model）要求除了顶层的启动类加载器外，其余加载器都应当有自己的父类加载器。类加载器之间的父子关系，通过组合关系复用。&lt;br/&gt;工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有到父加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用双亲委派模型，组织类加载器之间的关系？&quot;&gt;为什么要使用双亲委派模型，组织类加载器之间的关系？&lt;/h3&gt;
&lt;p&gt;Java类随着它的类加载器一起具备了一种带优先级的层次关系。比如java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各个类加载器环境中，都是同一个类。&lt;/p&gt;
&lt;p&gt;如果没有使用双亲委派模型，让各个类加载器自己去加载，那么Java类型体系中最基础的行为也得不到保障，应用程序会变得一片混乱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012753429.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是类加载机制？&quot;&gt;什么是类加载机制？&lt;/h3&gt;
&lt;p&gt;Class文件描述的各种信息，都需要加载到虚拟机后才能运行。虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。&lt;/p&gt;
&lt;h2 id=&quot;虚拟机和物理机的区别是什么？&quot;&gt;虚拟机和物理机的区别是什么？&lt;/h2&gt;
&lt;p&gt;这两种机器都有代码执行的能力，但是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面的。&lt;/li&gt;
&lt;li&gt;虚拟机的执行引擎是自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运行时栈帧结构&quot;&gt;运行时栈帧结构&lt;/h2&gt;
&lt;p&gt;栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构， 存储了方法的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;局部变量表&lt;/li&gt;
&lt;li&gt;操作数栈&lt;/li&gt;
&lt;li&gt;动态连接&lt;/li&gt;
&lt;li&gt;方法返回地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012805985.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-方法调用&quot;&gt;Java 方法调用&lt;/h2&gt;
&lt;h3 id=&quot;什么是方法调用？&quot;&gt;什么是方法调用？&lt;/h3&gt;
&lt;p&gt;方法调用唯一的任务是确定被调用方法的版本（调用哪个方法），暂时还不涉及方法内部的具体运行过程。&lt;/p&gt;
&lt;h3 id=&quot;java的方法调用，有什么特殊之处？&quot;&gt;Java的方法调用，有什么特殊之处？&lt;/h3&gt;
&lt;p&gt;Class文件的编译过程不包含传统编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这使得Java有强大的动态扩展能力，但使Java方法的调用过程变得相对复杂，需要在类加载期间甚至到运行时才能确定目标方法的直接引用。&lt;/p&gt;
&lt;h3 id=&quot;java虚拟机调用字节码指令有哪些？&quot;&gt;Java虚拟机调用字节码指令有哪些？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;invokestatic：调用静态方法&lt;/li&gt;
&lt;li&gt;invokespecial：调用实例构造器方法、私有方法和父类方法&lt;/li&gt;
&lt;li&gt;invokevirtual：调用所有的虚方法&lt;/li&gt;
&lt;li&gt;invokeinterface：调用接口方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;虚拟机是如何执行方法里面的字节码指令的？&quot;&gt;虚拟机是如何执行方法里面的字节码指令的？&lt;/h3&gt;
&lt;p&gt;解释执行（通过解释器执行）&lt;br/&gt;编译执行（通过即时编译器产生本地代码）&lt;/p&gt;
&lt;h3 id=&quot;解释执行&quot;&gt;解释执行&lt;/h3&gt;
&lt;p&gt;当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，只有虚拟机自己才能准确判断。&lt;/p&gt;
&lt;p&gt;Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译是半独立的实现。&lt;/p&gt;
&lt;h2 id=&quot;基于栈的指令集和基于寄存器的指令集&quot;&gt;基于栈的指令集和基于寄存器的指令集&lt;/h2&gt;
&lt;h3 id=&quot;什么是基于栈的指令集？&quot;&gt;什么是基于栈的指令集？&lt;/h3&gt;
&lt;p&gt;Java编译器输出的指令流，里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。&lt;/p&gt;
&lt;p&gt;计算“1+1=2”，基于栈的指令集是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;iconst_1
iconst_1
iadd
istore_0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两条iconst_1指令连续地把两个常量1压入栈中，iadd指令把栈顶的两个值出栈相加，把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中。&lt;/p&gt;
&lt;h3 id=&quot;什么是基于寄存器的指令集？&quot;&gt;什么是基于寄存器的指令集？&lt;/h3&gt;
&lt;p&gt;最典型的是x86的地址指令集，依赖寄存器工作。&lt;br/&gt;计算“1+1=2”，基于寄存器的指令集是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mov eax,  1
add eax,  1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里。&lt;/p&gt;
&lt;h3 id=&quot;基于栈的指令集的优缺点？&quot;&gt;基于栈的指令集的优缺点？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可移植性好：用户程序不会直接用到这些寄存器，由虚拟机自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存）放到寄存器以获取更好的性能。&lt;/li&gt;
&lt;li&gt;代码相对紧凑：字节码中每个字节就对应一条指令&lt;/li&gt;
&lt;li&gt;编译器实现简单：不需要考虑空间分配问题，所需空间都在栈上操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行速度稍慢&lt;/li&gt;
&lt;li&gt;完成相同功能所需的指令熟练多&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;频繁的访问栈，意味着频繁的访问内存，相对于处理器，内存才是执行速度的瓶颈。&lt;/p&gt;
&lt;h2 id=&quot;javac编译过程分为哪些步骤？&quot;&gt;Javac编译过程分为哪些步骤？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;解析与填充符号表&lt;/li&gt;
&lt;li&gt;插入式注解处理器的注解处理&lt;/li&gt;
&lt;li&gt;分析与字节码生成&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012818807.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;什么是即时编译器？&quot;&gt;什么是即时编译器？&lt;/h2&gt;
&lt;p&gt;Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code）。&lt;/p&gt;
&lt;p&gt;为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器成为即时编译器（Just In Time Compiler，JIT编译器）。&lt;/p&gt;
&lt;h2 id=&quot;解释器和编译器&quot;&gt;解释器和编译器&lt;/h2&gt;
&lt;p&gt;许多主流的商用虚拟机，都同时包含解释器和编译器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当程序需要快速启动和执行时，解释器首先发挥作用，省去编译的时间，立即执行。&lt;/li&gt;
&lt;li&gt;当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，可以提高执行效率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果内存资源限制较大（部分嵌入式系统），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时编译器的代码还能退回成解释器的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012829214.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么要采用分层编译？&quot;&gt;为什么要采用分层编译？&lt;/h3&gt;
&lt;p&gt;因为即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间越长。&lt;/p&gt;
&lt;h3 id=&quot;分层编译器有哪些层次？&quot;&gt;分层编译器有哪些层次？&lt;/h3&gt;
&lt;p&gt;分层编译根据编译器编译、优化的规模和耗时，划分不同的编译层次，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第0层：程序解释执行，解释器不开启性能监控功能，可出发第1层编译。&lt;/li&gt;
&lt;li&gt;第1层：也成为C1编译，将字节码编译为本地代码，进行简单可靠的优化，如有必要加入性能监控的逻辑。&lt;/li&gt;
&lt;li&gt;第2层：也成为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用Client Compiler和Server Compiler将会同时工作。用Client Compiler获取更高的编译速度，用Server Compiler获取更好的编译质量。&lt;/p&gt;
&lt;h2 id=&quot;编译对象与触发条件&quot;&gt;编译对象与触发条件&lt;/h2&gt;
&lt;h3 id=&quot;热点代码有哪些？&quot;&gt;热点代码有哪些？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;被多次调用的方法&lt;/li&gt;
&lt;li&gt;被多次执行的循环体&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何判断一段代码是不是热点代码？&quot;&gt;如何判断一段代码是不是热点代码？&lt;/h3&gt;
&lt;p&gt;要知道一段代码是不是热点代码，是不是需要触发即时编译，这个行为称为热点探测。主要有两种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于采样的热点探测，虚拟机周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是“热点方法”。实现简单高效，但是很难精确确认一个方法的热度。&lt;/li&gt;
&lt;li&gt;基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认为它是热点方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hotspot虚拟机使用第二种，有两个计数器：&quot;&gt;HotSpot虚拟机使用第二种，有两个计数器：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;方法调用计数器&lt;/li&gt;
&lt;li&gt;回边计数器（判断循环代码）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方法调用计数器统计方法&quot;&gt;方法调用计数器统计方法&lt;/h3&gt;
&lt;p&gt;统计的是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器的热度衰减，这个时间就被称为半衰周期。&lt;/p&gt;
&lt;h2 id=&quot;有哪些经典的优化技术（即时编译器）？&quot;&gt;有哪些经典的优化技术（即时编译器）？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;语言无关的经典优化技术之一：公共子表达式消除&lt;/li&gt;
&lt;li&gt;语言相关的经典优化技术之一：数组范围检查消除&lt;/li&gt;
&lt;li&gt;最重要的优化技术之一：方法内联&lt;/li&gt;
&lt;li&gt;最前沿的优化技术之一：逃逸分析&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;公共子表达式消除&quot;&gt;公共子表达式消除&lt;/h3&gt;
&lt;p&gt;普遍应用于各种编译器的经典优化技术，它的含义是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果一个表达式E已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。没有必要重新计算，直接用结果代替E就可以了。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组边界检查消除&quot;&gt;数组边界检查消除&lt;/h3&gt;
&lt;p&gt;因为Java会自动检查数组越界，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑是一种性能负担。&lt;/p&gt;
&lt;p&gt;如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组区间内，那么整个循环中就可以把数组的上下界检查消除掉，可以节省很多次的条件判断操作。&lt;/p&gt;
&lt;h3 id=&quot;方法内联&quot;&gt;方法内联&lt;/h3&gt;
&lt;p&gt;内联消除了方法调用的成本，还为其他优化手段建立良好的基础。&lt;/p&gt;
&lt;p&gt;编译器在进行内联时，如果是非虚方法，那么直接内联。如果遇到虚方法，则会查询当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那么也可以内联，不过这种内联属于激进优化，需要预留一个逃生门（Guard条件不成立时的Slow Path），称为守护内联。&lt;/p&gt;
&lt;p&gt;如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者的继承关系发现变化的类，那么内联优化的代码可以一直使用。否则需要抛弃掉已经编译的代码，退回到解释状态执行，或者重新进行编译。&lt;/p&gt;
&lt;h3 id=&quot;逃逸分析&quot;&gt;逃逸分析&lt;/h3&gt;
&lt;p&gt;逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法里面被定义后，它可能被外部方法所引用，这种行为被称为方法逃逸。被外部线程访问到，被称为线程逃逸。&lt;/p&gt;
&lt;h2 id=&quot;如果对象不会逃逸到方法或线程外，可以做什么优化？&quot;&gt;如果对象不会逃逸到方法或线程外，可以做什么优化？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;栈上分配：一般对象都是分配在Java堆中的，对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。但是垃圾回收和整理都会耗时，如果一个对象不会逃逸出方法，可以让这个对象在栈上分配内存，对象所占用的内存空间就可以随着栈帧出栈而销毁。如果能使用栈上分配，那大量的对象会随着方法的结束而自动销毁，垃圾回收的压力会小很多。&lt;/li&gt;
&lt;li&gt;同步消除：线程同步本身就是很耗时的过程。如果逃逸分析能确定一个变量不会逃逸出线程，那这个变量的读写肯定就不会有竞争，同步措施就可以消除掉。&lt;/li&gt;
&lt;li&gt;标量替换：不创建这个对象，直接创建它的若干个被这个方法使用到的成员变量来替换。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java与cc的编译器对比&quot;&gt;Java与C/C++的编译器对比&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力。&lt;/li&gt;
&lt;li&gt;Java语言虽然没有virtual关键字，但是使用虚方法的频率远大于C++，所以即时编译器进行优化时难度要远远大于C++的静态优化编译器。&lt;/li&gt;
&lt;li&gt;Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，使得全局的优化难以进行，因为编译器无法看见程序的全貌，编译器不得不时刻注意并随着类型的变化，而在运行时撤销或重新进行一些优化。&lt;/li&gt;
&lt;li&gt;Java语言对象的内存分配是在堆上，只有方法的局部变量才能在栈上分配。C++的对象有多种内存分配方式。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;物理机如何处理并发问题？&quot;&gt;物理机如何处理并发问题？&lt;/h2&gt;
&lt;p&gt;运算任务，除了需要处理器计算之外，还需要与内存交互，如读取运算数据、存储运算结果等（不能仅靠寄存器来解决）。&lt;br/&gt;计算机的存储设备和处理器的运算速度差了几个数量级，所以不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache），作为内存与处理器之间的缓冲：将运算需要的数据复制到缓存中，让运算快速运行。当运算结束后再从缓存同步回内存，这样处理器就无需等待缓慢的内存读写了。&lt;br/&gt;基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓存，它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存时，可能导致各自的缓存数据不一致。&lt;br/&gt;为了解决一致性的问题，需要各个处理器访问缓存时遵循缓存一致性协议。同时为了使得处理器充分被利用，处理器可能会对输出代码进行乱序执行优化。Java虚拟机的即时编译器也有类似的指令重排序优化。&lt;/p&gt;
&lt;h2 id=&quot;java-内存模型&quot;&gt;Java 内存模型&lt;/h2&gt;
&lt;h3 id=&quot;什么是java内存模型？&quot;&gt;什么是Java内存模型？&lt;/h3&gt;
&lt;p&gt;Java虚拟机的规范，用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的并发效果。&lt;/p&gt;
&lt;h3 id=&quot;java内存模型的目标？&quot;&gt;Java内存模型的目标？&lt;/h3&gt;
&lt;p&gt;定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。此处的变量包括实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是线程私有的，不会被共享，所以不存在竞争问题。&lt;/p&gt;
&lt;h3 id=&quot;主内存与工作内存&quot;&gt;主内存与工作内存&lt;/h3&gt;
&lt;p&gt;所以的变量都存储在主内存，每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012839363.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;内存间的交互操作&quot;&gt;内存间的交互操作&lt;/h3&gt;
&lt;p&gt;一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存，Java内存模型定义了8种操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200526012850190.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMDI4Mzg2ODA0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;原子性、可见性、有序性&quot;&gt;原子性、可见性、有序性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;原子性：对基本数据类型的访问和读写是具备原子性的。对于更大范围的原子性保证，可以使用字节码指令monitorenter和monitorexit来隐式使用lock和unlock操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字。因此synchronized块之间的操作也具有原子性。&lt;/li&gt;
&lt;li&gt;可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取之前从主内存刷新变量值来实现可见性的。volatile的特殊规则保证了新值能够立即同步到主内存，每次使用前立即从主内存刷新。synchronized和final也能实现可见性。final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去，那么其他线程中就能看见final字段的值。&lt;/li&gt;
&lt;li&gt;有序性：Java程序的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）；如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序和工作内存与主内存同步延迟线性）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;volatile&quot;&gt;volatile&lt;/h2&gt;
&lt;h3 id=&quot;什么是volatile？&quot;&gt;什么是volatile？&lt;/h3&gt;
&lt;p&gt;关键字volatile是Java虚拟机提供的最轻量级的同步机制。当一个变量被定义成volatile之后，具备两种特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保证此变量对所有线程的可见性。当一条线程修改了这个变量的值，新值对于其他线程是可以立即得知的。而普通变量做不到这一点。&lt;/li&gt;
&lt;li&gt;禁止指令重排序优化。普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;为什么基于volatile变量的运算在并发下不一定是安全的？&quot;&gt;为什么基于volatile变量的运算在并发下不一定是安全的？&lt;/h3&gt;
&lt;p&gt;volatile变量在各个线程的工作内存，不存在一致性问题（各个线程的工作内存中volatile变量，每次使用前都要刷新到主内存）。但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。&lt;/p&gt;
&lt;h3 id=&quot;为什么使用volatile？&quot;&gt;为什么使用volatile？&lt;/h3&gt;
&lt;p&gt;在某些情况下，volatile同步机制的性能要优于锁（synchronized关键字），但是由于虚拟机对锁实行的许多消除和优化，所以并不是很快。&lt;/p&gt;
&lt;p&gt;volatile变量读操作的性能消耗与普通变量几乎没有差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。&lt;/p&gt;
&lt;h2 id=&quot;并发与线程&quot;&gt;并发与线程&lt;/h2&gt;
&lt;h3 id=&quot;并发与线程的关系？&quot;&gt;并发与线程的关系？&lt;/h3&gt;
&lt;p&gt;并发不一定要依赖多线程，PHP中有多进程并发。但是Java里面的并发是多线程的。&lt;/p&gt;
&lt;h3 id=&quot;什么是线程？&quot;&gt;什么是线程？&lt;/h3&gt;
&lt;p&gt;线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O），又可以独立调度（线程是CPU调度的最基本单位）。&lt;/p&gt;
&lt;h3 id=&quot;实现线程有哪些方式？&quot;&gt;实现线程有哪些方式？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用内核线程实现&lt;/li&gt;
&lt;li&gt;使用用户线程实现&lt;/li&gt;
&lt;li&gt;使用用户线程+轻量级进程混合实现&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;java线程的实现&quot;&gt;Java线程的实现&lt;/h3&gt;
&lt;p&gt;操作系统支持怎样的线程模型，在很大程度上就决定了Java虚拟机的线程是怎样映射的。&lt;/p&gt;
&lt;h2 id=&quot;java线程调度&quot;&gt;Java线程调度&lt;/h2&gt;
&lt;h3 id=&quot;什么是线程调度？&quot;&gt;什么是线程调度？&lt;/h3&gt;
&lt;p&gt;线程调度是系统为线程分配处理器使用权的过程。&lt;/p&gt;
&lt;h3 id=&quot;线程调度有哪些方法？&quot;&gt;线程调度有哪些方法？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;协同式线程调度：实现简单，没有线程同步的问题。但是线程执行时间不可控，容易系统崩溃。&lt;/li&gt;
&lt;li&gt;抢占式线程调度：每个线程由系统来分配执行时间，不会有线程导致整个进程阻塞的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然Java线程调度是系统自动完成的，但是我们可以建议系统给某些线程多分配点时间——设置线程优先级。Java语言有10个级别的线程优先级，优先级越高的线程，越容易被系统选择执行。&lt;/p&gt;
&lt;p&gt;但是并不能完全依靠线程优先级。因为Java的线程是被映射到系统的原生线程上，所以线程调度最终还是由操作系统说了算。如Windows中只有7种优先级，所以Java不得不出现几个优先级相同的情况。同时优先级可能会被系统自行改变。Windows系统中存在一个“优先级推进器”，当系统发现一个线程执行特别勤奋，可能会越过线程优先级为它分配执行时间。&lt;/p&gt;
&lt;h2 id=&quot;线程安全的定义？&quot;&gt;线程安全的定义？&lt;/h2&gt;
&lt;p&gt;当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;java语言操作的共享数据，包括哪些？&quot;&gt;Java语言操作的共享数据，包括哪些？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;不可变&lt;/li&gt;
&lt;li&gt;绝对线程安全&lt;/li&gt;
&lt;li&gt;相对线程安全&lt;/li&gt;
&lt;li&gt;线程兼容&lt;/li&gt;
&lt;li&gt;线程对立&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;不可变&quot;&gt;不可变&lt;/h3&gt;
&lt;p&gt;在Java语言里，不可变的对象一定是线程安全的，只要一个不可变的对象被正确构建出来，那其外部的可见状态永远也不会改变，永远也不会在多个线程中处于不一致的状态。&lt;/p&gt;
&lt;h2 id=&quot;如何实现线程安全？&quot;&gt;如何实现线程安全？&lt;/h2&gt;
&lt;p&gt;虚拟机提供了同步和锁机制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阻塞同步（互斥同步）&lt;/li&gt;
&lt;li&gt;非阻塞同步&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;阻塞同步（互斥同步）&quot;&gt;阻塞同步（互斥同步）&lt;/h3&gt;
&lt;p&gt;互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。Java中最基本的同步手段就是synchronized关键字，其编译后会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。这两个字节码都需要一个Reference类型的参数指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那么这个对象就是Reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去获取对应的对象实例或Class对象作为锁对象。&lt;br/&gt;在执行monitorenter指令时，首先要尝试获取对象的锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器+1；当执行monitorexit指令时将锁计数器-1。当计数器为0时，锁就被释放了。&lt;/li&gt;
&lt;li&gt;如果获取对象失败了，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了synchronized之外，还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步。ReentrantLock比synchronized增加了高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。&lt;/p&gt;
&lt;p&gt;等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，对处理执行时间非常长的同步块很有用。&lt;/p&gt;
&lt;p&gt;公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized中的锁是非公平的。&lt;/p&gt;
&lt;h3 id=&quot;非阻塞同步&quot;&gt;非阻塞同步&lt;/h3&gt;
&lt;p&gt;互斥同步最大的问题，就是进行线程阻塞和唤醒所带来的性能问题，是一种悲观的并发策略。总是认为只要不去做正确的同步措施（加锁），那就肯定会出问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。&lt;/p&gt;
&lt;p&gt;随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。&lt;/p&gt;
&lt;h2 id=&quot;锁优化是在jdk的那个版本？&quot;&gt;锁优化是在JDK的那个版本？&lt;/h2&gt;
&lt;p&gt;JDK1.6的一个重要主题，就是高效并发。HotSpot虚拟机开发团队在这个版本上，实现了各种锁优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;适应性自旋&lt;/li&gt;
&lt;li&gt;锁消除&lt;/li&gt;
&lt;li&gt;锁粗化&lt;/li&gt;
&lt;li&gt;轻量级锁&lt;/li&gt;
&lt;li&gt;偏向锁&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;为什么要提出自旋锁？&quot;&gt;为什么要提出自旋锁？&lt;/h3&gt;
&lt;p&gt;互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来很大压力。同时很多应用共享数据的锁定状态，只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。先不挂起线程，等一会儿。&lt;/p&gt;
&lt;h3 id=&quot;自旋锁的原理？&quot;&gt;自旋锁的原理？&lt;/h3&gt;
&lt;p&gt;如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，让后面请求锁的线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放。为了让线程等待，我们只需让线程执行一个忙循环（自旋）。&lt;/p&gt;
&lt;h3 id=&quot;自旋的缺点？&quot;&gt;自旋的缺点？&lt;/h3&gt;
&lt;p&gt;自旋等待本身虽然避免了线程切换的开销，但它要占用处理器时间。所以如果锁被占用的时间很短，自旋等待的效果就非常好；如果时间很长，那么自旋的线程只会白白消耗处理器的资源。所以自旋等待的时间要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，那就应该使用传统的方式挂起线程了。&lt;/p&gt;
&lt;h3 id=&quot;什么是自适应自旋？&quot;&gt;什么是自适应自旋？&lt;/h3&gt;
&lt;p&gt;自旋的时间不固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果一个锁对象，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行，那么虚拟机认为这次自旋仍然可能成功，进而运行自旋等待更长的时间。&lt;/li&gt;
&lt;li&gt;如果对于某个锁，自旋很少成功，那在以后要获取这个锁，可能省略掉自旋过程，以免浪费处理器资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机也会越来越聪明。&lt;/p&gt;
&lt;h3 id=&quot;锁消除&quot;&gt;锁消除&lt;/h3&gt;
&lt;p&gt;锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。&lt;/p&gt;
&lt;p&gt;程序员怎么会在明知道不存在数据竞争的情况下使用同步呢？很多不是程序员自己加入的。&lt;/p&gt;
&lt;h3 id=&quot;锁粗化&quot;&gt;锁粗化&lt;/h3&gt;
&lt;p&gt;原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。&lt;/p&gt;
&lt;p&gt;锁粗化就是增大锁的作用域。&lt;/p&gt;
&lt;h3 id=&quot;轻量级锁&quot;&gt;轻量级锁&lt;/h3&gt;
&lt;p&gt;在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。&lt;/p&gt;
&lt;h3 id=&quot;偏向锁&quot;&gt;偏向锁&lt;/h3&gt;
&lt;p&gt;消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。即在无竞争的情况下，把整个同步都消除掉。这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考：《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Nov 2020 16:15:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 最近，一直有小伙伴让我整理下关于JVM的知识，经过十几天的收集与整理，初版算是整理出来了。希望对大家有所帮助。 JDK 是什么？ JDK 是用于支持 Java 程序开发的最小环境。 Java</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13997552.html</dc:identifier>
</item>
<item>
<title>《.NET 5.0 背锅案》第5集-案情大转弯：都是我们的错，让 .NET 5.0 背锅 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/13996747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/13996747.html</guid>
<description>&lt;p&gt;今天晚上我们发布了最新版博客系统的 .NET Core 3.1 版，之前回退的都是以前的 .NET Core 3.1 版，最新版是基于 .NET 5.0，今天进行一番降级修改才有了 .NET Core 3.1 版。出这个版本有2个打算，一是如果问题暂时解决不了，先用 .NET Core 3.1 版支撑一段时间，二是验证一下是不是这段时间我们代码的变更埋下的坑&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;62.432279909707&quot;&gt;
&lt;p&gt;今天晚上我们发布了最新版博客系统的 .NET Core 3.1 版，之前回退的都是以前的 .NET Core 3.1 版，最新版是基于 .NET 5.0，今天进行一番降级修改才有了 .NET Core 3.1 版。出这个版本有2个打算，一是如果问题暂时解决不了，先用 .NET Core 3.1 版支撑一段时间，二是验证一下是不是这段时间我们代码的变更埋下的坑。&lt;/p&gt;
&lt;p&gt;原本不报希望我们能写出如此大坑的代码，原以为这次发布肯定不会出现故障，但残酷的现实让我们无地自容，发布过程中竟然也出现了同样的故障 —— 这200%证明了问题是我们自己写的代码引起的，真凶代码就藏在博客系统 2.3.73 与 2.3.100 版本之间的200多个commit中，与 .NET 5.0 无任何关系，是我们的麻木自信让 .NET 5.0 刚刚出道就背锅，是我们给 .NET 社区雪上加霜，都是我们的错，我们会将功补过。&lt;/p&gt;
&lt;p&gt;我们会将糟糕的博客系统代码开源，给 .NET 社区提供一个反面教材，我们会苦练内功并分享自己的 .NET 开发实践，我们会尽自己的最大努力推动 .NET 社区的发展，因为我们的抹黑给 .NET 带来的损失，我们会黑一罚十地还回去。&lt;/p&gt;
&lt;p&gt;非常抱歉，这段时间给大家带来麻烦了，请大家谅解。&lt;/p&gt;
&lt;p&gt;接下来我们要好好 review 代码，找出究竟是什么样的代码惹出这么大的祸，给大家一个交代。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 17 Nov 2020 15:45:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>今天晚上我们发布了最新版博客系统的 .NET Core 3.1 版，之前回退的都是以前的 .NET Core 3.1 版，最新版是基于 .NET 5.0，今天进行一番降级修改才有了 .NET Core</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/13996747.html</dc:identifier>
</item>
<item>
<title>记在Linux上定位后台服务偶发崩溃的问题 - 浩天之家</title>
<link>http://www.cnblogs.com/cherishui/p/13997456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cherishui/p/13997456.html</guid>
<description>&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在最近的后台服务中，新增将某个指令的请求数据落盘保存的功能。在具体实现时，采用成员变量来保存请求消息代理头，在接收响应以及消息管理类释放时进行销毁。测试反馈，该服务偶发崩溃。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;测试环境上运行的是rel版程序，由于在编译时去掉了调试信息（-g）以及开启O3级别优化，从崩溃dump的堆栈上，只看到程序崩溃的调用栈，函数入参等被优化掉，由于此处没有打日志，只能想其他办法来复现。猜测是重复释放指针导致的崩溃，接下来继续分析。&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;rel&lt;/code&gt;版本的调用栈上看，只看见最后销毁的函数调用，而在实际代码中，有两处销毁的函数调用入口，为什么在dump中看到的调用栈顺序与实际代码不一致呢？猜测是开启O3优化，将函数内联。&lt;/p&gt;
&lt;p&gt;做了以下实验来分析，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
void test_dump()
{
        int* p = NULL;
        *p = 2;         // occur dump
}

void test_f2(int b)
{
        b += 1;
        test_dump();
}

void test_f1(int a)
{
        a+=1;
        test_f2(a);
}

int main()
{
    test_f1(1);
        return 0;
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Debug以及Rel模式下，触发崩溃，使用gdb来输出堆栈信息分别如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/17/1ABhTGQzKbrocWU.jpg&quot; alt=&quot;debug模式下的调用堆栈.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/11/17/rOcqt7FwGTWuKVJ.jpg&quot; alt=&quot;rel模式下的调用堆栈.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结论：在&lt;code&gt;Rel&lt;/code&gt;模式下，O3级别的优化内联了调用函数，如果从崩溃点往上回溯有多个可能入口点，那仅凭&lt;code&gt;dump&lt;/code&gt;信息不能确认是哪个入口触发的崩溃。&lt;/p&gt;
&lt;h3 id=&quot;构造测试环境&quot;&gt;构造测试环境&lt;/h3&gt;
&lt;p&gt;通过分析代码，得知要触发可能的多重释放，需要构造一边创建，一边销毁的场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建：可通过测试工具，定时高频发送特定指令，触发创建流程&lt;/li&gt;
&lt;li&gt;销毁：可在定时任务中，进行无效状态上报，触发销毁流程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了加快崩溃复现速度，创建以及销毁的速度需要合理匹配，如果太快销毁，会导致无法进入创建流程。经过分析尝试，最终&lt;br/&gt;设定测试工具每50毫秒发送一次，后台服务每50ms上报无效状态。&lt;/p&gt;
&lt;p&gt;为进一步验证崩溃的想法，在销毁操作等关键路径添加日志，启动&lt;code&gt;Rel&lt;/code&gt;版来重现。经过长时间的测试，获得了&lt;code&gt;2&lt;/code&gt;次宝贵的崩溃dump以及对应的日志。每次dump要花费2个半小时甚至更多才能复现，说明这个问题是偶发问题，很可能与多线程竞态有关。复现该问题的时间成本有点高，不过，从获得的dump以及日志已足以定位问题。&lt;/p&gt;
&lt;h2 id=&quot;日志分析&quot;&gt;日志分析&lt;/h2&gt;
&lt;p&gt;同一后台服务，不同业务模块的日志分布在不同日志文件中，在分析时，需要将各部分日志聚合起来，方便复现全流程。在聚合时，可以按需截取各模块的最后若干行日志，每种日志中包含正常以及异常的日志，将其汇总到单一文件，然后结合代码进行逐行关联分析。&lt;/p&gt;
&lt;p&gt;在分析过程中，遇到一些框架方面的疑问，通过询问相关同事得到解答。目前的消息收发框架在接收消息时，先将消息放入线程池的消息队列，通过信号量来唤醒线程，线程从消息队列中获取消息，从消息中取出处理函数进行处理。&lt;br/&gt;在应用层处理不同消息时，可能处理同一个变量时，会有发生竞态。通过对释放指针的分析，正常释放指针指都有一定的规律，当触发崩溃时，释放的指针值与正常的值有明显区别。&lt;/p&gt;
&lt;h2 id=&quot;经验小结&quot;&gt;经验小结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;发现有dump文件时，查看dump文件生成时间，将当时的日志以及可执行文件，连同dump文件一并放在独立的文件夹中，便于后续分析。因为当前的日志文件以及可执行文件可能被删除以及更新。&lt;/li&gt;
&lt;li&gt;每一次问题的解决，都是一次对已有系统的再深入认识，理解。&lt;/li&gt;
&lt;li&gt;构造复现环境时，要使用Rel版本，且只能通过日志来确认程序流程，而不是断点。&lt;/li&gt;
&lt;li&gt;在linux上，不能使用嵌套属性的互斥锁，它会破坏设计意图，让潜在的死锁更加难以发现。让错误尽早暴露好过后续找错。&lt;/li&gt;
&lt;li&gt;大胆假设，小心求证，胜利的曙光终会出现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/codestack/p/12830451.html&quot;&gt;线上问题 不能gdb调试怎么处理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.0xffffff.org/2017/01/22/39-multi-thread-memory-bug/&quot;&gt;Linux 环境下多线程 C/C++ 程序的内存问题调试&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Nov 2020 15:37:00 +0000</pubDate>
<dc:creator>浩天之家</dc:creator>
<og:description>本文描述在定位后台服务偶发崩溃时的心得体会。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cherishui/p/13997456.html</dc:identifier>
</item>
<item>
<title>微信个性化菜单开发 - 五哥-coder</title>
<link>http://www.cnblogs.com/lingxiukeji-wyj/p/13997407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lingxiukeji-wyj/p/13997407.html</guid>
<description>&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继上一篇的《自定义微信公众号的个性化菜单栏》的文章，为了“根据不同用户标签显示不同的功能菜单并且点击菜单跳转到外网”这个功能需求，研究了一天的微信开发文档关于个性化菜单，消息接口事件推送，用户标签的问题，将自己在开发过程中遇到的问题分享出来，让更多的小伙伴少走弯路。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;梳理问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其一 ：接触过微信公众号开发的小伙伴都知道，微信公众号(认证服务号)的后台是给用户提供有自定义菜单设置，并且在那里可以设置菜单并且设置url连接来跳转到网页&lt;/p&gt;
&lt;p&gt;其二：我们可以通过微信提供的自定义菜单创建接口，(如何获取AccessToken请参考上一篇文章)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
//生成自定义菜单（默认菜单）
    public function createMenu(){
        $access_token = $this-&amp;gt;getAccessToken();
        $url = &quot;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot;.$access_token;

        //拼装要生成的菜单
        $array = array(
            'button'=&amp;gt;array(
                //第一个一级菜单
//                array(
//                    'type'=&amp;gt;'click',
//                    'name'=&amp;gt;'hello',
//                    'key' =&amp;gt;'front',
//
//                ),
                array(
                    &quot;type&quot;=&amp;gt;&quot;view&quot;,
                    &quot;name&quot;=&amp;gt; 'world',
                    &quot;url&quot;=&amp;gt;&quot;http://www.baidu.com&quot;
                ),

                //第二个一级菜单
//                array(
//                    'type'=&amp;gt;'click',
//                    'name' =&amp;gt; urlencode($data['second_name']),
//                    'key' =&amp;gt;'behind',
//                ),
            ),

        );
        //转化成json的格式
        $arrayJson = urldecode(json_encode($array));
        $this-&amp;gt;http_curl($url,'post','json',$arrayJson);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　CURL请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; http_curl(&lt;span&gt;$url&lt;/span&gt;,&lt;span&gt;$type&lt;/span&gt;='get',&lt;span&gt;$res&lt;/span&gt;='json',&lt;span&gt;$arr&lt;/span&gt;=''&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.初始化&lt;/span&gt;
        &lt;span&gt;$ch&lt;/span&gt; =&lt;span&gt; curl_init();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.设置参数&lt;/span&gt;
        curl_setopt(&lt;span&gt;$ch&lt;/span&gt;, CURLOPT_URL, &lt;span&gt;$url&lt;/span&gt;&lt;span&gt;);
        curl_setopt(&lt;/span&gt;&lt;span&gt;$ch&lt;/span&gt;, CURLOPT_RETURNTRANSFER, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;( &lt;span&gt;$type&lt;/span&gt; == 'post'&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是post请求的话,设置post的一些参数&lt;/span&gt;
            curl_setopt(&lt;span&gt;$ch&lt;/span&gt; , CURLOPT_POST , 1&lt;span&gt;);
            curl_setopt(&lt;/span&gt;&lt;span&gt;$ch&lt;/span&gt; , CURLOPT_POSTFIELDS, &lt;span&gt;$arr&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行&lt;/span&gt;
        &lt;span&gt;$result&lt;/span&gt; = curl_exec(&lt;span&gt;$ch&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( curl_errno(&lt;span&gt;$ch&lt;/span&gt;&lt;span&gt;)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印错误日志&lt;/span&gt;
            &lt;span&gt;var_dump&lt;/span&gt;(curl_error(&lt;span&gt;$ch&lt;/span&gt;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( &lt;span&gt;$res&lt;/span&gt; == 'json'&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将json转化成数组的形式&lt;/span&gt;
            &lt;span&gt;$result&lt;/span&gt; = json_decode(&lt;span&gt;$result&lt;/span&gt; , &lt;span&gt;TRUE&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.关闭&lt;/span&gt;
        curl_close(&lt;span&gt;$ch&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$result&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：这里的菜单是定义的二级菜单，定义二级菜单的作用是可以通过其url参数实现点击跳转(特别提示：官方文档中并没有说明在没有一级菜单的情况下不允许定义二级菜单，所以通过自定义接口我们可以直接创建二级菜单)&lt;/p&gt;
&lt;p&gt;　　小插曲：开始按照官方文档指示，并没有创建二级菜单，而是创建一级菜单，然而一级菜单的type事件跟二级的type事件不一样，一级菜单需要开启公众号后台的服务器配置，并且需要配置相关服务器接口，微信根据所配置的接口，将用户操作的内容发送到该接口，一级菜单的click事件绑定的EventKey参数可以用来在接口中识别是点击了哪个自定义菜单，可以根据EventKey的值来进行相关业务逻辑的处理。&lt;/p&gt;
&lt;p&gt;其三：创建个性化菜单&lt;/p&gt;
&lt;p&gt;根据微信官方文档说明：&lt;/p&gt;
&lt;p&gt;个性化菜单匹配规则说明：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;个性化菜单的更新是会被覆盖的。 例如公众号先后发布了默认菜单，个性化菜单1，个性化菜单2，个性化菜单3。那么当用户进入公众号页面时，将从个性化菜单3开始匹配，如果个性化菜单3匹配成功，则直接返回个性化菜单3，否则继续尝试匹配个性化菜单2，直到成功匹配到一个菜单。 根据上述匹配规则，为了避免菜单生效时间的混淆，决定不予提供个性化菜单编辑API，开发者需要更新菜单时，需将完整配置重新发布一轮。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
//创建个性化匹配菜单
    public function characterMenu()
    {
        $access_token = $this-&amp;gt;getAccessToken();
        $url='https://api.weixin.qq.com/cgi-bin/menu/addconditional?access_token='.$access_token;

        $array = array(
            'button'=&amp;gt;array(
                array(
                    &quot;type&quot;=&amp;gt;&quot;view&quot;,
                    &quot;name&quot;=&amp;gt; 'hello',
                    &quot;url&quot;=&amp;gt;&quot;要跳转的url&quot;
                ),
                array(
                    &quot;type&quot;=&amp;gt;&quot;view&quot;,
                    &quot;name&quot;=&amp;gt; 'world',
                    &quot;url&quot;=&amp;gt;&quot;要跳转的url&quot;
                ),
            ),
            &quot;matchrule&quot;=&amp;gt;array(
                &quot;tag_id&quot;=&amp;gt;100//标签匹配，微信官方放回给你的标签id
            )
        );
        //转化成json的格式
        $arrayJson = urldecode(json_encode($array));
        $this-&amp;gt;http_curl($url,'post','json',$arrayJson);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：个性化菜单的创建也是直接创建的二级菜单，如何创建标签id接下来说明（申请标签应在创建个性化菜单之前）&lt;/p&gt;
&lt;p&gt;　　　　　matchrule的匹配规则项我们在这里只使用tag_id标签匹配，其他匹配项请参考微信开放文档(https://developers.weixin.qq.com/doc/offiaccount/Custom_Menus/Personalized_menu_interface.html)&lt;/p&gt;
&lt;p&gt;其四：创建用户标签&lt;/p&gt;
&lt;p&gt;创建用户标签也非常简单，直接上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 生成用户标签接口
     *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createTag()
    {
        &lt;/span&gt;&lt;span&gt;$access_token&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;getAccessToken();
        &lt;/span&gt;&lt;span&gt;$url&lt;/span&gt;='https://api.weixin.qq.com/cgi-bin/tags/create?access_token='.&lt;span&gt;$access_token&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;['tag']['name']=&lt;span&gt;urlencode&lt;/span&gt;('管理员'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;$res&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;http_curl(&lt;span&gt;$url&lt;/span&gt;,'post','json',json_encode(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;));
        dump(&lt;/span&gt;&lt;span&gt;$res&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功返回的参数包括tag_id&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其五：为用户添加标签&lt;/p&gt;
&lt;p&gt;该接口是批量为用户添加标签，参数为数组形式，里面只包含用户在该公众号下的唯一的openid值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量为用户打上微信公众号的标签类型&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; pasteTag(&lt;span&gt;$arr_openid&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$access_token&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;getAccessToken();
        &lt;/span&gt;&lt;span&gt;$url&lt;/span&gt;='https://api.weixin.qq.com/cgi-bin/tags/members/batchtagging?access_token='.&lt;span&gt;$access_token&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;['openid_list']=&lt;span&gt;$arr_openid&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;['tagid']=&lt;span&gt;你的标签id;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;http_curl(&lt;span&gt;$url&lt;/span&gt;,'post','json',json_encode(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;));
        dump(&lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在此，当用户访问该公众号的时候，根据用户身上的标签，会显示不同的菜单栏内容，实现个性化菜单的展示功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Additional：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为用户取消标签：&lt;/p&gt;
&lt;p&gt;openid为数组形式，数组里面是你要取消的该公众号下的唯一的用户的openid&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为用户取消标签&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; cancelTag(&lt;span&gt;$openid&lt;/span&gt;,&lt;span&gt;$tagid&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$access_token&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;getAccessToken();
        &lt;/span&gt;&lt;span&gt;$url&lt;/span&gt;='https://api.weixin.qq.com/cgi-bin/tags/members/batchuntagging?access_token='.&lt;span&gt;$access_token&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;['openid_list']=&lt;span&gt;$openid&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;['tagid']=&lt;span&gt;$tagid&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;http_curl(&lt;span&gt;$url&lt;/span&gt;,'post','json',json_encode(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;));
        wxlogging(&lt;/span&gt;'cancel_user_tag',json_encode(&lt;span&gt;$res&lt;/span&gt;&lt;span&gt;));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取该公众号创建的标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取微信公众号所创建的标签&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getTag()
    {
        &lt;/span&gt;&lt;span&gt;$access_token&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;getAccessToken();
        &lt;/span&gt;&lt;span&gt;$url&lt;/span&gt;='https://api.weixin.qq.com/cgi-bin/tags/get?access_token='.&lt;span&gt;$access_token&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;http_curl(&lt;span&gt;$url&lt;/span&gt;&lt;span&gt;);
        dump(&lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取某个标签下的用户：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取某个标签下面的粉丝openid&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getFans()
    {
        &lt;/span&gt;&lt;span&gt;$access_token&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;getAccessToken();
        &lt;/span&gt;&lt;span&gt;$url&lt;/span&gt;='https://api.weixin.qq.com/cgi-bin/user/tag/get?access_token='.&lt;span&gt;$access_token&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;['tagid']=100&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;http_curl(&lt;span&gt;$url&lt;/span&gt;,'post','json',json_encode(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;));
        dump(&lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除所有菜单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; delete()
    {
        &lt;/span&gt;&lt;span&gt;$access_token&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;getAccessToken();
        &lt;/span&gt;&lt;span&gt;$url&lt;/span&gt;='https://api.weixin.qq.com/cgi-bin/menu/delete?access_token='.&lt;span&gt;$access_token&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$res&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;http_curl(&lt;span&gt;$url&lt;/span&gt;,'get','json'&lt;span&gt;);
        dump(&lt;/span&gt;&lt;span&gt;$res&lt;/span&gt;&lt;span&gt;);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 17 Nov 2020 15:22:00 +0000</pubDate>
<dc:creator>五哥-coder</dc:creator>
<og:description>问题描述： 继上一篇的《自定义微信公众号的个性化菜单栏》的文章，为了“根据不同用户标签显示不同的功能菜单并且点击菜单跳转到外网”这个功能需求，研究了一天的微信开发文档关于个性化菜单，消息接口事件推送，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lingxiukeji-wyj/p/13997407.html</dc:identifier>
</item>
<item>
<title>[开源地址] 放弃Flink，.NET5.0开发CSharpFlink，简要设计、部署及二次开发说明。 - 唯笑志在-ineuos.net</title>
<link>http://www.cnblogs.com/lsjwq/p/13997341.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/13997341.html</guid>
<description>&lt;blockquote readability=&quot;1.4795918367347&quot;&gt;
&lt;p&gt;&lt;span&gt;github地址：&lt;a href=&quot;https://github.com/wxzz/CSharpFlink&quot; target=&quot;_blank&quot;&gt;https://github.com/wxzz/CSharpFlink&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;gitee地址：&lt;a href=&quot;https://gitee.com/wxzz/CSharpFlink&quot; target=&quot;_blank&quot;&gt;https://gitee.com/wxzz/CSharpFlink&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      我们有一个全国性质的面向工业的公有云平台，通过专线或4G的链路方式实时向平台传输数据，每天处理1亿条左右的数据量，为现场用户提供实时的在线服务和离线数据分析服务。现在已经上线稳定运行有将近3年的时间。同时也为工业企业提供私有云建设服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我们计划使用Flink作为云平台后台的实时计算部分，基本实现数据点的聚合计算、表达式规则计算等业务，进一步实现机器学习或自定义复杂算法的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我们经过将近一年左右时间的研究及开发，已经基本实现了聚合和逻辑等业务，但是感觉Flink比较重，并且应用和运维的水平要求比较高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      基于上述情况，我们自主使用NET 5.0开发一套CSharpFlink实时计算组件，支持自定义数据源、计算和存储的基本要求。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;主要面向物联网、工业互联网私有云或公有云平台建设过程中的数据点实时聚合和表达式计算。应用场景包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）数据点的实时时间窗口范围内聚合计算，例如：最大值、最小值、平均值、和值、众数、方差、中位数等，可以自定义二次开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）数据点的历史延迟窗口的一段时间范围内数据补充或更新的重新计算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）数据点的表达式计算，支持自定义C#脚本进行编辑，实时预警或数据深度加工处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）主从结构的分布式部署，主节点负责计算任务分发，工作节点负责任务计算及结果存储。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;主要特点主要是根据我们多年的物联网、工业项目经验的提炼和总结，满足实现应用场景，特点包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）使用最新的NET 5.0进行开发，完全跨平台。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）实时数据窗口范围外的数据补发或更新的重新计算，例如：当前5秒的实时数据窗口，支持5秒以前的数据补充和更新，并且进行重新计算及更新到数据存储单元。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）实时数据表达式计算支持定时计算或数据值改事件变触发计算，满足实时表达式或周期性计算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）C#语言的二次开发，对接多种数据源，自定义算子和多种方式数据存储等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）单节点或分布式部署。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;框架结构组件的基本示意，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202011/279374-20201117230431033-1640411941.png&quot; width=&quot;1024&quot; loading=&quot;lazy&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;使用VS2019进行工程开发，工程解决方案文件为：CSharpFlink.sln，代码目录说明如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Cache：主节点和工作节点计算任务本地缓存管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Calculate：计算任务输入、过程、输出操作及管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Channel：主节点和工作节点分布式部署模式的IO通讯操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Common：操作公众类库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Config：全局配置文件操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Execution：全局工程的执行环境入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）Expression：表达式计算任务操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）Log：日志操作及管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9）Model：数据点元数据信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（10）Node：主节点和工作节点管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（11）Protocol：主节点和工作节点之间分布式部署之间交互的协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（12）Sink：计算任务计算结果存储接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（13）Source：对接多种数据源接口，例如：mqtt、kafka、rabbitmq、数据库等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（14）Task：窗口或表达任务接口，主节点和工作节点任务操作及管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（15）Window：数据窗口任务操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（16）Worker：工作节点接口。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;配置文件默认为：cfg\global.cfg，可以自定义指定配置文件，参见：命令行操作说明。配置文件说明，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（1）MaxDegreeOfParallelism：任务并行度，主节点生成任务、工作节点处理任务依赖这个参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（2）MasterListenPort：主节点侦听端口，用于工作节点主动连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（3）MasterIp：主节点IP，用于工作节点主动连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（4）NodeType：节点运行模式，包括：Master、Slave和Both。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（5）RemoteInvokeInterval：远程调用工作节点间隔时间，单位：毫秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（6）RepeatRemoteInvokeInterval：调用工作节点失败后，重新调用工作节点间隔时间，单位：毫秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（7）SlaveExcuteCalculateInterval：工作节点执行计算任务间隔时间，单位：毫秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（8）MaxFrameLength：主节点和工作节点之间传输数据最大数据侦，单位：字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（9）WorkerPower：工作节点能力系数，大于1，会连续发送多个任务。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;二次开发参见：二次开发说明。开发好的任务，测试通过后，把程序集（.dll）复制到“tasks”目录下，例如工程TestTask项目测试、编译通过后，可以部署到“tasks”目录下，运行“CSharpFlink”主程序会自动加载和调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以自定义指定任务程序集，参见：命令行操作说明。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;命令行运行“CSharpFlink”程序，支持自定义指定配置文件或任务程序集，说明如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-h         显示命令行帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-c         加载指定配置文件。 例如:CSharpFlink -c c:/my.cfg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-t         加载任务程序集。     例如:CSharpFlink -t c:/mytask.dll&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet CSharpFlink.dll -c c:/master.cfg -t c:/mytask.dll
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; &lt;span&gt;9  部署说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;“release”目录下是编译好的程序，把“CSharpFlink v1.0”分别复制到不同的路径下，分别修改“cfg\global.cfg”配置文件中“NodeType”参数为：Master和Slave，修改主节点程序“tasks\tasks.cfg”文件中的任务数，分别运行不同目录下的“dotnet CSharpFlink.dll”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“TestTask.dll”源代码，参见：二次开发说明。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;二次开发主要针对数据源、计算过程和数据计算结果存储，大致过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）  数据源对接，可以自定义对接mqtt、kafka、rabbitmq、数据库等，需要继承SourceFunction接口，参见：RandomSourceFunction.cs类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）  数据计算过程，可以自定义数据处理或加工，需要继承Calculate.Calculate接口，参见：聚合计算Avg.cs、表达式计算ExpressionCalculate.cs。通过AddWindowTask或AddExpressionTask函数参数进行实例化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）  数据计算结果存储，可以自定义存储任何介质上，需要继承SinkFunction接口，参见：SinkFunction.cs类。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;同一台电脑，CPU：4核 I5-7400 3.0GHz,内存：16G，1个主节点，5个工作节点，生成1000个数据点任务，随机数据点时间窗口和计算算子，CPU使用率为：20%-30%，内存使用率：30%-40%，主节点CPU和内存使用情况：3%-5%、100MB-300MB, 工作节点CPU和内存使用情况：0.1%-2%、25MB-60MB。运行效果，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202011/279374-20201117230605084-1962198174.png&quot; width=&quot;1024&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;物联网&amp;amp;大数据技术 QQ群：&lt;span&gt;54256083&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;物联网&amp;amp;大数据合作 QQ群：727664080&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网站：&lt;a href=&quot;http://www.ineuos.net&quot; target=&quot;_blank&quot;&gt;http://www.ineuos.net&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;联系QQ：504547114&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合作微信：wxzz0151&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方博客：&lt;a href=&quot;https://www.cnblogs.com/lsjwq&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lsjwq&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iNeuOS工业互联网操作系统 公众号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/279374/202011/279374-20201109210223158-1810580141.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Nov 2020 15:07:00 +0000</pubDate>
<dc:creator>唯笑志在-ineuos.net</dc:creator>
<og:description>github地址：https://github.com/wxzz/CSharpFlinkgitee地址：https://gitee.com/wxzz/CSharpFlink 1 概述及背景 我们有一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lsjwq/p/13997341.html</dc:identifier>
</item>
<item>
<title>Linux杂谈: 实现一种简单实用的线程池（C语言） - TpCode</title>
<link>http://www.cnblogs.com/tp1226/p/13996788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp1226/p/13996788.html</guid>
<description>&lt;h2&gt;基本功能&lt;/h2&gt;
&lt;p&gt;1. 实现一个线程的队列，队列中的线程启动后不再释放；&lt;/p&gt;
&lt;p&gt;2. 没有任务执行时，线程处于pending状态，等待唤醒，不占cpu；&lt;/p&gt;
&lt;p&gt;3. 当有任务需要执行时，从线程队列中取出一个线程执行任务；&lt;/p&gt;
&lt;p&gt;4. 任务执行完成后线程再次进入pending状态，等待唤醒；&lt;/p&gt;

&lt;h2&gt;扩展功能&lt;/h2&gt;
&lt;p&gt;1. 线程的队列大小可设置；&lt;/p&gt;
&lt;p&gt;2. 最大可创建的线程数可设置；&lt;/p&gt;
&lt;p&gt;3. 根据运行需求，按需步进启动线程，避免大量线程一直处于pending状态，占用资源；&lt;/p&gt;

&lt;h2&gt;关键代码分析&lt;/h2&gt;
&lt;h3&gt;数据结构&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 线程执行的任务参数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; (*func)(&lt;span&gt;void&lt;/span&gt;*, &lt;span&gt;void&lt;/span&gt;*);    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数指针 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *arg1;                    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数第一个参数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *arg2;                    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数第二个参数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}tThreadTaskInfo;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 线程池参数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     pthread_mutex_t &lt;span&gt;lock&lt;/span&gt;;          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 线程池互斥锁 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     pthread_cond_t cond;           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 线程池同步信号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     pthread_t *threads;            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 保存线程池创建的所有线程 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     int32_t threadMaxNum;          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 最大可创建线程数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     int32_t threadStartStep;       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 一次启动线程的个数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     int32_t threadStartCnt;        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 已启动线程个数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     int32_t threadPendCnt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 已启动但是处于Pending状态的线程 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     tThreadTaskInfo *taskQueue;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待执行的任务队列 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     int32_t taskQueueSize;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务队列的大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     int32_t taskQueueHead;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 当前任务队列头索引 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     int32_t taskQueueTail;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 当前任务队列尾索引 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     int32_t taskPendCnt;           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待执行的任务个数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     int32_t isShutdown;            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 线程池正在关闭 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; }tThreadpoolInfo;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;创建线程池&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建线程池时只分配了存储pthread_t的空间，但是不启动线程，后面根据需求步进启动；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 创建线程池
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * @threadMaxNum     -- 最大可创建线程个数
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @threadStartStep  -- 一次启动线程的个数
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @taskQueueSize    -- 任务队列的大小
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Retuen  --  成功：线程池的引用
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; *              失败：NULL
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * *********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; tThreadpoolInfo*&lt;span&gt; threadpool_create(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    int32_t threadMaxNum,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    int32_t threadStartStep,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    int32_t taskQueueSize)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     tThreadpoolInfo *threadpool =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;0&lt;/span&gt; &amp;gt;=&lt;span&gt; threadMaxNum)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         || (&lt;span&gt;0&lt;/span&gt; &amp;gt;=&lt;span&gt; threadStartStep)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         || (&lt;span&gt;0&lt;/span&gt; &amp;gt;=&lt;span&gt; taskQueueSize))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid param.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error_exit;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     threadpool = (tThreadpoolInfo *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tThreadpoolInfo));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; threadpool)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;malloc threadpool failed.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error_exit;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     memset(threadpool, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tThreadpoolInfo));
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     threadpool-&amp;gt;threadMaxNum =&lt;span&gt; threadMaxNum;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     threadpool-&amp;gt;threadStartStep =&lt;span&gt; threadStartStep;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     threadpool-&amp;gt;taskQueueSize =&lt;span&gt; taskQueueSize;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 分配线程存储资源 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     threadpool-&amp;gt;threads = (pthread_t *)&lt;span&gt;calloc&lt;/span&gt;(threadMaxNum, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(pthread_t));
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL == threadpool-&amp;gt;&lt;span&gt;threads)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;malloc threads failed.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error_exit;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 分配任务队列 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     threadpool-&amp;gt;taskQueue = (tThreadTaskInfo *)&lt;span&gt;calloc&lt;/span&gt;(taskQueueSize, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tThreadTaskInfo));
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL == threadpool-&amp;gt;&lt;span&gt;taskQueue)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;malloc task queue failed.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error_exit;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化互斥信号量和同步信号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; !=&lt;span&gt; THREADPOOL_LOCK_INIT(threadpool))
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mutex init failed.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error_exit;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; !=&lt;span&gt; THREADPOOL_COND_INIT(threadpool))
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cond init failed.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error_exit;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; threadpool;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;error_exit:
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (threadpool !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;        threadpool_free(threadpool);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;向线程池添加任务&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看等待队列是否有空闲，如果没有空闲则返回错误；&lt;/li&gt;
&lt;li&gt;查看当前有没有处于pending的线程，如果没有则按照步进启动新的线程，如果已达到最大线程数则返回错误；&lt;/li&gt;
&lt;li&gt;将任务添加到队列中，并唤醒一个线程执行任务；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 向线程池添加任务
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * @threadpool -- 线程池引用
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @taskfunc   -- 任务回调函数
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @arg1       -- 任务第一个参数
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @arg1       -- 任务第二个参数
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * @Return  --  成功: 0
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; *              失败: -1
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * *********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;int32_t threadpool_addtask(
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     tThreadpoolInfo *&lt;span&gt;threadpool,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    THREADPOOLTASKFUNC taskfunc,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg1,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg2)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     int32_t ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((NULL == threadpool) || (NULL ==&lt;span&gt; taskfunc))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid param.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    THREADPOOL_LOCK(threadpool);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (threadpool-&amp;gt;&lt;span&gt;isShutdown)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadpool is shutdown.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             ret = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 判断等待执行的任务队列是否满 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (threadpool-&amp;gt;taskPendCnt == threadpool-&amp;gt;&lt;span&gt;taskQueueSize)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task queue is full.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             ret = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 如果pending状态的线程已用完，则启动新的线程 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (threadpool-&amp;gt;threadPendCnt &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; !=&lt;span&gt; threadpool_start(threadpool))
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 ret = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 将任务放入对尾 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         threadpool-&amp;gt;taskQueue[threadpool-&amp;gt;taskQueueTail].func =&lt;span&gt; taskfunc;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         threadpool-&amp;gt;taskQueue[threadpool-&amp;gt;taskQueueTail].arg1 =&lt;span&gt; arg1;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         threadpool-&amp;gt;taskQueue[threadpool-&amp;gt;taskQueueTail].arg2 =&lt;span&gt; arg2;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;         threadpool-&amp;gt;taskQueueTail = (threadpool-&amp;gt;taskQueueTail + &lt;span&gt;1&lt;/span&gt;) % threadpool-&amp;gt;&lt;span&gt;taskQueueSize;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         threadpool-&amp;gt;taskPendCnt++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 唤醒一个线程执行任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        THREADPOOL_COND_SIGNAL(threadpool);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;     } &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    THREADPOOL_UNLOCK(threadpool);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;线程的回调函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;线程第一次启动和被唤醒后检查队列中是否有需要执行的任务，如果没有则继续等待唤醒；&lt;/li&gt;
&lt;li&gt;如果有需要执行的任务，则从队列中取一个任务并执行；&lt;/li&gt;
&lt;li&gt;如果线程池已销毁，则退出线程；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 线程回调函数
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 等待线程池分配任务并执行分配的任务
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @arg  -- 线程池引用
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * *********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* thread_callback(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     tThreadpoolInfo *threadpool = (tThreadpoolInfo *&lt;span&gt;)arg;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    tThreadTaskInfo task;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        THREADPOOL_LOCK(threadpool);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待任务分配的信号 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         * 如果当前没有等待执行的任务，并且线程池没有关闭则继续等待信号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((&lt;span&gt;0&lt;/span&gt; == threadpool-&amp;gt;&lt;span&gt;taskPendCnt)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &amp;amp;&amp;amp; (&lt;span&gt;0&lt;/span&gt; == threadpool-&amp;gt;&lt;span&gt;isShutdown))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            THREADPOOL_COND_WAIT(threadpool);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 如果线程池已关闭，则退出线程  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (threadpool-&amp;gt;&lt;span&gt;isShutdown)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 取任务队列中当前第一个任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         task.func = threadpool-&amp;gt;taskQueue[threadpool-&amp;gt;&lt;span&gt;taskQueueHead].func;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         task.arg1 = threadpool-&amp;gt;taskQueue[threadpool-&amp;gt;&lt;span&gt;taskQueueHead].arg1;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         task.arg2 = threadpool-&amp;gt;taskQueue[threadpool-&amp;gt;&lt;span&gt;taskQueueHead].arg2;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         threadpool-&amp;gt;taskQueueHead = (threadpool-&amp;gt;taskQueueHead + &lt;span&gt;1&lt;/span&gt;) % threadpool-&amp;gt;&lt;span&gt;taskQueueSize;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         threadpool-&amp;gt;taskPendCnt--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         threadpool-&amp;gt;threadPendCnt--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        THREADPOOL_UNLOCK(threadpool);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 执行任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         (*&lt;span&gt;(task.func))(task.arg1, task.arg2);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务执行完成后，线程进入pending状态 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        THREADPOOL_LOCK(threadpool);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         threadpool-&amp;gt;threadPendCnt++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        THREADPOOL_UNLOCK(threadpool);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     threadpool-&amp;gt;threadStartCnt--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    THREADPOOL_UNLOCK(threadpool);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    pthread_exit(NULL);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;线程池销毁&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;销毁为确保资源释放，需要唤醒所有线程，并等待所有线程退出；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 删除线程池
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * @threadpool  -- 线程池引用
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * *********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; int32_t threadpool_destroy(tThreadpoolInfo *&lt;span&gt;threadpool)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     int32_t ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     int32_t i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; threadpool)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid param.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    THREADPOOL_LOCK(threadpool);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (threadpool-&amp;gt;&lt;span&gt;isShutdown)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            THREADPOOL_UNLOCK(threadpool);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         threadpool-&amp;gt;isShutdown = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 唤醒所有线程 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; !=&lt;span&gt; THREADPOOL_COND_BROADCAST(threadpool))
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             THREADPOOL_ERR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cond broadcast failed.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             threadpool-&amp;gt;isShutdown = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        THREADPOOL_UNLOCK(threadpool);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待所有进程退出 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; threadpool-&amp;gt;threadStartCnt; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             pthread_cancel(threadpool-&amp;gt;&lt;span&gt;threads[i]);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             pthread_join(threadpool-&amp;gt;&lt;span&gt;threads[i], NULL);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     }&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; !=&lt;span&gt; ret)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         threadpool-&amp;gt;isShutdown = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    threadpool_free(threadpool);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;线程池测试&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建最大线程数=256，队列大小=64，启动步进=8 的线程池；&lt;/li&gt;
&lt;li&gt;向线程池添加1024个任务，如果添加失败则等待1秒再添加；&lt;/li&gt;
&lt;li&gt;验证1024个任务是否均能执行；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Filename : test_main.c
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * Author :   taopeng
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * ********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadpool.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test_task(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; id = (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)arg;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task[%ld] enter\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, id);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     sleep(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; int32_t main(int32_t argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     tThreadpoolInfo *&lt;span&gt;threadpool;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     threadpool = threadpool_create(&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; threadpool)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (id = &lt;span&gt;1&lt;/span&gt;; id &amp;lt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; != threadpool_addtask(threadpool, (THREADPOOLTASKFUNC)test_task, (&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)id, NULL))
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         id++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     sleep(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    threadpool_destroy(threadpool);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;代码实例链接&lt;/h3&gt;
&lt;p&gt;https://gitee.com/github-18274965/threadpool.git&lt;/p&gt;

</description>
<pubDate>Tue, 17 Nov 2020 15:04:00 +0000</pubDate>
<dc:creator>TpCode</dc:creator>
<og:description>基本功能 1. 实现一个线程的队列，队列中的线程启动后不再释放； 2. 没有任务执行时，线程处于pending状态，等待唤醒，不占cpu； 3. 当有任务需要执行时，从线程队列中取出一个线程执行任务；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tp1226/p/13996788.html</dc:identifier>
</item>
<item>
<title>ESP8266 鼓捣记 - 入门（环境搭建） - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/13997317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/13997317.html</guid>
<description>&lt;h2 id=&quot;一前言&quot;&gt;一.前言&lt;/h2&gt;
&lt;p&gt;以前没怎么接触过硬件开发，ESP8266 这个名字还是从朋友处得知，用它做了许多好玩的东西，便想着自己也来玩一玩。定了一个小目标，做一个温度计。本文介绍从0到 “Hello World”。关于购买，建议选择某宝的开发板套装来进行入门，搭配有入门资料以及一些示例。&lt;/p&gt;
&lt;h2 id=&quot;二安装驱动&quot;&gt;二.安装驱动&lt;/h2&gt;
&lt;p&gt;使用USB连接线将ESP8266开发板与电脑连接后，发现不能识别USB串口。搜索了资料发现是没有安装驱动。&lt;/p&gt;
&lt;p&gt;1.下载驱动 &lt;a href=&quot;http://www.wch.cn/downloads/CH341SER_EXE.html&quot;&gt;http://www.wch.cn/downloads/CH341SER_EXE.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.连接开发板（一定要先连接开发板）&lt;/p&gt;
&lt;p&gt;3.打开下载的驱动，选择安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202011/668104-20201117230141331-1670878426.png&quot; alt=&quot;image-20201117224439363&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要记住这个COM编号。&lt;/p&gt;
&lt;h2 id=&quot;三安装-arduino&quot;&gt;三.安装 Arduino&lt;/h2&gt;
&lt;p&gt;访问 &lt;a href=&quot;https://www.arduino.cc/en/software&quot;&gt;https://www.arduino.cc/en/software&lt;/a&gt; 下载安装包。&lt;/p&gt;
&lt;p&gt;1.选择刚刚在设备管理器看到的串口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202011/668104-20201117230140947-263516301.png&quot; alt=&quot;image-20201117225022974&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.安装ESP8266开发板&lt;/p&gt;
&lt;p&gt;打开【文件】-&amp;gt; 【首选项】，然后点击开发板管理图标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202011/668104-20201117230140213-768708842.png&quot; alt=&quot;image-20201117225231105&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;https://arduino.esp8266.com/stable/package_esp8266com_index.json&lt;/code&gt; 后，点击“好”&lt;/p&gt;
&lt;p&gt;然后点击【工具】-&amp;gt;【开发板】-&amp;gt;【开发板管理器】，搜索 &lt;code&gt;esp8266&lt;/code&gt; 后安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202011/668104-20201117230139833-479309386.png&quot; alt=&quot;image-20201117225412603&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍等一会便会在【工具】菜单下看到板子型号等信息&lt;/p&gt;
&lt;h2 id=&quot;四运行-hello-world&quot;&gt;四.运行 Hello World&lt;/h2&gt;
&lt;p&gt;首先如图所示，选择 ESP8266 Blink示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202011/668104-20201117230139336-1672376010.png&quot; alt=&quot;image-20201117225626679&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择之后，点击上传，等待编译上传&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202011/668104-20201117230138639-755053090.png&quot; alt=&quot;image-20201117225724929&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上传完成后，板子芯片自带的 LED 灯就会闪烁。&lt;/p&gt;
&lt;p&gt;若将 Builtin Led 设置为0，则板子自带的 IO0 LED 会闪烁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202011/668104-20201117230137991-1659642276.png&quot; alt=&quot;image-20201117225833579&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如此便完成了“Hello World” 的运行。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Nov 2020 15:03:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<og:description>一.前言 以前没怎么接触过硬件开发，ESP8266 这个名字还是从朋友处得知，用它做了许多好玩的东西，便想着自己也来玩一玩。定了一个小目标，做一个温度计。本文介绍从0到 “Hello World”。关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stulzq/p/13997317.html</dc:identifier>
</item>
</channel>
</rss>