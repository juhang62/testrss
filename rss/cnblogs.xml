<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>webpack4下import()模块按需加载,打包按需切割模块，减少包体积，加快首页请求速度 - 双眸</title>
<link>http://www.cnblogs.com/both-eyes/p/10873155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/both-eyes/p/10873155.html</guid>
<description>&lt;h3 id=&quot;一背景&quot;&gt;一：背景&lt;/h3&gt;
&lt;h6 id=&quot;因为项目功能越加越多打包后的体积越来越大导致首页展示的时候速度比较慢因为要等压缩的js的包加载完毕&quot;&gt;因为项目功能越加越多，打包后的体积越来越大，导致首页展示的时候速度比较慢，因为要等压缩的js的包加载完毕。&lt;/h6&gt;
&lt;p&gt;首页展示的时候只需要对应的js，并不需要全部的js模块，所以这里就可以用按需加载，这里webpack4官方文档提供了模块按需切割加载，配合es6的按需加载import()方法，可以做到减少首页包体积，加快首页的请求速度，只有其他模块，只有当需要的时候才会加载对应js。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里参考一些资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;webpack4官方文档：&lt;a href=&quot;https://webpack.docschina.org/api/module-methods/#import-&quot; class=&quot;uri&quot;&gt;https://webpack.docschina.org/api/module-methods/#import-&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515232910514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;VUE的懒加载：&lt;a href=&quot;https://alexjover.com/blog/lazy-load-in-vue-using-webpack-s-code-splitting/&quot; class=&quot;uri&quot;&gt;https://alexjover.com/blog/lazy-load-in-vue-using-webpack-s-code-splitting/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019051523562715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二开始demo&quot;&gt;二：开始demo&lt;/h3&gt;
&lt;p&gt;首页先启动一个普通的webpack4项目，可以用脚手架，不过需要自己配置一些webpack4特性，这里可以参考：&lt;a href=&quot;https://blog.csdn.net/u010633266/article/details/90025292&quot;&gt;webpack3 项目升级 webpack4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目起来后，就可以用import实验一番：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515233354420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里我定义了三个界面（HelloWorld1，HelloWorld2，HelloWorld3），其中HelloWorld1用的impot()按需的方式，其他两个都是直接import。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：这里的&lt;code&gt;/* webpackChunkName: &quot;h-w1&quot; */&lt;/code&gt;&lt;br/&gt;是webpack4中提供的注解，给切割模块命名，如果不要这个注解的话切割出来的模块js不能分辨是那个业务模块的，所以一般都是一个业务模块共用一个名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码这样加了之后，控制台可能会一些错：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516000035814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这个错的意思就是不能识别import()的这种写法，因为还需要Babel的支持，网上查了下，需要&lt;code&gt;babel-plugin-dynamic-import-node&lt;/code&gt;插件和配置&lt;code&gt;.babelrc&lt;/code&gt;文件，那我们就配上：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516002556621.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516002859244.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;配上这些过后，代码确实没有语法错误了，可以正常启动访问。&lt;/p&gt;
&lt;p&gt;但是打包并没有切割开代码：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516002958666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这是打的包，并没有看到我们定义的&lt;code&gt;h-w1&lt;/code&gt;的包。&lt;/p&gt;
&lt;p&gt;这里前前后试了几个插件和配置都不行，语法还是抱错，最后终于试出来了：&lt;br/&gt;1，要么在升级eslint的版本，用5.14以后的；&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516004232577.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，要么eslint可以用4.19的，但要加上&lt;code&gt;acorn&lt;/code&gt;插件；&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516004552952.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里上面两种方法都可以解决问题，至于前面说的配置&lt;code&gt;.babelrc&lt;/code&gt;文件可以还原了，那个加上反而打包没效果了，小白我也不懂。。。。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019051600495477.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;最好我们就可以运行：&lt;code&gt;npm run build&lt;/code&gt; 看效果了，结果又抱错了：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516005152198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;从出错信息来看，是UglifyJS不支持ES6的语法。理论上不应该啊…&lt;br/&gt;于是Google之，发现&lt;code&gt;uglifyjs-webpack-plugin&lt;/code&gt; 2.0版本的&lt;a href=&quot;https://github.com/webpack-contrib/uglifyjs-webpack-plugin/releases/tag/v2.0.0&quot;&gt;Release日志&lt;/a&gt;中，明确提示重新切换回到&lt;code&gt;uglify-js&lt;/code&gt;，因为uglify-es被废弃了，如果需要ES6代码压缩，请使用&lt;a href=&quot;https://github.com/webpack-contrib/terser-webpack-plugin&quot;&gt;&lt;code&gt;terser-webpack-plugin&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决&quot;&gt;解决&lt;/h4&gt;
&lt;p&gt;方法一：安装并使用[&lt;code&gt;terser-webpack-plugin&lt;/code&gt;]：&lt;br/&gt;(参考：&lt;a href=&quot;http://makeup1122.github.io/2018/10/12/webpack-UglifyJS-issue/&quot; class=&quot;uri&quot;&gt;http://makeup1122.github.io/2018/10/12/webpack-UglifyJS-issue/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;方法二：降低UglifyJS版本&lt;/p&gt;
&lt;p&gt;这里我选第二个，最方便，把&lt;code&gt;uglifyjs-webpack-plugin&lt;/code&gt; 降到1.1.1版本：&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516005857749.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;再打包，终于成了，把HelloWorld1分离出来独立包&lt;code&gt;h-w1&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516005928373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;大家可以搜索下，h-w1包里面的代码和app包里面的代码是不是隔离的，也可以浏览器访问这包，看看h-w1包的js是不是按需加载的，这里就不贴结果了，我自己测试都是准确的。&lt;/p&gt;
&lt;p&gt;项目完整demo：&lt;a href=&quot;https://github.com/BothEyes1993/webpack4_demo&quot; class=&quot;uri&quot;&gt;https://github.com/BothEyes1993/webpack4_demo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 17:06:00 +0000</pubDate>
<dc:creator>双眸</dc:creator>
<og:description>一：背景 因为项目功能越加越多，打包后的体积越来越大，导致首页展示的时候速度比较慢，因为要等压缩的js的包加载完毕。 首页展示的时候只需要对应的js，并不需要全部的js模块，所以这里就可以用按需加载，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/both-eyes/p/10873155.html</dc:identifier>
</item>
<item>
<title>学习RadonDB源码（一） - wingsless</title>
<link>http://www.cnblogs.com/wingsless/p/10872892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wingsless/p/10872892.html</guid>
<description>&lt;h2 id=&quot;可能是开始也可能是结束&quot;&gt;1. 可能是开始也可能是结束&lt;/h2&gt;
&lt;p&gt;RadonDB是国内知名云服务提供商青云开源的一款产品，下面是一段来自官方的介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;QingCloud RadonDB 是基于 MySQL 研发的新一代分布式关系型数据库，可无限水平扩展，支持分布式事务，具备金融级数据强一致性，满足企业级核心数据库对大容量、高并发、高可靠及高可用的极致要求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做DBA的都知道关系型数据库在分布式数据库方面堪称举步维艰，虽然很多高手或者公司都开源了自己的中间件，但是很少有公司像青云这样将自己商用的成套解决方案直接开源的。可能开源版本和商用版本之间有很多功能差异，不过从解决方案的完整性角度来看，RadonDB堪称是良心产品了。&lt;/p&gt;
&lt;p&gt;而且RadonDB的还有一个明显的好处是用Go编写的，而且现在的代码量也不算大，对于一个学习Go语言的人来说这是一个极好的项目。另外还有一点，RadonDB模拟了完整的MySQL Server端，里面有一项核心的东西叫做SQL解析器和优化器的，刚好可以借此机会从源码角度学习一下其思想。要知道MySQL虽然开源，但是整个项目都是用C编写的，很难看懂。&lt;/p&gt;
&lt;p&gt;我打算用闲暇时间好好学习一下RadonDB源码，当然我可能半途而废，所以，这一篇可能是开始也可能是结束。&lt;/p&gt;
&lt;h2 id=&quot;入口的radon.go文件&quot;&gt;2. 入口的radon.go文件&lt;/h2&gt;
&lt;p&gt;这个文件在“radon/src/radon”目录下，代码只有区区82行，不过这是整个RadonDB的入口。&lt;/p&gt;
&lt;p&gt;这段代码中利用了不少flag包用于接收参数，首先映入眼帘的是一堆import，此处就不加赘述了，因为毕竟只是引入了包，至于做什么的，代码写了就能知道。&lt;/p&gt;
&lt;p&gt;接下来是包的初始化：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var (
    flagConf string
)

func init() {
    flag.StringVar(&amp;amp;flagConf, &quot;c&quot;, &quot;&quot;, &quot;radon config file&quot;)
    flag.StringVar(&amp;amp;flagConf, &quot;config&quot;, &quot;&quot;, &quot;radon config file&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;flag是一个很好用的包，用于接收命令行参数，至于怎么用可以参考网上的资料。这个init()函数很有意思，这个函数会在很多书的“包初始化”一节来讲述，其实记住几个顺序就可以：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化导入的包；&lt;/li&gt;
&lt;li&gt;在包级别为声明的变量计算并分配初始值；&lt;/li&gt;
&lt;li&gt;执行包内的init函数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是包的初始化顺序，那么回到radon.go，初始化顺序也是一目了然的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;init函数不能被引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来是一个简单的usage函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func usage() {
    fmt.Println(&quot;Usage: &quot; + os.Args[0] + &quot; [-c|--config] &amp;lt;radon-config-file&amp;gt;&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅仅是为了打印命令行的帮助，在引用的时候才有效，现在只是声明。&lt;/p&gt;
&lt;p&gt;而后就是程序的主入口main函数了，这段函数的最开始就执行了这样一句：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;runtime.GOMAXPROCS(runtime.NumCPU())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明了逻辑处理单元，数量和CPU核数相当，这一点在之前讲goroutine的笔记中讲述过。&lt;/p&gt;
&lt;p&gt;紧接着，程序将获得一些关键的环境信息：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;build := build.GetInfo()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然只有一句，但是背后的东西还是很丰富的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func GetInfo() Info {
    return Info{
        GoVersion: runtime.Version(),
        Tag:       &quot;8.0.0-&quot; + tag,
        Time:      time,
        Git:       git,
        Platform:  platform,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一种典型的结构体的初始化方式，如果对结构体不熟悉，建议也是百度一下相关资料。&lt;/p&gt;
&lt;p&gt;这些打印出信息的东西无非就是一些显示输出，跟我们平时启动Spring的时候打印那个炫酷的SPRING banner没什么区别，接来下才是处理一些要紧的东西，比如处理配置：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // config
    flag.Usage = func() { usage() }
    flag.Parse()
    if flagConf == &quot;&quot; {
        usage()
        os.Exit(0)
    }

    conf, err := config.LoadConfig(flagConf)
    if err != nil {
        log.Panic(&quot;radon.load.config.error[%v]&quot;, err)
    }
    log.SetLevel(conf.Log.Level)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的&lt;code&gt;flag.Usage&lt;/code&gt;是函数变量，函数变量是一个新颖的概念，举一个例子说明：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func square(n int) int { return n*n }

f := square
//打印9
fmt.Println(f(3))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;flag包中的Usage本身就是个函数变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面这段业务代码主要做了这么几件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解析flag，得到命令行参数；&lt;/li&gt;
&lt;li&gt;判断参数是否为空，为空则打印使用说明并退出；&lt;/li&gt;
&lt;li&gt;加载配置项，并做异常处理；&lt;/li&gt;
&lt;li&gt;设置日志级别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们先不说紧接着要启动的Monitor了，这是一个性能指标监控，并不在我的学习范围内。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // Proxy.
    proxy := proxy.NewProxy(log, flagConf, build.Tag, conf)
    proxy.Start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理是每个人写程序都挺喜欢写的名字。proxy是一个自行编写的包，我们来看看NewProxy的时候做了什么：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func NewProxy(log *xlog.Log, path string, serverVersion string, conf *config.Config) *Proxy {
    audit := audit.NewAudit(log, conf.Audit)
    router := router.NewRouter(log, conf.Proxy.MetaDir, conf.Router)
    scatter := backend.NewScatter(log, conf.Proxy.MetaDir)
    syncer := syncer.NewSyncer(log, conf.Proxy.MetaDir, conf.Proxy.PeerAddress, router, scatter)
    plugins := plugins.NewPlugin(log, conf, router, scatter)
    return &amp;amp;Proxy{
        log:           log,
        conf:          conf,
        confPath:      path,
        audit:         audit,
        router:        router,
        scatter:       scatter,
        syncer:        syncer,
        plugins:       plugins,
        sessions:      NewSessions(log),
        iptable:       NewIPTable(log, conf.Proxy),
        throttle:      xbase.NewThrottle(0),
        serverVersion: serverVersion,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码倒是很简单，就是利用入参中的配置项，声明了一系列的变量，并将这些变量封装在一个结构体内，然后返回。至于这些变量都是干什么的，我下次再说，这次只跟踪主流程。&lt;/p&gt;
&lt;p&gt;紧接着看看启动都做了什么：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Start used to start the proxy.
func (p *Proxy) Start() {
    log := p.log
    conf := p.conf
    audit := p.audit
    iptable := p.iptable
    syncer := p.syncer
    router := p.router
    scatter := p.scatter
    plugins := p.plugins
    sessions := p.sessions
    endpoint := conf.Proxy.Endpoint
    throttle := p.throttle
    serverVersion := p.serverVersion

    log.Info(&quot;proxy.config[%+v]...&quot;, conf.Proxy)
    log.Info(&quot;log.config[%+v]...&quot;, conf.Log)

    if err := audit.Init(); err != nil {
        log.Panic(&quot;proxy.audit.init.panic:%+v&quot;, err)
    }
    // 省略了一大堆，为了节省篇幅

    spanner := NewSpanner(log, conf, iptable, router, scatter, sessions, audit, throttle, plugins, serverVersion)
    if err := spanner.Init(); err != nil {
        log.Panic(&quot;proxy.spanner.init.panic:%+v&quot;, err)
    }
    svr, err := driver.NewListener(log, endpoint, spanner)
    if err != nil {
        log.Panic(&quot;proxy.start.error[%+v]&quot;, err)
    }
    p.spanner = spanner
    p.listener = svr
    log.Info(&quot;proxy.start[%v]...&quot;, endpoint)
    go svr.Accept()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个Start函数看起来好像Java中的构造器，做的事情也和构造器有点相似，就是赋值，不过它还能做多的事情，比如说启动了一个监听：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;svr, err := driver.NewListener(log, endpoint, spanner)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了监听之后，就可以启动一个goroutine了，而且是有条件的存活的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;go svr.Accept()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的条件就是Accept要做什么：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Accept runs an accept loop until the listener is closed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在listener关闭之前，Accept将始终运行一个循环，也就是说这个goroutine会一直生存下去。&lt;/p&gt;
&lt;p&gt;到这一步proxy就算启动起来了，然后就会去启动Admin了：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // Admin portal.
    admin := ctl.NewAdmin(log, proxy)
    admin.Start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照惯例看看NewAdmin在干什么：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// NewAdmin creates the new admin.
func NewAdmin(log *xlog.Log, proxy *proxy.Proxy) *Admin {
    return &amp;amp;Admin{
        log:   log,
        proxy: proxy,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码逻辑很简单，就是返回一个Admin结构体的指针。而Admin结构体是这样的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Admin tuple.
type Admin struct {
    log    *xlog.Log
    proxy  *proxy.Proxy
    server *http.Server
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看，之前的代码里没有对server进行赋值，这是为什么？答案在Start函数里：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Start starts http server.
func (admin *Admin) Start() {
    api := rest.NewApi()
    router, err := admin.NewRouter()
    if err != nil {
        panic(err)
    }

    api.SetApp(router)
    handlers := api.MakeHandler()
    admin.server = &amp;amp;http.Server{Addr: admin.proxy.PeerAddress(), Handler: handlers}

    go func() {
        log := admin.log
        log.Info(&quot;http.server.start[%v]...&quot;, admin.proxy.PeerAddress())
        if err := admin.server.ListenAndServe(); err != http.ErrServerClosed {
            log.Panic(&quot;%v&quot;, err)
        }
    }()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是一系列的Http操作，对server的赋值就在其中，此时会把默认IP，端口等等信息都写入到server中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-bd14d6d56526a5f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;默认值&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一看代码我就知道RadonDB要用3308端口进行连接，而起管理端口就注册在8080。&lt;/p&gt;
&lt;p&gt;好了，这些都很容易明白，此时Start函数只需要启动一个goroutine就可以了。关键在这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-b7f5b40c51d859e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;启动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看名字就知道这是干什么的，监听并维护一个服务，看看其注释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-be10dcb35a13d6eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;注释&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么这样一来，服务就启动起来了，当然后面还会有stop函数，就不再详解了。有意思的是，可以注意这几句：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // Handle SIGINT and SIGTERM.
    ch := make(chan os.Signal)
    signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
    log.Info(&quot;radon.signal:%+v&quot;, &amp;lt;-ch)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几句声明了一个通道，一个Signal类型的通道，可以用于接收系统调用，SIGINT一般是ctrl-c，SIGTERM一般是kill。在发生这两个系统调用后，系统开始关闭。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;3. 小结&lt;/h2&gt;
&lt;p&gt;Go语言还是简单的，至少现在看来，这些代码我是都能看懂的，而我学习Go语言的时间也不过两周。&lt;/p&gt;
&lt;p&gt;我希望能借着RadonDB的开源，学会关键的优化器和SQL解析器的思想。&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 15:28:00 +0000</pubDate>
<dc:creator>wingsless</dc:creator>
<og:description>1. 可能是开始也可能是结束 RadonDB是国内知名云服务提供商青云开源的一款产品，下面是一段来自官方的介绍： QingCloud RadonDB 是基于 MySQL 研发的新一代分布式关系型数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wingsless/p/10872892.html</dc:identifier>
</item>
<item>
<title>从阿里中台战略看企业IT架构转型之道 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/alibaba_it_architect_tranformation_study_notes.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/alibaba_it_architect_tranformation_study_notes.html</guid>
<description>&lt;p&gt;&lt;em&gt;此文是我阅读《企业IT架构转型之道》一书的学习笔记，所有内容出自钟华老师的这本书。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　在加入X公司后，开始了微服务架构的实践，也开始了共享平台服务的建设，在这方面阿里巴巴的中台战略是一个较好的参考。于是，领导就赠了这么一本《&lt;a href=&quot;http://item.jd.com/12176278.html&quot; target=&quot;_blank&quot;&gt;企业IT架构转型之道&lt;/a&gt;》给我，希望我学以致用，更多的是有这样的一个眼界去指导我们的中台架构设计。因此，我花了两周时间快速地阅读了一下此书，总结了此文作为学习笔记以供日后复习用。此书的确讲了一些干货，虽然很多内容留于表面，但是对于中台的定义和思考，建设中台的方法以及阿里中间件有比较完整的描述，和多年前出版的《&lt;a href=&quot;https://item.jd.com/11236743.html&quot; target=&quot;_blank&quot;&gt;淘宝技术这十年&lt;/a&gt;》以及《&lt;a href=&quot;https://item.jd.com/11322972.html&quot; target=&quot;_blank&quot;&gt;大型网站技术架构-核心原理与案例分析&lt;/a&gt;》一样，是一本值得学习的好书。&lt;/p&gt;

&lt;h2&gt;Part 1 阿里中台战略引发的思考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;起源自2008年阿里巴巴三大电商体系的技术支持架构
&lt;ul&gt;&lt;li&gt;1688、淘宝、天猫三套电商体系架构完全独立&lt;/li&gt;
&lt;li&gt;三座烟囱分别矗立支撑阿里巴巴最核心的电商业务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;烟囱式系统建设系统对企业的“三大”弊端
&lt;ul&gt;&lt;li&gt;重复功能建设和维护带来的重复投资&lt;/li&gt;
&lt;li&gt;打通“烟囱式”系统间交互的集成和协作成本高昂&lt;/li&gt;
&lt;li&gt;不利于业务的沉淀和持续发展 =&amp;gt; &lt;span&gt;&lt;strong&gt;对企业伤害最大&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;企业信息中心的组织职能是业务支持？&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;问题核心在于IT信息部门在现有模式下大多被高管定位为业务支持的部门 =&amp;gt; 一个花钱的成本中心&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;问题原因在于IT信息部门的人员不懂业务 =&amp;gt; 这里的懂业务是指“&lt;span&gt;&lt;strong&gt;能对业务的下一步发展有着自己的理解和看法&lt;/strong&gt;&lt;/span&gt;，对业务流程如何进一步优化能更好的地提升业务，甚至对企业现有的业务提出创新的想法，为企业带来新的业务增长点。”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;问题结果导致了IT信息部门的人员很少能在一个业务领域做足够的业务沉淀 =&amp;gt; 对业务知其然而不知其所以然&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190424085452971-664559800.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“烟囱式”的系统建设模式&lt;/p&gt;
&lt;h2&gt;Part 2 构建业务中台的基础—共享服务体系&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;SOA架构的核心价值
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;服务重用&lt;/strong&gt; &lt;span&gt;=&amp;gt; 从服务重用到共享服务&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;共享服务体系的建设：克服“烟囱式”架构的三大弊端
&lt;ul&gt;&lt;li&gt;避免重复功能建设和维护带来的成本浪费 =&amp;gt; 没有实现系统业务互通的诉求&lt;/li&gt;
&lt;li&gt;最大程度避免打通不同系统间实现业务交互带来的集成和协作成本 =&amp;gt; 各个应用在核心业务层已经实现了统一和畅通&lt;/li&gt;
&lt;li&gt;能够很好地培养出特定领域的专家 =&amp;gt; “&lt;span&gt;&lt;strong&gt;既精通业务，又熟悉技术&lt;/strong&gt;&lt;/span&gt;”的复合型人才&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;企业信息中心组织阵型的调整
&lt;ul&gt;&lt;li&gt;针对共享服务体系重新组织人员，使成员有机会成为业务领域的专家（复合型人才）&lt;/li&gt;
&lt;li&gt;最核心的角色是架构师，他们会是各服务中心的业务负责人&lt;/li&gt;
&lt;li&gt;信息团队会从“业务支持”的组织职能转向&lt;span&gt;&lt;strong&gt;基于企业核心业务和数据进行运营的团队&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190424091920197-938150062.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;阿里巴巴的“大中台”体系建设&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;在阅读这一部分时，个人最大的感触就在于企业信息中心的境遇，我所在的公司是一个传统行业，我们部门是从2018年末开始扩建的信息中心，和广大企业信息中心一样，虽然无一不被认可信息部门对企业发展的重要地位，行政级别也和核心业务部门的级别相当，但是实际情况却是没有同样平等的话语权，因为在高层领导的眼里就只是单纯把信息中心定位为了业务支持部门，是一个花钱的成本中心。而造成这样处境的原因，也很赞同钟华老师在书中的观点，那就是信息部门的员工不懂业务，这里的不懂业务是指&lt;strong&gt;能对业务的下一步发展有着自己的理解和看法&lt;/strong&gt;，对业务流程如何进一步优化能更好的地提升业务，甚至对企业现有的业务提出创新的想法，为企业带来新的业务增长点。而要提高信息部门的员工对于业务的精进，需要建设类似阿里巴巴的共享服务中心，服务需要不断的业务滋养才能足够强大地支持前线的士兵，也只有在滋养中才能从最初提供单薄业务功能的服务组件成长为企业最为宝贵的IT资产。正如钟华老师所示，未来在整个社会进入开放共享的时代，企业最大的价值将会是基于核心业务和数据进行对外开放的运营，到那时信息部门的共享服务体系将成为企业最为宝贵的资产。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Part 3 分布式服务框架的选择&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;“中心化”与“去中心化”服务框架的对比
&lt;ul&gt;&lt;li&gt;服务调用方式的不同带来业务的响应和扩展成本：基于ESB的响应速度慢（因为网络开销大一倍），而要扩展ESB需要承担软硬件的不小投入（比如巨大的授权费）&lt;/li&gt;
&lt;li&gt;“&lt;strong&gt;雪崩&lt;/strong&gt;”效应束缚了“中心化”服务框架的扩展能力：不适合互联网企业的根本原因，因为一旦雪崩故障恢复的时间和成本都非常高昂！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;阿里巴巴的分布式服务框架HSF
&lt;ul&gt;&lt;li&gt;组成部分：服务提供者、服务调用者、地址服务器（Nginx）、配置服务器（服务注册&amp;amp;发现）、Diamond服务器（类似于Zookeeper）&lt;/li&gt;
&lt;li&gt;工作原理：服务节点对配置服务器列表的获取、服务的注册发布、服务的订阅、服务规则的推送（如果需要）、服务交互&lt;/li&gt;
&lt;li&gt;核心能力：Netty+Hession数据序列化协议实现服务交互（大并发量下的高性能）、容错机制（长连接+秒级感知）、线性扩展（增加服务实例即可扩展服务能力）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于微服务
&lt;ul&gt;&lt;li&gt;阿里巴巴2009年开始的共享服务体系算得上是微服务实践的先驱&lt;/li&gt;
&lt;li&gt;从本质上说，&lt;strong&gt;微服务是SOA的一种演变后的形态，与SOA的方法和原则没有&lt;span&gt;本质&lt;/span&gt;上的差别&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;微服务与SOA的两点最鲜明差异在于：
&lt;ul&gt;&lt;li&gt;传统SOA架构基于“中心化”的ESB构建，而微服务采用的是系统提供服务的方式实现系统间的互通；&lt;/li&gt;
&lt;li&gt;传统SOA实施的方式是项目制，而微服务是以做产品的方式让服务在业务发展过程中快速演化；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;概念一时爽，问题一堆堆：
&lt;ul&gt;&lt;li&gt;微服务化的应用架构的有效服务管控？&lt;/li&gt;
&lt;li&gt;分布式事务的难题？&lt;/li&gt;
&lt;li&gt;自动化运维和平台稳定性？&lt;/li&gt;
&lt;li&gt;微服务的服务设计？=&amp;gt; DDD&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;微服务不是“免费的午餐”，阿里巴巴2009年开始的共享服务体系建设历程算得上是微服务架构的建设过程。正如钟华老师所说，“罗马不是一天建成的”，企业如果要构建微服务架构体系，也是需要多一份耐心的，通过服务能力在业务发展过程中的不断沉淀，当业务的能力沉淀到一个阶段后，才能真正感受到微服务架构给企业的业务发展带来的长远价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Part 4 共享服务中心建设原则&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;服务中心的三个特征
&lt;ul&gt;&lt;li&gt;服务中心是伴随业务不断发展的：不做过于超前的设计，也不做过于理想化的架构&lt;/li&gt;
&lt;li&gt;服务中心的服务形态多样化：接口、工具、数据...&lt;/li&gt;
&lt;li&gt;一个服务中心还可以进一步划分：单个服务模块、多个服务模块...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务中心的划分原则
&lt;ul&gt;&lt;li&gt;更多靠的是架构设计经验总结，很难给出精确的量化指标&lt;/li&gt;
&lt;li&gt;一般来说会兼顾3个方面的需求：
&lt;ul&gt;&lt;li&gt;设计 =&amp;gt; 遵循面向对象的分析和设计方法论&lt;/li&gt;
&lt;li&gt;运营 =&amp;gt; 服务中心应该是一个完整额业务模型&lt;/li&gt;
&lt;li&gt;工程 =&amp;gt; 综合评估业务层对服务中心在DB、业务以及运营方面的需求和技术上需要的投入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实际中的一些基本原则：
&lt;ul&gt;&lt;li&gt;高内聚、低耦合原则&lt;/li&gt;
&lt;li&gt;数据完整性原则：特别强调大数据思维&lt;/li&gt;
&lt;li&gt;业务可运营性原则：服务中心是承载业务逻辑、沉淀业务数据、产生业务价值的业务单元&lt;/li&gt;
&lt;li&gt;渐进性的建设原则：小步快跑，服务化从简单开始！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt; &lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;记得张逸老师在《领域驱动战略设计实践》课程中的开篇提到他向DDD大师Eric Evans提问“如何正确地识别限界上下文？”，结果Eric Evans思考了一会儿，严肃地回答了一句：“By experience！”。这是一个正确的废话，但好像又蛮有道理。对于共享服务中心的建设和划分来说，也同样如此，更多的是依靠架构设计经验的总结，作者也很难给出一些具体问题给出一个精确的量化指标。正如作者所说，架构本来就是一个追求平衡的艺术，不仅是设计原则上的平衡，还要在技术、成本、资源、性能、团队等各方面进行平衡，以最高效地解决主要问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Part 5 数据拆分实现数据库能力线性扩展&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据库分库分表的实践
&lt;ul&gt;&lt;li&gt;阿里巴巴分布式数据层平台发展演变：Cobar(2006) =&amp;gt; TDDL(2008) =&amp;gt; DRDS(2014)&lt;/li&gt;
&lt;li&gt;数据尽可能平均拆分：需要结合业务数据的结构和业务场景来决定&lt;/li&gt;
&lt;li&gt;尽量减少事务边界：“事务边界”指单个SQL语句在后端数据库上同时执行的数量&lt;/li&gt;
&lt;li&gt;异构索引表尽量降低全表扫描频率：“拿空间换时间”，阿里巴巴的精卫填海产品&lt;/li&gt;
&lt;li&gt;将多条件频繁查询引入搜索引擎平台：采用专业搜索引擎平台提供搜索服务，Lucene、Solr、ElasticSearch&lt;/li&gt;
&lt;li&gt;简单就是美：“数据尽可能平均拆分”作为第一优先考虑，82法则&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;阿里巴巴的分布式数据层平台发展的演变可谓是一部技术驱动变革的历程，经历了一个又一个的技术难题，出现了一个又一个的开源/商用产品，提高了阿里巴巴的效率。印象深刻的地方在于，我们都有一个印象就是在数据库开发和调用时，要充分利用索引，避免全表扫描。但是，作者说到在真实的业务场景中很难完全避免全表扫描，比如对于订单进行复杂的分布式条件检索的时候，就会需要采用全表扫描，将查询语句同时推送到后端的数据库中才能实现该场景。但是，因为调用量不会很频繁，而且计算的数据量并不大，所以整体上不会给DB产生太大的影响。另外一个点就是，从系统风险的角度来看，以82法则，在实际中，作者建议仅对那些在80%情况下访问的那20%的场景进行如数据异构索引这样的处理，达到这类场景的性能最优化，而对于其他80%偶尔出现跨库join、全表扫描的场景，采取最为简单直接的方式往往就是最有效的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Part 6 异步与缓存原则&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;异步化
&lt;ul&gt;&lt;li&gt;业务流程异步化：服务异步调用，提升大量远程服务线性调用带来的性能问题&lt;/li&gt;
&lt;li&gt;数据库事务异步化：将大事务拆分成小事务，提升吞吐量和事务操作的响应时间
&lt;ul&gt;&lt;li&gt;事务 =&amp;gt; 核心是ACID&lt;/li&gt;
&lt;li&gt;柔性事务 =&amp;gt; 基础是CAP理论和BASE理论，因为互联网应用最核心的需求是高可用（BASE中的BA）
&lt;ul&gt;&lt;li&gt;解决分布式问题的机制：①日志和补偿机制、②可靠的消息传递、③无锁实现（避免事务回滚、辅助业务变化明细表、乐观锁等）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ACID与BASE一般在系统中会结合使用，追求最终一致性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缓存
&lt;ul&gt;&lt;li&gt;小库存商品秒杀典型架构
&lt;ul&gt;&lt;li&gt;核心问题：处理好商品的库存的扣减，不出现超卖的情况&lt;/li&gt;
&lt;li&gt;核心方案：
&lt;ul&gt;&lt;li&gt;缓存商品的详细信息（包括库存），不直接访问后端数据库&lt;/li&gt;
&lt;li&gt;商品库存使用乐观锁，避免出现超卖&lt;/li&gt;
&lt;li&gt;商品库存控制业务流，只在下单环节才对数据库访问，降低数据库访问频率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大库存商品大促架构
&lt;ul&gt;&lt;li&gt;核心问题：处理好库存更新的准确与用户等待时间的平衡&lt;/li&gt;
&lt;li&gt;核心方案：
&lt;ul&gt;&lt;li&gt;将缓存提升到为库存操作提供事务支持的角色 =&amp;gt; 将订单交易创建环节在缓存服务器中运行，提高响应速度&lt;/li&gt;
&lt;li&gt;借助消息队列实现缓存服务器中的库存修改线性处理&lt;/li&gt;
&lt;li&gt;缓存服务故障时通过缓存数据和数据库订单信息还原订单处理的最新状态&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;异步化与缓存两个技术都和我们的系统性能有很大的关联，在分布式应用架构中，如果没有这两项技术的引入，相信设计出来的应用很难有优质的性能表现。淘宝平台是一个典型的分布式服务架构，通过业务流程异步化提升了性能，分库分表后又在异步操作场景下实现了事务一致性与数据库处理性能的平衡。最后，通过适当使用缓存技术实现了商品秒杀场景下的技术架构，这都是我们需要学习和借鉴的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201905/381412-20190514232428556-22457319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小库存商品秒杀场景订单处理流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201905/381412-20190514232543058-1625306272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大库存商品秒杀场景订单处理流程图&lt;/p&gt;
&lt;h2&gt;Part 7 打造数字化运营能力&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;业务服务化带来的问题&lt;br/&gt;&lt;ul&gt;&lt;li&gt;服务调用关系纷繁复杂，难以定位问题&lt;/li&gt;
&lt;li&gt;不同角色的技术人员需要一些列的管控&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分布式服务调用链路平台
&lt;ul&gt;&lt;li&gt;阿里巴巴内部实现：“鹰眼”平台，JStorm流式计算引擎&lt;/li&gt;
&lt;li&gt;核心思路：埋点和输出日志&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;海量日志分布式处理平台
&lt;ul&gt;&lt;li&gt;阿里巴巴内部实现：TLog平台，日志处理流程“所见即所得”&lt;/li&gt;
&lt;li&gt;日志收集控制：遇到大量请求时只记录其中一部分数据，而非全量收集&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;实现初步的分布式服务体系之后，我们的平台必然会变成一个比较复杂的交互链路网，这会对我们的管控带来一些问题，比如服务调用链监控、服务运行状态是否正常，如何提供关键指标以实现精准营销等等。好在无论是商用产品还是开源产品，都有了比较成熟的技术方案，我司已经在调研学习Skywalking和ElasticSearch，以后有机会做这方面的分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;strong&gt;在此推荐一波Skywalking：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/asp-net-core-skywalking.html&quot;&gt;在 ASP.NET Core 中集成 Skywalking APM&lt;/a&gt; （from savorboard 杨晓东）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/liuhaoyang/p/skywalking-dotnet-v02-release.html&quot; target=&quot;_blank&quot;&gt;Apache SkyWalking 为.NET Core带来开箱即用的分布式追踪和应用性能监控&lt;/a&gt; （from Lemon 刘浩杨）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/huangxincheng/p/9666930.html&quot;&gt;使用docker-compose 一键部署你的分布式调用链跟踪框架Skywalking&lt;/a&gt; （from 一线码农 黄星辰）&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;更多Skywalking分享&lt;/em&gt;：&lt;a href=&quot;https://github.com/OpenSkywalking/Community&quot; target=&quot;_blank&quot;&gt;https://github.com/OpenSkywalking/Community&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575322/201805/575322-20180523224851712-869373885.png&quot; alt=&quot;Skywalking Demo&quot; width=&quot;2876&quot; height=&quot;1518&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Skywalking中的请求调用链拓扑视图&lt;/p&gt;
&lt;h2&gt;Part 8 打造平台稳定性能力&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;提高稳定性的实践&lt;br/&gt;&lt;ul&gt;&lt;li&gt;限流和降级：限流相当于电路保险丝，而降级则是为保证核心服务而牺牲自己，阿里巴巴自研Sentinel限流平台&lt;/li&gt;
&lt;li&gt;流量调度：通过实时指标监控，对预计发生故障的服务进行下线等操作，以避免单点或局部故障&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;业务开关：通过集中化管理业务API操作开关，阿里巴巴自研Switch平台&lt;/li&gt;
&lt;li&gt;容量压测及评估规划：将线上真实流量引到压测服务器，并差异化分析对线上服务器的增减提供实时参考决策&lt;/li&gt;
&lt;li&gt;全链路压测：每个环节都参加的实战演习，例如双11实战演习&lt;/li&gt;
&lt;li&gt;业务一致性平台：保证业务与数据一致的业务稳定性，实时检测业务不一致的问题，阿里巴巴自研BCR业务审计平台&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　＃Sential Github: &lt;a href=&quot;https://github.com/alibaba/Sentinel&quot; target=&quot;_blank&quot;&gt;https://github.com/alibaba/Sentinel&lt;/a&gt; （轻量级的流量控制、熔断降级 Java 库）&lt;/p&gt;
&lt;p&gt;　　＃Sential Wiki：&lt;a href=&quot;https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D&quot; target=&quot;_blank&quot;&gt;分布式系统的流量防卫兵&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201905/381412-20190515090730327-638148100.png&quot; alt=&quot;Sential Main Features&quot; width=&quot;1470&quot; height=&quot;686&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Sentinel 的主要特性&lt;/p&gt;
&lt;h2&gt;Part 9 共享服务中心对内和对外的协作共享&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;共享服务平台的建设思路
&lt;ul&gt;&lt;li&gt;Step1.找到一个合适的服务化对象：比如API&lt;/li&gt;
&lt;li&gt;Step2.建设对象服务化的基础设施：比如结构化包装，让API成为治理良好的组件服务&lt;/li&gt;
&lt;li&gt;Step3.服务化实施阶段：循序渐进的过程，三个阶段参考
&lt;ul&gt;&lt;li&gt;API as Service =&amp;gt; 服务化的第一步&lt;/li&gt;
&lt;li&gt;Product as Service =&amp;gt; 大量业务API升级为服务化平台的组件服务&lt;/li&gt;
&lt;li&gt;Solution as Service =&amp;gt; 经过长时间的沉淀可以形成解决方案，如海外淘宝解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Step4.增强服务和基础设施实现服务的精细治理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对内：共享服务平台的协作
&lt;ul&gt;&lt;li&gt;与业务方的协作：以服务为对象建立一个在线市场，三大角色
&lt;ul&gt;&lt;li&gt;共享服务平台 =&amp;gt; SPAS&lt;/li&gt;
&lt;li&gt;服务提供者 =&amp;gt; 商品、交易、店铺、物流等&lt;/li&gt;
&lt;li&gt;服务消费者 =&amp;gt; 商品、交易、店铺、物流等 （消费者通常也是提供者）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;与前端应用协作：服务提供者与消费者，相辅相成，共同发展
&lt;ul&gt;&lt;li&gt;阿里巴巴的一些实践：紧密沟通，分歧升级、岗位轮转（换位思考）、业务沉淀及共建&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对内：业务中台绩效考核
&lt;ul&gt;&lt;li&gt;No.1 服务的稳定：比如一年只允许两次P1故障&lt;/li&gt;
&lt;li&gt;No.2 持续业务创新：鼓励业务中台运营团队业务创新，包容业务创新引起的故障&lt;/li&gt;
&lt;li&gt;No.3 服务接入量：考量服务能力的专业度以及对外的服务运营能力&lt;/li&gt;
&lt;li&gt;No.4 客户满意度：对中台服务运营团队起到督促作用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对外：开放能力构建生态
&lt;ul&gt;&lt;li&gt;核心内容：&lt;span&gt;&lt;strong&gt;将自身平台中的数据以服务的方式对外进行开放，从而吸引众多外部群体基于这些服务提供增值服务，持续地为客户提供优质的运营平台能力，从而最终构建基于开放平台的生态体系。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;在这部分内容里边，印象最深刻的还是作者提到在互联网转型时，很多人想要构建生态，但却没搞清楚“生态”和“上下游”的关系，它们之间的最本质的区别在于：在“上下游”模式中整个体系中所有的参与者都是被动的使用者，而“生态”模式中的参与者确是主动使用者，他们会持续地往整个体系中注入自己的智慧和创新的源泉，不断贡献自己的价值，只有这样的模式才能打造出企业所希望的生态效果。而传统企业现在应该着眼于企业内部的核心业务能力的打造，等到有一天需要通过能力开放的方式拓展企业业务边界或构建生态的时候，这些沉淀的服务会是企业最大的资产，而信息中心部门也不会只是一个成本中心，而有可能变为对外进行能力输出的关键运营部门。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Part 10 大型央企互联网转型&lt;/h2&gt;
&lt;p&gt;　　阿里巴巴协助国内某大型央企在90天构建出了一个B2B电商平台，整体平台架构基于阿里巴巴的共享服务理念和阿里云飞天Aliware的一系列产品，现在已经成为了国有大型企业进行互联网业务成功转型的标杆性项目。&lt;/p&gt;
&lt;h2&gt;Part 11时尚行业品牌公司互联网转型&lt;/h2&gt;
&lt;p&gt;　　某服装品牌民营企业基于阿里巴巴的共享服务架构完成了企业全渠道分销平台的重构，解决了高库存和高流单率的难题，实现了O2O的融合，建立了以客户体验为中心的系统架构，为企业在同行业的竞争中建立了差异化的竞争能力。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;2014年开始，国家就开始倡导“互联网+”的转型，越来越多的传统企业加入到互联网转型的浪潮，像我司一样的传统家居企业也开始了转型，于是开始建设信息中心，于是我就来了... 幸运的是，我司已经在成都地区小有名气，并且是一个知名的品牌，接下来要做的，借用作者的原话就是需要我们信息中心能够更好地使用互联网技术、利用互联网服务、借鉴互联网企业的运营模式，更好地实现价值链中各节点的连接，让流程更加透明，业务更加可视，最终能够挖掘企业的瓶颈，更好地满足消费者的需求，以获得更好的成长。对我个人而言，在此期间能够积累和沉淀更多的经验是最重要的，加油！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190420153730536-341629828.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;钟华，《企业IT架构转型之道-阿里巴巴中台战略思想与架构实战》&lt;/p&gt;
&lt;p&gt;James，《给架构师的推荐-企业IT架构转型之道》&lt;/p&gt;
&lt;p&gt;马崇，《企业IT架构转型之道的思考》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 15 May 2019 14:42:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>此文是我阅读《企业IT架构转型之道》一书的学习笔记，所有内容出自钟华老师的这本书。 零、为何读《企业IT架构转型之道》 在加入X公司后，开始了微服务架构的实践，也开始了共享平台服务的建设，在这方面阿里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/alibaba_it_architect_tranformation_study_notes.html</dc:identifier>
</item>
<item>
<title>WebGL three.js学习笔记 6种类型的纹理介绍及应用 - nsytsqdtn</title>
<link>http://www.cnblogs.com/nsytsqdtn/p/10872682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nsytsqdtn/p/10872682.html</guid>
<description>&lt;h2 id=&quot;webgl-three.js学习笔记-6种类型的纹理介绍及应用&quot;&gt;WebGL three.js学习笔记 6种类型的纹理介绍及应用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本文所使用到的demo演示：&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;反光效果demo演示因为是加载的模型所以速度会慢&quot;&gt;&lt;a href=&quot;https://nsytsqdtn.github.io/demo/environment_map/environment_map.html&quot;&gt;反光效果Demo演示&lt;/a&gt;（因为是加载的模型，所以速度会慢）&lt;/h2&gt;
&lt;h2 id=&quot;一普通纹理&quot;&gt;（一）普通纹理&lt;/h2&gt;
&lt;p&gt;计算机图形学中的纹理既包括通常意义上物体表面的纹理即使物体表面呈现凹凸不平的沟纹，同时也包括在物体的光滑表面上的彩色图案，所谓的纹理映射就是在物体的表面上绘制彩色的图案。&lt;/p&gt;
&lt;p&gt;在three.js中使用纹理可以实现很多不同的效果，但是最基本的就是为网格体的每个像素指定颜色。等同于将一张纹理图片应用在一个几何体的材质上。&lt;/p&gt;
&lt;p&gt;使用的方式很简单，只需要设置&lt;br/&gt;&lt;strong&gt;material.map = 需要设置的纹理对象&lt;/strong&gt;&lt;br/&gt;纹理对象的获得方式也很简单,只需要使用THREE.TextureLoader().load(url)函数就可以为url指定路径的纹理图片创建一个对象。具体的使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let texture = new THREE.TextureLoader().load(&quot;../../../Image/metal-rust.jpg&quot;);
        let material = new THREE.MeshBasicMaterial();
        material.map = texture;
        let geometry = new THREE.BoxGeometry(10,10,10);
        let cube = new THREE.Mesh(geometry,material);
        scene.add(cube);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&quot;../../../Image/metal-rust.jpg&quot;是我使用的纹理的路径,图片就是下面这一张&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514221053811.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;纹理贴图1&quot;/&gt;&lt;br/&gt;创建出来的带有上图纹理的cube就是这样的&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514220845261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;普通纹理&quot;/&gt;&lt;br/&gt;&lt;strong&gt;除了THREE.TextureLoader()这个加载器以为，three.js还为我们提供了其他自定义的加载器，如dds格式，pvr格式，tga格式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就拿tga格式举例，我们要加载tga格式的纹理，首先需要引用TGALoader.js这个文件，然后创建一个tga格式的加载器&lt;br/&gt;&lt;strong&gt;let loader = new THREE.TGALoader();&lt;/strong&gt;&lt;br/&gt;我们就可以使用loader这个加载器，像上面一样的加载tga格式的纹理了。&lt;br/&gt;具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let loader = new THREE.TGALoader();
        let texture = loader.load(&quot;../../../Image/crate_color8.tga&quot;);
        let material = new THREE.MeshBasicMaterial();
        material.map = texture;
        let geometry = new THREE.BoxGeometry(10,10,10);
        let cube = new THREE.Mesh(geometry,material);
        scene.add(cube);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是我使用的tga格式的纹理图片（只能上传截图，tga格式图片的这里上传不了）&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514222014706.png&quot; alt=&quot;tga纹理图片&quot;/&gt;&lt;br/&gt;运行出来是这个样子的&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019051422204536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;tga纹理&quot;/&gt;&lt;br/&gt;&lt;strong&gt;其他格式的加载也是和tga格式加载方法一样的，只需要引入相应的js文件就可以使用了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二凹凸贴图&quot;&gt;（二）凹凸贴图&lt;/h2&gt;
&lt;p&gt;凹凸纹理用于为材质添加厚度与深度，如字面意思一样，可以让材质看上去是凹凸不平的。凹凸贴图只包含像素的相对高度，像素的密集程度定义凹凸的高度，所以想要让物体好看，首先还是应该设置一个普通的纹理，再在这个基础上添加一个凹凸纹理，就可以实现凹凸不平的物体效果。&lt;br/&gt;凹凸贴图的创建方法很简单，和普通纹理类似，只是我们设置的不是map，而是bumpMap&lt;br/&gt;&lt;strong&gt;material.bumpMap = 需要设置的纹理对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别需要注意的是，这里的材质只能使用MeshPhongMaterial，凹凸贴图才会有效果。&lt;/strong&gt;&lt;br/&gt;具体的设置方法如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let geom = new THREE.BoxGeometry(10, 10, 10);
        
        //创建普通纹理材质
        let texture = new THREE.TextureLoader().load(&quot;../../../Image/stone.jpg&quot;);
        let material = new THREE.MeshPhongMaterial({
            map:texture
        });
        cube = new THREE.Mesh(geom,material);
        cube.position.set(-7,0,0);
        scene.add(cube);

        //创建凹凸纹理材质
        let bumpTexture = new THREE.TextureLoader().load(&quot;../../../Image/stone-bump.jpg&quot;);
        let bumpMaterial = new THREE.MeshPhongMaterial({
            map:texture,
            bumpMap:bumpTexture,
            bumpScale:2
        });
        bumpCube = new THREE.Mesh(geom,bumpMaterial);
        bumpCube.position.set(7,0,0);
        scene.add(bumpCube);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其中material.bumpScale可以设置凹凸的高度，如果为负值，则表示的是深度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行程序截图如下：&lt;br/&gt;左边材质的是普通的纹理贴图，右边的材质是带有凹凸纹理的，当前bumpScale设置的是2，两者看上去有比较明显的不同&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515123400191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;凹凸纹理&quot;/&gt;&lt;br/&gt;使用的纹理图片如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514224028694.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;纹理2&quot;/&gt;&lt;br/&gt;凹凸纹理图片：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514224059660.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;凹凸纹理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以发现，凹凸图只包含了像素的相对高度，没有任何的倾斜的方向信息，所以使用凹凸纹理能表达的深度信息有限，如果想用实现更多的细节可以使用下面介绍的法向贴图。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三法向贴图&quot;&gt;(三）法向贴图&lt;/h2&gt;
&lt;p&gt;法向贴图保存的不是高度的信息，而是法向量的信息，我们使用法向贴图，只需要很少的顶点和面就可以实现很丰富的细节。&lt;br/&gt;同样的，实现法向贴图和凹凸贴图也很类似，只需要设置&lt;br/&gt;&lt;strong&gt;material.normalMap = 需要设置的纹理对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同样也是在MeshPhongMaterial材质中才有效果，还要注意的一点是设置normalScale指定材质的凹凸程度时，normalScale需要接受的是一个THREE.Vector2类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let geom = new THREE.BoxGeometry(10, 10, 10);

        //创建普通纹理材质
        let texture = new THREE.TextureLoader().load(&quot;../../../Image/plaster.jpg&quot;);
        let material = new THREE.MeshPhongMaterial({
            map:texture
        });
        cube = new THREE.Mesh(geom,material);
        cube.position.set(-7,0,0);
        scene.add(cube);

        //创建凹凸纹理材质
        let normalTexture = new THREE.TextureLoader().load(&quot;../../../Image/plaster-normal.jpg&quot;);
        let normalMaterial = new THREE.MeshPhongMaterial({
            map:texture,
            normalMap:normalTexture,
            normalScale:new THREE.Vector2(1,1)
        });
        normalCube = new THREE.Mesh(geom,normalMaterial);
        normalCube.position.set(7,0,0);
        scene.add(normalCube);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;场景如下图，右边的是带有法向纹理的物体，明显感觉出材质的细节多出来了很多。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515171128156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;法向贴图&quot;/&gt;&lt;br/&gt;用到的纹理图&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515181055978.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;plaster&quot;/&gt;&lt;br/&gt;法向纹理图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515181118536.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;plaster-normal&quot;/&gt;&lt;br/&gt;虽然法向纹理能带给物体更逼真的效果，但是想要创建法向纹理图，本身就比较困难，需要ps或者blender这样的特殊工具。&lt;/p&gt;
&lt;h2 id=&quot;四光照贴图&quot;&gt;(四）光照贴图&lt;/h2&gt;
&lt;p&gt;如果我们想在场景中添加阴影，three.js给我们提供了renderer.shadowMapEnabled = true这个办法，但是这对于资源的消耗是很大的。如果我们只是需要对静态的物体添加阴影效果，我们就有一种开销很小的办法，那就是光照贴图。&lt;br/&gt;光照贴图是预先渲染好的阴影贴图，可以用来模拟真实的阴影。我们能使用这种技术创建出分辨率很高的阴影，并且不会损耗渲染的性能。因为是提前根据场景渲染好的，所以只对静态的场景有效。&lt;/p&gt;
&lt;p&gt;比如下面这张光照贴图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019051519065692.png&quot; alt=&quot;光照贴图&quot;/&gt;&lt;br/&gt;设置光照贴图的方式很简单，只需要设置&lt;br/&gt;&lt;strong&gt;material.lightMap = 需要设置的纹理对象&lt;/strong&gt;&lt;br/&gt;和前面两个没什么太大的区别。当纹理设置好以后，我们还需要把我们的物体摆放在正确的位置，这样阴影效果才会真实的显现出来。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let lightMap = new THREE.TextureLoader().load(&quot;../../../Image/lm-1.png&quot;);
        let map =  new THREE.TextureLoader().load(&quot;../../../Image/floor-wood.jpg&quot;);
        //创建地板
        let planeGeo = new THREE.PlaneGeometry(95,95,1,1);
        planeGeo.faceVertexUvs[1] = planeGeo.faceVertexUvs[0];
        let planeMat = new THREE.MeshBasicMaterial({
            color:0x999999,
            lightMap:lightMap,//在地板的材质上添加光照贴图
            map:map//地板的普通纹理材质
        });
        let plane = new THREE.Mesh(planeGeo,planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = 0;
        scene.add(plane);

        //创建大的cube
        var boxGeo = new THREE.BoxGeometry(12,12,12);
        var material = new THREE.MeshBasicMaterial();
        material.map = new THREE.TextureLoader().load(&quot;../../../Image/stone.jpg&quot;);
        var box = new THREE.Mesh(boxGeo,material);
        box.position.set(0.9,6,-12);
        scene.add(box);

        //创建小的cube
        var boxGeo = new THREE.BoxGeometry(6, 6, 6);
        var material = new THREE.MeshBasicMaterial();
        material.map = new THREE.TextureLoader().load(&quot;../../../Image/stone.jpg&quot;);
        var box = new THREE.Mesh(boxGeo,material);
        box.position.set(-13.2, 3, -6);
        scene.add(box);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其中，planeGeo.faceVertexUvs[1] = planeGeo.faceVertexUvs[0] 这句话是我们需要明确的指定光照贴图的uv映射（将纹理的哪一部分应用在物体表面）这样才能将光照贴图的使用和其他的纹理分别开来。&lt;/strong&gt;&lt;br/&gt;planeGeo.faceVertexUvs保存的就是几何体面的uv映射信息，我们将faceVertexUvs[0]层的信息保存到faceVertexUvs[1]层&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;faceVertexUvs的官方文档解释：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;.faceVertexUvs : Array&lt;br/&gt;Array of face UV layers, used for mapping&lt;br/&gt;textures onto the geometry. Each UV layer is an array of UVs matching&lt;br/&gt;the order and number of vertices in faces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行结果如图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515195606842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;光照贴图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五高光贴图&quot;&gt;(五）高光贴图&lt;/h2&gt;
&lt;p&gt;高光是光源照射到物体然后反射到人的眼睛里时,物体上最亮的那个点就是高光，高光不是光,而是物体上最亮的部分。&lt;br/&gt;而高光贴图就是高光贴图是反应光线照射在物体表面的高光区域时所产生的环境反射，它的作用是反映物体高光区域效果。&lt;/p&gt;
&lt;p&gt;通过高光贴图，我们可以为材质创建一个闪亮的、色彩明快的贴图。高光贴图的黑色部分会暗淡，而白色的部分会比较的亮。&lt;br/&gt;创建高光贴图的方法也和前面差不多&lt;br/&gt;&lt;strong&gt;material.specularMap= 需要设置的纹理对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体的代码如下:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let map = new THREE.TextureLoader().load(&quot;../../../Image/Earth.png&quot;);
        let specularMap = new THREE.TextureLoader().load(&quot;../../../Image/EarthSpec.png&quot;);
        let normalMap = new THREE.TextureLoader().load(&quot;../../../Image/EarthNormal.png&quot;);
        let sphereMaterial = new THREE.MeshPhongMaterial({
            map:map,
            specularMap:specularMap,
            normalMap:normalMap,
            normalScale:THREE.Vector2(2,2),
            specular:0x0000ff,
            shininess:2
        });
        let sphereGeometry = new THREE.SphereGeometry(30,30,30);
        let sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
        scene.add(sphere);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码创建了一个球体，并为球体的材质贴上了普通纹理，法向纹理和高光纹理，其中specular属性可以决定反光的颜色，shininess可以决定发光的亮度。&lt;/p&gt;
&lt;p&gt;运行出来的样子如下：&lt;br/&gt;可以看到，海洋的地方比较亮，而大陆的的颜色相对较暗。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515203936321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;高光贴图&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用到的几张纹理图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515202513560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;纹理&quot;/&gt;&lt;br/&gt;高光纹理：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515202532285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;高光纹理&quot;/&gt;&lt;br/&gt;法向纹理：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515202548765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;法向纹理&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六环境贴图&quot;&gt;(六）环境贴图&lt;/h2&gt;
&lt;p&gt;如果我们想要在场景中创建反光的物体，通常会使用光线追踪的算法，但是这对cpu的消耗是巨大的，但是环境贴图就给我们创造了更容易的方法，我们只需要使用给物体的材质贴上环境贴图，就可以模拟反光的效果。&lt;/p&gt;
&lt;p&gt;首先我们的场景需要有一个环境，这个环境我们可以使用CubeTextureLoader()来创建。在前面的文章里曾经介绍过如何创建360度全景的环境，这个CubeTextureLoader()和那里面用到的其实是一样的，只是版本的更替，现在更多使用这个函数。&lt;br/&gt;具体用法是：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let cubeMap = new THREE.CubeTextureLoader().setPath(
        &quot;../../../Image/MapCube/Bridge2/&quot;).load(
            [
                'posx.jpg',
                'negx.jpg',
                'posy.jpg',
                'negy.jpg',
                'posz.jpg',
                'negz.jpg'
            ]);
        scene = new THREE.Scene();
        scene.background = cubeMap;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面的文章已经介绍过，这里就不再赘述。&lt;br/&gt;创建cubeMap所用到的图片在http://www.humus.name/index.php?page=Textures可以直接下载。&lt;/p&gt;
&lt;p&gt;我们有了一个可以反射的环境以后，就可以开始为我们的物体创建材质贴图了。&lt;br/&gt;创建材质贴图的方式和前面还是差不多&lt;br/&gt;&lt;strong&gt;material.envMap = scene.background;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;scene.background就是我们刚刚所创建的场景的背景，这样材质的环境贴图就相当于贴上了周围环境，从摄像机去看物体的话，看上去就是对环境有一个反射的效果了。&lt;/p&gt;
&lt;p&gt;创建的代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;       function initObject()
       {
       let material = new THREE.MeshPhongMaterial();
       material.envMap = scene.background;
       let boxGeometry = new THREE.BoxGeometry(5,50,50);
       let box = new THREE.Mesh(boxGeometry,material);
       box.position.set(-70,0,-10);
       box.rotation.y-=Math.PI/2;
       scene.add(box);
       let sphereGeometry = new THREE.SphereGeometry(30,30,30);
       let sphere = new THREE.Mesh(sphereGeometry,material);
       sphere.position.set(70,0,-10);
       scene.add(sphere);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和前面的代码没有太大的区别，这里主要是创建了两个物体，都使用的相同环境贴图的材质。&lt;/p&gt;
&lt;p&gt;运行的结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515220613202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;环境贴图&quot;/&gt;&lt;br/&gt;可以看到，这两个物体都对环境有反射的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是，我们使用环境贴图创建的材质仅仅静态的环境贴图。我们只能看到物体上面有周围环境的反射，看不到物体对其他物体的反射。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们要看到物体对其他物体的反射，我们可以使用一个新的对象——cubeCamera&lt;/strong&gt;&lt;br/&gt;创建cubeCamera的方法很简单.&lt;br/&gt;&lt;strong&gt;let cubeCamera = new THREE.CubeCamera(0.1, 2000, 2048);&lt;br/&gt;scene.add(cubeCamera);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;br/&gt;&lt;strong&gt;第一个参数0.1是相机的近裁剪距离&lt;br/&gt;第二个参数2000是相机远裁剪距离&lt;br/&gt;第三个参数2048是相机分辨率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用THREE.CubeCamera可以为场景中所要渲染的物体创建快照，并使用这些快照创建CubeMap对象。但是需要确保摄像机被放置在THREE.Mesh网格上你所想显示反射的位置上。例如，我们想在球体的中心显示反射，由于球体所处的位置是(0, 0, 0),所以我们没有显示的指定THREE.CubeCamera的位置。我们只是将动态反射应用于球体上，所以把它的envMap设置为cubeCamera.renderTarget&lt;br/&gt;&lt;strong&gt;即material.envMap = cubeCamera.renderTarget;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单来说，就是把我们所要显示反射的“镜子”的material.envMap设置为cubeCamera.renderTarget，同时还要把cubeCamera的位置设置到镜子的位置，cubeCamera.position.copy(镜子.position);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let loader = new THREE.STLLoader();
        loader.load(&quot;../../../asset/LibertStatue.obj.stl&quot;,function (bufferGeometry)
        {
            let material = new THREE.MeshBasicMaterial();
            material.envMap=scene.background;
            obj = new THREE.Mesh(bufferGeometry,material);
            obj.scale.set(50,50,50);
            scene.add(obj);
        });//加载stl模型
       
        let cubeMaterial = new THREE.MeshPhongMaterial();
        cubeMaterial.envMap = cubeCamera.renderTarget;
        let boxGeometry = new THREE.BoxGeometry(3, 400, 400);
        let box = new THREE.Mesh(boxGeometry, cubeMaterial);
        box.position.set(0, 0, -300);
        box.rotation.y -= Math.PI / 2;
        scene.add(box);
        cubeCamera.position.copy(box.position);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码中，我们从外部加载了一个stl格式的模型，也可以就使用简单的几何体来演示。下面的一部分代码就创建了可以反射的镜子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，我们还需要在render()中添加cubeCamera.update(renderer, scene)用cubeCamera进行渲染&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function render()
    {
        if(obj) obj.rotation.y+=0.02;
        cubeCamera.update(renderer, scene);
        stats.update();
        renderer.clear();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后的情况如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515222459959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;cubeCamera&quot;/&gt;&lt;br/&gt;我们可以看到我们加载的stl模型在我们创建的镜子中反射出来了，并且会根据模型的移动，镜子的反射也会自动变化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上就是介绍的全部类型的纹理。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;反光效果demo的完整代码&quot;&gt;反光效果demo的完整代码：&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Environment Map&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;../../../import/three.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../../import/stats.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../../import/Setting.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../../import/OrbitControls.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../../import/STLLoader.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        body {
            border: none;
            cursor: pointer;
            width: 100%;
            height: 1000px;
            /*全屏显示的设置*/
            margin: 0;
            overflow: hidden; /*消除浏览器的滚动条*/

        }

        /*加载动画*/
        #loading {
            width: 100%;
            height: 850px;
            background-color: #333333;
        }

        #spinner {
            width: 100px;
            height: 100px;
            position: fixed;
            top: 50%;
            left: 50%;
        }

        .double-bounce1, .double-bounce2 {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: #67CF22;
            opacity: 0.6;
            position: absolute;
            top: 0;
            left: 0;
            -webkit-animation: bounce 2.0s infinite ease-in-out;
            animation: bounce 2.0s infinite ease-in-out;
        }

        .double-bounce2 {
            -webkit-animation-delay: -1.0s;
            animation-delay: -1.0s;
        }

        @-webkit-keyframes bounce {
            0%, 100% {
                -webkit-transform: scale(0.0)
            }
            50% {
                -webkit-transform: scale(1.0)
            }
        }

        @keyframes bounce {
            0%, 100% {
                transform: scale(0.0);
                -webkit-transform: scale(0.0);
            }
            50% {
                transform: scale(1.0);
                -webkit-transform: scale(1.0);
            }
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&quot;Start()&quot;&amp;gt;
&amp;lt;!--加载动画的div--&amp;gt;
&amp;lt;div id=&quot;loading&quot;&amp;gt;
    &amp;lt;div id=&quot;spinner&quot;&amp;gt;
        &amp;lt;div class=&quot;double-bounce1&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;double-bounce2&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let camera, renderer, scene, cubeCamera, light;
    let controller;

    function initThree()
    {
        //渲染器初始化
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x333333);
        document.body.appendChild(renderer.domElement);//将渲染添加到body中
        //初始化摄像机，这里使用透视投影摄像机
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 10000);
        camera.position.set(20, 15, 200);
        camera.up.x = 0;//设置摄像机的上方向为哪个方向，这里定义摄像的上方为Y轴正方向
        camera.up.y = 1;
        camera.up.z = 0;
        camera.lookAt(0, 0, 0);

        let cubeMap = new THREE.CubeTextureLoader().setPath(&quot;../../../Image/MapCube/Bridge2/&quot;).load(
            [
                'posx.jpg',
                'negx.jpg',
                'posy.jpg',
                'negy.jpg',
                'posz.jpg',
                'negz.jpg'
            ]);
        scene = new THREE.Scene();
        scene.background = cubeMap;

        cubeCamera = new THREE.CubeCamera(0.1, 1000, 2048);
        scene.add(cubeCamera);
        //相机的移动
        controller = new THREE.OrbitControls(camera, renderer.domElement);
        controller.target = new THREE.Vector3(0, 0, 0);

        light = new THREE.AmbientLight(0xffffff);
        light.position.set(-50, -50, -50);
        scene.add(light);
    }
    
     let obj;
    function initObject()
    {
        let loader = new THREE.STLLoader();
        loader.load(&quot;../../../asset/LibertStatue.obj.stl&quot;,function (bufferGeometry)
        {
            let material = new THREE.MeshBasicMaterial();
            material.envMap=scene.background;
            obj = new THREE.Mesh(bufferGeometry,material);
            obj.scale.set(50,50,50);
            scene.add(obj);
            console.log(obj);
        });
        let cubeMaterial = new THREE.MeshPhongMaterial();
        cubeMaterial.envMap = cubeCamera.renderTarget;
        let boxGeometry = new THREE.BoxGeometry(3, 400, 400);
        let box = new THREE.Mesh(boxGeometry, cubeMaterial);
        box.position.set(0, 0, -300);
        box.rotation.y -= Math.PI / 2;
        scene.add(box);
        cubeCamera.position.copy(box.position);
        document.getElementById('loading').style.display = 'none';
    }
    //渲染函数
    function render()
    {
        if(obj) obj.rotation.y+=0.02;
        cubeCamera.update(renderer, scene);
        stats.update();
        renderer.clear();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }

    //功能函数
    function setting()
    {
        loadFullScreen();
        loadAutoScreen(camera, renderer);
        loadStats();
    }

    //运行主函数
    function Start()
    {
        initThree();
        initObject();
        setting();
        render();
    }
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 15 May 2019 14:39:00 +0000</pubDate>
<dc:creator>nsytsqdtn</dc:creator>
<og:description>WebGL three.js学习笔记 6种类型的纹理介绍及应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nsytsqdtn/p/10872682.html</dc:identifier>
</item>
<item>
<title>mysql数据库的索引 - 王森</title>
<link>http://www.cnblogs.com/wangsen/p/10864136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangsen/p/10864136.html</guid>
<description>&lt;p&gt;索引是对数据库表中一列或多列的值【排好序】的数据结构。&lt;/p&gt;

&lt;p&gt;因为创建索引可以大大提高系统的查询性能。&lt;/p&gt;

&lt;p&gt;简单的理解：一张数据量比较大的表格如果没有添加任何索引，那我们在执行查询的时候&lt;br/&gt;就会是进行全表扫描，逐行比对，这样的读取效率肯定很低，如果我们为数据创建了索引&lt;br/&gt;索引的实现方式又是支持快速查询的这样我们只需要先查询索引中符合条件的，&lt;br/&gt;然后再通过索引指向的数据行位置就可以实现快速定位数据了，不用全表扫描了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514202705200-893647725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据库索引是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个G甚至更多。&lt;br/&gt;当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，这里的磁盘页就对应索引树的节点。&lt;/p&gt;

&lt;h2 id=&quot;哈希表&quot;&gt;哈希表&lt;/h2&gt;
&lt;p&gt;哈希表可能会出现哈希冲突。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514193333407-1719669551.png&quot;/&gt;&lt;br/&gt;最主要的原因是它不支持范围查询。&lt;/p&gt;
&lt;h2 id=&quot;完全平衡二叉树&quot;&gt;完全平衡二叉树&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514194148934-64409339.png&quot;/&gt;&lt;br/&gt;如图如果一个树的高度很大，如果查询的数据刚好在叶子节点那经历的磁盘Io的次数就是这个数的高度。&lt;br/&gt;所以极端情况下平衡二叉树也不是优选。&lt;/p&gt;
&lt;h2 id=&quot;b-tree&quot;&gt;B-Tree&lt;/h2&gt;
&lt;p&gt;先说说几个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;度（节点的数据存储个数）也就是说B-Tree上的一个节点可以存储多个数据。&lt;/li&gt;
&lt;li&gt;叶节点具有相同的深度&lt;/li&gt;
&lt;li&gt;叶节点的指针为空&lt;/li&gt;
&lt;li&gt;节点中的数据从左到右递增排列&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514201732286-701828340.png&quot;/&gt;&lt;br/&gt;这的确解决了树的高度问题，因为：B-Tree的节点可以存储多个值，高度肯定小于平衡二叉树，磁盘io的次数也会少。&lt;br/&gt;但是在范围查找方面较比B+Tree差点。&lt;br/&gt;题外话：B-Tree和BTree是一种树。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;btree&quot;&gt;B+Tree&lt;/h2&gt;
&lt;p&gt;B+Tree是B-Tree的变种，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514201440659-157658732.png&quot;/&gt;&lt;br/&gt;B+树的表示要比B树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连。&lt;/p&gt;
&lt;p&gt;mysql的实现中，B+Tree是把非叶子节点中只存储索引，不存储数据，只有叶子节点存储数据，这样节点中的空间更多的存储了索引，增加了度。&lt;br/&gt;最大程度的降低了树的高度，再加上一个节点的大小设置成为一页或页的倍数，一次磁盘io就可以读出了一个节点中的很多数据。&lt;br/&gt;加载到内存中再进行查找就很快了&lt;/p&gt;
&lt;p&gt;所以最后总结：&lt;br/&gt;使用B+Tree:可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。&lt;/p&gt;

&lt;h2 id=&quot;myisam中的btree&quot;&gt;MyISAM中的B+Tree&lt;/h2&gt;
&lt;p&gt;MYISAM中叶子节点的数据区域存储的是数据记录的地址.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514203511745-1871330661.png&quot;/&gt;&lt;br/&gt;MyISAM的索引是单独一个文件存放的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514203630245-256594033.png&quot;/&gt;&lt;br/&gt;MyISAM中的主键索引和辅助引是没有区别的，其叶子节点存放的都是数据记录的地址。&lt;/p&gt;
&lt;h2 id=&quot;innodb中的btree&quot;&gt;InnoDB中的B+Tree&lt;/h2&gt;
&lt;p&gt;InnoDB中的叶子节点数据区域存储的内容和主键索引和辅助索引引有关。&lt;br/&gt;如果是主键索引存储的就是索引+数据（index+data）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514203936039-1715498943.png&quot;/&gt;&lt;br/&gt;Innodb的主键索引要比MyISAM的主键索引查询效率要高，因为找到主键索引就找到了数据,MyISAM还有通过地址查询一次。&lt;br/&gt;如果是辅助索引存储的是主键的值&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514204130408-1994293907.png&quot;/&gt;&lt;br/&gt;因此可以看出InnoDB的辅助索引会发生两次，一次通过辅助索引查询主键索引，一次是通过主键索引查询到数据。&lt;/p&gt;
&lt;p&gt;InnoDB的索引是和数据文件放在一起的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514205023672-1191913641.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;聚集索引&quot;&gt;聚集索引&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;非聚集索引&quot;&gt;非聚集索引&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;数据行的物理顺序与列值的逻辑顺序不相同，一个表中可以拥有多个非聚集索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;叶子节点存放的不是实际数据，而是指向实际数据的指针。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190515193737476-1534361388.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;聚集索引以外的索引都是非聚集索引,细分可以分为：普通索引，唯一索引，全文索引&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;注意&quot;&gt;注意：&lt;/h2&gt;
&lt;p&gt;InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引&lt;/p&gt;

&lt;h2 id=&quot;什么样的字段适合建索引&quot;&gt;什么样的字段适合建索引&lt;/h2&gt;
&lt;p&gt;索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在具备下述特性的列上创建索引：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一、在经常需要搜索的列上，可以加快搜索的速度；&lt;/li&gt;
&lt;li&gt;第二、在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；&lt;/li&gt;
&lt;li&gt;第三、在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；&lt;/li&gt;
&lt;li&gt;第四、在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；&lt;/li&gt;
&lt;li&gt;第五、在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；&lt;/li&gt;
&lt;li&gt;第六、在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。&lt;br/&gt;建立索引，一般按照select的where条件来建立，&lt;br/&gt;比如： select的条件是where f1 and f2，那么如果我们在字段f1或字段f2上建立索引是没有用的，只有在字段f1和f2上同时建立索引才有用等。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么样的字段不适合建立索引&quot;&gt;什么样的字段不适合建立索引&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对于那些在查询中很少使用或者参考的列不应该创建索引&lt;/li&gt;
&lt;li&gt;对于那些只有很少数据值的列也不应该增加索引，比如：性别，状态，这是因为，由于这些列的取值很少，创建索引效果也不明显。&lt;/li&gt;
&lt;li&gt;对于那些定义为text, image和bit数据类型的列不应该增加索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wangsen/p/10871996.html&quot;&gt;mysql常见的优化策略&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;数据结构：&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; class=&quot;uri&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MTA1MDU2Ng==&amp;amp;mid=2247483698&amp;amp;idx=1&amp;amp;sn=63eee2f67bc05d46e0b40f9999e5c736&amp;amp;chksm=ce853d1bf9f2b40d7845f6a4c5c9bfe32397d87236347a7adf85d18ea1c79b9ee7d6bb80bd19&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0513oct1Eqn0fDWPuOMAZbyd&amp;amp;key=e5c9f0f84d46755059bc9825949648193177cb6fd6739c17c3f6751e70d598c6406dd4bcf7a030cfbb7dcc7663bd484ab3f3035073dc7b4a31974678d2aa7b044fd9200304cf8dfb95a0a0ea46984990&amp;amp;ascene=1&amp;amp;uin=NzkwMDM0MjYy&amp;amp;devicetype=Windows+10&amp;amp;version=62060739&amp;amp;lang=zh_CN&amp;amp;pass_ticket=%2BgyuPXnOA9g6lE0%2BamAQvTP2lKLvQ6X665z6wjditKxEPRnxoLkK66gbugtCj0lU&quot;&gt;面试必备之Mysql索引底层原理分析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_27602945/article/details/80118362&quot;&gt;为什么数据库选B-tree或B+tree而不是二叉树作为索引结构&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/fd49b1510dfd&quot;&gt;关于B-树问题的演示图解&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 12:50:00 +0000</pubDate>
<dc:creator>王森</dc:creator>
<og:description>什么是索引 索引是对数据库表中一列或多列的值【排好序】的数据结构。 为什么要加索引 因为创建索引可以大大提高系统的查询性能。 怎么提高查询性能的 简单的理解：一张数据量比较大的表格如果没有添加任何索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangsen/p/10864136.html</dc:identifier>
</item>
<item>
<title>【Java】ServiceLoader源码分析 - 松饼人</title>
<link>http://www.cnblogs.com/a526583280/p/10871795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a526583280/p/10871795.html</guid>
<description>&lt;p&gt;ServiceLoader主要的功能是用来完成对SPI的provider的加载。&lt;/p&gt;
&lt;p&gt;先看下它的成员：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServiceLoader&amp;lt;S&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;implements&lt;/span&gt; Iterable&amp;lt;S&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String PREFIX = &quot;META-INF/services/&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The class or interface representing the service being loaded&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;S&amp;gt;&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The class loader used to locate, load, and instantiate providers&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ClassLoader loader;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The access control context taken when the ServiceLoader is created&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; AccessControlContext acc;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cached providers, in instantiation order&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LinkedHashMap&amp;lt;String,S&amp;gt; providers = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The current lazy-lookup iterator&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LazyIterator lookupIterator;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到他首先是实现了Iterable接口，可以迭代。&lt;br/&gt;PREFIX：指明了路径是在&quot;META-INF/services/&quot;下。&lt;br/&gt;service：表示正在加载的服务的类或接口。&lt;br/&gt;loader：使用的类加载器。&lt;br/&gt;acc：创建ServiceLoader时获取的访问控制上下文。&lt;br/&gt;providers ：缓存的服务提供集合。&lt;br/&gt;lookupIterator：是其内部使用的迭代器，用于类的懒加载，只有在迭代时加载。&lt;/p&gt;
&lt;p&gt;其构造方法是一个private方法，不对外提供，在使用时我们需要调用其静态的load方法，由其自身产生ServiceLoader对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt;&lt;span&gt; service) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         ClassLoader cl =&lt;span&gt; Thread.currentThread().getContextClassLoader();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServiceLoader.load(service, cl);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt;&lt;span&gt; service,
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;                                            ClassLoader loader) {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceLoader&amp;lt;&amp;gt;&lt;span&gt;(service, loader);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到对load方法进行了重载，其中参数service是要加载的类；单参方法没有类加载器，使用的是当前线程的类加载器；最后调用的是双参的load方法；而双参的load方法也很简单，只是直接调用ServiceLoader的构造方法，实例化了一个对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; ServiceLoader(Class&amp;lt;S&amp;gt;&lt;span&gt; svc, ClassLoader cl) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         loader = (cl == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; ClassLoader.getSystemClassLoader() : cl;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         acc = (System.getSecurityManager() != &lt;span&gt;null&lt;/span&gt;) ? AccessController.getContext() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        reload();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到其构造方法逻辑依旧很简单，首先是判断传入的svc（即传入的service）是否为空，若是为空直接报异常，否则给service 成员赋值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T requireNonNull(T obj, String message) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException(message);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后给进行cl的非空判断，给loader 成员赋值；接着给acc 成员赋值，其根据是否设置了安全管理器SecurityManager来赋值；最后调用reload方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reload() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        providers.clear();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         lookupIterator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazyIterator(service, loader);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到reload方法是一个public方法，那么在每次调用reload时就需要将之前加载的清空掉，所以直接使用providers这个map的clear方法清空掉缓存；接着使用刚才赋值后的service和loader产生一个LazyIterator对象赋值给lookupIterator成员。&lt;/p&gt;
&lt;p&gt;LazyIterator是ServiceLoader的内部类，其定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazyIterator
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;S&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Class&amp;lt;S&amp;gt;&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    ClassLoader loader;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     Enumeration&amp;lt;URL&amp;gt; configs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Iterator&amp;lt;String&amp;gt; pending = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     String nextName = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LazyIterator(Class&amp;lt;S&amp;gt;&lt;span&gt; service, ClassLoader loader) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.service =&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.loader =&lt;span&gt; loader;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里就可以看到ServiceLoader的实际加载过程就交给了LazyIterator来做，将ServiceLoader的service和loader成员分别赋值给了LazyIterator的service和loader成员。&lt;br/&gt;configs是服务的URL枚举；&lt;br/&gt;pending是保存要加载的服务的名称集合；&lt;br/&gt;nextName是下一个要加载的服务名称；&lt;/p&gt;
&lt;p&gt;ServiceLoader实现了Iterable接口，其实现的iterator方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;S&amp;gt;&lt;span&gt; iterator() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Iterator&amp;lt;S&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Iterator&amp;lt;Map.Entry&amp;lt;String,S&amp;gt;&amp;gt;&lt;span&gt; knownProviders
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             =&lt;span&gt; providers.entrySet().iterator();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (knownProviders.hasNext())
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; lookupIterator.hasNext();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; S next() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (knownProviders.hasNext())
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; knownProviders.next().getValue();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; lookupIterator.next();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到它是直接创建了一个Iterator对象返回；其knownProviders成员直接获取providers的entrySet集合的迭代器；在hasNext和next方法中我们可以看到，它是先通过判断knownProviders里有没有（即providers），若没有再去lookupIterator中找；&lt;br/&gt;前面我们可以看到providers里并没用put任何东西，那么就说明put操作也是在lookupIterator中完成的。&lt;/p&gt;
&lt;p&gt;先看到lookupIterator的next方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; S next() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (acc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextService();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         PrivilegedAction&amp;lt;S&amp;gt; action = &lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;S&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; S run() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextService(); }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; AccessController.doPrivileged(action, acc);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先根据判断acc是否为空，若为空则说明没有设置安全策略直接调用nextService方法，否则以特权方式调用nextService方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; S nextService() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasNextService())
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     String cn =&lt;span&gt; nextName;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     nextName = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Class&amp;lt;?&amp;gt; c = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         c = Class.forName(cn, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, loader);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException x) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        fail(service,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;              &quot;Provider &quot; + cn + &quot; not found&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;service.isAssignableFrom(c)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        fail(service,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;              &quot;Provider &quot; + cn  + &quot; not a subtype&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         S p =&lt;span&gt; service.cast(c.newInstance());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        providers.put(cn, p);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable x) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        fail(service,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;              &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;             x);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error();          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This cannot happen&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先根据hasNextService方法判断，若为false直接抛出NoSuchElementException异常，否则继续执行。&lt;/p&gt;
&lt;p&gt;hasNextService方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNextService() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (nextName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (configs == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             String fullName = PREFIX +&lt;span&gt; service.getName();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (loader == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 configs =&lt;span&gt; ClassLoader.getSystemResources(fullName);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 configs =&lt;span&gt; loader.getResources(fullName);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException x) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             fail(service, &quot;Error locating configuration files&quot;&lt;span&gt;, x);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; ((pending == &lt;span&gt;null&lt;/span&gt;) || !&lt;span&gt;pending.hasNext()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;configs.hasMoreElements()) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         pending =&lt;span&gt; parse(service, configs.nextElement());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     nextName =&lt;span&gt; pending.next();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hasNextService方法首先根据nextName成员是否为空判断，若不为空，则说明已经初始化过了，直接返回true，否则继续执行。接着configs成员是否为空，configs 是一个URL的枚举，若是configs 没有初始化，就需要对configs初始化。&lt;br/&gt;configs初始化逻辑也很简单，首先根据PREFIX前缀加上PREFIX的全名得到完整路径，再根据loader的有无，获取URL的枚举。其中fail方法时ServiceLoader的静态方法，用于异常的处理，后面给出。&lt;br/&gt;在configs初始化完成后，还需要完成pending的初始化或者添加。&lt;br/&gt;可以看到只有当pending为null，或者没有元素时才进行循环。循环时若是configs里没有元素，则直接返回false；否则调用ServiceLoader的parse方法，通过service和URL给pending赋值；&lt;/p&gt;
&lt;p&gt;parse方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Iterator&amp;lt;String&amp;gt; parse(Class&amp;lt;?&amp;gt;&lt;span&gt; service, URL u)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     InputStream in = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     BufferedReader r = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     ArrayList&amp;lt;String&amp;gt; names = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         in =&lt;span&gt; u.openStream();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         r = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(in, &quot;utf-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; lc = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((lc = parseLine(service, u, r, lc, names)) &amp;gt;= 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException x) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         fail(service, &quot;Error reading configuration file&quot;&lt;span&gt;, x);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (r != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) r.close();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (in != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) in.close();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException y) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             fail(service, &quot;Error closing configuration file&quot;&lt;span&gt;, y);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; names.iterator();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到parse方法直接通过URL打开输入流，通过parseLine一行一行地读取将结果保存在names数组里。&lt;/p&gt;
&lt;p&gt;parseLine方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; parseLine(Class&amp;lt;?&amp;gt; service, URL u, BufferedReader r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lc,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                           List&amp;lt;String&amp;gt;&lt;span&gt; names)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     String ln =&lt;span&gt; r.readLine();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ln == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ci = ln.indexOf('#'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ci &amp;gt;= 0) ln = ln.substring(0&lt;span&gt;, ci);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ln =&lt;span&gt; ln.trim();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; ln.length();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (n != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((ln.indexOf(' ') &amp;gt;= 0) || (ln.indexOf('\t') &amp;gt;= 0&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             fail(service, u, lc, &quot;Illegal configuration-file syntax&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; cp = ln.codePointAt(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Character.isJavaIdentifierStart(cp))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             fail(service, u, lc, &quot;Illegal provider-class name: &quot; +&lt;span&gt; ln);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = Character.charCount(cp); i &amp;lt; n; i +=&lt;span&gt; Character.charCount(cp)) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             cp =&lt;span&gt; ln.codePointAt(i);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!Character.isJavaIdentifierPart(cp) &amp;amp;&amp;amp; (cp != '.'&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 fail(service, u, lc, &quot;Illegal provider-class name: &quot; +&lt;span&gt; ln);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!providers.containsKey(ln) &amp;amp;&amp;amp; !&lt;span&gt;names.contains(ln))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            names.add(ln);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; lc + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;parseLine方法就是读该URL对应地文件地一行，可以看到通过对“#”的位置判断，忽略注释，并且剔除空格，接着是一系列的参数合法检验，然后判断providers和names里是否都没包含这个服务名称，若都没包含names直接add，最后返回下一行的行标；&lt;/p&gt;
&lt;p&gt;当parse将所有内容读取完毕，返回names.iterator()赋值给hasNextService中的pending。循环结束，获取pending中的第一个元素赋值给nextName，返回true，hasNextService方法结束。&lt;/p&gt;
&lt;p&gt;在nextService方法往下执行时，先用cn保存nextName的值，再让nextName=null，为下一次的遍历做准备；接着通过类加载，加载名为cn的类，再通过该类实例化对象，并用providers缓存起来，最后返回该实例对象。&lt;/p&gt;
&lt;p&gt;其中cast方法是判断对象是否合法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T cast(Object obj) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (obj != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;isInstance(obj))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassCastException(cannotCastMsg(obj));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) obj;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此ServiceLoader的迭代器的next方法结束。其hasNext方法与其类似，就不详细分析了。&lt;/p&gt;
&lt;p&gt;而其remove方法就更直接，直接抛出异常来避免可能出现的危险情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中使用到的静态fail方法只是抛出异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fail(Class&amp;lt;?&amp;gt;&lt;span&gt; service, String msg, Throwable cause)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceConfigurationError(service.getName() + &quot;: &quot; +&lt;span&gt; msg,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                                            cause);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fail(Class&amp;lt;?&amp;gt;&lt;span&gt; service, String msg)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceConfigurationError(service.getName() + &quot;: &quot; +&lt;span&gt; msg);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fail(Class&amp;lt;?&amp;gt; service, URL u, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line, String msg)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     fail(service, u + &quot;:&quot; + line + &quot;: &quot; +&lt;span&gt; msg);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ServiceLoader除了load的两个方法外还有个loadInstalled方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; loadInstalled(Class&amp;lt;S&amp;gt;&lt;span&gt; service) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     ClassLoader cl =&lt;span&gt; ClassLoader.getSystemClassLoader();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     ClassLoader prev = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (cl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         prev =&lt;span&gt; cl;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         cl =&lt;span&gt; cl.getParent();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServiceLoader.load(service, prev);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法与load方法不同在于loadInstalled使用的是扩展类加载器，而load使用的是传入进来的或者是线程的上下文类加载器，其他都一样。&lt;/p&gt;

&lt;p&gt;ServiceLoader源码分析到此全部结束。&lt;/p&gt;

</description>
<pubDate>Wed, 15 May 2019 12:01:00 +0000</pubDate>
<dc:creator>松饼人</dc:creator>
<og:description>ServiceLoader主要的功能是用来完成对SPI的provider的加载。 先看下它的成员： 可以看到他首先是实现了Iterable接口，可以迭代。PREFIX：指明了路径是在&quot;MET</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/a526583280/p/10871795.html</dc:identifier>
</item>
<item>
<title>令牌Token和会话Session原理与攻略 - 朝野布告</title>
<link>http://www.cnblogs.com/huangsheng/p/10736796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangsheng/p/10736796.html</guid>
<description>&lt;p&gt;        本篇文章将从无到完整的登录框架或API详细讲述登录令牌原理、攻略等安全点。&lt;/p&gt;
&lt;p&gt;        有些协议或框架也喜欢把令牌叫票据（Ticket），不论是APP还是Web浏览器，很多框架或协议都用到了本文所说的这套类似的认证机制（客户端各种加密用户名密码当我没说），这里的以Asp.net core下Web登录和验证为例子进行讲述，但原理攻略和语言、框架都无关。&lt;/p&gt;

&lt;p&gt;目录：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp1&quot;&gt;一、过程与原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp2&quot;&gt;二、Demo数据库结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp3&quot;&gt;三、Demo源码介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp4&quot;&gt;四、构建与验证Token&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp5&quot;&gt;五、Token失效与登录唯一性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp6&quot;&gt;六、CAS/SSO单点登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp7&quot;&gt;七、URL授权验证与扫码登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp8&quot;&gt;八、Session实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp9&quot;&gt;九、关于Token刷新&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本片文章Demo：&lt;a href=&quot;https://github.com/chaoyebugao/AcctAuthDemo&quot;&gt;https://github.com/chaoyebugao/AcctAuthDemo&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;acp1&quot;&gt; &lt;/p&gt;

&lt;h2&gt;一、过程与原理 &lt;/h2&gt;
&lt;div&gt;&lt;a href=&quot;https://www.processon.com/view/link/5cc5804ae4b09b16ffcb7d60&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;令牌授权过程&quot; src=&quot;http://assets.processon.com/chart_image/5cc5804ae4b0bab9096bd889.png&quot; alt=&quot;令牌授权过程&quot; width=&quot;806&quot; height=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;令牌机制简单过程（点击查看大图）&lt;/p&gt;
&lt;p&gt;        首先，这套机制使用场景是登录授权和身份验证，可以用在Web上，也可以用在API的访问控制上。这套机制其实和很多无状态框架登录/授权验证协议类似，这里讲的其实和OAuth2.0里面授权码模式的原理是一样的(authorization code)，只不过我们在这里将其步骤拆分，了解其原理和实现，以后搭建项目应用才能庖丁解牛。还有一点，很多框架的授权机制都太繁重且并不能灵活应用，这时候就可以自己搭一个。&lt;/p&gt;
&lt;p&gt;        首先，用户使用终端向服务器提供可信凭证（一般登录是用户名密码，微信公众平台是appid+appsecret），服务端确认凭证正确，则返回授权的令牌（以下称Token）。这个Token是随机的字符串且与本次授权唯一相关。返回Token给终端的同时服务端也要一并保存Token，这样终端和服务端都只认Token，终端所有请求发送都需要携带此Token，服务端会验证和控制此Token。此时Token就有两个，一个是终端Token，一个是服务端Token，其中一个不对或没有，服务端都是拒绝的。&lt;/p&gt;
&lt;p&gt;        举个例子，你上12306购票，购买过程就是授权你Token的过程，你的纸质票就是Token，另外一半对应的Token保存在12306那的DB里头，所有门闸就是网关，当你过门闸时会验证你Token是否对应DB的Token。你下车后，12306就把DB的Token标记处理掉，这样服务端就不会再认你手上的纸质票，票也就作废了。&lt;/p&gt;
&lt;p&gt;        围绕这一机制，我们将讲述CAS单点登录、令牌授权与身份验证、Session实现、防重放攻击、登录唯一性、URL授权验证（用于验证邮箱等）等&lt;/p&gt;
&lt;p id=&quot;acp2&quot;&gt; &lt;/p&gt;

&lt;h2&gt;二、Demo数据库结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515152119061-754303208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设备表：用于识别、记录不同的设备，同一设备应该有唯一的标记Id，下面详说&lt;/p&gt;
&lt;p&gt;令牌表：用于持久化令牌，ExpireAt为过期时间，Token即令牌字符串，根据UserId与用户表相关联，根据DeviceId与设备表相关联&lt;/p&gt;
&lt;p&gt;用户表：用户表，保存用户名密码等&lt;/p&gt;
&lt;p&gt;设备表和设备标记（DeviceId）是可有可无的，可以根据实际业务来处理，有必要的话再增加其他相关联的数据和表&lt;/p&gt;
&lt;p id=&quot;acp3&quot;&gt; &lt;/p&gt;

&lt;h2&gt;三、Demo源码介绍&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;用户注册、登录、注销登录入口&quot; src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515170911612-223364984.png&quot; alt=&quot;用户Controller&quot; width=&quot;662&quot; height=&quot;479&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;验证入库&quot; src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515171230222-608122276.png&quot; alt=&quot;HomeController&quot; width=&quot;459&quot; height=&quot;172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UserController - 用户注册、登录、注销登录&lt;/p&gt;
&lt;p&gt;HomeController - Index - 默认启动页，Token验证页&lt;/p&gt;
&lt;p id=&quot;acp4&quot;&gt; &lt;/p&gt;

&lt;h2&gt;四、构建与验证Token&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515154042575-972564652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构建Token&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515163040423-1784808511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证Token&lt;/p&gt;
&lt;p&gt;        Token的构建发生在用户提供的凭证（如用户名密码）被服务端确认无误之后。一次登录/授权的Token分两部分，服务端持有的我们叫数据库Token，用户端（Endpoint）持有的叫终端Token。终端Token可以是任意的随机字符串构成，所以这里最后要根据登录情况来求得哈希值即终端Token本身。因为后面要根据终端Token来查询处理数据库Token记录，所以他们必须有种关联，这种关联就是如上图所示，终端Token+设备Id得到的哈希值即数据库Token本身。&lt;/p&gt;
&lt;p&gt;        可以看出，整个生成过程是单向不可逆的，验证也只能是单向验证，所以生成关系是这样的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.processon.com/view/link/5cdbcf56e4b0f34230cd3066&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;授权Token构建关系图&quot; src=&quot;http://assets.processon.com/chart_image/5cdbcf56e4b005286482c890.png&quot; alt=&quot;授权Token构建关系图&quot; width=&quot;348&quot; height=&quot;356&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;授权Token构建关系图&lt;/p&gt;

&lt;p&gt;        这里有几点要注意的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;终端Token应该有足够的长度，且每次应随机生成，因此才有Guid.NewGuid()参与求值&lt;/li&gt;
&lt;li&gt;终端Token参与生成的userId、name和inputPassword是起到了盐作用，让整个构建更加复杂&lt;/li&gt;
&lt;li&gt;不论是终端Token还是数据库Token都不应该可逆加密处理任何内容，因为可解密的话不论是终端还是数据库数据泄露的，都有被破解的风险，所以用哈希求值是最合适的&lt;/li&gt;
&lt;li&gt;构建数据库Token有deviceId参与，这样每次Token就只能是对应的deviceId才能被验证，这样就起了绑定作用。除了deviceId还可以绑定其他场景相关的，比如IP地址、终端类型&lt;/li&gt;
&lt;li&gt;日志最好不要记录任何Token&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        两部分Token构建好之后，终端Token将被返回给终端，数据库Token持久化到服务端中。终端和数据库都要将各自的Token和场景信息持久化，Demo里面终端Token和deviceId放到了Cookie中。每次请求的终端都需要提交终端Token和绑定用的场景信息(deviceId)，因为验证的时候数据库Token保存的是由它们哈希过来的值，因此验证的时候也是使用一样的构建过程（即Demo里面的BuildDatabaseToken方法），这样终端Token和数据库Token就有了对应关系。得到数据库Token就能在数据库里面查找了（即上图的loginTokenRepository.FindUser方法）。Demo的验证页面是Home/Index，里面使用了过滤器CheckLoginTokenActionFilterAttribute做验证，在需要验证的Controller或Action上做ServiceFilter属性标记处理即可。&lt;/p&gt;
&lt;p&gt;        这里有几点要注意的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果使用Http做接口且有App接入，不方便地支持Cookie机制的话可以改为放在请求头中&lt;/li&gt;
&lt;li&gt;如果使用Http且为Web浏览器，终端Token保存的Cookie应该设为HttpOnly，让JS不可触碰&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        到这里童鞋们知道为什么Token拆成两部分了吗？整个Token授权过程是单向不可逆的，而且每个用户都有自己的哈希盐来生成Token，这样能避免哈希值被批量暴力破解，即使终端Token和数据库Token都泄露了你也对应不上。试想一下如果不是这样而是终端数据库的Token是相同的，那一旦数据库泄露那么黑客就能模拟Token进行登录/授权了。另外数据库Token哈希过后长度变短，查询性能也能提高，毕竟每个请求都需要进行验证，查询频率是很高的。&lt;/p&gt;
&lt;p id=&quot;acp5&quot;&gt; &lt;/p&gt;

&lt;h2&gt;五、Token失效与登录唯一性&lt;/h2&gt;
&lt;p&gt;        不论是终端Token还是服务端Token都要有失效机制，时间越短越安全，但也要结合使用场景需求来设定时长。终端Token如果是Cookie的话直接用Cookie的过期时间即可，并且要和数据库Token的过期时间一致。数据库Token生成的时候也要指定过期时间，Demo里面数据库保存的字段为ExpireAt。一般有以下几种失效情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;到了过期时间&lt;/li&gt;
&lt;li&gt;用户修改账户关键信息，服务端需要主动将旧的Token全部作废掉，如修改密码&lt;/li&gt;
&lt;li&gt;用户注销登录&lt;/li&gt;
&lt;li&gt;用户使用Token刷新机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        另外，如果需求是只能一种终端一个登录，比如Web和App可以保持同时登录但App只能有一个登录，数据库Token还得绑定“终端类型”，这样在最新一次登录的时候把相同的终端类型的旧的数据库Token全部作废掉就好了。&lt;/p&gt;
&lt;p&gt;        可以看出，服务端的保有的数据库Token可以有效控制其授权，达到访问控制的目的。&lt;/p&gt;
&lt;p id=&quot;acp6&quot;&gt; &lt;/p&gt;

&lt;h2&gt;六、CAS/SSO单点登录&lt;/h2&gt;
&lt;p&gt;        CAS即中央认证服务，SSO即单点登录。很多时候这两个会放在一起说，其实CAS是一套解决方案，SSO是一种机制描述。如果我们使用的是Http-Web那么我们如何实现我们自己的SSO呢？很简单，把Token和绑定的场景信息提升到同一个域下即可。比如有总部和门店两个系统分别使用了hq.xxxx.com/store.xxxx.com子域名，那不管从哪个系统登录，login_token和deviceId这两个Cookie放在顶级域.xxxx.com下即可，这样所有子系统都能访问得到它们，继而都保有登录/授权状态。有没有发现登录新浪微博后，输入weibo.com都会先跳转到sso然后再跳转回来，这个也差不多，这也是为什么你登录了新浪微博，你新浪博客也是登录了的状态。&lt;/p&gt;
&lt;p id=&quot;acp7&quot;&gt; &lt;/p&gt;

&lt;h2&gt;七、URL授权验证与扫码登录&lt;/h2&gt;
&lt;p&gt;        当我们需要进行邮箱验证的时候，有可能是用户登录和邮箱不是一个终端的，这时候我们就需要进行URL授权验证来避免用户再次进行登录。其原理很简单，在用户点击验证的链接上面附上URL授权令牌即可（下面简称URL Token），这个URL Token与登录Token不应该有关系所以应当单独保存。生成一个URL Token，服务端再对应保存类似的服务端Token，这样就有了【URL Token】 - 【服务端Token】 - 【用户】这样的对应关系。当用户在有效期内点击后，服务端获得URL Token也就能进行授权或验证。&lt;/p&gt;
&lt;p&gt;        扫码登录的场景复杂一些，终端生成的二维码其实就是一个Token（我们称之为QR Token）这个Token是和终端绑定的。用户拿App扫了QR码，其实就是在App内同时提交QR Token和用户信息，用户确认可以登录后服务端会颁发登录Token给终端，这样终端就是登录状态了，这一步也就是上面构建和验证登录Token的过程。实际扫码登录需要实现即时通讯，这样终端才能做出相应的反应。另外QR Token也是一样有过期时间的，因此那些扫码登录的页面会做二维码自动刷新的。&lt;/p&gt;
&lt;p id=&quot;acp8&quot;&gt; &lt;/p&gt;

&lt;h2&gt;八、Session实现&lt;/h2&gt;
&lt;p&gt;        其实有些童鞋会纳闷，完善的框架都会提供Session操作，其原理是一样的，那为什么我们还这么“造作”呢？原因有二，框架自带的可能过重，比如我就很不喜欢asp.net自带的授权认证机制，微软弄得一套一套的，简直就是全家桶，笨重，自己实现一个能定制化且轻量。第二，考虑类似上面的功能实现，自己做能更灵活地实现。&lt;/p&gt;
&lt;p&gt;        我们已经实现了登录/授权和验证，接下来我们只要想办法把一些数据和Token绑定在一起，并放在缓存中，这些数据就是Session了。我一般的做法是封装一个SessionService，然后定义一套Session接口。一个Session数据由TokenKey-Value组成，如果Token失效，则清理所有对应的TokenKey数据即可。就是这么简单粗暴，不同的缓存组件实现不尽相同。&lt;/p&gt;
&lt;p id=&quot;acp9&quot;&gt; &lt;/p&gt;

&lt;h2&gt;九、关于Token刷新&lt;/h2&gt;
&lt;p&gt;        OAuth 2.0里面有提供Token刷新服务，即终端持有的Token快过期的时候，终端可以再调用刷新接口来替换快过期的Token，达到永续状态。简单来说就是请求新的Token，请求时旧Token作废掉，实现并不复杂，参见：&lt;a href=&quot;https://www.cnblogs.com/blowing00/p/4524132.html&quot; target=&quot;_blank&quot;&gt;Oauth2.0（三）：Access Token 与 Refresh Token&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;acp10&quot;&gt; &lt;/p&gt;

&lt;h2&gt;十、防重放攻击与签名机制&lt;/h2&gt;
&lt;p&gt;        重放攻击(Replay Attacks)又叫重播攻击，防范这个其实和本文讨论的主题没关系。完整实现的接口都有实现，欲知详情，等我下一篇。&lt;/p&gt;

&lt;p&gt;        花了好几天来写了这篇文章，同时也是自己对这一技术点的总结归纳，有不对的地方还请指正。&lt;/p&gt;

&lt;p&gt;相关链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dudu/p/4578511.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Web API与Owin OAuth：调用与用户相关的Web API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140183&quot; target=&quot;_blank&quot;&gt;微信公众平台技术文档 - 获取access_token&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 11:56:00 +0000</pubDate>
<dc:creator>朝野布告</dc:creator>
<og:description>本篇文章将从无到完整的登录框架或API详细讲述登录令牌原理、攻略等安全点。 有些协议或框架也喜欢把令牌叫票据（Ticket），不论是APP还是Web浏览器，很多框架或协议都用到了本文所说的这套类似的认</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangsheng/p/10736796.html</dc:identifier>
</item>
<item>
<title>程序员笔记|详解Eureka 缓存机制 - 宜信技术</title>
<link>http://www.cnblogs.com/yixinjishu/p/10871243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yixinjishu/p/10871243.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;Eureka是Netflix开源的、用于实现服务注册和发现的服务。Spring Cloud Eureka基于Eureka进行二次封装，增加了更人性化的UI，使用更为方便。但是由于Eureka本身存在较多缓存，服务状态更新滞后，最常见的状况是：服务下线后状态没有及时更新，服务消费者调用到已下线的服务导致请求失败。&lt;strong&gt;本文基于Spring Cloud Eureka 1.4.4.RELEASE，在默认region和zone的前提下，介绍Eureka的缓存机制。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;一、AP特性&lt;/h2&gt;
&lt;p&gt;从CAP理论看，Eureka是一个AP系统，优先保证可用性(A)和分区容错性(P)，不保证强一致性(C)，只保证最终一致性，因此在架构中设计了较多缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/yixinjishu/p/eureka高可用架构.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1682023/201905/1682023-20190515181538167-1697735305.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;center&gt;Eureka高可用架构&lt;/center&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;二、服务状态&lt;/h2&gt;
&lt;p&gt;Eureka服务状态enum类：&lt;code&gt;com.netflix.appinfo.InstanceInfo.InstanceStatus&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;UP&lt;/td&gt;
&lt;td&gt;在线&lt;/td&gt;
&lt;td&gt;OUT_OF_SERVICE&lt;/td&gt;
&lt;td&gt;失效&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DOWN&lt;/td&gt;
&lt;td&gt;下线&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;STARTING&lt;/td&gt;
&lt;td&gt;正在启动&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;toc_4&quot;&gt;三、Eureka Server&lt;/h2&gt;
&lt;p&gt;在Eureka高可用架构中，Eureka Server也可以作为Client向其他server注册，多节点相互注册组成Eureka集群，集群间相互视为peer。Eureka Client向Server注册、续约、更新状态时，接受节点更新自己的服务注册信息后，逐个同步至其他peer节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt;如果server-A向server-B节点单向注册，则server-A视server-B为peer节点，server-A接受的数据会同步给server-B，但server-B接受的数据不会同步给server-A。&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;3.1 缓存机制&lt;/h3&gt;
&lt;p&gt;Eureka Server存在三个变量：(&lt;strong&gt;registry、readWriteCacheMap、readOnlyCacheMap&lt;/strong&gt;)保存服务注册信息，默认情况下定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，每60s清理超过90s未续约的节点，Eureka Client每30s从readOnlyCacheMap更新服务注册信息，而UI则从registry更新服务注册信息。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1682023/201905/1682023-20190515181628501-1020024778.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三级缓存&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;缓存&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;registry&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ConcurrentHashMap&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;实时更新&lt;/strong&gt;，类AbstractInstanceRegistry成员变量，UI端请求的是这里的服务注册信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;readWriteCacheMap&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Guava Cache/LoadingCache&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;实时更新&lt;/strong&gt;，类ResponseCacheImpl成员变量，缓存时间180秒&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;readOnlyCacheMap&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ConcurrentHashMap&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;周期更新&lt;/strong&gt;，类ResponseCacheImpl成员变量，默认每&lt;strong&gt;30s&lt;/strong&gt;从readWriteCacheMap更新，Eureka client默认从这里更新服务注册信息，可配置直接从readWriteCacheMap更新&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;缓存相关配置&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置&lt;/th&gt;
&lt;th&gt;默认&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;eureka.server.useReadOnlyResponseCache&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;Client从&lt;strong&gt;readOnlyCacheMap&lt;/strong&gt;更新数据，false则跳过readOnlyCacheMap直接从readWriteCacheMap更新&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;eureka.server.responsecCacheUpdateIntervalMs&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;30000&lt;/td&gt;
&lt;td&gt;readWriteCacheMap更新至readOnlyCacheMap周期，默认&lt;strong&gt;30s&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;eureka.server.evictionIntervalTimerInMs&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;60000&lt;/td&gt;
&lt;td&gt;清理未续约节点(evict)周期，默认&lt;strong&gt;60s&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;eureka.instance.leaseExpirationDurationInSeconds&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;90&lt;/td&gt;
&lt;td&gt;清理未续约节点超时时间，默认&lt;strong&gt;90s&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;关键类&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;com.netflix.eureka.registry.AbstractInstanceRegistry&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;保存服务注册信息，持有registry和responseCache成员变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;com.netflix.eureka.registry.ResponseCacheImpl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;持有readWriteCacheMap和readOnlyCacheMap成员变量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;toc_6&quot;&gt;四、Eureka Client&lt;/h2&gt;
&lt;p&gt;Eureka Client存在两种角色：&lt;strong&gt;服务提供者&lt;/strong&gt;和&lt;strong&gt;服务消费者&lt;/strong&gt;，作为服务消费者一般配合Ribbon或Feign（Feign内部使用Ribbon）使用。Eureka Client启动后，作为服务提供者立即向Server注册，默认情况下每30s续约(renew)；作为服务消费者立即向Server全量更新服务注册信息，默认情况下每30s增量更新服务注册信息；Ribbon延时1s向Client获取使用的服务注册信息，默认每30s更新使用的服务注册信息，只保存状态为UP的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二级缓存&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;缓存&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;localRegionApps&lt;/td&gt;
&lt;td&gt;AtomicReference&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;周期更新&lt;/strong&gt;，类DiscoveryClient成员变量，Eureka Client保存服务注册信息，启动后立即向Server全量更新，默认每&lt;strong&gt;30s&lt;/strong&gt;增量更新&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;upServerListZoneMap&lt;/td&gt;
&lt;td&gt;ConcurrentHashMap&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;周期更新&lt;/strong&gt;，类LoadBalancerStats成员变量，Ribbon保存使用且状态为&lt;strong&gt;UP&lt;/strong&gt;的服务注册信息，启动后延时1s向Client更新，默认每&lt;strong&gt;30s&lt;/strong&gt;更新&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;缓存相关配置&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置&lt;/th&gt;
&lt;th&gt;默认&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;eureka.instance.leaseRenewalIntervalInSeconds&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;Eureka Client 续约周期，默认&lt;strong&gt;30s&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;eureka.client.registryFetchIntervalSeconds&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;Eureka Client 增量更新周期，默认&lt;strong&gt;30s&lt;/strong&gt;（正常情况下增量更新，超时或与Server端不一致等情况则全量更新）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;ribbon.ServerListRefreshInterval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;30000&lt;/td&gt;
&lt;td&gt;Ribbon 更新周期，默认&lt;strong&gt;30s&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;关键类&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;com.netflix.discovery.DiscoveryClient&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Eureka Client 负责注册、续约和更新，方法initScheduledTasks()分别初始化续约和更新定时任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;com.netflix.loadbalancer.PollingServerListUpdater&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Ribbon 更新使用的服务注册信息，start初始化更新定时任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;com.netflix.loadbalancer.LoadBalancerStats&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Ribbon，保存使用且状态为&lt;strong&gt;UP&lt;/strong&gt;的服务注册信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;toc_7&quot;&gt;五、默认配置下服务消费者最长感知时间&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Eureka Client&lt;/th&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;上线&lt;/td&gt;
&lt;td&gt;30(readOnly)+30(Client)+30(Ribbon)=&lt;strong&gt;90s&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;readWrite -&amp;gt; readOnly -&amp;gt; Client -&amp;gt; Ribbon 各30s&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;正常下线&lt;/td&gt;
&lt;td&gt;30(readonly)+30(Client)+30(Ribbon)=&lt;strong&gt;90s&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;服务正常下线（kill或kill -15杀死进程）会给进程善后机会，DiscoveryClient.shutdown()将向Server更新自身状态为DOWN，然后发送DELETE请求注销自己，registry和readWriteCacheMap实时更新，故UI将不再显示该服务实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;非正常下线&lt;/td&gt;
&lt;td&gt;30+60(evict)*2+30+30+30=&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;240s&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;服务非正常下线（kill -9杀死进程或进程崩溃）不会触发DiscoveryClient.shutdown()方法，Eureka Server将依赖每60s清理超过90s未续约服务从registry和readWriteCacheMap中删除该服务实例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;考虑如下情况&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0s时服务未通知Eureka Client直接下线；&lt;/li&gt;
&lt;li&gt;29s时第一次过期检查evict未超过90s；&lt;/li&gt;
&lt;li&gt;89s时第二次过期检查evict未超过90s；&lt;/li&gt;
&lt;li&gt;149s时第三次过期检查evict未续约时间超过了90s，故将该服务实例从registry和readWriteCacheMap中删除；&lt;/li&gt;
&lt;li&gt;179s时定时任务从readWriteCacheMap更新至readOnlyCacheMap;&lt;/li&gt;
&lt;li&gt;209s时Eureka Client从Eureka Server的readOnlyCacheMap更新；&lt;/li&gt;
&lt;li&gt;239s时Ribbon从Eureka Client更新。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，极限情况下服务消费者最长感知时间将无限趋近240s。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1682023/201905/1682023-20190515181644541-708901006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://www.cnblogs.com/yixinjishu/p/最长感知时间.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;h2 id=&quot;toc_8&quot;&gt;六、应对措施&lt;/h2&gt;
&lt;p&gt;服务注册中心在选择使用Eureka时说明已经接受了其优先保证可用性(A)和分区容错性(P)、不保证强一致性(C)的特点。如果需要优先保证强一致性(C)，则应该考虑使用ZooKeeper等CP系统作为服务注册中心。分布式系统中一般配置多节点，单个节点服务上线的状态更新滞后并没有什么影响，这里主要考虑服务下线后状态更新滞后的应对措施。&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;6.1 Eureka Server&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1.&lt;strong&gt;缩短readOnlyCacheMap更新周期&lt;/strong&gt;。缩短该定时任务周期可减少滞后时间。&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
eureka.server.responsecCacheUpdateIntervalMs: &lt;span&gt;10000&lt;/span&gt;  # Eureka Server readOnlyCacheMap更新周期
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.&lt;strong&gt;关闭readOnlyCacheMap&lt;/strong&gt;。中小型系统可以考虑该方案，Eureka Client直接从readWriteCacheMap更新服务注册信息。&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
eureka.server.useReadOnlyResponseCache: &lt;span&gt;false&lt;/span&gt;        # 是否使用readOnlyCacheMap
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_10&quot;&gt;6.2 Eureka Client&lt;/h3&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;1.&lt;strong&gt;服务消费者使用容错机制&lt;/strong&gt;。如Spring Cloud Retry和Hystrix，Ribbon、Feign、Zuul都可以配置Retry，服务消费者访问某个已下线节点时一般报ConnectTimeout，这时可以通过Retry机制重试下一个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.&lt;strong&gt;服务消费者缩短更新周期&lt;/strong&gt;。Eureka Client和Ribbon二级缓存影响状态更新，缩短这两个定时任务周期可减少滞后时间，例如配置：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
eureka.client.registryFetchIntervalSeconds: &lt;span&gt;5&lt;/span&gt;&lt;span&gt;        # Eureka Client更新周期
ribbon.ServerListRefreshInterval: &lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;               # Ribbon更新周期
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;3.&lt;strong&gt;服务提供者保证服务正常下线&lt;/strong&gt;。服务下线时使用kill或kill -15命令，避免使用kill -9命令，kill或kill -15命令杀死进程时将触发Eureka Client的shutdown()方法，主动删除Server的registry和readWriteCacheMap中的注册信息，不必依赖Server的evict清除。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;4.&lt;strong&gt;服务提供者延迟下线&lt;/strong&gt;。服务下线之前先调用接口使Eureka Server中保存的服务状态为DOWN或OUT_OF_SERVICE后再下线，二者时间差根据缓存机制和配置决定，比如默认情况下调用接口后延迟90s再下线服务即可保证服务消费者不会调用已下线服务实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_11&quot;&gt;七、网关实现服务下线实时感知&lt;/h2&gt;
&lt;p&gt;在软件工程中，没有一个问题是中间层解决不了的，而网关是服务提供者和服务消费者的中间层。以Spring Cloud Zuul网关为例，网关作为Eureka Client保存了服务注册信息，服务消费者通过网关将请求转发给服务提供者，只需要做到服务提供者下线时通知网关在自己保存的服务列表中使该服务失效。为了保持网关的独立性，可实现一个独立服务接收下线通知并协调网关集群。&lt;strong&gt;下篇文章将详细介绍网关如何实现服务下线实时感知&lt;/strong&gt;，敬请期待！&lt;/p&gt;
&lt;p&gt;作者：冯永彪&lt;/p&gt;
&lt;p&gt;内容来源：&lt;a href=&quot;http://college.creditease.cn/&quot;&gt;宜信技术学院&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 10:19:00 +0000</pubDate>
<dc:creator>宜信技术</dc:creator>
<og:description>本文基于Spring Cloud Eureka 1.4.4.RELEASE，在默认region和zone的前提下，介绍Eureka的缓存机制。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yixinjishu/p/10871243.html</dc:identifier>
</item>
<item>
<title>Vue.js 源码实现 - dora_zc</title>
<link>http://www.cnblogs.com/dora-zc/p/10871026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dora-zc/p/10871026.html</guid>
<description>&lt;h2 id=&quot;vue.js-代码实现&quot;&gt;Vue.js 代码实现&lt;/h2&gt;
&lt;p&gt;检验学习效果的最好方法就是自己造轮子。最近在学习Vue源码，写了一个迷你版vue，实现数据响应式。从step1到step3.2，是开发步骤和实现思路，每一步都可以独立运行。&lt;/p&gt;
&lt;p&gt;代码地址：https://github.com/dora-zc/miniature-vue&lt;/p&gt;
&lt;p&gt;目录结构&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;├── README.md&lt;/p&gt;
&lt;p&gt;├── step0&lt;/p&gt;
&lt;p&gt;│ └── defineProperty_test.html&lt;/p&gt;
&lt;p&gt;├── step1&lt;/p&gt;
&lt;p&gt;│ ├── XVue.js&lt;/p&gt;
&lt;p&gt;│ └── index.html&lt;/p&gt;
&lt;p&gt;├── step2&lt;/p&gt;
&lt;p&gt;│ ├── XVue.js&lt;/p&gt;
&lt;p&gt;│ └── index.html&lt;/p&gt;
&lt;p&gt;├── step3.1&lt;/p&gt;
&lt;p&gt;│ ├── XVue.js&lt;/p&gt;
&lt;p&gt;│ ├── compile.js&lt;/p&gt;
&lt;p&gt;│ └── index.html&lt;/p&gt;
&lt;p&gt;└── step3.2&lt;/p&gt;
&lt;p&gt;​ ├── XVue.js&lt;/p&gt;
&lt;p&gt;​ ├── compile.js&lt;/p&gt;
&lt;p&gt;​ └── index.html&lt;/p&gt;
&lt;p&gt;以上每个step文件夹对应下面的每一步骤，代表了代码实现的顺序，每个文件夹下的代码都可以独立运行。&lt;/p&gt;
&lt;h3 id=&quot;步骤一&quot;&gt;1. 步骤一&lt;/h3&gt;
&lt;p&gt;创建XVue.js。&lt;/p&gt;
&lt;p&gt;创建Vue类，通过Observer劫持监听所有属性。&lt;/p&gt;
&lt;p&gt;observe函数的作用：递归遍历data选项，它当中的defineReactive函数为data中每一个key定义getter和setter，达到数据劫持的目的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;步骤一对应代码目录：step1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;步骤二&quot;&gt;2. 步骤二&lt;/h3&gt;
&lt;p&gt;处理页面上的&lt;code&gt;&amp;lt;div&amp;gt;{{msg}}&amp;lt;/div&amp;gt;&lt;/code&gt;，也就是收集依赖，当msg的值发生变化时，视图需要做出相应的变化。因此需要创建依赖管理器，把所有依赖保存起来，当数据发生变化的时候再去更新对应的依赖。&lt;/p&gt;
&lt;h4 id=&quot;创建dep类&quot;&gt;2.1 创建Dep类&lt;/h4&gt;
&lt;p&gt;Dep负责将视图中的所有依赖收集管理，包括依赖添加和派发通知&lt;/p&gt;
&lt;p&gt;1- 在Dep类中创建数组deps=[]，用来存放Watcher的实例&lt;/p&gt;
&lt;p&gt;2-创建addDep方法，添加Watcher&lt;/p&gt;
&lt;p&gt;3-创建notify方法，通知所有的Wather执行更新。遍历deps数组，调用每个Wather的更新方法&lt;/p&gt;
&lt;h4 id=&quot;创建监听器watcher类&quot;&gt;2.2 创建监听器Watcher类&lt;/h4&gt;
&lt;p&gt;Watcher是具体的更新执行者。&lt;/p&gt;
&lt;p&gt;1-将当前Watcher实例添加到Dep.target上。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Dep.target = this&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后在get时，就能通过Dep.target拿到当前Watcher的实例。&lt;/p&gt;
&lt;p&gt;2-创建update方法&lt;/p&gt;
&lt;p&gt;3-set方法中，调用dep.notify，让依赖管理器通知更新，则所有的Watcher会执行update方法&lt;/p&gt;
&lt;p&gt;那么问题来了：Watcher在什么时候收集最合适？&lt;/p&gt;
&lt;p&gt;在defineReactive函数的get方法中，get方法触发时，把Watcher放进Dep.target中。&lt;/p&gt;
&lt;p&gt;那么问题又来了：为什么是在get方法中呢？&lt;/p&gt;
&lt;p&gt;因为在扫描视图中的依赖时，如果扫描到&lt;code&gt;&amp;lt;div&amp;gt;{{msg}}&amp;lt;/div&amp;gt;&lt;/code&gt;，此时一定会去访问msg的值，就会触发get。一旦get被触发，就能将Watcher放进dep中，实现依赖收集的目的。所以get是一个合适的时间点。&lt;/p&gt;
&lt;p&gt;代码测试：在get中输出dep.deps，如果Watcher已经放进去了，并且控制台打印出Watcher中的update方法中的log，说明这一步操作成功了。&lt;/p&gt;
&lt;p&gt;至此，已经完成的工作如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1449188/201905/1449188-20190515174412795-51996149.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;步骤二对应代码目录：step2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，Watcher发生变化时，视图还没有更新，下面我们将要完成视图更新的操作。&lt;/p&gt;
&lt;p&gt;首先，需要Compile对界面模板解析指令，进行编译，编译的阶段实际是创建Watcher的阶段。Watcher是由编译器创建的。编译器在做依赖收集的时候，顺便把Watcher创建了。Watcher在创建的时候，立刻就能知道它将来要更新的是谁，它应该被谁管理，它发生变化以后值应该是什么。于是Watcher就知道调谁(Updater去做更新了)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1449188/201905/1449188-20190515174427159-1081047437.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;步骤三&quot;&gt;3.步骤三&lt;/h3&gt;
&lt;p&gt;创建compile.js,用于扫描模板中所有依赖(指令、插值、绑定、事件…)，创建更新函数和Watcher&lt;/p&gt;
&lt;h4 id=&quot;扫描模板&quot;&gt;3.1 扫描模板&lt;/h4&gt;
&lt;p&gt;1-创建编译器Compile类，接收两个参数，el(宿主元素或选择器)和vm(当前vue实例)&lt;/p&gt;
&lt;p&gt;2-创建node2Fragment函数，将dom节点( $el )截成代码块( 转换为Fragment )来处理，而不是直接做dom操作，提高执行效率&lt;/p&gt;
&lt;p&gt;3-创建compile函数，执行编译( 将模板中的动态值替换为真实的值 )，传入代码块&lt;/p&gt;
&lt;p&gt;4-将生成的结果追加至宿主元素&lt;/p&gt;
&lt;h5 id=&quot;node2fragment函数&quot;&gt;3.1.1 node2Fragment函数&lt;/h5&gt;
&lt;p&gt;创建一个新的fragment，将原生节点移动至fragment&lt;/p&gt;
&lt;p&gt;返回fragment，传给编译函数进行编译&lt;/p&gt;
&lt;h5 id=&quot;compile函数&quot;&gt;3.1.2 compile函数&lt;/h5&gt;
&lt;p&gt;获取所有的孩子节点，进行遍历，判断节点类型，并作出相应的判断&lt;/p&gt;
&lt;p&gt;处理元素节点&lt;/p&gt;
&lt;p&gt;处理文本节点( 只处理{{msg}} 这种情况，其他的全部不处理)&lt;/p&gt;
&lt;p&gt;...其他的节点类型暂时不判断了&lt;/p&gt;
&lt;p&gt;遍历可能存在的子节点，往下递归&lt;/p&gt;
&lt;p&gt;下面是compile函数中的两个核心方法&lt;/p&gt;
&lt;p&gt;1-compileElement方法：编译元素节点&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div v-text=&quot;test&quot; @click=&quot;onClick&quot;&amp;gt;{{msg}}&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到所有属性名称，进行遍历&lt;/p&gt;
&lt;p&gt;2-compileText方法：编译文本节点&lt;/p&gt;
&lt;p&gt;代码测试：&lt;/p&gt;
&lt;p&gt;在XVue constructor中，创建编译器实例，将宿主元素el和当前vue实例作为参数传入。&lt;/p&gt;
&lt;p&gt;如果compileElement和compileText两个函数能触发，控制台打印出&quot;开始编译元素节点&quot;和&quot;开始编译文本节点&quot;，则说明功能正常，可以继续让下走了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对应代码：step3.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;编译元素节点和文本节点并创建更新函数&quot;&gt;3.2 编译元素节点和文本节点，并创建更新函数&lt;/h4&gt;
&lt;h5 id=&quot;编译元素节点compileelement方法实现&quot;&gt;3.2.1 编译元素节点compileElement方法实现&lt;/h5&gt;
&lt;p&gt;获取节点所有属性，进行遍历。判断指令和事件，已经相应的处理方法。&lt;/p&gt;
&lt;p&gt;指令只试着处理v-text，v-html，v-model三个，其他的暂不处理&lt;/p&gt;
&lt;p&gt;v-model：双向绑定还需要处理视图对模型的更新&lt;/p&gt;
&lt;h5 id=&quot;创建更新器函数&quot;&gt;3.2.2 创建更新器函数&lt;/h5&gt;
&lt;p&gt;更新器函数：接收四个参数，node，vm，exp，dir(指令)&lt;/p&gt;
&lt;p&gt;针对指令的更新器主要是在做dom操作&lt;/p&gt;
&lt;p&gt;在更新器函数中创建Watcher实例，当Watcher监听到变化的时候，就能触发视图的更新。&lt;/p&gt;
&lt;p&gt;至此，全部代码已经完成，双向数据绑定顺利实现！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1449188/201905/1449188-20190515174457824-684866078.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对应代码：step3.2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;vue.js-工作机制&quot;&gt;Vue.js 工作机制&lt;/h2&gt;
&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;p&gt;在new Vue()之后，Vue会调用初始化函数，会初始化声明周期、事件、props、methods、data、computed和watcher等。其中最重要的是通过Object.defineProperty设置setter和getter，用来实现响应式和依赖收集。&lt;/p&gt;
&lt;p&gt;初始化之后会调用$.mount挂载组件。&lt;/p&gt;
&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;
&lt;p&gt;编译模块分为三个阶段：&lt;/p&gt;
&lt;h4 id=&quot;parse&quot;&gt;1-parse&lt;/h4&gt;
&lt;p&gt;使用正则解析模板中的vue的指令、变量等等，形成抽象语法树AST&lt;/p&gt;
&lt;h4 id=&quot;optimize&quot;&gt;2-optimize&lt;/h4&gt;
&lt;p&gt;标记一些静态节点，用作后面的性能优化，在diff的时候直接略过&lt;/p&gt;
&lt;h4 id=&quot;generate&quot;&gt;3-generate&lt;/h4&gt;
&lt;p&gt;把第一步生成的AST转化为渲染函数 render function&lt;/p&gt;
&lt;h3 id=&quot;响应式&quot;&gt;响应式&lt;/h3&gt;
&lt;p&gt;这一块是vue最核心的内容。初始化的时候通过defineProperty进行绑定，设置通知的机制，当编译生成的渲染函数被实际渲染的时候，会触发getter进行依赖收集，在数据变化的时候，触发setter进行更新。&lt;/p&gt;
&lt;h3 id=&quot;虚拟dom&quot;&gt;虚拟dom&lt;/h3&gt;
&lt;p&gt;虚拟dom是由react首创，Vue2开始支持，就是用JavaScript对象来描述dom结构，数据修改的时候，我们先修改虚拟dom中的数据，然后数组做diff算法，最后再汇总所有的diff，力求做最少的dom操作，毕竟js里对比很快，而真实的dom操作太慢了。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div name=&quot;小菠萝&quot; style=&quot;color:red&quot; @click=&quot;xx&quot;&amp;gt;
   &amp;lt;a&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// vdom
{
   tag:'div',
   props:{
      name:'小菠萝',
      style: {color:red},
      onClick:xx
   },
   children:[
      {
        tag:'a',
        text:'click me'
      }
   ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更新视图&quot;&gt;更新视图&lt;/h3&gt;
&lt;p&gt;数据修改触发setter，然后监听器会通知进行修改，通过对比两个dom树，得到改变的地方，就是patch，然后只需要把这些差异修改即可。&lt;/p&gt;
&lt;h3 id=&quot;编译-1&quot;&gt;编译&lt;/h3&gt;
&lt;p&gt;compile的核心逻辑是获取dom，遍历dom，获取{{}}格式的变量，以及每个dom的属性，截取v-和@开头的部分来设置响应式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1449188/201905/1449188-20190515174512116-1442763241.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 09:45:00 +0000</pubDate>
<dc:creator>dora_zc</dc:creator>
<og:description>[TOC] Vue.js 代码实现 检验学习效果的最好方法就是自己造轮子。最近在学习Vue源码，写了一个迷你版vue，实现数据响应式。从step1到step3.2，是开发步骤和实现思路，每一步都可以独</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dora-zc/p/10871026.html</dc:identifier>
</item>
<item>
<title>Vue中使用jquery - 前端填坑之旅</title>
<link>http://www.cnblogs.com/cazj/p/10870624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cazj/p/10870624.html</guid>
<description>&lt;p&gt;&lt;span&gt;在vue项目中，需要实现某些特定的功能时，使用mvvm模式不易实现。因此引入jquery包来完成需求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jquery中的触发事件可以自己定义在mounted中，如果需要使用vue中data的数据，直接使用this.msg是无法使用的，需要另外定义const _this = this,&lt;/p&gt;
&lt;p&gt;存储this.之后便可以在事件中使用_this.msg数据了。&lt;/p&gt;

&lt;p&gt;需求：在品牌处可以输入，并且会有模糊搜索的下拉框，也可下拉选择，在输入完毕后检验值是否在下拉框中存在，聚焦时蓝色边框，change时如果不存在则红框显示，存在的话就绿框提示，（就是带输入建议的输入框）&lt;/p&gt;
&lt;p&gt;问题： 使用element-ui中的el-autocomplete组件，开始通过失焦事件来验证，但是如果选择了下拉框某个值时（选中后会将下拉框的值赋给上面的输入框），&lt;span&gt;失焦事件触发会在赋值之前&lt;/span&gt;，因此拿失焦时输入框的值来进行判断时错误的，在先改变输入框的值后再去选择下拉框,change事件有同样的bug，没办法只能自己引入jquery来完成&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1631381/201905/1631381-20190515154738203-426650277.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1631381/201905/1631381-20190515155914208-1439220041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击输入框后，通过placeholder判断是否是品牌下的的输入框，因为每个输入框都有这个类，如果是的话则增加一个类名，如果第一次点击的位置和第二次鼠标点击的位置都是品牌下的输入框，则执行相应的逻辑判断,&lt;/p&gt;
&lt;p&gt;在逻辑执行完后就删除其他处同样的类名inputList&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const _this = this &lt;br/&gt;$('body').delegate('.el-input__inner', 'focus', &lt;span&gt;function&lt;/span&gt;(e) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为是动态生成的，所以选择这种方式来监听事件&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (e.target.placeholder === '请输入品牌') { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当聚焦在品牌输入框时触发&lt;/span&gt;
        $(&lt;span&gt;this&lt;/span&gt;).addClass('inputList') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加上一个类名inputList&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ($('.inputList').length === 2) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断下一次点击的位置，当从第一个输入框改值后下一个聚焦位置还是品牌下的输入框时&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (!$('.inputList').not(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).val()) {
            $(&lt;/span&gt;'.inputList').not(&lt;span&gt;this&lt;/span&gt;).css('border', '1px solid #67c23a'&lt;span&gt;)
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            let num &lt;/span&gt;= 0
            &lt;span&gt;for&lt;/span&gt; (let j = 0; j &amp;lt; _this.goodsBrands.length; j++&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($('.inputList').not(&lt;span&gt;this&lt;/span&gt;).val() ===&lt;span&gt; _this.goodsBrands[j].value) {
                num &lt;/span&gt;+= 1
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
              }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num === 0&lt;span&gt;) {
              _this.$message.error(&lt;/span&gt;'输入的品牌不在品牌列表中'&lt;span&gt;)
              $(&lt;/span&gt;'.inputList').not(&lt;span&gt;this&lt;/span&gt;).css('border', '1px solid #F56C6C'&lt;span&gt;)
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
              $(&lt;/span&gt;'.inputList').not(&lt;span&gt;this&lt;/span&gt;).css('border', '1px solid #67c23a'&lt;span&gt;)
            }
          }
        }

        $(&lt;/span&gt;'.el-input__inner').not(&lt;span&gt;this&lt;/span&gt;).removeClass('inputList') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 逻辑执行完之后删除当前聚焦位置以外的inputList类，这样就保持.inputList长度最多为2&lt;/span&gt;
&lt;span&gt;      }
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
此处是为了模拟出输入框的change事件，因为在聚焦时会添加inputList这个类名。所以这里可以判断是否是自己想要的位置，如果是的话给一个标志位getindex,当点击到品牌下的输入框时，如果第二次的点击位置不是品牌其他位置的输入框，则进行逻辑判断
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    $(document).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) { // focus触发时也会触发这个事件，并且触发在focus事件之后
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.target.classList[1] === 'inputList'&lt;span&gt;) { // 判断是否点击在对应位置
        _this.getIndex &lt;/span&gt;= 1  // 用于标志在聚焦事件触发后的下一次点击是否同样会触发聚焦，如果是则把第二次点击当成第一次重新判断，等到下一次点击再来判断&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_this.getIndex === 1&lt;span&gt;) { 
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!$('.inputList').eq(0&lt;span&gt;).val()) {
            $(&lt;/span&gt;'.inputList').eq(0).css('border', '1px solid #67c23a'&lt;span&gt;)
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            let num &lt;/span&gt;= 0
            &lt;span&gt;for&lt;/span&gt; (let j = 0; j &amp;lt; _this.goodsBrands.length; j++&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($('.inputList').eq(0).val() ===&lt;span&gt; _this.goodsBrands[j].value) {
                num &lt;/span&gt;+= 1
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
              }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num === 0&lt;span&gt;) {
              _this.$message.error(&lt;/span&gt;'输入的品牌不在品牌列表中'&lt;span&gt;)
              $(&lt;/span&gt;'.inputList').eq(0).css('border', '1px solid #F56C6C'&lt;span&gt;)
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
              $(&lt;/span&gt;'.inputList').eq(0).css('border', '1px solid #67c23a'&lt;span&gt;)
            }
          }
          $(&lt;/span&gt;'.el-input__inner').removeClass('inputList'&lt;span&gt;)
          _this.getIndex &lt;/span&gt;= 0 // 每次第二次点击了其他位置时，getIndex重新计数&lt;span&gt;
        }
      }
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;小白一枚，如果有其他更好的方法，欢迎各位同行指教，多多交流&lt;/p&gt;
&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 15 May 2019 09:02:00 +0000</pubDate>
<dc:creator>前端填坑之旅</dc:creator>
<og:description>在vue项目中，需要实现某些特定的功能时，使用mvvm模式不易实现。因此引入jquery包来完成需求 jquery中的触发事件可以自己定义在mounted中，如果需要使用vue中data的数据，直接使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cazj/p/10870624.html</dc:identifier>
</item>
</channel>
</rss>