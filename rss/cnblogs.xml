<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SLAM+语音机器人DIY系列：（六）SLAM建图与自主避障导航——2.google-cartographer机器人SLAM建图 - 小虎哥哥爱学习</title>
<link>http://www.cnblogs.com/hiram-zhang/p/10415865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiram-zhang/p/10415865.html</guid>
<description>&lt;p&gt;&lt;span&gt;通过前面的基础学习，本章进入最为激动的&lt;span&gt;机器人自主导航&lt;span&gt;的学习。在前面的学习铺垫后，终于迎来了最大乐趣的时刻，就是赋予我们的miiboo机器人能自由行走的生命。本章将围绕机器人SLAM建图、导航避障、巡航、监控等内容展开。本章内容：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.在机器人上使用传感器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.google-cartographer机器人SLAM建图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.ros-navigation机器人自主避障导航&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.多目标点导航及任务调度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.机器人巡航与现场监控&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;主流的激光&lt;/span&gt;SLAM&lt;span&gt;算法有&lt;/span&gt;&lt;span&gt;hector&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;gmapping&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;karto&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;hector&lt;span&gt;是一种结合了鲁棒性较好的扫描匹方法&lt;/span&gt;&lt;span&gt;2D_SLAM&lt;/span&gt;&lt;span&gt;方法和使用惯性传感系统的导航技术。传感器的要求较高，高更新频率小测量噪声的激光扫描仪，不需要里程计。使空中无人机与地面小车在不平坦区域运行存在运用的可能性。作者利用现代激光雷达的高更新率和低距离测量噪声，通过扫描匹配实时地对机器人运动进行估计。所以当只有低更新率的激光传感器时，即便测距估计很精确，对该系统都会出现一定的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;gmapping&lt;span&gt;是一种基于粒子滤波的激光&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;算法，它已经集成在&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;中，是移动机器人中使用最多的&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;算法。基于粒子滤波的算法用许多加权粒子表示路径的后验概率，每个粒子都给出一个重要性因子。但是，它们通常需要大量的粒子才能获得比较好的的结果，从而增加该算法的的计算复杂性。此外，与&lt;/span&gt;&lt;span&gt;PF&lt;/span&gt;&lt;span&gt;重采样过程相关的粒子退化耗尽问题也降低了算法的准确性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;karto&lt;span&gt;是基于图优化的&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;算法，用高度优化和非迭代&lt;/span&gt;&lt;span&gt;cholesky&lt;/span&gt;&lt;span&gt;矩阵进行稀疏系统解耦作为解。图优化方法利用图的均值表示地图，每个节点表示机器人轨迹的一个位置点和传感器测量数据集，箭头的指向的连接表示连续机器人位置点的运动，每个新节点加入，地图就会依据空间中的节点箭头的约束进行计算更新。路标&lt;/span&gt;&lt;span&gt;landmark&lt;/span&gt;&lt;span&gt;越多&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;内存需求越大&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;然而图优化方式相比其他方法在大环境下制图优势更大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cartographer&lt;span&gt;是&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;开发的实时室内&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;项目，&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;采用基于&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;自家开发的&lt;/span&gt;&lt;span&gt;ceres&lt;/span&gt;&lt;span&gt;非线性优化的方法，&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;的量点在于代码规范与工程化，非常适合于商业应用和再开发。并且&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;基于&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;子图构建全局地图的思想，能有效的避免建图过程中环境中移动物体的干扰。并且&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;支持多传感器数据（&lt;/span&gt;&lt;span&gt;odometry&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;LaserScan&lt;/span&gt;&lt;span&gt;等）建图，支持&lt;/span&gt;&lt;span&gt;2D_SLAM&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;3D_SLAM&lt;/span&gt;&lt;span&gt;建图。所以，我果断采用&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;来建图，我的树莓派&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;主板跑&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;实时建图是十分的流畅，这一点很欣慰&lt;/span&gt;&lt;span&gt;^_^&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.1.google-cartographer&lt;span&gt;建图算法原理分析&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cartographer&lt;span&gt;采用的是主流的&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;框架，也就是特征提取、闭环检测、后端优化的三段式。由一定数量的&lt;/span&gt;&lt;span&gt;LaserScan&lt;/span&gt;&lt;span&gt;组成一个&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;子图，一系列的&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;子图构成了全局地图。用&lt;/span&gt;&lt;span&gt;LaserScan&lt;/span&gt;&lt;span&gt;构建&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;的短时间过程累计误差不大，但是用&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;构建全局地图的长时间过程就会存在很大的累计误差，所以需要利用闭环检测来修正这些&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;的位置，闭环检测的基本单元是&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;，闭环检测采用&lt;/span&gt;&lt;span&gt;scan_match&lt;/span&gt;&lt;span&gt;策略。&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;的重点内容就是融合多传感器数据（&lt;/span&gt;&lt;span&gt;odometry&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;LaserScan&lt;/span&gt;&lt;span&gt;等）的&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;子图创建以及用于闭环检测的&lt;/span&gt;&lt;span&gt;scan_match&lt;/span&gt;&lt;span&gt;策略的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221221104857-1739201579.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;图&lt;/span&gt;18&lt;span&gt;）&lt;/span&gt;cartographer&lt;span&gt;算法系统框图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.2.cartographer_ros&lt;span&gt;安装         &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们直接参考&lt;/span&gt;google-cartographer&lt;span&gt;官方教程安装就行，官方教程分为&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;，其实&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;就是核心算法层、&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;是核心算法层的&lt;/span&gt;&lt;span&gt;ros&lt;/span&gt;&lt;span&gt;调用层。官方教程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google-cartographer.readthedocs.io/en/latest/index.html#&quot;&gt;&lt;span&gt;https://google-cartographer.readthedocs.io/en/latest/index.html#&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google-cartographer-ros.readthedocs.io/en/latest/index.html#&quot;&gt;&lt;span&gt;https://google-cartographer-ros.readthedocs.io/en/latest/index.html#&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接按照第二个链接&lt;/span&gt;cartographer_ros&lt;span&gt;的安装教程，就可将&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;、以及各种依赖都安装了。&lt;/span&gt;&lt;span&gt;不过特别说明一点，为了解决从官网下载&lt;/span&gt;ceres-solver&lt;span&gt;速度慢的问题，我将&lt;/span&gt;&lt;span&gt;ceres-solver&lt;/span&gt;&lt;span&gt;的下载地址换到了&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;源；我需要将官方教程中生成的&lt;/span&gt;&lt;span&gt;src/.rosinstall&lt;/span&gt;&lt;span&gt;替换成了自己的内容，如图&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;。其余安装过程和官方教程一模一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）安装编译工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我来编译&lt;/span&gt;cartographer_ros&lt;span&gt;，我们需要用到&lt;/span&gt;&lt;span&gt;wsool&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;rosdep&lt;/span&gt;&lt;span&gt;。为了加快编译，我们使用&lt;/span&gt;&lt;span&gt;ninja&lt;/span&gt;&lt;span&gt;工具进行编译。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; -y python-wstool python-rosdep ninja-build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）创建存放&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;的专门工作空间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir&lt;/span&gt;&lt;span&gt; catkin_ws_carto
cd catkin_ws_carto
wstool init src

wstool merge &lt;/span&gt;-t src https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;raw.githubusercontent.com/googlecartographer/cartographer_ros/master/cartographer_ros.rosinstall&lt;/span&gt;
&lt;span&gt;
wstool update &lt;/span&gt;-t src
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;特别说明，在执行&lt;/span&gt;wstool update -t src&lt;span&gt;之前，需要将&lt;/span&gt;&lt;span&gt;src/.rosinstall&lt;/span&gt;&lt;span&gt;文件修改成以下内容&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;以&lt;span&gt;解决&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;ceres-solver&lt;/span&gt;&lt;span&gt;下载不了的问题&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，如图&lt;/span&gt;19&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221221821509-921051722.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;19&lt;span&gt;）我修改后的&lt;/span&gt;&lt;span&gt;src/.rosinstall&lt;/span&gt;&lt;span&gt;文件内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;（3&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;安装依赖项&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;安装&lt;/span&gt;cartographer_ros&lt;span&gt;的依赖项&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;deb&lt;/span&gt;&lt;span&gt;包等。如果执行&lt;/span&gt;&lt;span&gt;sudo rosdep init&lt;/span&gt;&lt;span&gt;报错，可以直接忽略。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
src/cartographer/scripts/install_proto3.&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; rosdep init
rosdep update

rosdep &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; --from-paths src --ignore-src --rosdistro=${ROS_DISTRO} -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）编译和安装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的配置和依赖都完成后，就可以开始编译和安装&lt;/span&gt;cartographer_ros&lt;span&gt;整个项目工程了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
catkin_make_isolated --&lt;span&gt;install&lt;/span&gt; --use-ninja
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;特别提醒，以后对&lt;/span&gt;cartographer_ros&lt;span&gt;中的配置文件或源码有改动时，都需要执行这个编译命令使修改生效。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.3.cartographer_ros&lt;span&gt;使用        &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;cartographer_ros&lt;span&gt;整体代码结构分析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最顶层的是&lt;/span&gt;cartographer_ros&lt;span&gt;，作为&lt;/span&gt;&lt;span&gt;rosj&lt;/span&gt;&lt;span&gt;接口调用层，通过调用&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;核心算法，订阅多传感器数据（&lt;/span&gt;&lt;span&gt;/scan&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/imu&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;等），并发布地图、机器人位置信息（&lt;/span&gt;&lt;span&gt;/map&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/tf&lt;/span&gt;&lt;span&gt;等）；其次是&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;，作为&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;算法的核心实现，特征提取、子图构建、闭环检测、全局优化都在这里实现，其中优化过程需要调用&lt;/span&gt;&lt;span&gt;ceres-solver&lt;/span&gt;&lt;span&gt;非线性优化库；最后是&lt;/span&gt;&lt;span&gt;ceres-solver&lt;/span&gt;&lt;span&gt;，是非线性优化库，用于求解&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;中的优化问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221222946330-1867929710.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;图&lt;/span&gt;20&lt;span&gt;）&lt;/span&gt;cartographer_ros&lt;span&gt;整体代码结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在&lt;/span&gt;miiboo&lt;span&gt;机器人上用&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;多传感器建图进行配置：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过前面对&lt;/span&gt;cartographer_ros&lt;span&gt;进行安装后，我们肯定迫不及待想在实际的&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人上使用&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;进行&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;建图了。为了最大限度的提高&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;建图的性能，我们的&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人提供了激光雷达、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;、轮式里程计（&lt;/span&gt;&lt;span&gt;/scan&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/imu&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;）这三种传感器的数据，所以我们需要先将&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;配置成对应的工作模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cartographer&lt;span&gt;算法是一个非常通用和适应不同平台的开放框架算法，所以支持多种配置与工作模式。我们就来看看&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;如何进行配置。配置文件由&lt;/span&gt;&lt;span&gt;*.lua&lt;/span&gt;&lt;span&gt;书写被放在路径&lt;/span&gt;&lt;span&gt;cartographer_ros/configuration_files/&lt;/span&gt;&lt;span&gt;，我们需要建立一个我们自己的配置文件，取名就叫&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.lua&lt;/span&gt;&lt;span&gt;吧，具体内容如图&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;。由于我们的&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人采用激光雷达、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;、轮式里程计三种传感器融合建图，所以以下参数一定要设置正确：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;tracking_frame&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;imu_link&lt;/span&gt;&lt;span&gt;，因为我们使用&lt;/span&gt;&lt;span&gt;/imu&lt;/span&gt;&lt;span&gt;的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;published_frame&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;odom&lt;/span&gt;&lt;span&gt;，因为我们使用&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;provide_odom_frame&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;，因为我们使用外部&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;，所以这里不需要内部提供；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;use_odometry&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，因为我们使用外部&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;use_imu_data&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，因为我们使用&lt;/span&gt;&lt;span&gt;/imu&lt;/span&gt;&lt;span&gt;的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;imu_gravity_time_constant&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;，这个是&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;的重力加速度常数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其余参数根据需要自行调整，由于&lt;/span&gt;cartographer&lt;span&gt;是发展很迅速的算法，所以很多代码和文档一直在更新，所以参考官方文档来解读这些参数的含义是最好的选择，官方文档连接地址我贴在下面了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google-cartographer-ros.readthedocs.io/en/latest/index.html&quot;&gt;&lt;span&gt;https://google-cartographer-ros.readthedocs.io/en/latest/index.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221223308133-1363879864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;21&lt;span&gt;）我们&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人的建图配置文件&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.lua&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后需要配置&lt;/span&gt;*.launch&lt;span&gt;文件，我们给&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人建立启动文件取名叫&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.launch&lt;/span&gt;&lt;span&gt;，存放路径在&lt;/span&gt;&lt;span&gt;cartographer_ros/launch/&lt;/span&gt;&lt;span&gt;里面，具体内容如图&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不难发现&lt;/span&gt;launch&lt;span&gt;文件中包含三个&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;启动项，即&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型启动项、&lt;/span&gt;&lt;span&gt;cartographer_node&lt;/span&gt;&lt;span&gt;启动项、&lt;/span&gt;&lt;span&gt;cartographer_occupancy_grid_node&lt;/span&gt;&lt;span&gt;启动项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个启动项是启动&lt;/span&gt;urdf&lt;span&gt;模型，这个接口是提供给那些只使用&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;单独建图的应用场景，由于我们&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人建立完地图后还需要继续进行自动导航任务，所以我们使用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;底盘提供的&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型，而不使用这里的&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型，所以这个启动项被注释掉了，这样建图和导航就更容易管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个启动项是启动&lt;/span&gt;cartographer_node&lt;span&gt;建图节点，这个是&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;建图主节点，我们建立的配置&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.lua&lt;/span&gt;&lt;span&gt;将在这里被载入，同时这里可以对建图输入数据&lt;/span&gt;&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;imu&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;odom&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;名称做重映射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三个启动项是启动&lt;/span&gt;cartographer_occupancy_grid_node&lt;span&gt;地图格式转换节点，由于&lt;/span&gt;&lt;span&gt;cartographer_node&lt;/span&gt;&lt;span&gt;建图节点提供的地图是&lt;/span&gt;&lt;span&gt;submapList&lt;/span&gt;&lt;span&gt;格式的，需要转换成&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;格式才能在&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;中显示和使用。这里面有两个可配参数，&lt;/span&gt;&lt;span&gt;resolution&lt;/span&gt;&lt;span&gt;用来设置&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;地图的分辨率，&lt;/span&gt;&lt;span&gt;publish_period_sec&lt;/span&gt;&lt;span&gt;用来设置&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;地图发布的频率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221223608845-564058946.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;22&lt;span&gt;）我们&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人的建图启动文件&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.launch&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;配置参数修改好后，不要忘了再编译一次整个&lt;/span&gt;catkin_ws_carto&lt;span&gt;工作空间，切换到&lt;/span&gt;&lt;span&gt;catkin_ws_carto&lt;/span&gt;&lt;span&gt;目录，执行下面的编译命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
catkin_make_isolated --&lt;span&gt;install&lt;/span&gt; --use-ninja
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;启动&lt;/span&gt;cartographer_ros&lt;span&gt;建图：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要在&lt;/span&gt;miiboo&lt;span&gt;机器人上，启动&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;建图，分为这几个步骤：启动机器人上的各个传感器、启动&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;、在&lt;/span&gt;&lt;span&gt;PC&lt;/span&gt;&lt;span&gt;端启动键盘控制机器人运动并启动&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;观察地图（或者在&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;手机端用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;控制机器人运动和观察地图）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，启动机器人上的各个传感器，为了操作方便，我已经将要启动的传感器都写入&lt;/span&gt;miiboo_bringup/launch/miiboo_all_sensor.launch&lt;span&gt;这个启动文件了，文件内容如图&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;。这个启动文件包含机器人&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;启动项、&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;底盘启动项、激光雷达启动项、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;启动项、摄像头启动项、广播&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;启动项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221223854757-495095153.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;23&lt;span&gt;）各个传感器启动文件&lt;/span&gt;&lt;span&gt;miiboo_all_sensor.launch&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;span&gt;打开终端，通过下面的命令直接启动就行了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
source ~/catkin_ws/devel/&lt;span&gt;setup.bash 
roslaunch miiboo_bringup miiboo_all_sensor.launch &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后，启动&lt;/span&gt;cartographer_ros&lt;span&gt;，由于前面已经做好了相应的配置，所以直接使用命令启动就行了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
source ~/catkin_ws_carto/install_isolated/&lt;span&gt;setup.bash
roslaunch cartographer_ros miiboo_mapbuild.launch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里给个小提示，为了查看&lt;/span&gt;cartographer_ros&lt;span&gt;建图算法有没有正常开始工作，我们可以用&lt;/span&gt;&lt;span&gt;rosrun rqt_tf_tree rqt_tf_tree&lt;/span&gt;&lt;span&gt;查看整个&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;树的结构，正常的&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;树如图&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;map-&amp;gt;odom&lt;/span&gt;&lt;span&gt;之间的关系由&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;建图节点提供，&lt;/span&gt;&lt;span&gt;odom-&amp;gt;base_footprint&lt;/span&gt;&lt;span&gt;之间的关系由&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;底盘的轮式里程计提供，&lt;/span&gt;&lt;span&gt;base_footprint-&amp;gt;imu_link&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;base_link&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;base_laser_link&lt;/span&gt;&lt;span&gt;之间的关系由&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人的&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型提供。从&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;树不难看出整个建图过程中机器人定位的实现原理，&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;建图节点通过维护&lt;/span&gt;&lt;span&gt;map-&amp;gt;odom&lt;/span&gt;&lt;span&gt;之间的关系最终实现全局定位，&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;底盘的轮式里程计通过维护&lt;/span&gt;&lt;span&gt;odom-&amp;gt;base_footprint&lt;/span&gt;&lt;span&gt;之间的关系来实现局部定位，传感器之间的安装关系由&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型提供，这个静态关系主要用于多传感器数据融合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224144407-1294687944.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;24&lt;span&gt;）&lt;/span&gt;cartographer&lt;span&gt;运行时正常的&lt;/span&gt;tf&lt;span&gt;树&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，在&lt;/span&gt;PC&lt;span&gt;端启动键盘控制机器人运动并启动&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;观察地图（或者在&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;手机端用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;控制机器人运动和观察地图）。如果用&lt;/span&gt;&lt;span&gt;PC&lt;/span&gt;&lt;span&gt;端控制和观察，启动命令如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;PC&lt;span&gt;端打开一个新终端，运行&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;启动命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rosrun rviz rviz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;rviz&lt;span&gt;窗口中添加订阅&lt;/span&gt;&lt;span&gt;/map&lt;/span&gt;&lt;span&gt;，就可以看到建图效果了，如图&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224414583-2080969512.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;25&lt;span&gt;）在&lt;/span&gt;&lt;span&gt;PC&lt;/span&gt;&lt;span&gt;端用&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;观察地图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;PC&lt;span&gt;端再打开一个新终端，运行键盘控制启动命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在该终端下，用键盘就可以控制机器人前进、后退、左转、右转了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是在&lt;/span&gt;Android&lt;span&gt;手机端用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;控制机器人运动和观察地图，直接就能使用，如图&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224615521-1957755232.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;26&lt;span&gt;）在&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;手机端用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;控制机器人运动和观察地图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;保存&lt;/span&gt;cartographer_ros&lt;span&gt;建图结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们在房间里面扫描一圈，地图建立的差不多了，就可以将建图结果保存下来了，&lt;/span&gt;cartographer_ros&lt;span&gt;提供了将建图结果保存为&lt;/span&gt;&lt;span&gt;*.pbstream&lt;/span&gt;&lt;span&gt;专门的方法，其实就是一条命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
source ~/catkin_ws_carto/install_isolated/&lt;span&gt;setup.bash
rosservice call &lt;/span&gt;/write_state  /home/ubuntu/map/carto_map.pbstream
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实就是调用&lt;/span&gt;cartographer_ros&lt;span&gt;提供的叫&lt;/span&gt;/write_state&lt;span&gt;这个名字的服务，服务传入参数&lt;/span&gt;/home/ubuntu/map/carto_map.pbstream&lt;span&gt;为地图的保存路径。保存成功后，会返回相应的状态信息，如图&lt;/span&gt;27&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224815511-753768000.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;27&lt;span&gt;）调用&lt;/span&gt;/write_state&lt;span&gt;服务保存建图结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;地图格式转换：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于用&lt;/span&gt;cartographer_ros&lt;span&gt;提供的&lt;/span&gt;/write_state&lt;span&gt;方法保存的地图是&lt;/span&gt;*.pbstream&lt;span&gt;的格式，而要在后续的自主导航中使用这个地图，我们需要将其转换为&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;中通用的&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;格式。其实很简单，&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;已经跟我们提供了&lt;/span&gt;cartographer_pbstream_to_ros_map&lt;span&gt;这个节点&lt;/span&gt;&lt;span&gt;用于转换的实现。所以，我们只需要写一个启动文件启动这个节点就行了，我给这个启动文件取名&lt;/span&gt;miiboo_pbstream2rosmap.launch&lt;span&gt;，存放路径是&lt;/span&gt;&lt;span&gt;cartographer_ros/launch/&lt;/span&gt;&lt;span&gt;，启动文件的内容如图&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;。在使用这个启动文件进行启动时，需要从外部传入两个参数，参数&lt;/span&gt;&lt;span&gt;pbstream_filename&lt;/span&gt;&lt;span&gt;为待转换的&lt;/span&gt;&lt;span&gt;*.pbstream&lt;/span&gt;&lt;span&gt;文件路径，参数&lt;/span&gt;&lt;span&gt;map_filestem&lt;/span&gt;&lt;span&gt;为转换后存放结果的文件路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224908818-377349320.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;28&lt;span&gt;）&lt;/span&gt;&lt;span&gt;pbstream&lt;/span&gt;&lt;span&gt;转&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;启动文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;配置参数修改好后，不要忘了再编译一次整个&lt;/span&gt;catkin_ws_carto&lt;span&gt;工作空间，切换到&lt;/span&gt;&lt;span&gt;catkin_ws_carto&lt;/span&gt;&lt;span&gt;目录，执行下面的编译命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
catkin_make_isolated --&lt;span&gt;install&lt;/span&gt; --use-ninja
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;最后，就可以打开终端，使用启动这个启动文件，对地图格式进行转换了，命令如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
roslaunch cartographer_ros miiboo_pbstream2rosmap.launch pbstream_filename:=/home/ubuntu/map/carto_map.pbstream map_filestem:=/home/ubuntu/map/carto_map
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;保存结束后，节点会自动退出，这时我们可以得到转换后的地图，转换后的&lt;/span&gt;GridMap&lt;span&gt;地图由&lt;/span&gt;&lt;span&gt;*.pgm&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;*.yaml&lt;/span&gt;&lt;span&gt;两部分构成，这时标准的&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;格式地图，可以被&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;导航框架中的&lt;/span&gt;&lt;span&gt;map_server&lt;/span&gt;&lt;span&gt;节点直接调用，&lt;/span&gt;&lt;span&gt;转换后的地图结果如图&lt;/span&gt;29&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221225100401-2112777935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;29&lt;span&gt;）地图格式转换后的结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果大家对博文的相关类容感兴趣，或有什么技术疑问，欢迎加入下面的《SLAM+语音机器人DIY》QQ技术交流群，一起讨论学习^_^&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190220162438739-1654241751.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 15:04:00 +0000</pubDate>
<dc:creator>小虎哥哥爱学习</dc:creator>
<og:description>摘要 通过前面的基础学习，本章进入最为激动的机器人自主导航的学习。在前面的学习铺垫后，终于迎来了最大乐趣的时刻，就是赋予我们的miiboo机器人能自由行走的生命。本章将围绕机器人SLAM建图、导航避障</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hiram-zhang/p/10415865.html</dc:identifier>
</item>
<item>
<title>我们为什么要搞长沙.NET技术社区（二） - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10415886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10415886.html</guid>
<description>&lt;h3 align=&quot;center&quot;&gt;我们为什么要搞长沙.NET技术社区（二）&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　某种意义上讲，长沙和中国大部分内地城市一样，都是互联网时代的灯下黑。没有真正意义上的互联网公司，例如最近发布的中国互联网企业一百强中没有一家湖南或者长沙的公司就是明证。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　然而长沙并非没有互联网人，在麓谷几十万计的IT 从业人员就是明证。即便如此，长沙依然是一个互联网氛围很不好的城市。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 　　表面上看互联网氛围是一个不可度量的东西，有人说他不过是许多公司的所说的企业文化一般，都是看不见，摸不着，大概只存在于老板的PPT 和公司吹过的牛逼里面。但是在互联网思维飞速发展的今天，他实际上已经深深的影响了我们的方方面面，尤其是对于IT 领域来说，更是如此。近多少年来，但凡是优秀的互联网公司，都以封闭为耻，充分的利用开源社区营造的众多基础设施，为企业的飞速发展插上了无穷想象力，在企业获得成功之后，再通过同样的开源的形式，将技术回馈社区，影响了许多同样需要基础设施的其他企业，如此周而往复，形成了一个又一个完善的闭环。除此之外，这些公司也会定期的组织技术分享，让开发者积极的了解技术的同时，也加深了许多对目标企业的好感。因此，做开源和做社区，实际上对开发者社区和企业来说是互利互惠的好事。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　与北上广深杭相比，长沙并没有那么多做开源和分享技术的企业，但也充满了无穷潜力。这也是多少年来，长沙唐胡子俱乐部把营造互联网氛围当作使命的主要原因，实际上到目前为止，他已经取得了不错的成绩。从QQ群，微信群开始，到线下的活动基地，他已经成功举办了数十次互联网类型的分享。而且前每个月都会组织各种类型的技术活动或互联网活动，惠及了不少互联网从业人员。尤其是2018年4月份，由俱乐部举办的岳麓峰会-互联网技术CTO专场，更是成为地区瞩目的焦点。当时报名人数一度突破三千人，而参与聆听技术分享的互联网从业人员超过一千人。借着岳麓峰会的东风，为了将互联网技术分享落到实处，俱乐部又发起成立了长沙互联网活动基地。去年笔者曾经作为唐胡子俱乐部的成员参与了众多长沙互联网活动，并深度参与了互联网活动基地的建设过程，深知互联网社区运营之艰难，尤其是要做落地的互联网技术社区，更是难上加难。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　为了让社区落地，我们打算成立技术社区，并从.NET社区开始。非常有幸，我认识了一群优秀的开发者，他们非常也愿意参与社区的建设。同样非常有幸，我们获得了来自全国各地微软.NET俱乐部的大力支持。尤其是作为这个时代最美丽的开发者微软MVP们，例如苏州俱乐部的潘老师，深圳.NET俱乐部的张队长、广州俱乐部的叶老师和陈老师，上海俱乐部的汪老师，微软的许老师等等，他们都非常支持我们的决定。来自苏州的潘老师甚至把苏州的经验无条件的全部分享给我，让我能够更加直观的了解到组建社区的基本流程。为此，我们开始了从设计到实践的全过程。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　于是，我们把群拉了起来，并打算开始逐步的进行下一步计划。不到一周时间，我们的微信群已经拥有将近600位成员，去掉重复的，还有560人。当然，我们的群获得了短期的活跃，然后第二天、第三天热度就急剧的下滑了。因为，大概是我们不想做水群。我们究竟打算怎样来建一个怎样的社区，后面几篇再分享。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　建群只是第一步，后期还有一万步。建一个群，或者建一万个群，没有落地都没有任何价值，只有落地才是王道。而究竟怎么落地？我们需要大家的积极参与，例如现在，为我们提建议，可以让我们能更好的规划我们的未来。也期待大家一起加入分享者的行列，让我们共同把社区经营好。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2018年我的朋友嘉鹏写了一首诗，正文是这样的。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;余常踱步而思，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;社群之发展，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;该如天公作法，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;雷厉风行。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;又该如春风化雨，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;润物无声。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;余又常想古人圣言，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;逝者如斯，白驹过隙。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;沧海桑田，朱颜易改。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;古人悬梁刺股，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;纵使白发葬青丝，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;不可荒嬉学仲永。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;我辈中人，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;当敏，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;而好学，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;方无悔矣。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;纵观古今社群之流，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;盛蔚乎如菁英荟萃之泰山。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;草芥兮不洁庭庑。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;社群之路，任重而道远。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;当此盛世，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;当炳开放，平等，迅疾，协作，分享，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;之互联网精神。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;以精师长技为本心，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;以广纳益友为心念，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;以开拓创新为旗帜，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;以繁盛星网为目标，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;合抱生于毫末，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;九层起于累土。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;星城之精英，当聚于此，共襄盛举。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;奇花初绽，矞矞皇皇！&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;干将发硎，有作其芒！&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;纵有千古，横有八荒。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;前途似海，来日方长，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;未来可期！未来可期！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　说那么多，都是为了继续征集问卷调查，请长沙.NET社区的开发者们百忙之中抽空填写问卷。非常感谢。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201902/191302-20190221225845358-1038623864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;https://www.wjx.top/jq/34721880.aspx&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 15:04:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>我们为什么要搞长沙.NET技术社区（二） 某种意义上讲，长沙和中国大部分内地城市一样，都是互联网时代的灯下黑。没有真正意义上的互联网公司，例如最近发布的中国互联网企业一百强中没有一家湖南或者长沙的公司</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10415886.html</dc:identifier>
</item>
<item>
<title>陪你解读Spring Batch（二）带你入手Spring Batch - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10415667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10415667.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　说得多不如show code。上一章简单介绍了一下Spring Batch。本章将从头到尾搭建一套基于Spring Batch(2.1.9)、Spring(3.0.5)、mybatis(3.4.5)、mysql、gradle的批处理简单应用来处理文件中大量交易数据的写入。&lt;/p&gt;
&lt;p&gt;　　那么这里简单定义以下交易文件的格式，一个txnId交易Id，一个amt交易金额。一天比如有100w交易数据过来要落表。文件大概长这样，只是简单定义以下，实际开发肯定不会那么少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190221220956239-1945469204.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因工作需求没有使用最新版本的Spring Batch，所以&lt;span&gt;本章是基于XML config的例子&lt;/span&gt;。最新版本支持用Java Config配置Spring Batch Job、Job Scope等。有兴趣的同学可以自行研究一下。本人技术有限，本章讲的如有错误希望请指正。&lt;/p&gt;

&lt;h2&gt;2.1 项目依赖&lt;/h2&gt;
&lt;p&gt;　　首先我们要引入Spring Batch的依赖，这里的版本是2.1.9&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
springbatch = [&quot;org.springframework.batch:spring-batch-core:2.1.9.RELEASE&quot;&lt;span&gt;,
                   &lt;/span&gt;&quot;org.springframework.batch:spring-batch-infrastructure:2.1.9.RELEASE&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　批量处理的过程中，我们都需要数据持久化。这里我用的数据库是mysql，ORM框架是mybatis。所以还要添加mysql-connect和mybatis的依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mybatis = &quot;org.mybatis:mybatis:3.4.5&quot;&lt;span&gt;
mysqlconnect &lt;/span&gt;= &quot;mysql:mysql-connector-java:5.1.25&quot;&lt;span&gt;
dbcp &lt;/span&gt;= &quot;commons-dbcp:commons-dbcp:1.4&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事务和数据库的配置就不用说了，必须的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- transaction config --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/m_test_db&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.2 配置Job&lt;/h2&gt;
&lt;p&gt;　　上一章节说过，其实文件批处理的场景，抽象的处理三大步骤分为，读，处理，写。那么我们就依照这张图来开始&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190221212512509-185058300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图如果看不懂的请看上一章节来理解。那么我们先建立一个Spring Batch任务的xml文件，然后定义Job&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;!--data-source，transaction-manager 数据源以及事务管理器--&amp;gt;&lt;br/&gt;&amp;lt;batch:job-repository id=&quot;jobRepository&quot;&lt;br/&gt;data-source=&quot;dataSource&quot; transaction-manager=&quot;transactionManager&quot;&lt;br/&gt;isolation-level-for-create=&quot;SERIALIZABLE&quot;&lt;br/&gt;table-prefix=&quot;DPL_&quot; max-varchar-length=&quot;1000&quot;/&amp;gt;&lt;/pre&gt;
&lt;pre&gt;
&amp;lt;batch:job id=&quot;investmentMatchFileJob&quot;&lt;span&gt;
               job-repository=&quot;jobRepository&quot;&amp;gt;
        &amp;lt;batch:step id=&quot;investmentMatchFileToDb&quot;&amp;gt;
            &amp;lt;batch:tasklet&amp;gt;
                &amp;lt;batch:chunk reader=&quot;txnListFileReader&quot; writer=&quot;txnListResultWriter&quot;&lt;span&gt;
                             commit-interval=&quot;300&quot;/&amp;gt;
            &amp;lt;/batch:tasklet&amp;gt;
        &amp;lt;/batch:step&amp;gt;
&amp;lt;/batch:job&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结合上面的图看，是不是找到点感觉了？一个Job可以有多个Step组合，每一个Step由开发者自己编写，可一把一个大Step分成多个小Step，完全看开发者意愿。每一个Step对应一个ItemReader、ItemProcessor和ItemWriter。所有的批处理框架都可以抽象成最简单的过程，读取数据，处理数据，写数据。所以Spring Batch提供了3个接口，ItemReader、ItemProcessor和ItemWriter。JobRepository则是记录Job、Step和发起Job的执行信息等。 &lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;xml配置Job必须依赖的有三项，名称，JobRepository和Step列表。还有一个没介绍就是commit-interval属性，这就是控制读了多少行进行一次写。总不可能读一行写一行对吧？这里配置多少，那么Writer的入参list的size就是多少。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.2.1 JobRepository&lt;/h3&gt;
&lt;p&gt;　　JobRepository是记录Job、Step和发起Job的执行信息，&lt;span&gt;SpringBatch一共会让你导入9张表&lt;/span&gt;，具体哪9张表请导入依赖然后查看schema-mysql.sql文件。&lt;/p&gt;
&lt;p&gt;　　这里要说明的一点是&lt;span&gt;table-prefix属性，默认是以BATCH_开头的，你可以改变前缀，当然你的sql脚本的表名前缀也要改动。注意，这里只能改前缀，不可以改表的全名&lt;/span&gt;。表的列可以增加，比如说你的公司建表必须要有id,created_at,xxxx等字段的话，可以增加列，没有问题。&lt;span&gt;但是原有列的名称不可以修改。脚本会在3张以SEQ结尾的表插入0，必须要先插入。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.3 Step&lt;/h2&gt;
&lt;h3&gt;2.3.1 Reader&lt;/h3&gt;
&lt;p&gt;　　上面配置的reader是以下这个bean，value=&quot;file:#{jobParameters['txnListFile']}&quot;。这里用到SPEL表达式，传入文件路径参数。FlatFileItemReader只能处理一个文件，实际使用中不可能只处理一个文件，所以你也可以导入下面那个叫MultiResourceItemReader类，通过给MultiResourceItemReader设置Resource数组可以实现一个Job读取一个目录下多个文件。但是这里注意，&lt;span&gt;JobRepository不会记录每个文件的处理情况。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;txnListFileReader&quot;
      &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.batch.item.file.FlatFileItemReader&quot;&lt;span&gt;
      scope&lt;/span&gt;=&quot;step&quot;&amp;gt;
    &amp;lt;!--输入文件--&amp;gt;
    &amp;lt;property name=&quot;resource&quot; value=&quot;file:#{jobParameters['txnListFile']}&quot;/&amp;gt;
    &amp;lt;!--将每行映射为一个对象--&amp;gt;
    &amp;lt;property name=&quot;lineMapper&quot;&amp;gt;
        &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.batch.item.file.mapping.DefaultLineMapper&quot;&amp;gt;
            &amp;lt;!--从划分的字段中构建一个对象--&amp;gt;
            &amp;lt;property name=&quot;fieldSetMapper&quot; ref=&quot;InvestMatchItemMapper&quot;/&amp;gt;
            &amp;lt;!--根据某种分隔符来分--&amp;gt;
            &amp;lt;property name=&quot;lineTokenizer&quot; ref=&quot;TxnListItemMapperFileLineTokenizer&quot;/&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!--跳过开头的的一些行--&amp;gt;
    &amp;lt;property name=&quot;linesToSkip&quot; value=&quot;1&quot;/&amp;gt;
    &amp;lt;property name=&quot;encoding&quot; value=&quot;UTF-8&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;InvestMatchItemMapper&quot; &lt;span&gt;class&lt;/span&gt;=&quot;me.grimmjx.sync.TxnListItemMapper&quot;/&amp;gt;
&amp;lt;bean id=&quot;TxnListItemMapperFileLineTokenizer&quot;
      &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.batch.item.file.transform.DelimitedLineTokenizer&quot;&amp;gt;
    &amp;lt;property name=&quot;delimiter&quot; value=&quot;|&quot;/&amp;gt;
    &amp;lt;property name=&quot;names&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;value&amp;gt;txnId&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;amt&amp;lt;/value&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;



&amp;lt;!--以下的内容是对一个目录下多个文件进行批处理的样例--&amp;gt;
&amp;lt;bean id=&quot;txnListFileReader&quot;
      &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.batch.item.file.MultiResourceItemReader&quot;&lt;span&gt;
      scope&lt;/span&gt;=&quot;step&quot;&amp;gt;
    &amp;lt;property name=&quot;resources&quot; value=&quot;file:#{jobParameters['txnListFile']}/*.txt&quot;/&amp;gt;
    &amp;lt;property name=&quot;delegate&quot;&amp;gt;
        &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.batch.item.file.FlatFileItemReader&quot;&lt;span&gt;
              scope&lt;/span&gt;=&quot;step&quot;&amp;gt;
            &amp;lt;property name=&quot;lineMapper&quot;&amp;gt;
                &amp;lt;&lt;span&gt;bean
                        &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.batch.item.file.mapping.DefaultLineMapper&quot;&amp;gt;
                    &amp;lt;property name=&quot;fieldSetMapper&quot; ref=&quot;InvestMatchItemMapper&quot;/&amp;gt;
                    &amp;lt;property name=&quot;lineTokenizer&quot;&lt;span&gt;
                              ref&lt;/span&gt;=&quot;TxnListItemMapperFileLineTokenizer&quot;/&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property name=&quot;linesToSkip&quot; value=&quot;1&quot;/&amp;gt;
            &amp;lt;property name=&quot;encoding&quot; value=&quot;UTF-8&quot;/&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以下图来理解比较方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190221220026881-839937897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从xml配置来看，&lt;span&gt;delimiter控制如何分割，names就是文件每一列的名字&lt;/span&gt;。在这么多配置里，我们只需要写一个Java类。这里就是从一行数据，转换成一个对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
 * 交易记录匹配器类。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TxnListItemMapper &lt;span&gt;implements&lt;/span&gt; FieldSetMapper&amp;lt;TxnList&amp;gt;&lt;span&gt;{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TxnList mapFieldSet(FieldSet fieldSet) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BindException {
        TxnList txnList &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TxnList();
        txnList.setTxnId(fieldSet.readString(&lt;/span&gt;&quot;txnId&quot;&lt;span&gt;));
        txnList.setAmt(fieldSet.readBigDecimal(&lt;/span&gt;&quot;amt&quot;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; txnList;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.3.2 Writer&lt;/h3&gt;
&lt;p&gt;　　writer的bean为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;txnListResultWriter&quot; &lt;span&gt;class&lt;/span&gt;=&quot;me.grimmjx.sync.TxnListResultWriter&quot; scope=&quot;step&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　writer执行的是写入操作，我们要实现ItemWriter&amp;lt;T&amp;gt;接口，以下为这个类的Java代码。这里的操作很简单，将构建好的对象集合直接写入库。注意了，&lt;span&gt;外面没有幂等的话，最好这里先判断库里有没有，不要无脑写入。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
 * 交易数据写入类。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TxnListResultWriter &lt;span&gt;implements&lt;/span&gt; ItemWriter&amp;lt;TxnList&amp;gt;&lt;span&gt; {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TxnListMapper txnListMapper;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; TxnList&amp;gt; items) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        List&lt;/span&gt;&amp;lt;TxnList&amp;gt; txnLists =&lt;span&gt; Lists.newArrayList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TxnList item : items) {
            txnLists.add(item);
        }
        txnListMapper.insertBatch(txnLists);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.4 启动Job&lt;/h2&gt;
&lt;p&gt;　　这里先定义一个bean，与之前的Job相关联。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;DefaultFileProcessor&quot; &lt;span&gt;class&lt;/span&gt;=&quot;me.grimmjx.processor.DefaultFileProcessor&quot;&amp;gt;
        &amp;lt;property name=&quot;job&quot; ref=&quot;investmentMatchFileJob&quot;/&amp;gt;
        &amp;lt;property name=&quot;jobLauncher&quot; ref=&quot;jobLauncher&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以下为这个processor的Java代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 默认文件处理器类。
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultFileProcessor {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 批次job
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Job job;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 任务启动器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; JobLauncher jobLauncher;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process() {
        String baseDir &lt;/span&gt;= &quot;/Users/miaojiaxing/test/2019.01.31.txt&quot;&lt;span&gt;;

        JobParametersBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobParametersBuilder();
        builder.addString(&lt;/span&gt;&quot;txnListFile&quot;&lt;span&gt;, baseDir);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 携带参数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        builder.addString(&quot;packageCode&quot;, &quot;12345&quot;);&lt;/span&gt;
        builder.addString(&quot;dateTime&quot;, System.currentTimeMillis() + &quot;&quot;&lt;span&gt;);
        JobParameters jobParas &lt;/span&gt;=&lt;span&gt; builder.toJobParameters();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            jobLauncher.run(job, jobParas);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;Run springBatchJob meet error&quot;&lt;span&gt;, e);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setJob(Job job) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.job =&lt;span&gt; job;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setJobLauncher(JobLauncher jobLauncher) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jobLauncher =&lt;span&gt; jobLauncher;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后我们试试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
 * &amp;lt;p&amp;gt;
 * 测试类。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ApplicationContext ctx &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        DefaultFileProcessor bean &lt;/span&gt;= ctx.getBean(&quot;DefaultFileProcessor&quot;, DefaultFileProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        bean.process();
        DefaultFileProcessor rereadProcessor &lt;/span&gt;= ctx.getBean(&quot;rereadProcessor&quot;, DefaultFileProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        rereadProcessor.process();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190221223919728-582905706.png&quot; alt=&quot;&quot; width=&quot;774&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　没有问题。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;下一章节将结合校验清洗、异常弹性处理、并行配置附上代码。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 14:46:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>前言 说得多不如show code。上一章简单介绍了一下Spring Batch。本章将从头到尾搭建一套基于Spring Batch(2.1.9)、Spring(3.0.5)、mybatis(3.4.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrimMjx/p/10415667.html</dc:identifier>
</item>
<item>
<title>详解mybatis映射配置文件 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/10399333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/10399333.html</guid>
<description>&lt;p&gt;&lt;span&gt;一  mybatis 映射文件结构&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;      mybatis映射配置文件存在如下顶级元素，且这些元素按照如下顺序被定义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;tt&gt;cache&lt;/tt&gt; – 给定命名空间的缓存配置。&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;cache-ref&lt;/tt&gt; – 其他命名空间缓存配置的引用。  &lt;/li&gt;
&lt;li&gt;&lt;tt&gt;resultMap&lt;/tt&gt; – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;&lt;s&gt;parameterMap&lt;/s&gt;&lt;/tt&gt;&lt;s&gt; – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;sql&lt;/tt&gt; – 可被其他语句引用的可重用语句块。&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;insert&lt;/tt&gt; – 映射插入语句&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;update&lt;/tt&gt; – 映射更新语句&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;delete&lt;/tt&gt; – 映射删除语句&lt;/li&gt;
&lt;li&gt;&lt;tt&gt;select&lt;/tt&gt; – 映射查询语句&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;二  mybatis映射配置文件顶级元素分析&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; （一）CRUD&lt;/p&gt;
&lt;p&gt; 在映射配置文件中，基本的CRUD操作定义如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;select by id&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getUserInfoById&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;UserInfo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT user_name ,user_addr FROM user_info WHERE user_id=#{user_id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;addUserInfo&quot;&lt;/span&gt;&lt;span&gt; useGeneratedKeys&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        INSERT INTO user_info(user_name,user_addr)VALUES(#{user_name},#{user_addr})
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateUserInfo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
         UPDATE user_info set user_name=#{user_name} WHERE user_id=#{user_id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;delUserInfoById&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        DELETE FROM user_info WHERE user_id=#{user_id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.#{}表示占位符，相当于？，#{}需要经过预处理，能防止SQL漏洞注入，当然，也可以使用${}，只是不能防止漏洞注入。&lt;/p&gt;
&lt;p&gt;2.select语句有很多属性&lt;/p&gt;
&lt;p&gt;id -- 唯一标识select语句&lt;/p&gt;
&lt;p&gt;parameterType --参数类型&lt;/p&gt;
&lt;p&gt;paramerterMap -- 参数映射&lt;/p&gt;
&lt;p&gt;resultType -- 返回类型&lt;/p&gt;
&lt;p&gt;resultMap -- 返回类型映射&lt;/p&gt;
&lt;p&gt;flushCache -- 当语句被调用时，是否清除本地缓存或二级缓存&lt;/p&gt;
&lt;p&gt;useCache -- 是否使用二级缓存&lt;/p&gt;
&lt;p&gt;timeout -- 在抛出异常之前，驱动程序等待数据库返回请求结果的秒数&lt;/p&gt;
&lt;p&gt;fetchSize -- 每次批量返回的结果行数&lt;/p&gt;
&lt;p&gt;statementType -- 使用STATEMENT，PREPARED 或 CALLABLE 的一个&lt;/p&gt;
&lt;p&gt;resultSetType -- 使用FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select
  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectPerson&quot;&lt;/span&gt;&lt;span&gt;
  parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt;
  parameterMap&lt;/span&gt;&lt;span&gt;=&quot;deprecated&quot;&lt;/span&gt;&lt;span&gt;
  resultType&lt;/span&gt;&lt;span&gt;=&quot;hashmap&quot;&lt;/span&gt;&lt;span&gt;
  resultMap&lt;/span&gt;&lt;span&gt;=&quot;personResultMap&quot;&lt;/span&gt;&lt;span&gt;
  flushCache&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
  useCache&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
  timeout&lt;/span&gt;&lt;span&gt;=&quot;10000&quot;&lt;/span&gt;&lt;span&gt;
  fetchSize&lt;/span&gt;&lt;span&gt;=&quot;256&quot;&lt;/span&gt;&lt;span&gt;
  statementType&lt;/span&gt;&lt;span&gt;=&quot;PREPARED&quot;&lt;/span&gt;&lt;span&gt;
  resultSetType&lt;/span&gt;&lt;span&gt;=&quot;FORWARD_ONLY&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（二）resultType&lt;/p&gt;
&lt;p&gt;resultType可表示返回基本类型，也可表示返回复杂对象类型(包括自定义类型)&lt;/p&gt;
&lt;p&gt;1.返回基本类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;listUserInfo&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
     SELECT userId FROM user_info
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.返回复杂类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getUserInfoById&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;UserInfo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
     SELECT user_name ,user_addr FROM user_info WHERE user_id=#{user_id}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（三）resultMap&lt;/p&gt;
&lt;p&gt;resultMap主要解决TABLE字段与JavaBean映射不匹配问题。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;定义一个JavaBean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo {
    String userName;
    String addr;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;setter和getter&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; `user_info`;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `user_info`  (
  `&lt;/span&gt;&lt;span&gt;user_id&lt;/span&gt;` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `&lt;/span&gt;&lt;span&gt;user_name&lt;/span&gt;` &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; latin1 COLLATE latin1_swedish_ci &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `user_addr` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; latin1 COLLATE latin1_swedish_ci &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (`&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;`) USING BTREE
) ENGINE &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; InnoDB AUTO_INCREMENT &lt;span&gt;=&lt;/span&gt; &lt;span&gt;16&lt;/span&gt; &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; latin1 COLLATE &lt;span&gt;=&lt;/span&gt; latin1_swedish_ci ROW_FORMAT &lt;span&gt;=&lt;/span&gt;&lt;span&gt; Compact;

&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过如上发现，user_name与userName不匹配，user_addr与addr不匹配。&lt;/p&gt;
&lt;p&gt;通过resultMap就能很好地解决该问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;resultMap id=&quot;userInfoMap&quot; type=&quot;UserInfo&quot;&amp;gt;
   &amp;lt;result property=&quot;userName&quot; column=&quot;user_name&quot;/&amp;gt;
   &amp;lt;result property=&quot;addr&quot; column=&quot;user_addr&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;property表示JavaBean,column表示table字段&lt;/p&gt;
&lt;p&gt;（四）SQL&lt;/p&gt;
&lt;p&gt;sql语句，定义可重用语句。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sql &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userColumns&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ${alias}.id,${alias}.username,${alias}.addr &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引定义好的sql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;listUserInfo&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;userInfoMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;userColumns&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;alias&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;t1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM user_info t1
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（五）cache &amp;amp;cache-ref&lt;/p&gt;
&lt;p&gt;cache和cache-ref比较重要，放在下篇文章讲解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三   Mybatis系列文章&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;     &lt;a href=&quot;https://www.cnblogs.com/wangjiming/p/10376010.html&quot;&gt;浅谈JavaWeb架构演变&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;     &lt;a href=&quot;https://www.cnblogs.com/wangjiming/p/10384975.html&quot;&gt;浅谈mybatis如何半自动化解耦&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;     &lt;a href=&quot;https://www.cnblogs.com/wangjiming/p/10399320.html&quot;&gt;详解mybatis配置文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四  参考文献&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;   【01】http://www.mybatis.org/mybatis-3/zh/configuration.html#&lt;/p&gt;
&lt;p&gt;五 版权区&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;   转载博客，必须注明博客出处&lt;/li&gt;
&lt;li&gt;   博主网址：http://www.cnblogs.com/wangjiming/&lt;/li&gt;
&lt;li&gt;   如您有新想法，欢迎提出，邮箱：2098469527@qq.com&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Thu, 21 Feb 2019 14:38:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>一 mybatis 映射文件结构 mybatis映射配置文件存在如下顶级元素，且这些元素按照如下顺序被定义。 cache – 给定命名空间的缓存配置。 cache-ref – 其他</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/10399333.html</dc:identifier>
</item>
<item>
<title>javascript深入浅出图解作用域链和闭包 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10415735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10415735.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、概要&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于闭包的定义（红宝书P178）：闭包就是指有权访问另外一个函数的作用域中的变量的函数。&lt;/p&gt;
&lt;p&gt;关键点：&lt;/p&gt;
&lt;p&gt;1、闭包是一个函数&lt;/p&gt;
&lt;p&gt;2、能够访问另外一个函数作用域中的变量&lt;/p&gt;
&lt;p&gt;文章首发地址于&lt;a href=&quot;https://www.mwcxs.top&quot; target=&quot;_blank&quot;&gt;sau交流学习社区&lt;/a&gt;：&lt;a href=&quot;https://www.mwcxs.top/page/571.html&quot; target=&quot;_blank&quot;&gt;https://www.mwcxs.top/page/571.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、闭包特性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于闭包有下面三个特性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、闭包可以访问当前函数以外的变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;getOuter(&lt;span class=&quot;hljs-params&quot;&gt;){
  &lt;span class=&quot;hljs-keyword&quot;&gt;var date = &lt;span class=&quot;hljs-string&quot;&gt;'815';
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;getDate(&lt;span class=&quot;hljs-params&quot;&gt;str){
    &lt;span class=&quot;hljs-built_in&quot;&gt;console.log(str + date);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、即使外部函数已经返回，闭包仍能访问外部函数定义的变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;getOuter(&lt;span class=&quot;hljs-params&quot;&gt;){
  &lt;span class=&quot;hljs-keyword&quot;&gt;var date = &lt;span class=&quot;hljs-string&quot;&gt;'815';
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;getDate(&lt;span class=&quot;hljs-params&quot;&gt;str){
    &lt;span class=&quot;hljs-built_in&quot;&gt;console.log(str + date);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、闭包可以更新外部变量的值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;updateCount(&lt;span class=&quot;hljs-params&quot;&gt;){
  &lt;span class=&quot;hljs-keyword&quot;&gt;var count = &lt;span class=&quot;hljs-number&quot;&gt;0;
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;getCount(&lt;span class=&quot;hljs-params&quot;&gt;val){
    count = val;
    &lt;span class=&quot;hljs-built_in&quot;&gt;console.log(count);
  }
  &lt;span class=&quot;hljs-keyword&quot;&gt;return getCount;     &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、作用域链&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;javascript中有一个执行上下文（execution context）的概念，它定义了变量或函数有权访问的其他数据，决定它们各自的行为。每一个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。你可以把它当做Javascript的一个普通对象，但是你只能修改它的属性，却不能引用它。&lt;/p&gt;
&lt;p&gt;变量对象也是有父作用域的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用域链定义&lt;/strong&gt;：当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不再存在父作用域了，这就是作用域链。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用域链和原型继承有点类似，但又有点小区别&lt;/strong&gt;：如果去查找一个普通对象的属性时，在当前对象和其原型中都找不到时，会返回undefined；但查找的属性在作用域链中不存在的话就会抛出ReferenceError。&lt;/p&gt;
&lt;p&gt;作用域链的顶端是全局对象。对于全局环境中的代码，作用域链只包含一个元素：全局对象。所以，在全局环境中定义变量的时候，它们就会被定义到全局对象中。当函数被调用的时候，作用域链就会包含多个作用域对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、全局环境&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于作用域链讲得略多(红皮书上有关于作用域及执行环境的详细解释)，看一个简单地例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;在全局环境中，创建了两个简单地变量。如前面所说，此时变量对象是全局对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/31BNIPZFyRiTp1_BlU5J5z3CAQ.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行上述代码，my_script.js本身会形成一个执行环境，以及它所引用的变量对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.1无嵌套函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;定义时&lt;/strong&gt;：当myFunc被定义的时候，myFunc的标识符（identifier）就被加到了全局对象中，这个标识符所引用的是一个函数对象（myFunc function object）。&lt;/p&gt;
&lt;p&gt;内部属性[[scope]]指向当前的作用域对象，也就是函数的标识符被创建的时候，我们所能够直接访问的那个作用域对象（即全局对象）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/31HOyw8toT-8IoyVyeouZEirSk.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;myFunc所引用的函数对象，其本身不仅仅含有函数的代码，并且还含有指向其被创建的时候的作用域对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用时&lt;/strong&gt;：当myFunc函数被调用的时候，一个新的作用域对象被创建了。新的作用域对象中包含myFunc函数所定义的本地变量，以及其参数（arguments）。这个新的作用域对象的父作用域对象就是在运行myFunc时能直接访问的那个作用域对象（即全局对象）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/31FuNRWBdFr_Q3uiXGszWE3n2z.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2嵌套函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当函数返回没有被引用的时候，就会被垃圾回收器回收。但是对于闭包，即使外部函数返回了，函数对象仍会引用它被&lt;strong&gt;创建时&lt;/strong&gt;的作用域对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&quot;use strict&quot;;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;createCounter(&lt;span class=&quot;hljs-params&quot;&gt;initial) {
  &lt;span class=&quot;hljs-keyword&quot;&gt;var counter = initial;
  
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;increment(&lt;span class=&quot;hljs-params&quot;&gt;value) {
    counter += value;
  }
  
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;get(&lt;span class=&quot;hljs-params&quot;&gt;) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return counter;
  }
  
  &lt;span class=&quot;hljs-keyword&quot;&gt;return {
    increment: increment,
    get: get
  };
}

&lt;span class=&quot;hljs-keyword&quot;&gt;var myCounter = createCounter(&lt;span class=&quot;hljs-number&quot;&gt;100);
&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(myCounter.get());   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用 createCounter(100) 时，内嵌函数increment和get都有指向createCounter(100) scope的引用。&lt;strong&gt;假设&lt;/strong&gt;createCounter(100)没有任何返回值，那么createCounter(100) scope不再被引用，于是就可以被垃圾回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/31w93n77ZrHs1QV2UXm8-nuYJz.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是createCounter(100)实际上是有返回值的，并且返回值被存储在了myCounter中，所以对象之间的引用关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/31C6IkjcFwmi-wrDUlgJMX1PoX.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即使createCounter(100)已经返回，但是其作用域仍在，并且只能被内联函数访问。可以通过调用myCounter.increment() 或 myCounter.get()来直接访问createCounter(100)的作用域。&lt;/p&gt;
&lt;p&gt;当myCounter.increment() 或 myCounter.get()被调用时，新的作用域对象会被创建，并且该作用域对象的父作用域对象会是当前可以直接访问的作用域对象。&lt;/p&gt;
&lt;p&gt;调用get()时，当执行到return counter时，在get()所在的作用域并没有找到对应的标示符，就会沿着作用域链往上找，直到找到变量counter，然后返回该变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/31co_qbvvMWRD0Y0INdbrVBTk8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单独调用increment(5)时，参数value保存在当前的作用域对象。当函数要访问counter时，没有找到，于是沿着作用域链向上查找，在createCounter(100)的作用域找到了对应的标示符，increment()就会修改counter的值。除此之外，没有其他方式来修改这个变量。闭包的强大也在于此，能够存贮私有数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/315q5ALd3xZ0tngopD-_Uhppu-.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;创建两个函数：&lt;code&gt;myCounter1&lt;/code&gt;和&lt;code&gt;myCounter2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;关系图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/31KyMTzv_D0Cn-fdfO1ALfB79M.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;myCounter1.increment和myCounter2.increment的函数对象拥有着一样的代码以及一样的属性值（name，length等等），但是它们的[[scope]]指向的是不一样的作用域对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、参考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dwqs/blog/issues/18&quot; target=&quot;_blank&quot;&gt;https://github.com/dwqs/blog/issues/18&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Feb 2019 14:25:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>一、概要 对于闭包的定义（红宝书P178）：闭包就是指有权访问另外一个函数的作用域中的变量的函数。 关键点： 1、闭包是一个函数 2、能够访问另外一个函数作用域中的变量 文章首发地址于sau交流学习社</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10415735.html</dc:identifier>
</item>
<item>
<title>整合X-Admin前端框架改造ABP - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10403132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10403132.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　“站在巨人的肩膀上”，这样一来，不要万事亲恭，在值得的方向上节约时间，毕竟人生就这么一次。在接触ABP以来，一直想花点时间整合LayUI前端框架到ABP中，进而能够逐渐打磨出一套适合自己的框架，开发习惯、项目架构、界面风格等等。在年前花了点时间了解了LayUI现有的后台模板，虽然LayUI自家的LayUIAdmin很不错，但奈何于贫穷，因此绕道看看是否有前端同胞已经弄出来一份免费版的，比较了几份后台模板后，找到了合适的X-Admin。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;演示地址：&lt;/strong&gt;&lt;a href=&quot;http://123.207.15.233:9527/&quot; target=&quot;_blank&quot;&gt;http://123.207.15.233:9527/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 　&lt;strong&gt;　码云地址：&lt;/strong&gt;&lt;a href=&quot;https://gitee.com/530521314/PithyDesign.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/530521314/PithyDesign.git&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;一、X-Admin前端框架和ABP框架&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　X-Admin是基于LayUI打造的一套前端框架，比起Bootstrap那种粗犷的风格，LayUI更加符合国人的审美观，同时LayUI也对后端开发人员友好，在不完全掌握前端知识的前提下也能够进行项目开发，官网地址：&lt;a href=&quot;http://x.xuebingsi.com/&quot; target=&quot;_blank&quot;&gt;http://x.xuebingsi.com/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　ABP框架是一个用最佳实践和流行技术开发现代Web应用程序的新起点，旨在快速搭建一个通用的Web应用框架和项目模板，集成着一些优秀的工具和思想，官网地址：&lt;a href=&quot;https://aspnetboilerplate.com/&quot; target=&quot;_blank&quot;&gt;https://aspnetboilerplate.com/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　如果觉得自己组合一套框架觉得繁琐，可以试试使用52ABP框架，该套优秀的前后端框架由梁桐铭在ABP框架的基础上进行整合，对于前后端相关功能进行改造，使满足国人的开发习惯，官网地址：&lt;a href=&quot;https://www.52abp.com/&quot; target=&quot;_blank&quot;&gt;https://www.52abp.com/&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;二、开始整合两个框架&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　1、先从ABP官网下载项目模板。经过文件结构调整后，项目文件路径如下，之所以项目文件路径和官网下载下来的不完全一致，是经过了一些调整，适用自己的开发习惯，毕竟适合的才是最好的，在之前的&lt;a href=&quot;https://www.cnblogs.com/CKExp/p/9860427.html&quot; target=&quot;_blank&quot;&gt;生成流水线搭建中&lt;/a&gt;也提到过项目结构，目的是使之标准化，而不需要每次都要重新设置一下项目文件结构。(&lt;strong&gt;注意，此处我下载的是.Net Core+MPA版+去掉登录、注册、用户、角色和多租户功能&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190220222258914-349359430.png&quot; alt=&quot;&quot; width=&quot;796&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2、下载X-Admin源码包，解压后，开始着手Ctrl+C、V操作，将需要的一些js、css等文件移入到ABP中。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190220221000627-1642025122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　3、去除在本次整合后部分在ABP中的不再需要的功能，如Boostrap及其相关的插件，并不是Boostrap不优秀而是LayUI是我的目的，功能相似下，没必要在冗余存在。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190220223409112-574710225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　并在bower包管理中删除对Boostrap的依赖，尽可能的使用大部分LayUI及LayUI社区提供的插件和功能，以减少后端开发人员的学习和使用成本。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190220223505320-1886583432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　4、将X-Admin文件夹中的js文件及css文件移入到ABP中，部分ABP分装了一层的js、css保持不变，仍然先存放着，如果后期确定不再使用，再进行移除ABP下载后自带了一个main.css文件，可以使用这个文件或直接使用X-Admin中的css文件。　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190220224049095-486162967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5、以现有的Layout母版页复制一个(此处我命名为_LayoutBase)，从X-Admin文件夹中查看index.html并复制Body标签内的代码到_Layout母版页的Body中(我对底部的footer删除了，位置不太合适)，整理引用的js、css文件，具体可见我的Git仓库中，使用控制器Home,方法Index的视图作为使用_LayoutBase母版页的视图，其余页面都将在Index界面中以iframe的形式出现，到现在，直接启动项目后，初步的界面可以展现出来了。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190220224958308-1703538482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;三、优化展示效果&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　1、X-Admin中，对于侧边栏收缩采用的是直接全部隐藏，在该功能的基础上改造一些功能，使得收缩后可以留下一列图标，实现方式可以有很多种，此处采取使用js脚本去控制左侧菜单宽度实现，在xadmin.js脚本中，找到&lt;strong&gt;$('.container .left_open').click()&lt;/strong&gt;方法，然后在此基础上进行改造，如以下改造，注意，部分css也需要改造，具体见仓库源代码中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
$('.container .left_open').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!$('.left-nav #nav .layui-nav-item').hasClass('nav-mini'&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左侧菜单&lt;/span&gt;
        $('.left-nav #nav .layui-nav-item').addClass('nav-mini'&lt;span&gt;);
        $(&lt;/span&gt;'.left-nav').animate({ left: '0px', width: '60px' }, 100&lt;span&gt;);
        $(&lt;/span&gt;'.sub-menu li').each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).hide();
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右侧内容&lt;/span&gt;
        $('.page-content').animate({ left: '60px' }, 100&lt;span&gt;);
        $(&lt;/span&gt;'.page-content-bg'&lt;span&gt;).hide();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左侧菜单&lt;/span&gt;
        $('.left-nav .layui-nav-item').removeClass('nav-mini'&lt;span&gt;);
        $(&lt;/span&gt;'.left-nav').animate({ left: '0px', width: '220px' }, 100, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;'.sub-menu li').each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).show();
            });
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右侧内容&lt;/span&gt;
        $('.page-content').animate({ left: '220px' }, 100&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($(window).width() &amp;lt; 768&lt;span&gt;) {
            $(&lt;/span&gt;'.page-content-bg'&lt;span&gt;).show();
        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　2、加入语言为简体中文，在领域层中的本地资源配置中加入中文及中文语言包，此处我将中文设置为默认语言，更改原有默认的英文包的PithyDesign为PithyDesign-en，并增加一个PithyDesign.json内容与英文包一样，将英文译成中文即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190221213111005-955050302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　增加中文并设置为默认选项，如有更多语言，可以在此基础上进行扩展。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190221212041673-174573465.png&quot; alt=&quot;&quot; width=&quot;940&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、对X-Admin代码包中存在的一些其它界面加入到ABP中如用户、管理员的增删改查界面、地址三级联动、百度的ECharts图表展示界面等，在增加前需要注意母版页的设置，在按Url：Home/Index进入后台界面后，Index视图直接套用_LayoutBase母版页，然后其它功能页以iframe的形式嵌入，其余功能页使用_Layout母版页。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190221215000364-1823276173.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;655&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　至此，整合工作算是完成了，后期考虑提高一些操作上的体验感，同时逐步完善如用户登录、注册、组织机构、角色等基础功能。&lt;/p&gt;

&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;&lt;span class=&quot;hljs-number&quot;&gt;2019-&lt;span class=&quot;hljs-number&quot;&gt;02-&lt;span class=&quot;hljs-number&quot;&gt;21,望技术有成后能回来看见自己的脚步&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 21 Feb 2019 13:58:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>“站在巨人的肩膀上”，这样一来，不要万事亲恭，在值得的方向上节约时间，毕竟人生就这么一次。在接触ABP以来，一直想花点时间整合LayUI前端框架到ABP中，进而能够逐渐打磨出一套适合自己的框架，开发习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/10403132.html</dc:identifier>
</item>
<item>
<title>补习系列(16)-springboot mongodb 数据库应用技巧 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10415569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10415569.html</guid>
<description>&lt;h2 id=&quot;一关于-mongodb&quot;&gt;一、关于 MongoDB&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201902/242916-20190221214305541-498285244.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MongoDB 目前非常流行，在最近的&lt;a href=&quot;https://db-engines.com/en/ranking&quot;&gt;DB-Engine&lt;/a&gt;排名中居第5位，仅次于传统的关系型数据库如 Oracle、Mysql。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201902/242916-20190221214337091-181575137.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而在非关系型数据库领域，MongoDB已经持续成为佼佼者一段时间了，这与 MongoDB的一些优势存在一定关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无模式(Schema)，便于快速开发；&lt;/li&gt;
&lt;li&gt;面向文档化的数据，基于BSON格式(类JSON)，灵活性强&lt;/li&gt;
&lt;li&gt;高性能，得益于其内存计算能力；&lt;/li&gt;
&lt;li&gt;副本集、自动分片特性，提供了高可用及水平扩展能力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MongoDB 的主要对象包括数据库（database）、集合（collection）、文档对象（document），与关系型数据库的对应关系如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;schema&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;collection&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;record&lt;/td&gt;
&lt;td&gt;document&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;column&lt;/td&gt;
&lt;td&gt;field&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;与关系型数据库一样，MongoDB也支持索引(不支持外键)，然而其没有定义固定的列(Column)，字段可以是任何类型的值，比如数值、数组或嵌套文档等。&lt;br/&gt;在最近发布的4.0版本中，MongoDB开始支持事务。可见，在未来这些数据库之间的差异只会越来越少。&lt;/p&gt;
&lt;h2 id=&quot;二spring-data-mongo&quot;&gt;二、Spring-Data-Mongo&lt;/h2&gt;
&lt;p&gt;Spring-Data-Mongo 是Spring框架对于MongoDB 数据读写的ORM 封装，&lt;br/&gt;与 大家熟悉的 JPA一样，其在MongoDB-Java-Driver基础之上做了一些封装，令应用开发更加简便。&lt;/p&gt;
&lt;p&gt;如下是&lt;strong&gt;SpringData&lt;/strong&gt; 整体框架的一个概要：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201902/242916-20190221214415279-268603964.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看出，SpringData 是基于分层设计的。从下之上，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库层；&lt;/li&gt;
&lt;li&gt;驱动层(JDBC/Driver)；&lt;/li&gt;
&lt;li&gt;ORM层(Repository)；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三整合-mongodb-crud&quot;&gt;三、整合 MongoDB CRUD&lt;/h2&gt;
&lt;p&gt;接下来的篇幅，主要针对如何在项目中使用框架进行MongoDB数据库的读写，部分代码可供参考。&lt;/p&gt;
&lt;h3 id=&quot;a.-引入框架&quot;&gt;A. 引入框架&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-mongodb&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;strong&gt;&lt;em&gt;spring-boot-starter-mongodb&lt;/em&gt;&lt;/strong&gt; 是一个胶水组件，声明对它的依赖会令项目自动引入&lt;strong&gt;&lt;em&gt;spring-data-mongo&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;mongodb-java-driver&lt;/em&gt;&lt;/strong&gt;等基础组件。&lt;/p&gt;
&lt;h3 id=&quot;b.-数据库配置&quot;&gt;B. 数据库配置&lt;/h3&gt;
&lt;p&gt;我们在 &lt;strong&gt;application.properties&lt;/strong&gt; 中声明一段配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.data.mongodb.host=127.0.0.1
spring.data.mongodb.port=27017
spring.data.mongodb.username=appuser
spring.data.mongodb.password=appuser@2016
spring.data.mongodb.database=appdb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难理解，这里是数据库主机、端口、用户密码、数据库的设置。&lt;/p&gt;
&lt;h3 id=&quot;c.-数据模型&quot;&gt;C. 数据模型&lt;/h3&gt;
&lt;p&gt;接下来，要定义数据集合(collection) 的一个结构，以 &lt;strong&gt;Book&lt;/strong&gt;实体为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Document(collection = &quot;book&quot;)
@CompoundIndexes({ @CompoundIndex(name = &quot;idx_category_voteCount&quot;, def = &quot;{'category': 1, 'voteCount': 1}&quot;),
        @CompoundIndex(name = &quot;idx_category_createTime&quot;, def = &quot;{'category': 1, 'createTime': 1}&quot;) })
public class Book {

    @Id
    private String id;

    @Indexed
    private String author;

    private String category;

    @Indexed
    private String title;

    private int voteCount;
    private int price;

    @Indexed
    private Date publishDate;

    private Date updateTime;
    private Date createTime;
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们给Book 实体定义了一些属性：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;书籍ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;author&lt;/td&gt;
&lt;td&gt;作者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;category&lt;/td&gt;
&lt;td&gt;书籍分类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;书籍标题&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;voteCount&lt;/td&gt;
&lt;td&gt;投票数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;price&lt;/td&gt;
&lt;td&gt;价格&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;publishDate&lt;/td&gt;
&lt;td&gt;发布日期&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;updateTime&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;createTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;除此以外，我们还会用到几个注解：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@Document&lt;/td&gt;
&lt;td&gt;声明实体为MongoDB文档&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@Id&lt;/td&gt;
&lt;td&gt;标记ID属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@Indexed&lt;/td&gt;
&lt;td&gt;单键索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@CompoundIndexes&lt;/td&gt;
&lt;td&gt;复合索引集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@CompoundIndex&lt;/td&gt;
&lt;td&gt;复合索引&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;关于MongoDB索引形态，可以参考&lt;a href=&quot;https://docs.mongodb.com/manual/indexes/&quot;&gt;官方文档&lt;/a&gt;做一个详细了解。&lt;/p&gt;
&lt;h3 id=&quot;d.-数据操作&quot;&gt;D. 数据操作&lt;/h3&gt;
&lt;p&gt;ORM 框架可以让你通过操作对象来直接影响数据，这样一来，可以大大减少上手的难度，你不再需要熟悉大量驱动层的API了。&lt;br/&gt;Spring-Data-Mongo 实现了类JPA的接口，通过预定义好的Repository可实现&lt;strong&gt;代码方法到数据库操作语句DML&lt;/strong&gt;的映射。&lt;br/&gt;下面是一些例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BookRepository&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface BookRepository extends MongoRepository&amp;lt;Book, String&amp;gt; {

    public List&amp;lt;Book&amp;gt; findByAuthor(String author);

    public List&amp;lt;Book&amp;gt; findByCategory(String category, Pageable pageable);

    public Book findOneByTitle(String title);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们所看到的 &lt;strong&gt;&lt;em&gt;findByAttribute&lt;/em&gt;&lt;/strong&gt; 将会直接被转换成对应的条件查询，如 findByAuthor 等价于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.find({author:'Lilei'})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们可以方便的在业务逻辑层(service层) 对Repository 进行调用，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class BookService {

    @Autowired
    private BookRepository bookRepository;

    private static final Logger logger = LoggerFactory.getLogger(BookService.class);

    /**
     * 创建book
     * 
     * @param category
     * @param title
     * @param author
     * @param price
     * @param publishDate
     * @return
     */
    public Book createBook(String category, String title, String author, int price, Date publishDate) {
        if (StringUtils.isEmpty(category) || StringUtils.isEmpty(title) || StringUtils.isEmpty(author)) {
            return null;
        }

        Book book = new Book();
        book.setAuthor(author);
        book.setTitle(title);
        book.setCategory(category);
        book.setPrice(price);
        book.setPublishDate(publishDate);

        book.setVoteCount(0);
        book.setCreateTime(new Date());
        book.setUpdateTime(book.getCreateTime());

        return bookRepository.save(book);
    }

    /**
     * 更新价格
     * 
     * @param id
     * @param price
     * @return
     */
    public boolean updatePrice(String id, int price) {
        if (StringUtils.isEmpty(id)) {
            return false;
        }

        Book book = bookRepository.findOne(id);
        if (book == null) {

            logger.info(&quot;the book '{}' is not exist&quot;, id);
            return false;
        }

        book.setPrice(price);
        book.setUpdateTime(new Date());
        if (bookRepository.save(book) != null) {
            return true;
        }
        return false;
    }

    /**
     * 根据获取book
     * 
     * @param title
     * @return
     */
    public Book getBookByTitle(String title) {
        if (StringUtils.isEmpty(title)) {
            return null;
        }
        return bookRepository.findOneByTitle(title);
    }

    /**
     * 获取投票排行列表
     * 
     * @param category
     * @param max
     * @return
     */
    public List&amp;lt;Book&amp;gt; listTopVoted(String category, int max) {

        if (StringUtils.isEmpty(category) || max &amp;lt;= 0) {
            return Collections.emptyList();
        }

        // 按投票数倒序排序
        Sort sort = new Sort(Direction.DESC, Book.COL_VOTE_COUNT);
        PageRequest request = new PageRequest(0, max, sort);

        return bookRepository.findByCategory(category, request);

    }

    /**
     * 删除书籍
     * 
     * @param id
     * @return
     */
    public boolean deleteBook(String id) {
        Book book = bookRepository.findOne(id);
        if (book == null) {

            logger.info(&quot;the book '{}' is not exist&quot;, id);
            return false;
        }

        bookRepository.delete(book);
        return true;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于Repository 映射规则，可以从&lt;a href=&quot;https://docs.spring.io/spring-data/mongodb/docs/2.1.0.M3/reference/html/#mongodb.repositories.queries&quot;&gt;这里&lt;/a&gt;找到详细介绍。&lt;/p&gt;
&lt;h3 id=&quot;e.-自定义操作&quot;&gt;E. 自定义操作&lt;/h3&gt;
&lt;p&gt;有时候，Repository的方法映射无法较好的满足一些特定场景，比如高级检索、局部更新、覆盖索引查询等等，&lt;br/&gt;此时可以使用框架提供的 &lt;strong&gt;MongoTemplate&lt;/strong&gt; 工具类来完成这些定制，MongoTemplate 提供了大量的 &lt;strong&gt;Criteria API&lt;/strong&gt; 来封装 Mongo-Java-Driver的实现。&lt;br/&gt;我们一方面可以选择直接使用该API，另一方面，则可以更加&lt;strong&gt;&quot;优雅&quot;&lt;/strong&gt;的整合到Repository 接口，如下面的代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;声明 Custom 接口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface BookRepositoryCustom {

    public PageResult&amp;lt;Book&amp;gt; search(String category, String title, String author, Date publishDataStart,
            Date publishDataEnd, Pageable pageable);

    public boolean incrVoteCount(String id, int voteIncr);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;声明接口继承关系&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface BookRepository extends MongoRepository&amp;lt;Book, String&amp;gt;, BookRepositoryCustom{&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class BookRepositoryImpl implements BookRepositoryCustom {

    @Autowired
    private MongoTemplate mongoTemplate;

    public boolean incrVoteCount(String id, int voteIncr) {
        if (StringUtils.isEmpty(id)) {
            return false;
        }

        Query query = new Query();
        query.addCriteria(Criteria.where(&quot;id&quot;).is(id));

        Update update = new Update();

        update.inc(Book.COL_VOTE_COUNT, voteIncr);
        update.set(Book.COL_UPDATE_TIME, new Date());

        WriteResult result = mongoTemplate.updateFirst(query, update, Book.class);
        return result != null &amp;amp;&amp;amp; result.getN() &amp;gt; 0;
    }

    @Override
    public PageResult&amp;lt;Book&amp;gt; search(String category, String title, String author, Date publishDataStart,
            Date publishDataEnd, Pageable pageable) {
        Query query = new Query();

        if (!StringUtils.isEmpty(category)) {
            query.addCriteria(Criteria.where(Book.COL_CATEGORY).is(category));
        }

        if (!StringUtils.isEmpty(author)) {
            query.addCriteria(Criteria.where(Book.COL_AUTHOR).is(author));
        }

        if (!StringUtils.isEmpty(title)) {
            query.addCriteria(Criteria.where(Book.COL_TITLE).regex(title));
        }

        if (publishDataStart != null || publishDataEnd != null) {
            Criteria publishDateCond = Criteria.where(Book.COL_PUBLISH_DATE);

            if (publishDataStart != null) {
                publishDateCond.gte(publishDataStart);
            }
            if (publishDataEnd != null) {
                publishDateCond.lt(publishDataEnd);
            }
            query.addCriteria(publishDateCond);
        }

        long totalCount = mongoTemplate.count(query, Book.class);
        if (totalCount &amp;lt;= 0) {
            return new PageResult&amp;lt;Book&amp;gt;();
        }

        if (pageable != null) {
            query.with(pageable);
        }

        List&amp;lt;Book&amp;gt; books = mongoTemplate.find(query, Book.class);
        return PageResult.of(totalCount, books);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用 AOP的魔法 ，Spring 框架会自动将我们这段代码实现&lt;strong&gt;织入&lt;/strong&gt; 到Bean对象中，&lt;br/&gt;这样一来，我们原先对Repository的依赖引用方式就不需要改变了。&lt;/p&gt;
&lt;h2 id=&quot;四高级技巧&quot;&gt;四、高级技巧&lt;/h2&gt;
&lt;p&gt;SpringBoot中完成Mongodb的自动化配置，是通过MongoAutoConfiguration、MongoDataAutoConfiguration完成的。&lt;/p&gt;
&lt;p&gt;其中MongoAutoConfiguration的实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@ConditionalOnClass(MongoClient.class)
@EnableConfigurationProperties(MongoProperties.class)
@ConditionalOnMissingBean(type = &quot;org.springframework.data.mongodb.MongoDbFactory&quot;)
public class MongoAutoConfiguration {

    private final MongoProperties properties;

    private final MongoClientOptions options;

    private final Environment environment;

    private MongoClient mongo;

    public MongoAutoConfiguration(MongoProperties properties,
            ObjectProvider&amp;lt;MongoClientOptions&amp;gt; options, Environment environment) {
        this.properties = properties;
        this.options = options.getIfAvailable();
        this.environment = environment;
    }

    @PreDestroy
    public void close() {
        if (this.mongo != null) {
            this.mongo.close();
        }
    }

    @Bean
    @ConditionalOnMissingBean
    public MongoClient mongo() throws UnknownHostException {
        this.mongo = this.properties.createMongoClient(this.options, this.environment);
        return this.mongo;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码可见，如果应用代码中未声明 MongoClient、MongoDbFactory，那么框架会根据配置文件自动做客户端的初始化。&lt;br/&gt;通过声明，可以取消这些自动化配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableAutoConfiguration(exclude = { EmbeddedMongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
        MongoAutoConfiguration.class })
public class DemoBoot {
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;真实线上的项目中，会对MongoDB 客户端做一些定制，下面的介绍几个用法&lt;/p&gt;
&lt;h3 id=&quot;连接池配置&quot;&gt;1. 连接池配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class MongoConfig {

    @Bean
    public MongoDbFactory mongoFactory(MongoProperties mongo) throws Exception {

        MongoClientOptions.Builder builder = new MongoClientOptions.Builder();
        // 连接池配置
        builder.maxWaitTime(1000 * 60 * 1).socketTimeout(30 * 1000).connectTimeout(10 * 1000).connectionsPerHost(60)
                .minConnectionsPerHost(60).socketKeepAlive(true);

        // 设置鉴权信息
        MongoCredential credential = null;
        if (!StringUtils.isEmpty(mongo.getUsername())) {
            credential = MongoCredential.createCredential(mongo.getUsername(), mongo.getDatabase(),
                    mongo.getPassword());
        }

        MongoClientOptions mongoOptions = builder.build();

        List&amp;lt;ServerAddress&amp;gt; addrs = Arrays.asList(new ServerAddress(mongo.getHost(), mongo.getPort()));
        MongoClient mongoClient = null;
        if (credential != null) {
            mongoClient = new MongoClient(addrs, Arrays.asList(credential), mongoOptions);
        } else {
            mongoClient = new MongoClient(addrs, mongoOptions);
        }
        return new SimpleMongoDbFactory(mongoClient, mongo.getDatabase());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们所关心的，往往是连接池大小、超时参数阈值、队列这几个，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//连接池最小值
private int minConnectionsPerHost;
//连接池最大值
private int maxConnectionsPerHost = 100;
//线程等待连接阻塞系数
private int threadsAllowedToBlockForConnectionMultiplier = 5;
//选择主机超时
private int serverSelectionTimeout = 1000 * 30;
//最大等待
private int maxWaitTime = 1000 * 60 * 2;
//最大连接闲时
private int maxConnectionIdleTime;
//最大连接存活
private int maxConnectionLifeTime;
//TCP建立连接超时
private int connectTimeout = 1000 * 10;
//TCP读取超时
private int socketTimeout = 0;
//TCP.keepAlive是否启用
private boolean socketKeepAlive = true;
//心跳频率
private int heartbeatFrequency = 10000;
//最小心跳间隔
private int minHeartbeatFrequency = 500;
//心跳TCP建立连接超时
private int heartbeatConnectTimeout = 20000;
//心跳TCP读取超时
private int heartbeatSocketTimeout = 20000;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;去掉_class属性&quot;&gt;2. 去掉_class属性&lt;/h3&gt;
&lt;p&gt;通过 SpringDataMongo 定义的实体，会自动写入一个***_class***属性，大多数情况下这个不是必须的，可以通过配置去掉：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Bean
    public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory, MongoMappingContext context) {

        DbRefResolver dbRefResolver = new DefaultDbRefResolver(mongoDbFactory);
        MappingMongoConverter converter = new MappingMongoConverter(dbRefResolver, context);
        converter.setTypeMapper(new DefaultMongoTypeMapper(null));

        converter.afterPropertiesSet();

        MongoTemplate mongoTemplate = new MongoTemplate(mongoDbFactory, converter);

        return mongoTemplate;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义序列化&quot;&gt;3. 自定义序列化&lt;/h3&gt;
&lt;p&gt;一些基础的字段类型，如 int 、long、string，通过JDK 装箱类就可以完成，&lt;br/&gt;对于内嵌的对象类型，SpringDataMongo框架会将其转换为 DBObject对象(java driver 实体)。&lt;br/&gt;一般情况下这已经足够了，但某些场景下你不得不实现自己的序列化方式，比如通过文档存储某些特殊格式的内容。&lt;/p&gt;
&lt;p&gt;这需要用到 Converter 接口，如下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   @Bean
    public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory, MongoMappingContext context) {

        DbRefResolver dbRefResolver = new DefaultDbRefResolver(mongoDbFactory);
        MappingMongoConverter converter = new MappingMongoConverter(dbRefResolver, context);
        converter.setTypeMapper(new DefaultMongoTypeMapper(null));

        // 自定义转换
        converter.setCustomConversions(customConversions());
        converter.afterPropertiesSet();

        MongoTemplate mongoTemplate = new MongoTemplate(mongoDbFactory, converter);
        return mongoTemplate;
    }

    private CustomConversions customConversions() {
        List&amp;lt;Converter&amp;lt;?, ?&amp;gt;&amp;gt; converters = new ArrayList&amp;lt;Converter&amp;lt;?, ?&amp;gt;&amp;gt;();
        converters.add(new BasicDBObjectWriteConverter());
        converters.add(new BasicDBObjectReadConverter());
        return new CustomConversions(converters);
    }

    /**
     * 写入序列化
     */
    @WritingConverter
    public static class BasicDBObjectWriteConverter implements Converter&amp;lt;BasicDBObject, String&amp;gt; {

        public String convert(BasicDBObject source) {
            if (source == null) {
                return null;
            }
            return source.toJson();
        }
    }

    /**
     * 读取反序列化
     */
    @ReadingConverter
    public static class BasicDBObjectReadConverter implements Converter&amp;lt;String, BasicDBObject&amp;gt; {

        public BasicDBObject convert(String source) {
            if (source == null || source.length() &amp;lt;= 0) {
                return null;
            }
            return BasicDBObject.parse(source);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读写分离&quot;&gt;4. 读写分离&lt;/h3&gt;
&lt;p&gt;MongoDB 本身支持读写分离的实现，前提是采用副本集、分片副本集的架构，&lt;br/&gt;通过声明客户端的 ReadPreference 级别可以达到优先读主、优先读备的控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class MongoConfig {

    @Bean(name=&quot;secondary&quot;)
    public MongoDbFactory mongoFactory(MongoProperties mongo) throws Exception {

        MongoClientOptions.Builder builder = new MongoClientOptions.Builder();
        // 连接池配置
        builder.maxWaitTime(1000 * 60 * 1).socketTimeout(30 * 1000).connectTimeout(10 * 1000).connectionsPerHost(60)
                .minConnectionsPerHost(60).socketKeepAlive(true);
        // 优先读备节点
        builder.readPreference(ReadPreference.secondaryPreferred());
        ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，将会为MongoClient 设置 &lt;strong&gt;secondaryPreferred&lt;/strong&gt; 的读级别。&lt;br/&gt;ReadPreference 级别包括以下几种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;primary&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;默认值，只从主节点读，主节点不可用时报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;primaryPreferred&lt;/td&gt;
&lt;td&gt;优先主节点(primary)读，主节点不可用时到从节点(secondary)读&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;secondary&lt;/td&gt;
&lt;td&gt;仅从备节点(secondary)读取数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;secondaryPreferred&lt;/td&gt;
&lt;td&gt;优先从备节点读，从节点不可用时到主节点读取&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;nearest&lt;/td&gt;
&lt;td&gt;到网络延迟最低的节点读取数据，不管是主节点还是从节点&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;a href=&quot;https://gitee.com/littleatp/springboot-samples&quot;&gt;Gitee同步代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;MongoDB 是当下 NoSQL 数据库的首选，也有不少服务化架构采用了 MongoDB作为主要数据库，&lt;br/&gt;其在 4.x版本中即将推出事务功能，在未来该文档数据库相对于RDBMS的差距将会大大缩小。&lt;br/&gt;也正由于MongoDB 具备 简单、易扩展、高性能等特性，其社区活跃度非常高，是非常值得关注和学习的。&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 13:54:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 一、关于 MongoDB MongoDB 目前非常流行，在最近的 'DB Engine' 排名中居第5位，仅次于传统的关系型数据库如 Oracle、Mysql。 然而在非关系型数据库领域，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10415569.html</dc:identifier>
</item>
<item>
<title>游戏服务器h2engine架构优化和跨平台设计 - 知然</title>
<link>http://www.cnblogs.com/zhiranok/p/h2enginewin.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhiranok/p/h2enginewin.html</guid>
<description>&lt;p&gt;H2engine的GitHub星星不知不觉已经破百了，也没有特意推广过，但是慢慢的关注的人越来越多。因为事情多，好久没有写东西了，前一段时间有了一些想法，把h2engine又更新了一下，感觉h2engine又向前迈了一大步。本文记录一下最近的心得体会，以及做出的相应修改。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201902/282357-20190221202933929-1765334617.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于rpc&quot;&gt;关于RPC&lt;/h2&gt;
&lt;p&gt;H2engine的rpc部分使用的是原来fflib的ffrpc组件，ffrpc设计的比较强大，但是因为h2engie的架构特点，ffrpc的一些功能用不到，很多网友都询问我关于rpc部分的设计问题，我仔细思考后觉得确实可以把h2engine的rpc部分进行简化，这样对于使用者而言更容易理解。&lt;br/&gt;先看一下h2engine的架构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;H2engine设计的为单gate，单服环境内linux下一个gate完全能够满足性能要求，Apache/nigx都是一个进程不是吗？单gate让分布式的结构大大简化。我们知道一般单服架构都有个loginserver，现在可以省略了，因为单gate，每个服直接配置gate地址。&lt;/li&gt;
&lt;li&gt;H2engine为多进程架构，但是h2engine限定了采用伪分布式的设计，虽然gate和gameserver通过网络通信，但是限定了gate和gameserver在一台机器上。虽然gate和gameserver放在不同机器上也可以通信，但是我们从现实运营的情况出发，很少运维会把gate和gameserver放不同机器上，一般有的时候一台机器上甚至有多个服。所以伪分布式是既能满足需求又能大大简化架构的一个设计。&lt;/li&gt;
&lt;li&gt;采用伪分布式设计后，gameserver之间就可以利用共享内存了，全局的数据比如排行榜、行会、好友、组队等，这些模块都是分布式进程中最费时费力容易出错的，但是在h2engine里变得逻辑清晰，直接操作全局内存就可以了，全同步。&lt;/li&gt;
&lt;li&gt;Rpc模块进行了简化，其实rpc通信分三种，gate调用gameserver接口，gameserver调用gate接口，和gameserver与gameserver之间调用，发现没，所有架构内rpc都需要通过gate，而且h2engine是单gate伪分布式（127.0.0.1速度飞起），那么整个rpc结构就变得非常清晰简单，感兴趣的可以看下gate的broker文件和rpc文件。这两个文件一个是gate端中转，一个是请求端封装，非常简洁。&lt;/li&gt;
&lt;li&gt;网络层进行了升级，原来socket是裸的指针，很多网友还是表达了不知道什么时候应该调用safedelete的问题，所以还是改成了智能指针，不需要关系socket什么时候释放。另外socket的私有数据进行了泛型封装，可以存入任何私有数据类型。&lt;br/&gt;共享内存的简单示意：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201902/282357-20190221203025771-351202048.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;关于跨平台&quot;&gt;关于跨平台&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;2engine一直是只支持linux下编译，Windows的移植一直没有时间弄，虽然行业内大部分服务器都是跑linux的，但是如果可以Windows下可以开发调试，那对于提高平常的开发效率来说将会大有裨益。&lt;br/&gt;&lt;/em&gt;2engine由于一开始是在linux下gcc下开发的，那么在Windows下也用gcc，那么需要修改的跨平台代码将会非常少，本着这个思路，h2engine成功移植到了Windows，并且改动的非常少。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Windows下的虽然有mingw直接包含了gcc环境，但是想用上cmake等编译工具还是挺麻烦的，所以我找了一个集成mingw且算得上比较流行的一个Windows IDE：CodeBlocks。见了一个CodeBlocks的项目，想要在Windows下运行只要下载一个CodeBlocks，然后双击工程文件就可以了。&lt;/li&gt;
&lt;li&gt;编译h2engine需要依赖openssl、curl、mysql、lua、python2.7，依赖文件都放到windependency文件夹里，包括运行的dll。&lt;/li&gt;
&lt;li&gt;H2workerlua在Windows下用的lua5.1&lt;/li&gt;
&lt;li&gt;H2workerpython在Windows下用的python2.7&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;关于c-sharp&quot;&gt;关于C sharp&lt;/h2&gt;
&lt;p&gt;H2engine的c#版本正在紧锣密鼓的开发中，大家拭目以待。&lt;br/&gt;相关连接&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文档 &lt;a href=&quot;http://h2cloud.org&quot; class=&quot;uri&quot;&gt;http://h2cloud.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;源码 &lt;a href=&quot;https://github.com/fanchy/h2engine&quot; class=&quot;uri&quot;&gt;https://github.com/fanchy/h2engine&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 21 Feb 2019 12:33:00 +0000</pubDate>
<dc:creator>知然</dc:creator>
<og:description>H2engine的GitHub星星不知不觉已经破百了，也没有特意推广过，但是慢慢的关注的人越来越多。因为事情多，好久没有写东西了，前一段时间有了一些想法，把h2engine又更新了一下，感觉h2eng</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhiranok/p/h2enginewin.html</dc:identifier>
</item>
<item>
<title>Node 框架接入 ELK 实践总结 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/10415062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/10415062.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文由云+社区发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：J2X&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们都有过上机器查日志的经历，当集群数量增多的时候，这种原始的操作带来的低效率不仅给我们定位现网问题带来极大的挑战，同时，我们也无法对我们服务框架的各项指标进行有效的量化诊断，更无从谈有针对性的优化和改进。这个时候，构建具备信息查找，服务诊断，数据分析等功能的实时日志监控系统尤为重要。&lt;/p&gt;
&lt;p&gt;ELK （ELK Stack: ElasticSearch, LogStash, Kibana, Beats） 是一套成熟的日志解决方案，其开源及高性能在各大公司广泛使用。而我们业务所使用的服务框架，如何接入 ELK 系统呢？&lt;/p&gt;
&lt;h2 id=&quot;业务背景&quot;&gt;业务背景&lt;/h2&gt;
&lt;p&gt;我们的业务框架背景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;业务框架是基于 NodeJs 的 WebServer&lt;/li&gt;
&lt;li&gt;服务使用 winston 日志模块将日志本地化&lt;/li&gt;
&lt;li&gt;服务产生的日志存储在各自机器的磁盘上&lt;/li&gt;
&lt;li&gt;服务部署在不同地域多台机器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;接入步骤&quot;&gt;接入步骤&lt;/h2&gt;
&lt;p&gt;我们将整个框架接入 ELK 简单归纳为下面几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志结构设计：由传统的纯文本日志改成结构化对象并输出为 JSON.&lt;/li&gt;
&lt;li&gt;日志采集：在框架请求生命周期的一些关键节点输出日志&lt;/li&gt;
&lt;li&gt;ES 索引模版定义：建立 JSON 到 ES 实际存储的映射&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一日志结构设计&quot;&gt;一、日志结构设计&lt;/h2&gt;
&lt;p&gt;传统的，我们在做日志输出的时候，是直接输出日志的等级（level）和日志的内容字符串（message）。然而我们不仅关注什么时间，发生了什么，可能还需要关注类似的日志发生了多少次，日志的细节与上下文，以及关联的日志。 因此我们不只是简单地将我们的日志结构化一下为对象，还要提取出日志关键的字段。&lt;/p&gt;
&lt;h3 id=&quot;将日志抽象为事件&quot;&gt;1. 将日志抽象为事件&lt;/h3&gt;
&lt;p&gt;我们将每一条日志的发生都抽像为一个事件。事件包含：&lt;/p&gt;
&lt;h4 id=&quot;事件元字段&quot;&gt;事件元字段&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;事件发生时间：&lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事件等级：&lt;code&gt;level&lt;/code&gt;， 例如: &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt;, &lt;code&gt;DEBUG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事件名称: &lt;code&gt;event&lt;/code&gt;, 例如：&lt;code&gt;client-request&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事件发生的相对时间（单位：纳秒）：&lt;code&gt;reqLife&lt;/code&gt;, 此字段为事件相对请求开始发生的时间（间隔）&lt;/li&gt;
&lt;li&gt;事件发生的位置: &lt;code&gt;line&lt;/code&gt;，代码位置; &lt;code&gt;server&lt;/code&gt;, 服务器的位置&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;请求元字段&quot;&gt;请求元字段&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;请求唯一ID: &lt;code&gt;reqId&lt;/code&gt;, 此字段贯穿整个请求链路上发生的所有事件&lt;/li&gt;
&lt;li&gt;请求用户ID: &lt;code&gt;reqUid&lt;/code&gt;, 此字段为用户标识，可以跟踪用户的访问或请求链路&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;数据字段&quot;&gt;数据字段&lt;/h4&gt;
&lt;p&gt;不同类型的事件，需要输出的细节不尽相同，我们将这些细节（非元字段）统一放到&lt;code&gt;d&lt;/code&gt; -- data，之中。使我们的事件结构更加清晰，同时，也能避免数据字段对元字段造成污染。&lt;/p&gt;
&lt;p&gt;e.g. 如 &lt;code&gt;client-init&lt;/code&gt;事件，该事件会在每次服务器接收到用户请求时打印，我们将用户的 &lt;code&gt;ip&lt;/code&gt;, &lt;code&gt;url&lt;/code&gt;等事件独有的统一归为数据字段放到 &lt;code&gt;d&lt;/code&gt; 对象中&lt;/p&gt;
&lt;p&gt;举个完整的例子&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    &quot;datetime&quot;:&quot;2018-11-07 21:38:09.271&quot;,
    &quot;timestamp&quot;:1541597889271,
    &quot;level&quot;:&quot;INFO&quot;,
    &quot;event&quot;:&quot;client-init&quot;,
    &quot;reqId&quot;:&quot;rJtT5we6Q&quot;,
    &quot;reqLife&quot;:5874,
    &quot;reqUid&quot;: &quot;999793fc03eda86&quot;,
    &quot;d&quot;:{
        &quot;url&quot;:&quot;/&quot;,
        &quot;ip&quot;:&quot;9.9.9.9&quot;,
        &quot;httpVersion&quot;:&quot;1.1&quot;,
        &quot;method&quot;:&quot;GET&quot;,
        &quot;userAgent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&quot;,
        &quot;headers&quot;:&quot;*&quot;
    },
    &quot;browser&quot;:&quot;{&quot;name&quot;:&quot;Chrome&quot;,&quot;version&quot;:&quot;70.0.3538.77&quot;,&quot;major&quot;:&quot;70&quot;}&quot;,
    &quot;engine&quot;:&quot;{&quot;version&quot;:&quot;537.36&quot;,&quot;name&quot;:&quot;WebKit&quot;}&quot;,
    &quot;os&quot;:&quot;{&quot;name&quot;:&quot;Mac OS&quot;,&quot;version&quot;:&quot;10.14.0&quot;}&quot;,
    &quot;content&quot;:&quot;(Empty)&quot;,
    &quot;line&quot;:&quot;middlewares/foo.js:14&quot;,
    &quot;server&quot;:&quot;127.0.0.1&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;一些字段，如：&lt;strong&gt;browser&lt;/strong&gt;, &lt;strong&gt;os&lt;/strong&gt;, &lt;strong&gt;engine&lt;/strong&gt;为什么在外层 &lt;em&gt;有时候我们希望日志尽量扁平（最大深度为2），以避免 ES 不必要的索引带来的性能损耗。在实际输出的时候，我们会将深度大于1的值输出为字符串。而有时候一些对象字段是我们关注的，所以我们将这些特殊字段放在外层，以保证输出深度不大于2的原则。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般的，我们在打印输出日志的时候，只须关注&lt;code&gt;事件名称&lt;/code&gt;及&lt;code&gt;数据字段&lt;/code&gt;即可。其他，我们可以在打印日志的方法中，通过访问上下文统一获取，计算，输出。&lt;/p&gt;
&lt;h3 id=&quot;日志改造输出&quot;&gt;2. 日志改造输出&lt;/h3&gt;
&lt;p&gt;前面我们提到了如何定义一个日志事件， 那么，我们如何基于已有日志方案做升级，同时，兼容旧代码的日志调用方式。&lt;/p&gt;
&lt;h4 id=&quot;升级关键节点的日志&quot;&gt;升级关键节点的日志&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 改造前
logger.info('client-init =&amp;gt; ' + JSON.stringfiy({
    url,
    ip,
    browser,
    //...
}));

// 改造后
logger.info({
    event: 'client-init',
    url,
    ip,
    browser,
    //...
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;兼容旧的日志调用方式&quot;&gt;兼容旧的日志调用方式&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;logger.debug('checkLogin');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 winston 的 日志方法本身就支持 &lt;code&gt;string&lt;/code&gt; 或者 &lt;code&gt;object&lt;/code&gt; 的传入方式, 所以对于旧的字符串传入写法，formatter 接收到的实际上是&lt;code&gt;{ level: 'debug', message: 'checkLogin' }&lt;/code&gt;。formatter 是 winston 的日志输出前调整日志格式的一道工序， 这一点使我们在日志输出前有机会将这类调用方式输出的日志，转为一个&lt;strong&gt;纯输出&lt;/strong&gt;事件 -- 我们称它们为&lt;code&gt;raw-log&lt;/code&gt;事件，而不需要修改调用方式。&lt;/p&gt;
&lt;h4 id=&quot;改造日志输出格式&quot;&gt;改造日志输出格式&lt;/h4&gt;
&lt;p&gt;前面提到 winston 输出日志前，会经过我们预定义的formatter，因此除了兼容逻辑的处理外，我们可以将一些公共逻辑统一放在这里处理。而调用上，我们只关注字段本身即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;元字段提取及处理&lt;/li&gt;
&lt;li&gt;字段长度控制&lt;/li&gt;
&lt;li&gt;兼容逻辑处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何提取元字段，这里涉及上下文的创建与使用，这里简单介绍一下 domain 的创建与使用。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//--- middlewares/http-context.js
const domain = require('domain');
const shortid = require('shortid');

module.exports = (req, res, next) =&amp;gt; {
    const d = domain.create();
    d.id =  shortid.generate(); // reqId;
    d.req = req;
    
    //...

    res.on('finish', () =&amp;gt; process.nextTick(() =&amp;gt; {
        d.id = null;
        d.req = null;
        d.exit();
    });

    d.run(() =&amp;gt; next());
}

//--- app.js
app.use(require('./middlewares/http-context.js'));

//--- formatter.js
if (process.domain) {
    reqId = process.domain.id;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就可以将 &lt;code&gt;reqId&lt;/code&gt; 输出到一次请求中所有的事件, 从而达到关联事件的目的。&lt;/p&gt;
&lt;h2 id=&quot;二日志采集&quot;&gt;二、日志采集&lt;/h2&gt;
&lt;p&gt;现在，我们知道怎么输出一个事件了，那么下一步，我们该考虑两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们要在哪里输出事件？&lt;/li&gt;
&lt;li&gt;事件要输出什么细节？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;换句话说，整个请求链路中，哪些节点是我们关注的，出现问题，可以通过哪个节点的信息快速定位到问题？除此之外，我们还可以通过哪些节点的数据做统计分析？&lt;/p&gt;
&lt;p&gt;结合一般常见的请求链路（用户请求，服务侧接收请求，服务请求下游服务器/数据库（*多次），数据聚合渲染，服务响应），如下方的流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1000052/7ndyqr784u.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;流程图&lt;/p&gt;
&lt;p&gt;那么，我们可以这样定义我们的事件：&lt;/p&gt;
&lt;h3 id=&quot;用户请求&quot;&gt;用户请求&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;client-init&lt;/code&gt;: 打印于框架接收到请求（未解析）， 包括：请求地址，请求头，Http 版本和方法，用户 IP 和 浏览器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client-request&lt;/code&gt;: 打印于框架接收到请求（已解析），包括：请求地址，请求头，Cookie, 请求包体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client-response&lt;/code&gt;: 打印于框架返回请求，包括：请求地址，响应码，响应头，响应包体&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;下游依赖&quot;&gt;下游依赖&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;http-start&lt;/code&gt;: 打印于请求下游起始：请求地址，请求包体，模块别名（方便基于名字聚合而且域名）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http-success&lt;/code&gt;: 打印于请求返回 &lt;strong&gt;200&lt;/strong&gt;：请求地址，请求包体，响应包体(code &amp;amp; msg &amp;amp; data)，耗时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http-error&lt;/code&gt;: 打印于请求返回&lt;strong&gt;非 200&lt;/strong&gt;，亦即连接服务器失败：请求地址，请求包体，响应包体(code &amp;amp; message &amp;amp; stack)，耗时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http-timeout&lt;/code&gt;: 打印于请求连接超时：请求地址，请求包体，响应包体(code &amp;amp; msg &amp;amp; stack)，耗时。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;字段这么多，该怎么选择？ 一言以蔽之，事件输出的字段原则就是：输出你关注的，方便检索的，方便后期聚合的字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一些建议&quot;&gt;一些建议&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;请求下游的请求体和返回体有固定格式， e.g. 输入：&lt;code&gt;{ action: 'getUserInfo', payload: {} }&lt;/code&gt; 输出: &lt;code&gt;{ code: 0, msg: '', data: {}}&lt;/code&gt; 我们可以在事件输出 action，code 等，以便后期通过 action 检索某模块具体某个接口的各项指标和聚合。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;一些原则&quot;&gt;一些原则&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;保证输出字段类型一致&lt;/strong&gt; 由于所有事件都存储在同一个 ES 索引， 因此，相同字段不管是相同事件还是不同事件，都应该保持一致，例如：code不应该既是数字，又是字符串，这样可能会产生字段冲突，导致某些记录（document）无法被冲突字段检索到。&lt;/li&gt;
&lt;li&gt;ES 存储类型为 keyword, 不应该超过 ES mapping 设定的 &lt;code&gt;ignore_above&lt;/code&gt; 中指定的字节数（默认4096个字节）。否则同样可能会产生无法被检索的情况&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三es-索引模版定义&quot;&gt;三、ES 索引模版定义&lt;/h2&gt;
&lt;p&gt;这里引入 ES 的两个概念，映射(Mapping)与模版(Template)。&lt;/p&gt;
&lt;p&gt;首先，ES 基本的存储类型大概枚举下，有以下几种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;String: keyword &amp;amp; text&lt;/li&gt;
&lt;li&gt;Numeric: long, integer, double&lt;/li&gt;
&lt;li&gt;Date: date&lt;/li&gt;
&lt;li&gt;Boolean: boolean&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般的，我们不需要显示指定每个事件字段的在ES对应的存储类型，ES 会自动根据字段第一次出现的document中的值来决定这个字段在这个索引中的存储类型。但有时候，我们需要显示指定某些字段的存储类型，这个时候我们需要定义这个索引的 Mapping, 来告诉 ES 这此字段如何存储以及如何索引。&lt;/p&gt;
&lt;p&gt;e.g.&lt;/p&gt;
&lt;p&gt;还记得事件元字段中有一个字段为 timestamp ？实际上，我们输出的时候，timestamp 的值是一个数字，它表示跟距离 1970/01/01 00:00:00 的毫秒数，而我们期望它在ES的存储类型为 date 类型方便后期的检索和可视化, 那么我们创建索引的时候，指定我们的Mapping。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;PUT my_logs
{
  &quot;mappings&quot;: {
    &quot;_doc&quot;: { 
      &quot;properties&quot;: { 
        &quot;title&quot;:    {
            &quot;type&quot;: &quot;date&quot;,
            &quot;format&quot;: &quot;epoch_millis&quot;
         }, 
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但一般的，我们可能会按日期自动生成我们的日志索引，假定我们的索引名称格式为 my_logs_&lt;em&gt;yyyyMMdd&lt;/em&gt; （e.g. my_logs_20181030）。那么我们需要定义一个模板（Template），这个模板会在（匹配的）索引创建时自动应用预设好的 Mapping。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;PUT _template/my_logs_template
{
  &quot;index_patterns&quot;: &quot;my_logs*&quot;,
  &quot;mappings&quot;: {
    &quot;_doc&quot;: { 
      &quot;properties&quot;: { 
        &quot;title&quot;:    {
            &quot;type&quot;: &quot;date&quot;,
            &quot;format&quot;: &quot;epoch_millis&quot;
         }, 
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提示：将所有日期产生的日志都存在一张索引中，不仅带来不必要的性能开销，也不利于定期删除比较久远的日志。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;至此，日志改造及接入的准备工作都已经完成了，我们只须在机器上安装 FileBeat -- 一个轻量级的文件日志Agent, 它负责将日志文件中的日志传输到 ELK。接下来，我们便可使用 Kibana 快速的检索我们的日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此文已由腾讯云+社区在各渠道发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取更多新鲜技术干货，可以关注我们&lt;a href=&quot;https://www.zhihu.com/org/teng-xun-yun-ji-zhu-she-qu/activities&quot;&gt;腾讯云技术社区-云加社区官方号及知乎机构号&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 12:29:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>本文由云+社区发表 作者：J2X 我们都有过上机器查日志的经历，当集群数量增多的时候，这种原始的操作带来的低效率不仅给我们定位现网问题带来极大的挑战，同时，我们也无法对我们服务框架的各项指标进行有效的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/10415062.html</dc:identifier>
</item>
<item>
<title>Java 泛型完全解读 - 三枣</title>
<link>http://www.cnblogs.com/sanzao/p/10415035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanzao/p/10415035.html</guid>
<description>&lt;p&gt;对于泛型的使用我想大家都非常熟悉，但是对于类型擦除，边界拓展等细节问题，可能不是很清楚，所以本文会重点讲解一下；另外对泛型的了解其实可以看出，一个语言特性的产生逻辑，这对我们平时的开发也是非常有帮助的；&lt;/p&gt;
&lt;h2 id=&quot;一为什么会出现泛型&quot;&gt;一、为什么会出现泛型&lt;/h2&gt;
&lt;p&gt;首先泛型并不是Java的语言特性，是直到 JDK1.5 才支持的特性（具体区别后面会讲到）；那么在泛型出现之前是怎么做的呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List list = new ArrayList();
list.add(&quot;123&quot;);
String s = (String) list.get(0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上面代码所示，在集合里面需要我们自己记住放进去的是什么，取出来的时候再强转； 也就将这种类型转换的错误推迟到了运行时，即麻烦还不安全，所以才出现了泛型；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;：泛型类，泛型接口，泛型方法；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test&amp;lt;T&amp;gt;
public interface Test&amp;lt;T&amp;gt;
public &amp;lt;T&amp;gt; void test(T t)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二泛型会带来什么样的问题&quot;&gt;二、泛型会带来什么样的问题&lt;/h2&gt;
&lt;p&gt;正如上面所讲泛型并不是 Java 一开始就具有的特性，所以在后来想要增加泛型的时候，就必须要兼容以前的版本，Sun 他们想到的折中解决方案就是&lt;strong&gt;类型擦除&lt;/strong&gt;；意思就是泛型的信息只存在于编译期，在运行时期所有的泛型信息都被擦除了，就想没有一样；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;();
List&amp;lt;Integer&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();
System.out.println(list1.getClass());
System.out.println(list2.getClass() == list1.getClass());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;// 打印：&lt;br/&gt;class java.util.ArrayList&lt;br/&gt;true&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;和&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;在运行时其实都是一样的，都是&lt;code&gt;class java.util.ArrayList&lt;/code&gt;；所以在使用泛型的时候需要牢记，&lt;strong&gt;在运行时期没有泛型信息，也无法获取任何有关参数类型的信息&lt;/strong&gt;；所以凡是需要获取运行时类型的操作，泛型都不支持！&lt;/p&gt;
&lt;h3 id=&quot;不能用基本类型实例化类型参数&quot;&gt;1. 不能用基本类型实例化类型参数&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;new ArrayList&amp;lt;int&amp;gt;();      // error
new ArrayList&amp;lt;Integer&amp;gt;();  // correct&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为类型擦除，会擦除到他的上界也就是&lt;code&gt;Object&lt;/code&gt;；而 Java 的8个基本类型的直接父类是 &lt;code&gt;Number&lt;/code&gt;，所以基本类型不不能用基本类型实例化类型参数，而必须使用基本类型的包装类；&lt;/p&gt;
&lt;h3 id=&quot;不能用于运行时类型检查&quot;&gt;2. 不能用于运行时类型检查&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;t instanceof T             // error
t instanceof List&amp;lt;T&amp;gt;       // error
t instanceof List&amp;lt;String&amp;gt;  // error
t instanceof List          // correct&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是可以使用&lt;code&gt;clazz.isInstance();&lt;/code&gt;进行补偿；&lt;/p&gt;
&lt;h3 id=&quot;不能创建类型实例&quot;&gt;3. 不能创建类型实例&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;T t = new T();  // error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样可以使用&lt;code&gt;clazz.newInstance();&lt;/code&gt;进行补偿；&lt;/p&gt;
&lt;h3 id=&quot;不能静态化&quot;&gt;4. 不能静态化&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static T t;                  // error
private T t;                         // correct
private static List&amp;lt;T&amp;gt; list;         // error
private static List&amp;lt;?&amp;gt; list;         // correct
private static List&amp;lt;String&amp;gt; list;    // correct

// e.g.
class Test&amp;lt;T&amp;gt; {
  private T t;
  public void set(T arg) { t = arg; }
  public T get() { return t; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为静态变量在类中共享，而泛型类型是不确定的，所以泛型不能静态化；但是非静态的时候，编译期可以根据上下文推断出&lt;code&gt;T&lt;/code&gt;是什么，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Test l = new Test();
System.out.println(l.get());
l.set(&quot;123&quot;);
System.out.println(l.get());

// javap -v 反编译
12: invokevirtual #15         // Method JDK/Test14_genericity$Test.get:()Ljava/lang/Object;
15: invokevirtual #16         // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
18: aload_1
19: ldc       #17             // String 123
21: invokevirtual #18         // Method JDK/Test14_genericity$Test.set:(Ljava/lang/Object;)V
24: getstatic   #6            // Field java/lang/System.out:Ljava/io/PrintStream;

// ---------------------------
Test l = new Test();
System.out.println(l.get());
l.set(&quot;123&quot;);
System.out.println(l.get());

// javap -v 反编译
12: invokevirtual #15         // Method JDK/Test14_genericity$Test.get:()Ljava/lang/Object;
15: invokevirtual #16         // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
18: aload_1
19: bipush    123
21: invokestatic  #17         // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上面的代码，可以很清楚的看到，编译器对非静态类型的推导；&lt;/p&gt;
&lt;p&gt;另外&lt;code&gt;List&amp;lt;?&amp;gt;和List&amp;lt;String&amp;gt;&lt;/code&gt;之所以是正确的，仍然是因为编译器可以在编译期间就能确定类型转换的正确性；&lt;/p&gt;
&lt;h3 id=&quot;不能抛出或捕获泛型类的实例&quot;&gt;5. 不能抛出或捕获泛型类的实例&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;catch (T t)                        // error
class Test&amp;lt;T&amp;gt; extends Throwable    // error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为在捕捉异常时候需要运行时类信息，并且判断异常的继承关系，所以不能抛出或捕获泛型类的实例；&lt;/p&gt;
&lt;h3 id=&quot;不允许作为参数进行重载&quot;&gt;6. 不允许作为参数进行重载&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void test(List&amp;lt;Integer&amp;gt; list)
void test(List&amp;lt;String&amp;gt; list)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为在运行时期泛型信息被擦除，重载的两个方法签名就完全一样了；&lt;/p&gt;
&lt;h3 id=&quot;不能创建泛型数组&quot;&gt;7. 不能创建泛型数组&lt;/h3&gt;
&lt;p&gt;对于一点我觉得是最重要的，关于数组的介绍可以参考，&lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10098974.html&quot;&gt;Array 相关&lt;/a&gt; ；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt;[] lists = new ArrayList&amp;lt;String&amp;gt;[10];             // error
List&amp;lt;String&amp;gt;[] lists1 = (List&amp;lt;String&amp;gt;[]) new ArrayList[10];   // correct&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以不能创建泛型数组的主要原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组是协变的，而泛型的不变的；&lt;/li&gt;
&lt;li&gt;数组的&lt;code&gt;Class&lt;/code&gt;信息是在运行时动态创建的，而运行时不能获取泛型的类信息；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据上面的讲解可以看出所谓的擦除补偿或者擦除后的修正，其大体思路都是用额外的方法告知运行时的类型信息，可以是记录到局部变量，也可以是指定参数的确切类型（&lt;code&gt;Array.newInstance(Class&amp;lt;?&amp;gt; componentType, int length)&lt;/code&gt;）；&lt;/p&gt;
&lt;h2 id=&quot;三边界拓展&quot;&gt;三、边界拓展&lt;/h2&gt;
&lt;p&gt;基于安全的考虑 Java 泛型是不变的（避免取出数据时的类型转换错误）；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();    // error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以在使用集合类的时候，每个集合都需要强制指定确切类型就有点不方便，比如我想指定一个集合存放 A 以及 A 的子类；在这种情况下就引入了&lt;code&gt;extends,super,?&lt;/code&gt; 来拓展和管理泛型的边界；&lt;/p&gt;
&lt;h3 id=&quot;无界通配符&quot;&gt;1. 无界通配符 &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;通配符主要用于泛型的使用场景（泛型一般有“声明”和“使用”两种场景）；&lt;br/&gt;通常情况下&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;和原生类型大致相同，就像&lt;code&gt;List&lt;/code&gt;和&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;的表现大部分都是一样的；但是要注意他们其实是有本质去别的，&lt;strong&gt;&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 代表了某一特定的类型，但是编译器不知道这种类型是什么；&lt;/strong&gt;而原生的表示可以是任何 &lt;code&gt;Object&lt;/code&gt;，其中并没有类型限制；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;?&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();    // correct
list.add(&quot;34&quot;);                            // error
String s = list.get(0);                    // error
Object o = list.get(0);                    // correct

boolean add(E e);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码很明确的反应了这一点（&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 代表了某一特定的类型，但是编译器不知道这种类型是什么），&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为编译器不知道这种类型是什么，所以在添加元素的时候，当然也就不能确认添加的这个类型是否正确；当使用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;的时候，代码中的&lt;code&gt;add(E e)&lt;/code&gt;方法，此时的 &lt;code&gt;E&lt;/code&gt; 会被替换为 &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;，&lt;strong&gt;实际上编译器为了安全起见，会直接拒绝参数列表中涉及通配符的方法调用；&lt;/strong&gt;就算这个方法没有向集合中添加元素，也会被直接拒绝；&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;取出元素的时候，同样因为不知道这个特定的类型是什么，所以只能将取出的元素放在&lt;code&gt;Object&lt;/code&gt;中；或者在取出后强转；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;上界-extends&quot;&gt;2. 上界 &lt;code&gt;&amp;lt;extends&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;，主要用于确定泛型的上界；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;T extends Test&amp;gt;                             // 泛型声明
&amp;lt;T extends Test &amp;amp; interface1 &amp;amp; interface2&amp;gt;   // 声明泛型是可以确定多个上界
&amp;lt;? extends T&amp;gt;                                // 泛型使用时&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;界定的范围如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201902/1119937-20190221202216393-9943252.png&quot; width=&quot;600&quot; alt=&quot;upperBounds&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应当注意的是当&lt;code&gt;extends&lt;/code&gt;用于参数类型限定时：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;? extends List&amp;gt; list = new ArrayList&amp;lt;ArrayList&amp;gt;();  // correct
list.add(new ArrayList());                               // error
List l = list.get(0);                                    // correct
ArrayList l = list.get(0);                               // error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的分析同无界通配符类似，只是 &lt;code&gt;List l = list.get(0);&lt;/code&gt; 是正确的，是因为 &lt;code&gt;&amp;lt;? extends List&amp;gt;&lt;/code&gt; 界定了放入的元素一定是 &lt;code&gt;List&lt;/code&gt; 或者 &lt;code&gt;list&lt;/code&gt; 的子类，所以取出的元素能放入 &lt;code&gt;List&lt;/code&gt; 中，但是不能放入 &lt;code&gt;ArrayList&lt;/code&gt; 中；&lt;/p&gt;
&lt;h3 id=&quot;下界-super&quot;&gt;3. 下界 &lt;code&gt;&amp;lt;super&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;super&lt;/code&gt;，主要用于确定泛型的下界；如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201902/1119937-20190221202249893-1818324335.png&quot; width=&quot;650&quot; alt=&quot;lowerBounds&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;? super HashMap&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();   // correct
LinkedHashMap m = new LinkedHashMap();            // correct
HashMap m1 = m;                                   // correct
Map m2 = m;                                       // correct
list.add(m);                                      // correct
list.add(m1);                                     // correct
list.add(m2);                                     // error

Map mm = list.get(0);                             // error
LinkedHashMap mm1 = list.get(0);                  // error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据图中的范围对照代码，就能很快发现&lt;code&gt;Map&lt;/code&gt;在&lt;code&gt;List&amp;lt;? super HashMap&amp;gt;&lt;/code&gt;的范围之外；而编辑器为了安全泛型下界集合取出的元素只能放在 &lt;code&gt;Object&lt;/code&gt;里面；&lt;/p&gt;
&lt;h3 id=&quot;pecs-原则&quot;&gt;4. &lt;code&gt;PECS&lt;/code&gt; 原则&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;PECS&lt;/code&gt;原则是对上界和下界使用的归纳，即&lt;code&gt;producer-extends, consumer-super&lt;/code&gt;；结合上面的两幅图，表示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;extends&lt;/code&gt;，&lt;strong&gt;只能读&lt;/strong&gt;，相当于生产者，向外产出；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;super&lt;/code&gt;，&lt;strong&gt;只能写&lt;/strong&gt;，相当于消费者，只能接收消费；&lt;/li&gt;
&lt;li&gt;同时边界不能同时规定上界和下界，正如图所示，他们的范围其实是一样的，只是开口不一样；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;自限定类型&quot;&gt;5. 自限定类型&lt;/h3&gt;
&lt;p&gt;对于上面讲的泛型边界拓展，有一个很特别的用法，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Test&amp;lt;T extends Test&amp;lt;T&amp;gt;&amp;gt; {}

public &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(List&amp;lt;T&amp;gt; list) {} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自限定类型可以通俗的解释，就是用自己限定自己，即自和自身相同的类进行某操作；如上面的 &lt;code&gt;max&lt;/code&gt; 方法，就表示可以和自身进行比较的类型；&lt;/p&gt;
&lt;p&gt;那么如果想要表达只要是同一祖先就能相互比较呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public &amp;lt;T extends Comparable&amp;lt;? super&amp;gt;&amp;gt; T max(List&amp;lt;? extends T&amp;gt; list) {} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;T extends Comparable&amp;lt;? super&amp;gt;&amp;gt;&lt;/code&gt;：表明只要是同一祖先就能相互比较，&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;表明集合中装的都是同一祖先的元素；（出至《Effective Java》第 28 条）&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对于泛型的时候首先要很清楚的知道，在运行时没有任何泛型的信息，全部都被擦除掉了；&lt;/li&gt;
&lt;li&gt;需要知道 Java 泛型做不到的事情；&lt;/li&gt;
&lt;li&gt;需要知道怎么拓展边界，让泛型更加灵活；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 21 Feb 2019 12:24:00 +0000</pubDate>
<dc:creator>三枣</dc:creator>
<og:description>对于泛型的使用我想大家都非常熟悉，但是对于类型擦除，边界拓展等细节问题，可能不是很清楚，所以本文会重点讲解一下；另外对泛型的了解其实可以看出，一个语言特性的产生逻辑，这对我们平时的开发也是非常有帮助的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanzao/p/10415035.html</dc:identifier>
</item>
</channel>
</rss>