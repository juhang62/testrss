<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>微服务实战SpringCloud之Spring Cloud Feign替代HTTP Client - 谁主沉浮oo7</title>
<link>http://www.cnblogs.com/feifuzeng/p/13613732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feifuzeng/p/13613732.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在项目中我们有时候需要调用第三方的API，微服务架构中这种情况则更是无法避免——各个微服务之间通信。比如一般的项目中，有时候我们会使用 HTTP Client 发送 HTTP 请求来进行调用，而在微服务架构，Spring Cloud 全家桶中，Spring Cloud Feign 则是更常见的选择。那么，我如何只使用 Spring Cloud Feign 而不引入整个 Spring Cloud 呢？&lt;/p&gt;
&lt;h2 id=&quot;什么是feign&quot;&gt;什么是Feign?&lt;/h2&gt;
&lt;p&gt;Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。&lt;/p&gt;
&lt;p&gt;而Feign则会完全代理HTTP请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。Feign整合了Ribbon和Hystrix，可以让我们不再需要显式地使用这两个组件。&lt;/p&gt;
&lt;p&gt;总起来说，Feign具有如下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可插拔的注解支持，包括Feign注解和JAX-RS注解;&lt;/li&gt;
&lt;li&gt;支持可插拔的HTTP编码器和解码器;&lt;/li&gt;
&lt;li&gt;支持Hystrix和它的Fallback;&lt;/li&gt;
&lt;li&gt;支持Ribbon的负载均衡;&lt;/li&gt;
&lt;li&gt;支持HTTP请求和响应的压缩。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这看起来有点像我们springmvc模式的Controller层的RequestMapping映射。这种模式是我们非常喜欢的。Feign是用@FeignClient来映射服务的。&lt;/p&gt;
&lt;h2 id=&quot;首先找一个aip&quot;&gt;首先找一个AIP&lt;/h2&gt;
&lt;p&gt;免费的API特别多，github上也有免费API地址汇总的repo，但这些都太正式了。有趣的事物总是会相互吸引的，无意间我发现了这么一个网站，“渣男：说话的艺术”（&lt;a href=&quot;https://lovelive.tools&quot;&gt;lovelive.tools&lt;/a&gt;) ，每次请求都可以获取一句甜言蜜语（渣男语录）,特别良心的是，作者提供了API列表，给作者点赞！&lt;/p&gt;
&lt;h2 id=&quot;如何调用第三方服务？&quot;&gt;如何调用第三方服务？&lt;/h2&gt;
&lt;p&gt;首先，我们先快速构建一个 Spring Boot 的 web 项目，这里我就省略了。然后在pom中添加feign的相关依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;                &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.1.3.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在启动类添加响应的注解 @EnableFeignClients：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableFeignClients
public class SpringbootMiddlewareFeignApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootMiddlewareFeignApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们便可以配置我们的 Client 了，我们先创建一个接口类，比如叫BadGuyFeignClient ，并声明为 FeignClient：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FeignClient
public interface BadGuyFeignClient {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@FeignClient有以下几个较常用属性：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;空字符串&lt;/td&gt;
&lt;td&gt;调用服务名称，和name属性相同，如果项目使用了 Ribbon，name属性会作为微服务的名称，用于服务发现；&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;serviceId&lt;/td&gt;
&lt;td&gt;空字符串&lt;/td&gt;
&lt;td&gt;服务id，作用和name属性相同&lt;/td&gt;
&lt;td&gt;已过期&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;空字符串&lt;/td&gt;
&lt;td&gt;调用服务名称，和value属性相同，如果项目使用了 Ribbon，name属性会作为微服务的名称，用于服务发现；&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;空字符串&lt;/td&gt;
&lt;td&gt;url一般用于调试，可以手动指定@FeignClient调用的地址&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;decode404&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;配置响应状态码为404时是否应该抛出FeignExceptions&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;configuration&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;Feign配置类，可以自定义 Feign的 Encoder、Decoder、LogLevel、Contract；&lt;/td&gt;
&lt;td&gt;参考FeignClientsConfiguration&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;fallback&lt;/td&gt;
&lt;td&gt;void.class&lt;/td&gt;
&lt;td&gt;定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口&lt;/td&gt;
&lt;td&gt;底层依赖hystrix，启动类要加上@EnableHystrix&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;fallbackFactory&lt;/td&gt;
&lt;td&gt;void.class&lt;/td&gt;
&lt;td&gt;工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;path&lt;/td&gt;
&lt;td&gt;空字符串&lt;/td&gt;
&lt;td&gt;自动给所有方法的requestMapping前加上前缀，类似与controller类上的requestMapping&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;然后，我们便可以配置对应的属性，这里我们只是用来实现类似于 HTTP Client 的功能，所以只是简单配置了url和path这些属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FeignClient(name = &quot;badGuy&quot;, url = &quot;${bab.guy.url}&quot;, path = &quot;api&quot;)
public interface BadGuyFeignClient {

    /**
     * 随机获取一句甜言蜜语
     *
     * @return
     */
    @GetMapping(&quot;SweetNothings&quot;)
    String getSweetNothings();

    /**
     * 获取 count 条甜言蜜语
     *
     * @param count 获取甜言蜜语条数
     * @return Json 格式的结果
     */
    @GetMapping(&quot;SweetNothings/{count}/Serialization/Json&quot;)
    ReturnResult&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; getSweetNothingsJsonByCount(@PathVariable(&quot;count&quot;) Integer count);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明为FeignClient之后，我们便可以在代码中使用@Resource或者@Autowire进行注入使用了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class BadServiceImpl implements BadGuyService {

    @Autowired
    private BadGuyFeignClient badGuyFeignClient;

    @Override
    public List&amp;lt;String&amp;gt; getQuotations(Integer count) {
        if (count == null || count &amp;lt;= 0) {
            String singleQuotation = badGuyFeignClient.getSweetNothings();
            return new ArrayList&amp;lt;String&amp;gt;() {{
                add(singleQuotation);
            }};
        }
        return badGuyFeignClient.getSweetNothingsJsonByCount(count).getReturnObj();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后Controller中是这么写的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Log4j2
@RequestMapping(&quot;/api/badGuy&quot;)
public class BadGuyController {

    @Resource
    private BadGuyService badGuyService;

    @GetMapping({&quot;quotations&quot;, &quot;quotations/{count}&quot;})
    public PlainResult&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; getBadGuyQuotations(
            @PathVariable(value = &quot;count&quot;, required = false) Integer count
    ) {
        PlainResult&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result = new PlainResult&amp;lt;&amp;gt;();
        try {
            List&amp;lt;String&amp;gt; resultStrings = badGuyService.getQuotations(count);
            result.setData(resultStrings);
        } catch (Exception e) {
            log.error(&quot;Failed to get bad guy quotations.&quot;, e);
            result.setErrorMessage(&quot;error&quot;);
        }
        return result;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目之后，我们可以访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8080/api/badGuy/quotations&quot;&gt;http://localhost:8080/api/badGuy/quotations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8080/api/badGuy/quotations/10&quot;&gt;http://localhost:8080/api/badGuy/quotations/10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后面跟数字，即可得到对应条目数的结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;success&quot;:true,
    &quot;code&quot;:0,
    &quot;message&quot;:&quot;successful&quot;,
    &quot;data&quot;:[
        &quot;我从未拥有过你一秒钟，心里却失去过你千万次。&quot;,
        &quot;现在几点了？是我们幸福的起点。&quot;,
        &quot;我不很快乐，因为你不很爱我。但所谓不很快乐者，并不等于不快乐，正如不很爱我不等于不爱我一样。&quot;,
        &quot;我看你挺笨的吹口哨都不会，要不要我嘴对嘴教你。&quot;,
        &quot;我玩了六年英雄联盟，后来才发现你才是我的英雄。&quot;,
        &quot;这里一切都丑的，风、雨、太阳，都丑，人也丑，我也丑得很。只有你是青天一样可羡。&quot;,
        &quot;他对她说，他依然爱她，和过去一样，至死不渝&quot;,
        &quot;你猜我喜欢什么制服” “被你制服”&quot;,
        &quot;人说红颜薄命，你做我的红颜，我愿为你薄命。&quot;,
        &quot;有时候我想比你晚出生一百年，你的一生被拍成一部电影，而我一生只做一件事：独自坐在房间，面对墙上的荧光屏，用我的一生把你的一生看完。&quot;
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;feign-client-如何设置请求头信息？&quot;&gt;Feign client 如何设置请求头信息？&lt;/h2&gt;
&lt;p&gt;在调用http接口时，一般都需要在请求头里面添加相应鉴权参数，类似于ak、sk之类的密钥或者某个动态参数等，那么在使用Feign client调用时，该如何添加请求头信息呢？&lt;/p&gt;
&lt;h3 id=&quot;准备接口&quot;&gt;准备接口&lt;/h3&gt;
&lt;p&gt;首先，准备一个第三方服务接口，我这里直接在rap上定义了一个&lt;a href=&quot;http://rap2api.taobao.org/app/mock/234467/api/queryUser&quot;&gt;查询用户信息&lt;/a&gt;接口，调用该接口必须在请求头传一个token参数和请求体中传userId，postman请求示例如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://feifuzeng.oss-cn-beijing.aliyuncs.com/upload/blog/hexo/rap-%E8%AF%B7%E6%B1%82%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何添加请求有呢，这里提供两种方式。&lt;/p&gt;
&lt;h3 id=&quot;在请求方法上添加请求头参数&quot;&gt;在请求方法上添加请求头参数&lt;/h3&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FeignClient(name = &quot;apiClient&quot;, url = &quot;${test.url}&quot;, path = &quot;api&quot;)
public interface BasicApiClient {
    /**
     * 查询用户信息接口-第一种方式
     *
     * @param userId
     * @param token
     * @return
     */
    @GetMapping(value = &quot;/queryUser&quot;)
    PlainResult&amp;lt;User&amp;gt; queryUser(@RequestParam(&quot;userId&quot;) String userId,
                                @RequestHeader(name = &quot;token&quot;) String token);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意queryUser方法中多了一个@RequestHeader参数token，这个就相当于往请求头添加了一个token参数，这种情况适用于该token是一个在业务中经常动态变化的参数，需要在接口调用方动态获取。&lt;/p&gt;
&lt;h3 id=&quot;利用feignclient的configuration属性&quot;&gt;利用@FeignClient的configuration属性&lt;/h3&gt;
&lt;p&gt;新建一个配置类如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ClientConfiguration {

    @Value(&quot;${test.token}&quot;)
    private String token;

    @Bean
    public RequestInterceptor headerInterceptor() {
        return new RequestInterceptor() {

            @Override
            public void apply(RequestTemplate template) {
                List&amp;lt;String&amp;gt; authorizationList = Lists.newArrayList(token);
                List&amp;lt;String&amp;gt; contentTypeList = Lists.newArrayList(&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);
                Map&amp;lt;String, Collection&amp;lt;String&amp;gt;&amp;gt; headers = ImmutableMap.of(&quot;token&quot;, authorizationList, &quot;Content-Type&quot;, contentTypeList);
                template.headers(headers);
            }
        };
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改请求类如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FeignClient(name = &quot;apiClientTwo&quot;, url = &quot;${test.url}&quot;, path = &quot;api&quot;, configuration = ClientConfiguration.class)
public interface CommonApiClient {

    /**
     * 查询用户信息接口-第二种方式
     *
     * @param userId
     * @return
     */
    @GetMapping(value = &quot;/queryUser&quot;)
    PlainResult&amp;lt;User&amp;gt; queryUser(@RequestParam(&quot;userId&quot;) String userId);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：这里使用了@FeignClient的configuration属性，并在该配置类中往请求头添加了token入参，这种方式适用于往请求头中存放的参数是固定的，类似于ak、sk或者用于授权的应用ID密钥之类的。&lt;/p&gt;
&lt;p&gt;完整项目源码请参考：&lt;a href=&quot;https://github.com/feifuzeng/springboot-middleware-demos/tree/master/springboot-middleware-feign&quot;&gt;&lt;strong&gt;springboot-middleware-feign&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;feignclient与httpclient的区别是什么？&quot;&gt;FeignClient与HttpClient的区别是什么？&lt;/h2&gt;
&lt;p&gt;HttpClient与之同样实现的还有Okhttp、Httpurlconnection、RestTemplate等等，其 URL 参数是以编程方式构造的，数据被发送到其他服务。在更复杂的情况下，我们将不得不RestTemplate深入到更低级别的 API提供的甚至是 &lt;code&gt;API&lt;/code&gt;的细节。&lt;/p&gt;
&lt;p&gt;FeignClient则更像是在基于 REST 的服务调用上提供更高级别的抽象，在客户端编写&lt;strong&gt;声明式&lt;/strong&gt;REST 服务接口，并使用这些接口来编写客户端程序。开发人员不用担心这个接口的实现。这将在运行时由 Spring 动态配置。通过这种声明性的方法，开发人员不需要深入了解由 HTTP 提供的 HTTP 级别API的细节的&lt;code&gt;RestTemplate&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;总的来讲，FeignClient更具抽象性，也更简单、灵活。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文简单介绍了如何使用Spring Cloud Feign组件来替代HttpClient来实现简单调用第三方服务的方法，除了集成Feign组件，我们也可以在项目中加入Ribbon用于服务发现，加入Hystrix用于服务熔断等等，这样就会完整地构建出一个基本服务了。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5daf10836fb9a04e054da1b5&quot;&gt;https://juejin.im/post/5daf10836fb9a04e054da1b5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_38809962/article/details/80354878&quot;&gt;https://blog.csdn.net/weixin_38809962/article/details/80354878&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/8bca50cb11d8&quot;&gt;https://www.jianshu.com/p/8bca50cb11d8&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;欢迎关注微信公众号『码仔zonE』，专注于分享Java、云计算相关内容，包括SpringBoot、SpringCloud、微服务、Docker、Kubernetes、Python等领域相关技术干货，期待与您相遇！&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/908629/202008/908629-20200819141402537-1758432824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Sep 2020 00:38:00 +0000</pubDate>
<dc:creator>谁主沉浮oo7</dc:creator>
<og:description>简介 在项目中我们有时候需要调用第三方的API，微服务架构中这种情况则更是无法避免——各个微服务之间通信。比如一般的项目中，有时候我们会使用 HTTP Client 发送 HTTP 请求来进行调用，而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feifuzeng/p/13613732.html</dc:identifier>
</item>
<item>
<title>为什么一个还没毕业的大学生能够把 IO 讲的这么好？ - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13624862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13624862.html</guid>
<description>&lt;p&gt;Java IO 是一个庞大的知识体系，很多人学着学着就会学懵了，包括我在内也是如此，所以本文将会从 Java 的 BIO 开始，一步一步深入学习，引出 JDK1.4 之后出现的 NIO 技术，对比 NIO 与 BIO 的区别，然后对 NIO 中重要的三个组成部分进行讲解（缓冲区、通道、选择器），最后实现一个&lt;strong&gt;简易的客户端与服务器通信功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/sadasdasdsa312378126391.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;传统的-bio&quot;&gt;传统的 BIO&lt;/h2&gt;
&lt;p&gt;Java IO流是一个庞大的生态环境，其内部提供了很多不同的&lt;strong&gt;输入流和输出流&lt;/strong&gt;，细分下去还有字节流和字符流，甚至还有&lt;strong&gt;缓冲流&lt;/strong&gt;提高 IO 性能，转换流将字节流转换为字符流······看到这些就已经对 IO 产生恐惧了，在日常开发中少不了对文件的 IO 操作，虽然 apache 已经提供了 &lt;code&gt;Commons IO&lt;/code&gt; 这种封装好的组件，但面对特殊场景时，我们仍需要自己去封装一个高性能的文件 IO 工具类，本文将会解析 Java IO 中涉及到的各个类，以及讲解如何正确、高效地使用它们。&lt;/p&gt;
&lt;h2 id=&quot;bio-nio-和-aio-的区别&quot;&gt;BIO NIO 和 AIO 的区别&lt;/h2&gt;
&lt;p&gt;我们会以一个经典的&lt;strong&gt;烧开水&lt;/strong&gt;的例子通俗地讲解它们之间的区别&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;烧开水&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BIO&lt;/td&gt;
&lt;td&gt;一直监测着某个水壶，该水壶烧开水后再监测下一个水壶&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NIO&lt;/td&gt;
&lt;td&gt;每隔一段时间就看看所有水壶的状态，哪个水壶烧开水就去处理哪个水壶&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;AIO&lt;/td&gt;
&lt;td&gt;不用监测水壶，每个水壶烧开水后都会主动通知线程说：“我的水烧开了，来处理我吧”&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;BIO (同步阻塞 I/O)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 小菠萝&lt;strong&gt;一直看着着这个水壶，直到这个水壶烧开，才去处理下一个水壶&lt;/strong&gt;。线程在等待水壶烧开的时间段什么都没有做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO（同步非阻塞 I/O）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还拿烧开水来说，NIO的做法是&lt;strong&gt;小菠萝一边玩着手机，每隔一段时间就看一看每个水壶的状态&lt;/strong&gt;，看看是否有水壶的状态发生了改变，如果某个水壶烧开了，可以先处理那个水壶，然后继续玩手机，继续隔一段时间又看看每个水壶的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AIO （异步非阻塞 I/O）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小菠萝觉得每隔一段时间就去看一看水壶太费劲了，于是购买了一批烧开水时可以&lt;strong&gt;哔哔响&lt;/strong&gt;的水壶，于是开始烧水后，小菠萝就直接去客厅玩手机了，水烧开时，就发出“哔哔”的响声，&lt;strong&gt;通知小菠萝来关掉水壶&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;什么是流&quot;&gt;什么是流&lt;/h2&gt;
&lt;p&gt;知识科普：我们知道任何一个文件都是以&lt;strong&gt;二进制&lt;/strong&gt;形式存在于设备中，计算机就只有 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt;，你能看见的东西全部都是由这两个数字组成，你看这篇文章时，这篇文章也是由01组成，只不过这些二进制串经过各种转换演变成一个个文字、一张张图片跃然屏幕上。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;流&lt;/strong&gt;就是将这些二进制串在各种设备之间进行传输，如果你觉得有些抽象，我举个例子就会好理解一些：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;下图是一张图片，它由01串组成，我们可以通过程序把一张图片拷贝到一个文件夹中，&lt;/p&gt;
&lt;p&gt;把图片转化成二进制数据集，把数据一点一点地传递到文件夹中 , 类似于水的流动 , 这样整体的数据就是一个数据流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-1598235636085.jpg&quot; alt=&quot;未命名绘图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IO 流读写数据的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;顺序读写&lt;/strong&gt;。读写数据时，大部分情况下都是按照顺序读写，读取时从文件开头的第一个字节到最后一个字节，写出时也是也如此（RandomAccessFile 可以实现随机读写）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节数组&lt;/strong&gt;。读写数据时本质上都是对字节数组做读取和写出操作，即使是字符流，也是在字节流基础上转化为一个个字符，所以字节数组是 IO 流读写数据的本质。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;流的分类&quot;&gt;流的分类&lt;/h2&gt;
&lt;p&gt;根据&lt;strong&gt;数据流向&lt;/strong&gt;不同分类：输入流 和 输出流&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;输入流&lt;/strong&gt;：从磁盘或者其它设备中将数据输入到进程中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出流&lt;/strong&gt;：将进程中的数据输出到磁盘或其它设备上保存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/1.jpg&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图示中的硬盘只是其中一种设备，还有非常多的设备都可以应用在IO流中，例如：打印机、硬盘、显示器、手机······&lt;/p&gt;
&lt;p&gt;根据&lt;strong&gt;处理数据的基本单位&lt;/strong&gt;不同分类：字节流 和 字符流&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字节流：以&lt;strong&gt;字节（8 bit）&lt;/strong&gt;为单位做数据的传输&lt;/li&gt;
&lt;li&gt;字符流：以&lt;strong&gt;字符&lt;/strong&gt;为单位（1字符 = 2字节）做数据的传输&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;字符流的本质也是通过字节流读取，Java 中的字符采用 Unicode 标准，在读取和输出的过程中，通过以字符为单位，查找对应的码表将字节转换为对应的字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面对字节流和字符流，很多读者都有疑惑：&lt;strong&gt;什么时候需要用字节流，什么时候又要用字符流？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我这里做一个简单的概括，你可以按照这个标准去使用：&lt;/p&gt;
&lt;p&gt;字符流只针对字符数据进行传输，所以如果是&lt;strong&gt;文本数据&lt;/strong&gt;，优先&lt;strong&gt;采用字符流&lt;/strong&gt;传输；除此之外，其它类型的数据（图片、音频等），最好还是以&lt;strong&gt;字节流&lt;/strong&gt;传输。&lt;/p&gt;
&lt;p&gt;根据这两种不同的分类，我们就可以做出下面这个表格，里面包含了 IO 中最核心的 4 个顶层抽象类：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据流向 / 数据类型&lt;/th&gt;
&lt;th&gt;字节流&lt;/th&gt;
&lt;th&gt;字符流&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;输入流&lt;/td&gt;
&lt;td&gt;InputStream&lt;/td&gt;
&lt;td&gt;Reader&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;输出流&lt;/td&gt;
&lt;td&gt;OutputStream&lt;/td&gt;
&lt;td&gt;Writer&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;现在看 IO 是不是有一些思路了，不会觉得很混乱了，我们来看这四个类下的所有成员。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200823091738251.png&quot; alt=&quot;image-20200823091738251&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[来自于 cxuan 的 《Java基础核心总结》]&lt;/p&gt;
&lt;p&gt;看到这么多的类是不是又开始觉得混乱了，不要慌，字节流和字符流下的输入流和输出流大部分都是一一对应的，有了上面的表格支撑，我们不需要再担心看见某个类会懵逼的情况了。&lt;/p&gt;
&lt;p&gt;看到 &lt;code&gt;Stream&lt;/code&gt; 就知道是&lt;strong&gt;字节流&lt;/strong&gt;，看到 &lt;code&gt;Reader / Writer&lt;/code&gt; 就知道是&lt;strong&gt;字符流&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里还要额外补充一点：Java IO 提供了&lt;strong&gt;字节流转换为字符流的转换类&lt;/strong&gt;，称为转换流。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;转换流 / 数据类型&lt;/th&gt;
&lt;th&gt;字节流与字符流之间的转换&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;（输入）字节流 =&amp;gt; 字符流&lt;/td&gt;
&lt;td&gt;InputStreamReader&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;（输出）字符流 =&amp;gt; 字节流&lt;/td&gt;
&lt;td&gt;OutputStreamWriter&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意字节流与字符流之间的转换是有严格定义的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入流：可以将字节流 =&amp;gt; 字符流&lt;/li&gt;
&lt;li&gt;输出流：可以将字符流 =&amp;gt; 字节流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么在输入流不能字符流 =&amp;gt; 字节流，输出流不能字节流 =&amp;gt; 字符流？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在存储设备上，所有数据都是以&lt;strong&gt;字节&lt;/strong&gt;为单位存储的，所以&lt;strong&gt;输入到内存时必定是以字节为单位输入，输出到存储设备时必须是以字节为单位输出&lt;/strong&gt;，字节流才是计算机最根本的存储方式，而字符流是在字节流的基础上对数据进行转换，输出字符，但每个字符依旧是以字节为单位存储的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;节点流和处理流&quot;&gt;节点流和处理流&lt;/h2&gt;
&lt;p&gt;在这里需要额外插入一个小节讲解节点流和处理流。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;节点流&lt;/strong&gt;：节点流是&lt;strong&gt;真正传输数据&lt;/strong&gt;的流对象，用于向特定的一个地方（节点）读写数据，称为节点流。例如 FileInputStream&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理流&lt;/strong&gt;：处理流是&lt;strong&gt;对节点流的封装&lt;/strong&gt;，使用外层的处理流读写数据，本质上是利用节点流的功能，外层的处理流可以提供额外的功能。处理流的基类都是以 &lt;code&gt;Filter&lt;/code&gt; 开头。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/1-1598317951549.jpg&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图将 &lt;code&gt;ByteArrayInputStream&lt;/code&gt; 封装成 &lt;code&gt;DataInputStream&lt;/code&gt;，可以将输入的字节数组转换为对应数据类型的数据。例如希望读入&lt;code&gt;int&lt;/code&gt;类型数据，就会以&lt;code&gt;2&lt;/code&gt;个字节为单位转换为一个数字。&lt;/p&gt;
&lt;h2 id=&quot;java-io-的核心类-file&quot;&gt;Java IO 的核心类 File&lt;/h2&gt;
&lt;p&gt;Java 提供了 File类，它指向计算机操作系统中的文件和目录，通过该类只能访问文件和目录，无法访问内容。 它内部主要提供了 &lt;code&gt;3&lt;/code&gt; 种操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;访问文件的属性&lt;/strong&gt;：绝对路径、相对路径、文件名······&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件检测&lt;/strong&gt;：是否文件、是否目录、文件是否存在、文件的读/写/执行权限······&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作文件&lt;/strong&gt;：创建目录、创建文件、删除文件······&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面举例的操作都是在开发中非常常用的，File 类远不止这些操作，更多的操作可以直接去 API 文档中根据需求查找。&lt;/p&gt;
&lt;p&gt;访问文件的属性：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;String getAbsolutePath()&lt;/td&gt;
&lt;td&gt;返回该文件处于系统中的绝对路径名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;String getPath()&lt;/td&gt;
&lt;td&gt;返回该文件的相对路径，通常与 new File() 传入的路径相同&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;String getName()&lt;/td&gt;
&lt;td&gt;返回该文件的文件名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;文件检测：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean isFIle()&lt;/td&gt;
&lt;td&gt;校验该路径指向是否一个文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean isDirectory()&lt;/td&gt;
&lt;td&gt;校验该路径指向是否一个目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean isExist()&lt;/td&gt;
&lt;td&gt;校验该路径指向的文件/目录是否存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean canWrite()&lt;/td&gt;
&lt;td&gt;校验该文件是否可写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean canRead()&lt;/td&gt;
&lt;td&gt;校验该文件是否可读&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean canExecute()&lt;/td&gt;
&lt;td&gt;校验该文件/目录是否可以被执行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;操作文件：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mkdirs()&lt;/td&gt;
&lt;td&gt;递归创建多个文件夹，路径中间有可能某些文件夹不存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;createNewFile()&lt;/td&gt;
&lt;td&gt;创建新文件，它是一个原子操作，有两步：检查文件是否存在、创建新文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;delete()&lt;/td&gt;
&lt;td&gt;删除文件或目录，删除目录时必须保证该目录为空&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;多了解一些&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件的读/写/执行权限，在 &lt;code&gt;Windows&lt;/code&gt; 中通常表现不出来，而在 &lt;code&gt;Linux&lt;/code&gt; 中可以很好地体现这一点，原因是 &lt;code&gt;Linux&lt;/code&gt; 有严格的用户权限分组，不同分组下的用户对文件有不同的操作权限，所以这些方法在 &lt;code&gt;Linux&lt;/code&gt; 下会比在 &lt;code&gt;Windows&lt;/code&gt; 下更好理解。下图是 redis 文件夹中的一些文件的详细信息，被红框标注的是不同用户的执行权限：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;r（Read）：代表该文件可以被当前用户读，操作权限的序号是 &lt;code&gt;4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;w（Write）：代表该文件可以被当前用户写，操作权限的序号是 &lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;x（Execute）：该文件可以被当前用户执行，操作权限的序号是 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200825080020253.png&quot; alt=&quot;image-20200825080020253&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;root root&lt;/code&gt; 分别代表：&lt;strong&gt;当前文件的所有者&lt;/strong&gt;，&lt;strong&gt;当前文件所属的用户分组&lt;/strong&gt;。Linux 下文件的操作权限分为三种用户：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件所有者&lt;/strong&gt;：拥有的权限是红框中的&lt;strong&gt;前三个字母&lt;/strong&gt;，&lt;code&gt;-&lt;/code&gt;代表没有某个权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件所在组的所有用户&lt;/strong&gt;：拥有的权限是红框中的&lt;strong&gt;中间三个字母&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其它组的所有用户&lt;/strong&gt;：拥有的权限是红框中的&lt;strong&gt;最后三个字母&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java-io-流对象&quot;&gt;Java IO 流对象&lt;/h2&gt;
&lt;p&gt;回顾流的分类有2种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据&lt;strong&gt;数据流向&lt;/strong&gt;分为输入流和输出流&lt;/li&gt;
&lt;li&gt;根据&lt;strong&gt;数据类型&lt;/strong&gt;分为字节流和字符流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，本小节将以字节流和字符流作为主要分割点，在其内部再细分为输入流和输出流进行讲解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200823091738251.png&quot; alt=&quot;image-20200823091738251&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;字节流对象&quot;&gt;字节流对象&lt;/h3&gt;
&lt;p&gt;字节流对象大部分输入流和输出流都是&lt;strong&gt;成双成对地出现&lt;/strong&gt;，所以学习的时候可以将输入流和输出流一一对应的流对象关联起来，输入流和输出流只是&lt;strong&gt;数据流向&lt;/strong&gt;不同，而&lt;strong&gt;处理数据的方式&lt;/strong&gt;可以是相同的。&lt;/p&gt;
&lt;p&gt;注意不要认为用什么流读入数据，就需要用对应的流写出数据，在 Java 中没有这么规定，下图只是各个对象之间的一个对应关系，&lt;strong&gt;不是两个类使用时必须强制关联使用&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;下面有非常多的类，我会介绍基类的方法，了解这些方法是&lt;strong&gt;非常有必要&lt;/strong&gt;的，子类的功能基于父类去扩展，只有真正了解父类在做什么，学习子类的成本就会下降。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200825084204026.png&quot; alt=&quot;image-20200825084204026&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;inputstream&quot;&gt;InputStream&lt;/h4&gt;
&lt;p&gt;InputStream 是字节输入流的抽象基类，提供了通用的读方法，让子类使用或重写它们。下面是 InputStream 常用的重要的方法。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;重要方法&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public abstract int read()&lt;/td&gt;
&lt;td&gt;从输入流中读取下一个字节，读到尾部时返回 -1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public int read(byte b[])&lt;/td&gt;
&lt;td&gt;从输入流中读取长度为 b.length 个字节放入字节数组 b 中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;public int read(byte b[], int off, int len)&lt;/td&gt;
&lt;td&gt;从输入流中读取指定范围的字节数据放入字节数组 b 中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;public void close()&lt;/td&gt;
&lt;td&gt;关闭此输入流并释放与该输入流相关的所有资源&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;还有其它一些不太常用的方法，我也列出来了。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;其它方法&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;public long skip(long n)&lt;/td&gt;
&lt;td&gt;跳过接下来的 n 个字节，返回实际上跳过的字节数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;public long available()&lt;/td&gt;
&lt;td&gt;返回下一次可读取（跳过）且不会被方法阻塞的字节数的估计值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;public synchronized void mark(int readlimit)&lt;/td&gt;
&lt;td&gt;标记此输入流的当前位置，对 reset() 方法的后续调用将会重新定位在 mark() 标记的位置，可以重新读取相同的字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public boolean markSupported()&lt;/td&gt;
&lt;td&gt;判断该输入流是否支持 mark() 和 reset() 方法，即能否重复读取字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public synchronized void reset()&lt;/td&gt;
&lt;td&gt;将流的位置重新定位在最后一次调用 mark() 方法时的位置&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200827082445395.png&quot; alt=&quot;image-20200827082445395&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）ByteArrayInputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ByteArrayInputStream 内部包含一个 &lt;code&gt;buf&lt;/code&gt; 字节数组缓冲区，该缓冲区可以从流中读取的字节数，使用 &lt;code&gt;pos&lt;/code&gt; 指针指向读取下一个字节的下标位置，内部还维护了一个&lt;code&gt;count&lt;/code&gt; 属性，代表能够读取 &lt;code&gt;count&lt;/code&gt; 个字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/bytearrayinputstream1.gif&quot; alt=&quot;bytearrayinputstream&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;必须保证 pos 严格小于 count，而 count 严格小于 buf.length 时，才能够从缓冲区中读取数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（2）FileInputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件输入流，从文件中读入字节，通常对文件的拷贝、移动等操作，可以使用该输入流把文件的字节读入内存中，然后再利用输出流输出到指定的位置上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）PipedInputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管道输入流，它与 PipedOutputStream 成对出现，可以实现多线程中的&lt;strong&gt;管道通信&lt;/strong&gt;。PipedOutputStream 中指定与特定的 PipedInputStream 连接，PipedInputStream 也需要指定特定的 PipedOutputStream 连接，之后输出流不断地往输入流的 &lt;code&gt;buffer&lt;/code&gt; 缓冲区写数据，而输入流可以从缓冲区中读取数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）ObjectInputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象输入流，用于对象的反序列化，将读入的字节数据反序列化为一个对象，实现对象的持久化存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）PushBackInputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是 FilterInputStream 的子类，是一个&lt;strong&gt;处理流&lt;/strong&gt;，它内部维护了一个缓冲数组&lt;code&gt;buf&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在读入字节的过程中可以将&lt;strong&gt;读取到的字节数据回退给缓冲区中保存&lt;/strong&gt;，下次可以再次从缓冲区中读出该字节数据。所以&lt;strong&gt;PushBackInputStream 允许多次读取输入流的字节数据&lt;/strong&gt;，只要将读到的字节放回缓冲区即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/pushBackInputStream.gif&quot; alt=&quot;2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是如果回推字节时，如果缓冲区已满，会抛出 &lt;code&gt;IOException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;它的应用场景：&lt;strong&gt;对数据进行分类规整&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假如一个文件中存储了&lt;strong&gt;数字&lt;/strong&gt;和&lt;strong&gt;字母&lt;/strong&gt;两种类型的数据，我们需要将它们交给两种线程各自去收集自己负责的数据，如果采用传统的做法，把所有的数据全部读入内存中，再将数据进行分离，面对大文件的情况下，例如&lt;strong&gt;1G、2G&lt;/strong&gt;，传统的输入流在读入数组后，&lt;strong&gt;由于没有缓冲区，只能对数据进行抛弃，这样每个线程都要读一遍文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用 PushBackInputStream 可以让一个专门的线程&lt;strong&gt;读取&lt;/strong&gt;文件，唤醒不同的线程读取字符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一次读取缓冲区的数据，判断该数据由哪些线程读取&lt;/li&gt;
&lt;li&gt;回退数据，唤醒对应的线程读取数据&lt;/li&gt;
&lt;li&gt;重复前两步&lt;/li&gt;
&lt;li&gt;关闭输入流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到这里，你是否会想到 &lt;code&gt;AQS&lt;/code&gt; 的 &lt;code&gt;Condition&lt;/code&gt; 等待队列，多个线程可以在不同的条件上等待被唤醒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）BufferedInputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓冲流，它是一种&lt;strong&gt;处理流&lt;/strong&gt;，对节点流进行封装并增强，其内部拥有一个 &lt;code&gt;buffer&lt;/code&gt; 缓冲区，用于缓存所有读入的字节，&lt;strong&gt;当缓冲区满时，才会将所有字节发送给客户端读取&lt;/strong&gt;，而不是每次都只发送一部分数据，提高了效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（7）DataInputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据输入流，它同样是一种&lt;strong&gt;处理流&lt;/strong&gt;，对节点流进行封装后，能够在内部对读入的字节转换为对应的 Java 基本数据类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（8）SequenceInputStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将两个或多个输入流看作是一个输入流依次读取，该类的存在与否并不影响整个 IO 生态，在程序中也能够做到这种效果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;s&gt;（9）StringBufferInputStream&lt;/s&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将字符串中每个字符的低 8 位转换为字节读入到字节数组中，目前已过期&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InputStream 总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InputStream 是所有输入字节流的&lt;strong&gt;抽象基类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ByteArrayInputStream 和 FileInputStream 是两种基本的节点流，他们分别从&lt;strong&gt;字节数组&lt;/strong&gt; 和 &lt;strong&gt;本地文件&lt;/strong&gt;中读取数据&lt;/li&gt;
&lt;li&gt;DataInputStream、BufferedInputStream 和 PushBackInputStream 都是&lt;strong&gt;处理流&lt;/strong&gt;，对基本的节点流进行封装并增强&lt;/li&gt;
&lt;li&gt;PipiedInputStream 用于&lt;strong&gt;多线程通信&lt;/strong&gt;，可以与其它线程公用一个管道，读取管道中的数据。&lt;/li&gt;
&lt;li&gt;ObjectInputStream 用于&lt;strong&gt;对象的反序列化&lt;/strong&gt;，将对象的字节数据读入内存中，通过该流对象可以将字节数据转换成对应的对象&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;outputstream&quot;&gt;OutputStream&lt;/h4&gt;
&lt;p&gt;OutputStream 是字节输出流的抽象基类，提供了通用的写方法，让继承的子类重写和复用。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public abstract void write(int b)&lt;/td&gt;
&lt;td&gt;将指定的字节写出到输出流，写入的字节是参数 b 的低 8 位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public void write(byte b[])&lt;/td&gt;
&lt;td&gt;将指定字节数组中的所有字节写入到输出流当中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;public void write(byte b[], int off, int len)&lt;/td&gt;
&lt;td&gt;指定写入的起始位置 offer，字节数为 len 的字节数组写入到输出流当中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;public void flush()&lt;/td&gt;
&lt;td&gt;刷新此输出流，并强制写出所有缓冲的输出字节到指定位置，每次写完都要调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;public void close()&lt;/td&gt;
&lt;td&gt;关闭此输出流并释放与此流关联的所有系统资源&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200827090101687.png&quot; alt=&quot;image-20200827090101687&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OutputStream 中大多数的类和 InputStream 是对应的，只不过数据的流向不同而已。从上面的图可以看出：&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;OutputStream 是所有输出字节流的&lt;strong&gt;抽象基类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ByteArrayOutputStream 和 FileOutputStream 是两种基本的节点流，它们分别向&lt;strong&gt;字节数组&lt;/strong&gt;和&lt;strong&gt;本地文件&lt;/strong&gt;写出数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;DataOutputStream、BufferedOutputStream 是&lt;strong&gt;处理流&lt;/strong&gt;，前者可以将&lt;strong&gt;字节数据转换成基本数据类型&lt;/strong&gt;写出到文件中；后者是缓冲字节数组，只有在缓冲区满时，才会将所有的字节写出到目的地，&lt;strong&gt;减少了 IO 次数&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;PipedOutputStream 用于&lt;strong&gt;多线程通信&lt;/strong&gt;，可以和其它线程共用一个管道，向管道中写入数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ObjectOutputStream 用于对象的&lt;strong&gt;序列化&lt;/strong&gt;，将对象转换成字节数组后，将所有的字节都写入到指定位置中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;PrintStream 在 OutputStream 基础之上提供了增强的功能，即&lt;strong&gt;可以方便地输出各种类型的数据&lt;/strong&gt;（而不仅限于byte型）的格式化表示形式，且 PrintStream 的方法从不抛出 IOEception，其原理是&lt;strong&gt;写出时将各个数据类型的数据统一转换为 String 类型&lt;/strong&gt;，我会在讲解完&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;字符流对象&quot;&gt;字符流对象&lt;/h3&gt;
&lt;p&gt;字符流对象也会有对应关系，大多数的类可以认为是&lt;strong&gt;操作的数据从字节数组变为字符&lt;/strong&gt;，类的功能和字节流对象是相似的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;字符输入流和字节输入流的组成非常相似，字符输入流是对字节输入流的&lt;strong&gt;一层转换&lt;/strong&gt;，所有文件的存储都是&lt;strong&gt;字节的存储&lt;/strong&gt;，在磁盘上保留的不是文件的字符，而是先把字符编码成字节，再保存到文件中。在读取文件时，读入的也是一个一个字节组成的字节序列，而 Java 虚拟机通过将字节序列，按照2个字节为单位转换为 Unicode 字符，实现字节到字符的映射。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200827094740444.png&quot; alt=&quot;image-20200827094740444&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;reader&quot;&gt;Reader&lt;/h4&gt;
&lt;p&gt;Reader 是字符输入流的抽象基类，它内部的重要方法如下所示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;重要方法&lt;/th&gt;
&lt;th&gt;方法功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public int read(java.nio.CharBuffer target)&lt;/td&gt;
&lt;td&gt;将读入的字符存入指定的字符缓冲区中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;public int read()&lt;/td&gt;
&lt;td&gt;读取一个字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public int read(char cbuf[])&lt;/td&gt;
&lt;td&gt;读入字符放入整个字符数组中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;abstract public int read(char cbuf[], int off, int len)&lt;/td&gt;
&lt;td&gt;将字符读入字符数组中的指定范围中&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;还有其它一些额外的方法，与字节输入流基类提供的方法是相同的，只是作用的对象不再是字节，而是字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200827095911702.png&quot; alt=&quot;image-20200827095911702&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reader 是所有字符输入流的&lt;strong&gt;抽象基类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;CharArrayReader 和 StringReader 是两种基本的节点流，它们分别从读取 &lt;strong&gt;字符数组&lt;/strong&gt; 和 &lt;strong&gt;字符串&lt;/strong&gt; 数据，StringReader 内部是一个 &lt;code&gt;String&lt;/code&gt; 变量值，通过遍历该变量的字符，实现读取字符串，&lt;strong&gt;本质上也是在读取字符数组&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PipedReader 用于多线程中的通信，从共用地管道中读取字符数据&lt;/li&gt;
&lt;li&gt;BufferedReader 是字符输入&lt;strong&gt;缓冲流&lt;/strong&gt;，将读入的数据放入字符缓冲区中，&lt;strong&gt;实现高效地读取字符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;InputStreamReader 是一种&lt;strong&gt;转换流&lt;/strong&gt;，可以实现从字节流转换为字符流，将字节数据转换为字符&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;writer&quot;&gt;Writer&lt;/h4&gt;
&lt;p&gt;Reader 是字符输出流的抽象基类，它内部的重要方法如下所示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;重要方法&lt;/th&gt;
&lt;th&gt;方法功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public void write(char cbuf[])&lt;/td&gt;
&lt;td&gt;将 cbuf 字符数组写出到输出流&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;abstract public void write(char cbuf[], int off, int len)&lt;/td&gt;
&lt;td&gt;将指定范围的 cbuf 字符数组写出到输出流&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public void write(String str)&lt;/td&gt;
&lt;td&gt;将字符串 str 写出到输出流，str 内部也是字符数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;public void write(String str, int off, int len)&lt;/td&gt;
&lt;td&gt;将字符串 str 的某一部分写出到输出流&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;abstract public void flush()&lt;/td&gt;
&lt;td&gt;刷新，如果数据保存在缓冲区，调用该方法才会真正写出到指定位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;abstract public void close()&lt;/td&gt;
&lt;td&gt;关闭流对象，每次 IO 执行完毕后都需要关闭流对象，释放系统资源&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-2020082710483752111.png&quot; alt=&quot;image-20200827104837521&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Writer 是所有的输出字符流的抽象基类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;CharArrayWriter、StringWriter 是两种基本的节点流，它们分别向Char 数组、字符串中写入数据。&lt;/strong&gt;StringWriter 内部保存了 StringBuffer 对象，可以实现字符串的动态增长&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PipedWriter 可以向共用的管道中&lt;strong&gt;写入字符数据&lt;/strong&gt;，给其它线程读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;BufferedWriter&lt;/strong&gt; 是&lt;strong&gt;缓冲输出流&lt;/strong&gt;，可以将写出的数据缓存起来，缓冲区满时再调用 flush() 写出数据，&lt;strong&gt;减少 IO 次数&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;PrintWriter 和 PrintStream 类似，功能和使用也非常相似，&lt;strong&gt;只是写出的数据是字符而不是字节&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;OutputStreamWriter&lt;/strong&gt; 将&lt;strong&gt;字符流转换为字节流&lt;/strong&gt;，将字符写出到指定位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;字节流与字符流的转换&quot;&gt;字节流与字符流的转换&lt;/h2&gt;
&lt;p&gt;从任何地方把数据读入到内存都是先以&lt;strong&gt;字节流&lt;/strong&gt;形式读取，即使是使用字符流去读取数据，依然成立，因为数据永远是以字节的形式存在于互联网和硬件设备中，字符流是通过&lt;strong&gt;字符集&lt;/strong&gt;的映射，才能够将字节转换为字符。&lt;/p&gt;
&lt;p&gt;所以 Java 提供了两种转换流：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InputStreamReader：从&lt;strong&gt;字节流转换为字符流&lt;/strong&gt;，将字节数据转换为字符数据读入到内存&lt;/li&gt;
&lt;li&gt;OutputStreamWriter：从&lt;strong&gt;字符流转换为字节流&lt;/strong&gt;，将字符数据转换为字节数据写出到指定位置&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;了解了 Java 传统的 BIO 中字符流和字节流的主要成员之后，至少要掌握以下两个关键点：&lt;/p&gt;
&lt;p&gt;（1）传统的 BIO 是以&lt;code&gt;流&lt;/code&gt;为基本单位处理数据的，想象成水流，一点点地传输字节数据，IO 流传输的过程永远是以&lt;code&gt;字节&lt;/code&gt;形式传输。&lt;/p&gt;
&lt;p&gt;（2）字节流和字符流的区别在于操作的数据单位不相同，字符流是通过将字节数据通过字符集映射成对应的字符，字符流本质上也是字节流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们再继续学习 NIO 知识，NIO 是当下非常火热的一种 IO 工作方式，它能够解决传统 BIO 的痛点：&lt;strong&gt;阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;BIO 如果遇到 IO 阻塞时，线程将会被挂起，直到 IO 完成后才唤醒线程，线程切换带来了额外的开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;BIO 中每个 IO 都需要有对应的一个线程去专门处理该次 IO 请求，会让服务器的压力迅速提高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们希望做到的是&lt;strong&gt;当线程等待 IO 完成时能够去完成其它事情，当 IO 完成时线程可以回来继续处理 IO 相关操作，不必干干的坐等 IO 完成。&lt;/strong&gt;在 IO 处理的过程中，能够有一个&lt;strong&gt;专门的线程负责监听这些 IO 操作，通知服务器该如何操作&lt;/strong&gt;。所以，我们聊到 IO，不得不去接触 NIO 这一块硬骨头。&lt;/p&gt;
&lt;h2 id=&quot;新潮的-nio&quot;&gt;新潮的 NIO&lt;/h2&gt;
&lt;p&gt;我们来看看 BIO 和 NIO 的区别，BIO 是&lt;strong&gt;面向流&lt;/strong&gt;的 IO，它建立的通道都是&lt;strong&gt;单向&lt;/strong&gt;的，所以输入和输出流的通道不相同，必须建立2个通道，通道内的都是传输&lt;mark&gt;0101001···&lt;/mark&gt;的字节数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/asdqweqweqe.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在 NIO 中，不再是面向流的 IO 了，而是面向&lt;strong&gt;缓冲区&lt;/strong&gt;，它会建立一个&lt;strong&gt;通道（Channel）&lt;/strong&gt;，该通道我们可以理解为&lt;strong&gt;铁路&lt;/strong&gt;，该铁路上可以运输各种货物，而通道上会有一个&lt;strong&gt;缓冲区（Buffer）&lt;/strong&gt;用于存储真正的数据，缓冲区我们可以理解为&lt;strong&gt;一辆火车&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道（铁路）&lt;/strong&gt;只是作为运输数据的一个连接资源，而真正存储数据的是&lt;strong&gt;缓冲区（火车）&lt;/strong&gt;。即&lt;strong&gt;通道负责传输，缓冲区负责存储。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200902090452.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解了上面的图之后，BIO 和 NIO 的主要区别就可以用下面这个表格简单概括。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;BIO&lt;/th&gt;
&lt;th&gt;NIO&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;面向流（Stream）&lt;/td&gt;
&lt;td&gt;面向缓冲区（Buffer）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;单向通道&lt;/td&gt;
&lt;td&gt;双向通道&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;阻塞 IO&lt;/td&gt;
&lt;td&gt;非阻塞 IO&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;选择器（Selectors）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;缓冲区（buffer）&quot;&gt;缓冲区（Buffer）&lt;/h2&gt;
&lt;p&gt;缓冲区是&lt;strong&gt;存储数据&lt;/strong&gt;的区域，在 Java 中，缓冲区就是数组，为了可以操作不同数据类型的数据，Java 提供了许多不同类型的缓冲区，&lt;strong&gt;除了布尔类型以外&lt;/strong&gt;，其它基本数据类型都有对应的缓冲区数组对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200906104811.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;为什么没有布尔类型的缓冲区呢？&lt;/p&gt;
&lt;p&gt;在 Java 中，boolean 类型数据只占用 &lt;code&gt;1 bit&lt;/code&gt;，而在 IO 传输过程中，都是以字节为单位进行传输的，所以 boolean 的 1 bit 完全可以使用 byte 类型的某一位，或者 int 类型的某一位来表示，没有必要为了这 1 bit 而专门提供多一个缓冲区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;缓冲区&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ByteBuffer&lt;/td&gt;
&lt;td&gt;存储&lt;strong&gt;字节数据&lt;/strong&gt;的缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CharBuffer&lt;/td&gt;
&lt;td&gt;存储&lt;strong&gt;字符数据&lt;/strong&gt;的缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ShortBuffer&lt;/td&gt;
&lt;td&gt;存储&lt;strong&gt;短整型数据&lt;/strong&gt;的缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IntBuffer&lt;/td&gt;
&lt;td&gt;存储&lt;strong&gt;整型数据&lt;/strong&gt;的缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LongBuffer&lt;/td&gt;
&lt;td&gt;存储&lt;strong&gt;长整型数据&lt;/strong&gt;的缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FloatBuffer&lt;/td&gt;
&lt;td&gt;存储&lt;strong&gt;单精度浮点型数据&lt;/strong&gt;的缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DoubleBuffer&lt;/td&gt;
&lt;td&gt;存储&lt;strong&gt;双精度浮点型数据&lt;/strong&gt;的缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;分配一个缓冲区的方式都高度一致：使用&lt;code&gt;allocate(int capacity)&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;例如需要分配一个 1024 大小的字节数组，代码就是下面这样子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缓冲区&lt;strong&gt;读写数据&lt;/strong&gt;的两个核心方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;put()：将数据写入到缓冲区中&lt;/li&gt;
&lt;li&gt;get()：从缓冲区中读取数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缓冲区的重要属性：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;capacity&lt;/strong&gt;：缓冲区中&lt;strong&gt;最大存储数据的容量&lt;/strong&gt;，一旦声明则无法改变&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;limit&lt;/strong&gt;：表示缓冲区中&lt;strong&gt;可以操作数据的大小&lt;/strong&gt;，limit 之后的数据无法进行读写。必须满足 limit &amp;lt;= capacity&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;position&lt;/strong&gt;：当前缓冲区中&lt;strong&gt;正在操作数据的下标位置&lt;/strong&gt;，必须满足 position &amp;lt;= limit&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;mark&lt;/strong&gt;：标记位置，调用 reset() 将 position 位置调整到 mark 属性指向的下标位置，&lt;strong&gt;实现多次读取数据&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缓冲区为高效读写数据而提供的其它&lt;strong&gt;辅助方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flip()：可以实现&lt;strong&gt;读写模式的切换&lt;/strong&gt;，我们可以看看里面的源码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final Buffer flip() {
    limit = position;
    position = 0;
    mark = -1;
    return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用 flip() 会将可操作的大小 limit 设置为当前写的位置，操作数据的起始位置 position 设置为 0，即&lt;strong&gt;从头开始读取数据&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;rewind()：可以将 position 位置设置为 0，再次读取缓冲区中的数据&lt;/li&gt;
&lt;li&gt;clear()：清空整个缓冲区，它会将 position 设置为 0，limit 设置为 capacity，可以&lt;strong&gt;写整个缓冲区&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;更多的方法可以去查阅 API 文档，本文碍于篇幅原因就不贴出其它方法了，主要是要&lt;strong&gt;理解缓冲区的作用&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们来看一个简单的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Class Main {
    public static void main(String[] args) {
         // 分配内存大小为11的整型缓存区
        IntBuffer buffer = IntBuffer.allocate(11);
        // 往buffer里写入2个整型数据
        for (int i = 0; i &amp;lt; 2; ++i) {
            int randomNum = new SecureRandom().nextInt();
            buffer.put(randomNum);
        }
        // 将Buffer从写模式切换到读模式
        buffer.flip();
        System.out.println(&quot;position &amp;gt;&amp;gt; &quot; + buffer.position()
                           + &quot;limit &amp;gt;&amp;gt; &quot; + buffer.limit() 
                           + &quot;capacity &amp;gt;&amp;gt; &quot; + buffer.capacity());
        // 读取buffer里的数据
        while (buffer.hasRemaining()) {
            System.out.println(buffer.get());
        }
        System.out.println(&quot;position &amp;gt;&amp;gt; &quot; + buffer.position()
                           + &quot;limit &amp;gt;&amp;gt; &quot; + buffer.limit() 
                           + &quot;capacity &amp;gt;&amp;gt; &quot; + buffer.capacity());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下图所示，首先我们往缓冲区中写入 2 个数据，position 在写模式下指向下标 2，然后调用 flip() 方法切换为读模式，limit 指向下标 2，position 从 0 开始读数据，读到下标为 2 时发现到达 limit 位置，不可继续读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200902104607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个过程可以用下图来理解，调用 flip() 方法以后，读出数据的同时 position 指针不断往后挪动，到达 limit 指针的位置时，该次读取操作结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200902104730.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;介绍完缓冲区后，我们知道它是存储数据的空间，进程可以将缓冲区中的数据读取出来，也可以写入新的数据到缓冲区，那缓冲区的数据从哪里来，又怎么写出去呢？接下来我们需要学习传输数据的介质：通道（Channel）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;通道（channel）&quot;&gt;通道（Channel）&lt;/h2&gt;
&lt;p&gt;上面我们介绍过，通道是作为一种连接资源，作用是传输数据，而真正存储数据的是缓冲区，所以介绍完缓冲区后，我们来学习通道这一块。&lt;/p&gt;
&lt;p&gt;通道是可以&lt;strong&gt;双向读写&lt;/strong&gt;的，传统的 BIO 需要使用输入/输出流表示数据的流向，在 NIO 中可以减少通道资源的消耗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200906104847.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通道类都保存在 &lt;code&gt;java.nio.channels&lt;/code&gt; 包下，我们日常用到的几个重要的类有 4 个：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;IO 通道类型&lt;/th&gt;
&lt;th&gt;具体类&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;文件 IO&lt;/td&gt;
&lt;td&gt;FileChannel（用于文件读写、操作文件的通道）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;TCP 网络 IO&lt;/td&gt;
&lt;td&gt;SocketChannel（用于读写数据的 TCP 通道）、ServerSocketChannel（监听客户端的连接）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UDP 网络 IO&lt;/td&gt;
&lt;td&gt;DatagramChannel（收发 UDP 数据报的通道）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以通过 &lt;code&gt;getChannel()&lt;/code&gt; 方法获取一个通道，支持获取通道的类如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件 IO：FileInputStream、FileOutputStream、RandomAccessFile&lt;/li&gt;
&lt;li&gt;TCP 网络 IO：Socket、ServerSocket&lt;/li&gt;
&lt;li&gt;UDP 网络 IO：DatagramSocket&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;示例：文件拷贝案例&quot;&gt;示例：文件拷贝案例&lt;/h3&gt;
&lt;p&gt;我们来看一个利用&lt;strong&gt;通道拷贝文件&lt;/strong&gt;的例子，需要下面几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开原文件的输入流通道，将字节数据读入到缓冲区中&lt;/li&gt;
&lt;li&gt;打开目的文件的输出流通道，将缓冲区中的数据写到目的地&lt;/li&gt;
&lt;li&gt;关闭所有流和通道（重要！）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是一张小菠萝的照片，它存在于&lt;code&gt;d:\小菠萝\&lt;/code&gt;文件夹下，我们将它拷贝到 &lt;code&gt;d:\小菠萝分身\&lt;/code&gt; 文件夹下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/myPhoto.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test {
        /** 缓冲区的大小 */
    public static final int SIZE = 1024;

    public static void main(String[] args) throws IOException {
        // 打开文件输入流
        FileChannel inChannel = new FileInputStream(&quot;d:\小菠萝\小菠萝.jpg&quot;).getChannel();
        // 打开文件输出流
        FileChannel outChannel = new FileOutputStream(&quot;d:\小菠萝分身\小菠萝-拷贝.jpg&quot;).getChannel();
        // 分配 1024 个字节大小的缓冲区
        ByteBuffer dsts = ByteBuffer.allocate(SIZE);
        // 将数据从通道读入缓冲区
        while (inChannel.read(dsts) != -1) {
            // 切换缓冲区的读写模式
            dsts.flip();
            // 将缓冲区的数据通过通道写到目的地
            outChannel.write(dsts);
            // 清空缓冲区，准备下一次读
            dsts.clear();
        }
        inChannel.close();
        outChannel.close();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我画了一张图帮助你理解上面的这一个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200904102845.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有人会问，NIO 的文件拷贝和传统 IO 流的文件拷贝有何不同呢？我们在编程时感觉它们没有什么区别呀，&lt;strong&gt;貌似只是 API 不同罢了&lt;/strong&gt;，我们接下来就去看看这两者之间的区别吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;bio-和-nio-拷贝文件的区别&quot;&gt;BIO 和 NIO 拷贝文件的区别&lt;/h3&gt;
&lt;p&gt;这个时候就要来了解了解操作系统底层是怎么对 IO 和 NIO 进行区别的，我会用尽量通俗的文字带你理解，可能并不是那么严谨。&lt;/p&gt;
&lt;p&gt;操作系统最重要的就是&lt;strong&gt;内核&lt;/strong&gt;，它既可以访问受保护的内存，也可以访问底层硬件设备，所以为了保护内核的安全，操作系统将底层的虚拟空间分为了&lt;strong&gt;用户空间&lt;/strong&gt;和&lt;strong&gt;内核空间&lt;/strong&gt;，其中用户空间就是给用户进程使用的，内核空间就是专门给操作系统底层去使用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200904104123.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，有一个 Java 进程希望把小菠萝这张图片从磁盘上拷贝，那么内核空间和用户空间都会有一个&lt;strong&gt;缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这张照片就会从磁盘中读出到&lt;strong&gt;内核缓冲区&lt;/strong&gt;中保存，然后操作系统将内核缓冲区中的这张图片字节数据拷贝到用户进程的缓冲区中保存下来，对应着下面这幅图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200904104823.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;然后用户进程会希望把缓冲区中的字节数据写到磁盘上的另外一个地方，会将数据拷贝到 Socket 缓冲区中，最终操作系统再将 Socket 缓冲区的数据写到磁盘的指定位置上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200904105253.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一轮操作下来，我们数数经过了几次数据的拷贝？&lt;code&gt;4&lt;/code&gt; 次。有 2 次是&lt;strong&gt;内核空间和用户空间之间的数据拷贝&lt;/strong&gt;，这两次拷贝涉及到&lt;strong&gt;用户态和内核态的切换&lt;/strong&gt;，需要&lt;strong&gt;CPU参与进来&lt;/strong&gt;，进行上下文切换。而另外 2 次是&lt;strong&gt;硬盘和内核空间之间的数据拷贝&lt;/strong&gt;，这个过程利用到 DMA与系统内存交换数据，不需要 CPU 的参与。&lt;/p&gt;
&lt;p&gt;导致 IO 性能瓶颈的原因：&lt;strong&gt;内核空间与用户空间之间数据过多无意义的拷贝，以及多次上下文切换&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;用户进程请求读取数据&lt;/td&gt;
&lt;td&gt;用户态 -&amp;gt; 内核态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;操作系统内核返回数据给用户进程&lt;/td&gt;
&lt;td&gt;内核态 -&amp;gt; 用户态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;用户进程请求写数据到硬盘&lt;/td&gt;
&lt;td&gt;用户态 -&amp;gt; 内核态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;操作系统返回操作结果给用户进程&lt;/td&gt;
&lt;td&gt;内核态 -&amp;gt; 用户态&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在用户空间与内核空间之间的操作，会涉及到上下文的切换，这里需要 CPU 的干预，而数据在两个空间之间来回拷贝，也需要 CPU 的干预，这无疑会增大 CPU 的压力，NIO 是如何减轻 CPU 的压力？运用操作系统的&lt;strong&gt;零拷贝&lt;/strong&gt;技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;操作系统的零拷贝&quot;&gt;操作系统的零拷贝&lt;/h3&gt;
&lt;p&gt;所以，操作系统出现了一个全新的概念，解决了 IO 瓶颈：&lt;strong&gt;零拷贝&lt;/strong&gt;。零拷贝指的是&lt;strong&gt;内核空间与用户空间之间的零次拷贝&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;零拷贝可以说是 IO 的一大救星，操作系统底层有许多种零拷贝机制，我这里仅针对 Java NIO 中使用到的其中一种零拷贝机制展开讲解。&lt;/p&gt;
&lt;p&gt;在 Java NIO 中，零拷贝是通过&lt;strong&gt;用户空间和内核空间的缓冲区共享一块物理内存&lt;/strong&gt;实现的，也就是说上面的图可以演变成这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/image-20200904122132978.png&quot; alt=&quot;image-20200904122132978&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这时，无论是用户空间还是内核空间操作自己的缓冲区，本质上都是&lt;strong&gt;操作这一块共享内存&lt;/strong&gt;中的缓冲区数据，&lt;strong&gt;省去了用户空间和内核空间之间的数据拷贝操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在我们重新来拷贝文件，就会变成下面这个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户进程通过系统调用 &lt;code&gt;read()&lt;/code&gt; 请求读取文件到用户空间缓冲区（&lt;strong&gt;第一次上下文切换&lt;/strong&gt;），用户态 -&amp;gt; 核心态，数据从硬盘读取到内核空间缓冲区中（&lt;strong&gt;第一次数据拷贝&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;系统调用返回到用户进程（&lt;strong&gt;第二次上下文切换&lt;/strong&gt;），此时用户空间与内核空间共享这一块内存（缓冲区），所以&lt;strong&gt;不需要从内核缓冲区拷贝到用户缓冲区&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用户进程发出 &lt;code&gt;write()&lt;/code&gt; 系统调用请求写数据到硬盘上（&lt;strong&gt;第三次上下文切换&lt;/strong&gt;），此时需要将内核空间缓冲区中的数据拷贝到内核的 Socket 缓冲区中（&lt;strong&gt;第二次数据拷贝&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;由 DMA 将 Socket 缓冲区的内容写到硬盘上（&lt;strong&gt;第三次数据拷贝&lt;/strong&gt;），&lt;code&gt;write()&lt;/code&gt; 系统调用返回（&lt;strong&gt;第四次上下文切换&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整个过程就如下面这幅图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200904123822.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中，&lt;strong&gt;需要 CPU 参与工作的步骤只有第③个步骤&lt;/strong&gt;，对比于传统的 IO，CPU 需要在用户空间与内核空间之间参与拷贝工作，需要无意义地占用 2 次 CPU 资源，导致 CPU 资源的浪费。&lt;/p&gt;
&lt;p&gt;下面总结一下操作系统中零拷贝的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;降低 CPU 的压力&lt;/strong&gt;：避免 CPU 需要参与内核空间与用户空间之间的数据拷贝工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少不必要的拷贝&lt;/strong&gt;：避免用户空间与内核空间之间需要进行数据拷贝&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的图示可能并不严谨，对于你理解零拷贝会有一定的帮助，关于零拷贝的知识点可以去查阅更多资料哦，这是一门大学问。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;介绍完通道后，我们知道它是用于&lt;strong&gt;传输数据的一种介质&lt;/strong&gt;，而且是&lt;strong&gt;可以双向读写&lt;/strong&gt;的，那么如果放在网络 IO 中，这些通道如果有数据就绪时，服务器是如何发现并处理的呢？接下来我们去学习 NIO 中的最后一个重要知识点：选择器（Selector）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;选择器（selectors）&quot;&gt;选择器（Selectors）&lt;/h2&gt;
&lt;p&gt;选择器是提升 IO 性能的灵魂之一，它底层利用了&lt;strong&gt;多路复用 IO&lt;/strong&gt;机制，让选择器可以监听多个 IO 连接，根据 IO 的状态响应到服务器端进行处理。通俗地说：&lt;strong&gt;选择器可以监听多个 IO 连接，而传统的 BIO 每个 IO 连接都需要有一个线程去监听和处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200906105002.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中很明显的显示了在 BIO 中，每个 Socket 都需要有一个专门的线程去处理每个请求，而在 NIO 中，只需要一个 Selector 即可监听各个 Socket 请求，而且 Selector 并不是阻塞的，所以&lt;strong&gt;不会因为多个线程之间切换导致上下文切换带来的开销&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200904185407.png&quot; alt=&quot;image-20200904185402331&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Java NIO 中，选择器是使用 &lt;code&gt;Selector&lt;/code&gt; 类表示，Selector 可以接收各种 IO 连接，在 IO 状态准备就绪时，会通知该通道注册的 Selector，Selector 在&lt;strong&gt;下一次轮询&lt;/strong&gt;时会发现该 IO 连接就绪，进而处理该连接。&lt;/p&gt;
&lt;p&gt;Selector 选择器主要用于&lt;strong&gt;网络 IO&lt;/strong&gt;当中，在这里我会将传统的 BIO Socket 编程和使用 NIO 后的 Socket 编程作对比，分析 NIO 为何更受欢迎。首先先来了解 Selector 的基本结构。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;重要方法&lt;/th&gt;
&lt;th&gt;方法解析&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;open()&lt;/td&gt;
&lt;td&gt;打开一个 Selector 选择器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;int select()&lt;/td&gt;
&lt;td&gt;阻塞地等待就绪的通道&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;int select(long timeout)&lt;/td&gt;
&lt;td&gt;最多阻塞 timeout 毫秒，如果是 0 则一直阻塞等待，如果是 1 则代表最多阻塞 1 毫秒&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;int selectNow()&lt;/td&gt;
&lt;td&gt;非阻塞地轮询就绪的通道&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在这里，你会看到 select() 和它的重载方法是会阻塞的，如果用户进程轮询时发现没有就绪的通道，操作系统有两种做法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一直等待直到一个就绪的通道，再返回给用户进程&lt;/li&gt;
&lt;li&gt;立即返回一个错误状态码给用户进程，让用户进程继续运行，不会阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种方法对应了&lt;strong&gt;同步阻塞 IO&lt;/strong&gt; 和 &lt;strong&gt;同步非阻塞 IO&lt;/strong&gt; ，这里读者的一点小的观点，请各位大神&lt;strong&gt;批判阅读&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Java 中的 NIO 不能真正意义上称为 Non-Blocking IO，我们通过 API 的调用可以发现，select() 方法还是会存在阻塞的现象，根据传入的参数不同，操作系统的行为也会有所不同，不同之处就是&lt;strong&gt;阻塞还是非阻塞&lt;/strong&gt;，所以我更倾向于把 NIO 称为 New IO，因为它不仅提供了 Non-Blocking IO，而且保留原有的 Blocking IO 的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;了解了选择器之后，它的作用就是：&lt;strong&gt;监听多个 IO 通道，当有通道就绪时选择器会轮询发现该通道，并做相应的处理&lt;/strong&gt;。那么 IO 状态分为很多种，我们如何去识别就绪的通道是处于哪种状态呢？在 Java 中提供了&lt;strong&gt;选择键（SelectionKey）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;选择键（selectionkey）&quot;&gt;选择键（SelectionKey）&lt;/h3&gt;
&lt;p&gt;在 Java 中提供了 4 种选择键：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SelectionKey.OP_READ：套接字通道准备好进行&lt;strong&gt;读操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_WRITE：套接字通道准备好进行&lt;strong&gt;写操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_ACCEPT：服务器套接字通道&lt;strong&gt;接受其它通道&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_CONNECT：套接字通道准备&lt;strong&gt;完成连接&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 SelectionKey 中包含了许多属性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;channel：该选择键&lt;strong&gt;绑定的通道&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;selector：轮询到该选择键的&lt;strong&gt;选择器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;readyOps：当前&lt;strong&gt;就绪选择键的值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;interesOps：该选择器对该通道&lt;strong&gt;感兴趣的所有选择键&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;选择键的作用是：&lt;strong&gt;在选择器轮询到有就绪通道时，会返回这些通道的就绪选择键（SelectionKey），通过选择键可以获取到通道进行操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单了解了选择器后，我们可以结合缓冲区、通道和选择器来完成一个简易的聊天室应用。&lt;/p&gt;
&lt;h3 id=&quot;示例：简易的客户端服务器通信&quot;&gt;示例：简易的客户端服务器通信&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;先说明，这里的代码非常的臭和长，不推荐细看，直接看注释附近的代码即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在服务器端会开辟两个线程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Thread1：专门监听客户端的连接，并把通道注册到客户端选择器上&lt;/li&gt;
&lt;li&gt;Thread2：专门监听客户端的其它 IO 状态（读状态），当客户端的 IO 状态就绪时，该选择器会轮询发现，并作相应处理&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NIOServer {
    
        Selector serverSelector = Selector.open();
    Selector clientSelector = Selector.open();
    
    public static void main(String[] args) throws IOException {
        NIOServer server = nwe NIOServer();
        new Thread(() -&amp;gt; {
            try {
                // 对应IO编程中服务端启动
                ServerSocketChannel listenerChannel = ServerSocketChannel.open();
                listenerChannel.socket().bind(new InetSocketAddress(3333));
                listenerChannel.configureBlocking(false);
                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);
                                server.acceptListener();
            } catch (IOException ignored) {
            }
        }).start();
        new Thread(() -&amp;gt; {
            try {
                server.clientListener();
            } catch (IOException ignored) {
            }
        }).start();
    }
}
// 监听客户端连接
public void acceptListener() {
    while (true) {
        if (serverSelector.select(1) &amp;gt; 0) {
            Set&amp;lt;SelectionKey&amp;gt; set = serverSelector.selectedKeys();
            Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = set.iterator();
            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();
                if (key.isAcceptable()) {
                    try {
                        // (1) 每来一个新连接，注册到clientSelector
                        SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
                        clientChannel.configureBlocking(false);
                        clientChannel.register(clientSelector, SelectionKey.OP_READ);
                    } finally {
                        // 从就绪的列表中移除这个key
                        keyIterator.remove();
                    }
                }
            }
        }
    }
}
// 监听客户端的 IO 状态就绪
public void clientListener() {
    while (true) {
        // 批量轮询是否有哪些连接有数据可读
        if (clientSelector.select(1) &amp;gt; 0) {
            Set&amp;lt;SelectionKey&amp;gt; set = clientSelector.selectedKeys();
            Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = set.iterator();
            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();
                                // 判断该通道是否读就绪状态
                if (key.isReadable()) {
                    try {
                        // 获取客户端通道读入数据
                        SocketChannel clientChannel = (SocketChannel) key.channel();
                        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                        clientChannel.read(byteBuffer);
                        byteBuffer.flip();
                        System.out.println(
                            LocalDateTime.now().toString() + &quot; Server 端接收到来自 Client 端的消息: &quot; +
                            Charset.defaultCharset().decode(byteBuffer).toString());
                    } finally {
                        // 从就绪的列表中移除这个key
                        keyIterator.remove();
                        key.interestOps(SelectionKey.OP_READ);
                    }
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在客户端，我们可以简单的输入一些文字，发送给服务器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NIOClient {
    
    public static final int CAPACITY = 1024;

    public static void main(String[] args) throws Exception {
        ByteBuffer dsts = ByteBuffer.allocate(CAPACITY);
        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 3333));
        socketChannel.configureBlocking(false);
        Scanner sc = new Scanner(System.in);
        while (true) {
            String msg = sc.next();
            dsts.put(msg.getBytes());
            dsts.flip();
            socketChannel.write(dsts);
            dsts.clear();
        }
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图可以看见，在客户端给服务器端发送信息，服务器接收到消息后，可以将该条消息&lt;strong&gt;分发给其它客户端&lt;/strong&gt;，就可以实现一个简单的&lt;strong&gt;群聊系统&lt;/strong&gt;，我们还可以给这些客户端贴上标签例如&lt;strong&gt;用户姓名，聊天等级······&lt;/strong&gt;，就可以标识每个客户端啦。在这里由于篇幅原因，我没有写出所有功能，因为使用原生的 NIO 实在是不太便捷。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.smallpineapple.top/20200906093418.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我相信你们都是直接滑下来看这里的，我在写这段代码的时候也非常痛苦，甚至有点厌烦 Java 原生的 NIO 编程。实际上我们在日常开发中很少直接用 NIO 进行编程，通常都会用 Netty，Mina 这种服务器框架，它们都是很好地 NIO 技术，对 Java 原生的 NIO 进行了上层的封装、优化，简化开发难度，但是&lt;strong&gt;在学习框架之前，我们需要了解它底层原生的技术，就像 Spring AOP 的动态代理，Spring IOC 容器的 Map 容器存储对象，Netty 底层的 NIO 基础······&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;NIO 的三大板块基本上都介绍完了，我没有做过多详细的 API 介绍，我希望能够通过这篇文章让你们对以下内容有所认知&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java IO 体系的组成部分：BIO 和 NIO&lt;/li&gt;
&lt;li&gt;BIO 的基本组成部分：字节流，字符流，转换流和处理流&lt;/li&gt;
&lt;li&gt;NIO 的三大重要模块：缓冲区（Buffer），通道（Channel），选择器（Selector）以及它们的作用&lt;/li&gt;
&lt;li&gt;NIO 与 BIO 两者的对比：同步/非同步、阻塞/非阻塞，在文件 IO 和 网络 IO 中，使用 NIO 相对于使用 BIO 有什么优势&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你好，我是 cxuan，我自己手写了四本 PDF，分别是 Java基础总结、HTTP 核心总结、计算机基础知识，操作系统核心总结，我已经整理成为 PDF，可以关注公众号 Java建设者 回复 PDF 领取优质资料。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202009/1515111-20200907082838049-2070267566.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Sep 2020 00:29:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>Java IO 是一个庞大的知识体系，很多人学着学着就会学懵了，包括我在内也是如此，所以本文将会从 Java 的 BIO 开始，一步一步深入学习，引出 JDK1.4 之后出现的 NIO 技术，对比 N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13624862.html</dc:identifier>
</item>
<item>
<title>akka-streams - 从应用角度学习：basic stream parts - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/13624832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/13624832.html</guid>
<description>&lt;p&gt;   &lt;span&gt;实际上很早就写了一系列关于akka-streams的博客。但那个时候纯粹是为了了解akka而去学习的，主要是从了解akka-streams的原理为出发点。因为akka-streams是akka系列工具的基础，如：akka-http, persistence-query等都是基于akka-streams的，其实没有真正把akka-streams用起来。这段时间所遇到的一些需求也是通过集合来解决的。不过，现在所处的环境还是逼迫着去真正了解akka-streams的应用场景。现状是这样的：跨入大数据时代，已经有大量的现代IT系统从传统关系数据库转到分布式数据库（非关系数据库）了。不难想象，这些应用的数据操作编程不说截然不同吧，肯定也会有巨大改变。特别是在传统SQL编程中依赖数据关系的join已经不复存在了，groupby、disctict等操作方法也不是所有的分布式数据库都能支持的。而这些操作在具体的数据呈现和数据处理中又是不可缺少的。当然，有很多需求可以通过集合来满足，但涉及到大数据处理我想最好还是通过流处理来实现，因为流处理stream-processing的其中一项特点就是能够在有限的内存空间里处理无限量的数据。所以流处理应该是分布式数据处理的理想方式了。这是这次写akka-streams的初衷：希望能通过akka-streams来实现分布式数据处理编程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先从基本流部件basic stream parts开始，即source,flow,sink。这几个部件可以组合成一个所谓线性流linear-stream。一个流对数据的处理包括两部分：1、对流中元素进行转变，如：source:Source[Int,NotUsed] = Source(1 to 10).map(i =&amp;gt; i.toString)，把流里的所有Int转变成String、2、对流内元素进行计算得出运算结果，如：sink: Sink[Int,Future[Int]] = Sink.fold(0)(_ + _)。当我们run这个sink后得出Future[Int]，如：res: Future[Int] = src.runWith(sink)。这两项对流元素的操作所产生的结果不同：元素转换得到动态流动的一串元素、运算元素得到一个静态值，这个运算值materialized-value只能在Sink里获取。即使有这样的表示方式：Source[Int,Future[Int]]，这是个迷惑，这个运算值只能通过自定义的graph才能得到，也就是说基本组件是没这个功能的。举个具体的例子吧：val source: Source[Int, Promise[Option[Int]]] = Source.maybe[Int] 这个表达式貌似可以在Source方获取运算值，再看看Source.maybe[Int]:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def maybe[T]: Source[T, Promise[Option[T]]] =&lt;span&gt;
    Source.fromGraph(MaybeSource.asInstanceOf[Graph[SourceShape[T], Promise[Option[T]]]])&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看出这个Source.maybe是从graph构建的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面这个例子里用一个Source对接一个Sink已经组成了一个完整的流，那么Flow是用来干什么的呢？由于运算值是无法当作流元素传递的，Flow只能是用来对Source传下来的元素进行转换后再传递给Sink，也就是说Flow是由一个或多个处理环节构成的。用Flow来分步实现功能是流处理实现并行运算的基本方式，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Source(&lt;span&gt;1&lt;/span&gt; to &lt;span&gt;10&lt;/span&gt;).&lt;span&gt;async&lt;/span&gt;.via(Flow[Int].map(i =&amp;gt; i + &lt;span&gt;1&lt;/span&gt;)).&lt;span&gt;async&lt;/span&gt;.runWith(sink)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用async把这个流分割成3个运算发送给3个actor去同时运算。乍看之下map好像是个Flow，它们的作用也似乎相同，也可以对接Source。如：Source(1 to 10).map(_ + 1)。但map和Flow还是有分别的，从类型款式来看Flow[In,Out,M]比起map[A,B]多出来了M，运算值。所以via(map(_.toString))无法匹配类型。那么对于定义带有预先处理环节的Sink就必须用Flow来实现了：ex_sink = Flow[Int].map(_ + 1).to(sink)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然运算值不能像流元素一样流动，但akka-streams提供了机制让用户选择是否返回某个节点的运算值M。系统默认只选择最最左边节点的M，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A source that can be signalled explicitly from the outside&lt;/span&gt;
val source: Source[Int, Promise[Option[Int]]] =&lt;span&gt; Source.maybe[Int]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A flow that internally throttles elements to 1/second, and returns a Cancellable
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; which can be used to shut down the stream&lt;/span&gt;
val flow: Flow[Int, Int, Cancellable] =&lt;span&gt; throttler

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A sink that returns the first element of a stream in the returned Future&lt;/span&gt;
val sink: Sink[Int, Future[Int]] =&lt;span&gt; Sink.head[Int]

val stream: RunnableGraph[(Cancellable, Future[Int])] &lt;/span&gt;=&lt;span&gt;
  source.viaMat(flow)(Keep.right).toMat(sink)(Keep.both)

val stream1: RunnableGraph[(Promise[Option[Int]], Cancellable, Future[Int])] &lt;/span&gt;=&lt;span&gt;
  source.viaMat(flow)(Keep.both).toMat(sink)(Keep.both)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运算值M可以通过viaMat,toMat选择，然后stream.run()获取。akka-streams提供了简便一点的运算方式runWith：指定runWith参数流组件的M为最终运算值。如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Using runWith will always give the materialized values of the stages added
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; by runWith() itself&lt;/span&gt;
val r4: Future[Int] =&lt;span&gt; source.via(flow).runWith(sink)
val r5: Promise[Option[Int]] &lt;/span&gt;=&lt;span&gt; flow.to(sink).runWith(source)
val r6: (Promise[Option[Int]], Future[Int]) &lt;/span&gt;= flow.runWith(source, sink)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;值得注意的是：我们可以分别从Source,Sink,Flow开始针对Source runWith(Sink), Sink runWith(Source)及Flow runWith (Source,Sink)。&lt;/span&gt;&lt;span&gt;用基础流组件Source,Flow,Sink构成的流是直线型的。也就是说从Source流出的元素会一个不漏的经过Flow进入Sink，不能多也不能少。可能Source.filter会产生疑惑，不过看看filter函数定义就明白了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def filter(p: Out =&amp;gt; Boolean): Repr[Out] =&lt;span&gt; via(Filter(p))

@InternalApi &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;[akka] final &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Filter[T](p: T =&amp;gt;&lt;span&gt; Boolean) extends SimpleLinearGraphStage[T] {
  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def initialAttributes: Attributes =&lt;span&gt; DefaultAttributes.filter

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def toString: String = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

  &lt;span&gt;override&lt;/span&gt; def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GraphStageLogic(shape) with OutHandler with InHandler {
      def decider &lt;/span&gt;=&lt;span&gt; inheritedAttributes.mandatoryAttribute[SupervisionStrategy].decider

      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; buffer: OptionVal[T] =&lt;span&gt; OptionVal.none

      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def preStart(): Unit = pull(&lt;span&gt;in&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onPush(): Unit =
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          val elem &lt;/span&gt;= grab(&lt;span&gt;in&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (p(elem))
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isAvailable(&lt;span&gt;out&lt;/span&gt;&lt;span&gt;)) {
              push(&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;, elem)
              pull(&lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt;)
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
              buffer &lt;/span&gt;=&lt;span&gt; OptionVal.Some(elem)
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; pull(&lt;span&gt;in&lt;/span&gt;&lt;span&gt;)
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; NonFatal(ex) =&amp;gt;&lt;span&gt;
            decider(ex) match {
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Supervision.Stop =&amp;gt;&lt;span&gt; failStage(ex)
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _                =&amp;gt; pull(&lt;span&gt;in&lt;/span&gt;&lt;span&gt;)
            }
        }

      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onPull(): Unit =&lt;span&gt;
        buffer match {
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; OptionVal.Some(value) =&amp;gt;&lt;span&gt;
            push(&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;, value)
            buffer &lt;/span&gt;=&lt;span&gt; OptionVal.none
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isClosed(&lt;span&gt;in&lt;/span&gt;)) pull(&lt;span&gt;in&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; completeStage()
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; already pulled&lt;/span&gt;
&lt;span&gt;        }

      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onUpstreamFinish(): Unit =
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (buffer.isEmpty) super.onUpstreamFinish()
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else onPull will complete&lt;/span&gt;
&lt;span&gt;
      setHandlers(&lt;/span&gt;&lt;span&gt;in&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;怎样？够复杂的了吧。很明显，复杂点的流处理需要根据上游元素内容来维护内部状态从而重新构建向下游发送元素的机制。如果想实现join,groupby,distict这些功能就必然对流动元素除转换之外还需要进行增减操作。这项需求可能还必须留在后面的sream-graph章节中讨论解决方案了。不过临时解决方法可以通过运算值M来实现。因为M可以是一个集合，在构建这个M集合时是可以对集合元素进行增减的，下面这段代码示范了一种cassandra数据表groupby的效果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; def getVouchers(terminalid: String, susp: Boolean)(&lt;span&gt;implicit&lt;/span&gt; classicSystem: ActorSystem) =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val session = CassandraSessionRegistry(classicSystem).sessionFor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alpakka.cassandra&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val ec =&lt;span&gt; classicSystem.dispatcher
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stmt = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from pos_on_cloud.txn_log where terminal = ? and txndate = ?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (susp) stmt = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from pos_on_cloud.txn_hold where terminal = ? and txndate = ?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    val source  &lt;/span&gt;= session.&lt;span&gt;select&lt;/span&gt;(stmt,terminalid,LocalDate.now.format(DateTimeFormatter.ofPattern(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyyMMdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
    val sink &lt;/span&gt;= Sink.fold[List[TxnItem],TxnItem](List[TxnItem]()){(acc,txn) =&amp;gt;
      &lt;span&gt;if&lt;/span&gt; (acc.isEmpty) txn.copy(price = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) :: acc
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (acc.head.num ==&lt;span&gt; txn.num) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txn.salestype == SALESTYPE.itm &amp;amp;&amp;amp;&lt;span&gt;
            txn.txntype &lt;/span&gt;==&lt;span&gt; TXNTYPE.sales) {
            val nacc &lt;/span&gt;=&lt;span&gt; acc.head.copy(
              price &lt;/span&gt;= acc.head.price + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
              qty &lt;/span&gt;= acc.head.qty +&lt;span&gt; txn.qty,
              amount &lt;/span&gt;= acc.head.amount +&lt;span&gt; txn.amount,
              dscamt &lt;/span&gt;= acc.head.dscamt +&lt;span&gt; txn.dscamt
            )
            nacc :: acc.drop(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; acc
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; txn :: acc
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
      vchs &lt;/span&gt;&amp;lt;-&lt;span&gt; source.map(TxnItem.fromCqlRow).toMat(sink)(Keep.right).run()
      _ &lt;/span&gt;&amp;lt;-&lt;span&gt; session.close(ec)
    } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; vchs
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然，基本流组件在流模式数据库读写方面还是比较高效的，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    def futTxns(items: Seq[TxnItem]): Future[Seq[TxnItem]] =&lt;span&gt; Source(items.toSeq)
      .via(
        CassandraFlow.create(CassandraWriteSettings.defaults,
          CQLScripts.insertTxns,
          statementBinder)
      )
      .runWith(Sink.seq)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Sep 2020 00:19:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<og:description>实际上很早就写了一系列关于akka-streams的博客。但那个时候纯粹是为了了解akka而去学习的，主要是从了解akka-streams的原理为出发点。因为akka-streams是akka系列工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tiger-xc/p/13624832.html</dc:identifier>
</item>
<item>
<title>一个后端开发的 Vue 笔记【入门级】 - BWH_Steven</title>
<link>http://www.cnblogs.com/ideal-20/p/13624713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ideal-20/p/13624713.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3f5fd2b292b4aba8da617bfaf147390~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近找了些教程，顺带着趴在官网上，看了看 Vue 的一些内容，入门的一些概念，以及基础语法，还有一些常用的操作，瞄了一眼，通篇文字+贴了部分代码 9000 多字，入门语法什么的还是很好理解的，以前也有一定做小程序的基础，感觉还是很相似的，不过对于一些稍复杂的点，感觉还是总结的不够细致，例如插槽，和计算属性等，平时前端的东西看的也不是很多，学习过程中整理的笔记，和大家一起分享交流！欢迎各位大大交流意见~&lt;/p&gt;

&lt;h2 id=&quot;一-vue-概念理解&quot;&gt;(一) Vue 概念理解&lt;/h2&gt;
&lt;h3 id=&quot;1-vuejs-是什么&quot;&gt;(1) Vue.js 是什么&lt;/h3&gt;
&lt;p&gt;Vue (读音 /vjuː/，类似于 &lt;strong&gt;view&lt;/strong&gt;) 是一套用于构建用户界面的&lt;strong&gt;渐进式框架&lt;/strong&gt;。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。&lt;/p&gt;
&lt;h3 id=&quot;2-渐进式框架是什么&quot;&gt;(2) 渐进式框架是什么&lt;/h3&gt;
&lt;p&gt;看了一些教程以及文章，简单理解的渐进式框架就三个字&lt;strong&gt;【不强求】&lt;/strong&gt;，Vue并不强求你用它的所有内容（功能特性），用户完全可以根据自己情况进行选择，使用其部分即可。&lt;/p&gt;
&lt;p&gt;这一块某乎上有一个比较好的答案，很容易度娘到，贴了部分&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;vue即主张较少，也就是说可以在原有系统上面，引入vue直接就可以当jquery用，使用 vue，你可以在原有大系统的上面，把一两个组件改用它实现，当 jQuery 用；也可以整个用它全家桶开发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二-mvvm-架构&quot;&gt;(二) MVVM 架构&lt;/h2&gt;
&lt;p&gt;正式学习 Vue 前我们首先还需要了解一个基于前端的架构模式，也就是 MVVM ，它是 Model-View-ViewMode 的简写，其关系简单的描述为下图：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff58572d768a495d9d1e2fc081a37a8e~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Model（模型层）：表示 Javascript 数据对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;View（视图层）：表示 DOM，也可以简单理解为前端展示的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ViewModel：连接视图和数据，即用于双向绑定数据与页面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 MVVM 架构中，视图和数据是没有办法直接进行沟通的，只能通过 ViewModel 来做一个中间关系，&lt;strong&gt;ViewModel 可以观察到数据的变化，然后更新视图内容，亦或者监听到视图的变化，并能通知数据发生改变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后面我马上会写一个入门的小案例，可以一起来体会一下它的特点！&lt;/p&gt;
&lt;h2 id=&quot;三-vue-的优点&quot;&gt;(三) Vue 的优点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、体积小&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;压缩后33K&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、更高的运行效率&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于虚拟dom一种可以预先通过 javascript 进行各种计算,把最终的 DOM操作计算出来并优化的技术，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以 叫做虚拟DOM。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3、双向数据绑定&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让开发者不用再去操作 dom 对象，把更多的精力投入到业务逻辑上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4、生态丰富、学习成本低&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;市场上拥有大量成熟、稳定的基于 vue.js 的 ui 框架、常用组件！&lt;/li&gt;
&lt;li&gt;拿来即用实现快速开发&lt;/li&gt;
&lt;li&gt;对初学者友好、入门容易、学习资料多&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四-入门案例&quot;&gt;(四) 入门案例&lt;/h2&gt;
&lt;p&gt;编写 Vue 你可以选择使用 Vscode 、 HBuilder 、sublime、Webstrom、甚至 IDEA 都是可以的，自行选择就好了&lt;/p&gt;
&lt;p&gt;首先我们需要引入 Vue，你可以去官网直接 down 下文件，进行一个本地的引入，类似引入 jQuery，或者使用一个网络的引用，例如下文中，在官网中就可以找到这种引入或下载的地址&lt;/p&gt;
&lt;p&gt;可以看到，引入后，我们通过 new 的这种形式创建了一个 Vue 的实例，其中通过 el 找到 id 值为 hello 的 div 进行绑定，在 data 中进行一个赋值，而在div 中 通过两组大括号来对数据进行回显&lt;/p&gt;
&lt;p&gt;如果你有一些微信小程序的基础的话，其实可以发现，这两者结构看起来似乎有一些相似的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;hello&quot;&amp;gt;
  &amp;lt;h2&amp;gt;{{content}}&amp;lt;/h2&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  var vm = new Vue({
      el: &quot;#hello&quot;,
      data:{
        content: &quot;Hello Vue!&quot;
      }
  })
&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回显数据肯定是没问题的，我们试着在控制台修改 content 的值，可以看到随之页面也就发生改变了&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed46d479b696471d84958846f0ceaf19~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是&lt;strong&gt;响应式的&lt;/strong&gt;。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 &lt;code&gt;app.message&lt;/code&gt; 的值，你将看到上例相应地更新。&lt;/p&gt;
&lt;p&gt;注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 &lt;code&gt;#app&lt;/code&gt;) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。—— Vue 官网&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一-声明式渲染&quot;&gt;(一) 声明式渲染&lt;/h2&gt;
&lt;p&gt;如果有接触过 Thymeleaf 这样的模板，你可以看出来，上面的 Vue 案例就是采用了一个简洁模板语法，即两组大括号包裹值，来声明式声明式地将数据渲染进 DOM 的系统，这其实和 Thymeleaf 中的 $ 加一组大括号 是相似的&lt;/p&gt;
&lt;p&gt;我们还有一种绑定元素的方式：即使用指令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-2&quot;&amp;gt;
  &amp;lt;span v-bind:title=&quot;content&quot;&amp;gt;
    鼠标悬停几秒钟查看此处动态绑定的提示信息！
  &amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  var vm = new Vue({
      el: &quot;#hello-2&quot;,
      data:{
        content: '页面加载于 ' + new Date().toLocaleString()
      }
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察结果，我们将鼠标悬停在文字上方，被绑定的数据就会出现&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e60ad44161044869e1374e750c2ec28~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;你看到的 &lt;code&gt;v-bind&lt;/code&gt; attribute 被称为&lt;strong&gt;指令&lt;/strong&gt;。指令带有前缀 &lt;code&gt;v-&lt;/code&gt;，以表示它们是 Vue 提供的特殊 attribute，代码的意思就是将这个元素节点的 &lt;code&gt;title&lt;/code&gt; attribute 和 Vue 实例的 &lt;code&gt;content&lt;/code&gt; property 保持一致”&lt;/p&gt;
&lt;p&gt;如果你在控制台进行修改 vm.content 的值，绑定的数据依旧会发生变化&lt;/p&gt;
&lt;p&gt;注：使用 v-bind 需要头部引入一个约束&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用 IDEA 安装 Vue.js 插件 会有提示补全&lt;/p&gt;
&lt;h2 id=&quot;二-条件判断&quot;&gt;(二) 条件判断&lt;/h2&gt;
&lt;p&gt;条件判断使用的指令就是 &lt;code&gt;v-if&lt;/code&gt; 、&lt;code&gt;v-else-if&lt;/code&gt;、&lt;code&gt;v-else&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;来看两个例子，首先是对于 true 或者 false 的判断&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-3&quot;&amp;gt;
  &amp;lt;h2 v-if=&quot;isBoy&quot;&amp;gt;是男孩&amp;lt;/h2&amp;gt;
  &amp;lt;h2 v-else&amp;gt;是女孩&amp;lt;/h2&amp;gt;

&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  var vm = new Vue({
      el: &quot;#hello-3&quot;,
      data:{
        isBoy: true
      }
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认显示是男孩，我们接着在控制台修改为false&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afc597d918db4c8196776149b933d70e~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;接着是对于值的判断，我们拿一个比较成绩的小例子，不过对数值的约束还是不够严谨的，仅仅为了讲解 if 这个例子，明白意思就行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-3&quot;&amp;gt;
  &amp;lt;h2 v-if=&quot;score &amp;lt; '60'&quot;&amp;gt;成绩不及格&amp;lt;/h2&amp;gt;
  &amp;lt;h2 v-else-if=&quot;score &amp;gt;= '60' &amp;amp;&amp;amp; score &amp;lt; '80'&quot;&amp;gt;成绩及格&amp;lt;/h2&amp;gt;
  &amp;lt;h2 v-else&amp;gt;成绩优秀&amp;lt;/h2&amp;gt;

&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  var vm = new Vue({
      el: &quot;#hello-3&quot;,
      data:{
          score: 66
      }
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在结果中继续修改看看&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9cf6dbb39864e72aa5d0fa6f80b7abd~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;三-循环&quot;&gt;(三) 循环&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;v-for&lt;/code&gt; 就可以进行循环遍历，真例如 java 中的 增强for 只不过是把 冒号 换成了 in，students 对应 data 中的数组名，student 代表其中的每一项，通过 XXX.xx 的形式取出具体的属性值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-4&quot;&amp;gt;
  &amp;lt;li v-for=&quot;student in students&quot;&amp;gt;
    {{student.name}}
  &amp;lt;/li&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var vm = new Vue({
        el: &quot;#hello-4&quot;,
        data: {
            students: [{name: '张三'}, {name: '李四'}, {name: '王五'}]
        }
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试着在控制台 push 一个新的，同样会更新出来&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d71e93f1bd341ab99bb38e0ecf209a3~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;说明：这里演示的只是最基本的一种情况，很多时候，若遍历的数组中为对象，且对象有多个值，例如含有 id 这样的值，一般会将这种唯一的 id 值作为 key 值，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&amp;gt;
  &amp;lt;!-- 内容 --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 &lt;code&gt;key&lt;/code&gt; attribute：&lt;/p&gt;
&lt;p&gt;建议尽可能在使用 &lt;code&gt;v-for&lt;/code&gt; 时提供 &lt;code&gt;key&lt;/code&gt; attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四-事件绑定&quot;&gt;(四) 事件绑定&lt;/h2&gt;
&lt;p&gt;经常我们需要通过点击一些按钮或者标签组件等，使得用户可以与应用进行交互，也就是进行事件绑定，在 Vue 中我们可以通过 &lt;code&gt;v-on&lt;/code&gt; 指令添加一个事件监听器来进行&lt;/p&gt;
&lt;p&gt;注：使用 v-on 引入约束&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-5&quot;&amp;gt;
  &amp;lt;button v-on:click=&quot;helloWorld&quot;&amp;gt;你好世界&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var vm = new Vue({
        el: &quot;#hello-5&quot;,
        data: {
            content: &quot;Hello World ！&quot;
        },
        methods: {
            helloWorld: function () {
                alert(this.content);
            }
        }
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，通过 &lt;code&gt;v-on:click&lt;/code&gt; 就将 helloWorld 这个事件绑定了，而事件的具体逻辑需要定义在 Vue 对象的 methods 中&lt;/p&gt;
&lt;h2 id=&quot;五-双向绑定&quot;&gt;(五) 双向绑定&lt;/h2&gt;
&lt;p&gt;早在开篇介绍 MVVM 架构模式的时候，图中就提到了 View 和 ViewModel 之间的双向绑定，通俗的说就是&lt;strong&gt;：当数据发生变化时，视图也变化，而当视图发生变化的时候，数据也跟着变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实在前面的基本语法中，我们已经能很明显的体会到了前半句，即修改 data 中的数据，从而引起视图中的变化，我们这里就重点提一下后半句&lt;/p&gt;
&lt;p&gt;首先，Vue 提供了 &lt;code&gt;v-model&lt;/code&gt; 指令，它能轻松实现表单输入和应用状态之间的双向绑定&lt;/p&gt;
&lt;p&gt;从常见的表单中的几种形式来讲，我们可以使用 &lt;code&gt;v-model&lt;/code&gt; 指令在表单的 &lt;code&gt;input&lt;/code&gt; 、&lt;code&gt;textarea&amp;gt;&lt;/code&gt;、&lt;code&gt;select&lt;/code&gt; 等上进行数据的双向绑定，它可以根据控件类型选取正确的方法来更新元素&lt;/p&gt;
&lt;p&gt;不过使用 &lt;code&gt;v-model&lt;/code&gt; 指令后会忽略表单原先的 value、checked、selected 等的初始值，而总将 Vue 实例中的数据最为数据源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;input 中 ，输入文本&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-6&quot;&amp;gt;
  输入: &amp;lt;input type=&quot;text&quot; v-model=&quot;content&quot; &amp;gt; 输出: {{content}}
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var vm = new Vue({
        el: &quot;#hello-6&quot;,
        data: {
            content: &quot;Hello World ！&quot;
        },
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在输出的位置使用两组大括号进行 content 这个值的回显我们之前就已经能做到了，而我们在 input 的属性中使用 v-model 进行对于 content 的绑定，这样就可以使得输入框中输入的值可以直接影响 data 中 content 的值，即随着你 input 中输入值的修改，随之输出位置的内容也会变化&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f5526d095b6468484a4fc3a46442b04~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;input 中 ，单选框&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-6&quot;&amp;gt;
  性别:
  &amp;lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; v-model=&quot;gender&quot;&amp;gt;男
  &amp;lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; v-model=&quot;gender&quot;&amp;gt;女
  输出: {{gender}}
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var vm = new Vue({
        el: &quot;#hello-6&quot;,
        data: {
            gender: '男'
        },
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果显示&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e54201e1c89e402ea0adecd02d2f95c3~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;select 中&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-6&quot;&amp;gt;
  &amp;lt;select v-model=&quot;choose&quot;&amp;gt;
    &amp;lt;option value=&quot;&quot; disabled&amp;gt;---请选择---&amp;lt;/option&amp;gt;
    &amp;lt;option&amp;gt;A-苹果&amp;lt;/option&amp;gt;
    &amp;lt;option&amp;gt;B-樱桃&amp;lt;/option&amp;gt;
    &amp;lt;option&amp;gt;C-西瓜&amp;lt;/option&amp;gt;
  &amp;lt;/select&amp;gt;
  输出: {{choose}}
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var vm = new Vue({
        el: &quot;#hello-6&quot;,
        data: {
            choose: ''
        },
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c37ebcdc99f445eb3ab1f1ae0641d4e~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;六-vue组件&quot;&gt;(六) Vue组件&lt;/h2&gt;
&lt;p&gt;Vue 中组件也是一个很重要的概念，例如一个页面中，头部、底部、侧边栏、主内容区 都可以看做一个一个组件，不过有一些组件是固定的，例如头部，还有一些是变换的例如内容区&lt;/p&gt;
&lt;p&gt;Vue 中就允许我们使用小型、独立和通常可复用的组件构建大型应用&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27827193d49443a5b9bf48a613e0da7f~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;注：实际都是创建 .vue 模板文件，并不会用直接在页面中书写的这种形式，仅为讲解方便&lt;/p&gt;
&lt;p&gt;直接拿一个简单，不过还算相对完善的案例来进行讲解‘&lt;/p&gt;
&lt;p&gt;先说一下最终我们想干嘛，例如 div 或者 input 等等 都是一个一个标签，我们现在向做的就是通过创建自定义组件模板，自定义出一个这样的标签，我们在需要的地方只需要引用这个标签，我们就可以达到显示出模板中想要的效果，达到抽取复用的效果&lt;/p&gt;
&lt;p&gt;首先使用 Vue.component....... 这样的格式创建组件，在其中 ideal-20 就是组件标签的名字， template 就代表模板中的内容，props 代表我们在引用处传入的参数名&lt;/p&gt;
&lt;p&gt;接着在一个已经绑定好的 hello-7 的 div 中引入自定义组件标签 ideal-20，而我们想要遍历 data 中的 fruits 数组，在 ideal-20 属性中进行 for 遍历即可，同时我们需要将每一项通过 &lt;code&gt;v-bind:ideal=&quot;item&quot;&lt;/code&gt; 绑定参数到组件模板中，因为数组不是一个普通的数组，所以赋 id 为 key值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-7&quot;&amp;gt;
  &amp;lt;ideal-20 v-for=&quot;item in fruits&quot; v-bind:ideal=&quot;item&quot; v-bind:key=&quot;item.id&quot;&amp;gt;&amp;lt;/ideal-20&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
    // 定义名为 todo-item 的新组件
    Vue.component('ideal-20', {
        props: ['ideal'],
        template: '&amp;lt;li&amp;gt;{{ideal.name}}&amp;lt;/li&amp;gt;'
    })
    var vm = new Vue({
        el: &quot;#hello-7&quot;,
        data: {
            fruits: [
                {id: 0, name: '苹果'},
                {id: 1, name: '樱桃'},
                {id: 2, name: '山竹'}
            ]
        }
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果展示&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e74a0c8a6b74289b33c3b59e1fe725a~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;七-axios-入门&quot;&gt;(七) Axios 入门&lt;/h2&gt;
&lt;p&gt;首先我们需要提一下，为什么要用这个东西呢？&lt;/p&gt;
&lt;p&gt;我们在以前传统的开发中，我们一般会使用 Ajax 进行通信，而 Vue,js 作为一个视图层框架，并不支持 Ajax 的通信功能，所以可以使用 Axios 来实现 Ajax 的异步通信&lt;/p&gt;
&lt;p&gt;首先看一下它的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从浏览器中创建 XMLHttpRequests&lt;/li&gt;
&lt;li&gt;从 node.js 创建 http 请求&lt;/li&gt;
&lt;li&gt;支持 Promise API&lt;/li&gt;
&lt;li&gt;拦截请求和响应&lt;/li&gt;
&lt;li&gt;转换请求数据和响应数据&lt;/li&gt;
&lt;li&gt;取消请求&lt;/li&gt;
&lt;li&gt;自动转换 JSON 数据&lt;/li&gt;
&lt;li&gt;客户端支持防御 XSRF&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先我们拿一段 json 来模拟数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;BWH_Steven&quot;,
  &quot;blog&quot;: &quot;www.ideal-20.cn&quot;,
  &quot;about&quot;: {
    &quot;country&quot;: &quot;中国&quot;,
    &quot;phone&quot;: &quot;13888888888&quot;
  },
  &quot;students&quot;: [
    {
      &quot;id&quot;: 0,
      &quot;name&quot;: &quot;张三&quot;
    },
    {
      &quot;id&quot;: 1,
      &quot;name&quot;: &quot;李四&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;王五&quot;
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过下图我们就可以知道 我们可以将代码写到 mounted() 中去&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce2cdb426afc43d1b203f1f7b15e5645~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;接着就是使用的代码了&lt;/p&gt;
&lt;p&gt;首先除了引入 Vue 还需要引入 Axios 的 CDN，在 mounted() 方法中，去拿到这个json文件，同时将 response.data 也就是拿到的值，赋值给我们在 data() 中定义的 info 中&lt;/p&gt;
&lt;p&gt;注意：data 和 data() 是不一样的&lt;/p&gt;
&lt;p&gt;接着在绑定好的 hello-8 div 中就可以调用回显了&lt;/p&gt;
&lt;p&gt;说明：为什么给 v-clock 添加了一个样式呢，这是因为，显示数据的过程是先显示出&lt;code&gt;{{info.name}}&lt;/code&gt; 这样的字样，拿到值后，再去渲染，如果网速慢的情况下可以看到 info.name 的，体验不是很好&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    [v-clock] {
      display: none;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;hello-8&quot; v-clock&amp;gt;
  &amp;lt;div&amp;gt;{{info.name}}&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;{{info.blog}}&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;{{info.about.country}}&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;{{info.about.phone}}&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;{{info.students[0].name}}&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;

    var vm = new Vue({
        el: &quot;#hello-8&quot;,
        data() {
            return {
                info: {}
            }
        },
        mounted() {
            axios.get(&quot;../json/data.json&quot;).then(response =&amp;gt; (this.info = response.data));
        }
    })
&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;八-计算属性&quot;&gt;(八) 计算属性&lt;/h2&gt;
&lt;p&gt;这一段，我认为官方文档说的还是比较清楚的&lt;/p&gt;
&lt;p&gt;模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;example&quot;&amp;gt;
  {{ message.split('').reverse().join('') }}
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 &lt;code&gt;message&lt;/code&gt; 的翻转字符串。当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理。&lt;/p&gt;
&lt;p&gt;所以，对于任何复杂逻辑，你都应当使用&lt;strong&gt;计算属性&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-9&quot;&amp;gt;
  &amp;lt;p&amp;gt;原始数据: &quot;{{ message }}&quot;&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;翻转数据: &quot;{{ reversedMessage }}&quot;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;


&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
    var vm = new Vue({
        el: '#hello-9',
        data: {
            message: 'Hello'
        },
        computed: {
            // 计算属性的 getter
            reversedMessage: function () {
                // `this` 指向 vm 实例
                return this.message.split('').reverse().join('')
            }
        }
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;原始数据: &quot;Hello&quot;&lt;/p&gt;
&lt;p&gt;翻转数据: &quot;olleH&quot;&lt;/p&gt;
&lt;p&gt;这里我们声明了一个计算属性 &lt;code&gt;reversedMessage&lt;/code&gt;。我们提供的函数将用作 property &lt;code&gt;vm.reversedMessage&lt;/code&gt; 的 getter 函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;console.log(vm.reversedMessage) // =&amp;gt; 'olleH'
vm.message = 'Goodbye'
console.log(vm.reversedMessage) // =&amp;gt; 'eybdooG'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以打开浏览器的控制台，自行修改例子中的 vm。&lt;code&gt;vm.reversedMessage&lt;/code&gt; 的值始终取决于 &lt;code&gt;vm.message&lt;/code&gt; 的值。&lt;/p&gt;
&lt;p&gt;你可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 依赖于 &lt;code&gt;vm.message&lt;/code&gt;，因此当 &lt;code&gt;vm.message&lt;/code&gt; 发生改变时，所有依赖 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算属性和方法的区别 ？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到这里，你会不会觉得，貌似我用方法也可以实现这种效果啊，将具体的业务逻辑放在定义的方法中，但是他们最大的区别是&lt;strong&gt;计算属性是基于它们的响应式依赖进行缓存的&lt;/strong&gt;，也就是说，我们上文中所依赖的 message 不发生改变，reversedMessage 会马上获取之前的结果，就不用再次执行函数了，计算属性可以帮我们节省大量的性能开销，不过如果我们并不希望出现缓存内容，就可以使用方法来代替它&lt;/p&gt;
&lt;h2 id=&quot;九-插槽-slot&quot;&gt;(九) 插槽 Slot&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的 attribute。新语法的由来可查阅这份 RFC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这块写的太浅了，不看也罢&lt;/p&gt;
&lt;p&gt;插槽就是子组件给父组件一个占位符即 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; 父组件就能在这个占位符，填一些模板或者 HTML 代码&lt;/p&gt;
&lt;p&gt;简单点理解就是组件套组件&lt;/p&gt;
&lt;p&gt;就像下面我定义了三个组件，ideal是父组件，在其中用 slot 进行占位，同时用 name 属性指向到了这两个子组件 ideal-title 和 ideal-content，而为了子组件中显示的数据来自服务器（模拟）所以需要动态地显示，即通过传参（前面讲解组件模板有说过），配合遍历等读出 data 中的数据即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;hello-10&quot;&amp;gt;
  &amp;lt;ideal&amp;gt;
    &amp;lt;ideal-title slot=&quot;ideal-title&quot; v-bind:title=&quot;title&quot;&amp;gt;&amp;lt;/ideal-title&amp;gt;
    &amp;lt;ideal-content slot=&quot;ideal-content&quot; v-for=&quot;contentItem in contents&quot; v-bind:content=&quot;contentItem&quot;&amp;gt;&amp;lt;/ideal-content&amp;gt;
  &amp;lt;/ideal&amp;gt;
&amp;lt;/div&amp;gt;


&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
    Vue.component(&quot;ideal&quot;, {
        template: '&amp;lt;div&amp;gt;\
                    &amp;lt;slot name=&quot;ideal-title&quot;&amp;gt;&amp;lt;/slot&amp;gt;\
                      &amp;lt;ul&amp;gt;\
                        &amp;lt;slot name=&quot;ideal-content&quot;&amp;gt;&amp;lt;/slot&amp;gt;\
                      &amp;lt;/ul&amp;gt;\
                   &amp;lt;/div&amp;gt;'
    })
    
    Vue.component(&quot;ideal-title&quot;, {
        props: ['title'],
        template: '&amp;lt;div&amp;gt;{{title}}&amp;lt;/div&amp;gt;'
    })
    
    Vue.component(&quot;ideal-content&quot;, {
        props: ['content'],
        template: '&amp;lt;li&amp;gt;{{content}}&amp;lt;/li&amp;gt;'
    })

    var vm = new Vue({
        el: '#hello-10',
        data: {
            title: &quot;理想二旬不止&quot;,
            contents: [&quot;Java&quot;, &quot;Linux&quot;, &quot;数据库&quot;]
        }
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87f2bc1b73a64a97b12bdb73d9c0d33c~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;

&lt;h2 id=&quot;一-创建-vue-cli-项目&quot;&gt;(一) 创建 Vue-cli 项目&lt;/h2&gt;
&lt;p&gt;Vue-cli 是官方提供的一个用于快速创建 Vue 项目的脚手架，可以简单的理解为 Maven ，即创建时选择一个骨架那种感觉，能让开发更加便捷&lt;/p&gt;
&lt;h3 id=&quot;1-准备&quot;&gt;(1) 准备&lt;/h3&gt;
&lt;h4 id=&quot;a：安装-nodejs&quot;&gt;A：安装 Node.js&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Node.js 去官网或者中文网进行下载&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;cmd 下输入 &lt;code&gt;node -v&lt;/code&gt; ，出现版本号即正常，输入 &lt;code&gt;npm -v&lt;/code&gt; 同样出现版本号即正常&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将 Node.js 的镜像调整为淘宝镜像加速（cnpm）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# -g 代表全局安全 推荐此方法
npm install cnpm -g

# 还有一种办法就是每次使用 npm 都在后面加一串字符串，不推荐
npm install --registry=https://registry.npm.tabao.org
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后打开此路径（abc是我这台机器的用户名，根据自己的来）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C:\Users\abc\AppData\Roaming\npm\node_modules&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;正常情况下里面会有安装好的 cnpm，接着我们就开始安装 vue-cli&lt;/p&gt;
&lt;h4 id=&quot;b：安装-vue-cli&quot;&gt;B：安装 vue-cli&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cnpm install vue-cli -g
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后在 npm 文件夹下打开 cmd 输入 &lt;code&gt;vue-list&lt;/code&gt; ，若出现下图这种星状内容，则完毕&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceee985fd03a42aeaf2ab8550fd60025~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;c：创建-vue-cli-程序&quot;&gt;C：创建 vue-cli 程序&lt;/h3&gt;
&lt;p&gt;自己在想要的位置创建一个目录，选择基于 webpack 的 vue 应用程序&lt;/p&gt;
&lt;p&gt;此文件夹下的 cmd 中输入命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vue init webpack vue_02_myvue
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入一些基本信息，例如 项目名 作者名&lt;/p&gt;
&lt;p&gt;下面的内容如果有选项的回车配合 n（也就是no）进行&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1cc15331f5440ab9978757c455df02d~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这时，它会询问你是否自动执行 npm install（如下），是的话则会自动安装一些依赖，点击否，需要自行再输入命令安装，所以选择是就行了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Should we run npm install for you after the project has been created? (recommended) npm
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成之后，项目中的 node_modules 就会多出很多很多依赖&lt;/p&gt;
&lt;p&gt;再接着，它又会提醒初始化好了，你如果想启动就可以执行这两条，第一句是从外面的文件夹进入到我自定义的那个项目文件夹中，第二句则是启动&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0e9e5acda774e54bfe16e2664a22d87~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;出现如果所示内容则启动成功，通过后面的地址和端口就可以访问&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90d3a36581de4a80b45cd8ff98dc4abe~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;找个编辑器看一下，我用 IDEA Open进这个文件夹来，就可以进行修改了，具体的代码文件还是在 src 目录下，同时还可以配置 IDEA 的 Terminal 为有管理员权限的 cmd 或者终端，能更便捷一些&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何快速创建项目&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以通过 HBuilder 进行相对快速的创建项目，其新建中直接就可以创建 vue 项目 以及终端运行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在想创建项目的目录下终端输入 vue ui 进入图形界面（此方法需要 vue-cli 版本为 3.x ，通过 vue --version 查询到 vue-cli 的版本 例如为 2.9.6 是不能使用的，可用的命令可以通过 vue -h 查看 ）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二-简单认识-webpack&quot;&gt;(二) 简单认识 Webpack&lt;/h2&gt;
&lt;h3 id=&quot;1-认识安装&quot;&gt;(1) 认识安装&lt;/h3&gt;
&lt;p&gt;盖菜我们创建 vue 项目的时候，选择的是 webpack 进行打包，但是都是自动化的过程，我们手动的操作一下，能更好的理解&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;webpack是一个现代 Javascript应用程序的静态模块打包器( module bundler)。当webpack处理应用程序时,它会递归地构建一个依赖关系 Dependency graph),其中包含应用程序需要的毎个模块,然后将所有这些模块打包成一个或多个 bundle&lt;br/&gt;webρack是当下最热门的前端资源模块化管理和打包工具,它可以将许多松散耦合的模块按照&lt;br/&gt;依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离,等到实际&lt;br/&gt;需要时再异步加载。通过 loader转换,任何形式的资源都可以当做模块,比如 Commonis、AMD、ES6、CSS、JSON、 Coffee Script、LESS等;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装 webpack、webpack-cli ，如果 npm 不太慢先考虑使用 npm 再考虑使用 cnpm&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cnpm install webpack -g

cnpm install webpack-cli -g
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;webpack -v&lt;/code&gt; 、&lt;code&gt;webpack-cli -v&lt;/code&gt; 查看是否出现版本号确定安装是否成功&lt;/p&gt;
&lt;h3 id=&quot;2-使用-webpack&quot;&gt;(2) 使用 webpack&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建项目（IDEA 的话，直接创建一个普通文件夹 Open进入就行了）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新建一个 modules 目录，放置 JS 模块等内容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 modules 下创建模块文件，例如 demo.js 用于编写 Js 模块相关代码，例如&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;exports.test = function () {
    document.write(&quot;&amp;lt;h2&amp;gt;理想二旬不止&amp;lt;/h2&amp;gt;&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在 moduels 下创建 main.js ，这是一个入口文件，用于打包时设置 entry 属性对应&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var demo = require(&quot;./demo&quot;)
demo.test();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在项目根目录下创建 webpack.config.js 文件，用于配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;module.exports = {
    entry: &quot;./modules/main.js&quot;,
    output: {
        filename: &quot;./js/bundle.js&quot;
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在 terminal 中输入 webpack 命令进行打包（进入项目目录后 输入 webpack 就行了，这是运行结果）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;abc@LAPTOP-5T03DV1G MINGW64 /f/develop/IdeaProjects/framework-code/vue/webpack_01_first
$ webpack
Hash: 7f61ef9440a6bab63058
Version: webpack 4.44.1
Time: 334ms
Built at: 2020-09-05 4:18:40 PM
         Asset        Size  Chunks             Chunk Names
./js/bundle.js  1020 bytes       0  [emitted]  main
Entrypoint main = ./js/bundle.js
[0] ./modules/main.js 42 bytes {0} [built]
[1] ./modules/demo.js 82 bytes {0} [built]

WARNING in configuration
The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each e
nvironment.
You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;打包后项目目录多出 dist 文件夹 其中有一个 js 文件夹，放着打包的 js，创建index.html 引入此 js&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;script src=&quot;dist/js/bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;页面效果如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86f8b38017694211a5c59199d631c3fe~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;补充：配置文件中可能会有哪些内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;entry：入口文件,指定 Web Pack用哪个文件作为项目的入口&lt;/li&gt;
&lt;li&gt;output：输出,指定 Web pack把处理完成的文件放置到指定路径&lt;/li&gt;
&lt;li&gt;module：模块,用于处理各种类型的文件plugins:插件,如:热更新、代码重用等&lt;/li&gt;
&lt;li&gt;resolve：设置路径指向&lt;/li&gt;
&lt;li&gt;watch：监听,用于设置文件改动后直接打包&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三-简单认识-vue-router-路由&quot;&gt;(三) 简单认识 Vue Router 路由&lt;/h2&gt;
&lt;p&gt;Vue Router是 Vue.js 的官方路由器。它与 Vue.js 核心深度集成，使使用 Vue.js 轻松构建单页应用程序变得轻而易举。功能包括：&lt;/p&gt;
&lt;p&gt;简单的说，可以实现一些页面的跳转，例如我们头部的内容是不变的，内容部分需要根据链接改变&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;嵌套路线/视图映射&lt;/li&gt;
&lt;li&gt;模块化，基于组件的路由器配置&lt;/li&gt;
&lt;li&gt;路由参数，查询，通配符&lt;/li&gt;
&lt;li&gt;查看由Vue.js过渡系统提供动力的过渡效果&lt;/li&gt;
&lt;li&gt;细粒度的导航控制&lt;/li&gt;
&lt;li&gt;与自动活动CSS类的链接&lt;/li&gt;
&lt;li&gt;HTML5历史记录模式或哈希模式，在IE9中具有自动回退&lt;/li&gt;
&lt;li&gt;可自定义的滚动行为&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;安装步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 vue-router 是一个插件包，还是老办法，npm/cnpm&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;npm install vue-router --save-dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后如果有一些问题，根据提示，输入对应命令即可，就像我遇到了提示输入 &lt;code&gt;npm audit fix&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建好项目后，删掉默认的 HelloWorld那个组件，然后再 components 中新建两个自定义组件，例如我创建的 FirstDemo.vue 和 Main.vue 前者是一个子页面，后者代表主页面，随便自拟&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FirstDemo.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;h1&amp;gt;第一个Demo页面&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    name: &quot;FirstDemo.vue&quot;
  }
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;

&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Main.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;h1&amp;gt;首页&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    name: &quot;Main.vue&quot;
  }
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着创建 router 文件夹，以及其中的 index.js 主配置&lt;/p&gt;
&lt;p&gt;注：如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import Vue from 'vue'
import VueRouter from 'vue-router'
import FirstDemo from '../components/FirstDemo'
import Main from '../components/Main'

Vue.use(VueRouter);

export default new VueRouter({
  routes: [
    {
      // 路由路径
      path: &quot;/firstDemo&quot;,
      name: 'firstDemo',
      // 跳转的组件
      component: FirstDemo
    },
    {
      // 路由路径
      path: &quot;/main&quot;,
      name: 'main',
      // 跳转的组件
      component: Main
    }
  ]
})

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 main.js 这个入口文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from 'vue'
import App from './App'
import router from './router'

Vue.config.productionTip = false

Vue.use(router);

/* eslint-disable no-new */
new Vue({
  el: '#app',
  //配置路由
  router,
  components: {App},
  template: '&amp;lt;App/&amp;gt;'
})

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及正式的书写页面，引入链接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;h1&amp;gt;理想二旬不止&amp;lt;/h1&amp;gt;
    &amp;lt;router-link to=&quot;/main&quot;&amp;gt;首页&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/firstDemo&quot;&amp;gt;第一个Demo页面&amp;lt;/router-link&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

  export default {
    name: 'App',
  }
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
  #app {
    font-family: 'Avenir', Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-align: center;
    color: #2c3e50;
    margin-top: 60px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四-vue--elementui-基本使用&quot;&gt;(四) Vue + ElementUi 基本使用&lt;/h2&gt;
&lt;p&gt;创建名字为 vue_03_vue_elementui 的项目，同时安装 vue-router、e1ement-ui、sass-loader 、node-sass 插件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 创建项目
vue init webpack vue_03_vue_elementui

# 进入工程目录
cd vue_03_vue_elementui
# 安装vue-router
npm install vue-router --save-dev
# 安装e1ement-ui
npm i element-ui -S
# 安装依赖
npm install
# 安装SASS加载器
cnpm install sass-loader node-sass --save-dev
# 启动测试
npm run dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;补充：Npm命令解释&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;npm install moduleName&lt;/strong&gt;：安装模块到项目目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;npm install - g moduleNMame&lt;/strong&gt;：-g 的意思是将模块安装到全局,具体安装到磁盘哪个位置，要看 npm config prefix的位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;npm install - save moduleName&lt;/strong&gt;：--save 的意思是将模块安装到项目目录下，并在package文件的 dependencies 节点写入依赖，-S为该命令的缩写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;npm install -save -dev moduleName&lt;/strong&gt;：--save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devdependencies节点写入依赖， -D为该命令的缩写&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着就可以在编辑器中打开了，看个人选择，我这里用 IDEA 打开，打开后注意看一下 modules 文件夹中是否已经把 router sass 等内容成功安装了&lt;/p&gt;
&lt;p&gt;接着将默认的 HelloWorld 那个组件和默认 logo 删掉，开始编写代码，创建一个 views 文件夹用来放视图&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建 Login.vue 和 Main.vue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Login.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;h1&amp;gt;主页面&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    name: &quot;Main.vue&quot;
  }
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Main.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;el-form ref=&quot;loginForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot; class=&quot;login-box&quot;&amp;gt;
      &amp;lt;h3 class=&quot;login-title&quot;&amp;gt;欢迎 登录&amp;lt;/h3&amp;gt;
      &amp;lt;el-form-item label=&quot; 账号&quot; prop=&quot;username&quot;&amp;gt;
        &amp;lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.username&quot;/&amp;gt;
      &amp;lt;/el-form-item&amp;gt;
      &amp;lt;el-form-item label=&quot; 密码&quot; prop=&quot;password&quot;&amp;gt;
        &amp;lt;el-input type=&quot;password&quot; placeholder=&quot; 请输入密码&quot; v-model=&quot;form.password&quot;/&amp;gt;
      &amp;lt;/el-form-item&amp;gt;
      &amp;lt;el-form-item&amp;gt;
        &amp;lt;el-button type=&quot;primary&quot; v-on:click=&quot;onSubmit( 'loginForm' )&quot;&amp;gt;登录&amp;lt;/el-button&amp;gt;
      &amp;lt;/el-form-item&amp;gt;
    &amp;lt;/el-form&amp;gt;
    &amp;lt;el-dialog
      title=&quot;温馨提示&quot;
      :visible.sync=&quot;dialogVisible&quot;
      width=&quot;30%&quot;
      :before-close=&quot;handLeClose&quot;&amp;gt;
      &amp;lt;span&amp;gt;请输入账号和密码&amp;lt;/span&amp;gt;
      &amp;lt;span slot=&quot;footer&quot; class=&quot;dialog- footer&quot;&amp;gt;
        &amp;lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&amp;gt;确定&amp;lt;/el-button&amp;gt;
      &amp;lt;/span&amp;gt;
    &amp;lt;/el-dialog&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;/template&amp;gt;


&amp;lt;script&amp;gt;
  export default {
    name: &quot;Login&quot;,
    data() {
      return {
        form: {
          username: '',
          password: ''
        },
        //表单验证，需要在el-form-item 元素中增加prop 属性
        rules: {
          username: [
            {required: true, message: &quot; 账号不可为空&quot;, trigger: 'blur'}
          ],
          password: [
            {required: true, message: &quot; 密码不可为空 &quot;, trigger: 'blur'}
          ]
        },
        //对话框显示和隐藏
        dialogVisible: false
      }
    },
    methods: {
      onSubmit(formName) {
        //为表单绑定验证功能
        this.$refs[formName].validate((valid) =&amp;gt; {
          if (valid) {
            //使用vue-router路由到指定页面，该方式称之为编程式导航
            this.$router.push(&quot;/main&quot;);
          } else {
            this.dialogVisible = true;
            return false;
          }
        });
      }
    }
  }
&amp;lt;/script&amp;gt;


&amp;lt;style lang=&quot;scss&quot; scoped&amp;gt;
  .login-box {
    border: 1px solid #DCDFE6;
    width: 350px;
    margin: 40px auto;
    padding: 35px 35px 15px 35px;
    border-radius: 5px;
    -webkit-border-radius: 5px;
    -moz-border-radius: 5px;
    box-shadow: 0 0 25px #909399;
  }

  .login-title {
    text-align: center;
    margin: 0 auto 40px auto;
    color: #303133;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建 router 文件夹，以及其中的 index.js，配置好跳转内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;index.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import Vue from 'vue'
import VueRouter from 'vue-router'
import Login from '../views/Login'
import Main from '../views/Main'

Vue.use(VueRouter);

export default new VueRouter({
  routes: [
    {
      path: &quot;/main&quot;,
      component: Main
    },
    {
      path: &quot;/login&quot;,
      component: Login
    }
  ]
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 main.js ，使用 router 和 elementui，关于 router 前面就说过，至于后者，照着官网起步文档就明白了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://element.eleme.cn/#/zh-CN/component/quickstart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import Vue from 'vue'
import App from './App'

import router from './router'
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

Vue.config.productionTip = false;

Vue.use(router);
Vue.use(ElementUI);

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  render: h =&amp;gt; h(App)
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;App.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;h1&amp;gt;理想二旬不止&amp;lt;/h1&amp;gt;
    &amp;lt;router-link to=&quot;/main&quot;&amp;gt;首页&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/login&quot;&amp;gt;登录页面&amp;lt;/router-link&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name: 'App',
}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里就写好了，我们可以开始运行了，但是运行时，我分别出现了如下错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TypeError [ERR_INVALID_ARG_TYPE]: The &quot;path&quot; argument must be of type string. Received type undefined

Module build failed: TypeError: this.getResolve is not a function
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经查阅后，修改项目目录下 package.json 中的 sass-loder 的版本 从 10.0.2 到 8.0.2 到 7.3.1 才可以正常通过 npm run dev 运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;sass-loader&quot;: &quot;^7.3.1&quot;,
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：修改配置后需要重新 npm install 或者 cnpm install&lt;/p&gt;
&lt;p&gt;展示一下最终效果：&lt;/p&gt;
&lt;p&gt;点击首页效果：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4944cda0c2d245a39581b8a90a3afda6~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;点击登录页面效果：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce9f09cd81ac45b289a924fde4794f42~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;最后，在某马上找了一个现成的页面案例，简单搭了下后台跑了一下，也算巩固一下最前面的基础语法，后台就基本的 SSM ，给了三个接口方法，作为一个后端，这应该算基本功了哇&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/user/findAll&lt;/code&gt; 、&lt;code&gt;/user/indById&lt;/code&gt; 、 &lt;code&gt;/user/updateUser&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就是简单的查询和一个更新操作，查询的主体是一个用户类，有这么几个基本字段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User implements Serializable {    
        private Integer id;
    private String username;
    private String password;
    private Integer age;
    private String sex;
    private String email;
    ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面中承接的数据的关键代码如下&lt;/p&gt;
&lt;p&gt;首先是关于所有用户数据展示的，通过一个对于 userList 的遍历，然后通过大括号组和 X.x 的形式取出属性值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;tr v-for=&quot;u in userList&quot;&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;input name=&quot;ids&quot; type=&quot;checkbox&quot;&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{u.id}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{u.username}}
  &amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{u.password}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{u.sex}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{u.age}}&amp;lt;/td&amp;gt;
  &amp;lt;td class=&quot;text-center&quot;&amp;gt;{{u.email}}&amp;lt;/td&amp;gt;
  &amp;lt;td class=&quot;text-center&quot;&amp;gt;
    &amp;lt;button type=&quot;button&quot; class=&quot;btn bg-olive btn-xs&quot;&amp;gt;详情&amp;lt;/button&amp;gt;
    &amp;lt;button type=&quot;button&quot; class=&quot;btn bg-olive btn-xs&quot; @click=&quot;findById(u.id)&quot;&amp;gt;编辑&amp;lt;/button&amp;gt;
  &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击编辑后执行对于当前用户的查询方法，用于回显，下面通过 v-model 进行与 user 的绑定（js后面给出）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;box-body&quot;&amp;gt;
  &amp;lt;div class=&quot;form-horizontal&quot;&amp;gt;


    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
      &amp;lt;label class=&quot;col-sm-2 control-label&quot;&amp;gt;用户名:&amp;lt;/label&amp;gt;
      &amp;lt;div class=&quot;col-sm-5&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.username&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
      &amp;lt;label class=&quot;col-sm-2 control-label&quot;&amp;gt;密码:&amp;lt;/label&amp;gt;
      &amp;lt;div class=&quot;col-sm-5&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.password&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
      &amp;lt;label class=&quot;col-sm-2 control-label&quot;&amp;gt;性别:&amp;lt;/label&amp;gt;
      &amp;lt;div class=&quot;col-sm-5&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.sex&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
      &amp;lt;label class=&quot;col-sm-2 control-label&quot;&amp;gt;年龄:&amp;lt;/label&amp;gt;
      &amp;lt;div class=&quot;col-sm-5&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.age&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
      &amp;lt;label class=&quot;col-sm-2 control-label&quot;&amp;gt;邮箱:&amp;lt;/label&amp;gt;
      &amp;lt;div class=&quot;col-sm-5&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.email&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要实现数据交互，最重要的还是定义数据，与使用 axios 进行异步请求&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var vue = new Vue({
    el: &quot;#app&quot;,
    data: {
        user: {id: &quot;&quot;, username: &quot;&quot;, password: &quot;&quot;, age: &quot;&quot;, sex: &quot;&quot;, email: &quot;&quot;},
        userList: []
    },
    methods: {
        findAll: function () {
            var _this = this;
            axios.get(&quot;user/findAll.do&quot;).then(function (response) {
                _this.userList = response.data;
                console.log(_this.userList);
            }).catch(function (err) {
                console.log(err);
            });
        },
        findById: function (userid) {
            var _this = this;
            axios.get(&quot;user/findById.do&quot;, {
                params: {
                    id: userid
                }
            }).then(function (response) {
                _this.user = response.data;
                $('#myModal').modal(&quot;show&quot;);
            }).catch(function (err) {
            });

        },
        update: function (user) {
            var _this = this;
            axios.post(&quot;user/updateUser.do&quot;, _this.user).then(function (response) {
                _this.findAll();
            }).catch(function (err) {
            });
        }
    },
    created() {
        this.findAll();
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码其实很好理解，首先定义了 user 和 userList 两个数据，userList 就是前面展示所有用户数据的一个遍历内容，用来承载 findAll 后的数据，user 则是对于进行单个用户查询，即修改时回显当前用户旧信息的一个承载实体，因为查询所有的操作是一开始就进行，所以在 created() 中就执行 findAll 方法，在 methos 中创建查和改的方法，通过 axios 进行 get 或者 post 请求，同时将返回的结果进行处理&lt;/p&gt;
&lt;p&gt;说明：&lt;code&gt;.then&lt;/code&gt; 中的是请求成功后执行的内容，&lt;code&gt;.catch&lt;/code&gt; 中是请求失败后执行的内容&lt;/p&gt;
&lt;p&gt;注意：最关键的一个内容就是在 axios 前定义了 &lt;code&gt;var _this = this&lt;/code&gt; 如果有接触过小程序可能会感到很熟悉，这里定义的原因是因为 例如在 axios 中有这样的语句 &lt;code&gt;_this.userList = response.data;&lt;/code&gt; 如果 userList 中前直接使用 this，这就代表着查找 axios 中的此内容，但我们明显想指代的是 data 中的 userList，所以此定义 &lt;code&gt;_this&lt;/code&gt; 步骤不可省略&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;查询所有&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538050de27c74f3c8653cd5f8d6b989f~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;
查询当前用户以及修改
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6470d31ae607489fa765ef72939506a7~tplv-k3u1fbpfcp-zoom-1.image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;如果文章中有什么不足，欢迎大家留言交流，感谢朋友们的支持！&lt;/p&gt;
&lt;p&gt;如果能帮到你的话，那就来关注我吧！如果您更喜欢微信文章的阅读方式，可以关注我的公众号&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在这里的我们素不相识，却都在为了自己的梦而努力 ❤&lt;/p&gt;
&lt;p&gt;一个坚持推送原创开发技术文章的公众号：理想二旬不止&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5bb62feeb174d099c1baff16e52dc1f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Sep 2020 23:51:00 +0000</pubDate>
<dc:creator>BWH_Steven</dc:creator>
<og:description>一个后端开发的 Vue 笔记，咱也不会，咱也不敢问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ideal-20/p/13624713.html</dc:identifier>
</item>
<item>
<title>【趣味设计模式系列】之【访问者模式】 - 小猪爸爸</title>
<link>http://www.cnblogs.com/father-of-little-pig/p/13603202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/father-of-little-pig/p/13603202.html</guid>
<description>&lt;h2 id=&quot;1-简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;访问者模式（Visitor Pattern）：表示一个作用在某对象结构中的元素的操作，它可以在不改变类的元素的前提下，定义作用于这些元素的新操作。这是《设计模式-可复用面向对象软件的基础》中的定义。换句通俗的话，就是类的&lt;span&gt;&lt;strong&gt;&lt;code&gt;结构元素不变&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;，可以根据&lt;span&gt;&lt;strong&gt;&lt;code&gt;访问者重新定义元素的操作&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-示例&quot;&gt;2. 示例&lt;/h2&gt;
&lt;h3 id=&quot;21-水果套餐例子&quot;&gt;2.1 水果套餐例子&lt;/h3&gt;
&lt;p&gt;假如有个水果套餐，是苹果、香蕉、橘子的组合，套餐内的水果种类一般不改变，需要对该购买套餐的消费者实行优惠，个人总价打9折，公司团购打8折，要求在不改变原有套餐内部元素与内部方法的情况下，根据外部访问者的变化，重新定义新的价格算法，如图所示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200902180631138-159211670.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200903101656812-1262673273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FruitPackage水果接口，接受访问者的方法accept，计算价格的方法getPrice&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

/**
 * @Author: wzj
 * @Date: 2020/9/2 20:16
 * @Desc: 水果套餐
 */
interface FruitPackage {
    void accept(Visitor v);
    double getPrice();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;套餐内的每个元素苹果、橘子、香蕉分别实现水果套餐接口FruitPackage，内部accept方法各种去访问对应的元素，并把当前元素的实例this传进去，Apple类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

/**
 * @Author: wzj
 * @Date: 2020/9/2 20:16
 * @Desc: 苹果
 */
public class Apple implements FruitPackage {

    @Override
    public void accept(Visitor visitor) {
        visitor.visitApple(this);
    }

    @Override
    public double getPrice() {
        return 30;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Orange类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

import com.wzj.proxy.v8.Discount;

/**
 * @Author: wzj
 * @Date: 2020/8/4 20:45
 * @Desc: 橘子
 */
public class Orange implements FruitPackage {

    @Override
    public void accept(Visitor visitor) {
        visitor.visitOrange(this);
    }

    @Override
    public double getPrice() {
        return 50;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Banana类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

/**
 * @Author: wzj
 * @Date: 2020/9/2 20:16
 * @Desc: 香蕉
 */
public class Banana implements FruitPackage {

    @Override
    public void accept(Visitor visitor) {
        visitor.visitBanana(this);
    }

    @Override
    public double getPrice() {
        return 40;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义访问者接口，内部依次定义访问每个元素的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

/**
 * @Author: wzj
 * @Date: 2020/9/2 20:14
 * @Desc: 访问者接口
 */
public interface Visitor {

    void visitApple(Apple apple);

    void visitOrange(Orange orange);

    void visitBanana(Banana banana);

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;个人访问者PersonelVisitor类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

/**
 * @Author: wzj
 * @Date: 2020/9/2 20:40
 * @Desc: 个人访问者--一律9折
 */
public class PersonelVisitor implements Visitor{

    double totalPrice = 0.0;


    @Override
    public void visitApple(Apple apple) {
        totalPrice += apple.getPrice() * 0.9;
    }

    @Override
    public void visitOrange(Orange orange) {
        totalPrice += orange.getPrice() * 0.9;
    }

    @Override
    public void visitBanana(Banana banana) {
        totalPrice += banana.getPrice() * 0.9;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;团购访问者GroupVisitor类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

/**
 * @Author: wzj
 * @Date: 2020/9/2 20:41
 * @Desc:  团购访问者--一律8折
 */
public class GroupVisitor implements Visitor{

    double totalPrice = 0.0;


    @Override
    public void visitApple(Apple apple) {
        totalPrice += apple.getPrice() * 0.8;
    }

    @Override
    public void visitOrange(Orange orange) {
        totalPrice += orange.getPrice() * 0.8;
    }

    @Override
    public void visitBanana(Banana banana) {
        totalPrice += banana.getPrice() * 0.8;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体水果套餐类ConcretePackage，把包含三个水果的元素组装起来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

/**
 * @Author: wzj
 * @Date: 2020/9/2 20:51
 * @Desc: 具体套餐，苹果、香蕉、橘子
 */
public class ConcretePackage implements FruitPackage{
    Apple apple;
    Orange orange;
    Banana banana;

    public ConcretePackage(Apple apple, Orange orange, Banana banana) {
        this.apple = apple;
        this.orange = orange;
        this.banana = banana;
    }

    public void accept(Visitor visitor) {
        this.apple.accept(visitor);
        this.orange.accept(visitor);
        this.banana.accept(visitor);
    }

    @Override
    public double getPrice() {
        return apple.getPrice() + orange.getPrice() + banana.getPrice();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端类Client&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example1;

import org.aspectj.weaver.ast.Or;

/**
 * @Author: wzj
 * @Date: 2020/9/2 20:57
 * @Desc:
 */
public class Client {
    public static void main(String[] args) {
        Apple apple = new Apple();
        Orange orange = new Orange();
        Banana banana = new Banana();
        //个人套餐价格
        PersonelVisitor p = new PersonelVisitor();
        new ConcretePackage(apple, orange, banana).accept(p);
        System.out.println(&quot;个人套餐价格：&quot; + p.totalPrice);
        //公司套餐价格
        GroupVisitor g = new GroupVisitor();
        new ConcretePackage(apple, orange, banana).accept(g);
        System.out.println(&quot;公司套餐价格：&quot; + g.totalPrice);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;个人套餐价格：108.0
公司套餐价格：96.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-台式机组装例子&quot;&gt;2.2 台式机组装例子&lt;/h3&gt;
&lt;p&gt;假如有个台式机组装，为简化起见，是组装元素由固定的三部分组成，CPU、内存条、主板，现对个人来访者总价打9折，公司团购来访者总价打8折，要求在不改变原有套餐内部元素与内部方法的情况下，根据外部访问者的变化，重新定义新的价格算法，如图所示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200902211249472-1734626651.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;类图设计&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200903101600207-527890664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;电脑部件类ComputerPart&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example2;

/**
 * @Author: wzj
 * @Date: 2020/9/2 21:15
 * @Desc: 电脑部件
 */
public interface ComputerPart {

    void accept(Visitor v);
    double getPrice();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CPU类、Memory类、Board类如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example2;

/**
 * @Author: wzj
 * @Date: 2020/9/2 21:13
 * @Desc: CPU
 */
public class CPU implements ComputerPart{
    @Override
    public void accept(Visitor v) {
        v.visitCpu(this);
    }

    @Override
    public double getPrice() {
        return 1000;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example2;

/**
 * @Author: wzj
 * @Date: 2020/9/2 21:13
 * @Desc: 内存条
 */
public class Memory implements ComputerPart{
    @Override
    public void accept(Visitor v) {
        v.visitMemory(this);
    }

    @Override
    public double getPrice() {
        return 500;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example2;

/**
 * @Author: wzj
 * @Date: 2020/9/2 21:13
 * @Desc: CPU
 */
public class Board implements ComputerPart{
    @Override
    public void accept(Visitor v) {
        v.visitBoard(this);
    }

    @Override
    public double getPrice() {
        return 800;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;个人访问者PersonelVisitor类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example2;

/**
 * @Author: wzj
 * @Date: 2020/9/2 21:21
 * @Desc: 个人购买9折
 */
public class PersonelVisitor implements Visitor {
    double totalPrice = 0.0;

    @Override
    public void visitCpu(CPU cpu) {
        totalPrice += cpu.getPrice() * 0.9;
    }

    @Override
    public void visitMemory(Memory memory) {
        totalPrice += memory.getPrice() * 0.9;
    }

    @Override
    public void visitBoard(Board board) {
        totalPrice += board.getPrice() * 0.9;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;团购访问者GroupVisitor类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example2;

/**
 * @Author: wzj
 * @Date: 2020/9/2 21:21
 * @Desc:  公司团购8折
 */
public class GroupVisitor implements Visitor {
    double totalPrice = 0.0;

    @Override
    public void visitCpu(CPU cpu) {
        totalPrice += cpu.getPrice() * 0.8;
    }

    @Override
    public void visitMemory(Memory memory) {
        totalPrice += memory.getPrice() * 0.8;
    }

    @Override
    public void visitBoard(Board board) {
        totalPrice += board.getPrice() * 0.8;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;电脑类Computer类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example2;

/**
 * @Author: wzj
 * @Date: 2020/9/2 21:24
 * @Desc:  电脑
 */
public class Computer {

    CPU cpu;
    Memory memory;
    Board board;

    public Computer(CPU cpu, Memory memory, Board board) {
        this.cpu = cpu;
        this.memory = memory;
        this.board = board;
    }

    public void acccept(Visitor v) {
        this.cpu.accept(v);
        this.memory.accept(v);
        this.board.accept(v);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端Client类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.visitor.example2;

/**
 * @Author: wzj
 * @Date: 2020/9/2 21:24
 * @Desc:
 */
public class Client {
    public static void main(String[] args) {
        CPU cpu = new CPU();
        Memory memory = new Memory();
        Board board = new Board();
        PersonelVisitor p = new PersonelVisitor();
        new Computer(cpu, memory, board).acccept(p);
        System.out.println(&quot;个人套餐价格：&quot; + p.totalPrice);
        GroupVisitor g = new GroupVisitor();
        new Computer(cpu, memory, board).acccept(g);
        System.out.println(&quot;公司套餐价格：&quot; + g.totalPrice);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;个人套餐价格：2070.0
公司套餐价格：1840.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-应用场景分析&quot;&gt;3. 应用场景分析&lt;/h2&gt;
&lt;p&gt;访问者模式一般用在特定的场景中，在经典的四人帮写的【设计模式】一书中，举了编译器的例子，如果需要将源程序表示一个&lt;code&gt;抽象语法树&lt;/code&gt;，编译器需要对抽象语法树实施某些操作，如类型检查、代码优化、优化格式打印，大多数操作对于不同节点进行不同处理，但是对于编译器来说，节点类的集合对于给定的语言，内部结构很少变化，如下图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200904161855992-1208299818.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译器对使用访问者对程序进行类型检查，它将创建一个TypeCheckingVisitor对象，并以这个对象为传入参数，在抽象语法树上调用accept方法，每一个节点在实现accept方法时会回调访问者：一个赋值节点AssignmentNode对象会回调visitAssignment(this)方法，一个变量引用节点VariableRefNode对象会调用visitVariableRef(this)方法。&lt;/p&gt;
&lt;p&gt;笔者在&lt;a href=&quot;https://www.cnblogs.com/father-of-little-pig/p/13594140.html&quot;&gt;【趣味设计模式系列】之【代理模式4--ASM框架解析】&lt;/a&gt;里面分析的ASM框架也是运用的访问者模式，几个核心类的关系如下图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1765702/202009/1765702-20200903101134900-1629673608.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;成员变量节点FieldNode类、方法节点MethodNode类，拥有接收访问者的方法accept，通过传入的具体的访问者ClassAdapter类或ClassWriter类，方法内部各自调用具体访问者访问自己部件的方法，对应途中的访问属性visitField，访问方法visitMethod。&lt;/p&gt;
&lt;h2 id=&quot;4-总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;h3 id=&quot;41-双分派技术&quot;&gt;4.1 双分派技术&lt;/h3&gt;
&lt;p&gt;讲到访问者模式，大部分书籍或者资料都会讲到 Double Dispatch，中文翻译为双分派。为什么支持双分派的语言就不需要访问者模式。&lt;/p&gt;
&lt;p&gt;既然有 Double Dispatch，对应的就有 Single Dispatch。所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓 Double Dispatch，指的是执行哪个对象的方法，根据&lt;code&gt;对象的运行时类型&lt;/code&gt;来决定；执行对象的哪个方法，根据&lt;code&gt;方法参数的运行时类型&lt;/code&gt;来决定。&lt;/p&gt;
&lt;p&gt;如何理解“Dispatch”这个单词呢？在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。如何理解“Single”“Double”这两个单词呢？“Single”“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下。Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。&lt;/p&gt;
&lt;p&gt;Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。&lt;br/&gt;举个例子来具体说明一下，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class ParentClass {
  public void f() {
    System.out.println(&quot;I am ParentClass's f().&quot;);
  }
}

public class ChildClass extends ParentClass {
  public void f() {
    System.out.println(&quot;I am ChildClass's f().&quot;);
  }
}

public class SingleDispatchClass {
  public void polymorphismFunction(ParentClass p) {
    p.f();
  }

  public void overloadFunction(ParentClass p) {
    System.out.println(&quot;I am overloadFunction(ParentClass p).&quot;);
  }

  public void overloadFunction(ChildClass c) {
    System.out.println(&quot;I am overloadFunction(ChildClass c).&quot;);
  }
}

public class DemoMain {
  public static void main(String[] args) {
    SingleDispatchClass demo = new SingleDispatchClass();
    ParentClass p = new ChildClass();
    demo.polymorphismFunction(p);//执行哪个对象的方法，由对象的实际类型决定
    demo.overloadFunction(p);//执行对象的哪个方法，由参数对象的声明类型决定
  }
}

//代码执行结果:
I am ChildClass's f().
I am overloadFunction(ParentClass p).
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这也回答了为什么支持 Double Dispatch 的语言不需要访问者模式。&lt;/p&gt;
&lt;p&gt;访问者模式允许在不改变类的情况下，有效的增加新的操作，这是一种很著名的技术，意味着执行的操作取决于请求的种类与接受者类型，accept方法是一个双分派操作， 取决于visitor类型与Node节点类型，使得访问者可以对每一种类型的请求执行不用的操作。&lt;/p&gt;
&lt;h3 id=&quot;42-优点&quot;&gt;4.2 优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;容易增加新的操作&lt;br/&gt;如果有复杂对象结构，需要增加新的操作，只需要增加新的访问者定义新操作即可。&lt;/li&gt;
&lt;li&gt;集中相关操作分离无关操作&lt;br/&gt;相关行为集中在访问者中，无关行为被分离到各自访问者的关子类中，所有与算法相关的数据结构都被隐藏在访问者中。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;43-缺点&quot;&gt;4.3 缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;具体元素对访问者公布，破坏封装；&lt;/li&gt;
&lt;li&gt;访问者依赖具体元素，而非依赖抽象，破坏了依赖倒置原则，导致具体元素的增加、删除、修改比较困难。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上，访问者模式一般都用在类似于&lt;span&gt;&lt;strong&gt;&lt;code&gt;编译器&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;等比较窄却很专业的场景中，如果自己非要使用，适合类的结构元素不变的情况下，需要重新定义元素操作。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;附：githup源码下载地址：&lt;a href=&quot;https://github.com/wuzhujun2006/design-patterns&quot;&gt;https://github.com/wuzhujun2006/design-patterns&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Sep 2020 23:06:00 +0000</pubDate>
<dc:creator>小猪爸爸</dc:creator>
<og:description>1. 简介 访问者模式（Visitor Pattern）：表示一个作用在某对象结构中的元素的操作，它可以在不改变类的元素的前提下，定义作用于这些元素的新操作。这是《设计模式-可复用面向对象软件的基础》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/father-of-little-pig/p/13603202.html</dc:identifier>
</item>
<item>
<title>数据结构和算法躬行记（3）——二叉树 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13355897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13355897.html</guid>
<description>&lt;p&gt;　　树是一种非线性表数据结构，树的基本概念如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）结点高度：结点到叶子结点的最长路径（即边数）。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/path-sum/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;112. 路径总和&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　（2）结点深度：根结点到这个结点所经历的边的个数。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;104. 二叉树的最大深度&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　（3）结点层数：结点深度加 1。&lt;/p&gt;
&lt;p&gt;　　（4）树的高度：根结点的高度。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-height-tree-lcci/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;面试题 04.02. 最小高度树&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　后面几张这种类型的图都来源于《&lt;span&gt;&lt;a href=&quot;https://time.geekbang.org/column/126&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;数据结构与算法之美&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200721163755022-1209025633.jpg&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 2&lt;/p&gt;
&lt;p&gt;　　（5）二叉树：只包含左右两个子结点的树（编号1）。&lt;/p&gt;
&lt;p&gt;　　（6）满二叉树：所有分支结点都存在左右子树，并且所有叶子结点都在同一层上（编号2）。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/all-possible-full-binary-trees/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;894. 所有可能的满二叉树&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　（7）完全二叉树：叶子结点都在最底下两层，最后一层的叶子结点都靠左排列，并且除了最后一层，其余结点个数都要达到最大（编号3）。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-complete-tree-nodes/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;222. 完全二叉树的结点个数&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200721163956155-1151516695.jpg&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 3&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有两种方法存储一棵二叉树，第一种是基于指针的链式存储法，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/LYGMrVO&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Node {
  constructor(data) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  }
}
class TreeList {
  constructor(datas) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    datas.forEach((value) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      const node &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(value);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root =&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.insert(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root, node);
    });
  }
  insert(parent, child) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent.data &amp;gt;&lt;span&gt; child.data) {
      parent.left &lt;/span&gt;=== &lt;span&gt;null&lt;/span&gt;
        ? (parent.left =&lt;span&gt; child)
        : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.insert(parent.left, child);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    parent.right &lt;/span&gt;=== &lt;span&gt;null&lt;/span&gt;
      ? (parent.right =&lt;span&gt; child)
      : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.insert(parent.right, child);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二种是基于数组的顺序存储法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
left = 2 * index + 1;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左结点下标&lt;/span&gt;
right = 2 * index + 2;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右结点下标&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　例题：LeetCode的&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;236. 二叉树的最近公共祖先&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，递归的在左右子树中查找两个指定的结点，最后判断公共祖先所在的位置。在当前结点的左子树，或在其右子树，又或者它就是两种的公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）遍历&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　二叉树的遍历有四种（&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/mdVaKVz&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;示例如下&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）：&lt;/p&gt;
&lt;p&gt;　　（1）前序：先访问当前结点，然后访问左子树，再访问右子树。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  preOrder(root = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前序&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;root) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    console.log(root.data);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.preOrder(root.left);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.preOrder(root.right);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730141551076-1442514582.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 4&lt;/p&gt;
&lt;p&gt;　　面试题28 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;对称二叉树&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。前序遍历的变种是先访问右结点，再访问左结点，如果其遍历结果与前序遍历结果相同，就说明是对称的。&lt;/p&gt;
&lt;p&gt;　　面试题34 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;二叉树中和为某一值的路径&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。前序遍历首先访问根结点，在用前序遍历访问结点时，将其压入栈中，遇到叶结点，就求和判断结果是否符合要求。然后将叶结点出栈，回到父节点，继续遍历右子树，递归执行该过程。&lt;/p&gt;
&lt;p&gt;　　（2）中序：先访问左子树，然后访问当前结点，再访问右子树。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  inOrder(root = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;root) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.midOrder(root.left);
    console.log(root.data);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.midOrder(root.right);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730141642136-798363850.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 5&lt;/p&gt;
&lt;p&gt;　　面试题7 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;重建二叉树&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。前序遍历第一个数是根结点，中序遍历以根结点为界其两边分别是左右子树，递归构建左右子树。&lt;/p&gt;
&lt;p&gt;　　面试题54 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;BST中第 k 大的结点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。中序遍历BST，得到的序列是递增的。&lt;/p&gt;
&lt;p&gt;　　（3）后序：先访问左子树，然后访问右子树，再访问当前结点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  postOrder(root = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后序&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;root) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.backOrder(root.left);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.backOrder(root.right);
    console.log(root.data);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730141709956-660983355.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 6&lt;/p&gt;
&lt;p&gt;　　面试题33 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;BST的后序遍历序列&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。序列的最后一个数字是根结点，左子树的结点都比根结点小，右子树的结点都比根结点大，递归执行该过程。&lt;/p&gt;
&lt;p&gt;　　（4）层序：自上而下，自左至右逐层访问树的结点。利用一个辅助队列来完成层序遍历。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  levelOrder(node = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;层序&lt;/span&gt;
    let queue =&lt;span&gt; [];
    queue.push(node);               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根结点入队&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (queue.length) {
      node &lt;/span&gt;= queue.shift();         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出队&lt;/span&gt;
      console.log(node.data);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问该结点&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node.left) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果它的右子树不为空&lt;/span&gt;
        queue.push(node.left);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将左子树的根结点入队&lt;/span&gt;
&lt;span&gt;      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node.right) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果它的右子树不为空&lt;/span&gt;
        queue.push(node.right);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将右子树的根结点入队&lt;/span&gt;
&lt;span&gt;      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除了层序遍历之外，其余三种都采用递归的方式来遍历二叉树。&lt;/p&gt;
&lt;p&gt;　　有两种图的搜索算法，也适用于树。&lt;/p&gt;
&lt;p&gt;　　（1）广度优先搜索算法（Breadth-First Search，BFS）会从根结点开始遍历，先访问其所有的相邻点，就像一次访问树的一层，也就是先宽后深地访问结点，之前的层序遍历就是BFS，如下图左半部分。&lt;/p&gt;
&lt;p&gt;　　（2）深度优先搜索算法（Depth-First-Search，DFS）会从根结点开始遍历，沿着路径直到这条路径最后一个叶结点被访问，接着原路回退并探索下一条路径，也就是先深度后广度地访问结点，如下图右半部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202008/211606-20200818123721387-1300109971.png&quot; width=&quot;700&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在《&lt;span&gt;&lt;a href=&quot;https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa#san-suan-fa-shua-ti-zhi-nan&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;算法小抄&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一文中曾强调先刷二叉树的LeetCode题目，因为很多难题本质上都是基于二叉树的遍历，例如LeetCode的&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;124 题&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（二叉树中的最大路径和）、&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;105 题&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（从前序与中序遍历序列构造二叉树）和&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/recover-binary-search-tree/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;99 题&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（恢复二叉搜索树）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）递归&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　递归是一种应用广泛的编程技巧，如果要使用递归，需要满足三个条件。&lt;/p&gt;
&lt;p&gt;　　（1）一个问题的解可以分解为几个子问题的解。&lt;/p&gt;
&lt;p&gt;　　（2）这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。&lt;/p&gt;
&lt;p&gt;　　（3）存在递归终止条件，即基线条件（Base Case）。&lt;/p&gt;
&lt;p&gt;　　注意，递归的关键就是找到将大问题分解为小问题的规律（推荐画出递归树），基于此写出递推公式，然后再推敲终止条件，并且需要警惕重复计算。下面是一个递归的大致模板。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; recursion(level, param1, param2, ...) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归的终止条件&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;(level &amp;gt;&lt;span&gt; MAX_LEVEL) {
    console.log(&lt;/span&gt;&quot;result&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据处理&lt;/span&gt;
&lt;span&gt;  processData(level, data1,...);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续递归&lt;/span&gt;
  recursion(level + 1&lt;span&gt;, p1, ...);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;收尾工作&lt;/span&gt;
&lt;span&gt;  reverseState(level);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　递归的数学模型就是&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;归纳法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，其过程如下。&lt;/p&gt;
&lt;p&gt;　　（1）基础情况：证明 P(b)语句成立，该步骤只需带入数字即可。&lt;/p&gt;
&lt;p&gt;　　（2）声明假设：假设 P(n)语句成立。&lt;/p&gt;
&lt;p&gt;　　（3）归纳步骤：证明如果 P(n)语句成立，那么 P(n+1) 语句也一定成立。&lt;/p&gt;
&lt;p&gt;　　例如设计一程序，求自然数 N 的阶乘 N!。&lt;/p&gt;
&lt;p&gt;　　（1）当 N=1 时，N!=1。&lt;/p&gt;
&lt;p&gt;　　（2）假设 P(N)=N!，P(N+1)=(N+1)!。&lt;/p&gt;
&lt;p&gt;　　（3）证明 P(N) 和 P(N+1) 的关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
P(N+1) = (N+1)! = (N+1)×(N)×…×2×1 = (N+1)×N! = (N+1)×P(N)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　根据这个公式可构造一个递归函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; factorial(N) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; N * factorial(N - 1);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归部分&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在采用数学归纳法设计递归程序后，就能摆脱每一步的递推，直接根据分析就能转化为代码。&lt;/p&gt;
&lt;p&gt;　　试图想清楚整个递和归过程的做法，实际上是一种思维误区，不符合人脑平铺直叙的思维方式。&lt;/p&gt;

&lt;p&gt;　　在二叉查找树（Binary Search Tree，BST）中，每个结点的值都大于左子结点，小于右子结点。当中序遍历BST时，就可在 O(n) 的时间复杂度内输出有序的结点。&lt;/p&gt;
&lt;p&gt;　　BST的时间复杂度和树的高度成正比，即 O(height)，经过推导后，完全二叉树的高度（height）小于等于 log2^n。&lt;/p&gt;
&lt;p&gt;　　平衡二叉查找树的高度接近 logn，所以插入、删除、查找等操作的时间复杂度也比较稳定，都是 O(logn)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在BST中查找一个结点的递归算法是（&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/JjGwZeZ&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;代码如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）：&lt;/p&gt;
&lt;p&gt;　　（1）如果被查找的结点和根结点的值相等，则查找命中，否则就递归地的在适当的子树中继续查找。&lt;/p&gt;
&lt;p&gt;　　（2）如果被查找的结点值较小就选择左子树，否则就选择右子树。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  find(data) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找&lt;/span&gt;
    let node = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data ==&lt;span&gt; node.data) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
      }
      data &lt;/span&gt;&amp;lt; node.data ? (node = node.left) : (node =&lt;span&gt; node.right);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　BST插入结点的过程和查找差不多，依次比较结点值和左右子树的大小。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  insert(parent, child) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (parent.data &amp;gt;&lt;span&gt; child.data) {
      parent.left &lt;/span&gt;=== &lt;span&gt;null&lt;/span&gt;
        ? (parent.left =&lt;span&gt; child)
        : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.insert(parent.left, child);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    parent.right &lt;/span&gt;=== &lt;span&gt;null&lt;/span&gt;
      ? (parent.right =&lt;span&gt; child)
      : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.insert(parent.right, child);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在BST中查找最大和最小的结点，以最小值为例，如果根结点的左链接为空，那么一棵BST中的最小值就是根结点；如果左链接非空，那么最小值就是左子树中的最小值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  min(node = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小值&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (node.left == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.min(node.left);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）删除&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　针对删除结点的子结点个数的不同，需要分类讨论（&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/oNbJMoK&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;代码如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）：&lt;/p&gt;
&lt;p&gt;　　（1）如果没有子结点，那么只需将父结点中，链接删除结点的指针置为 null。&lt;/p&gt;
&lt;p&gt;　　（2）如果只有一个子结点，那么只需更新父结点中，链接删除结点的指针指向其子结点即可。&lt;/p&gt;
&lt;p&gt;　　（3）如果包含两个子结点，那么需要先找到该结点右子树中的最小结点，替换要删除的结点；然后再删除该最小结点，由于最小结点肯定没有左子结点，因此可以使用上面两条规则删除它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730142752095-1182285224.jpg&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 7&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  del(data) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
    let p = &lt;span&gt;this&lt;/span&gt;.root,         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p指向要删除的结点，初始化指向根结点&lt;/span&gt;
      parent = &lt;span&gt;null&lt;/span&gt;;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父结点&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; p.data !=&lt;span&gt; data) {
      parent &lt;/span&gt;=&lt;span&gt; p;
      data &lt;/span&gt;&amp;gt; p.data ? (p = p.right) : (p =&lt;span&gt; p.left);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有找到&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要删除的结点有两个子结点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (p.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; p.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找右子树中最小结点&lt;/span&gt;
      let minP =&lt;span&gt; p.right,
        minParent &lt;/span&gt;= p;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;minParent表示minP的父结点&lt;/span&gt;
      &lt;span&gt;while&lt;/span&gt; (minP.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        minParent &lt;/span&gt;=&lt;span&gt; minP;
        minP &lt;/span&gt;=&lt;span&gt; minP.left;
      }
      p.data &lt;/span&gt;= minP.data;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将minP的数据替换到p中&lt;/span&gt;
      p = minP;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面就变成了删除minP了&lt;/span&gt;
      parent =&lt;span&gt; minParent;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除结点是叶子结点或者仅有一个子结点&lt;/span&gt;
    let child;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p的子结点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (p.left != &lt;span&gt;null&lt;/span&gt;) child =&lt;span&gt; p.left;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p.right != &lt;span&gt;null&lt;/span&gt;) child =&lt;span&gt; p.right;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; child = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;this&lt;/span&gt;.root =&lt;span&gt; child;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除的是根结点&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (parent.left == p) parent.left =&lt;span&gt; child;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; parent.right =&lt;span&gt; child;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）数据重复&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　要让BST支持重复数据，可以有两种处理方式。&lt;/p&gt;
&lt;p&gt;　　（1）在每个结点中增加一个链表，把相同的值存储到链表中。&lt;/p&gt;
&lt;p&gt;　　（2）将相同的值插入到结点的右子树中，作为大于这个结点来处理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）平衡二叉查找树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　平衡二叉树是指任意一个结点的左右子树的高度相差不能大于 1，让整棵树左右看起来比较对称和平衡，不要出现左子树很高、右子树很矮的情况。&lt;/p&gt;
&lt;p&gt;　　在下面的&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/eYJbLmo&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中，height()函数会自顶向下递归的计算结点的高度，isBalanced()函数会判断左右子树的高度差。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isBalanced(root) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Math.abs(height(root.left) - height(root.right)) &amp;gt; 1&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; isBalanced(root.left) &amp;amp;&amp;amp;&lt;span&gt; isBalanced(root.right);
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; height(root) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.max(height(root.left) + 1, height(root.right) + 1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　堆（heap）是一种特殊的树形数据结构，它有两个特性：&lt;/p&gt;
&lt;p&gt;　　（1）必须是一棵完全二叉树。&lt;/p&gt;
&lt;p&gt;　　（2）结点的值要大于等于或小于等于两个子结点的值。&lt;/p&gt;
&lt;p&gt;　　当结点的值小于等于两个子结点的值，称之为小顶堆；当结点的值大于等于两个子结点的值，称之为大顶堆。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　往堆中插入一个元素后，需要继续满足堆的两个特性，这个过程叫做堆化（heapify），下面的&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/bGEOxLm&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;在构建一个大顶堆。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; heapify(arr, x, len) {
  let l &lt;/span&gt;= 2 * x + 1,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左结点&lt;/span&gt;
    r = 2 * x + 2,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右结点&lt;/span&gt;
    largest =&lt;span&gt; x,
    temp;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l &amp;lt; len &amp;amp;&amp;amp; arr[l] &amp;gt;&lt;span&gt; arr[largest]) {
    largest &lt;/span&gt;=&lt;span&gt; l;
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r &amp;lt; len &amp;amp;&amp;amp; arr[r] &amp;gt;&lt;span&gt; arr[largest]) {
    largest &lt;/span&gt;=&lt;span&gt; r;
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (largest != x) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换位置&lt;/span&gt;
    temp =&lt;span&gt; arr[x];
    arr[x] &lt;/span&gt;=&lt;span&gt; arr[largest];
    arr[largest] &lt;/span&gt;=&lt;span&gt; temp;
    heapify(arr, largest, len);
  }
}
const tree &lt;/span&gt;= [4, 5, 1, 2, 3, 6&lt;span&gt;],
  heapSize &lt;/span&gt;=&lt;span&gt; tree.length;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = Math.floor(heapSize / 2) - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
  heapify(tree, i, heapSize);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）堆排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　堆排序是一种原地的、时间复杂度为 O(nlogn) 的不稳定排序算法。排序主要分为两个过程：一是构建堆；二是交换堆顶元素与最后一个元素的位置，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/pogqOMo&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; heapSort(arr) {
  let heapSize &lt;/span&gt;=&lt;span&gt; arr.length,
    temp;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建堆&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (let i = Math.floor(heapSize / 2) - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
    heapify(arr, i, heapSize);
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;堆排序&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (let j = heapSize - 1; j &amp;gt;= 1; j--&lt;span&gt;) {
    temp &lt;/span&gt;= arr[0&lt;span&gt;];
    arr[&lt;/span&gt;0] =&lt;span&gt; arr[j];
    arr[j] &lt;/span&gt;=&lt;span&gt; temp;
    heapify(arr, &lt;/span&gt;0, --&lt;span&gt;heapSize);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　堆有几个非常重要的应用，例如优先级队列、求Top K和求中位数。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;703. 数据流中的第K大元素&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;剑指 Offer 41. 数据流中的中位数&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　其中求中位数的方法很巧妙，会维护两个堆：大顶堆和小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。如果有 n 个数据：&lt;/p&gt;
&lt;p&gt;　　（1）当 n 是偶数时，前 2/n​ 个数据存储在大顶堆中，后 2/n​ 个数据存储在小顶堆中。&lt;/p&gt;
&lt;p&gt;　　（2）当 n 是奇数时，大顶堆就存储 2/n​+1 个数据，小顶堆中就存储 2n​ 个数据。&lt;/p&gt;
&lt;p&gt;　　这样，大顶堆中的堆顶元素就是要找的中位数。&lt;/p&gt;
</description>
<pubDate>Sun, 06 Sep 2020 23:05:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>树是一种非线性表数据结构，树的基本概念如下所列。 （1）结点高度：结点到叶子结点的最长路径（即边数）。例题：112. 路径总和。 （2）结点深度：根结点到这个结点所经历的边的个数。例题：104. 二叉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13355897.html</dc:identifier>
</item>
<item>
<title>浅谈HASH长度拓展攻击 - Yunen的博客</title>
<link>http://www.cnblogs.com/yunen/p/13624595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunen/p/13624595.html</guid>
<description>&lt;p&gt;最近在做CTF题的时候遇到这个考点，想起来自己之前在做实验吧的入门CTF题的时候遇到过这个点，当时觉得难如看天书一般，现在回头望去，仔细琢磨一番感觉也不是那么难，这里就写篇文章记录一下自己的学习的过程。&lt;/p&gt;

&lt;p&gt;何为HASH长度拓展攻击？&lt;/p&gt;
&lt;p&gt;简单的说，由于HASH的生成机制原因，使得我们可以人为的在原先明文数据的基础上添加新的拓展字符，使得原本的加密链变长，进而控制加密链的最后一节，使得我们得以控制最终结果。&lt;/p&gt;
&lt;p&gt;这里我们以MD5加密算法为例子。&lt;/p&gt;
&lt;h2 id=&quot;md5长度拓展攻击&quot;&gt;MD5长度拓展攻击&lt;/h2&gt;
&lt;p&gt;下面是个简单的PHP例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
include &quot;flag.php&quot;;
$secretKey = 'xxxxxx'; #xxx为未知内容，但长度已知为6。
$v1 = $_GET['str'];
$sign = $_GET['sign'];
$token = md5($secretKey.$v1);
if($v1 === 'test') {
    die($token); #token=2df51a84abc64a28740d6d2ae8cd7b16
} else {
    if($token === $sign) {
        die($flag);
    }
}
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们需要使得变量&lt;code&gt;$token&lt;/code&gt;与我们输入的sign参数满足一致才会输出flag。&lt;/p&gt;
&lt;p&gt;而由于我们无法知道变量&lt;code&gt;$secretKey&lt;/code&gt;的内容，所以无法得到&lt;code&gt;$token&lt;/code&gt;的值，故而看似是没有办法获取到flag的死局，而这时便轮到我们的拓展攻击来大显身手了。&lt;/p&gt;
&lt;h3 id=&quot;md5算法流程&quot;&gt;MD5算法流程&lt;/h3&gt;
&lt;p&gt;若想搞清楚原理，其算法的流程是必须了解的。不过我们无需去关心那些复杂的运算，只需要知道的大概的一个流程就OK了。&lt;/p&gt;
&lt;p&gt;这里借一张神图：&lt;/p&gt;
&lt;blockquote readability=&quot;0.703125&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907021934829-2120181102.png&quot; alt=&quot;MD5加密流程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摘自：&lt;a href=&quot;https://xz.aliyun.com/t/2563&quot;&gt;哈希长度拓展攻击(Hash Length Extension Attacks)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看不懂也没关系，相信你看完我这篇文章后再返回来看这张图就很清晰明了了。&lt;/p&gt;
&lt;p&gt;我们还是举个例子，对于字符串&lt;code&gt;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb&lt;/code&gt;（64个a、3个b）。长度为19个字符，且根据ASCII表，字符a、b的十六进制分别为0x61、0x62。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907022008311-1683967402.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而我们知道，&lt;code&gt;1&lt;/code&gt;位十六进制相当于&lt;code&gt;4&lt;/code&gt;位二进制表示(&lt;code&gt;16=2^4&lt;/code&gt;)。所以对于64个字符a的长度来说，其二进制长度为：&lt;code&gt;字符长度*二进制位数2*十六进制转二进制位数拓展4=64*2*4=512&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于MD5算法来说，我们需要将原数据进行分块处理，以512位个二进制数据为一块。”最后“一块的处理分为以下几种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;明文数据的二进制数据长度&amp;lt;=448，填充padding(无意义占位)数据使其长度为448，再添加原始明文数据的二进制长度信息（64位）使其长度为512位即可。&lt;/li&gt;
&lt;li&gt;448&amp;lt;明文数据的二进制数据长度&amp;lt;=512，填充padding数据至下一块的448位，而后再添加原始明文数据的二进制长度信息（64位）使其长度为512位即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两种情况如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907022025084-1991913322.png&quot; alt=&quot;第一种情况&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907022036709-1146554163.png&quot; alt=&quot;第二种情况&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：每块数据的长度均为&lt;strong&gt;512&lt;/strong&gt;位二进制，图中的数据我没有全都用二进制来表示，将明文数据分块之后就可以与向量进行运算了。&lt;/p&gt;
&lt;p&gt;对于padding数据（长度不定）来说：首位二进制位1，其余位为0.&lt;/p&gt;
&lt;p&gt;对于长度信息位（长度8Byte=64bit）来说，从低位向高位数，如上图的长度信息：&lt;code&gt;f0 03 00 00 00 00 00 00&lt;/code&gt;即代表0x03f0，其对应的十进制为1008，即为64+62=126个字符的二进制位数(一个字符1Byte即8bit)。&lt;/p&gt;
&lt;p&gt;对于MD5算法来说，有一串初始向量如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A=0x67452301
B=0xefcdab89
C=0x98badcfe
D=0x10325476
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这串初始向量的值是固定的，作为与第一块数据运算的原始向量。&lt;/p&gt;
&lt;p&gt;当这串向量与第一块数据块运算之后，得到了一串新的向量值，这串新的向量值接着与第二块数据块参加运算，直到最后一块数据块。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907022115124-747740824.png&quot; alt=&quot;向量运算&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而最后的MD5值就是这最后的向量串经过如下转换的结果。&lt;/p&gt;
&lt;p&gt;如向量串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A=0xab45bc01
B=0x6a64bb53
C=0x23ba8afe
D=0x46847a62
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先两两为一组进行组合，得到如下数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ab 45 bc 01
6a 64 bb 53
23 ba 8a fe
46 84 7a 62
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再进行高低位互换，得到如下数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;01 bc 45 ab
53 bb 64 6a
fe 8a ba 23
62 7a 84 46
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终拼接得到MD5值：&lt;code&gt;01bc45ab53bb646afe8aba23627a8446&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在，让我们回到开始的那个例子。&lt;/p&gt;
&lt;p&gt;对于MD5值：2df51a84abc64a28740d6d2ae8cd7b16。我们可以根据MD5与向量互转规则，将MD5转成&lt;code&gt;md5($secretKey + &quot;test&quot;)&lt;/code&gt;的最终向量值（A'、B'、C'、D'）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A'=0x841af52d
B'=0x284ac6ab
C'=0x2a6d0d74
D'=0x167bcde8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907022130634-1069811156.png&quot; alt=&quot;例子向量运算过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候我们修改&lt;code&gt;$v1&lt;/code&gt;变量的内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;test&quot; + [0x80 + (0x0)*45] + [0x50 + 0x0*7] + &quot;abc&quot;
相当于:
&quot;test&quot; + padding数据 + 长度数据 + &quot;abc&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则上述过程则被延续成下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907022146849-733951368.png&quot; alt=&quot;延续运算过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而对于上述运算过程来说，我们知道了倒数第二个向量串的内容和最后一个数据块，这样一来，最终的MD5值我们也可以自己通过MD5算法计算出来了。&lt;/p&gt;
&lt;h2 id=&quot;拓展&quot;&gt;拓展&lt;/h2&gt;
&lt;p&gt;如同MD5算法那般分组后与向量运算的流程被统称为&lt;strong&gt;Merkle–Damgård&lt;/strong&gt;结构。&lt;/p&gt;
&lt;p&gt;而同样使用此结构的HASH算法还有：SHA1、SHA2等&lt;/p&gt;
&lt;h2 id=&quot;hashpump&quot;&gt;hashpump&lt;/h2&gt;
&lt;p&gt;hashpump是一个专门生成MD5长度拓展攻击payload的工具。&lt;/p&gt;
&lt;p&gt;Github仓库：&lt;a href=&quot;https://github.com/bwall/HashPump&quot;&gt;https://github.com/bwall/HashPump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;#Linux
git clone https://github.com/bwall/HashPump.git
apt-get install g++ libssl-dev
cd HashPump
make
make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装好之后在终端里输入hashpump，回车即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907022200584-1778753259.png&quot; alt=&quot;hashpump&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以之前的例子为例，使用hashpump生成payload：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907022210380-410045813.png&quot; alt=&quot;生成payload&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;故我们的EXP即为（&lt;code&gt;\x&lt;/code&gt;用&lt;code&gt;%&lt;/code&gt;代替）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/?str=test%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00P%00%00%00%00%00%00%00abc&amp;amp;sign=bac6cb2d585d2de3f5f48f2759d2e5a7
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功读取FLAG：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095571/202009/1095571-20200907021858145-1755395093.png&quot; alt=&quot;成功读取FLAG&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ctf&quot;&gt;CTF&lt;/h2&gt;
&lt;p&gt;相关CTF题可供练习：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[De1CTF2019]SSRFMe&lt;/li&gt;
&lt;li&gt;实验吧-让我进去&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实这个知识点确实不难，但是回看两年前的自己，那时候是真的完完全全看不懂看不明白，但是现在只花了十几分钟就可以说是掌握这个知识点了。原来我们不知不觉间也对知识的认知又提升了一个台阶，原先难如天书的内容现在看来也不过尔尔，原先看不到、接触不到的知识，现在也有信心能够去尝试去学习、去理解并掌握。学习本该如此，如攀登高山一般，只有开始攀登，才有机会看得到山脚下看不到的风景，也唯有不断攀登，才能看到更多更多风景。&lt;/p&gt;

</description>
<pubDate>Sun, 06 Sep 2020 18:23:00 +0000</pubDate>
<dc:creator>Yunen的博客</dc:creator>
<og:description>对于HASH长度拓展攻击的简单学习笔记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yunen/p/13624595.html</dc:identifier>
</item>
<item>
<title>被Spring坑了一把，查看源码终于解决了DataFlow部署K8s应用的问题 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/13624590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/13624590.html</guid>
<description>&lt;blockquote readability=&quot;2.9545454545455&quot;&gt;
&lt;p&gt;欢迎访问&lt;a href=&quot;https://www.pkslow.com/&quot;&gt;南瓜慢说 www.pkslow.com&lt;/a&gt;获取更多精彩文章！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Docker &amp;amp; Kubernetes相关文章：&lt;/code&gt;&lt;a href=&quot;https://www.pkslow.com/categories/container&quot;&gt;容器技术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于各种原因，团队的&lt;code&gt;Kubernetes&lt;/code&gt;被加了限制，必须在特定的&lt;code&gt;Node&lt;/code&gt;才可以部署。而之前没有指定，所以&lt;code&gt;Spring Cloud Data Flow&lt;/code&gt;在跑&lt;code&gt;Task&lt;/code&gt;时失败了，无法创建&lt;code&gt;Pod&lt;/code&gt;。按照&lt;code&gt;Spring&lt;/code&gt;官方文档配置也一直没用，后面查看源码、修改源码增加日志后终于解决了。&lt;/p&gt;

&lt;p&gt;在自己定义&lt;code&gt;yaml&lt;/code&gt;文件，并通过&lt;code&gt;kubectl apply&lt;/code&gt;部署时，所添加的限制节点的内容是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: beta.kubernetes.io/os
                    operator: In
                    values:
                      - linux
      containers:
        - name: php-apache
          image: 'pkslow/hpa-example:latest'
          ports:
            - containerPort: 80
              protocol: TCP
          resources:
            requests:
              cpu: 200m
          imagePullPolicy: IfNotPresent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样设置是可以成功部署的。&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;Data Flow&lt;/code&gt;的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;    spring:
      cloud:
        dataflow:
          task:
            platform:
              kubernetes:
                accounts:
                  default:
                    limits:
                      memory: 1024Mi
                    affinity:
                      nodeAffinity:
                        requiredDuringSchedulingIgnoredDuringExecution:
                          nodeSelectorTerms:
                            - matchExpressions:
                                - key: beta.kubernetes.io/os
                                  operator: In
                                  values:
                                    - linux
      datasource:
        url: jdbc:mysql://${MYSQL_SERVICE_HOST}:${MYSQL_SERVICE_PORT}/mysql
        username: root
        password: ${mysql-root-password}
        driverClassName: org.mariadb.jdbc.Driver
        testOnBorrow: true
        validationQuery: &quot;SELECT 1&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;Spring Cloud Data Flow&lt;/code&gt;发布&lt;code&gt;Task&lt;/code&gt;，报错如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Pods in namespace pkslow can only map to specific nodes, status=Failure
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看官网，按照&lt;a href=&quot;https://docs.spring.io/spring-cloud-dataflow/docs/2.5.3.RELEASE/reference/htmlsingle/#configuration-kubernetes-deployer&quot;&gt;官方的格式&lt;/a&gt;修改配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202009/946674-20200907020709234-416122410.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;    spring:
      cloud:
        dataflow:
          task:
            platform:
              kubernetes:
                accounts:
                  default:
                    limits:
                      memory: 1024Mi
                    affinity:
                      nodeAffinity: { requiredDuringSchedulingIgnoredDuringExecution: { nodeSelectorTerms: [ { matchExpressions: [ { key: 'beta.kubernetes.io/os', operator: 'In', values: [ 'linux']}]}]}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依旧报错。改成&lt;code&gt;affinity.nodeAffinity=xxx&lt;/code&gt;，还是报错。加引号，也没用。&lt;/p&gt;
&lt;p&gt;查看日志，也没有太多信息。&lt;/p&gt;
&lt;p&gt;折腾了许久，也没太大进展。于是就查看源码了。&lt;/p&gt;

&lt;h2 id=&quot;31-源码下载&quot;&gt;3.1 源码下载&lt;/h2&gt;
&lt;p&gt;下载了&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-dataflow&quot;&gt;Spring Cloud Data Flow&lt;/a&gt;的源码，看了一下，没有多大用处，最终发布到&lt;code&gt;Kubernetes&lt;/code&gt;是通过&lt;code&gt;Spring Cloud Deployer Kubernetes&lt;/code&gt;来发布的，于是又下载了&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-deployer-kubernetes&quot;&gt;它的源码&lt;/a&gt;。要注意不要下载错了版本，我们用的是&lt;code&gt;2.4.0&lt;/code&gt;版本。或者直接下载所有，然后切换到对应分支：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ git clone https://github.com/spring-cloud/spring-cloud-deployer-kubernetes.git
Cloning into 'spring-cloud-deployer-kubernetes'...
remote: Enumerating objects: 65, done.
remote: Counting objects: 100% (65/65), done.
remote: Compressing objects: 100% (46/46), done.
remote: Total 4201 (delta 26), reused 42 (delta 8), pack-reused 4136
Receiving objects: 100% (4201/4201), 738.79 KiB | 936.00 KiB/s, done.
Resolving deltas: 100% (1478/1478), done.

$ cd spring-cloud-deployer-kubernetes/

$ git branch
* master

$ git checkout 2.4.0
Branch '2.4.0' set up to track remote branch '2.4.0' from 'origin'.
Switched to a new branch '2.4.0'

$ git branch
* 2.4.0
  master
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先&lt;code&gt;build&lt;/code&gt;一下，确保成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ mvn clean install -DskipTests
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32-添加日志&quot;&gt;3.2 添加日志&lt;/h2&gt;
&lt;p&gt;查看源码，也看不出为何配置没有生效，于是在关键点打些日志出来看看。找到发布&lt;code&gt;Task&lt;/code&gt;的入口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;KubernetesTaskLauncher#launch(AppDeploymentRequest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即类&lt;code&gt;KubernetesTaskLauncher&lt;/code&gt;的&lt;code&gt;launch&lt;/code&gt;方法。开始追踪创建&lt;code&gt;Kubernetes Pod&lt;/code&gt;的过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;KubernetesTaskLauncher#launch(AppDeploymentRequest)
KubernetesTaskLauncher#launch(String, AppDeploymentRequest)
AbstractKubernetesDeployer#createPodSpec
DeploymentPropertiesResolver#getAffinityRules
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在整个调用链增加日志打印，注意日志要加上特殊字符串，增加识别性，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;logger.info(&quot;***pkslow log***:&quot; + affinity.toString());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;追加了日志后，重新&lt;code&gt;build&lt;/code&gt;包，替换掉&lt;code&gt;Data Flow&lt;/code&gt;引入的&lt;code&gt;jar&lt;/code&gt;包，重新发布即可测试。&lt;/p&gt;
&lt;p&gt;通过新加的日志，发现设置的&lt;code&gt;Properties&lt;/code&gt;一直就是没有生效的，但为何没生效尚未得知。&lt;/p&gt;

&lt;p&gt;折腾了一圈还是没解决，但项目又要急着使用，于是想了个办法，先修改源码，自己根据属性使其生效：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202009/946674-20200907020709668-881560956.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果没有读取到&lt;code&gt;Affinity&lt;/code&gt;，就自己生成一个。&lt;/p&gt;
&lt;p&gt;重新打包、替换、部署后，不再报错，能正常执行&lt;code&gt;Task&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;之前的方案只是暂时解决，并不是一个好的办法，还是要搞清楚为何配置没有生效。于是再次查看源码。在查看类&lt;code&gt;KubernetesDeployerProperties&lt;/code&gt;的时候，发现了一点端倪：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202009/946674-20200907020709914-1211743032.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的字段是没有&lt;code&gt;Affinity&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;另外，从测试用例入手（这是一个很好的思维，测试用例能告诉你很多信息），看到了&lt;code&gt;DataFlow&lt;/code&gt;配置用例，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202009/946674-20200907020710583-523802644.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，应该是不用配置前缀&lt;code&gt;Affinity&lt;/code&gt;的，修改后配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;spring:
  cloud:
    dataflow:
      task:
        platform:
          kubernetes:
            accounts:
              default:
                limits:
                  memory: 1024Mi
                nodeAffinity: { requiredDuringSchedulingIgnoredDuringExecution: { nodeSelectorTerms: [ { matchExpressions: [ { key: 'beta.kubernetes.io/os', operator: 'In', values: [ 'linux']}]}]}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新部署后，可以了！！！&lt;/p&gt;

&lt;p&gt;这一次确实是被&lt;code&gt;Spring&lt;/code&gt;坑了一把，没有明确给出配置的示例，然后官方文档给的提示也是极其误导。一开始很难想到是不用前缀&lt;code&gt;Affinity&lt;/code&gt;的，因为&lt;code&gt;Kubernetes&lt;/code&gt;的标准配置是有的，而&lt;code&gt;Spring&lt;/code&gt;的官方文档提示也是有的。实在太坑了！&lt;/p&gt;
&lt;p&gt;还好，通过查看源码及调试，终于解决了这个问题。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注微信公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202009/946674-20200907020710896-87366899.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Sep 2020 18:07:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 前言 欢迎访问南瓜慢说 www.pkslow.com获取更多精彩文章！ Docker &amp;amp;amp; Kubernetes相关文章：容器技术 基于各种原因，团队的Kubernetes被加了限制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/13624590.html</dc:identifier>
</item>
<item>
<title>简单介绍HTML5 Landmark - 卷卷子</title>
<link>http://www.cnblogs.com/jrjrzivvv/p/13624576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jrjrzivvv/p/13624576.html</guid>
<description>&lt;p&gt;最近在进行无障碍相关文档翻译的时候遇到了 &lt;code&gt;landmark&lt;/code&gt; 的概念，在网上搜了下发现没有相关的中文资料，因此写一篇博客简单介绍一下。&lt;/p&gt;
&lt;h3 id=&quot;什么是-landmark&quot;&gt;什么是 Landmark&lt;/h3&gt;
&lt;p&gt;Landmark 是一种用来表示网页组织结构的方法。通常一个网页可以被切分成几个大块&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090623032029.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdfd2VuX3d1,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;以一个视频网站为例，网页的最上方是一条banner，左侧是一个导航栏，右侧显示视频。网页可以通过这种切分方式来分割出不同的功能区。当然在一个功能区内也可以递归地进行切分，这里先不展开。&lt;br/&gt;对于一个视力障碍者，他无法像常人一样理解从视觉角度传达出的网页结构信息，那么就需要网页开发者预先将网页的结构规划好，并将结构信息写在HTML代码里，最终将网页的结构信息通过读屏软件表达出来。&lt;br/&gt;而landmark就是连接网页结构信息和读屏软件的桥梁。网页开发者通过landmark对网页区域进行标注，读屏软件读取landmark信息并传达给视力障碍者。&lt;/p&gt;
&lt;h3 id=&quot;如何使用-landmark&quot;&gt;如何使用 Landmark&lt;/h3&gt;
&lt;p&gt;事实上，在HTML5 landmark出现之前，就已经有landmark的概念了。&lt;br/&gt;landmark有以下几种&lt;code&gt;main，navigation，complementary，banner，contentinfo，form，region，search&lt;/code&gt;。通过使用&lt;code&gt;&amp;lt;div role=&quot;main&quot;&amp;gt;&lt;/code&gt;就定义了一个&lt;code&gt;main&lt;/code&gt; landmark。&lt;/p&gt;
&lt;p&gt;而在HTML5中定义了一些全新的标签，并赋予他们隐式的landmark语义。&lt;br/&gt;HTML5 Landmark主要有以下几种&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;HTML Element&lt;/th&gt;
&lt;th&gt;Landmark Role&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;main&amp;gt;&lt;/td&gt;
&lt;td&gt;main&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;nav&amp;gt;&lt;/td&gt;
&lt;td&gt;navigation&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;aside&amp;gt;&lt;/td&gt;
&lt;td&gt;complementary&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;header&amp;gt;&lt;/td&gt;
&lt;td&gt;banner&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;footer&amp;gt;&lt;/td&gt;
&lt;td&gt;contentinfo&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;form&amp;gt;&lt;/td&gt;
&lt;td&gt;form&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;section&amp;gt;&lt;/td&gt;
&lt;td&gt;region&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这些标签本身就隐含着landmark的含义，也就是说&lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;div role=&quot;main&quot;&amp;gt;&lt;/code&gt;是完全等价的。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;search&lt;/code&gt; landmark没有定义专用的HTML标签，通常使用&lt;code&gt;&amp;lt;form role=&quot;search&quot;&amp;gt;&lt;/code&gt;来实现。&lt;/p&gt;
&lt;p&gt;也就是说，在上一节引用的网页中&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于1号区域，应当把所有的内容放到一个&lt;code&gt;&amp;lt;header&amp;gt;&amp;lt;/header&amp;gt;&lt;/code&gt;中，标识该部分是banner&lt;/li&gt;
&lt;li&gt;对于2号区域，应当把所有的内容放到一个&lt;code&gt;&amp;lt;nav&amp;gt;&amp;lt;/nav&amp;gt;&lt;/code&gt;中，标识该部分是导航栏&lt;/li&gt;
&lt;li&gt;对于3号区域，应当把所有的内容放到一个&lt;code&gt;&amp;lt;main&amp;gt;&amp;lt;/main&amp;gt;&lt;/code&gt;中，标识该部分是网页的主要内容&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;读屏软件会生成一系列的跳转链接来帮助视力障碍者确定网页的结构并迅速跳转至需要的部分。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在HTML5之前，只能通过role属性来定义landmark，HTML5推出的新标签能够在保持可访问性的情况下简化标记。但并不是每个用户使用的辅助工具都支持最新的标准，因此许多教程推荐使用&lt;code&gt;&amp;lt;main role=&quot;main&quot;&amp;gt;&lt;/code&gt;的写法来同时兼容两种标准。W3C的标准不鼓励在已经含有隐式语义的情况下使用&lt;code&gt;role&lt;/code&gt;属性，因为两者语义冲突的情况下可能导致无法预计的表现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;区分同类型的-landmark&quot;&gt;区分同类型的 Landmark&lt;/h4&gt;
&lt;p&gt;有时候页面中可能会有多个导航栏，分别有不同的作用。比如一个电商网站有一个主导航来跳转到购物车、收藏夹等不同的页面；还有一个产品导航来跳转到电子产品、婴儿产品。如何对两者进行区分呢，这里需要使用&lt;code&gt;aria-label&lt;/code&gt;或者&lt;code&gt;aria-labelledby&lt;/code&gt;属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;nav aria-label=&quot;主导航&quot;&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;主页&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;购物车&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;收藏夹&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
        
&amp;lt;nav aria-label=&quot;产品导航&quot;&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;婴儿产品&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;电子产品&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;体育产品&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样读屏软件会分别生成以下两个链接&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导航，主导航&lt;/li&gt;
&lt;li&gt;导航，产品导航&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样就将不同的landmark区分开了。&lt;/p&gt;
&lt;h3 id=&quot;使用读屏软件读取-landmark&quot;&gt;使用读屏软件读取 Landmark&lt;/h3&gt;
&lt;p&gt;为了更好地理解landmark，我尝试使用读屏软件来测试网页上的landmark。这里我使用的是Windows系统自带的&lt;strong&gt;讲述人&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090701270621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdfd2VuX3d1,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;按下&lt;code&gt;Caps Lock + F5&lt;/code&gt;来显示网页中所有的landmark。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200907012904650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdfd2VuX3d1,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按下&lt;code&gt;Caps Lock + N&lt;/code&gt;，可以看到&lt;strong&gt;讲述人&lt;/strong&gt;光标移动到了网页的主要内容部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200907013242153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdfd2VuX3d1,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;D&lt;/code&gt;或&lt;code&gt;Shift + D&lt;/code&gt;可以在landmark间切换，同时会朗读出每个landmark的信息。&lt;br/&gt;这里可以看到有一个&lt;code&gt;search&lt;/code&gt; landmark，它在&lt;code&gt;banner&lt;/code&gt; landmark的内部，这就是landmark嵌套的情况。对于landmark嵌套有一系列的规则，感兴趣的读者可以自己了解。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;和单词的原意一样，landmark就像是一个网页的许多个“入口”或“地标”。通过landmark标注网页结构的信息，可以帮助视力障碍者通过读屏软件了解网页的结构，并迅速到达需要的部分。&lt;br/&gt;然而正如并非所有的读屏软件都支持HTML5 Landmark一样，并非所有视力障碍者都了解landmark的概念并知道如何使用landmark。因此提供传统的跳转链接来&lt;strong&gt;跳过导航直接跳转到内容&lt;/strong&gt;仍然是有必要的。&lt;/p&gt;
</description>
<pubDate>Sun, 06 Sep 2020 17:50:00 +0000</pubDate>
<dc:creator>卷卷子</dc:creator>
<og:description>最近在进行无障碍相关文档翻译的时候遇到了 landmark 的概念，在网上搜了下发现没有相关的中文资料，因此写一篇博客简单介绍一下。 什么是 Landmark Landmark 是一种用来表示网页组织</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jrjrzivvv/p/13624576.html</dc:identifier>
</item>
<item>
<title>vue-element-admin改造接入后台，搭建有来商城youlai-mall后台前端管理平台 - 你好，旧时光</title>
<link>http://www.cnblogs.com/fly4j/p/13624548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly4j/p/13624548.html</guid>
<description>&lt;h2 id=&quot;一-前言&quot;&gt;&lt;strong&gt;一. 前言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本篇基于&lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot;&gt;有来商城youlai-mall&lt;/a&gt; 微服务项目，搭建后台前端管理平台，技术选型希望通过本篇文章你可以,技术解决方案选择了vue-element-admin。希望通过本篇文章你可以vue-element-admin工程改造接入到自己的平台。&lt;/p&gt;
&lt;h2 id=&quot;二-工程改造&quot;&gt;&lt;strong&gt;二. 工程改造&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;1下载vue-element-admin&quot;&gt;&lt;strong&gt;1.下载vue-element-admin&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;下载 vue-element-admin的i18n分支版本，这样可以支持中文，地址：&lt;a href=&quot;https://github.com/PanJiaChen/vue-element-admin/tree/i18n,%E6%9C%AC%E6%AC%A1%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%BAv4.4.O%E3%80%82&quot;&gt;https://github.com/PanJiaChen/vue-element-admin/tree/i18n,本次下载的版本为v4.4.O。&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2启动项目&quot;&gt;&lt;strong&gt;2.启动项目&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;导入vue-element-admin至IDEA，执行npm install,如果安装慢或网络差的情况下请参考&lt;a href=&quot;https://www.cnblogs.com/fly4j/p/13618844.html&quot;&gt;安装cnpm设置npm淘宝镜像源&lt;/a&gt;这篇文章安装cnpm，然后执行cnpm install安装依赖包。&lt;/p&gt;
&lt;p&gt;依赖包安装完成之后，执行npm run dev本地启动项目,浏览器自动会打开平台网址&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/09/05/HtCs4ohOkFuTJKZ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3工程改造&quot;&gt;&lt;strong&gt;3.工程改造&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;vue-element-admin项目默认走的是本地mock接口数据，那怎么接入到自己平台的后台接口呢？。&lt;/p&gt;
&lt;h4 id=&quot;31-mock接口信息&quot;&gt;&lt;strong&gt;3.1 mock接口信息&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;先看下vue-element-admin登录进入平台所需要的接口信息，如下图所示，是有两个关键接口&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/09/05/ucY5IkPsVmCUjlp.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口一：/user/login 登录认证获取token&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
        &quot;code&quot;: 20000,
        &quot;data&quot;: {
                &quot;token&quot;: &quot;admin-token&quot;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口二：/user/info?token=admin-token 根据token获取用户信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
        &quot;code&quot;: 20000,
        &quot;data&quot;: {
                &quot;roles&quot;: [&quot;admin&quot;],
                &quot;introduction&quot;: &quot;I am a super administrator&quot;,
                &quot;avatar&quot;: &quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;,
                &quot;name&quot;: &quot;Super Admin&quot;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;32-后台接口信息&quot;&gt;&lt;strong&gt;3.2 后台接口信息&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;关于后台接口首先对&lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot;&gt;youlai-mall&lt;/a&gt;开源项目有些了解，这里因为篇幅不做过多的介绍，详情请拉取下项目，依次启动nacos-server,youlai-admin,youlai-auth,youlai-gateway，项目启动有啥问题请下方留言，见到第一时间会回复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口一：登录认证获取token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;youlai-mall整合SpringCloud Gateway+Spring Security OAuth2+JWT技术实现的登录认证接口，调用信息如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:9999/youlai-auth/oauth/token&quot;&gt;http://localhost:9999/youlai-auth/oauth/token&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/lwAdnyCQR1msMHc.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口二：获取用户信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:9999/youlai-admin/users/current&quot;&gt;http://localhost:9999/youlai-admin/users/current&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/LOZDoYMeAhI3gpF.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是两个接口的请求以及响应信息，暂先可以不用顾及其内部实现。本篇侧重接入后台youlai-mall，最好拉取youlai-mall代码在本地启动跑一下流程。&lt;/p&gt;
&lt;p&gt;如果想自定义接口，只要按照特定数据格式返回即可。&lt;/p&gt;
&lt;h4 id=&quot;33-vue-element-admin移除mock&quot;&gt;&lt;strong&gt;3.3 vue-element-admin移除mock&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. vue.config.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/Yx1QIfDUWX632nc.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至于为什么添加配置devServer.proxy进行代理转发?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为前后端分离，就算是本地开发，也会因为端口不同而满足 跨域请求条件的。&lt;/p&gt;
&lt;p&gt;一般跨域是浏览器禁止的，服务器端之间并不禁止跨域（可以配置禁止）。&lt;/p&gt;
&lt;p&gt;配置好代理之后，在项目启动时本地会启动一个node服务，浏览器先将请求发送到本地node服务，然后经由node服务将请求代理转发到后台服务器，这样就可以避开浏览器禁止跨域的问题。&lt;/p&gt;
&lt;p&gt;具体原理详情可参照：&lt;a href=&quot;https://segmentfault.com/q/1010000014042635#comment-area&quot;&gt;node中跨域代理 proxyTable的原理是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. src/main.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/w9FsNYau6xkdtrO.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;34-vue-element-admin接入后台接口&quot;&gt;&lt;strong&gt;3.4 vue-element-admin接入后台接口&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. src/api/user.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口URL替换：&lt;/strong&gt; 完成1,2步骤即移除了mock接入到了后台，修改登录认证和获取用户信息两个接口的后台请求路径，替换后如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/vhQHtCqgsWjU3kx.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. src/store/modules/user.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认证接口参数：&lt;/strong&gt; 首先看下登录入口: src/views/login/index.vue的handleLogin方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/SC5ZxsBLwpAjohf.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;this.$store.dispatch是Vuex状态管理中调用方式，具体操作是分发actions-&amp;gt;调用mutations-&amp;gt;改变state,其中action包含了异步操做，这是action与mutation的区别，也是dispatch和commit的区别。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// dispatch 异步操作 
this.$store.dispatch('actions的方法'，args)

// commit 同步操作
this.$store.commit('mutations的方法'，args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;明白this.$store.dispatch是做actions的分发，分发路径是/user/login，找到user模块文件src/store/modules/user.js，在文件中actions找到login方法，详情如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/T7DVdF235L94vqg.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比3.2后台接口，发现OAuth2认证还少了3个参数：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数值&lt;/th&gt;
&lt;th&gt;参数名&lt;/th&gt;
&lt;th&gt;参数描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;grant_type&lt;/td&gt;
&lt;td&gt;password&lt;/td&gt;
&lt;td&gt;OAuth2授权方式：密码式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;client_id&lt;/td&gt;
&lt;td&gt;client&lt;/td&gt;
&lt;td&gt;客户端ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;client_secret&lt;/td&gt;
&lt;td&gt;123456&lt;/td&gt;
&lt;td&gt;客户端密钥&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;补全参数后如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/9Arnx5RYgOUaS34.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.src/utils/request.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改数据上传默认为JSON格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;axios.defaults.headers['Content-Type'] = 'application/json;charset=utf-8'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/3fGcUoeNxl9gQWF.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改请求头&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/B13UYfQoKwIyn87.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改成功响应状态码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/eJRk5DC7vTI9qai.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;35-接入后台登录测试&quot;&gt;&lt;strong&gt;3.5 接入后台登录测试&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/AOfjnaIHcevJ2Br.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/RKOG1LMSVgb8ltE.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/pN7gl8c2GBT1IRb.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里就完成了vue-element-admin移除mock接入到后台的功能&lt;/p&gt;
&lt;h2 id=&quot;三-搭建有来商城管理平台&quot;&gt;&lt;strong&gt;三. 搭建有来商城管理平台&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过上面步骤，我们已成功改造vue-element-admin接入到后台接口，接下来我们以管理平台的用户管理功能为例讲述如何使用vue-element-admin搭建我们自己的管理平台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 删除多余文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mock文件夹删除&lt;/p&gt;
&lt;p&gt;views下除了dashboard、error-page、login、profile、redirect之外的文件夹全部删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 引入用户管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新增user.js接口、user/index.vue用户页面，完整代码文章结尾获取，结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/ungMFHJqt6KTvoD.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 路由配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改路由配置文件 src/router/index.js，其中有静态路由constantRoutes和权限路由asyncRoutes需要修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态路由删减保留如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export const constantRoutes = [
  {
    path: '/redirect',
    component: Layout,
    hidden: true,
    children: [
      {
        path: '/redirect/:path(.*)',
        component: () =&amp;gt; import('@/views/redirect/index')
      }
    ]
  },
  {
    path: '/login',
    component: () =&amp;gt; import('@/views/login/index'),
    hidden: true
  },
  {
    path: '/auth-redirect',
    component: () =&amp;gt; import('@/views/login/auth-redirect'),
    hidden: true
  },
  {
    path: '/404',
    component: () =&amp;gt; import('@/views/error-page/404'),
    hidden: true
  },
  {
    path: '/401',
    component: () =&amp;gt; import('@/views/error-page/401'),
    hidden: true
  },
  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    children: [
      {
        path: 'dashboard',
        component: () =&amp;gt; import('@/views/dashboard/index'),
        name: 'Dashboard',
        meta: { title: 'Dashboard', icon: 'dashboard', affix: true }
      }
    ]
  },
  {
    path: '/profile',
    component: Layout,
    redirect: '/profile/index',
    hidden: true,
    children: [
      {
        path: 'index',
        component: () =&amp;gt; import('@/views/profile/index'),
        name: 'Profile',
        meta: { title: 'Profile', icon: 'user', noCache: true }
      }
    ]
  }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;权限路由删减，并新增用户管理路由如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export const asyncRoutes = [
  {
    path: '/admin',
    component: Layout,
    redirect: '/admin/user',
    alwaysShow: true, // will always show the root menu
    name: 'Admin',
    meta: {
      title: '系统管理',
      icon: 'documentation',
      roles: ['admin', 'editor'] // you can set roles in root nav
    },
    children: [
      {
        path: 'user',
        component: () =&amp;gt; import('@/views/admin/user'),
        name: 'User',
        meta: {
          title: '用户管理',
          roles: ['admin'] // or you can only set roles in sub nav
        }
      }
    ]
  },
  // 404 page must be placed at the end !!!
  { path: '*', redirect: '/404', hidden: true }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. 验证用户管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行npm run dev再次打开系统，登录后界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/07/GKQW3xMBStyFa5b.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，管理平台中的用户管理已成功集成到我们改造后的vue-element-admin工程，其他功能搭建按照同样方法即可。&lt;/p&gt;
&lt;h2 id=&quot;四-结语&quot;&gt;&lt;strong&gt;四. 结语&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本篇就如何改造vue-element-admin接入到后台实现youlai-mall后台前端管理平台的搭建。其中涉及的前后端分离解决浏览器跨域问题的解决原理，vuex、vue-router的应用，觉得很有意义去亲手实践一下，如果有问题下方留言即可。最后附上完整代码下载地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;youlai-mall&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui/youlai-mall-admin-web.git&quot;&gt;youlai-mall-admin-web&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 Sep 2020 17:11:00 +0000</pubDate>
<dc:creator>你好，旧时光</dc:creator>
<og:description>一. 前言 本篇基于有来商城youlai-mall 微服务项目，搭建后台前端管理平台，技术选型希望通过本篇文章你可以,技术解决方案选择了vue-element-admin。希望通过本篇文章你可以vue</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fly4j/p/13624548.html</dc:identifier>
</item>
</channel>
</rss>