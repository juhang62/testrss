<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2020 年 中国.NET开发者调查报告 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/12355503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/12355503.html</guid>
<description>&lt;p&gt;微信公众号dotnet跨平台2020年初做的一个关于&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/12116317.html&quot;&gt;中国.NET开发者调查&lt;/a&gt;收到了开发者近 1400 条回复。这份调查报告涵盖了开发者工具链的所有部分，包括编程语言、应用架构、应用服务器、运行时平台、框架技术、框架配置、IDE、.NET/.NET Core 发行版部署模式、构建工具和Kubernetes。&lt;/p&gt;
&lt;h3&gt;.NET发展面临的挑战&lt;/h3&gt;
&lt;p&gt;这是一个多选题，认为.NET向.NET Core升级的挑战只有25.3%， 然而有89.9% 的受访者表示，国内缺乏大的互联网厂商采用.NET Core 是最大的挑战，从2010年以来的移动互联网浪潮由于微软的战略失误，.NET技术从.NET 4以来缺乏创新，国内大的互联网厂商京东、携程等相继转Java 所带来的影响很大。但是很多人忽略了一个重要的方面是从2015年开始的云计算浪潮，云原生应用开发的崛起。微软从2014年开始的重大转型，成功把握了云计算浪潮，特别是云原生应用开发上微软有着清晰的领导者，从Azure的崛起以及云原生的参与度上，特别是从2016年正式发布的.NET Core 在云原生方面发生了蜕变，从后面的一项Kubernetes和Docker的采用上可以说明大家对.NET Core的采用上没有足够的认识，再说互联网厂商采用.NET Core方面也要换个角度来看，从2018年开发国内BAT等互联网厂商大量开始转型企业服务市场，我们来看下在这个新的方向上的互联网厂商采用.NET Core情况，国内新能源领域头部企业特来电采用.NET Core, 国内房地产信息化系统服务商头部企业明源云采用.NET Core, 在线教育头部企业校宝在线采用.NET Core.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084005418-324848383.jpg&quot;&gt;&lt;img width=&quot;605&quot; height=&quot;375&quot; title=&quot;clip_image002&quot; alt=&quot;clip_image002&quot; src=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084005887-1551130716.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对我们来说，传统的互联网厂商没有采用.NET Core不是最重要的，特别BAT都在搞公有云等面向企业服务，Azure、AWS、GCP对.NET Core的支持一等公民，需要阿里云、腾讯云、华为云等国内云厂商更好的对.NET Core有更大的支持。&lt;/p&gt;
&lt;h3&gt;.NET/.NET Core 版本&lt;/h3&gt;
&lt;p&gt;58% 的受访者表示，他们在主要应用程序中选择 .NET Core 作为编程平台，大部分计划升级到.NET Core 3.1。而.NET 4.6之前的版本 以 21% 的受访者位居第二。11.1% 的受访者表示使用 .NET 4.6,也没有升级到.NET Core 版本计划。这里要给大家普及一下.NET 5, 很多对.NET 5有误解是大融合，认为.NET 4版本在.NET 5出来后可以轻松的升级。这是一个巨大的认识错误，.NET 5是.NET Core 3.1 之后的一个大版本，他本质上是.NET 5, 从.NET Core 3.1开始，.NET Core都支持.NET FX的工作负载了（最典型的就是桌面Winform/WPF/UWP支持）， .NET 4应用需要升级到.NET 5必须向.NET Core的迁移，所以如果你有应用迁移计划，现在就可以做规划了，而不是等上一年为自己的无知买单。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084006208-1715280589.jpg&quot;&gt;&lt;img width=&quot;599&quot; height=&quot;453&quot; title=&quot;clip_image004&quot; alt=&quot;clip_image004&quot; src=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084006518-1704590306.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对我们来说，看到 .NET Core 3.1成为占主导地位的编程平台，并不是一件令人惊讶的事情。然而，令人惊讶的是，还有 32.4% 的受访者使用 .NETFX 4。我们认为，这与大家缺乏对.NET发展的正确认识和更新 .NET应用的成本有关。 对于仍在使用 .NET 4.6 或更早版本的受访者，我们预计，随着越来越多的应用程序继续迁移到.NET Core 3.1 或今年即将到来的.NET 5版本，这一数字将会减少。&lt;/p&gt;
&lt;h3&gt;微服务框架选择&lt;/h3&gt;
&lt;p&gt;这个问题要求受访者选择在他们的主要项目中使用的应用程序框架和技术。由于大多数应用程序使用各种不同的框架技术，因此这个问题允许多个回答。在调查的第9和第10问题里，很多人表达希望有一个.NET 上的Spring Cloud，然而只有5.7%的人选择了Steeltoe/Spring Cloud，这也许是大家对Steeltoe这个开源项目缺乏了解，Steeltoe是Spring Cloud的厂商Pivot 开源的Spring cloud的.NET解决方案，同时它也是.NET基金会下的开源项目，在github开源，star数却只有215，这正说明了大家对它缺乏认识，这几年开源社区的蓬勃发展，.NET社区有个开发框架ABP也拥有了大量的用户，特别是在中国的用户特别多，ABP vNext正是ABP框架针对单体模块化/微服务场景发展的框架，搭配kuberentes 非常适合微服务的开发，目前已经正式发布2.1.1版本，用7.6%的受访者选择了ABP vNext/Kubernetes, 37.8% 的受访者选择了.NET Core/Kubernetes, 采用kuberentes的受访者达到了45.4%，还有25.9%的受访者选择了自研框架，这部分自研框架的用户是很希望有SpringCloud，而采取的自研。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084006763-784627850.jpg&quot;&gt;&lt;img width=&quot;597&quot; height=&quot;389&quot; title=&quot;clip_image006&quot; alt=&quot;clip_image006&quot; src=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084007022-1090555665.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对我们来说，.NET Core在云原生时代拥有独特优势，镜像体积小、占用内存少，启动速度快，支持水平扩展，Kubernetes为.NET Core的微服务开发方面提供特别的机会，特别2020年Service Mesh的成熟，.NET Core的采用方面有新的发展。&lt;/p&gt;
&lt;h3&gt;.NET开发工具&lt;/h3&gt;
&lt;p&gt;在这个问题中，我们要求开发者列出他们专业使用的集成开发环境（Integrated Development Environment，IDE）。就在几年前，开发者还会质疑在 IDE 上花钱是否值得。由于大多数人使用几个不同的IDE，因此这个问题允许多个回答。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084007303-200355320.jpg&quot;&gt;&lt;img width=&quot;592&quot; height=&quot;394&quot; title=&quot;clip_image008&quot; alt=&quot;clip_image008&quot; src=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084007592-440726489.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，有 96.2% 的受访者表示他们使用Visual Studio，很明显，这个付费的 IDE 非常值得一试。第二个最常用的 IDE 是 Visual Studio Code，占 31.5%，而 JetBrains Rider 占 5.2%。最后，有 4.8% 的受访者表示，使用Visual Studio for Mac。这说明大部分人都是使用高生产率的Visual Studio 为主，其他的IDE工具为辅。&lt;/p&gt;
&lt;h3&gt;数据库访问技术ORM&lt;/h3&gt;
&lt;p&gt;在这个问题中，我们要求受访者选择他们当前使用的数据库访问技术ORM。最受欢迎的是 EntityFramework Core，占 44.7%，紧随其后的是Dapper，占 42.1%。接下来是 EntityFramework 6，有 32% 的受访者报告了使用情况。NHibernetes在受访者中只有3.1%，还不如这两年国内的新星FreeSql，在受访者中占 4%。国内还有另外一个类似于Java国内最流行的MyBatis的SmartSql ，在受访者中有2.1%。还有20.8%的受访者使用了其他的ORM或者是直接使用ADO.NET.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084007903-1852962149.jpg&quot;&gt;&lt;img width=&quot;604&quot; height=&quot;474&quot; title=&quot;clip_image010&quot; alt=&quot;clip_image010&quot; src=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084008208-1908856386.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;开发的软件类型&lt;/h3&gt;
&lt;p&gt;在这个问题中，我们要求开发者列出他们开发的软件类型，通常开发者会开发多种类型的应用程序，这个选项也是多选项，企业级应用和互联网应用位居前列，特别是企业级应用占比达到了66.2%，这和我们一直认为.NET 在企业级应用市场有很大的应用，随着互联网技术的发展，企业级应用市场也要互联网化，这也是.NET 开发的机会和挑战。 桌面客户端应用的受访占比是24.2%，移动应用客户端开发占比15.5%， 这里有一项比较意外的是游戏占比只有2.4%, 然而很多人的印象中游戏是.NET 开发非常优势的领域。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084008576-1476383296.jpg&quot;&gt;&lt;img width=&quot;614&quot; height=&quot;489&quot; title=&quot;clip_image012&quot; alt=&quot;clip_image012&quot; src=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084008875-1307291822.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;容器化&lt;/h3&gt;
&lt;p&gt;在这两个问题中，我们询问了开发者他们使用哪些容器化工具。到目前为止，使用 Docker的比率只有38.7% 。而61.3%的受访者都没有使用Docker，已经采用Kubernetes 的受访者只有11.7%，目前没有使用，正计划使用Kubernetes的受访者达到了37.6%，这表明 Kubernetes 在2020年会有持续的增长。没有计划使用Kubernetes的受访者达到了47.7%，这也是一个很意外的结果，我们认为很多人对Kubernetes 有认识误区，容器化不在于你的团队的规模大小，而且对于小团队来说，Kubernetes是加速你应用现代化的武器，每一个公有云厂商都提供了近乎免费的Kubernetes服务，使用Kubernetes的门槛非常低，这也是采用.NET Core的优势所在，很多人错误的认为需要自己搭建Kubernetes集群，对于搭建Kubernetes集群这件事情是很复杂的，需要有专门的Kubernetes运营团队在支撑，这对于大型企业来说是没问题的，也值得投资,博客园在kubernetes 方面的探索的很多经验也值得你借鉴。利用Kuberentes，我们不会被任何云厂商锁定。随着 Kubernetes 的发展，它在未来几年将在市场上占主导地位也就不足为奇了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084009209-1063485312.jpg&quot;&gt;&lt;img width=&quot;621&quot; height=&quot;690&quot; title=&quot;clip_image014&quot; alt=&quot;clip_image014&quot; src=&quot;https://img2018.cnblogs.com/blog/510/202002/510-20200224084009497-2061645909.jpg&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9和10两个调查是开放性问题，在于汇集大家的意见，具体参看调查数据：【腾讯文档】2020中国.NET开发者调查 &lt;a href=&quot;https://docs.qq.com/sheet/DWElLTkx5YUVMWnFn?c=L456L0PE0&quot;&gt;https://docs.qq.com/sheet/DWElLTkx5YUVMWnFn?c=L456L0PE0&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;云原生对开发者在应用程序开发过程中使用的技术带来了深远的影响。而且，随着公司继续转型并创建基于微服务的应用程序，我们预计技术选择将趋向于促进架构和在其中工作的开发人员的需求。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Feb 2020 00:40:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>微信公众号dotnet跨平台2020年初做的一个关于中国.NET开发者调查收到了开发者近 1400 条回复。这份调查报告涵盖了开发者工具链的所有部分，包括编程语言、应用架构、应用服务器、运行时平台、框</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/12355503.html</dc:identifier>
</item>
<item>
<title>Nginx-2.初学者使用 - Sheldon_Lou</title>
<link>http://www.cnblogs.com/sheldon-lou/p/12355171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheldon-lou/p/12355171.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://nginx.org/en/docs/beginners_guide.html&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nginx有一个master进程和几个worker进程。master进程用来读取和评估配置文件，以及维护worker进程。worker进程用来处理实际的请求。Nginx使用事件模型和基于操作系统的逻辑来实现高效的worker处理进程。worker进程的数量可以定义到配置文件中，或者根据cpu核心数来自动调节。&lt;/p&gt;
&lt;p&gt;默认配置文件&lt;code&gt;nginx.conf&lt;/code&gt;，默认地址&lt;code&gt;nginx/conf&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;启动停止重新加载配置文件&quot;&gt;启动，停止，重新加载配置文件&lt;/h3&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nginx -s signal&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;signal&lt;/code&gt;可以是以下几个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stop 快速停止&lt;/li&gt;
&lt;li&gt;quit 优雅停止&lt;/li&gt;
&lt;li&gt;reload 重新加载配置文件&lt;/li&gt;
&lt;li&gt;reopen 重新打开配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;demo：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;nginx -s quit #优雅的停止。和启动的用户必须是同一个。
nginx -s reload #改了配置文件要重洗加载生效。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nginx收到reload信号之后，master进程会检查配置文件，如果没有过，回滚配置，继续使用旧的配置文件。如果过了，会先生成一个新的worker进程，然后给老的worker进程发送信号。老的worker进程收到消息会停止接收新的连接，但是会执行完已经存在的连接，最后退出。&lt;/p&gt;
&lt;p&gt;Unix系统的&lt;code&gt;kill&lt;/code&gt;命令也可以用来发送signal给nginx。假设nginx的master进程id是1628，使用下面格式&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kill -QUIT 1628&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ps&lt;/code&gt;用来看所有的nginx进程&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ps -ax | grep nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件的结构&quot;&gt;配置文件的结构&lt;/h3&gt;
&lt;p&gt;nginx的模块（功能）通过配置文件的指令来控制。指令分为&lt;code&gt;简单指令&lt;/code&gt;和&lt;code&gt;块指令&lt;/code&gt;。&lt;code&gt;简单指令&lt;/code&gt;由指令名和参数构成，中间用空格分隔，以分号结尾。&lt;code&gt;块指令&lt;/code&gt;由指令名后跟&lt;code&gt;{}&lt;/code&gt;构成。&lt;/p&gt;
&lt;p&gt;如果一个指令块可以包含其他指令，这个就是一个Context，比如 &lt;code&gt;events&lt;/code&gt;，&lt;code&gt;http&lt;/code&gt;，&lt;code&gt;server&lt;/code&gt;，&lt;code&gt;location&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;配置文件最外层的指令叫&lt;code&gt;main context&lt;/code&gt;。比如&lt;code&gt;events&lt;/code&gt; 和 &lt;code&gt;http&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;# 表示注释。&lt;/p&gt;
&lt;p&gt;简单来说，一个配置文件要一个http，包含一个server，server包含一个location就可以了。&lt;/p&gt;
&lt;h3 id=&quot;为静态内容提供服务&quot;&gt;为静态内容提供服务&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;server&lt;/code&gt;块指令里面&lt;code&gt;listen&lt;/code&gt;和&lt;code&gt;server_name&lt;/code&gt;指令来判断具体的server。然后再根据里面的&lt;code&gt;location&lt;/code&gt;指令块的参数来判断。&lt;/p&gt;
&lt;p&gt;先定义一个&lt;code&gt;http&lt;/code&gt;指令块。&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;http{
  server{
    listen 8080;#可以写127.0.0.1:8080等
    server_name localhost;#域名
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;server&lt;/code&gt;里面放&lt;code&gt;location&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;location / {
  root /data/www;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求匹配location的/地址，把后面的内容加到root指令参数&quot;/data/www&quot;后面，可以指向到物理地址。如果有多个匹配，nginx会选最长的。&lt;/p&gt;
&lt;p&gt;比如再加一个&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;location /images/ {
  root /data;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么images的匹配会到后面这个。&lt;/p&gt;
&lt;p&gt;改完之后&lt;code&gt;reload&lt;/code&gt;生效配置文件。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;nginx -s reload&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置一个简单的代理服务器&quot;&gt;设置一个简单的代理服务器&lt;/h3&gt;
&lt;p&gt;设置两个nginx实例。&lt;/p&gt;
&lt;p&gt;第一个&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
  listen 8080;
  root /data/up1;
  
  location / {
    
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有8080的请求都会到&lt;code&gt;/data/up1&lt;/code&gt;下面。&lt;/p&gt;
&lt;p&gt;第二个&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
  location / {
    proxy_pass http://localhost:8080;
  }
  location ~ \.(gif|jpg|png)&amp;amp; {
    root /data/images;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过正则（正则表达式必须以~和空格开头）匹配gif等图片文件，请求映射到/data/images目录下，其他的通过&lt;code&gt;proxy_pass&lt;/code&gt;指令代理到localhost:8080下面。&lt;/p&gt;
&lt;h3 id=&quot;设置一个fastcgi代理&quot;&gt;设置一个FastCGI代理&lt;/h3&gt;
&lt;blockquote readability=&quot;4.0882352941176&quot;&gt;
&lt;p&gt;CGI(Common Gateway Interface) is an interface specification for &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_server&quot;&gt;web servers&lt;/a&gt; to execute programs that execute like &lt;a href=&quot;https://en.wikipedia.org/wiki/Console_application&quot;&gt;console applications&lt;/a&gt; (also called &lt;a href=&quot;https://en.wikipedia.org/wiki/Command-line_interface&quot;&gt;command-line interface programs&lt;/a&gt;) running on a &lt;a href=&quot;https://en.wikipedia.org/wiki/Server_(computing)&quot;&gt;server&lt;/a&gt; that &lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_web_page&quot;&gt;generates web pages dynamically&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;nginx 可以把请求路由转发到一些比如php写的框架服务上。基本的用法是使用&lt;code&gt;fastcgi_pass&lt;/code&gt;指令替换&lt;code&gt;proxy_pass&lt;/code&gt;指令。然后用&lt;code&gt;fastcgi_param&lt;/code&gt;来设置需要的转发的参数。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
  location / {
    fastcgi_pass localhost:9000;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    fastcgi_param QUERY_STRING $query_string;
  }
  location ~ \.(gif|jpg|png)$ {
    root /data/images;
  }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 24 Feb 2020 00:39:00 +0000</pubDate>
<dc:creator>Sheldon_Lou</dc:creator>
<og:description>&amp;quot;原文&amp;quot; Nginx有一个master进程和几个worker进程。master进程用来读取和评估配置文件，以及维护worker进程。worker进程用来处理实际的请求。Nginx使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sheldon-lou/p/12355171.html</dc:identifier>
</item>
<item>
<title>你应该了解的 Java SPI 机制 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/12355485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/12355485.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/202002/1431471-20200224082019727-1507668788.jpg&quot; alt=&quot;cicada8-spi.md---0082zybply1gc6rp5ur8fj30u00u0tf7.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;不知大家现在有没有去公司复工，我已经在家办公将近 3 周了，同时也在家呆了一个多月；还好工作并没有受到任何影响，我个人一直觉得远程工作和 IT 行业是非常契合的，这段时间的工作效率甚至比在办公室还高，同时由于我们公司的业务在海外，所以疫情几乎没有造成太多影响。&lt;/p&gt;
&lt;p&gt;扯远了，这次主要是想和大家分享一下 &lt;code&gt;Java&lt;/code&gt; 的 &lt;code&gt;SPI&lt;/code&gt; 机制。周末没啥事，我翻了翻我之前的写的博客 &lt;a href=&quot;https://crossoverjie.top/2018/11/15/wheel/cicada6/&quot;&gt;《设计一个可拔插的 IOC 容器》&lt;/a&gt;，发现当时的实现并不那么优雅。&lt;/p&gt;
&lt;p&gt;还没看过的朋友的我先做个前景提要，当时的需求：&lt;/p&gt;
&lt;blockquote readability=&quot;5.7707006369427&quot;&gt;
&lt;p&gt;我实现了一个类似于的 SpringMVC 但却很轻量的 http 框架 &lt;a href=&quot;https://github.com/TogetherOS/cicada/&quot;&gt;cicada&lt;/a&gt;，其中当然也需要一个 IOC 容器，可以存放所有的单例 bean。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这个 IOC 容器的实现我希望可以有多种方式，甚至可以提供一个接口供其他人实现；当然切换这个 IOC 容器的过程肯定是不能存在硬编码的，也就是这里所提到的&lt;strong&gt;可拔插&lt;/strong&gt;。&lt;br/&gt;当我想使用 A 的实现方式时，我就引入 A 的 jar 包，使用 B 时就引入 B 的包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/202002/1431471-20200224082021585-677639139.jpg&quot; alt=&quot;cicada8-spi.md---0082zybply1gc6sqv3gp4j30zm0u0n8c.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先给大家看看两次实现的区别，先从代码简洁程度来说就是 &lt;code&gt;SPI&lt;/code&gt; 更胜一筹。&lt;/p&gt;

&lt;p&gt;在具体分析之前还是先了解下 &lt;code&gt;SPI&lt;/code&gt; 是什么？&lt;/p&gt;
&lt;p&gt;首先它其实是 &lt;code&gt;Service provider interface&lt;/code&gt; 的简写，翻译成中文就是服务提供发现接口。&lt;/p&gt;
&lt;p&gt;不过这里不要被这个名词搞混了，这里的&lt;code&gt;服务发现&lt;/code&gt;和我们常听到的微服务中的服务发现并不能划等号。&lt;/p&gt;
&lt;p&gt;就如同上文提到的对 &lt;code&gt;IOC&lt;/code&gt; 容器的多种实现方式 A、B、C（可以把它们理解为服务），我需要在运行时知道应该使用哪一种具体的实现。&lt;/p&gt;
&lt;p&gt;其实本质上来说这就是一种典型的面向接口编程，这一点在我们刚开始学习编程的时候就被反复强调了。&lt;/p&gt;

&lt;p&gt;接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。&lt;/p&gt;
&lt;p&gt;既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/202002/1431471-20200224082022637-1353723602.jpg&quot; alt=&quot;cicada8-spi.md---0082zybply1gc6tlhql39j31490u0wjj.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中包含了一些 &lt;code&gt;Bean&lt;/code&gt; 容器所必须的操作：注册、获取、释放 bean。&lt;/p&gt;
&lt;p&gt;为了让其他人也能实现自己的 &lt;code&gt;IOC&lt;/code&gt; 容器，所以我们将这个接口单独放到一个 &lt;code&gt;Module&lt;/code&gt; 中，可供他人引入实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/202002/1431471-20200224082023030-1522160147.jpg&quot; alt=&quot;cicada8-spi.md---0082zybply1gc6tobsdgwj30u40ewdh1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以当我要实现一个单例的 &lt;code&gt;IOC&lt;/code&gt; 容器时，我只需要新建一个 &lt;code&gt;Module&lt;/code&gt; 然后引入刚才的模块并实现 &lt;code&gt;CicadaBeanFactory&lt;/code&gt; 接口即可。&lt;/p&gt;
&lt;p&gt;当然其中最重要的则是需要在 &lt;code&gt;resources&lt;/code&gt; 目录下新建一个 &lt;code&gt;META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory&lt;/code&gt; 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/202002/1431471-20200224082023355-955929494.jpg&quot; alt=&quot;cicada8-spi.md---0082zybply1gc6ts164zlj30uk0amq3x.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的内容便是我们自己实现类的全限定名：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;top.crossoverjie.cicada.bean.ioc.CicadaIoc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以想象最终会通过这里的全限定名来反射创建对象。&lt;/p&gt;
&lt;p&gt;只不过这个过程 Java 已经提供 API 屏蔽掉了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static CicadaBeanFactory getCicadaBeanFactory() {
        ServiceLoader&amp;lt;CicadaBeanFactory&amp;gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);
        if (cicadaBeanFactories.iterator().hasNext()){
            return cicadaBeanFactories.iterator().next() ;
        }

        return new CicadaDefaultBean();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;classpath&lt;/code&gt; 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 &lt;code&gt;java.util.ServiceLoader&lt;/code&gt; 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;一些都准备好之后，使用自然就非常简单了。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;top.crossoverjie.opensource&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;cicada-ioc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。&lt;/p&gt;
&lt;p&gt;这样就做到了不修改一行代码灵活的&lt;code&gt;可拔插&lt;/code&gt;选择 &lt;code&gt;IOC&lt;/code&gt; 容器了。&lt;/p&gt;

&lt;p&gt;虽然平时并不会直接使用到 SPI 来实现业务，但其实我们使用过的绝大多数框架都会提供 SPI 接口方便使用者扩展自己的功能。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;Dubbo&lt;/code&gt; 中提供一系列的扩展：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/202002/1431471-20200224082023678-81198385.jpg&quot; alt=&quot;cicada8-spi.md---0082zybply1gc6ue6zubvj30gq0pymyq.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同类型的 &lt;code&gt;RPC&lt;/code&gt; 框架 &lt;code&gt;motan&lt;/code&gt; 中也提供了响应的扩展：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/202002/1431471-20200224082024260-668528792.jpg&quot; alt=&quot;cicada8-spi.md---0082zybply1gc6ufacqt5j30lm0j8q5j.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他们的使用方式都和 Java SPI 非常类似，只不过原理略有不同，同时也新增了一些功能。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;motan&lt;/code&gt; 的 &lt;code&gt;spi&lt;/code&gt; 允许是否为单例等等。&lt;/p&gt;
&lt;p&gt;再比如 MySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/202002/1431471-20200224082024632-1759220718.jpg&quot; alt=&quot;cicada8-spi.md---0082zybply1gc6uqg2ga2j30ii0bmdgz.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 自身的 &lt;code&gt;SPI&lt;/code&gt; 其实也有点小毛病，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;遍历加载所有实现类效率较低。&lt;/li&gt;
&lt;li&gt;当多个 &lt;code&gt;ServiceLoader&lt;/code&gt; 同时 &lt;code&gt;load&lt;/code&gt; 时会有并发问题（虽然没人这么干）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后总结一下，&lt;code&gt;SPI&lt;/code&gt; 并不是某项高深的技术，本质就是面向接口编程，而面向接口本身在我们日常开发中也是必备技能，所以了解使用 &lt;code&gt;SPI&lt;/code&gt; 也是很用处的。&lt;/p&gt;
&lt;p&gt;本文所有源码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/TogetherOS/cicada&quot; class=&quot;uri&quot;&gt;https://github.com/TogetherOS/cicada&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Feb 2020 00:20:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前言 不知大家现在有没有去公司复工，我已经在家办公将近 3 周了，同时也在家呆了一个多月；还好工作并没有受到任何影响，我个人一直觉得远程工作和 IT 行业是非常契合的，这段时间的工作效率甚至比在办公室</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/12355485.html</dc:identifier>
</item>
<item>
<title>上周 GitHub 热点速览 vol.08：系统设计必看 The System Design Primer - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12353135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12353135.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182310585-900389980.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：GitHub Trending 上周看点，老项目依旧抢眼，系统设计必看 Repo：The System Design Primer 周获 1k+ star，而新开源的项目 Real-Time-Person-Removal 表现也不俗，开源当周 star 过 2k+，至于本周 Trending 的周主题 #机器学习# 项目 star 增涨也是蹭蹭蹭…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自上周微博的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间超过 30 天的项目一律称之为成熟稳重老项目，由于文章篇幅问题还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;可怕 GitHub 新生&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 日获 2k+ star GitHub 热门：1 on 1 Meeting Questions&lt;/li&gt;
&lt;li&gt;1.2 防窃听玩具：wearable-microphone-jamming&lt;/li&gt;
&lt;li&gt;1.3 SIMD几何代数库：Klein&lt;/li&gt;
&lt;li&gt;1.4 7 天系列：7days-golang&lt;/li&gt;
&lt;li&gt;1.5 万能 Excel：computer-vision-basics-in-microsoft-excel&lt;/li&gt;
&lt;li&gt;1.6 Duang 人不见了：Real-Time-Person-Removal&lt;/li&gt;
&lt;li&gt;1.7 视频工具：Waifu2x-Extension-GUI&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;尚能星否 GitHub 老项目&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1命令行的艺术：the-art-of-command-lines&lt;/li&gt;
&lt;li&gt;2.2 全能：The System Design Primer&lt;/li&gt;
&lt;li&gt;2.3 笔记工具：Joplin&lt;/li&gt;
&lt;li&gt;2.4 代码查看工具：Sourcegraph&lt;/li&gt;
&lt;li&gt;2.5 前端神器：Playwright&lt;/li&gt;
&lt;li&gt;2.6 GUI 调试器：GDBFrontend&lt;/li&gt;
&lt;li&gt;2.7 管理工具：DBeaver&lt;/li&gt;
&lt;li&gt;2.8 大型系统资料：awesome-scalability&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周 GitHub Trending #技术学习#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 计算机视觉：computervision-recipes&lt;/li&gt;
&lt;li&gt;3.2 深度学习：Trax&lt;/li&gt;
&lt;li&gt;3.3 Google 开源应用模型：MediaPipe&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可怕-github-新生&quot;&gt;1. 可怕 GitHub 新生&lt;/h2&gt;
&lt;h3 id=&quot;日获-2k-star-github-热门1-on-1-meeting-questions&quot;&gt;1.1 日获 2k+ star GitHub 热门：1 on 1 Meeting Questions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：6000+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1 on 1 Meeting Questions 可谓是上周#GitHub Trending#榜热门项目，光上 GitHub Trending 榜那天已获得 2,200+ 个 star，收录了大量一对一会议的议题，包括【管理】、【职业规划】、【公司团队】、【沟通交流】、【业务生活】等多个方面问题，可以 Pick 思考下人生的各类命题&lt;/p&gt;
&lt;blockquote readability=&quot;1.3559322033898&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/VGraupera/1on1-questions&quot; class=&quot;uri&quot;&gt;https://github.com/VGraupera/1on1-questions&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;防窃听玩具wearable-microphone-jamming&quot;&gt;1.2 防窃听玩具：wearable-microphone-jamming&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Wearable Microphone Jamming 是防窃听手环的知识库，此仓库提供了仿真源代码，硬件设计，固件和原理图。防窃听手环本身配备 24 个扬声器，可全方位播放非线性超音波讯号，类似驱蚊器声音，正常人听不到，但能有效影响收音装置，让收到的声音变成像风声等噪音而不能听到人声。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1764705882353&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/y-x-c/wearable-microphone-jamming&quot; class=&quot;uri&quot;&gt;https://github.com/y-x-c/wearable-microphone-jamming&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182336268-1188675971.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;simd几何代数库klein&quot;&gt;1.3 SIMD几何代数库：Klein&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Klein是一个 P(R*_{3,0,1}) 的实现，即 3D 射影几何代数。它是为需要高吞吐量的应用程序设计的，比如：动画库、运动学求解器等。与其他 GA 库不同，Klein并未概括空间度量或维数。为了弥补这种损失，Klein 使用 SSE (流式 SIMD 扩展)的全部权值来实现最大吞吐量的代数操作。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/jeremyong/Klein&quot; class=&quot;uri&quot;&gt;https://github.com/jeremyong/Klein&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;天系列7days-golang&quot;&gt;1.4 7 天系列：7days-golang&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：900+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7 天能写什么呢？类似 gin 的 Web 框架？类似 groupcache 的分布式缓存？或者一个简单的 Python 解释器？这个仓库可能能给你答案。项目暂时只有两个分类&lt;br/&gt;🎨7 天用 Go 从零实现分布式缓存 - GeeCache&lt;br/&gt;🎏7 天用Go 从零实现Web框架 - Gee&lt;/p&gt;
&lt;blockquote readability=&quot;1.4285714285714&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/geektutu/7days-golang&quot; class=&quot;uri&quot;&gt;https://github.com/geektutu/7days-golang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;万能-excelcomputer-vision-basics-in-microsoft-excel&quot;&gt;1.5 万能 Excel：computer-vision-basics-in-microsoft-excel&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;computer-vision-basics-in-microsoft-excel 是一个不依赖任何脚本或第三方插件，直接在 Excel 中实现可视化，比如：人脸检测，霍夫变换等算法的项目。&lt;br/&gt;学习这个项目你不需要掌握计算机视觉背景知识，只需了解 Excel 基础操作即可。当然你还需要具备一些数学背景，比如加权平均数、偏微分、特征值等。&lt;/p&gt;
&lt;blockquote readability=&quot;0.98765432098765&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/amzn/computer-vision-basics-in-microsoft-excel&quot; class=&quot;uri&quot;&gt;https://github.com/amzn/computer-vision-basics-in-microsoft-excel&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182352872-672516250.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;duang-人不见了real-time-person-removal&quot;&gt;1.6 Duang 人不见了：Real-Time-Person-Removal&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想让视频里的人 Duang 地不见吗，Real-Time-Person-Removal 是一个用 JavaScript &amp;amp; TensorFlow.js 在 Web 浏览器中移除人的项目。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1428571428571&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/jasonmayes/Real-Time-Person-Removal&quot; class=&quot;uri&quot;&gt;https://github.com/jasonmayes/Real-Time-Person-Removal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182403355-934995798.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频工具waifu2x-extension-gui&quot;&gt;1.7 视频工具：Waifu2x-Extension-GUI&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Waifu2x-Extension-GUI 是一款图片（包括 GIF） 和视频超分辨率放大工具，也支持降噪，该项目基于 Waifu2x-ncnn-vulkan 和 Waifu2x-converter 算法。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.1594202898551&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/AaronFeng753/Waifu2x-Extension-GUI&quot; class=&quot;uri&quot;&gt;https://github.com/AaronFeng753/Waifu2x-Extension-GUI&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182428837-1212151546.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;尚能星否-github-老项目&quot;&gt;2. 尚能星否 GitHub 老项目&lt;/h2&gt;
&lt;h3 id=&quot;命令行的艺术the-art-of-command-lines&quot;&gt;2.1命令行的艺术：the-art-of-command-lines&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。【the-art-of-command-lines】，又名命令行的艺术，记录了作者在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。该 repo 已被翻译成 15+ 国语言~&lt;/p&gt;
&lt;blockquote readability=&quot;1.25&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/jlevy/the-art-of-command-line&quot; class=&quot;uri&quot;&gt;https://github.com/jlevy/the-art-of-command-line&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182437429-1786749441.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;全能the-system-design-primer&quot;&gt;2.2 全能：The System Design Primer&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1050+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统设计是一个很宽泛的话题。在互联网上，关于系统设计原则的资源也是多如牛毛。The System Design Primer 这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。目前 repo 已被翻译成 20+ 个版本&lt;/p&gt;
&lt;blockquote readability=&quot;1.1940298507463&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/donnemartin/system-design-primer&quot; class=&quot;uri&quot;&gt;https://github.com/donnemartin/system-design-primer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182446220-256196276.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;笔记工具joplin&quot;&gt;2.3 笔记工具：Joplin&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Joplin 是一个多平台、免费的开源笔记和待办事项，它可以处理笔记本组织成的大量笔记。&lt;br/&gt;当使用图形界面时，你可以在纯文本、WYSIWYG 和同时显示源文本和渲染视图的分屏之间切换编辑器视图。你还可以在图形界面中指定外部编辑器，以便使用 Vim、Emacs 或任何其他能够处理文本文档的编辑器轻松更新笔记。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/laurent22/joplin&quot; class=&quot;uri&quot;&gt;https://github.com/laurent22/joplin&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182459152-1816847517.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码查看工具sourcegraph&quot;&gt;2.4 代码查看工具：Sourcegraph&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sourcegraph 是一个代码查看工具，由 Golang 编写而成，它可以为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接的 Chrome 扩展，它允许你像使用 IDE 那样浏览源代码。&lt;br/&gt;有了 Sourcegraph 之后，你可以从代码仓库和安装包甚至是函数里搜索代码，同时也可以直接点击被完全创建了链接的代码来阅读文档、跳转到变量定义或者马上找到可用的 Demo。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3793103448276&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/sourcegraph/sourcegraph&quot; class=&quot;uri&quot;&gt;https://github.com/sourcegraph/sourcegraph&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182510902-1069815935.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前端神器playwright&quot;&gt;2.5 前端神器：Playwright&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Playwright 是微软开源的，跨浏览器的 Web 自动化测试的 Node 库，可通过单个 API 创建浏览器实例，打开页面，然后对其进行操作。支持 Chromium，WebKit 和 Firefox 等 3 个浏览器。根据 repo 作者所述，相比 Puppeteer，Playwright 支持更多的浏览器，更易于测试，更加原生。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4545454545455&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/microsoft/playwright&quot; class=&quot;uri&quot;&gt;https://github.com/microsoft/playwright&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182523783-1725167065.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;gui-调试器gdbfrontend&quot;&gt;2.6 GUI 调试器：GDBFrontend&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：850+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GDBFrontend 是一个简洁，灵活和可扩展的 GUI 调试器。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.4285714285714&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/rohanrhu/gdb-frontend&quot; class=&quot;uri&quot;&gt;https://github.com/rohanrhu/gdb-frontend&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182533541-1907486260.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;管理工具dbeaver&quot;&gt;2.7 管理工具：DBeaver&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DBeaver 是一个通用的数据库管理工具和 SQL 客户端，支持 MySQL、PostgreSQL、Oracle、DB2、MSSQL、Sybase、Mimer、HSQLDB、Derby 以及其他兼容 JDBC 的数据库。DBeaver 提供一个图形界面用来查看数据库结构、执行 SQL 查询和脚本，浏览和导出数据，处理 BLOB/CLOB 数据，修改数据库结构等等。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/dbeaver/dbeaver&quot; class=&quot;uri&quot;&gt;https://github.com/dbeaver/dbeaver&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182542974-1827398463.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;大型系统资料awesome-scalability&quot;&gt;2.8 大型系统资料：awesome-scalability&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;awesome-scalability：一个系统的阅读列表，描述了可扩展、高可用、高性能的大型系统背后的东西。每部分都是基于真实案例，讲述了如何搭建一个可扩展、高可用、高性能的大型系统，案例都是来自于经过数百万甚至数十亿用户实战检验的系统。对于所有工程师而言都是一个很好的学习资料，开卷有益。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1764705882353&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/binhnguyennus/awesome-scalability&quot; class=&quot;uri&quot;&gt;https://github.com/binhnguyennus/awesome-scalability&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本周-github-trending-技术学习主题的主力军&quot;&gt;3. 本周 GitHub Trending #技术学习#主题的主力军&lt;/h2&gt;
&lt;p&gt;本周 GitHub Trending 上有许多机器学习相关项目，这边我们选取了 3 个项目。&lt;/p&gt;
&lt;h3 id=&quot;计算机视觉computervision-recipes&quot;&gt;3.1 计算机视觉：computervision-recipes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：350+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;computervision-recipes 是微软开源的计算机视觉最佳实践，包括示例代码和文档。该库结合了计算机视觉算法、神经体系结构和计算机视觉系统的最新进展来搭建一套全面的工具和示例。如果你要学习计算机视觉相关内容，不妨试下这个 repo。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3559322033898&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot; class=&quot;uri&quot;&gt;https://github.com/heibaiying/BigData-Notes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182555754-1521776543.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;深度学习trax&quot;&gt;3.2 深度学习：Trax&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Trax 是一个 Google 开源的深度学习进阶路线，从基础数学开始，然后进行层次，模型，监督和强化学习。此外，Trax 包含许多深度学习模型（ResNet，Transformer，RNN，...），并绑定了大量的深度学习数据集，包括 Tensor2Tensor 和 TensorFlow 数据集。&lt;/p&gt;
&lt;blockquote readability=&quot;1.7391304347826&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/google/trax&quot; class=&quot;uri&quot;&gt;https://github.com/google/trax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;google-开源应用模型mediapipe&quot;&gt;3.3 Google 开源应用模型：MediaPipe&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MediaPipe 是 Google Research 开源的跨平台多媒体机器学习模型应用框架，用于构建多模式（视频，音频和传感器）应用的机器学习管道。&lt;br/&gt;作为一款跨平台框架，MediaPipe 不仅可以被部署在服务器端，更可以在多个移动端 （安卓和苹果 iOS）和嵌入式平台（Google Coral 和树莓派）中作为设备端机器学习推理 （On-device Machine Learning Inference）框架。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/google/mediapipe&quot; class=&quot;uri&quot;&gt;https://github.com/google/mediapipe&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200223182608767-50426319.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上为 2020 年第 8 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加：HelloGitHub 为好友可同前端、Java、Go…各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200217165012919-1203910757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Feb 2020 00:09:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 摘要：GitHub Trending 上周看点，老项目依旧抢眼，系统设计必看 Repo：The System Design Primer 周获 1k+ star，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12353135.html</dc:identifier>
</item>
<item>
<title>浅析Internet上使用的安全协议 - AhuntSun</title>
<link>http://www.cnblogs.com/AhuntSun-blog/p/12355218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AhuntSun-blog/p/12355218.html</guid>
<description>&lt;h2 id=&quot;internet上使用的安全协议&quot;&gt;Internet上使用的安全协议&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;网络安全是分层实现的，从应用层安全到数据链路层安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一运输层安全协议安全套接字ssl&quot;&gt;一、运输层安全协议：安全套接字SSL&lt;/h3&gt;
&lt;h4 id=&quot;简介&quot;&gt;1.1.简介&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SSL&lt;/strong&gt; 是安全套接层 (Secure Socket Layer)，可对万维网客户与服务器之间传送的数据进行加密和鉴别。&lt;/li&gt;
&lt;li&gt;SSL 在双方的联络阶段协商将使用的加密算法和密钥，以及客户与服务器之间的鉴别。&lt;/li&gt;
&lt;li&gt;在联络阶段完成之后，所有传送的数据都使用在联络阶段商定的会话密钥。&lt;/li&gt;
&lt;li&gt;SSL 不仅被所有常用的浏览器和万维网服务器所支持，而且也是&lt;strong&gt;运输层安全协议 TLS&lt;/strong&gt; (Transport Layer Security)的基础。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ssl-的位置&quot;&gt;1.2.SSL 的位置&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/1.png&quot; alt=&quot;image-20200206165343194&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在发送方，SSL 接收应用层的数据（如 HTTP 或 IMAP 报文），对数据进行加密，然后把加了密的数据送往运输层 TCP 套接字。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在接收方，SSL 从 TCP 套接字读取数据，解密后把数据交给应用层。（发送方和接收方都有SSL层）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用ssl技术的例子&quot;&gt;1.3.使用SSL技术的例子&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/2.png&quot; alt=&quot;image-20200206172009093&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们访问网站时，一般不涉及输入账号密码等操作的网页使用的都是 &quot;HTTP&quot; 协议（使用80端口），即网站域名开头为：&lt;a href=&quot;http://%EF%BC%9B%E5%BD%93%E6%B6%89%E5%8F%8A%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%AD%89%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E7%BD%91%E7%AB%99%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E4%BD%BF%E7%94%A8&quot; class=&quot;uri&quot;&gt;http://；当涉及账号密码等敏感信息的操作时，网站一般都会使用&lt;/a&gt; &quot;HTTPS&quot;协议（使用443端口），&quot;S&quot;表示的即是SSL (Secure Socket Layer)，即网站域名开头为：&lt;a href=&quot;https://&quot; class=&quot;uri&quot;&gt;https://&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;例如，我们访问中国工商银行的官网：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/3.png&quot; alt=&quot;image-20200206170948893&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在主页处的域名栏中可以发现浏览器提醒的 &quot;不安全&quot; 字样，实际上该主页使用的就是HTTP协议，即不加密信息，明文传输。由于这是谷歌浏览器，没有显示 &quot;&lt;a href=&quot;http://&quot; class=&quot;uri&quot;&gt;http://&lt;/a&gt;&quot; 的域名前缀。&lt;/p&gt;
&lt;p&gt;当点击登录时，跳转到另外一个网页：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/4.png&quot; alt=&quot;image-20200206171337136&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从网站域名开头的 &quot;&lt;a href=&quot;https://&quot; class=&quot;uri&quot;&gt;https://&lt;/a&gt;&quot; 可以看出，涉及到账号密码等敏感信息的登录页面使用的是HTTPS协议，说明网页使用了SSL技术。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTP协议使用了安全套接字（SSL）变成了HTTPS协议，使用的端口由80变为443，其他应用层的协议也可以使用安全套接字：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IMAPS：TCP-993；&lt;/li&gt;
&lt;li&gt;POP3S：TCP-995；&lt;/li&gt;
&lt;li&gt;SMTPS：TCP-465；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;安全套接字实现的过程https&quot;&gt;1.4.安全套接字实现的过程：https&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/5.png&quot; alt=&quot;image-20200206223547589&quot;/&gt;&lt;/p&gt;
&lt;p&gt;https既采用了对称加密的效率，也采用了非对称加密的安全。&lt;/p&gt;
&lt;p&gt;通信前Web服务器先把证书中的公钥交给IE浏览器（客户），IE浏览器根据收到的公钥生成一个对称密钥，然后使用公钥加密对称密钥并发送给Web服务器。&lt;/p&gt;
&lt;p&gt;Web服务器使用私钥解密收到的加密后的对称密钥，随后使用对称密钥加密需要传输的数据。在之后的通信中都采用该对称密钥对数据加密和解密。&lt;/p&gt;
&lt;p&gt;在传输对称密钥的过程中使用非对称加密，在传输数据过程中使用对称加密。这样既保证了数据传输的安全，也提高了效率。&lt;/p&gt;
&lt;p&gt;所以，在使用https通信的时候一开始都不会太快，因为要协商对称密钥，协商好之后才会快起来。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;查看使用https网站的证书&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：百度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/6.png&quot; alt=&quot;image-20200206224006290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 &quot;锁&quot; 图标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/7.png&quot; alt=&quot;image-20200206224100256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 &quot;证书&quot; 即可查看到该网站使用的证书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/8.png&quot; alt=&quot;image-20200206224149426&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/9.png&quot; alt=&quot;image-20200206224207086&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;ssl-实现的三个功能&quot;&gt;1.5.SSL 实现的三个功能&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SSL 服务器鉴别&lt;/strong&gt; ：允许用户证实服务器的身份。具有 SSL 功能的浏览器维持一个表，上面有一些可信赖的&lt;strong&gt;认证中心&lt;/strong&gt; CA (Certificate Authority)和它们的公钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加密的 SSL 会话&lt;/strong&gt; ：客户和服务器交互的所有数据都在发送方加密，在接收方解密。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSL 客户鉴别&lt;/strong&gt; ：允许服务器证实客户的身份。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/10.png&quot; alt=&quot;image-20200206224325686&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图为颁发给百度首页的证书，可以看到SSL除了可以加密会话信息之外，还可以鉴别服务器和客户身份。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;二网络层安全协议ipsec&quot;&gt;二、网络层安全协议：IPSec&lt;/h3&gt;
&lt;p&gt;网络安全是分层实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/11.png&quot; alt=&quot;image-20200206225737400&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;应用层安全：比如微软的 &quot;Outlook&quot; 邮箱，可以通过在应用程序中的某些设置实现数据传输的安全。应用层安全的特点为需要应用程序的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;传输层安全：传输安全是通过夹在应用层和传输层中间的SSL层实现的，发送方的SSL可以将应用层的数据加密后给传输层，接收方的SSL传输层收到的数据解密后给应用层。SSL安全的特点为需要配置相应证书。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;网络层安全：属于底层安全，不需要应用程序支持，也不需要配置证书，对用户来说是透明的，即用户并不知道数据在该层进行了加密。&lt;/p&gt;
&lt;p&gt;比如，未加密的数据经过发送方的网卡实现了加密，接收方的网卡实现数据解密，整个过程用户是不知道的，是透明的，即使数据在传输过程中被截获了，第三方也不能破解其中内容；或者数据被篡改了，接收方也能发现，这便是网络层安全。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ipsec与安全关联-sa&quot;&gt;2.1.IPsec与安全关联 SA&lt;/h4&gt;
&lt;p&gt;网络层保密是指所有在 IP 数据报中的数据都是加密的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;IPsec 中最主要的两个部分&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;鉴别首部 AH&lt;/strong&gt; (Authentication Header)： AH鉴别源点和检查数据完整性，但不能保密。类似于数字签名，用于确保数据的来源并判断数据是否被更改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封装安全有效载荷 ESP&lt;/strong&gt; (Encapsulation Security Payload)：ESP 比 AH 复杂得多，它鉴别源点、检查数据完整性和提供保密。 类似于既使用数字签名，又使用共享密钥对数据进行加密。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;安全关联 SA(Security Association)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;在使用 AH 或 ESP 之前，先要从源主机到目的主机建立一条网络层的逻辑连接。此逻辑连接叫做安全关联 SA&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IPsec 就把传统的因特网无连接的网络层转换为具有逻辑连接的层。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;SA（安全关联）是构成IPSec的基础，是两个通信实体经协商（利用IKE协议）建立起来的一种协定，它决定了用来保护数据分组安全的安全协议（AH协议或者ESP协议）、转码方式、密钥及密钥的有效存在时间等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;安全关联的特点&quot;&gt;2.2.安全关联的特点&lt;/h4&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;安全关联是一个单向连接。它由一个三元组唯一地确定，包括：&lt;/p&gt;
&lt;p&gt;(1) 安全协议（使用 AH 或 ESP）的标识符；&lt;/p&gt;
&lt;p&gt;(2) 此单向连接的源 IP 地址；&lt;/p&gt;
&lt;p&gt;(3) 一个 32 位的连接标识符，称为&lt;strong&gt;安全参数索引&lt;/strong&gt; SPI (Security Parameter Index)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于一个给定的安全关联 SA，每一个 IPsec 数据报都有一个存放 SPI 的字段。通过此 SA 的所有数据报都使用同样的 SPI 值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查看安全关联&quot;&gt;2.3.查看安全关联&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在Windows系统开始页面输入命令mmc打开 &quot;Microsoft 管理控制台&quot;，打开 &quot;文件&quot; 选择 &quot;添加/删除管理单元&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/12.png&quot; alt=&quot;image-20200207211626876&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找到并添加 &quot;IP安全监视器&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/13.png&quot; alt=&quot;image-20200207211821913&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回到控制台界面，可在IP安全监视器中找到 &quot;安全关联&quot; 选项，选中后可查看已建立的安全关联。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/14.png&quot; alt=&quot;image-20200207212859987&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;鉴别首部协议-ah&quot;&gt;2.4.鉴别首部协议 AH&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在使用鉴别首部协议 AH 时，把 AH 首部插在原数据报数据部分的前面，同时把 IP 首部中的协议字段置为 51。&lt;/li&gt;
&lt;li&gt;在传输过程中，中间的路由器都不查看 AH 首部。当数据报到达终点时，目的主机才处理 AH 字段，以鉴别源点和检查数据报的完整性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/15.png&quot; alt=&quot;image-20200207231300350&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;AH首部&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(1) 下一个首部(8 位)。标志紧接着本首部的下一个首部的类型（如 TCP 或 UDP）。&lt;/p&gt;
&lt;p&gt;(2) 有效载荷长度(8 位)，即鉴别数据字段的长度，以 32 位字为单位。&lt;/p&gt;
&lt;p&gt;(3) 安全参数索引 &lt;strong&gt;SPI&lt;/strong&gt; (32 位)。标志安全关联，两个计算机进行通讯时的SPI值是固定的。&lt;/p&gt;
&lt;p&gt;(4) 序号(32 位)。鉴别数据字段的长度，以32 位字为单位。&lt;/p&gt;
&lt;p&gt;(5) 保留(16 位)。为今后用。&lt;/p&gt;
&lt;p&gt;(6) 鉴别数据(可变)。为 32 位字的整数倍，它包含了&lt;strong&gt;经数字签名的报文摘要&lt;/strong&gt;。因此可用来鉴别源主机和检查 IP 数据报的完整性。&lt;/p&gt;
&lt;h4 id=&quot;封装安全有效载荷-esp&quot;&gt;2.5.封装安全有效载荷 ESP&lt;/h4&gt;
&lt;p&gt;使用 ESP 时，IP 数据报首部的协议字段置为 &lt;strong&gt;50&lt;/strong&gt;。当 IP 首部检查到协议字段是 50 时，就知道在 IP 首部后面紧接着的是 ESP 首部，同时在原 IP 数据报后面增加了两个字段，即 ESP 尾部和 ESP 数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ESP 首部：&lt;/strong&gt;里面有标识一个安全关联的安全参数索引 SPI (32 位)，和序号(32 位)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESP 尾部：&lt;/strong&gt;里面有下一个首部（8 位，作用和 AH 首部的一样）。ESP 尾部和原来数据报的数据部分一起进行加密，因此攻击者无法得知所使用的运输层协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESP 鉴别：&lt;/strong&gt;和 AH 中的鉴别数据是一样的。因此，用 ESP 封装的数据报既有鉴别源站和检查数据报完整性的功能，又能提供保密。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/16.png&quot; alt=&quot;image-20200207232719822&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;设置本地计算机的ip安全策略&quot;&gt;2.6.设置本地计算机的IP安全策略&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在计算机的 &quot;开始&quot; 界面搜索 &quot;本地安全策略&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/17.png&quot; alt=&quot;image-20200207115239305&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;右键 &quot;IP安全策略&quot; 打开菜单，选择 &quot;创建 IP 安全策略&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/18.png&quot; alt=&quot;image-20200207115445503&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进入 &quot;IP安全策略向导&quot; ，创建一个自定义的 IP安全策略，随后一直 &quot;下一步&quot; 结束向导。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/19.png&quot; alt=&quot;image-20200207120033791&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/20.png&quot; alt=&quot;image-20200207120152009&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/21.png&quot; alt=&quot;image-20200207120247539&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的 &quot;激活默认规则&quot; 指的是，当没有指定规则时，使用默认的规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/22.png&quot; alt=&quot;image-20200207120323944&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进入自定义IP安全策略的属性界面，去掉默认勾选的 &quot;使用添加向导&quot; 这样可以看到更多的细节，然后点击 &quot;添加&quot;，添加新的IP安全规则。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/23.png&quot; alt=&quot;image-20200207120926871&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;进入 &quot;新规则 属性&quot; 界面，在 &quot;IP筛选器列表&quot; 选项中可选择和添加 IP筛选器列表，它的作用是：指定受此新规则影响的网络流量。比如所有的 IP 通讯、所有的 ICMP 通讯等，即设置允许接收从哪里来或到哪里去的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/24.png&quot; alt=&quot;image-20200207121257916&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击 &quot;添加&quot; 进入 &quot;IP 筛选器列表&quot;界面，自定义IP 筛选器列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/25.png&quot; alt=&quot;image-20200207124730121&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;去掉默认勾选的 &quot;使用添加向导&quot; 选项，继续点击 &quot;添加&quot; ，进入 &quot;IP 筛选器 属性&quot; 界面。该界面可以设置 IP筛选器 的地址、协议和描述信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/26.png&quot; alt=&quot;image-20200207122229921&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &quot;地址&quot; 选项卡的 &quot;源地址&quot; 选项中可以设置 与本计算机通信的流量数据中的源地址。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/27.png&quot; alt=&quot;image-20200207122623280&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同样也可以设置目标地址。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/28.png&quot; alt=&quot;image-20200207122659055&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &quot;协议&quot; 选项卡中，可以设置通信的协议类型和相应的端口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/29.png&quot; alt=&quot;image-20200207122830457&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/30.png&quot; alt=&quot;image-20200207122843818&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &quot;描述&quot; 选项卡可给自定义的IP筛选器添加描述。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/31.png&quot; alt=&quot;image-20200207122959980&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编辑完 IP 筛选器属性后，回到 &quot;IP筛选器列表&quot; 可看到刚才添加的IP筛选器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/32.png&quot; alt=&quot;image-20200207124912045&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击 &quot;确认&quot; ，回到 &quot;新规则 属性&quot; 界面，可在 &quot;IP 筛选器列表&quot; 中看到刚才自定义的IP筛选器列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/33.png&quot; alt=&quot;image-20200207124948681&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 &quot;筛选器操作&quot; 选项卡中，可以指定如何保障新建的IP筛选器列表的网络流量的安全，即指定在 &quot;IP 筛选器列表&quot; 中设置的允许通行的流量使用的安全方法（AH或ESP等）。同样不使用向导，点击 &quot;添加&quot;，添加筛选器的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/34.png&quot; alt=&quot;image-20200207145554515&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在进入的 &quot;新筛选器操作 属性&quot; 界面中，可以设置对应的安全方法，比如可以无条件阻止或许可之前选定的 IP 筛选列表中的通信流量，也可以在协商安全的情况下进行通信。我们选中 &quot;协商安全&quot; 选项，然后点击 &quot;添加&quot; ，添加对应的安全方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/35.png&quot; alt=&quot;image-20200207150110642&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进入 &quot;新增安全方法&quot; 界面，可以看到有两种安全方法，一种为 &quot;完整性和加密&quot;，相当于既使用数字签名也使用共享密钥加密；另一种为 &quot;仅保持完整性&quot;，相当于数字签名。这便是IPSec中的AH协议和ESP协议这两种协议。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/36.png&quot; alt=&quot;image-20200207150150691&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择 &quot;自定义&quot; 选项，再点击 &quot;设置&quot; ，进入 &quot;自定义安全方法设置&quot; 界面。在该界面中可以选择使用的安全协议AH或者ESP及相应的算法，也可以设置会话密钥生成的间隔（密钥生成时间）：每传输多少数据或每经过多长时间生成新密钥。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/37.png&quot; alt=&quot;image-20200207150854020&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置完相应的安全方法后回到 &quot;新筛选器操作 属性&quot; 界面， 可以看到刚才自定义的安全方法及相应设置。在界面下方的三个选项中，前两项设置如字面意思，第三项设置意思为新密钥生成之后，以后加密数据都不会再使用旧密钥。随后点击 &quot;应用&quot; 和 &quot;确认&quot; 回到 &quot;新规则 属性&quot; 界面。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/38.png&quot; alt=&quot;image-20200207152326688&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/39.png&quot; alt=&quot;image-20200207152720031&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在 &quot;身份验证方法&quot; 选项卡中，可以指定通信双方建立信任关系的方法，即验证通信双方的身份。点击 &quot;添加&quot; 进入 &quot;新身份验证方法 属性&quot; 界面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/40.png&quot; alt=&quot;image-20200207153533208&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在该界面中，可以指定身份验证方法。例如通过设置共享密钥，来实现身份验证。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/41.png&quot; alt=&quot;image-20200207153647894&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置完成后点击 &quot;确认&quot; 可回到 &quot;新规则 属性&quot; 界面，可看到新增的身份验证方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/42.png&quot; alt=&quot;image-20200207153856786&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&quot;新规则 属性&quot; 界面的 &quot;隧道设置&quot; 选项卡可设置IPSec隧道相关属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/43.png&quot; alt=&quot;image-20200207154209520&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&quot;新规则 属性&quot; 界面的 &quot;连接类型&quot; 选项卡可指定使用新规则的连接类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/44.png&quot; alt=&quot;image-20200207154307189&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这样便完成了新规则的属性设置，回到自定义IP安全策略的属性界面，可以看到添加的自定义列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/45.png&quot; alt=&quot;image-20200207154549163&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击 &quot;确定&quot;，回到 &quot;本地安全策略&quot; 界面，可看到新增的 &quot;toServer&quot; 安全策略，此时该安全策略还未生效。右键选择 &quot;分配&quot; 可指派该策略，使计算机使用该安全策略进行通信。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/46.png&quot; alt=&quot;image-20200207155041995&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;仿真练习&quot;&gt;2.7.仿真练习&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/47.png&quot; alt=&quot;image-20200207160024218&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把本地计算机当作Web服务器，按图中要求设置Web服务器到三台计算机的安全策略，其中计算机XP1的IP地址为192.168.80.101，XP2为192.168.80.102，XP3为192.168.80.103 。&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;设置Web服务器到计算机XP1的安全策略：&lt;/p&gt;
&lt;p&gt;在 &quot;新规则 属性&quot; 界面的 &quot;IP筛选器列表&quot; 中添加新列表，指定通信的目标地址为XP1的IP地址：192.168.80.101 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/48.png&quot; alt=&quot;image-20200207160540417&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/49.png&quot; alt=&quot;image-20200207160815453&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 &quot;IP筛选器列表&quot; 中选中 &quot;toXP1&quot; 的情况下，在 &quot;筛选器操作&quot; 中添加安全方法名称为改为AH。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/50.png&quot; alt=&quot;image-20200207161252422&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/51.png&quot; alt=&quot;image-20200207161513023&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/52.png&quot; alt=&quot;image-20200207161316685&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 &quot;IP筛选器列表&quot; 中选中 &quot;toXP1&quot; 和 &quot;筛选器操作&quot; 中选中 &quot;AH&quot;的情况下，在 &quot;身份验证方法&quot; 中添加Web服务器到XP1的身份验证方法：使用共享密钥aaa。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/53.png&quot; alt=&quot;image-20200207161631766&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/54.png&quot; alt=&quot;image-20200207161652255&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&quot;隧道设置&quot; 和 &quot;连接类型&quot; 两项该例中不用设置，由此完成从Web服务器到XP1安全策略的设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设置Web服务器到计算机XP2和XP3的安全策略与到XP1的设置同理。最后，Web服务器把到XP1~XP3的安全策略都按要求添加了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/55.png&quot; alt=&quot;image-20200207162607923&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回到 &quot;本地安全策略&quot; 界面，选中新增的 &quot;toXPS&quot; 安全策略，右键 &quot;分配&quot; ，该安全策略生效，即按要求完成了Web服务器的安全策略设置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/56.png&quot; alt=&quot;image-20200207162855522&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置完之后，当Web服务器与XP1和XP2通信时，使用装包工具抓到的数据包只能看到加密后的数据；当Web服务器与XP3通信时，由于没有加密，所以抓包工具抓到的数据包能看到传输的明文。可在虚拟机中模拟四台计算机进行验证，这里就不展开了。&lt;/p&gt;
&lt;h4 id=&quot;关于ip安全规则冲突问题&quot;&gt;2.8.关于IP安全规则冲突问题&lt;/h4&gt;
&lt;p&gt;如下图所示，在IP安全规则中勾选的 &quot;所有 IP 通讯量&quot; 是否与其他勾选的安全规则冲突呢？是不冲突的，选择IP安全规则时采用的是最佳匹配原则。比如：老师说中午12点下课，班干部11：30开完会后可以离开，张三11点就能走，虽然时间不同，但是每个学生都清楚自己几点可以走，这就是最佳匹配。通信时，如果是与XP2通信，那么计算机就采用 &quot;toXP2&quot; 安全规则；与XP3通信，则采用 &quot;toXP3&quot; 安全规则；如果都不是，才采用 &quot;所有 IP 通讯量&quot; 安全规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/57.png&quot; alt=&quot;image-20200207210220402&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Feb 2020 16:00:00 +0000</pubDate>
<dc:creator>AhuntSun</dc:creator>
<og:description>Internet上使用的安全协议 网络安全是分层实现的，从应用层安全到数据链路层安全。 一、运输层安全协议：安全套接字SSL 1.1.简介 SSL 是安全套接层 (Secure Socket Laye</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AhuntSun-blog/p/12355218.html</dc:identifier>
</item>
<item>
<title>7个有用的JavaScript技巧 - -LinzZ-</title>
<link>http://www.cnblogs.com/GeniusLyzh/p/12355154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GeniusLyzh/p/12355154.html</guid>
<description>&lt;p&gt;就如其他的编程语言一样，JavaScript也具有许多技巧来完成简单和困难的任务。 一些技巧已广为人知，而有一些技巧也会让你耳目一新。 让我们来看看今天可以开始使用的七个JavaScript技巧吧！&lt;/p&gt;
&lt;h2 id=&quot;数组去重&quot;&gt;数组去重&lt;/h2&gt;
&lt;p&gt;使用ES6全新的数据结构即可简单实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var j = [...new Set([1, 2, 3, 3])]
输出： [1, 2, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Set的详细用法可以查看&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/set-map&quot;&gt;ES6入门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;数组和布尔值&quot;&gt;数组和布尔值&lt;/h2&gt;
&lt;p&gt;当数组需要快速过滤掉一些为false的值（0,undefined,false等）使，一般是这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myArray
    .map(item =&amp;gt; {
        // ...
    })
    // Get rid of bad values
    .filter(item =&amp;gt; item);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用Boolean更简洁地实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myArray
    .map(item =&amp;gt; {
        // ...
    })
    // Get rid of bad values
    .filter(Boolean);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log([1,0,null].filter(Boolean));
//输出：[1]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建纯空对象&quot;&gt;创建纯空对象&lt;/h2&gt;
&lt;p&gt;你一般会使用&lt;code&gt;{}&lt;/code&gt;来创建一个空对象，但是这个对象其实还是会有__proto__特性和&lt;code&gt;hasOwnProperty&lt;/code&gt;方法以及其他方法的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var o = {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如有一些对象方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686913/202002/686913-20200223234126746-1656359872.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是创建一个纯“字典”对象，可以这样实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let dict = Object.create(null);

// dict.__proto__ === &quot;undefined&quot;
// 对象没有任何的属性及方法&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;合并对象&quot;&gt;合并对象&lt;/h2&gt;
&lt;p&gt;合并多个对象这个使用展开运算符（...）即可简单实现:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const person = { name: 'David Walsh', gender: 'Male' };
const tools = { computer: 'Mac', editor: 'Atom' };
const attributes = { handsomeness: 'Extreme', hair: 'Brown', eyes: 'Blue' };

const summary = {...person, ...tools, ...attributes};
/*
Object {
  &quot;computer&quot;: &quot;Mac&quot;,
  &quot;editor&quot;: &quot;Atom&quot;,
  &quot;eyes&quot;: &quot;Blue&quot;,
  &quot;gender&quot;: &quot;Male&quot;,
  &quot;hair&quot;: &quot;Brown&quot;,
  &quot;handsomeness&quot;: &quot;Extreme&quot;,
  &quot;name&quot;: &quot;David Walsh&quot;,
}
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数参数必传校验&quot;&gt;函数参数必传校验&lt;/h2&gt;
&lt;p&gt;函数设置默认参数是JS一个很好的补充，但是下面这个技巧是要求传入参数值需要通过校验。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const isRequired = () =&amp;gt; { throw new Error('param is required'); };

const hello = (name = isRequired()) =&amp;gt; { console.log(`hello ${name}`) };

// 没有传值，抛出异常
hello();

// 抛出异常
hello(undefined);

// 校验通过
hello(null);
hello('David');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数默认参数允许在没有值或undefined被传入时使用默认形参。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。&lt;/p&gt;
&lt;h2 id=&quot;解构别名&quot;&gt;解构别名&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;const obj = { x: 1 };

// 通过{ x }获取 obj.x 值 
const { x } = obj;

// 设置 obj.x 别名为 { otherName }
const { x: otherName } = obj;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取查询字符串参数&quot;&gt;获取查询字符串参数&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;URLSearchParams&lt;/code&gt;API可以轻松获取查询字符串各项的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Assuming &quot;?post=1234&amp;amp;action=edit&quot;

var urlParams = new URLSearchParams(window.location.search);

console.log(urlParams.has('post')); // true
console.log(urlParams.get('action')); // &quot;edit&quot;
console.log(urlParams.getAll('action')); // [&quot;edit&quot;]
console.log(urlParams.toString()); // &quot;?post=1234&amp;amp;action=edit&quot;
console.log(urlParams.append('active', '1')); // &quot;?post=1234&amp;amp;action=edit&amp;amp;active=1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://davidwalsh.name/javascript-tricks&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters&quot;&gt;默认参数&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Feb 2020 15:43:00 +0000</pubDate>
<dc:creator>-LinzZ-</dc:creator>
<og:description>就如其他的编程语言一样，JavaScript也具有许多技巧来完成简单和困难的任务。 一些技巧已广为人知，而有一些技巧也会让你耳目一新。 让我们来看看今天可以开始使用的七个JavaScript技巧吧！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GeniusLyzh/p/12355154.html</dc:identifier>
</item>
<item>
<title>将你的Archlinux打造成路由器 - wendster</title>
<link>http://www.cnblogs.com/wendster/p/make-your-archlinux-server-to-a-home-router.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wendster/p/make-your-archlinux-server-to-a-home-router.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://blog.wendster.com/usr/uploads/2020/02/3023059589.jpeg&quot; alt=&quot;route.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;弄了一块J2900双千兆网口的工控板回来（奇怪的型号）当软路由用，无奈我又想各种皮，还想装桌面环境配VNC，而且我还对虚拟机不感冒（况且这U还不支持直通），只得放弃所有路由器系统。作为一名Arch铁粉，追求无定制纯原生，便决定装Archlinux然后变之为路由器。Archlinux的安装就不谈了，只讲跟标题有关的事。步骤简单美丽，其他Linux发行版若想食用需自行领会。&lt;/p&gt;
&lt;p&gt;首先，你需要一台双网口的电脑（单网口想弄WiFi的自行体会），最小化安装了Archlinux（已经安装了别的东西也不要紧，只是网络配置部分需自行调整），推荐在ArchISO里操作，避免网络问题无法安装软件包（・_・?）。&lt;/p&gt;
&lt;p&gt;打造路由器无非几点：一个网卡用DHCP等方式上网，另一个网卡设置静态地址并在其上配置DHCP服务，搭建DNS服务（可选），最后配置iptables以转发流量并充当防火墙。&lt;/p&gt;
&lt;p&gt;（可选）在配置网络之前，为了”美观”，我把网口接口名称换成了lan和wan。只需要编辑&lt;code&gt;/etc/udev/rules.d/10-network.rules&lt;/code&gt;，添加如下内容：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, ATTR{address}==&quot;00:e0:b5:90:09:1a&quot;, NAME=&quot;lan&quot; 
SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, ATTR{address}==&quot;00:e0:b5:90:09:19&quot;, NAME=&quot;wan&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将MAC地址换成自己的就好。&lt;/p&gt;
&lt;p&gt;安装必须的软件包（若不想用netctl可换，iptables为Archlinux自带）：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pacman -S netctl dhcpcd dhcp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后配置网络，我选用netctl，至于为什么不用NetworkManager是因为可能会导致无法控制网卡的情况。&lt;/p&gt;
&lt;p&gt;先配置WAN口，编辑&lt;code&gt;/etc/netctl/extern-profile&lt;/code&gt;（名字自取），然后添加如下内容：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Description='Public Interface'
Interface=wan
Connection=ethernet
IP='dhcp'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是通过DHCP上网，需拨号请查阅ArchWiki。&lt;/p&gt;
&lt;p&gt;然后配置LAN口，编辑&lt;code&gt;/etc/netctl/intern-profile&lt;/code&gt;（名字自取），然后添加如下内容：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Description='Private Interface'
Interface=lan
Connection=ethernet
IP='static'
Address=('192.168.0.1/24')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Description只是个描述而已，如果你没有改网口接口名称，需要将Interface替换成你自己的（如&lt;code&gt;eth0&lt;/code&gt;、&lt;code&gt;enp0s0&lt;/code&gt;之类），Address是（自行领会）。&lt;/p&gt;
&lt;p&gt;然后启用这些东西：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;netctl enable intern-profile 
netctl enable extern-profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在配置DHCP服务，编辑&lt;code&gt;/etc/dhcpd.conf&lt;/code&gt;，删除所有内容，添加如下内容：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;option domain-name-servers 8.8.8.8;
option subnet-mask 255.255.255.0;
option routers 192.168.0.1;
subnet 192.168.0.0 netmask 255.255.255.0 {
    range 192.168.0.2 192.168.0.255;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;domain-name-servers&lt;/code&gt;是DNS服务器地址，可配置多个，如果搭建了本地DNS服务器，可替换，&lt;code&gt;subnet-mask&lt;/code&gt;是子网掩码，基本不用管，&lt;code&gt;routers&lt;/code&gt;是网关地址，注意和之前netctl的Address匹配，&lt;code&gt;subnet&lt;/code&gt;必须是&lt;code&gt;x.x.x.0&lt;/code&gt;，&lt;code&gt;range&lt;/code&gt;表面可分配地址区间。&lt;/p&gt;
&lt;p&gt;再编辑 &lt;code&gt;/usr/lib/systemd/system/dhcpd4.service&lt;/code&gt;，在&lt;code&gt;ExecStart&lt;/code&gt;最后面添加监听网卡名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.wendster.com/usr/uploads/2020/02/3746191305.jpeg&quot; alt=&quot;dhcpd.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后设置开机自启，顺便也让iptables自启：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;systemctl enable dhcpd4
systemctl enable iptables&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我用不上ipv6，所以省略了。&lt;/p&gt;
&lt;p&gt;退出chroot重启进入系统操作，如果你是远程操作ArchISO的，会操作到一半断线导致无法继续，况且之前配置的服务还没启动（虽然可以手动启动）。&lt;/p&gt;
&lt;p&gt;现在WAN口已经连上网了，但是不能通过LAN口上网，于是开始配置转发和防火墙。&lt;/p&gt;
&lt;p&gt;先开启转发功能（我只开ipv4）：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;echo 'net.ipv4.ip_forward=1' &amp;gt; /etc/sysctl.d/30-ipforward.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Arch系写到单独的文件，其他发行版直接写到&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后配置iptables，先清除所有规则：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;iptables -F 
iptables -t nat -F&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后设置默认策略以处理不匹配流量：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;iptables -P INPUT ACCEPT 
iptables -P OUTPUT ACCEPT 
iptables -P FORWARD DROP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后设置变量名，以进行后面的命令（如果没有修改网口接口名称需修改成自己的）：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;export LAN=lan 
export WAN=wan&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（可选）锁定服务，使之只为LAN口工作：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;iptables -I INPUT 1 -i ${LAN} -j ACCEPT 
iptables -I INPUT 1 -i lo -j ACCEPT 
iptables -A INPUT -p UDP --dport bootps ! -i ${LAN} -j REJECT 
iptables -A INPUT -p UDP --dport domain ! -i ${LAN} -j REJECT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（可选）将特权端口的TCP/UDP包丢弃：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;iptables -A INPUT -p TCP ! -i ${LAN} -d 0/0 --dport 0:1023 -j DROP 
iptables -A INPUT -p UDP ! -i ${LAN} -d 0/0 --dport 0:1023 -j DROP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后添加NAT规则（注意自行修改）：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;iptables -I FORWARD -i ${LAN} -d 192.168.0.0/16 -j DROP 
iptables -A FORWARD -i ${LAN} -s 192.168.0.0/16 -j ACCEPT 
iptables -A FORWARD -i ${WAN} -d 192.168.0.0/16 -j ACCEPT 
iptables -t nat -A POSTROUTING -o ${WAN} -j MASQUERADE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在通过LAN口连接的设备应该能上网了，保存iptables规则：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;rm -rf /etc/iptables/iptables.rules 
iptables-save &amp;gt; /etc/iptables/iptables.rules&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大功告成，敬情享用吧！（终于可以皮了）&lt;/p&gt;
</description>
<pubDate>Sun, 23 Feb 2020 15:35:00 +0000</pubDate>
<dc:creator>wendster</dc:creator>
<og:description>弄了一块J2900双千兆网口的工控板回来（奇怪的型号）当软路由用，无奈我又想各种皮，还想装桌面环境配VNC，而且我还对虚拟机不感冒（况且这U还不支持直通），只得放弃所有路由器系统。作为一名Arch铁粉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wendster/p/make-your-archlinux-server-to-a-home-router.html</dc:identifier>
</item>
<item>
<title>利用django打造自己的工作流平台(三):团队成员任务跟踪系统 - 垒土毫末</title>
<link>http://www.cnblogs.com/leituhaomo/p/12349658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leituhaomo/p/12349658.html</guid>
<description>&lt;p&gt;　　近期受疫情影响公司食堂不开放，为解决同事们的吃饭问题，部门需要在每周五统计下周的订餐情况；员工根据个人意愿选择是否从公司订下周的午餐和晚餐，一旦确定一周保持不变。&lt;/p&gt;
&lt;p&gt;　　通常要完成一次部门内员工的订餐信息收集需要经过以下步骤：&lt;/p&gt;
&lt;p&gt;1.部门负责人通知各小组接口人收集组员订餐信息；&lt;/p&gt;
&lt;p&gt;2.各小组接口人通知组员反馈订餐信息，每个小组收集信息形式各异，如通过QQ留言、微信接龙等方式进行反馈；&lt;/p&gt;
&lt;p&gt;3.各小组接口人汇总组员的订餐信息反馈给部门负责人；&lt;/p&gt;
&lt;p&gt;4.部门负责人汇总各个小组的数据形成总表，并将总表截图反馈到工作群并要求员工进一步确认；&lt;/p&gt;
&lt;p&gt;5.员工核对总表信息，若发现自己订餐信息有误的再单独反馈部门负责人修改。&lt;/p&gt;
&lt;p&gt;6.部门负责人将核对后的表格发给负责订餐的工作人员。&lt;/p&gt;
&lt;p&gt;　　由于当过一次轮值小组接口人，发现了一些效率较低的地方:&lt;/p&gt;
&lt;p&gt;1.尚未反馈的人员的确定；需要根据已反馈人员和组内所有成员对比才能找出谁还没有反馈信息；&lt;/p&gt;
&lt;p&gt;2.需要小组接口人（多人）和部门负责人两级进行excel表格汇总；&lt;/p&gt;
&lt;p&gt;3.人工统计难以保证不出错，需要反复核对；&lt;/p&gt;
&lt;p&gt;为此创建了两个项目用于更方便的收集员工的订餐信息，如图1所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1431907/202002/1431907-20200223221517546-1088892016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图1  用于收集订餐信息的两个项目 &lt;/p&gt;
&lt;p&gt;利用该系统收集订餐信息的步骤如下：&lt;/p&gt;
&lt;p&gt;1.部门负责人在&quot;团队任务跟踪&quot;项目中创建一个问题，并将所有员工的账号列表填入到&quot;分配给&quot;字段对应的表单中，点击“批量分配”按钮即可为列表中的每个账户分配一个子任务，并将子任务显示在问题下方；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1431907/202002/1431907-20200223201559204-2051122882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2  团队任务跟踪的问题以及子任务列表&lt;/p&gt;
&lt;p&gt;2.部门负责人在&quot;团队任务跟踪&quot;和“子任务项目1”两个项目的管理界面点击&quot;批量注册&quot;按钮为团队成员批量创建账号（批量创建的账号的默认密码为123456），并点击“添加到用户群组”将账号批量添加到具有问题执行权限(ExecAuth)的“用户群组”中；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1431907/202002/1431907-20200223220439088-533591193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3 权限管理界面&lt;/p&gt;
&lt;p&gt;3.组员获得账号以及操作权限后，登录系统通过父任务下的子任务列表或者进入“子任务项目1”查看分配给自己的问题，填写相应信息并按流程操作。&lt;/p&gt;
&lt;p&gt;如图4所示，当前问题状态为“未提交”，根据流程可以进行&quot;更新信息&quot;和“提交”两种操作，对应下方的两个按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1431907/202002/1431907-20200223202116470-536435445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4 子任务的详细信息&lt;/p&gt;
&lt;p&gt;用户superadmin点击&quot;提交&quot;按钮后，子任务列表中对应的状态会同步进行更改；部门负责人可以通过子任务列表清楚地看到各个同事的提交情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1431907/202002/1431907-20200223202814216-524596503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5 superadmin提交后的子任务列表&lt;/p&gt;
&lt;p&gt;4.部门负责人点击图2中的&quot;导出子任务&quot;按钮，可将各组员的反馈情况导出到excel，如图6所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1431907/202002/1431907-20200223203416955-65881759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6 导出到excel的子任务数据 &lt;/p&gt;
&lt;p&gt;　　从订餐信息收集推而广之，很多上级分派下级执行的任务都可以用类似方法进行跟踪，只需要修改子任务的流程和字段即可。&lt;/p&gt;
&lt;p&gt;该系统具有的特点：&lt;/p&gt;
&lt;p&gt;　　1.部门负责人只要保留一份团队成员列表就可以很方便地一键分派任务；&lt;/p&gt;
&lt;p&gt;　　2.每个员工单独处理自己的问题，无法修改分配给他人的问题，避免误操作；&lt;/p&gt;
&lt;p&gt;　　3.每个子任务按制定的流程进行处理；&lt;/p&gt;
&lt;p&gt;　　4.子任务当前状态直观显示，便于任务分派人了解所有团队成员执行子任务情况；&lt;/p&gt;
&lt;p&gt;　　5.一键导出表格； &lt;/p&gt;
&lt;p&gt;　　很可能有人会问为什么不用超级表格？首先疫情期间可能因远程办公的人数太多，用户数超过负载导致超级表格极不稳定甚至很多时候无法访问；其次是某些同事未反馈时很难找到未及时反馈的人员；最重要的一点是超级表格无法按特定流程进行事务跟踪。&lt;/p&gt;
</description>
<pubDate>Sun, 23 Feb 2020 15:30:00 +0000</pubDate>
<dc:creator>垒土毫末</dc:creator>
<og:description>近期受疫情影响公司食堂不开放，为解决同事们的吃饭问题，部门需要在每周五统计下周的订餐情况；员工根据个人意愿选择是否从公司订下周的午餐和晚餐，一旦确定一周保持不变。 通常要完成一次部门内员工的订餐信息收</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leituhaomo/p/12349658.html</dc:identifier>
</item>
<item>
<title>JavaScript中，数组和对象的遍历方法总结 - 吾儿滨滨</title>
<link>http://www.cnblogs.com/52binbin/p/12355063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52binbin/p/12355063.html</guid>
<description>&lt;p&gt;循环遍历是写程序很频繁的操作，JavaScript 提供了很多方法来实现。&lt;/p&gt;
&lt;p&gt;这篇文章将分别总结数组和对象的遍历方法，新手可以通过本文串联起学过的知识。&lt;/p&gt;
&lt;h2 id=&quot;数组遍历&quot;&gt;数组遍历&lt;/h2&gt;
&lt;h4 id=&quot;方法一for-循环&quot;&gt;方法一：for 循环&lt;/h4&gt;
&lt;p&gt;for 循环是使用最多，也是性能优化最好的一种遍历方式。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
for (var i = 0; i &amp;lt; arr.length; i++) {
  console.log(arr[i])
}
// a b c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样常规的循环类型还有 while 循环和 do/while 循环。&lt;/p&gt;
&lt;p&gt;它们之间的区别在于，for 循环预先知道循环次数，while 循环不知道循环次数，do/while 至少会循环次数。&lt;/p&gt;
&lt;h4 id=&quot;方法二for-of-遍历&quot;&gt;方法二：for-of 遍历&lt;/h4&gt;
&lt;p&gt;for-of 是 ES6 新增的语法。它直接遍历值，而不是数组下标（或对象属性）。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
for (let item of arr) {
  console.log(item);
}
// a b c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，for-of 语句不仅可以循环遍历数组对象。&lt;/p&gt;
&lt;p&gt;还可以迭代 Array、Map、Set、String 等对象。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 遍历String
let str = &quot;Hello&quot;;
for (let value of str) {
  console.log(value)
}
// H e l l o

// 遍历Map
let iterable = new Map([[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]);
for (let entry of iterable) {
  console.log(entry);
}
// [&quot;a&quot;, 1]
// [&quot;b&quot;, 2]
// [&quot;c&quot;, 3]
for (let [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;for-of 的工作原理是，向循环对象请求一个迭代器对象，然后通过迭代器对象的next()方法来获得返回值。&lt;/p&gt;
&lt;p&gt;数组内置了 &lt;code&gt;@@iterator&lt;/code&gt;，&lt;code&gt;@@iterator&lt;/code&gt;不是迭代器，而是返回一个迭代器对象的函数。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [&quot;a&quot;, &quot;b&quot;,&quot;c&quot;];
var it = arr[Symbol.iterator]();
console.log(it.next());  // { value: 'a', done: false }
console.log(it.next());  // { value: 'b', done: false }
console.log(it.next());  // { value: 'c', done: false }
console.log(it.next());  // { value: undefined, done: true }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，value 表示当前遍历值，done 是布尔值，表示是否还有可以遍历的值。&lt;/p&gt;
&lt;p&gt;需要注意的是，普通对象没有内置&lt;code&gt;@@iterator&lt;/code&gt;，所以无法使用 for-of 遍历。&lt;/p&gt;
&lt;p&gt;这么做的原因很复杂，简单来说，就是为了避免影响未来的对象类型。&lt;/p&gt;
&lt;p&gt;不过，我们可以通过&lt;code&gt;Object.defineProperty(...)&lt;/code&gt;给对象定义&lt;code&gt;@@iterator&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;详细可以通过&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch3.md&quot;&gt;这里了解&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;方法三数组方法&quot;&gt;方法三：数组方法&lt;/h4&gt;
&lt;p&gt;为了适应不同方式的遍历，JavaScript 内置了许多的数组方法。&lt;/p&gt;
&lt;p&gt;例如比较常用的&lt;code&gt;forEach()&lt;/code&gt;方法，写起来，可以让代码更简洁。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
arr.forEach((index, item) =&amp;gt; {
  console.log(index, item)
})
// a 0
// b 1
// c 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [1, 2, 3];
var newArr = arr.map(item =&amp;gt; {
  return item * 2;
});
console.log(newArr);  // [2, 4, 6]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;filter()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [1, 2, 3];
var newArr = arr.filter(item =&amp;gt; {
  return item &amp;gt; 1;
});
console.log(newArr); // [2, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;reduce()&lt;/code&gt;方法是 ES5 新增，专为下面这种累加操作的设计的。&lt;/p&gt;
&lt;p&gt;实际能做的事情远比这要丰富，本文只是简单介绍基本用法，详细可以&lt;a href=&quot;https://aotu.io/notes/2016/04/14/js-reduce/index.html&quot;&gt;查看本文&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [1, 2, 3];
var sum = arr.reduce((pre, cur) =&amp;gt; {
  return pre + cur;
});
console.log(sum); // 6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;every()&lt;/code&gt;方法用于检测数组元素是否全部符合指定条件。&lt;/p&gt;
&lt;p&gt;它通常和下面的&lt;code&gt;some()&lt;/code&gt;方法放在一起理解。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [1, 2, 3];
var bool = arr.every(item =&amp;gt; {
  return item &amp;lt; 5;
});
console.log(bool); // true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;some()&lt;/code&gt;方法用于检测数组是否存在一个符合指定条件的元素。&lt;/p&gt;
&lt;p&gt;下面的例子是检测数组元素是否存在 Number 类型。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var arr = [&quot;a&quot;, 1, &quot;b&quot;];
var bool = arr.some(item =&amp;gt; {
  return typeof item === &quot;number&quot;;
});
console.log(bool);  // true&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象的遍历方法&quot;&gt;对象的遍历方法&lt;/h2&gt;
&lt;p&gt;对象的遍历相对麻烦一些。&lt;/p&gt;
&lt;p&gt;有两种方式可以实现对象的遍历，一种是直接使用 for-in 循环；另一方式，是将对象转换成数组，再进行遍历。&lt;/p&gt;
&lt;h4 id=&quot;方法一for-in-循环&quot;&gt;方法一：for-in 循环&lt;/h4&gt;
&lt;p&gt;for-in 专门用于遍历对象的可枚举属性，包括 prototype 原型链上的属性，因此性能会比较差。&lt;/p&gt;
&lt;p&gt;什么是&lt;a href=&quot;https://chenoge.github.io/2018/01/20/JS-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/&quot;&gt;可枚举属性&lt;/a&gt;？&lt;/p&gt;
&lt;p&gt;从名字上可以看出，就是该属性会出现在对象的迭代（枚举）中，比如 for-in 循环中。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var obj = { a: 2, b: 4, c: 6 };
for (let key in obj) {
  console.log(key);
}
// a b c&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法二object.keys-和-object.getownpropertynames&quot;&gt;方法二：Object.keys() 和 Object.getOwnPropertyNames()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Object.key()&lt;/code&gt;会返回一个数组，包含所有可枚举属性；&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;也会返回一个数组，包含所有元素，不管是否可枚举。&lt;/p&gt;
&lt;p&gt;需要说明的是，两者都只查找对象的自定义属性。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var obj = { a: 2, b: 4, c: 6 };
// Object.keys()
Object.keys(obj).forEach(key =&amp;gt; {
  console.log(key);
})
// a b c

// Object.getOwnPrepertyNames()
Object.getOwnPropertyNames(obj).forEach(key =&amp;gt; {
  console.log(key);
})
// a b c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，还可以通过&lt;code&gt;Reflect.ownKeys(obj)&lt;/code&gt;方法来遍历。&lt;/p&gt;
&lt;p&gt;它返回一个数组，包含对象自定义的属性，不管属性名是 Symbol 还是字符串，也不管是否可枚举。&lt;/p&gt;
&lt;p&gt;由于使用不多，这里&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys&quot;&gt;了解一下&lt;/a&gt;即可。&lt;/p&gt;
&lt;p&gt;最后，整理了不同对象遍历方法的特点。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;for-in&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;Object.keys(..)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Object.getOwnpropertyNames(..)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;吾儿滨滨&lt;/p&gt;
</description>
<pubDate>Sun, 23 Feb 2020 15:22:00 +0000</pubDate>
<dc:creator>吾儿滨滨</dc:creator>
<og:description>循环遍历是写程序很频繁的操作，JavaScript 提供了很多方法来实现。 这篇文章将分别总结数组和对象的遍历方法，新手可以通过本文串联起学过的知识。 数组遍历 方法一：for 循环 for 循环是使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/52binbin/p/12355063.html</dc:identifier>
</item>
<item>
<title>vuex知识笔记，及与localStorage和sessionStorage的区别 - TDX</title>
<link>http://www.cnblogs.com/tandaxia/p/12353218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tandaxia/p/12353218.html</guid>
<description>&lt;h3&gt;菜单快捷导航&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/tandaxia/p/12353218.html#tanOne&quot;&gt;Vuex是什么东东，有什么应用场景？localStorage和sessionStorage能否替代它？&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/tandaxia/p/12353218.html#tanTwo&quot;&gt;Vuex知识点State、Getter、Mutaion、Action&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/tandaxia/p/12353218.html#tanThree&quot;&gt;Vuex模块化(Module)&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;tanOne&quot;&gt; 1、Vuex概念和应用场景&lt;/h2&gt;
&lt;p&gt;　　首先，Vuex是什么，&lt;a href=&quot;https://vuex.vuejs.org/zh/&quot; target=&quot;_blank&quot;&gt;官网介绍说Vuex&lt;/a&gt; 是一个专为 Vue.js 应用程序开发的状态管理模式。我的理解就是Vuex就是类似于sessionStorage这样管理数据(本地存和取)的一种技术方案。&lt;/p&gt;
&lt;p&gt;　　既然vuex类似于sessionStorage，那为何我们还要学习vuex，直接用sessionStorage和localStorage不就好了？这个问得好，我来描述一种场景：多个视图(view)组件都要用到某一条数据(状态)，当这条数据发生变化的时候，依赖于该数据(状态)的相关视图(view)都要跟着即时更新。这种场景在工作中非常常见，我说一个自己碰到的例子，以前有一个react项目，其中有个功能是在pc页面自定义小程序页面，然后整个PC页面有三个组件组成，在三个组件中还有其他的很多子组件。然后一开始的做法就是通过事件和组件间传值来进行整个页面数据同步更新，后面随着组件越来越多，功能越来越复杂，麻烦和问题也就越来越多。然后每一个后面来接手的同事看代码都要看好一阵，长痛不如短痛...&lt;/p&gt;
&lt;p&gt;　　对的，在工作中这种常见的多个组件依赖于同一条数据(状态)，需要即时响应更新的情况，vuex的价值就体现出来了。这种情况下，vuex相比其他实现手段，就要简单干脆方便多了！先看一个小例子，看看&lt;strong&gt;&lt;span&gt;vuex和localStorage、sessionStorage的区别&lt;/span&gt;&lt;/strong&gt;，上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/454511/202002/454511-20200223184641368-1917707018.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如图，vuexPageA页面中引用了三个组件，每个组件都分别从localStorage、sessionStorage、vuex中取了一个值。点击按钮加1的时候，vuex的值是及时更新了，其他需要刷新才能更新。总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;localStorage存储的值能够永久的存储在浏览器上。不管是重新打开新窗口还是重启，同一个浏览器上的相同域名下，localStorage的值一直在。&lt;/li&gt;
&lt;li&gt;sessionStorage存储的值依赖于当前窗口(当前会话), 只要当前窗口不关闭，它存储的数据就一直在。一旦关闭窗口或者打开新窗口，sessionStorage之前存储的数据就会消失。&lt;/li&gt;
&lt;li&gt;相比localStorage和sessionStorage，vuex存储的数据可以即时更新到，当前项目下的所有引用了该数据的组件。但是如果刷新页面的话，vuex存储的值会重置，而localStorage和sessionStorage存储的值不会重置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　相关代码见：&lt;a href=&quot;https://github.com/xiaotanit/tan_vue/blob/master/src/views/vuex/VuexPageA.vue&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaotanit/tan_vue/blob/master/src/views/vuex/VuexPageA.vue&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;tanTwo&quot;&gt;2、Vuex知识点State、Getter、Mutaion、Action&lt;/h2&gt;
&lt;h3&gt;2.1 Vuex之State和mapState&lt;/h3&gt;
&lt;p&gt;　　每一个Vuex应用的核心就是store(仓库)，“store&quot;基本上就是一个容器。Vuex使用单一状态树，相当于用一个对象(store)就包含了全部的应用层级状态，也就是说每个应用也只包含一个store实例。因此Vuex的使用从new一个Vuex.Store实例(store实例)开始。store实例中的State属性就是用来存放Vue应用的所有的状态。先来看要给最简单的包含State属性的store实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import Vuex from 'vuex'&lt;span&gt;
import Vue from &lt;/span&gt;'vue'&lt;span&gt;
Vue.use(Vuex)

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
    state: {
        count: &lt;/span&gt;0&lt;span&gt;,
    },
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面的mutations、getters、actions再慢慢往里面加入代码。&lt;/p&gt;
&lt;p&gt;　　store实例创建，如何应用？Vue实例创建时，提供了一个store选项，可以让Vuex通过store选项，将store实例对象从根组件”注入“到每一个子组件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;
import App from &lt;/span&gt;'./App.vue'&lt;span&gt;
import router from &lt;/span&gt;'./router.js'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vuex 之 store实例对象&lt;/span&gt;
import store from './api/store/index' 

&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  router,  &lt;/span&gt;
  store, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件&lt;/span&gt;
  render: h =&amp;gt;&lt;span&gt; h(App)
}).$mount(&lt;/span&gt;'#app')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　store实例注入根组件后，应用中的每个组件中通过this.$store指的就是该store实例对象。那么现在如何在Vue组件中展示store中的state状态(数据)呢？由于Vuex的状态存储是即时响应的，从store实例中读取状态最简单的方法就是在Vue组件中”计算属性“computed中返回某个状态。每当store.state中某个状态变化的时候，都会重新求取计算属性，并且触发更新相关联的DOM。&lt;/p&gt;
&lt;p&gt;　　mapState是一个辅助函数，当我们应用中一个组件需要获取store中多个状态的时候，使用mapState辅助函数可以帮助我们更加方便生成计算属性。看看下面的应用测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9691da2-de9e-4080-81d4-e7899ed242be')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_c9691da2-de9e-4080-81d4-e7899ed242be&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9691da2-de9e-4080-81d4-e7899ed242be&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9691da2-de9e-4080-81d4-e7899ed242be',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9691da2-de9e-4080-81d4-e7899ed242be&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
import { mapState } from 'vuex'&lt;span&gt;;

    export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
        data(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                localCount: &lt;/span&gt;88&lt;span&gt;
            }
        },
        mounted(){
            console.log(&lt;/span&gt;&quot;...store对象：&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store);
        },
        computed:{
            localStorage_count(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; localStorage.getItem('localStorage_count'&lt;span&gt;)
            },
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用对象展开符&quot;...&quot;，可以将对象目标对象混入到外部对象中&lt;/span&gt;
&lt;span&gt;            ...mapState({
                sessionStorage_count(){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sessionStorage.getItem('sessionStorage_count'&lt;span&gt;)
                },
                vuex_count: state &lt;/span&gt;=&amp;gt; state.count, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;箭头函数可以使代码更简练&lt;/span&gt;
                vuex_count_alias: 'count', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传字符串参数'count'等同于 state =&amp;gt; state.count&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了能够使用 `this` 获取局部状态，必须使用常规函数&lt;/span&gt;
&lt;span&gt;                countPlusLocalState (state) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.count + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.localCount
                }
            }),
        },
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;2.2 Vuex之Getter和mapGetters&lt;/h3&gt;
&lt;p&gt;　　有时我们需要从store中的state种派生出一些状态，比如对store中的某一个状态(数据)进行筛选过滤，然后特别是当有多个组件需要用到这种状态(数据)时，“getter&quot;就出场了！Vuex允许我们在store中定义”getter&quot;（可以认为是store对象的计算属性）。就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter接受state作为其第一个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e3fece99-68f3-414f-9e92-89fd062cb45c')&quot; readability=&quot;42.5&quot;&gt;&lt;img id=&quot;code_img_closed_e3fece99-68f3-414f-9e92-89fd062cb45c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e3fece99-68f3-414f-9e92-89fd062cb45c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e3fece99-68f3-414f-9e92-89fd062cb45c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e3fece99-68f3-414f-9e92-89fd062cb45c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
    state: {
        count: &lt;/span&gt;0&lt;span&gt;,
        todos: [
            { id: &lt;/span&gt;1, text: '金戈铁马，气吞万里如虎', done: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { id: &lt;/span&gt;2, text: '老骥伏枥，志在千里', done: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { id: &lt;/span&gt;3, text: '周公吐哺，天下归心', done: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { id: &lt;/span&gt;4, text: '但使龙城飞将在，不教胡马度阴山', done: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
        ]
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Vuex允许我们再store中定义&quot;getter&quot;（可以认为是store的计算属性）。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。&lt;/span&gt;
&lt;span&gt;    getters: {
        doneTodos: state &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'...state.getters.donwTodos...'&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.todos.filter(todo =&amp;gt;&lt;span&gt; todo.done)
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Getter也可以接受其他getter作为第二个参数&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;getter在通过属性访问时是作为Vue的响应式系统的一部分缓存其中的&lt;/span&gt;
        doneTodosCount: (state, getters) =&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'...state.getters.doneTodosLength...'&lt;span&gt;, getters.doneTodos)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getters.doneTodos.length;
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过方法访问：通过让getter返回一个函数，来实现给getter传参。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;getter在通过方法访问时，每次都会去进行调用，而不会缓存结果。&lt;/span&gt;
        getTodoById: (state) =&amp;gt; (id) =&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'...state.getters.getTodoById...: '&lt;span&gt;, id);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.todos.find(todo =&amp;gt; todo.id ===&lt;span&gt; id);
        }
    },
    
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 　　Getter应用：Getter会暴露为 store.getters 对象，然后在组件中，我们可以通过this.$store.getters来得到getter。getter里面的属性，可以返回属性，也可以返回方法。如果getter通过属性访问时是作为Vue的响应式系统的一部分缓存，首次调用后再次调用时就会调用缓存，只有该属性的依赖值变化时，再次调用该属性才会重新调用重新缓存。如果getter通过方法访问时，每次都会去进行调用，而不会缓存结果。组件中应用测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f2143070-94e6-4ad0-aa81-38524d74fda8')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_f2143070-94e6-4ad0-aa81-38524d74fda8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f2143070-94e6-4ad0-aa81-38524d74fda8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f2143070-94e6-4ad0-aa81-38524d74fda8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f2143070-94e6-4ad0-aa81-38524d74fda8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;methods:{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;state.getters调用&lt;/span&gt;
            stateGettersProperty(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;getters属性调用, 属性调用会被缓存&lt;/span&gt;
                console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.getters.doneTodos);
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.getters.doneTodosCount);
            },
            stateGettersMethod(){ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法调用,每次都会去进行调用，而不会缓存结果。&lt;/span&gt;
                console.log(&lt;span&gt;this&lt;/span&gt;.$store.getters.getTodoById(2&lt;span&gt;).text);
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.getters.getTodoById(3&lt;span&gt;).text);
            },
            addTodo(){ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加数据&lt;/span&gt;
                let count = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.todos.length;
                let obj &lt;/span&gt;=&lt;span&gt; {
                    id: count &lt;/span&gt;+ 1&lt;span&gt;,
                    text: (count&lt;/span&gt;+1) + '***' + (count+1&lt;span&gt;),
                    done: count &lt;/span&gt;% 2&lt;span&gt;
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.commit('addTodos'&lt;span&gt;, obj);
            },

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　mapGetters也是一个辅助函数，可以将store对象中的getter映射到局部计算属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b2b04398-847f-433d-b012-75c5c846be2b')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b2b04398-847f-433d-b012-75c5c846be2b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b2b04398-847f-433d-b012-75c5c846be2b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b2b04398-847f-433d-b012-75c5c846be2b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b2b04398-847f-433d-b012-75c5c846be2b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
import { mapGetters } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  computed: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用对象展开运算符将 getter 混入 computed 对象中&lt;/span&gt;
&lt;span&gt;    ...mapGetters([
      &lt;/span&gt;'doneTodosCount'&lt;span&gt;,
      &lt;/span&gt;'anotherGetter'&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    ])
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　如果你想将一个 getter 属性另取一个名字，使用对象形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b77f4c17-1acd-441b-9a65-06794a52937f')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_b77f4c17-1acd-441b-9a65-06794a52937f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b77f4c17-1acd-441b-9a65-06794a52937f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b77f4c17-1acd-441b-9a65-06794a52937f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b77f4c17-1acd-441b-9a65-06794a52937f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mapGetters({
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`&lt;/span&gt;
  doneCount: 'doneTodosCount'&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;2.3 Vuex之Mutation和mapMutations&lt;/h3&gt;
&lt;p&gt;　　上面说的mapState、getters、mapGetters都是对store对象中的状态(state)进行应用，如果想更改Vuex的store对象中的状态(state)，必须要用mutation。Vuex中的mutation非常类似于事件：每个mutation都有一个字符串的&lt;strong&gt;&lt;span&gt;事件类型(type)&lt;/span&gt;&lt;/strong&gt;和一个&lt;strong&gt;&lt;span&gt;回调函数(handler)&lt;/span&gt;&lt;/strong&gt;　。这个回调函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a8ea2b49-f560-43a8-b195-451ad1b7715a')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_a8ea2b49-f560-43a8-b195-451ad1b7715a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a8ea2b49-f560-43a8-b195-451ad1b7715a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a8ea2b49-f560-43a8-b195-451ad1b7715a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a8ea2b49-f560-43a8-b195-451ad1b7715a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    count: &lt;/span&gt;1&lt;span&gt;
  },
  mutations: {
    increment (state) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变更状态&lt;/span&gt;
      state.count++&lt;span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　mutation里面handler调用通过store.commit来调用，调用方式有“载荷（payload)&quot;和“对象风格”两种方式：&lt;/p&gt;

&lt;h3&gt;2.4 Vuex之Action和mapActions&lt;/h3&gt;
&lt;p&gt;　　Action类似于mutation，但是Action提交的是mutation，不能直接变更状态；另外Action可以包含任意异步操作。在组件中使用this.$store.dispatch('***')调用action，或者使用mapActions辅助函数将组件中的methods映射为store.dispatch调用。&lt;/p&gt;

&lt;p&gt;State、Getter、Mutation、Action的一些应用测试代码见：&lt;a href=&quot;https://github.com/xiaotanit/tan_vue/blob/master/src/views/vuex/VuexPageB.vue&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaotanit/tan_vue/blob/master/src/views/vuex/VuexPageB.vue&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;tanThree&quot;&gt;3、Vuex之模块化(Module)&lt;/h2&gt;
&lt;p&gt;　　 由于使用单一状态树，应用的所有状态(数据)会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相当臃肿。为了解决这种问题，Vuex允许我们将store分隔成模块(module)。每个模块都有自己的state、mutation、action、getter、甚至是嵌套子模块。&lt;/p&gt;
&lt;p&gt;　　默认情况下，模块内容的action、mutation和getter是注册在全局命名空间的，这样使得多个模块能够对同一mutation或action作出响应。因此为了让模块具有更高的封装度和复用性，我们可以在每个子模块中添加namespaced: true属性，这样表示该模块成为了带命名空间的模块。这样后面再调用该模块的getter、action和mutation时需要带上该模块名称+调用的属性或方法。下面写一个示例代码：&lt;/p&gt;
&lt;p&gt;　　新建三个js文件moduleA.js、moduleB.js、moduleStore.js，其中moduleA和moduleB分别为子模块。&lt;/p&gt;
&lt;p&gt;moduleA.js:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d97006d7-5ade-4935-93e7-099bf7f838cf')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_d97006d7-5ade-4935-93e7-099bf7f838cf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d97006d7-5ade-4935-93e7-099bf7f838cf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d97006d7-5ade-4935-93e7-099bf7f838cf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d97006d7-5ade-4935-93e7-099bf7f838cf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
const state =&lt;span&gt; {
    countA: &lt;/span&gt;99&lt;span&gt;
}

const mutations &lt;/span&gt;=&lt;span&gt; {
    increment(state){
        state.countA&lt;/span&gt;++&lt;span&gt;
    },
    decrement(state){
        state.countA&lt;/span&gt;--&lt;span&gt;
    }
}

const getters &lt;/span&gt;=&lt;span&gt; {
    doubleCount(state){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.countA * 2&lt;span&gt;
    }
}

const actions &lt;/span&gt;=&lt;span&gt; {
    add({ commit }){
        setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            commit(&lt;/span&gt;'increment'&lt;span&gt;)
        }, &lt;/span&gt;50&lt;span&gt;)
    },
    minus({ commit }){
        setTimeout(()&lt;/span&gt;=&amp;gt;&lt;span&gt;{
            commit(&lt;/span&gt;'decrement'&lt;span&gt;)
        }, &lt;/span&gt;500&lt;span&gt;)
    }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    namespaced: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示设置命名空间&lt;/span&gt;
&lt;span&gt;    state,
    mutations,
    getters,
    actions
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;moduleB.js: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1a20186a-44a5-4912-afd2-1d95589608a1')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_1a20186a-44a5-4912-afd2-1d95589608a1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1a20186a-44a5-4912-afd2-1d95589608a1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1a20186a-44a5-4912-afd2-1d95589608a1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1a20186a-44a5-4912-afd2-1d95589608a1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
const state =&lt;span&gt; {
    countB: &lt;/span&gt;11&lt;span&gt;
}

const mutations &lt;/span&gt;=&lt;span&gt; {
    increment(state){
        state.countB&lt;/span&gt;++&lt;span&gt;;
    },
    decrement(state){
        state.countB&lt;/span&gt;--&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;getters类似state里面属性的计算属性&lt;/span&gt;
const getters =&lt;span&gt; {
    doubleCount(state){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.countB * 2&lt;span&gt;;
    }
}

const actions &lt;/span&gt;=&lt;span&gt; {
    add({ commit }){
        commit(&lt;/span&gt;'increment'&lt;span&gt;)
    },
    minus({ commit }){
        commit(&lt;/span&gt;'decrement'&lt;span&gt;)
    }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    namespaced: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    state,
    getters,
    mutations,
    actions
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;moduleStore.js: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
*  当项目大了后，为了责任清晰，目标明确，更易管理，将store拆成多个module形式
* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
import moduleCountA from &lt;/span&gt;'./moduleA'&lt;span&gt;
import moduleCountB from &lt;/span&gt;'./moduleB'&lt;span&gt;
import vuex from &lt;/span&gt;'vuex'&lt;span&gt;
import vue from &lt;/span&gt;'vue'&lt;span&gt;
vue.use(vuex)

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; vuex.Store({
    modules: {
        moduleCountA,
        moduleCountB
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再新建一个VuexPageC.vue页面，测试调用，js代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
import { mapGetters, mapActions, mapMutations } from 'vuex'&lt;span&gt;

    export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
        computed:{
            ...mapGetters({
                doubleCountA: &lt;/span&gt;'moduleCountA/doubleCount'&lt;span&gt;,
                doubleConunB: &lt;/span&gt;'moduleCountB/doubleCount'&lt;span&gt;
            })
        },
        methods: {
            ...mapActions({
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;moduleA模块的actions&lt;/span&gt;
                addCountA: 'moduleCountA/add'&lt;span&gt;,
                minusCountA: &lt;/span&gt;'moduleCountA/minus'&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;moduleB模块的actions&lt;/span&gt;
                addCountB: 'moduleCountB/add'&lt;span&gt;,
                minusCountB: &lt;/span&gt;'moduleCountB/minus'&lt;span&gt;
            }),
            ...mapMutations({
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;moduleA模块的mutions&lt;/span&gt;
                incrementA: 'moduleCountA/increment'&lt;span&gt;,
                decrementA: &lt;/span&gt;'moduleCountA/decrement'&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;moduleB模块的mutions&lt;/span&gt;
                incrementB: 'moduleCountB/increment'&lt;span&gt;,
                decrementB: &lt;/span&gt;'moduleCountB/decrement'&lt;span&gt;
            }),
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面效果如图：&lt;img src=&quot;https://img2018.cnblogs.com/common/454511/202002/454511-20200223230009329-1016187487.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整VuexPageC.vue页面代码见：&lt;a href=&quot;https://github.com/xiaotanit/tan_vue/blob/master/src/views/vuex/VuexPageC.vue&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaotanit/tan_vue/blob/master/src/views/vuex/VuexPageC.vue&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Feb 2020 15:09:00 +0000</pubDate>
<dc:creator>TDX</dc:creator>
<og:description>菜单快捷导航 Vuex是什么东东，有什么应用场景？localStorage和sessionStorage能否替代它？ Vuex知识点State、Getter、Mutaion、Action Vuex模块</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tandaxia/p/12353218.html</dc:identifier>
</item>
</channel>
</rss>