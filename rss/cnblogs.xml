<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>1.shell学习之常用语句 - NQian</title>
<link>http://www.cnblogs.com/lifexy/p/10159634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/10159634.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本章学习内容:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;1.常见符号&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;2.命令分隔符-分号&quot;;&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;3.双分号 &quot;;;&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;4. '单引号和&quot;双引号&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;5.`反引号和$()&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;6.${}和$&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;7.冒号:&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;8.()小括号&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;9.(())双括号&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;10.{}大括号&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;11.[]和[[]]之间的条件测试区别&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;12.~波浪号&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;13.延时&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;14.变量赋值的注意&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.常见符号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;$0　　 当前脚本的文件名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;$n        传递给脚本的参数n,比如$1表示第一个参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;$#        传递给脚本或函数的参数个数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;$*,$@  传递给脚本或函数的所有参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;$?        上个命令的退出状态，或函数的返回值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;$$         当前Shell脚本所在的进程ID&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt; $*
&lt;span&gt;do&lt;/span&gt;
&lt;span&gt;   echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$var&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;           #for循环打印所有参数
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.命令分隔符分号&quot;;&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;作用:可以在同一行上写两个或两个以上的命令&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$filename&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;&lt;span&gt;     #执行两条命令
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File $filename exists.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.双分号;;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;作用:用在case语句,类似于C里面的case,用来承担break作用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;shell的case语法如下所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;变量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;
&lt;span&gt;  &quot;&lt;/span&gt;&lt;span&gt;变量1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      ...
  ;;          &lt;span&gt;#这里的双分号类似于break&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;  &quot;&lt;/span&gt;&lt;span&gt;变量2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      ...
  ;; &lt;br/&gt;&lt;/span&gt;  *&lt;span&gt;)          &lt;span&gt;#匹配剩下的变量n&lt;/span&gt;
     ...
  ;; &lt;br/&gt;&lt;span&gt;esac  &lt;/span&gt;     &lt;span&gt; #case结束语句&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;base

variable&lt;/span&gt;=&lt;span&gt;xyz

&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$variable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
abc) &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\$variable = abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ;;
xyz) &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\$variable = xyz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ;; 
&lt;/span&gt;&lt;span&gt;esac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;打印:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1182576/201812/1182576-20181221235130142-2066832312.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. '单引号和&quot;双引号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单引号:  将会阻止所有特殊字符的解释,被单引号括住的内容都是普通字符串&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;双引号: 引号包围起来的字符串，部分特殊字符将起到它们的作用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

a&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
b&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;${a}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${b}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;打印:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;${a}
this is b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.`反引号和$()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;都是用来实现命令替换的,可以通过这个将命令的输出赋值到一个变量中去&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; $(&lt;span&gt;date&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+ %Y/%m/%d %H:%M:%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)    &lt;span&gt; #运行date命令
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; `&lt;span&gt;date&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+ %Y/%m/%d %H:%M:%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;`      &lt;span&gt;#运行date命令&lt;/span&gt;
c&lt;/span&gt;=$(&lt;span&gt;echo&lt;/span&gt; hello)                      &lt;span&gt;  #打印: c=hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.${}和$&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;都是变量替换,不过${}的好处在于,可以精确变量名称(也可以实现字符串替换等,&lt;span&gt;下章来学习&lt;/span&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;比如:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
A=&lt;span&gt;123&lt;/span&gt;

&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $AB      &lt;span&gt;#错误,将打印空的一行,因为运行时默认会去找变量值AB的解释
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; ${A}B    &lt;span&gt;#正常打印:123B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.冒号:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;空命令,一个什么都不干的命令,该命令的返回值为0(true).&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;示例如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $?   &lt;span&gt; # 打印上个命令的返回值,为0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;由于冒号的返回值为0,所以可以通过&amp;gt;将一个文件清空,但是不会修改该文件权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
: &amp;gt; data.xxx      &lt;span&gt;   #如果该文件不存在,则会创建, 与cat /dev/null &amp;gt;data.xxx的作用相同&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.()小括号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.1当用作命令组时&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;()会启动一个子shell顺序运行,需要注意的是, 由于()里的变量位于子shell中,并不是当前shell中,所以退出()后,变量还是不会变的&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
(a&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a = $a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)   &lt;span&gt; #打印a=2&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a = $a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         &lt;span&gt;  #打印a=1,说明变量a并没有改变&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.2当用作初始化数组时&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例-遍历数组: &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
arr=(&lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;)           &lt;span&gt;  #等价于array[0]=1 array[1]=2 array[2]=3&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;(( i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;${#arr[@]};i++&lt;span&gt;)) 
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; ${arr[i]};
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.3当用作命令替换时&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; $(&lt;span&gt;date&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+ %Y/%m/%d %H:%M:%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)   &lt;span&gt; #运行date命令&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;9.(())双括号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9.1用于for循环时&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(( i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;5&lt;/span&gt;;i++));&lt;span&gt;do&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; $i;&lt;span&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;9.2转换运算进制时,可以通过(())将任意数据转为10进制&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; $((&lt;span&gt;16&lt;/span&gt;#ff))    &lt;span&gt;#打印255&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;9.3 用于整数判断时&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.{}大括号&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;10.1当用做代码块时&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;像一个匿名函数,但是{}里的变量对其它代码来说是可见的, 并且不会开启新的子shell&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例1:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
{
   a&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;   echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a = $a&lt;/span&gt;&lt;span&gt;&quot;  &lt;/span&gt;&lt;span&gt; #打印a=2&lt;/span&gt;&lt;span&gt;
} 
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a = $a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      &lt;span&gt;#打印a=2,说明已被修改&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例2-写入文件:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
{
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is test file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}  &lt;/span&gt;&amp;gt; ./test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;效果:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182576/201812/1182576-20181221235758368-1198654941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.2当用做遍历时&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; {&lt;span&gt;1&lt;/span&gt;..&lt;span&gt;10&lt;/span&gt;}       &lt;span&gt; #打印1 2 3 4 5 6 7 8 9 10&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt;&lt;span&gt; {a..z}
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; $var           &lt;span&gt;#打印a~z字母
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.3也可以用作字符变量截取替换时&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;未完待续,在下一章将学习.&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11.[ ]和[[]]之间的条件测试区别&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;11.1 [ ]的参数有以下几种&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;-z: 判断字符串长度为0则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-n: 判断字符串长度非0则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-o: 或&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-a: 与&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-x: 可执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-r:  可读&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-w: 可写&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;11.2当用作文件判断时,有以下几种参数:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;-e filename&lt;/strong&gt;  :如果 filename存在，则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-d filename &lt;/strong&gt; :如果 filename为目录，则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-f filename &lt;/strong&gt;  :如果 filename为常规文件，则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-L filename&lt;/strong&gt;  : 如果 filename为符号链接，则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-r filename &lt;/strong&gt;  :如果 filename可读，则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-w filename&lt;/strong&gt;  :如果 filename可写，则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-x filename &lt;/strong&gt; :如果 filename可执行，则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-s filename &lt;/strong&gt; :如果文件长度不为0，则为真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-h filename&lt;/strong&gt;  :如果文件是软链接，则为真　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;filename1 -nt filename2&lt;/strong&gt; :如果 filename1比 filename2新，则为真。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;filename1 -ot filename2&lt;/strong&gt; :如果 filename1比 filename2旧，则为真。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;示例-检查当前目录的test文件是否存在:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

testfile&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${PWD}/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; [ -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$testfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ];&lt;span&gt;then&lt;/span&gt;
      &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; $testfile is exist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;11.3 在比较整数时,都使用-eq -ne –gt –ge –lt -le等&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-eq 判断等于(equal)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -eq &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-ne 判断不等于(no equal)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -ne &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-gt 大于(greater than)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -gt &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-ge 大于等于&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -ge &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-lt 小于(less than)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -lt &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-le 小于等于&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -le &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;11.4比较字符串时,只能使用!=和=,如果使用大于小于时,则需要加 &lt;span&gt;\&lt;/span&gt; 转义&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcde&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
b&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; [ -n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; \&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &lt;span&gt;#判断a非0,且a&amp;gt;b
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a &amp;gt; b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;11.5而[[]]也能适用于整数和字符串,而且对于整数或者字符串而言,它们都可以支持&amp;amp;&amp;amp;、||、&amp;lt;和&amp;gt;、!=、==&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a=&lt;span&gt;11&lt;/span&gt;&lt;span&gt;
b&lt;/span&gt;=&lt;span&gt;11&lt;/span&gt;&lt;span&gt;
c&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
e&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; [[ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a = b,c &amp;lt; e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;12.~波浪号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;~    为home目录&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;~+  为当前目录,等价于$PWD&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
A=~&lt;span&gt;
B&lt;/span&gt;=~+
&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $A           &lt;span&gt; #打印home目录
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $B           &lt;span&gt; #打印当前目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;13.延时&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在shell中,延时使用sleep命令&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;     #延时1秒
&lt;/span&gt;&lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;   #延时0.5秒
&lt;/span&gt;&lt;span&gt;sleep&lt;/span&gt;&lt;span&gt; 1m    &lt;span&gt;#睡眠1分
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;sleep&lt;/span&gt; 1h    &lt;span&gt;#睡眠1小时&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;14.变量赋值时的注意&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果变量里存在空白,则必须加上引用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a= &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3    &lt;/span&gt;&lt;span&gt; #将会出错,正确的用法应该是a=&quot;1 2 3&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 21 Dec 2018 16:23:00 +0000</pubDate>
<dc:creator>NQian</dc:creator>
<og:description>本章学习内容: 1.常见符号 2.命令分隔符-分号&quot;;&quot; 3.双分号 &quot;;;&quot; 4. '单引号和&quot;双引号 5.`反引号和$() 6.${}和$</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/10159634.html</dc:identifier>
</item>
<item>
<title>单元测试框架之unittest(一) - davieyang</title>
<link>http://www.cnblogs.com/davieyang/p/10159630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davieyang/p/10159630.html</guid>
<description>&lt;p&gt;一、单元测试的含义&lt;/p&gt;
&lt;p&gt;unittest单元测试框架的设计灵感来源于Junit(Java语言的单元测试框架)，它与其他语言的单元测试框架风格相类似，支持自动化测试、为测试共享setUp和shutDown、它可以在将测试用例聚合到一起形成一个集合一起执行的同时在测试报告中展示独立的测试结果。&lt;/p&gt;
&lt;p&gt;为了达到此目的，unittest支持几个重要的面向对象式的概念：&lt;/p&gt;
&lt;p&gt;1、test fixture&lt;/p&gt;
&lt;p&gt;　　一个test fixture所做的事情是执行单个或多个测试用例时的准备工作和执行结束后的一些相关清理工作，这包括：创建临时或代理数据库、目录或开始服务器进程。&lt;/p&gt;
&lt;p&gt;2、test case&lt;/p&gt;
&lt;p&gt;　　一个test case 是一个独立的测试单元，针对于一组特定的输入得到的特殊相应的验证，通过继承unittest提供的基类TestCase， 然后可以创建新的测试用例&lt;/p&gt;
&lt;p&gt;3、test suite&lt;/p&gt;
&lt;p&gt;　　一个test suite 是一组测试用例的集合，也可以是一组test suite的集合，也可以两者混合的集合，test suite就是用来聚合你想要一起执行的测试用例的&lt;/p&gt;
&lt;p&gt;4、test runner&lt;/p&gt;
&lt;p&gt;　　一个test runner 是一个协调测试执行并向用户提供执行结果的组建，它可以使用图形界面、文本界面或返回一个特殊值标识测试执行的结果&lt;/p&gt;
&lt;p&gt;二、实例代码&lt;/p&gt;
&lt;p&gt;下面我们看Python官方给的一个简单的小例子，来测试三个字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestStringMethods(unittest.TestCase):  &lt;span&gt;# 测试类继承了unittest.TestCase类，因此在该类里可以创建新的测试用例

    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_upper(self):
        self.assertEqual(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.upper(), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FOO&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  &lt;span&gt;# ‘foo’是一个字符串，upper()方法会将这个字符串转成大写，assertEqual是unittest提供的一个断言方法，用来比较逗号前后两个值是否相等

    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_isupper(self):
        self.assertTrue(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FOO&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.isupper())  &lt;span&gt;# assertTrue也是unittest提供的断言方法，用来判断括号内的内容是真是假，如果是真则断言成功，否则为失败，'FOO'是个字符串并且是大写，调用isupper()方法，返回结果&lt;/span&gt;
        self.assertFalse(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.isupper())  &lt;span&gt;# assertFalse则正好相反，如果括号内返回为假则断言成功，否则为失败

    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_split(self):
        s &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.assertEqual(s.split(), [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; check that s.split fails when the separator is not a string&lt;/span&gt;
&lt;span&gt;        with self.assertRaises(TypeError):
            s.split(&lt;/span&gt;2&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码解析：&lt;/p&gt;
&lt;p&gt;在第三个用例里，定义了一个字符串，s='hello world', 然后进行了断言，断言的条件里调用了一个split()方法，实际上初学者看到这会比较懵，s.split()到底返回的是什么，它是否等于逗号后边['hello', 'world']?&lt;/p&gt;
&lt;p&gt;学这个东西就是要多试试，那么接下来我们进行一个尝试&lt;/p&gt;
&lt;p&gt;启动命令行CMD，进入python环境&lt;/p&gt;
&lt;p&gt;定义一个字符串  s = 'hello world', 然后 print(s)回车，我们看一下结果应该是  hello world&lt;/p&gt;
&lt;p&gt;那么如果我们print(s.split())呢，结果应该是['hello', 'world'], 到此我们就得到了答案，第三条用例里的断言self.assertEqual(s.split(), ['hello', 'world'])是成功，继续向split()对字符串'hello world'做了什么？&lt;/p&gt;
&lt;p&gt;如果我们print(s.split(2)) 会是什么结果？  如果我们print(s.split('o'))又会是什么结果？&lt;/p&gt;
&lt;p&gt;最后的unittest.main()，有了它我们就有了一个简单的方式执行这个脚本，unittest.main()提供了命令行界面运行脚本的方式&lt;/p&gt;
&lt;p&gt;假设我们上边的脚本保存在文件testingunit.py里，然后我们启动命令行，输入python  testingunit.py  看看是个什么结果？&lt;/p&gt;
&lt;p&gt;如果我们执行python testingunit.py -v 又是什么结果？&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 16:22:00 +0000</pubDate>
<dc:creator>davieyang</dc:creator>
<og:description>一、单元测试的含义 unittest单元测试框架的设计灵感来源于Junit(Java语言的单元测试框架)，它与其他语言的单元测试框架风格相类似，支持自动化测试、为测试共享setUp和shutDown、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davieyang/p/10159630.html</dc:identifier>
</item>
<item>
<title>力荐！这些工具可以帮你写出干净的代码 - 燕十三丶</title>
<link>http://www.cnblogs.com/Yanss/p/10159628.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yanss/p/10159628.html</guid>
<description>&lt;p&gt;&lt;strong&gt;作者｜Adeel Imran译者｜无明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;想写出好代码，却不知道从哪里开始？想删除死代码？想在代码库中找出未被使用的变量？想在代码中找出有问题的模式？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你是多元化团队的负责人吗？你的团队中有新来的开发人员吗？你担心他们会写出不符合标准的代码吗？在代码评审时是否花了一整天的时间去检查代码标准，而不是实际的逻辑实现？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我一直在做这样的事情，经常忙得像热锅上的蚂蚁。但从现在开始，我们要保证永远不再担心这类问题。在阅读本文过程中，如果遇到困难，可以参考代码库（https://github.com/adeelibr/react-starter-kit）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文更多地是针对 React 应用程序，但同样适用于其他 Web 项目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;让我们从 Prettier 开始吧 Prettier 是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prettier 是一种代码格式化程序，它以特定的方式为你格式化代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请看这个 GIF：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1563071/201812/1563071-20181222001818961-1011406505.gif&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 我们为什么需要 Prettier？1. 清理现有代码库：通过单个命令行清理代码库。想象一下清理超过 20,000 行代码的代码库会是怎样的一种情景。2. 易于适用：Prettier 在格式化代码时使用争议最少的编码风格。因为是开源的，很多人已经在修复一些边缘情况和优化体验方面进行了多次迭代。3. 编写代码：人们没有意识到的是，他们花了很多时间用于格式化代码，这浪费了他们太多的精神能量。让 Prettier 来处理格式化的事情，开发人员就可以专注在核心业务逻辑上。Prettier 可以将效率提高 10％。4. 帮助新手：如果你是一位与优秀工程师并肩工作的新手，并且你希望自己看起来很酷，可以写出干净的代码，那就使用 Prettier 吧。 如何设置 Prettier？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建一个叫作 app 的文件夹，进入该文件夹，在命令行中敲入：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;npm init -y&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这将在 app 文件夹中创建一个 package.json 文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我将在本文中使用 yarn，但你也可以使用 npm。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装我们的第一个依赖项：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;yarn add --dev prettier&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这将安装 package.json 中指定的开发依赖项，如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;react-boiler-plate&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A react boiler plate&quot;,
  &quot;main&quot;: &quot;src/index.js&quot;,
  &quot;author&quot;: &quot;Adeel Imran&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;scripts&quot;: {
    &quot;prettier&quot;: &quot;prettier --write src/**/*.js&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;prettier&quot;: &quot;^1.14.3&quot;
  }
}&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;稍后我会解释&lt;code&gt;“prettier”: “prettier — write src/**/*.js”&lt;/code&gt;的作用，现在先让我们在 app 文件夹中创建一个 src/ 文件夹。在 src/ 文件夹中，再创建一个名为 index.js 的文件——名字可以随意起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 index.js 文件中，按原样粘贴这句话：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;let person =                     {
  name: &quot;Yoda&quot;,
                designation: 'Jedi Master '
                };




              function trainJedi (jediWarrion) {
if (jediWarrion.name === 'Yoda') {
  console.log('No need! already trained');
}
console.log(`Training ${jediWarrion.name} complete`)
              }


trainJedi(person)
              trainJedi({ name: 'Adeel',
              designation: 'padawan' 
  });&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;到目前为止，我们有了一个 src/app/index.js 文件，包含了一些难看的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以做三件事：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用自动化工具；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我打算选择第二项，所以我们安装了一个依赖项，并在 package.json 中声明了 Prettier。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在在 app 根文件夹中创建一个 prettier.config.js 文件，并在其中添加一些 Prettier 规则：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;module.exports = {
  printWidth: 100,
  singleQuote: true,
  trailingComma: 'all',
  bracketSpacing: true,
  jsxBracketSameLine: false,
  tabWidth: 2,
  semi: true,
};&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;printWidth 将确保你的单行代码不会超过 100 个字符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;singleQuote 会将所有双引号转换为单引号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trailingComma 将确保在最后一个对象属性的末尾会有一个逗号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bracketSpacing 在对象字面量之间打印空格：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;If bracketSpacing is true - Example: { foo: bar }
If bracketSpacing is false - Example: {foo: bar}&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;jsxBracketSameLine 将在多行 JSX 元素的最后一行放置&amp;gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;// true example
&amp;lt;button
  className=&quot;prettier-class&quot;
  id=&quot;prettier-id&quot;
  onClick={this.handleClick}&amp;gt;
  Click Here
&amp;lt;/button&amp;gt;

// false example
&amp;lt;button
  className=&quot;prettier-class&quot;
  id=&quot;prettier-id&quot;
  onClick={this.handleClick}
&amp;gt;
  Click Here
&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;tabWidth 指定单个缩进的空格数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果 semi 设置为 true，将在语句末尾加上 ;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在让我们来说说这个脚本的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;“prettier”: “prettier  — write src/**/*.js”&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;它的意思是运行 prettier，并让它在 src/ 文件夹中查找所有的.js 文件。--write 标志告诉 prettier 要把格式化好的内容保存到文件中，并找出格式化过程中发现的任何异常。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在在终端中运行这个脚本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;yarn prettier&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这是我在运行代码时看到的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1563071/201812/1563071-20181222001842626-243595923.gif&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESLint 什么是代码 linter？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;代码 linting 是一种代码静态分析，通常被用于查找不符合某些样式指南的有问题的模式或代码。大多数编程语言都有代码 linting，编译器有时会在编译过程中加入 linting。——来自 ESLint&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么 JavaScript 需要 linter？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于 JavaScript 是动态类型的，而且是一种松散类型的语言，因此开发人员在使用这门语言时很容易犯错。因为不经过编译，所以通常需要在执行.js 文件的情况下才能发现语法或其他错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;像 ESLint 这样的 linting 工具可以帮助开发人员在不执行 JavaScript 代码的情况下发现问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 是什么让 ESLint 如此特别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESLint 中的所有东西都是可插拔的，你甚至可以在运行时添加规则。你添加的每个 linting 规则都是独立的，任何一个规则都可以独自打开或关闭。每个规则都可以设置为警告或错误级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在有 2 个流行的风格指南：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Google JavaScript Style Guide（https://google.github.io/styleguide/jsguide.html）；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Airbnb JavaScript Style Guide（https://github.com/airbnb/javascript#table-of-contents）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我一直在使用 Airbnb 的风格指南。这个风格指南一直有人在维护，在本文中，我将使用受 Airbnb 风格指南启发的规则集。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先更新 package.json 文件：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;react-boiler-plate&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A react boiler plate&quot;,
  &quot;main&quot;: &quot;src/index.js&quot;,
  &quot;author&quot;: &quot;Adeel Imran&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;scripts&quot;: {
    &quot;lint&quot;: &quot;eslint --debug src/&quot;,
    &quot;lint:write&quot;: &quot;eslint --debug src/ --fix&quot;,
    &quot;prettier&quot;: &quot;prettier --write src/**/*.js&quot;
  },
  &quot;husky&quot;: {
    &quot;hooks&quot;: {
      &quot;pre-commit&quot;: &quot;lint-staged&quot;
    }
  },
  &quot;lint-staged&quot;: {
    &quot;*.(js|jsx)&quot;: [&quot;npm run lint:write&quot;, &quot;git add&quot;]
  },
  &quot;devDependencies&quot;: {
    &quot;babel-eslint&quot;: &quot;^8.2.3&quot;,
    &quot;eslint&quot;: &quot;^4.19.1&quot;,
    &quot;eslint-config-airbnb&quot;: &quot;^17.0.0&quot;,
    &quot;eslint-config-jest-enzyme&quot;: &quot;^6.0.2&quot;,
    &quot;eslint-plugin-babel&quot;: &quot;^5.1.0&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.12.0&quot;,
    &quot;eslint-plugin-jest&quot;: &quot;^21.18.0&quot;,
    &quot;eslint-plugin-jsx-a11y&quot;: &quot;^6.0.3&quot;,
    &quot;eslint-plugin-prettier&quot;: &quot;^2.6.0&quot;,
    &quot;eslint-plugin-react&quot;: &quot;^7.9.1&quot;,
    &quot;husky&quot;: &quot;^1.1.2&quot;,
    &quot;lint-staged&quot;: &quot;^7.3.0&quot;,
    &quot;prettier&quot;: &quot;^1.14.3&quot;
  }
}&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在开始进行配置之前，先让我们来看看每个依赖包的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;babel-eslint：这个包让你可以轻松在 Babel 上使用 lint。如果你不使用 ESLint 尚不支持的 Flow 或实验性功能，则不一定需要这个插件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint：这是 lint 代码所需的主要工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint-config-airbnb：这个包提供了所有 Airbnb 的 ESLint 配置，你可以修改它们。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint-plugin-babel：babel-eslint 的插件伴侣。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint-plugin-import：这个插件旨在支持 ES2015+（ES6+）的导入 / 导出语法，并防止出现拼写错误的文件路径和导入名称。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint-plugin-jsx-a11y：适用于 JSX 元素可访问性规则的 linting 规则。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint-plugin-prettier：让 ESLint 与 Prettier 的使用更顺畅。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint-plugin-react：特定于 React 的 linting 规则。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint-config-jest-enzyme：用于特定于 React 和 Enzyme 的全局变量。这个 lint 配置让 ESLint 知道有哪些全局变量，并且不会针对它们发出警告——有点像断言 it 和 describe。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eslint-plugin-jest：Jest 的 ESLint 插件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;husky：在自动化部分会进行更多介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lint-staged：在自动化部分会进行更多介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在我们已经有了基本的了解，接下来可以开始了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 app/ 根目录创建.eslintrc.js 文件：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;module.exports = {
    env: {
        es6: true,
        browser: true,
        node: true,
    },
    extends: ['airbnb', 'plugin:jest/recommended', 'jest-enzyme'],
    plugins: [
        'babel',
        'import',
        'jsx-a11y',
        'react',
        'prettier',
    ],
    parser: 'babel-eslint',
    parserOptions: {
        ecmaVersion: 6,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true
        }
    },
    rules: {
        'linebreak-style': 'off', // Don't play nicely with Windows.
        'arrow-parens': 'off', // Incompatible with prettier
        'object-curly-newline': 'off', // Incompatible with prettier
        'no-mixed-operators': 'off', // Incompatible with prettier
        'arrow-body-style': 'off', // Not our taste?
        'function-paren-newline': 'off', // Incompatible with prettier
        'no-plusplus': 'off',
        'space-before-function-paren': 0, // Incompatible with prettier
        'max-len': ['error', 100, 2, { ignoreUrls: true, }], // airbnb is allowing some edge cases
        'no-console': 'error', // airbnb is using warn
        'no-alert': 'error', // airbnb is using warn
        'no-param-reassign': 'off', // Not our taste?
        &quot;radix&quot;: &quot;off&quot;, // parseInt, parseFloat radix turned off. Not my taste.
        'react/require-default-props': 'off', // airbnb use error
        'react/forbid-prop-types': 'off', // airbnb use error
        'react/jsx-filename-extension': ['error', { extensions: ['.js'] }], // airbnb is using .jsx
        'prefer-destructuring': 'off',
        'react/no-find-dom-node': 'off', // I don't know
        'react/no-did-mount-set-state': 'off',
        'react/no-unused-prop-types': 'off', // Is still buggy
        'react/jsx-one-expression-per-line': 'off',

        &quot;jsx-a11y/anchor-is-valid&quot;: [&quot;error&quot;, { &quot;components&quot;: [&quot;Link&quot;], &quot;specialLink&quot;: [&quot;to&quot;] }],
        &quot;jsx-a11y/label-has-for&quot;: [2, {
            &quot;required&quot;: {
                &quot;every&quot;: [&quot;id&quot;]
            }
        }], // for nested label htmlFor error

        'prettier/prettier': ['error'],
    },
};&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;还要在 app/ 根目录中添加.eslintignore 文件：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;/.git
/.vscode
node_modules&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;我们先介绍一下.eslintrc.js 文件的作用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先把它拆分一下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;module.exports = { 
   env:{}, 
   extends: {}, 
   plugin: {}, 
   parser: {}, 
   parserOptions: {}, 
   rules: {},
};&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. env：用于预定义全局变量。在我们的例子中，可用的环境包括 es6、browser 和 es6。es6 将启用除模块之外的所有 ECMAScript 6 功能。browser 将添加所有浏览器全局变量，如 Windows。node 将添加 Node 全局变量和 Node 作用域，比如 global。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. extends：字符串数组——扩展了之面配置的额外配置选项。现在我们正在使用 airbnb 的 linting 规则，这些规则被扩展到 jest，然后是 jest-enzyme。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. plugins：插件基本上就是我们想要使用的 linting 规则。现在我们正在使用 babel、import、jsx-a11y、react、prettier。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. parser：默认情况下，ESLint 使用 Espree，但因为我们使用了 babel，我们还需要使用 Babel-ESLint。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. parserOptions：如果我们将 Espree 的默认解析器更改为 babel-eslint，需要指定 parserOptions——它是必需的。我通过选项告诉 ESLint，ecmaVersion 是 6。因为我们在 EcmaScript 模块（而不是 script）中编写代码，所以我们将 sourceType 指定为 module。由于我们使用了 React，引入了 JSX，所以在 ecmaFeatures 中加了 jsx 选项，并将其设置为 true。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. rules：我们已经扩展并通过插件添加的所有规则，我们可以更改或覆盖它们。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 现在介绍一下.eslintignore&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.eslintignore 里包含了我们不希望 ESLint 对它们进行 lint 的路径列表。这里我只指定三个：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. /.git——我不希望 Git 相关文件被 lint。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. /.vscode——由于我使用的是 VS Code，这个编辑器提供了自己的配置文件，我不希望配置文件被 lint。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. node_modules——我不希望依赖项被 lint，所以把这个目录也添加到列表中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来让我们来看看 package.json 中新添加的脚本。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;&quot;lint&quot;: &quot;eslint --debug src/&quot;
&quot;lint:write&quot;: &quot;eslint --debug src/ --fix&quot;&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$ yarn lint——运行这个命令，它将遍历 src/ 中的所有文件，并在每个找到错误的文件中提供详细日志，你可以手动打开这些文件并更正错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img class=&quot; __bg_gif&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/XIibZ0YbvibkWQLcTicXA94hmRMt5RAW2qwFZPElaK0QxqcMbN6aw5ByibWUwkS9SpmfN1dh5Jao9nmQ8iakHBzicNyQ/640?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4155206286836935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/XIibZ0YbvibkWQLcTicXA94hmRMt5RAW2qwFZPElaK0QxqcMbN6aw5ByibWUwkS9SpmfN1dh5Jao9nmQ8iakHBzicNyQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1018&quot; data-order=&quot;2&quot; data-fail=&quot;0&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$ yarn lint:write——运行这个命令，它将执行与上述命令相同的操作。不同的地方在于，如果它可以纠正它发现的错误，它将纠正它们，并尝试从代码中尽可能多地移除代码坏气味。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;让它更自动化一些&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;到目前为止，我们设置好了 prettier 和 eslint，但每次我们都要运行脚本。接下来我们让它更加自动化一些。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 在编辑器中按下 ctrl + s 时格式化和 lint 代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 每次提交代码时，自动对代码进行 lint 和格式化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 要在保存代码时进行格式化和 lint，需要使用像 VS Code 这样的编辑器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装 ESLint 扩展插件。在此（https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint）下载插件或在 VS Code 编辑器中按下 ctrl + shift + x 打开扩展模块，搜索 eslint，将出现一系列插件。安装 Dirk Baeumer 开发的那个。安装完成后，点击 reload 按钮重新启动编辑器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装好这个插件后，在 app/ 根文件夹中创建一个名为.vscode/ 的文件夹 ——不要忘了那个点号，这个非常重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在文件夹中创建一个 settings.json 文件，如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;{
  &quot;editor.formatOnSave&quot;: false,
  &quot;eslint.autoFixOnSave&quot;: true,
}&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，当你运行 yarn lint:write 时，它也会 lint 和美化你的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;试想一下，如果你有 2 万行代码，然后通过手动的方式进行审计和改进，然后再想象一下用一个命令就可以完成所有事情。手动方法可能需要 30 天，而自动方法可能只需要 30 秒。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脚本已经设置好了，每次点击保存时，编辑器都会对特定文件做出神奇的回应。但是，并不是团队中的每个人都会选择使用 VS Code。不过没关系，我们可以更自动化一些。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;husky husky 是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;husky（https://github.com/typicode/husky）是一个 Git 钩子，你可以在提交代码前或在将代码推送到分支时执行某些特定的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你所要做的就是安装 husky：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;yarn add --dev husky&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;然后在 package.json 文件中添加以下内容：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;&quot;husky&quot;: {    
   &quot;hooks&quot;: {      
     &quot;pre-commit&quot;: &quot;YOUR_COMMAND_HERE&quot;, 
     &quot;pre-push&quot;: &quot;YOUR_COMMAND_HERE&quot;   
   }  
},&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;每次在提交或推送代码时，它都会执行某个脚本或命令——比如运行测试用例或格式化代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lint-staged lint-staged 是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lint-staged（https://github.com/okonet/lint-staged）可以在暂存（Git staged）文件上运行 linter，这样就不会将错误的代码推送到分支上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要用 lint-staged？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在提交代码之前进行 lint 是很有意义的，你可以确保没有错误进入到代码库中，并且可以强制应用代码样式。但在整个项目上运行 lint 过程会很慢，而且有些 lint 结果可能无关紧要。你可能只想对要提交的文件进行 lint。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个项目提供了一个脚本，这个脚本将执行任意的 shell 任务，并将暂存文件列表作为参数，按指定的通配模式进行文件过滤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你要做的是安装 lint-staged：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;yarn add --dev lint-staged&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;然后在 package.json 文件中添加：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;&quot;lint-staged&quot;: {    
   &quot;*.(js|jsx)&quot;: [&quot;npm run lint:write&quot;, &quot;git add&quot;]  
},&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这段配置的意思是先运行 lint:write 命令，然后将文件添加到暂存区域。它仅针对.js 和.jsx 文件运行这个命令，但你也可以根据需要针对其他文件运行这个命令。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;husky 与 lint-staged 一起使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次提交代码之前，都会运行一个叫作 lint-staged 的脚本，这个脚本将运行 npm run lint:write 命令，这个将 lint 并格式化你的代码，然后将代码添加到暂存区并提交。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终的 package.json 文件应如下所示。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;react-boiler-plate&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A react boiler plate&quot;,
  &quot;main&quot;: &quot;src/index.js&quot;,
  &quot;author&quot;: &quot;Adeel Imran&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;scripts&quot;: {
    &quot;lint&quot;: &quot;eslint --debug src/&quot;,
    &quot;lint:write&quot;: &quot;eslint --debug src/ --fix&quot;,
    &quot;prettier&quot;: &quot;prettier --write src/**/*.js&quot;
  },
  &quot;husky&quot;: {
    &quot;hooks&quot;: {
      &quot;pre-commit&quot;: &quot;lint-staged&quot;
    }
  },
  &quot;lint-staged&quot;: {
    &quot;*.(js|jsx)&quot;: [&quot;npm run lint:write&quot;, &quot;git add&quot;]
  },
  &quot;devDependencies&quot;: {
    &quot;babel-eslint&quot;: &quot;^8.2.3&quot;,
    &quot;eslint&quot;: &quot;^4.19.1&quot;,
    &quot;eslint-config-airbnb&quot;: &quot;^17.0.0&quot;,
    &quot;eslint-config-jest-enzyme&quot;: &quot;^6.0.2&quot;,
    &quot;eslint-plugin-babel&quot;: &quot;^5.1.0&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.12.0&quot;,
    &quot;eslint-plugin-jest&quot;: &quot;^21.18.0&quot;,
    &quot;eslint-plugin-jsx-a11y&quot;: &quot;^6.0.3&quot;,
    &quot;eslint-plugin-prettier&quot;: &quot;^2.6.0&quot;,
    &quot;eslint-plugin-react&quot;: &quot;^7.9.1&quot;,
    &quot;husky&quot;: &quot;^1.1.2&quot;,
    &quot;lint-staged&quot;: &quot;^7.3.0&quot;,
    &quot;prettier&quot;: &quot;^1.14.3&quot;
  }
}&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;现在，每当你提交代码时：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;$ git add .
$ git commit -m &quot;some descriptive message here&quot;&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;它将根据.eslintrc.js 文件的所有规则对代码进行 lint 和格式化。有了这个，你就可以确保没有坏代码被推到生产环境中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在介绍一下 EditorConfig&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先在 app/ 根文件夹中创建一个.editorconfig 文件，然后在该文件中粘贴以下代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;code&gt;# EditorConfig is awesome: http://EditorConfig.org

# top-most EditorConfig file
root = true

[*.md]
trim_trailing_whitespace = false

[*.js]
trim_trailing_whitespace = true

# Unix-style newlines with a newline ending every file
[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
insert_final_newline = true
max_line_length = 100&lt;/code&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; 那么 EditorConfig 是什么东西？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并不是每个人都会使用 VS Code，所以为了让每个人保持统一（例如在制表符空格或换行方面），我们使用.editorconfig，这样有助于强制执行某些规则。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持 EditorConfig（https://editorconfig.org/）的编辑器包括 Web Storm、App Code、Atom、Eclipse、Emacs、bbedit，等等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上述的配置将执行以下操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缩进大小为 2；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英文原文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;https://medium.freecodecamp.org/these-tools-will-help-you-write-clean-code-da4b5401f68e&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 16:19:00 +0000</pubDate>
<dc:creator>燕十三丶</dc:creator>
<og:description>作者｜Adeel Imran译者｜无明 想写出好代码，却不知道从哪里开始？想删除死代码？想在代码库中找出未被使用的变量？想在代码中找出有问题的模式？ 你是多元化团队的负责人吗？你的团队中有新来的开发人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yanss/p/10159628.html</dc:identifier>
</item>
<item>
<title>2018年个人心灵历程记录 - 乀崋</title>
<link>http://www.cnblogs.com/fameg/p/10159585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fameg/p/10159585.html</guid>
<description>&lt;p&gt;&lt;span&gt;这一年一晃过去了，繁忙之余总给我一种仿佛昨天一样，很多想法很多事情”似曾相识“。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也不知道该怎么评价这一年，关于评价，再容我想想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先就这一年的角色无序的梳理一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、我是一名讲师。从公司的新人培训、项目人员培训、公司项目客串培训、外聘培训等。内容包括ETL(informatica)、Oracle、OGG、企业信息化、大数据分析、电网数据中心等等，人数在数人到百人左右不等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、我是一名项目经理、项目集经理。管理多个项目，或大或小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、我是一名售前顾问。配合、支撑商务做项目销售，达成项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、我是一名需求分析顾问。挖掘客户需求、解决客户需求等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、我是一名电网信息化架构师。描绘蓝图，设计信息化总体架构、功能模块拆解、技术选型等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、我是一名问题导向型得”产品经理“。根据信息化建设问题，设计具体产品改善、解决问题，产品规模或大或小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、我是一名 “消防员”。这个不用解释，我想大家都知道。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或许这是有些人口中得”全能“，做了这么多，却无从总结，无法量化价值。现有的项目模式真实越来越看不懂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面再说说学习：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、报考PMP，于9月份参加考试并通过，这或许是这一年最有价值的事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、备考在职研究生，但备考计划不成体系，断断续续。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、学习一门口语，也没能坚持，断断续续。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、学习一门开发语言，Python学了一半。农历年前争取基础内容看完。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、听书、读书，樊等读书会两年会员，今年算是整整听了一年，也买了不少书，有10本吧，包括技术、管理、语言、育儿、心灵、综合类，其中2本作为工具的除外，完整看完的应该是3本，其他的都还是看当中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我在脉脉上发过一次实名动态，写道”毕业7年，在一家公司干了6年，发现好像啥也不会了，真的很讽刺。回头思考，一路走来，不是我项目要具备什么养的能力，二是公司、项目需要我具备什么样得能力，庆幸我还具备良好的学习能力。“&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公司得一位老领导这样讲：”佛讲三重境界：一重看山是山，看水是水；二重看山不是山，看水不是水；三重看山还是山，看水还是水。我还在第二重，自己去体会。“&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可是我体会了很久还是没有体会到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我总是再给自己找一条路，一条在何时何地都具备个人竞争力得路。但没有找到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我总是能体会到自身能力的缺陷，因为看见了身边一些人，很难想象5年、10年后现在的他们就是我的缩影，我确实无法接受。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我总是有一颗 ”不满于现状的心“。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孔子说 ”三十而立”，大概是说在前面阶段的学习和充实自己修养的基础上，确立自己在为人处事，对待生活的态度和原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么三十+的我，从年龄上讲立，但是从知识储备、能力储备上还未立。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;路还很长，有过迷茫有过失落有过抱怨有过奋斗。但愿今后少一些负面情绪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成长的路上应当有位导师，既然没有，那就对人不要有私心、乐于于人分享，那就撸起袖子加油。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 15:55:00 +0000</pubDate>
<dc:creator>乀崋</dc:creator>
<og:description>这一年一晃过去了，繁忙之余总给我一种仿佛昨天一样，很多想法很多事情”似曾相识“。 也不知道该怎么评价这一年，关于评价，再容我想想。 先就这一年的角色无序的梳理一下： 1、我是一名讲师。从公司的新人培训</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fameg/p/10159585.html</dc:identifier>
</item>
<item>
<title>变量赋值（初学者） - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10159557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10159557.html</guid>
<description>&lt;p&gt;各类数值型数据之间的混合运算：变量的数据类型是可以相互转换的。转换的方法有两种，一种是自动转换，一种是强制转换。&lt;/p&gt;
&lt;p&gt;1、自动转换：自动转换发生在不同数据类型的量混合运算时，由编译系统自动完成的。&lt;/p&gt;
&lt;p&gt;自动转换遵循以下规则：（1）若参与运算量的类型不同，则先转换成同一类型，然后进行运算。&lt;/p&gt;
&lt;p&gt;（2）转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。&lt;/p&gt;
&lt;p&gt;a.若两种类型的字节数不同，转换成字节数高的类型  &lt;br/&gt;b.若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型&lt;/p&gt;
&lt;p&gt;（3）所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。&lt;/p&gt;
&lt;p&gt;（4）char型和short型参与运算时，必须先转换成int型。&lt;/p&gt;
&lt;p&gt;（5）在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入向前舍入。&lt;/p&gt;
&lt;p&gt;类型自动转换的规则：char,short→int→unsigned→long→double&lt;/p&gt;
&lt;p&gt;练习：void main()&lt;br/&gt;{&lt;br/&gt; float PI=3.14159;&lt;br/&gt; int s,r=5;&lt;br/&gt; s=r*r*PI;&lt;br/&gt; printf(&quot;s=%d\n&quot;,s);&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;该程序中，PI为实型；s，r为整型，在执行s=r*r*PI语句时，r和PI都转换成double进行计算，计算结果也为double型。但由于s为整型，故赋值结果仍为整型，舍去了小数部分。&lt;/p&gt;
&lt;p&gt;2、强制类型转换&lt;/p&gt;
&lt;p&gt;强制类型转换是通过类型转换运算来实现的。其一般形式为：（类型说明符）（表达式），其功能是把表达式的运算结果强制转化成类型说明符所表示的类型。例：（float) a     把a转化为实型&lt;/p&gt;
&lt;p&gt;注意：（1）类型说明符和表达式都必须加括号（单个变量可以不加括号）。如把（int）（x+y）写为（int）x+y就变成了把x转换成int型后再与y相加。&lt;/p&gt;
&lt;p&gt;（2）无论是强制转换还是自动转换，都是为了本次运算的需要而临时对变量的数据长度进行的临时性转换，而不改变数据说明时对该变量定义的类型。&lt;/p&gt;
&lt;p&gt;例：程序：&lt;/p&gt;
&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;void main()&lt;br/&gt;{&lt;br/&gt; printf(&quot;(int)f=%d,f=%f\n&quot;,(int)f,f);&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;可以很好的说明以上观点。&lt;/p&gt;

</description>
<pubDate>Fri, 21 Dec 2018 15:47:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>各类数值型数据之间的混合运算：变量的数据类型是可以相互转换的。转换的方法有两种，一种是自动转换，一种是强制转换。 1、自动转换：自动转换发生在不同数据类型的量混合运算时，由编译系统自动完成的。 自动转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10159557.html</dc:identifier>
</item>
<item>
<title>Spring Boot 之订制 logo - 静默虚空</title>
<link>http://www.cnblogs.com/jingmoxukong/p/10159493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingmoxukong/p/10159493.html</guid>
<description>&lt;p&gt;Spring Boot 启动时默认会显示以下 logo：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.1.1.RELEASE)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，Spring Boot 支持自定义 logo 的功能。&lt;/p&gt;
&lt;p&gt;让我们来看看如何实现的。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;只要你在 &lt;code&gt;resources&lt;/code&gt; 目录下放置名为 &lt;code&gt;banner.txt&lt;/code&gt;、&lt;code&gt;banner.gif&lt;/code&gt; 、&lt;code&gt;banner.jpg&lt;/code&gt; 或 &lt;code&gt;banner.png&lt;/code&gt; 的文件，Spring Boot 会自动加载，将其作为启动时打印的 logo。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于文本文件，Spring Boot 会将其直接输出。&lt;/li&gt;
&lt;li&gt;对于图像文件（ &lt;code&gt;banner.gif&lt;/code&gt; 、&lt;code&gt;banner.jpg&lt;/code&gt; 或 &lt;code&gt;banner.png&lt;/code&gt; ），Spring Boot 会将图像转为 ASCII 字符，然后输出。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;变量&quot;&gt;变量&lt;/h3&gt;
&lt;p&gt;banner.txt 文件中还可以使用变量来设置字体、颜色、版本号。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.6678966789668&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;${application.version}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MANIFEST.MF&lt;/code&gt; 中定义的版本。如：&lt;code&gt;1.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;${application.formatted-version}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MANIFEST.MF&lt;/code&gt; 中定义的版本，并添加一个 &lt;code&gt;v&lt;/code&gt; 前缀。如：&lt;code&gt;v1.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;${spring-boot.version}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Spring Boot 版本。如：&lt;code&gt;2.1.1.RELEASE&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;${spring-boot.formatted-version}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Spring Boot 版本，并添加一个 &lt;code&gt;v&lt;/code&gt; 前缀。如：&lt;code&gt;v2.1.1.RELEASE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5.265306122449&quot;&gt;&lt;td&gt;&lt;code&gt;${Ansi.NAME}&lt;/code&gt; (or &lt;code&gt;${AnsiColor.NAME}&lt;/code&gt;, &lt;code&gt;${AnsiBackground.NAME}&lt;/code&gt;, &lt;code&gt;${AnsiStyle.NAME}&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;ANSI 颜色、字体。更多细节，参考：&lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java&quot;&gt;&lt;code&gt;AnsiPropertySource&lt;/code&gt;&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;${application.title}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MANIFEST.MF&lt;/code&gt; 中定义的应用名。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;在 Spring Boot 项目中的 &lt;code&gt;resources&lt;/code&gt; 目录下添加一个名为 banner.txt 的文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;${AnsiColor.BRIGHT_YELLOW}${AnsiStyle.BOLD}
 ________  ___  ___  ________   ___       __   ___  ___
|\   ___ \|\  \|\  \|\   ___  \|\  \     |\  \|\  \|\  \
\ \  \_|\ \ \  \\\  \ \  \\ \  \ \  \    \ \  \ \  \\\  \
 \ \  \ \\ \ \  \\\  \ \  \\ \  \ \  \  __\ \  \ \  \\\  \
  \ \  \_\\ \ \  \\\  \ \  \\ \  \ \  \|\__\_\  \ \  \\\  \
   \ \_______\ \_______\ \__\\ \__\ \____________\ \_______\
    \|_______|\|_______|\|__| \|__|\|____________|\|_______|
${AnsiBackground.WHITE}${AnsiColor.RED}${AnsiStyle.UNDERLINE}
:: Spring Boot ::             (v${spring-boot.version})
:: Spring Boot Tutorial ::    (v1.0.0)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：&lt;code&gt;${}&lt;/code&gt; 设置字体颜色的变量之间不能换行或空格分隔，否则会导致除最后一个变量外，都不生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动应用后，控制台将打印如下 logo：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dunwu.test.upcdn.net/snap/20181221231330.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推荐两个生成字符画的网站，可以将生成的字符串放入这个&lt;code&gt;banner.txt&lt;/code&gt; 文件：&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;application.properties&lt;/code&gt; 中与 Banner 相关的配置：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# banner 模式。有三种模式：console/log/off
# console 打印到控制台（通过 System.out）
# log - 打印到日志中
# off - 关闭打印
spring.main.banner-mode = off
# banner 文件编码
spring.banner.charset = UTF-8
# banner 文本文件路径
spring.banner.location = classpath:banner.txt
# banner 图像文件路径（可以选择 png,jpg,gif 文件）
spring.banner.image.location = classpath:banner.gif
used).
# 图像 banner 的宽度（字符数）
spring.banner.image.width = 76
# 图像 banner 的高度（字符数）
spring.banner.image.height =
# 图像 banner 的左边界（字符数）
spring.banner.image.margin = 2
# 是否将图像转为黑色控制台主题
spring.banner.image.invert = false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你也可以在 YAML 文件中配置，例如：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  main:
    banner-mode: off&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编程&quot;&gt;编程&lt;/h3&gt;
&lt;p&gt;默认，Spring Boot 会注册一个 &lt;code&gt;SpringBootBanner&lt;/code&gt; 的单例 Bean，用来负责打印 Banner。&lt;/p&gt;
&lt;p&gt;如果想完全个人定制 Banner，可以这么做：先实现 &lt;code&gt;org.springframework.boot.Banner#printBanner&lt;/code&gt; 接口来自己定制 Banner。在将这个 Banner 通过 &lt;code&gt;SpringApplication.setBanner(…)&lt;/code&gt; 方法注入 Spring Boot。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;完整示例：&lt;a href=&quot;https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/core/sbe-core-banner&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn clean package
cd target
java -jar sbe-core-banner.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引申和引用&quot;&gt;引申和引用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;引申&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 15:25:00 +0000</pubDate>
<dc:creator>静默虚空</dc:creator>
<og:description>Spring Boot 之订制 logo &lt;! TOC depthFrom:2 depthTo:3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingmoxukong/p/10159493.html</dc:identifier>
</item>
<item>
<title>论文笔记：语音情感识别（四）语音特征之声谱图，log梅尔谱，MFCC，deltas - PilgrimHui</title>
<link>http://www.cnblogs.com/liaohuiqiang/p/10159429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaohuiqiang/p/10159429.html</guid>
<description>&lt;p&gt;一：&lt;strong&gt;原始信号&lt;/strong&gt;&lt;br/&gt;从音频文件中读取出来的原始语音信号通常称为raw waveform，是一个一维数组，长度是由音频长度和采样率决定，比如采样率Fs为16KHz，表示一秒钟内采样16000个点，这个时候如果音频长度是10秒，那么raw waveform中就有160000个值，值的大小通常表示的是振幅。&lt;/p&gt;
&lt;p&gt;二：&lt;strong&gt;（线性）声谱图&lt;/strong&gt;&lt;br/&gt;（1）对原始信号进行分帧加窗后，可以得到很多帧，对每一帧做FFT（快速傅里叶变换），傅里叶变换的作用是把时域信号转为频域信号，把每一帧FFT后的频域信号（频谱图）在时间上堆叠起来就可以得到声谱图，其直观理解可以形象地表示为以下几个图，图源见参考资料[1]。&lt;br/&gt;（2）有些论文提到的DCT（离散傅里叶变换）和STFT（短时傅里叶变换）其实是差不多的东西。STFT就是对一系列加窗数据做FFT。而DCT跟FFT的关系就是：FFT是实现DCT的一种快速算法。&lt;br/&gt;（3）FFT有个参数N，表示对多少个点做FFT，如果一帧里面的点的个数小于N就会zero-padding到N的长度。对一帧信号做FFT后会得到N点的复数，这个点的模值就是该频率值下的幅度特性。每个点对应一个频率点，某一点n（n从1开始）表示的频率为&lt;span class=&quot;math inline&quot;&gt;\(F_n = (n-1)*Fs/N\)&lt;/span&gt;，第一个点（n=1，Fn等于0）表示直流信号，最后一个点N的下一个点（n=N+1，Fn=Fs时，实际上这个点是不存在的）表示采样频率Fs。&lt;br/&gt;（4）FFT后我们可以得到N个频点，频率间隔（也叫频率分辨率或）为 Fs / N，比如，采样频率为16000，N为1600，那么FFT后就会得到1600个点，频率间隔为10Hz，FFT得到的1600个值的模可以表示1600个频点对应的振幅。因为FFT具有对称性，当N为偶数时取N/2+1个点，当N为奇数时，取(N+1)/2个点，比如N为512时最后会得到257个值。&lt;br/&gt;（5）用python_speech_feature库时可以看到有三种声谱图，包括振幅谱，功率谱，log功率谱。振幅谱就是fft后取绝对值。功率谱就是在振幅谱的基础上平方然后除以N。log功率谱就是在功率谱的基础上取10倍lg，然后减去最大值。得到声谱图矩阵后可以通过matplotlib来画图。&lt;br/&gt;（6）常用的声谱图都是STFT得到的，另外也有用CQT（constant-Q transform）得到的，为了区分，将它们分别称为STFT声谱图和CQT声谱图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224530922-479480973.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224541923-1780314401.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224554397-162344585.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三：&lt;strong&gt;梅尔声谱图&lt;/strong&gt;：&lt;br/&gt;（1）人耳听到的声音高低和实际（Hz）频率不呈线性关系，用Mel频率更符合人耳的听觉特性（这正是用Mel声谱图的一个动机，由人耳听力系统启发），即在1000Hz以下呈线性分布，1000Hz以上呈对数增长，Mel频率与Hz频率的关系为&lt;span class=&quot;math inline&quot;&gt;\(f_{mel} = 2595 \cdot lg(1+\frac{f}{700Hz})\)&lt;/span&gt;，如下图所示，图源见参考资料[2]。有另一种计算方式为&lt;span class=&quot;math inline&quot;&gt;\(f_{mel} = 1125 \cdot ln(1+\frac{f}{700Hz})\)&lt;/span&gt;。下面给出一个计算Mel声谱图的例子。另，python中可以用librosa调包得到梅尔声谱图。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224622095-1486888859.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）假设现在用10个Mel filterbank（一些论文会用40个，如果求MFCC一般是用26个然后在最后取前13个），为了获得filterbanks需要选择一个lower频率和upper频率，用300作为lower，8000作为upper是不错的选择。如果采样率是8000Hz那么upper频率应该限制为4000。然后用公式把lower和upper转为Mel频率，我们使用上述第二个公式（ln那条），可以得到401.25Mel 和 2834.99Mel。&lt;br/&gt;（3）因为用10个滤波器，所以需要12个点来划分出10个区间，在401.25Mel和2834.99Mel之间划分出12个点，m(i) = (401.25, 622.50, 843.75, 1065.00, 1286.25, 1507.50, 1728.74, 1949.99, 2171.24, 2392.49, 2613.74, 2834.99)。&lt;br/&gt;（4）然后把这些点转回Hz频率，h(i) = (300, 517.33, 781.90, 1103.97, 1496.04, 1973.32, 2554.33, 3261.62, 4122.63, 5170.76, 6446.70, 8000)。&lt;br/&gt;（5）把这些频率转为fft bin，f(i) = floor( (N+1)*h(i)/Fs)，N为FFT长度，默认为512，Fs为采样频率，默认为16000Hz，则f(i) = (9, 16, 25, 35, 47, 63, 81, 104, 132, 165, 206, 256)。这里256刚好对应512点FFT的8000Hz。&lt;br/&gt;（6）然后创建滤波器，第一个滤波器从第一个点开始，在第二个点到达最高峰，第三个点跌回零。第二个滤波器从第二个点开始，在第三个点到达最大值，在第四个点跌回零。以此类推。滤波器的示意图如下图所示，图源见参考资料[3]。可以看到随着频率的增加，滤波器的宽度也增加。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224736710-1682561520.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）接下来给出滤波器输出的计算公式，如下所示，其中m从1到M，M表示滤波器数量，这里是10。k表示点的编号，一个fft内256个点，k从1到256，表示了fft中的256个频点（k=0表示直流信号，算进来就是257个频点，为了简单起见这里省略k=0的情况）。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[H_m(k) = \left\{\begin{matrix} \frac{k-f(m-1)}{f(m)-f(m-1)} &amp;amp; f(m-1) \leq k \leq f(m)\\ \frac{f(m+1)-k}{f(m+1)-f(m)} &amp;amp; f(m) \leq k \leq f(m+1) \\ 0 &amp;amp; others \\ \end{matrix}\right.\]&lt;/span&gt;&lt;br/&gt;（8）最后还要乘上fft计算出来的能量谱，关于能量谱在前一节（线性）声谱图中已经讲过了。将滤波器的输出应用到能量谱后得到的就是梅尔谱，具体应用公式如下，其中&lt;span class=&quot;math inline&quot;&gt;\(|X(k)|^2\)&lt;/span&gt;表示能量谱中第k个点的能量。以每个滤波器的频率范围内的输出作为权重，乘以能量谱中对应频率的对应能量，然后把这个滤波器范围内的能量加起来。举个例子，比如第一个滤波器负责的是9和16之间的那些点（在其它范围的点滤波器的输出为0），那么只对这些点对应的频率对应的能量做加权和。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[MelSpec(m) = \sum_{k=f(m-1)}^{f(m+1)} H_m(k) * |X(k)|^2\]&lt;/span&gt;&lt;br/&gt;（9）这样计算后，对于一帧会得到M个输出。经常会在论文中看到说40个梅尔滤波器输出，指的就是这个（实际上前面说的梅尔滤波器输出是权重H，但是这里的意思应该是将滤波器输出应用到声谱后得到的结果，根据上下文可以加以区分）。然后在时间上堆叠多个“40个梅尔滤波器输出”就得到了梅尔尺度的声谱（梅尔谱），如果再取个log，就是log梅尔谱，log-Mels。&lt;br/&gt;（10）把滤波器范围内的能量加起来，可以解决一个问题，这个问题就是人耳是很难理解两个靠的很近的线性频率（就是和梅尔频率相对应的赫兹频率）之间不同。如果把一个频率区域的能量加起来，只关心在每个频率区域有多少能量，这样人耳就比较能区分，我们希望这种方式得到的（Mel）声谱图可以更加具有辨识度。最后取log的motivation也是源于人耳的听力系统，人对声音强度的感知也不是线性的，一般来说，要使声音的音量翻倍，我们需要投入8倍的能量，为了把能量进行压缩，所以取了log，这样，当x的log要翻倍的话，就需要增加很多的x。另外一个取log的原因是为了做倒谱分析得到MFCC，具体细节见下面MFCC的介绍。&lt;/p&gt;
&lt;p&gt;四：&lt;strong&gt;MFCC&lt;/strong&gt;&lt;br/&gt;（1）MFCC，梅尔频率的倒谱系数，是广泛应用于语音领域的特征，在这之前常用的是线性预测系数Linear Prediction Coefficients（LPCs）和线性预测倒谱系数（LPCCs），特别是用在HMM上。&lt;br/&gt;（2）先说一下获得MFCC的步骤，首先分帧加窗，然后对每一帧做FFT后得到（单帧）能量谱（具体步骤见上面线性声谱图的介绍），对线性声谱图应用梅尔滤波器后然后取log得到log梅尔声谱图（具体步骤见上面梅尔声谱图的介绍），然后对log滤波能量（log梅尔声谱）做DCT，离散余弦变换（傅里叶变换的一种），然后保留第二个到第13个系数，得到的这12个系数就是MFCC。&lt;br/&gt;（3）然后再大致说说MFCC的含义，下图第一个图（图源见参考资料[1]）是语音的频谱图，峰值是语音的主要频率成分，这些峰值称为共振峰，共振峰携带了声音的辨识（相当于人的身份证）。把这些峰值平滑地连起来得到的曲线称为频谱包络，包络描述了携带声音辨识信息的共振峰，所以我们希望能够得到这个包络来作为语音特征。频谱由频谱包络和频谱细节组成，如下第二个图（图源见参考资料[1]）所示，其中log X[k]代表频谱（注意图中给出的例子是赫兹谱，这里只是举例子，实际我们做的时候通常都是用梅尔谱），log H[k]代表频谱包络，log E[k]代表频谱细节。我们要做的就是从频谱中分离得到包络，这个过程也称为倒谱分析，下面就说说倒谱分析是怎么做的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224852822-1848315135.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224902529-1572460338.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）要做的其实就是对频谱做FFT，在频谱上做FFT这个操作称为逆FFT，需要注意的是我们是在频谱的log上做的，因为这样做FFT后的结果x[k]可以分解成h[k]和e[k]的和。我们先看下图（图源见参考资料[1]），对包络log H[k]做IFFT的结果，可以看成“每秒4个周期的正弦波”，于是我们在伪频率轴上的4Hz上给一个峰值，记作h[k]。对细节log E[k]做IFFT的结果，可以看成“每秒100个周期的正弦波”，于是我们在伪频率轴上的100Hz上给一个峰值，记作e[k]。对频谱log X[k]做IFFT后的结果记作x[k]，这就是我们说的倒谱，它会等于h[k]和e[k]的叠加，如下第二个图所示。我们想要得到的就是包络对应的h[k]，而h[k]是x[k]的低频部分，只需要对x[k]取低频部分就可以得到了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224927630-2116898656.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221224944430-837617222.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）最后再总结一下得到MFCC的步骤，求线性声谱图，做梅尔滤波得到梅尔声谱图，求个log得到log梅尔谱，做倒谱分析也就是对log X[k]做DCT得到x[k]，取低频部分就可以得到倒谱向量，通常会保留第2个到第13个系数，得到12个系数，这12个系数就是常用的MFCC。图源见参考资料[1]。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201812/1160281-20181221225011597-1988899505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五：&lt;strong&gt;deltas，deltas-deltas&lt;/strong&gt;&lt;br/&gt;（1）deltas和deltas-deltas，看到很多人翻译成一阶差分和二阶差分，也被称为微分系数和加速度系数。使用它们的原因是，MFCC只是描述了一帧语音上的能量谱包络，但是语音信号似乎有一些动态上的信息，也就是MFCC随着时间的改变而改变的轨迹。有证明说计算MFCC轨迹并把它们加到原始特征中可以提高语音识别的表现。&lt;br/&gt;（2）以下是deltas的一个计算公式，其中t表示第几帧，N通常取2，c指的就是MFCC中的某个系数。deltas-deltas就是在deltas上再计算以此deltas。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[d_t = \frac{\sum_{n=1}^{N} n(c_{t+n}-c_{t-n})}{2 \sum_{n=1}^{N} n^2}\]&lt;/span&gt;&lt;br/&gt;（3）对MFCC中每个系数都做这样的计算，最后会得到12个一阶差分和12个二阶差分，我们通常在论文中看到的“MFCC以及它们的一阶差分和二阶差分”指的就是这个。&lt;br/&gt;（4）值得一提的是deltas和deltas-deltas也可以用在别的参数上来表述动态特性，有论文中是直接在log Mels上做一阶差分和二阶差分的，&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/10128835.html&quot;&gt;论文笔记：语音情感识别（二）声谱图+CRNN&lt;/a&gt;中3-D Convolutional Recurrent Neural Networks with Attention Model for Speech Emotion Recognition这篇论文就是这么做的。&lt;/p&gt;
&lt;p&gt;六：&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br/&gt;[1] &lt;a href=&quot;http://www.speech.cs.cmu.edu/15-492/slides/03_mfcc.pdf&quot;&gt;CMU语音课程slides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;http://practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/&quot;&gt;一个MFCC的介绍教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://blog.csdn.net/xiaoding133/article/details/8106672&quot;&gt;csdn-MFCC计算过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&quot;https://www.cnblogs.com/BaroC/p/4283380.html&quot;&gt;博客园-MFCC学习笔记&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 15:04:00 +0000</pubDate>
<dc:creator>PilgrimHui</dc:creator>
<og:description>介绍最近看语音情感识别论文中用到的各种语音特征，主要是声谱图（spectrogram），log梅尔声谱图（log-mels），MFCC和一阶差分（deltas），二阶差分（deltas-deltas）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaohuiqiang/p/10159429.html</dc:identifier>
</item>
<item>
<title>python字典类型 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10159432.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10159432.html</guid>
<description>&lt;h2 id=&quot;字典类型简介&quot;&gt;字典类型简介&lt;/h2&gt;
&lt;p&gt;字典(dict)是存储key/value数据的容器，也就是所谓的map、hash、关联数组。无论是什么称呼，都是键值对存储的方式。&lt;/p&gt;
&lt;p&gt;在python中，dict类型使用大括号包围：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D = {&quot;key1&quot;: &quot;value1&quot;,
     &quot;key2&quot;: &quot;value2&quot;,
     &quot;key3&quot;: &quot;value3&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dict对象中存储的元素没有位置顺序，所以dict不是序列，不能通过索引的方式取元素。dict是按照key进行存储的，所以需要通过key作为定位元素的依据，比如取元素或修改key对应的value。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D['key1']     # 得到value1
D['key2']     # 得到value2
D['key3']     # 得到value3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字典的结构&quot;&gt;字典的结构&lt;/h2&gt;
&lt;p&gt;dict是一个hashtable数据结构，除了数据类型的声明头部分，还主要存储了3部分数据：一个hash值，两个指针。下面详细解释dict的结构。&lt;/p&gt;
&lt;p&gt;下面是一个Dict对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D = {&quot;key1&quot;: &quot;value1&quot;,
     &quot;key2&quot;: &quot;value2&quot;,
     &quot;key3&quot;: &quot;value3&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181220205655540-1699450040.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图很容易理解，key和value一一对应，只不过这里多加了一个hash值而已。但这只是便于理解的结构，它并非正确。看源码中对dict类型的简单定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct {
    /* Cached hash code of me_key. */
    Py_hash_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictKeyEntry;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码中可知，一个hash值，这个hash值是根据key运用内置函数hash()来计算的，占用8字节(64位机器)。除了hash值，后面两个是指针，这两个指针分别是指向key、指向value的指针，每个指针占用一个机器字长，也即是说对于64位机器各占用8字节，所以一个dict的元素，除了实际的数据占用的内存空间，还额外占用24字节的空间。&lt;/p&gt;
&lt;p&gt;所以，正确的结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181220210134909-2091965768.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于存储dict元素的时候，首先根据key计算出hash值，然后将hash值存储到dict对象中，与每个hash值同时存储的还有两个引用，分别是指向key的引用和指向value的引用。&lt;/p&gt;
&lt;p&gt;如果要从dict中取出key对应的那个记录，则首先计算这个key的hash值，然后从dict对象中查找这个hash值，能找到说明有对应的记录，于是通过对应的引用可以找到key/value数据。&lt;/p&gt;
&lt;p&gt;dict是可变的，可以删除元素、增加元素、修改元素的value。这些操作的过程与上面的过程类似，都是先hash，并根据hash值来存储或检索元素。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，在python中，能hashable的数据类型都必须是不可变类型的，所以列表、集合、字典不能作为dict的key，字符串、数值、元组都可以作为dict的key(类的对象实例也可以，因为自定义类的对象默认是不可变的)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 字符串作为key
&amp;gt;&amp;gt;&amp;gt; D = {&quot;aa&quot;:&quot;aa&quot;,&quot;bb&quot;:&quot;bb&quot;}
&amp;gt;&amp;gt;&amp;gt; D
{'aa': 'aa', 'bb': 'bb'}

# 数值作为key
&amp;gt;&amp;gt;&amp;gt; D = {1:&quot;aa&quot;,&quot;bb&quot;:&quot;bb&quot;}
&amp;gt;&amp;gt;&amp;gt; D[1]
'aa'

# 元组作为key
&amp;gt;&amp;gt;&amp;gt; D = {(1,2):&quot;aa&quot;,&quot;bb&quot;:&quot;bb&quot;}
&amp;gt;&amp;gt;&amp;gt; D
{(1, 2): 'aa', 'bb': 'bb'}

# 列表作为key，报错
&amp;gt;&amp;gt;&amp;gt; D = {[1,2]:&quot;aa&quot;,&quot;bb&quot;:&quot;bb&quot;}
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: unhashable type: 'list'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字典元素的顺序改变&quot;&gt;字典元素的顺序改变&lt;/h3&gt;
&lt;p&gt;因为元素存储到dict的时候，都经过hash()计算，且存储的实际上是key对应的hash值，所以dict中各个元素是无序的，或者说无法保证顺序。所以，遍历dict得到的元素结果也是无序的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# python 3.5.2
&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; d
{'four': 4, 'two': 2, 'three': 3, 'one': 1}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无序是理论上的。但是在python 3.7中，已经保证了python dict中元素的顺序和插入顺序是一致的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Changed in version 3.7: Dictionary order is guaranteed to be insertion order. This behavior was an implementation detail of CPython from 3.6.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;# python 3.7.1
&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽保证了顺序，但后面介绍dict的时候，仍然将它当作无序来解释。&lt;/p&gt;
&lt;h3 id=&quot;字典和列表的比较&quot;&gt;字典和列表的比较&lt;/h3&gt;
&lt;p&gt;python中list是元素有序存储的序列代表，dict是元素无序存储的代表。它们都可变，是python中最灵活的两种数据类型。&lt;/p&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;dict的元素检索、增删改速度快，不会随着元素增多、减少而改变。但缺点是内存占用大&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;list的元素检索、增删改速度随着元素增多会越来越慢(当然实际影响并没有多大)，但是内存占用小&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;换句话说，dict是空间换时间，list是时间换空间。&lt;/p&gt;
&lt;p&gt;其实从dict和list的数据结构上很容易可以看出dict要比list占用的内存大。不考虑存储元素的实际数据空间，list存储每个元素只需一个指针共8字节(64位机器)即可保存，而dict至少需要24字节(64位机器)。&lt;/p&gt;
&lt;h2 id=&quot;构造字典&quot;&gt;构造字典&lt;/h2&gt;
&lt;p&gt;有几种构造字典的方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用大括号包围&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用dict()构造方法，dict()构造有3种方式：
&lt;ul&gt;&lt;li&gt;dict(key=value)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;dict(DICT)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;dict(iterable)，其中iterable的每个元素必须是两元素的数据对象，例如&lt;code&gt;(&quot;one&quot;,1)&lt;/code&gt;、&lt;code&gt;[&quot;two&quot;,2]&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;后两种都可以结合第一种方式&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用dict对象的fromkey()方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用dict对象的copy()方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;字典解析的方式。这个在后文再解释&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; D = {}     # 空字典
&amp;gt;&amp;gt;&amp;gt; type(D)
&amp;lt;class 'dict'&amp;gt;

&amp;gt;&amp;gt;&amp;gt; D = {&quot;key1&quot;: &quot;value1&quot;,
     &quot;key2&quot;: &quot;value2&quot;,
     &quot;key3&quot;: &quot;value3&quot;}
&amp;gt;&amp;gt;&amp;gt; D
{'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}

&amp;gt;&amp;gt;&amp;gt; a = dict(one=1, two=2, three=3)
&amp;gt;&amp;gt;&amp;gt; b = {'one': 1, 'two': 2, 'three': 3}
&amp;gt;&amp;gt;&amp;gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
&amp;gt;&amp;gt;&amp;gt; d = dict([('two', 2), ('one', 1), ('three', 3)])
&amp;gt;&amp;gt;&amp;gt; e = dict({'three': 3, 'one': 1, 'two': 2})
&amp;gt;&amp;gt;&amp;gt; f = dict([('two', 2), ('one', 1), ('three', 3)], four=4, five=5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fromkey(seq,value)&lt;/code&gt;是dict的类方法，所以可直接通过dict类名来调用(当然，使用已存在的对象来调用也没有问题)。它构造的字典的key来自于给定的序列，值来自于指定的第二个参数，如果没有第二个参数，则所有key的值默认为None。所以，第二个参数是构造新dict时的默认值。&lt;/p&gt;
&lt;p&gt;例如，构造一个5元素，key全为数值的字典：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(range(5))
{0: None, 1: None, 2: None, 3: None, 4: None}

&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(range(5), &quot;aa&quot;)
{0: 'aa', 1: 'aa', 2: 'aa', 3: 'aa', 4: 'aa'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再例如，根据已有的dict来初始化一个新的dict：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = dict(one=1, two=2, three=3, four=4, five=5)

&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(d)
{'one': None, 'two': None, 'three': None, 'four': None, 'five': None}

&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(d, &quot;aa&quot;)
{'one': 'aa', 'two': 'aa', 'three': 'aa', 'four': 'aa', 'five': 'aa'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为key的来源可以是任意序列，所以也可以从元组、列表、字符串中获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(&quot;abcd&quot;,&quot;aa&quot;)
{'a': 'aa', 'b': 'aa', 'c': 'aa', 'd': 'aa'}

&amp;gt;&amp;gt;&amp;gt; L = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(L)
{'a': None, 'b': None, 'c': None, 'd': None}

&amp;gt;&amp;gt;&amp;gt; T = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
&amp;gt;&amp;gt;&amp;gt; dict.fromkeys(L)
{'a': None, 'b': None, 'c': None, 'd': None}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dict的copy()方法会根据已有字典完全拷贝成一个新的字典副本。但需要注意的是，拷贝过程是浅拷贝。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; dd = d.copy()
&amp;gt;&amp;gt;&amp;gt; dd
{'three': 3, 'one': 1, 'two': 2, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; id(d[&quot;one&quot;]), id(dd[&quot;one&quot;])
(10919424, 10919424)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;操作字典&quot;&gt;操作字典&lt;/h2&gt;
&lt;p&gt;官方手册：&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mapping-types-dict&quot; class=&quot;uri&quot;&gt;https://docs.python.org/3/library/stdtypes.html#mapping-types-dict&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;dict的增删改查&quot;&gt;dict的增删改查&lt;/h3&gt;
&lt;p&gt;通过key即可检索到元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3}

&amp;gt;&amp;gt;&amp;gt; d[&quot;one&quot;]
1

&amp;gt;&amp;gt;&amp;gt; d[&quot;four&quot;] = 4
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; d[&quot;ten&quot;]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'ten'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于dict类型，检索不存在的key时会报错。但如果自己去定义dict的子类，那么可以自己重写&lt;code&gt;__missing__()&lt;/code&gt;方法来决定检索的key不存在时的行为。例如，对于不存在的键总是返回None。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; class mydict(dict):
...     def __missing__(self, key):
...         return None
...

&amp;gt;&amp;gt;&amp;gt; dd = mydict(d)
&amp;gt;&amp;gt;&amp;gt; dd
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; dd[&quot;ten&quot;]
&amp;gt;&amp;gt;&amp;gt; print(dd[&quot;ten&quot;])
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;get(key,default)方法&lt;/strong&gt;检索dict中的元素，如果元素存在，则返回对应的value，否则返回指定的default值，如果没有指定default，且检索的key又不存在，则返回None。这正好是上面自定义dict子类的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; d.get(&quot;two&quot;)
2

&amp;gt;&amp;gt;&amp;gt; d.get(&quot;six&quot;,&quot;not exists&quot;)
'not exists'
&amp;gt;&amp;gt;&amp;gt; print(d.get(&quot;six&quot;))
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;len()&lt;/strong&gt;函数可以用来查看字典有多少个元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'three': 3, 'four': 4, 'two': 2, 'one': 1}
&amp;gt;&amp;gt;&amp;gt; len(d)
4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;setdefault(key,default)&lt;/strong&gt;方法检索并设置一个key/value，如果key已存在，则直接返回对应的value，如果key不存在，则新插入这个key并指定其value为default并返回这个default，如果没有指定default，key又不存在，则默认为None。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d.setdefault(&quot;one&quot;)
1

&amp;gt;&amp;gt;&amp;gt; d.setdefault(&quot;five&quot;)
{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': None}

&amp;gt;&amp;gt;&amp;gt; d.setdefault(&quot;six&quot;,6)
6
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': None, 'six': 6}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;update(key/value)&lt;/strong&gt;方法根据给定的key/value对更新已有的键，如果键不存在则新插入。key/value的表达方式有多种，只要能表达出key/value的配对行为就可以。比如已有的dict作为参数，key=value的方式，2元素的迭代容器对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; d.update(five=5, six=6)   # key=value的方式
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6}

&amp;gt;&amp;gt;&amp;gt; d.update({&quot;one&quot;:11, &quot;two&quot;:22})  # dict作为参数
&amp;gt;&amp;gt;&amp;gt; d
{'one': 11, 'two': 22, 'three': 3, 'four': 4, 'five': 5, 'six': 6}

&amp;gt;&amp;gt;&amp;gt; d.update([(&quot;five&quot;,55),(&quot;six&quot;,66)])  # 列表中2元素的元组
&amp;gt;&amp;gt;&amp;gt; d
{'one': 11, 'two': 22, 'three': 3, 'four': 4, 'five': 55, 'six': 66}

&amp;gt;&amp;gt;&amp;gt; d.update(((&quot;five&quot;,55),(&quot;six&quot;,66)))  # 这些都可以
&amp;gt;&amp;gt;&amp;gt; d.update(([&quot;five&quot;,55],[&quot;six&quot;,66]))
&amp;gt;&amp;gt;&amp;gt; d.update(zip([&quot;five&quot;,&quot;six&quot;],[55,66]))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;del D[KEY]&lt;/strong&gt;可以用来根据key删除字典D中给定的元素，如果元素不存在则报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; del d[&quot;four&quot;]
&amp;gt;&amp;gt;&amp;gt; d
{'three': 3, 'two': 2, 'one': 1}

&amp;gt;&amp;gt;&amp;gt; del d[&quot;five&quot;]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'five'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;方法用来删除字典中所有元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'three': 3, 'four': 4, 'two': 2, 'one': 1}
&amp;gt;&amp;gt;&amp;gt; d.clear()
&amp;gt;&amp;gt;&amp;gt; d
{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;pop(key,default)&lt;/strong&gt;用来移除给定的元素并返回移除的元素。但如果元素不存在，则返回default，如果不存在且没有给定default，则报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'three': 3, 'four': 4, 'two': 2, 'one': 1}

&amp;gt;&amp;gt;&amp;gt; d.pop(&quot;one&quot;)
1
&amp;gt;&amp;gt;&amp;gt; d.pop(&quot;five&quot;,&quot;hello world&quot;)
'hello world'
&amp;gt;&amp;gt;&amp;gt; d.pop(&quot;five&quot;)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'five'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;popitem()&lt;/strong&gt;用于移除并返回一个&lt;code&gt;(key,value)&lt;/code&gt;元组对，每调用一次移除一个元素，没元素可移除后将报错。在python 3.7中保证以LIFO的顺序移除，在此之前不保证移除顺序。&lt;/p&gt;
&lt;p&gt;例如，下面是在python 3.5中的操作时(不保证顺序)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'three': 3, 'four': 4, 'two': 2, 'one': 1}

&amp;gt;&amp;gt;&amp;gt; d.popitem()
('three', 3)
&amp;gt;&amp;gt;&amp;gt; d.popitem()
('four', 4)
&amp;gt;&amp;gt;&amp;gt; d.popitem()
('two', 2)
&amp;gt;&amp;gt;&amp;gt; d.popitem()
('one', 1)
&amp;gt;&amp;gt;&amp;gt; d.popitem()
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'popitem(): dictionary is empty'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;d[key]&lt;/code&gt;的方式检索字典中的某个元素时，如果该元素不存在将报错。使用get()方法可以指定元素不存在时的默认返回值，而不报错。而设置元素时，可用通过直接赋值的方式，也可以通过setdefault()方法来为不存在的值设置默认值。&lt;/p&gt;
&lt;p&gt;重点在于元素是否存在于字典中。上面的几种方法能在检测元素是否存在时做出对应的操作，但字典作为容器，也可以直接用&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;not in&lt;/code&gt;去测试元素的存在性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &quot;one&quot; in d
True
&amp;gt;&amp;gt;&amp;gt; &quot;one3&quot; in d
False
&amp;gt;&amp;gt;&amp;gt; &quot;one3&quot; not in d
True&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;迭代和dict视图&quot;&gt;迭代和dict视图&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;keys()&lt;/strong&gt;返回字典中所有的key组成的视图对象；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;values()&lt;/strong&gt;返回字典中所有value组成的视图对象；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;items()&lt;/strong&gt;返回字典中所有(key,value)元组对组成的视图对象；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;iter(d)&lt;/strong&gt;函数返回字典中所有key组成的可迭代对象。等价于&lt;code&gt;iter(d.keys())&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前3个方法返回的是字典视图对象，关于这个稍后再说。先看返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'three': 3, 'four': 4, 'two': 2, 'one': 1}

&amp;gt;&amp;gt;&amp;gt; d.keys()
dict_keys(['three', 'four', 'two', 'one'])
&amp;gt;&amp;gt;&amp;gt; list(d.keys())
['three', 'four', 'two', 'one']

&amp;gt;&amp;gt;&amp;gt; d.values()
dict_values([3, 4, 2, 1])

&amp;gt;&amp;gt;&amp;gt; d.items()
dict_items([('three', 3), ('four', 4), ('two', 2), ('one', 1)])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;iter(d)返回的是由key组成的可迭代对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; iter(d)
&amp;lt;dict_keyiterator object at 0x7f0ab9c9c4f8&amp;gt;

&amp;gt;&amp;gt;&amp;gt; for i in iter(d):print(i)
...
three
four
two
one&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然这些都返回key、value、item组成的&quot;列表&quot;对象(视图对象)，那么可以直接拿来迭代遍历。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for i in d.keys():
...     print(i)
...
three
four
two
one

&amp;gt;&amp;gt;&amp;gt; for i in d.values():
...     print(i)
...
3
4
2
1

&amp;gt;&amp;gt;&amp;gt; for (key,value) in d.items():
...     print(key,&quot;--&amp;gt;&quot;,value)
...
three --&amp;gt; 3
four --&amp;gt; 4
two --&amp;gt; 2
one --&amp;gt; 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dict视图对象&quot;&gt;dict视图对象&lt;/h2&gt;
&lt;p&gt;keys()、values()、items()返回字典视图对象。视图对象中的数据会随着原字典的改变而改变。如果知道关系型数据库里的视图，这很容易理解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
&amp;gt;&amp;gt;&amp;gt; d.keys()
dict_keys(['one', 'two', 'three', 'four'])

&amp;gt;&amp;gt;&amp;gt; list(d.keys())
['one', 'two', 'three', 'four']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字典视图对象是可迭代对象，可以用来一个个地生成对应数据，但它毕竟不是列表。如果需要得到列表，只需使用list()方法构造即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(d.keys())
['one', 'two', 'three', 'four']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为字典试图是可迭代对象，所以可以进行测试存在性、迭代、遍历等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KEY in d.keys()

for key in d.keys(): ...
for value in d.values(): ...
for (key, value) in d.items(): ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字典的视图对象有两个函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;len(obj_view)：返回视图对象的长度&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;iter(obj_view)：返回视图对象对应的可迭代对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; len(d.keys())
4

&amp;gt;&amp;gt;&amp;gt; iter(d.keys())
&amp;lt;dict_keyiterator object at 0x000001F0A7D9A9F8&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，字典视图对象是可迭代对象，但并不是实际的列表，所以不能使用sort方法来排序，但可以使用sorted()内置函数来排序(按照key进行排序)。&lt;/p&gt;
&lt;p&gt;最后，视图对象是随原始字典动态改变的。修改原始字典，视图也会改变。例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

&amp;gt;&amp;gt;&amp;gt; ks = d.keys()

&amp;gt;&amp;gt;&amp;gt; del d[&quot;one&quot;]
&amp;gt;&amp;gt;&amp;gt; k
dict_keys(['two', 'three', 'four'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字典迭代和解析&quot;&gt;字典迭代和解析&lt;/h2&gt;
&lt;p&gt;字典自身有迭代器，如果需要迭代key，则不需要使用keys()来间接迭代。所以下面是等价的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for key in d:
for key in d.keys()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于字典解析，看几个示例即可理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = {k:v for (k,v) in zip([&quot;one&quot;,&quot;two&quot;,&quot;three&quot;],[1,2,3])}
&amp;gt;&amp;gt;&amp;gt; d
{'one': 1, 'two': 2, 'three': 3}

&amp;gt;&amp;gt;&amp;gt; d = {x : x ** 2 for x in [1,2,3,4]}
&amp;gt;&amp;gt;&amp;gt; d
{1: 1, 2: 4, 3: 9, 4: 16}

&amp;gt;&amp;gt;&amp;gt; d = {x : None for x in &quot;abcde&quot;}
&amp;gt;&amp;gt;&amp;gt; d
{'a': None, 'b': None, 'c': None, 'd': None, 'e': None}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 21 Dec 2018 14:58:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>字典类型简介 字典(dict)是存储key/value数据的容器，也就是所谓的map、hash、关联数组。无论是什么称呼，都是键值对存储的方式。 在python中，dict类型使用大括号包围： dic</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10159432.html</dc:identifier>
</item>
<item>
<title>salesforce零基础学习（九十一）Facet - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/10152801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/10152801.html</guid>
<description>&lt;p&gt;说Facet以前，我们先说一下浏览器加载解析以及渲染的过程。浏览器获取一个HTML的文件时，会按照自上向下的顺序进行解析，并在加载过程中进行渲染。对html解析成DOM树，对CSS 解析成CSS Rule树，然后通过DOM数以及CSS Rule树构造Rendering树。&lt;/p&gt;
&lt;p&gt;接下来转回Facet，Facet是什么？有哪些的使用场景呢？&lt;/p&gt;
&lt;p&gt;Facet 可以理解成一个占位符，这个占位符用于对父组件的指定的部分进行重新渲染。 很多组件都有默认的渲染，如果默认的渲染的结果不是你想要得到的结果，可以使用facet进行重新的渲染。通过Facet对默认组件进行重新渲染，从而生成你想要的Rendering树，展示你想要的自定义的UI。&lt;/p&gt;
&lt;p&gt;因为Facet是一个占位符，所以Facet不会单独的出现在外层的组件，只会作为父元素组建的一个子进行出现。当然也不是所有的元素都可以使用Facet，只有部分的组件元素可以使用Facet。Facet既可以使用在lightning中，也可以使用到classic中。Facet在classic中使用 apex:facet 组件，在lightning中使用Aura.Component。&lt;/p&gt;
&lt;p&gt;classic中Facet可以搭配的常用的父组件有：&lt;/p&gt;
&lt;p&gt;apex:dataTable /apex:actionStatus / apex:column / apex:relatedList等，不同的组件支持的不同的自定义元素位置不同，具体可以查看API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Classic使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Demo举例：针对Notes / Attachment related list, 标准提供的功能无法隐藏add按钮，我们可以通过facet方式对apex:relatedList进行重新渲染，从而隐藏add按钮。apex:relatedList可以对body,footer以及header进行重新渲染，demo中我们只渲染header，感兴趣的可以操作其他的部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201812/910966-20181220224533905-1986287832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:page &lt;/span&gt;&lt;span&gt;standardController&lt;/span&gt;&lt;span&gt;=&quot;Account&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:relatedList &lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;=&quot;CombinedAttachments&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:facet &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　 　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　 　　&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　　 　　&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pbTitle&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　　　　 　　&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Notes and Attachments&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　　　　 &amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　　 &amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　 &amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　  &amp;lt;/&lt;/span&gt;&lt;span&gt;apex:facet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:relatedList&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201812/910966-20181220224831463-1016216710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Lightning使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;lightning中我们可以通过apex:attribute作为value provider作为参数传递以及使用，有两个主要属性，一个是name，一个是type，当type声明为Aura:Component或者Aura:Component[]情况下，可以在父组件中动态传递参数进行渲染以及解析。&lt;/p&gt;
&lt;p&gt;Demo举例：动态传递参数，加载时传递参数才解析（demo来源于官方文档）。&lt;/p&gt;
&lt;p&gt; c:facetHeader：此元素组件声明了一个header的attribute，类型为Aura.Component，当父元素组件引用此元素并且赋值情况下，便可以动态的加载赋值。这里面有一个{!v.body}需要说明，针对lightning，每个aura:component都会内置一个body的属性，当父调用此元素时，此元素内部的body部分便会作为v.body进行渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Aura.Component[]&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{!v.header}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c:helloFacet：此元素组件引用了facetHeader元素组件，其中 Nice body!将会作为facetHeader的body内容进行渲染，我们动态的赋值了header内容进行渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    See how we set the header facet.&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:facetHeader&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        Nice body!
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:set &lt;/span&gt;&lt;span&gt;attribute&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            Hello Header!
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;c:facetHeader&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201812/910966-20181221215539427-1833193620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;此篇只是简单的介绍了Facet的使用，Facet针对classic的组件可以进行很多的定制，比如table展示哪些固定的列，apex:actionStatus 做loading效果的起始截止样式等。感兴趣的可以自行试验，篇中有问题的欢迎提出，有不懂的欢迎留言。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 14:05:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>说Facet以前，我们先说一下浏览器加载解析以及渲染的过程。浏览器获取一个HTML的文件时，会按照自上向下的顺序进行解析，并在加载过程中进行渲染。对html解析成DOM树，对CSS 解析成CSS Ru</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/10152801.html</dc:identifier>
</item>
<item>
<title>java实现word转pdf在线预览（前端使用PDF.js；后端使用openoffice、aspose） - ph7seven</title>
<link>http://www.cnblogs.com/ph7seven/p/10158489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ph7seven/p/10158489.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　之前一直是用户点击下载word文件到本地，然后使用office或者wps打开。需求优化，要实现可以直接在线预览，无需下载到本地然后再打开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　随后开始上网找资料，网上资料一大堆，方案也各有不同，大概有这么几种方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.word转html然后转pdf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.Openoffice + swftools + Flexmapper + jodconverter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.kkFileView&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　分析之后最后决定使用Openoffice+PDF.js方式实现&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1.安装Openoffice，下载地址：http://www.openoffice.org/download/index.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　安装完成之后，cmd进入安装目录执行命令：soffice &quot;-accept=socket,host=localhost,port=8100;urp;StarOffice.ServiceManager&quot; -nologo -headless -nofirststartwizard&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221181211940-300580376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.PDF.js，下载地址：http://mozilla.github.io/pdf.js/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下载之后解压，目录结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221181641482-927102260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221181931429-1427366086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221182042517-749906151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　编码方面，分前端后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后端：java后端使用openoffice把word文档转换成pdf文件，返回流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前端：把PDF.js解压后的文件加到项目中，修改对应路径，PDF.js拿到后端返回的流直接展示&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;后端&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　项目使用springboot，pom文件添加依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; openoffice word转pdf &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.artofsolving&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jodconverter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.2.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openoffice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jurt&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openoffice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ridl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openoffice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;juh&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openoffice&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;unoil&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　application.properties配置openoffice服务地址与端口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;openoffice.host=127.0.0.1
openoffice.port=8100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　doc文件转pdf文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ConnectException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xxx.utils.Doc2PdfUtil;

@Controller
@RequestMapping(&lt;/span&gt;&quot;/doc2PdfController&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doc2PdfController {
    @Value(&lt;/span&gt;&quot;${openoffice.host}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String OpenOfficeHost;
    @Value(&lt;/span&gt;&quot;${openoffice.port}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer OpenOfficePort;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Doc2PdfController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @RequestMapping(&lt;/span&gt;&quot;/doc2pdf&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doc2pdf(String fileName,HttpServletResponse response){
        File pdfFile &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        OutputStream outputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedInputStream bufferedInputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        Doc2PdfUtil doc2PdfUtil &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Doc2PdfUtil(OpenOfficeHost, OpenOfficePort);
        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;doc转pdf，返回pdf文件&lt;/span&gt;
            pdfFile =&lt;span&gt; doc2PdfUtil.doc2Pdf(fileName);
            outputStream &lt;/span&gt;=&lt;span&gt; response.getOutputStream();
            response.setContentType(&lt;/span&gt;&quot;application/pdf;charset=UTF-8&quot;&lt;span&gt;);  
            bufferedInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(pdfFile));  
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; buffBytes[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];  
            outputStream &lt;/span&gt;=&lt;span&gt; response.getOutputStream();  
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; read = 0&lt;span&gt;;    
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((read = bufferedInputStream.read(buffBytes)) != -1&lt;span&gt;) {    
                outputStream.write(buffBytes, &lt;/span&gt;0&lt;span&gt;, read);    
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ConnectException e) {
            logger.info(&lt;/span&gt;&quot;****调用Doc2PdfUtil doc转pdf失败****&quot;&lt;span&gt;);
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }  &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(outputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    outputStream.flush();
                    outputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }    
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bufferedInputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    bufferedInputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ConnectException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.artofsolving.jodconverter.DocumentConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.artofsolving.jodconverter.openoffice.connection.OpenOfficeConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.artofsolving.jodconverter.openoffice.connection.SocketOpenOfficeConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.artofsolving.jodconverter.openoffice.converter.StreamOpenOfficeDocumentConverter;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doc2PdfUtil {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String OpenOfficeHost; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;openOffice服务地址&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Integer OpenOfficePort; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;openOffice服务端口&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Doc2PdfUtil(){
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Doc2PdfUtil(String OpenOfficeHost, Integer OpenOfficePort){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.OpenOfficeHost =&lt;span&gt; OpenOfficeHost;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.OpenOfficePort =&lt;span&gt; OpenOfficePort;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Doc2PdfUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * doc转pdf
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; pdf文件路径
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ConnectException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; File doc2Pdf(String fileName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ConnectException{
        File docFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(fileName + &quot;.doc&quot;&lt;span&gt;);
        File pdfFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(fileName + &quot;.pdf&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (docFile.exists()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pdfFile.exists()) {
                OpenOfficeConnection connection &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketOpenOfficeConnection(OpenOfficeHost, OpenOfficePort);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.connect();
                    DocumentConverter converter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamOpenOfficeDocumentConverter(connection);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最核心的操作，doc转pdf&lt;/span&gt;
&lt;span&gt;                    converter.convert(docFile, pdfFile);
                    connection.disconnect();
                    logger.info(&lt;/span&gt;&quot;****pdf转换成功，PDF输出：&quot; + pdfFile.getPath() + &quot;****&quot;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (java.net.ConnectException e) {
                    logger.info(&lt;/span&gt;&quot;****pdf转换异常，openoffice服务未启动！****&quot;&lt;span&gt;);
                    e.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (com.artofsolving.jodconverter.openoffice.connection.OpenOfficeException e) {
                    System.out.println(&lt;/span&gt;&quot;****pdf转换器异常，读取转换文件失败****&quot;&lt;span&gt;);
                    e.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    e.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            logger.info(&lt;/span&gt;&quot;****pdf转换异常，需要转换的doc文档不存在，无法转换****&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pdfFile;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;前端&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221185041587-474981928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　把pdfjs-2.0.943-dist下的两个文件夹build、web整体加到项目中，然后把viewer.html改成viewer.jsp，并调整了位置，去掉了默认的pdf文件compressed.tracemonkey-pldi-09.pdf，将来使用我们生成的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　viewer.jsp、viewer.js注意点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.引用的js、css路径要修改过来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.viewer.jsp中调用pdf/web/viewer.js，viewer.js中配置了默认的pdf文件路径，我们要动态生成pdf，因此需要修改，在jsp中定义一个参数DEFAULT_URL，然后在js中使用它&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.jsp中写了一个ajax获取pdf流，之后赋值给DEFAULT_URL，然后再让viewer.js去加载，因此需要把/pdf/web/viewer.js放到ajax方法后面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.viewer.js中把compressed.tracemonkey-pldi-09.pdf改成我们定义的变量DEFAULT_URL；pdf.worker.js的路径修改成对应路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221190244729-743341425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221190448959-1705410293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221190526935-61653889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://java.sun.com/jsp/jstl/core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
Copyright 2012 Mozilla Foundation

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Adobe CMap resources are covered by their own copyright but the same license:

    Copyright 1990-2015 Adobe Systems Incorporated.

See https://github.com/adobe-type-tools/cmap-resources
&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;dir&lt;/span&gt;&lt;span&gt;=&quot;ltr&quot;&lt;/span&gt;&lt;span&gt; mozdisallowselectionprint&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;google&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;notranslate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:set &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;=&quot;qtpath&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${pageContext.request.contextPath}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; qtpath &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;${qtpath}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; fileName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;${fileName}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PDF.js viewer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/pdf/web/viewer.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; This snippet is used in production (included from viewer.html) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;resource&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;application/l10n&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/pdf/web/locale/locale.properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/js/jquery/jquery-2.1.4.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; DEFAULT_URL &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，删除的变量在这里重新定义  &lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; PDFData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;  
    $.ajax({  
        type:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  
        async:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;        mimeType: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/plain; charset=x-user-defined&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,  
        url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;${qtpath}/doc2PdfController/doc2pdf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fileName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:fileName},
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){  
           PDFData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; data;  
        }  
    });  
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; rawLength &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; PDFData.length;  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换成pdf.js能直接解析的Uint8Array类型,见pdf.js-4068  &lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; array &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uint8Array(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayBuffer(rawLength));    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; rawLength; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {  
      array[i] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; PDFData.charCodeAt(i) &lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;;  
    }  
    DEFAULT_URL &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; array;
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/pdf/build/pdf.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;${qtpath}/res/pdf/web/viewer.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  ...&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221194055303-377547294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;分割线&lt;/h2&gt;
&lt;p&gt;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本以为完美的实现了doc在线预览，上测试环境后发现了一个大坑，我们的doc文件不是在本地office创建后上传的，是其他同事用freemarker ftl模板生成的，这种生成的doc文件根本不是微软标准的doc，本质是xml数据结构，openoffice拿这种文件去转换pdf文件直接就报错了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1083688/201812/1083688-20181221212943604-1657074877.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;　　上网查资料查了半天也没找到这种问题的解决方案，想想只能是放弃openoffice改用其他方法了（freemarker ftl生成doc这个肯定是不能动的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看到一些博客使用word--html--pdf生成pdf，还有的使用freemarker ftl xml 生成pdf感觉还是太繁琐了，我只是想拿现有的doc（虽然是freemarker ftl生成的）转换成pdf啊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续看博客查资料，看到一种方法，使用aspose把doc转换成pdf，抱着试一试的心态在本地测试了下，没想到竟然成了，感觉太意外了，aspose方法超级简单，只要导入jar包，几行代码就可以搞定，并且转换速度比openoffice要快很多。很是奇怪，这么好用这么简单的工具为什么没在我一开始搜索word转pdf的时候就出现呢&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;aspose doc转pdf&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在maven仓库搜索aspose，然后把依赖加入pom.xml发现jar包下载不下来，没办法，最后在csdn下载aspose jar包，然后mvn deploy到仓库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　pom.xml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; word转pdf maven仓库没有需要本地jar包发布到私服 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.aspose.words&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aspose-words-jdk16&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;14.9.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ConnectException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xxx.utils.Doc2PdfUtil;

@Controller
@RequestMapping(&lt;/span&gt;&quot;/doc2PdfController&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doc2PdfController {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Doc2PdfController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @RequestMapping(&lt;/span&gt;&quot;/doc2pdf&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doc2pdf(String fileName,HttpServletResponse response){
        File pdfFile &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        OutputStream outputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedInputStream bufferedInputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String docPath &lt;/span&gt;= fileName + &quot;.doc&quot;&lt;span&gt;;
        String pdfPath &lt;/span&gt;= fileName + &quot;.pdf&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            pdfFile &lt;/span&gt;=&lt;span&gt; Doc2PdfUtil.doc2Pdf(docPath, pdfPath);
            outputStream &lt;/span&gt;=&lt;span&gt; response.getOutputStream();
            response.setContentType(&lt;/span&gt;&quot;application/pdf;charset=UTF-8&quot;&lt;span&gt;);  
            bufferedInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(pdfFile));  
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; buffBytes[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];  
            outputStream &lt;/span&gt;=&lt;span&gt; response.getOutputStream();  
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; read = 0&lt;span&gt;;    
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((read = bufferedInputStream.read(buffBytes)) != -1&lt;span&gt;) {    
                outputStream.write(buffBytes, &lt;/span&gt;0&lt;span&gt;, read);    
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ConnectException e) {
            logger.info(&lt;/span&gt;&quot;****调用Doc2PdfUtil doc转pdf失败****&quot;&lt;span&gt;);
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }  &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(outputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    outputStream.flush();
                    outputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }    
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bufferedInputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    bufferedInputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　Doc2PdfUtil.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ByteArrayInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aspose.words.License;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aspose.words.SaveFormat;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doc2PdfUtil {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Doc2PdfUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * doc转pdf
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; docPath doc文件路径，包含.doc
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; pdfPath pdf文件路径，包含.pdf
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; File doc2Pdf(String docPath, String pdfPath){
        File pdfFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(pdfPath);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            String s &lt;/span&gt;= &quot;&amp;lt;License&amp;gt;&amp;lt;Data&amp;gt;&amp;lt;Products&amp;gt;&amp;lt;Product&amp;gt;Aspose.Total for Java&amp;lt;/Product&amp;gt;&amp;lt;Product&amp;gt;Aspose.Words for Java&amp;lt;/Product&amp;gt;&amp;lt;/Products&amp;gt;&amp;lt;EditionType&amp;gt;Enterprise&amp;lt;/EditionType&amp;gt;&amp;lt;SubscriptionExpiry&amp;gt;20991231&amp;lt;/SubscriptionExpiry&amp;gt;&amp;lt;LicenseExpiry&amp;gt;20991231&amp;lt;/LicenseExpiry&amp;gt;&amp;lt;SerialNumber&amp;gt;8bfe198c-7f0c-4ef8-8ff0-acc3237bf0d7&amp;lt;/SerialNumber&amp;gt;&amp;lt;/Data&amp;gt;&amp;lt;Signature&amp;gt;sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU=&amp;lt;/Signature&amp;gt;&amp;lt;/License&amp;gt;&quot;&lt;span&gt;;
            ByteArrayInputStream is &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(s.getBytes());
            License license &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; License();
            license.setLicense(is);
            com.aspose.words.Document document &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; com.aspose.words.Document(docPath);
            document.save(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(pdfFile),SaveFormat.PDF);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.info(&lt;/span&gt;&quot;****aspose doc转pdf异常&quot;&lt;span&gt;);
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pdfFile;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　aspose-words-jdk16-14.9.0.jar下载地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　https://download.csdn.net/download/u013279345/10868189&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Dec 2018 13:14:00 +0000</pubDate>
<dc:creator>ph7seven</dc:creator>
<og:description>java word转pdf openoffice aspose</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ph7seven/p/10158489.html</dc:identifier>
</item>
</channel>
</rss>