<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Pytorch入门实战二：LeNet、AleNet、VGG、GoogLeNet、ResNet模型详解 - 泽积</title>
<link>http://www.cnblogs.com/shenpings1314/p/10468418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenpings1314/p/10468418.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;LeNet&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　1998年，&lt;span lang=&quot;EN-US&quot;&gt;LeCun提出了第一个真正的卷积神经网络，也是整个神经网络的开山之作，称为&lt;span lang=&quot;EN-US&quot;&gt;LeNet，现在主要指的是&lt;span lang=&quot;EN-US&quot;&gt;LeNet5或&lt;span lang=&quot;EN-US&quot;&gt;LeNet-5，如图1.1所示。它的主要特征是将卷积层和下采样层相结合作为网络的基本机构，如果不计输入层，该模型共&lt;span lang=&quot;EN-US&quot;&gt;7层，包括&lt;span lang=&quot;EN-US&quot;&gt;2个卷积层，&lt;span lang=&quot;EN-US&quot;&gt;2个下采样层，&lt;span lang=&quot;EN-US&quot;&gt;3个全连接层。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190303225522945-1713391211.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图1.1&lt;/p&gt;
&lt;p&gt;　　注：由于在接入全连接层时，要将池化层的输出转换成全连接层需要的维度，因此，必须清晰的知道全连接层前feature map的大小。卷积层与池化层输出的图像大小，其计算如图&lt;span lang=&quot;EN-US&quot;&gt;1.2所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190303225807748-569818319.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图1.2&lt;/p&gt;
&lt;p&gt; 　　本次利用&lt;span lang=&quot;EN-US&quot;&gt;pytorch实现整个&lt;span lang=&quot;EN-US&quot;&gt;LeNet模型，图中的&lt;span lang=&quot;EN-US&quot;&gt;Subsampling层即可看作如今的池化层，最后一层（输出层）也当作全连接层进行处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch as torch
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.nn as nn
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LeNet(nn.Module):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         super(LeNet,self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         layer1 =&lt;span&gt; nn.Sequential()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         layer1.add_module(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,nn.Conv2d(1,6,5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         layer1.add_module(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,nn.MaxPool2d(2,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.layer1 =&lt;span&gt; layer1
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         layer2 =&lt;span&gt; nn.Sequential()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         layer2.add_module(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,nn.Conv2d(6,16,5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         layer2.add_module(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,nn.MaxPool2d(2,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         self.layer2 =&lt;span&gt; layer2
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         layer3 =&lt;span&gt; nn.Sequential()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         layer3.add_module(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,nn.Linear(16*5*5,120&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         layer3.add_module(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,nn.Linear(120,84&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         layer3.add_module(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,nn.Linear(84,10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         self.layer3 =&lt;span&gt; layer3
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; forward(self, x):
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         x =&lt;span&gt; self.layer1(x)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         x =&lt;span&gt; self.layer2(x)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         x = x.view(x.size(0),-1&lt;span&gt;)#转换（降低）数据维度，进入全连接层
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         x =&lt;span&gt; self.layer3(x)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;代入数据检验&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; y = torch.randn(1,1,32,32&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; model =&lt;span&gt; LeNet()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; model(y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; AlexNet&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在&lt;span lang=&quot;EN-US&quot;&gt;2010年，斯坦福大学的李飞飞正式组织并启动了大规模视觉图像识别竞赛（&lt;span lang=&quot;EN-US&quot;&gt;ImageNet Large Scale Visual Recognition Challenge，&lt;span lang=&quot;EN-US&quot;&gt;ILSVRC）。在&lt;span lang=&quot;EN-US&quot;&gt;2012年，&lt;span lang=&quot;EN-US&quot;&gt;Alex Krizhevsky、&lt;span lang=&quot;EN-US&quot;&gt;Ilya Sutskever提出了一种非常重要的卷积神经网络模型，它就是&lt;span lang=&quot;EN-US&quot;&gt;AlexNet，如图1.3所　　示，在&lt;span lang=&quot;EN-US&quot;&gt;ImageNet竞赛上大放异彩，领先第二名&lt;span lang=&quot;EN-US&quot;&gt;10%的准确率夺得了冠军，吸引了学术界与工业界的广泛关注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　&lt;strong&gt;AlexNet神经网络相比&lt;span lang=&quot;EN-US&quot;&gt;LeNet：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span lang=&quot;EN-US&quot;&gt;1、 使用&lt;span lang=&quot;EN-US&quot;&gt;ReLU激活函数。在&lt;span lang=&quot;EN-US&quot;&gt;AlexNet之前，神经网络一般都使用&lt;span lang=&quot;EN-US&quot;&gt;sigmoid或&lt;span lang=&quot;EN-US&quot;&gt;tanh作为激活函数，这类函数在自变量非常大或者非常小时，函数输出基本不变，称之为饱和函数。为了提高训练速度，&lt;span lang=&quot;EN-US&quot;&gt;AlexNet使用了修正线性函数&lt;span lang=&quot;EN-US&quot;&gt;ReLU，它是一种非饱和函数，与 &lt;span lang=&quot;EN-US&quot;&gt;sigmoid 和&lt;span lang=&quot;EN-US&quot;&gt;tanh 函数相比，&lt;span lang=&quot;EN-US&quot;&gt;ReLU分片的线性结构实现了非线性结构的表达能力，梯度消失现象相对较弱，有助于训练更深层的网络。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;EN-US&quot;&gt;2、 使用&lt;span lang=&quot;EN-US&quot;&gt;GPU训练。与&lt;span lang=&quot;EN-US&quot;&gt;CPU不同的是，&lt;span lang=&quot;EN-US&quot;&gt;GPU转为执行复杂的数学和几何计算而设计，&lt;span lang=&quot;EN-US&quot;&gt;AlexNet使用了&lt;span lang=&quot;EN-US&quot;&gt;2个&lt;span lang=&quot;EN-US&quot;&gt;GPU来提升速度，分别放置一半卷积核。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;EN-US&quot;&gt;3、 局部响应归一化。&lt;span lang=&quot;EN-US&quot;&gt;AlexNet使用局部响应归一化技巧，将&lt;span lang=&quot;EN-US&quot;&gt;ImageNet上的&lt;span lang=&quot;EN-US&quot;&gt;top-1与&lt;span lang=&quot;EN-US&quot;&gt;top-5错误率分别减少了&lt;span lang=&quot;EN-US&quot;&gt;1.4%和&lt;span lang=&quot;EN-US&quot;&gt;1.2%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;EN-US&quot;&gt;4、 重叠池化层。与不重叠池化层相比，重叠池化层有助于缓解过拟合，使得&lt;span lang=&quot;EN-US&quot;&gt;AlexNet的&lt;span lang=&quot;EN-US&quot;&gt;top-1和&lt;span lang=&quot;EN-US&quot;&gt;top-5错误率分别降低了&lt;span lang=&quot;EN-US&quot;&gt;0.4%和&lt;span lang=&quot;EN-US&quot;&gt;0.3%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;EN-US&quot;&gt;5、 减少过拟合。&lt;span lang=&quot;EN-US&quot;&gt;AlexNet使用了数据扩增与丢失输出两种技巧。数据扩增：&lt;span lang=&quot;EN-US&quot;&gt;a、图像的平移、翻转，&lt;span lang=&quot;EN-US&quot;&gt;b、基于&lt;span lang=&quot;EN-US&quot;&gt;PCA的&lt;span lang=&quot;EN-US&quot;&gt;RGB强度调整。丢失输出技巧（&lt;span lang=&quot;EN-US&quot;&gt;DropOut层），&lt;span lang=&quot;EN-US&quot;&gt;AlexNet以&lt;span lang=&quot;EN-US&quot;&gt;0.5的概率将两个全连接层神经元的输出设置为&lt;span lang=&quot;EN-US&quot;&gt;0，有效阻止了过拟合现象的发生。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190304000803901-518573141.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图1.3&lt;/p&gt;
&lt;p&gt;　　利用pytorch实现&lt;span lang=&quot;EN-US&quot;&gt;AlexNet网络，由于当时，&lt;span lang=&quot;EN-US&quot;&gt;GPU的计算能力不强，因此&lt;span lang=&quot;EN-US&quot;&gt;Alex采用了&lt;span lang=&quot;EN-US&quot;&gt;2个&lt;span lang=&quot;EN-US&quot;&gt;GPU并行来计算，如今的&lt;span lang=&quot;EN-US&quot;&gt;GPU计算能力，完全可以替代。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.nn as nn
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AlexNet(nn.Module):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,num_classes):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         super(AlexNet,self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.features =&lt;span&gt; nn.Sequential(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             nn.Conv2d(3,64,11,4,padding=2&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; inplace=&lt;span data-mce-=&quot;&quot;&gt;True&lt;/span&gt;，是对于Conv2d这样的上层网络传递下来的tensor直接进行修改，好处就是可以节省运算内存，不用多储存变量&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             nn.MaxPool2d(kernel_size=3,stride=2&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             nn.Conv2d(64,192,kernel_size=5,padding=2&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             nn.MaxPool2d(kernel_size=3,stride=2&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             nn.Conv2d(192,384,kernel_size=3,padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             nn.Conv2d(384,256,kernel_size=3,padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             nn.Conv2d(256,256,kernel_size=3,padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             nn.MaxPool2d(kernel_size=3,stride=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         self.classifier =&lt;span&gt; nn.Sequential(
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            nn.Dropout(),
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             nn.Linear(256*6*6,4096&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            nn.Dropout(),
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             nn.Linear(4096,4096&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             nn.Linear(4096&lt;span&gt;,num_classes)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; forward(self, x):
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         x =&lt;span&gt; self.features(x)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         x = x.view(x.size(0),-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         x =&lt;span&gt; self.classifier(x)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; x
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;VGGNet&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在&lt;span lang=&quot;EN-US&quot;&gt;2014年，参加&lt;span lang=&quot;EN-US&quot;&gt;ILSVRC竞赛的“&lt;span lang=&quot;EN-US&quot;&gt;VGG”队在&lt;span lang=&quot;EN-US&quot;&gt;ImageNet上获得了比赛的亚军。&lt;span lang=&quot;EN-US&quot;&gt;VGG的核心思想是利用较小的卷积核来增加网络的深度。常用的有&lt;span lang=&quot;EN-US&quot;&gt;VGG16、&lt;span lang=&quot;EN-US&quot;&gt;VGG19两种类型。&lt;span lang=&quot;EN-US&quot;&gt;VGG16拥有&lt;span lang=&quot;EN-US&quot;&gt;13个卷积层（核大小均为&lt;span lang=&quot;EN-US&quot;&gt;3*3），&lt;span lang=&quot;EN-US&quot;&gt;5个最大池化层，&lt;span lang=&quot;EN-US&quot;&gt;3个全连接层。&lt;span lang=&quot;EN-US&quot;&gt;VGG19拥有&lt;span lang=&quot;EN-US&quot;&gt;16个卷积层（核大小均为&lt;span lang=&quot;EN-US&quot;&gt;3*3），&lt;span lang=&quot;EN-US&quot;&gt;5个最大池化层，&lt;span lang=&quot;EN-US&quot;&gt;3个全连接层，如图1.4所示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190304220838188-1483249144.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图1.4&lt;/p&gt;
&lt;p&gt;　　加深结构都使用&lt;span lang=&quot;EN-US&quot;&gt;ReLU激活函数，&lt;span lang=&quot;EN-US&quot;&gt;VGG19比&lt;span lang=&quot;EN-US&quot;&gt;VGG16的区别在于多了&lt;span lang=&quot;EN-US&quot;&gt;3个卷积层，利用&lt;span lang=&quot;EN-US&quot;&gt;pytorch实现整&lt;span lang=&quot;EN-US&quot;&gt;VG16模型，&lt;span lang=&quot;EN-US&quot;&gt;VGG19同理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;113&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch as torch
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.nn as nn
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VGG16(nn.Module):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,num_classes):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         super(VGG16,self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.features =&lt;span&gt; nn.Sequential(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             nn.Conv2d(3,64,kernel_size=3,padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             nn.Conv2d(64,64,kernel_size=3,padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             nn.Conv2d(64,128,kernel_size=3,padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             nn.Conv2d(128, 128, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             nn.Conv2d(128, 256, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             nn.Conv2d(256, 256, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             nn.Conv2d(256, 256, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             nn.Conv2d(256, 512, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             nn.Conv2d(512, 512, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             nn.Conv2d(512, 512, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             nn.Conv2d(512, 512, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             nn.Conv2d(512, 512, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             nn.Conv2d(512, 512, kernel_size=3, padding=1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         self.classifier =&lt;span&gt; nn.Sequential(
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             nn.Linear(512*7*7,4096&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             nn.ReLU(inplace=&lt;span&gt;True),
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            nn.Dropout(),
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             nn.Linear(4096,4096&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            nn.ReLU(True),
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            nn.Dropout(),
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;             nn.Linear(4096&lt;span&gt;,num_classes)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; forward(self, x):
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         x =&lt;span&gt; self.features(x),
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         x = x.view(x.size(0),-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         x =&lt;span&gt; self.classifier(x)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; x
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;GoogLeNet&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　GoogLeNet专注于加深网络结构，与此同时引入了新的基本结构——&lt;span lang=&quot;EN-US&quot;&gt;Inception模块，从而来增加网络的宽度。&lt;span lang=&quot;EN-US&quot;&gt;GoogLeNet一共&lt;span lang=&quot;EN-US&quot;&gt;22层，它没有全连接层，在&lt;span lang=&quot;EN-US&quot;&gt;2014年的比赛中获得了冠军。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　每个原始&lt;span lang=&quot;EN-US&quot;&gt;Inception模块由&lt;span lang=&quot;EN-US&quot;&gt;previous layer、并行处理层及&lt;span lang=&quot;EN-US&quot;&gt;filter concatenation层组成，如图&lt;span lang=&quot;EN-US&quot;&gt;1.5。并行处理层包含&lt;span lang=&quot;EN-US&quot;&gt;4个分支，即&lt;span lang=&quot;EN-US&quot;&gt;1*1卷积分支，&lt;span lang=&quot;EN-US&quot;&gt;3*3卷积分支，&lt;span lang=&quot;EN-US&quot;&gt;5*5卷积分支和&lt;span lang=&quot;EN-US&quot;&gt;3*3最大池化分支。一个关于原始&lt;span lang=&quot;EN-US&quot;&gt;Inception模块的最大问题是，&lt;span lang=&quot;EN-US&quot;&gt;5*5卷积分支即使采用中等规模的卷积核个数，在计算代价上也可能是无法承受的。这个问题在混合池化层之后会更为突出，很快的出现计算量的暴涨。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190304233450094-509721844.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;   图&lt;span lang=&quot;EN-US&quot;&gt;1.5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为了克服原始&lt;span lang=&quot;EN-US&quot;&gt;Inception模块上的困难，&lt;span lang=&quot;EN-US&quot;&gt;GoogLeNet推出了一个新款，即采用&lt;span lang=&quot;EN-US&quot;&gt;1*1的卷积层来降低输入层的维度，使网络参数减少，因此减少网络的复杂性，如图&lt;span lang=&quot;EN-US&quot;&gt;1.6。因此得到降维&lt;span lang=&quot;EN-US&quot;&gt;Inception模块，称为&lt;span lang=&quot;EN-US&quot;&gt;inception V1。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190304233515838-345936654.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 图1.6&lt;/p&gt;
&lt;p&gt;　　从&lt;span lang=&quot;EN-US&quot;&gt;GoogLeNet中明显看出，共包含&lt;span lang=&quot;EN-US&quot;&gt;9个&lt;span lang=&quot;EN-US&quot;&gt;Inception V1模块，如图1.7所示。所有层均采用了&lt;span lang=&quot;EN-US&quot;&gt;ReLU激活函数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190305220144078-1371624951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图1.7&lt;/p&gt;
&lt;p&gt;　　自从&lt;span lang=&quot;EN-US&quot;&gt;2014年过后，&lt;span lang=&quot;EN-US&quot;&gt;Inception模块不断的改进，现在已发展到&lt;span lang=&quot;EN-US&quot;&gt;V4。&lt;span lang=&quot;EN-US&quot;&gt;GoogLeNet V2中的&lt;span lang=&quot;EN-US&quot;&gt;Inception参考&lt;span lang=&quot;EN-US&quot;&gt;VGGNet用两个&lt;span lang=&quot;EN-US&quot;&gt;3*3核的卷积层代替了具有&lt;span lang=&quot;EN-US&quot;&gt;5*5核的卷积层，与此同时减少了一个辅助分类器，并引入了&lt;span lang=&quot;EN-US&quot;&gt;Batch Normalization（&lt;span lang=&quot;EN-US&quot;&gt;BN），它是一个非常有用的正则化方法。&lt;span lang=&quot;EN-US&quot;&gt;V3相对于&lt;span lang=&quot;EN-US&quot;&gt;V2的学习效率提升了很多倍，并且训练时间大大缩短了。在&lt;span lang=&quot;EN-US&quot;&gt;ImageNet上的&lt;span lang=&quot;EN-US&quot;&gt;top-5错误率为&lt;span lang=&quot;EN-US&quot;&gt;4.8%。&lt;span lang=&quot;EN-US&quot;&gt;Inception V3通过改进&lt;span lang=&quot;EN-US&quot;&gt;V2得到，其核心思想是将一个较大的&lt;span lang=&quot;EN-US&quot;&gt;n*n的二维卷积拆成两个较小的一维卷积&lt;span lang=&quot;EN-US&quot;&gt;n*1和&lt;span lang=&quot;EN-US&quot;&gt;1*n。&lt;span lang=&quot;EN-US&quot;&gt;Inception V3有三种不同的结构（&lt;span lang=&quot;EN-US&quot;&gt;Base的大小分别为&lt;span lang=&quot;EN-US&quot;&gt;35*35、&lt;span lang=&quot;EN-US&quot;&gt;17*17、&lt;span lang=&quot;EN-US&quot;&gt;8*8），如图1.8所示，其中分支可能嵌套。&lt;span lang=&quot;EN-US&quot;&gt;GoogLeNet也只用了一个辅助分类器，在&lt;span lang=&quot;EN-US&quot;&gt;ImageNet上&lt;span lang=&quot;EN-US&quot;&gt;top-5的错误率为&lt;span lang=&quot;EN-US&quot;&gt;3.5%。&lt;span lang=&quot;EN-US&quot;&gt;Inception V4是一种与&lt;span lang=&quot;EN-US&quot;&gt;Inception V3类似或更复杂的网络模块。&lt;span lang=&quot;EN-US&quot;&gt;V4在&lt;span lang=&quot;EN-US&quot;&gt;ImageNet上&lt;span lang=&quot;EN-US&quot;&gt;top-5的错误率为&lt;span lang=&quot;EN-US&quot;&gt;3.08%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190305220244072-1917649206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图1.8&lt;/p&gt;

&lt;p&gt;　　接下来利用&lt;span lang=&quot;EN-US&quot;&gt;pytorch实现&lt;span lang=&quot;EN-US&quot;&gt;GoogLeNet中的&lt;span lang=&quot;EN-US&quot;&gt;Inception V2模块，其实整个&lt;span lang=&quot;EN-US&quot;&gt;GoogLeNet都是由&lt;span lang=&quot;EN-US&quot;&gt;Inception模块构成的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.nn as nn
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch as torch
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.nn.functional as F
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torchvision.models.inception
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasicConv2d(nn.Module):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,in_channels,out_channels,**&lt;span&gt;kwargs):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         super(BasicConv2d,self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.conv = nn.Conv2d(in_channels,out_channels,bias=False,**&lt;span&gt;kwargs)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.bn = nn.BatchNorm2d(out_channels,eps=0.001&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; forward(self, x):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         x =&lt;span&gt; self.conv(x)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         x =&lt;span&gt; self.bn(x)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; F.relu(x,inplace=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Inception(nn.Module):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,in_channels,pool_features):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         super(Inception,self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         self.branch1X1 = BasicConv2d(in_channels,64,kernel_size = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         self.branch5X5_1 = BasicConv2d(in_channels,48,kernel_size = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         self.branch5X5_2 = BasicConv2d(48,64,kernel_size=5,padding = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         self.branch3X3_1 = BasicConv2d(in_channels,64,kernel_size = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         self.branch3X3_2 = BasicConv2d(64,96,kernel_size = 3,padding = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.branch3X3_2 = BasicConv2d(96, 96, kernel_size=1,padding = 1)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         self.branch_pool = BasicConv2d(in_channels,pool_features,kernel_size = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; forward(self, x):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         branch1X1 =&lt;span&gt; self.branch1X1(x)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         branch5X5 =&lt;span&gt; self.branch5X5_1(x)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         branch5X5 =&lt;span&gt; self.branch5X5_2(branch5X5)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         branch3X3 =&lt;span&gt; self.branch3X3_1(x)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         branch3X3 =&lt;span&gt; self.branch3X3_2(branch3X3)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         branch_pool = F.avg_pool2d(x,kernel_size = 3,stride = 1,padding = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         branch_pool =&lt;span&gt; self.branch_pool(branch_pool)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         outputs =&lt;span&gt; [branch1X1,branch3X3,branch5X5,branch_pool]
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; torch.cat(outputs,1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;ResNet&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　随着神经网络的深度不断的加深，梯度消失、梯度爆炸的问题会越来越严重，这也导致了神经网络的学习与训练变得越来越困难。有些网络在开始收敛时，可能出现退化问题，导致准确率很快达到饱和，出现层次越深、错误率反而越高的现象。让人惊讶的是，这不是过拟合的问题，仅仅是因为加深了网络。这便有了&lt;span lang=&quot;EN-US&quot;&gt;ResNet的设计，&lt;span lang=&quot;EN-US&quot;&gt;ResNet在&lt;span lang=&quot;EN-US&quot;&gt;2015年的&lt;span lang=&quot;EN-US&quot;&gt;ImageNet竞赛获得了冠军，由微软研究院提出，通过残差模块能够成功的训练高达&lt;span lang=&quot;EN-US&quot;&gt;152层深的网络，如图&lt;span lang=&quot;EN-US&quot;&gt;1.10所示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;ReNet与普通残差网络不同之处在于，引入了跨层连接（&lt;span lang=&quot;EN-US&quot;&gt;shorcut connection），来构造出了残差模块。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在一个残差模块中，一般跨层连接只有跨&lt;span lang=&quot;EN-US&quot;&gt;2~3层，如图&lt;span lang=&quot;EN-US&quot;&gt;1.9所示，但是不排除跨更多的层，跨一层的实验效果不理想。&lt;/span&gt;&lt;/span&gt;在去掉跨连接层，用其输出用&lt;span lang=&quot;EN-US&quot;&gt;H(x)，当加入跨连接层时，&lt;span lang=&quot;EN-US&quot;&gt;F(x) 与&lt;span lang=&quot;EN-US&quot;&gt;H(x)存在关系：&lt;span lang=&quot;EN-US&quot;&gt;F(x)：&lt;span lang=&quot;EN-US&quot;&gt;=H(x)-X，称为残差模块。既可以用全连接层构造残差模块，也可以用卷积层构造残差模块。基于残差模块的网络结构非常的深，其深度可达&lt;span lang=&quot;EN-US&quot;&gt;1000层以上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190305225132404-1774391844.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图&lt;span lang=&quot;EN-US&quot;&gt;1.9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190305225239151-1740331971.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图&lt;span lang=&quot;EN-US&quot;&gt;1.10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用于&lt;span lang=&quot;EN-US&quot;&gt;ImageNet&lt;/span&gt;的&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;种深层残差网络结构，如图&lt;span lang=&quot;EN-US&quot;&gt;1.11&lt;/span&gt;所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190305225314618-1356204480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.11&lt;/p&gt;
&lt;p&gt;　　从何凯明的论文中也读到&lt;span lang=&quot;EN-US&quot;&gt;plain-18、&lt;span lang=&quot;EN-US&quot;&gt;plain-34（即未加&lt;span lang=&quot;EN-US&quot;&gt;shotcut层）错误率比&lt;span lang=&quot;EN-US&quot;&gt;ResNet-18、&lt;span lang=&quot;EN-US&quot;&gt;ResNet-34（加了&lt;span lang=&quot;EN-US&quot;&gt;shotcut层）大了很多，如图&lt;span lang=&quot;EN-US&quot;&gt;1.12所示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190305225332236-1733364872.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图&lt;span lang=&quot;EN-US&quot;&gt;1.12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下面利用&lt;span lang=&quot;EN-US&quot;&gt;pytorch实现&lt;span lang=&quot;EN-US&quot;&gt;ReNet的残差学习单元，此处参考了torchvision的model。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.nn as nn
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; conv3x3(in_planes, out_planes, stride=1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;3x3 convolution with padding&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=&lt;span&gt;stride,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                      padding=1, bias=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasicBlock(nn.Module):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     expansion = 1
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, inplanes, planes, stride=1, downsample=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         super(BasicBlock, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.conv1 =&lt;span&gt; conv3x3(inplanes, planes, stride)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.bn1 =&lt;span&gt; nn.BatchNorm2d(planes)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.relu = nn.ReLU(inplace=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.conv2 =&lt;span&gt; conv3x3(planes, planes)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         self.bn2 =&lt;span&gt; nn.BatchNorm2d(planes)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         self.downsample =&lt;span&gt; downsample
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         self.stride =&lt;span&gt; stride
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; forward(self, x):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         residual =&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         out =&lt;span&gt; self.conv1(x)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         out =&lt;span&gt; self.bn1(out)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         out =&lt;span&gt; self.relu(out)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         out =&lt;span&gt; self.conv2(out)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         out =&lt;span&gt; self.bn2(out)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.downsample &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             residual =&lt;span&gt; self.downsample(x)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         out +=&lt;span&gt; residual
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         out =&lt;span&gt; self.relu(out)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; out
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，不管是LeNet，还是VGGNet，亦或是ResNet，这些经典的网络结构，pytorch的torchvision的model中都已经实现，并且还有预训练好的模型，可直接对模型进行微调便可使用。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 15:36:00 +0000</pubDate>
<dc:creator>泽积</dc:creator>
<og:description>LeNet 1998年，LeCun提出了第一个真正的卷积神经网络，也是整个神经网络的开山之作，称为LeNet，现在主要指的是LeNet5或LeNet-5，如图1.1所示。它的主要特征是将卷积层和下采样</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shenpings1314/p/10468418.html</dc:identifier>
</item>
<item>
<title>学习笔记---线性表 - 殇灬央</title>
<link>http://www.cnblogs.com/shangyang/p/10474812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shangyang/p/10474812.html</guid>
<description>&lt;p&gt;           线性表是n个类型相同数据元素的有限序列，通常记作（a&lt;sub&gt;1&lt;/sub&gt;，…，a&lt;sub&gt;i-1&lt;/sub&gt;，a&lt;sub&gt;i&lt;/sub&gt;，a&lt;sub&gt;i+1&lt;/sub&gt;，…，a&lt;sub&gt;n&lt;/sub&gt;）。&lt;/p&gt;
&lt;h3&gt;　　1.相同数据类型&lt;/h3&gt;
&lt;p&gt;　　　　在线性表的定义中，线性表的n个数据元素具有相同的数据类型。&lt;/p&gt;
&lt;p&gt;　　　　比如都是数字，如（1,2,3,4,5)；&lt;/p&gt;
&lt;p&gt;　　　　也可以都是字符，如（A，B，...，Z）；&lt;/p&gt;
&lt;p&gt;　　　　还可以是具有更复杂结构的数据元素，如学生，图书，商品。&lt;/p&gt;
&lt;p&gt;　　　　相同的数据类型意味着在内存中存储时，每个元素会占用相同的内存空间，便于后续的查询定位。&lt;/p&gt;
&lt;h3&gt;　　2.序列（有序性）&lt;/h3&gt;
&lt;p&gt;　　　　在线性表的相邻数据元素之间存在着徐偶关系。&lt;/p&gt;
&lt;p&gt;　　　　即a&lt;sub&gt;i-1&lt;/sub&gt;是a&lt;sub&gt;i&lt;/sub&gt;的直接前驱，则a&lt;sub&gt;i&lt;/sub&gt;是a&lt;sub&gt;i-1&lt;/sub&gt;的直接后续，&lt;/p&gt;
&lt;p&gt;　　　　同时a&lt;sub&gt;i&lt;/sub&gt;又是a&lt;sub&gt;i+1&lt;/sub&gt;的直接前驱，a&lt;sub&gt;i+1&lt;/sub&gt;是a&lt;sub&gt;i&lt;/sub&gt;的直接后继。&lt;/p&gt;
&lt;p&gt;　　　　唯一没有直接前驱的元素a&lt;sub&gt;0&lt;/sub&gt;一端称为表头，&lt;/p&gt;
&lt;p&gt;　　　　唯一没有直接后续的元素a&lt;sub&gt;n&lt;/sub&gt;一端称为表尾。&lt;/p&gt;
&lt;p&gt;　　　　除了表头和表尾元素外，任何一个元素都有且仅有一个直接前驱和直接后继。&lt;/p&gt;
&lt;h3&gt;　　3.有限&lt;/h3&gt;
&lt;p&gt;　　　　线性表中数据元素的个数n定义为线性表的长度，n是一个有限值。&lt;/p&gt;
&lt;p&gt;　　　　当n=0时线性表为空表。&lt;/p&gt;
&lt;p&gt;　　　　在非空的线性表中每个数据元素在线性表中都有唯一确定的序号，如a&lt;sub&gt;0&lt;/sub&gt;的序号是0,a&lt;sub&gt;i&lt;/sub&gt;的序号是i。&lt;/p&gt;
&lt;p&gt;　　　　在一个具有n&amp;gt;0个数据元素的线性表中，数据元素序号的范围是[0,n-1]。&lt;/p&gt;
&lt;h2&gt; 线性表的逻辑结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190305223802059-1390743454.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;线性表的存储结构&lt;/h2&gt;
&lt;h4&gt;　　1.顺序表-------顺序存储结构&lt;/h4&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190305224635401-436006542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　特点：在内存中分配连续的空间，只存储数据，不需要存储地址信息，位置就隐含着地址。&lt;/p&gt;
&lt;p&gt;　　　　优点：&lt;/p&gt;
&lt;p&gt;　　　　　　1.节省存储空间，数据是连续存放的，命中率比较高。&lt;/p&gt;
&lt;p&gt;　　　　　　2.索引查找效率高，即一个结点对应一个序号，由该序号可以直接计算出结点的存储地址。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　假设线性表的每个数据元素需占用K个存储单元，并以元素所占的第一个存储单元的地址作为数据元素的存储地址。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　线性表的i号元素a&lt;sub&gt;i&lt;/sub&gt;的存储地址为&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　LOC(a&lt;sub&gt;i&lt;/sub&gt;) = LOC(a&lt;sub&gt;0&lt;/sub&gt;) + i*K&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　其中LOC(a&lt;sub&gt;0&lt;/sub&gt;)为0号元素a&lt;sub&gt;0&lt;/sub&gt;的存储地址，通常成为线性表的起始地址。&lt;/p&gt;

&lt;p&gt;　　　　缺点：&lt;/p&gt;
&lt;p&gt;　　　　　　1.插入和删除操作需要移动元素，效率较低。&lt;/p&gt;
&lt;p&gt;　　　　　　2.必须提前分配固定数量的空间，如果存储元素少，可能导致空闲浪费。&lt;/p&gt;
&lt;p&gt;　　　　　　3.按照内容查询效率低，因为需要逐个比较判断。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;span&gt;时间复杂度 :查找操作为O(1) ,插入和删除操作为O(n)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;　　2.链表------链式存储结构&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190305230934559-232854978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　特点：该线性表中的数据元素可以用任意的存储单元来存储。线性表中逻辑相邻的两元素的存储空间可以是不连续的。&lt;/p&gt;
&lt;p&gt;　　　　　　每个结点是由数据域和指针域组成。元素之间的逻辑关系通过存储节点之间的链接关系反映出来。&lt;/p&gt;
&lt;p&gt;　　　　　　逻辑上相邻的节点物理上不必相邻。&lt;/p&gt;
&lt;p&gt;　　　　优点：&lt;/p&gt;
&lt;p&gt;　　　　　　1.插入、删除灵活，不必移动节点，只需改变指针指向即可。&lt;/p&gt;
&lt;p&gt;　　　　　　2.不用事先开辟内存，有元素才会分配内存空间。&lt;/p&gt;
&lt;p&gt;　　　　　　3.内存利用率较高。&lt;/p&gt;
&lt;p&gt;　　　　缺点：&lt;/p&gt;
&lt;p&gt;　　　　　　1.比顺序存结构的存储密度小（需占用额外的空间存储指针，比较浪费空间）。&lt;/p&gt;
&lt;p&gt;　　　　　　2.查找结点时链式存储要比顺序节点慢（每个节点地址不连续，查找时需循环链表）。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;span&gt;时间复杂度 :查找操作为O(n) ,插入和删除操作为O(1)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 15:30:00 +0000</pubDate>
<dc:creator>殇灬央</dc:creator>
<og:description>线性表是n个类型相同数据元素的有限序列，通常记作（a1，…，ai-1，ai，ai+1，…，an）。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shangyang/p/10474812.html</dc:identifier>
</item>
<item>
<title>Redis Cluster搭建高可用Redis服务器集群 - java_lover</title>
<link>http://www.cnblogs.com/haha12/p/10480534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haha12/p/10480534.html</guid>
<description>&lt;h3 id=&quot;hrediscluster&quot;&gt;一、Redis Cluster集群简介&lt;/h3&gt;
&lt;p&gt;Redis Cluster是Redis官方提供的分布式解决方案，在3.0版本后推出的，有效地解决了Redis分布式的需求，当一个节点挂了可以快速的切换到另一个节点，当遇到单机内存、并发等瓶颈时，可以采用分布式方案要解决问题。&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;二、集群原理&lt;/h3&gt;
&lt;h3&gt;&lt;img title=&quot;Redis Cluster架构图&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OXnTwHqwxnbpv8C671GKz7n50nmk8UpRstJUPoSOX3AzYjllV66nlXS4b4icicibCOt9pD9BRqHAoMYLzJxzxkhag/0?wx_fmt=jpeg&quot; alt=&quot;Redis Cluster架构图&quot;/&gt;Redis Cluster架构图&lt;br/&gt;Redis Cluster集群采用了P2P的模式，完全去中心化，Redis把所有的Key分成了16384个slot，每个Redis实例负责其中一部分slot，集群中的所有信息（节点、端口、slot等），都通过节点之间定期的数据交换而更新，Redis客户端可以在任意一个Redis实例发出请求，如果所需数据不在该实例中，通过重定向命令引导客户端访问所需的实例。&lt;/h3&gt;

&lt;p&gt;其结构特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。&lt;/li&gt;
&lt;li&gt;节点的fail是通过集群中超过半数的节点检测失效时才生效。&lt;/li&gt;
&lt;li&gt;客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。&lt;/li&gt;
&lt;li&gt;redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配），cluster负责维护node&amp;lt;-&amp;gt;slot&amp;lt;-&amp;gt;value。&lt;/li&gt;
&lt;li&gt;Redis集群预分好16384个桶，当需要在Redis集群中放置一个key-value 时，根据CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h-1&quot;&gt;三、集群搭建&lt;/h3&gt;
&lt;p&gt;要让集群正常工作至少需要3个主节点，一共就需要6个节点，其中3个为主节点，3个为从节点，为了简单在下面在一台机器上演示，演示使用了linux服务器上7000到7005的6个端口。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载redis、解压、安装&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs go&quot;&gt;wget http:&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;将redis-trib.rb复制到/usr/local/bin目录下&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cd src&lt;br/&gt;cp redis-trib.rb /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local/bin&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;创建Redis节点并修改配置文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;mkdir redis_cluster　　&lt;br/&gt;cd redis_cluster/&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;mkdir &lt;span class=&quot;hljs-number&quot;&gt;7000 &lt;span class=&quot;hljs-number&quot;&gt;7001 &lt;span class=&quot;hljs-number&quot;&gt;7002 &lt;span class=&quot;hljs-number&quot;&gt;7003 &lt;span class=&quot;hljs-number&quot;&gt;7004 &lt;span class=&quot;hljs-number&quot;&gt;7005&lt;br/&gt;cp redis.conf redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7000&lt;br/&gt;cp redis.conf redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7001&lt;br/&gt;cp redis.conf redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7002&lt;br/&gt;cp redis.conf redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7003&lt;br/&gt;cp redis.conf redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7004&lt;br/&gt;cp redis.conf redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7005&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按下面提示修改6个配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs delphi&quot;&gt;port  &lt;span class=&quot;hljs-number&quot;&gt;7000       &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;启动6个Redis实例，并且要指定配置文件，这些配置文件分别在各自的子目录下面&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs vbscript&quot;&gt;./src/redis-&lt;span class=&quot;hljs-built_in&quot;&gt;server redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7000/redis.conf &lt;br/&gt;./src/redis-&lt;span class=&quot;hljs-built_in&quot;&gt;server redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7001/redis.conf &lt;br/&gt;./src/redis-&lt;span class=&quot;hljs-built_in&quot;&gt;server redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7002/redis.conf &lt;br/&gt;./src/redis-&lt;span class=&quot;hljs-built_in&quot;&gt;server redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7003/redis.conf &lt;br/&gt;./src/redis-&lt;span class=&quot;hljs-built_in&quot;&gt;server redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7004/redis.conf &lt;br/&gt;./src/redis-&lt;span class=&quot;hljs-built_in&quot;&gt;server redis_cluster/&lt;span class=&quot;hljs-number&quot;&gt;7005/redis.conf &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;安装ruby&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;yum &lt;span class=&quot;hljs-keyword&quot;&gt;install ruby&lt;br/&gt;yum &lt;span class=&quot;hljs-keyword&quot;&gt;install -y rubygems&lt;br/&gt;gem &lt;span class=&quot;hljs-keyword&quot;&gt;install redis -v &lt;span class=&quot;hljs-number&quot;&gt;3.2&lt;span class=&quot;hljs-number&quot;&gt;.2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;使用redis-trib.rb创建集群&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;cd /usr/local/bin&lt;br/&gt;./redis-trib.rb create --replicas &lt;span class=&quot;hljs-number&quot;&gt;1 &lt;span class=&quot;hljs-number&quot;&gt;192.168.0.204:7000 &lt;span class=&quot;hljs-number&quot;&gt;192.168.0.204:7001 &lt;span class=&quot;hljs-number&quot;&gt;192.168.0.204:7002 &lt;span class=&quot;hljs-number&quot;&gt;192.168.0.204:7003 &lt;span class=&quot;hljs-number&quot;&gt;192.168.0.204:7004 &lt;span class=&quot;hljs-number&quot;&gt;192.168.0.204:7005  &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;Redis Cluster启动成功截图&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OXnTwHqwxnbpv8C671GKz7n50nmk8UpRW0m3tRAlhJ5hzJ2dq6Giaib6nRpicksFcZ12vsicHZ8TgicWXS20cFkOZiaA/0?wx_fmt=png&quot; alt=&quot;Redis Cluster启动成功截图&quot;/&gt;Redis Cluster启动成功截图&lt;/h3&gt;

&lt;p&gt;如果一切顺利，你会看到类似截图上的消息： [OK] All 16384 slots covered， 这说明Redis的Cluster集群环境搭建成功。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;简单解释一下这个命令：调用 ruby 命令来进行创建集群，--replicas 1 表示主从节点比例为 1:1，即一个主节点对应一个从节点；然后，默认给我们分配好了每个主节点和对应从节点服务，以及solt的大小，因为在Redis集群中有且仅有16383个solt，默认情况会给我们平均分配，当然你可以指定，后续的增减节点也可以重新分配。&lt;br/&gt;M: 5237fa04bd793832b605d92ceb1d2f493da22e43 为主节点Id&lt;br/&gt;S: b6b696c11bbffa8f9d4e6397ef4d27b0b54fea32 192.168.0.204:7003 replicates 5237fa04bd793832b605d92ceb1d2f493da22e43 从节点下对应主节点Id&lt;br/&gt;目前来看，7000-7002 为主节点，7003-7005 为从节点，并向你确认是否同意这么配置，输入yes后，会开始集群创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-2&quot;&gt;四、验证集群&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;通过Cluster Nodes命令和Cluster Info命令来看看集群效果&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;./redis-cli -c  -h 192.168.0.204 -p 7001&lt;br/&gt;cluster info&lt;br/&gt;cluster nodes&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;运行成功截图&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OXnTwHqwxnbpv8C671GKz7n50nmk8UpR5Z4MYN9nNPmFKcsJpxfYicYmpx75vTCjzWEEnOD5Zz7pBu2anORxrcQ/0?wx_fmt=png&quot; alt=&quot;运行成功截图&quot;/&gt;运行成功截图&lt;/h3&gt;

&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在集群上通过增加数据来测试集群效果&lt;br/&gt;运行结果如下：&lt;br/&gt;&lt;img title=&quot;测试集群截图&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OXnTwHqwxnbpv8C671GKz7n50nmk8UpRdnzNlBPrpEnlA5hvEXTSnEK8QnXD1mXpZnaJYE3CVsF31rbbJVVTPw/0?wx_fmt=png&quot; alt=&quot;测试集群截图&quot;/&gt;测试集群截图&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;下面的是我的公众号二维码图片，欢迎关注，欢迎留言，一起学习，一起进步。&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;Java碎碎念公众号&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OXnTwHqwxnYc8Qxiappy2M1MnJcc3MLI9R1PorLeibiczcODP9IAYGdrB2HOTWW24NX5rfeB1ZJ8G4jPfKRnah2WQ/0?wx_fmt=jpeg&quot; alt=&quot;Java碎碎念公众号&quot;/&gt;Java碎碎念公众号&lt;/h3&gt;

</description>
<pubDate>Tue, 05 Mar 2019 15:21:00 +0000</pubDate>
<dc:creator>java_lover</dc:creator>
<og:description>一、Redis Cluster集群简介 Redis Cluster是Redis官方提供的分布式解决方案，在3.0版本后推出的，有效地解决了Redis分布式的需求，当一个节点挂了可以快速的切换到另一个节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haha12/p/10480534.html</dc:identifier>
</item>
<item>
<title>深入理解es6-Promise对象 - 热爱前端的17号诶</title>
<link>http://www.cnblogs.com/sqh17/p/10480431.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sqh17/p/10480431.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;    在之前翻博客时，看到promise，又重读了一边，突然发现理解很浅，记的笔记也不是很好理解，又重新学习promise，加深理解，学以致用&lt;br/&gt;    在promise出来之前，js常用解决异步方式都是采用回调函数方式，但是如果需求过多，会形成一系列的回调函数，俗称：回调地狱。导致后期阅读和维护代码特别麻烦。所以es6的Promise就是为了解决这个麻烦而出来的新对象，之前早就存在，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。&lt;/p&gt;
&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Promise对象是为了简化异步编程。解决回调地狱情况。&lt;/code&gt;&lt;br/&gt;Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。重点是取决与这个事件之后的一系列动作，then()或catch()的等等。&lt;br/&gt;从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise对象用于延迟(deferred) 计算和异步(asynchronous ) 计算。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。这样表示了&lt;code&gt;一旦用了promise对象，就不能退出，直到出现结果为止（resloved或rejected）&lt;/code&gt;&lt;br/&gt;Promise是一个对象，可以用构造函数来创建一个Promise实例。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let promise = new Promise((resolve, reject) =&amp;gt;{
    // .... some coding
    if (true){   // 异步操作成功
        resolve(value);
    } else {
        reject(error);
    }
})
promise.then(value=&amp;gt;{
    // 成功的回调函数
}, error=&amp;gt;{
    // 失败后的回调函数
})
console.log(typeof promise) // object&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;参数解释&quot;&gt;参数解释&lt;/h6&gt;
&lt;p&gt;params:传参是一个回调函数。这个回调函数有两个参数resolve和reject。&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li&gt;resolve: 将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。(简单来说就是&lt;code&gt;成功了的执行&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;reject: 将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。(简单来说就是&lt;code&gt;失败了的执行&lt;/code&gt;)&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;promise之后then的参数：
&lt;ul&gt;&lt;li&gt;第一个参数是成功的回调函数，必选&lt;/li&gt;
&lt;li&gt;第二个参数是失败的回调函数,可选&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 成功时
let promise = new Promise((resolve, reject) =&amp;gt;{
    console.log('开始')
    if (2 &amp;gt; 1){   // 异步操作成功
        resolve({name:'peter',age:25});
    } else {
        reject(error);
    }
})
promise.then(value=&amp;gt;{
    // 成功的回调函数
    console.log(value)
}, error=&amp;gt;{
    // 失败后的回调函数
    console.log(error)
})
// 开始
// {name: &quot;peter&quot;, age: 25} &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 失败时
let promise = new Promise((resolve, reject) =&amp;gt;{
    console.log('开始')
    if (2 &amp;gt; 3){   // 异步操作成功
        resolve(a);
    } else {
        reject('未知错误');
    }
})
promise.then(value=&amp;gt;{
    // 成功的回调函数
    console.log(value)
}, error=&amp;gt;{
    // 失败后的回调函数
    console.log(error)
})
// 开始
// 未知错误&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ps：Promise实例化一个对象后，会立即实行。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;new Promise((resolve, reject)=&amp;gt;console.log('promise'));
console.log('123');
// promise
// 123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个结果发现，先执行promise后执行123。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;promise的特点&quot;&gt;Promise的特点&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。&lt;/li&gt;
&lt;li&gt;一旦状态改变，就不会再变，任何时候都可以得到这个结果。就是成功了就一直是成功的状态fulfilled，失败一直是失败的状态rejected。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;promise先按顺序实行完promise实例中方法再实行then中的resolve或者reject。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let promise = new Promise((resolve, reject)=&amp;gt;{
    console.log('promise')
    if (2 &amp;gt; 1){   // 异步操作成功
        resolve({name:'peter',age:25});
    } else {
        reject(error);
    }
    console.log('end')
})
promise.then(
    value=&amp;gt;{
        console.log(value)
    },
    error=&amp;gt;{
        console.log(error)
    }
)
// promise
// end 
// {name: &quot;peter&quot;, age: 25}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ajax是最常见的异步操作方式，那么用promise封装Ajax的例子&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const getJSON = function (url) {
    const promise = new Promise(function (resolve, reject) {
        const handler = function () {
            if (this.readyState !== 4) {
                return;
            }
            if (this.status === 200) {
                resolve(this.response);
            } else {
                reject(new Error(this.statusText));
            }
        };
        const client = new XMLHttpRequest();
        client.open(&quot;GET&quot;, url);
        client.onreadystatechange = handler;
        client.responseType = &quot;json&quot;;
        client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
        client.send();
    });
    return promise;
};

getJSON(&quot;xxxxx&quot;).then(function (value) {
    console.log('Contents: ' + value);
}, function (error) {
    console.error('出错了', error);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;promise方法&quot;&gt;Promise方法&lt;/h5&gt;
&lt;h6 id=&quot;promise.then&quot;&gt;promise.then()&lt;/h6&gt;
&lt;p&gt;then() 为 Promise 实例添加状态改变时的回调函数,上面已经提起过。&lt;br/&gt;params解释:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个参数是resolved状态的回调函数， 必选&lt;/li&gt;
&lt;li&gt;第二个参数是rejected状态的回调函数, 可选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常情况下，then方法作为成功时的回调方法，catch方法作为失败时回调方法。catch()在后面,可以理解为then方法中的reject参数&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let promise = new Promise((resolve, rejected)=&amp;gt;{
    if(2&amp;lt;3){
        resolve()
    }else{
        rejected()
    }
})
promise.then(resolve=&amp;gt;{
    console.log('right')
}).catch(reject=&amp;gt;{
    console.log('error')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ps: then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var aPromise = new Promise(function (resolve) {
    resolve(100);
});
var thenPromise = aPromise.then(function (value) {
    console.log(value);
});
var catchPromise = thenPromise.catch(function (error) {
    console.error(error);
});
console.log(aPromise !== thenPromise); // =&amp;gt; true
console.log(thenPromise !== catchPromise);// =&amp;gt; true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以每一个then()方法就是一个新promise对象。因此可以采用链式写法，即then方法后面再调用另一个then方法。这样必须要传一个参数过去。&lt;br/&gt;promise的链式编程，就是第一个的Promise实例的返回的值作为下一个Promise实例的参数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function start() {
    return new Promise((resolve, reject) =&amp;gt; {
        resolve('start');
    });
}
start()
    .then(data =&amp;gt; {
        // promise start
        console.log(data);
        return Promise.resolve(1); // 1
    })
    .then(data =&amp;gt; {
        // promise 1
        console.log(data);
    })
// start
// 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面例子可知：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;start函数里resolve里传了一个参数‘start’&lt;/li&gt;
&lt;li&gt;第一个then方法接受了start,然后return 一个成功的值 1&lt;/li&gt;
&lt;li&gt;第二个then方法接受上一个then传来的值 1&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;promise.catch&quot;&gt;Promise.catch()&lt;/h6&gt;
&lt;p&gt;catch()和then()都是挂载在promise对象的原型上的。&lt;br/&gt;&lt;code&gt;Promise.prototype.catch&lt;/code&gt;方法是&lt;code&gt;promise.then(null, rejection&lt;/code&gt;)或&lt;code&gt;promise.then(undefined, rejection)&lt;/code&gt;的别名，用于指定发生错误时的回调函数。&lt;br/&gt;一般是等价于：（在遇到失败的情况下）&lt;br/&gt;&lt;code&gt;Promise.catch()&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;promise.then(null,e=&amp;gt;reject())&lt;/code&gt;&lt;br/&gt;如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const promise = new Promise(function(resolve, reject) {
  throw new Error('test');
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function throwError(value) {
    // 抛出异常
    throw new Error(value);
}
// &amp;lt;1&amp;gt; onRejected不会被调用
function badMain(onRejected) {
    return Promise.resolve(42).then(throwError, onRejected);
}
// &amp;lt;2&amp;gt; 有异常发生时onRejected会被调用
function goodMain(onRejected) {
    return Promise.resolve(42).then(throwError).catch(onRejected);
}
// 运行示例
badMain(function(){
    console.log(&quot;BAD&quot;);
});
goodMain(function(){
    console.log(&quot;GOOD&quot;);
});
// GOOD&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中， badMain 是一个不太好的实现方式（但也不是说它有多坏）， goodMain 则是一个能非常好的进行错误处理的版本。&lt;br/&gt;为什么说 badMain 不好呢？，因为虽然我们在 .then 的第二个参数中指定了用来错误处理的函数，但实际上它却不能捕获第一个参数 onFulfilled 指定的函数（本例为 throwError ）里面出现的错误。也就是说，这时候即使 throwError 抛出了异常，onRejected 指定的函数也不会被调用（即不会输出&quot;BAD&quot;字样）。&lt;br/&gt;与此相对的是， goodMain 的代码则遵循了 throwError→onRejected 的调用流程。 这时候 throwError 中出现异常的话，在会被方法链中的下一个方法，即 .catch 所捕获，进行相应的错误处理。&lt;br/&gt;.then 方法中的onRejected参数所指定的回调函数，实际上针对的是其promise对象或者之前的promise对象，而不是针对 .then 方法里面指定的第一个参数，即onFulfilled所指向的对象，这也是 then 和 catch 表现不同的原因。（详见Javascript Promise 迷你版）&lt;br/&gt;这个是从别人的博客拿来的代码和解释，了那么多，总结为，&lt;code&gt;catch能够捕获它之前的异常，而在then()方法中第二个参数是没办法捕获到的，因为实行了resolve方法。&lt;/code&gt;&lt;/p&gt;
&lt;h6 id=&quot;promise.resolve&quot;&gt;Promise.resolve()&lt;/h6&gt;
&lt;p&gt;看字面量的意思，是返回一个成功的promise实例。&lt;br/&gt;&lt;code&gt;Promise.resolve()&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;new Promise((resolve,rejected)=&amp;gt;resolve())&lt;/code&gt;&lt;br/&gt;最常见的就是将不是promise对象的异步操作转化为promise对象。&lt;br/&gt;该方法有四个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无参数&lt;br/&gt;直接返回一个resolved状态的 Promise 对象，所谓的字面量意思。&lt;/li&gt;
&lt;li&gt;参数是一个 Promise 实例&lt;br/&gt;Promise.resolve将不做任何修改、原封不动地返回这个实例。&lt;/li&gt;
&lt;li&gt;参数是一个thenable对象&lt;br/&gt;所谓的thenable对象指的就是具有then方法的对象，类似于类数组具有数组的length，但不是数组一样。&lt;br/&gt;&lt;code&gt;javascript let thenable = { then: function(resolve, reject) { resolve(42); } }; var promise = Promise.resolve(thenable) .then(value=&amp;gt;console.log(value));// 42&lt;/code&gt;&lt;br/&gt;上面的例子就是将具有then方法的thenable对象转化为promise对象，并且立即执行resolve方法。&lt;/li&gt;
&lt;li&gt;参数不是具有then方法的对象，或根本就不是对象&lt;br/&gt;如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。&lt;br/&gt;&lt;code&gt;javascript var str = '17号' Promise.resolve(str).then(value=&amp;gt;console.log(value)) // 17号&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;promise.reject&quot;&gt;Promise.reject()&lt;/h6&gt;
&lt;p&gt;返回一个新的 Promise 实例，该实例的状态为rejected。用法和resolve一样，但是都是以失败返回结果&lt;br/&gt;&lt;code&gt;Promise.reject()&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;new Promise((resolve,reject) = &amp;gt;reject())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps:Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const thenable = {
  then(resolve, reject) {
    reject('出错了');
  }
};

Promise.reject(thenable)
        .catch( e=&amp;gt; {
            console.log(e)
        })
// 返回的是thenable对象&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;promise.all&quot;&gt;Promise.all()&lt;/h6&gt;
&lt;p&gt;Promise.all 接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 .then() 方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该方法的参数是一个数组&lt;/li&gt;
&lt;li&gt;该方法的参数数组是必须含有promise对象的数组&lt;/li&gt;
&lt;li&gt;只有数组中所有的promise对象都变成resolve或者reject才能进行下一步操作。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// `delay`毫秒后执行resolve
function timerPromisefy(delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve(delay);
        }, delay);
    });
}
var startDate = Date.now();
// 所有promise变为resolve后程序退出
Promise.all([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (values) {
    console.log(Date.now() - startDate + 'ms');
    console.log(values); 
});
// 129ms
// 1,32,64,128&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述结果可以看出，传递给 Promise.all 的promise并不是一个个的顺序执行的，而是同时开始、并行执行的。&lt;br/&gt;假设法：如果这些promise全部串行处理的话，那么需要 等待1ms → 等待32ms → 等待64ms → 等待128ms ，全部执行完毕需要225ms的时间。但实际上不是，而是129ms左右。&lt;/p&gt;
&lt;h6 id=&quot;promise.race&quot;&gt;Promise.race()&lt;/h6&gt;
&lt;p&gt;和Promise.all()方法一样，参数是一个数组，但是只要有一个promise对象更改状态时就实行下一步。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// `delay`毫秒后执行resolve
function timerPromisefy(delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve(delay);
        }, delay);
    });
}
// 任何一个promise变为resolve或reject 的话程序就停止运行
Promise.race([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (value) {
    console.log(value);    // =&amp;gt; 1
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子是1秒后就resolve了，所以直接then()了。&lt;/p&gt;
&lt;h6 id=&quot;promsie.finally&quot;&gt;Promsie.finally()&lt;/h6&gt;
&lt;p&gt;该方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。无论resolve还是reject都会实行的操作，不依赖其他的操作。按照执行顺序。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function promise(){
    return new Promise((resolve, reject) =&amp;gt; {
        resolve('success');
    })
};
promise().then(data =&amp;gt; {
    console.log(data)
    return Promise.reject('fail')
}).finally(() =&amp;gt; {
    console.log('end')
}).catch(data =&amp;gt;{
    console.log(data)
})
// success
// end
// fail&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的例子可知，是按照promise的实行顺序执行的，在then()中，要求返回一个失败的状态，但是却没先实行失败的方法，而是按照顺序实行了finally方法。&lt;/p&gt;
&lt;h6 id=&quot;promise.done&quot;&gt;Promise.done()&lt;/h6&gt;
&lt;p&gt;Promise 对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Promise.prototype.done = function (resolve, reject) {
    this.then(resolve, reject)
        .catch( function (reason) {
            // 抛出一个全局错误
            setTimeout( () =&amp;gt; { throw reason }, 0);
        });
}

// 使用示例
var p = new Promise( (resolve, reject) =&amp;gt; {
    resolve('p');
});
p.then(ret =&amp;gt; {
    console.log(ret);
    return 'then1';
}).catch( err =&amp;gt; {
    console.log(err.toString());
}).then( ret =&amp;gt; {
    console.log(ret);
    return 'then2';
}).then( ret =&amp;gt; {
    console.log(ret);
    x + 2;
}).done();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该例子参考别人的例子。发现到最后直接抛出了 'Uncaught ReferenceError: x is not defined'。说明最后一个then实行时会抛出异常,也可以类似于catch方法吧。&lt;/p&gt;
&lt;h6 id=&quot;总结&quot;&gt;总结&lt;/h6&gt;
&lt;p&gt;总结来说Promise其实就是做了一件事情，那就是对异步操作进行了封装，然后可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调地狱，提供统一的接口方法，使得控制异步操作更加容易，但是也有一定的缺点，promise一旦没确定状态，是没法终止的，同样的，也无法取消promise。&lt;br/&gt;如果本文有什么不对的地方，欢迎指出，谢谢，大家一起进步加油。我把笔记放到&lt;a href=&quot;https://github.com/sqh17/notes/blob/master/ways/promise.md&quot;&gt;github&lt;/a&gt;了，如果满意的话给个star。&lt;/p&gt;
&lt;h6 id=&quot;参考资料&quot;&gt;参考资料&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot;&gt;ES6标准入门&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://liubin.org/promises-book/#introduction&quot;&gt;Javascript Promise 迷你版&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007685095&quot;&gt;学习Promise&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 15:10:00 +0000</pubDate>
<dc:creator>热爱前端的17号诶</dc:creator>
<og:description>前言     在之前翻博客时，看到promise，又重读了一边，突然发现理解很浅，记的笔记也不是很好理解，又重新学习promise，加深理解，学以致用 &amp;nbs</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sqh17/p/10480431.html</dc:identifier>
</item>
<item>
<title>typescript中抽象类与接口详细对比与应用场景介绍 - 牙疼哥哥</title>
<link>http://www.cnblogs.com/pomelott/p/10480390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pomelott/p/10480390.html</guid>
<description>&lt;p&gt;现如今，TS正在逐渐成为前端OO编程的不二之选，以下是我在学习过程中对抽象类和接口做的横向对比。&lt;/p&gt;
&lt;p&gt;1. &lt;strong&gt;抽象类当做父类，被继承。且抽象类的派生类的构造函数中必须调用super()；接口可以当做“子类”继承其他类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象类派生：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
abstract class Human {
    constructor (readonly name:string) {}
    
}

class Student extends Human {
    constructor (name:string) {
        super(name)
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口继承类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Man {
    job: string;
    constructor (readonly name: string) {}
    earnMoney () {
        console.log(`earning money`)
    }
}

interface HumanRule extends Man{
    nose: string;
    mouth: string;
    ear: string;
    eye: string;
    eyebrow: string
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当类被接口继承时，通常是需要为这个类的子类添加约束。例如下面的例子中，Man类的子类就需要去实现特定的五官属性，否则将会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Player extends Man implements HumanRule{
    nose: string;
    mouth: string;
    ear: string;
    eye: string;
    eyebrow: string
    constructor (name) {
        super(name);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. &lt;strong&gt;抽象类与接口都无法实例化， 类类型接口实际上是一种 抽象类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按个人理解，在使用类类型的接口时，类类型的接口其实就相当于抽象类的子集。抽象类中除了可以像接口那样只定义不实现外，还可以部分实现，而且也可以使用类型修饰符。&lt;/p&gt;
&lt;p&gt;类类型的接口更多的是当做一种抽象的数据类型使用，此处所说的类型通常是某个类的实例类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
let James: Player = new Player('james');  // 类类型使用

class SoccerPlayer extends Player {
    constructor (name) {
        super(name)
    }

    playSoccer () {
        console.log(`${this.name} is playing soccer.`)
    }
}

function createPlayer (pl: SoccerPlayer, name: string) {  // 类类型调用
    return new SoccerPlayer(name);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. &lt;strong&gt;接口中不能包含具体实现，抽象类中除抽象函数之外，其他函数可以包含具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此处我们将Human类增加一些内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
abstract class Human {
    constructor (readonly name:string) {}
    protected thinking () {
        console.log(`I am a human, so i can think, ${this.name} is thinking.`)
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为人类，可以在人类 这个类中添加具体实现，因为人类都可以思考。所以思考这个类就不必非要放到子类中去具体实现，这也正是抽象类的灵活之处。&lt;/p&gt;
&lt;p&gt;4. &lt;strong&gt;抽象类中的抽象方法在子类中必须实现， 接口中的非可选项在接口被调用时必须实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此处我们继续增加Human类的内容，增加move的具体实现方法为抽象方法，因为不同类型的人，移动的实现不同。（此处实际上也是OO的特性中，多态的一种具体实现）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
abstract class Human {
    constructor (readonly name:string) {}
    protected thinking () {
        console.log(`I am a human, so i can think, ${this.name} is thinking.`)
    }
    abstract move (): void
}

class Student extends Human {
    constructor (name:string) {
        super(name)
    }

    move () {
        console.log(`I am a student, so i move by bus`)
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而接口一旦调用，就必须要严格实现。此处以函数类型的接口为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
interface createPlayer {
    (pl: SoccerPlayer, name:string): SoccerPlayer
}

let createPlayer:createPlayer = function  (pl: SoccerPlayer, name: string) {  // 修改createPlayer 使用匿名函数方法创建
    return new SoccerPlayer(name);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. &lt;strong&gt;抽象方法可当做类的实例方法，添加访问修饰符；但是接口不可以&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象方法的添加访问修饰符和接口的严格实现其实都是各自的特点，我们也往往是根据这些特点去选择究竟是使用抽象类还是使用接口。&lt;/p&gt;
&lt;p&gt;还拿Human类来说：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
abstract class Human {
    constructor (readonly name:string) {}
    protected thinking () {
        console.log(`I am a human, so i can think, ${this.name} is thinking.`)
    }
    protected abstract move (): void
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;我们为move方法添加abstract标识符，是想让开发者非常明白，Human的派生类中必须要实现此方法；而使用protected标识符，是想限制move方法调用或重载的权限。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合来说抽象类更多的是实现业务上的严谨性；接口更多的是制定各种规范，而此规范又分为很多类规范，就像官方文档在介绍接口这一节的时候所说的，例如函数型规范、类类型规范、混合规范、索引规范等。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 14:51:00 +0000</pubDate>
<dc:creator>牙疼哥哥</dc:creator>
<og:description>现如今，TS正在逐渐成为前端OO编程的不二之选，以下是我在学习过程中对抽象类和接口做的横向对比。 1. 抽象类当做父类，被继承。且抽象类的派生类的构造函数中必须调用super()；接口可以当做“子类”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pomelott/p/10480390.html</dc:identifier>
</item>
<item>
<title>工作感悟--对上一份工作总结 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10480133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10480133.html</guid>
<description>&lt;p&gt;      1月份上一家公司离职，给自己放了一个小长假，蛮舒服的, 上周五进入新公司入职，新工作新的开始,加油。&lt;/p&gt;
&lt;p&gt;觉得很有必要对上一份工作做一个总结,因为收获满满。&lt;/p&gt;
&lt;p&gt;     上一家公司不大，我记得我投这家公司给我印象最深是，该公司在招聘上写着‘不加班’,当时就觉得不得了,竟然还有企业招软件开发写上这么一条。后面我去面试了,&lt;/p&gt;
&lt;p&gt;两个人一起面试我,其实我感觉当时表现并不好,可是有一个人一直问我最快什么时候能入职，当时以为是在逗我的,不过第二天晚上确实就拿到了offer，欣喜如狂。虽然&lt;/p&gt;
&lt;p&gt;前几分钟刚刚收到另一个offer，但远远没有这个来的激动，可能是面试的感觉和走进公司的环境吸引了，这就是一见钟情吧，哈哈。&lt;/p&gt;
&lt;p&gt;在这家公司，让自己一下子成长了很多, 这个成长不仅仅从技术角度出发,我觉得最重要的是做事的态度变得更加积极,更加愿意去承担责任！&lt;/p&gt;
&lt;p&gt;主要有两点：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、开始变的对代码有一定的洁癖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     经常会思考: 这段代码从可读性或者效率方面来讲有没有优化的地方。如果还能优化,就觉得很有乐趣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、养成了一个很好的习惯: 学会比人家快一步发现你自己的bug之前去修复它。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      当你开发(开始）完成一个功能后,一定要及时观察日志,数据,看哪里出现错误。&lt;/p&gt;
&lt;p&gt;      也要思考可能哪里会出现问题,并及时解决它。这是一种非常重要的态度。因为bug如果你没有及时处理,总有一天会被发现,当人家发现告诉你,给人感觉是不一样的。&lt;/p&gt;
&lt;p&gt;既然人家发现还是你改,为什么不在人家发现之前就发现它,改掉呢。这样会给同事领导带来很好的印象。&lt;/p&gt;
&lt;p&gt;      最后我走的时候,同事把他的精华送给我,真的很感动。自己再整理后如下:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开发前思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   1、&lt;strong&gt;思考清楚&lt;/strong&gt;：给新任务时,别着急开发，至少思考下 会有哪些开发步骤和可能出现的问题。(我进刚进公司 看了代码就直接开发了 被领导说了 先把需求理解清楚)&lt;/p&gt;
&lt;p&gt;   2、&lt;strong&gt;数据库设计&lt;/strong&gt;：如果需要建新表 那么一定把表的设计思考清楚,再来开发代码,不然如果数据库表都没有考虑清楚如何设计,很可能会带来代码无效开发）&lt;/p&gt;
&lt;p&gt;   3、&lt;strong&gt;数据库设计&lt;/strong&gt;：如果表表之间数据是一对多关系,那么就无需新建关联映射表。如果是多对多关系，那么就应该建一张关联映射表。&lt;/p&gt;
&lt;p&gt;   4、&lt;strong&gt;简单化&lt;/strong&gt;： 任何需求都有最简单的实现方案，如果你的实现方案比较复杂，说明还不是最优方案。&lt;/p&gt;
&lt;p&gt;   5、&lt;strong&gt;设计明了&lt;/strong&gt;： 不要过度设计，需求是时刻在变的。能解决现有需求的设计 就是很不错的设计方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;开发过程中&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   1、&lt;strong&gt;性能的考虑&lt;/strong&gt;：for循环里不对数据库层做任何操作（特殊除外，后面的情况就属于特殊），批量保存数据量太大 分批次保存&lt;/p&gt;
&lt;p&gt;   2、&lt;strong&gt;异常情况处理&lt;/strong&gt;：对所有数据的来源做判断，适当加try catch，日志输出，预警&lt;/p&gt;
&lt;p&gt;   3、&lt;strong&gt;代码风格&lt;/strong&gt;：缩进、命名、注释、空行。保持每写一行代码的干净整洁，而不是想到先写完功能再来一键格式化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;开发完&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  1、&lt;strong&gt;主动解决问题&lt;/strong&gt;：观察日志，报警，数据是否如期入库。要第一时间发现问题，并在造成影响之前，修复掉。&lt;/p&gt;
&lt;p&gt;  2、&lt;strong&gt;优化&lt;/strong&gt;：根据日志情况、数据更新情况，适当做些优化调整。&lt;/p&gt;
&lt;p&gt;  3、&lt;strong&gt;总结&lt;/strong&gt;：在正常运行之前，出了哪些bug，下次如何避免同样的问题发生。&lt;/p&gt;

&lt;p&gt;最后提醒自己，坚持study！坚持study！坚持study！&lt;/p&gt;

</description>
<pubDate>Tue, 05 Mar 2019 14:48:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>工作总结 1月份上一家公司离职，给自己放了一个小长假，蛮舒服的, 上周五进入新公司入职，新工作新的开始,加油。 觉得很有必要对上一份工作做一个总结,因为收获满满。 上一家公司不大，我记得我投这家公司给</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10480133.html</dc:identifier>
</item>
<item>
<title>.NETCore 下支持分表分库、读写分离的通用 Repository - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/10480333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/10480333.html</guid>
<description>&lt;p&gt;首先声明这篇文章不是标题党，我说的这个类库是 FreeSql.Repository，它作为扩展库现实了通用仓储层功能，接口规范参数 abp vnext，定义和实现基础的仓储层（CURD）。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet add package FreeSql.Repository&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.Sqlite, @&quot;Data Source=|DataDirectory|\document.db;Pooling=true;Max Pool Size=10&quot;)
    .UseLogger(loggerFactory.CreateLogger&amp;lt;IFreeSql&amp;gt;())
    .UseAutoSyncStructure(true) //自动迁移实体的结构到数据库
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;过滤与验证&quot;&gt;过滤与验证&lt;/h2&gt;
&lt;p&gt;假设我们有User(用户)、Topic(主题)两个实体，在某领域类中定义了两个仓储：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var userRepository = fsql.GetGuidRepository&amp;lt;User&amp;gt;();
var topicRepository = fsql.GetGuidRepository&amp;lt;Topic&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开发过程中，我总会担心 topicRepository 的数据安全问题，即有可能查询或操作到其他用户的主题。因此在v0.0.7版本进行了改进，增加了 filter lambad 表达式参数。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var userRepository = fsql.GetGuidRepository&amp;lt;User&amp;gt;(a =&amp;gt; a.Id == 1);
var topicRepository = fsql.GetGuidRepository&amp;lt;Topic&amp;gt;(a =&amp;gt; a.UserId == 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在查询/修改/删除时附加此条件，从而达到不会修改其他用户的数据；&lt;/li&gt;
&lt;li&gt;在添加时，使用表达式验证数据的合法性，若不合法则抛出异常；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有朋友说这个功能像 abp 的租户，但这是更小单位的过滤+验证，确保数据安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有朋友说这个功能省事，但我觉得是省心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;分表与分库&quot;&gt;分表与分库&lt;/h2&gt;
&lt;p&gt;GuidRepository 作为分存式仓储将实现了分表与分库（不支持跨服务器分库）的封装类。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var logRepository = fsql.GetGuidRepository&amp;lt;Log&amp;gt;(null, oldname =&amp;gt; $&quot;{oldname}_{DateTime.Now.ToString(&quot;YYYYMM&quot;)}&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们得到一个日志仓储实例按年月分表，使用它 CURD 最终会操作 Log_201903 表。&lt;/p&gt;
&lt;p&gt;注意：虽然 FreeSql 支持 CodeFirst 迁移，但不提供迁移分表，开发环境中仍然可以迁移 Log 表。&lt;/p&gt;
&lt;h2 id=&quot;读写分离&quot;&gt;读写分离&lt;/h2&gt;
&lt;p&gt;FreeSql 支持数据库读写分离，本功能是客户端的读写分离行为，数据库服务器该怎么配置仍然那样配置，不受本功能影响，为了方便描术后面讲到的【读写分离】都是指客户端的功能支持。&lt;/p&gt;
&lt;p&gt;各种数据库的读写方案不一，数据库端开启读写分离功能后，读写分离的实现大致分为以下几种：&lt;/p&gt;
&lt;p&gt;1、nginx代理，配置繁琐且容易出错；&lt;/p&gt;
&lt;p&gt;2、中件间，如MySql可以使用MyCat，但是其他数据库怎么办？&lt;/p&gt;
&lt;p&gt;3、在client端支持；&lt;/p&gt;
&lt;p&gt;FreeSql 实现了第3种方案，支持一个【主库】多个【从库】，【从库】的查询策略为随机方式。&lt;/p&gt;
&lt;p&gt;若某【从库】发生故障，将切换到其他可用【从库】，若已全部不可用则使用【主库】查询。&lt;/p&gt;
&lt;p&gt;出现故障【从库】被隔离起来间隔性的检查可用状态，以待恢复。以 mysql 为例：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var connstr = &quot;Data Source=127.0.0.1;Port=3306;User ID=root;Password=root;&quot; + 
    &quot;Initial Catalog=cccddd;Charset=utf8;SslMode=none;Max pool size=10&quot;;

IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.MySql, connstr)
    .UseSlave(&quot;connectionString1&quot;, &quot;connectionString2&quot;) //使用从数据库，支持多个
    .Build();

select.Where(a =&amp;gt; a.Id == 1).ToOne(); //读【从库】（默认）
select.Master().WhereId(a =&amp;gt; a.Id == 1).ToOne(); //强制读【主库】&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他特性&quot;&gt;其他特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;[x] 支持 CodeFirst 迁移；&lt;/li&gt;
&lt;li&gt;[x] 支持 DbFirst 从数据库导入实体类，支持三种模板生成器；&lt;/li&gt;
&lt;li&gt;[x] 采用 ExpressionTree 高性能读取数据；&lt;/li&gt;
&lt;li&gt;[x] 支持深入的类型映射，比如pgsql的数组类型；&lt;/li&gt;
&lt;li&gt;[x] 支持丰富的表达式函数；&lt;/li&gt;
&lt;li&gt;[x] 支持导航属性查询，和延时加载；&lt;/li&gt;
&lt;li&gt;[x] 支持同步/异步数据库操作方法，丰富多彩的链式查询方法；&lt;/li&gt;
&lt;li&gt;[x] 支持读写分离、分表分库；&lt;/li&gt;
&lt;li&gt;[x] 支持多种数据库，MySql/SqlServer/PostgreSQL/Oracle/Sqlite；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;这个点我还没吃晚饭，对今天更新的 v0.1.11 作两个小时的测试。觉得好请献上宝贵一星，谢谢支持！&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/2881099/FreeSql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/FreeSql&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 14:40:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>首先声明这篇文章不是标题党，我说的这个类库是 FreeSql.Repository，它作为扩展库现实了通用仓储层功能，接口规范参数 abp vnext，定义和实现基础的仓储层（CURD）。 安装 do</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kellynic/p/10480333.html</dc:identifier>
</item>
<item>
<title>函数装饰器和闭包 - StackNeverOverFlow</title>
<link>http://www.cnblogs.com/StackNeverOverFlow/p/10453240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StackNeverOverFlow/p/10453240.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;装饰器基础知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　- 装饰器是可调用对象，其参数是另一个函数&lt;/p&gt;
&lt;p&gt;　　- 装饰器会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; deco(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inner is called&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@deco
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;func is called&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; func被装饰器修改成inner&lt;/span&gt;
&lt;span&gt;func()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func)&lt;p&gt;输出：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;inner is called&lt;br/&gt;&amp;lt;function deco.&amp;lt;locals&amp;gt;.inner at 0x00000155417B9F28&amp;gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Python何时执行装饰器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　- 装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。&lt;/p&gt;
&lt;p&gt;　　- 即在模块导入初始化时运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
registry =&lt;span&gt; []

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; register(func):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running register(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; func)
    registry.append(func)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func

@register
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func1 is running&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

@register
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func2 is running&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func3 is running&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在main()运行之前，register已经运行了两次&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这两次就是在被装饰函数定义时&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所以registry也已经被初始化&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;main is running&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;registry:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,registry)
    func1()
    func2()
    func3()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;p&gt;输出：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;running register(&amp;lt;function func1 at 0x000001BAE35B9EA0&amp;gt;)&lt;br/&gt;running register(&amp;lt;function func2 at 0x000001BAE35B9F28&amp;gt;)&lt;br/&gt;main is running&lt;br/&gt;registry: [&amp;lt;function func1 at 0x000001BAE35B9EA0&amp;gt;, &amp;lt;function func2 at 0x000001BAE35B9F28&amp;gt;]&lt;br/&gt;func1 is running&lt;br/&gt;func2 is running&lt;br/&gt;func3 is running&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;变量作用域规则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　- Python不要求声明变量，但是假定在函数定义体中有赋值的变量是局部变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
b = 3

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(a):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里b是局部变量，所以错误提示为在赋值之前使用&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果想获取全局变量b，需要加上global b&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    b &lt;/span&gt;= 9&lt;span&gt;

f1(&lt;/span&gt;1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;闭包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　- 只有涉及嵌套函数时才有闭包问题&lt;/p&gt;
&lt;p&gt;　　- 闭包指延伸了作用域的某个函数，它包含了不在函数内定义的非全局变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_avg():
    vars &lt;/span&gt;=&lt;span&gt; []

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; avg(value):
        vars.append(value)
        total &lt;/span&gt;=&lt;span&gt; sum(vars)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; total/&lt;span&gt;len(vars)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; avg

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; avg中包含了在make_avg中定义的vars列表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 即使make_avg已经返回，但vars仍然被保留下来&lt;/span&gt;
avg =&lt;span&gt; make_avg()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(11&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(12&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 闭包中引用的非自己定义的的非全局变量称为自由变量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 自由变量的名称被保存在__code__.co_freevars中&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 自由变量的值被保存在__closure__[i].cell_contents中&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg.__code__.co_freevars:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,avg.&lt;span&gt;__code__&lt;/span&gt;&lt;span&gt;.co_freevars)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg.__closure__[0].cell_contents&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,avg.&lt;span&gt;__closure__&lt;/span&gt;[0].cell_contents)&lt;p&gt;输出：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;10.0&lt;br/&gt;10.5&lt;br/&gt;11.0&lt;br/&gt;avg.__code__.co_freevars: ('vars',)&lt;br/&gt;avg.__closure__[0].cell_contents [10, 11, 12]&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;nonlocal声明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　- 在闭包中对自由变量进行赋值，会生成一个局部变量覆盖自由变量，并且报错：局部变量使用前未赋值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_avg():
    count&lt;/span&gt;=&lt;span&gt;0
    total&lt;/span&gt;=&lt;span&gt;0
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; avg(value):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; count+=1就是count = count + 1&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里会自动生成一个未赋初始值的局部变量count覆盖自由变量count&lt;/span&gt;
        count+=1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; total和count相同情况&lt;/span&gt;
        total+=&lt;span&gt;value
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; total/&lt;span&gt;count
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; avg

avg &lt;/span&gt;=&lt;span&gt; make_avg()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(11&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(12&lt;span&gt;))

输出：
UnboundLocalError: local variable &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; referenced before assignment
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 使用nonlocal声明，不会覆盖自由变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_avg():
    count&lt;/span&gt;=&lt;span&gt;0
    total&lt;/span&gt;=&lt;span&gt;0
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; avg(value):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用nonlocal声明，不会覆盖自由变量&lt;/span&gt;
&lt;span&gt;        nonlocal count,total
        count&lt;/span&gt;+=1&lt;span&gt;
        total&lt;/span&gt;+=&lt;span&gt;value
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; total/&lt;span&gt;count
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; avg

avg &lt;/span&gt;=&lt;span&gt; make_avg()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(11&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(avg(12&lt;span&gt;))

输出：
&lt;/span&gt;10.0
10.5
11.0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个函数执行时间的装饰器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　- func的函数__name__和__doc__属性将被clocked相应属性覆盖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; clock(func):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; clocked(*&lt;span&gt;args):
        t0 &lt;/span&gt;=&lt;span&gt; time.perf_counter()
        result &lt;/span&gt;= func(*&lt;span&gt;args)
        elapsed &lt;/span&gt;= time.perf_counter() -&lt;span&gt; t0
        func_name &lt;/span&gt;= func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;
        func_args &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(str(args))
        s &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%0.8fs] %s(%s) --&amp;gt; %r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (elapsed,func_name,func_args,result)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clocked

@clock
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; snooze(n):
    time.sleep(n)

@clock
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n*factorial(n-1&lt;span&gt;)

snooze(&lt;/span&gt;0.123&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; * 100&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;factorial(6):&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,factorial(6&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; * 100&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the name of factorial:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,factorial.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

输出：
[0.12324016s] snooze((,0,.,&lt;/span&gt;1,2,3,,,)) --&amp;gt;&lt;span&gt; None
&lt;/span&gt;----------------------------------------------------------------------------------------------------&lt;span&gt;
[0.00000032s] factorial((,&lt;/span&gt;1,,,)) --&amp;gt; 1&lt;span&gt;
[0.00001091s] factorial((,&lt;/span&gt;2,,,)) --&amp;gt; 2&lt;span&gt;
[0.00002855s] factorial((,&lt;/span&gt;3,,,)) --&amp;gt; 6&lt;span&gt;
[0.00003401s] factorial((,&lt;/span&gt;4,,,)) --&amp;gt; 24&lt;span&gt;
[0.00003914s] factorial((,&lt;/span&gt;5,,,)) --&amp;gt; 120&lt;span&gt;
[0.00004588s] factorial((,&lt;/span&gt;6,,,)) --&amp;gt; 720&lt;span&gt;
factorial(&lt;/span&gt;6): 720
----------------------------------------------------------------------------------------------------&lt;span&gt;
the name of factorial: clocked&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　- 使用wraps装饰器后，func的__name__和__doc__将不会被覆盖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; clock(func):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用wraps装饰器后，func的__name__和__doc__将不会被覆盖&lt;/span&gt;
&lt;span&gt;    @functools.wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; clocked(*&lt;span&gt;args):
        t0 &lt;/span&gt;=&lt;span&gt; time.perf_counter()
        result &lt;/span&gt;= func(*&lt;span&gt;args)
        elapsed &lt;/span&gt;= time.perf_counter() -&lt;span&gt; t0
        func_name &lt;/span&gt;= func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;
        func_args &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(str(args))
        s &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%0.8fs] %s(%s) --&amp;gt; %r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (elapsed,func_name,func_args,result)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clocked

@clock
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n*factorial(n-1&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the name of factorial:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,factorial.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

输出：
the name of factorial: factorial&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用functools.lru_cache做备忘&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; clock(func):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用wraps装饰器后，func的__name__和__doc__将不会被覆盖&lt;/span&gt;
&lt;span&gt;    @functools.wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; clocked(*&lt;span&gt;args):
        t0 &lt;/span&gt;=&lt;span&gt; time.perf_counter()
        result &lt;/span&gt;= func(*&lt;span&gt;args)
        elapsed &lt;/span&gt;= time.perf_counter() -&lt;span&gt; t0
        func_name &lt;/span&gt;= func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;
        func_args &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.join([str(a) &lt;span&gt;for&lt;/span&gt; a &lt;span&gt;in&lt;/span&gt; args &lt;span&gt;if&lt;/span&gt; str(a) != &lt;span&gt;''&lt;/span&gt;&lt;span&gt;])
        s &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%0.8fs] %s(%s) --&amp;gt; %r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (elapsed,func_name,func_args,result)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clocked

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不使用lru_cache，fib(6)要调用fib(1)8次，fic(2)5次等等&lt;/span&gt;
&lt;span&gt;@clock
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fib(n-2) + fib(n-1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用lru_cache，可以缓存中间结果，避免重复调用。&lt;/span&gt;
&lt;span&gt;@functools.lru_cache()
@clock
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib2(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fib2(n-2) + fib2(n-1&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fib(6):&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fib(6&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; * 100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fib2(6):&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fib2(6&lt;span&gt;))

输出：
[0.00000032s] fib(0) &lt;/span&gt;--&amp;gt;&lt;span&gt; 0
[0.00000032s] fib(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00004235s] fib(&lt;/span&gt;2) --&amp;gt; 1&lt;span&gt;
[0.00000000s] fib(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00000000s] fib(0) &lt;/span&gt;--&amp;gt;&lt;span&gt; 0
[0.00000032s] fib(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00001059s] fib(&lt;/span&gt;2) --&amp;gt; 1&lt;span&gt;
[0.00002117s] fib(&lt;/span&gt;3) --&amp;gt; 2&lt;span&gt;
[0.00007443s] fib(&lt;/span&gt;4) --&amp;gt; 3&lt;span&gt;
[0.00000032s] fib(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00000032s] fib(0) &lt;/span&gt;--&amp;gt;&lt;span&gt; 0
[0.00000000s] fib(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00001091s] fib(&lt;/span&gt;2) --&amp;gt; 1&lt;span&gt;
[0.00002181s] fib(&lt;/span&gt;3) --&amp;gt; 2&lt;span&gt;
[0.00000032s] fib(0) &lt;/span&gt;--&amp;gt;&lt;span&gt; 0
[0.00000000s] fib(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00001123s] fib(&lt;/span&gt;2) --&amp;gt; 1&lt;span&gt;
[0.00000032s] fib(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00000032s] fib(0) &lt;/span&gt;--&amp;gt;&lt;span&gt; 0
[0.00000032s] fib(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00001123s] fib(&lt;/span&gt;2) --&amp;gt; 1&lt;span&gt;
[0.00002246s] fib(&lt;/span&gt;3) --&amp;gt; 2&lt;span&gt;
[0.00004459s] fib(&lt;/span&gt;4) --&amp;gt; 3&lt;span&gt;
[0.00007731s] fib(&lt;/span&gt;5) --&amp;gt; 5&lt;span&gt;
[0.00016297s] fib(&lt;/span&gt;6) --&amp;gt; 8&lt;span&gt;
fib(&lt;/span&gt;6): 8
----------------------------------------------------------------------------------------------------&lt;span&gt;
[0.00000000s] fib2(0) &lt;/span&gt;--&amp;gt;&lt;span&gt; 0
[0.00000032s] fib2(&lt;/span&gt;1) --&amp;gt; 1&lt;span&gt;
[0.00001476s] fib2(&lt;/span&gt;2) --&amp;gt; 1&lt;span&gt;
[0.00000064s] fib2(&lt;/span&gt;3) --&amp;gt; 2&lt;span&gt;
[0.00002695s] fib2(&lt;/span&gt;4) --&amp;gt; 3&lt;span&gt;
[0.00000064s] fib2(&lt;/span&gt;5) --&amp;gt; 5&lt;span&gt;
[0.00003882s] fib2(&lt;/span&gt;6) --&amp;gt; 8&lt;span&gt;
fib2(&lt;/span&gt;6): 8
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用单分派函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　- 类似其他面向对象语言的方法重载，以不同方式执行相同操作的一组函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; singledispatch
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; html
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; abc
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numbers

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单分派函数的基函数&lt;/span&gt;
&lt;span&gt;@singledispatch
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; htmlize(obj):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;pre&amp;gt;{}&amp;lt;pre&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(html.escape(repr(obj)))


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 各个专门函数使用@&amp;lt;base_function&amp;gt;.register(&amp;lt;type&amp;gt;)修饰&lt;/span&gt;
&lt;span&gt;@htmlize.register(str)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 函数名无关紧要，_是个不错的选择，简单明了&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _(txt):
    s &lt;/span&gt;= html.escape(txt).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;{}&amp;lt;p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(s)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; numbers.Integral是int的虚拟超类&lt;/span&gt;
&lt;span&gt;@htmlize.register(numbers.Integral)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _(n):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;pre&amp;gt;{0}(0x{0:X})&amp;lt;/pre&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以叠放多个register装饰器，让同一个函数支持不同类型&lt;/span&gt;
&lt;span&gt;@htmlize.register(tuple)
@htmlize.register(abc.MutableSequence)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _(seq):
    inner &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/li&amp;gt;\n&amp;lt;li&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.join(htmlize(item) &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; seq)
    outer &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;ul&amp;gt;\n&amp;lt;li&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + inner + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/li&amp;gt;\n&amp;lt;/ul&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; outer


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(htmlize({1, 2, 3&lt;span&gt;}))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(htmlize(abs))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(htmlize(42&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(htmlize([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alpha&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,66,{3,2,1}]))&lt;p&gt;输出：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;pre&amp;gt;{1, 2, 3}&amp;lt;pre&amp;gt;&lt;br/&gt;&amp;lt;pre&amp;gt;&amp;amp;lt;built-in function abs&amp;amp;gt;&amp;lt;pre&amp;gt;&lt;br/&gt;&amp;lt;pre&amp;gt;42(0x2A)&amp;lt;/pre&amp;gt;&lt;br/&gt;&amp;lt;ul&amp;gt;&lt;br/&gt;&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;alpha&amp;lt;p&amp;gt;&amp;lt;/li&amp;gt;&lt;br/&gt;&amp;lt;li&amp;gt;&amp;lt;pre&amp;gt;66(0x42)&amp;lt;/pre&amp;gt;&amp;lt;/li&amp;gt;&lt;br/&gt;&amp;lt;li&amp;gt;&amp;lt;pre&amp;gt;{1, 2, 3}&amp;lt;pre&amp;gt;&amp;lt;/li&amp;gt;&lt;br/&gt;&amp;lt;/ul&amp;gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个参数化的装饰器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
registry =&lt;span&gt; set()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; register是装饰器工厂，返回一个装饰器&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 它接受一个可选关键字参数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; register(active=&lt;span&gt;True):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; decorate是真正的装饰器，它的参数是一个函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorate(func):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running register(active=%s) -&amp;gt; decorate(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (active,func))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; active为真，注册func&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; active:
            registry.add(func)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; active为假，删除func&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            registry.discard(func)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorate

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; register必须作为函数调用，并且可以传入参数&lt;/span&gt;
@register(active=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running func1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 即使不传入参数，也要作为函数调用&lt;/span&gt;
&lt;span&gt;@register()
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running func2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; active为假，不注册func3&lt;/span&gt;
@register(active=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running func3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    func1()
    func2()
    func3()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(registry)

输出：
running register(active&lt;/span&gt;=True) -&amp;gt; decorate(&amp;lt;function func1 at 0x00000201B1579F28&amp;gt;&lt;span&gt;)
running register(active&lt;/span&gt;=True) -&amp;gt; decorate(&amp;lt;function func2 at 0x00000201B1586048&amp;gt;&lt;span&gt;)
running register(active&lt;/span&gt;=False) -&amp;gt; decorate(&amp;lt;function func3 at 0x00000201B15860D0&amp;gt;&lt;span&gt;)
running func1
running func2
running func3
{&lt;/span&gt;&amp;lt;function func1 at 0x00000201B1579F28&amp;gt;, &amp;lt;function func2 at 0x00000201B1586048&amp;gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三层嵌套的装饰器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

default_fmt &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[{elapsed:0.8f}s] {name}({args}) -&amp;gt; {result}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个三层嵌套的装饰器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; clock(fmt=&lt;span&gt;default_fmt):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; @clock()返回decorate&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorate(func):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再把被装饰函数传递给decorate，运行它&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回clocked，替代被装饰函数&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; clocked(*&lt;span&gt;args):
            t0 &lt;/span&gt;=&lt;span&gt; time.time()
            _result &lt;/span&gt;= func(*&lt;span&gt;args)
            elapsed &lt;/span&gt;= time.time()-&lt;span&gt;t0
            name &lt;/span&gt;= func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;
            args &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.join(repr(item) &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args)
            result &lt;/span&gt;=&lt;span&gt; repr(_result)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(fmt.format(**&lt;span&gt;locals()))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _result
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clocked
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorate

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; func被clocked替代&lt;/span&gt;
&lt;span&gt;@clock()
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    time.sleep(&lt;/span&gt;0.123&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
        func()

输出：
[0.12314367s] func() &lt;/span&gt;-&amp;gt;&lt;span&gt; None
[0.12322927s] func() &lt;/span&gt;-&amp;gt;&lt;span&gt; None
[0.12370729s] func() &lt;/span&gt;-&amp;gt; None
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 05 Mar 2019 13:44:00 +0000</pubDate>
<dc:creator>StackNeverOverFlow</dc:creator>
<og:description>装饰器基础知识 - 装饰器是可调用对象，其参数是另一个函数 - 装饰器会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象 inner is called&lt;function d</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StackNeverOverFlow/p/10453240.html</dc:identifier>
</item>
<item>
<title>Java网络编程中异步编程的理解 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/10479874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/10479874.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这篇文章主要是总结自己对于网络编程中异步，同步，阻塞和非阻塞的理解，这个问题自从学习NIO以来一直困扰着我，，其实想来很久就想写了，只不过当时理解不够，无从下手。最近在学习VertX框架，又去熟悉了下Netty的代码，因为了对于多线程也有了更深的理解，所以才开始对于这些概念有了理解，用于理清思路，本文需要有良好的多线程和网络编程基础，不适合初学者。&lt;/p&gt;
&lt;h2 id=&quot;一异步同步阻塞和非阻塞的理解&quot;&gt;一、异步，同步，阻塞和非阻塞的理解&lt;/h2&gt;
&lt;p&gt;关于这四个概念在IO方面的理解我贴两个链接，他们已经有了很好的说明我就不再讲述：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/19732473/answer/20851256&quot;&gt;怎样理解阻塞非阻塞与同步异步的区别？ - 严肃的回答 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/historyasamirror/article/details/5778378&quot;&gt;IO - 同步，异步，阻塞，非阻塞&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以前在学习c++中muduo只是记得&lt;a href=&quot;https://www.zhihu.com/question/19732473/answer/26091478&quot;&gt;陈硕说的epoll是一个同步非阻塞的模型&lt;/a&gt;，但是网上很多人说Reactor模型是一个异步阻塞的模型，在学习Netty的时候&lt;a href=&quot;https://Netty.io/&quot;&gt;官网&lt;/a&gt;是这么介绍的:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Netty is an asynchronous event-driven network application framework&lt;br/&gt;for rapid development of maintainable high performance protocol servers &amp;amp; clients.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Netty是一个异步的高性能网络框架，那么到底是谁说错了？&lt;/p&gt;
&lt;p&gt;其实大家都没有错误,只是角度不同。&lt;br/&gt;先说说什么IO是异步的？异步其实是针对数据从内核拷贝到用户进程空间这个操作是谁完成的，同步IO非常好理解，当用户进程发起一个read操作的时候发生一次系统调用，然后内核检查有没有数据，如果有则复制数据到进程空间，用户进程继续执行。而异步IO中复制数据到进程空间这个操作是内核帮你完成的，等完成之后再来通知你，执行你的逻辑。Reactor模型中，EventLoop线程在select到有可读数据之后，然后在自己去读取数据，所以从这个角度来讲Reactor模型确实是同步的，在Linux的五种IO模型中只有异步IO是异步的。&lt;/p&gt;
&lt;p&gt;那么为什么Netty说他是一个异步网络库呢，这其实是另一个角度的阐述，对于网络库的作者来说，他们面向的是Linux提供的这些api，所以说多路复用的Reactor是同步的没问题。那么对于Netty的使用者来说，我们面向的是Netty，Netty进一步封装了IO操作，在我们发起IO操作的时候它返回了一个Future，我们可以提供一个监听器来传入我们的回调，当IO操作完成时会执行我们的逻辑，我们的这个操作相对于Netty就是异步的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以Reactor是同步非阻塞的，Netty是异步非阻塞的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二异步编程从用户层面和框架层面不同角度的理解&quot;&gt;二、异步编程从用户层面和框架层面不同角度的理解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Java中的Future是异步的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于这个问题，我想相信很多同学都会认为是异步的，这里我认为是同步的，下面谈谈我的理解。&lt;br/&gt;先想想一个异步操作需要哪些元素，我认为需要&lt;strong&gt;发起者，执行者，执行逻辑，回调逻辑&lt;/strong&gt;。流程： 发起者请求执行者去执行所需逻辑，然后在成功之后调用回调逻辑。Future中缺了什么？没错，就是那个回调！&lt;/p&gt;
&lt;p&gt;我们使用Future的模式一般是：投递一个任务到线程池得有个Future，然后去执行其他可以并行的操作，操作完之后去调用Future的get方法获取结果或者isDone判断是否执行完毕。这里的Future只是对于计算结果的一个建模，我们在后面需要使用的时候再去轮询（轮询也是同步非阻塞的一个标志）或者阻塞，他提供的了一个非常好的特性：非阻塞！所以我认为Future是一个同步非阻塞的实现。也正是因为Future没有实现异步的特性，在jdk1.8之后新增了CompletableFuture提供了异步的特性。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意异步元素的发起者和执行者可以是同一个线程，最常见的例子就是NodeJs的单线程模型。拿Netty的线程来具体，你在EventLoop中发起一个写请求后得到一个Future，你可以设置回调，下次执行这个回调的还是EventLoop线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;用户角度的理解&quot;&gt;用户角度的理解&lt;/h3&gt;
&lt;p&gt;这里主要说说在使用异步编程的一点理解，因为平时还是用为主，我们作为框架的使用者有必要了解一些常见的使用范式。就我目前接触的最多还是CompletableFuture，Netty和VertX，当时也写过一点Js，Js主要也是回调的用法。我知道的用法如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;回调 这种是最常见的，相信也是最容易理解的，Js和VertX很多都采用了这个实现，我们在调用一个函数的时候提供一个响应结果的回调。响应式编程就是结合函数式和异步回调的一个产物，我相信以后会越来越常见&lt;/li&gt;
&lt;li&gt;监听器 这个是Netty的实现，Netty将很多同步的地方改成了异步同时返回一个Future，我们可以通过这个Future添加监听器，执行得到结果时的逻辑&lt;/li&gt;
&lt;li&gt;组合式 相对于回调式，在实现多个回调时代码扁平化，可以了解下CompletableFuture的用法和实现真的是非常的优雅&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因为异步的高性能，很多时候我们自己也想把一个操作封装成异步的，就需要明白到底什么是异步，明白异步需要的元素，你会发现如果不借助以后的异步组件将一个操作封装成异步非常的困难，所以最简单的方案就是将你的回调最终传递到已有异步的组件中。&lt;/p&gt;
&lt;p&gt;举2个简单的例子：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们利用&lt;code&gt;CompletableFuture.supplyAsync(Object::new).thenAccept(o -&amp;gt; System.out.println(o));&lt;/code&gt;这一行非常简单的代码实现了一个异步，&lt;code&gt;Object::new&lt;/code&gt;会被投递到线程池中，然后执行完成后执行打印语句。&lt;/li&gt;
&lt;li&gt;VertX的例子，VertX将很多同步的操作封装成了异步的操作，比如场景的发起Http请求的，他的底层实现就是将这个操作委托给了Netty&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;框架角度的理解&quot;&gt;框架角度的理解&lt;/h3&gt;
&lt;p&gt;框架层面的理解有助于我们在写代码中不会用错。有没有想过一个异步操作框架给你做了什么？&lt;br/&gt;当你发起一个操作的时候，框架会去执行你的逻辑，在执行完毕时(成功或异常)去&lt;strong&gt;修改状态并执行你的回调&lt;/strong&gt;。&lt;strong&gt;修改状态并执行你的回调&lt;/strong&gt;这个操作在JDK中放在了CompletableFuture中，在Netty中则单独采用了Promise接口，其实两者的实现是非常类似的（方法名都取的差不多）。以Netty举例分为Future和Promise两个方法，作为用户我们更应该关心Future的接口，Promise是框架层面需要实现的，我们在自己去实现的时候值得我们去学习里面的思想。&lt;/p&gt;
&lt;p&gt;不过我认为我们直接使用Promise的这种接口的机会很少，Netty和VertX场景下还是有机会用到，在用到Promise接口的时候应该考虑下是否合理，检查下是不是在同一个线程中，是不是可以简单的接口代替。给一个简单的错误示例：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里说下Promise，我们知道Js中也有一个Promise，千万不要当成类似的东西，两者毫无干系，Netty的Promise是对完成操作的行为的建模，Js的Promise是为了组合各个异步的调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import io.VertX.core.Future;

public class AuctionHandler {

  public Future&amp;lt;Void&amp;gt; handle() {
    // 请求级别变量
    Context context = new Context();
    context.future.tryComplete();
    return context.future;
  }

  public static class Context {
    Future&amp;lt;Void&amp;gt; future = Future.future();
  }
  public static void main(String[] args) { 
    //  注意这里的handle方法返回的Future是VertX的。
    //  这里的方法都是在同一个线程中执行的，完全没有异步化，所以可以改成传递一个普通的接口即可
    new AuctionHandler().handle().setHandler(event1 -&amp;gt; System.out.println(&quot;handler exec!&quot;));
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这个的代码错误看上去很低级，但是在开发VertX应用时需要时刻保持警惕。另外还有一点需要说明：当返回给你的Future已经是完成状态时，如上面的代码示例，你再增加回调，&lt;strong&gt;这个回调还会被执行&lt;/strong&gt;，Netty和CompletableFuture在添加回调的时候都是检查状态是否完成，完成的话直接投递到相应线程执行。&lt;/p&gt;
&lt;h2 id=&quot;三为什么使用异步&quot;&gt;三、为什么使用异步&lt;/h2&gt;
&lt;p&gt;为什么要使用异步，相信很多同学都知道是为了高性能，那么异步为什么高性能？&lt;/p&gt;
&lt;p&gt;这里先谈谈NodeJs和Java，对于NodeJs，很多人听说性能十分高，&quot;秒杀&quot;Java。我当时一直无法理解，为什么Js能超过Java，&lt;br/&gt;首先Node是单线程的，虽然可以借助第三方库来实现多线程，另外Jvm作为业界最优秀的虚拟机，那么Node到底是靠了什么超过了Java？这里的关键就在于Node的Io模型采用了Reactor模型，可以处理大量的连接。Java中的Web开发是以Servlet为主导，采用了同步阻塞模型，虽然用线程池实现n个连接用m和线程做优化，但是当有大量连接时，线程数量过多导致的线程调度成本会很高，另外在线程处理Io的时候也是同步阻塞，如果对方返回很难会导致当前线程一直无法释放，所以Tomcat这种不适合处理大量连接的场景。&lt;/p&gt;
&lt;p&gt;我们知道Jetty的底层实现就是Reactor模型，Tomcat在8之后默认也用了Reactor是不是会大幅提高性能？不幸的是，虽然可以提高一些性能但是还是无法和Node一较高低，他解决的是Http连接那一块的阻塞问题，但是由于Servlet的编程模型，大量的同步阻塞操作还是无法避免，比如你在一个请求中去访问了数据库，这个线程就会一直被占用，一定程度上你可以通过增加线程来缓解但是线程过多又会增加调度的成本，可能会导致虚拟机假死。所以如果你的处理中有这种耗时操作，那他就是你的瓶颈，你的qps的上限就很低。在高并发场景下，Servlet的瓶颈会十分突出，只能通过大量的堆机器来水平扩展，但是没有很好的榨干服务器的性能。&lt;/p&gt;
&lt;p&gt;所以我们需要的是编程模型的改变，像Nodejs那样在同步阻塞的地方进行异步非阻塞或者异步阻塞化。Spring5.0中的 WebFlux给了一个对应的解决方案，提供了响应式编程的模型用以取代Servlet，他对常见同步阻塞的地方进行了重写，如Redis和Mysql等常见的IO。很早之前VertX（早期名字Node.X，Java版的Nodejs）框架也提供了这样的编程模型，对很多同步阻塞的地方进行了重写，这个框架十分轻量级，社区活跃度非常高，使用起来非常方便。这两个底层都是Netty，不得不说Netty实在是太强大了。也从另外一个角度说明设计的重要性，语言反而是其次。NodeJs，WebFlux和VertX都采用了类似的Reactor模型，高性能服务器领域这个模型几乎已经是最佳实践，理解这个模型就和多线程一样重要。我觉得拿Servlet和NodeJs来做性能的对比，是十分不公平的。NodeJs在Java领悟的对手应该是VertX这种框架，关于高性能Web框架的对比，&lt;a href=&quot;https://www.techempower.com/benchmarks/&quot;&gt;techempower&lt;/a&gt;这个网站已经给出了详细的排名，排名前十的大部分是Jvm语言，Nodejs在五十名之后了，所以不要在拿Servlet去和NodeJs做对比了，Servlet这种模型在高并发领悟一定会被逐渐取代。所以要深入理解响应式编程，拥抱响应式编程，现有的代码以及未来的开发都可以用响应式编程来做优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么异步到底解决了什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面举的例子只是简单说明了现有的异步非阻塞框架的性能优势。但是这个问题我也无法给出准确的解释，只是谈谈我自己的理解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;非阻塞很好理解，如果是阻塞的，那个当前的用户线程一定被hang住，直到数据写完或者读完（这个过程中这个线程就是没用的，所以我们需要开启大量的线程），如果非阻塞可以立即返回，继续处理其他任务。&lt;/li&gt;
&lt;li&gt;异步的理解我用一个例子来说名：Netty中发起一个写操作时立即返回了一个Future，用户可以提供一个监听器执行写操作完成后的逻辑。试想如果这里是同步非阻塞的，即调用Future的sync方法（不要在EventLoop中调用，导致死锁），那就会白白浪费一个线程，&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;程序运行过程中始终是围绕着两个主题：IO、CPU。CPU和IO的速度差距十分大，异步和Reactor模型都是为了平衡这个差距，让CPU能充分利用起来，不要因为IO和其他同步操作导致线程Hang住，始终处于可运行的状态，可以使用少量的线程充分利用CPU。&lt;/p&gt;
&lt;h2 id=&quot;四理解这些能在实际中的应用&quot;&gt;四、理解这些能在实际中的应用&lt;/h2&gt;
&lt;p&gt;很多人可能会疑问就算了把这些弄的明明白白到底有什么用？其实如果你很好的掌握了Reactor的编程模型，很多问题就能想明白了下面谈下自己理解的有用的地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果用过Redis都了解他是单线程来处理用户的请求的，他实际就是采用了Reactor模型来处理请求，也就很好的理解了为什么Redis单线程能保持很好的性能。知道了他的实现，在使用的过程中就知道尽量避免大对象的传输，因为是单线程处理，如果一个连接传输大对象那么别的连接的请求将不能被及时处理。还有Redis需要处理过期的键，它内部有定时任务去清理过期键，那么既然Redis是单线程的这个任务由谁去执行呢？还是那个处理请求的EventLoop线程，EventLoop线程其实不光处理IO请求，还会处理一些任务和定时任务用来避免锁（具体可以参考Netty的网络模型）&lt;/li&gt;
&lt;li&gt;明白NodeJs的高性能，我觉得也是一个应用，在技术选型的过程中不用人云亦云。Java也有拿得出手的框架：Netty&lt;/li&gt;
&lt;li&gt;采用响应式框架编写代码。，在开发响应式代码中心中也能保持警惕自己所写的代码会不会导致EventLoop的阻塞（阻塞EventLoop是相当严重的问题）。如果阻塞最好是能通过异步的api实现业务逻辑，如果避免不了阻塞或者耗时操作，则需要把任务投递到另外的线程池中去处理，任何情况下都不要去阻塞EventLoop，像VertX框架中如操作Mysql，PostgreSql这种都已经有了异步的实现。响应式编程一种趋势，从现在开始拥抱它吧！&lt;/li&gt;
&lt;li&gt;在学习Dubbo的时候他默认的Rpc协议&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html&quot;&gt;Dubbo协议&lt;/a&gt;底层就是Netty，消费者和提供者之间是单一长连接，所以官网也指出他更适合小数据量大并发，因为单个连接的带宽上限在7MByte左右。如果要传输文件，可以采用Http，这样的带宽上限就是物理网卡的上限，Http可以开启多个连接。&lt;/li&gt;
&lt;li&gt;上面四条说了Reactor结合异步的，其实Jdk8中的CompletableFuture是一个非常优秀的异步实现，我们在需要异步化逻辑时（比如调用第三方接口）可以充分利用这个类，我曾经也写过一点关于这个类：&lt;a href=&quot;https://www.cnblogs.com/chenfangzhi/p/9932845.html#%E5%9B%9B%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93&quot;&gt;异步编程降低延迟&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后还想说一句，Netty这个框架实在是太强大了，线程模型设计十分优秀，VertX把很多异步操作委托给了底层的Netty，因为Netty实现中的EventLoop具有天然的线程隔离（一个EventLoop对应一个线程，只会被这个线程调用），很多地方免去了同步，VertX同样继承了这个优点，有机会一定好好看看Netty的设计和源码。&lt;/p&gt;
&lt;h2 id=&quot;六困惑&quot;&gt;六、困惑&lt;/h2&gt;
&lt;p&gt;阻塞和同步的四种组合，对于异步阻塞还是无法理解，这种模式真的存在吗？&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/entry/57fa6a4e67f3560058752542&quot;&gt;回调地狱的今生前世&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/19732473/answer/20851256&quot;&gt;怎样理解阻塞非阻塞与同步异步的区别？ - 严肃的回答 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/19732473/answer/26091478&quot;&gt;怎样理解阻塞非阻塞与同步异步的区别？ - 陈硕的回答 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://Netty.io/&quot;&gt;Netty官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/historyasamirror/article/details/5778378&quot;&gt;IO - 同步，异步，阻塞，非阻塞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014926921&quot;&gt;nodejs真的是单线程吗?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/35280583/answer/487808916&quot;&gt;作为一个服务器，node.js 是性能最高的吗？ - 圆胖肿的回答 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.techempower.com/benchmarks/&quot;&gt;web框架性能排名&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Java8实战第11章&lt;/li&gt;
&lt;li&gt;Java并发编程实战&lt;/li&gt;
&lt;li&gt;Netty权威指南第二版&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 05 Mar 2019 13:31:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>[TOC] 前言 这篇文章主要是总结自己对于网络编程中异步，同步，阻塞和非阻塞的理解，这个问题自从学习NIO以来一直困扰着我，，其实想来很久就想写了，只不过当时理解不够，无从下手。最近在学习VertX</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/10479874.html</dc:identifier>
</item>
<item>
<title>java爬虫爬取https协议的网站时，SSL报错， java.lang.IllegalArgumentException TSLv1.2 报错 - 五香麻辣大白兔</title>
<link>http://www.cnblogs.com/sixgodbiao/p/10479784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sixgodbiao/p/10479784.html</guid>
<description>&lt;p&gt;&lt;span&gt;目前在广州一家小公司实习，这里的学习环境还是挺好的，今天公司从业十几年的大佬让我检查一下几年前的爬虫程序是否还能使用……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我从myeclipse上check out了大佬的程序，放到workspace中开始试探……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个错误出现了：握手失败，https三次握手机制是我遇到的第一个问题……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大佬似乎发现了我的问题，于是过来指导，“你先这样，再这样，就可以了”……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;惊慌的我赶快点头，“嗯嗯……”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是按照大佬的指点，首先在对应的jdk目录下添加文件……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1511231/201903/1511231-20190305210528398-2111229595.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1511231/201903/1511231-20190305210430823-414227491.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 对应文件我放在百度上了，链接是：链接: &lt;a href=&quot;https://pan.baidu.com/s/1GpKaF8zlF0ONJf3y_L7igg&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1GpKaF8zlF0ONJf3y_L7igg&lt;/a&gt; 提取码: nscm &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大佬给我说的是：上面三个压缩包，选择对应的版本，把里面的两个文件：local_policy.jar，US_export_policy.jar覆盖掉，目录就是第一行的目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在选项：windows-preferences-java-Installed JREs中，点击你的jdk版本，点右边的edit键，在Default VM Arguments中，把调试模式打开，并添加支持的协议类型（建议大家按我这样写）……当然，具体情况需要具体分析，看报什么错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1511231/201903/1511231-20190305210826823-1630432285.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我严格的按照大佬的要求来，发现没用，还是报错，不知道是不是我刚开始把所有的协议都写上去的原因……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是还是要搞定这个问题啊，于是，我开始疯狂百度，终于让我找到了解决办法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那就是，下载&lt;/span&gt; bcprov-ext-jdk15on-1.52   bcprov-jdk15on-1.52 &lt;span&gt;这两个jar包，给大家贡献一个下载jar包的网站：&lt;a href=&quot;https://mvnrepository.com/&quot; target=&quot;_blank&quot;&gt;https://mvnrepository.com/&lt;/a&gt; 基本上我找jar包都是在这里了……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载好之后，我们把jar包放到 $JAVA_HOME/jre/lib/ext 目录下面，然后编辑 $JAVA_HOME/jre/lib/security/目录下的  java.security  文件……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到security.provider.9，然后在这句话下面加上：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;security.provider.10=org.bouncycastle.jce.provider.BouncyCastleProvider&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后，就重启一下myeclipse，毕竟重启能解决很多问题……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你严格按照我的步骤做到这里，问题基本上应该能解决了，如果还没有解决的话，那就换jdk版本试试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要更换项目jdk版本的话吗，请参照我的另一篇随笔…… &lt;span&gt;&lt;em&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/sixgodbiao/p/10479887.html&quot;&gt;https://www.cnblogs.com/sixgodbiao/p/10479887.html&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 13:20:00 +0000</pubDate>
<dc:creator>五香麻辣大白兔</dc:creator>
<og:description>目前在广州一家小公司实习，这里的学习环境还是挺好的，今天公司从业十几年的大佬让我检查一下几年前的爬虫程序是否还能使用…… 我从myeclipse上check out了大佬的程序，放到workspace</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sixgodbiao/p/10479784.html</dc:identifier>
</item>
</channel>
</rss>