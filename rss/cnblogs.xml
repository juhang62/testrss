<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[java初探06]__排序算法的简单认识 - 小舍先生</title>
<link>http://www.cnblogs.com/gemuxiaoshe/p/10663956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gemuxiaoshe/p/10663956.html</guid>
<description>&lt;p&gt;&lt;em&gt;今天,准备填完昨天没填的坑,将排序算法方面的知识系统的学习一下,但是在简单的了解了一下后,有些不知如何组织学习了,因为排序算法的种类,实在是太多了,各有优略,各有适用的场景.有些不知所措,从何开始.&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最后按照常规思路,我将逐次从排序算法的了解,常用的几种排序算法的原理及实现,几种算法的对比以及适用场景.三个方面展开对排序算法的学习.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;排序算法的基本了解&lt;/strong&gt;&lt;br/&gt;在我们学习一样知识,技术之前,首先我们应当对它有一个基本的了解,然后在了解的基础上逐渐深入学习.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在计算机科学与数学中，排序算法（Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法例如搜索算法与合并算法中是重要的.基本上，排序算法的输出必须遵守下列两个原则：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;输出结果为递增序列（递增是针对所需的排序顺序而言）&lt;/li&gt;
&lt;li&gt;输出结果是原输入的一种排列、或是重组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而在计算机科学种关于排序算法的分类,也十分有趣,是直接按照排序算法的性能分类的,而排序算法的性能又是以&lt;strong&gt;时间复杂度&lt;/strong&gt;,&lt;strong&gt;空间复杂度&lt;/strong&gt;来判断的,而在排序算法中,主要被考虑到的当然就是时间复杂度了,毕竟一组数据的排序快慢是可以很直观的影响到其性能的.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度与空间复杂度&lt;br/&gt;时间复杂度,就是一个定性描述算法执行时间的函数.空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;由于时间复杂度的定义比较难以使人理解,我将另写一篇文章,全面总结和学习一下时间复杂度和空间复杂度的相关知识,这里就不大篇幅的来进行说明了.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;几种常用的排序算法的探讨&quot;&gt;几种常用的排序算法的探讨&lt;/h3&gt;
&lt;p&gt;排序算法是真的有很多,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-f8ccb3215bc1d12b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-6-01.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过选择,在这里选取其中最常使用到的6种排序算法进行探讨,关于一些较特殊的,高级的算法在之后需要使用到的时候再去学习.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最基本的冒泡,选择,插入排序&lt;/li&gt;
&lt;li&gt;进阶级别的希尔,归并,快速排序&lt;br/&gt;***&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&quot;算法的实现原理&quot;&gt;算法的实现原理&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;br/&gt;冒泡排序,作为最简单的最基础的排序方法,被广为人知,其是在排序算法问题之初就自然而然使人想到并运用到的排序算法,可以称之为排序算法的基础.&lt;br/&gt;其算法思路是通过循环不断对比相邻的两个数据,使小的向前,大的向后,两者交换,较小的数像气泡一样不断上浮,最终完成排序,因此形象的称之为冒泡排序.&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8067684-1df19b8c4a8ce91e.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;冒泡排序&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; /**
     * 冒泡排序
     * 通过两个for循环来排序数组
     * 外层循环控制需要循环的轮次
     * 内层循环控制相邻元素的对比及交换.
     */
    public void BubbleSort(int[] arr){
        long startime = System.nanoTime(); // 记录程序开始运行的时间点
        for (int i=1;i&amp;lt;arr.length;i++){ // 外层for循环
            for (int j=0;j&amp;lt;arr.length-i;j++){ //内层for循环,arr.length-i表示每进行完一轮就将循环对比的的次数减小一次,因为最后面的顺序都是每次循环中最大的,顺序已经排好,不需要再进行对比了.
                if (arr[j]&amp;gt;arr[j+1]){  //判断交换的条件,如果当前元素比后一个元素大就交换两者位置 
                    int a=arr[j+1];  // 两个数的交换代码
                    arr[j+1]=arr[j];
                    arr[j]=a;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
        long endtime = System.nanoTime(); // 记录程序结束的时间点
        System.out.println(&quot;运行时间:&quot;+(endtime-startime)+&quot;ns&quot;); // 输出程序运行的时间(开始结束的时间差)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;选择排序&lt;br/&gt;选择排序算法思想是在末未排序的序列中找到最小的一个元素,然后和当前的首位元素交换位置,之后在循环在未排序的序列中找到最小的元素,将其插入到已排序的末尾位置.&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8067684-a9b95c7a5b6a1942.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;选择排序&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; /**
     * 选择排序
     * 选择排序也是通过两个for循环来实现的
     * 外层for循环控制循环轮次,总共n-1轮
     * 此外我们还需要声明一个局部变量记录每次循环对比的最小元素的下标.
     * 内存for循环,通过依次对比比较,将当前未排序的序列中最小元素的下标记录下来.
     *最后通过if判断找到的下标与最开始的下标i是否相同,不相同就交换两者对应的元素
     */
    public void Selectsort(int[] arr){
        System.out.println(&quot;选择排序:&quot;);
        long startime = System.nanoTime();
        for(int i=0;i&amp;lt;arr.length-1;i++){ // 控制循环的轮次,总共需要n-1次.
            int min =i; // 声明成员变量,用来储存最小元素的下标.
            for(int j=i+1;j&amp;lt;arr.length;j++){ // 内层for循环,j=i+1是为了将序列分开为i表示的已排列,和i+1及之后的未排列两部分,
                if(arr[j]&amp;lt;arr[min]){  // 判断条件,在未排列(即i+1之后的序列.)序列里找到最小元素
                    min =j; // 将最小元素的下标保存到成员变量min中
                }
            }
            if(min !=i){  // 判断条件,判断最小元素是否和当前首位元素相同,
                // 交换位置.
                int a=arr[i];  
                arr[i]=arr[min];
                arr[min]=a;
            }
        }
        System.out.println(Arrays.toString(arr)); // Arrays类的toAString方法,遍历输出数组
        long endtime=System.nanoTime();
        System.out.println(&quot;运行时间:&quot;+(endtime-startime)+&quot;ns&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;插入排序&lt;br/&gt;插入排序的算法思路也是将序列分为已排序和未排序两部分,然后从未排序的首位开始,依次和已排序的每个元素对比,大于或等于就插在该元素后一位,小于就插入到该元素前一位.插入排序是最容易理解的排序方法,其就像我们打扑克是的插牌一样.&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8067684-30399c0701a1b5f8.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;插入排序&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  /**
     * 插入排序
     *插入排序也是通过嵌套循环实现排序的.
     * y原始案例通过for,while循环嵌套实现,
     */
    public void Insertsort(int[] arr){
        long startime=System.nanoTime();
        System.out.println(&quot;插入排序:&quot;);
        int[] copyarr=Arrays.copyOf(arr,23); // 复制数组,以防改变了数组arr.
        for (int i=1;i&amp;lt;copyarr.length;i++){ //外层循环控制轮次.
            int tmp=copyarr[i]; //将当前未排序的序列首位元素抽出.
            int j=i-1; // 定义局部变量 j代表i前面的已排序序列的末位
           while(j&amp;gt;=0 &amp;amp;&amp;amp; copyarr[j]&amp;gt;tmp){ // while循环控制,从已排序末位逐渐往前对比,如果比tmp大.
               copyarr[j+1]=copyarr[j]; //就交换两者值,
               j--; // j自减一,实现循环比较交换,排序
           }
            copyarr[j+1]=tmp; // 其他条件下,说明tmp就是当前的最小值,直接将tmp赋值给copyarr[j+1].
        }
        System.out.println(Arrays.toString(copyarr));
        long endtime=System.nanoTime();
        System.out.println(&quot;运行时间:&quot;+(endtime-startime)+&quot;ns&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;冒泡排序,选择排序,插入排序,都是最早,最简单演变下的排序算法,其时间复杂度相同,是最慢的排序算法,其在循环上进行了太多的重复性,无意义的循环操作.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;希尔排序&lt;br/&gt;希尔排序也是一种递增减量算法,是插入排序的更高效的版本.希尔排序主要根据插入排序的两点改进的:
&lt;ul&gt;&lt;li&gt;当插入排序在处理趋近于正序的的序列时,效率最高,可以趋近于线性排序的效率.&lt;/li&gt;
&lt;li&gt;插入排序每次只对一个数据进行操作移动,无疑使其效率低化.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;希尔排序的基本思路:先将待排序列分为若干个子序列,再分别使用插入排列.在基本有序之后,再全部序列进行插入排列.也就是分组插入排列加插入排列.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8067684-efe0b0138af44107.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;希尔排列&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 希尔排列
     * 希尔排列是插入排列的进阶版
     * 相当于将无序序列分成为多个子级无序序列,再分别进行插入排列.
     */
    public void Shellsort(int[] arr) {
        long startime = System.nanoTime();
        System.out.println(&quot;希尔排序:&quot;);
        int[] copyarr = Arrays.copyOf(arr, 23);
        for (int gap = copyarr.length / 2; gap &amp;gt; 0; gap /= 2) { // for循环控制分组情况,每次循环将序列拆分为两组直到不能拆分为止.
            for (int j = gap; j &amp;lt; copyarr.length; j++) { //然后通过for循环控制每组无序序列直接进行插入排序
                int temp = copyarr[j];
                int k;
                for (k = j - gap; k &amp;gt;= 0 &amp;amp;&amp;amp; copyarr[k] &amp;gt; temp; k -= gap) {
                    copyarr[k + gap] = copyarr[k];
                }
                copyarr[k + gap] = temp;
            }
        }
        System.out.println(Arrays.toString(copyarr));
        long endtime = System.nanoTime();
        System.out.println(&quot;运行时间:&quot; + (endtime - startime) + &quot;ns&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;归并排序&lt;br/&gt;归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一个十分高效的排序方法,并且其在任何情况下,时间复杂度都是相同的,但高效的同时,必然会牺牲一定的内存空间,由于归并排序需要一块额外的内存储存数组,所以可以说占用额外的内存空间是它唯一的缺点,这一点也注定了,它将不适合大型,大规模数据的排序.&lt;br/&gt;其实现思路是,通过递归,或迭代的方式,将序列分成两个有序的序列,然后比较合并两个有序序列.合并两个有序序列是十分高效的.可以取景于O(n).&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8067684-18bed0b197f975a4.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;归并排序&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;归并排序的原理图解:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-a2d18a648ec93b88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-7-01.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分,即通过递归不断分组,治,将排序好的分组合并.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * 归并排序
     * 这里通过两个方法的调用实现.
     * mergesort方法,主要将数组copy并分为左右两个序列.
     * 通过调用本身实现不断的分化.
     */
    public int[] Mergesort(int[] arr){
        int[] copyarr = Arrays.copyOf(arr, arr.length);
        if (copyarr.length&amp;lt;2){
            return copyarr;
        }
        int middle =(int)Math.floor(copyarr.length / 2); // 将序列的长度一分为二.
        int[] left = Arrays.copyOfRange(copyarr, 0, middle); 
        int[] right = Arrays.copyOfRange(copyarr, middle, copyarr.length);
        // 返回值调用合并方法,将排序后的分组不断合并.最后返回一个完整的排序后的序列.
        return merge(Mergesort(left),Mergesort(right));

    }

    protected int[] merge(int[] left, int[] right) { //传参,将左右两个无序序列传进来.
        int[] result = new int[left.length + right.length]; //定义一个新的空数组,长度为左右序列的长度之和,

        int i = 0;  // 声明一个成员变量i.

        while (left.length &amp;gt; 0 &amp;amp;&amp;amp; right.length &amp;gt; 0) { // while 循环控制条件
            if (left[0] &amp;lt;= right[0]) {  // if判断语句,判断左右序列对应位置元素的大小.
                result[i++] = left[0]; // 然后将小的元素存放在合并数组的对应位置中.
                left = Arrays.copyOfRange(left, 1, left.length);
            } else {
                result[i++] = right[0];
                right = Arrays.copyOfRange(right, 1, right.length);
            }
        }
        while(left.length&amp;gt;0){ // 不满足以上while条件跳出循环时,执行,
            result[i++] = left[0];
            left = Arrays.copyOfRange(left,1,left.length);
        }
        while(right.length&amp;gt;0){
            result[i++] = right[0];
            right = Arrays.copyOfRange(right,1,right.length);
        }
        return result; // 返回排序合并后的序列.
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;快速排序&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;快速排序也是在分治思想上的又一经典的应用,在大部分情况下,快速排序总是最高效的,比归并排序还要高效的多,且其适用于大多所情况下,在无序的随机数排序上表现也要好的多,但同时它的缺点也很明显,它的时间按复杂并不固定,存在最坏情况,时间复杂度波动非常大,且其实现思路也是基于递归思想的,其空间复杂度会很高,占用额外的内存.&lt;/p&gt;
&lt;p&gt;本质上,快速排序是在冒泡排序的基础上演变而来的分而治之的思想,其思路是:从序列中挑选一个基准值,将大于该数的数放在该基准的右边,小的放在左边,然后使用递归,依次将两边的序列排序.&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8067684-495d11fd76ed4e9d.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;快速排序&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
     * 快速排序
     *快速排序是分而治之的经典应用之一
     * 通过递归调用的方式实现排序,
     * 在大多情况下,其效率是最高的.
     */
    public int[] sort(int[] arr){ // sort 方法 用来出copy数组,并调用排序方法.
        int[] copyarr=Arrays.copyOf(arr,arr.length);
        return quicksort(copyarr,0,copyarr.length-1);
    }
    // 快速排序方法.
    private int[] quicksort(int[] arr,int left,int right){ //传入参数,待排序的数组,左下标,及数组长度减1.
        if(left&amp;lt;right){  // if判断条件,这里没有else是因为left必然是小于right的.如果等于的话,直接返回数组就可以了.
            int partitionindex = partition(arr,left,right); // 声明局部变量,调用分区方法,递归调用.
            quicksort(arr,left,partitionindex-1); // 
            quicksort(arr,partitionindex+1,right); // 递归调用本身,
        }
        return arr;
    }
    /**
     *     分区方法,将无序序列以基准为界分别放在左右两边,
     *     真正的比较交换操作,是在这个分区方法里实现的.
     *     然后在通过前面的递归调用,来循环使用分区方法,实现排序.
     */
    private int partition(int[] arr,int left,int right){
        int pivot =left;
        int index = pivot+1;
        for (int i=index;i&amp;lt;=right;i++){
            if (arr[i]&amp;lt;arr[pivot]){
                swap(arr,i,index);
                index++;
            }
        }
        swap(arr,pivot,index-1);
        return index-1;
    }
    // 封装通用方法,将数组arr中的arr[i]与arr[j]的值交换
    private void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package day_4_6;
import java.util.Arrays;
/**
 * @outhor xiaoshe
 * @date 2019/4/6  - @time 11:20
 * 排序算法
 */
public class Sty_Sortalgrithm {
    public static void main(String[] args) {
        int[] arr = {5, 2, 4, 1, 3, 7, 9, 5, 6, 8, 0, 9, 10, 13, 11, 15, 12, 17, 14, 13, 18, 19, 20};
        Sty_Sortalgrithm sortalgrithm = new Sty_Sortalgrithm();
        sortalgrithm.BubbleSort(arr);
        sortalgrithm.Selectsort(arr);
        sortalgrithm.Insertsort(arr);
        sortalgrithm.Shellsort(arr);
        System.out.println(&quot;归并排序:&quot;);
        System.out.println(Arrays.toString(sortalgrithm.Mergesort(arr)));
        System.out.println(&quot;快速排序:&quot;);
        System.out.println(Arrays.toString(sortalgrithm.sort(arr)));
    }
    /**
     * 冒泡排序
     * 通过两个for循环来排序数组
     * 外层循环控制需要循环的轮次
     * 内层循环控制相邻元素的对比及交换.
     */
    public void BubbleSort(int[] arr) {
        long startime = System.nanoTime(); // 记录程序开始运行的时间点
        int[] copyarr = Arrays.copyOf(arr, 23);
        System.out.println(&quot;冒泡排序:&quot;);
        for (int i = 1; i &amp;lt; copyarr.length; i++) { // 外层for循环
            for (int j = 0; j &amp;lt; copyarr.length - i; j++) { //内层for循环,arr.length-i表示每进行完一轮就将循环对比的的次数减小一次,因为最后面的顺序都是每次循环中最大的,顺序已经排好,不需要再进行对比了.
                if (copyarr[j] &amp;gt; copyarr[j + 1]) {  //判断交换的条件,如果当前元素比后一个元素大就交换两者位置
                    int a = copyarr[j + 1];  // 两个数的交换代码
                    copyarr[j + 1] = copyarr[j];
                    copyarr[j] = a;
                }
            }
        }
        System.out.println(Arrays.toString(copyarr)); // Arrays类中的toString方法遍历输出数组.
        long endtime = System.nanoTime(); // 记录程序结束的时间点
        System.out.println(&quot;运行时间:&quot; + (endtime - startime) + &quot;ns&quot;); // 输出程序运行的时间(开始结束的时间差)
    }
    /**
     * 选择排序
     * 选择排序也是通过两个for循环来实现的
     * 外层for循环控制循环轮次,总共n-1轮
     * 此外我们还需要声明一个局部变量记录每次循环对比的最小元素的下标.
     * 内存for循环,通过依次对比比较,将当前未排序的序列中最小元素的下标记录下来.
     * 最后通过if判断找到的下标与最开始的下标i是否相同,不相同就交换两者对应的元素
     */
    public void Selectsort(int[] arr) {
        long startime = System.nanoTime();
        int[] copyarr = Arrays.copyOf(arr, 23);
        System.out.println(&quot;选择排序:&quot;);
        for (int i = 0; i &amp;lt; copyarr.length - 1; i++) { // 控制循环的轮次,总共需要n-1次.
            int min = i; // 声明成员变量,用来储存最小元素的下标.
            for (int j = i + 1; j &amp;lt; copyarr.length; j++) { // 内层for循环,j=i+1是为了将序列分开为i表示的已排列,和i+1及之后的未排列两部分,
                if (copyarr[j] &amp;lt; copyarr[min]) {  // 判断条件,在未排列(即i+1之后的序列.)序列里找到最小元素
                    min = j; // 将最小元素的下标保存到成员变量min中
                }
            }
            if (min != i) {  // 判断条件,判断最小元素是否和当前首位元素相同,
                // 交换位置.
                int a = copyarr[i];
                copyarr[i] = copyarr[min];
                copyarr[min] = a;
            }
        }
        System.out.println(Arrays.toString(copyarr)); // Arrays类的toAString方法,遍历输出数组
        long endtime = System.nanoTime();
        System.out.println(&quot;运行时间:&quot; + (endtime - startime) + &quot;ns&quot;);
    }
    /**
     * 插入排序
     * 插入排序也是通过嵌套循环实现排序的.
     * y原始案例通过for,while循环嵌套实现,
     */
    public void Insertsort(int[] arr) {
        long startime = System.nanoTime();
        System.out.println(&quot;插入排序:&quot;);
        int[] copyarr = Arrays.copyOf(arr, 23); // 复制数组,以防改变了数组arr.
        for (int i = 1; i &amp;lt; copyarr.length; i++) { //外层循环控制轮次.
            int temp = arr[i]; // 声明temp,将此时未排序的首位元素抽出.
            int j;
            for (j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; copyarr[j] &amp;gt; temp; j--) { // 内存for循环和判断条件合并.
                //当无序序列首位元素(temp)小于有序序列末尾元素(copyarr[j])时
                //就将j的值赋给j+1,这里的j+1=i;之所以使用j+1是为了能够在条件不满足时在内层for循环中循环进行判断.
                copyarr[j + 1] = copyarr[j];
            }
            copyarr[j + 1] = temp;  //在外层循环其他条件下,直接将temp赋值给j+1
        }
        System.out.println(Arrays.toString(copyarr));
        long endtime = System.nanoTime();
        System.out.println(&quot;运行时间:&quot; + (endtime - startime) + &quot;ns&quot;);
    }
    /**
     * 希尔排序
     * 希尔排列是插入排列的进阶版
     * 相当于将无序序列分成为多个子级无序序列,再分别进行插入排列.
     */
    public void Shellsort(int[] arr) {
        long startime = System.nanoTime();
        System.out.println(&quot;希尔排序:&quot;);
        int[] copyarr = Arrays.copyOf(arr, 23);
        for (int gap = copyarr.length / 2; gap &amp;gt; 0; gap /= 2) { // for循环控制分组情况,每次循环将序列拆分为两组直到不能拆分为止.
            for (int j = gap; j &amp;lt; copyarr.length; j++) { //然后通过for循环控制每组无序序列直接进行插入排序
                int temp = copyarr[j];
                int k;
                for (k = j - gap; k &amp;gt;= 0 &amp;amp;&amp;amp; copyarr[k] &amp;gt; temp; k -= gap) {
                    copyarr[k + gap] = copyarr[k];
                }
                copyarr[k + gap] = temp;
            }
        }
        System.out.println(Arrays.toString(copyarr));
        long endtime = System.nanoTime();
        System.out.println(&quot;运行时间:&quot; + (endtime - startime) + &quot;ns&quot;);
    }
    /**
     * 归并排序
     * 这里通过两个方法的调用实现.
     * mergesort方法,主要将数组copy并分为左右两个序列.
     * 通过调用本身实现不断的分化.
     */
    public int[] Mergesort(int[] arr){
        int[] copyarr = Arrays.copyOf(arr, arr.length);
        if (copyarr.length&amp;lt;2){
            return copyarr;
        }
        int middle =(int)Math.floor(copyarr.length / 2); // 将序列的长度一分为二.
        int[] left = Arrays.copyOfRange(copyarr, 0, middle);
        int[] right = Arrays.copyOfRange(copyarr, middle, copyarr.length);
        // 返回值调用合并方法,将排序后的分组不断合并.最后返回一个完整的排序后的序列.
        return merge(Mergesort(left),Mergesort(right));

    }
    protected int[] merge(int[] left, int[] right) { //传参,将左右两个无序序列传进来.
        int[] result = new int[left.length + right.length]; //定义一个新的空数组,长度为左右序列的长度之和,
        int i = 0;  // 声明一个成员变量i.
        while (left.length &amp;gt; 0 &amp;amp;&amp;amp; right.length &amp;gt; 0) { // while 循环控制条件
            if (left[0] &amp;lt;= right[0]) {  // if判断语句,判断左右序列对应位置元素的大小.
                result[i++] = left[0]; // 然后将小的元素存放在合并数组的对应位置中.
                left = Arrays.copyOfRange(left, 1, left.length);
            } else {
                result[i++] = right[0];
                right = Arrays.copyOfRange(right, 1, right.length);
            }
        }
        while(left.length&amp;gt;0){ // 不满足以上while条件跳出循环时,执行,
            result[i++] = left[0];
            left = Arrays.copyOfRange(left,1,left.length);
        }
        while(right.length&amp;gt;0){
            result[i++] = right[0];
            right = Arrays.copyOfRange(right,1,right.length);
        }
        return result; // 返回排序合并后的序列.
    }
    /**
     * 快速排序
     *快速排序是分而治之的经典应用之一
     * 通过递归调用的方式实现排序,
     * 在大多情况下,其效率是最高的.
     */
    public int[] sort(int[] arr){ // sort 方法 用来出copy数组,并调用排序方法.
        int[] copyarr=Arrays.copyOf(arr,arr.length);
        return quicksort(copyarr,0,copyarr.length-1);
    }
    // 快速排序方法.
    private int[] quicksort(int[] arr,int left,int right){ //传入参数,待排序的数组,左下标,及数组长度减1.
        if(left&amp;lt;right){  // if判断条件,这里没有else是因为left必然是小于right的.如果等于的话,直接返回数组就可以了.
            int partitionindex = partition(arr,left,right); // 声明局部变量,调用分区方法,递归调用.
            quicksort(arr,left,partitionindex-1); //
            quicksort(arr,partitionindex+1,right); // 递归调用本身,
        }
        return arr;
    }
    /**
     *     分区方法,将无序序列以基准为界分别放在左右两边,
     *     真正的比较交换操作,是在这个分区方法里实现的.
     *     然后在通过前面的递归调用,来循环使用分区方法,实现排序.
     */
    private int partition(int[] arr,int left,int right){
        int pivot =left;
        int index = pivot+1;
        for (int i=index;i&amp;lt;=right;i++){
            if (arr[i]&amp;lt;arr[pivot]){
                swap(arr,i,index);
                index++;
            }
        }
        swap(arr,pivot,index-1);
        return index-1;
    }
    // 封装通用方法,将数组arr中的arr[i]与arr[j]的值交换
    private void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;算法的比较与使用&quot;&gt;算法的比较与使用&lt;/h4&gt;
关于个排序算法的复杂度,稳定性,等信息的对比,可以参照下面这张图:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-22a7e96231e8ef1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-7-02.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据前面的学些了解的特性,最基本的三种排序,冒泡,选择,插入排序,在小规模数据的排序上,表现会好些,在序列趋近于正序时,冒泡和插入更高效,.&lt;/p&gt;
&lt;p&gt;归并排序是最稳定的排序算法,其在不同情况下的时间复杂度不会有多大变化,而在对大量无序随机数排序时,快排的效率时最高的,但,归并排序和快速排序对内存有一定要求,不适合需要控制内存使用的情况.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;更新时间:&lt;br/&gt;2019-4-7&lt;br/&gt;3:14&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 19:23:00 +0000</pubDate>
<dc:creator>小舍先生</dc:creator>
<og:description>今天,准备填完昨天没填的坑,将排序算法方面的知识系统的学习一下,但是在简单的了解了一下后,有些不知如何组织学习了,因为排序算法的种类,实在是太多了,各有优略,各有适用的场景.有些不知所措,从何开始.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gemuxiaoshe/p/10663956.html</dc:identifier>
</item>
<item>
<title>HTTP 缓存相关 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/http_cache_stuff.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/http_cache_stuff.html</guid>
<description>&lt;p&gt;网络中数据传输是很耗时的，数据要在漫长的路径中奔波，客户端在数据完整到达前只能等待。如果能够复用已经请求过的资源，势必会让整个页面加载高效许多。这可以通过合理地设置服务器的缓存，与浏览器的缓存机制配合以达到最优。&lt;/p&gt;
&lt;p&gt;缓存设置得当不但可减少用户等待时间，提升体验，还节省服务器开销省流量带宽。&lt;/p&gt;
&lt;p&gt;缓存的配置有两种策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;稳定的内容 + 长期缓存&lt;/li&gt;
&lt;li&gt;经常变动的内容 + 使用前询问&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;稳定的内容 + 长期缓存&lt;/h2&gt;
&lt;p&gt;在知道文件内容不太可能变化的情况下，可对该资源进行长期缓存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cache-Control: max-age=31536000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种模式下浏览器获取资源流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页面：请求资源 &lt;code&gt;a.v1.js&lt;/code&gt;,&lt;code&gt;b.v1.css&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;缓存：本地没有，向服务器获取。&lt;/li&gt;
&lt;li&gt;服务器：找到资源并返回，同时告知浏览器缓存该资源，比如，缓存一年。&lt;/li&gt;
&lt;li&gt;页面：一段时间后再次请求 &lt;code&gt;a.v2.js&lt;/code&gt;,&lt;code&gt;b.v1.css&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;缓存：发现本地有对 &lt;code&gt;b.v1.css&lt;/code&gt; 的缓存，直接使用，对于 &lt;code&gt;a.v2.js&lt;/code&gt; 则询问服务器。&lt;/li&gt;
&lt;li&gt;服务器：找到资源并返回 &lt;code&gt;a.v2.js&lt;/code&gt;，同时告知浏览器缓存该资源。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看到，这种模式下，我们更新的是文件名，即资源的 URI 地址，而不是直接更新文件内容。因为文件被缓存后，如果文件名没变，浏览器是不会重新去获取的。&lt;/p&gt;
&lt;h2&gt;经常变动的内容 + 使用前询问&lt;/h2&gt;
&lt;p&gt;对于经常变动的资源，但地址又不能变，比如静态博客页面，则不能像上面那样缓存。这种情况下可设置缓存为 &lt;code&gt;no-cache&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cache-Control: no-cache
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，缓存 Header 的值不能按照字面意思来解释，需要去理解它，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;no-cache&lt;/code&gt; 并不是表示不要缓存，而是缓存该资源，但使用前先询问服务器该资源是否有更新，而 &lt;code&gt;no-store&lt;/code&gt; 才表示完全不缓存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;must-revalidate&lt;/code&gt; 不是必需重新验证资源有效性的意思，而是暗含了一个前提，就是资源如果还没有超过设置的缓存时限 &lt;code&gt;max-age&lt;/code&gt; 才重新验证。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此模式下，服务器可通过下发 &lt;code&gt;ETag&lt;/code&gt; 或 &lt;code&gt;Last-Modified&lt;/code&gt; 响应头，浏览器下次再请求时会查检查已缓存的资源，并带上相应的 &lt;code&gt;If-None-Match&lt;/code&gt; 或 &lt;code&gt;If-Modified-Since&lt;/code&gt; 请求头，然后服务器再决定是否返回新的资源或告知浏览器直接使用本地缓存。&lt;/p&gt;
&lt;p&gt;使用 ETag 的场景示例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器请求资源。&lt;/li&gt;
&lt;li&gt;服务器返回资源，并且带上 ETag （可以是 hash 或者其他能够跟随资源内容而变的 id）。&lt;/li&gt;
&lt;li&gt;过段时间，浏览器再次请求该资源，通过设置 &lt;code&gt;If-None-Match&lt;/code&gt; 请求头带上前面得到的 ETag。&lt;/li&gt;
&lt;li&gt;服务器将 ETag 与资源内容进行比较，发现资源没有更新过，返回 304 （not modified）告诉浏览器资源没有变化，可使用本地已经缓存的版本。&lt;/li&gt;
&lt;li&gt;浏览器得到 304 响应，直接使用本地缓存。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个过程没有对资源进行重复下载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ETag&lt;/code&gt;/&lt;code&gt;Last-Modified&lt;/code&gt; 不可用的情况下，服务器始终下发完整资源。&lt;/p&gt;
&lt;p&gt;相比方式一，这种方式始终会和服务器进行一次沟通。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;max-age&lt;/code&gt; 的注意事项&lt;/h2&gt;
&lt;p&gt;对易变的内容设置 &lt;code&gt;max-age&lt;/code&gt; 方式的缓存容易引起各资源不一致的问题。&lt;/p&gt;
&lt;p&gt; 比如设置缓存为如下格式时，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cache-Control: must-revalidate, max-age=600
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于缓存时间小于 10 分钟的资源，浏览器不会重新请求而是直接使用缓存。&lt;/p&gt;
&lt;p&gt;假设一个场景，页面 A 包含一个公共脚本 &lt;code&gt;common.js&lt;/code&gt; 和页面 A 的业务脚本 &lt;code&gt;a.js&lt;/code&gt;。当页面 A 首页加载时，所有资源都正确缓存。&lt;/p&gt;
&lt;p&gt;过了一段时间，切换到页面 B，页面 B 也包含公共脚本 &lt;code&gt;common.js&lt;/code&gt;，同时有自己的业务脚本 &lt;code&gt;b.js&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在请求页面 B 之前，因为已经缓存过 &lt;code&gt;common.js&lt;/code&gt;，所以会使用缓存，但这期间文件有可能已经更新。此时浏览器使用旧的 &lt;code&gt;common.js&lt;/code&gt; 运行页面 B 势必会出问题。&lt;/p&gt;
&lt;p&gt;所以，对于经常变动的内容设置 &lt;code&gt;max-age&lt;/code&gt; 是不推荐的做法。&lt;/p&gt;
&lt;p&gt;多数情况下针对上面的问题，一次强刷就解决了，这也是有 bug 时研发会给出的高频回复。&lt;/p&gt;
&lt;h2&gt;参考内容&lt;/h2&gt;
</description>
<pubDate>Sat, 06 Apr 2019 17:06:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>网络中数据传输是很耗时的，数据要在漫长的路径中奔波，客户端在数据完整到达前只能等待。如果能够复用已经请求过的资源，势必会让整个页面加载高效许多。这可以通过合理地设置服务器的缓存，与浏览器的缓存机制配合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/http_cache_stuff.html</dc:identifier>
</item>
<item>
<title>如何使用redis设计关系数据库 - 艾露米婭娜</title>
<link>http://www.cnblogs.com/ailumiyana/p/10663833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ailumiyana/p/10663833.html</guid>
<description>&lt;h2 id=&quot;redis设计关系数据库&quot;&gt;redis设计关系数据库&lt;/h2&gt;
&lt;hr/&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近需要一张用户信息表，因为数据量并不大，想先放在内存中，等需求变更了，再移到磁盘上，或者往mysql塞，那么问题来了，怎么用redis的数据类型设计一个关系数据库呢。&lt;/p&gt;
&lt;p&gt;redis只有key-value这种存储结构，如果想利用它做成想其他数据库一样具备 &lt;code&gt;增删改查&lt;/code&gt;等功能只能再设计了，这里分享一下我的设计方法，比较简单，我不知道算不算好，只是网上找了很久没找到一种通用的方法，如果有什么好的方法，还想请教一下各位，十分感谢。&lt;/p&gt;
&lt;h2 id=&quot;设计用户信息表结构&quot;&gt;设计用户信息表结构&lt;/h2&gt;
&lt;h3 id=&quot;hash存储记录&quot;&gt;hash存储记录&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;key值&lt;/code&gt; : &lt;code&gt;域名:表名:主键&lt;/code&gt;&lt;br/&gt;&lt;code&gt;value值&lt;/code&gt; :直接使用redis的Hash类型&lt;br/&gt;如:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;test:accounts_info:0 id 0 accounts ailumiyana_0 password 123456 nick_name sola_0
test:accounts_info:1 id 1 accounts ailumiyana_1 password 123456 nick_name sola_1
test:accounts_info:2 id 2 accounts ailumiyana_2 password 123456 nick_name sola_2
test:accounts_info:3 id 3 accounts ailumiyana_3 password 123456 nick_name sola_3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407004457882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3MzA4MzIx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;set存储id&quot;&gt;set存储id&lt;/h3&gt;
&lt;p&gt;另添加一个set集存放表主键, 也即id.&lt;br/&gt;&lt;code&gt;key值&lt;/code&gt; : &lt;code&gt;ids:域名:表名&lt;/code&gt;&lt;br/&gt;&lt;code&gt;value值&lt;/code&gt;: id&lt;br/&gt;将已生成的用户id同时添加进set集合中.&lt;br/&gt;我这里用了list演示，不设计类型的特殊方法的话，演示效果是一样的。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407004519702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3MzA4MzIx,size_16,color_FFFFFF,t_70&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;图示&quot;&gt;图示&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019040700443256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3MzA4MzIx,size_16,color_FFFFFF,t_70&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;索引查询&quot;&gt;索引/查询:&lt;/h2&gt;
&lt;h3 id=&quot;select-查询所有记录-类似sql的select-from-table_name&quot;&gt;1、select&lt;em&gt;&lt;br/&gt;查询所有记录 : 类似sql的select&lt;/em&gt; from table_name&lt;/h3&gt;
&lt;p&gt;有了set表后我们就可以使用redis中sort的get方法,获取所有记录.&lt;br/&gt;&lt;code&gt;sort ids:test:accounts_info get test:accounts_info:*-&amp;gt;accounts get test:accounts_info:*-&amp;gt;nick_name&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201904070044221.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;根据主键查询记录&quot;&gt;2、根据主键查询记录&lt;/h3&gt;
&lt;p&gt;直接使用string类型建立主键到id的索引，其实id就是主键，但是我们一般不会用id去找记录，更多的使用account账号去找.&lt;br/&gt;&lt;code&gt;key值&lt;/code&gt; : &lt;code&gt;域名:表名:列键名:列键值&lt;/code&gt;&lt;br/&gt;这样我们直接用get 取得accounts的id 后再去hash中查找记录就行了.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407004405207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3MzA4MzIx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;其他列索引&quot;&gt;3、其他列索引&lt;/h3&gt;
&lt;p&gt;最后可以根据表的需要建立一些其他索引，&lt;br/&gt;方法同 2 ，使用类型不一定是set 哪个方便用哪个。&lt;br/&gt;例如 我要统计最近登录的10个用户的信息， 那么我直接用list 的 lrange limit 0 10 就能取到.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407004333518.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;c-实现&quot;&gt;c++ 实现&lt;/h2&gt;
&lt;p&gt;以上设计的c++实现，其中的redis的客户端使用了cpp_redis库。&lt;/p&gt;
&lt;p&gt;例程中 :&lt;br/&gt;1、我创建了一张 account_info的表 默认使用accounts 作为主键&lt;/p&gt;
&lt;p&gt;2、插入4个用户信息.&lt;/p&gt;
&lt;p&gt;3、查询用户ailu_1的记录值.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class table// : public redis::er_table
{
public:
    //! ctor
  table(void);
  //! dtor
  ~table(void) = default;

  //! copy ctor
  table(const table&amp;amp;) = delete;
  //! assignment operator
  table&amp;amp; operator=(const table&amp;amp;) = delete;

public:
  //! vector type to save table records.
  typedef std::vector&amp;lt;std::string&amp;gt; records_t;

  //! vector type to save table records entitys.
  typedef std::vector&amp;lt;std::string&amp;gt; entitys_t;

public:
  //! create table,
  //! default primary key is the records_t vec[0], if primary_key is empty!
  void create(const std::string&amp;amp; table_name, const records_t&amp;amp; vec, const std::string&amp;amp; primary_key = &quot;&quot;);

public:
  //! incr primary key id.
  std::string incr_id();

  //! insert new entity to table, pelease orderly insert refer to records vector !
  //! return false while entity exits.
  bool insert(const entitys_t&amp;amp; vec);

  //! get entitys by primary key value.
  entitys_t get_entitys_by_primary_key_value(const std::string&amp;amp; primary_key_value);

private:
  //! get id by primary key value
  //! retrun &quot;&quot; while primary key inexitences.
  std::string get_id_by_primary_key_value(const std::string&amp;amp; primary_key_value);

private:
  //! redis client
  cpp_redis::client m_redis_client;

  //!
  records_t m_records;

  //! records count.
  std::size_t m_records_count;

  //! ids set key
  std::string m_ids;

  //! table name
  std::string m_table_name;

  //! incr key
  uint64_t m_incr_key;

  //! primary key
  std::string m_primary_key;
  std::size_t m_primary_key_index;
};


table::table()
  :m_records_count(0),
  m_incr_key(0)
{
  m_redis_client.connect();
  m_redis_client.select(3);
  m_redis_client.sync_commit();
}

void table::create(const std::string&amp;amp; table_name, const records_t&amp;amp; vec, const std::string&amp;amp; primary_key){
  assert(m_records_count == 0);
  m_ids = &quot;ids:&quot; + table_name;
  m_table_name = table_name;
  m_records = vec;
  m_records_count = vec.size();
  if(primary_key.empty()){
    m_primary_key = vec[0];
    m_primary_key_index = 0;
  } else {
    m_primary_key = primary_key;
    auto iter = std::find(vec.begin(), vec.end(), primary_key);
    if(iter == vec.end()){
      LOG_FATAL &amp;lt;&amp;lt; &quot;no such key.&quot;;
    }
    m_primary_key_index = iter - vec.begin();
  }

}

std::string table::incr_id(){
  return std::move(std::to_string(m_incr_key++));
}

std::string table::get_id_by_primary_key_value(const std::string&amp;amp; primary_key_value){

  std::future&amp;lt;cpp_redis::reply&amp;gt; fu = m_redis_client.get(primary_key_value);
  m_redis_client.sync_commit();

  cpp_redis::reply reply = fu.get();

  if(!reply.is_null()){
    return std::move(reply.as_string());
  }

  LOG_DEBUG &amp;lt;&amp;lt; &quot;primary_key &quot; &amp;lt;&amp;lt; primary_key_value &amp;lt;&amp;lt; &quot; inexitences. return \&quot;\&quot;.&quot;;

  return &quot;&quot;;
}

bool table::insert(const entitys_t&amp;amp; vec){
  assert(m_records_count != 0);
  assert(m_records_count == vec.size());

  std::string get_id = incr_id();

  // check whether the primary key already exists.
  std::string check_id = get_id_by_primary_key_value(vec[m_primary_key_index]);
  if(!check_id.empty()){
    return false;
  }

  // redis string type primary key to id index.
  //LOG_DEBUG &amp;lt;&amp;lt; m_table_name + &quot;:&quot; + m_records[m_primary_key_index] + &quot;:&quot; + vec[m_primary_key_index];
  m_redis_client.set(m_table_name + &quot;:&quot; + m_records[m_primary_key_index] + &quot;:&quot; + vec[m_primary_key_index], get_id);

  // redis set type to save id.
  std::vector&amp;lt;std::string&amp;gt; id_vec = {get_id};
  m_redis_client.sadd(m_ids, id_vec);

  // redis hash type to save records key-value.
  std::vector&amp;lt;std::pair&amp;lt;std::string, std::string&amp;gt;&amp;gt; entitys_pair_vec;

  for(std::size_t i = 0; i &amp;lt; m_records_count; i++){
    entitys_pair_vec.emplace_back(make_pair(m_records[i], vec[i]));
  }

  m_redis_client.hmset(m_table_name + &quot;:&quot; + get_id, entitys_pair_vec);

  m_redis_client.sync_commit();

  return true;
}

table::entitys_t table::get_entitys_by_primary_key_value(const std::string&amp;amp; primary_key_value){
  std::string id = get_id_by_primary_key_value(m_table_name + &quot;:&quot; + m_records[m_primary_key_index] + &quot;:&quot; + primary_key_value);

  if(id == &quot;&quot;){
    static entitys_t static_empty_entitys_vec;
    return static_empty_entitys_vec;
    LOG_ERROR &amp;lt;&amp;lt; &quot;no this entitys&quot;;
  }

  entitys_t vec;

  std::future&amp;lt;cpp_redis::reply&amp;gt; reply = m_redis_client.hgetall(m_table_name + &quot;:&quot; + id);
  m_redis_client.sync_commit();

  std::vector&amp;lt;cpp_redis::reply&amp;gt; v = reply.get().as_array();
  auto iter = v.begin();
  for(iter++; iter &amp;lt; v.end(); iter += 2){
    //LOG_DEBUG &amp;lt;&amp;lt; (*iter).as_string();
    vec.emplace_back((*iter).as_string());
  }

  return std::move(vec);
}

int main()
{
  table accounts_info;
  table::records_t records_vec = {&quot;id&quot;, &quot;accounts&quot;, &quot;password&quot;, &quot;nick_name&quot;};
  accounts_info.create(&quot;sip:accounts_info&quot;, records_vec, &quot;accounts&quot;);

  table::entitys_t entitys_vec0 = {&quot;0&quot;, &quot;ailu_0&quot;, &quot;123&quot;, &quot;sola_0&quot;};
  accounts_info.insert(entitys_vec0);

  table::entitys_t entitys_vec1 = {&quot;1&quot;, &quot;ailu_1&quot;, &quot;123&quot;, &quot;sola_1&quot;};
  accounts_info.insert(entitys_vec1);

  table::entitys_t entitys_vec2 = {&quot;2&quot;, &quot;ailu_2&quot;, &quot;123&quot;, &quot;sola_2&quot;};
  accounts_info.insert(entitys_vec2);

  table::entitys_t entitys_vec3 = {&quot;3&quot;, &quot;ailu_3&quot;, &quot;123&quot;, &quot;sola_3&quot;};
  accounts_info.insert(entitys_vec3);


  table::entitys_t ailu_1_accounts = accounts_info.get_entitys_by_primary_key_value(&quot;ailu_1&quot;);

  auto it = ailu_1_accounts.begin();
  while(it != ailu_1_accounts.end()){
    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
    it++;
  }

  getchar();
  return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407004312676.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407004301666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3MzA4MzIx,size_16,color_FFFFFF,t_70&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;目前给出了redis增查简单设计方法，更新和删除也是通过redis的基本方法对应设计即可，这里不再详述。&lt;br/&gt;此外，可以看出redis的数据库设计还是比较灵活的，如何设计出最适合我们场景需求且高效的正是它难点所在。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 16:49:00 +0000</pubDate>
<dc:creator>艾露米婭娜</dc:creator>
<og:description>redis设计关系数据库 [toc] 前言 最近需要一张用户信息表，因为数据量并不大，想先放在内存中，等需求变更了，再移到磁盘上，或者往mysql塞，那么问题来了，怎么用redis的数据类型设计一个关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ailumiyana/p/10663833.html</dc:identifier>
</item>
<item>
<title>linux 搭建squid代理服务器 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10646347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10646347.html</guid>
<description>&lt;p&gt;&lt;span&gt;linux 搭建squid代理服务器&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;实验环境: &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一台linux搭建Web服务器，充当内网web服务器(同时充当内网客户端) 202.100.10.100&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一台linux系统充当网关服务器,两个网卡，开启路由转发 192.168.133.131和202.100.10.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一台linux搭建Web服务器，充当外网web服务器(同时充当外网客户端)) 192.168.133.131&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实验步骤:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.配置内网web服务器、网关服务器、外网Web服务器的IP地址，开启网关的路由转发，关闭网关的防火墙，测试内网web服务器与外网Web服务器的联通性,保证能互通。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.安装内网Web服务器和外网Web服务器的web服务，启动服务，新建一个测试页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.测试内网客户端访问外网web服务器，外网客户端访问内网web服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.内网客户端访问外网web服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190402235800926-2013741755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5&lt;/span&gt;.&lt;span&gt;外网客户端访问内网web服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190402235839785-170828258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;防火墙SNAT和DNAT&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;内网客户端访问外网web服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000035261-690832476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在外网web服务器上查看日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tail -f /var/log/httpd/access_log&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000107707-1051473740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.在网关设置地址转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iptables -t nat -A POSTROUTING -s 192.168.133.0/24 -o eth2 -j  SNAT --to-source 202.100.10.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者iptables -t nat -A POSTROUTING -s 192.168.133.0/24 -o eth2 -j MASQUERADE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000131883-686891686.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.再次在内网客户端访问外网web服务器，然后查看外网的web服务器可以看到,日志文件记录的IP的不是内网客户端的IP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000200630-1658976557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DNAT：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.在网关上设置，把内网web服务器映射到网关外网的接口上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iptables -t nat -A PREROUTING -i eth2 -d 202.100.10.1 -p tcp --dport 80 -j DNAT --to-destination 192.168.133.131&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.访问网关外网的接口IP(实际上就是访问内网web服务器)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000222508-1947982160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.查看内网web服务器的日志文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000243860-805547760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;squid代理服务器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.在配置网关服务器配置squid代理服务器，安装squid, yum install -y squid&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1传统代理服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动squid服务  service squid start&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为squid.conf配置文件，默认允许所有私网IP通过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2在内网客户端设置浏览器，加入代理，测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000313766-295149910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000329086-206878601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在外网服务器查看日志文件，可以看到IP是代理服务器的IP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000345833-671927135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.3关闭网关服务器的代理服务器，再次测试，下图说明客户端访问外网web服务器经过代理服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000430154-2011976385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.透明代理服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1在网关服务器上配置,设置透明代理并开启高速缓存, vim /etc/squid/squid.conf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http_port 192.168.133.130：3128 transparent     #192.168.133.130为内网接口IP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cache_dir ufs /var/spool/squid 100 16 256&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iptables -t nat -A PREROUTING -i eth1 -s 192.168.133.0/24 -p tcp --dport 80 -j REDIRECT --to-ports 3128     #-i接口是内网接口   -s 跟的是内网网段   -j 跟的是REDIRECT(重定向)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000507356-2127121186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2重启squid服务,然后在内网客户端测试，取消之前测试中浏览器设置的代理，透明代理不需要设置在客户端设置任何东西&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000530627-1097215840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3在外网web服务器上查看日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190403000552089-1262164627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 06 Apr 2019 16:46:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>linux 搭建squid代理服务器 实验环境: 一台linux搭建Web服务器，充当内网web服务器(同时充当内网客户端) 202.100.10.100 一台linux系统充当网关服务器,两个网卡，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10646347.html</dc:identifier>
</item>
<item>
<title>javascript的ES6学习总结(第一部分) - 消逝的风i</title>
<link>http://www.cnblogs.com/abc-x/p/10663786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abc-x/p/10663786.html</guid>
<description>&lt;h2&gt;ES6（ESNext学习总结——第一部分）&lt;/h2&gt;
&lt;p&gt;ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。&lt;/p&gt;
&lt;p&gt;ECMA每年6月份，发布一个版本&lt;/p&gt;
&lt;p&gt;2016年6月       ES6.1       ES7       ES2016&lt;br/&gt;2017年6月       ES6.2       ES8       ES2017&lt;br/&gt;2018年6月       ES...         ES9       ES2018&lt;/p&gt;
&lt;h3&gt;1.let、const用法&lt;/h3&gt;
&lt;p&gt;let 相当于之前的var，let定义的是块级作用域&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;//块级作用域&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 12&lt;span&gt;;
}
console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
        let a &lt;/span&gt;= 12&lt;span&gt;;
    }
console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a is not defined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在花括号中用let定义的变量，作用域只在花括号内生效，只能在当前花括号使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;let注意：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)没有预解析，不存在变量提升&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
        alert(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TDZ 暂时性死区&lt;/span&gt;
        let a = 12&lt;span&gt;;
}
console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a is not defined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)同一个作用域里，不能重复定义变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
let a &lt;/span&gt;= 10&lt;span&gt;;
let a &lt;/span&gt;= 20&lt;span&gt;;
console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Identifier 'a' has already been declared&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)for循环中，for循环圆括号里的是父级作用域，花括号中的是子级作用域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(let i=0;i&amp;lt;3;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父级作用域&lt;/span&gt;
        let i = 'aaa';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子级作用域&lt;/span&gt;
&lt;span&gt;        console.log(i);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;const 常量，定义好了不能改变&lt;/p&gt;
&lt;p&gt;1.const的特性和let一样&lt;/p&gt;
&lt;p&gt;const定义的常量必须有值，不能后赋值，也不能修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;var定义的变量是全局的，属于window，let、const不同&lt;/p&gt;
&lt;h3&gt;2.解构赋值&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1方括号解构赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在es6之前，如果我们想要给数组每一项的值赋给每个变量，是这样获取的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr = [4,5,6&lt;span&gt;],a = arr[0],&lt;/span&gt;b = arr[1],c = arr[2]&lt;span&gt;;&lt;br/&gt;console.log(a,b,c&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,5,6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在es6之后，我们可以写成这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let [a,b,c] = [4,5,6&lt;span&gt;];
console.log(a,b,c); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,5,6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;左右俩边，结构格式要保持一致，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let [a,[b,c]] = [4,[5,6&lt;span&gt;]];
console.log(a,b,c); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,5,6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.2方括号解构赋值默认值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
let [a,b,c='暂无'] = ['aa','bb'&lt;span&gt;];
console.log(a,b,c);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aa bb 暂无&lt;/span&gt;
let [a,b,c='暂无'] = ['aa','bb'&lt;span&gt;,undefined];
console.log(a,b,c);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aa bb 暂无&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.3花括号解构赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在es6之前，如果我们想要给json数据每一项的值赋给每个变量，是这样获取的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; jsonData =&lt;span&gt; {
        name:&lt;/span&gt;'tom'&lt;span&gt;,
        age:&lt;/span&gt;29&lt;span&gt;,
        job:&lt;/span&gt;'web'&lt;span&gt;
},&lt;br/&gt;name&lt;/span&gt;=jsonData.name,&lt;br/&gt;age=jsonData.age,&lt;br/&gt;job=&lt;span&gt;jsonData.job;
console.log(name,age,job);//tom 29 web&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在es6之后，我们可以写成这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let jsonData =&lt;span&gt; {
        name:&lt;/span&gt;'tom'&lt;span&gt;,
        age:&lt;/span&gt;29&lt;span&gt;,
        job:&lt;/span&gt;'web'&lt;span&gt;
};
let {name,age,job} &lt;/span&gt;=&lt;span&gt; jsonData;
console.log(name,age,job);//tom 29 web&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.4花括号解构赋值起别名(注：只有花括号结构赋值才可以其别名)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let jsonData =&lt;span&gt; {
        name:&lt;/span&gt;'tom'&lt;span&gt;,
        age:&lt;/span&gt;29&lt;span&gt;,
        job:&lt;/span&gt;'web'&lt;span&gt;
    };
let {name:n,age:a,job:j} &lt;/span&gt;=&lt;span&gt; jsonData;
console.log(n,a,j);//tom 29 web&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.5花括号解构赋值其他方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;let a;
{a} &lt;/span&gt;= {a:'apple',b:'banana'&lt;span&gt;};
console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Uncaught SyntaxError: Unexpected token =&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写会报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;let a;
({a} &lt;/span&gt;= {a:'apple',b:'banana'&lt;span&gt;});
console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以换成这样写，一般不推荐这么做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.6利用解构赋值交换位置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let a=12,b=25&lt;span&gt;;
[a,b] &lt;/span&gt;=&lt;span&gt; [b,a];
console.log(a,b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;25,12&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let a=12,b=25&lt;span&gt;;
let [c,d] &lt;/span&gt;=&lt;span&gt; [b,a];
console.log(c,d);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;25,12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.7函数中的解构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数参数解构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show({a,b}){
        console.log(a,b);
}
show({
        a:&lt;/span&gt;1&lt;span&gt;,
        b:&lt;/span&gt;2&lt;span&gt;
});&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数参数给默认值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; show({a,b='默认'&lt;span&gt;}){
        console.log(a,b);
    }
show({
        a:&lt;/span&gt;1&lt;span&gt;,
        b:undefined
});&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,&quot;默认&quot;&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt; show({a,b='默认'&lt;span&gt;}){
        console.log(a,b);
    }
show({
        a:&lt;/span&gt;1&lt;span&gt;
});&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,&quot;默认&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数调用时参数都为空&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; show({a='默认1',b='默认2'&lt;span&gt;}){
        console.log(a,b);
}
show({});&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;默认1,&quot;默认2&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; show({a='默认1',b='默认2'&lt;span&gt;}){
        console.log(a,b);
    }
show();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会报错：Uncaught TypeError: Cannot destructure property `a` of 'undefined' or 'null'.&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;解决方法：&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; show({a='默认1',b='默认2'}=&lt;span&gt;{}){
        console.log(a,b);
}
show();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;默认1,&quot;默认2&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.字符串模板(``)以及字符串新增&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;3.1&lt;/strong&gt; &lt;strong&gt;es6新增了``字符串模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;es6以前字符串拼接都是用以下的形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; name = 'tom'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = '这个人的名字叫'+name+'，年龄是'+age+'岁';//这个人的名字叫tom,年龄是30岁
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在es6以后就可以使用以下方式字符串模板来拼接字符串了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let name = 'tom'&lt;span&gt;;
let age &lt;/span&gt;= 30&lt;span&gt;;
let str &lt;/span&gt;= `这个人的名字叫${name},年龄是${age}岁`;//这个人的名字叫tom,年龄是30岁
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;``&lt;/strong&gt;运算符在键盘的这个位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398770/201904/1398770-20190406183951213-2113933664.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 es6后新增字符串查找（准确来说是es2016，或者es7）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;es6以前字符串查找都是用str.indexOf(‘要查找的内容') 返回索引(第一次出现的位置)，没找到返回-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fruits = 'apple banana pear'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = fruits.indexOf('banana');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6，从下标0开始的第6位&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在es6以后就可以使用str.includes('要查找的内容') 返回布尔值 true/false&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let fruits = 'apple banana pear'&lt;span&gt;;
let str &lt;/span&gt;= fruits.includes('banana');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.3 es6后新增字符串其他方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串以谁开头：&lt;/p&gt;
&lt;p&gt;str.startsWith('检测的东西') 返回布尔值true/false&lt;/p&gt;
&lt;p&gt;字符串以谁结尾：&lt;/p&gt;
&lt;p&gt;str.endsWith('检测的东西') 返回布尔值true/false&lt;/p&gt;
&lt;p&gt;重复字符串：&lt;/p&gt;
&lt;p&gt;str.repeat(重复的次数)&lt;/p&gt;
&lt;p&gt;填充字符串：&lt;/p&gt;
&lt;p&gt;str.padStart(填充后字符串的长度，要填充的东西)  在开头填充&lt;/p&gt;
&lt;p&gt;str.padEnd(填充后字符串的长度，要填充的东西)  在末尾填充&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let str = 'abc'&lt;span&gt;;
let padStr &lt;/span&gt;= 'tom'&lt;span&gt;;
let str1 &lt;/span&gt;= str.padStart(str.length+padStr.length,padStr);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tomabc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;4.函数默认参数、箭头函数、剩余参数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1函数默认参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在es6的函数默认参数没出来之前，我们写函数的默认参数是这样写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; goto(a,b){
        a &lt;/span&gt;= a || 'aaa'&lt;span&gt;;
        b &lt;/span&gt;= b || 'bbb'&lt;span&gt;;
        console.log(a,b);
}
goto(&lt;/span&gt;'a',);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa,bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在es6函数默认参数出来后，我们可以这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; goto(a='aaa',b='bbb'&lt;span&gt;){
        console.log(a,b);
}
goto(&lt;/span&gt;'aaa',);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa,bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;函数参数默认已经定义了，所以不能再用let，const来声明&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; goto(a='aaa',b='bbb'&lt;span&gt;){
        let a &lt;/span&gt;= 12&lt;span&gt;;
        let b &lt;/span&gt;= 23&lt;span&gt;;
        console.log(a,b);
}
goto(&lt;/span&gt;'aaa',);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Identifier 'a' has already been declared&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.2Spread Operator 拓展运算符(展开运算符)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组装对象或者数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组&lt;/span&gt;
    const color = ['red', 'yellow'&lt;span&gt;]
    const colorful &lt;/span&gt;= [...color, 'green', 'pink'&lt;span&gt;]
    console.log(colorful) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[red, yellow, green, pink]&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;
    const alp = { fist: 'a', second: 'b'&lt;span&gt;}
    const alphabets &lt;/span&gt;= { ...alp, third: 'c'&lt;span&gt; }
    console.log(alphabets) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{ &quot;fist&quot;: &quot;a&quot;, &quot;second&quot;: &quot;b&quot;, &quot;third&quot;: &quot;c&quot;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
const number = [1,2,3,4,5&lt;span&gt;]
    const [first, ...rest] &lt;/span&gt;=&lt;span&gt; number
    console.log(rest) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2,3,4,5&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;
    const user =&lt;span&gt; {
        username: &lt;/span&gt;'lux'&lt;span&gt;,
        gender: &lt;/span&gt;'female'&lt;span&gt;,
        age: &lt;/span&gt;19&lt;span&gt;,
        address: &lt;/span&gt;'peking'&lt;span&gt;
    }
    const { username, ...rest } &lt;/span&gt;=&lt;span&gt; user
    console.log(rest) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{&quot;address&quot;: &quot;peking&quot;, &quot;age&quot;: 19, &quot;gender&quot;: &quot;female&quot;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 新增) 当然如果有重复的属性名，右边覆盖左边&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const first =&lt;span&gt; {
        a: &lt;/span&gt;1&lt;span&gt;,
        b: &lt;/span&gt;2&lt;span&gt;,
        c: &lt;/span&gt;6&lt;span&gt;,
}
const second &lt;/span&gt;=&lt;span&gt; {
        c: &lt;/span&gt;3&lt;span&gt;,
        d: &lt;/span&gt;4&lt;span&gt;
}
const total &lt;/span&gt;=&lt;span&gt; { ...first, ...second }
console.log(total) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; { a: 1, b: 2, c: 3, d: 4 }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;相当于其他语言的array.merge()功能 只不过这里是对象的merge&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.3Array.from()将一个类数组对象或者可遍历对象转换成一个真正的数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象。&lt;/p&gt;
&lt;p&gt;1、将类数组对象转换为真正数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
let arrayLike =&lt;span&gt; {
    &lt;/span&gt;0: 'tom'&lt;span&gt;, 
    &lt;/span&gt;1: '65'&lt;span&gt;,
    &lt;/span&gt;2: '男'&lt;span&gt;,
    &lt;/span&gt;3: ['jane','john','Mary'&lt;span&gt;],
    &lt;/span&gt;'length': 4&lt;span&gt;
}
let arr &lt;/span&gt;=&lt;span&gt; Array.from(arrayLike)
console.log(arr) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ['tom','65','男',['jane','john','Mary']]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么，如果将上面代码中length属性去掉呢？实践证明，答案会是一个长度为0的空数组。&lt;/p&gt;
&lt;p&gt;这里将代码再改一下，就是具有length属性，但是对象的属性名不再是数字类型的，而是其他字符串型的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
let arrayLike =&lt;span&gt; {
    &lt;/span&gt;'name': 'tom'&lt;span&gt;, 
    &lt;/span&gt;'age': '65'&lt;span&gt;,
    &lt;/span&gt;'sex': '男'&lt;span&gt;,
    &lt;/span&gt;'friends': ['jane','john','Mary'&lt;span&gt;],
    length: &lt;/span&gt;4&lt;span&gt;
}
let arr &lt;/span&gt;=&lt;span&gt; Array.from(arrayLike)
console.log(arr)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ undefined, undefined, undefined, undefined ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会发现结果是长度为4，元素均为undefined的数组&lt;/p&gt;
&lt;p&gt;由此可见，要将一个类数组对象转换为一个真正的数组，必须具备以下条件：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、该类数组对象的属性名必须为数值型或字符串型的数字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps: 该类数组对象的属性名可以加引号，也可以不加引号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、将Set结构的数据转换为真正的数组：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
let arr = [12,45,97,9797,564,134,45642&lt;span&gt;]
let set &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set(arr)
console.log(Array.from(set))  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ 12, 45, 97, 9797, 564, 134, 45642 ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Array.from&lt;/code&gt;还可以接受第二个参数，作用类似于数组的&lt;code&gt;map&lt;/code&gt;方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
let arr = [12,45,97,9797,564,134,45642&lt;span&gt;]
let set &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set(arr)
console.log(Array.from(set, item &lt;/span&gt;=&amp;gt; item + 1)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ 13, 46, 98, 9798, 565, 135, 45643 ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.Array.from()还可以将字符串转为数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
let json = 'hello'&lt;span&gt;;
let arr &lt;/span&gt;=&lt;span&gt; Array.from(json);
arr[&lt;/span&gt;0] = 'm'&lt;span&gt;;
console.log(arr,json);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;m&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] &quot;hello&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在以前我们映射一个数组，可以用如下方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let json = ['a','b','c'&lt;span&gt;];
let arr &lt;/span&gt;= json;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用赋值&lt;/span&gt;
arr[0] = 'sss'&lt;span&gt;;
console.log(arr,json);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;sss&quot;, &quot;b&quot;, &quot;c&quot;] (3) [&quot;sss&quot;, &quot;b&quot;, &quot;c&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样会改变原数组，如果我们不想改变原数组，可以使用以下方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let json = ['a','b','c'&lt;span&gt;];
let arr &lt;/span&gt;= [...json];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拓展运算符&lt;/span&gt;
arr[0] = 'sss'&lt;span&gt;;
console.log(arr,json);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;sss&quot;, &quot;b&quot;, &quot;c&quot;] (3) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let json = ['a','b','c'&lt;span&gt;];
let arr &lt;/span&gt;=&lt;span&gt; Array.from(json);
arr[&lt;/span&gt;0] = 'sss'&lt;span&gt;;
console.log(arr,json);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;sss&quot;, &quot;b&quot;, &quot;c&quot;] (3) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.4箭头函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在es6以前我们定义一个函数都是这样定义的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
}
console.log(show());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在es6之后，引入了箭头函数的概念，我们可以这样定义函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let show = ()=&amp;gt;1&lt;span&gt;;
console.log(show());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let show = (a,b)=&amp;gt;a+&lt;span&gt;b;
console.log(show(&lt;/span&gt;1,2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;以上代码相当于&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(a,b){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;
}
console.log(show(&lt;/span&gt;1,2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let show = a=&amp;gt;a*&lt;span&gt;a;
console.log(show(&lt;/span&gt;3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;以上代码相当于&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(a){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a*&lt;span&gt;a;
}
console.log(show(&lt;/span&gt;3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let show = (a=12,b=5)=&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;
};
console.log(show());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;以上代码相当于&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; show(a=12,b=5&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;
}
console.log(show());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.this问题，定义函数所在的对象，不再是运行时所在的对象&lt;/p&gt;
&lt;p&gt;2.arguments，在箭头函数中没有arguments&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(){
        console.log(...arguments);
}
show(&lt;/span&gt;1,23,4,56);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 23 4 56&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;箭头函数中没有arguments，但可以用拓展运算符代替&lt;/span&gt;
let show = (...arg)=&amp;gt;&lt;span&gt;{
console.log(...arg);
}
show(&lt;/span&gt;1,23,4,56);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 23 4 56&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.箭头函数不能当构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = 'abc'&lt;span&gt;;
}
let s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; show();
console.log(s.name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;以下代码将报错，因为箭头函数不能当构造函数用&lt;/span&gt;
let show = ()=&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = 'abc'&lt;span&gt;;
}
let s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; show();
console.log(s.name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;show is not a constructor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.ES2017中，函数参数最后的逗号可以有&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(a,b,c,d,){
        console.log(a,b,c,d);
}
show(&lt;/span&gt;1,2,3,4,);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 2 3 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第一部分就先告一段落了，后面还有二个部分，会在后面一段时间抽时间总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;end...&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 16:21:00 +0000</pubDate>
<dc:creator>消逝的风i</dc:creator>
<og:description>ES6（ESNext学习总结——第一部分） ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。 ECMA每年6月份，发布一个版本 201</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abc-x/p/10663786.html</dc:identifier>
</item>
<item>
<title>spring boot 2.0.0 + mybatis 报：Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required - dba_xyx</title>
<link>http://www.cnblogs.com/dbaxyx/p/10663485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dbaxyx/p/10663485.html</guid>
<description>&lt;p&gt;spring boot 2.0.0 + mybatis 报：Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required 无法启动&lt;/p&gt;
&lt;p&gt;google baidu了一番，多数都提示缺少：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实最重要的应该是缺少如下数据库连接池的包，我这里用的druid，这里要添加druid for spring boot依赖，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;druid-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.9&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加上后项目启动正常。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 15:52:00 +0000</pubDate>
<dc:creator>dba_xyx</dc:creator>
<og:description>spring boot 2.0.0 + mybatis 报：Property 'sqlSessionFactory' or 'sqlSessionTemplate' a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dbaxyx/p/10663485.html</dc:identifier>
</item>
<item>
<title>深度学习在推荐系统的应用(二) - 混沌战神阿瑞斯</title>
<link>http://www.cnblogs.com/arachis/p/DL4REC2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arachis/p/DL4REC2.html</guid>
<description>&lt;h3 id=&quot;afm模型attentional-factorization-machine&quot;&gt;AFM模型(Attentional Factorization Machine)&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ ŷ_{AFM}(x)=ω_0+∑_{i=1}^{n}ω_{i}x_{i}+p^T∑^{n}_{i=1}∑^{n}_{j=i+1}a_{ij}(v_i⊙v_j)x_ix_j \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;fwfm模型field-weighted-factorization-machines&quot;&gt;FwFM模型(Field-weighted Factorization Machines)&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Φ_{FwFMs}((w,v), x) = w_{0} +∑_{i=1}^{m}x_iw_i +∑_{i=1}^{m}∑_{j=i+1}^{m}x_ix_j⟨v_i,v_j⟩r_{F (i),F (j)} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;fwfm模型field-weighted-factorization-machines-1&quot;&gt;FwFM模型(Field-weighted Factorization Machines)&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Φ_{FwFMs}((w,v), x) = w_{0} +∑_{i=1}^{m}x_iw_i +∑_{i=1}^{m}∑_{j=i+1}^{m}x_ix_j⟨v_i,v_j⟩r_{F (i),F (j)} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.4017632241814&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;模型特点&lt;br/&gt;FwFM是在WWW'18上由Oath公司提出的点击率预估模型，针对FFM参数量大的不足提出了改进并在著名的公开数据集Criteo上验证有效。从模型形式上可以看出FwFM与FM区别仅在于FwFM给每个二阶交叉项引入了一个实数weight:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ r_{F (i),F (j)} \]&lt;/span&gt;&lt;br/&gt;总计多出m*(m-1)/2个参数,m是field个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.31578947368421&quot;&gt;
&lt;p&gt;模型案例&lt;br/&gt;&lt;a href=&quot;https://github.com/Tongzhenguo/Python-Project/blob/master/ctr_model/FwFM.py&quot;&gt;Tongzhenguo/Python-Project&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;xdeepfm极深因子分解机模型&quot;&gt;xDeepFM(极深因子分解机模型)&lt;/h3&gt;
&lt;p&gt;1.CIN结构:&lt;br/&gt;&lt;img src=&quot;https://yangxudong.github.io/xdeepfm/CIN.png&quot; alt=&quot;CIN结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.矩阵&lt;span class=&quot;math display&quot;&gt;\[𝑋^𝑘\]&lt;/span&gt;中的第ℎ行的计算公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ X_{h,*}^k = \sum_{i=1}^{H_{k-1}}\sum_{j=1}^m{W_{ij}^{k,h}(X_{i,*}^{k-1} \circ X_{j,*}^0)} \]&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>混沌战神阿瑞斯</dc:creator>
<og:description>### AFM模型(Attentional Factorization Machine) ### FwFM模型(Field-weighted Factorization Machines) #</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/arachis/p/DL4REC2.html</dc:identifier>
</item>
<item>
<title>线程池优化之充分利用线程池资源 - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/10660479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/10660479.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　最近做了电子发票的需求，分省开票接口和发票下载接口都有一定的延迟。为了完成开票后自动将发票插入用户微信卡包，目前的解决方案是利用线程池，将开票后插入卡包的任务（轮询分省发票接口，直到获取到发票相关信息或者轮询次数用完，如果获取到发票信息，执行发票插入微信卡包，结束任务）放入线程池异步执行。仔细想一想，这种实现方案存在一个问题，线程池没有充分的利用。为什么没有充分的利用？下面详细的分析。&lt;/p&gt;
&lt;h2&gt;二、异步线程池和异步任务包装&lt;/h2&gt;
&lt;p&gt;　　AsyncConfigurerSupport可以帮我们指定异步任务（注有@Async注解）对应的线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyAsyncConfigurer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AsyncConfigurerSupport {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(MyAsyncConfigurer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor taskExecutor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolTaskExecutor();
        taskExecutor.setCorePoolSize(&lt;/span&gt;2&lt;span&gt;);
        taskExecutor.setMaxPoolSize(&lt;/span&gt;4&lt;span&gt;);
        taskExecutor.setQueueCapacity(&lt;/span&gt;10&lt;span&gt;);
        taskExecutor.setRejectedExecutionHandler((runnable, executor) &lt;/span&gt;-&amp;gt; LOGGER.error(&quot;异步线程池拒绝任务...&quot; +&lt;span&gt; runnable));
        taskExecutor.setThreadFactory(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyAsyncThreadFactory());
        taskExecutor.initialize();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; taskExecutor;
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyAsyncThreadFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ThreadFactory {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger poolNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ThreadGroup group;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger threadNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String namePrefix;

        MyAsyncThreadFactory() {
            SecurityManager s &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
            group &lt;/span&gt;= (s != &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; s.getThreadGroup() :
                    Thread.currentThread().getThreadGroup();
            namePrefix &lt;/span&gt;= &quot;myasync-pool-&quot; +&lt;span&gt;
                    poolNumber.getAndIncrement() &lt;/span&gt;+
                    &quot;-thread-&quot;&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
            Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(group, r,
                    namePrefix &lt;/span&gt;+&lt;span&gt; threadNumber.getAndIncrement(),
                    &lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t.isDaemon())
                t.setDaemon(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.getPriority() !=&lt;span&gt; Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　异步任务包装，除了异步，还加入了retry功能，实现指定次数的接口轮询。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncWrapped {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(AsyncWrapped.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Async
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; asyncProcess(Runnable runnable, Callback callback, Retry retry) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (retry == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                retry &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Retry(1&lt;span&gt;);
            }
            retry.execute(ctx &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                runnable.run();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }, ctx &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    callback.call();
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            });
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;异步调用异常...&quot;&lt;span&gt;, e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　业务代码大致逻辑如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
asyncWrapped.asyncProcess(() -&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用分省接口获取发票信息
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果发票信息异常，抛出异常（进入下次重试）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则，插入用户微信卡包&lt;/span&gt;
    }, () -&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;轮询次数用尽，用户插入卡包失败&lt;/span&gt;
&lt;span&gt;    }
    , &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Retry(2, 1000&lt;span&gt;)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里说一下为什么线程池没有充分的利用。异步任务中包含轮询操作，轮询有一定的时间间隔，导致在这段时间间隔内，线程一直处于被闲置的状态。所以为了能更好的利用线程池资源，我们得想办法解决时间间隔的问题。假如有个延迟队列，队列里放着我们的异步任务（不包含重试机制），然后延迟（轮询的时间间隔）一定时间之后，将任务放入线程池中执行，任务执行完毕之后根据是否需要再次执行决定是否再次放入到延迟队列去，这样每个线程池中的线程都不会闲着，达到了充分利用的目的。&lt;/p&gt;
&lt;h2&gt;三、定时任务线程池和实现轮询机制&lt;/h2&gt;
&lt;p&gt;　　@EnableScheduling 帮助开启@Scheduled注解解析。注册一个名字是ScheduledAnnotationBeanPostProcessor.DEFAULT_TASK_SCHEDULER_BEAN_NAME的定时任务线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableScheduling
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskConfiguration {

    @Bean(name &lt;/span&gt;=&lt;span&gt; ScheduledAnnotationBeanPostProcessor.DEFAULT_TASK_SCHEDULER_BEAN_NAME)
    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ScheduledExecutorService scheduledAnnotationProcessor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Executors.newScheduledThreadPool(5, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultThreadFactory());
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultThreadFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ThreadFactory {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger poolNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ThreadGroup group;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger threadNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String namePrefix;

        DefaultThreadFactory() {
            SecurityManager s &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
            group &lt;/span&gt;= (s != &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; s.getThreadGroup() :
                    Thread.currentThread().getThreadGroup();
            namePrefix &lt;/span&gt;= &quot;pool-&quot; +&lt;span&gt;
                    poolNumber.getAndIncrement() &lt;/span&gt;+
                    &quot;-schedule-&quot;&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
            Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(group, r,
                    namePrefix &lt;/span&gt;+&lt;span&gt; threadNumber.getAndIncrement(),
                    &lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t.isDaemon()) {
                t.setDaemon(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.getPriority() !=&lt;span&gt; Thread.NORM_PRIORITY) {
                t.setPriority(Thread.NORM_PRIORITY);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　实现轮询任务，实现接口SchedulingConfigurer，获取ScheduledTaskRegistrar 并指定定时任务线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureTasks(ScheduledTaskRegistrar registrar) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.registrar =&lt;span&gt; registrar;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.registrar.setScheduler(&lt;span&gt;this&lt;/span&gt;.applicationContext.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, ScheduledExecutorService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    scheduledTaskRegistrarHelper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ScheduledTaskRegistrarHelper();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　scheduledFutures提交定时任务时返回结果集，periodTasks 定时任务结果集。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentHashMap&amp;lt;String, ScheduledFuture&amp;lt;?&amp;gt;&amp;gt; scheduledFutures = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentHashMap&amp;lt;String, TimingTask&amp;gt; periodTasks = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定时任务包装类，包含任务的执行次数（重试次数）、重试间隔、具体任务、重试次数用尽之后的回调等，以及自动结束定时任务、重试计数重置功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimingTask {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试次数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer retry;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务标识&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String taskId;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试间隔&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long period;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体任务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ScheduledRunnable task;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束回调&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ScheduledCallback callback;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试计数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; AtomicInteger count = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父线程MDC&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; curContext;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimingTask(Integer retry, String taskId, Long period, ScheduledRunnable task, ScheduledCallback callback) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.retry =&lt;span&gt; retry;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskId =&lt;span&gt; taskId;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.period =&lt;span&gt; period;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.task =&lt;span&gt; task;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.callback =&lt;span&gt; callback;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.curContext =&lt;span&gt; MDC.getCopyOfContextMap();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getPeriod() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; period;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPeriod(Long period) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.period =&lt;span&gt; period;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTaskId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; taskId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTaskId(String taskId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskId =&lt;span&gt; taskId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getRetry() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retry;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRetry(Integer retry) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.retry =&lt;span&gt; retry;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicInteger getCount() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; reset() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; cnt = &lt;span&gt;this&lt;/span&gt;.count.intValue(); cnt &amp;lt; &lt;span&gt;this&lt;/span&gt;.retry; cnt = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.count.intValue()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.count.compareAndSet(cnt, 0&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process() {
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; preContext =&lt;span&gt; MDC.getCopyOfContextMap();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.curContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                MDC.clear();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将父线程的MDC内容传给子线程&lt;/span&gt;
                MDC.setContextMap(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.curContext);
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.task.run();
            exitTask(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;定时任务异常...&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, e);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count.incrementAndGet() &amp;gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.retry) {
                exitTask(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (preContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                MDC.clear();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                MDC.setContextMap(preContext);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时任务退出&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exitTask(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; execCallback) {
        scheduledFutures.get(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskId).cancel(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        scheduledFutures.remove(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getTaskId());
        periodTasks.remove(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getTaskId());
        LOGGER.info(&lt;/span&gt;&quot;结束定时任务: &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (execCallback &amp;amp;&amp;amp; callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            callback.call();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionToStringBuilder.toString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;
                , ToStringStyle.JSON_STYLE
                , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                , TimingTask.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意上面定时任务是如何退出的，是在某一次任务执行成功之后（没有异常抛出）或者定时任务执行次数用尽才退出的。直接调用ScheduledFuture的cancel方法可以退出定时任务。还有就是定时任务中的日志需要父线程中的日志变量，所以需要对MDC进行一下处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@Scope(&quot;prototype&quot;&lt;span&gt;)
@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AspectTimingTask aspectTimingTask() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AspectTimingTask();
}

@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScheduledAspect {
    @Around(&lt;/span&gt;&quot;target(AspectTimingTask)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object executeScheduledWrapped(ProceedingJoinPoint proceedingJoinPoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (proceedingJoinPoint &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MethodInvocationProceedingJoinPoint) {
            MethodInvocationProceedingJoinPoint methodJoinPoint &lt;/span&gt;=&lt;span&gt; (MethodInvocationProceedingJoinPoint) proceedingJoinPoint;
            Method method &lt;/span&gt;=&lt;span&gt; ((MethodSignature) methodJoinPoint.getSignature()).getMethod();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AnnotatedElementUtils.isAnnotated(method, ScheduledTask.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                LOGGER.info(&lt;/span&gt;&quot;电子发票定时任务日志同步...&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他处理&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proceedingJoinPoint.proceed();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AspectTimingTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TimingTask timingTask;

    @Override
    @ScheduledTask
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        timingTask.process();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTimingTask(TimingTask timingTask) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.timingTask =&lt;span&gt; timingTask;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　AspectTimingTask 是对TimingTask 的包装类，实现了Runnable接口。主要是为了对run接口做一层切面，获取ProceedingJoinPoint 实例（公司中的日志调用链系统需要这个参数）。AspectTimingTask 的bean实例的scope是prototype，这个注意下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; register(Integer retry
        , Long period
        , String taskId
        , ScheduledRunnable task
        , ScheduledCallback callback) {
    scheduledTaskRegistrarHelper.register(retry, taskId, period, task, callback);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScheduledTaskRegistrarHelper {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; register(Integer retry
            , String taskId
            , Long period
            , ScheduledRunnable task
            , ScheduledCallback callback) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否可以重置定时任务&lt;/span&gt;
        TimingTask preTask =&lt;span&gt; periodTasks.get(taskId);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; preTask
                &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; preTask.reset()
                &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; existTask(taskId)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        TimingTask curTask &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimingTask(retry, taskId, period, task, callback);
        AspectTimingTask aspectTimingTask &lt;/span&gt;= applicationContext.getBean(AspectTimingTask.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        aspectTimingTask.setTimingTask(curTask);
        ScheduledFuture&lt;/span&gt;&amp;lt;?&amp;gt; scheduledFuture =&lt;span&gt; registrar.getScheduler().scheduleAtFixedRate(aspectTimingTask, period);
        scheduledFutures.put(taskId, scheduledFuture);
        periodTasks.put(taskId, curTask);
        LOGGER.info(&lt;/span&gt;&quot;注册定时任务: &quot; +&lt;span&gt; curTask);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; existTask(String taskId) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; scheduledFutures.containsKey(taskId) &amp;amp;&amp;amp;&lt;span&gt; periodTasks.containsKey(taskId);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果taskId的定时任务已经存在则重置定时任务，否则注册新的定时任务。AspectTimingTask 实例通过ApplicationContext获取，每次获取都是一个新的实例。&lt;/p&gt;
&lt;p&gt;　　由 异步轮询任务 优化成 定时任务，充分利用了线程池。修改之后的业务代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
ScheduledTaskRegistrarHelper.register(10&lt;span&gt;
    , 5*&lt;/span&gt;1000L&lt;span&gt;
    , &lt;/span&gt;&quot;taskId&quot;&lt;span&gt;
    , () &lt;/span&gt;-&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用分省接口获取发票信息
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果发票信息异常，抛出异常（进入下次重试）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则，插入用户微信卡包&lt;/span&gt;
&lt;span&gt;    }
    () &lt;/span&gt;-&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;轮询次数用尽，用户插入卡包失败&lt;/span&gt;
&lt;span&gt;    }
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　针对电子发票插入微信卡包定时任务，重试执行次数10次，每隔5秒执行一次。任务完成之后结束定时任务，执行次数用尽之后触发插入卡包失败动作。&lt;/p&gt;
&lt;h2&gt;四、参考　　&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;     &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hujunzheng/p/10549849.html&quot;&gt;Spring异步调用原理及SpringAop拦截器链原理&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hujunzheng/p/10353390.html&quot;&gt;Springboot定时任务原理及如何动态创建定时任务&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 15:08:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>一、前言 最近做了电子发票的需求，分省开票接口和发票下载接口都有一定的延迟。为了完成开票后自动将发票插入用户微信卡包，目前的解决方案是利用线程池，将开票后插入卡包的任务（轮询分省发票接口，直到获取到发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/10660479.html</dc:identifier>
</item>
<item>
<title>SpringBoot中异步请求和异步调用（看这一篇就够了） - 会炼钢的小白龙</title>
<link>http://www.cnblogs.com/baixianlong/p/10661591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baixianlong/p/10661591.html</guid>
<description>&lt;h2 id=&quot;异步请求与同步请求&quot;&gt;1、异步请求与同步请求&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/xianlongbai/Static-Resources/blob/master/image/22906052.png?raw=true&quot; alt=&quot;同步请求&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://github.com/xianlongbai/Static-Resources/blob/master/image/71641059.png?raw=true&quot; alt=&quot;异步请求&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;特点：&lt;/h3&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;可以先释放容器分配给请求的线程与相关资源，减轻系统负担，释放了容器所分配线程的请求，其响应将被延后，可以在耗时处理完成（例如长时间的运算）时再对客户端进行响应。&lt;span&gt;一句话：增加了服务器对客户端请求的吞吐量&lt;/span&gt;（实际生产上我们用的比较少，如果并发请求量很大的情况下，我们会通过nginx把请求负载到集群服务的各个节点上来分摊请求压力，当然还可以通过消息队列来做请求的缓冲）。&lt;/p&gt;
&lt;h2 id=&quot;异步请求的实现&quot;&gt;2、异步请求的实现&lt;/h2&gt;
&lt;h3 id=&quot;方式一servlet方式实现异步请求&quot;&gt;方式一：Servlet方式实现异步请求&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  @RequestMapping(value = &quot;/email/servletReq&quot;, method = GET)
  public void servletReq (HttpServletRequest request, HttpServletResponse response) {
      AsyncContext asyncContext = request.startAsync();
      //设置监听器:可设置其开始、完成、异常、超时等事件的回调处理
      asyncContext.addListener(new AsyncListener() {
          @Override
          public void onTimeout(AsyncEvent event) throws IOException {
              System.out.println(&quot;超时了...&quot;);
              //做一些超时后的相关操作...
          }
          @Override
          public void onStartAsync(AsyncEvent event) throws IOException {
              System.out.println(&quot;线程开始&quot;);
          }
          @Override
          public void onError(AsyncEvent event) throws IOException {
              System.out.println(&quot;发生错误：&quot;+event.getThrowable());
          }
          @Override
          public void onComplete(AsyncEvent event) throws IOException {
              System.out.println(&quot;执行完成&quot;);
              //这里可以做一些清理资源的操作...
          }
      });
      //设置超时时间
      asyncContext.setTimeout(20000);
      asyncContext.start(new Runnable() {
          @Override
          public void run() {
              try {
                  Thread.sleep(10000);
                  System.out.println(&quot;内部线程：&quot; + Thread.currentThread().getName());
                  asyncContext.getResponse().setCharacterEncoding(&quot;utf-8&quot;);
                  asyncContext.getResponse().setContentType(&quot;text/html;charset=UTF-8&quot;);
                  asyncContext.getResponse().getWriter().println(&quot;这是异步的请求返回&quot;);
              } catch (Exception e) {
                  System.out.println(&quot;异常：&quot;+e);
              }
              //异步请求完成通知
              //此时整个请求才完成
              asyncContext.complete();
          }
      });
      //此时之类 request的线程连接已经释放了
      System.out.println(&quot;主线程：&quot; + Thread.currentThread().getName());
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方式二使用很简单直接返回的参数包裹一层callable即可可以继承webmvcconfigureradapter类来设置默认线程池和超时处理&quot;&gt;方式二：使用很简单，直接返回的参数包裹一层callable即可，可以继承WebMvcConfigurerAdapter类来设置默认线程池和超时处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  @RequestMapping(value = &quot;/email/callableReq&quot;, method = GET)
  @ResponseBody
  public Callable&amp;lt;String&amp;gt; callableReq () {
      System.out.println(&quot;外部线程：&quot; + Thread.currentThread().getName());

      return new Callable&amp;lt;String&amp;gt;() {

          @Override
          public String call() throws Exception {
              Thread.sleep(10000);
              System.out.println(&quot;内部线程：&quot; + Thread.currentThread().getName());
              return &quot;callable!&quot;;
          }
      };
  }

  @Configuration
  public class RequestAsyncPoolConfig extends WebMvcConfigurerAdapter {

  @Resource
  private ThreadPoolTaskExecutor myThreadPoolTaskExecutor;

  @Override
  public void configureAsyncSupport(final AsyncSupportConfigurer configurer) {
      //处理 callable超时
      configurer.setDefaultTimeout(60*1000);
      configurer.setTaskExecutor(myThreadPoolTaskExecutor);
      configurer.registerCallableInterceptors(timeoutCallableProcessingInterceptor());
  }

  @Bean
  public TimeoutCallableProcessingInterceptor timeoutCallableProcessingInterceptor() {
      return new TimeoutCallableProcessingInterceptor();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方式三和方式二差不多在callable外包一层给webasynctask设置一个超时回调即可实现超时处理&quot;&gt;方式三：和方式二差不多，在Callable外包一层，给WebAsyncTask设置一个超时回调，即可实现超时处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    @RequestMapping(value = &quot;/email/webAsyncReq&quot;, method = GET)
    @ResponseBody
    public WebAsyncTask&amp;lt;String&amp;gt; webAsyncReq () {
        System.out.println(&quot;外部线程：&quot; + Thread.currentThread().getName());
        Callable&amp;lt;String&amp;gt; result = () -&amp;gt; {
            System.out.println(&quot;内部线程开始：&quot; + Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(4);
            } catch (Exception e) {
                // TODO: handle exception
            }
            logger.info(&quot;副线程返回&quot;);
            System.out.println(&quot;内部线程返回：&quot; + Thread.currentThread().getName());
            return &quot;success&quot;;
        };
        WebAsyncTask&amp;lt;String&amp;gt; wat = new WebAsyncTask&amp;lt;String&amp;gt;(3000L, result);
        wat.onTimeout(new Callable&amp;lt;String&amp;gt;() {

            @Override
            public String call() throws Exception {
                // TODO Auto-generated method stub
                return &quot;超时&quot;;
            }
        });
        return wat;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方式四deferredresult可以处理一些相对复杂一些的业务逻辑最主要还是可以在另一个线程里面进行业务处理及返回即可在两个完全不相干的线程间的通信&quot;&gt;方式四：DeferredResult可以处理一些相对复杂一些的业务逻辑，最主要还是可以在另一个线程里面进行业务处理及返回，即可在两个完全不相干的线程间的通信。&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@RequestMapping(value = &quot;/email/deferredResultReq&quot;, method = GET)
    @ResponseBody
    public DeferredResult&amp;lt;String&amp;gt; deferredResultReq () {
        System.out.println(&quot;外部线程：&quot; + Thread.currentThread().getName());
        //设置超时时间
        DeferredResult&amp;lt;String&amp;gt; result = new DeferredResult&amp;lt;String&amp;gt;(60*1000L);
        //处理超时事件 采用委托机制
        result.onTimeout(new Runnable() {

            @Override
            public void run() {
                System.out.println(&quot;DeferredResult超时&quot;);
                result.setResult(&quot;超时了!&quot;);
            }
        });
        result.onCompletion(new Runnable() {

            @Override
            public void run() {
                //完成后
                System.out.println(&quot;调用完成&quot;);
            }
        });
        myThreadPoolTaskExecutor.execute(new Runnable() {

            @Override
            public void run() {
                //处理业务逻辑
                System.out.println(&quot;内部线程：&quot; + Thread.currentThread().getName());
                //返回结果
                result.setResult(&quot;DeferredResult!!&quot;);
            }
        });
       return result;
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;介绍&quot;&gt;1、介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;5.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;异步请求的处理。除了异步请求，一般上我们用的比较多的应该是异步调用。通常在开发过程中，会遇到一个方法是和实际业务无关的，没有紧密性的。比如记录日志信息等业务。这个时候正常就是启一个新线程去做一些业务处理，让主线程异步的执行其他业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方式基于spring下&quot;&gt;2、使用方式（基于spring下）&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;需要在启动类加入@EnableAsync使异步调用@Async注解生效&lt;/li&gt;
&lt;li&gt;在需要异步执行的方法上加入此注解即可@Async(&quot;threadPool&quot;),threadPool为自定义线程池&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;代码略。。。就俩标签，自己试一把就可以了&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;3、注意事项&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;在默认情况下，未设置TaskExecutor时，默认是使用SimpleAsyncTaskExecutor这个线程池，但此线程不是真正意义上的线程池，因为线程不重用，每次调用都会创建一个新的线程。可通过控制台日志输出可以看出，每次输出线程名都是递增的。所以最好我们来自定义一个线程池。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;调用的异步方法，不能为同一个类的方法（包括同一个类的内部类），简单来说，因为Spring在启动扫描时会为其创建一个代理类，而同类调用时，还是调用本身的代理类的，所以和平常调用是一样的。其他的注解如@Cache等也是一样的道理，说白了，就是Spring的代理机制造成的。所以在开发中，最好把异步服务单独抽出一个类来管理。下面会重点讲述。。&lt;/p&gt;
&lt;h2 id=&quot;什么情况下会导致async异步方法会失效&quot;&gt;4、什么情况下会导致@Async异步方法会失效？&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;7.5&quot;&gt;&lt;li&gt;&lt;span&gt;调用同一个类下注有@Async异步方法&lt;/span&gt;：在spring中像@Async和@Transactional、cache等注解本质使用的是动态代理，其实Spring容器在初始化的时候Spring容器会将含有AOP注解的类对象“替换”为代理对象（简单这么理解），那么注解失效的原因就很明显了，就是因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器，那么解决方法也会沿着这个思路来解决。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用的是静态(static )方法&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;调用(private)私有化方法&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决4中问题1的方式其它23两个问题自己注意下就可以了&quot;&gt;5、解决4中问题1的方式（其它2,3两个问题自己注意下就可以了）&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将要异步执行的方法单独抽取成一个类&lt;/span&gt;，原理就是当你把执行异步的方法单独抽取成一个类的时候，这个类肯定是被Spring管理的，其他Spring组件需要调用的时候肯定会注入进去，这时候实际上注入进去的就是代理类了。&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;其实我们的注入对象都是从Spring容器中给当前Spring组件进行成员变量的赋值，由于某些类使用了AOP注解，那么实际上在Spring容器中实际存在的是它的代理对象。那么我们就可以&lt;span&gt;通过上下文获取自己的代理对象调用异步方法&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Controller
@RequestMapping(&quot;/app&quot;)
public class EmailController {

    //获取ApplicationContext对象方式有多种,这种最简单,其它的大家自行了解一下
    @Autowired
    private ApplicationContext applicationContext;

    @RequestMapping(value = &quot;/email/asyncCall&quot;, method = GET)
    @ResponseBody
    public Map&amp;lt;String, Object&amp;gt; asyncCall () {
        Map&amp;lt;String, Object&amp;gt; resMap = new HashMap&amp;lt;String, Object&amp;gt;();
        try{
            //这样调用同类下的异步方法是不起作用的
            //this.testAsyncTask();
            //通过上下文获取自己的代理对象调用异步方法
            EmailController emailController = (EmailController)applicationContext.getBean(EmailController.class);
            emailController.testAsyncTask();
            resMap.put(&quot;code&quot;,200);
        }catch (Exception e) {
            resMap.put(&quot;code&quot;,400);
            logger.error(&quot;error!&quot;,e);
        }
        return resMap;
    }

    //注意一定是public,且是非static方法
    @Async
    public void testAsyncTask() throws InterruptedException {
        Thread.sleep(10000);
        System.out.println(&quot;异步任务执行完成！&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;开启cglib代理，手动获取Spring代理类&lt;/span&gt;,从而调用同类下的异步方法。
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;首先，在启动类上加上&lt;span&gt;@EnableAspectJAutoProxy(exposeProxy = true)&lt;/span&gt;注解。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;代码实现，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
@Transactional(value = &quot;transactionManager&quot;, readOnly = false, propagation = Propagation.REQUIRED, rollbackFor = Throwable.class)
public class EmailService {

    @Autowired
    private ApplicationContext applicationContext;

    @Async
    public void testSyncTask() throws InterruptedException {
        Thread.sleep(10000);
        System.out.println(&quot;异步任务执行完成！&quot;);
    }


    public void asyncCallTwo() throws InterruptedException {
        //this.testSyncTask();
//        EmailService emailService = (EmailService)applicationContext.getBean(EmailService.class);
//        emailService.testSyncTask();
        boolean isAop = AopUtils.isAopProxy(EmailController.class);//是否是代理对象；
        boolean isCglib = AopUtils.isCglibProxy(EmailController.class);  //是否是CGLIB方式的代理对象；
        boolean isJdk = AopUtils.isJdkDynamicProxy(EmailController.class);  //是否是JDK动态代理方式的代理对象；
        //以下才是重点!!!
        EmailService emailService = (EmailService)applicationContext.getBean(EmailService.class);
        EmailService proxy = (EmailService) AopContext.currentProxy();
        System.out.println(emailService == proxy ? true : false);
        proxy.testSyncTask();
        System.out.println(&quot;end!!!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;两者的使用场景不同，异步请求用来解决并发请求对服务器造成的压力，从而提高对请求的吞吐量；而异步调用是用来做一些非主线流程且不需要实时计算和响应的任务，比如同步日志到kafka中做日志分析等。&lt;/li&gt;
&lt;li&gt;异步请求是会一直等待response相应的，需要返回结果给客户端的；而异步调用我们往往会马上返回给客户端响应，完成这次整个的请求，至于异步调用的任务后台自己慢慢跑就行，客户端不会关心。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;异步请求和异步调用的使用到这里基本就差不多了，有问题还希望大家多多指出。&lt;/li&gt;
&lt;li&gt;这边文章提到了动态代理，而spring中Aop的实现原理就是动态代理，后续会对动态代理做详细解读，还望多多支持哈~&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;2.0412371134021&quot;&gt;
&lt;p&gt;个人博客地址：&lt;/p&gt;
&lt;blockquote readability=&quot;2.3023255813953&quot;&gt;
&lt;p&gt;csdn:&lt;a href=&quot;https://blog.csdn.net/tiantuo6513&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/tiantuo6513&lt;/a&gt;&lt;br/&gt;cnblogs:&lt;a href=&quot;https://www.cnblogs.com/baixianlong&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/baixianlong&lt;/a&gt;&lt;br/&gt;segmentfault:&lt;a href=&quot;https://segmentfault.com/u/baixianlong&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/u/baixianlong&lt;/a&gt;&lt;br/&gt;github:https://github.com/xianlongbai&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 06 Apr 2019 14:33:00 +0000</pubDate>
<dc:creator>会炼钢的小白龙</dc:creator>
<og:description>一、SpringBoot中异步请求的使用 1、异步请求与同步请求 特点： 可以先释放容器分配给请求的线程与相关资源，减轻系统负担，释放了容器所分配线程的请求，其响应将被延后，可以在耗时处理完成（例如长</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baixianlong/p/10661591.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——88. 防御性地编写READOBJECT方法 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/10663149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/10663149.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;书中的源代码地址：https://github.com/jbloch/effective-java-3e-source-code&lt;br/&gt;注意，书中的有些代码里方法是基于Java 9 API中的，所以JDK 最好下载 JDK 9以上的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;条目 50 里有一个不可变的日期范围类，它包含一个可变的私有Date属性。 该类通过在其构造方法和访问器中防御性地拷贝Date对象，竭尽全力维持其不变性（invariants and immutability）。 代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Immutable class that uses defensive copying
public final class Period {

    private final Date start;
    private final Date end;

    /**
     * @param  start the beginning of the period
     * @param  end the end of the period; must not precede start
     * @throws IllegalArgumentException if start is after end
     * @throws NullPointerException if start or end is null
     */
    public Period(Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end   = new Date(end.getTime());
        if (this.start.compareTo(this.end) &amp;gt; 0)
            throw new IllegalArgumentException(
                          start + &quot; after &quot; + end);
    }

    public Date start () { return new Date(start.getTime()); }

    public Date end () { return new Date(end.getTime()); }

    public String toString() { return start + &quot; - &quot; + end; }

    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设要把这个类可序列化。由于&lt;code&gt;Period&lt;/code&gt;对象的物理表示精确地反映了它的逻辑数据内容，所以使用默认的序列化形式是合理的(条目 87)。因此，要使类可序列化，似乎只需将implements Serializable 添加到类声明中就可以了。但是，如果这样做，该类不再保证它的关键不变性了。&lt;/p&gt;
&lt;p&gt;问题是readObject方法实际上是另一个公共构造方法，它需要与任何其他构造方法一样的小心警惕。 正如构造方法必须检查其参数的有效性（条目 49）并在适当的地方对参数防御性拷贝（条目 50），readObject方法也要这样做。 如果readObject方法无法执行这两个操作中的任何一个，则攻击者违反类的不变性是相对简单的事情。&lt;/p&gt;
&lt;p&gt;简而言之，readObject是一个构造方法，它将字节流作为唯一参数。 在正常使用中，字节流是通过序列化正常构造的实例生成的。当readObject展现一个字节流时，问题就出现了，这个字节流是人为构造的，用来生成一个违反类不变性的对象。 这样的字节流可用于创建一个不可能的对象，该对象无法使用普通构造方法创建。&lt;/p&gt;
&lt;p&gt;假设我们只是将&lt;code&gt;implements Serializablet&lt;/code&gt;添加到&lt;code&gt;Period&lt;/code&gt;类声明中。 然后，这个丑陋的程序生成一个Period实例，其结束时间在其开始时间之前。 对byte类型的值进行强制转换，其高阶位被设置，这是由于Java缺乏byte字面量，并且错误地决定对byte类型进行签名:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BogusPeriod {
  // Byte stream couldn't have come from a real Period instance!
  private static final byte[] serializedForm = {
    (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06,
    0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x40, 0x7e, (byte)0xf8,
    0x2b, 0x4f, 0x46, (byte)0xc0, (byte)0xf4, 0x02, 0x00, 0x02,
    0x4c, 0x00, 0x03, 0x65, 0x6e, 0x64, 0x74, 0x00, 0x10, 0x4c,
    0x6a, 0x61, 0x76, 0x61, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2f,
    0x44, 0x61, 0x74, 0x65, 0x3b, 0x4c, 0x00, 0x05, 0x73, 0x74,
    0x61, 0x72, 0x74, 0x71, 0x00, 0x7e, 0x00, 0x01, 0x78, 0x70,
    0x73, 0x72, 0x00, 0x0e, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x75,
    0x74, 0x69, 0x6c, 0x2e, 0x44, 0x61, 0x74, 0x65, 0x68, 0x6a,
    (byte)0x81, 0x01, 0x4b, 0x59, 0x74, 0x19, 0x03, 0x00, 0x00,
    0x78, 0x70, 0x77, 0x08, 0x00, 0x00, 0x00, 0x66, (byte)0xdf,
    0x6e, 0x1e, 0x00, 0x78, 0x73, 0x71, 0x00, 0x7e, 0x00, 0x03,
    0x77, 0x08, 0x00, 0x00, 0x00, (byte)0xd5, 0x17, 0x69, 0x22,
    0x00, 0x78
  };

  public static void main(String[] args) {
    Period p = (Period) deserialize(serializedForm);
    System.out.println(p);
  }

  // Returns the object with the specified serialized form
  static Object deserialize(byte[] sf) {
    try {
      return new ObjectInputStream(
          new ByteArrayInputStream(sf)).readObject();
    } catch (IOException | ClassNotFoundException e) {
      throw new IllegalArgumentException(e);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于初始化serializedForm的字节数组字面量（literal）是通过序列化正常的Period实例，并手动编辑生成的字节流生成的。 流的细节对于该示例并不重要，但是如果好奇，则在《Java Object Serialization Specification》[序列化，6]中描述了序列化字节流格式。 如果运行此程序，它会打印&lt;code&gt;Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984&lt;/code&gt;。只需声明&lt;code&gt;Period&lt;/code&gt;类为可序列化，我们就可以创建一个违反其类不变性的对象。&lt;/p&gt;
&lt;p&gt;要解决此问题，请为Period提供一个readObject方法，该方法调用defaultReadObject，然后检查反序列化对象的有效性。如果有效性检查失败，readObject方法抛出InvalidObjectException异常，阻止反序列化完成:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// readObject method with validity checking - insufficient!
private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
    s.defaultReadObject();

    // Check that our invariants are satisfied
    if (start.compareTo(end) &amp;gt; 0)
        throw new InvalidObjectException(start +&quot; after &quot;+ end);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这样可以防止攻击者创建无效的Period实例，但仍然存在潜在的更微妙的问题。 可以通过构造以有效Period实例开头的字节流来创建可变Period实例，然后将额外引用附加到Period实例内部的私有Date属性。 攻击者从ObjectInputStream中读取Period实例，然后读取附加到流的“恶意对象引用”。 这些引用使攻击者可以访问Period对象中私有Date属性引用的对象。 通过改变这些Date实例，攻击者可以改变Period实例。 以下类演示了这种攻击：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MutablePeriod {
    // A period instance
    public final Period period;

    // period's start field, to which we shouldn't have access
    public final Date start;

    // period's end field, to which we shouldn't have access
    public final Date end;

    public MutablePeriod() {
        try {
            ByteArrayOutputStream bos =
                new ByteArrayOutputStream();
            ObjectOutputStream out =
                new ObjectOutputStream(bos);
            // Serialize a valid Period instance
            out.writeObject(new Period(new Date(), new Date()));

            /*
             * Append rogue &quot;previous object refs&quot; for internal
             * Date fields in Period. For details, see &quot;Java
             * Object Serialization Specification,&quot; Section 6.4.
             */
            byte[] ref = { 0x71, 0, 0x7e, 0, 5 };  // Ref #5
            bos.write(ref); // The start field
            ref[4] = 4;     // Ref # 4
            bos.write(ref); // The end field

            // Deserialize Period and &quot;stolen&quot; Date references
            ObjectInputStream in = new ObjectInputStream(
                new ByteArrayInputStream(bos.toByteArray()));
            period = (Period) in.readObject();
            start  = (Date)   in.readObject();
            end    = (Date)   in.readObject();
        } catch (IOException | ClassNotFoundException e) {
            throw new AssertionError(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要查看正在进行的攻击，请运行以下程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    MutablePeriod mp = new MutablePeriod();
    Period p = mp.period;
    Date pEnd = mp.end;

    // Let's turn back the clock
    pEnd.setYear(78);
    System.out.println(p);

    // Bring back the 60s!
    pEnd.setYear(69);
    System.out.println(p);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我的语言环境中，运行此程序会产生以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978
Wed Nov 22 00:21:29 PST 2017 - Sat Nov 22 00:21:29 PST 1969&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然创建了Period实例且保持了其不变性，但可以随意修改其内部组件。 一旦拥有可变的Period实例，攻击者可能会通过将实例传递给依赖于Period的安全性不变性的类来造成巨大的伤害。 这并非如此牵强：有些类就是依赖于String的不变性来保证安全性的。&lt;/p&gt;
&lt;p&gt;问题的根源是Period类的readObject方法没有做足够的防御性拷贝。 &lt;strong&gt;对象反序列化时，防御性地拷贝包含客户端不能拥有的对象引用的属性，是至关重要的&lt;/strong&gt;。 因此，每个包含私有可变组件的可序列化不可变类，必须在其readObject方法中防御性地拷贝这些组件。 以下readObject方法足以确保Period的不变性并保持其不变性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// readObject method with defensive copying and validity checking
private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
    s.defaultReadObject();

    // Defensively copy our mutable components
    start = new Date(start.getTime());
    end   = new Date(end.getTime());

    // Check that our invariants are satisfied
    if (start.compareTo(end) &amp;gt; 0)
        throw new InvalidObjectException(start +&quot; after &quot;+ end);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，防御性拷贝在有效性检查之前执行，并且我们没有使用Date的clone方法来执行防御性拷贝。 需要这两个细节来保护Period免受攻击（条目 50）。 另请注意，final属性无法进行防御性拷贝。 要使用readObject方法，我们必须使start和end属性不能是final类型的。 这是不幸的，但它是这两个中较好的一个做法。 使用新的readObject方法并从&lt;code&gt;start&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;属性中删除final修饰符后，&lt;code&gt;MutablePeriod&lt;/code&gt;类不再无效。 上面的攻击程序现在生成如下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017
Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个简单的石蕊测试(litmus test)，用于确定类的默认readObject方法是否可接受：你是否愿意添加一个公共构造方法，该构造方法把对象中每个非瞬时状态的属性值作为参数，并在没有任何验证的情况下，将值保存在属性中？如果没有，则必须提供readObject方法，并且它必须执行构造方法所需的所有有效性检查和防御性拷贝。或者，可以使用序列化代理模式（serialization proxy pattern））(条目 90)。强烈推荐使用这种模式，因为它在安全反序列化方面花费了大量精力。&lt;/p&gt;
&lt;p&gt;readObject方法和构造方法还有一个相似之处，它们适用于非final可序列化类。 与构造方法一样，readObject方法不能直接或间接调用可重写的方法（条目 19）。 如果违反此规则并且重写了相关方法，则重写方法会在子类状态被反序列化之前运行。 程序可能会导致失败[Bloch05，Puzzle 91]。&lt;/p&gt;
&lt;p&gt;总而言之，无论何时编写readObject方法，都要采用这样一种思维方式，即正在编写一个公共构造方法，该构造方法必须生成一个有效的实例，而不管给定的是什么字节流。不要假设字节流一定表示实际的序列化实例。虽然本条目中的示例涉及使用默认序列化形式的类，但是所引发的所有问题都同样适用于具有自定义序列化形式的类。下面是编写readObject方法的指导原则:&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于具有必须保持私有的对象引用属性的类，防御性地拷贝该属性中的每个对象。不可变类的可变组件属于这一类别。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;检查任何不变性，如果检查失败，则抛出InvalidObjectException异常。 检查应再任何防御性拷贝之后。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果必须在反序列化后验证整个对象图（object graph），那么使用ObjectInputValidation接口(在本书中没有讨论)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不要直接或间接调用类中任何可重写的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 06 Apr 2019 14:16:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 书中的源代码地址：https://github.com/jbloch/effective java 3e source code 注意，书中的有些代码里方法是基于Java 9 API中的，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/10663149.html</dc:identifier>
</item>
</channel>
</rss>