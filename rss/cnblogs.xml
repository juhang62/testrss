<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>野生前端的数据结构练习（12）贪心算法 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10073306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10073306.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201811/30/bd166f93c622d5d531a522568ec65c46.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.1052631578947&quot;&gt;
&lt;p&gt;参考代码可见：&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Structure/GreedyAlogrithm&quot; class=&quot;uri&quot;&gt;https://github.com/dashnowords/blogs/tree/master/Structure/GreedyAlogrithm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一.贪心算法&quot;&gt;一.贪心算法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;贪心算法&lt;/code&gt;属于比较简单的算法，它总是会选择当下最优解，而不去考虑单次递归时是否会对未来造成影响，也就是说不考虑得到的解是否是&lt;strong&gt;全局最优&lt;/strong&gt;。在很多实际问题中，寻找全局最优解的代价是非常大的，这时候就可以通过求次优解来解决问题，这种思想其实在软件工程中很常见，例如&lt;code&gt;React&lt;/code&gt;中著名的&lt;code&gt;DOM Diff&lt;/code&gt;算法中需要对比两棵DOM树，树的完全对比时间复杂度为&lt;strong&gt;O(n^3)&lt;/strong&gt;，而React团队通过只比较同层节点的策略将问题简化为&lt;strong&gt;O(n)&lt;/strong&gt;，也就是说得到的结果从全局角度来说并不一定是绝对最优的，但是它可以在大多数情况下表现并不差。&lt;/p&gt;
&lt;p&gt;下面通过几个简单例子来理解&lt;code&gt;贪心算法&lt;/code&gt;（题目来自&lt;strong&gt;《数据结构与算法Javascript描述》&lt;/strong&gt;一书）。&lt;/p&gt;
&lt;h3 id=&quot;二.贪心算法求解背包问题&quot;&gt;二.贪心算法求解背包问题&lt;/h3&gt;
&lt;p&gt;贪心算法求解背包问题实际上很像人工求解，如果你是一个大盗，自己带着背包在宝库挑东西，总不能拿一张草稿纸出来开始动态规划或手动递归吧，那等你求出结果来估计警察也来了，可能的做法例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不做衡量，拿起什么放什么，放不进去或者没有更多东西了，然后离开。&lt;/li&gt;
&lt;li&gt;从最贵的开始挑，能放进去就放，放不进去就接着挑别的，最后背包塞不下更多或者没东西了，然后离开。&lt;/li&gt;
&lt;li&gt;简单计算一下性价比（一般可以以【价值】/【体积】来衡量），然后按性价比从高到低开始挑，能放进去就放，放不进去就下一个，最后背包塞不下更多或者没东西了，离开。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这几种方式都可以作为贪心算法的一部分参与计算，得到的结果也不一定是一样的，但都可以认为是一种局部最优解，同时也可能是全局最优解。&lt;/p&gt;
&lt;p&gt;示例算法实现：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 贪心算法求解背包问题局部最优解
 */
function ksack(values, weights, capacity, n) {
    var load = 0;
    var i =0;
    var w = 0;
    while (load &amp;lt; capacity &amp;amp;&amp;amp; i &amp;lt; n){
        if(weights[i] &amp;lt;= (capacity-load)){
            w += values[i];
            load += weights[i];
        }else{
            var r = (capacity - load) / weights[i];
            w += r * values[i];
            load += weights[i];
        }
        i++;
    }
    return w;
}

var items = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];
var values = [50, 140, 60 ,60];
var weights = [5, 20, 10, 12];
var n = 4;
var capacity = 30;

console.log(ksack(values,weights, capacity, n))&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三.最长公共子串&quot;&gt;三.最长公共子串&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;书中第14章练习题1：使用暴力技巧求解最长公共子串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 题解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;暴力求解公共字符串的方法，从较短的字符串整体开始找起，逐步缩小步长，例如长字符串为&lt;code&gt;long_str&lt;/code&gt;,较短的字符串称为&lt;code&gt;short_str&lt;/code&gt;,假设&lt;code&gt;short_str&lt;/code&gt;的长度为6，先查看&lt;code&gt;short_str&lt;/code&gt;是否整个包含在&lt;code&gt;long_str&lt;/code&gt;中，如果是则返回，如果不是，再将步长设置为5,然后查看&lt;code&gt;short_str[0,5)&lt;/code&gt;, &lt;code&gt;short_str[1,6)&lt;/code&gt;这两个字符串是否在&lt;code&gt;long_str&lt;/code&gt;中，以此类推，过程和找零问题很相似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 参考代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 贪心算法寻找公共子串
 */
function greedy_lsc(str1, str2) {
    //保证str2是长度较短的序列
    if (str1.length &amp;lt; str2.length) {
        let temp = str1;
        str1 = str2;
        str2 = temp;
    }
    let stepLength = str2.length;
    //从长到短枚举
    while(stepLength &amp;gt;= 0){
        for(let i = 0; i &amp;lt; str2.length - stepLength; i++){
            //相当于拿一个不断缩短的尺子逐段截取来查看截取的片段是否被长字符串包含，
            //一旦找到则就是最长公共子串
            let checking = str2.slice(i, i+stepLength);
            if (contains(str1,checking)) {
                return checking;
            }
        }
        stepLength--;
    }
}

//str2是否是str1的子串
function contains(str1, str2) {
    return str1.indexOf(str2) !== -1;
}

//测试
let str1 = 'aabcdefsssefce';
let str2 = 'abssefsssse';

console.log(greedy_lsc(str1,str2));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四.找零问题&quot;&gt;四.找零问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;书中第14章练习题3：使用贪心算法求解找零问题，要求不能用10美分，需要找零30美分。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 题解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;书中有例题，没什么难度，就不展开讲了，仅提供参考代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2 参考代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 贪心算法求解零钱问题
 * 要求：不能使用10美分
 */

function makeChange(money, coins) {
    let remain = money;
    if (remain / 25 &amp;gt; 0) {
        coins[2] = parseInt(remain / 25, 10);
        remain = remain - coins[2]*25;
    }
    if (remain / 5 &amp;gt; 0) {
        coins[1] = parseInt(remain / 5 , 10);
        remain = remain - coins[1]*5;
    }
    coins[0] = remain;
}

/**
 * 显示结果
 */
function showChange(coins) {
   if (coins[2] &amp;gt; 0) {
     console.log('25美分-' + coins[2]);
   }
   if (coins[1] &amp;gt; 0) {
     console.log('5美分-' + coins[1]);
   }
    if (coins[0] &amp;gt; 0) {
     console.log('1美分-' + coins[0]);
   }
}

var origAmt = 30;
var coins = [];
makeChange(origAmt, coins);
showChange(coins);&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 05 Dec 2018 22:48:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>参考代码可见：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10073306.html</dc:identifier>
</item>
<item>
<title>express+vue+mongodb+session 实现注册登录 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/10074148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/10074148.html</guid>
<description>&lt;p&gt;上个月写了一篇文章是 &lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9926725.html&quot; target=&quot;_blank&quot;&gt;express+mongodb+vue 实现增删改查&lt;/a&gt;. 只是简单的实现了增删改查功能，那么今天是在那个基础之上做了扩展，首先实现的功能有如下：&lt;/p&gt;
&lt;p&gt;1. 支持注册，登录功能，用户可以注册完成后，进行登录，登录完成后会进入到列表增删改查页面。&lt;br/&gt;2. 支持session会话，也就是说设置了多长时间登录过期，如果用户没有登录，直接进查询列表页面，会重定向到登录页面去，如果用户登录了后，把浏览器关掉，直接输入列表查询页面，会直接进入列表页面的。&lt;br/&gt;3. 列表数据加入了分页功能。&lt;br/&gt;4. 对数据库中的请求加入了日志记录。&lt;/p&gt;
&lt;p&gt;该代码和之前的实现&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9926725.html&quot; target=&quot;_blank&quot;&gt;增删改查&lt;/a&gt;代码，目录有所调整，目的想文件目录更加清晰。我们在讲解之前，还是和之前一样，先看下效果：&lt;br/&gt;&lt;strong&gt;1. 首先服务器重启后，在地址栏中输入 http://localhost:8081/ 后，会重定向到登录页面来，如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205230705161-746020117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 如果没有账号的话，我们可以注册一个账号，进入注册页面，如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205230723066-117190412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 如果用户名和密码没有输入，或者输入的格式不合法的话，会如下提示所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205230739131-1762011590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205230746458-242973046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 当用户注册成功后，可以看到如下页面了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205230802399-1773582852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 我们去登录页面，进行登录，如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205230816843-2094036098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 登录成功后，会跳转到列表页面，如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205230831881-561986801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面的增删改查操作的流程，我就不再介绍了，和我之前的 &lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9926725.html&quot; target=&quot;_blank&quot;&gt;express+mongodb+vue 实现增删改查&lt;/a&gt;中的演示是一样的。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;7. 下面我们来看看我们的数据库中是否增加了刚刚注册的用户账号了，如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205230940066-964171882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的四个账号都是我注册的，在数据库中可以看到，注册成功了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果某个用户注册过了，你再使用相同的账号继续注册话，是不能注册，会提示该账号已经注册过了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205231004808-1769035027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面还是来看下我们项目的整个目录架构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### 目录结构如下：
demo1                                       # 工程名
&lt;/span&gt;|   |---&lt;span&gt; dist                               # 打包后生成的目录文件             
&lt;/span&gt;|   |---&lt;span&gt; node_modules                       # 所有的依赖包
&lt;/span&gt;|   |----&lt;span&gt;database                           # 数据库相关的文件目录
&lt;/span&gt;|   | |---&lt;span&gt;db.js                             # mongoose类库的数据库连接操作
&lt;/span&gt;|   | |---&lt;span&gt;models                            # 存放所有模型表
&lt;/span&gt;|   | | |---&lt;span&gt; user.js                        # 增删改查用户数据表
&lt;/span&gt;|   | | |---&lt;span&gt; userTable.js                   # 用户账号表
&lt;/span&gt;|   |---&lt;span&gt; app
&lt;/span&gt;|   | |---&lt;span&gt;index
&lt;/span&gt;|   | | |--&lt;span&gt; views                           # 存放所有vue页面文件
&lt;/span&gt;|   | | | |--&lt;span&gt; list.vue                      # 列表数据
&lt;/span&gt;|   | | | |--&lt;span&gt; index.vue
&lt;/span&gt;|   | | | |--&lt;span&gt; login.vue                     # 用户登录页面
&lt;/span&gt;|   | | | |--&lt;span&gt; regist.vue                    # 用户注册页面
&lt;/span&gt;|   | | |--&lt;span&gt; components                      # 存放vue公用的组件
&lt;/span&gt;|   | | |--&lt;span&gt; js                              # 存放js文件的
&lt;/span&gt;|   | | |--&lt;span&gt; css                             # 存放css文件
&lt;/span&gt;|   | | |--&lt;span&gt; store                           # store仓库
&lt;/span&gt;|   | | | |---&lt;span&gt; actions.js
&lt;/span&gt;|   | | | |---&lt;span&gt; mutations.js
&lt;/span&gt;|   | | | |---&lt;span&gt; state.js
&lt;/span&gt;|   | | | |--- mutations-&lt;span&gt;types.js
&lt;/span&gt;|   | | | |---&lt;span&gt; index.js
&lt;/span&gt;|   | | | |
|   | | |--&lt;span&gt; app.js                          # vue入口配置文件
&lt;/span&gt;|   | | |--&lt;span&gt; router.js                       # 路由配置文件
&lt;/span&gt;|   |---&lt;span&gt; api                                # 保存所有接口操作的文件
&lt;/span&gt;|   | |---&lt;span&gt; addAndDelete.js                  # 增删改查的接口
&lt;/span&gt;|   | |---&lt;span&gt; regAndLogin.js                   # 注册登录的接口
&lt;/span&gt;|   | |---&lt;span&gt; userSession.js                   # 用户session有效的接口
&lt;/span&gt;|   |---&lt;span&gt; routes                             # 存放所有的路由文件
&lt;/span&gt;|   | |---&lt;span&gt; addAndDelete.js                  # 增删改查路由
&lt;/span&gt;|   | |---&lt;span&gt; regAndLogin.js                   # 注册和登录路由
&lt;/span&gt;|   | |---&lt;span&gt; userSession.js                   # session路由
&lt;/span&gt;|   |---&lt;span&gt; views
&lt;/span&gt;|   | |--&lt;span&gt; index.html                        # html文件
&lt;/span&gt;|   |---&lt;span&gt; webpack.config.js                  # webpack配置文件 
&lt;/span&gt;|   |---&lt;span&gt; .gitignore  
&lt;/span&gt;|   |---&lt;span&gt; README.md
&lt;/span&gt;|   |---&lt;span&gt; package.json
&lt;/span&gt;|   |---&lt;span&gt; .babelrc                           # babel转码文件
&lt;/span&gt;|   |--- app.js                             # express入口文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们先看下 根目录下的 app.js 文件代码(服务器代码)：&lt;/p&gt;
&lt;p&gt;部分代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入express模块&lt;/span&gt;
const express = require('express'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入session&lt;/span&gt;
const session = require('express-session'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建app对象&lt;/span&gt;
const app =&lt;span&gt; express();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载路由&lt;/span&gt;
const addAndDelete = require('./routes/addAndDelete'&lt;span&gt;);
const regAndLogin &lt;/span&gt;= require('./routes/regAndLogin'&lt;span&gt;);
const userSession &lt;/span&gt;= require('./routes/userSession'&lt;span&gt;);

const bodyParser &lt;/span&gt;= require(&quot;body-parser&quot;&lt;span&gt;);

const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mongoose-morgan&lt;/span&gt;
const morgan = require('mongoose-morgan'&lt;span&gt;);

app.use(bodyParser.json());

app.use(bodyParser.urlencoded({ extended: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt; }));

app.use(session({
  secret: &lt;/span&gt;'kongzhi', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对 session id 相关的cookie 进行加密签名&lt;/span&gt;
&lt;span&gt;  cookie: {
    maxAge: &lt;/span&gt;1000 * 60 * 10  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 session的有效时间，单位为毫秒，设置有效期为10分钟&lt;/span&gt;
&lt;span&gt;  }
}));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Logger 添加数据库操作日志记录  https://www.npmjs.com/package/mongoose-morgan&lt;/span&gt;
&lt;span&gt;app.use(morgan({
  connectionString: &lt;/span&gt;'mongodb://localhost:27017/dataDb'&lt;span&gt;
}));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用&lt;/span&gt;
app.use('/user'&lt;span&gt;, addAndDelete);
app.use(&lt;/span&gt;'/reglogin'&lt;span&gt;, regAndLogin);
app.use(&lt;/span&gt;'/user', userSession);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，加载路由后，然后使用 use了，对应的 routes文件下的js文件，代码分别如下：&lt;/p&gt;
&lt;p&gt;1. routes/addAndDelete.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入express 模块 &lt;/span&gt;
const express = require('express'&lt;span&gt;);

const router &lt;/span&gt;=&lt;span&gt; express.Router();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入user.js&lt;/span&gt;
const User = require('../api/addAndDelete'&lt;span&gt;);

router.post(&lt;/span&gt;'/add'&lt;span&gt;, User.add);

router.post(&lt;/span&gt;'/query'&lt;span&gt;, User.query);

router.post(&lt;/span&gt;'/del'&lt;span&gt;, User.del);

router.post(&lt;/span&gt;'/update'&lt;span&gt;, User.update);

module.exports &lt;/span&gt;= router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. routes/regAndLogin.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const express = require('express'&lt;span&gt;);

const router &lt;/span&gt;=&lt;span&gt; express.Router();

const RegAndLogin &lt;/span&gt;= require('../api/regAndLogin'&lt;span&gt;);

router.post(&lt;/span&gt;'/regist'&lt;span&gt;, RegAndLogin.registered);

router.post(&lt;/span&gt;'/login'&lt;span&gt;, RegAndLogin.login);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注销&lt;/span&gt;
router.post('/logout'&lt;span&gt;, RegAndLogin.logout);

module.exports &lt;/span&gt;= router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. routes/userSession.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const express = require('express'&lt;span&gt;);

const router &lt;/span&gt;=&lt;span&gt; express.Router();

const userSession &lt;/span&gt;= require('../api/userSession'&lt;span&gt;);

router.post(&lt;/span&gt;'/usersession'&lt;span&gt;, userSession.usersession);

module.exports &lt;/span&gt;= router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此对于 app.use('/user', addAndDelete); 的时候，会调用 routes/addAndDelete.js 下的请求方法，分别为：&lt;/p&gt;
&lt;p&gt;/add, /query, /update, /del, 因此在我们列表页面中使用接口方式如：类似于如下这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205231210963-1884558640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;都是 /user/add, /user/query, /user/update, /user/del 这样的接口，比如说我们使用 /user/add post请求这样的接口的时候，他们会调用到 routes/addAndDelete.js 中的router.post('/add', User.add); 这里面的 User.add方法，所以它就会调用到 api/addAndDelete.js 中的add函数，如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const User = require('../database/models/user'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新增信息&lt;/span&gt;
module.exports.add = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res, next) {
  const user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User({
    name: req.body.name,
    age: req.body.age,
    sex: req.body.sex
  });
  user.save((err, docs) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      res.send({ &lt;/span&gt;'code': 1, 'errorMsg': '新增失败'&lt;span&gt; });
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      res.send({ &lt;/span&gt;&quot;code&quot;: 0, 'message': '新增成功'&lt;span&gt; });
    }
  });
  next();
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此会调用数据库的操作，会在数据库中增加一条数据。如上代码，会应用到 database/models/user 这个表中的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 定义一个user的Schema
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const mongoose &lt;/span&gt;= require('../db.js'&lt;span&gt;);
const Schema &lt;/span&gt;=&lt;span&gt; mongoose.Schema;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个模型&lt;/span&gt;
const UserSchema = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Schema({
  name: { type: String}, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性name，类型为String&lt;/span&gt;
  age: { type: Number, &lt;span&gt;default&lt;/span&gt;: 30 }, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性age，类型为Number，默认值为30&lt;/span&gt;
&lt;span&gt;  sex: { type: String }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导出model模块&lt;/span&gt;
const User = module.exports = mongoose.model('User', UserSchema);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此会创建user表，并且在表中插入对应的数据。&lt;/p&gt;
&lt;p&gt;如上只是解释下增加接口的调用方式，其他的接口设计也是一样的。就不多解释了。对应 /user 这样的，我们在webpack中的devServer中会配置下，解决跨域问题，因为我现在是启动两个服务的，node端的端口是 3001, 而我的webpack的端口是8081， 会存在跨域的，因此webpack的 devServer 需要做如下配置的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;devServer: {
  port: &lt;/span&gt;8081&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; host: '0.0.0.0',&lt;/span&gt;
&lt;span&gt;  headers: {
    &lt;/span&gt;'X-foo': '112233'&lt;span&gt;
  },
  inline: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  overlay: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  stats: &lt;/span&gt;'errors-only'&lt;span&gt;,
  proxy: {
    &lt;/span&gt;'/user'&lt;span&gt;: {
      target: &lt;/span&gt;'http://127.0.0.1:3001'&lt;span&gt;,
      changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否跨域&lt;/span&gt;
&lt;span&gt;    },
    &lt;/span&gt;'/combineFile'&lt;span&gt;: {
      target: &lt;/span&gt;'http://127.0.0.1:3001'&lt;span&gt;,
      changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否跨域,&lt;/span&gt;
&lt;span&gt;      pathRewrite: {
        &lt;/span&gt;'^/combineFile' : ''  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写路径&lt;/span&gt;
&lt;span&gt;      }
    },
    &lt;/span&gt;'/reglogin'&lt;span&gt;: {
      target: &lt;/span&gt;'http://127.0.0.1:3001'&lt;span&gt;,
      changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否跨域&lt;/span&gt;
&lt;span&gt;    }
  }
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. app.js 中使用了 mongoose-morgan 这个插件，为了数据库操作接口的时候，写入日志，比如报错的时候可以在服务器端看到报错信息，该API的具体使用可以&lt;br/&gt;看下 npm库（&lt;a href=&quot;https://www.npmjs.com/package/mongoose-morgan&quot; target=&quot;_blank&quot;&gt;https://www.npmjs.com/package/mongoose-morgan&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;如下日志记录：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181205231522929-367392308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的代码这边就不多解释，有兴趣的话可以去github上下载代码查看下哦。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/webpack-all-demo/tree/master/express%2Bsession%20%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95&quot; target=&quot;_blank&quot;&gt;查看github上源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 15:17:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>express+vue+mongodb+session 实现注册登录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/10074148.html</dc:identifier>
</item>
<item>
<title>python网络编程-udp - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-socket-udp.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-socket-udp.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;创建socket&quot;&gt;1. 创建socket&lt;/h2&gt;
&lt;p&gt;在 Python 中 使用socket 模块的函数 socket 就可以完成（大多数的编程语言的套路是相似的）：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket
socket.socket(AddressFamily, Type)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;函数 socket.socket 创建一个 socket，该函数带有两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET&lt;/li&gt;
&lt;li&gt;Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建一个udp socket（udp套接字）：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket

# 创建udp socket
udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# ...
# 使用套接字收/发数据

# 关闭socket
udp_socket.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;套接字使用流程 与 文件的使用流程很类似
&lt;ol&gt;&lt;li&gt;创建套接字&lt;/li&gt;
&lt;li&gt;使用套接字收/发数据&lt;/li&gt;
&lt;li&gt;关闭套接字&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;udp网络程序-发送数据&quot;&gt;2. udp网络程序-发送数据&lt;/h2&gt;
&lt;p&gt;创建一个基于udp的网络程序流程很简单，具体步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建客户端套接字&lt;/li&gt;
&lt;li&gt;发送/接收数据&lt;/li&gt;
&lt;li&gt;关闭套接字&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket

def main():
        # 创建套接字
        udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        # 读取输入的数据
        send_data = input('请输入要发送的数据：')

        # 发送数据
        send_addr = ('192.168.92.190', 7878)
        udp_socket.sendto(send_data.encode('GBK'), send_addr)

        # 关闭
        udp_socket.close()



if __name__ == '__main__':
        main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ubuntu的终端中执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181205214407279-406283568.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在windows中运行“网络调试助手”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181205214520715-1298986964.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;udp网络程序-接收数据&quot;&gt;3. udp网络程序-接收数据&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket

def main():

        # 创建套接字
        udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        # 绑定一个本地信息
        localaddr = (&quot;&quot;, 8080)
        udp_socket.bind(localaddr)

        # 接收数据
        recv_data = udp_socket.recvfrom(1024)

        # recv_data是一个元组(接收到的数据, (发送方的IP, port))
        recv_msg = recv_data[0] # 存储接收到的数据
        send_addr = recv_data[1] # 存储发送方的地址

        # 打印收到的消息
        # print(recv_data)
        print(&quot;%s:%s&quot; % (str(send_addr), recv_msg.decode('GBK')))

        # 关闭
        udp_socket.close()

if __name__ == '__main__':
        main()
        &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ubuntu的终端中执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181205222405077-1668725574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网咯助手中发送数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181205222457657-772347713.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;python3中的编码转换&quot;&gt;4. python3中的编码转换&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用socket发送的是数据的二进制，需要将字符串转换成bytes&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;str.encode()&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用socket接收的是数据的二进制，需要将bytes转换成字符&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;bytes.decode()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ipython3中尝试：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;In [2]: text = &quot;一串文本&quot;

In [3]: text
Out[3]: '一串文本'

In [5]: bytes_text = text.encode()

In [6]: bytes_text
Out[6]: b'\xe4\xb8\x80\xe4\xb8\xb2\xe6\x96\x87\xe6\x9c\xac'

In [7]: type(text)
Out[7]: str

In [8]: type(bytes_text)
Out[8]: bytes

In [9]: decoded_text = bytes_text.decode()
    
In [10]: decoded_text
Out[10]: '一串文本'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中decode()与encode()方法可以接受参数，其声明分别为:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;bytes.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)
str.encode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的encoding是指在解码编码过程中使用的编码(此处指“编码方案”是名词)，errors是指错误的处理方案。&lt;/p&gt;
&lt;p&gt;详细的可以参照官方文档：&lt;/p&gt;
&lt;h2 id=&quot;udp端口绑定&quot;&gt;5. udp端口绑定&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一个udp网络程序，运行时没有绑定端口，系统会给它分配一个随机的端口，如果再次运行，端口可能发生变化&lt;/li&gt;
&lt;li&gt;一个udp网络程序，也可以绑定信息（ip地址，端口号），如果绑定成功，那么操作系统用这个端口号来进行区别收到的网络数据是否是此进程的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;什么时候需要绑定端口呢？&lt;/p&gt;
&lt;p&gt;一般来说，如果要做成一个服务端的应用程序的话，是需要绑定固定端口的。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 14:58:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 1. 创建socket 在 Python 中 使用socket 模块的函数 socket 就可以完成（大多数的编程语言的套路是相似的）： 说明： 函数 socket.socket 创建一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-socket-udp.html</dc:identifier>
</item>
<item>
<title>工程事故与现实世界 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/10074040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/10074040.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201812/815275-20181205225152319-888130896.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每年的双十一都是电商行业程序员们的一次大考。今年的双十一刚刚过去不久，在双十一之前的那一周，我几乎每天都会想一个问题：如果系统会发生故障，那么可能会在哪里？&lt;/p&gt;
&lt;p&gt;双十一前一个月，是为数不多能暂缓业务需求，集中进行系统检修的机会，在这期间会发现之前积累下来的各类隐患和小缺陷，并进行集中修复，然后上线压测。虽然这已经是我经历的第八次双十一，各类备战准备流程已经轻车熟路，一套架势打下来，基本也算相对比较全面了。但还是没有百分百的把握，因为事故，特别是工程上的事故总是发生在你想不到的地方。&lt;/p&gt;
&lt;p&gt;就怕想不到，不怕做不到；备战期间，专门找了一些工程上的失败事故来看看，启发一下思维路径。这些工程事故都不是软件开发方面的，而是更广泛的传统工程行业，但其事故影响也更加触目惊心。每读完一个事故的描述，我心下都是一惊，一回味，似乎类似的错误，要么自己犯过，要么碰到过。&lt;/p&gt;
&lt;p&gt;简单分享一些其中的事故。&lt;/p&gt;
&lt;h2 id=&quot;量级问题&quot;&gt;量级问题&lt;/h2&gt;
&lt;p&gt;1940 年，美国华盛顿州的塔科马海峡大桥，在一次大风中坍塌。&lt;/p&gt;
&lt;p&gt;塔科马海峡大桥是当时最长的悬索桥，桥梁设计师复制了现有结构较小的悬索桥，简单构建了一个更长的悬索桥。这种结构在短跨度的桥上已经得到了验证，工程师未经仔细计算想当然地扩大到了长跨度的桥上。后来，一天海上刮起了强烈的大风，桥开始波动并扭曲，随后坍塌了。&lt;/p&gt;
&lt;p&gt;曾经我在程序实现中就碰到过一个类似的场景：一个字符串替换函数的实现。这是一个公共的工具函数，但其实现并不合理，当字符串的长度比较小的时候，比如说 50K 以内吧，它的执行耗时对整个系统的影响几乎感觉不出来。但一旦字符串比较大了以后，性能会急剧下降。&lt;/p&gt;
&lt;p&gt;而系统中确实偶尔就会出现超大的字符串输入，达到 100K～200K，这时这个函数的执行耗时会高出一个量级，系统的并行吞吐能力就瞬间下降很多，感觉非常明显了。&lt;/p&gt;
&lt;p&gt;这就是典型的量级问题，跨越了某个量级的边界，逻辑就可能变了，而预期结果也不一样了。&lt;/p&gt;
&lt;h2 id=&quot;实施偏差&quot;&gt;实施偏差&lt;/h2&gt;
&lt;p&gt;1981 年，美国堪萨斯市凯悦酒店，酒店大堂悬在半空中的走廊，在开业聚会上，人们在上面跳舞，产生了坍塌，导致 100 多人死亡。&lt;/p&gt;
&lt;p&gt;空中走廊的固定方案，设计师的意图在实施时却变了样。因为承包施工方不知道整体结构的设计影响，而为了赶工期急于完成这项工作，对设计方案的施工作了看似无关紧要，但却最终致命的修改。&lt;/p&gt;
&lt;p&gt;这在程序设计与实现中，简直太常见了。软件工程相比建筑工程，其从设计到实施的严谨性，规范性相差可以说是天壤之别。建筑工程中尚且无法完全避免，软件工程中简直是家常便饭了。&lt;/p&gt;
&lt;p&gt;实施中，很可能为了便利的选择，从而减弱了设计的初衷。&lt;/p&gt;
&lt;p&gt;这有好的办法来控制这个过程，减小实施偏差吗？Code Review 算是一种吧，属于实施走查，可以降低偏差的概率。但它也有成本，相对来说越是核心关键系统的代码，实施 Code Review 即使成本很高，也更容易推行。&lt;/p&gt;
&lt;p&gt;比如说，底层存储类数据库系统，如果引发灾难级事故，其影响很可能是不可逆的，那么再高的成本也得承担。但更多的业务类代码，业务本身在探索、演变和进化，而业务错误大部分也不是难以承担的不可逆错误，所以在效率和成本之间就需要经常去平衡了。&lt;/p&gt;
&lt;p&gt;现实中确实有这种情况，我们在写代码实现时也许能发现更好的方法路径，但做出这种改变时，要特别反思一下当初设计的初衷，是否把所有的点都考虑全面了。&lt;/p&gt;
&lt;h2 id=&quot;场景缺失&quot;&gt;场景缺失&lt;/h2&gt;
&lt;p&gt;1968 年 1 月，挑战者号航天飞机升空后不久爆炸。&lt;/p&gt;
&lt;p&gt;挑战者号是在美国佛罗里达肯尼迪航天中心发射的，爆炸的原因是航天飞机的多节推进器连接的 O 形密封圈破裂，火焰从裂开的密封圈喷出并点燃了相邻的燃料箱。&lt;/p&gt;
&lt;p&gt;为什么会破裂呢？因为这个密封圈缺乏在 0 度环境以下的测试。发射当天，气温很低，达到了 -2 摄氏度，这对于处在亚热带地区的佛罗里达是一个异常的低温。过度冰冷的密封圈变得太脆，从而发生了低温破裂。&lt;/p&gt;
&lt;p&gt;我再想，如果当时发射时间选在春夏季节，也许就不会发生这次事故，但这个隐患可能很久都无法被发现。有些 Bug 会隐藏很久，但该来的总会到来。&lt;/p&gt;
&lt;p&gt;大概是在上一次双十一吧，我们的系统中就埋藏了类似这样一个 Bug，那次公司在电视上作了互动，整点通过打开 App 摇一摇来抽奖。本以为这个场景和我们没啥关系，但没想到在代码层面真有了关系，每次摇动的用户都和我们系统建立连接并发起了登录，这部分流量完全在我们的预估之外，导致了系统访问量比预估的最大量还高了十多倍，直接引发了限流，降低了用户可用性和体验。&lt;/p&gt;
&lt;p&gt;这就是场景考虑缺失的问题，佛罗里达也许很少有这样的低温天气，而我们也没想到还有这样一个场景。&lt;/p&gt;
&lt;p&gt;想不到的，才是最危险的。&lt;/p&gt;
&lt;p&gt;有什么好办法来预防吗？也许可以让团队来开一个事故头脑风暴会，把大家各自掌握的信息和思维路径都分享碰撞以下，也许会有一些启发。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;今天写不完了，还有一些其他颇有启示的事故案例，下次续一篇再聊。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 14:53:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<og:description>每年的双十一都是电商行业程序员们的一次大考。今年的双十一刚刚过去不久，在双十一之前的那一周，我几乎每天都会想一个问题：如果系统会发生故障，那么可能会在哪里？ 双十一前一个月，是为数不多能暂缓业务需求，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/10074040.html</dc:identifier>
</item>
<item>
<title>异步 JavaScript - 事件循环 - 极光推送</title>
<link>http://www.cnblogs.com/jpush88/p/10073979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpush88/p/10073979.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;简评：如果你对 JavaScript 异步的原理感兴趣，这里有一篇不错的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;javascript-同步代码是如果工作的&quot;&gt;JavaScript 同步代码是如果工作的&lt;/h2&gt;
&lt;p&gt;在介绍 JavaScript 异步执行之前先来了解一下， JavaScript 同步代码是如何执行的。&lt;/p&gt;
&lt;p&gt;这里有两个概念需要了解：&lt;/p&gt;
&lt;p&gt;** 执行上下文（Excution Context）**&lt;/p&gt;
&lt;p&gt;执行上下文是一个抽象的概念，用于表示 JavaScript 的运行环境，任何代码都会有一个执行上下文。&lt;/p&gt;
&lt;p&gt;全局代码运行在全局执行上下文，函数里的代码运行在函数执行上下文，每一个函数都有自己的执行上下文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用堆栈（Call Stack）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用栈是一个具有 LIFO（后进先出）结构的栈，用于储存代码执行阶段所有的执行上下文。&lt;/p&gt;
&lt;p&gt;因为 JavaScript 是单线程的，所以 JavaScript 只有一个单独的调用栈。&lt;/p&gt;
&lt;p&gt;我们以下面例子介绍同步代码执行过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const second = () =&amp;gt; {
  console.log('Hello there!');
}
const first = () =&amp;gt; {
  console.log('Hi there!');
  second();
  console.log('The End');
}
first();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/042369854aac4e227eb8cb8f666506d1d3b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建全局上下文（由 main() 表示），并将全局上下文推到栈顶。然后依次将遇到函数执行上下文推到栈顶（如果函数中执行其他他函数，其他函数依次推到栈顶以此类推）。当函数执行完毕对应的执行上下文会从调用栈弹出，程序结束时全局上下文从调用栈弹出。&lt;/p&gt;
&lt;h2 id=&quot;javascript-异步代码是如何执行的&quot;&gt;JavaScript 异步代码是如何执行的？&lt;/h2&gt;
&lt;p&gt;通过上个章节我们已经对调用栈和 JavaScript 的同步执行有了基本的了解，现在来看看 JavaScript 异步执行是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是阻塞？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 JavaScript 是单线程的，如果某个函数耗费的时间比较长，会阻塞后面的任务执行，这就造成了阻塞。解决阻塞最简单的方法是函数直接返回不等待，使用异步回调来处理返回结果。&lt;/p&gt;
&lt;p&gt;在了解 JavaScript 异步执行之前还需要知道一些概念，&lt;strong&gt;事件循环和回调队列（也称为任务队列或消息队列）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/56b9683b8c6659218dc96bf5ac31ad843ef.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：Event Loop 、Web APIs 和 Message Queue 并不是 JavaScript 引擎的一部分，而是浏览器运行时环境和 Nodejs 运行时环境的一部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们以下面代码为例，解释异步代码是如何执行的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const networkRequest =（）=&amp;gt; { 
  setTimeout（（）=&amp;gt; { 
    console.log（'Async Code'）; 
  }，2000）; 
};
console.log（'Hello World'）;
networkRequest（）;
console.log('The End');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/0334c70d58230f73d4f2863b4036e6663c7.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当上述程序加载到浏览器时 console.log(‘Hello World’) 代码执行时会一次在调用栈推入和弹出。遇到 networkRequest() 将其推入到调用栈顶。然后继续将 networkRequest 内的 setTimeout 方法推入栈顶，随后 setTimeout networkRequest 依次出栈。最后对 console.log(‘The End’) 进行入栈出栈。&lt;/p&gt;
&lt;p&gt;当 timer 到期后会将 callback 推入 message queue（消息队列）中，此时 callback 不会马上执行。会等待事件循环调度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事件循环的作用是查看调用栈并确定调用栈是否空闲。如果调用栈空闲，even loop 会查看消息队列是否有待处理的 callback 需要触发。例子中的消息队列只包含一个 callback，当调用栈为空的时候，even loop 会将 callback 推入调用栈中触发 networkRequest 的回调。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOM 事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息队列还会包含来自 DOM 的事件回调，比如鼠标和键盘事件回调。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;document.querySelector('.btn').addEventListener('click',function callback(event) {
  console.log('Button Clicked');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于 DOM 事件，当具体的事件触发会将 callback 推入消息队列中，等待 even loop 来调度执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ES6 job queue/micro-task queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ES6 新增了 job queue/micro-task queue 概念，在 Promise 中用到。job queue 比 message queue 拥有更高的优先级。意味着 job queue 和 message queue 都有任务时会优先执行 job queue 中的任务。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log('Script start');

// callback 在 message queue 中
setTimeout(function callback() {
  console.log('setTimeout');
}, 0);

// 任务在 micro-task queue 中
new Promise((resolve, reject) =&amp;gt; {
    resolve('Promise resolved');
  }).then(res =&amp;gt; console.log(res))
    .catch(err =&amp;gt; console.log(err));
console.log('Script End');

// 输出：
Script start
Script End
Promise resolved
setTimeout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看下一个例子(两个 setTimeout 和 两个 Promise)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log('Script start');
setTimeout(() =&amp;gt; {
  console.log('setTimeout 1');
}, 0);
setTimeout(() =&amp;gt; {
  console.log('setTimeout 2');
}, 0);
new Promise((resolve, reject) =&amp;gt; {
    resolve('Promise 1 resolved');
  }).then(res =&amp;gt; console.log(res))
    .catch(err =&amp;gt; console.log(err));
new Promise((resolve, reject) =&amp;gt; {
    resolve('Promise 2 resolved');
  }).then(res =&amp;gt; console.log(res))
    .catch(err =&amp;gt; console.log(err));
console.log('Script End');


//输出为
Script start
Script End
Promise 1 resolved
Promise 2 resolved
setTimeout 1
setTimeout 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见 micro-task queue 中的所有任务都会优先于 message queue 中的任务执行。&lt;/p&gt;
&lt;blockquote readability=&quot;0.65217391304348&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://link.zhihu.com/?target=https://blog.bitsrc.io/understanding-asynchronous-javascript-the-event-loop-74cd408419ff&quot;&gt;Understanding Asynchronous JavaScript — the Event Loop&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 05 Dec 2018 14:41:00 +0000</pubDate>
<dc:creator>极光推送</dc:creator>
<og:description>简评：如果你对 JavaScript 异步的原理感兴趣，这里有一篇不错的介绍。 JavaScript 同步代码是如果工作的 在介绍 JavaScript 异步执行之前先来了解一下， JavaScrip</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpush88/p/10073979.html</dc:identifier>
</item>
<item>
<title>laravel5实现第三方登录(微信) - 如是说</title>
<link>http://www.cnblogs.com/lishanlei/p/10073878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lishanlei/p/10073878.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;最近手头一个项目需要实现用户在网站的第三方登录(微信和微博)，后端框架laravel5.4。&lt;/p&gt;
&lt;p&gt;实现过程以微信网页版第三方登录，其他于此类似，在此不做重复。&lt;/p&gt;

&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;p&gt;网站应用微信登录是基于OAuth2.0协议标准构建的微信OAuth2.0授权登录系统。&lt;br/&gt;在进行微信OAuth2.在进行微信OAuth2.0授权登录接入之前，在微信开放平台注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的AppID和AppSecret，申请微信登录且通过审核后，可开始接入流程。&lt;/p&gt;
&lt;p&gt;总结下来就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进入微信开放平台注册开发者账号&lt;/li&gt;
&lt;li&gt;根据项目类型创建应用，再此我创建的是网站应用.&lt;/li&gt;
&lt;li&gt;接入微信登陆功能，让用户可使用微信登录你的网站应用&lt;/li&gt;
&lt;li&gt;获得AppID和AppSectet&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到此微信第三方登录的准备工作就完成了。&lt;/p&gt;

&lt;h2&gt;授权流程说明&lt;/h2&gt;
&lt;p&gt;1. 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；&lt;br/&gt;2. 通过code参数加上AppID和AppSecret等，通过API换取access_token；&lt;br/&gt;3. 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;14&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://res.wx.qq.com/op_res/D0wkkHSbtC6VUSHX4WsjP5ssg5mdnEmXO8NGVGF34dxS9N1WCcq6wvquR4K_Hcut&quot; alt=&quot;&quot; width=&quot;800&quot; data-cke-saved-src=&quot;https://res.wx.qq.com/op_res/D0wkkHSbtC6VUSHX4WsjP5ssg5mdnEmXO8NGVGF34dxS9N1WCcq6wvquR4K_Hcut&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://res.wx.qq.com/op_res/D0wkkHSbtC6VUSHX4WsjP5ssg5mdnEmXO8NGVGF34dxS9N1WCcq6wvquR4K_Hcut&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;800&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;在框架中实现(laravel)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Laravel Socialite简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了传统的基于表单的登录认证外，Laravel 还可以通过 &lt;a href=&quot;https://github.com/laravel/socialite&quot; data-cke-saved-href=&quot;https://github.com/laravel/socialite&quot;&gt;Laravel Socialite&lt;/a&gt; 提供 OAuth 认证，目前支持的认证驱动包括 Facebook、Twitter、Google、LinkedIn、GitHub 和 Bitbucket。&lt;/p&gt;
&lt;p&gt;安装相关依赖&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;相关配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 设置app/config.php&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加providers：&lt;/p&gt;

&lt;p&gt;添加aliases：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;２. 配置config/services.php&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 设置app/Providers/EventServiceProvider.php&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加事件监听&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;strong&gt;４. 添加路由&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 编写WeixinController&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;访问auth/weixin，获得返回数据。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201942/201812/1201942-20181205222433897-761909055.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;常见错误&lt;/h3&gt;
&lt;p&gt;１. 微信授权回调域不符(redirect_uri不符)，参见下面规范：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3183838619,1017775252&amp;amp;fm=170&amp;amp;s=0C607432190F744D5C6194DA0000C0B3&amp;amp;w=640&amp;amp;h=612&amp;amp;img.JPEG&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3183838619,1017775252&amp;amp;fm=170&amp;amp;s=0C607432190F744D5C6194DA0000C0B3&amp;amp;w=640&amp;amp;h=612&amp;amp;img.JPEG&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3183838619,1017775252&amp;amp;amp;fm=170&amp;amp;amp;s=0C607432190F744D5C6194DA0000C0B3&amp;amp;amp;w=640&amp;amp;amp;h=612&amp;amp;amp;img.JPEG&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. 执行过程中出现一下错误：&lt;/p&gt;

&lt;p&gt;解决：&lt;/p&gt;
&lt;p&gt;通过stateless()方法禁止会话状态验证&lt;/p&gt;


&lt;p&gt;其他第三方登录在此不做赘述。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Dec 2018 14:25:00 +0000</pubDate>
<dc:creator>如是说</dc:creator>
<og:description>背景 最近手头一个项目需要实现用户在网站的第三方登录(微信和微博)，后端框架laravel5.4。 实现过程以微信网页版第三方登录，其他于此类似，在此不做重复。 准备工作 网站应用微信登录是基于OAu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lishanlei/p/10073878.html</dc:identifier>
</item>
<item>
<title>ThreadPoolExecutor线程池任务执行失败的时候会怎样 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/10073838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/10073838.html</guid>
<description>&lt;p&gt;&lt;span&gt;接上一篇 《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cjsblog/p/8214921.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JDK1.8中的线程池&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.  任务执行失败时的处理逻辑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1.  Worker&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Worker相当于线程池中的线程&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205211047958-865167183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;可以看到，Worker有几个重要的属性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;thread ： 这是Worker运行的线程，可以理解为一个Worker就是一个线程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;firstTask ： 初始任务，可能为为null&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;completedTasks ： Worker完成的任务数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;同时，还应该注意到，在构造方法中给thread赋值为一个新线程。由于Worker实现了Runnable接口，也就是说它本身就是可执行的任务，当它启动的时候理所当然应该运行run()方法，而它的run()方法中调用了runWorker(this)方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2.  Worker是如何创建的&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205212346484-2106372900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205212547029-1043553549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;主要是：创建Workder对象，并将该对象加入到Worker集合中，最后启动Worker（PS：启动Worker中的线程是启动Worker）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.3.  runWorker(this)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205213404388-1558157810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205213343670-1476777371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;可以看到，创建线程的时候传的是this，this代表的是Worker对象，而Worker是一个Runnable，因此当调用线程的start()方法后执行的是Worker的run()方法，而Worker的run()方法里面调用的时候runWorker(this)，因此，接下来重点看一下runWorker(this)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205214312140-2015877015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如果task.run()方法抛异常，则会被catch捕捉到，但是catch又将异常抛出去了，外层的两个try没有捕获，跳出循环，执行3个finally&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们只看最后一个finally&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205215216380-1215182520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;看到这里，一切真相大白&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当任务执行失败后，该Workder会被从Worker集合中删除，然后，只要线程池当前还在继续处理任务，则重新创建一个新的Worker&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，&lt;span&gt;任务执行失败后，原来的Worker就死了，如果线程池还在继续处理任务，则再创建一个新的Worker&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.  拒绝策略&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205215708081-504980485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205215725008-536491916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181205220833659-876908210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;四种策略：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;直接抛异常（默认）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;什么也不做，也不抛异常&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果线程池当期处于RUNNING状态，则执行这个任务，否则什么也不做&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果线程池当前处于RUNNING状态，则删除队列头部的任务，然后将该任务加到工作任务队列中&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;3.  其它相关&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cjsblog/p/8214921.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JDK1.8中的线程池&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 05 Dec 2018 14:17:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<og:description>接上一篇 《JDK1.8中的线程池》 1. 任务执行失败时的处理逻辑 1.1. Worker Worker相当于线程池中的线程 可以看到，Worker有几个重要的属性： thread ： 这是Work</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/10073838.html</dc:identifier>
</item>
<item>
<title>React 特性剪辑(版本 16.0 ~ 16.9) - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/10073841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/10073841.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673bcf829ddb05c?w=640&amp;amp;h=280&amp;amp;f=jpeg&amp;amp;s=12258&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Before you're going to hate it, then you're going to love it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/5/1677eb37f03c3957?w=526&amp;amp;h=400&amp;amp;f=jpeg&amp;amp;s=31688&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;concurrent-render贯穿-16&quot;&gt;Concurrent Render(贯穿 16)&lt;/h3&gt;
&lt;p&gt;在 18年的 &lt;a href=&quot;https://www.youtube.com/watch?v=v6iR3Zk4oDY&quot;&gt;JSConf Iceland&lt;/a&gt; 上, Dan 神提到 Concurrent Render 涉及到 CPU 以及 IO 这两方面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/5/1677eb37efc8bc6a?w=877&amp;amp;h=400&amp;amp;f=jpeg&amp;amp;s=28039&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Time Slicing 对应解决左侧的问题, Suspense 对应解决了右侧的问题。它们共同要解决的是的提升用户体验, 在更多的场景下都可以做到&lt;code&gt;可交互&lt;/code&gt;。而 Fiber 架构是上述两者的基石。&lt;/p&gt;
&lt;h4 id=&quot;time-slicing&quot;&gt;Time Slicing&lt;/h4&gt;
&lt;p&gt;在 16 之前的版本的渲染过程可以想象成一次性潜水 30 米，在这期间做不了其它事情(Stack Reconciler);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/5/1677eb37f0233b62?w=270&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=5327&quot;/&gt;&lt;/p&gt;
&lt;p&gt;痛点概括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一次性渲染到底&lt;/li&gt;
&lt;li&gt;中途遇到优先级更高的事件无法调整相应的顺序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着拿上面的潜水例子为例，现在变为可以每次潜 10 米，分 3 个 chunk 进行; chunk 和 chunk 之间通过链表连接; chunk 间插入优先级更高的任务, 先前的任务被抛弃。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/5/1677eb37ef38974b?w=279&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=7075&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;开启 Fiber 后，获取异步数据的方法应放到 render 后面的生命周期钩子里(phase 2 阶段)进行, 因为 render 前面的生命周期钩子(phase 1阶段)会被执行多次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意: 并没有缩短原先组件的渲染时间(甚至还加长了)，但用户却能感觉操作变流畅了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.6736842105263&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2015/08/using-requestidlecallback&quot;&gt;requestIdleCallback()&lt;/a&gt;: 借力此 api, 浏览器能在空闲的时间处理低优先级的事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;suspense16.6-16.8-16.9&quot;&gt;Suspense(16.6, 16.8, 16.9)&lt;/h4&gt;
&lt;p&gt;Suspense 意思是能暂停当前组件的渲染, 当完成某件事以后再继续渲染。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;code splitting(16.6, 已上线): 文件懒加载。在此之前的实现方式是 &lt;a href=&quot;https://github.com/jamiebuilds/react-loadable&quot;&gt;react-loadable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;并发模式(16.8, 2019 年 Q2 季度): 在文件懒加载的同时能做其它交互;&lt;/li&gt;
&lt;li&gt;data fetching(16.9 版本, 2019 年中): 数据动态呈现;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React, { lazy, Suspense } from 'react'
const OtherComponent = lazy(() =&amp;gt; import('./OtherComponent'))

function MyComponent() {
  return (
    &amp;lt;Suspense fallback={&amp;lt;div&amp;gt;loading...&amp;lt;/div&amp;gt;}&amp;gt;
      &amp;lt;OtherComponent /&amp;gt;
    &amp;lt;/Suspense&amp;gt;
  )
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一种简单的预加载思路, 可参考 &lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;preload&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const OtherComponentPromise = import('./OtherComponent');
const OtherComponent = React.lazy(() =&amp;gt; OtherComponentPromise);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;render-新增的返回类型&quot;&gt;render 新增的返回类型&lt;/h3&gt;
&lt;p&gt;在 React16 版本中 render() 增加了一些返回类型，到目前为止支持的返回类型如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;React elements.&lt;/li&gt;
&lt;li&gt;Arrays and fragments.&lt;/li&gt;
&lt;li&gt;Portals.&lt;/li&gt;
&lt;li&gt;String and numbers.&lt;/li&gt;
&lt;li&gt;Booleans or null.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/react-component.html#render&quot;&gt;render&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 render() 支持返回 Arrays 能让我们少写一个父节点, 如下所示:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const renderArray = () =&amp;gt; [
  &amp;lt;div key=&quot;A&quot;&amp;gt;A&amp;lt;/div&amp;gt;
  &amp;lt;div key=&quot;B&quot;&amp;gt;B&amp;lt;/div&amp;gt;
]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.4545454545455&quot;&gt;
&lt;p&gt;render() 支持返回数组的特性类似 &lt;a href=&quot;https://reactjs.org/docs/fragments.html&quot;&gt;Fragments&lt;/a&gt;(16.2), 使用 Fragments 可以不用写 key。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;portals传送门&quot;&gt;Portals(传送门)&lt;/h3&gt;
&lt;p&gt;将 React 子节点渲染到指定的节点上&lt;/p&gt;
&lt;p&gt;案例：实现一个 Modal 组件，&lt;a href=&quot;https://codepen.io/gaearon/pen/yzMaBd&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外关于 Portals 做到冒泡到父节点的兄弟节点这个现象, &lt;a href=&quot;https://codepen.io/gaearon/pen/jGBWpE&quot;&gt;demo&lt;/a&gt;, 我想可以这样子实现：如果组件返回是 Portal 对象，则将该组件的父组件的上的事件 copy 到该组件上。其实并不是真的冒泡到了父节点的兄弟节点上。&lt;/p&gt;
&lt;h3 id=&quot;error-boundaries&quot;&gt;Error Boundaries&lt;/h3&gt;
&lt;p&gt;React 16 提供了一个新的错误捕获钩子 &lt;code&gt;componentDidCatch(error, errorInfo)&lt;/code&gt;, 它能将子组件生命周期里所抛出的错误捕获, 防止页面全局崩溃。&lt;a href=&quot;https://codepen.io/gaearon/pen/wqvxGa?editors=0010&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;componentDidCatch 并不会捕获以下几种错误&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件机制抛出的错误(事件里的错误并不会影响渲染)&lt;/li&gt;
&lt;li&gt;Error Boundaries 自身抛出的错误&lt;/li&gt;
&lt;li&gt;异步产生的错误&lt;/li&gt;
&lt;li&gt;服务端渲染&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;服务端渲染&quot;&gt;服务端渲染&lt;/h3&gt;
&lt;p&gt;服务端渲染一般是作为最后的优化手段, 这里浅显(缺乏经验)谈下 React 16 在其上的优化。&lt;/p&gt;
&lt;p&gt;在 React 16 版本中引入了 &lt;code&gt;React.hydrate()&lt;/code&gt;, 它的作用主要是将相关的事件&lt;code&gt;注水&lt;/code&gt;进 &lt;code&gt;html&lt;/code&gt; 页面中, 同时会比较前端生成的 &lt;code&gt;html&lt;/code&gt; 和服务端传到前端的 &lt;code&gt;html&lt;/code&gt; 的文本内容的差异, 如果两者不一致将前端产生的文本内容替换服务端生成的(忽略属性)。&lt;/p&gt;
&lt;h3 id=&quot;支持自定义属性&quot;&gt;支持自定义属性&lt;/h3&gt;
&lt;p&gt;在 React 16 版本中, 支持自定义属性(推荐 &lt;code&gt;data-xxx&lt;/code&gt;), 因而 React 可以少维护一份 attribute 白名单, 这也是 React 16 体积减少的一个重要因素。&lt;/p&gt;
&lt;h3 id=&quot;context16.316.6&quot;&gt;Context(16.3、16.6)&lt;/h3&gt;
&lt;p&gt;Context 相当于是用组件化的方式使用 global, 使用其可以共享认证的用户、首选语言(国际化)等一些全局的信息, 而不必通过组件一层层传递。&lt;/p&gt;
&lt;p&gt;以下是比较冗余的传递:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;Page riderId={riderId} /&amp;gt;
// ... which renders ...
&amp;lt;RiderDetail riderId={riderId} /&amp;gt;
// ... which renders ...
&amp;lt;RiderLevel riderId={riderId} /&amp;gt;
// ... which renders ...
&amp;lt;Avatar riderId={riderId} /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;Context&lt;/code&gt; 之前可以传递 &lt;code&gt;&amp;lt;Avatar&amp;gt;&lt;/code&gt; 本身(Component Composition 的思想), 写法如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Page(props) {
  const avatar = &amp;lt;Avatar riderId={props.riderId} /&amp;gt;
  return &amp;lt;RiderDetail avatar={avatar} /&amp;gt;
}

&amp;lt;Page riderId={riderId} /&amp;gt;
// ... which renders ...
&amp;lt;RiderDetail avatar={avatar} /&amp;gt;
// ... which renders ...
&amp;lt;RiderLevel avatar={avatar} /&amp;gt;
// ... which renders ...
{ props.avatar }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着是使用 &lt;code&gt;Context&lt;/code&gt; 书写的例子, 写法如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const RiderContext = React.createContext(1) // 这里为默认值

function Page(props) {
  const riderId = props.riderId
  return (
    &amp;lt;RiderContext.Provider value={riderId}&amp;gt;
      &amp;lt;RiderDetail /&amp;gt;
    &amp;lt;/RiderContext.Provider&amp;gt;
  )
}

function RiderDetail() {
  return &amp;lt;RiderLevel /&amp;gt;
}

class RiderLevel extends React.Component {
  static contextType = RiderContext
  render() {
    return &amp;lt;Avatar avatar={this.context} /&amp;gt;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新的生命周期16.3&quot;&gt;新的生命周期(16.3)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/5/1677eb37e1bc8744?w=1087&amp;amp;h=668&amp;amp;f=png&amp;amp;s=101814&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在未来 17 的版本中，将移除的生命周期钩子如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;componentWillMount()&lt;/code&gt;: 移除这个 api 基于以下两点考虑:
&lt;ul&gt;&lt;li&gt;服务端渲染: 在服务端渲染的情景下, componentWillMount 执行完立马执行 render 会导致 componentWillMount 里面执行的方法(获取数据, 订阅事件) 并不一定执行完;&lt;/li&gt;
&lt;li&gt;Concurrent Render: 在 fiber 架构下, render 前的钩子会被多次调用, 在 componentWillMount 里执行订阅事件就会产生内存泄漏;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;迁移思路, 将以前写在 &lt;code&gt;componentWillMount&lt;/code&gt; 的获取数据、时间订阅的方法写进 &lt;code&gt;componentDidMount&lt;/code&gt; 中;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;componentWillReceiveProps(nextProps)&lt;/code&gt;: 移除这个 api 基于如下考虑:
&lt;ul&gt;&lt;li&gt;语义不太契合逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子: 比如切换 tab 时都要重新获取当前页面的数据, 之前通常会这么做:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;componentWillReceiveProps(nextProps) {
  if (nextProps.riderId !== this.props.riderId) {
    fetchData()
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的钩子 &lt;code&gt;getDerivedStateFromProps()&lt;/code&gt; 更加纯粹, 它做的事情是将新传进来的属性和当前的状态值进行对比, 若不一致则更新当前的状态。之前 &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; 里的获取数据的逻辑之前提到 &lt;code&gt;Concurrent render&lt;/code&gt; 的时候也提到了应该后置到 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 中。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;getDerivedStateFromProps(nextProps, prevState) {
  if (nextProps.riderId !== prevState.riderId) {
    return {
      riderId: nextProps.riderId
    }
  }
  // 返回 null 则表示 state 不用作更新
  return null
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;componentWillUpdate()&lt;/code&gt;: 目前将其理解为和 &lt;code&gt;componentWillMount&lt;/code&gt; 一样的情况&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 React 16.3 的版本中，新加入了两个生命周期:&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;getDerivedStateFromProps(nextProps, prevState)&lt;/code&gt;: 更加语义化, 用来替代 &lt;code&gt;componentWillMount()&lt;/code&gt; 和 &lt;code&gt;componentWillReceiveProps(nextProps)&lt;/code&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;getSnapshotBeforeUpdate(prevProps, prevState)&lt;/code&gt;: 可以将该钩子返回的结果传入 componentDidUpdate 的第三个参数中, 从而达到 dom 数据统一。用来替代 componentWillUpdate();&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;2.1590909090909&quot;&gt;
&lt;p&gt;具体 demo 可见 &lt;a href=&quot;https://react.docschina.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state&quot;&gt;Update on Async Rendering&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;react.memo16.6&quot;&gt;React.memo(16.6)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;React.memo&lt;/code&gt; 是一个高阶组件, 它使无状态组件拥有有状态组价中的 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 以及 &lt;code&gt;PureComponent&lt;/code&gt; 的能力。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const MyComponent = React.memo(function MyComponent(props) {
  ...
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hooks16.7&quot;&gt;Hooks(16.7)&lt;/h3&gt;
&lt;p&gt;在 React 16.7 之前，React 有两种形式的组件，有状态组件(类)和无状态组件(函数)。Hooks 的意义就是赋能先前的无状态组件，让之变为有状态。这样一来更加契合了 React 所推崇的函数式编程。&lt;/p&gt;
&lt;p&gt;接下来梳理 Hooks 中最核心的 2 个 api, &lt;code&gt;useState&lt;/code&gt; 和 &lt;code&gt;useEffect&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;usestate&quot;&gt;useState&lt;/h4&gt;
&lt;p&gt;useState 返回状态和一个更新状态的函数&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const [count, setCount] = useState(initialState)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Hooks 相比之前用 class 的写法最直观的感受是更为简洁&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function App() {
  const [count, setCount] = useState(0)

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;p&amp;gt;You clicked {count} times&amp;lt;/p&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;useeffectfn&quot;&gt;useEffect(fn)&lt;/h4&gt;
&lt;p&gt;在每次 render 后都会执行这个钩子。可以将它当成是 &lt;code&gt;componentDidMount&lt;/code&gt;、&lt;code&gt;componentDidUpdate&lt;/code&gt;、&lt;code&gt;componentWillUnmount&lt;/code&gt; 的合集。因此使用 useEffect 比之前优越的地方在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以避免在 &lt;code&gt;componentDidMount、componentDidUpdate&lt;/code&gt; 书写重复的代码;&lt;/li&gt;
&lt;li&gt;可以将关联逻辑写进一个 &lt;code&gt;useEffect&lt;/code&gt;;(在以前得写进不同生命周期里);&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;react-的未来&quot;&gt;React 的未来&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/5/1677eb37f11757a3?w=365&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=9405&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今年的 React Conf 的一张图, 可以看到 React 从出来到现在势头呈稳健上升趋势, 并在 2018 年这个节点上把 Jquery 拉下了王座。但可以看见 React 未来还有一段很长的路要走。&lt;/p&gt;
&lt;h3 id=&quot;相关链接&quot;&gt;相关链接&lt;/h3&gt;
</description>
<pubDate>Wed, 05 Dec 2018 14:17:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<og:description>Before you're going to hate it, then you're going to love it. Concurrent Render(贯穿 16) 在 18年的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/10073841.html</dc:identifier>
</item>
<item>
<title>WinForm版图像编辑小程序（实现图像拖动、缩放、旋转、抠图） - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/multi_pic_edit.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/multi_pic_edit.html</guid>
<description>&lt;p&gt;闲暇之余，开发一个图片编辑小程序。程序主要特点就是可方便的对多个图像编辑，实现了一些基本的操作。本文主要介绍一下程序的功能、设计思路。&lt;/p&gt;
&lt;p&gt;执行程序 下载地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1cszsgjKN9ecWZ9sm1hDAdQ&quot; target=&quot;_blank&quot;&gt;百度网盘&lt;/a&gt;。https://pan.baidu.com/s/1cszsgjKN9ecWZ9sm1hDAdQ &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://download.csdn.net/download/qq_29939347/10831160&quot; target=&quot;_blank&quot;&gt;CSDN&lt;/a&gt;       https://download.csdn.net/download/qq_29939347/10831160&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1功能介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;程序主界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181205205941379-424473005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击打开图片，可选择多个图片文件。图片缩略图左侧显示，双击左侧图片，添加到编辑区。&lt;/p&gt;
&lt;p&gt;图片编辑区分为：纸张区域和打印区域。图片只能在打印区编辑。当选中这两个区，可调整各个区的大小。&lt;/p&gt;
&lt;p&gt; 主要功能点：&lt;/p&gt;
&lt;p&gt;1 拖动：选中图片后，可以任意拖动图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181205210838210-1916560197.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 缩放：可对图片左右上下实现缩放。可以锁定显示比例缩放。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181205211156419-772512212.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3 旋转，可以选择旋转基点再旋转。如果不选择旋转基点，以对角为基点旋转。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181205211714408-961588622.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181205212738380-1729822574.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4 抠图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181205211905820-1125188931.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5 其他一些操作&lt;/p&gt;
&lt;p&gt;当有多个图片相互覆盖时，可以调整图层。&lt;/p&gt;
&lt;p&gt;选中一个图片后，可以对图片的位置、大小、旋转角度调整。&lt;/p&gt;
&lt;p&gt;选择保存，会将编辑的图片保存为文件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 2 处理思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  图片编辑信息&lt;/strong&gt;&lt;/span&gt; 每个图像都有对应的变量记录该图像的详细，比如位置、尺寸、旋转角度、剪切区域。见下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageProperty
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Image EditImage { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始图片&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ActualWidth =&amp;gt; EditImage.Width; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际尺寸&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ActualHeight =&amp;gt;&lt;span&gt; EditImage.Height;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ShowImageTip { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; LockSizeRate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比例是否锁定&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Size DrawSize { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示尺寸&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Tag { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageEditInfo
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ImageProperty ImageProperty { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Point Location { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于打印区的位置&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Point LocationTopRight =&amp;gt; &lt;span&gt;new&lt;/span&gt; Point(Location.X +&lt;span&gt; Width, Location.Y);
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Point LocationBottomRight =&amp;gt; &lt;span&gt;new&lt;/span&gt; Point(Location.X + Width, Location.Y +&lt;span&gt; Height);
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Point LocationBottomLeft =&amp;gt; &lt;span&gt;new&lt;/span&gt; Point(Location.X, Location.Y +&lt;span&gt; Height);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RightX =&amp;gt; Location.X +&lt;span&gt; Width;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ButtomY =&amp;gt; Location.Y +&lt;span&gt; Height;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Size DrawSize
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ImageProperty.DrawSize; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { ImageProperty.DrawSize =&lt;span&gt; value; }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Image Image =&amp;gt;&lt;span&gt; ImageProperty.EditImage;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; RotateAngle { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转角度&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsSelect { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; LockSizeRate  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示比例是否锁定&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ImageProperty.LockSizeRate;
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                ImageProperty.LockSizeRate &lt;/span&gt;=&lt;span&gt; value;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Width
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DrawSize.Width;
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                ImageProperty.DrawSize &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(value, DrawSize.Height);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Height
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DrawSize.Height;
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                ImageProperty.DrawSize &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(DrawSize.Width, value);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ShowImageTip
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ImageProperty.ShowImageTip; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { ImageProperty.ShowImageTip =&lt;span&gt; value; }
        } 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Point? RotatioBasePoint { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转基点&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; Point RotatioBasePointValue =&amp;gt;&lt;span&gt; RotatioBasePoint.Value;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasRotatioBasePoint =&amp;gt; (RotatioBasePoint != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; RotatioBasePoint.HasValue);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图片旋转&lt;/strong&gt;&lt;/span&gt; 对正常的图片移动、缩放并不难。只要调整图像的长宽、位置就行，基本就是加法减法计算。如果图片有旋转，计算起来就麻烦。比如判断鼠标是否点击了图片、鼠标缩放等，实现这些操作都麻烦。&lt;/p&gt;
&lt;p&gt;比如判断鼠标是否点击了图片，如果一个图片是斜的（旋转后的），如何处理？我的思路是旋转：将图片和鼠标所在的点都反向旋转；此后，判断逻辑就和常规方法一样了。旋转函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; pointMove相对于removeAt，以一定角度旋转
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pointMove&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;removeAt&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;rotateAngle&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;clockwise&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Point RotationAt(Point pointMove, Point removeAt, &lt;span&gt;double&lt;/span&gt; rotateAngle, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; clockwise)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rotateAngle == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pointMove;

            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (matrix)
            {
                matrix.Reset();
                matrix.Rotate((&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;)(clockwise ? rotateAngle : -&lt;span&gt;rotateAngle));

                Point pt2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(pointMove.X - removeAt.X, pointMove.Y -&lt;span&gt; removeAt.Y);
                Point[] pts &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point[] { &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point(pt2.X, pt2.Y) };
                matrix.TransformPoints(pts);

                Point result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(pts[&lt;span&gt;0&lt;/span&gt;].X + removeAt.X, pts[&lt;span&gt;0&lt;/span&gt;].Y +&lt;span&gt; removeAt.Y);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
        }

 &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt;&lt;span&gt; EN_LinePart MouseMove_HitTest(Point pt)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标位置 反向旋转，&lt;/span&gt;
            pt = DrawHelper.RotationAt(pt, Location, RotateAngle, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面就是 和正常判断逻辑一样&lt;/span&gt;
            EN_LinePart result =&lt;span&gt; MouseMove_HitTest_Corner(pt);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result !=&lt;span&gt; EN_LinePart.无)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;画图：&lt;/span&gt;&lt;/strong&gt;对图片相关参数修改后，需要调用refresh，强制重画。调用GDI+。根据图片在列表的顺序调用（也就是根据图层）。调用时，根据设定显示区域，旋转角度等，做变换后再画。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;void&lt;/span&gt; DrawWithRotation(Graphics g, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; saveToFile)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置质量&lt;/span&gt;
&lt;span&gt;            ImageHelper.SetHighQuality(g);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;置背景色&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;saveToFile)
                g.Clear(BackgroundColor);

            ImageEditInfo selectImage &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (ImageEditInfo imageInfo &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ImageGroup.ListImageToDraw)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画图片&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (imageInfo.IsSelect)
                {
                    Debug.Assert(selectImage &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    selectImage &lt;/span&gt;=&lt;span&gt; imageInfo;
                }

                g.TranslateTransform(imageInfo.Location.X, imageInfo.Location.Y);
                g.RotateTransform(imageInfo.RotateAngle);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否需要画 抠图&lt;/span&gt;
                Image imageToDraw =&lt;span&gt; imageInfo.Image;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (imageInfo.CutStat ==&lt;span&gt; ImageCutStat.have_cut
                    &lt;/span&gt;&amp;amp;&amp;amp; imageInfo.CutPoints.Count &amp;gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    Bitmap bitmap &lt;/span&gt;= imageToDraw &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Bitmap;
                    System.Windows.Point[] points &lt;/span&gt;= imageInfo.CutPoints.Select(o =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Point(o.X,o.Y)).ToArray();
                    Bitmap cutBitmap &lt;/span&gt;=&lt;span&gt; ImageCutout.GetImage(bitmap, points);
                    imageToDraw &lt;/span&gt;=&lt;span&gt; cutBitmap;
                }

                g.DrawImage(imageToDraw,
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Rectangle(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, imageInfo.DrawSize.Width, imageInfo.DrawSize.Height),
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Rectangle(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, imageInfo.Image.Width, imageInfo.Image.Height),
                      GraphicsUnit.Pixel);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画旋转基点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!saveToFile &amp;amp;&amp;amp;&lt;span&gt; imageInfo.HasRotatioBasePoint)
                {
                    Point pt &lt;/span&gt;=&lt;span&gt; imageInfo.RotatioBasePointValue;
                    g.FillEllipse(RotatioBaseBrush, pt.X &lt;/span&gt;- RotatioBaseRadius, pt.Y - RotatioBaseRadius, RotatioBaseRadius * &lt;span&gt;2&lt;/span&gt;, RotatioBaseRadius * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示信息&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!saveToFile &amp;amp;&amp;amp;&lt;span&gt; imageInfo.ShowImageTip)
                {                
                    ImageProperty ImageProperty &lt;/span&gt;=&lt;span&gt; imageInfo.ImageProperty;
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; info = &lt;span&gt;string&lt;/span&gt;.Format($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;({imageInfo.Location.X},{imageInfo.Location.Y}) ({ImageProperty.ActualWidth}X{ImageProperty.ActualHeight}--{imageInfo.DrawSize.Width}X{imageInfo.DrawSize.Height}) (∠{imageInfo.RotateAngle.ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    SizeF sizeF &lt;/span&gt;=&lt;span&gt; g.MeasureString(info, _drawProperty.TxtFont);
                    g.FillRectangle(_drawProperty.TxtBackgroundBrush,
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RectangleF(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point(), sizeF));

                    g.DrawString(info, _drawProperty.TxtFont, _drawProperty.TxtBrush, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point());
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画抠图线&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;saveToFile
                    &lt;/span&gt;&amp;amp;&amp;amp; imageInfo.CutStat ==&lt;span&gt; ImageCutStat.in_cuting
                    &lt;/span&gt;&amp;amp;&amp;amp; imageInfo.CutPoints.Count&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt; imageInfo.CutPoints.Count;i++&lt;span&gt; )
                    {
                        g.DrawLine(SelectBorderPen, imageInfo.ToDestImage(imageInfo.CutPoints[i&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
                            imageInfo.ToDestImage(imageInfo.CutPoints[i]));
                    }

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(imageInfo.CutPoints.Count &amp;gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                    {
                        g.DrawLine(SelectBorderPen, imageInfo.ToDestImage(imageInfo.CutPoints.First()),
                            imageInfo.ToDestImage(imageInfo.CutPoints.Last()));
                    }
                }

                g.ResetTransform();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画选中状态 &lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!saveToFile  &amp;amp;&amp;amp; selectImage != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                DrawSelectImageWithRotation(g, selectImage);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记：&lt;/strong&gt;&lt;/span&gt;一般来讲，图像的处理属于比较难的操作。需要有空间想象能力，相应的几何数学基础。不过，如果掌握好了图像操作，对了解控件原理很有帮助。当遇到难以实现的界面，gdi+就是最后的手段；winform也是微软过时的技术了，使用winform作图效率很难提高；为了响应的事件，不停重画，效率很低。WPF对图像的操作又进了一步，wpf属于“保持模型”，就是你告诉操作系统你要画什么就行了，只需要告诉一次。而对于winform，操作系统不停的告诉你，你需要重画了。这就导致winform画图效率比较低，但是省了内存。&lt;/p&gt;

</description>
<pubDate>Wed, 05 Dec 2018 14:15:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>闲暇之余，开发一个图片编辑小程序。程序主要特点就是可方便的对多个图像编辑，实现了一些基本的操作。本文主要介绍一下程序的功能、设计思路。 执行程序 下载地址： 百度网盘。https://pan.baid</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/multi_pic_edit.html</dc:identifier>
</item>
<item>
<title>程序员如何讲清楚技术方案 - owenandhisfriends</title>
<link>http://www.cnblogs.com/owenandhisfriends/p/10073821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/owenandhisfriends/p/10073821.html</guid>
<description>&lt;p&gt;最近在评审技术方案，和代码review的时候，遇到刚入行的同学们，很多都讲不清楚技术方案。&lt;/p&gt;
&lt;p&gt;具体表现是：&lt;br/&gt;– 上来不说需求，直接说算法实现。台下一头雾水，根本不知道设计方案是否合理。&lt;br/&gt;– 描述完需求后，又直接看代码，看表结构，没有交代流程。&lt;br/&gt;– 比较简单的算法，描述的特别绕，让人听不懂。被别人指出后，觉得这东西这么简单，你们为什么听不懂，还很委屈。&lt;br/&gt;– 直接说术语，不给解释。还有自己造术语不给解释的，更混乱的是「复用」已有的术语，让大家理解都不同。&lt;/p&gt;
&lt;p&gt;那么程序员如何把技术方案讲清楚呢？下面从实用的角度教大家一些小技巧，在短时间内具备讲清楚的能力。在文末给出通用的方法论学习书籍，供长线学习，达到把所有事情都能交代清楚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、要先交代需求背景。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么要做这个需求，对于实现的要求是什么，产品经理提了哪些边界条件。没有银弹，一个技术方案的好坏与实现要求息息相关，是不能脱钩的。例如，一个接口访问质量统计系统，可以接受一天跑一次脚本生成数据。但是为用户提供服务的消费明细，肯定要能实时展示，并且不能出错。&lt;/p&gt;
&lt;p&gt;在评审中，消耗时间比较多的，就是台下的听众问被评审人需求背景。还有台下的人给出了某个建议，然后被被评审人否定，说有个产品的要求我刚才没说。这时对提出建议的人来说，是很伤的。&lt;/p&gt;
&lt;p&gt;交代好背景并对齐，是评审技术方案和代码review的基础，否则别人不知道你后面的是否合理，甚至不知道你到底在做什么。技术方案评审就无从谈起了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、介绍技术方案整体架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;背景知识说完后，说你的做法。要先总后分，先从整体介绍架构设计。有哪些模块，各自负责什么职责，如何衔接……让大家有个整体认识，看到哪部分是主要矛盾，大家把80%的精力花费在20%的重要模块上评审，好钢用在刀刃上。&lt;/p&gt;
&lt;p&gt;例如一个发奖活动，最重要的模块是发奖抽奖模块，但是上来不讲整体，而是先讲展示活动规则的模块，而且用掉了大半的时间，是很浪费人力的。&lt;/p&gt;
&lt;p&gt;整体架构的描述用架构图、流程图，加上简练的语言，交代明白即可。一般都有架构模板，直接按照模板的要求，参考已有的优秀例子，都不会有大问题。最重要的是这块要先讲，先交代清楚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、介绍协议、库表设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整体方案介绍完之后，介绍协议和数据库表设计，开始逐步深入细节。因为这块设计的是否合理，对程序的效率影响比较大。&lt;/p&gt;
&lt;p&gt;分清哪些协议、表是重要的，着重讲，其他不太重要的快速讲。&lt;/p&gt;
&lt;p&gt;协议的执行流程，要交代清晰，整个协议是怎么在各个模块中流转的，到具体数据修改时，是如何和已有表结构串联起来的。这也是程序执行的流程，如果讲不清楚，会深度怀疑你是否能实现清楚。&lt;/p&gt;
&lt;p&gt;这部分要注意，尽量少说术语。因为大家的背景知识不同，一些专门术语大家是不知道的，你要用直白的话语让大家听明白。&lt;/p&gt;
&lt;p&gt;例如：有人在描述协议流程时说「我调用server提供的123号命令，返回成功后，把数据库的state字段改为2，就完成发奖了」。但是你说的123是干什么的，state是什么意思，2是什么状态？&lt;/p&gt;
&lt;p&gt;大家的疑问太多了，好的说法应该是，「我调用server提供的123号发奖的协议，返回成功后，把数据库中该用户的发奖状态，更新为已发奖」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、描述分支和异常逻辑，讲解代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过前面几部的讲解，方案基本上讲完了。剩下的就是讲分支逻辑，和异常逻辑。一份代码写的好不好，程序员是否有经验，主要是看对于异常处理是否到位。&lt;/p&gt;
&lt;p&gt;这部分从架构上主要讲容灾、鲁棒性，例如某个server死掉了，或者某个模块频繁请求，你的系统是否有预警，能够兼容。说白了就是要讲解系统的边界条件和服务能力。&lt;/p&gt;
&lt;p&gt;最后上代码，如果是代码review，在这个时候才开始说你的代码。虽然看的时间比较晚，但是大家都知道你的代码是什么功能了，看的速度也会加快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、复盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次评审后，要自己复盘，总结。别人都问题哪些问题，为什么要问？哪些问题是我应该交代没交代的，让人家问了？哪些是我方案的问题，别人提出的挑战？&lt;/p&gt;
&lt;p&gt;对于自己没交代的，思考为什么会漏，如果能提前讲清楚，是否能节约很多时间。&lt;/p&gt;
&lt;p&gt;根本的心法就是要有同理心。从对方的角度思考，这个问题他会了解吗，我不说他明白吗？&lt;strong&gt;方案评审重要的不是你说完，而是别人听懂。&lt;/strong&gt;关注台下人的反应，你的任务不是讲，而是让大家听明白。不是一个劲的说，而是要让大家都理解你的意思，这样别人才能帮你。否则别人会一直问问题，挑战你，最后否定你的方案。&lt;/p&gt;
&lt;p&gt;千万不要觉得听众好笨，这么简单都不明白，如果台下的人都不明白，那么一定是你错了。能力强的人是能够把难题讲解的很简单的。美国有专门负责科普的作家，把复杂的科学知识做到「老妪能解」。台下评审的人都是身经百战的，如果他们都反映听不懂，那么会是谁的问题呢？&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;技术方案讲解要先交代背景，再讲整体架构，再细化流程。先主线，再分支，先正确路径，再异常逻辑。要在听众的角度去讲，尽量直白简单，能够让不懂技术的人听懂才是最好的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;br/&gt;通用的方法论可以学习《金字塔原理》《问题的分析与解决》中的SCQA、MECE等方法，这些才是根本，要努力学习和刻意练习才能够掌握。&lt;/p&gt;
&lt;hr/&gt;

&lt;div&gt;&lt;img src=&quot;http://www.owenzhang.net/blog/wp-content/uploads/2018/08/qrcode.png&quot; alt=&quot;欢迎收听公众号&quot; align=&quot;middle&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 05 Dec 2018 14:14:00 +0000</pubDate>
<dc:creator>owenandhisfriends</dc:creator>
<og:description>最近在评审技术方案，和代码review的时候，遇到刚入行的同学们，很多都讲不清楚技术方案。 具体表现是：– 上来不说需求，直接说算法实现。台下一头雾水，根本不知道设计方案是否合理。– 描述完需求后，又</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/owenandhisfriends/p/10073821.html</dc:identifier>
</item>
</channel>
</rss>