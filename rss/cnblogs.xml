<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis哨兵（Sentinel）模式快速入门 - 全菜工程师小辉</title>
<link>http://www.cnblogs.com/mseddl/p/11495405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mseddl/p/11495405.html</guid>
<description>&lt;p&gt;更多内容，欢迎关注微信公众号：全菜工程师小辉。公众号回复关键词，领取免费学习资料。&lt;/p&gt;
&lt;p&gt;当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。 所以更多时候，我们优先考虑哨兵(sentinel) 模式。&lt;/p&gt;
&lt;p&gt;Redis sentinel是Redis高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。从Redis的2.6版本开始提供的，但是当时这个版本的模式是不稳定的，直到Redis的2.8版本以后，这个哨兵模式才稳定下来，在生产环境中，如果想要使用Redis的哨兵模式，也会尽量使用Redis的2.8版本之后的版本。&lt;/p&gt;
&lt;p&gt;哨兵虽然有一个单独的可执行文件Redis-sentinel ，但实际上它只是一个运行在特殊模式下的 Redis服务器，你可以在启动一个普通Redis服务器时通过给定&lt;code&gt;--sentinel&lt;/code&gt;选项来启动哨兵，哨兵的一些设计思路和zookeeper非常类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190910085844408-294742149.png&quot; alt=&quot;Redis哨兵模式&quot;/&gt;&lt;/p&gt;

&lt;p&gt;sentinel机制中有三种重要的定时任务。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每10秒每个sentinel对master和slave执行info&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发现slave节点。&lt;/li&gt;
&lt;li&gt;确认主从关系。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;每2秒每个sentinel通过master节点的channel交换信息(pub/sub)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;互相通信掌握节点的信息和自身信息，可以感知新加入的sentinel&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过master节点的__sentinel__:hello频道进行交互，所有sentinel订阅这个频道并每2秒向该频道发布信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;每1秒每个sentinel对其他sentinel和master，slave进行ping&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;心跳检测&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;主观下线&quot;&gt;主观下线&lt;/h2&gt;
&lt;p&gt;主观下线：单个sentinel节点对Redis节点通信失败的“偏见”。&lt;/p&gt;
&lt;p&gt;这是一种主观下线。因为在复杂的网络环境下，这个sentinel与这个master不通，但是如果master与其他的sentinel都是通的呢？所以是一种“偏见”。&lt;/p&gt;
&lt;p&gt;这是依靠的第三种定时：每秒去ping一下周围的sentinel和Redis。对于slave Redis,可以使用这个主观下线，因为他不需要进行故障转移；但是对于master Redis，必须使用客观下线。&lt;/p&gt;
&lt;h2 id=&quot;客观下线&quot;&gt;客观下线&lt;/h2&gt;
&lt;p&gt;客观下线：所有sentinel节点对master Redis节点失败“达成共识”（超过quorum个则统一，quorum可配置）。&lt;/p&gt;
&lt;p&gt;这是依靠的第二种定时：每两秒，sentinel之间进行“商量”（一个 sentinel 可以通过向另一个 sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）&lt;/p&gt;
&lt;p&gt;对于master redis的下线，必须要达成共识才可以，因为涉及故障转移，仅仅依靠一个sentinel判断是不够的&lt;/p&gt;

&lt;p&gt;当sentinel集群需要故障转移的时候会在集群中选出Leader执行故障转移操作。sentinel采用了Raft协议实现了sentinel间选举Leader的算法，不过也不完全跟论文描述的步骤一致。sentinel集群运行过程中故障转移完成，所有sentinel又会恢复平等。Leader仅仅是故障转移操作出现的角色。&lt;/p&gt;
&lt;h2 id=&quot;选举流程&quot;&gt;选举流程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;某个sentinel认定master客观下线的节点后，该sentinel会先看看自己有没有投过票，如果自己已经投过票给其他sentinel了，在2倍故障转移的超时时间自己就不会成为Leader。相当于它是一个Follower。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果该sentinel还没投过票，那么它就成为Candidate。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;和Raft协议描述的一样，成为Candidate，sentinel需要完成几件事情&lt;br/&gt;3.1 更新故障转移状态为start&lt;br/&gt;3.2 当前epoch加1，相当于进入一个新term，在sentinel中epoch就是Raft协议中的term。&lt;br/&gt;3.3 更新自己的超时时间为当前时间随机加上一段时间，随机时间为1s内的随机毫秒数。&lt;br/&gt;3.4 向其他节点发送is-master-down-by-addr命令请求投票。命令会带上自己的epoch。&lt;br/&gt;3.5 给自己投一票，在sentinel中，投票的方式是把自己master结构体里的leader和leader_epoch改成投给的sentinel和它的epoch。&lt;/li&gt;
&lt;li&gt;其他sentinel会收到Candidate的is-master-down-by-addr命令。如果sentinel当前epoch和Candidate传给他的epoch一样，说明他已经把自己master结构体里的leader和leader_epoch改成其他Candidate，相当于把票投给了其他Candidate。投过票给别的sentinel后，在当前epoch内自己就只能成为Follower。&lt;/li&gt;
&lt;li&gt;Candidate会不断的统计自己的票数，直到他发现认同他成为Leader的票数超过一半而且超过它配置的quorum（quorum可以参考《redis sentinel设计与实现》）。sentinel比Raft协议增加了quorum，这样一个sentinel能否当选Leader还取决于它配置的quorum。&lt;/li&gt;
&lt;li&gt;如果在一个选举时间内，Candidate没有获得超过一半且超过它配置的quorum的票数，自己的这次选举就失败了。&lt;/li&gt;
&lt;li&gt;如果在一个epoch内，没有一个Candidate获得更多的票数。那么等待超过2倍故障转移的超时时间后，Candidate增加epoch重新投票。&lt;/li&gt;
&lt;li&gt;如果某个Candidate获得超过一半且超过它配置的quorum的票数，那么它就成为了Leader。&lt;/li&gt;
&lt;li&gt;与Raft协议不同，Leader并不会把自己成为Leader的消息发给其他sentinel。其他sentinel等待Leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;当多个sentinel发现并确认了master有问题&lt;/li&gt;
&lt;li&gt;接着会选举出一个sentinel作为领导&lt;/li&gt;
&lt;li&gt;再选举出一个slave作为master&lt;/li&gt;
&lt;li&gt;通知其余的slave，新的master是谁&lt;/li&gt;
&lt;li&gt;通知客户端一个主从的变化&lt;/li&gt;
&lt;li&gt;最后，sentinel会等待旧的master复活，然后将新master成为slave&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么，如何选择“合适”的slave节点呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择slave-priority(slave节点优先级，人为配置)最高的slave节点，如果存在则返回，不存在则继续。&lt;/li&gt;
&lt;li&gt;其次会选择复制偏移量最大的slave节点(复制得最完整)，如果存在则返回，不存在则继续&lt;/li&gt;
&lt;li&gt;最后会选择run_id最小的slave节点(启动最早的节点)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;故障转移后客户端无法感知将无法保证正常的使用。所以，实现客户端高可用的步骤如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端获取sentinel节点集合&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190910085845265-1264156447.png&quot; alt=&quot;Redis哨兵模式&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端通过sentinel get-master-addr-by-name master-name这个api来获取对应主节点信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190910085846719-737461915.png&quot; alt=&quot;Redis哨兵模式&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端验证当前获取的“主节点”是真正的主节点，这样的目的是为了防止故障转移期间主节点的变化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190910085848783-891612354.png&quot; alt=&quot;Redis哨兵模式&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端保持和sentinel节点集合的联系，即订阅sentinel节点相关频道，时刻获取关于主节点的相关信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190910085849474-1384257786.png&quot; alt=&quot;Redis哨兵模式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的模型可以看出，Redis sentinel客户端只有在初始化和切换主节点时需要和sentinel进行通信来获取主节点信息，所以在设计客户端时需要将sentinel节点集合考虑成配置（相关节点信息和变化）发现服务。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;尽可能在不同物理机上和同一个网络部署Redis sentinel的所有节点&lt;/li&gt;
&lt;li&gt;Redis sentinel中的sentinel节点个数应该大于等于3且最好是奇数。（节点数多可以保证高可用）&lt;/li&gt;
&lt;li&gt;Redis sentinel中的数据节点和普通数据节点没有区别。每个sentinel节点在本质上还是一个Redis实例，只不过和Redis数据节点不同的是，其主要作用是监控Redis数据节点&lt;/li&gt;
&lt;li&gt;客户端初始化时连接的是sentinel节点集合，不再是具体的Redis节点，但sentinel只是配置中心不是代理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多内容，欢迎关注微信公众号：全菜工程师小辉。公众号回复关键词，领取免费学习资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190910085850720-1636355776.gif&quot; alt=&quot;哎呀，如果我的名片丢了。微信搜索“全菜工程师小辉”，依然可以找到我&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 00:59:00 +0000</pubDate>
<dc:creator>全菜工程师小辉</dc:creator>
<og:description>更多内容，欢迎关注微信公众号：全菜工程师小辉。公众号回复关键词，领取免费学习资料。 当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mseddl/p/11495405.html</dc:identifier>
</item>
<item>
<title>聊聊前后端分离接口规范 - 小__伟</title>
<link>http://www.cnblogs.com/qwlscn/p/11495402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qwlscn/p/11495402.html</guid>
<description>&lt;h2&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;随着互联网的高速发展，前端页面的展示、交互体验越来越灵活、炫丽，响应体验也要求越来越高，后端服务的高并发、高可用、高性能、高扩展等特性的要求也愈加苛刻，从而导致前后端研发各自专注于自己擅长的领域深耕细作。&lt;/p&gt;
&lt;p&gt;然而带来的另一个问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自干各自的，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。&lt;/p&gt;
&lt;p&gt;本文的主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。&lt;/p&gt;
&lt;h2&gt;2. 为何要分离&lt;/h2&gt;
&lt;p&gt;参考两篇文章：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://blog.jobbole.com/65509/&lt;br/&gt;http://blog.jobbole.com/56161/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前现有前后端开发模式：“后端为主的MVC时代”，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;12&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTItMTU1NzAxOTg0Ny5qcGc?x-oss-process=image/format,png&quot; alt=&quot;聊聊前后端分离接口规范&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTItMTU1NzAxOTg0Ny5qcGc?x-oss-process=image/format,png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.javazhiyin.com/wp-content/uploads/2019/05/java2-1557019847.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;聊聊前后端分离接口规范&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;后端为主的MVC时代&lt;/p&gt;
&lt;p&gt;代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。为了让 View 层更简单干脆，还可以选择 Velocity、Freemaker 等模板，使得模板里写不了 Java 代码。&lt;/p&gt;
&lt;p&gt;看起来是功能变弱了，但正是这种限制使得前后端分工更清晰。然而依旧并不是那么清晰，这个阶段的典型问题是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端开发重度依赖开发环境，开发效率低。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种架构下，前后端协作有两种模式：一种是前端写demo，写好后，让后端去套模板 。淘宝早期包括现在依旧有大量业务线是这种模式。好处很明显，demo 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。&lt;/p&gt;
&lt;p&gt;另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前后端职责依旧纠缠不清。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Velocity 模板还是蛮强大的，变量、逻辑、宏等特性，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对前端发挥的局限。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作才能碰撞出火花，但由于后端框架限制，我们很难使用Comet、Bigpipe等技术方案来优化性能。&lt;/p&gt;
&lt;p&gt;总上所述，就跟为什麽要代码重构一样：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;关注点分离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;职责分离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对的人做对的事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更好的共建模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速的反应变化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3. 什么是分离&lt;/h2&gt;
&lt;p&gt;我们现在要做的前后分离第一阶段：“基于 Ajax 带来的 SPA 时代”，如图：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;11&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTEwLTE1NTcwMTk4NDcuanBn?x-oss-process=image/format,png&quot; alt=&quot;聊聊前后端分离接口规范&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTEwLTE1NTcwMTk4NDcuanBn?x-oss-process=image/format,png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.javazhiyin.com/wp-content/uploads/2019/05/java10-1557019847.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;聊聊前后端分离接口规范&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于 Ajax 带来的 SPA 时代&lt;/p&gt;
&lt;p&gt;这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;10&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTUtMTU1NzAxOTg0OC5qcGc?x-oss-process=image/format,png&quot; alt=&quot;聊聊前后端分离接口规范&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTUtMTU1NzAxOTg0OC5qcGc?x-oss-process=image/format,png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.javazhiyin.com/wp-content/uploads/2019/05/java5-1557019848.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;聊聊前后端分离接口规范&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;浏览器端的分层架构&lt;/p&gt;
&lt;p&gt;对于这一SPA阶段，前后端分离有几个重要挑战：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前后端接口的约定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦。这一块在业界有 API Blueprint 等方案来约定和沉淀接口，==在阿里，不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。== 相信这一块会越做越好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端开发的复杂度控制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。&lt;/p&gt;
&lt;h2&gt;4. 如何做分离&lt;/h2&gt;
&lt;h3&gt;4.1 职责分离&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;9&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTUtMTU1NzAxOTg0OC5qcGVn?x-oss-process=image/format,png&quot; alt=&quot;聊聊前后端分离接口规范&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTUtMTU1NzAxOTg0OC5qcGVn?x-oss-process=image/format,png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.javazhiyin.com/wp-content/uploads/2019/05/java5-1557019848.jpeg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;聊聊前后端分离接口规范&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;职责分离&lt;/p&gt;

&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前后端仅仅通过异步接口(AJAX/JSONP)来编程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前后端都各自有自己的开发流程，构建工具，测试集合&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关注点分离，前后端变得相对独立并松耦合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTgtMTU1NzAxOTg0OC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;聊聊前后端分离接口规范&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTgtMTU1NzAxOTg0OC5wbmc?x-oss-process=image/format,png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.javazhiyin.com/wp-content/uploads/2019/05/java8-1557019848.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;聊聊前后端分离接口规范&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.2 开发流程&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;后端编写和维护接口文档，在 API 变化时更新接口文档&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;后端根据接口文档进行接口开发&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前端根据接口文档进行开发 + Mock平台&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;开发完成后联调和提交测试&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Mock 服务器根据接口文档自动生成 Mock 数据，实现了接口文档即API：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;7&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTYtMTU1NzAxOTg0OC5qcGVn?x-oss-process=image/format,png&quot; alt=&quot;聊聊前后端分离接口规范&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTYtMTU1NzAxOTg0OC5qcGVn?x-oss-process=image/format,png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.javazhiyin.com/wp-content/uploads/2019/05/java6-1557019848.jpeg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;聊聊前后端分离接口规范&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;开发流程&lt;/p&gt;
&lt;h3&gt;4.3 具体实施&lt;/h3&gt;
&lt;p&gt;现在已基本完成了，接口方面的实施：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接口文档服务器：可实现接口变更实时同步给前端展示；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Mock接口数据平台：可实现接口变更实时Mock数据给前端使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接口规范定义：很重要，接口定义的好坏直接影响到前端的工作量和实现逻辑；具体定义规范见下节；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTktMTU1NzAxOTg0OC5qcGVn?x-oss-process=image/format,png&quot; alt=&quot;聊聊前后端分离接口规范&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTktMTU1NzAxOTg0OC5qcGVn?x-oss-process=image/format,png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.javazhiyin.com/wp-content/uploads/2019/05/java9-1557019848.jpeg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;聊聊前后端分离接口规范&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接口文档+Mock平台服务器&lt;/p&gt;
&lt;h2&gt;5. 接口规范V1.0.0&lt;/h2&gt;
&lt;h3&gt;5.1 规范原则&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接口返回数据即显示：前端仅做渲染逻辑处理；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;渲染逻辑禁止跨多个接口调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;5.2 基本格式&lt;/h3&gt;
&lt;p&gt;5.2.1 请求基本格式&lt;/p&gt;
&lt;p&gt;GET请求、POST请求==必须包含key为body的入参，所有请求数据包装为JSON格式，并存放到入参body中==，示例如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET请求：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;POST请求：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTYtMTU1NzAxOTg0OS5qcGVn?x-oss-process=image/format,png&quot; alt=&quot;聊聊前后端分离接口规范&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMDUvamF2YTYtMTU1NzAxOTg0OS5qcGVn?x-oss-process=image/format,png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.javazhiyin.com/wp-content/uploads/2019/05/java6-1557019849.jpeg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;聊聊前后端分离接口规范&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.2.2 响应基本格式&lt;/p&gt;

&lt;p&gt;code : 请求处理状态&lt;/p&gt;
&lt;p&gt;data.message: 请求处理消息&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;code=200 且 data.message=&quot;success&quot;: 请求处理成功&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;code=200 且 data.message!=&quot;success&quot;: 请求处理成功, 普通消息提示：message内容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;code=500: 请求处理失败，警告消息提示：message内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;5.3 响应实体格式&lt;/h3&gt;

&lt;p&gt;data.entity: 响应返回的实体数据&lt;/p&gt;
&lt;h3&gt;5.4 响应列表格式&lt;/h3&gt;
&lt;p&gt;data.list: 响应返回的列表数据&lt;/p&gt;
&lt;h3&gt;5.5 响应分页格式&lt;/h3&gt;


&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;data.recordCount: 当前页记录数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;data.totalCount: 总记录数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;data.pageNo: 当前页码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;data.pageSize: 每页大小&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;data.totalPage: 总页数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;5.6 特殊内容规范&lt;/h3&gt;
&lt;p&gt;5.6.1 下拉框、复选框、单选框&lt;/p&gt;
&lt;p&gt;由后端接口统一逻辑判定是否选中，通过isSelect标示是否选中，示例如下：&lt;/p&gt;

&lt;p&gt;禁止下拉框、复选框、单选框判定选中逻辑由前端来处理，统一由后端逻辑判定选中返回给前端展示；&lt;/p&gt;
&lt;p&gt;5.6.2 Boolean类型&lt;/p&gt;
&lt;p&gt;关于Boolean类型，JSON数据传输中一律使用1/0来标示，1为是/True，0为否/False；&lt;/p&gt;
&lt;p&gt;5.6.3 日期类型&lt;/p&gt;
&lt;p&gt;关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定；&lt;/p&gt;
&lt;h2&gt;6. 未来的大前端&lt;/h2&gt;
&lt;p&gt;目前我们现在用的前后端分离模式属于第一阶段，由于使用到的一些技术jquery等，对于一些页面展示、数据渲染还是比较复杂，不能够很好的达到复用。对于前端还是有很大的工作量。&lt;/p&gt;
&lt;p&gt;下一阶段可以在前端工程化方面，对技术框架的选择、前端模块化重用方面，可多做考量。也就是要迎来“==前端为主的 MV* 时代==”。大多数的公司也基本都处于这个分离阶段。&lt;/p&gt;
&lt;p&gt;最后阶段就是==Node 带来的全栈时代==，完全有前端来控制页面，URL，Controller，路由等，后端的应用就逐步弱化为真正的数据服务+业务服务，做且仅能做的是提供数据、处理业务逻辑，关注高可用、高并发等。&lt;/p&gt;
&lt;p&gt;这两个阶段仅做简单介绍，有兴趣的可以参考下面的资料。&lt;/p&gt;
&lt;h3&gt;7. 参考资料&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;https://www.zhihu.com/question/28207685&lt;br/&gt;http://taobaofed.org/&lt;br/&gt;http://2014.jsconf.cn/slides/herman-taobaoweb&lt;br/&gt;http://blog.jobbole.com/65509/&lt;br/&gt;https://blog.kaolafed.com/&lt;br/&gt;http://blog.jobbole.com/65513/&lt;br/&gt;http://blog.jobbole.com/65534/&lt;br/&gt;http://blog.jobbole.com/65541/&lt;br/&gt;http://blog.jobbole.com/56161/&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 10 Sep 2019 00:58:00 +0000</pubDate>
<dc:creator>小__伟</dc:creator>
<og:description>1. 前言 随着互联网的高速发展，前端页面的展示、交互体验越来越灵活、炫丽，响应体验也要求越来越高，后端服务的高并发、高可用、高性能、高扩展等特性的要求也愈加苛刻，从而导致前后端研发各自专注于自己擅长</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qwlscn/p/11495402.html</dc:identifier>
</item>
<item>
<title>用.NET写“算命”程序 - .NET骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/20190905-fortune-with-dotnet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/20190905-fortune-with-dotnet.html</guid>
<description>&lt;p&gt;“算命”，是一种迷信，我父亲那一辈却执迷不悟，有时深陷其中，有时为求一“上上签”，甚至不惜重金，向“天神”保佑。我曾看到过有些算命网站，可以根据人的生辰八字，来求得这个人一生的财运、桃花运，如果第一卦算得不好，还可以向“天神”“请愿”（充钱），再算一卦，直到达到好运为止。&lt;/p&gt;
&lt;p&gt;作为一个深信唯物辩证法的人来说，这些东西当然是不信。&lt;/p&gt;
&lt;p&gt;但仔细口味，发现这些东西其中需要有些科学道理。我可以将&lt;code&gt;算命&lt;/code&gt;总结为以下“三要素”：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;一致性&lt;/p&gt;
“命中注定”，因此“算”出来的东西，不管早算还是晚算，什么时候算，结果应该都一样。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;无规律性&lt;/p&gt;
&lt;p&gt;“天机不可泄露”，因此输入相近的姓名等参数，输出应该相差较远。“每个人的命运各不相同”，比如狗二和狗三，相差只有一个字，但他们的命运并不一定会几乎一样。算法应该也考虑这一点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;个性化&lt;/p&gt;
&lt;p&gt;输入参数应该尽量个性化，不要像&lt;code&gt;十二生肖&lt;/code&gt;/&lt;code&gt;十二星座&lt;/code&gt;那样，和&lt;code&gt;性别&lt;/code&gt;做排列组合，只有&lt;code&gt;12x2=24&lt;/code&gt;种结果。否则撞车的人太多，容易露馅😂。因此输入参数必须个性化，最好是&lt;code&gt;姓名&lt;/code&gt;、&lt;code&gt;性别&lt;/code&gt;再加上&lt;code&gt;生辰八字&lt;/code&gt;（出生时间）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;可操作性&lt;/p&gt;
&lt;p&gt;孜孜不倦的求卦者，可能会“诚心诚意”想求个“上上签”，因此在一致性的基础上，必须要加一点点“&lt;strong&gt;可操作性&lt;/strong&gt;”。这个可以当作一个单独的输入参数来表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果将&lt;code&gt;算命&lt;/code&gt;当作一个函数，那它的输入无疑是&lt;code&gt;姓名&lt;/code&gt;、&lt;code&gt;其它个人信息&lt;/code&gt;和&lt;code&gt;诚心&lt;/code&gt;。，输出就是一个分数（&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;100&lt;/code&gt;），可以用下图的代码表示：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int destinyScore = f(name, otherPersonalInformation, faith);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面，我将用&lt;code&gt;.NET&lt;/code&gt;实现这个“算命”的功能。&lt;/p&gt;

&lt;h2 id=&quot;最初想法&quot;&gt;最初想法&lt;/h2&gt;
&lt;p&gt;如果只以&lt;code&gt;姓名&lt;/code&gt;作为输入，那么这个函数可以简化为：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int destinyScore = f(name);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这可能就好办多了，如&lt;code&gt;.NET&lt;/code&gt;中的&lt;code&gt;.GetHashCode()&lt;/code&gt;，即可快速获取一个字符串的哈希值，这个哈希值&lt;strong&gt;应该&lt;/strong&gt;是固定的（&lt;strong&gt;吗？&lt;/strong&gt;），该值的取值范围是&lt;code&gt;int.MinValue&lt;/code&gt;-&lt;code&gt;int.MaxValue&lt;/code&gt;。因此最简单的办法，可以先可以通过对&lt;code&gt;100&lt;/code&gt;求模，此时的取值范围是&lt;code&gt;-99~99&lt;/code&gt;；然后再取绝对值+1即可，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int GetForturn(string name)
{
    return Math.Abs(name.GetHashCode() % 100) + 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;.NET Framework 4.8&lt;/code&gt;中运行，可以算出我（周杰）的得分固定为15分。&lt;/p&gt;
&lt;h2 id=&quot;最简单算法的缺点-.net-core的不一致&quot;&gt;最简单算法的缺点-&lt;code&gt;.NET Core&lt;/code&gt;的不一致&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;.NET Core&lt;/code&gt;中，这个算法每次重新运行，算出的结果都不同，因为&lt;code&gt;.NET Core&lt;/code&gt;为了确保安全性，在应用程序启动时，会随机生成一个字符串哈希值种子，因此每次&lt;code&gt;exe&lt;/code&gt;运行，哈希值都会变，文档是这么说的：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;哈希代码本身不一定是稳定的。 对于单个版本的 .NET, 相同字符串的哈希代码可能跨 .net 实现、跨 .NET 版本和跨 .NET 平台 (如32位和64位) 不同。 在某些情况下, 它们甚至不同于应用程序域。 这意味着, 同一程序的两次后续运行可能返回不同的哈希代码。&lt;/em&gt;（源自：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.string.gethashcode?view=netframework-4.8&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/api/system.string.gethashcode?view=netframework-4.8&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;很显然，这不符合“一致性”，看来想简单地通过&lt;code&gt;GetHashCode()&lt;/code&gt;快速“算命”的想法落空了，只能使用标准的&lt;strong&gt;哈希算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当然，使用如此简单的算法，客户知道了，可能也不太情愿消费更多的“诚意金”了。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;哈希算法&quot;&gt;哈希算法&lt;/h2&gt;
&lt;p&gt;哈希算法可以给任意长度的字符转换为一串二进制数组，也就是哈希值。&lt;code&gt;.NET&lt;/code&gt;内置了许多不同的哈希算法可供选择：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有单纯的哈希，如&lt;code&gt;MD5&lt;/code&gt;、&lt;code&gt;SHA1&lt;/code&gt;之类；&lt;/li&gt;
&lt;li&gt;有“加盐”的哈希，如&lt;code&gt;HMACSHA&lt;/code&gt;、&lt;code&gt;HMACSHA256&lt;/code&gt;等；&lt;/li&gt;
&lt;li&gt;有可指定生成长度、可多次迭代、综合性“加盐”的哈希，如&lt;code&gt;Rfc2898DeriveBytes&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们要指定一点点“天机”（加盐），但“天机不可泄露”，因此简单地&lt;code&gt;MD5&lt;/code&gt;等单纯哈希算法排除；&lt;/p&gt;
&lt;p&gt;我们要转化为一个整数，最大的整数类型，&lt;code&gt;long&lt;/code&gt;/&lt;code&gt;Int64&lt;/code&gt;，为&lt;code&gt;64&lt;/code&gt;位，而最小的内置哈希算法，&lt;code&gt;MD5&lt;/code&gt;，就已达&lt;code&gt;128&lt;/code&gt;位。因此也要排除&lt;code&gt;HMACSHA&lt;/code&gt;等“加盐”哈希。当然这些哈希值也可以手动截取部分长度，但安全性是个问号（也受强迫症影响）。&lt;/p&gt;
&lt;p&gt;搞过&lt;code&gt;ASP.NET Identity&lt;/code&gt;登录的都知道里面用到了&lt;code&gt;Rfc2898DeriveBytes&lt;/code&gt;，它默认为&lt;code&gt;ASP.NET Core&lt;/code&gt;做了&lt;code&gt;10000&lt;/code&gt;次迭代，用多次迭代的方式（而不是引入一个新哈希算法的方式），确保了安全性。搞对称加密的时候，有时也用这个类将客户的密码转换为加密算法的&lt;code&gt;密钥&lt;/code&gt;(&lt;code&gt;key&lt;/code&gt;)，非常有用。&lt;/p&gt;
&lt;p&gt;所以最终我们选择了&lt;code&gt;Rfc2898DeriveBytes&lt;/code&gt;，该算法可以生成任意指定长度的哈希值。这个类的构造函数要求输入一个盐值和迭代次数，在这个示例中我们取一个别人不知道的值（代码中写死了，你们假装不知道，你们想用这个代码时可以改改😁）。可以写出如下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int GetForturn(string name)
{
    using (var h = new Rfc2898DeriveBytes(name, 
        salt: new byte[8] { 44, 2, 3, 4, 5, 6, 7, 8}, 
        iterations: 10086))
    {
        return (int)(BitConverter.ToUInt64(h.GetBytes(8), 0) % 100) + 1;
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见算出一卦80分以上的“上签”，已经非常不容易了。我从网上自动生成了888个姓名，然后调用该函数，发现得分超过&lt;code&gt;90&lt;/code&gt;分“上上签”标准的，只有83个，相同于十分之一，符合分布特点（详情见&lt;code&gt;Github&lt;/code&gt;上的代码）。&lt;/p&gt;
&lt;p&gt;通过以下代码，可以算出“狗二”是48分，“狗三”是96分，可见一字之差相差甚远：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;GetForturn(&quot;狗二&quot;).Dump(); // 48
GetForturn(&quot;狗三&quot;).Dump(); // 96&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;完整算法&quot;&gt;完整算法&lt;/h2&gt;
&lt;p&gt;最后，依葫芦画瓢，加上个人信息参数（生日）和“诚意金次数”，完成最后的算法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int GetForturn(string name, DateTime birthDay, int faithCount)
{
    using (var h = new Rfc2898DeriveBytes(name + birthDay + faithCount,
        salt: new byte[8] { 44, 2, 3, 4, 5, 6, 7, 8 },
        iterations: 10086))
    {
        return (int)(BitConverter.ToUInt64(h.GetBytes(8), 0) % 100) + 1;
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后又是“狗二”和“狗三”，加上他们的生日参数后，默认他们的得分是95分和3分：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;GetForturn(&quot;狗二&quot;, new DateTime(1994, 5, 17), 0).Dump(); // 95
GetForturn(&quot;狗三&quot;, new DateTime(1996, 11, 3), 0).Dump(); // 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但狗三经过1次“诚意金”后，也求得了高达99分以上的“上上签”：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;GetForturn(&quot;狗二&quot;, new DateTime(1994, 5, 17), 0).Dump(); // 98
GetForturn(&quot;狗三&quot;, new DateTime(1996, 11, 3), ).Dump(); // 99&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Rfc2898DeriveBytes&lt;/code&gt;非常有用，本文说了&lt;code&gt;Rfc2898DeriveBytes&lt;/code&gt;的一种使用场景，相信各位在工作当时也经常会有机会去接触它。&lt;/p&gt;
&lt;p&gt;我将上述功能做了一个页面，愿博君一笑：&lt;a href=&quot;https://destiny.starworks.cc/&quot; class=&quot;uri&quot;&gt;https://destiny.starworks.cc/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201909/233608-20190909215240434-1933311131.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文所用代码下载地址：&lt;a href=&quot;https://github.com/sdcb/blog-data/tree/master/2019/20190905-fortune-with-dotnet&quot; class=&quot;uri&quot;&gt;https://github.com/sdcb/blog-data/tree/master/2019/20190905-fortune-with-dotnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请关注我的微信公众号：【DotNet骚操作】，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201908/233608-20190825165420518-990227633.jpg&quot; alt=&quot;DotNet骚操作&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 00:51:00 +0000</pubDate>
<dc:creator>.NET骚操作</dc:creator>
<og:description>“算命”，是一种迷信，我父亲那一辈却执迷不悟，有时深陷其中，有时为求一“上上签”，甚至不惜重金，向“天神”保佑。我曾看到过有些算命网站，可以根据人的生辰八字，来求得这个人一生的财运、桃花运，如果第一卦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/20190905-fortune-with-dotnet.html</dc:identifier>
</item>
<item>
<title>工作中遇到的99%SQL优化，这里都能给你解决方案(三) - 小强的进阶之路</title>
<link>http://www.cnblogs.com/xiaoqiang-code/p/11495376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoqiang-code/p/11495376.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;-- 示例表
CREATE TABLE `employees` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(24) NOT NULL DEFAULT '' COMMENT '姓名',
  `age` int(20) NOT NULL DEFAULT '0' COMMENT '年龄',
  `position` varchar(20) NOT NULL DEFAULT '' COMMENT '职位',
  `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '入职时间',
  PRIMARY KEY (`id`),
  KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE,
  KEY `idx_age` (`age`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=136326 DEFAULT CHARSET=utf8 COMMENT='员工表'

--创建100000条记录
drop procedure if EXISTS insert_emp;
delimiter ;;
create procedure insert_emp()
BEGIN
    declare i int;
    set i=1;
    while(i &amp;lt; 100000)DO
        INSERT INTO employees(name,age,position) values(CONCAT('xiaoqiang',i),i,'coder');
        SET i=i+1;
    end WHILE;
end;;
delimiter ;
call insert_emp();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;根据自增且连续的主键排序的分页查询&quot;&gt;根据自增且连续的主键排序的分页查询&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;select * from employees LIMIT 9999 ,5;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084957201-583356763.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084957365-1168505638.jpg&quot;/&gt;&lt;br/&gt;表示从表employees 中取出从10000行开始的5行记录。看似只查询5条记录，实际这条SQL是先读取10005条记录，然后抛弃前10000条记录，然后读到后面5条想要的数据。没有添加单独的order by，表示通过主键排序。&lt;br/&gt;因此要查询一张大表比较靠后的数据，执行效率是非常低的。&lt;br/&gt;因为主键是自增且连续的，所以可以改写成按照主键查询从第10001开始的五行数据，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from  employees WHERE id &amp;gt; 9999 limit 5;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084957515-68702251.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084957651-1075823864.jpg&quot;/&gt;&lt;br/&gt;可以看到两个sql的执行计划，显然改写后的sql走了索引，而且扫描的行数大大减少，执行效率会更高。但是，这条改写的sql在很多场景下并不实用，因为表中可能某些记录被删除后，主键空缺，导致结果不一致。&lt;br/&gt;先删除一条记录，然后测试下原来sql和优化后的sql：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from employees LIMIT 9999 ,5;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084957823-1634758047.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; select * from employees where id&amp;gt; 9999 limit 5;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084957954-1377303408.jpg&quot;/&gt;&lt;br/&gt;两条sql的结果不一样，因此，如果主键不连续，不能使用上面描述的方法。&lt;br/&gt;另外由于原来sql是order by非主键字段，按照上面的方法改写sql的结果不一致。所以这种改写得满足以下两个条件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from employees order by name limit 9000, 5;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084958076-259543668.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; explain select * from employees order by name limit 9000, 5;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084958196-633674116.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;key字段对应的值为null，发现并没有使用name字段的索引。因为扫描整个索引并查找到没有索引的行，可能要便利多个索引树，其成本比扫描全表的成本更高，索引优化器放弃使用索引。&lt;br/&gt;优化的关键是：让排序时返回的字段尽可能的少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录。&lt;br/&gt;改下如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from employees as e inner join(select id from employees order by name limit 9000,5) as ed on e.id=ed.id;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084958322-122460881.jpg&quot;/&gt;&lt;br/&gt;可以看到结果与原来的sql结果是一致的，执行时间减少了一般以上，再对比下执行计划：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084958454-642359635.jpg&quot;/&gt;&lt;br/&gt;原来的sql使用的是filesort排序，而优化后的sql使用的是索引排序。&lt;/p&gt;
&lt;h4 id=&quot;in和exists优化&quot;&gt;in和exists优化&lt;/h4&gt;
&lt;p&gt;原则：小表驱动大表，即小表的数据集驱动大表的数据集&lt;br/&gt;in：当B表的数据集小于A表的数据集时，in由于exists&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from A where id in(select id from B)
等价于
 for(select id from B){
     select * from A where A.id=B.id
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;exists:当A表的数据集小于B表的数据集时，exitsts优于in&lt;br/&gt;当著查询A的数据，放到子查询B中做条件验证，根据验证结果（true或false）来决定著查询的数据是否保留。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from A  exists(select 1 from B where A.id=B.id)

等价于
for(select * from A){
    select * from B where A.id=B.id
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;count查询优化&quot;&gt;count(*)查询优化&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;explain select count(1) from employees;
explain select count(id) from employees;
explain select count(name) from employees;
explain select count(*) from employees;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084958587-1559409854.jpg&quot;/&gt;&lt;br/&gt;四个sql的执行计划几乎一样的，count(name)使用的是联合索引， 主要区别根据某个字段做count操作不会统计字段为null的值的数据行。&lt;br/&gt;除了count(name)的其他count操作，都是用的辅助索引而不是主键索引， 因为二级索引存储数据更少，检索性能更高。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;还没关注我的公众号？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;扫文末二维码关注公众号【小强的进阶之路】可领取如下:&lt;/li&gt;
&lt;li&gt;学习资料： 1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频教程；&lt;/li&gt;
&lt;li&gt;100多本书：包含C/C++、Java、Python三门编程语言的经典必看图书、LeetCode题解大全；&lt;/li&gt;
&lt;li&gt;软件工具：几乎包括你在编程道路上的可能会用到的大部分软件；&lt;/li&gt;
&lt;li&gt;项目源码：20个JavaWeb项目源码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201909/1771943-20190910084959332-2004126400.png&quot; alt=&quot;小强的进阶之路二维码&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 10 Sep 2019 00:50:00 +0000</pubDate>
<dc:creator>小强的进阶之路</dc:creator>
<og:description>``` 示例表 CREATE TABLE ( int(11) NOT NULL AUTO_INCREMENT, varchar(24) NOT NULL DEFAULT '' COMMENT '姓名'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoqiang-code/p/11495376.html</dc:identifier>
</item>
<item>
<title>「每日五分钟，玩转JVM」：对象内存布局 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/11495362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/11495362.html</guid>
<description>&lt;h3 id=&quot;概览&quot;&gt;概览&lt;/h3&gt;
&lt;p&gt;一个对象根据不同情况可以被划分成两种情况，当对象是一个非数组对象的时候，对象头，实例数据，对齐填充在内存中三分天下，而数组对象中在对象头中多了一个用于描述数组对象长度的部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-23-141859.png&quot; alt=&quot;image-20190823221858767&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象头&quot;&gt;对象头&lt;/h3&gt;
&lt;p&gt;对象头分为两部分，第一部分称之为&lt;strong&gt;&quot;Mark Word&quot;&lt;/strong&gt;，第二部分是用于获取该对象类型的&lt;strong&gt;类型指针&lt;/strong&gt;，如果是数组对象还包括记录数组长度的数据。&lt;/p&gt;
&lt;p&gt;在不同的操作系统中，这些区域所占的内存也不同，在32位的系统中，MarkWord占用32bit的空间（也就是4字节）。类型指针和数组长度数据一样合作占用32bit的空间。&lt;/p&gt;
&lt;p&gt;在64位的操作系统中，MarkWord占用64bit的空间，类型指针在不开启指针压缩（CompressedOOPs）的情况下是64bit（8 byte），而在开启指针压缩的情况下，仅剩32bit（4 byte）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-23-145704.png&quot; alt=&quot;image-20190823225703812&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;mark-word&quot;&gt;Mark Word&lt;/h4&gt;
&lt;p&gt;这一部分存储的是&lt;strong&gt;对象自身的运行时数据&lt;/strong&gt;，这一块儿内容的数据结构并不固定，它会根据对象的状态复用自己的存储空间，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-23-150559.png&quot; alt=&quot;image-20190823230559543&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是摘自markOop.hpp文件中的片段，其中表示了对象的以下五种状态：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;无锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;偏向锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;轻量级锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;重量级锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;GC Mark&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们接下来接着去看MarkWord的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-23-151212.png&quot; alt=&quot;image-20190823231212050&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里我们可以看到，初始化的时候只是定义了无锁和偏向锁状态的结构（上半部分是没有开启COOPs-指针压缩的结构，下半部分是开启了指针压缩的结构），&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当处于轻量级锁、重量级锁时，记录的对象指针，根据JVM的说明，此时认为指针仍然是64位，最低两位假定为0;当处于偏向锁时，记录的为获得偏向锁的线程指针，该指针也是64位；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-23-151522.png&quot; alt=&quot;image-20190823231522289&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-23-154630.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多的内容我们就不再这里扩展了，根据反馈的情况，我会在后面并发编程中单开一篇来聊聊锁的进化之路。&lt;/p&gt;
&lt;h4 id=&quot;类型指针&quot;&gt;类型指针&lt;/h4&gt;
&lt;p&gt;这个东西有时候会用到去确定该对象属于&lt;strong&gt;哪个类的实例&lt;/strong&gt;，也有用不到的时候，这个要根据不同的虚拟机对于对象的定位实现算法的选择来进行（比如HotSpot JVM就使用该类型指针去获取该对象类型数据）&lt;/p&gt;
&lt;h3 id=&quot;实例数据&quot;&gt;实例数据&lt;/h3&gt;
&lt;p&gt;实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的&lt;strong&gt;字段内容&lt;/strong&gt;，这里的字段内容不仅仅包括当前类的字段，也包括他的父类中所定义的字段。&lt;/p&gt;
&lt;p&gt;这部分的存储规则遵循虚拟机分配策略参数和字段在Java源码中的定义顺序，HotSpot JVM默认的分配策略是long/double， int，short/char，byte/boolean，oops（普通对象指针，Ordinary Object Pointers）也可以理解为reference，关于指针压缩我们下节去说。&lt;/p&gt;
&lt;p&gt;这里需要注意，在父类中定义的变量会出现在子类前，但是我们可以通过将CompactFileds参数设置为true，将子类中较小的变量插入到父类大变量的空隙中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-24-040848.png&quot; alt=&quot;image-20190824120847519&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对齐填充&quot;&gt;对齐填充&lt;/h3&gt;
&lt;p&gt;这部分内容并不是必须存在的，因为Hot Spot JVM中规定了&lt;strong&gt;对象的大小必须是8字节的整数倍&lt;/strong&gt;，在C/C++中类似的功能被称之为&lt;strong&gt;内存对齐&lt;/strong&gt;，内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。&lt;/p&gt;
&lt;p&gt;内存对齐遵循两个规则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;假设第一个成员的起始地址为0，每个成员的起始地址（startpos）必须是其数据类型所占空间大小的整数倍&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;结构体的最终大小必须是其成员（基础数据类型成员）里最大成员所占大小的整数倍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这里也就不难理解为什么JVM规定对象的大小必须是8字节的整数倍了，因为在64位系统下（不开启指针压缩），对象中存在很多占用8 byte的数据类型。但是同时也存在一些4 byte的数据类型，这时我们的Padding就起到了作用，去补充不满8 byte的部分，凑齐8的整数倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-24-041115.png&quot; alt=&quot;image-20190824121114907&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1528535/201909/1528535-20190910084605081-708186693.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 00:46:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>概览 一个对象根据不同情况可以被划分成两种情况，当对象是一个非数组对象的时候，对象头，实例数据，对齐填充在内存中三分天下，而数组对象中在对象头中多了一个用于描述数组对象长度的部分 对象头 对象头分为两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/11495362.html</dc:identifier>
</item>
<item>
<title>并发Bug之源有三，请睁大眼睛看清它们 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/11495334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/11495334.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;生活中你一定听说过——能者多劳&lt;/li&gt;
&lt;li&gt;作为 Java 程序员，你一定听过——这个功能请求慢，能加一层缓存或优化一下 SQL 吗？&lt;/li&gt;
&lt;li&gt;看过中国古代神话故事的也一定听过——天上一天，地上一年&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083149335-166058393.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一切设计来源于生活，上一章 &lt;a href=&quot;https://mp.weixin.qq.com/s/SrNsvp2NjhAEqYugx6c-3Q&quot;&gt;学并发编程，透彻理解这三个核心是关键&lt;/a&gt; 中有讲过，作为&quot;资本家&quot;，你要尽可能的榨取 CPU，内存与 IO 的剩余价值，但三者完成任务的速度相差很大，CPU &amp;gt; 内存 &amp;gt; IO分，CPU 是天，那内存就是地，内存是天，那 IO 就是地，那怎样平衡三者，提升整体速度呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;CPU 增加缓存，还不止一层缓存，平衡内存的慢&lt;/li&gt;
&lt;li&gt;CPU 能者多劳，通过分时复用，平衡 IO 的速度差异&lt;/li&gt;
&lt;li&gt;优化编译指令&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的方式貌似解决了木桶短板问题，但同时这种解决方案也伴随着产生新的&lt;strong&gt;可见性，原子性，和有序性&lt;/strong&gt;的问题，且看&lt;/p&gt;
&lt;h2 id=&quot;三大问题&quot;&gt;三大问题&lt;/h2&gt;
&lt;h3 id=&quot;可见性&quot;&gt;可见性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谈到可见性，要先引出 JMM (Java Memory Model) 概念, 即 Java 内存模型，Java 内存模型规定，将所有的变量都存放在 &lt;strong&gt;主内存&lt;/strong&gt; 中，当线程使用变量时，会把主内存里面的变量 &lt;strong&gt;复制&lt;/strong&gt; 到自己的工作空间或者叫作 &lt;strong&gt;私有内存&lt;/strong&gt; ，线程读写变量时操作的是自己工作内存中的变量。&lt;/p&gt;
&lt;p&gt;用 Git 的工作流程理解上面的描述就很简单了，&lt;strong&gt;Git 远程仓库就是主内存，Git 本地仓库就是自己的工作内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文字描述有些抽象，我们来图解说明:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083149668-219233983.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看这个场景:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;主内存中有变量 x，初始值为 0&lt;/li&gt;
&lt;li&gt;线程 A 要将 x 加 1，先将 x=0 拷贝到自己的私有内存中，然后更新 x 的值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程 A 将更新后的 x 值回刷到主内存的时间是不固定的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x=2 就会编程 x=1&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这就是线程可见性的问题&lt;/p&gt;
&lt;p&gt;JMM 是一个抽象的概念，在实际实现中，线程的工作内存是这样的:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083149869-271492925.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了平衡内存/IO 短板，会在 CPU 上增加缓存，每个核都只有自己的一级缓存，甚至有一个所有 CPU 都共享的二级缓存，就是上图的样子了，都说这么设计是硬件同学留给软件同学的一个坑，但能否跳过去这个坑也是衡量软件同学是否走向 Java 进阶的关键指标吧......&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;h4 id=&quot;小提示&quot;&gt;小提示&lt;/h4&gt;
&lt;p&gt;从上图中你也可以看出，在 Java 中，所有的实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间共享，这些在后续文章中都称之为「共享变量」，局部变量，方法定义参数和异常处理器参数不会在线程之间共享，所以他们不会有内存可见性的问题，也就不受内存模型的影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一句话，要想解决多线程可见性问题，所有线程都必须要刷取主内存中的变量&lt;/strong&gt;&lt;br/&gt;怎么解决可见性问题呢？Java 关键字 &lt;strong&gt;volatile&lt;/strong&gt; 帮你搞定，后续章节会分析......&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;原子性&lt;/h3&gt;
&lt;p&gt;原子（atom）指化学反应不可再分的基本微粒，原子性操作你应该能感受到其含义:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小品「钟点工」有一句非常经典的台词，要把大象装冰箱，总共分几步？&lt;/p&gt;
&lt;p&gt;来看一小段程序:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083151915-1125038039.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多线程情况下能得到我们期盼的 &lt;code&gt;count = 20000&lt;/code&gt; 的值吗？ 也许有同学会认为，线程调用的 counter 方法只有一个 count++ 操作，是单一操作，所以是原子性的，非也。在线程第一讲中说过我们不能用高级语言思维来理解 CPU 的处理方式，count++ 转换成 CPU 指令则需要三步，通过下面命令解析出汇编指令等信息:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;javap -c UnsafeCounter &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;截取 counter 方法的汇编指令来看:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083153160-14832998.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释一下上面的指令，&lt;br/&gt;16 : 获取当前 count 值，并且放入栈顶&lt;br/&gt;19 : 将常量 1 放入栈顶&lt;br/&gt;20 : 将当前栈顶中两个值相加，并把结果放入栈顶&lt;br/&gt;21 : 把栈顶的结果再赋值给 count&lt;/p&gt;
&lt;p&gt;由此可见，简单的 count++ 不是一步操作，被转换为汇编后就不具备原子性了，就好比大象装冰箱，其实要分三步:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;第一步，把冰箱门打开；第二步，把大象放进去；第三步，把冰箱门带上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结合 JMM 结构图理解，说明一下为什么很难得到 &lt;code&gt;count=20000&lt;/code&gt; 的结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083153431-571999528.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多线程计数器，如何保证多个操作的原子性呢？最粗暴的方式是在方法上加 &lt;strong&gt;synchronized&lt;/strong&gt; 关键字，比如这样:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083154271-1845781132.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题是解决了，如果 synchronized 是万能良方，那么也许并发就没那么多事了，可以靠一个 synchronized 走天下了，事实并不是这样，synchronized 是独占锁 (同一时间只能有一个线程可以调用)，没有获取锁的线程会被阻塞；另外也会带来很多线程切换的上下文开销&lt;/p&gt;
&lt;p&gt;所以 JDK 中就有了非阻塞 CAS (Compare and &lt;strong&gt;Swap&lt;/strong&gt;) 算法实现的原子操作类 AtomicLong 等工具类，看过源码的同学也许会发现一个共同特点，所有原子类中都有下面这样一段代码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final Unsafe unsafe = Unsafe.getUnsafe();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类是 JDK 的 rt.jar 包中的 Unsafe 类提供了 &lt;strong&gt;硬件级别&lt;/strong&gt; 的原子性操作，类中的方法都是 native 修饰的，后面介绍原子类之前也会先说明这个类中的几个方法，这里先简单介绍有个印象即可。&lt;/p&gt;
&lt;p&gt;有同学不理解我刚刚提到的线程上下文切换开销很大是什么意思，举 2个例子你就懂了:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;你(CPU)在看两本书(两个线程)，看第一本书很短时间后要去看第二本书，看第二本书很短时间后又回看第一本书，并要精确的记得看到第几行，当初看到了什么(CPU 记住线程级别的信息)，当让你 &lt;strong&gt;&quot;同时&quot;&lt;/strong&gt; 看 10 本甚至更多，切换的开销就很大了吧&lt;/li&gt;
&lt;li&gt;综艺节目中有很多游戏，让你一边数钱，又要一边做其他的事，最终保证多样事情都做正确，大脑开销大不大，你试试就知道了😊&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;有序性&quot;&gt;有序性&lt;/h3&gt;
&lt;p&gt;生活中你问候他人「吃了吗你？」和「你吃了吗？」是一个意思，你写的是下面程序:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;a = 1；
b =  2;
System.out.println(a);
System.out.println(b);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器优化后可能就变成了这样:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;b =  2;
a = 1；
System.out.println(a);
System.out.println(b);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个情况，编译器调整了语句顺序没什么影响，但编译器 &lt;strong&gt;擅自&lt;/strong&gt; 优化顺序，就给我们埋下了雷，比如应用双重检查方式实现的单例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083155200-1988793753.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一切又很完美是不是，非也，问题出现在 &lt;code&gt;instance = new Singleton();&lt;/code&gt;，这 1 行代码转换成了 CPU 指令后又变成了 3 个，我们理解 new 对象应该是这样的:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配一块内存 M&lt;/li&gt;
&lt;li&gt;在内存 M 上初始化 Singleton 对象&lt;/li&gt;
&lt;li&gt;然后 M 的地址赋值给 instance 变量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但编译器&lt;strong&gt;擅自&lt;/strong&gt;优化后可能就变成了这样:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配一块内存 M&lt;/li&gt;
&lt;li&gt;然后将 M 的地址赋值给 instance 变量&lt;/li&gt;
&lt;li&gt;在内存 M 上初始化 Singleton 对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先 new 对象分了三步，给 CPU 留下了切换线程的机会；另外，编译器优化后的顺序可能导致问题的发生，来看:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;线程 A 先执行 getInstance 方法，当执行到指令 2 时，恰好发生了线程切换&lt;/li&gt;
&lt;li&gt;线程 B 刚进入到 getInstance 方法，判断 if 语句 instance 是否为空&lt;/li&gt;
&lt;li&gt;线程 A 已经将 M 的地址赋值给了 instance 变量，所以线程 B 认为 instance 不为空&lt;/li&gt;
&lt;li&gt;线程 B 直接 return instance 变量&lt;/li&gt;
&lt;li&gt;CPU 切换回线程 A，线程 A 完成后续初始化内容&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我们还是画个图说明一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083155661-136395980.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果线程 A 执行到第 2 步，线程切换，由于线程 A 没有把红色箭头执行完全，线程 B 就会得到一个未初始化完全的对象，访问 instance 成员变量的时候就可能发生 NPE，如果将变量 instance 用 volatile 或者 final 修饰(涉及到类的加载机制，可看我之前写的文章: &lt;a href=&quot;https://mp.weixin.qq.com/s/Dnr1jLebvBUHnziZzSfcrA&quot;&gt;双亲委派模型：大厂高频面试题，轻松搞定&lt;/a&gt;)，问题就解决了.&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;你所看到的程序并不一定是编译器优化/编译后的 CPU 指令，大象装冰箱是是个程序，但其隐含三个步骤，学习并发编程，你要按照 CPU 的思维考虑问题，所以你需要深刻理解 &lt;strong&gt;可见性/原子性/有序性&lt;/strong&gt; ，这是产生并发 Bug 的源头&lt;/p&gt;
&lt;p&gt;本节说明了三个问题，下面的文章也会逐个分析解决以上问题的办法，以及相对优的方案，请持续关注，另外关于并发的测试代码我都会按例上传到 github，公众号回复「demo」——&amp;gt; concurrency 获取更多内容&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;为什么用 final 修饰的变量就是线程安全的了呢？&lt;/li&gt;
&lt;li&gt;你会经常查看 CPU 汇编指令吗？&lt;/li&gt;
&lt;li&gt;如果让你写单例，你通常会采用哪种实现？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;提高效率工具&quot;&gt;提高效率工具&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083155810-755712823.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;material-theme-ui&quot;&gt;Material Theme UI&lt;/h3&gt;
&lt;p&gt;这是一款 IDEA 的主题插件，安装后，选择 &lt;code&gt;Material Palenight&lt;/code&gt; 主题，同时作出如下设置&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083158943-1962656352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置完后，你的 IDEA 就是下面这样，引起极度舒适&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083202763-2022194341.jpg&quot;/&gt;&lt;br/&gt;--------&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号日拱一兵&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总 | 回复「工具」&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取 | 回复「资料」&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201909/1583165-20190910083203588-504864575.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 00:32:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>写在前面 生活中你一定听说过——能者多劳 作为 Java 程序员，你一定听过——这个功能请求慢，能加一层缓存或优化一下 SQL 吗？ 看过中国古代神话故事的也一定听过——天上一天，地上一年 一切设计来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/11495334.html</dc:identifier>
</item>
<item>
<title>改进版梯度下降 - Timcode</title>
<link>http://www.cnblogs.com/TimVerion/p/11495327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TimVerion/p/11495327.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;改进版梯度下降&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;发展历史&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190702232145882-1421968396.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190702232145882-1421968396.png&quot; alt=&quot;img&quot; width=&quot;456&quot; height=&quot;121&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;标准梯度下降法的缺陷&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190702232206305-1372345460.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190702232206305-1372345460.png&quot; alt=&quot;img&quot; width=&quot;528&quot; height=&quot;302&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果学习率选的不恰当会出现以上情况&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;因此有一些自动调学习率的方法。一般来说，随着迭代次数的增加，学习率应该越来越小，因为迭代次数增加后，得到的解应该比较靠近最优解，所以要缩小步长η，那么有什么公式吗？比如：&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190702232224163-1424039140.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190702232224163-1424039140.png&quot; alt=&quot;img&quot; data-alt=&quot;img&quot;/&gt;&lt;span class=&quot;md-plain&quot;&gt;，但是这样做后，所有参数更新时仍都采用同一个学习率，即学习率不能适应所有的参数更新。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;解决方案是：&lt;span&gt;&lt;strong&gt;给不同的参数不同的学习率&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;Adagrad法&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;假设N元函数f(x)，针对一个自变量研究Adagrad梯度下降的迭代过程，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134149503-286131798.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134149503-286131798.png&quot; alt=&quot;img&quot; width=&quot;232&quot; height=&quot;71&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可以看出，Adagrad算法中有自适应调整梯度的意味（adaptive gradient），&lt;span&gt;&lt;strong&gt;学习率需要除以一个东西，这个东西就是前n次迭代过程中偏导数的平方和再加一个常量最后开根号&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举例：使用Adagrad算法求y = x2的最小值点&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;导函数为g(x) = 2x&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;初始化x(0) = 4，学习率η=0.25，ε=0.1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第①次迭代：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134228647-998159348.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134228647-998159348.png&quot; alt=&quot;img&quot; width=&quot;382&quot; height=&quot;54&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第②次迭代：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134308074-1444174784.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134308074-1444174784.png&quot; alt=&quot;img&quot; width=&quot;540&quot; height=&quot;48&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第③次迭代：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134332187-1980529925.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134332187-1980529925.png&quot; alt=&quot;img&quot; width=&quot;549&quot; height=&quot;42&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;求解的过程如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134354667-1305978580.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134354667-1305978580.png&quot; alt=&quot;img&quot; width=&quot;707&quot; height=&quot;333&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;对应代码为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot as plt
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; mpl_toolkits.mplot3d &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Axes3D

fig &lt;/span&gt;=&lt;span&gt; plt.figure()
x &lt;/span&gt;= np.arange(-4, 4, 0.025&lt;span&gt;)
plt.plot(x,x&lt;/span&gt;**2&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y = x^2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x**2
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; h(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2*&lt;span&gt;x
η &lt;/span&gt;= 0.25&lt;span&gt;
ε &lt;/span&gt;= 0.1&lt;span&gt;
x &lt;/span&gt;= 4&lt;span&gt;
iters &lt;/span&gt;=&lt;span&gt; 0
sum_square_grad &lt;/span&gt;=&lt;span&gt; 0
X &lt;/span&gt;=&lt;span&gt; []
Y &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; iters&amp;lt;12&lt;span&gt;:
    iters&lt;/span&gt;+=1&lt;span&gt;
    X.append(x)
    Y.append(f(x))
    sum_square_grad &lt;/span&gt;+= h(x)**2&lt;span&gt;
    x &lt;/span&gt;= x - η/np.sqrt(sum_square_grad+ε)*&lt;span&gt;h(x)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(iters,x)
plt.plot(X,Y,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ax &lt;/span&gt;=&lt;span&gt; plt.subplot()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(X)):
    ax.text(X[i], (X[i])&lt;/span&gt;**2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;({:.3f},{:.3f})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(X[i], (X[i])**2), color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;缺点：由于分母是累加梯度的平方，到后面累加的比较大时，会导致梯度更新缓慢&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;RMSprop法&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;AdaGrad算法在迭代后期由于学习率过小，可能较难找到一个有用的解。为了解决这一问题，RMSprop算法对Adagrad算法做了一点小小的修改，RMSprop使用了加权平均的方法,由累积平方梯度变成平均平方梯度,解决了后期学习率太小的缺点.(类似于动量梯度下降)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;假设N元函数f(x)，针对一个自变量研究RMSprop梯度下降的迭代过程，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1507784/201909/1507784-20190910082250821-128786568.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可以看出分母不再是一味的增加，它会重点考虑距离他较近的梯度（指数衰减的效果），也就不会出现Adagrad到后期收敛缓慢的问题&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举例：使用RMSprop算法求y = x2的最小值点&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;导函数为h(x) = 2x&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;初始化g(0) = 1，x(0) = 4，ρ=0.9，η=0.01，ε=10-10&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第①次迭代：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134825988-722663580.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134825988-722663580.png&quot; alt=&quot;img&quot; width=&quot;309&quot; height=&quot;84&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第②次迭代：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134834239-1810360221.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134834239-1810360221.png&quot; alt=&quot;img&quot; width=&quot;326&quot; height=&quot;75&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;求解的过程如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134849805-1127173238.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703134849805-1127173238.png&quot; alt=&quot;img&quot; width=&quot;613&quot; height=&quot;294&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对应代码为：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot as plt
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; mpl_toolkits.mplot3d &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Axes3D

fig &lt;/span&gt;=&lt;span&gt; plt.figure()
x &lt;/span&gt;= np.arange(-4, 4, 0.025&lt;span&gt;)
plt.plot(x,x&lt;/span&gt;**2&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y = x^2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x**2
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; h(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2*&lt;span&gt;x
g &lt;/span&gt;= 1&lt;span&gt;
x &lt;/span&gt;= 4&lt;span&gt;
ρ &lt;/span&gt;= 0.9&lt;span&gt;
η &lt;/span&gt;= 0.01&lt;span&gt;
ε &lt;/span&gt;= 10e-10&lt;span&gt;
iters &lt;/span&gt;=&lt;span&gt; 0
X &lt;/span&gt;=&lt;span&gt; []
Y &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; iters&amp;lt;12&lt;span&gt;:
    iters&lt;/span&gt;+=1&lt;span&gt;
    X.append(x)
    Y.append(f(x))
    g &lt;/span&gt;= ρ*g+(1-ρ)*h(x)**2&lt;span&gt;
    x &lt;/span&gt;= x - η/np.sqrt(g+ε)*&lt;span&gt;h(x)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(iters,x)
plt.plot(X,Y,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ax &lt;/span&gt;=&lt;span&gt; plt.subplot()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(X)):
    ax.text(X[i], (X[i])&lt;/span&gt;**2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;({:.3f},{:.3f})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(X[i], (X[i])**2), color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;Momentum法&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Momentum是动量的意思，想象一下，一个小车从高坡上冲下来，他不会停在最低点，因为他还有一个动量，还会向前冲，甚至可以冲过一些小的山丘，如果面对的是较大的坡，他可能爬不上去，最终又会倒车回来，折叠几次，停在谷底。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135026548-183730178.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135026548-183730178.png&quot; alt=&quot;img&quot; width=&quot;571&quot; height=&quot;215&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果使用的是没有动量的梯度下降法，则可能会停到第一个次优解&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135113046-618759366.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135113046-618759366.png&quot; alt=&quot;img&quot; width=&quot;555&quot; height=&quot;198&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;最直观的理解就是，若当前的梯度方向与累积的历史梯度方向一致，则当前的梯度会被加强，从而这一步下降的幅度更大。若当前的梯度方向与累积的梯度方向不一致，则会减弱当前下降的梯度幅度。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135157742-169502057.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135157742-169502057.png&quot; alt=&quot;img&quot; width=&quot;434&quot; height=&quot;311&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;从这幅图可以看出来，当小球到达A点处，负梯度方向的红箭头朝着x轴负向，但是动量方向（绿箭头）朝着x轴的正向并且长度大于红箭头，因此小球在A处还会朝着x轴正向移动。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面正式介绍Momentum法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;假设N元函数f(x)，针对一个自变量研究Momentum梯度下降的迭代过程，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135214379-1455238698.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135214379-1455238698.png&quot; alt=&quot;img&quot; width=&quot;165&quot; height=&quot;76&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;v表示动量，初始v=0&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;α是一个接近于1的数，一般设置为0.9，也就是把之前的动量缩减到0.9倍&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;η是学习率&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面通过一个例子演示一下，求y = 2*x^4-x^3-x^2的极小值点&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135316532-1321014342.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135316532-1321014342.png&quot; alt=&quot;img&quot; width=&quot;552&quot; height=&quot;283&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可以看出从-0.8开始迭代，依靠动量成功越过第一个次优解，发现无法越过最优解，折叠回来，最终收敛到最优解。对应代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot as plt
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

fig &lt;/span&gt;=&lt;span&gt; plt.figure()
x &lt;/span&gt;= np.arange(-0.8, 1.2, 0.025&lt;span&gt;)
plt.plot(x,&lt;/span&gt;-x**3-x**2+2*x**4&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y = 2*x^4-x^3-x^2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2*x**4-x**3-x**2
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; h(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 8*x**3 - 3*x**2 - 2*&lt;span&gt;x
η &lt;/span&gt;= 0.05&lt;span&gt;
α &lt;/span&gt;= 0.9&lt;span&gt;
v &lt;/span&gt;=&lt;span&gt; 0
x &lt;/span&gt;= -0.8&lt;span&gt;
iters &lt;/span&gt;=&lt;span&gt; 0
X &lt;/span&gt;=&lt;span&gt; []
Y &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; iters&amp;lt;12&lt;span&gt;:
    iters&lt;/span&gt;+=1&lt;span&gt;
    X.append(x)
    Y.append(f(x))
    v &lt;/span&gt;= α*v - η*&lt;span&gt;h(x)
    x &lt;/span&gt;= x +&lt;span&gt; v
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(iters,x)
plt.plot(X,Y)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Adam法&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;Adam实际上是把momentum和RMSprop结合起来的一种算法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;假设N元函数f(x)，针对一个自变量研究Adam梯度下降的迭代过程，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面依次解释这五个式子：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1507784/201909/1507784-20190910082641303-1089503937.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;在①式中，注意m(n)是反向的动量与梯度的和（而在Momentum中是正向动量与负梯度的和，因此⑤式对应的是减号）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在②式中，借鉴的是RMSprop的指数衰减&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;③和④式目的是纠正偏差&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;⑤式进行梯度更新&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举例：使用Adagrad算法求y = x2的最小值点&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;导函数为h(x) = 2x&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;初始化x(0) = 4，m(0) = 0，v(0) = 0，β1=0.9，β2=0.999，ε=10-8，η = 0.001&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第①次迭代：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135502705-454790823.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135502705-454790823.png&quot; alt=&quot;img&quot; width=&quot;342&quot; height=&quot;178&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第②次迭代：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135511106-96974125.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135511106-96974125.png&quot; alt=&quot;img&quot; width=&quot;442&quot; height=&quot;176&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;求解的过程如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135525336-1238134557.png&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1244340/201907/1244340-20190703135525336-1238134557.png&quot; alt=&quot;img&quot; width=&quot;610&quot; height=&quot;298&quot; data-alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对应代码为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot as plt
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; mpl_toolkits.mplot3d &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Axes3D

fig &lt;/span&gt;=&lt;span&gt; plt.figure()
x &lt;/span&gt;= np.arange(-4, 4, 0.025&lt;span&gt;)
plt.plot(x,x&lt;/span&gt;**2&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y = x^2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x**2
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; h(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2*&lt;span&gt;x
x &lt;/span&gt;= 4&lt;span&gt;
m &lt;/span&gt;=&lt;span&gt; 0
v &lt;/span&gt;=&lt;span&gt; 0
β1 &lt;/span&gt;= 0.9&lt;span&gt;
β2 &lt;/span&gt;= 0.999&lt;span&gt;
η &lt;/span&gt;= 0.001&lt;span&gt;
ε &lt;/span&gt;= 10e-8&lt;span&gt;
iters &lt;/span&gt;=&lt;span&gt; 0
X &lt;/span&gt;=&lt;span&gt; []
Y &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; iters&amp;lt;12&lt;span&gt;:
    iters&lt;/span&gt;+=1&lt;span&gt;
    X.append(x)
    Y.append(f(x))
    m &lt;/span&gt;= β1*m + (1-β1)*&lt;span&gt;h(x)
    v &lt;/span&gt;= β2*v + (1-β2)*h(x)**2&lt;span&gt;
    m_het &lt;/span&gt;= m/(1-β1**&lt;span&gt;iters)
    v_het &lt;/span&gt;= v/(1-β2**&lt;span&gt;iters)
    x &lt;/span&gt;= x - η/np.sqrt(v_het+ε)*&lt;span&gt;m_het
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(iters,x)
plt.plot(X,Y,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ax &lt;/span&gt;=&lt;span&gt; plt.subplot()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(X)):
    ax.text(X[i], (X[i])&lt;/span&gt;**2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;({:.3f},{:.3f})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(X[i], (X[i])**2), color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 00:28:00 +0000</pubDate>
<dc:creator>Timcode</dc:creator>
<og:description>改进版梯度下降 发展历史 标准梯度下降法的缺陷 如果学习率选的不恰当会出现以上情况 因此有一些自动调学习率的方法。一般来说，随着迭代次数的增加，学习率应该越来越小，因为迭代次数增加后，得到的解应该比较</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TimVerion/p/11495327.html</dc:identifier>
</item>
<item>
<title>一文看尽Java-多线程概念 - 大魔王先生</title>
<link>http://www.cnblogs.com/wtzbk/p/11489059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wtzbk/p/11489059.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    主要讲解一下多线程中的一些概念，本文之后就开始针对JUC包的设计开始解读；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;1.存在共享数据(临界资源)；2.多个线程同时操作共享数据；只有同时出现这两种情况的时候才会造成线程安全问题；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;解决线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据以后在对共享数据进行操作；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;多线程特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    原子性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 现在的操作系统主要是通过时间分片的形式来管理线程或者进程，Java编程语言一句语言需要多条CPU指令来完成，Java在多线程切换的时候由于不满足原子性的特征，导致共享变量产生意料之外的结果；典型的count+=1，如下图，共享变量的count的指最终结果是1而不是2；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201909/1005447-20190908210105040-550255983.png&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;269&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/strong&gt;在多处理器(CPU)系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，整体结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201909/1005447-20190908211732045-765161641.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;258&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在单核CPU的情况下，CPU缓存与内存数据一致性问题容易处理，因为所有线程的操作都是针对同一个CPU的缓存，一个线程对缓存的写对于另外的线程一定是可见的，整体的执行情况如下图：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201909/1005447-20190908212216876-1922987092.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    在多CPU的情况下，每个CPU都有自己的缓存，这个时候每个共享变量在CPU中的缓存都是不可见的，这个时候就产生了CPU缓存与内存数据一致性的问题，整体执行的情况如下图，由于count变量分别在不同的CPU上执行，相互看不到对方的操作，这个时候变量count就会不一致，产生意料之外的结果，针对这种我也写了一个demo；&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201909/1005447-20190908213504419-739530906.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('62be0fb5-1d87-4338-bb6f-679c31782a37')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_62be0fb5-1d87-4338-bb6f-679c31782a37&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_62be0fb5-1d87-4338-bb6f-679c31782a37&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('62be0fb5-1d87-4338-bb6f-679c31782a37',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_62be0fb5-1d87-4338-bb6f-679c31782a37&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wtz
 *
 * 线程可见性demo
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadVisiable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; retry = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (retry &amp;lt; 10000&lt;span&gt;) {
            count &lt;/span&gt;+= 1&lt;span&gt;;
            retry&lt;/span&gt;++&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sumCount() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {

        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            add();
        });

        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            add();
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        ThreadVisiable threadVisiable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadVisiable();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; threadVisiable.sumCount();
        System.out.println(count);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    &lt;strong&gt;有序性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 编译器为了优化性能，有的时候会改变程序中语句的执行顺序，在Java经典的双重检查创建单例模式，就是其中的一个体现，代码如下图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('29aba8b7-9d3c-47f5-b824-26cc89a87c22')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_29aba8b7-9d3c-47f5-b824-26cc89a87c22&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_29aba8b7-9d3c-47f5-b824-26cc89a87c22&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('29aba8b7-9d3c-47f5-b824-26cc89a87c22',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_29aba8b7-9d3c-47f5-b824-26cc89a87c22&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wtz
 * &amp;lt;p&amp;gt;
 * 双重锁定单例模式 指令重排
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton singleton;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (Singleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    singleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    代码整体上看起来无任何瑕疵，但是实际这个方法并不完美，问题出在new的操作上，正常情况下new Singleton()执行的操作如下步骤：&lt;/p&gt;
&lt;p&gt;    1.在内存中分配一块空间；&lt;/p&gt;
&lt;p&gt;    2.在内存上初始化Singleton对象；&lt;/p&gt;
&lt;p&gt;    3.将内存地址赋值给singleton变量；&lt;/p&gt;
&lt;p&gt;    经过编译器优化以后可能是这个样子：&lt;strong&gt;  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    1.在内存中分配一块空间；&lt;/p&gt;
&lt;p&gt;    2.将内存地址赋值给singleton变量；&lt;/p&gt;
&lt;p&gt;    3.在内存上初始化Singleton对象； &lt;/p&gt;
&lt;p&gt;    优化以后当CPU时间片切换时间刚好是线程B判断为空的时候，这个时候singleton此时不为空，不需要进入锁中，这个时候就返回为初始化的singleton,整体性执行过程如下图：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201909/1005447-20190908215816413-644391312.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;363&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    竞态条件&amp;amp;临界区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;互斥锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;互斥锁解决了并发程序中的原子性问题,保证同一时刻只有一个线程执行，保证了一个或多个操作在CPU执行的过程中不被中断，Java原生语言主要是通过synchronized实现互斥锁；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    Java内存模型&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;    Java内存模型主要是为了解决内存可见性和指令重排(编译优化)的问题，使用内存模型约束了CPU缓存和编译优化；Java内存模型(JMM)从不同的角度来说都可以说很多的东西，比如从线程角度来说，JMM规范不同线程之间线程通信的问题，从操作系统的角度来说，JMM规范了工作线程与内存之间访问的问题；我们主要从程序员角度来看这个问题的话我认为可以从三方面说起：&lt;/p&gt;
&lt;p&gt;    1.volatile、synchronized和final语义；&lt;/p&gt;
&lt;p&gt;    2.JUC并发包；&lt;/p&gt;
&lt;p&gt;    3.happens-before；&lt;/p&gt;
&lt;p&gt;    我们主要说第3点，第1，2点以后在补充，我们先要明白一些概念，才能更好的理解后面的一些内容；happens-before主要有8个原则，我们通俗的话来讲讲：&lt;/p&gt;
&lt;p&gt;    1.程序的顺序性，单线程的每个前面的操作优先于后面的操作；&lt;/p&gt;
&lt;p&gt;    2.volatile，对于volatile修饰的变量，写的操作一定优先于读的操作，也就是说对变量写操作对于后续的读操作都是可见的；&lt;/p&gt;
&lt;p&gt;    3.锁，解锁的操作优先于加锁的操作，在Java锁指的就是synchronized，变量在解锁之前的操作，在重新加锁之后一定可以看到；&lt;/p&gt;
&lt;p&gt;    4.传递性，A优先于B，B优先于C，则A优先于C；&lt;/p&gt;
&lt;p&gt;    5.线程开始原则，主线程A启动子线程B，则子线程B能够看到主线程A在启动B子线程之前的操作；&lt;/p&gt;
&lt;p&gt;    6.线程终止原则，主线程A等待子线程B完成，当子线程B完成以后，主线程A能够看到子线程的B的操作；&lt;/p&gt;
&lt;p&gt;    7.线程中断原则，对线程interrupt()方法优先于发生被中断线程检测到中断事件的发生；&lt;/p&gt;
&lt;p&gt;    8.对象终结规则，构造函数的执行一定优先于它的finalize方法；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;等待-通知机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 等待-通知机制主要是为了处理循环等待造成的CPU消耗问题，主要有以下两个步骤：&lt;/p&gt;
&lt;p&gt;    1.线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；&lt;/p&gt;
&lt;p&gt;    2.当要求的条件满足时，通知等待的线程，重新获取互斥锁；&lt;/p&gt;
&lt;p&gt;    Java原生语言主要是通过&lt;code&gt;synchronized + wait + notify/notifyAll实现；&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;活跃性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    死锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 死锁的定义一组相互竞争资源的线程因相互等待，导致永久阻塞的现象，发生死锁必备的四个条件：&lt;/p&gt;
&lt;p&gt;    1.互斥，共享资源同时只有占用一个线程；&lt;/p&gt;
&lt;p&gt;    2.占有且等待，线程A获取共享资源X，在等待共享资源Y的时候，不是释放共享资源Y；&lt;/p&gt;
&lt;p&gt;    3.不可抢占，其他线程不能抢占线程A获取的共享资源；&lt;/p&gt;
&lt;p&gt;    4.循环等待，线程A等待线程B获取的共享资源，线程B等待线程A获取的共享资源；&lt;/p&gt;
&lt;p&gt;    只要破坏其中任意一个条件就可以跑坏死锁；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;活锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 线程之间互相谦让，导致线程无法执行下去，解决方案通过给线程随机等待一个时间；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;饥饿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 线程不能正常的访问共享资源，并且无法执行下去，解决线程饥饿的办法：&lt;/p&gt;
&lt;p&gt;    1.保证资源的公平性，也就线程的优先级一样；&lt;/p&gt;
&lt;p&gt;    2.保证资源充足；&lt;/p&gt;
&lt;p&gt;    3.避免线程长时间占用锁执行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 三、结束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;欢迎大家加群438836709！欢迎大家关注我！&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201906/1005447-20190620221533393-1847070636.png&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 00:27:00 +0000</pubDate>
<dc:creator>大魔王先生</dc:creator>
<og:description>一、前言 主要讲解一下多线程中的一些概念，本文之后就开始针对JUC包的设计开始解读； 二、概念 线程安全 1.存在共享数据(临界资源)；2.多个线程同时操作共享数据；只有同时出现这两种情况的时候才会造</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wtzbk/p/11489059.html</dc:identifier>
</item>
<item>
<title>不要小看小小的 emoji 表情 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/11495319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/11495319.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082109805-1343494230.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好久没更新了，最近事比较多，或许下个月就会恢复到正常的发文频次。&lt;/p&gt;
&lt;p&gt;这篇文章得从一个 &lt;code&gt;emoji&lt;/code&gt; 表情开始，我之前开源的一个 &lt;code&gt;IM&lt;/code&gt; 项目中有朋友提到希望可以支持 &lt;code&gt;emoji&lt;/code&gt; 表情传输。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/crossoverJie/cim/issues/12&quot; class=&quot;uri&quot;&gt;https://github.com/crossoverJie/cim/issues/12&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082112119-1967054692.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正好那段时间有空，加上这功能看着也比较简单准备把它实现了。&lt;/p&gt;
&lt;p&gt;但在真正实现时却发现没那么简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082112351-991754317.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我首先尝试将一个 &lt;code&gt;emoji&lt;/code&gt; 表情存入数据库看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082112531-1187598615.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;果不其然的出错了，导致这个异常的原因是目前数据库所支持的编码中并不能存放 &lt;code&gt;emoji&lt;/code&gt;，那 &lt;code&gt;emoji&lt;/code&gt; 表情到底是个什么东西呢。&lt;/p&gt;
&lt;p&gt;本质上来说计算机所存储的信息都是二进制 &lt;code&gt;01&lt;/code&gt;，&lt;code&gt;emoji&lt;/code&gt; 也不例外，只要存储和读取（编解码）的方式一致那就可以准确的展示这个信息。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;更多编解码的内容后文再介绍，这里先想想如何快速解决问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;虽说想要在 &lt;code&gt;MySQL&lt;/code&gt; 中存储 &lt;code&gt;emoji&lt;/code&gt; 的方式也有好几种，比如可以升级存储字符集到可以存放 &lt;code&gt;emoji&lt;/code&gt; ，但这种需要 &lt;code&gt;MySQL&lt;/code&gt; 的版本支持。&lt;/p&gt;
&lt;p&gt;所以更保险的方式还是在应用层解决，比如我们是否可以将 emoji 当做字符串存储，只是显示的时候要格式化为一个 emoji 表情，这样对于所有的数据库版本都可兼容。&lt;/p&gt;
&lt;p&gt;于是我们这里的需求是一个 &lt;code&gt;emoji&lt;/code&gt; 表情转换为字符串，同时还得将这个字符串转换为 emoji。&lt;/p&gt;
&lt;p&gt;为此我在 &lt;code&gt;GitHub&lt;/code&gt; 上找到了一个库，它可以方便的将一个 &lt;code&gt;emoji&lt;/code&gt; 转换为字符串的别名，同时也支持将这个别名转换为 &lt;code&gt;emoji&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vdurmont/emoji-java&quot; class=&quot;uri&quot;&gt;https://github.com/vdurmont/emoji-java&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Test
    public void emoji() throws Exception{
        String str = &quot;An :grinning:awesome :smiley:string &amp;amp;#128516;with a few :wink:emojis!&quot;;
        String result = EmojiParser.parseToUnicode(str);
        System.out.println(result);

        result = EmojiParser.parseToAliases(str);
        System.out.println(result);

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082113024-1143483669.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以基于这个基础库最终实现了表情功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082114747-4260807.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实它本质上是自己维护了一个 emoji 的别名及它的 Unicode 编码(本质上是 &lt;code&gt;UTF-16&lt;/code&gt;)的映射关系，再每次格式化数据的时候都会从这个表中进行翻译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082116905-1266313205.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;自此需求是完成了，但还有几个问题待解决。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Java&lt;/code&gt; 中是如何存储 &lt;code&gt;emoji&lt;/code&gt; 的？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;emoji&lt;/code&gt; 是如何进行编码的？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;ascii&quot;&gt;ASCII&lt;/h2&gt;
&lt;p&gt;在谈 &lt;code&gt;emoji&lt;/code&gt; 之前非常有必要了解下计算机编码鼻祖的 ASCII 码。&lt;/p&gt;
&lt;p&gt;大家现在都知道在计算机内部存储数据本质上都是二进制的 0/1，对于一个字节来说有 8 位；每一位可以表示两种状态，也就是 0 或 1，这样排列组合下来，一个字节就可以表示 256(2∧8) 种不同的状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082117171-975280922.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;对于美国来说他们日常使用的英语只需要 26 个英文字母，再加上一些标点符号就足够用计算机来进行信息交流。&lt;/p&gt;
&lt;p&gt;于是上个世纪 60年代定义了一套二进制与英文字符的映射关系，可以表明 128 个不同的英文字符，也就是现在的 &lt;code&gt;ASCII&lt;/code&gt; 码。&lt;/p&gt;
&lt;p&gt;这样我们就可以使用一个字节来表示现代英文，看起来非常不错。&lt;/p&gt;
&lt;h2 id=&quot;unicode&quot;&gt;Unicode&lt;/h2&gt;
&lt;p&gt;随着计算机的发展，逐渐在欧洲、亚洲地区流行；再利用这套 &lt;code&gt;ASCII&lt;/code&gt; 码进行信息交流显然是不行的，很多地区压根就不使用英文，而且也远超了 128 位字符（中文就更不用说了）。&lt;/p&gt;
&lt;p&gt;虽说一个字节在 &lt;code&gt;ASCII&lt;/code&gt; 码中只用了 &lt;code&gt;128&lt;/code&gt; 位，但剩下(&lt;code&gt;258-128&lt;/code&gt;)的依然不足用用于描述其他语言。&lt;/p&gt;
&lt;p&gt;这时如果能有一种包含了世界上所有的文字的字符集，每一个地区的文字都在这个字符集中有唯一的二进制表示，这样便不会出现乱码问题了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt; 就是来做这个的，截止目前 &lt;code&gt;Unicode&lt;/code&gt; 已经收录了 10W+ 的字符，你所能使用的字符都包含进去了。&lt;/p&gt;
&lt;h2 id=&quot;utf-8&quot;&gt;UTF-8&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt; 虽说包含了几乎所有的文字，但在我们日常使用好像很少看到他的身影，我们用的更多的还是 &lt;code&gt;UTF-8&lt;/code&gt; 这样的编码规则。&lt;/p&gt;
&lt;p&gt;这也有几方面的原因，比如说除开英文，其他大部分的文字都需要用 2 个甚至更多的字节来表示；如果统一都用 Unicode 来表示，那必然需要以占用字节最多的字符长度为标准。&lt;/p&gt;
&lt;p&gt;比如汉字需要 2 个字节来表示，而英文只需要一个字节；这时就得规定 2 个字节表示一个字符，不然汉字就没法表示了。&lt;/p&gt;
&lt;p&gt;但这样也会带来一个问题：用两个字节表示英文会使得第一个字节完全是浪费的，如果一段信息全是英文那对内存的浪费是巨大的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这时大家应该都能想到，我们需要一个可变的长度的字符编码规则，当是英文时我们就用一个字节表示，甚至可以完全兼容 ASCII 码。&lt;/p&gt;
&lt;p&gt;UTF-8 便是实现这个需求的，它利用两种规则可以表示一个字节以及多字节的字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082117614-1640146331.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当第一个字节的第一位为 0 时便表示为单字节字符，此时和 ASCII 码一致，完全兼容。&lt;/li&gt;
&lt;li&gt;当第一个字节为 1 时，有几个 1 便代表是几个字节 Unicode 字符。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样便可根据字符的长度最大程度的节省存储空间。&lt;/p&gt;
&lt;p&gt;当然还有其他的编码规则，比如 &lt;code&gt;UTF-16&lt;/code&gt;、&lt;code&gt;UTF-32&lt;/code&gt;，平时用的不多，但本质上都和 &lt;code&gt;UTF-8&lt;/code&gt; 一样，都是 &lt;code&gt;Unicode&lt;/code&gt; 的不同实现，也是用于表示世界上大部分文字的字符集。&lt;/p&gt;

&lt;p&gt;现在来回到本次的主题，&lt;code&gt;emoji&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;刚才说到 &lt;code&gt;Unicode&lt;/code&gt; 包含了世界上大部分的字符，&lt;code&gt;emoji&lt;/code&gt; 自然也不例外。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082120026-659514237.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://apps.timwhitlock.info/emoji/tables/unicode&quot; class=&quot;uri&quot;&gt;https://apps.timwhitlock.info/emoji/tables/unicode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个表格中包含了所有的 &lt;code&gt;emoji&lt;/code&gt; 以及它所对应的 &lt;code&gt;Unicode&lt;/code&gt; 编码，同时也有对应的 &lt;code&gt;UTF-8&lt;/code&gt; 编码的实现。&lt;/p&gt;
&lt;p&gt;从图中也可以看出 &lt;code&gt;emoji&lt;/code&gt; 表情用 &lt;code&gt;UTF-8&lt;/code&gt; 表示时会占用 4 个字节，那在 Java 中它会是怎么存储的呢？&lt;/p&gt;
&lt;p&gt;很简单，debug 一下就知道了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082121203-2005964474.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 中也是通过 &lt;code&gt;char&lt;/code&gt; 来存储 &lt;code&gt;emoji&lt;/code&gt; 的，&lt;code&gt;char&lt;/code&gt; 作为基本数据类型会占用 2 个字节；从刚才的图中可以看出，&lt;code&gt;emoji&lt;/code&gt; 使用 &lt;code&gt;UTF-8&lt;/code&gt; 会占用四个字节，这样很明显 &lt;code&gt;char&lt;/code&gt; 是没法存储的，所以在这里其实是使用 &lt;code&gt;UTF-16&lt;/code&gt; 编码进行存储。&lt;/p&gt;
&lt;p&gt;基于这个原理，我们也可以自己实现将一个 &lt;code&gt;emoji&lt;/code&gt; 表情转换为字符串，同时也可通过字符串转换为 &lt;code&gt;emoji&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201909/1431471-20190910082122945-1680691556.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从这次研究 &lt;code&gt;emoji&lt;/code&gt; 可以看出，任何一门基础知识都是应用的根基，在计算机行业尤为突出，希望大家看完这篇能回忆起大学课堂被老师支配的恐惧😂。&lt;/p&gt;
&lt;p&gt;随便提一下，相关源码可在这里查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/crossoverJie/cim&quot; class=&quot;uri&quot;&gt;https://github.com/crossoverJie/cim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 00:21:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前言 好久没更新了，最近事比较多，或许下个月就会恢复到正常的发文频次。 这篇文章得从一个 表情开始，我之前开源的一个 项目中有朋友提到希望可以支持 表情传输。 'https://github.com/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/11495319.html</dc:identifier>
</item>
<item>
<title>Spring.Net是怎么在MVC中实现注入的（原理） - MedlarCanFly</title>
<link>http://www.cnblogs.com/MedlarCanFly/p/11488689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MedlarCanFly/p/11488689.html</guid>
<description>&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;本文将介绍Spring.Net（不仅仅是Spring.Net,其实所有的IoC容器要向控制器中进行注入，原理都是差不多的）在MVC控制器中依赖注入的实现原理，&lt;strong&gt;本文并没有关于在MVC使用Spring怎么配置，怎么使用，怎么实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引言放在前面，只是为了避免浪费你的时间。&lt;/p&gt;
&lt;p&gt;望你能&lt;strong&gt;静心片刻&lt;/strong&gt;，认真阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;防止爬虫，加个链接：&lt;a title=&quot;https://www.cnblogs.com/MedlarCanFly/p/11488689.html&quot; href=&quot;https://www.cnblogs.com/MedlarCanFly/p/11488689.html&quot;&gt;https://www.cnblogs.com/MedlarCanFly/p/11488689.html&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('abf860a5-876b-4cce-a5f8-1a6101abfa2a')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_abf860a5-876b-4cce-a5f8-1a6101abfa2a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_abf860a5-876b-4cce-a5f8-1a6101abfa2a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('abf860a5-876b-4cce-a5f8-1a6101abfa2a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_abf860a5-876b-4cce-a5f8-1a6101abfa2a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是一个很神奇的注入&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; IBLL.IUserInfoService UserInfoService { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Content(UserInfoService.GetName());
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;每次看代码都有不一样的理解，今天我在看MVC控制器中一个通过Spring.Net依赖注入的UserInfoService属性时，突然有些疑问，&lt;strong&gt;注入的前提是控制反转&lt;/strong&gt;，这么说我的&lt;strong&gt;Controller是从IoC容器中来的了？&lt;/strong&gt;但是我不记得在哪个地方有配置额，对此我展开了深入的研究。&lt;/p&gt;

&lt;p&gt;首先我们要搞懂MVC本身是通过什么方式获取控制器对象的，&lt;strong&gt;本质如果都没有搞懂，又何来扩展呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在MVC模式下，通过实现IControllerFactory接口的对象来获取当前请求的控制器对象，实现IControllerFactory接口的对象也就是控制器的创建工厂。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单看下IControllerFactory&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1681a876-94b7-4029-a73e-b42bb3be24b8')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_1681a876-94b7-4029-a73e-b42bb3be24b8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1681a876-94b7-4029-a73e-b42bb3be24b8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1681a876-94b7-4029-a73e-b42bb3be24b8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1681a876-94b7-4029-a73e-b42bb3be24b8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     定义控制器工厂所需的方法。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IControllerFactory
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     使用指定的请求上下文来创建指定的控制器。
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   requestContext:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     请求上下文。
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controllerName:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器的名称。
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器。&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         IController CreateController(RequestContext requestContext, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; controllerName);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     获取控制器的会话行为。
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   requestContext:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     请求上下文。
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controllerName:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     你想要获取器其会话行为的控制器的名称。
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器的会话行为。&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         SessionStateBehavior GetControllerSessionBehavior(RequestContext requestContext, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; controllerName);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     释放指定的控制器。
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controller:
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器。&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReleaseController(IController controller);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;一个Http请求过来，选择哪个控制器是通过MvcHandler来处理的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制器工厂是通过ControllerBuilder的Current属性提供给MvcHandler使用的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的代码是反编译过来的，简单看下即可(因为我要标记黄色高亮部分，所以没有折叠)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt;&lt;span&gt; ControllerBuilder ControllerBuilder
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;get&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;._controllerBuilder == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;&lt;span&gt;this&lt;/span&gt;._controllerBuilder =&lt;span&gt; ControllerBuilder.Current;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._controllerBuilder;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;._controllerBuilder =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcHandler : IHttpAsyncHandler, IHttpHandler, IRequiresSessionState
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fields&lt;/span&gt;
&lt;span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ControllerBuilder _controllerBuilder;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; _processRequestTag;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; MvcVersion;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; MvcVersionHeaderName;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Methods&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MvcHandler();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MvcHandler(RequestContext requestContext);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddVersionHeader(HttpContextBase httpContext);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IAsyncResult BeginProcessRequest(HttpContext httpContext, AsyncCallback callback, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; state);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IAsyncResult BeginProcessRequest(HttpContextBase httpContext, AsyncCallback callback, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; state);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EndProcessRequest(IAsyncResult asyncResult);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetMvcVersionString();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessRequest(HttpContext httpContext);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessRequest(HttpContextBase httpContext);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProcessRequestInit(HttpContextBase httpContext, &lt;span&gt;out&lt;/span&gt; IController controller, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; IControllerFactory factory);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RemoveOptionalRoutingParameters();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     IAsyncResult IHttpAsyncHandler.BeginProcessRequest(HttpContext context, AsyncCallback cb, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; extraData);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; IHttpAsyncHandler.EndProcessRequest(IAsyncResult result);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; IHttpHandler.ProcessRequest(HttpContext httpContext);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Properties&lt;/span&gt;
&lt;span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;internal&lt;/span&gt; ControllerBuilder ControllerBuilder { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; DisableMvcResponseHeader { &lt;span&gt;get&lt;/span&gt;; [CompilerGenerated] &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsReusable { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; RequestContext RequestContext { &lt;span&gt;get&lt;/span&gt;; [CompilerGenerated] &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; IHttpHandler.IsReusable { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nested Types&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    [Serializable, CompilerGenerated]
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &amp;lt;&amp;gt;&lt;span&gt;c
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fields&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; MvcHandler.&amp;lt;&amp;gt;c &amp;lt;&amp;gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BeginInvokeDelegate&amp;lt;MvcHandler.ProcessRequestState&amp;gt; &amp;lt;&amp;gt;&lt;span&gt;9__20_0;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; EndInvokeVoidDelegate&amp;lt;MvcHandler.ProcessRequestState&amp;gt; &amp;lt;&amp;gt;&lt;span&gt;9__20_1;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Func&amp;lt;KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt; &amp;lt;&amp;gt;&lt;span&gt;9__26_0;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Methods&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &amp;lt;&amp;gt;&lt;span&gt;c();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &amp;lt;&amp;gt;&lt;span&gt;c();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt; IAsyncResult &amp;lt;BeginProcessRequest&amp;gt;b__20_0(AsyncCallback asyncCallback, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; asyncState, MvcHandler.ProcessRequestState innerState);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &amp;lt;BeginProcessRequest&amp;gt;&lt;span&gt;b__20_1(IAsyncResult asyncResult, MvcHandler.ProcessRequestState innerState);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &amp;lt;RemoveOptionalRoutingParameters&amp;gt;b__26_0(KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; entry);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    [StructLayout(LayoutKind.Sequential)]
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ProcessRequestState
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt;&lt;span&gt; IAsyncController AsyncController;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt;&lt;span&gt; IControllerFactory Factory;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt;&lt;span&gt; RequestContext RequestContext;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReleaseController();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;默认情况下，在ControllerBuilder内部会创建一个DefaultControllerFactory类型的对象，以提供处理请求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DefaultControllerFactory是实现IControllerFactory接口的。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0500e219-3322-462d-8912-3612ed434c53')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_0500e219-3322-462d-8912-3612ed434c53&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0500e219-3322-462d-8912-3612ed434c53&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0500e219-3322-462d-8912-3612ed434c53',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0500e219-3322-462d-8912-3612ed434c53&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     表示默认情况下已注册的控制器工厂。&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultControllerFactory : IControllerFactory
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     初始化 System.Web.Mvc.DefaultControllerFactory 类的新实例。&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultControllerFactory();
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     使用控制器激活器来初始化 System.Web.Mvc.DefaultControllerFactory 类的新实例。
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controllerActivator:
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     实现控制器激活器接口的对象。&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultControllerFactory(IControllerActivator controllerActivator);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     使用指定的请求上下文来创建指定的控制器。
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   requestContext:
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     HTTP 请求的上下文，其中包括 HTTP 上下文和路由数据。
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controllerName:
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器的名称。
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器。
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentNullException:
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     requestContext 参数为 null。
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentException:
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     controllerName 参数为 null 或为空。&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IController CreateController(RequestContext requestContext, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; controllerName);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     释放指定的控制器。
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controller:
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     要释放的控制器。&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReleaseController(IController controller);
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     检索指定请求上下文和控制器类型的控制器实例。
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   requestContext:
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     HTTP 请求的上下文，其中包括 HTTP 上下文和路由数据。
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controllerType:
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器的类型。
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器实例。
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.Web.HttpException:
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     controllerType 为 null。
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentException:
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     无法分配 controllerType。
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.InvalidOperationException:
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     无法创建 controllerType 的实例。&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IController GetControllerInstance(RequestContext requestContext, Type controllerType);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回控制器的会话行为。
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   requestContext:
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     请求上下文。
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controllerType:
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器的类型。
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器的会话行为。&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; SessionStateBehavior GetControllerSessionBehavior(RequestContext requestContext, Type controllerType);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     检索指定名称和请求上下文的控制器类型。
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   requestContext:
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     HTTP 请求的上下文，其中包括 HTTP 上下文和路由数据。
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   controllerName:
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器的名称。
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     控制器类型。&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Type GetControllerType(RequestContext requestContext, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; controllerName);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;默认情况下，&lt;strong&gt;Controller类需要提供默认的构造函数，因为DefaultControllerFactory是通过反射来创建Controller对象实例的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们定义的Controller需要通过构造函数创建，或者通过某个IoC容器管理Controller，可以通过自定义控制器工厂来实现。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为什么说这么多关于控制器工厂的东西呢，其实&lt;strong&gt;Spring.Net就是通过继承DefaultControllerFactory创建&lt;span class=&quot;pl-en&quot;&gt;SpringControllerFactory的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说了这么多就是为了后面可以更容易的理解Spring.Net的控制器工厂源码罢了。&lt;/p&gt;
&lt;p&gt;回归正题，接着创建自己的控制器工厂。&lt;/p&gt;
&lt;h2&gt;1.Home控制器内容如下&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; IUserInfoService UserInfoService { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HomeController(IUserInfoService userInfoService)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             UserInfoService =&lt;span&gt; userInfoService;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Content(UserInfoService.GetName());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的UserInfoService只是一个很简陋的测试类，只有一个GetName()方法用来返回“小明”。&lt;/p&gt;
&lt;p&gt;接下来将&lt;strong&gt;通过自定义控制器工厂实现构造注入UserInfoService&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2.创建控制器工厂MyControllerFactory&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为了方便我直接继承了DefaultControllerFactory，当然也可以通过实现IControllerFactory来创建&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyControllerFactory : DefaultControllerFactory
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IBLL.IUserInfoService userInfoService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BLL.UserInfoService();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写CreateController&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; IController CreateController(RequestContext requestContext, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; controllerName)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             IController controller = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (controllerName == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是我们制定的Home控制器则给其实例化，并通过构造参数注入userInfoService&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 controller = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HomeController(userInfoService);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过默认控制器工厂创建控制器&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 controller = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CreateController(requestContext, controllerName);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.在Global.asax中注册&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Application_Start()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             MyControllerFactory myControllerFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyControllerFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过ControllerBuilder设置制定的控制器工厂&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;            ControllerBuilder.Current.SetControllerFactory(myControllerFactory);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;            AreaRegistration.RegisterAllAreas();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            RouteConfig.RegisterRoutes(RouteTable.Routes);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4.运行测试（神奇不再神奇）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603175/201909/1603175-20190909230311746-1819068782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;意料之外，情理之中，我们并没有在控制器中实例化，结果却出来了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（实例化在工厂中完成了）&lt;/p&gt;


&lt;p&gt;说了这么多，回头看看标题“Spring.Net是怎么在MVC中实现注入的”，你倒是说啊，等的花都谢了，连Spring.Net的毛都没看到.....&lt;/p&gt;
&lt;p&gt;其实，&lt;strong&gt;如果你是认真读过来的，答案在你心中应该已经有了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开折叠，就是答案&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e74582dc-256c-488b-aec5-7e43d9f6b38d')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_e74582dc-256c-488b-aec5-7e43d9f6b38d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e74582dc-256c-488b-aec5-7e43d9f6b38d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e74582dc-256c-488b-aec5-7e43d9f6b38d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e74582dc-256c-488b-aec5-7e43d9f6b38d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Spring.Web.Mvc
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Controller Factory for ASP.NET MVC
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringControllerFactory : DefaultControllerFactory
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IApplicationContext _context;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the application context.
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;value&amp;gt;&lt;/span&gt;&lt;span&gt;The application context.&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IApplicationContext ApplicationContext
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (_context == &lt;span&gt;null&lt;/span&gt; || _context.Name !=&lt;span&gt; ApplicationContextName)
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(ApplicationContextName))
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                         _context =&lt;span&gt; ContextRegistry.GetContext();
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                         _context =&lt;span&gt; ContextRegistry.GetContext(ApplicationContextName);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _context;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets or sets the name of the application context.
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Defaults to using the root (default) Application Context.
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;value&amp;gt;&lt;/span&gt;&lt;span&gt;The name of the application context.&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ApplicationContextName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Creates the specified controller by using the specified request context.
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;requestContext&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The context of the HTTP request, which includes the HTTP context and route data.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;controllerName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The name of the controller.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;A reference to the controller.&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;exception cref=&quot;T:System.ArgumentNullException&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;paramref name=&quot;requestContext&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; parameter is null.&lt;/span&gt;&lt;span&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;exception cref=&quot;T:System.ArgumentException&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;paramref name=&quot;controllerName&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; parameter is null or empty.&lt;/span&gt;&lt;span&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; IController CreateController(RequestContext requestContext, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; controllerName)
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;            IController controller;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ApplicationContext.ContainsObjectDefinition(controllerName))
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                 controller = ApplicationContext.GetObject(controllerName) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IController;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 controller = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CreateController(requestContext, controllerName);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            AddActionInvokerTo(controller);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Retrieves the controller instance for the specified request context and controller type.
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;requestContext&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The context of the HTTP request, which includes the HTTP context and route data.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;controllerType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The type of the controller.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;The controller instance.&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;exception cref=&quot;T:System.Web.HttpException&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;     &lt;span&gt;&amp;lt;paramref name=&quot;controllerType&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; is null.&lt;/span&gt;&lt;span&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;exception cref=&quot;T:System.ArgumentException&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;     &lt;span&gt;&amp;lt;paramref name=&quot;controllerType&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; cannot be assigned.&lt;/span&gt;&lt;span&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;exception cref=&quot;T:System.InvalidOperationException&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;An instance of &lt;/span&gt;&lt;span&gt;&amp;lt;paramref name=&quot;controllerType&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; cannot be created.&lt;/span&gt;&lt;span&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; IController GetControllerInstance(RequestContext requestContext, Type controllerType)
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             IController controller = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (controllerType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; controllers =&lt;span&gt; ApplicationContext.GetObjectsOfType(controllerType);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (controllers.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                     controller =&lt;span&gt; (IController)controllers.First().Value;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (controller == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;pass to base class for remainder of handling if can't find it in the context&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;                 controller = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.GetControllerInstance(requestContext, controllerType);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;            AddActionInvokerTo(controller);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Adds the action invoker to the controller instance.
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;controller&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The controller.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddActionInvokerTo(IController controller)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (controller == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Controller).IsAssignableFrom(controller.GetType()))
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                 ((Controller)controller).ActionInvoker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringActionInvoker(ApplicationContext);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;关于代码我想就不用过多解释了，有了上面的知识基础，这就是一看就懂的那种。&lt;/p&gt;
&lt;p&gt;算了，我还是说一下CreateController方法吧，防止有不熟悉Spring.Net的小伙伴。&lt;/p&gt;

&lt;p&gt;ApplicationContext：这就是相当于IoC容器的东西&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-smi&quot;&gt;ApplicationContext.&lt;span class=&quot;pl-en&quot;&gt;ContainsObjectDefinition(&lt;span class=&quot;pl-smi&quot;&gt;controllerName)：返回容器中是否存在名称为controllerName的对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;仔细品味每一行代码，会发现任何东西都没有表面上那么简单，&lt;strong&gt;每一个实现的背后都值得深入研究。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码了这么长时间，&lt;strong&gt;希望能对正在阅读的你有所帮助。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参考书籍：《ASP.NET本质论》&lt;/p&gt;

&lt;p&gt;如有说的不清楚或者错误的地方，还望指正&lt;/p&gt;

</description>
<pubDate>Tue, 10 Sep 2019 00:18:00 +0000</pubDate>
<dc:creator>MedlarCanFly</dc:creator>
<og:description>本文将介绍Spring.Net（不仅仅是Spring.Net,其实所有的IoC容器要向控制器中进行注入，原理都是差不多的）在MVC控制器中依赖注入的实现原理，本文并没有关于在MVC使用Spring怎么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MedlarCanFly/p/11488689.html</dc:identifier>
</item>
</channel>
</rss>