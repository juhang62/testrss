<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从Java小白到阿里巴巴工程师，回顾我两年来的学习经历 - 程序员江湖_陆小凤</title>
<link>http://www.cnblogs.com/xll1025/p/10523435.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/10523435.html</guid>
<description>&lt;p&gt;本文首发于微信公众号【程序员江湖】&lt;/p&gt;
&lt;p&gt;作者How 2 Play Life，985 软件硕士，阿里 Java 研发工程师，在技术校园招聘、自学编程、计算机考研等方面有丰富经验和独到见解，目前致力于分享程序员干货和学习经验，同时热衷于分享作为程序员的一些成长心得和生活感悟。&lt;/p&gt;
&lt;p&gt;关注后在后台回复“资料”即可领取3T免费技术学习资料（包含作者的原创文章合集）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1452299/93ebhdi5iz.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;写在最前&lt;/p&gt;
&lt;p&gt;我写过很多篇秋招总结，这篇文章应该是最后一篇总结，当然也是最完整，最详细的一篇总结。秋招是我人生中一段宝贵的经历，不仅是我研究生生涯交出的一份答卷，也是未来职业生涯的开端。仅以此文，献给自己，以及各位在求职路上的，或者是已经经历过校招的朋友们。不忘初心，方得始终。&lt;/p&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;在下本是跨专业渣考研的985渣硕一枚，经历研究生两年的学习积累，有幸于2019秋季招聘中拿到几个公司的研发岗offer，包括百度，阿里，腾讯，今日头条，网易，华为等。&lt;/p&gt;
&lt;p&gt;（在秋招末期，有幸又拿到了滴滴和亚马逊的offer，那时已经11月份了，所以之前的文章里都没有提到过）&lt;/p&gt;
&lt;p&gt;一路走来也遇到很多困难，也踩了很多坑，同时我自己也探索了很多的学习方法，总结了很多心得体会，并且，我对校园招聘也做了一些研究和相应的准备。在今年的秋季招聘结束以后，我也决定把这些东西全部都写成文字，做成专题，以便分享给更多未来将要参加校招的同学。&lt;/p&gt;
&lt;p&gt;大学时期的迷茫与坚定&lt;/p&gt;
&lt;p&gt;我的本科专业是电子信息工程，基本没有接触过计算机专业的课程，只学过c语言，然后在大三的时候接触过java，Android，以及前端开发。这时候我只是一个刚刚入门的菜鸟，还不知道软件开发的水有多深，抱着试一试的态度去应聘了很多公司。结果可想而知，连简历筛选都没有通过。&lt;/p&gt;
&lt;p&gt;当年我对游戏开发很有兴趣，特别是对网易游戏情有独钟，但是当我看到网易游戏研发工程师的招聘要求时，我只能望而却步，因为它要求学历至少是985的硕士。&lt;/p&gt;
&lt;p&gt;也因为这个契机，我在大三的暑假开始准备考研，花了一个月的时间深思熟虑之后，选择了华科作为我的目标院校。&lt;/p&gt;
&lt;p&gt;于是，2016年的下半年，我成为了“两耳不闻窗外事，一心只读圣贤书”的考研党，回想起来那确实是玩命学习的半年时间，每天稳定泡在图书馆8个小时以上，有时候学到宿舍都能学到晚上12点，那时候感觉自己完全变了一个人似的，可能当一个人为了某个目标而努力时，真的会变得不一样。最终我顺利地考上了，令我意外的是，成绩还挺不错。&lt;/p&gt;
&lt;p&gt;研究生时期的方向选择&lt;/p&gt;
&lt;p&gt;对于即将读研的同学来说，一般有两件事很重要，一件事是选择导师，一件事是选择方向。&lt;/p&gt;
&lt;p&gt;我在刚读研的时候最头疼的也是这两件事情。首先说明一下，我读的是专硕，所以实验室一般不搞科研，有部分导师会带项目，由于我不打算在实验室做项目（因为我更希望去大公司里锻炼几年），所以我当时本着想要找实习的想法选择了导师，事实证明我的选择还是很正确的，我在研二有大段时间去参加实习，让我在大厂里有足够的时间去锻炼和学习。&lt;/p&gt;
&lt;p&gt;而选择方向这件事，我倒是折腾了好久。研一期间我做的最多的事情就是看书了，当时自己的方向还不明确，所以找了很多书来看。当别人都在专研数据挖掘和机器学习时，我还在各种方向之间摇摆不定。&lt;/p&gt;
&lt;p&gt;我在读研之前想做游戏开发和Android开发，但我以前也学过Java Web开发。于是我在网上了解对应方向的资讯，发现游戏研发的就业面比较窄。&lt;/p&gt;
&lt;p&gt;最后，我综合公司的岗位情况，个人兴趣，以及我之前的学习经历等因素，选定了Java开发方向。&lt;/p&gt;
&lt;p&gt;于是，我在学校的实训项目中选择了Java Web项目，从此也真正意义上地踏上了Java的学习之路。&lt;/p&gt;
&lt;p&gt;笨鸟先飞，勤能补拙&lt;/p&gt;
&lt;p&gt;尽管我的入学成绩是全学院的top3，但是，我发现，作为非科班出身的我，和很多科班同学相比，还是有一定差距的。&lt;/p&gt;
&lt;p&gt;大部分同学本科都上过计算机专业的相关课程，比如计算机网络，操作系统，数据结构等等，而我以前连听都没听过，除此之外，他们一般都会几段比较完整的项目经验，至少在Java Web方面已经算是比较熟悉了。而我在当时，只学了数据结构，另外接触过一些Java基础，有一部分项目经验，基本上就是入门水平。&lt;/p&gt;
&lt;p&gt;于是我痛定思痛，决定好好弥补我的不足，平时一有空就去图书馆找些书来看，不论是操作系统，计算机网络，还是数据库等本科课程，我都会找一些对应的书籍来看，当时不太清楚其实有些课程其实不需要特地去补，以至于我连计算机组成原理，编译原理，软件测试等方面的书都特地找来看，现在想想也是挺逗比的。&lt;/p&gt;
&lt;p&gt;由于我们上的课比较水，所以上课时间反而变成了我自学基础课程的大好时光了。所以我平时上课的时候都会带两三本书，一到两周内看完一本，虽然可能吸收的不是特别好，但是对当时的我来说还是有很大帮助的。&lt;/p&gt;
&lt;p&gt;除此之外，有时候我还会偷偷去旁听有一些本科生的课程，这也是因为我在自学一些课程的时候遇到了困难，比如《操作系统》，《数据库原理》等等。于是我花时间研究了一下本科生的课表，趁着自己没课的时候赶紧去旁听课程。有时候感觉自己在课堂中显得非常突兀，尴尬地想要逃跑，但总算是坚持地听完了一门数据库的课程。&lt;/p&gt;
&lt;p&gt;此外，我还在各种视频网站上看网课，比亦或是看中国MOOC的计算机基础课程，里面的操作系统，数据库等课程也让我印象深刻。&lt;/p&gt;
&lt;p&gt;就这样，每天我都把自己的时间填满，愣是在研一上学期看了好几本书，当时书的版本现在有的记不清了，主要是计算机网络，操作系统，计算机组成原理，另外还有软件工程，软件测试，设计模式，等书籍。就这样，我靠着这段时间的坚持把计算机基础课程补上来了一些。&lt;/p&gt;
&lt;p&gt;历尽艰辛，终得实习&lt;/p&gt;
&lt;p&gt;时间来到研一下半页，这时候我刚刚结束了学校的Java Web的项目实训课程，在做这个项目期间，我发现自己暴露出了很多问题，技术实践能力不足，Java基础不扎实。这件事情也给我自己敲响了警钟，因为我计划在春招期间找一份大厂的实习，但是目前看来我的水平还远远不够。&lt;/p&gt;
&lt;p&gt;压力之下，只有努力一条出路。于是，从那时候起，我开始了“留守“实验室的学习生活。为什么要在实验室学习，一是因为学习气氛好，二是因为平时大家也可以互相交流问题。&lt;/p&gt;
&lt;p&gt;每天早上9点到实验室打开电脑，晚上9点背电脑回寝室。大部分时间我会花在看书上，这段时间主要看的都是Java相关的书籍，借鉴的是江南白衣大佬的“Java后端书架”，比如《深入理解JVM虚拟机》，《Java并发编程艺术》，《深入分析Java Web技术内幕》，《深入剖析Spring源码》等等。&lt;/p&gt;
&lt;p&gt;另外一部分时间我会用来看一些技术博客，我主要是根据面经上的知识点按图索骥，找到对应讲解该知识点的文章，那时候主要还是通过搜索引擎来找文章，当然有时候看到一些重点难点也会自己写一些博客。不过这个时期并不是我大量写博客的阶段，主要还是看一些讲解面试知识点的技术博客为主。&lt;/p&gt;
&lt;p&gt;除此之外在面试前几天我会花时间去看这家公司的面经，搞懂每一个面经上的知识点，并且记录在我的笔记上，光是面经相关的笔记我就记了100多篇，这样的学习习惯我一直坚持到了秋招，确保每个面试知识点都能被我记住，消化，直至完全理解。&lt;/p&gt;
&lt;p&gt;慢慢的，笔记越来越多，我参加面试的公司也越来越多，于是我开始不断完善自己的简历，总结自己的面试技巧，选择合适的网申时机。从头到尾我大概花了3个月的时间在找实习上，期间大大小小参加了20多次面试，我也从一开始面试一问三不知的菜鸟，逐渐变成了面霸，到复习末期，我对Java常见面试知识点已经了然于胸，同时也越来越自信，不管面什么大厂都不慌不忙。&lt;/p&gt;
&lt;p&gt;这样的日子持续了好几个月，所谓世上无难事，只怕有心人。到最后，实验室里每个人都拿到了心仪的实习offer。&lt;/p&gt;
&lt;p&gt;实习路上，我明白了很多&lt;/p&gt;
&lt;p&gt;踏出学校大门，我的实习之路才刚刚开始。8个月左右的实习时间，说长也长，说短也短。但经历过这段实习之后，我才明白了很多事情。&lt;/p&gt;
&lt;p&gt;在猪场实习的日子里，我第一次了解大公司的开发流程，亲自参与项目代码的开发，我的导师会和我提需求，会指导我怎么做得更好。在这里的成长无疑是非常快速的，但我很快意识到我的问题所在，不熟悉部门技术栈，对很多Java Web的技术原理都不太熟悉，这段时间我意识到了自己的知识深度和广度都可能都有待提高。&lt;/p&gt;
&lt;p&gt;不过由于家里的一些事情。我提前离职了，所以在猪场呆的时间很短，以致于我没来得及搞懂部门项目的技术架构就走了，这也让我在离开以后感觉很遗憾，所以我下定决心在下个实习单位要好好做。&lt;/p&gt;
&lt;p&gt;离开猪场后我来到了熊厂。部门给我提的需求不算太难，大部分都是一些CURD的工作，但是这次很快就意识到了问题所在，就是我不太熟悉部门的整体技术栈，所以在需要借鉴别人代码时偶尔会看不懂。后来部门又给了新的重构需求，此时的我开始焦虑起来，是不是应该做出一些改变呢。&lt;/p&gt;
&lt;p&gt;终于，我找到了新的目标，我要搞懂部门的项目架构，了解相关技术栈（我们部门做的是私有云），一开始，我会请教我的导师，尽量去了解项目的架构设计，除此之外，我还会利用一些时间去看其他同事负责的代码，并且通过一些文档和PPT去了解这些代码的功能和意义。结合代码和文档，再加上和同时的交流，我对部门项目的架构逐渐熟悉起来，为了更好地理解每一块代码的作用，我还为一些模块的代码写了注释。&lt;/p&gt;
&lt;p&gt;当然，光看代码和文档还不能解决所有问题，因为这个项目的重点难点不在Web应用，而是在底层技术，这个项目中包含了两套架构，分别是一套OpenStack集群和一套docker集群。为了学习这两块内容，我先是看了很多博客，然后在平台上跑虚拟机和容器来做实践，最后又看了这方面的一些书籍，主要是《OpenStack设计与实现》，《docker技术入门实战》。&lt;/p&gt;
&lt;p&gt;但是这还不够，虚拟化技术与Linux内核息息相关，又需要学习者对操作系统和计算网络非常熟悉，我自知这些内容我学得还不够深入，于是我花大量时间看这方面的书，当时也遇到了几本确实不错的书，分别是《深入理解计算机系统》，《计算机网络：自顶向下方法》，还有一本没来得及看完的《Linux内核设计与实现》。虽然以后不一定会作云计算方向的开发，但是学完这些东西我还是非常开心的。&lt;/p&gt;
&lt;p&gt;到后来，我工位上的书越来越多，我对部门的技术栈也越来越熟悉，有时候我还会去听公司内各个团队组织的技术分享，有空的时候看看内网的技术课程，真正地实现了自己在技术广度上的拓展。&lt;/p&gt;
&lt;p&gt;有时候我觉得，实习生活是会骗人的，你佩戴着和正式员工一样的工牌，和他们做着类似的事情，会让你觉得你的水平已经和他们差不多了，但事实上是，在转正之前，你和他们还差得远，所以不要停下自己前进的脚步，抓紧时间学习吧，把握好你在公司里的机会，合理利用公司给你提供的资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190313150413994.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;秋招前的积累与沉淀&lt;/p&gt;
&lt;p&gt;研究生期间我有一件事情一直在坚持，那就是做笔记和写博客。&lt;/p&gt;
&lt;p&gt;做笔记，就是记录学习中大大小小的事情，可能是面试问题，可能是一周的学习计划，也可能知识一个知识点，总归都是值得记录的东西，对我来说，就是一种积累。而对于博客，我从一开始只用于记录项目，到后来做转载，再到后来写原创，整理系列文章，则更像是一种沉淀。&lt;/p&gt;
&lt;p&gt;但是在春招刚刚结束的这段时间，我发现一个问题，之前学过的东西忘记了很多，特别是那些理解的不够深的知识点，总是特别容易忘记。另外我发现，虽然我在笔记中记录了很多的知识点和面试题，但是往往我只看过一次，不会再去看第二次。&lt;/p&gt;
&lt;p&gt;这也意味着，虽然记录的内容很多，但是真正消化吸收的内容很少，脑子里充斥着总是那些零碎的知识点和面试问题，对于完整的知识体系知之甚少。这些问题在春招期间也不断地暴露出来，让我思考了很久。&lt;/p&gt;
&lt;p&gt;面对如此窘境，我想做出改变，趁着现在时间充裕，我想要为这些内容做一次减法，并且借此机会，推翻自己原有的知识体系，重建新的知识框架。简单说来，就是重新开始学习Java后端，这次我要用一种更高效的方式，避免走之前走的弯路，要用最高效，最合理的方式去复习。由于我之前已经有基础，所以我对完成这一目标有信心，相应地我也为此做出了明确且详细的学习计划。&lt;/p&gt;
&lt;p&gt;对于Java方向的朋友，这里要强烈推荐我的另一个公众号&lt;/p&gt;
&lt;p&gt;微信公众号【Java技术江湖】一位阿里Java工程师的技术小站，致力于分享Java后端技术文章，以及这几年学习Java的心得体会，偶尔也记录在阿里成长的点滴，和大家一起在Java学习道路上成长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190313150636346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;我打算用几个关键词来形容这三个月的秋招复习。&lt;/p&gt;
&lt;p&gt;“具体可靠的学习计划”&lt;/p&gt;
&lt;p&gt;在三个月的时间里，我首先按照Java后端路线图安排好复习计划，每个知识点都会对应安排一段时间，比如我可能花一天时间复习“Java反射”，两天时间复习“设计模式”，一周的时间用于复习&quot;JVM虚拟机”。我一般会在月初做好整个月的计划，然后根据进度做一些微调，但是基本上我都可以跟上进度，并且是在复习到位的前提下。&lt;/p&gt;
&lt;p&gt;所以我觉得，对于秋招这一场苦战，指定计划尤为重要，一旦计划定下来，战略目标清晰，对应的战术制定也会变得清晰，执行力也会随之变强。&lt;/p&gt;
&lt;p&gt;“写博客整合知识点”&lt;/p&gt;
&lt;p&gt;至于复习方法，我主要通过看高质量博客，并且结合代码实践的方式巩固这部分知识点，比如今天学习“concurrenthashmap”，我会去找两三篇比较好的博客先看看，主要是源码解读方面的，然后我会把它们进行整合，如果有遗漏的知识点我会再进行补充，有时候我还会自己去看看JDK源码，以便更好地理解博客内容，完成知识整合之后，我就会对应地整理出一篇博客出来，发在我的个人博客上。&lt;/p&gt;
&lt;p&gt;除此之外，当我完成了一整个专题的复习之后，我会把这些文章整理成一个专题，比如上面说的“concurrenthashmap”，实际上属于Java并发包，所以我会专门做一个博客专栏，用来完成Java并发系列的文章专题。对于每一个文章专题，我都会先理清这个专题一共有哪些内容，然后再开始整理。比如对于Java并发包，我会先写Java多线程基础的文章，再写JMM内存模型的文章，接着一步步着手写Java线程池，阻塞队列，工具类，原子类等等。这样一来这部分内容就复习完毕了，写系列文章的好处就在于，我可以从头到尾理清脉络，并且对于每一部分的知识点都做了比较好的总结。&lt;/p&gt;
&lt;p&gt;对于博客的选择，我吸取了之前的教训，宁愿花半小时看一篇高质量文章，也不花10分钟看5篇烂文章。深度阅读的好处，就是可以让这部分内容更好地融入你脑内的知识体系，而不是像其他快餐文章一样转瞬即逝。&lt;/p&gt;
&lt;p&gt;“做项目巩固实践能力”&lt;/p&gt;
&lt;p&gt;由于之前在实习期间参加的项目都比较大，我接触的模块也比较单一，没有对整体项目有一个很好的把握，所以我决定趁这段时间再巩固一下我的项目实践能力，这里的能力主要是指的是对项目架构的把握能力，以及对业务开发的熟练度，当然也包括对各种常用后端技术的熟悉程度。&lt;/p&gt;
&lt;p&gt;我花了大概一个月的时间完成了两个项目的开发，当然主要也是模仿两个开源项目做了，这两个项目都使用SpringBoot快速开发，并且用到一些常用的后端技术比如redis，云存储，以及一些常见Web框架，除此之外还涉及到了solr，爬虫等技术。虽然项目不算很难，但是我在这段时间里很快地熟悉了完整项目开发的流程，并且每天做迭代，通过Git来跟进版本，每个版本都会写清所做的内容，这也让我对项目的架构非常熟悉。&lt;/p&gt;
&lt;p&gt;在项目之余，我也找一些常用的后端组件来跑一跑demo，以便让我对这些技术有一个直观的了解，比如面试常问的dubbo，zookeeper，消息队列等组件。这些尝试也让我在理解它们的原理时更加得心应手了。&lt;/p&gt;
&lt;p&gt;“坚持刷题，注重方法”&lt;/p&gt;
&lt;p&gt;算法题是秋招笔试面试中的重头戏，每个研发同学都免不了经历算法题的摧残，对我这么一个非科班同学来说，更是让人头大。正因为如此，我放弃了刷大量LeetCode题目的方法，选择了更加行之有效的刷题方式。&lt;/p&gt;
&lt;p&gt;首先我重新刷了一遍剑指offer，并且对每道题目进行总结，尽量保证每一道题都可以记在脑子里，众所周知剑指offer中的题是面试时非常喜欢考的，所以先搞定这部分题目是最为关键的。&lt;/p&gt;
&lt;p&gt;搞定剑指offer之后，当然还要刷LeetCode了，LeetCode题目这么多，怎么选择呢，我没有按照tag刷，也没有按照顺序刷，而是参考当时一个大佬的LeetCode刷题指南来进行刷题的，他把每个类型的题目都做了归纳，每部分只放一些比较经典的题目。所以我前后大概刷了100多道LeetCode的题目，并且在第二遍刷题复习的时候，我也对这些题目做了一份总结。&lt;/p&gt;
&lt;p&gt;除了上面两个经典题库，我还着重刷了大厂的历年真题，这部分我主要是通过牛客网的历年真题题库来完成刷题的。说实话，真题是非常重要的，因为公司出的题目不像平时的那些算法题，可能会出得非常奇葩，所以你如果不提前适应的话会比较吃亏。完成这部分题目之后，我对算法题的复习也基本告一段落了。&lt;/p&gt;
&lt;p&gt;当我完成所有内容的复习时，提前批已经开始了。终于要上战场了，因为战前准备比较充分，所以我对秋招还是比较乐观的，但事实上，秋招不仅是攻坚战，而且是持久战，要笑到最后，确实也不是那么容易的事情。&lt;/p&gt;
&lt;p&gt;重建知识体系，对学过的东西做减法&lt;/p&gt;
&lt;p&gt;前面提到我在秋招前完成了知识体系重建，那在这里我也想跟大家分享一下我当时大致的知识体系构成。就跟我前面说的一样，我选择重新再学一遍Java后端相关的技术内容，因为我知道大致的学习方向，并且有一定的基础，所以看很多文章变得更加得心应手，写文章和做总结也更加有底气了。&lt;/p&gt;
&lt;p&gt;首先在Java基础方面，我写了20多篇原创博客，主要是对Java核心技术的解析，比如“Java反射”，“Java序列化和反序列化”，“Java异常体系”等等。&lt;/p&gt;
&lt;p&gt;在Java集合类方面，我原创了部分文章，另外整合了一些比较好的技术文章，其中最主要的就是关于hashmap的文章，当时我整合的文章几乎没有遗漏任何一个知识点。&lt;/p&gt;
&lt;p&gt;在Java并发编程方面，我主要参考了并发编程网以及一些优质博客的文章，先搞懂了Java并发原理，再一步步学习JUC并发包的组件，其中重点看了chm，并发工具类以及阻塞队列等JDK源码的解析文章，除此之外，我还会在IDE中跑JUC相关的emo，毕竟这方面的内容非常需要实践。&lt;/p&gt;
&lt;p&gt;在Java网络编程方面，我先从最基础的socket入手，再讲到NIO,AIO，并且加入了几篇对Linux IO模型解析的文章，让整个知识体系更加完整（因为NIO是基于Linux Epoll实现的），接着我又加入了对Netty的探讨，以及Tomcat中对NIO的应用，可以说是把Java网络编程一些比较重要的部分都囊括进来了。为了更好理解这部分内容，我也在网上参考了很多客户端和服务端通信的demo，最后我分别用Socket，NIO,AIO以及Netty把C/S 通信的demo都写了一遍。&lt;/p&gt;
&lt;p&gt;在JVM虚拟机方面，我则按照《深入理解JVM虚拟机》这本书的行文脉络进行文章的整理。在搞定JVM基本原理以后，我着重了解了JVM调优和实践中常遇到的问题，并且整理了常用的JVM调优工具，场景问题以及调优实践的案例，这也是因为面试中对JVM调优实践越来越重视了。&lt;/p&gt;
&lt;p&gt;在JavaWeb方面，我从Java Web相关技术的发展入手，一步步了解了每种技术存在的意义，比如JSP，Servlet，JDBC，Spring等等，然后对每种技术进行了比较全面的了解，并且着重地看了Spring和SpringMVC的源码分析文章，另外一方面，我花了很多时间去研究Tomcat的工作原理。除此之外，JavaWeb项目中常用的maven，日志组件，甚至是单测试组件，也纳入了我的系列文章里。&lt;/p&gt;
&lt;p&gt;在数据库和缓存方面，我主要学习了MySQL和Redis这两种最常用的数据库。对于Mysql，我从简单的sql开始了解，然后开始了解sql优化，MySQL的存储引擎和索引，事务及锁，还有更复杂的主从复制，分库分表等内容。对于Redis，我也是从简单的api入手，然后去了解每一种数据结构的底层实现原理，接着尝试去学习Redis的持久化方式，以及作为缓存常需要考虑的技术点，当然，也包括Redis的分布式锁实现，以及它的分布式集群方案。&lt;/p&gt;
&lt;p&gt;最后一部分就是分布式相关的理论和技术了，这个也是困扰我很久的一块内容，我主要把这块内容分为两个部分，分别是分布式理论和分布式技术，理论方面，我先了解CAP,BASE等基本知识，然后开始学习一致性协议和算法，接着探讨分布式事务。对于分布式技术，涉及的东西就更多了，例如分布式session，负载均衡，分布式锁等内容，这些知识点我都会用一到两篇文章去总结，对于分布式缓存，消息队列，以及分布式服务等内容，我会花比较多的时间去全面学习，然后总结出一个系列的文章出来。当然，对于这些技术的学习主要还是停留在理论方面，在自己的项目中能用到的比较少。&lt;/p&gt;
&lt;p&gt;至此，我的知识体系基本构建完成，这也是我在秋招中能够成功闯过那么多面试的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190313150428431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;秋招之路，砥砺前行&lt;/p&gt;
&lt;p&gt;不管前期做了多少准备，到秋招的时候也不能掉以轻心，从七月底第一次面试到9月基本佛系，中间经历了大大小小的面试。&lt;/p&gt;
&lt;p&gt;在完成知识体系重建以后，我把重点转向了另外几件事，一是完善和熟悉我的简历，以便在面试中能够比较好地发挥，二是持续刷题，保持对算法题和笔试真题的手感和熟练度，三则是看面经查缺补漏，我一直认为看面经是很重要的一项复习内容。&lt;/p&gt;
&lt;p&gt;就这样，我一边继续复习，以便开始了一场接一场的面试接力。&lt;/p&gt;
&lt;p&gt;起初，我面了几家小公司练手，接着阿里的提前批接踵而至，我战战兢兢地参加了阿里中间件部门的面试，面难难度还算适中，一共四轮面试，当时我的表现也还不错，问题基本都答上来了。面完不到一周以后我就收到了通过的消息，当时还有点懵。没想到第一个offer这么快就来了。&lt;/p&gt;
&lt;p&gt;这段时间内，蚂蚁金服的两个部门也给了我面试机会，我都参加了它们的面试，并且顺利地拿到了其中一个部门的offer。由于我对蚂蚁这边的业务比较感兴趣，最终选择了蚂蚁金服的offer。&lt;/p&gt;
&lt;p&gt;阿里提前批的胜利确实是意外之喜，但也大大地鼓舞了我，于是我又参加了百度和腾讯的提前批面试，由于百度的提前批不走流程，一共有四个部门面试了我，每个部门都有2到3轮面试，总计约为12次面试，到后来我已经快晕了，看到百度的电话就害怕，由于面试次数太多，有时候发挥确实也不是很好，我也没有特别在意，只当是在锻炼自己了。&lt;/p&gt;
&lt;p&gt;百度的面试难度每个部门不一样，但是每次面试必写算法题，一写算法题，时间至少就是一个小时以上，每次面试完都有一种身体被掏空的感觉。&lt;/p&gt;
&lt;p&gt;经历了百度面试的摧残以后，我手写算法的速度也变快了，很多坑也被我填上了。接下来面对腾讯的面试，我也是既激动又担心，腾讯的面试难度比较大，对于操作系统和网络的知识喜欢深挖，问的东西也很有深度，面完前三面以后，第四面拖了3周才进行。当时三面面试官对我的评价比较好，也让我信心爆棚了好久。&lt;/p&gt;
&lt;p&gt;在等待腾讯终面的期间，我参加了今日头条的面试，当时有幸拿到了一个白金码，免去笔试，事实证明白金码作用真的很大。头条的面试难度和腾讯差不多，三轮面试，同样需要写各种算法，由于是视频面试，我可以清楚地看到，头条的面试官真的非常高冷啊。面完头条我的第一感觉就是应该挂了吧。没想到最后还是给了offer。&lt;/p&gt;
&lt;p&gt;结束这几家大厂的面试之后，我觉得我的秋招已经接近尾声了，不过由于之前投的比较多，所以我又面了几家大公司，如网易，华为，快手等。到9月上旬的时候，我接连收到了bat和头条，网易的意向书，阿里最早，腾讯最晚，每收到一封意向书我都很开心，没想到最后我真的可以集齐bat等大厂的offer。&lt;/p&gt;
&lt;p&gt;9月以后，除了偶尔和同学做几场大厂的笔试，我基本就佛系了。直到后来一些外企例如亚马逊，大摩开始笔试面试，我才又重新回到了状态。&lt;/p&gt;
&lt;p&gt;截止目前，我基本上把该拒绝的offer都拒绝了，综合各方面因素的考虑，最后应该会签阿里，原因是部门是我自己喜欢的，同时给的评级也比较高。虽然腾讯也给了sp，但是最后还是忍痛割爱啦。至于百度和头条，给的offer并不是很令人满意，所以就没有考虑了。&lt;/p&gt;
&lt;p&gt;至此，我的秋招之旅总算圆满结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190313150441172.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;面经分享&lt;/p&gt;
&lt;p&gt;具体的面经都比较长，这里大概介绍一下面试的情况，具体的面经请大家关注我的公众号并回复“面经”即可查看。&lt;/p&gt;
&lt;p&gt;1 阿里面经&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=9ec90620478b35d63a4a971a2222095d&amp;amp;chksm=f9e5b29dce923b8b2b080151e4b6b78373ee3f3e6f75b69252fc00b1a009d85c6f96944ed6e6&amp;amp;scene=21#wechat_redirect&quot;&gt;阿里中间件研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483861&amp;amp;idx=1&amp;amp;sn=34317917908fdb778f16fa9dd557908b&amp;amp;chksm=f9e5b284ce923b922446fb5431b84094dec03ee4688da9c8de1f025d80eac715cbd9740e8464&amp;amp;scene=21#wechat_redirect&quot;&gt;蚂蚁金服研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;岗位是研发工程师，直接找蚂蚁金服的大佬进行内推。&lt;/p&gt;
&lt;p&gt;我参与了阿里巴巴中间件部门的提前批面试，一共经历了四次面试，拿到了口头offer。&lt;/p&gt;
&lt;p&gt;然后我也参加了蚂蚁金服中间件部门的面试，经历了三次面试，但是没有走流程，所以面试中止了。&lt;/p&gt;
&lt;p&gt;最后我走的是蚂蚁金服财富事业群的流程，经历了四次面试，包括一次交叉面，最终拿到了蚂蚁金服的意向书，评级为A。&lt;/p&gt;
&lt;p&gt;阿里的面试体验还是比较好的，至少不要求手写算法，但是非常注重Java基础，中间件部门还会特别安排Java基础笔试。&lt;/p&gt;
&lt;p&gt;2 腾讯面经&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483849&amp;amp;idx=1&amp;amp;sn=f81fd42954589fb2deaf128026ddd856&amp;amp;chksm=f9e5b298ce923b8ef02ae36f7e9029fef0ddb7d5ae456dfa9d64c0073bebaacfb78fac4c8035&amp;amp;scene=21#wechat_redirect&quot;&gt;腾讯研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;岗位是后台开发工程师，我没有选择意向事业群。&lt;/p&gt;
&lt;p&gt;SNG的部门捞了我的简历，开始了面试，他们的技术栈主要是Java，所以比较有的聊。&lt;/p&gt;
&lt;p&gt;一共经历了四次技术面试和一次HR面试，目前正在等待结果。&lt;/p&gt;
&lt;p&gt;腾讯的面试一如既往地注重考查网络和操作系统，并且喜欢问Linux底层的一些知识，在这方面我还是有很多不足的。&lt;/p&gt;
&lt;p&gt;3 百度面经&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483857&amp;amp;idx=1&amp;amp;sn=214b0f93db93407a7ac5a5149778cbad&amp;amp;chksm=f9e5b280ce923b96fcd535b2ef639fee2de78f12aa961d525b21760b11a3b95c0879113c2944&amp;amp;scene=21#wechat_redirect&quot;&gt;百度研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483866&amp;amp;idx=1&amp;amp;sn=88dc80fef6ad6aa3a4221862f3630a90&amp;amp;chksm=f9e5b28bce923b9d4defc91ed30d8bbe650d7215966f9fb776fe5b244eae527bcd24b1941204&amp;amp;scene=21#wechat_redirect&quot;&gt;百度研发面经整合版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;岗位是研发工程师岗位，部门包括百度智能云的三个分部门以及大搜索部门。&lt;/p&gt;
&lt;p&gt;百度的提前批面试不走流程，所以可以同时面试好多个部门，所以我参加百度面试的次数大概有12次左右，最终应该是拿了两个部门的offer。&lt;/p&gt;
&lt;p&gt;百度的面试风格非常统一，每次面试基本都要到电脑上写算法，所以那段时间写算法写的头皮发麻。&lt;/p&gt;
&lt;p&gt;4 网易面经&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483875&amp;amp;idx=1&amp;amp;sn=fa9eaedd9cc3da172ad71d360c46a054&amp;amp;chksm=f9e5b2b2ce923ba443b91d56b24486d22b15bea16a4788e5ed3421906e84f8edd9ee10b2b306&amp;amp;scene=21#wechat_redirect&quot;&gt;网易研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;面试部门是网易云音乐，岗位是Java开发工程师。&lt;/p&gt;
&lt;p&gt;网易是唯一一家我去外地面试的公司，也是我最早去实习的老东家。&lt;/p&gt;
&lt;p&gt;一共三轮面试，耗时一个下午。&lt;/p&gt;
&lt;p&gt;网易的面试比我想象中的要难，面试官会问的问题都比较深，并且会让你写一些结合实践的代码。&lt;/p&gt;
&lt;p&gt;5 头条面经&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483869&amp;amp;idx=1&amp;amp;sn=eedb7aebcb90cf3d4fe2450ef2d99947&amp;amp;chksm=f9e5b28cce923b9a9b0852a1c998ec014eb1aeb0442916c9028da276be8db0b2934c92292961&amp;amp;scene=21#wechat_redirect&quot;&gt;今日头条研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;岗位是后台研发工程师，地点选择了上海。&lt;/p&gt;
&lt;p&gt;我参加的是字节跳动的内推面试，当时找了一个牛友要到了白金码，再次感谢这位头条大佬。&lt;/p&gt;
&lt;p&gt;然后就开始了一下午的视频面试，一共三轮技术面试，每一轮都要写代码，问问题的风格有点像腾讯，也喜欢问一些底层知识，让我有点懵逼。&lt;/p&gt;
&lt;p&gt;更多面经请点击阅读原文进行查看。&lt;/p&gt;
&lt;p&gt;笔试经验&lt;/p&gt;
&lt;p&gt;提前批的笔试其实不是很多，我参加了网易，网易游戏，拼多多等公司的笔试，应该都是低分飘过。&lt;/p&gt;
&lt;p&gt;我的算法基础比较一般，读研之前0基础，所以这方面学的比较艰辛，分享一些我的笔试准备经验。&lt;/p&gt;
&lt;p&gt;1 打好数据结构和算法基础&lt;/p&gt;
&lt;p&gt;2 先易后难，看一些基础的算法书籍，比如《图结算法》，《啊哈算法》等等。&lt;/p&gt;
&lt;p&gt;3 剑指offer刷起来，两到三遍，做到胸有成竹&lt;/p&gt;
&lt;p&gt;4 LeetCode刷个200题左右，记得二刷，做好总结。&lt;/p&gt;
&lt;p&gt;5 到牛客网做公司的历年真题，熟悉题型，保持手感。&lt;/p&gt;
&lt;p&gt;剑指offer指南和LeetCode刷题指南可以在我的博客里找到。&lt;/p&gt;
&lt;p&gt;其中LeetCode指南是参考@CyC2018大佬的文章。&lt;/p&gt;
&lt;p&gt;面试经验&lt;/p&gt;
&lt;p&gt;面试主要考的还是你的基础知识，需要你对Java后端技术栈有一个全局上的把握，具体说起来就太多了，具体复习方案可以参考文章后面的内容。&lt;/p&gt;
&lt;p&gt;我个人也总结了一些面试方面的经验，主要是一些技巧。&lt;/p&gt;
&lt;p&gt;1 做好自我介绍和项目总结，把握你发言的主动权&lt;/p&gt;
&lt;p&gt;2 搞清楚简历上的技术点，兵来将挡水来土掩&lt;/p&gt;
&lt;p&gt;3 注意分点答题，思路清晰，也更容易讲清楚原理。&lt;/p&gt;
&lt;p&gt;4 压力面下保持冷静，不要回怼面试官&lt;/p&gt;
&lt;p&gt;5 HR面试注意常用技巧，可以提前准备。&lt;/p&gt;
&lt;p&gt;Java后端技术专栏&lt;/p&gt;
&lt;p&gt;对于校园招聘来说，最重要的还是基础知识。下面的博客专栏出自我的技术博客 https://blog.csdn.net/a724888&lt;/p&gt;
&lt;p&gt;这些专栏中有一些文章是我自己原创的，也有一些文章是转载自技术大牛的，基本都是是我在学习Java后端的两年时间内陆续完成的。&lt;/p&gt;
&lt;p&gt;总的来说算是比较全面了，做后端方向的同学可以参考一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/21930&quot;&gt;深入浅出Java核心技术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本专栏主要介绍Java基础，并且会结合实现原理以及具体实例来讲解。同时还介绍了Java集合类，设计模式以及Java8的相关知识。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/21960&quot;&gt;深入理解JVM虚拟机&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;带你走进JVM的世界，整合高质量文章以阐述虚拟机的原理及相关技术，让开发者更好地了解Java的底层运行原理以及相应的调优方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/21961&quot;&gt;Java并发指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本专栏主要介绍Java并发编程相关的基本原理以及进阶知识。主要包括Java多线程基础，Java并发编程基本原理以及JUC并发包的使用和源码解析。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/21963&quot;&gt;Java网络编程与NIO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java网络编程一直是很重要的一部分内容，其中涉及了socket的使用，以及Java网络编程的IO模型，譬如BIO,NIO,AIO，当然也包括Linux的网络编程模型。&lt;/p&gt;
&lt;p&gt;了解这部分知识对于理解网络编程有很多帮助。另外还补充了两个涉及NIO的重要技术：Tomcat和Netty。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/21850&quot;&gt;JavaWeb技术世界&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从这里开始打开去往JavaWeb世界的大门。什么是J2EE，什么是JavaWeb，以及这个生态中常用的一些技术：Maven，Spring，Tomcat，Junit，log4j等等。&lt;/p&gt;
&lt;p&gt;我们不仅要了解怎么使用它们，更要去了解它们为什么出现，其中一些技术的实现原理是什么。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/21851&quot;&gt;Spring与SpringMVC源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本专栏主要讲解Spring和SpringMVC的实现原理。&lt;/p&gt;
&lt;p&gt;Spring是最流行的Java框架之一。&lt;/p&gt;
&lt;p&gt;本专栏文章主要包括IOC的实现原理分析，AOP的实现原理分析，事务的实现源码分析等，当然也有SpringMVC的源码解析文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/21877&quot;&gt;重新学习MySQL与Redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本专栏介绍MySQL的基本知识，比如基本架构，存储引擎，索引原理，主从复制，事务等内容。当然也会讲解一些和sql语句优化有关的知识。&lt;/p&gt;
&lt;p&gt;同时本专栏里也介绍了Redis的基本实现原理，包括数据结构，主从复制，集群方案，分布式锁等实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/24090&quot;&gt;分布式系统理论与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本专栏介绍分布式的基本理论和相关技术，比如CAP和BASE理论，一致性算法，以及ZooKeeper这类的分布式协调服务。&lt;/p&gt;
&lt;p&gt;在分布式实践方面，我们会讲到负载均衡，缓存，分布式事务，分布式锁，以及Dubbo这样的微服务，也包括消息队列，数据库中间件等等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/column/info/25481&quot;&gt;后端开技术杂谈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本专栏涵盖了大后端的众多技术文章，当你在Java后端方面有一定基础以后，再多了解一些相关技术总是有好处的。&lt;/p&gt;
&lt;p&gt;除了Java后端的文章以外，还会涉及Hadoop生态，云计算技术，搜索引擎，甚至包括一些数据挖掘和AI的文章。&lt;/p&gt;
&lt;p&gt;总的来说选取了一些不错的基础类文章，能让你对大后端有一个更直观的认识。我之前专门写了一篇文章介绍了Java工程师的书单，可以这里重点列举一些好书，推荐给大家。&lt;/p&gt;
&lt;p&gt;完整内容可以参考这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a724888/article/details/73195803&quot;&gt;Java工程师必备书单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《计算机网络：自顶向下》这本从应用层讲到物理层，感觉这种方式学起来更轻松。&lt;/p&gt;
&lt;p&gt;《图解算法》《啊哈算法》&lt;/p&gt;
&lt;p&gt;这两部书籍非常适合学习算法的入门，前者主要用图解的形式覆盖了大部分常用算法，包括dp，贪心等等，可以作为入门书，后者则把很多常用算法都进行了实现，包括搜索，图，树等一些比较高级的常用算法。&lt;/p&gt;
&lt;p&gt;《剑指offer》这本书还是要强烈推荐的，毕竟是面试题经常参考的书籍，当然最好有前面基本的铺垫再看，可能收获更大，这本书在面试之前一般都要嚼烂。如果想看Java版本的代码，可以到我的Github仓库中查看。&lt;/p&gt;
&lt;p&gt;《Java编程思想》这本书也是被誉为Java神书的存在了，但是对新手不友好，适合有些基础再看，当然要选择性地看。我当时大概只看了1/3&lt;/p&gt;
&lt;p&gt;《Java核心技术卷一》&lt;/p&gt;
&lt;p&gt;这本书还是比较适合入门的，当然，这种厚皮书要看完还是很有难度的，不过比起上面那本要简单一些&lt;/p&gt;
&lt;p&gt;《深入理解JVM虚拟机》&lt;/p&gt;
&lt;p&gt;这本书是Java开发者必须看的书，很多jvm的文章都是提取这本书的内容。JVM是Java虚拟机，赋予了Java程序生命，所以好好看看把，我自己就已经看了三遍了。&lt;/p&gt;
&lt;p&gt;《Java并发编程艺术》&lt;/p&gt;
&lt;p&gt;这本书是国内作者写的Java并发书籍，比上面那一本更简单易懂，适合作为并发编程的入门书籍，当然，学习并发原理之前，还是先把Java的多线程搞懂吧。&lt;/p&gt;
&lt;p&gt;《深入JavaWeb技术内幕》&lt;/p&gt;
&lt;p&gt;这本书是Java Web的集大成之作，涵盖了大部分Java Web开发的知识点，不过一本书显然无法把所有细节都讲完，但是作为Java Web的入门或者进阶书籍来看的话还是很不错的。&lt;/p&gt;
&lt;p&gt;《Redis设计与实现》&lt;/p&gt;
&lt;p&gt;该书全面而完整地讲解了 Redis 的内部运行机制,对 Redis 的大多数单机功能以及所有多机功能的实现原理进行了介绍。这本书把Redis的基本原理讲的一清二楚，包括数据结构，持久化，集群等内容，有空应该看看。&lt;/p&gt;
&lt;p&gt;《大型网站技术架构》&lt;/p&gt;
&lt;p&gt;这本淘宝系技术指南还是非常值得推崇的，可以说是把大型网站的现代架构进行了一次简单的总结，内容涵盖了各方面，主要讲的是概念，很适合没接触过架构的同学入门。看完以后你会觉得后端技术原来这么博大精深。&lt;/p&gt;
&lt;p&gt;《分布式服务框架原理与实践》&lt;/p&gt;
&lt;p&gt;上面那本书讲的是分布式架构的实践，而这本书更专注于分布式服务的原理讲解和对应实践，很好地讲述了分布式服务的基本概念，相关技术，以及解决方案等，对于想要学习分布式服务框架的同学来说是本好书。&lt;/p&gt;
&lt;p&gt;《从Paxos到Zookeeper分布式一致性原理与实践》&lt;/p&gt;
&lt;p&gt;说起分布式系统，我们需要了解它的原理，相关理论及技术，这本书也是从这个角度出发，讲解了分布式系统的一些常用概念，并且带出了分布式一哥zookeeper，可以说是想学分布式技术的同学必看的书籍。&lt;/p&gt;
&lt;p&gt;《大数据技术原理与应用》&lt;/p&gt;
&lt;p&gt;作为大数据方面的一本教材，厦大教授写的这本书还是非常赞的，从最基础的原理方面讲解了Hadoop的生态系统，并且把每个组件的原理都讲得比较清楚，另外也加入了spark，storm等内容，可以说是大数据入门非常好的一本书了。&lt;/p&gt;
&lt;p&gt;技术大牛推荐&lt;/p&gt;
&lt;p&gt;1 江南白衣&lt;/p&gt;
&lt;p&gt;这位大大绝对是我的Java启蒙导师，他推荐的Java后端书架让我受益匪浅。&lt;/p&gt;
&lt;p&gt;2 码农翻身&lt;/p&gt;
&lt;p&gt;刘欣，一位工作15年的IBM架构师，用最浅显易懂的文章讲解技术的那些事，力荐，他的文章帮我解决了很多困惑。&lt;/p&gt;
&lt;p&gt;3 CoolShell&lt;/p&gt;
&lt;p&gt;陈皓老师的博客相信大家都看过，干货很多，酷壳应该算是国内最有影响力的个人博客了。&lt;/p&gt;
&lt;p&gt;4 廖雪峰&lt;/p&gt;
&lt;p&gt;学习Git和Python，看它的博客就够了。&lt;/p&gt;
&lt;p&gt;5 HollisChuang&lt;/p&gt;
&lt;p&gt;阿里一位研发大佬的博客，主要分享Java技术文章，内容还不错。&lt;/p&gt;
&lt;p&gt;6 梁桂钊&lt;/p&gt;
&lt;p&gt;阿里另一位研发大佬，博客里的后端技术文章非常丰富。&lt;/p&gt;
&lt;p&gt;7 chenssy&lt;/p&gt;
&lt;p&gt;这位大佬分享的Java技术文章也很多，并且有很多基础方面的文章，新手可以多看看。&lt;/p&gt;
&lt;p&gt;8 Java Doop&lt;/p&gt;
&lt;p&gt;一位魔都Java开发者的技术博客，里面有一些不错的讲解源码的文章，数量不是很多，但是质量都挺不错的。&lt;/p&gt;
&lt;p&gt;学习资源分享&lt;/p&gt;
&lt;p&gt;学习Java后端两年的时间里，接触过很多的资料，网站和课程，也走了不少弯路，所以这里也总结一些比较好的资源推荐给大家。&lt;/p&gt;
&lt;p&gt;0 CSDN和博客园，主流的技术交流平台，虽然广告越打越多了，但是还是有很多不错的博文的。&lt;/p&gt;
&lt;p&gt;1 importnew 专注Java学习资源分享，适合Java初学者。&lt;/p&gt;
&lt;p&gt;2 并发编程网，主要分享Java相关进阶内容，适合Java提高。&lt;/p&gt;
&lt;p&gt;3 推酷 一个不错的技术分享社区。&lt;/p&gt;
&lt;p&gt;4 segmentfault，有点像国内的Stack Overflow，适合交流代码问题的地方。&lt;/p&gt;
&lt;p&gt;5 掘金，一个很有极客范的技术社区，强推，有很多技术大牛分享优质文章。&lt;/p&gt;
&lt;p&gt;6 开发者头条，一个整合优质技术博客的社区，里面基本上都是精选的高质量博文，适合技术学习提升。&lt;/p&gt;
&lt;p&gt;7 v2ex，一个极客社区，除了交流技术以外还会有很多和程序员生活相关的话题分享。&lt;/p&gt;
&lt;p&gt;8 知乎&lt;/p&gt;
&lt;p&gt;这个就不必多说了。&lt;/p&gt;
&lt;p&gt;9 简书&lt;/p&gt;
&lt;p&gt;简书上有些技术文章也很不错，有空大家也可以去看看。&lt;/p&gt;
&lt;p&gt;10 Github&lt;/p&gt;
&lt;p&gt;有一些GitHub的项目还是非常不错的，其中也有仓库会分享技术文章。&lt;/p&gt;
&lt;p&gt;后记&lt;/p&gt;
&lt;p&gt;秋招结束以后，我就把主要精力花在做这个公众号上了。当然，剩下要处理的事情还有很多，毕业论文，毕业旅行，还有工作前的知识储备等等。果然，人的一生需要不断的修行，刚刚闯过了一关又马上要迎接下一轮挑战，你不能停下脚步，毕竟大家都在往前走。&lt;/p&gt;
&lt;p&gt;希望还在求职路上的各位少侠好好加油，在未来也能够顺利地拿到自己想要的offer！&lt;/p&gt;
&lt;p&gt;本文中涉及到的几个链接我汇总在这里，方便大家查看。&lt;/p&gt;
&lt;p&gt;1、CSDN技术博客：blog.csdn.net/a724888（Java后端技术站点，整理很多Java后端技术文章，推荐Java方向的同学看看）&lt;/p&gt;
&lt;p&gt;2、知乎：www.zhihu.com/people/h2pl（知乎活跃用户，希望未来能成为大V）&lt;/p&gt;
&lt;p&gt;3、牛客网：www.nowcoder.com/profile/3539721（牛客网活跃粉，分享过一些面经和心得）&lt;/p&gt;
&lt;p&gt;4、GitHub：https://github.com/h2pl（用于自己做项目，以及刷剑指offer、LeetCode、历年笔试题）&lt;/p&gt;
&lt;p&gt;当然，记得要关注一下本公众号，有很多校招和学习干货在这里等你发掘，特别是正在准备校园招聘的各位同学，一定不要错过了哈。&lt;/p&gt;
&lt;p&gt;作者在今年秋招中成功拿到BAT头条网易等大厂的研发offer，期间总结了很多经验和心得，并把它们写成文字，发表在公众号上，希望让更多有需要的朋友看到，给各位未来的技术大牛们一些小小的帮助。转发和点赞是对作者的最大支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190313145116779.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加描述&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 07:24:00 +0000</pubDate>
<dc:creator>程序员江湖_陆小凤</dc:creator>
<og:description>本文首发于微信公众号【程序员江湖】作者How 2 Play Life，985 软件硕士，阿里 Java 研发工程师，在技术校园招聘、自学编程、计算机考研等方面有丰富经验和独到见解，目前致力于分享程序员</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xll1025/p/10523435.html</dc:identifier>
</item>
<item>
<title>前后端分离之【接口文档管理及数据模拟工具docdoc与dochelper】 - 多彩泰坦</title>
<link>http://www.cnblogs.com/xiayudashan/p/10518500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiayudashan/p/10518500.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;前后端分离的常见开发方式是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;后端：接收http请求-&amp;gt;根据请求url及params处理对应业务逻辑-&amp;gt;将处理结果序列化为json返回&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;前端：发起http请求并传递相关参数-&amp;gt;获取返回结果处理相关逻辑&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;分离的主要目的是让前后端可以并行的进行工作，彼此之间只需要依赖一份接口文档&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接口文档可能会使用一些文本工具进行记录，例如word，excel等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其中记录的内容可能为请求路径，请求类型，请求参数，响应参数，请求示例，响应示例，变更记录等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;不过以上方式还存在那么一点不完美，那就是前端需要等待后端开发完接口才能有数据进行测试在此之前只能先画页面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这就有可能造成前端要等后端的情况，使工作变为串行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因此我想能否有办法可以消除这种情况，让前端不必等待后端&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;经过一段时间的摸索，我想可以做一个mock server来模拟前端需要的数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当前端请求某个url时，mock server会在其数据库中进行查询，匹配到这个url后就返回默认或者用户自定义的模拟数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这样一来前端就可以在不依赖后端的情况下拿到数据进行测试了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但如果只是仅仅依赖mock server，那么一些已开发的接口将无法得到正常的请求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;那么问题就又变成了如何使正常接口与mock接口共存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;很容易想到的就是使用nginx反向代理，将未开发完的接口匹配到mock server，剩余的接口匹配正常程序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以前端开发时自己启动一个nginx，然后需要mock什么接口自己去配置即可&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是。。。。当接口很多时，前端得自己手动去配置nginx，还要在对nginx进行重启等等操作，很繁琐&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为了解决这个问题我又想能不能让这一切自动化的去完成&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有一个客户端程序，自动的对nginx进行相关配置并启动nginx，将开发中的接口转发给mock server，将其余接口转发给正常程序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;显然这个思路是可行的，为了让程序好用，客户端制作成了GUI，并且打包成了exe，使以上nginx配置步骤变为一键操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;以下是根据以上思路制作完毕的docdoc及dochelper截图，及一个简单的演示视频：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;视频地址：&lt;a href=&quot;https://www.bilibili.com/video/av46052020&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.bilibili.com/video/av46052020&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;github docdoc：&lt;a href=&quot;https://github.com/github20120522/docdoc&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/github20120522/docdoc&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;github dochelper：&lt;a href=&quot;https://github.com/github20120522/docdochelper&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/github20120522/docdochelper&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313144014866-2016688256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143835597-211094025.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143844211-355499675.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143851415-403508961.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143858149-711938140.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143904552-1502340368.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143913283-412486967.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143920489-437186814.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143926545-905191456.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143931878-181337661.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143940785-1545764268.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143946961-752656679.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143952663-708024102.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313143958317-1668256120.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/755022/201903/755022-20190313144004601-2082076192.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 13 Mar 2019 07:21:00 +0000</pubDate>
<dc:creator>多彩泰坦</dc:creator>
<og:description>前后端分离的常见开发方式是： 后端：接收http请求-&gt;根据请求url及params处理对应业务逻辑-&gt;将处理结果序列化为json返回 前端：发起http请求并传递相关参数-&gt;获取返</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiayudashan/p/10518500.html</dc:identifier>
</item>
<item>
<title>FFmpeg封装格式处理4-转封装例程 - 叶余</title>
<link>http://www.cnblogs.com/leisure_chn/p/10506662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leisure_chn/p/10506662.html</guid>
<description>&lt;p&gt;本文为作者原创，转载请注明出处：&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10506662.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/leisure_chn/p/10506662.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FFmpeg封装格式处理相关内容分为如下几篇文章：&lt;br/&gt;[1]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10506636.html&quot;&gt;FFmpeg封装格式处理-简介&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10506642.html&quot;&gt;FFmpeg封装格式处理-解复用例程&lt;/a&gt;&lt;br/&gt;[3]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10506653.html&quot;&gt;FFmpeg封装格式处理-复用例程&lt;/a&gt;&lt;br/&gt;[4]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10506662.html&quot;&gt;FFmpeg封装格式处理-转封装例程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;转封装例程&quot;&gt;5. 转封装例程&lt;/h2&gt;
&lt;p&gt;转封装是将一种封装格式转换为另一种封装格式，不涉及编解码操作，转换速度非常快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://leichn.github.io/img/ffmpeg_muxde/remuxing.jpg&quot; title=&quot;remuxing&quot; alt=&quot;remuxing&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;5.1 源码&lt;/h3&gt;
&lt;p&gt;源码修改自 FFmpeg 4.1 自带的例程 remuxing.c。代码非常简短：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;libavutil/timestamp.h&amp;gt;
#include &amp;lt;libavformat/avformat.h&amp;gt;

int main(int argc, char **argv)
{
    AVOutputFormat *ofmt = NULL;
    AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL;
    AVPacket pkt;
    const char *in_filename, *out_filename;
    int ret, i;
    int stream_index = 0;
    int *stream_mapping = NULL;
    int stream_mapping_size = 0;

    if (argc &amp;lt; 3) {
        printf(&quot;usage: %s input output\n&quot;
               &quot;API example program to remux a media file with libavformat and libavcodec.\n&quot;
               &quot;The output format is guessed according to the file extension.\n&quot;
               &quot;\n&quot;, argv[0]);
        return 1;
    }

    in_filename  = argv[1];
    out_filename = argv[2];

    // 1. 打开输入
    // 1.1 读取文件头，获取封装格式相关信息
    if ((ret = avformat_open_input(&amp;amp;ifmt_ctx, in_filename, 0, 0)) &amp;lt; 0) {
        printf(&quot;Could not open input file '%s'&quot;, in_filename);
        goto end;
    }
    
    // 1.2 解码一段数据，获取流相关信息
    if ((ret = avformat_find_stream_info(ifmt_ctx, 0)) &amp;lt; 0) {
        printf(&quot;Failed to retrieve input stream information&quot;);
        goto end;
    }

    av_dump_format(ifmt_ctx, 0, in_filename, 0);

    // 2. 打开输出
    // 2.1 分配输出ctx
    avformat_alloc_output_context2(&amp;amp;ofmt_ctx, NULL, NULL, out_filename);
    if (!ofmt_ctx) {
        printf(&quot;Could not create output context\n&quot;);
        ret = AVERROR_UNKNOWN;
        goto end;
    }

    stream_mapping_size = ifmt_ctx-&amp;gt;nb_streams;
    stream_mapping = av_mallocz_array(stream_mapping_size, sizeof(*stream_mapping));
    if (!stream_mapping) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

    ofmt = ofmt_ctx-&amp;gt;oformat;

    for (i = 0; i &amp;lt; ifmt_ctx-&amp;gt;nb_streams; i++) {
        AVStream *out_stream;
        AVStream *in_stream = ifmt_ctx-&amp;gt;streams[i];
        AVCodecParameters *in_codecpar = in_stream-&amp;gt;codecpar;

        if (in_codecpar-&amp;gt;codec_type != AVMEDIA_TYPE_AUDIO &amp;amp;&amp;amp;
            in_codecpar-&amp;gt;codec_type != AVMEDIA_TYPE_VIDEO &amp;amp;&amp;amp;
            in_codecpar-&amp;gt;codec_type != AVMEDIA_TYPE_SUBTITLE) {
            stream_mapping[i] = -1;
            continue;
        }

        stream_mapping[i] = stream_index++;

        // 2.2 将一个新流(out_stream)添加到输出文件(ofmt_ctx)
        out_stream = avformat_new_stream(ofmt_ctx, NULL);
        if (!out_stream) {
            printf(&quot;Failed allocating output stream\n&quot;);
            ret = AVERROR_UNKNOWN;
            goto end;
        }

        // 2.3 将当前输入流中的参数拷贝到输出流中
        ret = avcodec_parameters_copy(out_stream-&amp;gt;codecpar, in_codecpar);
        if (ret &amp;lt; 0) {
            printf(&quot;Failed to copy codec parameters\n&quot;);
            goto end;
        }
        out_stream-&amp;gt;codecpar-&amp;gt;codec_tag = 0;
    }
    av_dump_format(ofmt_ctx, 0, out_filename, 1);

    if (!(ofmt-&amp;gt;flags &amp;amp; AVFMT_NOFILE)) {    // TODO: 研究AVFMT_NOFILE标志
        // 2.4 创建并初始化一个AVIOContext，用以访问URL(out_filename)指定的资源
        ret = avio_open(&amp;amp;ofmt_ctx-&amp;gt;pb, out_filename, AVIO_FLAG_WRITE);
        if (ret &amp;lt; 0) {
            printf(&quot;Could not open output file '%s'&quot;, out_filename);
            goto end;
        }
    }

    // 3. 数据处理
    // 3.1 写输出文件头
    ret = avformat_write_header(ofmt_ctx, NULL);
    if (ret &amp;lt; 0) {
        printf(&quot;Error occurred when opening output file\n&quot;);
        goto end;
    }

    while (1) {
        AVStream *in_stream, *out_stream;

        // 3.2 从输出流读取一个packet
        ret = av_read_frame(ifmt_ctx, &amp;amp;pkt);
        if (ret &amp;lt; 0)
            break;

        in_stream  = ifmt_ctx-&amp;gt;streams[pkt.stream_index];
        if (pkt.stream_index &amp;gt;= stream_mapping_size ||
            stream_mapping[pkt.stream_index] &amp;lt; 0) {
            av_packet_unref(&amp;amp;pkt);
            continue;
        }

        pkt.stream_index = stream_mapping[pkt.stream_index];
        out_stream = ofmt_ctx-&amp;gt;streams[pkt.stream_index];

        /* copy packet */
        // 3.3 更新packet中的pts和dts
        // 关于AVStream.time_base的说明：
        // 输入：输入流中含有time_base，在avformat_find_stream_info()中可取到每个流中的time_base
        // 输出：avformat_write_header()会根据输出的封装格式确定每个流的time_base并写入文件中
        // AVPacket.pts和AVPacket.dts的单位是AVStream.time_base，不同的封装格式其AVStream.time_base不同
        // 所以输出文件中，每个packet需要根据输出封装格式重新计算pts和dts
        av_packet_rescale_ts(&amp;amp;pkt, in_stream-&amp;gt;time_base, out_stream-&amp;gt;time_base);
        pkt.pos = -1;

        // 3.4 将packet写入输出
        ret = av_interleaved_write_frame(ofmt_ctx, &amp;amp;pkt);
        if (ret &amp;lt; 0) {
            printf(&quot;Error muxing packet\n&quot;);
            break;
        }
        av_packet_unref(&amp;amp;pkt);
    }

    // 3.5 写输出文件尾
    av_write_trailer(ofmt_ctx);
end:

    avformat_close_input(&amp;amp;ifmt_ctx);

    /* close output */
    if (ofmt_ctx &amp;amp;&amp;amp; !(ofmt-&amp;gt;flags &amp;amp; AVFMT_NOFILE))
        avio_closep(&amp;amp;ofmt_ctx-&amp;gt;pb);
    avformat_free_context(ofmt_ctx);

    av_freep(&amp;amp;stream_mapping);

    if (ret &amp;lt; 0 &amp;amp;&amp;amp; ret != AVERROR_EOF) {
        printf(&quot;Error occurred: %s\n&quot;, av_err2str(ret));
        return 1;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译&quot;&gt;5.2 编译&lt;/h3&gt;
&lt;p&gt;源文件为remuxing.c，在SHELL中执行如下编译命令：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;gcc -o remuxing remuxing.c -lavformat -lavcodec -lavutil -g&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成可执行文件remuxing&lt;/p&gt;
&lt;h3 id=&quot;验证&quot;&gt;5.3 验证&lt;/h3&gt;
&lt;p&gt;测试文件下载：&lt;a href=&quot;https://github.com/leichn/blog_resources/blob/master/video/tuan/tnliny.flv&quot;&gt;tnshih.flv&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://leichn.github.io/img/ffmpeg_muxde/tnliny-001.jpg&quot; title=&quot;林译&quot; alt=&quot;林译&quot;/&gt;&lt;br/&gt;先看一下测试用资源文件的格式：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;think@opensuse&amp;gt; ffprobe tnliny.flv 
ffprobe version 4.1 Copyright (c) 2007-2018 the FFmpeg developers
Input #0, flv, from 'tnliny.flv':
  Metadata:
    encoder         : Lavf58.20.100
  Duration: 00:02:26.54, start: 0.000000, bitrate: 446 kb/s
    Stream #0:0: Video: h264 (High), yuv420p(progressive), 800x450, 25 fps, 25 tbr, 1k tbn, 50 tbc
    Stream #0:1: Audio: aac (LC), 44100 Hz, stereo, fltp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行如下命令进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./remuxing tnliny.flv tnliny.ts&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用ffprobe检测输出文件正常。使用ffplay播放输出文件正常，播放效果和原始的测试文件一致。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 07:19:00 +0000</pubDate>
<dc:creator>叶余</dc:creator>
<og:description>本文为作者原创，转载请注明出处： FFmpeg封装格式处理相关内容分为如下几篇文章： '1]. [FFmpeg封装格式处理 简介' '2]. [FFmpeg封装格式处理 解复用例程' '3]. [FF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leisure_chn/p/10506662.html</dc:identifier>
</item>
<item>
<title>C# 组件模组引用第三方组件问题 - 旦旦</title>
<link>http://www.cnblogs.com/DasonKwok/p/10523279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DasonKwok/p/10523279.html</guid>
<description>&lt;p&gt;&lt;span&gt;对接上一文章由于是动态加载指定程序集，会把当前目录下所有&lt;/span&gt;dll&lt;span&gt;都加载进来。如果像&lt;/span&gt;&lt;span&gt;sqlite&lt;/span&gt;&lt;span&gt;这种第三组件调用了由&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;非&lt;/span&gt;&lt;span&gt;.net&lt;/span&gt;&lt;span&gt;语言所以生成的&lt;/span&gt;&lt;span&gt;Dll&lt;/span&gt;&lt;span&gt;。因为自动生成的原因。会把非&lt;/span&gt;&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;生成的&lt;/span&gt;&lt;span&gt;dll&lt;/span&gt;&lt;span&gt;都加载入来导致加载失败。程序异常。那结果当然不是我们想要的结果了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150349566-75194048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;怎么避免这类事情的发现。那竟然不能加载所有&lt;/span&gt;dll&lt;span&gt;了。那就再细化处理。如果有人把组件模组生成了&lt;/span&gt;&lt;span&gt;exe&lt;/span&gt;&lt;span&gt;那我们正常来说也应该要处理的。毕竟这也是&lt;/span&gt;&lt;span&gt;.net&lt;/span&gt;&lt;span&gt;所生成出来的项目。也可以动态加载才是正路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按上一文章生成输出的设置。把每个组件模组生成到指定的目录中去。发下图（可参考上一文章&lt;/span&gt;IDE&lt;span&gt;项目的设置）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150449533-344038407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优化加载管理类，把组件模组目录的一级目录当组件名称。一个组件占一个目录以组件模组命名目录。在加载组件时扫描第一层目录。通过第一层目录知道这个组件模组的主程序集。通过命名约束来找到主程序集引用加载。避免加载到非&lt;/span&gt;.net&lt;span&gt;生成的&lt;/span&gt;&lt;span&gt;dll&lt;/span&gt;&lt;span&gt;。然后通过&lt;/span&gt;&lt;span&gt;GetReferencedAssemblies&lt;/span&gt;&lt;span&gt;方法找出组件模组引用的程序集，把相关的程序集一一加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150512937-117331800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加载组件模组引用第三方&lt;/span&gt;.net&lt;span&gt;如图是第三方写的&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;组件。动态加载后再把这个第三方程序集也成功引用入到平台项目中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150539563-590164124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后运行的效果发现出错了说是调用不成功要引用的第三方组件，因为找不到那个文件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150557018-1668591900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;竟然是找不到文件那要不把那个文件加入到目录试下。果然是能够运行起来了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150628112-1711297739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但这不科学不合理啊。我主程序都没有引用我怎么能够把第三方程序集放到根目录呢。那要是这样子我们还怎么扩展做组件模组。把所在第三方都放在根目录以要是项目引用很多第三方那很不好管理。要是管理不当，引用包的版本冲突这是有一定机率发现的。那竟然是找不到调用文件能不能在解释出错时返回一个正常的程序集包就行了吧。这理论上也是没毛病的。在&lt;/span&gt;AppDomaing&lt;span&gt;下找到对应的事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150703667-483049803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那就对这事件进行下调用方法。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150709858-2000608196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这段代码只要在执行组件模组前调用就行了。为了方便就只直写在&lt;/span&gt;Main&lt;span&gt;方法的第一行中方便大家见到。运行效果就不贴图了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但如引用&lt;/span&gt;sqlite&lt;span&gt;这样的第三方组件，由于这第三方组件还调用了&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;写的&lt;/span&gt;&lt;span&gt;SQLite.Interop.dll&lt;/span&gt;&lt;span&gt;文件，还区分运行平台是&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;位系是&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;位程序。运行输出效果还是找不到指定文件。还是能够够通过把&lt;/span&gt;&lt;span&gt;x64\x86&lt;/span&gt;&lt;span&gt;这两个文件目录复制到根目录去这就解决问题了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150804412-1696569030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150811519-662676556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150827723-1703207322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;但这也还是在把东西复制到根目录啊，有没有办法解决这个问题呢。调用非&lt;/span&gt;.net&lt;span&gt;的&lt;/span&gt;&lt;span&gt;dll&lt;/span&gt;&lt;span&gt;主要是思路基本上是找到第三方的&lt;/span&gt;&lt;span&gt;dll&lt;/span&gt;&lt;span&gt;的绝对路径，通过路径调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;System.Runtime.InteropServices.DllImportAttribute(string dllName)&lt;/p&gt;
&lt;p&gt;System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute()&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这类方法去调用非&lt;/span&gt;.net&lt;span&gt;的&lt;/span&gt;&lt;span&gt;dll&lt;/span&gt;&lt;span&gt;文件的指定方法。这主要还是看写组件开发者的写法，像&lt;/span&gt;&lt;span&gt;system.data.sqlite&lt;/span&gt;&lt;span&gt;的开发者还提供&lt;/span&gt;&lt;span&gt;dll&lt;/span&gt;&lt;span&gt;配置方式。可以在初始化时加入配置。然后执行的效果和上面一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/43071/201903/43071-20190313150902587-1508005154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但如果没有配置的是不是一定要把&lt;/span&gt;dll&lt;span&gt;放在根目录上呢。&lt;/span&gt;&lt;span&gt;这个问题是关于程序域（&lt;/span&gt;AppDomain&lt;span&gt;）的问题还是下一回慢慢解说吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;版本&lt;/span&gt;2&lt;span&gt;的代码附件https://files.cnblogs.com/files/DasonKwok/MyPlatformV2.zip&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 07:13:00 +0000</pubDate>
<dc:creator>旦旦</dc:creator>
<og:description>对接上一文章由于是动态加载指定程序集，会把当前目录下所有dll都加载进来。如果像sqlite这种第三组件调用了由C、C++非.net语言所以生成的Dll。因为自动生成的原因。会把非C#生成的dll都加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DasonKwok/p/10523279.html</dc:identifier>
</item>
<item>
<title>测试管理-测试过程监控 - Vincent83</title>
<link>http://www.cnblogs.com/yingyingja/p/10523110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yingyingja/p/10523110.html</guid>
<description>&lt;p&gt;测试活动的监控，对于整体测试工程而言是非常重要的管理内容。&lt;/p&gt;
&lt;p&gt;测试工作本身是非常依赖项目其他环节的，测试活动的进行充满了变数。所以对测试的实行情况进行持续的监控和做出及时应对，是管好一个测试项目的必要工作。&lt;/p&gt;

&lt;p&gt;测试的监控是一个贯穿于整个测试周期内的工作。&lt;/p&gt;
&lt;p&gt;在一些情况下，监控的行为并不需要非常系统化的规划和定义，即使如此他很可能也在实时发生着。比如询问某个测试人员的工作进展情况，就可以视作基础的监控动作。对于复杂度相对较低，流程梳理清晰的项目而言，监控工作可能并不复杂，也无需精密的体系和机制进行保证。但是对于复杂平台等一些项目，建立良好的监督控制框架可能是有必要的。&lt;/p&gt;
&lt;h2&gt;1.&lt;strong&gt;&lt;span&gt;监控&lt;/span&gt;&lt;span&gt;的目标&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在理想情况下，参照V模型理论，我们项目研发应该从项目立项到需求分析到设计到编码，测试从需求评审到测试计划到测试设计到测试执行和报告，有条不紊的开展下去。每个阶段都产出高质量的产出，为下一个或下几个阶段提供支撑。&lt;/p&gt;
&lt;p&gt;然而，在实际工作场景中，我们有可能遇到复杂的甚至是计划和预料之外的情况。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需求到位不及时，或者需求文档质量低下，测试依据不足；&lt;/li&gt;
&lt;li&gt;单元测试覆盖率不达标甚至整体缺失，底层测试不充分；&lt;/li&gt;
&lt;li&gt;代码提测时间延期，压缩测试时间；&lt;/li&gt;
&lt;li&gt;交付产品缺陷情况超出预期，测试任务加重；&lt;/li&gt;
&lt;li&gt;项目计划无预期变更，测试原本规划被打乱；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;等等&lt;/span&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;笔者将监控的目标总结如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l &lt;strong&gt;进度掌控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-把握项目进度情况，根据实际与排期之间的差别及时做出调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l &lt;strong&gt;管理风险&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-及时对项目中的风险进行识别和评估，并作出控制和缓解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l &lt;strong&gt;解决问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-做为管理方主动发现和解决团队成员工作中遭遇到的实际困难和问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l &lt;strong&gt;加强协同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-通过监控达到加强团队协同能力的目的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;总的来说，管理人员必须及时跟进测试实施情况，一旦发生进度滞后，质量低下等影响产品按期高质量交付的情况，必须采取合适的控制行动，扭转这些偏离和异常。良好规划的测试计划是测试管理人实行监督控制的基准和依据，所以也要求我们的计划本身需要高质量制定。良好的计划会使得监督工作更容易展开，有更明确的测试目标和安排，也就更容易让我们发现实际开展过程中的异常。&lt;/p&gt;
&lt;p&gt;实际操作过程中，对异常情况或者目标偏离的控制手段，可以是计划的变更以适应实际情况，也可以是资源（人员，时间）的调整。在这个过程中，很有可能需要项目其他方面的协调协助，测试管理人应该始终与项目其他干系人保持良好的合作关系。&lt;/p&gt;
&lt;p&gt;为了保证测试任务能够顺利完成，建立有效的监控机制是有必要的。&lt;/p&gt;

&lt;h2&gt;2. &lt;strong&gt;建立监控机制&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;2.1. &lt;strong&gt;监控整体流程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们可以用一系列的活动来组织监控流程，一个良好的监控流程应该有以下阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;信息采集&lt;/li&gt;
&lt;li&gt;问题分析&lt;/li&gt;
&lt;li&gt;实施控制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体到过程上：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;了解情况&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;发现问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;核实问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;评估影响&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;给出方案&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解决问题&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201903/1451355-20190313145739017-1248263391.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;2.2. &lt;strong&gt;触发机制&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;监控触发机制定义测试管理人员在什么触发条件下，启动监控手段。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CMMi定义了以下三种启动形式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l &lt;strong&gt;定期监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;- 安排固定的监控周期，比如每天、每周等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;项目的管理安排一般都会确定这样的定期活动，比如周例会是很多项目会采取的形式，会议中与会各方会提供关于项目进展的信息以供跟踪控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在敏捷型项目中，一个Scrum会议就是典型的定期监控活动，每天项目成员会集体讨论各自的工作进展情况；而在每一个冲刺期的最后阶段，还会安排当前冲刺期的定期回顾会议活动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l &lt;strong&gt;阶段性监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-以项目生命周期各阶段的里程碑为标记，通过里程碑的评审会议来对项目的各种参数进行跟踪和监控。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前文我们在测试计划中提到了里程碑的概念，一个里程碑的到达标识着阶段性成果的达成。之所以要设置里程碑，最主要的意义就在于给我们预先设立一个检查点，让我们检查项目进度情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l &lt;strong&gt;事件触发性监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-当突发性事件发生时，需要启动及时的控制手段以应对事件的影响。比如需求的计划变更；比如人员的变动等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;除了以上这些触发场景之外，测试管理人也需要实时关注测试工作进展，保证测试任务尽可能无偏差完成。&lt;/p&gt;
&lt;h3&gt;2.3. &lt;strong&gt;度量机制&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;测试管理人应该建立相应的度量指标，这样才更有利于对相应情况进行比对分析。否则如果缺乏明确的度量办法，监督得出的结论可能偏向主观评判。&lt;/p&gt;
&lt;p&gt;测试的监控对象主要可以有以下方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l 质量风险 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 缺陷 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 测试进度 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 覆盖率 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 信心&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;在项目和业务中，产品风险、缺陷、测试和覆盖率可以，且通常以特定的方式进行度量和汇报。如果这些度量数据和测试计划中定义的出口准则相关，他们可以作为判断测试工作是否完成的客观标准。信心的度量可以通过调查或使用覆盖率作为替代度量，不过通常也会以主观的方式汇报信心。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;如果以上内容在项目中适合做为监控对象，那么测试管理人应该尽量明确量化的标准，并且建立这些相关数据的采集办法。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;比如对于&lt;strong&gt;风险&lt;/strong&gt;的监控，可以采用的度量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l 完全覆盖的风险百分比&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 部分覆盖的风险的百分比&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 还未完全测试的风险的百分比&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 按风险类别划分的覆盖的风险百分比 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 在初次质量风险分析后识别的风险的百分比&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;对于&lt;strong&gt;测试过程&lt;/strong&gt;的监控，可以采用的度量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l 已定义的测试工作项（比如用例设计）的完成度与完成时间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 已计划的、已详细说明（已实施）的、已运行、通过的、失败的、无法执行的和跳过不执行的 测试总数 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 回归测试和确认测试的状态，包括趋势和未通过的回归测试总数及未通过的确认测试总数 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 计划的每日测试时长对比实际的每日测试时长 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 测试环境的可用性（准备测试团队可用的测试环境占计划测试时长的百分比）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;对于&lt;strong&gt;缺陷情况&lt;/strong&gt;可以采用的度量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l 缺陷到达率：缺陷在一定时间段内爆出的数量；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 缺陷移除率：缺陷在发生阶段被移除的情况；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 缺陷分布：缺陷在不同模块或子系统中出现的占比；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 缺陷修复率：单位时间内，报出的，被修复的以及遗留的缺陷数量的对比；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;除了这些以外还有缺陷有效率，缺陷类型统计等等可以帮助我们去度量缺陷收敛情况的数据。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;对于&lt;strong&gt;覆盖率&lt;/strong&gt;监控，可以采用的度量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l 需求和设计要素的覆盖率 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 风险覆盖率 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 环境／配置覆盖率 ·&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 代码覆盖率&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;justify&quot;&gt;&lt;span&gt; 2.4. 信息&lt;strong&gt;采集机制&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上节提到的数据度量，都需要基于足够并且准确的数据才能完成，所以有必要建立高效的数据采集机制。可以考虑采用以下办法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l 问讯 ·&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　-　　即测试管理人主动向测试干系人和测试人员询问进度情况&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l 阶段性汇报&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　-　　比如日报和周报的手段，收集测试人员关于工作内容及时间花费、测试执行情况、缺陷收敛情况、需要解决之问题以及未来大致安排等信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　-　　这些信息需要被整合，得出整体进度、缺陷、工作安排、严重问题的汇总。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l 跟踪矩阵&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　-　　采用跟踪矩阵的形式，收集测试活动进程信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　-　　常见的矩阵可以从个人工作信息和汇总信息两个层面组织。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如个人层面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201903/1451355-20190313150318965-1086940036.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;汇总层面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201903/1451355-20190313150338468-1216403126.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;采用图表跟踪的办法可以让收集的信息呈现出更高的可视性和可读性，例如：&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201903/1451355-20190313150352742-1616866592.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;318&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;3. &lt;/span&gt;&lt;strong&gt;补充&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　最后，测试监控的目的，不仅仅是确保测试进度、完成情况与计划和预期的吻合。对于测试管理人而言，我们测试管理的终极目的在于对质量的保证，而不单单是完成测试的任务。像之前章节中提到的，测试做为整体研发的反馈回路，测试监控中收集到的信息和分析，也是对于项目整体情况的反馈信息源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　测试工作本身并不能直接产出质量，就像用体重器称重并不能减肥一样。测试需要依靠它的反馈功能，来促使问题的解决和质量的提高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　测试的反馈作用体现在汇报问题和促进问题解决，还表现在用测试的信息收集功能，对于整个研发过程乃至项目管理的情况进行反馈，帮助解决研发过程和管理效能方面的问题。测试监督过程中收集到的数据和信息，都可以用于研发过程能力的反馈。&lt;/span&gt;比如项目计划阶段，我们通过风险评估可能会得出某一模块出现缺陷的分概念较低的结论。但是实际测试过程中，可能反映出的实际情况是该模块缺陷频繁爆出。这样的信息可以很大程度推出开发过程出现了未预知的问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　测试管理人应该及时将类似问题系统化，并反馈给开发负责人，依靠和告知团队其他干系人比如项目经理。不能一味的依靠测试执行工作去解决这样的现状，而是要争取从研发链路的更上游控制问题的解决。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 07:08:00 +0000</pubDate>
<dc:creator>Vincent83</dc:creator>
<og:description>测试活动的监控，对于整体测试工程而言是非常重要的管理内容。 测试工作本身是非常依赖项目其他环节的，测试活动的进行充满了变数。所以对测试的实行情况进行持续的监控和做出及时应对，是管好一个测试项目的必要工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yingyingja/p/10523110.html</dc:identifier>
</item>
<item>
<title>iOS学习——图片压缩到指定大小以内 - mukekeheart</title>
<link>http://www.cnblogs.com/mukekeheart/p/10522911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mukekeheart/p/10522911.html</guid>
<description>&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;　　在我们开发过程中，有可能会遇到拍照、或者从相册中选择图片，要么单选或者多选，然后上传图片到服务器，一般情况下一张图片可能3-4M，如果类似微信朋友圈上传9张图片大约是 35M左右，如果我们上传 35M左右的图片到服务器，可想而知后台的压力有多大，最主要的还是特别耗时，如果是在网速比较慢，那么用户上传图片可能需要4-5分钟，那么用户就会受不了，可能会退出应用。所有&lt;/span&gt;&lt;span&gt;在开发过程中，考虑到手机性能、网络性能等因素的影响，更重要的是后台服务器的内存、网络等性能的限制，我们再通过网络发送图片等信息时不能发送超过一定大小的图片，如果超过了指定大小，我们需要进行压缩后发送。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们必须明确图片的压缩其实是两个概念：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;“&lt;strong&gt;压&lt;/strong&gt;” 是指文件体积变小，但是像素数不变，长宽尺寸不变，那么质量可能下降。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;“&lt;strong&gt;缩&lt;/strong&gt;” 是指文件的尺寸变小，也就是像素数减少，而长宽尺寸变小，文件体积同样会减小。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt; 2.1 “压”处理&lt;/h2&gt;
&lt;div readability=&quot;41&quot;&gt;
&lt;p&gt;&lt;span&gt;　　对于“压”的功能，我们一般是使用系统提供的UIImageJPEGRepresentation或UIImagePNGRepresentation方法实现，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format&lt;/span&gt;
UIKIT_EXTERN NSData *UIImagePNGRepresentation(UIImage *&lt;span&gt;image); 

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)                              &lt;/span&gt;
UIKIT_EXTERN NSData *UIImageJPEGRepresentation(UIImage *&lt;span&gt;image, CGFloat compressionQuality); 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UIImageJPEGRepresentation需要传两个参数，
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数是图片对象
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数是压的系数，其值范围为0~1&lt;/span&gt;
NSData *imgData=UIImageJPEGRepresentation(image, &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UIImagePNGRepresentation只需要传一个参数，就是图片对象&lt;/span&gt;
NSData *imgData = UIImagePNGRepresentation(image);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　UIImagePNGRepresentation要比UIImageJPEGRepresentation(UIImage* image, 1.0)返回的图片数据量大很多。同样的一张照片, 使用UIImagePNGRepresentation(image)返回的数据量大小为199K,而UIImageJPEGRepresentation(image, 1.0)返回的数据量大小只为140K,比前者少了59K。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;如果对图片的清晰度要求不是极高,建议使用UIImageJPEGRepresentation，可以大幅度降低图片数据量.其中&lt;span class=&quot;s1&quot;&gt;UIImageJPEGRepresentation(&lt;span class=&quot;s2&quot;&gt;UIImage&lt;span class=&quot;s1&quot;&gt; *image, &lt;span class=&quot;s2&quot;&gt;CGFloat&lt;span class=&quot;s1&quot;&gt; compressionQuality)提供了一个压缩比率的参数compressionQuality，但是实际体验确实compressionQuality并不能够按照设定好的数值，比例压缩。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;比如一张2.9M的图片(jpg格式),通过UIImageJPEGRepresentation方法设置不同压缩比进行压缩后的大小如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt;-&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;33.546342&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; CJMobile[&lt;span&gt;52591&lt;/span&gt;:&lt;span&gt;15764262&lt;/span&gt;] compression = &lt;span&gt;1.000000&lt;/span&gt; image length = &lt;span&gt;7076.682617&lt;/span&gt;&lt;span&gt; kB
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt;-&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;33.658606&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; CJMobile[&lt;span&gt;52591&lt;/span&gt;:&lt;span&gt;15764262&lt;/span&gt;] compression = &lt;span&gt;0.500000&lt;/span&gt; image length = &lt;span&gt;1490.095703&lt;/span&gt;&lt;span&gt; kB
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt;-&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;33.748077&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; CJMobile[&lt;span&gt;52591&lt;/span&gt;:&lt;span&gt;15764262&lt;/span&gt;] compression = &lt;span&gt;0.250000&lt;/span&gt; image length = &lt;span&gt;671.213867&lt;/span&gt;&lt;span&gt; kB
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt;-&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;33.834126&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; CJMobile[&lt;span&gt;52591&lt;/span&gt;:&lt;span&gt;15764262&lt;/span&gt;] compression = &lt;span&gt;0.125000&lt;/span&gt; image length = &lt;span&gt;550.979492&lt;/span&gt;&lt;span&gt; kB
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt;-&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;33.918830&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; CJMobile[&lt;span&gt;52591&lt;/span&gt;:&lt;span&gt;15764262&lt;/span&gt;] compression = &lt;span&gt;0.062500&lt;/span&gt; image length = &lt;span&gt;532.168945&lt;/span&gt;&lt;span&gt; kB
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt;-&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;34.004086&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; CJMobile[&lt;span&gt;52591&lt;/span&gt;:&lt;span&gt;15764262&lt;/span&gt;] compression = &lt;span&gt;0.031250&lt;/span&gt; image length = &lt;span&gt;532.107422&lt;/span&gt;&lt;span&gt; kB
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt;-&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;34.089819&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; CJMobile[&lt;span&gt;52591&lt;/span&gt;:&lt;span&gt;15764262&lt;/span&gt;] compression = &lt;span&gt;0.015625&lt;/span&gt; image length = &lt;span&gt;532.107422&lt;/span&gt; kB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;s1&quot;&gt;　　通过上面的结果我们可以看到，compressionQuality压缩系数跟最后文件的大小并没有明显的关系，不同的图片呈现不同结果，而且最后压缩比减小但是得到的图片大小没有变化。&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;本人对图片存储格式不是很了解，所以对出现这样的情况不是很了解，如果有对此比较了解的同学烦请赐教。但是图片颜色细节越单一，图片可压缩的比率会越高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;s1&quot;&gt;　　&lt;span&gt;&lt;strong&gt;UIImagePNGRepresentation虽然可以让我们控制压缩质量比例，但是我们看到这个压缩比compressionQuality实际上很难确定一张图片是否能压缩到误差范围内，无法实现精确压缩&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;2.2 “缩”处理&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;UIImagePNGRepresentation虽然可以让我们控制压缩质量比例，但是我们看到这个压缩比compressionQuality实际上很难确定一张图片是否能压缩到误差范围内，无法实现精确压缩。所以我们对图片只“压”而不缩，有时候是达不到我们的需求的。因此，必要的时候，我们需要适当地对图片“缩”一“缩“尺寸，就可以满足我们的需求。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;18.5&quot;&gt;
&lt;p&gt;&lt;span&gt;通过 &lt;span class=&quot;cnblogs_code&quot;&gt;[sourceImage drawInRect:CGRectMake(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, targetWidth, targetHeight)]&lt;/span&gt; 可以进行图片“缩”的功能。示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
- (UIImage*)compressImage:(UIImage*&lt;span&gt;)sourceImage toTargetWidth:(CGFloat)targetWidth {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取原图片的大小尺寸&lt;/span&gt;
    CGSize imageSize =&lt;span&gt; sourceImage.size;
    CGFloat width &lt;/span&gt;=&lt;span&gt; imageSize.width;
    CGFloat height &lt;/span&gt;=&lt;span&gt; imageSize.height;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据目标图片的宽度计算目标图片的高度&lt;/span&gt;
    CGFloat targetHeight = (targetWidth / width) *&lt;span&gt; height;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启图片上下文&lt;/span&gt;
&lt;span&gt;    UIGraphicsBeginImageContext(CGSizeMake(targetWidth, targetHeight));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制图片&lt;/span&gt;
    [sourceImage drawInRect:CGRectMake(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, targetWidth, targetHeight)];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从上下文中获取绘制好的图片&lt;/span&gt;
    UIImage*newImage =&lt;span&gt; UIGraphicsGetImageFromCurrentImageContext();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭图片上下文&lt;/span&gt;
&lt;span&gt;    UIGraphicsEndImageContext();
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newImage;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;通过“缩”处理，我们可以将图片压缩到任何我们制定的大小尺寸内，但是这种处理，我们改变了原先图片的尺寸大小，无法保证图片的质量&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　当我们需要对图片的大小进行限制时，我们首先应该优先采取“压”处理，如果“压”处理达不到要求，那么我们在“压”处理的结果上继续进行“缩”处理，直到图片的大小达到我们的要求为止。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;!
 *  @brief 使图片压缩后刚好小于指定大小
 *
 *  @param image 当前要压缩的图 maxLength 压缩后的大小
 *
 *  @return 图片对象
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片质量压缩到某一范围内，如果后面用到多，可以抽成分类或者工具类,这里压缩递减比二分的运行时间长，二分可以限制下限。&lt;/span&gt;
- (UIImage *)compressImageSize:(UIImage *&lt;span&gt;)image toByte:(NSUInteger)maxLength{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先判断原图大小是否在要求内，如果满足要求则不进行压缩，over&lt;/span&gt;
    CGFloat compression = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    NSData &lt;/span&gt;*data =&lt;span&gt; UIImageJPEGRepresentation(image, compression);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.length &amp;lt; maxLength) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; image;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原图大小超过范围，先进行“压处理”，这里 压缩比 采用二分法进行处理，6次二分后的最小压缩比是0.015625，已经够小了&lt;/span&gt;
    CGFloat max = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    CGFloat min &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;6&lt;/span&gt;; ++&lt;span&gt;i) {
        compression &lt;/span&gt;= (max + min) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
        data &lt;/span&gt;=&lt;span&gt; UIImageJPEGRepresentation(image, compression);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.length &amp;lt; maxLength * &lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;) {
            min &lt;/span&gt;=&lt;span&gt; compression;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.length &amp;gt;&lt;span&gt; maxLength) {
            max &lt;/span&gt;=&lt;span&gt; compression;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断“压处理”的结果是否符合要求，符合要求就over&lt;/span&gt;
    UIImage *resultImage =&lt;span&gt; [UIImage imageWithData:data];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.length &amp;lt; maxLength) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultImage;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩处理，直接用大小的比例作为缩处理的比例进行处理，因为有取整处理，所以一般是需要两次处理&lt;/span&gt;
    NSUInteger lastDataLength = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (data.length &amp;gt; maxLength &amp;amp;&amp;amp; data.length !=&lt;span&gt; lastDataLength) {
        lastDataLength &lt;/span&gt;=&lt;span&gt; data.length;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取处理后的尺寸&lt;/span&gt;
        CGFloat ratio = (CGFloat)maxLength /&lt;span&gt; data.length;
        CGSize size &lt;/span&gt;= CGSizeMake((NSUInteger)(resultImage.size.width *&lt;span&gt; sqrtf(ratio)),
                                 (NSUInteger)(resultImage.size.height &lt;/span&gt;*&lt;span&gt; sqrtf(ratio)));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过图片上下文进行处理图片&lt;/span&gt;
&lt;span&gt;        UIGraphicsBeginImageContext(size);
        [resultImage drawInRect:CGRectMake(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, size.width, size.height)];
        resultImage &lt;/span&gt;=&lt;span&gt; UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取处理后图片的大小&lt;/span&gt;
        data =&lt;span&gt; UIImageJPEGRepresentation(resultImage, compression);
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultImage;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 13 Mar 2019 06:34:00 +0000</pubDate>
<dc:creator>mukekeheart</dc:creator>
<og:description>一、图片压缩简述 在我们开发过程中，有可能会遇到拍照、或者从相册中选择图片，要么单选或者多选，然后上传图片到服务器，一般情况下一张图片可能3-4M，如果类似微信朋友圈上传9张图片大约是 35M左右，如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mukekeheart/p/10522911.html</dc:identifier>
</item>
<item>
<title>全网Star最多（近20k）的Spring Boot开源教程 2019 年要继续更新了！ - 程序猿DD</title>
<link>http://www.cnblogs.com/didispace/p/10522810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/didispace/p/10522810.html</guid>
<description>&lt;p&gt;从2016年1月开始写博客，默默地更新&lt;a href=&quot;http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/&quot;&gt;《Spring Boot系列教程》&lt;/a&gt;，从无人问津到千万访问，作为一个独立站点（&lt;a href=&quot;http://blog.didispace.com&quot; class=&quot;uri&quot;&gt;http://blog.didispace.com&lt;/a&gt;），相信只有那些跟我一样，坚持维护自己独立博客的童鞋才能体会这有多么不容易。&lt;/p&gt;
&lt;p&gt;由于没有行业资讯类网站这样的权重优势，各种发布于这些平台上的洗稿文章与相似内容，就算发布时间较晚，它依然可以在百度上占据很大的搜索优势，以至于一些读者在读了其他人发布于CSDN上的一些文章之后看到我的原文，再来我这里喷我抄袭，这样的现象早已经习以为常了。但是庆幸，这些内容的很大一部分读者都是科学上网的好手，我大部分的流量来源都源自谷歌，这点不得不佩服谷歌对原创与一手内容的尊重，这才让我们这些能够独立思考与写作分享的技术人可以一直坚持下去。&lt;/p&gt;
&lt;p&gt;不知道从什么时候开始，技术圈里的浮夸运营风也越来越重，各种原本非常有含金量的数据也变得越来越虚假，洗稿、盗版等内容的横行，不断侵害着所有原创作者的切身利益。也许这其中包含各种原因：运营KPI的压力，一些大v自媒体的粗暴价值观宣导，所谓的运营套路分享等等。很多原本坚持原创和自有版权的技术人，也都逐步顶不住诱惑得去制造低质量内容，甚至也去传播盗版侵权内容。&lt;/p&gt;
&lt;p&gt;这些环境问题，有时候很想去改变，但是当我想去做什么的时候，才发现自己是多么渺小，因为面对这个现实，要对抗的不是简单的内容发布者，而是那些有背景强大的机构、是那些拥有更大流量的自媒体。想要去改变这样的环境，对于我这样的个体来说几乎是不可能的。&lt;/p&gt;
&lt;p&gt;对于这样的现状，我虽然无力去改变，也无法控制别人不要去做那些盗版侵权的事，但是我还是可以继续坚持做好自己。&lt;/p&gt;
&lt;p&gt;所以，下面我想给大家推荐一下我在维护的目前全网关注（Star）最多的Spring Boot开源教程项目！因为，接下来对于该项目的内容更新，将列入2019年的主要输出内容计划之一，下周开始，我会以每周至少1-2篇的速度持续更新该系列内容，主要目标是整理最新的Spring 2.1.x的入门指南。&lt;strong&gt;如果您关注Spring Boot，并且认可我对该框架的解读，欢迎在文末获取项目地址，点击”Star“关注，第一时间获得更新内容！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一直以来，我从来都没有这样直接的给大家推荐过自己的开源项目。对于我个人而言，一直都是一个比较纯粹的技术人，至今依然每天都有大量的时间花在了阅读和编写代码，享受每天解决问题的成就感与获取新知识的满足感。对于开源项目数据的增长没有KPI压力，也没有对数据的虚荣追求，长期以来这些数据的唯一意义是作为顺带的评价指标，在没有主动索要和刷量的情况下，这些指标对于任何一个开源项目质量的评价有着重要意义（当然放在今日，很多国内项目的数据虚胖问题，相信大家也有所了解，前文也提到了一些背景原因，这里就不做过多导向性的评判）。&lt;/p&gt;
&lt;p&gt;下面列一下主要维护的两个渠道信息，截止到现在，我维护的Spring Boot系列教程的两个代码库，累计接近&lt;strong&gt;2万Star&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;github&quot;&gt;Github&lt;/h3&gt;
&lt;p&gt;Github是我所有内容的第一更新渠道，所以如果您对后续更新感兴趣，那就Star关注吧！&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/dyc87112/SpringBoot-Learning&quot; class=&quot;uri&quot;&gt;https://github.com/dyc87112/SpringBoot-Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201903/626506-20190313141851710-2125835624.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;gitee&quot;&gt;Gitee&lt;/h3&gt;
&lt;p&gt;Gitee的仓库是Github的镜像仓库，由于网络优势，所以一直都会第一时间同步。这个项目的数据是最另我意外的，在整站所有项目的Star排名中居然位列第二，如果是Gitee的忠实用户也可以直接关注这里，一样会得到最快的更新信息。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://gitee.com/didispace/SpringBoot-Learning&quot; class=&quot;uri&quot;&gt;https://gitee.com/didispace/SpringBoot-Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201903/626506-20190313141858479-358097830.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果您觉得内容不错，”Star“、”转发“ 支持一下吧~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 13 Mar 2019 06:19:00 +0000</pubDate>
<dc:creator>程序猿DD</dc:creator>
<og:description>从2016年1月开始写博客，默默地更新 '《Spring Boot系列教程》' ，从无人问津到千万访问，作为一个独立站点（ 'http://blog.didispace.com' ），相信只有那些跟我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/didispace/p/10522810.html</dc:identifier>
</item>
<item>
<title>mysql用户操作、权限分配、远程登录设置 - vinter_he</title>
<link>http://www.cnblogs.com/vinter/p/10522802.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vinter/p/10522802.html</guid>
<description>&lt;p&gt;对最近mysql的常用运维命令进行整理&lt;/p&gt;
&lt;h2 id=&quot;查看使用的哪个配置文件启动的mysql&quot;&gt;查看使用的哪个配置文件启动的mysql&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;1.  ps aux|grep mysql|grep 'my.cnf'
如果启动的命令中选择了配置文件，则可以查询出来，也可能查询不到。


2.  mysql --help|grep 'my.cnf'
输出：
order of preference, my.cnf, $MYSQL_TCP_PORT,
/etc/my.cnf /etc/mysql/my.cnf /opt/app/mysql/etc/my.cnf ~/.my.cnf 
启动时选择配置文件的默认顺序从前到后。

3.  locate my.cnf命令可以列出所有的my.cnf文件，或者使用find命令也可以
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;账户的创建修改和设置权限&quot;&gt;账户的创建修改和设置权限&lt;/h2&gt;
&lt;h4 id=&quot;查看当前已有用户&quot;&gt;1.查看当前已有用户&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    连接mysql的通用方式，可以省略其中一部分参数 ：
    mysql -uroot -h 127.0.0.1 -P 3306 -p

    注意：大写P是端口  小写p是密码
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;create-user创建用户和修改密码和删除&quot;&gt;2. create user创建用户和修改密码和删除&lt;/h4&gt;
&lt;h5 id=&quot;创建用户&quot;&gt;2.1 创建用户：&lt;/h5&gt;
&lt;p&gt;CREATE USER 'username'@'host' IDENTIFIED BY 'password';&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;
例子:

    CREATE USER 'vinter'@'localhost' IDENTIFIED BY '123456';
    注意
    用户名和host必须加引号否则不能运行
    create user vinter;
    此种写法账户无密码，可以在任意客户端任意ip下登录
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;修改密码&quot;&gt;2.2 修改密码：&lt;/h5&gt;
&lt;h6 id=&quot;最容易记住的就是直接update-user表update成功后要使用-flush-privileges更新&quot;&gt;2.2.1 最容易记住的，就是直接update user表,update成功后要使用 flush privileges;更新&lt;/h6&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; update user set password = password('111111') where user = 'vinter';
 
 flush privileges;&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;使用mysqladmin语法mysqladmin--u用户名--p旧密码-password-新密码&quot;&gt;2.2.2 使用mysqladmin语法：mysqladmin -u用户名 -p旧密码 password 新密码&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;mysqladmin -u vinter -p 123 password 456；&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;使用set-password-语句修改&quot;&gt;2.2.3 使用set password 语句修改&lt;/h6&gt;
&lt;p&gt;SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');&lt;br/&gt;如果是当前登陆用户用SET PASSWORD = PASSWORD(&quot;newpassword&quot;);&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    set password forr 'vinter'@'%'=password('haojia');&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删除用户&quot;&gt;2.3 删除用户:&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;DROP USER username@localhost;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用grant语句设置权限&quot;&gt;3.使用grant语句设置权限&lt;/h4&gt;
&lt;h5 id=&quot;赋予权限&quot;&gt;1. 赋予权限：&lt;/h5&gt;
&lt;p&gt;格式语句：&lt;br/&gt;grant 权限1,权限2,...权限n on 数据库名称.表名称 to 用户名@用户地址 identified by '连接密码' [with grant option];&lt;/p&gt;
&lt;p&gt;权限取值如下：&lt;/p&gt;
&lt;p&gt;select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file等&lt;/p&gt;
&lt;p&gt;　　数据库名和表名可以使用通配符&lt;em&gt;来表示所有，比如 dbname.&lt;/em&gt; 和&lt;em&gt;.&lt;/em&gt;&lt;br/&gt;　&lt;br/&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grant all privileges on testdb.* to '‘'vinte'r@'127.0.0.1' identified by '111111';

grant insert,delete,select,update on testdb.* to vinter@127.0.0.1 identified by '111111';

identified by 可以不写，如果写会更改密码为新密码。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：如果带了 with grant option则被授予权限的人，可以把此权限再转授权（传递）给其他用户。&lt;/p&gt;
&lt;h5 id=&quot;撤销权限&quot;&gt;2. 撤销权限&lt;/h5&gt;
&lt;p&gt;语法：REVOKE 权限列表 ON db.table FROM 'username'@'localhost';&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;REVOKE ALL PRIVILEGES ON *.* FROM 'vinter'@'%';

revoke update on *.* from 'vinter'@'%' ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置远程登录&quot;&gt;设置远程登录&lt;/h2&gt;
&lt;p&gt;我们先说一下实现远程登录mysql的条件&lt;br/&gt;首先mysql必须设置相关的权限，允许该账户远程登录，第二需要防火墙设置了3306端口的远程访问。&lt;/p&gt;
&lt;h4 id=&quot;mysql设置远程访问&quot;&gt;1. mysql设置远程访问&lt;/h4&gt;
&lt;p&gt;可以使用grant语句，可以直接更新user表中相关项。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;例子中用户为vinter，ip为192.168.1.111
//固定ip：
grant all privileges on *.* to 'vinter'@'192.168.1.111' identified by '123' with grant option;

insert into user (host,user,password) values('192.168.1.111','vinter',password('123'));


//不限制ip
grant all privileges on *.* to 'vinter'@'%' identified by '123' with grant option;

insert into user (host,user,password) values('%','vinter',password('123'));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;防火墙设置centos7&quot;&gt;2. 防火墙设置（centos7）&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;常用的如下几个其他的见文后附录：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;添加一个端口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重新载入&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;firewall-cmd --reload&lt;/p&gt;
&lt;p&gt;firewall-cmd --zone=public --query-port=80/tcp&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看所有打开的端口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;firewall-cmd --zone=public --list-ports&lt;/p&gt;
&lt;h2 id=&quot;附录-firewalld基本操作&quot;&gt;附录 firewalld基本操作&lt;/h2&gt;
&lt;h4 id=&quot;firewalld的基本使用&quot;&gt;1、firewalld的基本使用&lt;/h4&gt;
&lt;p&gt;启动： systemctl start firewalld&lt;/p&gt;
&lt;p&gt;关闭： systemctl stop firewalld&lt;/p&gt;
&lt;p&gt;查看状态： systemctl status firewalld&lt;/p&gt;
&lt;p&gt;开机禁用 ： systemctl disable firewalld&lt;/p&gt;
&lt;p&gt;开机启用 ： systemctl enable firewalld&lt;/p&gt;
&lt;h4 id=&quot;systemctl是centos7的服务管理工具中主要的工具它融合之前service和chkconfig的功能于一体&quot;&gt;2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。&lt;/h4&gt;
&lt;p&gt;启动一个服务：systemctl start firewalld.service&lt;/p&gt;
&lt;p&gt;关闭一个服务：systemctl stop firewalld.service&lt;/p&gt;
&lt;p&gt;重启一个服务：systemctl restart firewalld.service&lt;/p&gt;
&lt;p&gt;显示一个服务的状态：systemctl status firewalld.service&lt;/p&gt;
&lt;p&gt;在开机时启用一个服务：systemctl enable firewalld.service&lt;/p&gt;
&lt;p&gt;在开机时禁用一个服务：systemctl disable firewalld.service&lt;/p&gt;
&lt;p&gt;查看服务是否开机启动：systemctl is-enabled firewalld.service&lt;/p&gt;
&lt;p&gt;查看已启动的服务列表：systemctl list-unit-files|grep enabled&lt;/p&gt;
&lt;p&gt;查看启动失败的服务列表：systemctl --failed&lt;/p&gt;
&lt;h4 id=&quot;配置firewalld-cmd&quot;&gt;3.配置firewalld-cmd&lt;/h4&gt;
&lt;p&gt;查看版本： firewall-cmd --version&lt;/p&gt;
&lt;p&gt;查看帮助： firewall-cmd --help&lt;/p&gt;
&lt;p&gt;显示状态： firewall-cmd --state&lt;/p&gt;
&lt;p&gt;查看所有打开的端口： firewall-cmd --zone=public --list-ports&lt;/p&gt;
&lt;p&gt;更新防火墙规则： firewall-cmd --reload&lt;/p&gt;
&lt;p&gt;查看区域信息: firewall-cmd --get-active-zones&lt;/p&gt;
&lt;p&gt;查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0&lt;/p&gt;
&lt;p&gt;拒绝所有包：firewall-cmd --panic-on&lt;/p&gt;
&lt;p&gt;取消拒绝状态： firewall-cmd --panic-off&lt;/p&gt;
&lt;p&gt;查看是否拒绝： firewall-cmd --query-panic&lt;/p&gt;
&lt;p&gt;添加端口&lt;/p&gt;
&lt;p&gt;firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）&lt;/p&gt;
&lt;p&gt;重新载入&lt;/p&gt;
&lt;p&gt;firewall-cmd --reload&lt;/p&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;p&gt;firewall-cmd --zone=public --query-port=80/tcp&lt;/p&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;p&gt;firewall-cmd --zone=public --remove-port=80/tcp --permanent&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 06:18:00 +0000</pubDate>
<dc:creator>vinter_he</dc:creator>
<og:description>对最近mysql的常用运维命令进行整理 查看使用的哪个配置文件启动的mysql 账户的创建修改和设置权限 1.查看当前已有用户 2. create user创建用户和修改密码和删除 2.1 创建用户：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vinter/p/10522802.html</dc:identifier>
</item>
<item>
<title>Java 并发编程整体介绍 | 内含超多干货 - 余同学的开发之路</title>
<link>http://www.cnblogs.com/YJK923/p/10522705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/10522705.html</guid>
<description>&lt;p&gt;前段时间一直在学习多线程相关的知识，目前也算有了一个整体的认识，今天呢，主要从整体介绍一下，只谈造火箭，拧螺丝这种细节还需要自己深究。&lt;/p&gt;

&lt;p&gt;首先是操作系统级别对于多线程的支持，由 CPU 的多级缓存、缓存一致性、乱序执行优化等问题而设计出 Java 内存模型。关于这部分我前面已经总结过。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/YJK923/p/10302180.html&quot; target=&quot;_blank&quot;&gt;彻底搞懂 CPU 中的内存结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/YJK923/p/10478716.html&quot; target=&quot;_blank&quot;&gt;Java 内存模型 ，一篇就够了！&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说完了操作系统级别的多线程的后备知识以及 Java 内存模型的设计，接着说说 多线程的实现以及Java 中的多线程是怎么实现的，具体可以看这篇。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/YJK923/p/10506654.html&quot; target=&quot;_blank&quot;&gt;多线程实现原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面说的都是一些原理，深层次的东西，你若是不懂，也不影响你使用 Java 多线程来编码，无非就是继承 Thread 实现 Runnable 。但是呢，使用多线程，不可避免的就会出现线程安全问题。&lt;/p&gt;

&lt;p&gt;虽说我们也知道，不管三七二十一我使用 synchronized 关键字就好使，但是呢，想要知其所以然的同学还是需要好好学习一下上面说的那些原理的。而且，处理线程安全问题会涉及到性能问题，这就是高手之间的差别了。&lt;/p&gt;

&lt;p&gt;这么一说，我们的重点就放在如何保证线程安全的问题上了，首先，线程安全的特性有 3 个，原子性，可见性，有序性。我们主要看看 Java 中都是使用什么方式来保证这 3 个特性的。&lt;/p&gt;

&lt;p&gt;主要的体现在 atomic 包、CAS 思想、synchronized 锁、Lock 锁、volatile 关键字、还有一个非常重要的 JUC 包，别急，后面一个一个的说。&lt;/p&gt;

&lt;p&gt;哎，发现我已经说了 atomic 和 CAS 了，&lt;a href=&quot;https://www.cnblogs.com/YJK923/p/10510033.html&quot; target=&quot;_blank&quot;&gt;atomic包、synchronized | Java 中线程安全&lt;/a&gt; 关于 volatile 关键字，在 JVM 中的语义，即为防止指令重排并添加内存屏障，简单来说就是限制指令的执行顺序，并默认添加一些指令（内存屏障）以达到有序和可见性的目的。比方说在 volatile 变量读操作之前必须先完成写。&lt;/p&gt;

&lt;p&gt;简单提一下，使用 volatile 修饰的变量不一定是线程安全的，除非对变量的操作都是原子性的。&lt;/p&gt;

&lt;p&gt;在说 JUC 之前，先说一种比较讨巧的手段来处理多线程问题，我们知道多线程中存在问题主要就是在不同线程之间对共享变量进行操作，使得数据变脏。那我们在多线程中杜绝出现共享变量就行了呀，基于此，也就出现了 ThreadLocal 这个类。&lt;/p&gt;

&lt;p&gt;ThreadLocal 也被称为线程局部变量，实际上它是封装了一个当前线程为 K 的一个 Map，将需要用到的变量存进 Map，用的时候取出来，而这个 Map 又是线程私有的，其它线程无法访问，自然是线程安全的。&lt;/p&gt;

&lt;p&gt;使用 ThreadLocal 有个实际的例子，我们在过滤器中添加变量到 ThreadLocal 中，在拦截器中删除 ThreadLocal 中的值，这个变量可能是用户唯一性的标识或是其它，因为每一个请求都会触发一个线程执行，经过过滤器之后设置好变量，在方法中使用，而在拦截器中对请求处理之后即可对 ThreadLocal 中的数据进行清除，不然会发生内存泄漏。&lt;/p&gt;

&lt;p&gt;为什么 ThreadLocal 可以保证线程安全，因为它存放的变量都是线程私有的，还有一种我们经常定义的变量也是线程私有的，那就是我们定义的局部变量，方法内的变量。因为这些变量是存放在线程栈上面，这部分区域是线程私有的，也就是我们之前说的工作内存的概念，所以我们经常写局部变量，而从来没有考虑过线程安全问题，实际原因在这。&lt;/p&gt;

&lt;p&gt;线程私有可以保证线程安全，但是全局变量又是少不了一环，偶尔定义了那么一个，一不留神，在多线程环境中可能就会出错。最最常说的无非就是那几个集合类和 String 相关的类，当然还有其它的不安全的类，可能你已经使用了但还不知道。&lt;/p&gt;

&lt;p&gt;既然知道不安全了，那在多线程的环境中就避免使用它，而贴心的 JDK 也提供了一套与之对应的安全的类给我们使用，我们要做的就是知道哪些类是不安全的，对应的安全的类是什么以及如何保证的安全。&lt;/p&gt;

&lt;p&gt;先说 String、StringBuffer、StringBuilder 之间细微的差别，String 是不可变类，不可变类本身就是定义的时候就是线程安全的，关于不可变类这又是一块知识，暂时不说了。&lt;/p&gt;

&lt;p&gt;但是也正是因为 String 的不可变，所以每次对字符串的修改都会新创建一个字符串，而最终我们想要得到的可能就是最后的一个值，中间那些中间值太占空间。嗯，优化之后就有了后面两兄弟。&lt;/p&gt;

&lt;p&gt;简单说 StringBuffer 是线程安全的，而 StringBuilder 是不安全的，这两个较 String 都是可变对象。所以说，在单线程中使用 StringBuilder 代替 String ，多线程中使用 StringBuffer 代替 String 是个不错的选择。对了，StringBuffer 保证线程安全的手段也就是使用 synchronized 方法。&lt;/p&gt;

&lt;p&gt;还有就是关于集合类相关的线程安全操作，有一个 Collections 工具类，提供了一套 synchronizedXXX 方法，好吧，都写在脸上了，这样一来，List、Set、Map 都摇身一变安全了。&lt;/p&gt;

&lt;p&gt;还有一些古老的实现类，像什么 Vector，Hashtable，也是可以实现线程安全的，但是一来是基本不使用，二是有些情况下可能并不能保证线程安全，像 Vector 中的  add 和 remove 方法就是没有进行同步操作，在某些情况下就会出现不安全。&lt;/p&gt;

&lt;p&gt;不知道你们有没有发现，这些古老的实现类中实现安全的方式无非就是添加 synchronized 关键字。有没有高级一点的操作啊，肯定有，但是今天扯不动了，下次再说吧！&lt;/p&gt;

&lt;p&gt;简单总结一下，今天说了什么，回顾之前的文章并理顺了整体的思路，从底层原理到 JMM，从多线程的实现到如何保证线程安全，又举例说明了 JDK 中类的设计思路，后面的 JUC 设计的更秀。&lt;/p&gt;

&lt;p&gt;说的挺多，但是万变不离其宗，做好分类，学习记忆更便捷，Java 保证线程安全底层看 3 大特性，语言实现层面主要看锁，锁也就两大类 synchronized 和 Lock，只不过分支极多而已，还有一层是算法层面，像什么 CAS 。但是，回到 CPU 时代还他么都是 0、1 代码，所以，不要怂就是干！&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 06:04:00 +0000</pubDate>
<dc:creator>余同学的开发之路</dc:creator>
<og:description>前段时间一直在学习多线程相关的知识，目前也算有了一个整体的认识，今天呢，主要从整体介绍一下，只谈造火箭，拧螺丝这种细节还需要自己深究。 首先是操作系统级别对于多线程的支持，由 CPU 的多级缓存、缓存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/10522705.html</dc:identifier>
</item>
<item>
<title>WebView，我已经长大了，知道自己区分是否安全了！ - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/webview_safe_list.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/webview_safe_list.html</guid>
<description>&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;如果你在用 Android 原生系统（Google Play 服务），在使用 WebView 加载某些网页时，一定遇到过以下的安全警告红屏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcly1g0kvk33ouij30p018g76g.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是 WebView 的安全浏览保护策略，在 Android 8.0（API Level 26）开始的默认策略，被应用在所有 App 的 WebView 当中。&lt;/p&gt;
&lt;p&gt;Google 会自己维护一套“不安全”网站的列表，并通过 Google Play 服务，同步到所有的设备上。当你要访问某些被标记为“不安全”的网站时，它就会以此“红屏”警告用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意这是默认策略，虽然出发点是为了保护用户，但是有时候我们自己的 App 还是要有自主管控的权利。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那我们有办法在自己的 App 内，关闭此项保护吗？毕竟我的应用我做主，安不安全自己来管控。&lt;/p&gt;
&lt;p&gt;今天就来聊聊，如何在 Android 8.0（API Level 26）中，关闭此安全保护策略。&lt;/p&gt;
&lt;h2 id=&quot;二什么是webview的安全策略&quot;&gt;二、什么是WebView的安全策略&lt;/h2&gt;
&lt;p&gt;自 2018 年 4 月起，随着 WebView 66 发布，Google Play 保护机制，将在 WebView 中默认开始此安全浏览策略。&lt;/p&gt;
&lt;p&gt;而 Android 开发者在使用 WebView 时，无需再进行任何更改，即可享受此项保护服务。自 Android 8.0 开始，WebView 中即已经集成安全浏览功能，并且与 Android 版的 Chrome 采用相同的底层技术。&lt;/p&gt;
&lt;p&gt;一旦触发 WebView 的安全机制，就会出现类似下图这样的“红屏”警告。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcly1g0kvvanxvij306h0b43yi.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google 会自维护一套不良网站的列表，以确保用户可以在浏览之前，发出警告。&lt;/strong&gt;为了同步这部分列表，Google 花费了很大的努力，就是为了保护用户的安全。&lt;/p&gt;
&lt;h2 id=&quot;三如何控制安全策略&quot;&gt;三、如何控制安全策略&lt;/h2&gt;
&lt;p&gt;在 Android 8.0 及以上的设备中，WebView 的安全浏览策略，是默认生效的。&lt;/p&gt;
&lt;p&gt;也就是说，如果我们想要使用它，我们什么额外的工作都不需要做，但是我们如果不想采用它，就需要通过一个方法将其关闭。&lt;/p&gt;
&lt;h3 id=&quot;如何监控开启&quot;&gt;3.1 如何监控开启&lt;/h3&gt;
&lt;p&gt;WebView 的安全浏览，是依赖于 Google Play 和 Chrome 更新的，也就是说，虽然你的设备是 Android 8.0，但是此策略也是有可能没有生效的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么如何确定此功能是否生效呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WebView 提供了一个方法 &lt;code&gt;startSafeBrowsing()&lt;/code&gt; 方法，来主动开启安全浏览策略，在回调中，我们可以知道当前设备是否准备好了，符合开启安全浏览的条件。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;WebView.startSafeBrowsing(this, object : ValueCallback&amp;lt;Boolean&amp;gt; {
    override fun onReceiveValue(value: Boolean?) {
        val isOpen = value ?:false
        if (isOpen) {
            Log.i(&quot;cxmy_dev&quot;, &quot;Safe browsing. On&quot;)
        } else {
            Log.i(&quot;cxmy_dev&quot;, &quot;Safe browsing. Off&quot;)
        }
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意回调内的 value 可能为 null。&lt;/p&gt;
&lt;h3 id=&quot;如何关闭安全策略&quot;&gt;3.2 如何关闭安全策略&lt;/h3&gt;
&lt;p&gt;WebView 的安全策略是默认开始的，如果想要关闭它，需要通过 WebSettings 这个类，其中有 &lt;code&gt;setSafeBrowsingEnabled(boolean)&lt;/code&gt; 方法，可以用于设置是否开启安全模式。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;webSettings.safeBrowsingEnabled = false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此方法是一种全局的策略，也就是要么开启、要么关闭。&lt;/p&gt;
&lt;h3 id=&quot;配置白名单&quot;&gt;3.3 配置白名单&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;setSafeBrowsingEnable()&lt;/code&gt; 方法，只能做二态的设置，要么开启要么关闭。如果我们想设置，只允许某些 Host 不经过安全策略校验，如何设置呢？&lt;/p&gt;
&lt;p&gt;WebView 还提供了一个 &lt;code&gt;setSafeBrowsingWhiteList()&lt;/code&gt; 的方法，用于设置一个安全策略的白名单。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;var array = ArrayList&amp;lt;String&amp;gt;()
array.add(&quot;example.com&quot;)
WebView.setSafeBrowsingWhitelist(array, object : ValueCallback&amp;lt;Boolean&amp;gt; {
    override fun onReceiveValue(value: Boolean?) {
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;setSafeBrowsingWhiteList()&lt;/code&gt; 方法很灵活，可以通过配置指定域名及其子域名，或者仅此域名不包含其子域名。还可以直接配置 IP 地址，支持 IPV4 和 IPV6。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1g0kymr5dqqj30hp05ajrb.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四小结时刻&quot;&gt;四、小结时刻&lt;/h2&gt;
&lt;p&gt;今天我们聊到如何关闭 WebView 的安全浏览策略，本文涉及的 API，全部仅支持 API Level 27，使用的时候注意判断。&lt;/p&gt;
&lt;p&gt;当然，WebView 的安全浏览是有必要的，所以如果你的域名被 Google 误认为是危险链接，可以通过申述的方式解封，&lt;a href=&quot;https://support.google.com/chrome/answer/99020&quot;&gt;申述地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文对你有帮助吗？&lt;strong&gt;留言、点赞、转发&lt;/strong&gt;是最大的支持，谢谢！&lt;/p&gt;
&lt;blockquote readability=&quot;0.76388888888889&quot;&gt;
&lt;p&gt;references:&lt;br/&gt;&lt;a href=&quot;https://security.googleblog.com/2015/12/protecting-hundreds-of-millions-more.html&quot;&gt;protecting-hundreds-of-millions-mores&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/reference/android/webkit/WebView.html&quot;&gt;Webkit-WebView&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.google.com/chrome/privacy/whitepaper.html&quot;&gt;whitepaper&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我准备的学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步；你还能回复『&lt;strong&gt;提问&lt;/strong&gt;』，向我发起提问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485881&amp;amp;idx=1&amp;amp;sn=fcff7ac02622e7a1a7d8c93bab9b732b&amp;amp;chksm=97851098a0f2998eb1089261c16ef334d00ff69fc1591015b560b2a90c6c6ca862ed12a72ec7#rd&quot;&gt;关于字符编码，你需要知道的都在这里&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485579&amp;amp;idx=1&amp;amp;sn=d939e6b1dabe7495b5ca5f0a0c988c8e&amp;amp;chksm=978511aaa0f298bc75e0d0c507a19e28d5d4fac3b30502565688617b1ae9fcf899a9836b2d65#rd&quot;&gt;图解：HTTP 范围请求&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485952&amp;amp;idx=1&amp;amp;sn=26ba1c2c8342062d82f3b5487839753d&amp;amp;chksm=97851321a0f29a37fe2e2f72bb3448cb7b141ac30b7b715ec126583e8c6fa2c5da76ec83c6b6&amp;amp;token=584023549&amp;amp;lang=zh_CN#rd&quot;&gt;Java 异常处理&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485939&amp;amp;idx=1&amp;amp;sn=a5a3535b80c16c47775cf845d353e4bb&amp;amp;chksm=978510d2a0f299c4f57963510a2633773926bf41007760e44a8a33f33cbf831d8877f2f60e84#rd&quot;&gt;安卓防止用户关闭动画导致动画失效&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485931&amp;amp;idx=1&amp;amp;sn=05b153e1d7b83b90032d5365eba9ef1a&amp;amp;chksm=978510caa0f299dc8031a7cd1a11b25215940e4b4ae51f065fb5bea5ad95dfb3470c0212f62a&amp;amp;token=584023549&amp;amp;lang=zh_CN#rd&quot;&gt;Git 找回遗失的代码&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485918&amp;amp;idx=1&amp;amp;sn=04b79bcd89425b4514f0b8eb0ded0c22&amp;amp;chksm=978510ffa0f299e99f353abafe73e05974e0a72f797ce4155abf3e04c2c769277e05953f2295#rd&quot;&gt;阿里的 Alpha 助力 App 启动速度优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcly1fpzmg0hppuj30rs0b474v.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 06:02:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<og:description>一、前言 如果你在用 Android 原生系统（Google Play 服务），在使用 WebView 加载某些网页时，一定遇到过以下的安全警告红屏。 这是 WebView 的安全浏览保护策略，在 A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/webview_safe_list.html</dc:identifier>
</item>
</channel>
</rss>