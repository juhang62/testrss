<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于数据库字段的一点思考 - 我爱1和0</title>
<link>http://www.cnblogs.com/woaitech/p/13580741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woaitech/p/13580741.html</guid>
<description>&lt;p&gt;设计了很多数据库，很多表，前几天想了下字段的设计，&lt;/p&gt;
&lt;p&gt;比如我们要设计一个商品表，商品的业务属性有名称，品牌，价格，生产商等，&lt;/p&gt;
&lt;p&gt;那这个表的设计很简单&lt;/p&gt;
&lt;p&gt;表名：Product&lt;/p&gt;
&lt;p&gt;字段： id 唯一主键&lt;/p&gt;
&lt;p&gt;            name 名称&lt;/p&gt;
&lt;p&gt;            brand 品牌&lt;/p&gt;
&lt;p&gt;            price 价格&lt;/p&gt;
&lt;p&gt;            manufacturer 生产商&lt;/p&gt;
&lt;p&gt;这个表可以说就完成了，下面列出一些表的相关需求&lt;/p&gt;
&lt;p&gt;1.系统中需要单独记录生厂商，即有一个生产商的表，那么商品的生产商&lt;/p&gt;
&lt;p&gt;就变成了一个外键manufacturerId，关联生产商表&lt;/p&gt;

&lt;p&gt;2.需要知道所有商品什么时候创建的，最后一个是什么时候修改&lt;/p&gt;
&lt;p&gt;增加字段createTime 创建时间, updateTime 更新时间，&lt;/p&gt;

&lt;p&gt;3.商品的数量很多，生产商也很多，并且需要经常根据生产商的名字做模糊查询，为了提高查询效率&lt;/p&gt;
&lt;p&gt;直接在商品表增加生产商名字字段，manufacturerName 生产商名字&lt;/p&gt;

&lt;p&gt;4.商品的修改需要审核才能生效，审核中的商品不能修改&lt;/p&gt;
&lt;p&gt;增加字段status 状态，提交审核后商品的状态变为审核中，根据商品状态限制操作&lt;/p&gt;

&lt;p&gt;现在商品表变成下面的样子&lt;/p&gt;
&lt;p&gt;　　id 唯一主键&lt;/p&gt;
&lt;p&gt;　　name 名称&lt;/p&gt;
&lt;p&gt;　　brand 品牌&lt;/p&gt;
&lt;p&gt;　　price 价格&lt;/p&gt;
&lt;p&gt;　　manufacturerId 生产商&lt;/p&gt;
&lt;p&gt;　　manufacturerName 生产商名字&lt;/p&gt;
&lt;p&gt;　　createTime 创建时间&lt;/p&gt;
&lt;p&gt;　　updateTime 更新时间&lt;/p&gt;
&lt;p&gt;　　status 状态&lt;/p&gt;
&lt;p&gt;可以给这些字段分下类，&lt;/p&gt;
&lt;p&gt;name,brand,price,manufacturerId是业务的必须字段，即业务字段，&lt;/p&gt;
&lt;p&gt;manufacturerName是为了方便提高效率加的，即冗余字段&lt;/p&gt;
&lt;p&gt;createTime，updateTime 是为了记录用户的操作，即记录字段&lt;/p&gt;
&lt;p&gt;status 决定了对数据可以做操作，即逻辑字段&lt;/p&gt;
&lt;p&gt;总结下，数据库表的字段可以分为四类，业务字段，冗余字段，记录字段，逻辑字段&lt;/p&gt;

</description>
<pubDate>Sat, 29 Aug 2020 00:06:00 +0000</pubDate>
<dc:creator>我爱1和0</dc:creator>
<og:description>设计了很多数据库，很多表，前几天想了下字段的设计， 比如我们要设计一个商品表，商品的业务属性有名称，品牌，价格，生产商等， 那这个表的设计很简单 表名：Product 字段： id 唯一主键 name</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/woaitech/p/13580741.html</dc:identifier>
</item>
<item>
<title>Alink漫谈(二十) ：卡方检验源码解析 - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13580716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13580716.html</guid>
<description>&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将带领大家来分析 Alink 中 卡方检验 的实现。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;419.00958188153&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将带领大家来分析 Alink 中 卡方检验 的实现。&lt;/p&gt;
&lt;p&gt;因为Alink的公开资料太少，所以以下均为自行揣测，肯定会有疏漏错误，希望大家指出，我会随时更新。&lt;/p&gt;
&lt;h2 id=&quot;0x01-背景概念&quot;&gt;0x01 背景概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：在南方的小明要去北京读书，小明的父母都担心起来，北方的生活能习惯吗？是不是只能吃面？他们的脑子里面提出了很多很多的假设，是不是都要验证一下呢。&lt;/p&gt;
&lt;h3 id=&quot;11-假设检验&quot;&gt;1.1 假设检验&lt;/h3&gt;
&lt;p&gt;统计假设是指我们对总体的猜测或判断，比如中国广为流行的地域划分，北方人是不是都吃面食？江浙是不是都喜欢吃甜食？江南的妹子是不是脾气都很好？北方的男生是不是都大条？&lt;/p&gt;
&lt;p&gt;为了证明，或者说绝对确定某个假设是正确或错误的，&lt;u&gt;我们需要绝对知识，也就是说我们需要检查所有的样本&lt;/u&gt;，比如问问所有的北方人是不是都吃面食，或者说问问江浙一带的女生是不是都不吵架？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是我们无法把所有样本都统计一遍&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;假设检验就是为了解决这个问题而诞生的，它使用随机的样本来判断假设是否有理&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;这来源于一个最基本的思路，那就是统计是从有限样本推断总体。既然我们不可能知道所有样本，换句话说我们不可能知道总体到底是什么统计性质，那么我们只能拿有限的样本做文章。&lt;/p&gt;
&lt;p&gt;假设检验依据的原理是小概率事件原理。小概率事件是一个事件的发生概率，由于概率小，它在一次试验中是几乎不可能发生的。例如，拿我们生活的经验来说，只买一次彩票就中大奖的几率是很小的，所以还没看到过偶尔买彩票就中大奖的报道。&lt;/p&gt;
&lt;h3 id=&quot;12-h0和h1是什么？&quot;&gt;1.2 H0和H1是什么？&lt;/h3&gt;
&lt;p&gt;小明父母的种种假设到底对不对呢？对是一种结果，不对是另一种结果。在假设检验中，我们也有两部分，一部分叫做H0，一部分是H1。&lt;/p&gt;
&lt;p&gt;H是英文单词hypothesis的第一个字母，H0代表了原假设（null hypothesis），H1是备择假设（alternative hypothesis）。换句话说，我们想在两个假设中选一个，尽管这个“选”不是通常意义下的“二选一”。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;H0 原假设又叫零假设，一般来说，我们&lt;u&gt;把认为想收集证据反对的假设称为0假设&lt;/u&gt;，比如太阳绕着地球转，鸟是不会飞的。小明这里的 H0 就是 “北方不吃米饭”，是小明父母不希望，想拒绝的。&lt;/li&gt;
&lt;li&gt;H1又叫备选假设，一般来说，我们都希望备选假设，也就是H1为真，比如小明的父母希望北方也是吃饭的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;H0和H1并不是不能互换，但是选取的H0原则是&lt;strong&gt;H0必须是一个可以被拒绝的假设&lt;/strong&gt;。对于一个假设检验问题，如果&lt;strong&gt;H1是一个不能被拒绝的假设&lt;/strong&gt;，那么H0和H1不能互换。&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;什么样的H1是不能被拒绝的假设？比如下面这个问题：总体是一个班级的所有同学一次的考试成绩，原假设H0是全班同学的平均成绩为80分，H1是全班同学的平均成绩不是80分。在这个框架中，H0是一个可以被拒绝的假设，H1是一个不能被拒绝的假设。&lt;/p&gt;
&lt;p&gt;为什么这么说？如果H0选做全班同学的平均成绩不是80分，那么哪怕你知道全班几乎所有人的成绩，不妨认为平均是80分，只要有一个人的成绩你不知道，那么知道其他人的成绩对于你拒绝H0没有任何帮助。只有在这个人恰好80分的情况下，原假设是不成立的，这个人是81或者79,原假设都成立。从另一个角度，也可以认为当H0是一个不能被拒绝的假设的时候，H0太过宽泛，和H1区分不了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说，假设检验的结果有下面两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;H0错，H1对（用专业的话来说，就是接受H1，拒绝H0，因为有足够多的样本支持H1，比如说小明爸妈问了5，6个到北方读书的人，都说食堂面和饭都有。他们大可以说，北方也是吃饭的）。&lt;/li&gt;
&lt;li&gt;H1错（用专业的话说，不拒绝H0，因为证据不够。小明爸妈问了5个到北方读书的人，1个说食堂面和饭都有，那食堂到底有没有呢？心里可是直打鼓了。）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有一点要注意，无法拒绝H0并不是说H0为真，而是说我们的证据不足，无法证明H1。我们经常在法庭上听到，证据不足，无罪释放，但是，这个人到底有没有罪，还是要打个问号的。&lt;/p&gt;
&lt;h3 id=&quot;13-p值-p-value&quot;&gt;1.3 P值 (P-value)&lt;/h3&gt;
&lt;p&gt;P值，也就是常见到的 P-value。P 值是一种概率，指的是&lt;strong&gt;在 H0 假设为真的前提下，样本结果出现的概率&lt;/strong&gt;。即 &lt;strong&gt;p值是在原假设成立的基础上计算的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;如果 P-value 很小，则说明在原假设为真的前提下，样本结果出现的概率很小，甚至很极端，这就反过来说明了原假设很大概率是错误的&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;另外一个角度想，p值也是弃真错误的概率。&lt;strong&gt;也就是这个假设成立的情况下&lt;/strong&gt;，出现这个糟糕结果的概率，也当然就是如果此时把h0拒绝，出现错误的概率。只要p值足够小，我们就认为此时拒绝h0，出错的概率很小，那就干脆把h0拒绝好了。&lt;/p&gt;
&lt;p&gt;通常，会设置一个显著性水平（significance level） alpha 与 P-value 进行比较，如果 P-value &amp;lt; alpha ，则说明在显著性水平 alpha 下拒绝原假设，alpha 通常情况下设置为0.05。&lt;/p&gt;
&lt;p&gt;假如我们比较某地区男、女性的饮食口味是否存在差异，则 H0 是 &quot;男女的饮食口味相同，不存在差异&quot;。&lt;/p&gt;
&lt;p&gt;最后得出 &lt;strong&gt;P=0.283&lt;/strong&gt; &amp;gt; 0.05，在α=0.05水平上不拒绝零假设，即不能认为该地区男女的饮食口味不同。&lt;/p&gt;
&lt;h3 id=&quot;14-交叉表&quot;&gt;1.4 交叉表&lt;/h3&gt;
&lt;p&gt;在统计学中，交叉表是矩阵格式的一种表格，显示变量的（多变量）频率分布。&lt;/p&gt;
&lt;p&gt;“交叉表”对象是一个网格，用来根据指定的条件返回值。数据显示在压缩行和列中。这种格式易于比较数据并辨别其趋势。它由三个元素组成：行 / 列 / 摘要字段。&lt;/p&gt;
&lt;p&gt;让我们举例说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;马军头领&lt;/th&gt;
&lt;th&gt;步兵头领&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;二龙山&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;少华山&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;“交叉表”中的行沿水平方向延伸（从一侧到另一侧）。在上面的示例中，”二龙山” 是一行。&lt;/li&gt;
&lt;li&gt;“交叉表”中的列沿垂直方向延伸（上下）。在上面的示例中，“马军头领” 是一列。&lt;/li&gt;
&lt;li&gt;汇总字段位于行和列的交叉处。每个交叉处的值代表对既满足行条件又满足列条件的记录的汇总（求和、计数等）。在上面的示例中，“二龙山”和“马军头领”交叉处的值是1，这是在二龙山上马军头领的数目。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上文中交叉表是按两个变量交叉分类的，该列联表称为两维列联表，若按3个变量交叉分类，所得的列联表称为3维列联表，依次类推。3维及以上的列联表通常称为“多维列联表”或“高维列联表”，而一维列联表就是频数分布表。&lt;/p&gt;
&lt;h3 id=&quot;15-卡方&quot;&gt;1.5 卡方&lt;/h3&gt;
&lt;p&gt;交叉分类所得的表格称为“列联表”，统计推断（检验）则要使用列联表分析的方法------卡方检验。&lt;/p&gt;
&lt;p&gt;卡方检验，主要用于检验统计样本的实际观测值与理论推断值之间的偏离程度，或者是&lt;strong&gt;检验一批数据是否与某种理论分布相符合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Alink 文档中给出的是：&lt;u&gt;卡方独立性检验是检验两个因素（各有两项或以上的分类）之间是否相互影响的问题，其零假设是两因素之间相互独立&lt;/u&gt;。&lt;/p&gt;
&lt;h4 id=&quot;151-公式&quot;&gt;1.5.1 公式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;卡方值&lt;/strong&gt;是卡方检验时用到的&lt;strong&gt;检验统计量&lt;/strong&gt;，卡方值越大，说明观测值与理论值之间的偏离就越大；反之，二者偏差越小。实际应用时，可以根据卡方值计算 P-value，从而选择拒绝或者接受原假设。&lt;/p&gt;
&lt;p&gt;公式如下：&lt;/p&gt;
&lt;p&gt;\[X^2 = \sum\frac{(observed - expected)^2}{expected} \]&lt;/p&gt;
&lt;h4 id=&quot;152-基本思想&quot;&gt;1.5.2 基本思想&lt;/h4&gt;
&lt;p&gt;卡方检验最基本的思想就是通过观察实际值与理论值的偏差来确定理论的正确与否。&lt;/p&gt;
&lt;p&gt;具体做的时候常常先假设两个变量确实是独立的（行话就叫做“原假设”），然后观察实际值（也可以叫做观察值）与理论值（这个理论值是指“如果两者确实独立”的情况下应该有的值）的偏差程度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果偏差足够小，我们就认为误差是很自然的样本误差，是测量手段不够精确导致或者偶然发生的，两者确确实实是独立的，此时就接受原假设。&lt;/li&gt;
&lt;li&gt;如果偏差大到一定程度，使得这样的误差不太可能是偶然产生或者测量不精确所致，我们就认为两者实际上是相关的，即否定原假设，而接受备择假设。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;153-实现过程&quot;&gt;1.5.3 实现过程&lt;/h4&gt;
&lt;p&gt;卡方分析的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假设两个变量是相互独立，互不关联的。这在统计上称为原假设；&lt;/li&gt;
&lt;li&gt;对于调查中得到的两个变量的数据，用一个表格的形式来表示它们的分布（频数和百分数），这里的频数叫观测频数，这种表格叫列联表；&lt;/li&gt;
&lt;li&gt;如果原假设成立，在这个前提下，可以计算出上面列联表中每个格子里的频数应该是多少，这叫期望频数；&lt;/li&gt;
&lt;li&gt;比较观测频数与期望频数的差，如果两者的差越大，表明实际情况与原假设相去甚远；差越小，表明实际情况与原假设越相近。这种差值用一个卡方统计量来表示；&lt;/li&gt;
&lt;li&gt;对卡方值进行检验，如果卡方检验的结果不显著，则不能拒绝原假设，即两变量是相互独立、互不关联的，如果卡方检验的结果显著，则拒绝原假设，即两变量间存在某种关联，至于是如何关联的，这要看列联表中数据的分布形态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体实现过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按照假设检验的步骤，首先我们需要确定原假设 H0(null hypothesis)：原假设是变量独立的，实际观测频率和理论频率一致。&lt;/li&gt;
&lt;li&gt;其次我们根据实际观测的联连表，去求理论的联连表；卡方统计值：X2，记为Statistic；&lt;/li&gt;
&lt;li&gt;然后选取适合的置信度(一般为95%)同自由度一起确定临界值Critical Value，比较卡方统计值和临界值大小：
&lt;ol&gt;&lt;li&gt;If Statistic &amp;gt;= Critical Value: 认为变量对结果有影响，则拒绝原假设，变量不独立&lt;/li&gt;
&lt;li&gt;If Statistic &amp;lt; Critical Value: 认为变量对结果没有影响，接受原假设，变量独立&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;16-自由度&quot;&gt;1.6 自由度&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;自由度：&lt;/strong&gt;取值不受限制的变量的个数。&lt;/p&gt;
&lt;p&gt;如何理解这句简单的话呢？给定一组数据，我们来计算不同的统计量，看看自由度的变化。这些数据分别为 1 2 4 6 8. 5个数。&lt;/p&gt;
&lt;p&gt;先来求平均值，这几个数据都可以任意变化成其它数据，而我们仍然可以对它们求平均值，它们的平均值也跟着变化。这时自由度为5，也就是说有几个数据自由度就是几。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卡方检验的自由度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）如果是独立性检验，那么自由度就等于（a-1）*（b-1），a b表示这两个检验条件的对应的分类数。&lt;/p&gt;
&lt;p&gt;2）适合性检验，类别数减去1。此处相当于约束条件只有一个。&lt;/p&gt;
&lt;p&gt;卡方检验只有在用笔算查表时使用自由度，软件计算不用担心这个问题，但是最好明白自由度代表着总的变量数目减去约束条件的数目。&lt;/p&gt;
&lt;h2 id=&quot;0x02-示例代码&quot;&gt;0x02 示例代码&lt;/h2&gt;
&lt;p&gt;本文示例代码如下，这里需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&quot;col1&quot;,&quot;col2&quot;是所选择的列；&lt;/li&gt;
&lt;li&gt;&quot;col4&quot;是Label；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ChiSquareTestBatchOpExample {
    public static void main(String[] args) throws Exception {
        Row[] testArray =
                new Row[]{
                        Row.of(&quot;a&quot;, 1.1, 1.2, 1),
                        Row.of(&quot;b&quot;, 0.9, 1.0, -2),
                        Row.of(&quot;c&quot;, -0.01, 1.0, 100),
                        Row.of(&quot;d&quot;, 100.9, 0.1, -99),
                        Row.of(&quot;a&quot;, 1.1, 1.2, 1),
                        Row.of(&quot;b&quot;, 0.9, 1.0, -2),
                        Row.of(&quot;c&quot;, -0.01, 0.2, 100),
                        Row.of(&quot;d&quot;, 100.9, 0.3, -99)
                };

        String[] colNames = new String[]{&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;};

        MemSourceBatchOp source = new MemSourceBatchOp(Arrays.asList(testArray), colNames);

        ChiSquareTestBatchOp test = new ChiSquareTestBatchOp()
                .setSelectedCols(&quot;col1&quot;,&quot;col2&quot;)
                .setLabelCol(&quot;col4&quot;);

        test.linkFrom(source).print();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;col|chisquare_test
---|--------------
col1|{&quot;comment&quot;:&quot;chi-square test&quot;,&quot;df&quot;:9.0,&quot;p&quot;:0.004301310843500827,&quot;value&quot;:24.0}
col2|{&quot;comment&quot;:&quot;chi-square test&quot;,&quot;df&quot;:9.0,&quot;p&quot;:0.004301310843500827,&quot;value&quot;:24.0}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换为图表更好理解：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;col&lt;/th&gt;
&lt;th&gt;chisquare_test&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;col1&lt;/td&gt;
&lt;td&gt;{&quot;comment&quot;:&quot;chi-square test&quot;,&quot;df&quot;:9.0,&quot;p&quot;:0.004301310843500827,&quot;value&quot;:24.0}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;col2&lt;/td&gt;
&lt;td&gt;{&quot;comment&quot;:&quot;chi-square test&quot;,&quot;df&quot;:9.0,&quot;p&quot;:0.004301310843500827,&quot;value&quot;:24.0}&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;u&gt;df是自由度，p就是p-value， value就是我们前面说的卡方值&lt;/u&gt;，即&lt;/p&gt;
&lt;p&gt;\[卡方值 = \sum\frac{(observed - expected)^2}{expected} \]&lt;/p&gt;
&lt;h2 id=&quot;0x03-总体逻辑&quot;&gt;0x03 总体逻辑&lt;/h2&gt;
&lt;p&gt;训练总体逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 flatMap 做 flatting data to triple。遍历输入Row，然后把Row给flat了，得到三元组&amp;lt;idx in row, value in row, y-label&amp;gt;。比如 对应输入 Row.of(&quot;b&quot;, 0.9, 1.0, -2)，则row = {Row@9419} &quot;b,0,9,-2&quot;，因为col1, col2是特征，col4是 label，则发送两个三元组是 &amp;lt;0, b, -2&amp;gt;, &amp;lt;1, 0.9, -2&amp;gt;；&lt;/li&gt;
&lt;li&gt;使用 toTable 把前面处理的dataSet再进行转换，生成一张表 data。{&quot;col&quot;, &quot;feature&quot;, &quot;label&quot;} 就对应着我们之前的三元组；&lt;/li&gt;
&lt;li&gt;对 data 进行 计算交叉表 和 卡方校验；
&lt;ul&gt;&lt;li&gt;groupBy(&quot;col,feature,label&quot;) 进行分类排序；&lt;/li&gt;
&lt;li&gt;select(&quot;col,feature,label,count(1) as count2&quot;)) 得出 feature 的个数作为count2；&lt;/li&gt;
&lt;li&gt;groupBy(&quot;col&quot;).reduceGroup 再根据col排序，归并；
&lt;ul&gt;&lt;li&gt;得到 &amp;lt;feature, y-label&amp;gt; : &quot;count of feature&quot; 这个map；&lt;/li&gt;
&lt;li&gt;Crosstab.convert(map) 利用map来做交叉表；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;map(new ChiSquareTestFromCrossTable()) 利用交叉表来构建卡方检验；
&lt;ul&gt;&lt;li&gt;test(crossTabWithId) 这里进行计算，其中会调用 org.apache.commons.math3.distribution.GammaDistribution.cumulativeProbability 进行Gamma计算；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x04-训练&quot;&gt;0x04 训练&lt;/h2&gt;
&lt;p&gt;还是老套路，直奔ChiSquareTestBatchOp的linkFrom函数。&lt;/p&gt;
&lt;p&gt;代码是缩减版，但原本就非常简单，获取“选择的列”和“Y列”，然后用输入数据进行训练检验。&lt;/p&gt;
&lt;p&gt;深入看下去却很有难度。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ChiSquareTestBatchOp linkFrom(BatchOperator&amp;lt;?&amp;gt;... inputs) {
    BatchOperator&amp;lt;?&amp;gt; in = checkAndGetFirst(inputs);
    String[] selectedColNames = getSelectedCols();
    String labelColName = getLabelCol();

    this.setOutputTable(ChiSquareTestUtil.buildResult(
        ChiSquareTestUtil.test(in, selectedColNames, labelColName),
        selectedColNames,
        getMLEnvironmentId()));

    return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后会辗转进入到 ChiSquareTest.test，这里才是真章。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static DataSet&amp;lt;Row&amp;gt; test(BatchOperator in,
                                String[] selectedColNames,
                                String labelColName) {
    in = in.select(ArrayUtils.add(selectedColNames, labelColName));
    return ChiSquareTest.test(in.getDataSet(), in.getMLEnvironmentId());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;41-chisquaretest&quot;&gt;4.1 ChiSquareTest&lt;/h3&gt;
&lt;p&gt;其test函数的输入输出是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入：in 的最后一列是label，其余列是所选择的特征列；&lt;/li&gt;
&lt;li&gt;输出：有三列，分别是 1th is colId, 2th is pValue, 3th is chi-square value；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的总体逻辑是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 flatMap 做 flatting data to triple。遍历输入Row，然后把Row给flat了，得到三元组&amp;lt;idx in row, value in row, y-label&amp;gt;；&lt;/li&gt;
&lt;li&gt;使用 toTable 把前面处理的dataSet再进行转换，生成一张表 data。{&quot;col&quot;, &quot;feature&quot;, &quot;label&quot;} 就对应着我们之前的三元组；&lt;/li&gt;
&lt;li&gt;对 data 进行 计算交叉表 和 卡方校验；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected static DataSet&amp;lt;Row&amp;gt; test(DataSet&amp;lt;Row&amp;gt; in, Long sessionId) {
    //flatting data to triple.
    //这里就是遍历输入Row，然后把Row给flat了，得到三元组&amp;lt;idx in row, value in row, y-label&amp;gt;
    //比如 对应输入 Row.of(&quot;b&quot;, 0.9, 1.0, -2)，则row = {Row@9419} &quot;b,0,9,-2&quot;，因为col1, col2是特征，col4是 label，则发送两个三元组是  &amp;lt;0, b, -2&amp;gt;, &amp;lt;1, 0.9, -2&amp;gt;
    DataSet&amp;lt;Row&amp;gt; dataSet = in
        .flatMap(new FlatMapFunction&amp;lt;Row, Row&amp;gt;() {
            @Override
            public void flatMap(Row row, Collector&amp;lt;Row&amp;gt; result) {
                int n = row.getArity() - 1;
                String nStr = String.valueOf(row.getField(n));
                for (int i = 0; i &amp;lt; n; i++) {
                    Row out = new Row(3);
                    out.setField(0, i);
                    out.setField(1, String.valueOf(row.getField(i)));
                    out.setField(2, nStr);
                    result.collect(out);
                }
            }
        });

        // 把前面处理的dataSet再进行转换，生成一张表。{&quot;col&quot;, &quot;feature&quot;, &quot;label&quot;} 就对应着我们之前的三元组
    Table data = DataSetConversionUtil.toTable(
        sessionId,
        dataSet,
        new String[]{&quot;col&quot;, &quot;feature&quot;, &quot;label&quot;},
        new TypeInformation[]{Types.INT, Types.STRING, Types.STRING});


    // 对 data 进行 计算交叉表 和 卡方校验
    //calculate cross table  and chiSquare test.
    return DataSetConversionUtil.fromTable(sessionId, data
        .groupBy(&quot;col,feature,label&quot;) //分类排序
        .select(&quot;col,feature,label,count(1) as count2&quot;)) // 为了得出 feature 的个数作为count2
        .groupBy(&quot;col&quot;).reduceGroup( // 再根据col排序
            new GroupReduceFunction&amp;lt;Row, Tuple2&amp;lt;Integer, Crosstab&amp;gt;&amp;gt;() {
                @Override
                public void reduce(Iterable&amp;lt;Row&amp;gt; iterable, Collector&amp;lt;Tuple2&amp;lt;Integer, Crosstab&amp;gt;&amp;gt; collector) {
                    Map&amp;lt;Tuple2&amp;lt;String, String&amp;gt;, Long&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
                    int colIdx = -1;
                    for (Row row : iterable) {
            
// 假如有如下，row = {Row@9684} &quot;0,a,1,2&quot;，他对应了两个 Row.of(&quot;a&quot;, 1.1, 1.2, 1), 就是 &amp;lt;col,feature,label,count(1)&amp;gt;, 就是 &amp;lt;'a'是第0列，'a'，对应 y-label是 1， 'a' 有两个&amp;gt;
                      
                        map.put(Tuple2.of(row.getField(1).toString(),
                                row.getField(2).toString()),
                            (long) row.getField(3));
                        colIdx = (Integer) row.getField(0);
                    }
                  
// 得到 &amp;lt;feature, y-label&amp;gt; : &quot;count of feature&quot; 这个map
map = {HashMap@9676}  size = 4
 {Tuple2@9688} &quot;(a,1)&quot; -&amp;gt; {Long@9689} 2
 {Tuple2@9690} &quot;(b,-2)&quot; -&amp;gt; {Long@9689} 2
 {Tuple2@9691} &quot;(d,-99)&quot; -&amp;gt; {Long@9689} 2
 {Tuple2@9692} &quot;(c,100)&quot; -&amp;gt; {Long@9689} 2                   
                  
                    // 利用map来做交叉表
                    collector.collect(new Tuple2&amp;lt;&amp;gt;(colIdx, Crosstab.convert(map)));
                }
            })
        .map(new ChiSquareTestFromCrossTable()); // 构建卡方检验
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-crosstab&quot;&gt;4.2 Crosstab&lt;/h3&gt;
&lt;p&gt;上面代码中，使用 &lt;code&gt;collector.collect(new Tuple2&amp;lt;&amp;gt;(colIdx, Crosstab.convert(map)));&lt;/code&gt; 来构建交叉表。&lt;/p&gt;
&lt;p&gt;Crosstab 就是 Cross Tabulations reflects the relationship between two variables。即以map key为横轴，纵轴，value作为数值，就是feature和label之间的交叉。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static Crosstab convert(Map&amp;lt;Tuple2&amp;lt;String, String&amp;gt;, Long&amp;gt; maps) {
 
    Crosstab crosstab = new Crosstab();

    //get row tags and col tags
    Set&amp;lt;Tuple2&amp;lt;String, String&amp;gt;&amp;gt; sets = maps.keySet();

    Set&amp;lt;String&amp;gt; rowTags = new HashSet&amp;lt;&amp;gt;(); // 拿到行，列
    Set&amp;lt;String&amp;gt; colTags = new HashSet&amp;lt;&amp;gt;();
    for (Tuple2&amp;lt;String, String&amp;gt; tuple2 : sets) {
        rowTags.add(tuple2.f0);
        colTags.add(tuple2.f1);
    }

    crosstab.rowTags = new ArrayList&amp;lt;&amp;gt;(rowTags);
    crosstab.colTags = new ArrayList&amp;lt;&amp;gt;(colTags);

    int rowLen = crosstab.rowTags.size();
    int colLen = crosstab.colTags.size();

    //compute value
    crosstab.data = new long[rowLen][colLen];
    for (Map.Entry&amp;lt;Tuple2&amp;lt;String, String&amp;gt;, Long&amp;gt; entry : maps.entrySet()) {
        int rowIdx = crosstab.rowTags.indexOf(entry.getKey().f0);
        int colIdx = crosstab.colTags.indexOf(entry.getKey().f1);
        crosstab.data[rowIdx][colIdx] = entry.getValue();
    }
    return crosstab;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里输入输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 输入如下
maps = {HashMap@9676}  size = 4
 {Tuple2@9688} &quot;(a,1)&quot; -&amp;gt; {Long@9689} 2
 {Tuple2@9690} &quot;(b,-2)&quot; -&amp;gt; {Long@9689} 2
 {Tuple2@9691} &quot;(d,-99)&quot; -&amp;gt; {Long@9689} 2
 {Tuple2@9692} &quot;(c,100)&quot; -&amp;gt; {Long@9689} 2  

// 交叉表如下
crosstab = {Crosstab@9703} 
 colTags = {ArrayList@9720}  size = 4
  0 = &quot;1&quot;  1 = &quot;100&quot;  2 = &quot;-2&quot;  3 = &quot;-99&quot;
 rowTags = {ArrayList@9721}  size = 4
  0 = &quot;a&quot;  1 = &quot;b&quot;  2 = &quot;c&quot;  3 = &quot;d&quot;
data = {long[4][]@9713} 
 0 = {long[4]@9722}   0 = 2  1 = 0  2 = 0  3 = 0
 1 = {long[4]@9723}   0 = 0  1 = 0  2 = 2  3 = 0
 2 = {long[4]@9724}   0 = 0  1 = 2  2 = 0  3 = 0
 3 = {long[4]@9725}   0 = 0  1 = 0  2 = 0  3 = 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造出来交叉表如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;100&lt;/th&gt;
&lt;th&gt;-2&lt;/th&gt;
&lt;th&gt;-99&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;c&lt;/strong&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;d&lt;/strong&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;43-构建卡方检验&quot;&gt;4.3 构建卡方检验&lt;/h3&gt;
&lt;p&gt;4.1中，有 &lt;code&gt;.map(new ChiSquareTestFromCrossTable());&lt;/code&gt; ，这里就是根据&lt;code&gt;collector.collect(new Tuple2&amp;lt;&amp;gt;(colIdx, Crosstab.convert(map)));&lt;/code&gt;交叉表构建卡方检验。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * calculate chi-square test value from cross table.
 */
public static class ChiSquareTestFromCrossTable implements MapFunction&amp;lt;Tuple2&amp;lt;Integer, Crosstab&amp;gt;, Row&amp;gt; {

    @Override
    public Row map(Tuple2&amp;lt;Integer, Crosstab&amp;gt; crossTabWithId) throws Exception {
        Tuple4 tuple4 = test(crossTabWithId);

        // f0 is id of cross table, f1 is pValue, f2 is chi-square Value, f3 is df
        Row row = new Row(4);
        row.setField(0, tuple4.f0);
        row.setField(1, tuple4.f1);
        row.setField(2, tuple4.f2);
        row.setField(3, tuple4.f3);

        return row;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;test(crossTabWithId)是关键点，其中 distribution.cumulativeProbability 最后调用到 org.apache.commons.math3.distribution.GammaDistribution.cumulativeProbability。&lt;/p&gt;
&lt;p&gt;这里能够看到&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;u&gt;df 的定义就是 (double)(rowLen - 1) * (colLen - 1)，即（行 - 1）*（列 - 1）&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;卡方值就是严格按照定义来构建的。&lt;/li&gt;
&lt;li&gt;p-value是 调用到 org.apache.commons.math3.distribution.GammaDistribution.cumulativeProbability。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @param crossTabWithId: f0 is id, f1 is cross table
 * @return tuple4: f0 is id which is id of cross table, f1 is pValue, f2 is chi-square Value, f3 is df
 */
protected static Tuple4&amp;lt;Integer, Double, Double, Double&amp;gt; test(Tuple2&amp;lt;Integer, Crosstab&amp;gt; crossTabWithId) {
    int colIdx = crossTabWithId.f0;
    Crosstab crosstab = crossTabWithId.f1;

    int rowLen = crosstab.rowTags.size();
    int colLen = crosstab.colTags.size();

    //compute row sum and col sum 计算出列的数值和，行的数值和
    double[] rowSum = crosstab.rowSum(); 
    double[] colSum = crosstab.colSum();
    double n = crosstab.sum();


    //compute statistic value 计算统计值
    double chiSq = 0;
    for (int i = 0; i &amp;lt; rowLen; i++) {
        for (int j = 0; j &amp;lt; colLen; j++) {
            double nij = rowSum[i] * colSum[j] / n;
            double temp = crosstab.data[i][j] - nij;
            chiSq += temp * temp / nij; // 就是按照定义来构建卡方值
        }
    }

    //set result
    double p;
    if (rowLen &amp;lt;= 1 || colLen &amp;lt;= 1) {
        p = 1;
    } else {
        ChiSquaredDistribution distribution =
            new ChiSquaredDistribution(null, (rowLen - 1) * (colLen - 1));
        p = 1.0 - distribution.cumulativeProbability(Math.abs(chiSq));
    }

    // return tuple4: f0 is id which is id of cross table, f1 is pValue, f2 is chi-square Value, f3 is df
    return Tuple4.of(colIdx, p, chiSq, (double)(rowLen - 1) * (colLen - 1));
}

// runtime是
tuple4 = {Tuple4@9842} &quot;(0,0.004301310843500827,24.0,9.0)&quot;
 f0 = {Integer@9843} 0
 f1 = {Double@9844} 0.004301310843500827
 f2 = {Double@9847} 24.0
 f3 = {Double@9848} 9.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Leo-Z/p/13186680.html&quot;&gt;卡方检验(Chi_square_test)： 原理及python实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/frankiehello/article/details/87894245&quot;&gt;T检验、卡方检验以及p-value&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/hulubo/blog/1916149&quot;&gt;卡方检验的自由度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/075638fabdc6&quot;&gt;交叉表和卡方检验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/idatamining/article/details/8565042&quot;&gt;卡方检验值转换为P值&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/cad58914445a&quot;&gt;相似度计算和p-value&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/34866983/answer/60541847&quot;&gt;怎么来理解伽玛（gamma）分布？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yszd/p/11957869.html&quot;&gt;Spark MLlib基本算法【相关性分析、卡方检验、总结器】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tovin/p/4019131.html&quot;&gt;spark(1.1) mllib 源码分析(一)-卡方检验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/075638fabdc6&quot;&gt;交叉表和卡方检验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hbr2014/article/details/79189806&quot;&gt;统计学中的H0和H1假设（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/24168200&quot;&gt;统计学中的H0，H1假设是怎么来的？为什么H0不是H1，H1不是H0呢？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/23149768/answer/812134949&quot;&gt;统计学假设检验中 p 值的含义具体是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/idatamining/article/details/8564981&quot;&gt;卡方检验用于特征选择&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/idatamining/article/details/8564966&quot;&gt;卡方检验基础&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 28 Aug 2020 23:32:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将带领大家来分析 Alink 中 卡方检验 的实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13580716.html</dc:identifier>
</item>
<item>
<title>《Java从入门到失业》第三章：基础语法及基本程序结构（五）：基本算数运算符（1） - Java大失叔</title>
<link>http://www.cnblogs.com/javadss/p/13537348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javadss/p/13537348.html</guid>
<description>&lt;h2&gt;3.7运算符&lt;/h2&gt;
&lt;p&gt;      数学运算是计算机的基本用途之一，Java提供了非常丰富的运算符来支持。我们根据运算的特点和性质，把运算符划分为几组：基本算数运算符、自增自减运算符、关系运算符、位运算符、逻辑运算符、赋值运算符、其他运算符。下面分别介绍。&lt;/p&gt;
&lt;h3&gt;3.7.1基本算数运算符&lt;/h3&gt;
&lt;p&gt;       在Java中，采用&lt;strong&gt;+、-、*、/、%&lt;/strong&gt;来表示加、减、乘、除、取余（取模），这种运算小学就学过，无需多讲，列表举例如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;运算&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;算式&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;结果（假设a=15，b=10）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;加法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;a+b&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p align=&quot;center&quot;&gt;25&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;减法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;a-b&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p align=&quot;center&quot;&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;乘法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;a*b&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p align=&quot;center&quot;&gt;150&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;除法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;a/b&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;取余&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;a%b&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p align=&quot;center&quot;&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;运算非常简单，但是还是有一些问题需要注意，下面分别用实例来说明。&lt;/p&gt;
&lt;h4&gt;3.7.1.1类型变化&lt;/h4&gt;
&lt;p&gt;　　我们看一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {  
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; a1 = 15&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;double&lt;/span&gt; a2 = 15&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; b = 2&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; c = 0&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.println(&quot;整数运算：&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;a1 + b = &quot; + (a1 +&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;a1 - b = &quot; + (a1 -&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;a1 * b = &quot; + (a1 *&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;a1 / b = &quot; + (a1 /&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;a1 % b = &quot; + (a1 %&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;浮点数运算：&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.out.println(&quot;a2 + b = &quot; + (a2 +&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;a2 - b = &quot; + (a2 -&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;a2 * b = &quot; + (a2 *&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;a2 / b = &quot; + (a2 /&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         System.out.println(&quot;a2 % b = &quot; + (a2 %&lt;span&gt; b));  
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     } 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;整数运算：  
a1 &lt;/span&gt;+ b = 17&lt;span&gt;  
a1 &lt;/span&gt;- b = 13&lt;span&gt;  
a1 &lt;/span&gt;* b = 30&lt;span&gt;  
a1 &lt;/span&gt;/ b = 7&lt;span&gt;  
a1 &lt;/span&gt;% b = 1&lt;span&gt;  
浮点数运算：  
a2 &lt;/span&gt;+ b = 17.0&lt;span&gt;  
a2 &lt;/span&gt;- b = 13.0  
a2 * b = 30.0  
a2 / b = 7.5  
a2 % b = 1.0  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们看到，整数15/2=7，而浮点数15/7=7.5。在Java中，参与运算的2个数有浮点数时，就会自动将非浮点数变成浮点数来运算。&lt;/p&gt;
&lt;p&gt;下面为了节省篇幅，就不再分别列出代码和结果了。&lt;/p&gt;
&lt;h4&gt;3.7.1.2被0除问题&lt;/h4&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
0.0 / 0 =&lt;span&gt; NaN  
&lt;/span&gt;1.0 / 0 =&lt;span&gt; Infinity  
&lt;/span&gt;-1.0 / 0 = -&lt;span&gt;Infinity  
&lt;/span&gt;1 / 0 =&lt;span&gt;   
Exception in thread &lt;/span&gt;&quot;main&quot; java.lang.ArithmeticException: /&lt;span&gt; by zero  
    at ch03.JibenYunsuanfu.main(JibenYunsuanfu.java:&lt;/span&gt;16) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们看到，浮点数0除以0，得到NaN；正负浮点数除以0得到正负无穷大；整数除以0会抛出异常。&lt;/p&gt;
&lt;h4&gt;3.7.1.3原码反码补码&lt;/h4&gt;
&lt;p&gt;       我们知道，Java的整型和浮点型都是有范围的，如果运算结果超过范围怎么办呢？我们知道int型的最大值是214783647，假如我们+1会得到什么结果呢？结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2147483647 + 1 = -2147483648
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明这个问题原因之前，得先学习原码、反码、补码的相关知识。&lt;/p&gt;
&lt;h5&gt;3.7.1.3.1原码&lt;/h5&gt;
&lt;p&gt;　　我们现实生活当中，可以用正负号来表示正负数，但是计算机中只有0和1，怎么表示正负数呢？于是想出了一个办法，对于固定字长n的二进制数，把2&lt;sup&gt;n&lt;/sup&gt;个数划分为正负数，把最高位规定为符号位，0代表正，1代表负，剩下的二进制数对应十进制数的绝对值。例如假设字长为3，那么一共表示8个数：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;十进制&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;二进制&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这种规定叫做“&lt;strong&gt;原码&lt;/strong&gt;”，即3的原码是011，-3的原码是111。看起来很完美吧，但是有2个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;0的表示不唯一&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无法将减法转换为加法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;0的表示不唯一一目了然，为什么不能将减法转换为加法？我们看个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2 - 1 = 2 + (-1) = 010 + 101 = 111 = -3（正确结果为1）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果错误。那么又为什么要把减法转换为加法呢？我们学习过计算机组成，知道CPU中只有加法寄存器，因为计算机中处理加法比较简单，如果要直接处理减法，需要增加逻辑部件，而且处理减法有借位问题很麻烦。因此在计算机中用原码来进行运算和存储行不通。&lt;/p&gt;
&lt;h5&gt;3.7.1.3.2反码&lt;/h5&gt;
&lt;p&gt;       还有别的办法吗？人们又发明了“&lt;strong&gt;反码&lt;/strong&gt;”。反码规定：正数的反码和原码一致，负数的反码为该数对应的绝对值的原码按位取反。假设字长为3，原码反码分别如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;十进制&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;原码&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;反码&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;反码解决了减法转换为加法的问题，但是额外需要多一个规定，就是当发生溢出时，需要对最低位加1。我们看2个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 – 1 = 1 + (-1) = 001 + 110 = 111 =-0
2 - 1 = 2 + (-1) = 010 + 110 = 1000，溢出了，去掉溢出位后需再加1即000 + 001 = 001 = 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到，结果都正确。但是还是存在2个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;0的表示不唯一&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减法转加法，需要判断溢出问题&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;3.7.1.3.3补码&lt;/h5&gt;
&lt;p&gt;继续探讨，于是出现“&lt;strong&gt;补码&lt;/strong&gt;”。补码规定正数的补码和原码一致，负数的补码为该数对应的绝对值按位取反后加1（如果溢出丢弃最高位）&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;十进制&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;原码&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;反码&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;补码&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们发现0的表示唯一了。另外用补码计算减法也很简单了，直接转换即可（溢出直接丢弃最高位），我们看2个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 – 1 = 1 + (-1) = 001 + 111 = 1000 = 000 = 0
2 - 1 = 2 + (-1) = 010 + 111 = 1001 = 001 = 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;喜欢钻牛角尖的同学就会问了，为什么使用补码就可以解决这些问题呢？有什么道理吗？我就知道你会问，还好我也恶补了这段知识，下面我们来研究一下。&lt;/p&gt;
&lt;h5&gt;3.7.1.3.4补码原理&lt;/h5&gt;
&lt;p&gt;       我们知道，对于一个3位的二进制，对应的十进制为0-7，一共8个。7+1=111+000=1000，去掉溢出位，又变成000即0。我们可以说这8个数字形成了一个闭环。这其实对应数学中的一个概念：模。&lt;/p&gt;
&lt;p&gt;　　模是指一个计量系统的计数范围，例如我们熟悉的时钟，它的计数范围是0-11，模是12。计算机也可以看成一个计量机器，因为计算机的字长是定长的，即存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模”。对于字长3位的机器来说，计数范围是0-7，模是8。“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。任何有模的计量器，均可化减法为加法运算。&lt;/p&gt;
&lt;p&gt;　　我们以时钟为例：当前时间是2点，逆时针拨2格变成0点。顺时针拨10格也是0点。假设逆时针叫减，顺时针叫加，那么对于模12的系统里，减2和加10的效果一样。事实上，减3和加9，减4和加8效果也一样。我们把2和10、3和9、4和8互称为补数，特点就是二者相加等于模。因此在有模的系统里，减去一个数，可以变成加上它的补数，即可以把减法变成加法。&lt;/p&gt;
&lt;p&gt;回到3位数的二进制如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2121036/202008/2121036-20200820185736323-1625609897.png&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;335&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们很容易就知道模为8，1和7、2和6、3和5、4和4他们互为补数。列一个表：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;减数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;补数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p align=&quot;center&quot;&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p align=&quot;center&quot;&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p align=&quot;center&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p align=&quot;center&quot;&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p align=&quot;center&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p align=&quot;center&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p align=&quot;center&quot;&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p align=&quot;center&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p align=&quot;center&quot;&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p align=&quot;center&quot;&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;但是问题来了，3位二进制系统里，虽然减n可以变成加n&lt;sub&gt;补&lt;/sub&gt;，但是由于没有负数，因此计算减法，需要先计算减数的补数，例如减1，需要计算1的补数8-1。怎么办？聪明的你一定可以想到，补数都是成对的，我们把成对的补数中的一半规定为负数是不是就可以了？例如a-1=a+(-1)=a+7，假如我们规定7的二进制111代表-1，那么在计算的时候就没有减法了。同理我们还可以规定110代表-2，101代表-3。至于100是代表4还是-4，都可以，一般我们选择代表-4。这样一来，对于3位二进制系统，表示数的范围就变成-4~3，而所有的减法就变成加法了。而且这样一来我们还惊奇的发现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所有的正数最高位都是0，负数最高位都是1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有负数的二进制都是它所对应的绝对值的二进制按位取反后+1，就是补码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到此为止，我们就搞清楚了为什么在计算中要用补码来表示负数了。&lt;/p&gt;
&lt;p&gt;　　最后，我们回到开头的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2147483647 + 1 = -2147483648 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在回答这个问题太easy了。在Java中，一个数字如果不加后缀，默认就是int型的。我们知道int型占用4个字节，则int的系统是一个模为2&lt;sup&gt;32&lt;/sup&gt;的系统。然后采用补码规则存储，这样最大的正数是2&lt;sup&gt;31&lt;/sup&gt;-1=2147483647。这个数再加1就变成2&lt;sup&gt;31&lt;/sup&gt;。2&lt;sup&gt;31&lt;/sup&gt;的补数是它自己，但是由于2&lt;sup&gt;31&lt;/sup&gt;的二进制最高位是1，我们习惯把它规定为负数，即-2&lt;sup&gt;31&lt;/sup&gt;，因此就是-2147483648。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Aug 2020 14:18:00 +0000</pubDate>
<dc:creator>Java大失叔</dc:creator>
<og:description>Java基本运算符、原码、反码、补码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javadss/p/13537348.html</dc:identifier>
</item>
<item>
<title>设计模式-适配器模式 - 煮诗君</title>
<link>http://www.cnblogs.com/FindTheWay/p/13580073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FindTheWay/p/13580073.html</guid>
<description>&lt;p&gt;适配器模式是将一个类的接口转换成客户希望的另外一个接口，即将原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;86.597066769587&quot;&gt;
&lt;h2 id=&quot;生活中的例子&quot;&gt;生活中的例子&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202008/474750-20200828213625301-1981056023.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，生活中适配器无处不在，如电源适配器，读卡器，甚至多转接头读卡器等，都是很常见的例子，它们的目的都是将原本不能一起工作的部件能够在一起工作。&lt;br/&gt;在软件工程领域的适配器也是同样类似的作用。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;适配器模式是将一个类的接口转换成客户希望的另外一个接口，即将原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;这里就以一个简单的读卡器的例子来加以说明。通常在我们使用SD卡存储文件时，会存在如下情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;电脑只有USB接口，不能直接插入SD卡；&lt;/li&gt;
&lt;li&gt;电脑和SD卡都是成型的产品，不可能改造电脑或者读卡器。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，我们需要在中间实现一个转换器，也就是读卡器。具体关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202008/474750-20200828214416931-1515383525.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不难发现，电脑(&lt;code&gt;Computer&lt;/code&gt;)和读卡器(&lt;code&gt;SdReader&lt;/code&gt;)都实现了USB接口(&lt;code&gt;IUsb&lt;/code&gt;)，而读卡器又聚合了SD卡，也就是SD卡随时可以插到读卡器上。具体实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;public interface IUsb
{
    void Request();
}

public class Sd
{
    public void ReadWrite()
    {
        Console.WriteLine(&quot;存取数据&quot;);
    }
}

public class Computer
{
    private IUsb _usb;

    public void SetUsb(IUsb usb)
    {
        _usb = usb;
    }

    public void ConnectUsb()
    {
        if (_usb != null)
        {
            _usb.Request();
        }
    }
}

public class SdReader : IUsb
{
    private Sd _sd;

    public SdReader(Sd sd)
    {
        _sd = sd;
    }

    public void Request()
    {
        _sd.ReadWrite();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，USB接口(&lt;code&gt;IUsb&lt;/code&gt;)、电脑(&lt;code&gt;Computer&lt;/code&gt;)还有SD卡(&lt;code&gt;Sd&lt;/code&gt;)都是不可变，而读卡器(&lt;code&gt;SdReader&lt;/code&gt;)的目的就是为了让SD卡(&lt;code&gt;Sd&lt;/code&gt;)能够适配USB接口(&lt;code&gt;IUsb&lt;/code&gt;)而额外增加的部分。&lt;/p&gt;
&lt;h2 id=&quot;uml类图&quot;&gt;UML类图&lt;/h2&gt;
&lt;p&gt;将上述类图进行简单的抽象就可以得到如下UML类图，，这就是适配器模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/474750/202008/474750-20200828215731949-184797136.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Target&lt;/strong&gt;：目标接口，我们期望的接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adapter&lt;/strong&gt;：适配器，将被适配者转换成我们期望的形式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adaptee&lt;/strong&gt;: 被适配者，原有的接口&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;优缺点&quot;&gt;优缺点&lt;/h2&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;可以让任何两个没有关联的类一起运行。&lt;/li&gt;
&lt;li&gt;提高了类的复用。&lt;/li&gt;
&lt;li&gt;通过引入一个适配器类来重用现有的类，而无须修改原有结构，遵守了开闭原则&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;过多地使用适配器，会让系统非常零乱，不易整体进行把握。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;适配器模式虽然可以让任何两个没有关联的类一起运行，但是却属于补偿机制，专门用来在系统后期扩展、修改时使用，属于迫不得已的做法。因此，适配器模式也不宜过度使用，如果可以的话，我们应该优先通过重构解决，即让被适配的两个类一开始就可以一起工作或许会更好。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ZShijun/DesignPattern.git&quot;&gt;源码链接&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 28 Aug 2020 14:07:00 +0000</pubDate>
<dc:creator>煮诗君</dc:creator>
<og:description>适配器模式是将一个类的接口转换成客户希望的另外一个接口，即将原本由于接口不兼容而不能一起工作的那些类可以一起工作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FindTheWay/p/13580073.html</dc:identifier>
</item>
<item>
<title>“大地主”IPV6的邻居发现BD - 无头充电器</title>
<link>http://www.cnblogs.com/lwq-ICT/p/13580005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwq-ICT/p/13580005.html</guid>
<description>&lt;div data-contents=&quot;true&quot; readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cpks6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;引入&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;fv7e1&quot; data-offset-key=&quot;amlu2-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;amlu2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;因为当初设计IPv4的时候，没有考虑到网络发展的速度这么快，到今现在IPv4有很多不足，32位的 IPv4地址不够用，现在128位的IPv6能完全够用，据说可以地球上每一粒沙子都分配一个地址，而且拥有更小路由表，对组播改进能更好对服务质量进行控制，地址自动配置，安全性提高； IPv6过渡会用到NATPT，当完全过度到IPv6之后NAT将不会使用，相应的会有OSPFv4，RIPNG、BGP 4+； IPv6也有跟IPv4一样的邻居发现、地址解析，但是IPv6不用ARP和ICMPv4这些协议，下面就介绍IPv6的邻居发现协议；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;2c3su-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;2c3su-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;邻居发现概述&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;fv7e1&quot; data-offset-key=&quot;14lgh-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;14lgh-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;ND(Neighbor Discovery，邻居发现）协议是IPv6中一个非常重要的基础协议，根据IPv4做了一些改变，和加了其他的新功能；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-0dd29aae25cb98c3557133908f65a039_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;616&quot; data-rawheight=&quot;380&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-0dd29aae25cb98c3557133908f65a039.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-06e4bbfa9a80fe0ac795068d1e561f47.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;fv7e1&quot; data-offset-key=&quot;av6kk-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;av6kk-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;IPv6的ICMPv6报文头部&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-c3c6093776028fc965f346669c9544f2_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;790&quot; data-rawheight=&quot;89&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;fv7e1&quot; data-offset-key=&quot;6oek4-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6oek4-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;报文类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span data-offset-key=&quot;1m50a-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;1m50a-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;工作流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;fv7e1&quot; data-offset-key=&quot;5e9m3-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5e9m3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;1.地址解析 IPv4中的地址解析不同，IPv6地址解析包含了两个过程 →解析IPv6地址所对应的链路层地址过程 →邻居可达性状态的维护过程，即邻居不可达检测 (NUD) IPv6地址解析的优点 →加强了解析协议与底层链路的独立性 →增强了安全性 →减小了报文传播范围 IPv4一样，开始只知道IP地址，但是你不知道MAC无法进行数据链路层的通信； ND协议通过在节点间交互NS和NA报文完成地址解析并建立相应的邻居缓存表项，放边下一次直接转信息； &lt;span data-offset-key=&quot;5e9m3-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;补充说明：通信过程IP地址、MAC地址的作用 &lt;span data-offset-key=&quot;5e9m3-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;5e9m3-0-3&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;IP地址作为一个逻辑地址，在网络中具有寻址的功能，而在网络中不是每一个主机都有单独的 &lt;span data-offset-key=&quot;5e9m3-0-4&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;5e9m3-0-5&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;公网地址，IP地址不是唯一的，有可能是IP是相同的，在传输过程为了进一步保证数据的正确 &lt;span data-offset-key=&quot;5e9m3-0-6&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;5e9m3-0-7&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;传达，MAC地址就会作为唯一的标识标识主机，而MAC地址在网络中是不具有寻址功能的， &lt;span data-offset-key=&quot;5e9m3-0-8&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;5e9m3-0-9&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;所以在想要ARP解析，根据目的IP地址去，寻找MAC地址，完成通信；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-eef40e4fc376bde513e5279a5e3afbf1_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1008&quot; data-rawheight=&quot;315&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-eef40e4fc376bde513e5279a5e3afbf1.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-ed8d4a284ff5c843ee5d27c37fbd234b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;fv7e1&quot; data-offset-key=&quot;7g2b5-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7g2b5-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;2.邻居消息不可达检测 NUD (Neighbor Unreachability Detection，邻居不可达检测）是节点确定邻居可达性的过程； 邻居可达性状态机用来描述邻居的可达性，共有六种状态，可互相迁移： EMPTY（空闲状态）：表示节点上没有相关邻接点的邻居缓存表项 INCOMPLETE(未完成)：尝试进行地址解析 REACHABLE（可达)：地址解析成功 STALE(失效)：可达时间超时，未确定邻居是否可达 DEALY（延时)：未确定邻居是否可达 PROBE（探测)：会周期性的向邻居发送NS报文&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-b4da824ff98c17f83d54458a027a64a0_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1056&quot; data-rawheight=&quot;691&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-b4da824ff98c17f83d54458a027a64a0.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-2530c0dea7554d874bfc49a0d4fd750e.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;fv7e1&quot; data-offset-key=&quot;8a314-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8a314-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;3.地址自动配置 有状态地址自动配置： →从DHCP服务器获取地址及相关信息 无状态地址配置： →根据路由器发布的信息而自动配置IPv6地址及相关信息 无状态地址自动配置的优点 →真正的即插即用 →网络迁移方便 ND协议通过在节点间交互RS和RA报文完成路由器发现/前缀发现并自动配置全局IPv6地址&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-a362105bafccea8451a456d6686ba741_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1034&quot; data-rawheight=&quot;406&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-a362105bafccea8451a456d6686ba741.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-68a6ee0e556aaff5515d84be5a9a3bcf.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8prii-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;8prii-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;基本配置&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-05c83d8ad0461e6214eed95143e09311_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1006&quot; data-rawheight=&quot;189&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-05c83d8ad0461e6214eed95143e09311.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-45ce597dbfa75573c1eb84fd0cd7692b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-f9153bd655483eac9bf169d05eea2164_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;968&quot; data-rawheight=&quot;255&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-f9153bd655483eac9bf169d05eea2164.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-c36301db6814d69923781c98437cd5e7.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-bacb6f667d4f5ce4a0966a812de0fc77_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;990&quot; data-rawheight=&quot;158&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-88debeaa5c6ad8bc13ee4569d08e0a51_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;977&quot; data-rawheight=&quot;211&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-88debeaa5c6ad8bc13ee4569d08e0a51.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-005c7cd9d36504bdd88801f162e4455d.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-c2a3f7949abd15013ff354a626282777_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;990&quot; data-rawheight=&quot;253&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-c2a3f7949abd15013ff354a626282777.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-d82f9c10514345f48627559f83ef7acc.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-8a247c3f14bc0801c38edddb9a13310c_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;994&quot; data-rawheight=&quot;182&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-8a247c3f14bc0801c38edddb9a13310c.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-b7e8d4d932e1f72be63868cc35f3fd55.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-8a247c3f14bc0801c38edddb9a13310c_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;994&quot; data-rawheight=&quot;182&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-8a247c3f14bc0801c38edddb9a13310c.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-b7e8d4d932e1f72be63868cc35f3fd55.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-220c528d6f6f3e3cbce2b4fd2e2c6ddd_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;999&quot; data-rawheight=&quot;169&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-220c528d6f6f3e3cbce2b4fd2e2c6ddd.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-99fa97922188cc6c9e740ba76707c291.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;fv7e1&quot; data-offset-key=&quot;8i74b-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8i74b-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在IPv4协议里面看的是ARP表，但是IPv6不用ARP地址解析，用的介绍下面这个命令 查看IP地址和MAC地址的对应关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-96ca27fd848705de704f78b9711dd0f3_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1091&quot; data-rawheight=&quot;387&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-96ca27fd848705de704f78b9711dd0f3.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-bf72b24857c35fe5da27497a290ac643.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8p7pd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;走过路过，点个三连，十分感谢 一起学习，一起进步 技术交流资料分享：QQ---1740602259&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 28 Aug 2020 13:48:00 +0000</pubDate>
<dc:creator>无头充电器</dc:creator>
<og:description>引入 因为当初设计IPv4的时候，没有考虑到网络发展的速度这么快，到今现在IPv4有很多不足，32位的 IPv4地址不够用，现在128位的IPv6能完全够用，据说可以地球上每一粒沙子都分配一个地址，而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwq-ICT/p/13580005.html</dc:identifier>
</item>
<item>
<title>【WEB自动化测试之控件定位】基于HTML5控件的唯一控件属性定位 - Felix7157</title>
<link>http://www.cnblogs.com/felix-g/p/13579978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/felix-g/p/13579978.html</guid>
<description>&lt;p&gt;&lt;strong&gt;  一、WEB控件定位是什么&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要想弄懂这个问题，我们还是基于实践来学习。我们先来看一条入门级别自动化测试用例的构成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DemoCase:&lt;/strong&gt;正确用户名和密码登录博客园，登录成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URL：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://account.cnblogs.com/signin&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写思路（入门级别）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、打开谷歌浏览器&lt;/p&gt;
&lt;p&gt;2、打开博客园登录网页地址&lt;/p&gt;
&lt;p&gt;3、在用户名输入框内输入用户名&lt;/p&gt;
&lt;p&gt;4、在密码输入框内输入密码&lt;/p&gt;
&lt;p&gt;5、点击登录&lt;/p&gt;
&lt;p&gt;6、检测是否跳转到了登录成功的页面&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;脚本如下图:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1447073/202008/1447073-20200828213920381-1426659926.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;现在我们来分解下&lt;strong&gt;输入用户名&lt;/strong&gt;这个动作&lt;/p&gt;
&lt;p&gt;1、首先找到用户名输入框&lt;/p&gt;
&lt;p&gt;2、在输入框中输入用户名&lt;/p&gt;

&lt;p&gt;【找到用户名输入框】实现此步骤的前提就是需要掌握控件的定位。具体在脚本中实现也就是图中的第11行：&lt;/p&gt;
&lt;p&gt;('//*[@autocomplete=&quot;username&quot;]')&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WEB控件定位所做的事情，就是通过特定的方式找到我们需要操作的页面控件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么如何才能学会这个控件定位呢？第一步就是简单了解下前端的语言。和我一起往下看即可轻松学会。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;二、WEB网页文本—HTML5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要想掌握WEB自动化测试的控件定位，我们首选要了解控件是什么。&lt;/p&gt;
&lt;p&gt;控件就是浏览器展示的前端语言生成对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;web前端的基础语言就是HTML5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依旧是老套路，拿博客园举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1447073/202008/1447073-20200828213939841-1107571123.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;用户打开浏览器，看到的用户名输入框、密码输入框、登陆按钮、立即注册等等所有，都是浏览器展示的HTML5语言的对象。&lt;/p&gt;
&lt;p&gt;我们按下F12键即可打开浏览器的调试模式，来查看网页的HTML5源代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按下F12后右边页面中Elements选项对应的就是网页的html5代码&lt;/p&gt;

&lt;p&gt;第一次接触肯定觉得非常晦涩难懂、云里雾里。但是相信我，万事开头难！你在看我自动化测试思维的文章以前不也是觉得自动化测试非常高大上吗?&lt;/p&gt;
&lt;p&gt;不了解什么是自动化测试思维？可以看博主的另一篇文章&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1447073/202008/1447073-20200828213953063-661107589.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;HTML5一个控件的写法一般是2个尖括号成对出现。&lt;/p&gt;
&lt;p&gt;一、第一个尖括号的第一个单次为控件类型，之后是控件属性。&lt;/p&gt;
&lt;p&gt;二、第二个尖括号表示此控件的尾部。&lt;/p&gt;
&lt;p&gt;三、2个尖括号中间为控件在前端显示的文字部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;举例说明的话。控件类型是狗的类型（中华田园犬、哈巴狗、牧羊犬等），控件属性就是这条狗的名字、性别、体重、毛发颜色等。&lt;/strong&gt;2个尖括号中间的文字，就是你想在此页面上展示的这个狗的'名字'。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是拿博客园的登陆界面举例来说：&lt;/p&gt;
&lt;p&gt;点击'小箭头'定位控件，或者在控件处右键选中'检查元素'，即可定位到指定的控件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1447073/202008/1447073-20200828214054334-1344222367.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;控件的源码为：&lt;/p&gt;
&lt;p&gt;&amp;lt;input _ngcontent-miv-c141=&quot;&quot;matinput=&quot;&quot;formcontrolname=&quot;username&quot;placeholder=&quot;登录用户名 / 邮箱&quot;autocomplete=&quot;username&quot;class=&quot;mat-input-element mat-form-field-autofill-control ng-tns-c100-5 cdk-text-field-autofill-monitored ng-touched ng-dirty ng-invalid&quot; id=&quot;mat-input-0&quot; aria-describedby=&quot;mat-error-0&quot; aria-invalid=&quot;true&quot; aria-required=&quot;false&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;input就是控件类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;input以外的就都是控件属性 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个输入框的控件属性有：&lt;/p&gt;
&lt;p&gt;_ngcontent-miv-c141=&quot;&quot;&lt;/p&gt;
&lt;p&gt;matinput=&quot;&quot;&lt;/p&gt;
&lt;p&gt;formcontrolname=&quot;username&quot;&lt;/p&gt;
&lt;p&gt;placeholder=&quot;登录用户名 / 邮箱&quot;&lt;/p&gt;
&lt;p&gt;autocomplete=&quot;username&quot;&lt;/p&gt;
&lt;p&gt;class=&quot;mat-input-element mat-form-field-autofill-control ng-tns-c100-5 cdk-text-field-autofill-monitored ng-touched ng-dirty ng-invalid&quot; &lt;/p&gt;
&lt;p&gt;id=&quot;mat-input-0&quot; &lt;/p&gt;
&lt;p&gt;aria-describedby=&quot;mat-error-0&quot; &lt;/p&gt;
&lt;p&gt;aria-invalid=&quot;true&quot; &lt;/p&gt;
&lt;p&gt;aria-required=&quot;false&quot;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;三、基于控件的唯一控件属性定位&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;了解了什么是控件，现在我们在上手控件的定位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selenium有八种定位控件的方式，有6种都是基于HTML5原生控件的单一控件属性来定位的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;id定位：&lt;/p&gt;
&lt;p&gt;find_element_by_id()&lt;/p&gt;
&lt;p&gt;name定位：&lt;/p&gt;
&lt;p&gt;find_element_by_name()&lt;/p&gt;
&lt;p&gt;class定位：&lt;/p&gt;
&lt;p&gt;find_element_by_class_name()&lt;/p&gt;
&lt;p&gt;tag定位：&lt;/p&gt;
&lt;p&gt;find_element_by_tag_name()&lt;/p&gt;
&lt;p&gt;link定位：&lt;/p&gt;
&lt;p&gt;find_element_by_link_text()&lt;/p&gt;
&lt;p&gt;partial_link定位：&lt;/p&gt;
&lt;p&gt;find_element_by_partial_link_text()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以下两种为特定的2种控件定位方法，下一篇文章再做详解。&lt;br/&gt;&lt;/strong&gt;&lt;strong&gt;xpath定位：find_element_by_xpath()&lt;/strong&gt;&lt;strong&gt;CSS定位：find_element_by_css_selector()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面我将举例来讲解这6种基于单一控件属性的定位方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是拿博客园的登陆界面举例来说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1447073/202008/1447073-20200828214109038-17632638.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;登陆用户名的输入框的HTML5源码为：&lt;/p&gt;
&lt;p&gt;&amp;lt;input _ngcontent-miv-c141=&quot;&quot;matinput=&quot;&quot;formcontrolname=&quot;username&quot;placeholder=&quot;登录用户名 / 邮箱&quot;autocomplete=&quot;username&quot;class=&quot;mat-input-element mat-form-field-autofill-control ng-tns-c100-5 cdk-text-field-autofill-monitored ng-touched ng-dirty ng-invalid&quot; id=&quot;mat-input-0&quot; aria-describedby=&quot;mat-error-0&quot; aria-invalid=&quot;true&quot; aria-required=&quot;false&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;这个输入框的控件属性有：&lt;/p&gt;
&lt;p&gt;_ngcontent-miv-c141=&quot;&quot;&lt;/p&gt;
&lt;p&gt;matinput=&quot;&quot;&lt;/p&gt;
&lt;p&gt;formcontrolname=&quot;username&quot;&lt;/p&gt;
&lt;p&gt;placeholder=&quot;登录用户名 / 邮箱&quot;&lt;/p&gt;
&lt;p&gt;autocomplete=&quot;username&quot;&lt;/p&gt;
&lt;p&gt;class=&quot;mat-input-element mat-form-field-autofill-control ng-tns-c100-5 cdk-text-field-autofill-monitored ng-touched ng-dirty ng-invalid&quot; &lt;/p&gt;
&lt;p&gt;id=&quot;mat-input-0&quot; &lt;/p&gt;
&lt;p&gt;aria-describedby=&quot;mat-error-0&quot; &lt;/p&gt;
&lt;p&gt;aria-invalid=&quot;true&quot; &lt;/p&gt;
&lt;p&gt;aria-required=&quot;false&quot;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对应的定位方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;id属性来定位此控件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写法为：&lt;/p&gt;
&lt;p&gt;find_element_by_id(mat-input-0)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;name属性来定位此控件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此控件前端开发没有定义name属性，则无法使用此定位方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tag属性来定位此控件（控件的类型）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写法为：&lt;/p&gt;
&lt;p&gt;find_element_by_tag_name('input')&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class属性来定位此控件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写法为：&lt;/p&gt;
&lt;p&gt;find_element_by_class_name(mat-input-0)&lt;/p&gt;

&lt;p&gt;另外两种定位是针对link属性的控件，也就是链接控件。如下图：&lt;/p&gt;
&lt;p&gt;依旧是老老路。使用博客园登陆页举例：&lt;/p&gt;
&lt;p&gt;【立即注册】就是页面中的一个link控件，其作用就是跳转到注册页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1447073/202008/1447073-20200828214120245-370961203.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&amp;lt;a _ngcontent-arq-c141=&quot;&quot; class=&quot;ng-tns-c141-2&quot; href=&quot;/signup?returnUrl=https:%2F%2Fwww.cnblogs.com%2F&quot;&amp;gt;立即注册&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;他的控件属性有class=&quot;ng-tns-c141-2&quot;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;link定位(通过link控件的文本值)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;find_element_by_link_text('立即注册')&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是部分页面会存在，link的文本值非常长，所以就发明了partial_link定位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图中的百度文库的某一页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1447073/202008/1447073-20200828214129872-1714162614.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;link的文本值为：全国2018年10月04741计算机网络原理真题以及答案解析&lt;/p&gt;
&lt;p&gt;定位的脚本就可以写成：（只取文本的某一段值即可）&lt;/p&gt;
&lt;p&gt;find_element_by_link_text('04741计算机网络')&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是这样的定位方式存在一个致命且常见的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着前端的技术不断的发展，页面的复杂度越来越高。一个页面的控件越来越多（tag不唯一），id、name、class_name可能有很多重名或者完全是动态的一串字母（id、name、class_name、link_name可能都不唯一），我们基于唯一控件属性定位的在特别复杂的项目上可能完全无法完成UI自动化测试的定位工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了解决上述情况，伟大工程师们又发明了XPATH定位和CSS定位！这两种定位在现在的前端框架中，几乎是万能的定位方法了。但是学会他们的前提，也是需要掌握H5语言的基本的原理，于是有了此文。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文已超过2400字，由于篇幅限制，将在下一篇文章中详解这2种定位方法（XPATH定位和CSS定位）。敬请各位观众大老爷们期待。&lt;/p&gt;



&lt;p&gt;如果你觉得本文对你有用，麻烦给本文点个赞。这是对作者最大的支持与鼓励，我将继续输出更多更有价值的文章。谢谢！&lt;/p&gt;


&lt;p&gt;关注博主的微信公众号，免费获取更多干货！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1447073/202008/1447073-20200828214153742-521707379.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 28 Aug 2020 13:42:00 +0000</pubDate>
<dc:creator>Felix7157</dc:creator>
<og:description>一、WEB控件定位是什么 要想弄懂这个问题，我们还是基于实践来学习。我们先来看一条入门级别自动化测试用例的构成。 DemoCase:正确用户名和密码登录博客园，登录成功 URL： https://ac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/felix-g/p/13579978.html</dc:identifier>
</item>
<item>
<title>Git 撤销修改和版本回退 - 暴脾气大大</title>
<link>http://www.cnblogs.com/sebastian-tyd/p/13579921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sebastian-tyd/p/13579921.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;span&gt;撤销修改&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 撤销修改是指将工作区中的修改撤销
git checkout [文件名或路径]

# 1、撤销工作区中当前目录中的所有修改
git checkout .

# 2、撤销工作区中指定文件的修改
git checkout -- filename
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;span&gt;checkout&lt;/span&gt;&lt;span&gt;命令只能撤销工作区中的修改，不能撤销暂存区中的修改&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;git checkout&lt;/span&gt;&lt;span&gt;命令还有一个非常重要的作用就是切换分支，可用于分支管理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 1、切换到指定分支（如果分支在本地不存在，会自动从远程仓库拉取）
git checkout dev

# 2、切换分支的同时创建分支
git checkout -b dev
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;版本回退&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 版本回退是指将版本库从当前版本回退到其他版本

git reset -- hard 版本号
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有时，我们需要将&lt;/span&gt;&lt;span&gt;Git&lt;/span&gt;&lt;span&gt;版本回退（还原）到以前的某个版本，可以使用&lt;/span&gt; &lt;span&gt;git reset&lt;/span&gt; &lt;span&gt;命令&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;中，&lt;/span&gt;&lt;span&gt;HEAD&lt;/span&gt;&lt;span&gt;指针指向的是当前版本，也就是最新的&lt;/span&gt;&lt;span&gt;conmit id&lt;/span&gt;&lt;span&gt;，上一个版本是&lt;/span&gt;&lt;span&gt; &lt;span&gt;HEAD^&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，上上个版本就是&lt;/span&gt;&lt;span&gt; &lt;span&gt;HEAD^^&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，上&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;个版本可以写作&lt;/span&gt;&lt;span&gt;&lt;span&gt;HEAD~50&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 可以使用下面的命令，回退到上一个版本

git reset --hard HEAD^
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;这时，我们再使用 git log 命令查看版本库被修改的日志。却发现，看不到被回退的版本之后的历史记录了。 如果，想再回到最新的版本，怎么办？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;只要刚刚的命令行窗口没有关掉，你就可以顺着往上面找，直到发现最新的版本号（如&lt;/span&gt;&lt;span&gt;4b2a0c88a2d03675694013ac6a2bd6f55c830cdc&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 就可以使用下面的命令还原到指定的版本，版本号（commit id）没必要写全，一般写前七位就够了，Git会自动去匹配：

git reset --hard 4b2a0c8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是，假如你回退到了某个版本后，把电脑关了。第二天又后悔了，想要恢复到最新版本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这时，可以使用命令&lt;/span&gt; &lt;span&gt;git reflog&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;来查&lt;/span&gt;&lt;span&gt;看你的每一次操作日志，该命令可以输出对应的版本号的操作记录。这样，我们就可以恢复到任意版本了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;span&gt;git reset options&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;git reset&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;有很多可用选项，可以使用命令&lt;/span&gt; &lt;span&gt;&lt;span&gt;git reset -h&lt;/span&gt; &lt;span&gt;来查看&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其中最常用的三个选项是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;--mixed&lt;/span&gt;&lt;span&gt;：&lt;/span&gt; &lt;span&gt;reset HEAD and index&lt;/span&gt;&lt;span&gt;。表示重置&lt;/span&gt; &lt;span&gt;HEAD&lt;/span&gt; &lt;span&gt;指针和&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;暂存区，但保持工作区不变。它是默认选项。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;--soft&lt;/span&gt;&lt;span&gt;：&lt;/span&gt; &lt;span&gt;reset only HEAD&lt;/span&gt;&lt;span&gt;。表示仅仅重置&lt;/span&gt; &lt;span&gt;HEAD&lt;/span&gt; &lt;span&gt;指针，即只改变&lt;/span&gt; &lt;span&gt;HEAD&lt;/span&gt; &lt;span&gt;的指向，但保持工作区和暂存区不变。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;--hard&lt;/span&gt;&lt;span&gt;：&lt;/span&gt; &lt;span&gt;reset HEAD, index and working tree&lt;/span&gt;&lt;span&gt;。表示重置&lt;/span&gt; &lt;span&gt;HEAD&lt;/span&gt; &lt;span&gt;指针、&lt;/span&gt;&lt;span&gt;index&lt;/span&gt; &lt;span&gt;暂存区和工作区。这个才是完整的版本回退。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;11&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看版本库的状态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;span&gt;git status&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;git status&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;命令非常有用。它可以查看版本库的当前状态，还可以看到相关操作的提示信息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看修改&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 如果你修改了工作区中的某些文件，想要查看具体更改了什么内容，可以使用 git diff 命令
git diff .
git diff filename
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看工作区和版本库的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 如果你只是修改了工作区，还没有 git add 到暂存区，想要查看工作区和版本库的区别。
# 查看工作区和版本库的区别
git diff
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;上述命令只能查看到工作区中&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;已经存在的文件的修改&lt;span&gt;，如果是新创建的文件，它追踪不到。如果修改和新文件已经&lt;/span&gt;&lt;/span&gt; &lt;span&gt;git add&lt;/span&gt; &lt;span&gt;到了暂存区，就需要使用下面的命令来查看。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看暂存区和版本库的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 如果你修改了工作区，已经 git add 到了暂存区，想要查看暂存区和版本库的区别。
git diff --cached
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;6.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看两个版本之间的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你修改了工作区，已经&lt;/span&gt; &lt;span&gt;git add&lt;/span&gt; &lt;span&gt;到了暂存区，并且&lt;/span&gt; &lt;span&gt;git commit&lt;/span&gt; &lt;span&gt;到了版本库。这样&lt;/span&gt; &lt;span&gt;head&lt;/span&gt; &lt;span&gt;指针就指向了最新的版本。想要比较两个版本之间的区别。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;语法：&lt;/span&gt; &lt;span&gt;git diff [&lt;/span&gt;&lt;span&gt;版本号&lt;/span&gt;&lt;span&gt;1] [&lt;/span&gt;&lt;span&gt;版本号&lt;/span&gt;&lt;span&gt;2]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 比较两个版本之间的差异
git diff 4129523 0a7d9af

# 4129523：表示上一个版本号
# 0a7d9af：当前版本号（最新版本号）

# 比较之前的版本和当前版本的差异
git diff 4129523 head

# 比较某个文件在两个版本之间的差异
git diff 09d9b45 head ./config/app.php

# 比较之前的版本和当前版本的差异的简写形式
git diff 4129523
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看本地的两个分支的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;span&gt;git diff [branch1] [branch2]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 比较develop分支和master分支的区别
git diff develop master
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看本地分支和远程分支的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 对比本地的develop分支和远程master分支的区别
git diff develop origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看版本库的历史记录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你想查看版本库提交的历史记录&lt;/span&gt;&lt;span&gt;，可以使用&lt;/span&gt; &lt;span&gt;git log&lt;/span&gt; &lt;span&gt;命令。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 查看版本库的历史记录
git log

# 查看版本库的历史记录，美化输出
git log --pretty=oneline

# 查看版本库的历史记录，只显示前 5 条
git log -5
git log -5 --pretty=oneline
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;场景分析&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;场景一&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 仅仅是撤销工作区中的修改
git checkout .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;场景二&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;假如你修改了工作区，并把工作区中的修改&lt;/span&gt; &lt;span&gt;git add&lt;/span&gt; &lt;span&gt;到了暂存区&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 如果你想撤销工作区和暂存区中的修改。
git reset --hard HEAD
# 简写为
git reset --hard

# 如果你仅仅只是想要撤销暂存区中的修改。
git reset --mixed
# 简写为
git reset
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;场景三&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 如果你想回退到上一个版本，可以使用下面的命令。
git reset --hard HEAD^

# 查看当前的版本号，可以使用。 
git rev-parse HEAD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;说明：完整的版本回退，包含三个要素：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;更改&lt;/span&gt; &lt;span&gt;HEAD&lt;/span&gt; &lt;span&gt;指针的指向（即让&lt;/span&gt; &lt;span&gt;HEAD&lt;/span&gt; &lt;span&gt;指向目标版本）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;回退暂存区（即暂存区中的内容也要回退到目标版本）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;回退工作区（即工作区中的内容也要回退到目标版本）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 28 Aug 2020 13:25:00 +0000</pubDate>
<dc:creator>暴脾气大大</dc:creator>
<og:description>撤销修改 # 撤销修改是指将工作区中的修改撤销 git checkout [文件名或路径] # 1、撤销工作区中当前目录中的所有修改 git checkout . # 2、撤销工作区中指定文件的修改</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sebastian-tyd/p/13579921.html</dc:identifier>
</item>
<item>
<title>Combine 框架，从0到1  —— 2.通过 ConnectablePublisher 控制何时发布 - Ficow</title>
<link>http://www.cnblogs.com/ficow/p/13579857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ficow/p/13579857.html</guid>
<description>
&lt;p&gt;本文首发于 &lt;a href=&quot;https://ficowshen.com&quot;&gt;Ficow Shen's Blog&lt;/a&gt;，原文地址： &lt;a href=&quot;https://blog.ficowshen.com/page/post/14&quot;&gt;Combine 框架，从0到1 —— 2.通过 ConnectablePublisher 控制何时发布&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;内容概览&quot;&gt;内容概览&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;使用 makeConnectable() 和 connect() 手动控制发布&lt;/li&gt;
&lt;li&gt;使用 autoconnect() 操作符进行自动连接&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;Connectable Publisher&lt;/code&gt;， 你可以决定发布者何时开始发送订阅元素给订阅者。那么，为什么我们需要这么做？&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;sink(receiveValue:)&lt;/code&gt; 可以立刻开始接收订阅元素，但是这可能不是你想要的结果。当多个订阅者订阅了同一个发布者时，有可能会出现其中一个订阅者收到订阅内容，而另外一个订阅者收不到的情况。&lt;/p&gt;
&lt;p&gt;比如，当你发起一个网络请求，并为这个请求创建了一个发布者以及连接了这个发布者的订阅者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ficowblog.oss-cn-shenzhen.aliyuncs.com/uploads/1597552131518.png&quot; alt=&quot;图片alt&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，这个订阅者的订阅操作触发了实际的网络请求。在某个时间点，你将第二个订阅者连接到了这个发布者。如果在连接第二个订阅者之前，网络请求已经完成，那么第二个订阅者将只会收到完成事件，收不到网络请求的响应结果。这时候，这个结果将不是你所期望。&lt;/p&gt;
&lt;p&gt;在使用 &lt;code&gt;Combine&lt;/code&gt; 的过程中，我们往往需要面对这些问题。现在就来弄清楚如何处理这一类问题吧~&lt;/p&gt;

&lt;h2 id=&quot;使用-makeconnectable-和-connect-控制发布&quot;&gt;使用 makeConnectable() 和 connect() 控制发布&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ConnectablePublisher&lt;/code&gt; 是一个协议类型，它可以在你准备好之前阻止发布者发布元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;/// 可连接的发布者，它提供了显式的连接、取消订阅的方式
///
/// 使用 `makeConnectable()` 来从任何一个失败类型是 `Never` 的发布者创建一个 `ConnectablePublisher`
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol ConnectablePublisher : Publisher {

    /// 连接到发布者并返回一个用于取消发布的 `Cancellable` 实例
    ///
    /// - 返回值: 一个用于取消发布的 `Cancellable` 实例
    func connect() -&amp;gt; Cancellable
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在你显式地调用 &lt;code&gt;connect()&lt;/code&gt; 方法之前，一个 &lt;code&gt;ConnectablePublisher&lt;/code&gt; 不会发送任何元素。&lt;/p&gt;
&lt;p&gt;现在，就让我们用 &lt;code&gt;ConnectablePublisher&lt;/code&gt; 来解决上面提到的网络请求示例中的问题吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ficowblog.oss-cn-shenzhen.aliyuncs.com/uploads/1597552861187.png&quot; alt=&quot;ConnectablePublisher&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在两个订阅者都连接到发布者之后，调用 &lt;code&gt;connect()&lt;/code&gt;，然后网络请求才被触发。这样就可以避免竞争(race condition)，保证两个订阅者都收到数据。&lt;/p&gt;
&lt;p&gt;为了在你的 Combine 代码中使用 &lt;code&gt;ConnectablePublisher&lt;/code&gt;，你可以使用 &lt;code&gt;makeConnectable()&lt;/code&gt; 操作符将当前的发布者包装到一个 &lt;code&gt;Publishers.MakeConnectable&lt;/code&gt; 结构体实例中。&lt;/p&gt;
&lt;p&gt;如下方的代码所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;class ConnectablePublisherDemo {
    
    private var cancellable1: AnyCancellable?
    private var cancellable2: AnyCancellable?
    private var connection: Cancellable?
    
    func run() {
        let url = URL(string: &quot;https://ficow.cn&quot;)!
        let connectable = URLSession.shared
            .dataTaskPublisher(for: url)
            .map(\.data)
            .catch() { _ in Just(Data()) }
            .share()
            .makeConnectable() // 阻止发布者发布内容
        
        cancellable1 = connectable
            .sink(receiveCompletion: { print(&quot;Received completion 1: \($0).&quot;) },
                  receiveValue: { print(&quot;Received data 1: \($0.count) bytes.&quot;) })
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.cancellable2 = connectable.sink(receiveCompletion: { log(&quot;Received completion 2: \($0).&quot;) },
                                                 receiveValue: { log(&quot;Received data 2: \($0.count) bytes.&quot;) })
        }

        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                        // 显式地启动发布。返回值需要被强引用，可用于取消发布（主动调用cancel方法或返回值被析构）
            self.connection = connectable.connect() 
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，在 &lt;code&gt;makeConnectable()&lt;/code&gt; 操作符前面有一个 &lt;code&gt;share()&lt;/code&gt; 操作符！请问，这个操作符有什么作用呢？&lt;/p&gt;

&lt;h2 id=&quot;使用-autoconnect-操作符进行自动连接&quot;&gt;使用 autoconnect() 操作符进行自动连接&lt;/h2&gt;

&lt;p&gt;某些 &lt;code&gt;Combine&lt;/code&gt; 发布者已经实现了 &lt;code&gt;ConnectablePublisher&lt;/code&gt; 协议，如：&lt;code&gt;Publishers.Multicast&lt;/code&gt; 和 &lt;code&gt;Timer.TimerPublisher&lt;/code&gt;。使用这些发布者时，如果你不需要配置发布者或者不需要连接多个订阅者，你就需要显式地调用 &lt;code&gt;connect()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;对于这种情况，&lt;code&gt;ConnectablePublisher&lt;/code&gt; 提供了 &lt;code&gt;autoconnect()&lt;/code&gt; 操作符。当一个订阅者通过 &lt;code&gt;subscribe(_:)&lt;/code&gt; 方法连接到发布者时，&lt;code&gt;connect()&lt;/code&gt; 方法会被马上调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;let cancellable = Timer.publish(every: 1, on: .main, in: .default)
    .autoconnect()
    .sink() { date in
        print (&quot;Date now: \(date)&quot;)
     }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码示例中使用了 &lt;code&gt;autoconnect()&lt;/code&gt;，所以订阅者可以马上接收到定时器发送的元素。如果没有 &lt;code&gt;autoconnect()&lt;/code&gt;，我们就需要在某个时刻手动地调用 &lt;code&gt;connect()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Combine&lt;/code&gt; 为我们提供了很强大的异步编程功能，不过这也是有代价的，我们需要深知使用 &lt;code&gt;Combine&lt;/code&gt; 过程中可能会遭遇的问题。如果不了解这些&lt;code&gt;“坑”&lt;/code&gt;就开始上路，犯错的概率会非常高，犯错的成本也会非常高。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文内容来源：&lt;/strong&gt; &lt;a href=&quot;https://developer.apple.com/documentation/combine/controlling-publishing-with-connectable-publishers&quot;&gt;Controlling Publishing with Connectable Publishers&lt;/a&gt;，转载请&lt;a href=&quot;https://blog.ficowshen.com&quot;&gt;注明出处&lt;/a&gt;。&lt;/p&gt;

</description>
<pubDate>Fri, 28 Aug 2020 13:04:00 +0000</pubDate>
<dc:creator>Ficow</dc:creator>
<og:description>本文首发于 Ficow Shen&amp;amp;#39;s Blog，原文地址： Combine 框架，从0到1 —— 2.通过 ConnectablePublisher 控制何时发布。 内容概览 前言 使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ficow/p/13579857.html</dc:identifier>
</item>
<item>
<title>Istio的流量管理(实操三) - charlieroro</title>
<link>http://www.cnblogs.com/charlieroro/p/13558508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlieroro/p/13558508.html</guid>
<description>&lt;p&gt;涵盖官方文档&lt;a href=&quot;https://istio.io/docs/tasks/traffic-management/&quot;&gt;Traffic Management&lt;/a&gt;章节中的egress部分。其中有一小部分问题(已在下文标注)待官方解决。&lt;/p&gt;

&lt;h2 id=&quot;访问外部服务&quot;&gt;访问外部服务&lt;/h2&gt;
&lt;p&gt;由于启用了istio的pod的出站流量默认都会被重定向到代理上，因此对集群外部URL的访问取决于代理的配置。默认情况下，Envoy代理会透传对未知服务的访问，虽然这种方式为新手提供了便利，但最好配置更严格的访问控制。&lt;/p&gt;
&lt;p&gt;本节展示使用如下三种方式访问外部服务:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;允许Envoy代理透传到网格外部的服务&lt;/li&gt;
&lt;li&gt;配置&lt;a href=&quot;https://istio.io/docs/reference/config/networking/service-entry/&quot;&gt;service entries&lt;/a&gt;来访问外部访问&lt;/li&gt;
&lt;li&gt;透传某一个IP端的请求&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;部署sleep app，用于发送请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;设置&lt;code&gt;SOURCE_POD&lt;/code&gt;为请求源pod名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;envoy透传流量到外部服务&quot;&gt;Envoy透传流量到外部服务&lt;/h3&gt;
&lt;p&gt;istio有一个&lt;a href=&quot;https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode&quot;&gt;安装选项&lt;/a&gt;，&lt;code&gt;meshConfig.outboundTrafficPolicy.mode&lt;/code&gt;，用于配置sidecar处理外部服务(即没有定义到istio内部服务注册中心的服务)。如果该选项设置为&lt;code&gt;ALLOW_ANY&lt;/code&gt;，则istio代理会放行到未知服务的请求；如果选项设置为&lt;code&gt;REGISTRY_ONLY&lt;/code&gt;，则istio代理会阻塞没有在网格中定义HTTP服务或服务表项的主机。默认值为&lt;code&gt;ALLOW_ANY&lt;/code&gt;，允许快速对istio进行评估。&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;首先将&lt;code&gt;meshConfig.outboundTrafficPolicy.mode&lt;/code&gt;选项设置为&lt;code&gt;ALLOW_ANY&lt;/code&gt;。默认应该就是&lt;code&gt;ALLOW_ANY&lt;/code&gt;，使用如下方式获取当前的模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$kubectl get configmap istio -n istio-system -o yaml |grep -o &quot;mode: ALLOW_ANY&quot; |uniq
mode: ALLOW_ANY
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有配置模式，可以手动添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;outboundTrafficPolicy: 
  mode: ALLOW_ANY
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;从网格内向外部服务发送两个请求，可以看到请求成功，返回200&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -I https://www.baidu.com | grep  &quot;HTTP/&quot;; kubectl exec -it $SOURCE_POD -c sleep -- curl -I https://edition.cnn.com | grep &quot;HTTP/&quot;
HTTP/1.1 200 OK
HTTP/2 200
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种方式可以访问外部服务，但无法对该流量进行监控和控制，下面介绍如何监控和控制网格到外部服务的流量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;控制访问外部服务&quot;&gt;控制访问外部服务&lt;/h3&gt;
&lt;p&gt;使用ServiceEntry配置可以从istio集群内部访问公共服务。本节展示如何配置访问外部HTTP服务，httpbin.org以及www.baidu.com，同时会监控和控制istio流量。&lt;/p&gt;
&lt;h4 id=&quot;修改默认的阻塞策略&quot;&gt;修改默认的阻塞策略&lt;/h4&gt;
&lt;p&gt;为了展示如何控制访问外部服务的方式，需要将&lt;code&gt;meshConfig.outboundTrafficPolicy.mode&lt;/code&gt;设置为&lt;code&gt;REGISTRY_ONLY&lt;/code&gt;&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;执行如下命令将&lt;code&gt;meshConfig.outboundTrafficPolicy.mode&lt;/code&gt;选项设置为&lt;code&gt;REGISTRY_ONLY&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g' | kubectl replace -n istio-system -f -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;从SOURCE_POD访问外部HTTPS服务，此时请求会被阻塞(可能需要等一段时间来使配置生效)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -I https://www.baidu.com | grep  &quot;HTTP/&quot;; kubectl exec -it $SOURCE_POD -c sleep -- curl -I https://edition.cnn.com | grep &quot;HTTP/&quot;
command terminated with exit code 35
command terminated with exit code 35
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;访问外部http服务&quot;&gt;访问外部HTTP服务&lt;/h4&gt;
&lt;ol readability=&quot;9.942218798151&quot;&gt;&lt;li readability=&quot;9.9522445081184&quot;&gt;
&lt;p&gt;创建一个&lt;code&gt;ServiceEntry&lt;/code&gt;注册外部服务，这样就可以直接访问外部HTTP服务，可以看到此处并没有用到virtual service和destination rule&lt;/p&gt;
&lt;blockquote readability=&quot;12.918136020151&quot;&gt;
&lt;p&gt;下面serviceEntry使用&lt;code&gt;DNS&lt;/code&gt; 作为resolution是一种比较安全的方式，将resolution设置为&lt;code&gt;NONE&lt;/code&gt;将可能导致攻击。例如，恶意客户可能会再HOST首部中设置&lt;code&gt;httpbin.org&lt;/code&gt;，但实际上访问的不同的IP地址。istio sidecar代理会信任HOST首部，并错误地允许此次访问(即使会将流量传递到不同于主机的IP地址)，该主机可能是一个恶意网站，或是一个被网格安全策略屏蔽的合法网站。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;DNS&lt;/code&gt; resolution时，sidecar代理会忽略原始目的地址，并将流量传递给&lt;code&gt;hosts&lt;/code&gt;字段的主机。在转发流量前会使用DNS请求&lt;code&gt;hosts&lt;/code&gt;字段的IP地址。&lt;/p&gt;
&lt;p&gt;serviceEntry包括如下三种&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/service-entry/#ServiceEntry-Resolution&quot;&gt;resolution&lt;/a&gt;：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;NONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Assume that incoming connections have already been resolved (to a specific destination IP address). Such connections are typically routed via the proxy using mechanisms such as IP table REDIRECT/ eBPF. After performing any routing related transformations, the proxy will forward the connection to the IP address to which the connection was bound.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;STATIC&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Use the static IP addresses specified in endpoints (see below) as the backing instances associated with the service.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;&lt;code&gt;DNS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Attempt to resolve the IP address by querying the ambient DNS, during request processing. If no endpoints are specified, the proxy will resolve the DNS address specified in the hosts field, if wildcards are not used. If endpoints are specified, the DNS addresses specified in the endpoints will be resolved to determine the destination IP address. DNS resolution cannot be used with Unix domain socket endpoints.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: httpbin-ext
spec:
  hosts:
  - httpbin.org #外部服务URI
  ports:
  - number: 80 #外部服务HTTP端口信息
    name: http
    protocol: HTTP
  resolution: DNS
  location: MESH_EXTERNAL # 表示一个外部服务，即httpbin.org是网格外部的服务
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;从SOURCE_POD请求外部HTTP服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl http://httpbin.org/headers
{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;,
    &quot;Content-Length&quot;: &quot;0&quot;,
    &quot;Host&quot;: &quot;httpbin.org&quot;,
    &quot;User-Agent&quot;: &quot;curl/7.64.0&quot;,
    ...
    &quot;X-Envoy-Decorator-Operation&quot;: &quot;httpbin.org:80/*&quot;,
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意HTTP添加了istio sidecar代理首部&lt;code&gt;X-Envoy-Decorator-Operation&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.9328859060403&quot;&gt;
&lt;p&gt;校验&lt;code&gt;SOURCE_POD&lt;/code&gt; sidecar代理的日志(实际并没有如同官方文档中的打印，&lt;a href=&quot;https://github.com/istio/istio.io/issues/7419&quot;&gt;issue&lt;/a&gt;跟踪)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl logs $SOURCE_POD -c istio-proxy | tail
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;访问外部https服务&quot;&gt;访问外部HTTPS服务&lt;/h4&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建ServiceEntry允许访问外部HTTPS服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: baidu
spec:
  hosts:
  - www.baidu.com
  ports:
  - number: 443 # 外部服务HTTPS端口
    name: https
    protocol: HTTPS #指定外部服务为HTTPS协议
  resolution: DNS
  location: MESH_EXTERNAL
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;从&lt;code&gt;SOURCE_POD&lt;/code&gt;访问外部服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -I https://www.baidu.com | grep  &quot;HTTP/&quot;
HTTP/1.1 200 OK
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;管理到外部的流量&quot;&gt;管理到外部的流量&lt;/h4&gt;
&lt;p&gt;与管理集群内部的流量类似，istio 的路由规则也可以管理使用&lt;code&gt;ServiceEntry&lt;/code&gt;配置的外部服务。本例将会为&lt;code&gt;httpbin.org&lt;/code&gt;服务设置一个超时规则.&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;从测试的pod向外部服务&lt;code&gt;httpbin.org&lt;/code&gt;的/delay地址发送一个请求，大概5s后返回200&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- time curl -o /dev/null -s -w &quot;%{http_code}\n&quot; http://httpbin.org/delay/5
200
real    0m 5.43s
user    0m 0.00s
sys     0m 0.00s
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;对外部服务&lt;code&gt;httpbin.org&lt;/code&gt;设置一个3s的超时时间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: httpbin-ext
spec:
  hosts:
    - httpbin.org #此处的hosts与serviceEntry的hosts字段内容对应
  http:
  - timeout: 3s
    route:
      - destination:
          host: httpbin.org 
        weight: 100
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;几秒后，重新访问该服务，可以看到访问超时&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- time curl -o /dev/null -s -w &quot;%{http_code}\n&quot; http://httpbin.org/delay/5
504
real    0m 3.02s
user    0m 0.00s
sys     0m 0.00s
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;卸载&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete serviceentry httpbin-ext google
$ kubectl delete virtualservice httpbin-ext --ignore-not-found=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;直接访问外部服务&quot;&gt;直接访问外部服务&lt;/h4&gt;
&lt;p&gt;可以配置Envoy sidecar，使其不拦截特定IP段的请求。为了实现该功能，可以修改&lt;code&gt;global.proxy.includeIPRanges&lt;/code&gt;或&lt;code&gt;global.proxy.excludeIPRanges&lt;/code&gt;&lt;a href=&quot;https://archive.istio.io/v1.4/docs/reference/config/installation-options/&quot;&gt;配置选项&lt;/a&gt;(&lt;em&gt;类似白名单和黑名单&lt;/em&gt;)，并使用&lt;code&gt;kubectl apply&lt;/code&gt;命令更新&lt;code&gt;istio-sidecar-injector&lt;/code&gt;配置。也可以修改annotations &lt;code&gt;traffic.sidecar.istio.io/includeOutboundIPRanges&lt;/code&gt;来达到相同的效果。在更新&lt;code&gt;istio-sidecar-injector&lt;/code&gt;配置后，相应的变动会影响到所有的应用pod。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;与使用ALLOW_ANY流量策略配置sidecar放行所有到未知服务的流量不同，上述方式会绕过sidecar的处理，即在特定IP段上不启用istio功能。使用这种方式不能增量地为特定目的地添加service entry，但使用&lt;code&gt;ALLOW_ANY&lt;/code&gt;方式是可以的，因此这种方式仅仅建议用于性能测试或其他特殊场景中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一种不把到外部IP的流量重定向到sidecar代理的方式是将&lt;code&gt;global.proxy.includeIPRanges&lt;/code&gt;设置为集群内部服务使用的一个IP段或多个IP段。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://istio.io/docs/tasks/traffic-management/egress/egress-control/#determine-the-internal-ip-ranges-for-your-platform&quot;&gt;找到&lt;/a&gt;平台使用的内部IP段后，就可以使用如下方式配置&lt;code&gt;includeIPRanges&lt;/code&gt;，这样目的地非&lt;code&gt;10.0.0.1/24&lt;/code&gt;的流量会绕过sidecar的处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ istioctl manifest apply &amp;lt;the flags you used to install Istio&amp;gt; --set values.global.proxy.includeIPRanges=&quot;10.0.0.1/24&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本节介绍了三种访问外部服务的方式:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置Envoy 允许访问外部服务&lt;/li&gt;
&lt;li&gt;在网格内部使用service entry注册可访问的外部服务，推荐使用这种方式&lt;/li&gt;
&lt;li&gt;配置istio sidecar排除处理某些IP段的流量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一种方式的流量会经过istio sidecar代理，当使用这种方式时，无法监控访问外部服务的流量，无法使用istio的流量控制功能。第二种方法可以在调用集群内部或集群外部的服务时充分使用istio服务网格特性，本章的例子中，在访问外部服务时设置了超时时间。第三种方式会绕过istio sidecar代理，直接访问外部服务。然而这种方式需要指定集群的配置，与第一种方式类似，这种方式也无法监控到外部服务的流量，且无法使用istio的功能。&lt;/p&gt;
&lt;h3 id=&quot;卸载-2&quot;&gt;卸载&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete -f samples/sleep/sleep.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;环境恢复&quot;&gt;环境恢复&lt;/h4&gt;
&lt;p&gt;检查当前的模式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get configmap istio -n istio-system -o yaml | grep -o &quot;mode: ALLOW_ANY&quot; | uniq
$ kubectl get configmap istio -n istio-system -o yaml | grep -o &quot;mode: REGISTRY_ONLY&quot; | uniq
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将模式从&lt;code&gt;ALLOW_ANY&lt;/code&gt;切换到&lt;code&gt;REGISTRY_ONLY&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g' | kubectl replace -n istio-system -f -
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将模式从&lt;code&gt;REGISTRY_ONLY&lt;/code&gt;切换到&lt;code&gt;ALLOW_ANY&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get configmap istio -n istio-system -o yaml | sed 's/mode: REGISTRY_ONLY/mode: ALLOW_ANY/g' | kubectl replace -n istio-system -f -
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;egress-tls-originationegress-tls源&quot;&gt;Egress TLS Origination(Egress TLS源)&lt;/h2&gt;
&lt;p&gt;本节展示如何通过配置istio来(对到外部服务的流量)初始化TLS。当原始流量为HTTP时，Istio会与外部服务建立HTTPS连接，即istio会加密到外部服务的请求。&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;sleep&lt;/code&gt;应用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取&lt;code&gt;sleep&lt;/code&gt;的pod名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建&lt;code&gt;ServiceEntry&lt;/code&gt; 和&lt;code&gt;VirtualService&lt;/code&gt;访问 &lt;code&gt;edition.cnn.com&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: edition-cnn-com
spec:
  hosts:
  - edition.cnn.com #外部服务URI
  ports:
  - number: 80     # HTTP访问
    name: http-port
    protocol: HTTP
  - number: 443    # HTTPS访问
    name: https-port
    protocol: HTTPS #指定外部服务为HTTPS协议
  resolution: DNS
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: edition-cnn-com
spec:
  hosts:
  - edition.cnn.com #外部服务URI
  tls: #非终结的TLS&amp;amp;HTTPS流量
  - match: #将edition.cnn.com:443的流量分发到edition.cnn.com:443
    - port: 443
      sniHosts:
      - edition.cnn.com
    route:
    - destination:
        host: edition.cnn.com
        port:
          number: 443
      weight: 100
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问外部服务，下面使用了&lt;code&gt;-L&lt;/code&gt;选项使请求端依照返回的重定向信息重新发起请求。第一个请求会发往&lt;code&gt;http://edition.cnn.com/politics&lt;/code&gt;，服务端会返回重定向信息，第二个请求会按照重定向信息发往&lt;code&gt;https://edition.cnn.com/politics&lt;/code&gt;。可以看到第一次是&lt;code&gt;HTTP&lt;/code&gt;访问，第二次是&lt;code&gt;HTTPS&lt;/code&gt;访问。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果没有上述VirtualService，也可以通过下面命令进行访问。此处应该是为了与下面例子结合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -sL -o /dev/null -D - http://edition.cnn.com/politics

HTTP/1.1 301 Moved Permanently
...
location: https://edition.cnn.com/politics
...

HTTP/2 200
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述过程会有两个弊端：上面的第一个HTTP访问显然是冗余的；如果在应用和&lt;code&gt;edition.cnn.com&lt;/code&gt; 之间存在攻击者，这样该攻击者就可以通过嗅探链路获取请求端执行的操作，存在安全风险。&lt;/p&gt;
&lt;p&gt;使用istio的TLS源可以解决如上问题。&lt;/p&gt;
&lt;h3 id=&quot;为egress流量配置tls源&quot;&gt;为Egress流量配置TLS源&lt;/h3&gt;
&lt;p&gt;重新定义 &lt;code&gt;ServiceEntry&lt;/code&gt; 和&lt;code&gt;VirtualService&lt;/code&gt; ，并增加&lt;code&gt;DestinationRule&lt;/code&gt;来发起TLS。此时&lt;code&gt;VirtualService&lt;/code&gt;会将HTTP请求流量从80端口重定向到&lt;code&gt;DestinationRule&lt;/code&gt;的443端口，然后由&lt;code&gt;DestinationRule&lt;/code&gt;来发起TLS。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry # serviceEntry跟前面配置一样
metadata:
  name: edition-cnn-com
spec:
  hosts:
  - edition.cnn.com #注册到注册中心的host。用于选择virtualService和DestinationRule
  ports:
  - number: 80
    name: http-port
    protocol: HTTP
  - number: 443
    name: https-port-for-tls-origination
    protocol: HTTPS
  resolution: DNS
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: edition-cnn-com #请求的hosts字段
spec:
  hosts:
  - edition.cnn.com #请求中的hosts字段内容
  http:
  - match:
    - port: 80 #后续将http流量通过destinationrule转换为https流量
    route:
    - destination:
        host: edition.cnn.com #此时定义了DestinationRule，会经过DestinationRule处理
        subset: tls-origination
        port:
          number: 443
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: edition-cnn-com
spec:
  host: edition.cnn.com #istio注册表中的服务
  subsets:
  - name: tls-origination
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
      portLevelSettings: #配置与上游服务edition.cnn.com的连接。即在443端口上使用tls SIMPLE进行连接
      - port:
          number: 443
        tls:
          mode: SIMPLE # initiates HTTPS when accessing edition.cnn.com
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向&lt;code&gt;http://edition.cnn.com/politics&lt;/code&gt;发送请求，可以看到此时会返回200，且不会经过重定向，相当于做了一个代理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -sL -o /dev/null -D - http://edition.cnn.com/politics
HTTP/1.1 200 OK
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然直接使用https进行访问也是可以的，与上面使用http进行访问的结果相同&lt;code&gt;kubectl exec -it $SOURCE_POD -c sleep -- curl -sL -o /dev/null -D - https://edition.cnn.com/politics&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;需要考虑的安全性问题&quot;&gt;需要考虑的安全性问题&lt;/h3&gt;
&lt;p&gt;由于应用和sidecar代理之间是没有加密。因此渗透到应用所在的node节点的攻击者仍然能够看到该节点上未加密的本地通信内容。对于安全性较高的场景，建议应用直接使用HTTPS。&lt;/p&gt;
&lt;h3 id=&quot;卸载-3&quot;&gt;卸载&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete serviceentry edition-cnn-com
$ kubectl delete virtualservice edition-cnn-com
$ kubectl delete destinationrule edition-cnn-com
$ kubectl delete -f samples/sleep/sleep.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;egress-网关&quot;&gt;Egress 网关&lt;/h2&gt;
&lt;p&gt;本节描述如何通过一个指定的egress网关访问外部服务。istio使用ingress和egress网关在服务网格边界配置负载均衡。一个ingress网关允许定义网格的入站点，egress网关的用法类似，定义了网格内流量的出站点。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;假设在一个安全要求比较高的组织中，所有离开服务网格的流量都要经过一个&lt;strong&gt;指定的节点&lt;/strong&gt;(&lt;em&gt;前面的egress访问都是在离开pod之后按照k8s方式访问，并没有指定必须经过某个节点&lt;/em&gt;)，这些节点会运行在指定的机器上，与运行应用的集群的节点分开。这些特定的节点会在出站流量上应用策略，且对这些节点的监控将更加严格。&lt;/p&gt;
&lt;p&gt;另外一个场景是集群中的应用所在的节点没有公网IP，因此网格内部的服务无法访问因特网。定义一个egress网关并为该网关所在的节点分配公网IP，这样流量就可以通过该节点访问公网服务。&lt;/p&gt;
&lt;h3 id=&quot;环境配置&quot;&gt;环境配置&lt;/h3&gt;
&lt;p&gt;创建sleep应用并获取Pod名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部署istio-egress网关&quot;&gt;部署Istio egress网关&lt;/h3&gt;
&lt;p&gt;校验是否已经部署istio egress网关&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get pod -l istio=egressgateway -n istio-system
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有部署，执行如下步骤部署egress网关&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ istioctl manifest apply -f cni-annotations.yaml --set values.global.istioNamespace=istio-system --set values.gateways.istio-ingressgateway.enabled=true --set values.gateways.istio-egressgateway.enabled=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9.2982456140351&quot;&gt;
&lt;p&gt;注意：apply的时候使用自己定制化的文件，否则系统会使用默认的profile，导致配置丢失！&lt;/p&gt;
&lt;p&gt;下面操作关于在&lt;code&gt;default&lt;/code&gt;命名空间中为egress网关创建destination rule，因此要求&lt;code&gt;sleep&lt;/code&gt;应用也部署在&lt;code&gt;default&lt;/code&gt;命名空间中。如果应用不在default命名空间中，将无法在&lt;a href=&quot;https://istio.io/docs/ops/best-practices/traffic-management/#cross-namespace-configuration&quot;&gt;destination rule查找路径&lt;/a&gt;找到destination rule，客户端请求将会失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;http流量的egress网关&quot;&gt;&lt;span id=&quot;jump&quot;&gt;HTTP流量的egress网关&lt;/span&gt;&lt;/h3&gt;
&lt;ol readability=&quot;16.815217391304&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;上面例子中，当网格内的客户端可以直接访问外部服务，此处将会创建一个egress网关，内部流量访问外部服务时会经过该网关。创建一个&lt;code&gt;ServiceEntry&lt;/code&gt;允许流量访问外部服务&lt;code&gt;edition.cnn.com&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: cnn
spec:
  hosts:
  - edition.cnn.com
  ports: #可以通过HTTP和HTTPS服务外部服务
  - number: 80
    name: http-port
    protocol: HTTP
  - number: 443
    name: https
    protocol: HTTPS
  resolution: DNS
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;校验请求能够发往http://edition.cnn.com/politics，此处的操作与上一节相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -sL -o /dev/null -D - http://edition.cnn.com/politics
HTTP/1.1 301 Moved Permanently
...

HTTP/2 200
...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;为&lt;code&gt;edition.cnn.com&lt;/code&gt;创建一个&lt;code&gt;Gateway&lt;/code&gt;，端口80，监听来自&lt;code&gt;edition.cnn.com:80&lt;/code&gt;的流量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-egressgateway
spec:
  selector:
    istio: egressgateway
  servers:
  - port: #监听来自edition.cnn.com:80的流量，
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - edition.cnn.com
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule #该DestinationRule没有定义任何规则，实际可以删除该DestinationRule，并删除下面VirtualService的&quot;subset: cnn&quot;一行
metadata:
  name: egressgateway-for-cnn
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local
  subsets:
  - name: cnn #下面VirtualService中会用到
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;定义&lt;code&gt;VirtualService&lt;/code&gt;，将流量从sidecar定向到egress网关，然后将流量从egress网关定向到外部服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: direct-cnn-through-egress-gateway
spec:
  hosts:
  - edition.cnn.com
  gateways: #列出应用路由规则的网关
  - istio-egressgateway
  - mesh #istio保留字段，表示网格中的所有sidecar，当忽略gateways字段时，默认会使用mesh，此处表示所有sidecar到edition.cnn.com的请求
  http: #采用http路由规则
  - match: #各个match是OR关系
    - gateways: #处理mesh网关，将来自mesh的edition.cnn.com:80请求发往istio-egressgateway.istio-system.svc.cluster.local:80
      - mesh
      port: 80
    route:
    - destination:
        host: istio-egressgateway.istio-system.svc.cluster.local
        subset: cnn #对应DestinationRule中的subset名，由于使用了subset，因此必须使用DestinationRule。删除该行后就可以不使用上面的DestinationRule
        port:
          number: 80
      weight: 100
  - match:
    - gateways:
      - istio-egressgateway #处理istio-egressgateway网关，将来自gateway edition.cnn.com:80的请求发往edition.cnn.com:80
      port: 80
    route:
    - destination:
        host: edition.cnn.com #该host就对应serviceEntry注册的服务地址
        port:
          number: 80
      weight: 100
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1.6884422110553&quot;&gt;
&lt;p&gt;发送HTTP请求&lt;a href=&quot;https://edition.cnn.com/politics&quot;&gt;http://edition.cnn.com/politics&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -sL -o /dev/null -D - http://edition.cnn.com/politics
HTTP/1.1 301 Moved Permanently
...

HTTP/2 200
...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3.9384615384615&quot;&gt;
&lt;p&gt;校验egress日志（需要&lt;a href=&quot;https://istio.io/docs/tasks/observability/logs/access-log/#enable-envoy-s-access-logging&quot;&gt;启用&lt;/a&gt;Envoy日志）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl logs -l istio=egressgateway -c istio-proxy -n istio-system | tail
[2020-08-25T14:55:49.810Z] &quot;GET /politics HTTP/2&quot; 301 - &quot;-&quot; &quot;-&quot; 0 0 1445 1444 &quot;10.80.3.231&quot; &quot;curl/7.64.0&quot; &quot;2151bde2-4382-4e2f-b088-e464943c2a9b&quot; &quot;edition.cnn.com&quot; &quot;151.101.1.67:80&quot; outbound|80||edition.cnn.com 10.80.3.232:51516 10.80.3.232:8080 10.80.3.231:38072 - -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本例中仍然实在sleep pod中执行HTTP请求，通过301重定向重新发送HTTPS请求，而上面规则中并没有将HTTPs流程转发给网关，因此从上面网关上看不到到443端口的流量，但可以在sleep的istio-proxy sidecar的日志中可以看到完整的流量信息，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[2020-08-25T14:55:33.114Z] &quot;GET /politics HTTP/1.1&quot; 301 - &quot;-&quot; &quot;-&quot; 0 0 310 310 &quot;-&quot; &quot;curl/7.64.0&quot; &quot;d57ddf5f-985b-431a-8766-7481b75dc486&quot; &quot;edition.cnn.com&quot; &quot;151.101.1.67:80&quot; outbound|80||edition.cnn.com 10.80.3.231:48390 151.101.65.67:80 10.80.3.231:44674 - default
[2020-08-25T14:55:33.439Z] &quot;- - -&quot; 0 - &quot;-&quot; &quot;-&quot; 906 1326852 5490 - &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;151.101.129.67:443&quot; outbound|443||edition.cnn.com 10.80.3.231:47044 151.101.65.67:443 10.80.3.231:42990 edition.cnn.com -
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;卸载-4&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete gateway istio-egressgateway
$ kubectl delete serviceentry cnn
$ kubectl delete virtualservice direct-cnn-through-egress-gateway
$ kubectl delete destinationrule egressgateway-for-cnn
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;https流量的egress-gateway&quot;&gt;&lt;span id=&quot;jump&quot;&gt;HTTPS流量的egress gateway&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;本节展示通过egress网关定向&lt;code&gt;HTTPS&lt;/code&gt;流量，。会使用到&lt;code&gt;ServiceEntry&lt;/code&gt;，一个egress &lt;code&gt;Gateway&lt;/code&gt;和一个&lt;code&gt;VirtualService&lt;/code&gt;。&lt;/p&gt;
&lt;ol readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;创建到&lt;code&gt;edition.cnn.com&lt;/code&gt;的&lt;code&gt;ServiceEntry&lt;/code&gt;，定义外部服务https://edition.cnn.com&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: cnn
spec:
  hosts:
  - edition.cnn.com
  ports:
  - number: 443
    name: tls
    protocol: TLS #protocol为TLS，用于非终结的流量
  resolution: DNS
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;protocol字段可以为&lt;code&gt;HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS&lt;/code&gt;其中之一，其中TLS 表示不会终止TLS连接，且连接会基于SNI首部进行路由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;校验可以通过&lt;code&gt;ServiceEntry&lt;/code&gt;访问https://edition.cnn.com/politics&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -sL -o /dev/null -D - https://edition.cnn.com/politics
HTTP/2 200
...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6.5&quot;&gt;
&lt;p&gt;为&lt;code&gt;edition.cnn.com&lt;/code&gt;创建egress &lt;code&gt;Gateway&lt;/code&gt;，一个destination rule和一个virtual service。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-egressgateway
spec:
  selector:
    istio: egressgateway
  servers:
  - port:
      number: 443
      name: tls
      protocol: TLS #该字段与serviceEntry的字段相同
    hosts:
    - edition.cnn.com
    tls:
      mode: PASSTHROUGH #透传模式，不在网关上终止TLS，由sidecar发起TLS
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: egressgateway-for-cnn
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local
  subsets:
  - name: cnn
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: direct-cnn-through-egress-gateway
spec:
  hosts:
  - edition.cnn.com
  gateways:
  - mesh
  - istio-egressgateway
  tls: #此处由http变为了tls
  - match:
    - gateways:
      - mesh
      port: 443
      sniHosts:
      - edition.cnn.com #基于SNI的路由
    route:
    - destination:
        host: istio-egressgateway.istio-system.svc.cluster.local
        subset: cnn
        port:
          number: 443
  - match:
    - gateways:
      - istio-egressgateway
      port: 443
      sniHosts:
      - edition.cnn.com #指定tls的SNI
    route:
    - destination:
        host: edition.cnn.com
        port:
          number: 443
      weight: 100
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由于TLS本身是加密的，无法像HTTP一样根据host首部字段进行路由管理，因此采用了SNI扩展。SNI位于TLS协商的client-hello阶段，作为client-hello的扩展字段存在，基于TLS SNI的路由与基于HTTP host首部字段的路由管理，在逻辑上是相同的。SNI也支持通配符模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1334952/202008/1334952-20200825110446619-299137861.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;访问https://edition.cnn.com/politics&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- curl -sL -o /dev/null -D - https://edition.cnn.com/politics
HTTP/2 200
...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;校验log&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl logs -l istio=egressgateway -n istio-system
...
[2020-06-02T09:06:43.152Z] &quot;- - -&quot; 0 - &quot;-&quot; &quot;-&quot; 906 1309129 1282 - &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;151.101.193.67:443&quot; outbound|443||edition.cnn.com 10.83.1.219:39574 10.83.1.219:443 10.80.3.25:35492 edition.cnn.com -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;卸载-5&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete serviceentry cnn
$ kubectl delete gateway istio-egressgateway
$ kubectl delete virtualservice direct-cnn-through-egress-gateway
$ kubectl delete destinationrule egressgateway-for-cnn
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安全考量&quot;&gt;安全考量&lt;/h3&gt;
&lt;p&gt;istio不能保证所有通过egress网关出去的流量的安全性，仅能保证通过sidecar代理的流量的安全性。如果攻击者绕过了sidecar代理，就可以不经过egress网关直接访问外部服务。此时，攻击者的行为不受istio的控制和监控。集群管理员或云供应商必须保证所有的流量都要经过egress网关。例如，集群管理员可以配置一个防火墙，拒绝所有非egress网关的流量。&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/network-policies/&quot;&gt;Kubernetes network policies&lt;/a&gt;也可以禁止所有非egress网关的流量。此外，集群管理员或云供应商可以配置网络来保证应用节点只能通过网关访问因特网，为了实现这种效果，需要阻止将公共IP分配给网关以外的pod，并配置NAT设备丢弃非egress网关的报文。&lt;/p&gt;
&lt;h3 id=&quot;使用kubernetes-network-policies&quot;&gt;使用Kubernetes network policies&lt;/h3&gt;
&lt;p&gt;本节展示如何创建一个&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/network-policies/&quot;&gt;Kubernetes network policy&lt;/a&gt;来防止绕过egress网关。为了测试网络策略，需要创建一个命名空间&lt;code&gt;test-egress&lt;/code&gt;，部署&lt;code&gt;sleep&lt;/code&gt;应用，并尝试向网关安全的外部服务发送请求。&lt;/p&gt;
&lt;p&gt;首先完成中的&lt;a href=&quot;https://istio.io/docs/tasks/traffic-management/egress/egress-gateway/#egress-gateway-for-https-traffic&quot;&gt;egress-gateway-for-https-traffic&lt;/a&gt;步骤，然后执行如下操作&lt;/p&gt;
&lt;ol readability=&quot;39.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建&lt;code&gt;test-egress&lt;/code&gt;命名空间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create namespace test-egress
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将&lt;code&gt;sleep&lt;/code&gt;部署到&lt;code&gt;test-egress&lt;/code&gt;命名空间中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -n test-egress -f samples/sleep/sleep.yaml
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;校验部署的pod不存在istio sidecar&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get pod $(kubectl get pod -n test-egress -l app=sleep -o jsonpath={.items..metadata.name}) -n test-egress
NAME                    READY   STATUS    RESTARTS   AGE
sleep-f8cbf5b76-g2t2l   1/1     Running   0          27s
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;从 &lt;code&gt;test-egress&lt;/code&gt; 命名空间中的&lt;code&gt;sleep&lt;/code&gt; pod向https://edition.cnn.com/politics 发送HTTPS请求，返回200成功&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $(kubectl get pod -n test-egress -l app=sleep -o jsonpath={.items..metadata.name}) -n test-egress -c sleep -- curl -s -o /dev/null -w &quot;%{http_code}\n&quot;  https://edition.cnn.com/politics
200
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在istio组件所在的命名空间创建标签，如果istio组件部署在&lt;code&gt;istio-system&lt;/code&gt;命名空间中，则操作方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl label namespace istio-system istio=system
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;给&lt;code&gt;kube-system&lt;/code&gt;命名空间打标签&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl label ns kube-system kube-system=true
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;部署一个&lt;code&gt;NetworkPolicy&lt;/code&gt;限制从&lt;code&gt;test-egress&lt;/code&gt;命名空间到&lt;code&gt;istio-system&lt;/code&gt;命名空间和&lt;code&gt;kube-system&lt;/code&gt; DNS服务的egress流量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ cat &amp;lt;&amp;lt;EOF | kubectl apply -n test-egress -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-egress-to-istio-system-and-kube-dns
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          kube-system: &quot;true&quot;
    ports:
    - protocol: UDP
      port: 53
  - to:
    - namespaceSelector:
        matchLabels:
          istio: system
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;重新发送HTTPS请求到https://edition.cnn.com/politics，此时由于network policy阻止了流量，请求会失败。由于&lt;code&gt;sleep&lt;/code&gt; Pod无法绕过&lt;code&gt;istio-egressgateway&lt;/code&gt;(&lt;em&gt;需要环境保证，如果环境上即使没有&lt;code&gt;istio-egressgateway&lt;/code&gt;也能访问外部服务，则此处可能会与预期不一样，本人使用的openshift环境无法测试这种场景&lt;/em&gt;)访问外部服务，唯一的方式是将流量定向到&lt;code&gt;istio-egressgateway&lt;/code&gt;上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $(kubectl get pod -n test-egress -l app=sleep -o jsonpath={.items..metadata.name}) -n test-egress -c sleep -- curl -v https://edition.cnn.com/politics
Hostname was NOT found in DNS cache
  Trying 151.101.65.67...
  Trying 2a04:4e42:200::323...
Immediate connect fail for 2a04:4e42:200::323: Cannot assign requested address
  Trying 2a04:4e42:400::323...
Immediate connect fail for 2a04:4e42:400::323: Cannot assign requested address
  Trying 2a04:4e42:600::323...
Immediate connect fail for 2a04:4e42:600::323: Cannot assign requested address
  Trying 2a04:4e42::323...
Immediate connect fail for 2a04:4e42::323: Cannot assign requested address
connect to 151.101.65.67 port 443 failed: Connection timed out
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;现在给&lt;code&gt;test-egress&lt;/code&gt;命名空间的&lt;code&gt;sleep&lt;/code&gt; pod注入istio sidecar代理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl label namespace test-egress istio-injection=enabled
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;重新在&lt;code&gt;test-egress&lt;/code&gt;命名空间中部署&lt;code&gt;sleep&lt;/code&gt; deployment&lt;/p&gt;
&lt;p&gt;openshift环境需要首先执行如下步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ cat &amp;lt;&amp;lt;EOF | oc -n test-egress create -f -
apiVersion: &quot;k8s.cni.cncf.io/v1&quot;
kind: NetworkAttachmentDefinition
metadata:
  name: istio-cni
EOF

$ oc adm policy add-scc-to-group privileged system:serviceaccounts:test-egress
$ oc adm policy add-scc-to-group anyuid system:serviceaccounts:test-egress
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部署&lt;code&gt;sleep&lt;/code&gt;应用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete deployment sleep -n test-egress
$ kubectl apply -f samples/sleep/sleep.yaml -n test-egress
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;校验&lt;code&gt;test-egress&lt;/code&gt;命名空间的sleep注入了istio sidecar&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get pod $(kubectl get pod -n test-egress -l app=sleep -o jsonpath={.items..metadata.name}) -n test-egress -o jsonpath='{.spec.containers[*].name}'
sleep istio-proxy
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建与&lt;code&gt;default&lt;/code&gt;命名空间中相同的destination rule，将流量定向到egress网关：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -n test-egress -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: egressgateway-for-cnn
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local #内部服务地址，不需要用serviceEntry
  subsets:
  - name: cnn
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;发送HTTPS请求到https://edition.cnn.com/politics：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $(kubectl get pod -n test-egress -l app=sleep -o jsonpath={.items..metadata.name}) -n test-egress -c sleep -- curl -s -o /dev/null -w &quot;%{http_code}\n&quot; https://edition.cnn.com/politics
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;校验egress网关代理的日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl logs -l istio=egressgateway -n istio-system
...
[2020-06-02T09:04:11.239Z] &quot;- - -&quot; 0 - &quot;-&quot; &quot;-&quot; 906 1309030 1606 - &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;151.101.1.67:443&quot; outbound|443||edition.cnn.com 10.83.1.219:56116 10.83.1.219:443 10.80.3.25:59032 edition.cnn.com -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;卸载网络策略&quot;&gt;卸载网络策略&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete -f samples/sleep/sleep.yaml -n test-egress
$ kubectl delete destinationrule egressgateway-for-cnn -n test-egress
$ kubectl delete networkpolicy allow-egress-to-istio-system-and-kube-dns -n test-egress
$ kubectl label namespace kube-system kube-system-
$ kubectl label namespace istio-system istio-
$ kubectl delete namespace test-egress
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;带tls源的egress网关文件挂载&quot;&gt;带TLS源的Egress网关(文件挂载)&lt;/h2&gt;
&lt;p&gt;在上一节的&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/13558508.html#jump&quot;&gt;HTTPS流量的egress gateway&lt;/a&gt;中展示了如何配置istio来实现对外部服务的流量发起TLS。&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/13558508.html#jump&quot;&gt;HTTP流量的egress网关&lt;/a&gt;中展示例子展示了如何配置istio来通过一个特定的egress网格服务来转发egress流量。本节的例子将结合这两个例子来描述如何配置一个egress网关来为到外部服务的流量发起TLS。&lt;/p&gt;
&lt;h3 id=&quot;部署-2&quot;&gt;部署&lt;/h3&gt;
&lt;p&gt;在default(已启用sidecar自动注入)命名空间下安装sleep&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取Pod名称&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建egress网关&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ istioctl install -f cni-annotations.yaml --set values.global.istioNamespace=istio-system --set values.gateways.istio-egressgateway.enabled=true  --set meshConfig.accessLogFile=&quot;/dev/stdout&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用一个egress网关发起tls&quot;&gt;使用一个egress网关发起TLS&lt;/h3&gt;
&lt;p&gt;本节描述如何使用于&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/13558508.html#jump&quot;&gt;HTTPS流量的egress gateway&lt;/a&gt;相同的方式发起TLS，但此处使用了一个egress网关。注意这种情况下，通过egress网关来发起TLS，而前面的例子中使用了sidecar发起TLS(curl时指定的是https://edition.cnn.com/politics)。&lt;/p&gt;
&lt;ol readability=&quot;19.64418938307&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;为&lt;code&gt;edition.cnn.com&lt;/code&gt;定义一个&lt;code&gt;ServiceEntry&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: cnn
spec:
  hosts:
  - edition.cnn.com
  ports:
  - number: 80
    name: http
    protocol: HTTP
  - number: 443
    name: https
    protocol: HTTPS
  resolution: DNS
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1.7695167286245&quot;&gt;
&lt;p&gt;校验可以通过创建的&lt;code&gt;ServiceEntry&lt;/code&gt;向&lt;a href=&quot;https://edition.cnn.com/politics&quot;&gt;http://edition.cnn.com/politics&lt;/a&gt;发送请求&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;${SOURCE_POD}&quot; -c sleep -- curl -sL -o /dev/null -D - http://edition.cnn.com/politics
HTTP/1.1 301 Moved Permanently
...
location: https://edition.cnn.com/politics
...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;为&lt;code&gt;edition.cnn.com&lt;/code&gt;创建一个&lt;code&gt;Gateway&lt;/code&gt;，监听&lt;code&gt;edition.cnn.com:80&lt;/code&gt;，以及一个destination rule来处理sidecar到egress网关的请求&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-egressgateway
spec:
  selector:
    istio: egressgateway
  servers: #配置网关暴露的主机信息
  - port:
      number: 80
      name: https-port-for-tls-origination
      protocol: HTTPS
    hosts:
    - edition.cnn.com
    tls: 
      mode: ISTIO_MUTUAL #与网关的连接使用ISTIO_MUTUAL模式
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: egressgateway-for-cnn
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local
  subsets:
  - name: cnn
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
      portLevelSettings: #基于单个端口的流量策略
      - port:
          number: 80
        tls: #与上游服务的连接设置，即到网关的tls配置，使用ISTIO_MUTUAL模式
          mode: ISTIO_MUTUAL
          sni: edition.cnn.com #表示TLS连接的服务端
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;定义一个&lt;code&gt;VirtualService&lt;/code&gt;将流量转移到egress网关，以及一个&lt;code&gt;DestinationRule&lt;/code&gt;来为到&lt;code&gt;edition.cnn.com&lt;/code&gt;的请求发起TLS。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: direct-cnn-through-egress-gateway
spec:
  hosts:
  - edition.cnn.com
  gateways:
  - istio-egressgateway
  - mesh
  http:
  - match:
    - gateways: #处理来自网格内部所有到edition.cnn.com的流量，发送到egress网关，并使用subset: cnn进行处理
      - mesh
      port: 80
    route:
    - destination:
        host: istio-egressgateway.istio-system.svc.cluster.local
        subset: cnn
        port:
          number: 80
      weight: 100
  - match:
    - gateways:
      - istio-egressgateway #处理来自网关istio-egressgateway的流量，直接发往edition.cnn.com
      port: 80
    route:
    - destination:
        host: edition.cnn.com
        port:
          number: 443
      weight: 100
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: originate-tls-for-edition-cnn-com
spec:
  host: edition.cnn.com
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
    portLevelSettings:
    - port:
        number: 443
      tls:
        mode: SIMPLE # 网关到edition.cnn.com使用SIMPLE模式，由于edition.cnn.com是网格外部服务，因此不能使用ISTIO_MUTUAL
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个过程为：网格内部HTTP流量-&amp;gt;istio-egressgateway(配置TLS)-&amp;gt;发起TLS连接&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.4464285714286&quot;&gt;
&lt;p&gt;发送&lt;code&gt;HTTP&lt;/code&gt;请求到&lt;a href=&quot;https://edition.cnn.com/politics&quot;&gt;http://edition.cnn.com/politics&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;${SOURCE_POD}&quot; -c sleep -- curl -sL -o /dev/null -D - http://edition.cnn.com/politics
HTTP/1.1 200 OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时的输出中不包含&lt;em&gt;301 Moved Permanently&lt;/em&gt; 消息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;校验&lt;code&gt;istio-egressgateway&lt;/code&gt; pod的日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl logs -l istio=egressgateway -c istio-proxy -n istio-system | tail
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到如下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[2020-08-25T15:16:17.840Z] &quot;GET /politics HTTP/2&quot; 200 - &quot;-&quot; &quot;-&quot; 0 1297688 7518 460 &quot;10.80.3.231&quot; &quot;curl/7.64.0&quot; &quot;2c71707e-3304-418c-840e-c37256c1ad41&quot; &quot;edition.cnn.com&quot; &quot;151.101.193.67:443&quot; outbound|443||edition.cnn.com 10.80.3.232:38522 10.80.3.232:8080 10.80.3.231:46064 edition.cnn.com -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;4.7138964577657&quot;&gt;
&lt;p&gt;各种资源的tls设置：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;资源&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5835694050991&quot;&gt;&lt;tr readability=&quot;4.9643705463183&quot;&gt;&lt;td&gt;virtualService&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#TLSRoute&quot;&gt;tls&lt;/a&gt;字段：用于非终结TLS&amp;amp;HTTPS流量的路由规则。通常使用ClientHello消息中的SNI值进行路由。TLS路由将会应用于端口名为&lt;code&gt;https -&lt;/code&gt; &lt;code&gt;tls-&lt;/code&gt;的平台服务，使用HTTPS/TLS协议的非终结网关端口(使用&lt;code&gt;passthrough&lt;/code&gt;TLS模式)，以及使用HTTPS/TLS协议的serviceEntry端口。注：不关联virtual service的&lt;code&gt;https-&lt;/code&gt;或&lt;code&gt;tls-&lt;/code&gt;端口的流量将被视为不透明的TCP流量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.5405405405405&quot;&gt;&lt;td&gt;DestinationRule&lt;/td&gt;
&lt;td&gt;DestinationRule主要对连接上游服务的tls进行配置，包含网格内的网关以及网格外的服务&lt;br/&gt;&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/destination-rule/#ClientTLSSettings&quot;&gt;ClientTLSSettings&lt;/a&gt;字段：连接上游的SSL/TLS相关设置&lt;br/&gt;&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/destination-rule/#TrafficPolicy-PortTrafficPolicy&quot;&gt;portLevelSettings&lt;/a&gt;字段：按照端口对上游服务进行设置，该字段包含了ClientTLSSettings字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.6176470588235&quot;&gt;&lt;td&gt;Gateway&lt;/td&gt;
&lt;td&gt;Gateway主要暴露的服务的tls进行配置，含ingress和egress，前者通常可以使用SIMPLE/MUTUAL模式，后者可以使用SIMPLE/MUTUAL/ISTIO_MUTUAL模式&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/gateway/#ServerTLSSettings&quot;&gt;&lt;br/&gt;ServerTLSSettings&lt;/a&gt;字段：控制服务端行为的TLS相关选项集。使用这些选项来控制是否应将所有http请求重定向到https，并使用&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/gateway/#ServerTLSSettings-TLSmode&quot;&gt;TLS模式&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;卸载-6&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete gateway istio-egressgateway
$ kubectl delete serviceentry cnn
$ kubectl delete virtualservice direct-cnn-through-egress-gateway
$ kubectl delete destinationrule originate-tls-for-edition-cnn-com
$ kubectl delete destinationrule egressgateway-for-cnn
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用egress网关发起mutual-tls&quot;&gt;使用egress网关发起mutual TLS&lt;/h3&gt;
&lt;p&gt;与前面章节类似，本节描述如何配置egress网关来向外部服务发起TLS，不同的是这次要使用mutual TLS(上面用的是SIMPLE模式)。&lt;/p&gt;
&lt;p&gt;在本例中首先需要：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成client和server证书&lt;/li&gt;
&lt;li&gt;部署支持mutual TLS协议的外部服务&lt;/li&gt;
&lt;li&gt;重新部署egress网关，使用mutual TLS证书&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后就是通过egress 网关发起TLS。&lt;/p&gt;
&lt;h4 id=&quot;生成client和server的证书和key&quot;&gt;生成client和server的证书和key&lt;/h4&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建根证书和私钥，用于签发服务证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=example Inc./CN=example.com' -keyout example.com.key -out example.com.crt
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;为 &lt;code&gt;my-nginx.mesh-external.svc.cluster.local&lt;/code&gt;创建证书和私钥&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ openssl req -out my-nginx.mesh-external.svc.cluster.local.csr -newkey rsa:2048 -nodes -keyout my-nginx.mesh-external.svc.cluster.local.key -subj &quot;/CN=my-nginx.mesh-external.svc.cluster.local/O=some organization&quot;
$ openssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 0 -in my-nginx.mesh-external.svc.cluster.local.csr -out my-nginx.mesh-external.svc.cluster.local.crt
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;生成client证书和私钥&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ openssl req -out client.example.com.csr -newkey rsa:2048 -nodes -keyout client.example.com.key -subj &quot;/CN=client.example.com/O=client organization&quot;
$ openssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 1 -in client.example.com.csr -out client.example.com.crt
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;部署mutual-tls-server&quot;&gt;部署mutual TLS server&lt;/h4&gt;
&lt;p&gt;为了模拟一个支持mutual TLS协议的外部服务，需要在kubernetes集群中部署一个NGINX服务，但该服务位于istio服务网格外，即位于一个没有启用istio sidecar代理注入的命名空间。&lt;/p&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建一个唯一istio网格外的命名空间，名为&lt;code&gt;mesh-external&lt;/code&gt;，该命名空间不启用sidecar自动注入。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create namespace mesh-external
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建kubernetes secret，包含服务端的证书和CA证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create -n mesh-external secret tls nginx-server-certs --key my-nginx.mesh-external.svc.cluster.local.key --cert my-nginx.mesh-external.svc.cluster.local.crt
$ kubectl create -n mesh-external secret generic nginx-ca-certs --from-file=example.com.crt
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;创建NGINX 服务的配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ cat &amp;lt;&amp;lt;\EOF &amp;gt; ./nginx.conf
events {
}

http {
  log_format main '$remote_addr - $remote_user [$time_local]  $status '
  '&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; '
  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
  access_log /var/log/nginx/access.log main;
  error_log  /var/log/nginx/error.log;

  server {
    listen 443 ssl;

    root /usr/share/nginx/html;
    index index.html;

    server_name my-nginx.mesh-external.svc.cluster.local;
    ssl_certificate /etc/nginx-server-certs/tls.crt;
    ssl_certificate_key /etc/nginx-server-certs/tls.key;
    ssl_client_certificate /etc/nginx-ca-certs/example.com.crt;
    ssl_verify_client on;
  }
}
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;创建一个kubernetes ConfigMap来保存NGINX服务的配置信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  namespace: mesh-external
  labels:
    run: my-nginx
spec:
  ports:
  - port: 443
    protocol: TCP
  selector:
    run: my-nginx
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx
  namespace: mesh-external
spec:
  selector:
    matchLabels:
      run: my-nginx
  replicas: 1
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
      - name: my-nginx
        image: nginx
        ports:
        - containerPort: 443
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx
          readOnly: true
        - name: nginx-server-certs
          mountPath: /etc/nginx-server-certs
          readOnly: true
        - name: nginx-ca-certs
          mountPath: /etc/nginx-ca-certs
          readOnly: true
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-configmap
      - name: nginx-server-certs
        secret:
          secretName: nginx-server-certs
      - name: nginx-ca-certs
        secret:
          secretName: nginx-ca-certs
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;使用client证书重新部署egress网关&quot;&gt;使用client证书重新部署egress网关&lt;/h4&gt;
&lt;ol readability=&quot;20&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建kubernetes secret，包含客户端证书和CA证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create -n istio-system secret tls nginx-client-certs --key client.example.com.key --cert client.example.com.crt
$ kubectl create -n istio-system secret generic nginx-ca-certs --from-file=example.com.crt
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;24&quot;&gt;
&lt;p&gt;更新&lt;code&gt;istio-egressgateway&lt;/code&gt; deployment来挂载创建的secret。创建如下&lt;code&gt;gateway-patch.json&lt;/code&gt;文件来给&lt;code&gt;istio-egressgateway&lt;/code&gt; deployment打补丁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;cat &amp;gt; gateway-patch.json &amp;lt;&amp;lt;EOF
[{
  &quot;op&quot;: &quot;add&quot;,
  &quot;path&quot;: &quot;/spec/template/spec/containers/0/volumeMounts/0&quot;,
  &quot;value&quot;: {
    &quot;mountPath&quot;: &quot;/etc/istio/nginx-client-certs&quot;,
    &quot;name&quot;: &quot;nginx-client-certs&quot;,
    &quot;readOnly&quot;: true
  }
},
{
  &quot;op&quot;: &quot;add&quot;,
  &quot;path&quot;: &quot;/spec/template/spec/volumes/0&quot;,
  &quot;value&quot;: {
  &quot;name&quot;: &quot;nginx-client-certs&quot;,
    &quot;secret&quot;: {
      &quot;secretName&quot;: &quot;nginx-client-certs&quot;,
      &quot;optional&quot;: true
    }
  }
},
{
  &quot;op&quot;: &quot;add&quot;,
  &quot;path&quot;: &quot;/spec/template/spec/containers/0/volumeMounts/1&quot;,
  &quot;value&quot;: {
    &quot;mountPath&quot;: &quot;/etc/istio/nginx-ca-certs&quot;,
    &quot;name&quot;: &quot;nginx-ca-certs&quot;,
    &quot;readOnly&quot;: true
  }
},
{
  &quot;op&quot;: &quot;add&quot;,
  &quot;path&quot;: &quot;/spec/template/spec/volumes/1&quot;,
  &quot;value&quot;: {
  &quot;name&quot;: &quot;nginx-ca-certs&quot;,
    &quot;secret&quot;: {
      &quot;secretName&quot;: &quot;nginx-ca-certs&quot;,
      &quot;optional&quot;: true
    }
  }
}]
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;使用如下命令使补丁生效&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl -n istio-system patch --type=json deploy istio-egressgateway -p &quot;$(cat gateway-patch.json)&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;校验加载到&lt;code&gt;istio-egressgateway&lt;/code&gt; pod中的密钥和证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -n istio-system &quot;$(kubectl -n istio-system get pods -l istio=egressgateway -o jsonpath='{.items[0].metadata.name}')&quot; -- ls -al /etc/istio/nginx-client-certs /etc/istio/nginx-ca-certs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tls.crt&lt;/code&gt; 和&lt;code&gt;tls.key&lt;/code&gt; 应该位于 &lt;code&gt;/etc/istio/nginx-client-certs&lt;/code&gt;目录中，而 &lt;code&gt;ca-chain.cert.pem&lt;/code&gt; 位于&lt;code&gt;/etc/istio/nginx-ca-certs&lt;/code&gt;目录中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;配置egress流量的mutual-tls源&quot;&gt;配置egress流量的mutual TLS源&lt;/h4&gt;
&lt;ol readability=&quot;15.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;为&lt;code&gt;my-nginx.mesh-external.svc.cluster.local:443&lt;/code&gt;创建一个egress Gateway，以及destination rules和virtual service来将流量转发到egress网关上，并通过该egress网关转发给外部服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-egressgateway
spec:
  selector:
    istio: egressgateway
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - my-nginx.mesh-external.svc.cluster.local #暴露给网格内部服务地址，使用ISTIO_MUTUAL进行交互
    tls:
      mode: ISTIO_MUTUAL
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule #处理网格内部pod到网关的流量
metadata:
  name: egressgateway-for-nginx
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local
  subsets:
  - name: nginx
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
      portLevelSettings: #连接的上游服务属性
      - port:
          number: 443
        tls:
          mode: ISTIO_MUTUAL
          sni: my-nginx.mesh-external.svc.cluster.local
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;定义一个VirtualService将流量转移到egress网关&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: direct-nginx-through-egress-gateway
spec:
  hosts:
  - my-nginx.mesh-external.svc.cluster.local
  gateways:
  - istio-egressgateway
  - mesh
  http: #内部流量采用http协议，由网关进行mutual tls协商
  - match:
    - gateways:
      - mesh
      port: 80
    route:
    - destination:
        host: istio-egressgateway.istio-system.svc.cluster.local
        subset: nginx
        port:
          number: 443
      weight: 100
  - match:
    - gateways:
      - istio-egressgateway
      port: 443
    route:
    - destination:
        host: my-nginx.mesh-external.svc.cluster.local #外部服务地址
        port:
          number: 443
      weight: 100
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;添加一个&lt;code&gt;DestinationRule&lt;/code&gt;来发起TLS&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -n istio-system -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule #处理网关到外部服务的流量
metadata:
  name: originate-mtls-for-nginx
spec:
  host: my-nginx.mesh-external.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
    portLevelSettings:
    - port:
        number: 443
      tls:
        mode: MUTUAL #使用MUTUAL模式连接外部服务，证书位于网关pod中
        clientCertificate: /etc/istio/nginx-client-certs/tls.crt
        privateKey: /etc/istio/nginx-client-certs/tls.key
        caCertificates: /etc/istio/nginx-ca-certs/example.com.crt
        sni: my-nginx.mesh-external.svc.cluster.local
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;发送HTTP请求到&lt;code&gt;http://my-nginx.mesh-external.svc.cluster.local&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec &quot;$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})&quot; -c sleep -- curl -s http://my-nginx.mesh-external.svc.cluster.local
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;校验&lt;code&gt;istio-egressgateway&lt;/code&gt; pod的日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl logs -l istio=egressgateway -n istio-system | grep 'my-nginx.mesh-external.svc.cluster.local' | grep HTTP
[2020-08-26T08:26:15.054Z] &quot;GET / HTTP/1.1&quot; 200 - &quot;-&quot; &quot;-&quot; 0 612 4 4 &quot;10.80.3.231&quot; &quot;curl/7.64.0&quot; &quot;e8bf12bd-9c39-409e-a837-39afc151fc7e&quot; &quot;my-nginx.mesh-external.svc.cluster.local&quot; &quot;10.80.2.14:443&quot; outbound|443||my-nginx.mesh-external.svc.cluster.local 10.80.2.15:56608 10.80.2.15:8443 10.80.3.231:50962 my-nginx.mesh-external.svc.cluster.local -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;卸载-7&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete secret nginx-server-certs nginx-ca-certs -n mesh-external
$ kubectl delete secret istio-egressgateway-certs istio-egressgateway-ca-certs -n istio-system
$ kubectl delete configmap nginx-configmap -n mesh-external
$ kubectl delete service my-nginx -n mesh-external
$ kubectl delete deployment my-nginx -n mesh-external
$ kubectl delete namespace mesh-external
$ kubectl delete gateway istio-egressgateway
$ kubectl delete virtualservice direct-nginx-through-egress-gateway
$ kubectl delete destinationrule -n istio-system originate-mtls-for-nginx
$ kubectl delete destinationrule egressgateway-for-nginx

$ rm example.com.crt example.com.key my-nginx.mesh-external.svc.cluster.local.crt my-nginx.mesh-external.svc.cluster.local.key my-nginx.mesh-external.svc.cluster.local.csr client.example.com.crt client.example.com.csr client.example.com.key

$ rm ./nginx.conf
$ rm ./gateway-patch.json
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete service sleep
$ kubectl delete deployment sleep
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;带tls源的egress网关sds&quot;&gt;带TLS源的Egress网关(SDS)&lt;/h2&gt;
&lt;p&gt;本节展示如何通过配置一个egress网关来为到外部服务的流量发起TLS。使用&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret#secret-discovery-service-sds&quot;&gt;Secret Discovery Service (SDS)&lt;/a&gt;来配置私钥，服务证书以及根证书(上一节中使用文件挂载方式来管理证书)。&lt;/p&gt;
&lt;h3 id=&quot;部署-3&quot;&gt;部署&lt;/h3&gt;
&lt;p&gt;部署sleep应用，并获取其Pod名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;egress网关使用sds发起tls&quot;&gt;egress网关使用SDS发起TLS&lt;/h3&gt;
&lt;h4 id=&quot;生成ca和server证书和密钥&quot;&gt;生成CA和server证书和密钥&lt;/h4&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建根证书和私钥来签署服务的证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=example Inc./CN=example.com' -keyout example.com.key -out example.com.crt
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;为 &lt;code&gt;my-nginx.mesh-external.svc.cluster.local&lt;/code&gt;创建证书和私钥&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ openssl req -out my-nginx.mesh-external.svc.cluster.local.csr -newkey rsa:2048 -nodes -keyout my-nginx.mesh-external.svc.cluster.local.key -subj &quot;/CN=my-nginx.mesh-external.svc.cluster.local/O=some organization&quot;
$ openssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 0 -in my-nginx.mesh-external.svc.cluster.local.csr -out my-nginx.mesh-external.svc.cluster.local.crt
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;部署一个simple-模式的tls服务&quot;&gt;部署一个simple 模式的TLS服务&lt;/h4&gt;
&lt;p&gt;下面的操作与使用文件挂载相同，部署一个NGINX服务&lt;/p&gt;
&lt;ol readability=&quot;10&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建istio网格外的命名空间&lt;code&gt;mesh-external&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create namespace mesh-external
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建kubernetes secret来保存服务的证书和CA证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create -n mesh-external secret tls nginx-server-certs --key my-nginx.mesh-external.svc.cluster.local.key --cert my-nginx.mesh-external.svc.cluster.local.crt
$ kubectl create -n mesh-external secret generic nginx-ca-certs --from-file=example.com.crt
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;创建NGINX服务的配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ cat &amp;lt;&amp;lt;\EOF &amp;gt; ./nginx.conf
events {
}

http {
  log_format main '$remote_addr - $remote_user [$time_local]  $status '
  '&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; '
  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
  access_log /var/log/nginx/access.log main;
  error_log  /var/log/nginx/error.log;

  server {
    listen 443 ssl;

    root /usr/share/nginx/html;
    index index.html;

    server_name my-nginx.mesh-external.svc.cluster.local;
    ssl_certificate /etc/nginx-server-certs/tls.crt;
    ssl_certificate_key /etc/nginx-server-certs/tls.key;
    ssl_client_certificate /etc/nginx-ca-certs/example.com.crt;
    ssl_verify_client off; # simple TLS下server不需要校验client的证书
  }
}
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建一个kubernetes ConfigMap来保存NGINX服务的配置信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create configmap nginx-configmap -n mesh-external --from-file=nginx.conf=./nginx.conf
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;部署NGINX服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  namespace: mesh-external
  labels:
    run: my-nginx
spec:
  ports:
  - port: 443
    protocol: TCP
  selector:
    run: my-nginx
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx
  namespace: mesh-external
spec:
  selector:
    matchLabels:
      run: my-nginx
  replicas: 1
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
      - name: my-nginx
        image: nginx
        ports:
        - containerPort: 443
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx
          readOnly: true
        - name: nginx-server-certs
          mountPath: /etc/nginx-server-certs
          readOnly: true
        - name: nginx-ca-certs
          mountPath: /etc/nginx-ca-certs
          readOnly: true
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-configmap
      - name: nginx-server-certs
        secret:
          secretName: nginx-server-certs
      - name: nginx-ca-certs
        secret:
          secretName: nginx-ca-certs
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;为egress流量发起simple-tls&quot;&gt;为egress流量发起simple TLS&lt;/h4&gt;
&lt;ol readability=&quot;21&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;创建一个kubernetes Secret来保存egress网格发起TLS使用的CA证书，由于使用的是SIMPLE模式，因此无需客户端证书，仅对ca证书实现SDS，后续在网关的destinationRule中使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create secret generic client-credential-cacert --from-file=ca.crt=example.com.crt -n istio-system
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，Istio-only-CA证书的secret名称必须以-cacert结尾，并且必须在与部署的Istio相同的命名空间(默认为&lt;code&gt;Istio-system&lt;/code&gt;)中创建该secret。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;secret名称不应该以&lt;code&gt;istio&lt;/code&gt;或&lt;code&gt;prometheus&lt;/code&gt;开头，且secret不能包含&lt;code&gt;token&lt;/code&gt;字段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的配置除最后一个destinationRule外，其余配置都与上一节相同&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;为&lt;code&gt;my-nginx.mesh-external.svc.cluster.local:443&lt;/code&gt;创建一个egress Gateway，以及destination rules和virtual service来将流量转发到egress网关上，并通过该egress网关转发给外部服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-egressgateway
spec:
  selector:
    istio: egressgateway
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - my-nginx.mesh-external.svc.cluster.local
    tls:
      mode: ISTIO_MUTUAL
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: egressgateway-for-nginx
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local
  subsets:
  - name: nginx
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
      portLevelSettings:
      - port:
          number: 443
        tls:
          mode: ISTIO_MUTUAL
          sni: my-nginx.mesh-external.svc.cluster.local
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;定义一个VirtualService将流量转移到egress网关&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: direct-nginx-through-egress-gateway
spec:
  hosts:
  - my-nginx.mesh-external.svc.cluster.local
  gateways:
  - istio-egressgateway
  - mesh
  http:
  - match:
    - gateways:
      - mesh
      port: 80
    route:
    - destination:
        host: istio-egressgateway.istio-system.svc.cluster.local
        subset: nginx
        port:
          number: 443
      weight: 100
  - match:
    - gateways:
      - istio-egressgateway
      port: 443
    route:
    - destination:
        host: my-nginx.mesh-external.svc.cluster.local
        port:
          number: 443
      weight: 100
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;添加一个&lt;code&gt;DestinationRule&lt;/code&gt;来发起TLS&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -n istio-system -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: originate-tls-for-nginx
spec:
  host: my-nginx.mesh-external.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
    portLevelSettings:
    - port:
        number: 443
      tls:
        mode: SIMPLE
        credentialName: client-credential # 对应前面创建的包含ca证书的secret client-credential-cacert，但此时不带&quot;-cacert&quot;后缀
        sni: my-nginx.mesh-external.svc.cluster.local #网格外部服务
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;发送一个HTTP请求到 &lt;code&gt;http://my-nginx.mesh-external.svc.cluster.local&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec &quot;$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})&quot; -c sleep -- curl -s http://my-nginx.mesh-external.svc.cluster.local
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;检查&lt;code&gt;istio-egressgateway&lt;/code&gt;中的访问日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl logs -l istio=egressgateway -n istio-system | grep 'my-nginx.mesh-external.svc.cluster.local' | grep HTTP
[2020-08-26T12:26:09.316Z] &quot;GET / HTTP/1.1&quot; 200 - &quot;-&quot; &quot;-&quot; 0 612 3 3 &quot;10.80.3.231&quot; &quot;curl/7.64.0&quot; &quot;67803676-5617-4e12-a14a-5cef95ea2e87&quot; &quot;my-nginx.mesh-external.svc.cluster.local&quot; &quot;10.80.2.19:443&quot; outbound|443||my-nginx.mesh-external.svc.cluster.local 10.80.2.15:40754 10.80.2.15:8443 10.80.3.231:57626 my-nginx.mesh-external.svc.cluster.local -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;卸载-8&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete destinationrule originate-tls-for-nginx -n istio-system
$ kubectl delete virtualservice direct-nginx-through-egress-gateway
$ kubectl delete destinationrule egressgateway-for-nginx
$ kubectl delete gateway istio-egressgateway
$ kubectl delete secret client-credential-cacert -n istio-system
$ kubectl delete service my-nginx -n mesh-external
$ kubectl delete deployment my-nginx -n mesh-external
$ kubectl delete configmap nginx-configmap -n mesh-external
$ kubectl delete secret nginx-server-certs nginx-ca-certs -n mesh-external
$ kubectl delete namespace mesh-external
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ rm example.com.crt example.com.key my-nginx.mesh-external.svc.cluster.local.crt my-nginx.mesh-external.svc.cluster.local.key my-nginx.mesh-external.svc.cluster.local.csr
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ rm ./nginx.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;egress网关使用sds发起mutual-tls&quot;&gt;egress网关使用SDS发起mutual TLS&lt;/h3&gt;
&lt;h4 id=&quot;创建客户端和服务端证书和密钥&quot;&gt;创建客户端和服务端证书和密钥&lt;/h4&gt;
&lt;p&gt;下面操作跟前面一样，创建CA和客户端，服务端证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=example Inc./CN=example.com' -keyout example.com.key -out example.com.crt

$ openssl req -out my-nginx.mesh-external.svc.cluster.local.csr -newkey rsa:2048 -nodes -keyout my-nginx.mesh-external.svc.cluster.local.key -subj &quot;/CN=my-nginx.mesh-external.svc.cluster.local/O=some organization&quot;
$ openssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 0 -in my-nginx.mesh-external.svc.cluster.local.csr -out my-nginx.mesh-external.svc.cluster.local.crt

$ openssl req -out client.example.com.csr -newkey rsa:2048 -nodes -keyout client.example.com.key -subj &quot;/CN=client.example.com/O=client organization&quot;
$ openssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 1 -in client.example.com.csr -out client.example.com.crt
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;部署一个mutual-tls服务端&quot;&gt;部署一个mutual TLS服务端&lt;/h4&gt;
&lt;p&gt;下面的配置也跟之前一样&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create namespace mesh-external
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create -n mesh-external secret tls nginx-server-certs --key my-nginx.mesh-external.svc.cluster.local.key --cert my-nginx.mesh-external.svc.cluster.local.crt
$ kubectl create -n mesh-external secret generic nginx-ca-certs --from-file=example.com.crt
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ cat &amp;lt;&amp;lt;\EOF &amp;gt; ./nginx.conf
events {
}

http {
  log_format main '$remote_addr - $remote_user [$time_local]  $status '
  '&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; '
  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
  access_log /var/log/nginx/access.log main;
  error_log  /var/log/nginx/error.log;

  server {
    listen 443 ssl;

    root /usr/share/nginx/html;
    index index.html;

    server_name my-nginx.mesh-external.svc.cluster.local;
    ssl_certificate /etc/nginx-server-certs/tls.crt;
    ssl_certificate_key /etc/nginx-server-certs/tls.key;
    ssl_client_certificate /etc/nginx-ca-certs/example.com.crt;
    ssl_verify_client on; # mutual TLS下的server会校验client的证书
  }
}
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create configmap nginx-configmap -n mesh-external --from-file=nginx.conf=./nginx.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  namespace: mesh-external
  labels:
    run: my-nginx
spec:
  ports:
  - port: 443
    protocol: TCP
  selector:
    run: my-nginx
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx
  namespace: mesh-external
spec:
  selector:
    matchLabels:
      run: my-nginx
  replicas: 1
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
      - name: my-nginx
        image: nginx
        ports:
        - containerPort: 443
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx
          readOnly: true
        - name: nginx-server-certs
          mountPath: /etc/nginx-server-certs
          readOnly: true
        - name: nginx-ca-certs
          mountPath: /etc/nginx-ca-certs
          readOnly: true
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-configmap
      - name: nginx-server-certs
        secret:
          secretName: nginx-server-certs
      - name: nginx-ca-certs
        secret:
          secretName: nginx-ca-certs
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置egress流量使用sds发起mutual-tls&quot;&gt;配置egress流量使用SDS发起mutual TLS&lt;/h4&gt;
&lt;ol readability=&quot;14&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;创建一个kubernetes secret来保存客户端证书和ca证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create secret -n istio-system generic client-credential --from-file=tls.key=client.example.com.key \
  --from-file=tls.crt=client.example.com.crt --from-file=ca.crt=example.com.crt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用SDS的secret名称跟上一节的要求一样，部署到istio所在的命名空间，且名称不能以&lt;code&gt;istio&lt;/code&gt;和&lt;code&gt;prometheus&lt;/code&gt;开头，不能包含&lt;code&gt;token&lt;/code&gt;字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;为&lt;code&gt;my-nginx.mesh-external.svc.cluster.local:443&lt;/code&gt;创建&lt;code&gt;Gateway&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-egressgateway
spec:
  selector:
    istio: egressgateway
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - my-nginx.mesh-external.svc.cluster.local
    tls:
      mode: ISTIO_MUTUAL
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: egressgateway-for-nginx
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local
  subsets:
  - name: nginx
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
      portLevelSettings:
      - port:
          number: 443
        tls:
          mode: ISTIO_MUTUAL
          sni: my-nginx.mesh-external.svc.cluster.local
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建&lt;code&gt;VirtualService&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: direct-nginx-through-egress-gateway
spec:
  hosts:
  - my-nginx.mesh-external.svc.cluster.local
  gateways:
  - istio-egressgateway
  - mesh
  http:
  - match:
    - gateways:
      - mesh
      port: 80
    route:
    - destination:
        host: istio-egressgateway.istio-system.svc.cluster.local
        subset: nginx
        port:
          number: 443
      weight: 100
  - match:
    - gateways:
      - istio-egressgateway
      port: 443
    route:
    - destination:
        host: my-nginx.mesh-external.svc.cluster.local
        port:
          number: 443
      weight: 100
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;与前面不同点就在该&lt;code&gt;DestinationRule&lt;/code&gt;中的&lt;code&gt;credentialName&lt;/code&gt;字段，包含了前面创建的证书&lt;code&gt;client-credential&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -n istio-system -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: originate-mtls-for-nginx
spec:
  host: my-nginx.mesh-external.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
    portLevelSettings:
    - port:
        number: 443
      tls:
        mode: MUTUAL
        credentialName: client-credential # this must match the secret created earlier to hold client certs
        sni: my-nginx.mesh-external.svc.cluster.local
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;发送请求并校验egressgateway pod的日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec &quot;$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})&quot; -c sleep -- curl -s http://my-nginx.mesh-external.svc.cluster.local
$ kubectl logs -l istio=egressgateway -n istio-system | grep 'my-nginx.mesh-external.svc.cluster.local' | grep HTTP
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;卸载-9&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete secret nginx-server-certs nginx-ca-certs -n mesh-external
$ kubectl delete secret client-credential -n istio-system
$ kubectl delete configmap nginx-configmap -n mesh-external
$ kubectl delete service my-nginx -n mesh-external
$ kubectl delete deployment my-nginx -n mesh-external
$ kubectl delete namespace mesh-external
$ kubectl delete gateway istio-egressgateway
$ kubectl delete virtualservice direct-nginx-through-egress-gateway
$ kubectl delete destinationrule -n istio-system originate-mtls-for-nginx
$ kubectl delete destinationrule egressgateway-for-nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ rm example.com.crt example.com.key my-nginx.mesh-external.svc.cluster.local.crt my-nginx.mesh-external.svc.cluster.local.key my-nginx.mesh-external.svc.cluster.local.csr client.example.com.crt client.example.com.csr client.example.com.key
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ rm ./nginx.conf
$ rm ./gateway-patch.json
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete service sleep
$ kubectl delete deployment sleep
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用通配符主机的egress&quot;&gt;使用通配符主机的egress&lt;/h2&gt;
&lt;p&gt;上两节中为网关配置了特定的主机名，如 &lt;code&gt;edition.cnn.com&lt;/code&gt;。本节将展示如何为egress流量配置位于同域的一组主机，如&lt;code&gt;*.wikipedia.org&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;背景说明&quot;&gt;背景说明&lt;/h3&gt;
&lt;p&gt;假设要在istio上为所有语言的&lt;code&gt;wikipedia.org&lt;/code&gt;站点启用egress流量，每个特定语言的&lt;code&gt;wikipedia.org&lt;/code&gt;站点都有其各自的主机名，如&lt;code&gt;en.wikipedia.org&lt;/code&gt; 和&lt;code&gt;de.wikipedia.org&lt;/code&gt;分别表示英文和德文。此时可能会希望为所有的Wikipedia egress流量配置相同的参数，而不需要为每种语言的站点单独指定。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原文中用于展示的站点为&lt;code&gt;*.wikipedia.org&lt;/code&gt;，但鉴于这类站点在国内无法访问，故修改为&lt;code&gt;*.baidu.com&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;部署-4&quot;&gt;部署&lt;/h3&gt;
&lt;p&gt;部署sleep应用并获取POD名称&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置到通配符主机的直接流量&quot;&gt;配置到通配符主机的直接流量&lt;/h3&gt;
&lt;p&gt;首先，为了简化场景，创建一个带通配符主机的&lt;code&gt;ServiceEntry&lt;/code&gt;，并直接访问服务。当直接调用服务时(不经过egress网关)，通配符主机的配置与其他主机并没有什么不同(只是对同一域中的主机的服务更加方便)。&lt;/p&gt;
&lt;p&gt;为&lt;code&gt;*.baidu.com&lt;/code&gt;定义一个&lt;code&gt;ServiceEntry&lt;/code&gt;和相应的&lt;code&gt;VirtualSevice&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: baidu
spec:
  hosts:
  - &quot;*.baidu.com&quot; #通配符主机
  ports:
  - number: 443
    name: tls
    protocol: TLS
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: baidu
spec:
  hosts:
  - &quot;*.baidu.com&quot;
  tls:
  - match:
    - port: 443
      sniHosts:
      - &quot;*.baidu.com&quot;
    route:
    - destination:
        host: &quot;*.baidu.com&quot;
        port:
          number: 443
EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送请求给https://map.baidu.com/和https://fanyi.baidu.com/:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec -it $SOURCE_POD -c sleep -- sh -c 'curl -s https://map.baidu.com/ | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;; curl -s https://fanyi.baidu.com/ | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;'
&amp;lt;title&amp;gt;百度地图&amp;lt;/title&amp;gt;
&amp;lt;title&amp;gt;百度翻译-200种语言互译、沟通全世界！&amp;lt;/title&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以不使用VirtualService&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;卸载-10&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete serviceentry baidu
$ kubectl delete virtualservice baidu
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置到通配符主机的egress网关流量&quot;&gt;配置到通配符主机的egress网关流量&lt;/h3&gt;
&lt;p&gt;通过egress网关访问通配符主机的配置取决于通配符域集是否由一个公共主机来提供服务。例如&lt;em&gt;*.wikipedia.org&lt;/em&gt;，所有指定语言的站点都由&lt;em&gt;*wikipedia.org&lt;/em&gt;的某一个服务端提供服务，这样就可以将流量路由到任何&lt;em&gt;*.wikipedia.org&lt;/em&gt;站点对应的IP(包括&lt;em&gt;www.wikipedia.org&lt;/em&gt;)。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于map.baidu.com和fanyi.baidu.com的服务并不是由www.baidu.com对应的某个IP服务的(可以使用nslookup或dig命令查看)，因此无法用于测试本场景，下面为官网内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般情况下，如果一个通配符的所有域名不是由一个托管服务器提供服务的，则需要更复杂的配置。&lt;/p&gt;
&lt;h4 id=&quot;单个主机服务器的通配符配置&quot;&gt;单个主机服务器的通配符配置&lt;/h4&gt;
&lt;p&gt;当一个服务端服务所有的通配符主机时，对使用egress网关访问通配符主机的配置与访问非通配符主机的配置类似。&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;为&lt;code&gt;*.wikipedia.org,&lt;/code&gt;创建一个egress &lt;code&gt;Gateway&lt;/code&gt;，destination rule和一个virtual service，将流量导入egress网关，并通过egress网关访问外部服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$  kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-egressgateway
spec:
  selector:
    istio: egressgateway
  servers:
  - port:
      number: 443
      name: tls
      protocol: TLS
    hosts:
    - &quot;*.wikipedia.org&quot;
    tls:
      mode: PASSTHROUGH #由网格内部发起https请求，非终结TLS
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: egressgateway-for-wikipedia
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local
  subsets:
    - name: wikipedia
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: direct-wikipedia-through-egress-gateway
spec:
  hosts:
  - &quot;*.wikipedia.org&quot;
  gateways:
  - mesh
  - istio-egressgateway
  tls: #网格内部的TLS流量处理
  - match:
    - gateways:
      - mesh
      port: 443
      sniHosts:
      - &quot;*.wikipedia.org&quot;
    route:
    - destination:
        host: istio-egressgateway.istio-system.svc.cluster.local
        subset: wikipedia
        port:
          number: 443
      weight: 100
  - match:
    - gateways:
      - istio-egressgateway
      port: 443
      sniHosts:
      - &quot;*.wikipedia.org&quot;
    route:
    - destination:
        host: www.wikipedia.org #将流量从网格传给外部服务
        port:
          number: 443
      weight: 100
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;为目的服务www.wikipedia.com创建&lt;code&gt;ServiceEntry&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: www-wikipedia
spec:
  hosts:
  - www.wikipedia.org
  ports:
  - number: 443
    name: tls
    protocol: TLS
  resolution: DNS
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;发送请求给https://map.baidu.com/和https://fanyi.baidu.com/:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it $SOURCE_POD -c sleep -- sh -c 'curl -s https://en.wikipedia.org/wiki/Main_Page | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;; curl -s https://de.wikipedia.org/wiki/Wikipedia:Hauptseite | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;'
&amp;lt;title&amp;gt;Wikipedia, the free encyclopedia&amp;lt;/title&amp;gt;
&amp;lt;title&amp;gt;Wikipedia – Die freie Enzyklopädie&amp;lt;/title&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;卸载-11&quot;&gt;卸载&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete serviceentry www-wikipedia
$ kubectl delete gateway istio-egressgateway
$ kubectl delete virtualservice direct-wikipedia-through-egress-gateway
$ kubectl delete destinationrule egressgateway-for-wikipedia
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;任意域的通配符配置&quot;&gt;任意域的通配符配置&lt;/h4&gt;
&lt;p&gt;上一节中的配置之所以能够生效，是因为任何一个&lt;em&gt;wikipedia.org&lt;/em&gt;服务端都可以服务所有的&lt;em&gt;*.wikipedia.org&lt;/em&gt;站点。然有些情况下不是这样的，例如有可能希望访问更加通用的域，如&lt;code&gt;.com&lt;/code&gt;或&lt;code&gt;.org&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在istio网关上配置到任意通配符的域会带来挑战，上一节中直接将流量传递给了 &lt;em&gt;www.wikipedia.org&lt;/em&gt;(直接配置到了网关上)。受限于&lt;a href=&quot;https://www.envoyproxy.io/&quot;&gt;Envoy&lt;/a&gt;(默认的istio egress网关代理)，网关并不知道接收到的请求中的任意主机的IP地址。Envoy会将流量路由到&lt;strong&gt;预定义的主机&lt;/strong&gt;，&lt;strong&gt;预定义的IP地址&lt;/strong&gt;或&lt;strong&gt;请求中的原始目的IP地址&lt;/strong&gt;。在网关场景下，由于请求会首先被路由到egress网关上，因此会丢失请求中的原始目的IP地址，并将目的IP地址替换为网关的IP地址，最终会导致基于Envoy的istio网关无法路由到没有进行预配置的任意主机，进而导致无法为任意通配符域执行流量控制。&lt;/p&gt;
&lt;p&gt;为了给HTTPS和TLS启用流量控制，需要额外部署一个SNI转发代理。Envoy会将到通配符域的请求路由到SNI转发代理，然后将请求转发到SNI中指定的目的地。&lt;/p&gt;
&lt;p&gt;使用SNI代理和相关组件的egress网关架构如下，由于Envoy无法处理任意通配符的主机，因此需要转发到SNI代理上进行SNI的路由处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1334952/202008/1334952-20200827105838226-1820408330.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面将展示如何重新部署egress网关来使用SNI代理，并配置istio通过网关路由HTTPS流量到任意通配符域。&lt;/p&gt;
&lt;h5 id=&quot;配置egress网关的sni代理&quot;&gt;配置egress网关的SNI代理&lt;/h5&gt;
&lt;p&gt;本节中将在标准的istio Envoy代理之外部署为egress网关部署一个SNI代理。本例中使用Nginx作为SNI代理，该SNI代理将会监听8443端口，然后将流量转发到443端口。&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;为Nginx SNI代理创建配置文件。注意&lt;code&gt;server&lt;/code&gt;下的&lt;code&gt;listen&lt;/code&gt;指令为8443，&lt;code&gt;proxy_pass&lt;/code&gt;指令使用&lt;code&gt;ssl_preread_server_name&lt;/code&gt;，端口443以及将&lt;code&gt;ssl_preread&lt;/code&gt;设置为&lt;code&gt;on&lt;/code&gt;来启用&lt;code&gt;SNI&lt;/code&gt; reading。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ cat &amp;lt;&amp;lt;EOF &amp;gt; ./sni-proxy.conf
user www-data;

events {
}

stream {
  log_format log_stream '\$remote_addr [\$time_local] \$protocol [\$ssl_preread_server_name]'
  '\$status \$bytes_sent \$bytes_received \$session_time';

  access_log /var/log/nginx/access.log log_stream;
  error_log  /var/log/nginx/error.log;

  # tcp forward proxy by SNI
  server {
    resolver 8.8.8.8 ipv6=off;
    listen       127.0.0.1:8443;
    proxy_pass   \$ssl_preread_server_name:443;
    ssl_preread  on;
  }
}
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建一个kubernets ConfigMap来保存Nginx SNI代理的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create configmap egress-sni-proxy-configmap -n istio-system --from-file=nginx.conf=./sni-proxy.conf
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;下面命令将生成 &lt;code&gt;istio-egressgateway-with-sni-proxy.yaml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.7222222222222&quot;&gt;
&lt;p&gt;本例因为官方isitoOperator格式有变而无法运行，官方可能需要修改代码，参见此&lt;a href=&quot;https://github.com/istio/istio/issues/26635&quot;&gt;issue&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;配置使用sni代理的egress网关的路由转发&quot;&gt;配置使用SNI代理的egress网关的路由转发&lt;/h5&gt;
&lt;p&gt;....&lt;/p&gt;
&lt;h5 id=&quot;卸载-12&quot;&gt;卸载&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete serviceentry wikipedia
$ kubectl delete gateway istio-egressgateway-with-sni-proxy
$ kubectl delete virtualservice direct-wikipedia-through-egress-gateway
$ kubectl delete destinationrule egressgateway-for-wikipedia
$ kubectl delete --ignore-not-found=true envoyfilter forward-downstream-sni egress-gateway-sni-verifier
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete serviceentry sni-proxy
$ kubectl delete destinationrule disable-mtls-for-sni-proxy
$ kubectl delete -f ./istio-egressgateway-with-sni-proxy.yaml
$ kubectl delete configmap egress-sni-proxy-configmap -n istio-system
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ rm ./istio-egressgateway-with-sni-proxy.yaml
$ rm ./sni-proxy.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;卸载-13&quot;&gt;卸载&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete -f samples/sleep/sleep.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;egress流量的kubernetes服务&quot;&gt;Egress流量的kubernetes服务&lt;/h2&gt;
&lt;p&gt;kubernetes &lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/#externalname&quot;&gt;ExternalName&lt;/a&gt; services 和带&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors&quot;&gt;Endpoints&lt;/a&gt;的kubernetes services 允许为外部服务创建本地DNS别名，该DNS别名的格式与本地服务的DNS表项的格式相同，即 &lt;code&gt;&amp;lt;service name&amp;gt;.&amp;lt;namespace name&amp;gt;.svc.cluster.local&lt;/code&gt;。DNS别名为工作负载提供了位置透明性：负载可以通过这种方式调用本地和外部服务。如果某个时间需要在&lt;strong&gt;集群中&lt;/strong&gt;部署外部服务，就可以通过更新该kubernetes service来引用本地版本。工作负载将继续运行，不需要做任何改变。&lt;/p&gt;
&lt;p&gt;本任务将展示istio如何使用这些kubernetes机制来访问外部服务。不过此时必须使用TLS模式来进行访问，而不是istio的mutual TLS。因为外部服务不是istio服务网格的一部分，因此不能使用istio mutual TLS，必须根据外部服务的需要以及负载访问外部服务的方式来设置TLS模式。如果负载发起明文HTTP请求，但外部服务需要TLS，此时可能需要istio发起TLS。如果负载已经使用了TLS，那么流量已经经过加密，此时就可以禁用istio的mutual TLS。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本节描述如何将istio集成到现有kubernetes配置中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然本例使用了HTTP协议，但使用egress流量的kubernetes Services也可以使用其他协议。&lt;/p&gt;
&lt;h3 id=&quot;部署-5&quot;&gt;部署&lt;/h3&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;部署sleep应用并获取POD名称&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建一个不使用istio的命名空间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create namespace without-istio
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在&lt;code&gt;without-istio&lt;/code&gt;命名空间下启用&lt;code&gt;sleep&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml -n without-istio
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建一个环境变量&lt;code&gt;SOURCE_POD_WITHOUT_ISTIO&lt;/code&gt;来保存&lt;code&gt;without-istio&lt;/code&gt;命名空间下的pod名称&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ export SOURCE_POD_WITHOUT_ISTIO=&quot;$(kubectl get pod -n without-istio -l app=sleep -o jsonpath={.items..metadata.name})&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;校验该pod没有istio sidecar&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl get pod &quot;$SOURCE_POD_WITHOUT_ISTIO&quot; -n without-istio
NAME                    READY   STATUS    RESTARTS   AGE
sleep-f8cbf5b76-tbptz   1/1     Running   0          53s
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;通过kubernetes-externalname-service访问外部服务&quot;&gt;通过kubernetes ExternalName service访问外部服务&lt;/h3&gt;
&lt;ol readability=&quot;22.410303587856&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在&lt;code&gt;default&lt;/code&gt;命名空间中为&lt;code&gt;httpbin.org&lt;/code&gt;创建一个kubernetes ExternalName service，将外服服务&lt;code&gt;httpbin.org&lt;/code&gt;映射为kubernetes服务&lt;code&gt;my-httpbin&lt;/code&gt;，即可以通过访问&lt;code&gt;my-httpbin.default.svc.cluster.local&lt;/code&gt;来访问&lt;code&gt;my-httpbin&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
kind: Service
apiVersion: v1
metadata:
  name: my-httpbin
spec:
  type: ExternalName
  externalName: httpbin.org
  ports:
  - name: http
    protocol: TCP
    port: 80
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;观察service，可以看到并没有cluster IP&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl get svc my-httpbin
NAME         TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
my-httpbin   ExternalName   &amp;lt;none&amp;gt;       httpbin.org   80/TCP    3s
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;在源pod(不带istio sidecar)中通过kubernetes的service主机名访问 &lt;code&gt;httpbin.org&lt;/code&gt;。由于在网格中，因此不需要访问时禁用istio 的mutual TLS。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$SOURCE_POD_WITHOUT_ISTIO&quot; -n without-istio -c sleep -- curl my-httpbin.default.svc.cluster.local/headers
{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;,
    &quot;Host&quot;: &quot;my-httpbin.default.svc.cluster.local&quot;,
    &quot;User-Agent&quot;: &quot;curl/7.64.0&quot;,
    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5f485a71-54548d2e5f8b0dc1002e2ce0&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5.8823529411765&quot;&gt;
&lt;p&gt;本例中，使用向 &lt;code&gt;httpbin.org&lt;/code&gt; 发送了未加密的HTTP请求。为了简单例子，下面禁用了TLS模式，允许向外部服务发送未加密的流量。在实际使用时，建议配置&lt;a href=&quot;https://istio.io/latest/docs/tasks/traffic-management/egress/egress-tls-origination/&quot;&gt;Egress TLS源&lt;/a&gt;，下面相当于将流量重定向到内部服务&lt;code&gt;my-httpbin.default.svc.cluster.local&lt;/code&gt;上，而&lt;code&gt;my-httpbin.default.svc.cluster.local&lt;/code&gt;映射了外部服务 &lt;code&gt;httpbin.org&lt;/code&gt;，这样就可以通过这种方式通过kubernetes service来访问外部服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: my-httpbin
spec:
  host: my-httpbin.default.svc.cluster.local
  trafficPolicy:
    tls:
      mode: DISABLE
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;在带istio sidecar的pod中通过kubernetes service主机名访问&lt;code&gt;httpbin.org&lt;/code&gt;，注意isito sidecar添加的首部，如 &lt;code&gt;X-Envoy-Decorator-Operation&lt;/code&gt;。同时注意&lt;code&gt;Host&lt;/code&gt;首部字段等于自己的service主机名。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$SOURCE_POD&quot; -c sleep -- curl my-httpbin.default.svc.cluster.local/headers
{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;,
    &quot;Content-Length&quot;: &quot;0&quot;,
    &quot;Host&quot;: &quot;my-httpbin.default.svc.cluster.local&quot;,
    &quot;User-Agent&quot;: &quot;curl/7.64.0&quot;,
    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5f485d05-ac81b19dcee92359b5cae307&quot;,
    &quot;X-B3-Sampled&quot;: &quot;0&quot;,
    &quot;X-B3-Spanid&quot;: &quot;bee9babd29c28cec&quot;,
    &quot;X-B3-Traceid&quot;: &quot;b8260c4ba5390ed0bee9babd29c28cec&quot;,
    &quot;X-Envoy-Attempt-Count&quot;: &quot;1&quot;,
    &quot;X-Envoy-Decorator-Operation&quot;: &quot;my-httpbin.default.svc.cluster.local:80/*&quot;,
    &quot;X-Envoy-Peer-Metadata&quot;: &quot;ChoKCkNMVVNURVJfSUQSDBoKS3ViZXJuZXRlcwo2CgxJTlNUQU5DRV9JUFMSJhokMTAuODAuMi4yNixmZTgwOjozMGI4OmI3ZmY6ZmUxNDpiMjE0Ct4BCgZMQUJFTFMS0wEq0AEKDgoDYXBwEgcaBXNsZWVwChkKDGlzdGlvLmlvL3JldhIJGgdkZWZhdWx0CiAKEXBvZC10ZW1wbGF0ZS1oYXNoEgsaCWY4Y2JmNWI3NgokChlzZWN1cml0eS5pc3Rpby5pby90bHNNb2RlEgcaBWlzdGlvCioKH3NlcnZpY2UuaXN0aW8uaW8vY2Fub25pY2FsLW5hbWUSBxoFc2xlZXAKLwojc2VydmljZS5pc3Rpby5pby9jYW5vbmljYWwtcmV2aXNpb24SCBoGbGF0ZXN0ChoKB01FU0hfSUQSDxoNY2x1c3Rlci5sb2NhbAofCgROQU1FEhcaFXNsZWVwLWY4Y2JmNWI3Ni13bjlyNwoWCglOQU1FU1BBQ0USCRoHZGVmYXVsdApJCgVPV05FUhJAGj5rdWJlcm5ldGVzOi8vYXBpcy9hcHBzL3YxL25hbWVzcGFjZXMvZGVmYXVsdC9kZXBsb3ltZW50cy9zbGVlcAoaCg9TRVJWSUNFX0FDQ09VTlQSBxoFc2xlZXAKGAoNV09SS0xPQURfTkFNRRIHGgVzbGVlcA==&quot;,
    &quot;X-Envoy-Peer-Metadata-Id&quot;: &quot;sidecar~10.80.2.26~sleep-f8cbf5b76-wn9r7.default~default.svc.cluster.local&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;卸载-14&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete destinationrule my-httpbin
$ kubectl delete service my-httpbin
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用带endpoints的kubernetes-service访问一个外部服务&quot;&gt;使用带endpoints的kubernetes service访问一个外部服务&lt;/h3&gt;
&lt;ol readability=&quot;20&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;为&lt;code&gt;map.baidu.com&lt;/code&gt;创建一个kubernetes service，不带selector&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
kind: Service
apiVersion: v1
metadata:
  name: my-baidu-map
spec:
  ports:
  - protocol: TCP
    port: 443
    name: tls
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;为外部服务手动创建endpoints，IP来自&lt;code&gt;map.baidu.com&lt;/code&gt;后端地址。此时可以通过kubernetes service直接访问外部服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# nslookup map.baidu.com
Server:         100.100.2.136
Address:        100.100.2.136#53

Non-authoritative answer:
map.baidu.com   canonical name = map.n.shifen.com.
Name:   map.n.shifen.com
Address: 180.101.49.69
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
kind: Endpoints
apiVersion: v1
metadata:
  name: my-baidu-map
subsets:
  - addresses:
      - ip: 180.101.49.69
    ports:
      - port: 443
        name: tls
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;观测上述service，可以通过其cluster IP访问&lt;code&gt;map.baidu.com&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# oc get svc my-baidu-map
NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-baidu-map   ClusterIP   10.84.20.176   &amp;lt;none&amp;gt;        443/TCP   116s
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;从不带istio sidecar的pod中向&lt;code&gt;map.baidu.com&lt;/code&gt;发送HTTPS请求。注意下面&lt;code&gt;curl&lt;/code&gt;在访问&lt;code&gt;map.baidu.com&lt;/code&gt;时使用了&lt;code&gt;--resolve&lt;/code&gt;选项&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$SOURCE_POD_WITHOUT_ISTIO&quot; -n without-istio -c sleep -- curl -s --resolve map.baidu.com:443:&quot;$(kubectl get service my-baidu-map -o jsonpath='{.spec.clusterIP}')&quot; https://map.baidu.com | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;
&amp;lt;title&amp;gt;百度地图&amp;lt;/title&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;这种情况下，负载会直接向&lt;code&gt;map.baidu.com&lt;/code&gt;发送HTTPS请求，此时可以安全禁用istio的mutual TLS(当然也可以不禁用，此时不需要部署destinationRule)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: my-baidu-map
spec:
  host: my-baidu-map.default.svc.cluster.local
  trafficPolicy:
    tls:
      mode: DISABLE
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;从带istio sidecar的pod中访问&lt;code&gt;map.baidu.com&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$SOURCE_POD&quot; -c sleep -- curl -s --resolve map.baidu.com:443:&quot;$(kubectl get service my-baidu-map -o jsonpath='{.spec.clusterIP}')&quot; https://map.baidu.com  | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;
&amp;lt;title&amp;gt;百度地图&amp;lt;/title&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;校验请求确实是通过cluster IP(&lt;code&gt;10.84.20.176&lt;/code&gt;)进行访问的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$SOURCE_POD&quot; -c sleep -- curl -v --resolve map.baidu.com:443:&quot;$(kubectl get service my-baidu-map -o jsonpath='{.spec.clusterIP}')&quot; https://map.baidu.com -o /dev/null
* Expire in 0 ms for 6 (transfer 0x562c95903680)
* Added map.baidu.com:443:10.84.20.176 to DNS cache
* Hostname map.baidu.com was found in DNS cache
*   Trying 10.84.20.176...
* TCP_NODELAY set
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;卸载-15&quot;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete destinationrule my-baidu-map
$ kubectl delete endpoints my-baidu-map
$ kubectl delete service my-baidu-map
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;卸载-16&quot;&gt;卸载&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete -f samples/sleep/sleep.yaml
$ kubectl delete -f samples/sleep/sleep.yaml -n without-istio
$ kubectl delete namespace without-istio
$ unset SOURCE_POD SOURCE_POD_WITHOUT_ISTIO
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用外部https代理&quot;&gt;使用外部HTTPS代理&lt;/h2&gt;
&lt;p&gt;在前面&lt;a href=&quot;https://istio.io/latest/docs/tasks/traffic-management/egress/egress-gateway/&quot;&gt;配置Egress网关&lt;/a&gt;的例子中展示了如何通过istio边界组件&lt;em&gt;Egress网关&lt;/em&gt;将流量转发到外部服务中。然而，但是，有些情况下需要外部的、遗留的（非Istio）HTTPS代理来访问外部服务。例如，公司可能已经部署了一个代理，所有组织中的应用都必须通过该代理来转发流量。&lt;/p&gt;
&lt;p&gt;本例展示如何通过外部代理转发流量。由于所有的由于都会使用HTTP CONNECT方法来与HTTPS代理建立连接，配置流量到一个外部代理不同于配置流量到外部HTTP和HTTPS服务。&lt;/p&gt;
&lt;h3 id=&quot;部署-6&quot;&gt;部署&lt;/h3&gt;
&lt;p&gt;创建sleep应用并获取POD名称&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部署一个https代理&quot;&gt;部署一个HTTPS代理&lt;/h3&gt;
&lt;p&gt;为了模拟一个遗留的代理，需要在集群中部署HTTPS代理。为了模拟在集群外部运行的更真实的代理，需要通过代理的IP地址而不是Kubernetes服务的域名来定位代理的pod。本例使用&lt;a href=&quot;http://www.squid-cache.org/&quot;&gt;Squid&lt;/a&gt;，但也可以使用其他HTTPS代理来支持HTTP CONNECT。&lt;/p&gt;
&lt;ol readability=&quot;21&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;为HTTPS代理创建一个命名空间，不启用istio sidecar自动注入。使用这种方式来模拟集群外的代理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create namespace external
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建Squid代理的配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ cat &amp;lt;&amp;lt;EOF &amp;gt; ./proxy.conf
http_port 3128

acl SSL_ports port 443
acl CONNECT method CONNECT

http_access deny CONNECT !SSL_ports
http_access allow localhost manager
http_access deny manager
http_access allow all

coredump_dir /var/spool/squid
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建一个kubernetes ConfigMap来保存代理的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create configmap proxy-configmap -n external --from-file=squid.conf=./proxy.conf
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;部署Squid容器。注：openshift可能会因为scc导致权限错误，为方便测试，将容器设置为privileged权限&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;# oc adm policy add-scc-to-user privileged -z default
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: squid
  namespace: external
spec:
  replicas: 1
  selector:
    matchLabels:
      app: squid
  template:
    metadata:
      labels:
        app: squid
    spec:
      serviceAccount: default
      volumes:
      - name: proxy-config
        configMap:
          name: proxy-configmap
      containers:
      - name: squid
        image: sameersbn/squid:3.5.27
        imagePullPolicy: IfNotPresent
        securityContext:
          privileged: true
        volumeMounts:
        - name: proxy-config
          mountPath: /etc/squid
          readOnly: true
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在external命名空间中创建sleep应用来测试到代理的流量(不受istio控制)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -n external -f samples/sleep/sleep.yaml
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;获取代理pod的地址并定义在&lt;code&gt;PROXY_IP&lt;/code&gt;环境变量中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ export PROXY_IP=&quot;$(kubectl get pod -n external -l app=squid -o jsonpath={.items..podIP})&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定义&lt;code&gt;PROXY_PORT&lt;/code&gt;环境变量来保存代理的端口，即Squid使用的端口3128&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ export PROXY_PORT=3128
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;从external命名空间中的sleep Pod中通过代理向外部服务发送请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$(kubectl get pod -n external -l app=sleep -o jsonpath={.items..metadata.name})&quot; -n external -- sh -c &quot;HTTPS_PROXY=$PROXY_IP:$PROXY_PORT curl https://map.baidu.com&quot; | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0&amp;lt;title&amp;gt;百度地图&amp;lt;/title&amp;gt;
100  154k    0  154k    0     0   452k      0 --:--:-- --:--:-- --:--:--  452k
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;检查代理的访问日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$(kubectl get pod -n external -l app=squid -o jsonpath={.items..metadata.name})&quot; -n external -- tail /var/log/squid/access.log
1598596320.477    342 10.80.2.81 TCP_TUNNEL/200 165939 CONNECT map.baidu.com:443 - HIER_DIRECT/180.101.49.69 -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在，完成了如下两个于istio无关的任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;部署了HTTPS 代理&lt;/li&gt;
&lt;li&gt;通过代理访问&lt;code&gt;map.baidu.com&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面将配置启用istio的pod使用HTTPS代理。&lt;/p&gt;
&lt;h3 id=&quot;配置流量到外部https代理&quot;&gt;配置流量到外部HTTPS代理&lt;/h3&gt;
&lt;ol readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;为HTTPS代理定义一个TCP(非HTTP) Service Entry。虽然应用会使用HTTP CONNECT方法来与HTTPS代理建立连接，但必须为代理配置TCP流量，而非HTTP。一旦建立连接，代理只是充当一个TCP隧道。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
  name: proxy
spec:
  hosts:
  - my-company-proxy.com # ignored
  addresses:
  - $PROXY_IP/32 #hosts字段的后端IP
  ports:
  - number: $PROXY_PORT
    name: tcp
    protocol: TCP
  location: MESH_EXTERNAL
EOF
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;从default命名空间中的sleep Pod发送请求，由于该pod带有sidecar，istio会对流量进行控制&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$SOURCE_POD&quot; -c sleep -- sh -c &quot;HTTPS_PROXY=$PROXY_IP:$PROXY_PORT curl https://map.baidu.com&quot; | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0&amp;lt;title&amp;gt;百度地图&amp;lt;/title&amp;gt;
100  154k    0  154k    0     0   439k      0 --:--:-- --:--:-- --:--:--  439k
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;检查istio sidecar 代理的日志，可以看到对外访问了my-company-proxy.com&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$SOURCE_POD&quot; -c sleep -- sh -c &quot;HTTPS_PROXY=$PROXY_IP:$PROXY_PORT curl https://map.baidu.com&quot; | grep -o &quot;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&quot;
[2020-08-28T12:38:10.064Z] &quot;- - -&quot; 0 - &quot;-&quot; &quot;-&quot; 898 166076 354 - &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;-&quot; &quot;10.80.2.87:3128&quot; outbound|3128||my-company-proxy.com 10.80.2.77:36576 10.80.2.87:3128 10.80.2.77:36574 - -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;检查代理的访问日志，可以看到转发了HTTP CONNECT请求&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# kubectl exec &quot;$(kubectl get pod -n external -l app=squid -o jsonpath={.items..metadata.name})&quot; -n external -- tail /var/log/squid/access.log
1598618290.412    346 10.80.2.77 TCP_TUNNEL/200 166076 CONNECT map.baidu.com:443 - HIER_DIRECT/180.101.49.69 -
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;过程理解&quot;&gt;过程理解&lt;/h3&gt;
&lt;p&gt;在本例中完成了如下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;部署一个HTTPS代理来模拟外部代理&lt;/li&gt;
&lt;li&gt;创建TCP service entry来使istio控制的流量转发到外部代理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意不能为需要经过外部代理的外部服务(如map.baidu.com)创建service entry。这是因为从istio的角度看，这些请求仅会发送到外部代理，Istio并不知道外部代理会进一步转发请求的事实。&lt;/p&gt;
&lt;h3 id=&quot;卸载-17&quot;&gt;卸载&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete -f samples/sleep/sleep.yaml
$ kubectl delete -f samples/sleep/sleep.yaml -n external
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete -n external deployment squid
$ kubectl delete -n external configmap proxy-configmap
$ rm ./proxy.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete namespace external
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete serviceentry proxy
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 28 Aug 2020 12:42:00 +0000</pubDate>
<dc:creator>charlieroro</dc:creator>
<og:description>Istio的流量管理(实操三) 涵盖官方文档Traffic Management章节中的egress部分。其中有一小部分问题(已在下文标注)待官方解决。 访问外部服务 由于启用了istio的pod的出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/charlieroro/p/13558508.html</dc:identifier>
</item>
<item>
<title>C++算法 线段树 - lichangjian</title>
<link>http://www.cnblogs.com/lichangjian/p/13579744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lichangjian/p/13579744.html</guid>
<description>&lt;p&gt;线段树这个算法，看起来非常高端，而且很有用处，所以还是讲一下下吧。&lt;/p&gt;
&lt;p&gt;温馨提示：写线段树前请做好写码5分钟，调试一辈子的准备^-^&lt;/p&gt;
&lt;p&gt;啊直接步入正题……&lt;/p&gt;
&lt;p&gt;首先我们考虑一个题目：有一个序列，要做到单点修改单点查询，该怎么做呢？&lt;/p&gt;
&lt;p&gt;同学们先不要着急关掉……我们细细分析，像这种题，明显大家都知道……直接暴力就过了嘛……，所以不做分析……&lt;/p&gt;
&lt;p&gt;然后我们考虑第二个题目：有一个序列，要做到单点修改区间求和，该怎么做呢？&lt;/p&gt;
&lt;p&gt;像传统的for(int i=1;i&amp;lt;=n;i++)ans+=a[i]当然是很香的，但如果遇到一些非常奇怪的题目（数 据 大 到 你 自 闭），这个就没什么用了……&lt;/p&gt;

&lt;p&gt;啊这，简单的暴力不能用，就要用复杂的暴力——线段树，当然是简单亿点点的~因为单点修改可以O(1)，不存在浪费时间的事情，所以我们用线段树小小的处理一下就好了。&lt;/p&gt;
&lt;p&gt;接下来画一个图帮助斯烤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1941702/202008/1941702-20200828194743818-158934991.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在这个图上呢……一共有8个点，就是底下那些最小的线段，而我们把他合成了许多部分，每个部分的值就是f[wz*2]+f[wz*2+1]（f是每个的值，wz是每个的编号)。&lt;/p&gt;
&lt;p&gt;然后就可以把他一直向下，一直向下，直到发现这个区间是被我们要求的区间所包含的，然后这个区间内的数就全部加上，就这么一直向下找找找……，最后就可以算出一个区间的总和。&lt;/p&gt;
&lt;p&gt;下面是演示代码~&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void qh(long long wz)//wz是现在所处的小块编号 
{
        if(tree[wz].l&amp;gt;=a&amp;amp;&amp;amp;tree[wz].r&amp;lt;=b)//a和b是我们要求的区间的左右端点 
        {
                zshu+=tree[wz].shu;//全部被包含，直接加上 
                return;
        } 
        long long mid=(tree[wz].l+tree[wz].r)/2;//不能被包含?分裂一下试试吧
        if(b&amp;gt;mid)//和谐小细节~ 
        {
                qh(wz*2+1);//如果有被包含，就去右边的小块看看 
        }
        if(a&amp;lt;=mid)//和谐小细节*2~(至于为啥有和谐小细节，以及为什么要这样写，请同学们自己斯烤(这么简单还是可以的8)) 
        {
                qh(wz*2);//如果有被包含，也要去左边的小块看看
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;嘿嘿简单吧^-^，啊我忘记讲建树了QAQ。没事马上就讲。&lt;/p&gt;
&lt;p&gt;建树嘛，直接递归就好了，每次把这个区间分成两份，一直分到l和r一样（就是说这是一个点的值，要输入了），然后获取两个点的值之后就可以向上递归~嗯嗯对，一直递归就建好了，相信大家都有这个写递归的能力，但要实在不会就看看下面的代码吧（温馨提示：线段树用来建树的数组要开到节点数的4倍大，至于为什么我也忘了……）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct hehe
{
        long long l,r,shu,f;
}tree[400005];//tree结构体~ 
long long mid;
void js(long long ll,long long rr,long long wz)//js，建树的意思。ll和rr分别是左右边界，wz就是他的编号 
{
        tree[wz].l=ll;//左边界是ll 
        tree[wz].r=rr;//右边界是rr 
        if(ll==rr)//左右边界一致，这是一个点 
        {
                scanf(&quot;%lld&quot;,&amp;amp;tree[wz].shu);
                return;
        }
        long long mid=(ll+rr)/2;//如果这不是一个点，肯定能分成两部分 
        js(ll,mid,wz*2);//左边 
        js(mid+1,rr,wz*2+1);//右边 
        tree[wz].shu=tree[wz*2].shu+tree[wz*2+1].shu;//加起来 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看，是不是非常简单，接下来为了学的更深一点点，要把题目加难了（是的还要加难，但我相信你们一定可以学会的）&lt;/p&gt;
&lt;p&gt;有一个序列，要做到区间增加区间求和，该怎么做呢？&lt;/p&gt;
&lt;p&gt;啊这，这个是线段树里最难的一部分（起码我觉得最难），直接下放显然不太现实……，会浪费掉很多不必要的时间。正所谓科技发展在于懒人~，其实我们也可以在不影响结果的情况下偷个懒是吧QWQ。&lt;/p&gt;
&lt;p&gt;就像加一样~我知道这两个序列的和，我就没必要去求所有单个序列是多少，加法和这个差不多，我们可以看看有那个序列是全都要加的，然后直接算出它加完之后的值。这样求这个值的时候肯定是不影响计算的（偷懒成功！）。但这时就会有一些同学吐槽：&quot;啊你这个不严谨啊，如果下一次求和是求这个序列的一部分怎么办呢？&quot;其实呢，我刚才也写了是吧……&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
其实我们也可以在不影响结果的情况下偷个懒是吧
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我刚才说的是不影响，但这个操作明显影响了，在哪里影响了呢？就是只加了一个总序列，没有让他的一部分加上（偷懒失败QWQ）。但好像根本没有必要调整他的一部分啊，因为目前根本用不到，没说让做的事情我们还要去做不是浪费时间吗？但又不能不加，怎么办呢？我们可以设定一个懒标记，表示它之前被加了多少，这样呢，每次要求和的时候只要下放这个懒标记，并且加上该加的数，就能达到不说不做，最大程度优化时间，还保证正确hhhhh（偷懒成功）&lt;/p&gt;
&lt;p&gt;至于代码的实现也是非常的简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void xf(long long wz)
{
        tree[wz*2].shu+=(tree[wz*2].r-tree[wz*2].l+1)*tree[wz].f;//每个长度单位都加上tree[wz].f，总值就增加了(tree[wz*2].r-tree[wz*2].l+1)*tree[wz].f
        tree[wz*2].f+=tree[wz].f;//之前每一个长度单位要加tree[wz*2].f，现在发现它还要加上tree[wz].f，就把他们两个加起来就好了嘛，很容易的。 
        tree[wz*2+1].shu+=(tree[wz*2+1].r-tree[wz*2+1].l+1)*tree[wz].f;
        tree[wz*2+1].f+=tree[wz].f;//同理
        tree[wz].f=0;//这里已经加过了，要清零的，就像转账一样，你给另一个人转了钱，你钱就没了。 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上方是下放懒标记的代码，下方是区间修改代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void xg(long long wz)
{
        if(tree[wz].l&amp;gt;=a&amp;amp;&amp;amp;tree[wz].r&amp;lt;=b)
        {
                tree[wz].shu+=(tree[wz].r-tree[wz].l+1)*c;//更改值 
                tree[wz].f+=c;//增加懒标记 
                return;
        }//啊后面的都说过，不打了… 
        tree[wz].shu+=(min(tree[wz].r,b)-max(tree[wz].l,a)+1)*c;
        long long mid=(tree[wz].l+tree[wz].r)/2;
        if(b&amp;gt;mid)
        {
                xg(wz*2+1);
        }
        if(a&amp;lt;=mid)
        {
                xg(wz*2);
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于加了懒标记以后别的代码也是要动的。&lt;/p&gt;
&lt;p&gt;比如在原来的求和代码里多了一个xf(wz);&lt;/p&gt;
&lt;p&gt;至于加在哪里同学们自己斯烤吧（我太仁慈了）&lt;/p&gt;
&lt;p&gt;啊我再放一道线段树模板题，大家可以秒掉来吊打我：&lt;a href=&quot;https://www.luogu.com.cn/problem/P3372&quot; target=&quot;_blank&quot;&gt;模板题传送们&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了我觉得我讲完了，如果有什么不好或漏掉的地方大家可以及时评论，我会更改的。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Aug 2020 12:27:00 +0000</pubDate>
<dc:creator>lichangjian</dc:creator>
<og:description>线段树这个算法，看起来非常高端，而且很有用处，所以还是讲一下下吧。 温馨提示：写线段树前请做好写码5分钟，调试一辈子的准备^-^ 啊直接步入正题…… 首先我们考虑一个题目：有一个序列，要做到单点修改单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lichangjian/p/13579744.html</dc:identifier>
</item>
</channel>
</rss>