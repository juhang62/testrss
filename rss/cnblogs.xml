<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>中间件：ElasticSearch组件RestHighLevelClient用法详解 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14322789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14322789.html</guid>
<description>&lt;p&gt;RestHighLevelClient的API作为ElasticSearch备受推荐的客户端组件，其封装系统操作ES的方法，包括索引结构管理，数据增删改查管理，常用查询方法，并且可以结合原生ES查询原生语法，功能十分强大。在使用RestHighLevelClient的语法时，通常涉及上面几个方面，在掌握基础用法之上可以根据业务特点进行一些自定义封装，这样可以更优雅的解决业务需求。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;164.13775065388&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot; target=&quot;_blank&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot; target=&quot;_blank&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1、resthighlevelclient&quot;&gt;1、RestHighLevelClient&lt;/h2&gt;
&lt;p&gt;RestHighLevelClient的API作为ElasticSearch备受推荐的客户端组件，其封装系统操作ES的方法，包括索引结构管理，数据增删改查管理，常用查询方法，并且可以结合原生ES查询原生语法，功能十分强大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210124224456155-1622521458.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在使用RestHighLevelClient的语法时，通常涉及上面几个方面，在掌握基础用法之上可以根据业务特点进行一些自定义封装，这样可以更优雅的解决业务需求。&lt;/p&gt;
&lt;h2 id=&quot;2、核心依赖&quot;&gt;2、核心依赖&lt;/h2&gt;
&lt;p&gt;使用RestHighLevelClient需要依赖&lt;code&gt;rest-high-level-client&lt;/code&gt;包，和ES相关基础依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.elasticsearch&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;elasticsearch&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.elasticsearch.client&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;elasticsearch-rest-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.elasticsearch.client&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;elasticsearch-rest-high-level-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里不做过多描述，注意一点：因为ES的数据结构特点，所以不需要索引更新方法，新的字段在更新数据时直接写入即可，不需要提前更新索引结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class EsIndexOperation {

    @Resource
    private RestHighLevelClient client ;
    private final RequestOptions options = RequestOptions.DEFAULT;

    /**
     * 判断索引是否存在
     */
    public boolean checkIndex (String index) {
        try {
            return client.indices().exists(new GetIndexRequest(index), options);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return Boolean.FALSE ;
    }

    /**
     * 创建索引
     */
    public boolean createIndex (String indexName ,Map&amp;lt;String, Object&amp;gt; columnMap){
        try {
            if(!checkIndex(indexName)){
                CreateIndexRequest request = new CreateIndexRequest(indexName);
                if (columnMap != null &amp;amp;&amp;amp; columnMap.size()&amp;gt;0) {
                    Map&amp;lt;String, Object&amp;gt; source = new HashMap&amp;lt;&amp;gt;();
                    source.put(&quot;properties&quot;, columnMap);
                    request.mapping(source);
                }
                this.client.indices().create(request, options);
                return Boolean.TRUE ;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return Boolean.FALSE;
    }

    /**
     * 删除索引
     */
    public boolean deleteIndex(String indexName) {
        try {
            if(checkIndex(indexName)){
                DeleteIndexRequest request = new DeleteIndexRequest(indexName);
                AcknowledgedResponse response = client.indices().delete(request, options);
                return response.isAcknowledged();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Boolean.FALSE;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里在更新数据时，可以直接修改索引结构，在dataMap中放进新的字段即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class EsDataOperation {

    @Resource
    private RestHighLevelClient client ;
    private final RequestOptions options = RequestOptions.DEFAULT;

    /**
     * 写入数据
     */
    public boolean insert (String indexName, Map&amp;lt;String,Object&amp;gt; dataMap){
        try {
            BulkRequest request = new BulkRequest();
            request.add(new IndexRequest(indexName,&quot;doc&quot;).id(dataMap.remove(&quot;id&quot;).toString())
                    .opType(&quot;create&quot;).source(dataMap,XContentType.JSON));
            this.client.bulk(request, options);
            return Boolean.TRUE ;
        } catch (Exception e){
            e.printStackTrace();
        }
        return Boolean.FALSE;
    }

    /**
     * 批量写入数据
     */
    public boolean batchInsert (String indexName, List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; userIndexList){
        try {
            BulkRequest request = new BulkRequest();
            for (Map&amp;lt;String,Object&amp;gt; dataMap:userIndexList){
                request.add(new IndexRequest(indexName,&quot;doc&quot;).id(dataMap.remove(&quot;id&quot;).toString())
                        .opType(&quot;create&quot;).source(dataMap,XContentType.JSON));
            }
            this.client.bulk(request, options);
            return Boolean.TRUE ;
        } catch (Exception e){
            e.printStackTrace();
        }
        return Boolean.FALSE;
    }

    /**
     * 更新数据，可以直接修改索引结构
     */
    public boolean update (String indexName, Map&amp;lt;String,Object&amp;gt; dataMap){
        try {
            UpdateRequest updateRequest = new UpdateRequest(indexName,&quot;doc&quot;, dataMap.remove(&quot;id&quot;).toString());
            updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);
            updateRequest.doc(dataMap) ;
            this.client.update(updateRequest, options);
            return Boolean.TRUE ;
        } catch (Exception e){
            e.printStackTrace();
        }
        return Boolean.FALSE;
    }

    /**
     * 删除数据
     */
    public boolean delete (String indexName, String id){
        try {
            DeleteRequest deleteRequest = new DeleteRequest(indexName,&quot;doc&quot;, id);
            this.client.delete(deleteRequest, options);
            return Boolean.TRUE ;
        } catch (Exception e){
            e.printStackTrace();
        }
        return Boolean.FALSE;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;注意：查询总数的CountRequest语法，SearchRequest查询结果中数据转换语法，分页查询中需要指定偏移位置和分页大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class EsQueryOperation {

    @Resource
    private RestHighLevelClient client ;
    private final RequestOptions options = RequestOptions.DEFAULT;

    /**
     * 查询总数
     */
    public Long count (String indexName){
        // 指定创建时间
        BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();
        queryBuilder.must(QueryBuilders.termQuery(&quot;createTime&quot;, 1611378102795L));

        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        sourceBuilder.query(queryBuilder);

        CountRequest countRequest = new CountRequest(indexName);
        countRequest.source(sourceBuilder);
        try {
            CountResponse countResponse = client.count(countRequest, options);
            return countResponse.getCount();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return 0L;
    }

    /**
     * 查询集合
     */
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; list (String indexName) {
        // 查询条件,指定时间并过滤指定字段值
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();
        queryBuilder.must(QueryBuilders.termQuery(&quot;createTime&quot;, 1611378102795L));
        queryBuilder.mustNot(QueryBuilders.termQuery(&quot;name&quot;,&quot;北京-李四&quot;));
        sourceBuilder.query(queryBuilder);
        SearchRequest searchRequest = new SearchRequest(indexName);
        searchRequest.source(sourceBuilder);
        try {
            SearchResponse searchResp = client.search(searchRequest, options);
            List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; data = new ArrayList&amp;lt;&amp;gt;() ;
            SearchHit[] searchHitArr = searchResp.getHits().getHits();
            for (SearchHit searchHit:searchHitArr){
                Map&amp;lt;String,Object&amp;gt; temp = searchHit.getSourceAsMap();
                temp.put(&quot;id&quot;,searchHit.getId()) ;
                data.add(temp);
            }
            return data;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null ;
    }

    /**
     * 分页查询
     */
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; page (String indexName,Integer offset,Integer size) {
        // 查询条件,指定时间并过滤指定字段值
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        sourceBuilder.from(offset);
        sourceBuilder.size(size);
        sourceBuilder.sort(&quot;createTime&quot;, SortOrder.DESC);
        SearchRequest searchRequest = new SearchRequest(indexName);
        searchRequest.source(sourceBuilder);
        try {
            SearchResponse searchResp = client.search(searchRequest, options);
            List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; data = new ArrayList&amp;lt;&amp;gt;() ;
            SearchHit[] searchHitArr = searchResp.getHits().getHits();
            for (SearchHit searchHit:searchHitArr){
                Map&amp;lt;String,Object&amp;gt; temp = searchHit.getSourceAsMap();
                temp.put(&quot;id&quot;,searchHit.getId()) ;
                data.add(temp);
            }
            return data;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;排序除了常规的指定字段升序降序规则之外，还可以基于原生的脚本语法，基于自定义规则排序让一些特定的数据沉底或者置顶。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class EsSortOperation {

    @Resource
    private RestHighLevelClient client ;
    private final RequestOptions options = RequestOptions.DEFAULT;

    /**
     * 排序规则
     */
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; sort (String indexName) {
        // 先升序时间，在倒序年龄
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        sourceBuilder.sort(&quot;createTime&quot;, SortOrder.ASC);
        sourceBuilder.sort(&quot;age&quot;,SortOrder.DESC) ;
        SearchRequest searchRequest = new SearchRequest(indexName);
        searchRequest.source(sourceBuilder);
        try {
            SearchResponse searchResp = client.search(searchRequest, options);
            List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; data = new ArrayList&amp;lt;&amp;gt;() ;
            SearchHit[] searchHitArr = searchResp.getHits().getHits();
            for (SearchHit searchHit:searchHitArr){
                Map&amp;lt;String,Object&amp;gt; temp = searchHit.getSourceAsMap();
                temp.put(&quot;id&quot;,searchHit.getId()) ;
                data.add(temp);
            }
            return data;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null ;
    }

    /**
     * 自定义排序规则
     */
    public List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; defSort (String indexName) {
        // 指定置换顺序的规则
        // [age 12--&amp;gt;60]\[age 19--&amp;gt;10]\[age 13--&amp;gt;30]\[age 18--&amp;gt;40],age其他值忽略为1
        Script script = new Script(&quot;def _ageSort = doc['age'].value == 12?60:&quot; +
                                                            &quot;(doc['age'].value == 19?10:&quot; +
                                                            &quot;(doc['age'].value == 13?30:&quot; +
                                                            &quot;(doc['age'].value == 18?40:1)));&quot; + &quot;_ageSort;&quot;);
        ScriptSortBuilder sortBuilder = SortBuilders.scriptSort(script,ScriptSortBuilder.ScriptSortType.NUMBER);
        sortBuilder.order(SortOrder.ASC);
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        sourceBuilder.sort(sortBuilder);
        SearchRequest searchRequest = new SearchRequest(indexName);
        searchRequest.source(sourceBuilder);
        try {
            SearchResponse searchResp = client.search(searchRequest, options);
            List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt; data = new ArrayList&amp;lt;&amp;gt;() ;
            SearchHit[] searchHitArr = searchResp.getHits().getHits();
            for (SearchHit searchHit:searchHitArr){
                Map&amp;lt;String,Object&amp;gt; temp = searchHit.getSourceAsMap();
                temp.put(&quot;id&quot;,searchHit.getId()) ;
                data.add(temp);
            }
            return data;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/data-manage-parent
GitEE·地址
https://gitee.com/cicadasmile/data-manage-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：编程体系整理&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 25 Jan 2021 00:09:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>RestHighLevelClient的API作为ElasticSearch备受推荐的客户端组件，其封装系统操作ES的方法，包括索引结构管理，数据增删改查管理，常用查询方法，并且可以结合原生ES查询原</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14322789.html</dc:identifier>
</item>
<item>
<title>SEO大杀器rendertron安装 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/14323389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/14323389.html</guid>
<description>[unable to retrieve full-text content]前段时间做SEO的优化，使用的是GoogleChrome/rendertron，发现这个安装部署的时候还是会有一些要注意的地方，做个记录 为什么要使用rendertron 目前很多网站都是使用 vue、recat等框架开发的网站，一般都是在服务器上只有一个index.html，index.html引</description>
<pubDate>Sun, 24 Jan 2021 23:53:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<dc:identifier>http://www.cnblogs.com/feixiangmanon/p/14323389.html</dc:identifier>
</item>
<item>
<title>二. SpringCloud基本Rest微服务工程搭建 - MPolaris</title>
<link>http://www.cnblogs.com/mpolaris/p/14323158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mpolaris/p/14323158.html</guid>
<description>[unable to retrieve full-text content]1. 父工程构建 1.1 Maven项目搭建 环境 版本 JDK 1.8 Maven 3.6+ Maven模板 maven-archetype-size 删除父工程src文件 1.2 父工程pom文件 回顾： ① Maven中dependencyManagement和dependencies的区别 </description>
<pubDate>Sun, 24 Jan 2021 16:58:00 +0000</pubDate>
<dc:creator>MPolaris</dc:creator>
<dc:identifier>https://www.cnblogs.com/mpolaris/p/14323158.html</dc:identifier>
</item>
<item>
<title>OLED的波形曲线、进度条、图片显示（STM32 HAL库 模拟SPI通信 5线OLED屏幕）详细篇 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/14321569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/14321569.html</guid>
<description>[unable to retrieve full-text content]少废话，先上效果图 屏幕显示效果 全家福 观看演示效果： https://www.bilibili.com/video/BV13V411b78V 一、基础认识及引脚介绍 屏幕参数： 尺寸：0.96英寸 分辨率：128*64 驱动芯片：SSD1306 驱动接口协议：SPI 引脚说明： 二、 SSD13</description>
<pubDate>Sun, 24 Jan 2021 16:09:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/14321569.html</dc:identifier>
</item>
<item>
<title>.NET Core使用Source Link提高源代码调试体验和生产效率 - 追逐时光者</title>
<link>http://www.cnblogs.com/Can-daydayup/p/14321010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/14321010.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　在我们日常开发过程中常常会使用到很多其他封装好的第三方中间件（NuGet依赖项）、类库或者是.NET框架中自带的库。但是当你想要对这些类库的方法设置断点调试，然后发现无法F11（逐语句）调试进源码中调用堆栈大部分显示为灰色，而不让您看到调用堆栈中较早发生的事情。如果可以设置断点并在NuGet依赖项或框架本身上使用调试器的所有功能，那么我们的源码调试体验和生产效率会提升非常的多。那么Source Link这项技术刚好就满足了我们对源码调试的意愿。&lt;/p&gt;
&lt;h2&gt;什么是Source Link：&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Source Link是一项技术，可让开发人员从NuGet调试.NET程序集的源代码。&lt;/span&gt;&lt;span&gt;源链接在创建NuGet程序包时执行，并将源代码控制元数据嵌入程序集和程序包中。&lt;/span&gt;&lt;span&gt;下载该程序包并在Visual Studio中启用了Source Link的开发人员可以进入其源代码。&lt;/span&gt;&lt;span&gt;Source Link提供了源代码控制元数据，以创建出色的调试体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GitHub源码地址：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/dotnet/sourcelink&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/sourcelink&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Visual Studio配置启用Source Link：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;拓展：符号文件即为.pdb的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、选择&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;工具&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;选项&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;调试&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;符号，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;并确保已选中“ Microsoft符号服务器（.NET框架相关的库）和NuGet.org符号服务器”选项。&lt;/span&gt;&lt;span&gt;为符号高速缓存指定目录是避免再次下载相同符号，提高源码查看效率。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202101/1336199-20210124224052373-410434095.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 2、&lt;span&gt;&lt;span&gt;在“&lt;/span&gt;&lt;span&gt;工具”&lt;/span&gt;&lt;span&gt; &amp;gt;“&lt;/span&gt;&lt;span&gt;选项”&lt;/span&gt;&lt;span&gt; &amp;gt;“&lt;/span&gt;&lt;span&gt;调试”&lt;/span&gt;&lt;span&gt; &amp;gt;“&lt;/span&gt;&lt;span&gt;常规”中禁用【启用“仅我的代码”】&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;因为我们希望调试器尝试为解决方案之外的代码找到符号。&lt;/span&gt;&lt;span&gt;验证是否&lt;/span&gt;&lt;span&gt;已选中（默认情况下）。&lt;/span&gt;&lt;span&gt;如果您想进入.NET Framework代码，则还需要选中&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;.NET Core不需要此功能。&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot; prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202101/1336199-20210124224614780-1890675941.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Visual Studio启用Source Link调试：&lt;/h2&gt;
&lt;p&gt;　　  接下来以Newtonsoft.Json（一款.NET中开源的Json序列化和反序列化类库）为例。有时您想进入框架来查看发生了什么，特别是如果发生了意外的事情。使用Source Link，您可以像使用自己的代码一样进入框架方法，检查所有变量并设置断点。&lt;/p&gt;
&lt;h3&gt;未启用Source Link调试之前：&lt;/h3&gt;
&lt;p&gt;如果您在没有Source Link的情况下尝试了此操作，那么在按F11介入之前和之后，就会看到以下内容，无法进入类库中查看其源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202101/1336199-20210124222723714-2007681237.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202101/1336199-20210124222746437-1181927045.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 启用Source Link调试：&lt;/h3&gt;
&lt;p&gt; 调试器不会介入，是因为没有符号或源。一旦配置了Source Link，当我们进入时，可以通过F11直接调试Nuget依赖库的源码（因为第一次需要下载源文件到本地可能等待时间要久一些）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202101/1336199-20210124231248034-1925451106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202101/1336199-20210124233523093-849101531.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;指定下载对应文件的源代码进行调试：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202101/1336199-20210124234248420-1953053441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 24 Jan 2021 15:39:00 +0000</pubDate>
<dc:creator>追逐时光者</dc:creator>
<og:description>前言： 在我们日常开发过程中常常会使用到很多其他封装好的第三方中间件（NuGet依赖项）、类库或者是.NET框架中自带的库。但是当你想要对这些类库的方法设置断点调试，然后发现无法F11（逐语句）调试进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/14321010.html</dc:identifier>
</item>
<item>
<title>我在华为OD的275天 - 瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/14322931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/14322931.html</guid>
<description>&lt;p&gt;2020年3月到2020年12月，我在华为 OD 待了共275天。 华为 OD 有 HR 说得那么好吗？有网络上其他人说得那么差吗？在华为 OD 工作到底是什么样的体验？ 希望这篇文章能给你提供一些参考。欢迎评论区交流啊😄&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;160.47356346952&quot;&gt;

&lt;h2 id=&quot;0---时间线&quot;&gt;0 - 时间线&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;18年7月，毕业于某不知名985计科专业；&lt;/li&gt;
&lt;li&gt;毕业前，在某马的 JavaEE（后台开发）培训了6个月；&lt;/li&gt;
&lt;li&gt;第一份工作（18-07 ~ 19-12）接触了大数据，感觉大数据更有前景；&lt;/li&gt;
&lt;li&gt;19年12月，入职中国平安产险（去到才发现是做后台开发😢）&lt;/li&gt;
&lt;li&gt;20年3月，从平安辞职，跳去华为 OD 做大数据基础平台。。。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;1---为什么会去华为-od&quot;&gt;1 - 为什么会去华为 OD&lt;/h2&gt;
&lt;p&gt;在平安产险（正式员工）只待了3个月，就跳去华为 OD，朋友们都是很不理解的 —— 好好的正编不做，去什么外包啊😂&lt;/p&gt;
&lt;p&gt;但那个时候，我铁了心要去做大数据，不想和没完没了的 CRUD 打交道。刚好面试通过的岗位是华为 Cloud BU 的大数据部门，做的是国内政企中使用率绝对领先的大数据平台……&lt;br/&gt;平台和工作内容都不错，这么好的机会，说啥也要去啊💪&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;其实有想过在平安内部转岗到大数据的，但是不满足“入职一年以上”这个要求；&lt;br/&gt;「等待就是浪费生命」，在转正流程还没批下来的时候，赶紧溜了😂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2---华为-od-的工作内容&quot;&gt;2 - 华为 OD 的工作内容&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;带着无限的期待，火急火燎地去华为报到了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和招聘的 HR 说的一样，和华为自有员工一起办公，工作内容和他们完全一样：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;主管根据你的能力水平分配工作，逐渐增加难度，能者多劳；&lt;br/&gt;试用期6个月，有导师带你，一般都是高你2个 Level 的华为自有员工，基本都是部门大牛。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，&lt;strong&gt;不存在外包做的都是基础的、流程性的、没有技术含量的工作&lt;/strong&gt; —— 顾虑这个的完全不用担心，你只需要打听清楚要去的部门/小组具体做什么，能接受就再考虑其他的。&lt;/p&gt;
&lt;p&gt;感触很深的一点是：华为是有着近20万员工的巨头，内部有很多流程和制度。好处是：能接触到大公司的产品从开发、测试，到发布、运维等一系列的流程，比如提交代码的时候，会由经验资深、经过内部认证的大牛给你 Review，在拉会检视的时候，可以学习他们考虑问题的角度，还有对整个产品全局的把控。&lt;/p&gt;
&lt;p&gt;但同时，个人觉得这也有不好的地方：流程繁琐会导致工作效率变低，比如改动几行代码，就需要跑完整个 CI（有些耗时比较久），还要提供自验和 VT 的报告。&lt;/p&gt;
&lt;h2 id=&quot;3---od-与华为自有员工的对比&quot;&gt;3 - OD 与华为自有员工的对比&lt;/h2&gt;
&lt;p&gt;什么是 OD？Outstanding Dispatcher，人员派遣，官方强调说，OD 和常说的“外包”是不一样的。&lt;/p&gt;
&lt;p&gt;说说我了解的 OD：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;参考华为的薪酬框架，OD 人员的薪酬体系有一定的市场竞争力 —— 的确是这样，貌似会稍微倒挂同级别的自有员工；&lt;/li&gt;
&lt;li&gt;可以参与华为主力产品的研发 —— 是的，这也是和某软等“供应商”的兄弟们不一样的地方；&lt;/li&gt;
&lt;li&gt;外网权限也可以申请打开（对，就是梯子），部门内部的大多数文档都是可以看的；&lt;/li&gt;
&lt;li&gt;工号是单独的300号段，其他供应商员工的工号是8开头，或着 WX 开头；&lt;/li&gt;
&lt;li&gt;工卡带是红色的，和自有员工一样，但是工卡内容不同，OD 的明确标注：办公区通行证，并有德科公司的备注：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1438655/202101/1438655-20210124231550508-1315720640.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;还听到一些内部的说法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;没股票，没TUP，年终奖少，只有工资可能比我司高一点点而已；&lt;/li&gt;
&lt;li&gt;不能借针对HW的消费贷，也不能买公司提供的优惠保险……&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;4---那，到底要不要去华为-od？&quot;&gt;4 - 那，到底要不要去华为 OD？&lt;/h2&gt;
&lt;p&gt;我想，搜到我这篇文字的你，心里其实是有偏向的，只是缺最后一片雪花❄️，让自己下决心。&lt;/p&gt;
&lt;p&gt;作为过来人之一，我再提供一些参考吧 😃&lt;/p&gt;
&lt;p&gt;1）除了华为 OD，&lt;strong&gt;还有没有更好的选择？&lt;/strong&gt; 综合考虑加班（996、有些是9106甚至更多）、薪资、工作内容，以及这份工作经历对你整个职业的加成等等因素；&lt;/p&gt;
&lt;p&gt;2）有看到一些内部的说法，比如：“奇怪OD这么棒，为啥大家不自愿转去OD啊？”；再比如：“OD等同华为？这话都说的出口，既然都等同，为啥还要OD？就是降成本嘛……”&lt;/p&gt;
&lt;p&gt;3）内心够强大吗？虽然没有人会说你是 OD，但总有一些事情会提醒你：&lt;strong&gt;你不是华为员工&lt;/strong&gt;。比如：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;a) 内部发文啥的，还有心声平台的大部分内容，都是无权限看的：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1438655/202101/1438655-20210124225007848-1701355006.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;b) 你的考勤是在租赁人员管理系统里考核，绩效管理也是；&lt;br/&gt;c) 自有员工的工卡具有消费功能（包括刷夜宵），OD 的工卡不能消费，需要办个消费卡，而且夜宵只能通过手机软件领取（自有员工是用工卡领的）；&lt;br/&gt;d) 你的加班一定要提加班申请电子流换 Double 薪资，不然只能换调休，离职时没时间调休也换不来 Double —— 而华为员工即使自己主动离职，也是有 N+1，以及加班时间换成 Double 薪资的；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;说了这么多，决定还是要你自己下💪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是要强调下：在我20年12月底离职的时候，OD 同学的工号已经排到1w+了。&lt;br/&gt;也就是说，在一年左右的时间里，有1万多同学接受了 OD 并成功入职了，在技术实力、工作能力上，基本都是挺不错的，希望社会上没切实了解过 OD 的同学，不要戴着有色眼镜看我们。&lt;/p&gt;
&lt;h2 id=&quot;5---网传的-od-转华为正编，真的假的？&quot;&gt;5 - 网传的 OD 转华为正编，真的假的？&lt;/h2&gt;
&lt;p&gt;这个放到单独的一节，是因为它很重要，有很多纠结的同学在关注这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案是：真的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;据各类非官方渠道（比如知乎上的一些分享），转华为自有是有条件的（&lt;a href=&quot;https://www.zhihu.com/question/356592219/answer/1562692667&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/356592219/answer/1562692667&lt;/a&gt;）：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1）入职时间：一年以上&lt;br/&gt;2）绩效要求：连续两次绩效 A&lt;br/&gt;3）认证要求：通过可信专业级认证&lt;br/&gt;4）其他条件：根据业务部门的人员需求及指标要求确定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说说这些条件吧 😃&lt;/p&gt;
&lt;h3 id=&quot;2-连续两次绩效-a&quot;&gt;2) 连续两次绩效 A&lt;/h3&gt;
&lt;p&gt;上面链接里的说法：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;绩效 A 大约占整个部门的前10%，连续两次A的意思就是一年里两次考评都排在部门前10%，能做到这样的在华为属于火车头，这种难得的绩效会舍得分给一个租赁人员吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OD 同学能拿到 A 吗？不知道，我入职晚，都没有经历一个完整的绩效考评。但据我了解，这种事既看实力，又看劳动态度（能不能拼命三郎疯狂加班），还要看运气（主管对你是不是认可）……&lt;/p&gt;
&lt;h3 id=&quot;3-通过可信专业级认证&quot;&gt;3) 通过可信专业级认证&lt;/h3&gt;
&lt;p&gt;可信专业级认证考试是啥？华为在推动技术人员的可信认证，算是一项安全合规的工作。&lt;br/&gt;专业级有哪些考试呢？共有四门：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;科目一：上级编程，对比力扣2道中等、1道困难；&lt;br/&gt;科目二：编程知识与应用，考察基础的编程语言知识等；&lt;br/&gt;科目三：安全编程、质量、隐私，还有开发者测试等；&lt;br/&gt;科目四：重构知识，包括设计模式、代码重构等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这些，每一门单季度只能考一次（好像有些一年只能考3次），每个都要准备，少则3天，多则1星期，不准备，基本都过不了。&lt;br/&gt;我在4个月左右、还没转正的时候，就考过了专业级的科目二、三、四，只剩科目一大半年都没过（算法确实太菜了😂&lt;br/&gt;但也有同事没准备，连着好几次都没通过。&lt;/p&gt;
&lt;h3 id=&quot;4-部门人员需求指标？&quot;&gt;4) 部门人员需求指标？&lt;/h3&gt;
&lt;p&gt;这个听起来都感觉很玄学。还是那句话，实力和运气到了，应该可以的！成功转正员工图镇楼：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1438655/202101/1438655-20210124231943817-1976130336.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5---最后，真的感谢-od，也感谢华为&quot;&gt;5 - 最后，真的感谢 OD，也感谢华为&lt;/h2&gt;
&lt;p&gt;运气很好，在我换工作还不到3个月的时候，华为还收我。&lt;/p&gt;
&lt;p&gt;我遇到了很好的主管，起码在工作时间，感觉跟兄长一样指导、帮助我；&lt;/p&gt;
&lt;p&gt;分配给我的导师，是我工作以来认识到技术实力最厉害的人，定位问题思路清晰，编码实力强悍，全局思考问题、制定方案……&lt;/p&gt;
&lt;p&gt;小组、部门的同学都很 nice，9个多月里，我基本每天都跟打了鸡血一样，现在想想，也不知道当时为什么会那么积极有干劲😂&lt;/p&gt;
&lt;p&gt;从个人能力上来讲，我是进不去华为的（心里还是有点数的😂）。正是有了 OD 这个渠道，才有机会切身感受华为的工作氛围，也学到了很多软技能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;积极主动，勇于承担尝试，好工作要抢过来自己做；&lt;/li&gt;
&lt;li&gt;及时同步工作进展，包括已完成、待完成，存在的风险困难等内容，要让领导知道你的工作情况；&lt;/li&gt;
&lt;li&gt;勤于总结提炼输出，形成个人 DNA，利人利己；&lt;/li&gt;
&lt;li&gt;有不懂的可以随时找人问，脸皮要厚，虚心求教；&lt;/li&gt;
&lt;li&gt;不管多忙，所有的会议，不论大小，都要有会议纪要，邮件发给相关人……&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;再次感谢，大家都加油，向很牛掰很牛掰前进💪&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;啰嗦完了，可能会有同学还有很多问号❓，可以的，在这里留言，或者关注公众号之后留言，都能找到我。&lt;/p&gt;
&lt;p&gt;这茫茫人海的，能来找我，我会很高兴，你有啥问题，我肯定好好解答。&lt;/p&gt;
&lt;p&gt;另外提前预告下，下一篇写写我为什么年底离职，以及离职后去了哪儿。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 24 Jan 2021 15:18:00 +0000</pubDate>
<dc:creator>瘦风</dc:creator>
<og:description>2020年3月到2020年12月，我在华为 OD 待了共275天。 华为 OD 有 HR 说得那么好吗？有网络上其他人说得那么差吗？在华为 OD 工作到底是什么样的体验？ 希望这篇文章能给你提供一些参</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shoufeng/p/14322931.html</dc:identifier>
</item>
<item>
<title>【原创】Linux虚拟化KVM-Qemu分析（八）之virtio初探 - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/14322824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/14322824.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;KVM版本：5.9.1&lt;/li&gt;
&lt;li&gt;QEMU版本：5.0.0&lt;/li&gt;
&lt;li&gt;工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;从本文开始将研究一下virtio；&lt;/li&gt;
&lt;li&gt;本文会从一个网卡虚拟化的例子来引入virtio，并从大体架构上进行介绍，有个宏观的认识；&lt;/li&gt;
&lt;li&gt;细节的阐述后续的文章再跟进；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;11-网卡工作原理&quot;&gt;1.1 网卡工作原理&lt;/h2&gt;
&lt;p&gt;先来看一下网卡的架构图（以Intel的82540为例）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124224948934-1913021948.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OSI模型，将网络通信中的数据流划分为7层，最底下两层为物理层和数据链路层，对应到网卡上就是&lt;code&gt;PHY&lt;/code&gt;和&lt;code&gt;MAC控制器&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PHY&lt;/code&gt;：对应物理层，负责通信设备与网络媒介（网线）之间的互通，它定义传输的光电信号、线路状态等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MAC控制器&lt;/code&gt;：对应数据链路层，负责网络寻址、错误侦测和改错等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PHY&lt;/code&gt;和&lt;code&gt;MAC&lt;/code&gt;通过&lt;code&gt;MII/GMII(Media Independent Interface)&lt;/code&gt;和&lt;code&gt;MDIO(Management Data Input/output)&lt;/code&gt;相连；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MII/GMII(Gigabit MII)&lt;/code&gt;：由&lt;code&gt;IEEE&lt;/code&gt;定义的以太网行业标准，与媒介无关，包含数据接口和管理接口，用于网络数据传输；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MDIO&lt;/code&gt;接口，也是由&lt;code&gt;IEEE&lt;/code&gt;定义，一种简单的串行接口，通常用于控制收发器，并收集状态信息等；&lt;/li&gt;
&lt;li&gt;网卡通过PCI接口接入到PCI总线中，CPU可以通过访问BAR空间来获取数据包，也有网卡直接挂在内存总线上；&lt;/li&gt;
&lt;li&gt;网卡还有一颗EEPROM芯片，用于记录厂商ID、网卡的MAC地址、配置信息等；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们主要关心它的数据流，所以，看看它的工作原理吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124224958286-1916188878.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络包的接收与发送，都是典型的&lt;code&gt;生产者-消费者&lt;/code&gt;模型，简单来说，CPU会在内存中维护两个&lt;code&gt;ring-buffer&lt;/code&gt;，分别代表&lt;code&gt;RX&lt;/code&gt;和&lt;code&gt;TX&lt;/code&gt;，&lt;code&gt;ring-buffer&lt;/code&gt;中存放的是描述符，描述符里包含了一个网络包的信息，包括了网络包地址、长度、状态等信息；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ring-buffer&lt;/code&gt;有头尾两个指针，发送端为：&lt;code&gt;TDH(Transmit Descriptor Head)和TDT(Transmit Descriptor Tail)&lt;/code&gt;，同理，接收端为：&lt;code&gt;RDH(Receive Descriptor Head)和RDT(Receive Descriptor Tail)&lt;/code&gt;，在数据传输时，由CPU和网卡来分开更新头尾指针的值，这也就是生产者更新尾指针，消费者更新头指针，永远都是消费者追着生产者跑，&lt;code&gt;ring-buffer&lt;/code&gt;也就能转起来了；&lt;/li&gt;
&lt;li&gt;数据的传输，使用DMA来进行搬运，CPU的拷贝显然是一种低效的选择。在之前PCI系列分析文章中分析过，PCI设备有自己的BAR空间，可以通过DMA在BAR空间和DDR空间内进行搬运；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;12-linux网卡驱动&quot;&gt;1.2 Linux网卡驱动&lt;/h2&gt;
&lt;p&gt;在网卡数据流图中，我们也基本看到了网卡驱动的影子，驱动与网卡之间是异步通信：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225007980-1864647992.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;驱动程序负责硬件的初始化，以及TX和RX的&lt;code&gt;ring-buffer&lt;/code&gt;的创建及初始化；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ndo_start_xmit&lt;/code&gt;负责将网络包通过驱动程序发送出去，&lt;code&gt;netif_receive_skb&lt;/code&gt;负责通过驱动程序接收网络包数据；&lt;/li&gt;
&lt;li&gt;数据通过&lt;code&gt;struct sk_buff&lt;/code&gt;来存储；&lt;/li&gt;
&lt;li&gt;发送数据时，CPU负责准备TX网络包数据以及描述符资源，更新TDT指针，并通知NIC可以进行数据发送了，当数据发送完毕后NIC通过中断信号通知CPU进行下一个包的处理；&lt;/li&gt;
&lt;li&gt;接收数据时，CPU负责准备RX的描述符资源，接收数据后，NIC通过中断通知CPU，驱动程序通过调度内核线程来处理网络包数据，处理完成后进行下一包的接收；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;21-全虚拟化方案&quot;&gt;2.1 全虚拟化方案&lt;/h2&gt;
&lt;p&gt;全虚拟化方案，通过软件来模拟网卡，Qemu+KVM的方案如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225017779-906916600.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Qemu中，设备的模拟称为前端，比如&lt;code&gt;e1000&lt;/code&gt;，前端与后端通信，后端再与底层通信，我们来分别看看发送和接收处理的流程；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;发送：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Guest OS在准备好网络包数据以及描述符资源后，通过写&lt;code&gt;TDT&lt;/code&gt;寄存器，触发VM的异常退出，由KVM模块接管；&lt;/li&gt;
&lt;li&gt;KVM模块返回到Qemu后，Qemu会检查VM退出的原因，比如检查到&lt;code&gt;e1000&lt;/code&gt;寄存器访问出错，因而触发&lt;code&gt;e1000前端&lt;/code&gt;工作；&lt;/li&gt;
&lt;li&gt;Qemu能访问Guest OS中的地址内容，因而&lt;code&gt;e1000前端&lt;/code&gt;能获取到Guest OS内存中的网络包数据，发送给后端，后端再将网络包数据发送给TUN/TAP驱动，其中TUN/TAP为虚拟网络设备；&lt;/li&gt;
&lt;li&gt;数据发送完成后，除了更新&lt;code&gt;ring-buffer&lt;/code&gt;的指针及描述符状态信息外，KVM模块会模拟TX中断；&lt;/li&gt;
&lt;li&gt;当再次进入VM时，Guest OS看到的是数据已经发送完毕，同时还需要进行中断处理；&lt;/li&gt;
&lt;li&gt;Guest OS跑在vCPU线程中，发送数据时相当于会打算它的执行，直到处理完后再恢复回来，也就是一个严格的同步处理过程；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当TUN/TAP有网络包数据时，可以通过读取TAP文件描述符来获取；&lt;/li&gt;
&lt;li&gt;Qemu中的I/O线程会被唤醒并触发后端处理，并将数据发送给&lt;code&gt;e1000前端&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e1000&lt;/code&gt;前端将数据拷贝到Guest OS的物理内存中，并模拟RX中断，触发VM的退出，并由KVM模块接管；&lt;/li&gt;
&lt;li&gt;KVM模块返回到Qemu中进行处理后，并最终重新进入Guest OS的执行中断处理；&lt;/li&gt;
&lt;li&gt;由于有I/O线程来处理接收，能与vCPU线程做到并行处理，这一点与发送不太一样；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;22-弊端&quot;&gt;2.2 弊端&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Guest OS去操作寄存器的时候，会触发VM退出，涉及到KVM和Qemu的处理，并最终再次进入VM，overhead较大；&lt;/li&gt;
&lt;li&gt;不管是在Host还是Guest中，中断处理的开销也很大，中断涉及的寄存器访问也较多；&lt;/li&gt;
&lt;li&gt;软件模拟的方案，吞吐量性能也比较低，时延较大；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，让我们大声喊出本文的主角吧！&lt;/p&gt;

&lt;p&gt;在进入主题前，先思考几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;全虚拟化下Guest可以重用驱动、网络协议栈等，但是在软件全模拟的情况下，我们是否真的需要去访问寄存器吗（比如中断处理），真的需要模拟网卡的自协商机制以及EEPROM等功能吗？&lt;/li&gt;
&lt;li&gt;是否真的需要模拟大量的硬件控制寄存器，而这些寄存器在软件看来毫无意义？&lt;/li&gt;
&lt;li&gt;是否真的需要生产者/消费者模型的通知机制（寄存器访问、中断）？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;31-virtio&quot;&gt;3.1 virtio&lt;/h2&gt;
&lt;p&gt;网卡的工作过程是一个生产者消费者模型，但是在前文中可以看出，在全虚拟化状态下存在一些弊端，一个更好的生产者消费者模型应该遵循以下原则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;寄存器只被生产者使用去通知消费者&lt;code&gt;ring-buffer&lt;/code&gt;有数据（消费者可以继续消费），而不再被用作存储状态信息；&lt;/li&gt;
&lt;li&gt;中断被消费者用来通知生产者&lt;code&gt;ring-buffer&lt;/code&gt;是非满状态（生产者可以继续生产）；&lt;/li&gt;
&lt;li&gt;生产者和消费者的状态信息应该存储在内存中，这样读取状态信息时不需要VM退出，减少overhead；&lt;/li&gt;
&lt;li&gt;生产者和消费者跑在不同的线程中，可以并行运行，并且尽可能多的处理任务；&lt;/li&gt;
&lt;li&gt;非必要情况下，相互之间的通知应该避免使用；&lt;/li&gt;
&lt;li&gt;忙等待（比如轮询）不是一个可以接受的通用解决方案；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基于上述原则，我们来看看从特殊到一般的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225030969-1952520201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一行是针对网卡的实现，第二行更进一步的抽象，第三行是通用的解决方案了，对I/O操作的虚拟化通用支持；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，在virtio的方案下，网卡的虚拟化看上去就是下边这个样子了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225040517-1032020700.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Hypervisor和Guest都需要实现virtio，这也就意味着Guest的设备驱动知道自己本身运行在VM中；&lt;/li&gt;
&lt;li&gt;virtio的目标是高性能的设备虚拟化，已经形成了规范来定义标准的消息传递API，用于驱动和Hypervisor之间的传递，不同的驱动和前端可以使用相同的API；&lt;/li&gt;
&lt;li&gt;virtio驱动（比如图中的virtio-net driver）的工作是将OS-specific的消息转换成virtio格式的消息，而对端（virtio-net frontend）则是做相反的工作；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;virtio的数据传递使用&lt;code&gt;scatter-gather list（sg-list）&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225049058-70219482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sg-list是概念上的（物理）地址和长度对的链表，通常作为数组来实现；&lt;/li&gt;
&lt;li&gt;每个sg-list描述一个多块的buffer，消费者用它来作为输入或输出操作；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;br/&gt;virtio的核心是&lt;code&gt;virtqueue(VQ)&lt;/code&gt;的抽象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;VQ是队列，sg-list会被Guest的驱动放置到VQ中，以供Hypervisor来消费；&lt;/li&gt;
&lt;li&gt;输出sg-list用于向Hypervisor来发送数据，而输入sg-list用于接收Hypervisor的数据；&lt;/li&gt;
&lt;li&gt;驱动可以使用一个或多个&lt;code&gt;virqueue&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225105737-1978247546.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当Guest的驱动产生一个sg-list时，调用&lt;code&gt;add_buf(SG, Token)&lt;/code&gt;入列；&lt;/li&gt;
&lt;li&gt;Hypervisor进行出列操作，并消费sg-list，并将sg-list push回去；&lt;/li&gt;
&lt;li&gt;Guest通过&lt;code&gt;get_buf()&lt;/code&gt;进行清理工作；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上图说的是数据流方向，那么事件的通知机制如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225113754-353622526.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当Guest驱动想要Hypervisor消费sg-list时，通过VQ的&lt;code&gt;kick&lt;/code&gt;来进行通知；&lt;/li&gt;
&lt;li&gt;当Hypervisor通知Guest驱动已经消费完了，通过&lt;code&gt;interupt&lt;/code&gt;来进行通知；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大体的数据流和控制流讲完了，细节实现后续再跟进了。&lt;/p&gt;
&lt;h2 id=&quot;32-半虚拟化方案&quot;&gt;3.2 半虚拟化方案&lt;/h2&gt;
&lt;p&gt;那么，半虚拟化框架下的网卡虚拟化数据流是啥样的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225127172-1182373630.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225134666-1220243725.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信你应该对virtio有个大概的了解了，好了，收工。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;《Virtio networking: A case study of I/O paravirtualization》&lt;/code&gt;&lt;br/&gt;&lt;code&gt;《 PCI/PCI-X Family of Gigabit Ethernet Controllers Software Developer's Manual》&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注个人公众号，不定期更新Linux相关技术文章。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202101/1771657-20210124225217681-808258576.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jan 2021 14:53:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 Read the fucking source code! --By 鲁迅 A picture is worth a thousand words. --By 高尔基 说明： KVM版本：5.9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/14322824.html</dc:identifier>
</item>
<item>
<title>Ice系列--基于IceGrid的部署方案 - whao2world</title>
<link>http://www.cnblogs.com/whao2world/p/14322758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whao2world/p/14322758.html</guid>
<description>[unable to retrieve full-text content]前言 前一篇文章介绍了IceGrid的简单应用。这篇文章来介绍一下它的高端玩法—如何将模板，复制组，知名对象应用于部署方案及其作用。 基于模板的部署方案 之前介绍了xml格式的配置文件通过各种描述符如node，server，adaptor等，描述应用部署信息。当服务部署复杂度增加时，书写这些描述符是</description>
<pubDate>Sun, 24 Jan 2021 14:47:00 +0000</pubDate>
<dc:creator>whao2world</dc:creator>
<dc:identifier>https://www.cnblogs.com/whao2world/p/14322758.html</dc:identifier>
</item>
<item>
<title>图解 | 原来这就是TCP - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/14322660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/14322660.html</guid>
<description>[unable to retrieve full-text content]你是一台电脑，你的名字叫 A 经过《图解 | 原来这就是网络》这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B 这就是物理层、数据链路层、网络层这三层所做的事情。站在第四层的你，就可以不要脸地利用下三层所做的铺垫</description>
<pubDate>Sun, 24 Jan 2021 14:15:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<dc:identifier>https://www.cnblogs.com/flashsun/p/14322660.html</dc:identifier>
</item>
<item>
<title>java进阶(33)--IO流 - Mrwhite86</title>
<link>http://www.cnblogs.com/mrwhite2020/p/14305950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrwhite2020/p/14305950.html</guid>
<description>[unable to retrieve full-text content]一、IO流概念：1、基本概念2、IO流分类3、java.io流的四大家族4、流的close和flush方法5、java.id下常用的16个流 二、FileInputStream字节输入流1、FileInputStream完成字节流输入的流程2、使用while优化FileInputStream读取流程</description>
<pubDate>Sun, 24 Jan 2021 14:13:00 +0000</pubDate>
<dc:creator>Mrwhite86</dc:creator>
<dc:identifier>https://www.cnblogs.com/mrwhite2020/p/14305950.html</dc:identifier>
</item>
</channel>
</rss>