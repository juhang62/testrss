<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringBoot入门 (六) 数据库访问之Mybatis - 梓&amp;艺</title>
<link>http://www.cnblogs.com/love-wzy/p/10334259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/love-wzy/p/10334259.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文记录学习在SpringBoot中使用Mybatis。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一 什么是Mybatis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录（官方定义）;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方使用示例代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
SqlSession session = sqlSessionFactory.openSession();
try {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  Blog blog = mapper.selectBlog(101);
} finally {
  session.close();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过示例程序可以看到它的执行过程主要有以下几个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1 应用程序启动时，根据配置文件生成一个SqlSessionFactory;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2 通过SqlSessionFactory的到一个SqlSession；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3 SqlSession内部通过Excutor执行对应的SQl；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4 返回处理结果；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5 释放资源；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二 SpringBoot集成Mybatis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Mybatis使用有2中方式，一种是使用注解，即在接口定义的方法上通过注解写入要执行的SQL和要完成的数据映射；一种是使用xml配置文件即在xml文件中写相关SQL和完成表与实体的映射。本文我们使用xml文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先需要引入SpringBoot集成Mybatis的依赖jar包，这里我们只引入了Spring与Mybatis集成的包，springboot默认会自动帮我们引入其他依赖的jar包。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在application.properties文件中配置数据库连接信息和指定mybatis的接口对应的xml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;#datasoure
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=123456
#mybatis
mybatis.mapper-locations=classpath:mybatis/*.xml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上，我们的mapper xml文件放在reources目录下的mybatis文件夹下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写一个接口，定义我们要完成的功能&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Mapper
public interface UserMapper {

    /**
     * 根据ID删除
     */
    int deleteByPrimaryKey(Long id);

    /**
     * 新增
     */
    int insert(UserInfo record);

    /**
     * 根据ID查询
     */
    UserInfo selectByPrimaryKey(Long id);

    /**
     * 修改
     */
    int updateByPrimaryKey(UserInfo record);

    /**
     * 查询所有
     */
    List&amp;lt;UserInfo&amp;gt; selectAll();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;@Mapper 该注解说名当前类是一个Mybatis的Mapper接口类，交给spring管理，令一种方式是使用注解 @MapperScan(basePackages=&quot;...&quot;) 说明basePackages及其子包下的接口都交给spring管理，我们多数情况下都会使用@MapperScan这个注解，这样我们就不用在每一个Mapper接口上写注解了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在xml文件中完成SQl，实现具体的方法，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;mapper namespace=&quot;org.allen.demo.dao.UserMapper&quot; &amp;gt;
  &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;org.allen.demo.domain.UserInfo&quot; &amp;gt;
    &amp;lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&amp;gt;
    &amp;lt;result column=&quot;age&quot; property=&quot;age&quot; jdbcType=&quot;INTEGER&quot; /&amp;gt;
    &amp;lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
  &amp;lt;/resultMap&amp;gt;
  &amp;lt;sql id=&quot;Base_Column_List&quot; &amp;gt;
    id, age, name
  &amp;lt;/sql&amp;gt;
  &amp;lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Long&quot; &amp;gt;
    select 
    &amp;lt;include refid=&quot;Base_Column_List&quot; /&amp;gt;
    from t_user
    where id = #{id,jdbcType=BIGINT}
  &amp;lt;/select&amp;gt;
  &amp;lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot;&amp;gt;
    select
    &amp;lt;include refid=&quot;Base_Column_List&quot; /&amp;gt;
    from t_user
  &amp;lt;/select&amp;gt;
  &amp;lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot; &amp;gt;
    delete from t_user
    where id = #{id,jdbcType=BIGINT}
  &amp;lt;/delete&amp;gt;
  &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;org.allen.demo.domain.UserInfo&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&amp;gt;
    insert into t_user (id, age, name)
    values (#{id,jdbcType=BIGINT}, #{age,jdbcType=INTEGER}, #{name,jdbcType=VARCHAR})
  &amp;lt;/insert&amp;gt;
  &amp;lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;org.allen.demo.domain.UserInfo&quot; &amp;gt;
    update t_user
    set age = #{age,jdbcType=INTEGER},
      name = #{name,jdbcType=VARCHAR}
    where id = #{id,jdbcType=BIGINT}
  &amp;lt;/update&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　从这个xml文件，我们可以看到以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 &lt;span&gt;n&lt;span&gt;amespace=&quot;org.allen.demo.dao.UserMapper&quot;&lt;/span&gt; 通过namespace来指定将当前&lt;span&gt;xml文件的SQL实现的对应的接口Mapper&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt; &lt;span&gt;通过 &lt;/span&gt;resultMap 完成实体类与数据库表字段的映射&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3 xml中的SQL语句都必须写在&amp;lt;select&amp;gt; &amp;lt;insert&amp;gt; &amp;lt;update&amp;gt;&amp;lt;delete&amp;gt;内部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4 每一个标识的id都必须与接口中的方法名保持一直&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5 insert 中使用的 useGeneratedKeys 设置是否使用JDBC的getGenereatedKeys方法获取主键并赋值到keyProperty设置的领域模型属性中。如果设置了true，我们就可以在insert完成后直接通过当前操作的实体类获取数据库主键。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三 测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用Junit做测试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class MybatisApplicationTests {

    @Resource
    private UserMapper userMapper;

    @Test
    public void save() {
        UserInfo user = new UserInfo();
        user.setName(&quot;world&quot;);
        user.setAge(2);
        userMapper.insert(user);
        System.out.println(&quot;保存后的ID：&quot; + user.getId());
    }

    @Test
    public void delete() {
        long id = 5;
        userMapper.deleteByPrimaryKey(id);
    }

    @Test
    public void update() {
        UserInfo user = new UserInfo();
        user.setName(&quot;world&quot;);
        user.setAge(5);
        long id = 3;
        user.setId(id);
        userMapper.updateByPrimaryKey(user);
    }

    @Test
    public void selectById() {
        long id = 3;
        userMapper.selectByPrimaryKey(id);
    }

    @Test
    public void selectAll() {
        List&amp;lt;UserInfo&amp;gt; userList = userMapper.selectAll();
    }
    
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 29 Jan 2019 07:32:00 +0000</pubDate>
<dc:creator>梓&amp;amp;艺</dc:creator>
<og:description>本文记录学习在SpringBoot中使用Mybatis。 一 什么是Mybatis MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/love-wzy/p/10334259.html</dc:identifier>
</item>
<item>
<title>springboot整合mybatis增删改查（四）：完善增删改查及整合swgger2 - 姜飞祥</title>
<link>http://www.cnblogs.com/smfx1314/p/10334335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smfx1314/p/10334335.html</guid>
<description>&lt;p&gt;接下来就是完成增删改查的功能了，首先在config包下配置Druid数据连接池,在配置之前先把相关配置在application.preperties中完善&lt;/p&gt;
&lt;h4 id=&quot;application.preperties&quot;&gt;application.preperties&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 下面为连接池的补充设置，应用到上面所有数据源中
# 初始化大小，最小，最大
spring.datasource.initialSize=5
spring.datasource.minIdle=5
spring.datasource.maxActive=30
# 配置获取连接等待超时的时间
spring.datasource.maxWait=60000
# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
spring.datasource.timeBetweenEvictionRunsMillis=60000
# 配置一个连接在池中最小生存的时间，单位是毫秒
spring.datasource.minEvictableIdleTimeMillis=300000
spring.datasource.validationQuery=SELECT 1 FROM DUAL
spring.datasource.testWhileIdle=true
spring.datasource.testOnBorrow=false
spring.datasource.testOnReturn=false
# 打开PSCache，并且指定每个连接上PSCache的大小
spring.datasource.poolPreparedStatements=true
spring.datasource.maxPoolPreparedStatementPerConnectionSize=20
# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
spring.datasource.filters=stat,wall,log4j
# 通过connectProperties属性来打开mergeSql功能；慢SQL记录
spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
# 合并多个DruidDataSource的监控数据
spring.datasource.useGlobalDataSourceStat=true
# Druid 监控 Servlet 配置参数
spring.datasource.druidRegistrationUrl: /druid/* 
spring.datasource.resetEnable: true 
spring.datasource.loginUsername: admin
spring.datasource.loginPassword: 1234
# Druid 监控过滤相关配置参数
spring.datasource.filtersUrlPatterns: /* 
spring.datasource.exclusions: '*.js,*.gif,*.jpg,*.jpeg,*.png,*.css,*.ico,*.jsp,/druid/*'
spring.datasource.sessionStatMaxCount: 2000 
spring.datasource.sessionStatEnable: true 
spring.datasource.principalSessionName: session_user_key 
spring.datasource.profileEnable: true
#druid datasouce database settings end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面配置完之后开始完成Druid数据连接池配置&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在config包-&amp;gt;新建DruidDbConfig类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;druiddbconfig类&quot;&gt;DruidDBConfig类&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class DruidDBConfig {
   // private Logger logger = LoggerFactory.getLogger(DruidDBConfig.class);

    @Value(&quot;${spring.datasource.driver-class-name}&quot;)
    private String driverClassName;

    @Value(&quot;${spring.datasource.url}&quot;)
    private String dbUrl;

    @Value(&quot;${spring.datasource.username}&quot;)
    private String username;

    @Value(&quot;${spring.datasource.password}&quot;)
    private String password;

    @Value(&quot;${spring.datasource.initialSize}&quot;)
    private int initialSize;

    @Value(&quot;${spring.datasource.minIdle}&quot;)
    private int minIdle;

    @Value(&quot;${spring.datasource.maxActive}&quot;)
    private int maxActive;

    @Value(&quot;${spring.datasource.maxWait}&quot;)
    private int maxWait;

    @Value(&quot;${spring.datasource.timeBetweenEvictionRunsMillis}&quot;)
    private int timeBetweenEvictionRunsMillis;

    @Value(&quot;${spring.datasource.minEvictableIdleTimeMillis}&quot;)
    private int minEvictableIdleTimeMillis;

    @Value(&quot;${spring.datasource.validationQuery}&quot;)
    private String validationQuery;

    @Value(&quot;${spring.datasource.testWhileIdle}&quot;)
    private boolean testWhileIdle;

    @Value(&quot;${spring.datasource.testOnBorrow}&quot;)
    private boolean testOnBorrow;

    @Value(&quot;${spring.datasource.testOnReturn}&quot;)
    private boolean testOnReturn;

    @Value(&quot;${spring.datasource.poolPreparedStatements}&quot;)
    private boolean poolPreparedStatements;

    @Value(&quot;${spring.datasource.maxPoolPreparedStatementPerConnectionSize}&quot;)
    private int maxPoolPreparedStatementPerConnectionSize;

    @Value(&quot;${spring.datasource.filters}&quot;)
    private String filters;

    @Value(&quot;{spring.datasource.connectionProperties}&quot;)
    private String connectionProperties;

    @Bean     //声明其为Bean实例
    @Primary  //在同样的DataSource中，首先使用被标注的DataSource
    public DataSource dataSource(){
       DruidDataSource datasource = new DruidDataSource();

        datasource.setUrl(this.dbUrl);
        datasource.setUsername(username);
        datasource.setPassword(password);
        datasource.setDriverClassName(driverClassName);

        //configuration
        datasource.setInitialSize(initialSize);
        datasource.setMinIdle(minIdle);
        datasource.setMaxActive(maxActive);
        datasource.setMaxWait(maxWait);
        datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        datasource.setValidationQuery(validationQuery);
        datasource.setTestWhileIdle(testWhileIdle);
        datasource.setTestOnBorrow(testOnBorrow);
        datasource.setTestOnReturn(testOnReturn);
        datasource.setPoolPreparedStatements(poolPreparedStatements);
        datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);
        try {
            datasource.setFilters(filters);
        } catch (SQLException e) {
          //  logger.error(&quot;druid configuration initialization filter&quot;, e);
        }
        datasource.setConnectionProperties(connectionProperties);

        return datasource;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述配置中的日志已经注释了，如果需要配置可以在resources中加入logback-spring.xml：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;resources-&amp;gt;logback-spring.xml&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;logback-spring.xml&quot;&gt;logback-spring.xml&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&amp;gt;
    &amp;lt;contextName&amp;gt;logback&amp;lt;/contextName&amp;gt;
    &amp;lt;!--自己定义一个log.path用于说明日志的输出目录--&amp;gt;
    &amp;lt;property name=&quot;log.path&quot; value=&quot;/log/jiangfeixiang/&quot;/&amp;gt;
    &amp;lt;!--输出到控制台--&amp;gt;
    &amp;lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;!-- &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&amp;gt;
             &amp;lt;level&amp;gt;ERROR&amp;lt;/level&amp;gt;
         &amp;lt;/filter&amp;gt;--&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!--输出到文件--&amp;gt;
    &amp;lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${log.path}/logback.%d{yyyy-MM-dd}.log&amp;lt;/fileNamePattern&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;root level=&quot;debug&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;console&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;file&quot;/&amp;gt;
    &amp;lt;/root&amp;gt;

    &amp;lt;!-- logback为java中的包 --&amp;gt;
    &amp;lt;logger name=&quot;com.example.springboootmybatis.controller&quot;/&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;userserviec接口&quot;&gt;UserServiec接口&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserService {
    /**
     * 查询所有用户
     */
    public List&amp;lt;User&amp;gt; getAllUser();

    /**
     * 保存用户
     * @param user
     */
    void saveUser(User user);

    /**
     * 根据id查询用户
     */
    User getById(Integer id);

    /**
     * 校验用户名
     * @param userName
     * @return
     */
    Boolean checkUserName(String userName);

    /**
     * 修改用户
     * @param user
     */
    void updateUser(User user);

    /**
     * 根据id删除用户
     * @param id
     */
    void deleteUser(Integer id);

    /**
     * 全选删除
     * @param useridList
     */
    void deleteBatchUser(List&amp;lt;Integer&amp;gt; useridList);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserServiceImpl实现类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
@Transactional
public class UserServiceImpl implements UserService {
    //注入
    @Autowired
    private UserMapper userMapper;

    /**
     * 查询所有用户
     */
    @Override
    public List&amp;lt;User&amp;gt; getAllUser() {
        List&amp;lt;User&amp;gt; users = userMapper.selectByExample(null);
        return users;
    }

    /**
     * 根据id查询用户
     */
    @Override
    public User getById(Integer id) {
        User user = userMapper.selectByPrimaryKey(id);
        return user;
    }

    /**
     * 添加用户
     * @param user
     */
    @Override
    public void saveUser(User user) {
        userMapper.insertSelective(user);
    }

    /**
     * 校验用户名是否存在
     * @param userName
     * @return
     * 数据库没有这条记录，count==0，返回true
     */
    @Override
    public Boolean checkUserName(String userName) {
        UserExample example=new UserExample();
        UserExample.Criteria criteria=example.createCriteria();
        criteria.andUsernameEqualTo(userName);
        long count=userMapper.countByExample(example);
        if(count==0){
            return true;
        }
        return false;
    }

    /**
     * 修改用户
     * @param user
     */
    @Override
    public void updateUser(User user) {
        userMapper.updateByPrimaryKeySelective(user);
    }

    /**
     * 根据id删除（单个）
     * @param id
     */
    @Override
    public void deleteUser(Integer id) {
        userMapper.deleteByPrimaryKey(id);
    }


    /**
     * 批量删除
     * @param useridList
     */
    @Override
    public void deleteBatchUser(List&amp;lt;Integer&amp;gt; useridList) {
      /*  UserExample example=new UserExample();
        UserExample.Criteria criteria=example.createCriteria();
        criteria.andUseridIn(useridList);
        userMapper.deleteByExample(example);*/

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;usercontroller&quot;&gt;UserController&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@RequestMapping(value = &quot;/user&quot;)
public class UserController {
    //注入
    @Autowired
    private UserService userService;

    /**
     * 查询所有用户
     */
    @ApiOperation(value=&quot;获取用户列表&quot;)
    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)
    public List&amp;lt;User&amp;gt; getListAll(){
        List&amp;lt;User&amp;gt; listAll = userService.getAllUser();
        return listAll;
    }

    /**
     * 用户保存
     * @return
     */
    @ApiOperation(value = &quot;添加用户&quot;,notes = &quot;根据user添加用户&quot;)
    @ApiImplicitParam(name = &quot;user&quot;,value = &quot;用户user&quot;,required = true,dataType = &quot;User&quot;)
    @RequestMapping(value = &quot;/users&quot;,method = RequestMethod.POST)
    public String saveUser(@RequestBody User user){
        userService.saveUser(user);
        return &quot;success&quot;;
    }

    /**
     * 根据id查询
     */
    @ApiOperation(value = &quot;根据id查询&quot;)
    @ApiImplicitParam(name = &quot;id&quot;,value = &quot;用户id&quot;)
    @RequestMapping(value = &quot;/{id}&quot;,method = RequestMethod.GET)
    public User getById(@PathVariable(&quot;id&quot;) Integer id){
        User user = userService.getById(id);
        return user;
    }

    /**
     * 校验用户名
     * @param username
     * @return
     */
    @ApiOperation(value = &quot;校验用户名&quot;)
    @ApiImplicitParam(name = &quot;userName&quot;,value = &quot;用户名&quot;,required = true,dataType = &quot;String&quot;)
    @RequestMapping(value = &quot;/{username}&quot;,method = RequestMethod.POST)
    public Boolean checkUserName(@PathVariable(&quot;username&quot;)String username){
        Boolean aboolean = userService.checkUserName(username);
        if (aboolean){
            return true;
        }else {
            return false;
        }
    }

    /**
     * 修改用户
     * @param user
     */
    @ApiOperation(value = &quot;修改用户&quot;)
    @ApiImplicitParam(name = &quot;user&quot;,value = &quot;用户&quot;,required = true,dataType = &quot;User&quot;)
    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)
    public String updateUser(@RequestBody User user){
        userService.updateUser(user);
        return &quot;success&quot;;
    }

    /**
     * 根据id删除用户
     */
    @ApiOperation(value = &quot;根据id删除用户&quot;)
    @ApiImplicitParam(name = &quot;id&quot;,value = &quot;用户id&quot;,required = true,dataType = &quot;Integer&quot;)
    @RequestMapping(value = &quot;/{id}&quot;,method = RequestMethod.DELETE)
    public String deleteUser(@PathVariable Integer id){
        userService.deleteUser(id);
        return &quot;success&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;controller类中使用了swgger2如下：&lt;/p&gt;
&lt;h4 id=&quot;springboot中整合swgger2&quot;&gt;springboot中整合swgger2&lt;/h4&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--swgger2--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;springbootmybatis包下创建SwaggerConfig.java&lt;/p&gt;
&lt;h4 id=&quot;swaggerconfig&quot;&gt;SwaggerConfig&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket createRestApi() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;使用Swagger2构建RESTful APIs&quot;) //标题
                .description(&quot;客户端与服务端接口文档&quot;) //描述
                .termsOfServiceUrl(&quot;http://localost:8080&quot;) //域名地址
                .contact(&quot;姜飞祥&quot;) //作者
                .version(&quot;1.0.0&quot;) //版本号
                .build();

        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;com.example.springbootmybatis&quot;))
                .paths(PathSelectors.any())
                .build();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就算完成了，写的不好请见谅。具体测试请参考下面的springboot整合swgger2,之后访问http://localhost:8080/swagger-ui.html即可，和&lt;/p&gt;
&lt;h4 id=&quot;备注&quot;&gt;备注：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;springboot整合swgger2参考:https://www.jianshu.com/p/57a4381a2b45&lt;/li&gt;
&lt;li&gt;MyBatis的Mapper接口以及Example的实例函数及详解：https://blog.csdn.net/biandous/article/details/65630783&lt;/li&gt;
&lt;li&gt;Mybatis Generator最完整配置详解：https://www.jianshu.com/p/e09d2370b796&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 29 Jan 2019 07:31:00 +0000</pubDate>
<dc:creator>姜飞祥</dc:creator>
<og:description>接下来就是完成增删改查的功能了，首先在config包下配置Druid数据连接池,在配置之前先把相关配置在application.preperties中完善 application.preperties</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smfx1314/p/10334335.html</dc:identifier>
</item>
<item>
<title>Kubernetes 弹性伸缩全场景解析 （四）- 让核心组件充满弹性 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10334276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10334276.html</guid>
<description>&lt;h4 id=&quot;1&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont680239.i0.72851c2aYt3zfR&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;在本系列的前三篇中，我们介绍了弹性伸缩的整体布局以及HPA的一些原理，HPA的部分还遗留了一些内容需要进行详细解析。在准备这部分内容的期间，会穿插几篇弹性伸缩组件的最佳实践。今天我们要讲解的是&lt;/p&gt;
&lt;p&gt;cluster-proportional-autoscaler 。cluster-proportional-autoscaler是根据集群中节点的数目进行Pod副本数水平伸缩的组件，这个组件的产生主要是为了解决集群的核心组件负载弹性的问题。在一个Kubernetes集群中，除了&lt;code&gt;APIServer&lt;/code&gt;等耳熟能详的&lt;code&gt;Control Pannel&lt;/code&gt;组件，还有很多系统组件是部署在worker上的，例如&lt;code&gt;CoreDNS&lt;/code&gt;、&lt;code&gt;Ingress Controller&lt;/code&gt;、&lt;code&gt;Istio&lt;/code&gt;等等。这些核心组件大部分和我们的应用接入层息息相关，也就是说每当我们的系统处理了一条外部的请求，可能都会调用这些组件。那么这就有可能由于这些组件的负载过大，造成应用的QPS达到瓶颈。那么一个集群该运行多少个核心组件副本呢？&lt;/p&gt;
&lt;p&gt;很遗憾，这个问题是没有统一答案的，因为不同的类型的应用、不同的网络模型、不同的调度分布，都有可能会带来不同的挑战。在本篇文章中，我们不谈具体的指标和数据，只探讨解法。在本系列后面的文章中，会为大家深入解析。&lt;/p&gt;
&lt;p&gt;大部分的情况下，核心组件的副本数目和集群的节点数目是成正比的，一个集群的节点数目越多，核心组件所需要的副本数就越多。今天我们以&lt;code&gt;CoreDNS&lt;/code&gt;为例，通过cluster-proportional-autoscaler，来实现一个动态的、基于节点数目的核心组件动态伸缩。&lt;/p&gt;
&lt;h4 id=&quot;2&quot;&gt;cluster-proportional-autoscaler的使用&lt;/h4&gt;
&lt;p&gt;cluster-proportional-autoscaler和传统的Kubernetes组件设计有所不同，我们已经见惯了各种&lt;code&gt;Controller&lt;/code&gt;、&lt;code&gt;CRD&lt;/code&gt;或者&lt;code&gt;Operator&lt;/code&gt;，而cluster-proportional-autoscaler走了另外一条非常简单的路。使用cluster-proportional-autoscaler只需要部署一个Yaml并选择一个伸缩的监听对象以及伸缩策略即可。如果需要有多个组件进行伸缩，那就部署多个Yaml，每个Yaml包含一个cluster-proportional-autoscaler。一个使用cluster-proportional-autoscaler弹性伸缩coredns的模板如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: dns-autoscaler
  &lt;span class=&quot;hljs-keyword&quot;&gt;namespace: kube-system
  labels:
    k8s-app: dns-autoscaler
spec:
  selector:
    matchLabels:
       k8s-app: dns-autoscaler
  &lt;span class=&quot;hljs-keyword&quot;&gt;template:
    metadata:
      labels:
        k8s-app: dns-autoscaler
    
    spec:
      containers:
      - name: autoscaler
        image: registry.cn-hangzhou.aliyuncs.com/ringtail/cluster-proportional-autoscaler-amd64:v1&lt;span class=&quot;hljs-number&quot;&gt;.3&lt;span class=&quot;hljs-number&quot;&gt;.0
        resources:
            requests:
                cpu: &lt;span class=&quot;hljs-string&quot;&gt;&quot;200m&quot;
                memory: &lt;span class=&quot;hljs-string&quot;&gt;&quot;150Mi&quot;
        command:
          - /cluster-proportional-autoscaler
          - --&lt;span class=&quot;hljs-keyword&quot;&gt;namespace=kube-system
          - --configmap=dns-autoscaler
          - --target=Deployment/coredns
          - --&lt;span class=&quot;hljs-keyword&quot;&gt;default-params={&lt;span class=&quot;hljs-string&quot;&gt;&quot;linear&quot;:{&lt;span class=&quot;hljs-string&quot;&gt;&quot;coresPerReplica&quot;:&lt;span class=&quot;hljs-number&quot;&gt;16,&lt;span class=&quot;hljs-string&quot;&gt;&quot;nodesPerReplica&quot;:&lt;span class=&quot;hljs-number&quot;&gt;2,&lt;span class=&quot;hljs-string&quot;&gt;&quot;min&quot;:&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-string&quot;&gt;&quot;max&quot;: &lt;span class=&quot;hljs-number&quot;&gt;100,&lt;span class=&quot;hljs-string&quot;&gt;&quot;preventSinglePointFailure&quot;: &lt;span class=&quot;hljs-literal&quot;&gt;true}}
          - --logtostderr=&lt;span class=&quot;hljs-literal&quot;&gt;true
          - --v=&lt;span class=&quot;hljs-number&quot;&gt;2
        serviceAccountName: admin 
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cluster-proportional-autoscaler的伸缩策略主要有两种，一种是线性模型，一种是梯度模型。&lt;/p&gt;
&lt;p&gt;简单的理解，线性模型就是 &lt;code&gt;y = rate * x + min&lt;/code&gt;，设置最小值，以及伸缩的区间，并根据当前节点的数目，通过线性模型计算所需的核心组件数目。在上面的例子中，我们用的就是线性模型，线性模型支持的配置参数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs json&quot;&gt;{
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;coresPerReplica&quot;: &lt;span class=&quot;hljs-number&quot;&gt;2,
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;nodesPerReplica&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1,
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;min&quot;: &lt;span class=&quot;hljs-number&quot;&gt;1,
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;max&quot;: &lt;span class=&quot;hljs-number&quot;&gt;100,
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;preventSinglePointFailure&quot;: &lt;span class=&quot;hljs-literal&quot;&gt;true
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;max&lt;/code&gt;、以及&lt;code&gt;preventSinglePointFailure&lt;/code&gt;都比较好理解，&lt;code&gt;coresPerReplica&lt;/code&gt;的意思是按照核心数目来计算副本集，&lt;code&gt;nodesPerReplica&lt;/code&gt;是按照节点数目来计算副本集。用一个实际的例子进行举例，例如当前集群有两个节点，每个节点的配置是4C8G，那么如果按照&lt;code&gt;coresPerReplica&lt;/code&gt;这个指标计算，则需要弹出4*2/2=4个副本。如果按照nodesPerReplica来计算，则需要弹出2*1 = 2个副本。此时cluster-proportional-autoscaler会取两者之间的大的数值，也就是4作为最后的伸缩数目进行扩容。&lt;/p&gt;
&lt;p&gt;梯度模型就是分级的机制，每个梯度对应了一个副本，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs json&quot;&gt;{
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;coresToReplicas&quot;:
      [
        [ &lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;1 ],
        [ &lt;span class=&quot;hljs-number&quot;&gt;64, &lt;span class=&quot;hljs-number&quot;&gt;3 ],
        [ &lt;span class=&quot;hljs-number&quot;&gt;512, &lt;span class=&quot;hljs-number&quot;&gt;5 ],
        [ &lt;span class=&quot;hljs-number&quot;&gt;1024, &lt;span class=&quot;hljs-number&quot;&gt;7 ],
        [ &lt;span class=&quot;hljs-number&quot;&gt;2048, &lt;span class=&quot;hljs-number&quot;&gt;10 ],
        [ &lt;span class=&quot;hljs-number&quot;&gt;4096, &lt;span class=&quot;hljs-number&quot;&gt;15 ]
      ],
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;nodesToReplicas&quot;:
      [
        [ &lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;1 ],
        [ &lt;span class=&quot;hljs-number&quot;&gt;2, &lt;span class=&quot;hljs-number&quot;&gt;2 ]
      ]
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个配置表示存在&lt;code&gt;coresToReplicas&lt;/code&gt;和&lt;code&gt;nodesToReplicas&lt;/code&gt;两个梯度，其中&lt;code&gt;coresToReplicas&lt;/code&gt;的梯度表示，最小为1个副本；CPU核心数目大于3小于64的时候，为2个副本；依次类推。同样&lt;code&gt;nodesToReplicas&lt;/code&gt;表示1个节点的时候为1个副本，2个节点的时候为2个副本。&lt;/p&gt;
&lt;h4 id=&quot;3&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;至此，cluster-proportional-autoscaler的使用就给大家讲解完了，建议优先配置&lt;code&gt;CoreDNS&lt;/code&gt;的autoscaler，对于负载不高的场景可以考虑节点副本1:2的比例，如果负载比较高，可以1:1的配置进行配置。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/680239?utm_content=g_1000040448&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 07:22:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>前言 在本系列的前三篇中，我们介绍了弹性伸缩的整体布局以及HPA的一些原理，HPA的部分还遗留了一些内容需要进行详细解析。在准备这部分内容的期间，会穿插几篇弹性伸缩组件的最佳实践。今天我们要讲解的是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10334276.html</dc:identifier>
</item>
<item>
<title>TortoiseGit 使用教程 - 啊，那一个人</title>
<link>http://www.cnblogs.com/anayigeren/p/10177027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anayigeren/p/10177027.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　作为一个软件开发人员，不可能不知道Git。Git作为一个复杂的版本控制系统，命令之多，即使经常使用，一些命令也记不住，一般只记住几个常用的命令，不是所有使用Git命令行都是高效的。本教程不讲Git命令，而是先让你用上git，再去学习git。本教程应该称作TortoiseGit入门指南。因为下面要借助一个图形化的软件，TortoiseGit来操作git。用GUI（图形界面）再谈CLI（命令行），我相信这会更容易让人接受。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;git使用教程&quot; data-source-line=&quot;1&quot;&gt;TortoiseGit 简介&lt;/h3&gt;
&lt;blockquote data-source-line=&quot;5&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;TortoiseGit 简称 tgit， 中文名海龟Git。TortoiseGit是一个开放的GIT版本控制系统的源客户端。&lt;/p&gt;
&lt;p&gt;TortoiseGit 支持Winxp/vista/win7/Win10，提供有中文版支持。&lt;/p&gt;
&lt;p&gt;TortoiseGit 可以恢复您的文件的旧版本，并研究如何以及合适改变了历史数据，谁改变了它。下面教程针对使用TortoiseGit 的用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div data-source-line=&quot;11&quot; data-role=&quot;mermaid&quot; data-src=&quot;graph%20LR%0AGit2.9--%3ETortoisegit64%0ATortoisegit64--%3ETortoisegitLanguagepack%0A&quot; data-processed=&quot;true&quot; data-processed-src=&quot;graph%20LR%0AGit2.9--%3ETortoisegit64%0ATortoisegit64--%3ETortoisegitLanguagepack%0A&quot; readability=&quot;29.548480463097&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下载安装Git及Tortoisegit&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;54.16496350365&quot;&gt;
&lt;p&gt;　　环境安装，需要依次安装以下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226093653263-1799208160.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第1步：&lt;/strong&gt;下载Git，下载地址：&lt;a href=&quot;https://git-for-windows.github.io/&quot; target=&quot;_blank&quot;&gt;https://git-for-windows.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226093132806-1986443552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Git 安装过程不详述，可参考：https://www.cnblogs.com/wj-1314/p/7993819.html&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第2步：&lt;/strong&gt;下载安装Tortoisegit及中文语言包（Tortoisegit及语言包&lt;a href=&quot;http://tortoisegit.org/download/&quot; target=&quot;_blank&quot;&gt;下载&lt;/a&gt; ，Tortoisegit &lt;a href=&quot;https://jingyan.baidu.com/article/f3ad7d0f37a75d09c2345b6f.html&quot; target=&quot;_blank&quot;&gt;安装教程&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226093406774-793372004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Tortoisegit 配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;第1步： &lt;/strong&gt;&lt;/span&gt;首先，请选定一个存放Git项目的目录，这样方便管理. 如: E:\Git，然后在资源管理器中打开：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226101013771-1546783556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第2步： &lt;/strong&gt;在空白处点击鼠标右键，选择 --&amp;gt; TortoiseGit --&amp;gt; Settings，然后就可以看到配置界面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226101238662-1239995954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第3步：&lt;/strong&gt;选中General，在右边的 Language中选择简体中文(当然,你也可以继续使用英文)。取消勾选升级检查的复选框，可能还需要指定 git.exe 文件的路径，如 &quot;D:\Program Files\Git\bin&quot;。完成后，点击应用，确定关闭对话框。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226101620940-451030022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第4步：&lt;/strong&gt;配置用户，用户作为你操作git的个人标识，进入设置，点选左边的Git标签，可以发现,右边可以配置用户的名字与Email信息. 如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226103516088-1463032884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因为当前还没有本地项目,所以 “编辑本地 .git/config(L)” 按钮处于灰色不可用状态，如果在某个本地Git项目下打开配置对话框，那么这个按钮就可用,然后就可以编辑此项目的一些属性。&lt;/p&gt;
&lt;p&gt;　　点击 “编辑全局 .git/config(O)”按钮,会使用记事本打开全局配置文件，在全局配置文件中，在后面加上下面的内容（记住密码）:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[credential]
  helper = store&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　完成后保存，关闭记事本，确定即可。&lt;/p&gt;
&lt;p&gt;　　则当你使用 HTTPS URL 方式推送项目到GitHub等在线仓库时，海龟git会记住你输入的用户名和密码（这里不是用户的姓名和Email哦），可以避免每次提交都要输入用户名和密码。（还有种方式，通过使用 SSH URL 来提交代码便可以一劳永逸了~~~）&lt;/p&gt;
&lt;p&gt;　　如果你编辑的是 本地 .git/config(L)，其实这个翻译为本地有点问题，应该叫局部，也就是在某个项目下面设置，只对此项目有效，配置是一样的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Tortoisegit 使用示例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;克隆一个项目（分别从github仓库、自己搭建的g&lt;/strong&gt;itblit &lt;strong&gt;仓库上获取&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;教程开始之前，补充一个知识点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本地仓库和远程git仓库的连接方式有两种：&lt;strong&gt;HTTPS&lt;/strong&gt; 和 &lt;strong&gt;SSH&lt;/strong&gt;，很多时候都是直接使用 HTTPS URL 方式克隆项目到本地，当然也有有些人使用SSH URL克隆到本地。这两种方式的主要区别在于：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;HTTPS&lt;/strong&gt;：使用起来不用配置，对初学者来说会比较方便，只要复制HTTPS URL然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次 fetch 和 push代码都需要输入账号和密码，这也是HTTPS 方式的麻烦之处。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;SSH&lt;/strong&gt;：&lt;/span&gt;使用SSH URL方式需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。多数介绍Git的博客里面采用的都是https的方式作为案例，今天主要是记录如何配置并在海龟git中使用SSH方式来提交和克隆代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;第1步：&lt;/strong&gt;此处介绍通过&lt;strong&gt;SSH URL方式传输&lt;/strong&gt;，使用之前需要先将本地的 SSH 公钥配置到 Git 服务器上。&lt;/p&gt;
&lt;p&gt;　　先&lt;span&gt;查看SSH Key。在C盘用户主目录用户目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有&lt;/span&gt;&lt;span&gt;&lt;code&gt;id_rsa&lt;/code&gt;和&lt;code&gt;id_rsa.pub&lt;/code&gt;&lt;/span&gt;&lt;span&gt;这两个文件，如果已经有了，可直接跳到&lt;strong&gt;第2步&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226113405247-1942190673.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　如果没有上述文件，则需要创建一个SSH Key，&lt;/span&gt;在任意文件夹下点击右键，选择 Git GUI Here。在弹出的程序中选择主菜单的【Help】→【Show SSH Key】：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226114055886-180594107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　如果没有Key，则点击“Generate Key”生成一个SSH Key：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226115510598-122268944.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　把生成的全部内容拷出来。&lt;/p&gt;
&lt;p&gt;　　　　如果一切顺利的话，可以在用户主目录里找到&lt;code&gt;.ssh&lt;/code&gt;目录，里面有&lt;code&gt;id_rsa&lt;/code&gt;和&lt;code&gt;id_rsa.pub&lt;/code&gt;两个文件，这两个就是SSH Key的秘钥对，&lt;code&gt;id_rsa&lt;/code&gt;是私钥，不能泄露出去，&lt;code&gt;id_rsa.pub&lt;/code&gt;是公钥，可以放心地告诉任何人。（其他创建SSH Key方式：&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000&quot; target=&quot;_blank&quot;&gt;通过Shell命令方式创建&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第2步：&lt;/strong&gt;把 SSH Key 填到Git 服务器的配置中。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;GitHub服务器：&lt;/strong&gt;登陆GitHub，【头像】→【Settings】→【SSH and GPG Keys】→【New SSH Key】，填入上一步的复制的SSHKey，然后【Add SSH Key】：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226121245026-1546328791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Gitblit 服务器&lt;/strong&gt;（自己搭建 Git 服务器，Gitblit的安装教程&lt;a href=&quot;https://www.cnblogs.com/anayigeren/p/10175367.html&quot; target=&quot;_blank&quot;&gt;请看这里&lt;/a&gt;），登录 Gitblit账户，在【头像】→【用户中心】→【SSH Keys】，填入上一步的复制的SSHKey，然后【添加】&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226132901278-1097084455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第3步：&lt;/strong&gt;要克隆 GitHub 或 Gitblit&lt;strong&gt; &lt;/strong&gt;上的项目，先要获取对应远程存储库的路径（&lt;strong&gt;注意：此处使用 SSH URL 方式&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　GitHub仓库&lt;/strong&gt;：从 GitHub项目页面上得到对应存储库的 giturl 路径：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226122012947-1020013679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Gitblit 仓库：&lt;/strong&gt;在存储库页面这个位置得到存储库的 giturl 路径：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226133807571-386299740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第4步：&lt;/strong&gt;在本地文件夹的空白位置处，右击鼠标，在菜单中选择【Git克隆】：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226122429702-1374729661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　把git 路径填写到URL，并选择本地文件目录，点击【确定】，弹出下载进度窗口。（服务器端至少要有一个文件，否则 pull的时候会报错 fatal: Couldn't find remote ref HEAD）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227111642077-139096442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;克隆成功，则在文件夹上就可以看到角标标识：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226122800854-457145087.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Git文件上角标符号说明：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;文件上的图标，可以反映出当前文件或者文件夹的状态：&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;justify&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;　　1、正常的：&lt;strong&gt;绿色的对号 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226130633376-1375659427.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2、被修改过的：&lt;strong&gt;红色感叹号  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226130659002-1901548592.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　3、新添加的：&lt;strong&gt;蓝色的加号&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226130708046-702059723.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　4、未受控的（无版本控制的）：&lt;strong&gt;蓝色的问号&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226130715848-1344413806.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　5、忽略不受控的：&lt;strong&gt;灰色的减号&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226130727649-1356151074.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　6、删除的：&lt;strong&gt;红色的x号 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226130737919-811538319.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　7、有冲突的：&lt;strong&gt;黄色的感叹号 &lt;/strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181226130617418-883916259.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h4 data-source-line=&quot;38&quot;&gt; &lt;/h4&gt;
&lt;h4 data-source-line=&quot;38&quot;&gt;&lt;span&gt;&lt;strong&gt;将代码提交到服务器&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Git的使用类似TFS、SVN等源代码或者文件管理器，惯例的流程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227115208257-1683338978.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div data-source-line=&quot;41&quot; data-role=&quot;mermaid&quot; data-src=&quot;graph%20LR%0A%E6%94%B9%E5%8A%A8--%3E%E6%8F%90%E4%BA%A4%E6%9C%AC%E5%9C%B0%0A%E6%8F%90%E4%BA%A4%E6%9C%AC%E5%9C%B0--%3E%E5%90%8C%E6%AD%A5%E6%8B%89%E5%8F%96%0A%E5%90%8C%E6%AD%A5%E6%8B%89%E5%8F%96--%3E%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%0A%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3--%3E%E7%BC%96%E8%AF%91OK%0A%E7%BC%96%E8%AF%91OK--%3E%E6%8E%A8%E9%80%81%E8%BF%9C%E7%A8%8B%0A&quot; data-processed=&quot;true&quot; data-processed-src=&quot;graph%20LR%0A%E6%94%B9%E5%8A%A8--%3E%E6%8F%90%E4%BA%A4%E6%9C%AC%E5%9C%B0%0A%E6%8F%90%E4%BA%A4%E6%9C%AC%E5%9C%B0--%3E%E5%90%8C%E6%AD%A5%E6%8B%89%E5%8F%96%0A%E5%90%8C%E6%AD%A5%E6%8B%89%E5%8F%96--%3E%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%0A%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3--%3E%E7%BC%96%E8%AF%91OK%0A%E7%BC%96%E8%AF%91OK--%3E%E6%8E%A8%E9%80%81%E8%BF%9C%E7%A8%8B%0A&quot; readability=&quot;58.86524822695&quot;&gt;
&lt;p&gt;&lt;strong&gt;　　第一步：&lt;/strong&gt;改动，修改本地项目中的&lt;span&gt;某些文件，如修改 README.md&lt;/span&gt; 内容，还可以增加一些文件， 如Hello.txt。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第二步：&lt;/strong&gt;提交本地，在本地项目的空白处点击鼠标右键，选择 【Git提交(C) -&amp;gt; &quot;master&quot;...】&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227100121491-491368160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在弹出提交（Commit）对话框中完成提交说明信息，和选择需要提交的文件，可根据需要新建分支，然后点击 【提交】 按钮，将修改提交到&lt;strong&gt;本地仓库：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190103171759895-2065852804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　弹出提交进度窗口，提交成功后还需要“推送”将本地仓库的修改推送到&lt;strong&gt;远程仓库&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227101140031-683442032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　第3步：&lt;/strong&gt;同步拉取，在实际工作中，如果多人协作或者多个客户端进行修改，那么我们还要拉取别人推送到在线仓库的内容，所以在推送之前需要先执行同步拉取(Pull ...)操作。&lt;/p&gt;
&lt;p&gt;　　在本地仓库文件夹上【右击鼠标】→【Git同步】：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227130530378-1669594219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开Git同步窗口（包括常规操作及日志，同右击菜单快捷操作一样），点击【拉取(P)】，将远程分支拉取到本地：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227132850405-85698829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果服务器上的文件没有被修改过，就会直接提示已经更新到最新，那你就可以直接进行下一步“推送(H)”操作了：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227132243336-896908105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　反之，如果服务器上的文件被修改过了（本地文件修改前不是最新版本），就会提示冲突。先要解决冲突，然后再提交结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227134452525-392356522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　需要注意的是，和使用TFS、SVN的习惯一样，你在修改本地内容之前，最好先 拉取（pull）一下，减少冲突的可能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;第四步：推送远程，将提交到本地仓库的修改推送到远程仓库，可以直接在提交成功后的提示窗口上点击【推送(H)...】，或者在Git同步窗口点击【推送(H)...】，鼠标右击的菜单上也有相应的快捷操作：选择 【TortoiseGit(T)】→【推送(H)...】&lt;/p&gt;
&lt;p&gt;　　弹出推送(push)对话框：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227101955704-1846772346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一般保持默认,点击 “确定” 按钮&lt;/p&gt;
&lt;p&gt;　　然后弹出推送进度界面，可能要求你输入用户名，点击【确定】，然后要求输入密码，密码输入正确后，显示推送成功界面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201812/1545277-20181227102125969-798122801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果你按照上一小节&lt;strong&gt;Tortoisegit 配置&lt;/strong&gt;的设置操作，则输入密码以后会记住密码。密码会明文保存在C:\Users\用户名\.git-credentials 这个文件中，请小心保存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上就是海龟Git常规的操作流程，git的功能很强大，相应的命令也很多，使用图形界面把Git的操作简化了确是大大的方便。除了小海龟还有 &lt;a href=&quot;https://www.sourcetreeapp.com/&quot; target=&quot;_blank&quot;&gt;Source Tree&lt;/a&gt;，也是开源且好用的Git GUI管理工具，待得有空小编再整理一份Source Tree的操作教程。补充一点，因为很多项目是在VS上进行开发的，所以更多的情况，我们不会去使用文件夹上的操作，而是结合VS的git模块来进行操作，查看&lt;a href=&quot;https://www.cnblogs.com/anayigeren/p/10185251.html&quot; target=&quot;_blank&quot;&gt;VS2017中使用Git进行版本控制&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;推荐廖雪峰的&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 29 Jan 2019 07:09:00 +0000</pubDate>
<dc:creator>啊，那一个人</dc:creator>
<og:description>该文章转自：https://note.youdao.com/share/?id=dc4d97ed11598f4cc27db60ce87dde5a&amp;type=note#/（大师兄的Git说明教程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anayigeren/p/10177027.html</dc:identifier>
</item>
<item>
<title>H5与企业微信jssdk集成 - _herbert</title>
<link>http://www.cnblogs.com/yfrs/p/weixinh5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yfrs/p/weixinh5.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;author herbert QQ:464884492&lt;/span&gt;
&lt;span&gt;getAccessToken() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否缓存有&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; access_token = localStorage.getItem(&quot;accessToken&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; expires = localStorage.getItem(&quot;expires_accessToken&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (expires &amp;gt; &lt;span&gt;new&lt;/span&gt; Date().getTime() - 2000&lt;span&gt;) {
resolve(access_token);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
let accessTokenUrl &lt;/span&gt;= 'https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=' + &lt;span&gt;this&lt;/span&gt;.groupId + &quot;&amp;amp;corpsecret=&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.secretId;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fetch(accessTokenUrl, { method: &quot;GET&quot; })&lt;/span&gt;
fetch(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.porxyUrl, {
method: &lt;/span&gt;&quot;POST&quot;&lt;span&gt;,
body: JSON.stringify({
method: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
url: accessTokenUrl
})
}).then(resp &lt;/span&gt;=&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resp.json()
}).then(data &lt;/span&gt;=&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.errcode == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存本次获取的accessToken&lt;/span&gt;
localStorage.setItem(&quot;accessToken&quot;&lt;span&gt;, data.access_token);
localStorage.setItem(&lt;/span&gt;&quot;expires_accessToken&quot;, &lt;span&gt;new&lt;/span&gt; Date().getTime() + data.expires_in * 1000&lt;span&gt;);
resolve(data.access_token);
}
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(data =&amp;gt;&lt;span&gt; {
reject();
})
});
},&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 29 Jan 2019 07:06:00 +0000</pubDate>
<dc:creator>_herbert</dc:creator>
<og:description>H5与企业微信jssdk集成 一、公众号设置 注册企业微信，在应用与小程序栏目中，设置可信域名，配置公众号菜单。可信域名不得不说下，在最初开发时，认为设置并验证后，微信认证接口会实现跨域请求，其实并没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yfrs/p/weixinh5.html</dc:identifier>
</item>
<item>
<title>Docker镜像细节 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10334013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10334013.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只有光头才能变强。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.9545454545455&quot;&gt;
&lt;p&gt;文本已收录至我的GitHub仓库，欢迎Star：&lt;a href=&quot;https://github.com/ZhongFuCheng3y/3y&quot; class=&quot;uri&quot;&gt;https://github.com/ZhongFuCheng3y/3y&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/168985468c9c389b?w=1566&amp;amp;h=696&amp;amp;f=png&amp;amp;s=294564&quot; alt=&quot;Docker&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回顾前面：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前面两篇已经讲解了为什么需要Docker这项技术，以及解释了Docker的基本概念/术语，使用Docker成功运行Tomcat~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上篇也同样留下一个问题：&lt;code&gt;我们知道Tomcat运行起来需要Java的支持，那么我们在DockerHub拉取下来的Tomcat镜像是不是也有Java环境呢？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以，这篇主要来讲讲Docker镜像相关的知识点！&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Dockerfile是用来&lt;strong&gt;构建Docker镜像的文件&lt;/strong&gt;，是由一系列命令和参数构成的&lt;strong&gt;脚本&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说：Dockerfile是镜像的&lt;strong&gt;源码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上一篇我们&lt;code&gt;pull&lt;/code&gt;了一份&lt;code&gt;Tomcat&lt;/code&gt;的镜像，我们也可以去看看它的Dockerfile长的什么样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/168985468e51ea39?w=1158&amp;amp;h=818&amp;amp;f=png&amp;amp;s=24191&quot; alt=&quot;搜索，拉下去就有得看Dockerfile了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们随便点进去一个看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/168985468c799520?w=1409&amp;amp;h=779&amp;amp;f=png&amp;amp;s=39087&quot; alt=&quot;Dockerfile&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在Dockerfile的第一行就可以发现&lt;code&gt;FROM openjdk:8-jre&lt;/code&gt;，所以可以确定的是：在DockerHub拉取下来的Tomcat镜像&lt;strong&gt;一定有Java环境&lt;/strong&gt;！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在这里我们先不说如何&lt;code&gt;阅读/编写&lt;/code&gt;Dockerfile文件，先了解到Dockerfile是镜像的源码即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说：通过Dockerfile文件可以知道我们拉取下来的镜像究竟是怎么构建的。&lt;/p&gt;

&lt;p&gt;我们知道Docker Hub有很多常用的镜像，比如说&lt;code&gt;Centos&lt;/code&gt;。我们去&lt;code&gt;pull&lt;/code&gt;一个下来看看Docker中的&lt;code&gt;Centos&lt;/code&gt;长啥样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/168985468e861fec?w=1454&amp;amp;h=335&amp;amp;f=png&amp;amp;s=20431&quot; alt=&quot;从Hub中pull一个Centos&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现的是：&lt;code&gt;Tomcat&lt;/code&gt;的&lt;strong&gt;SIZE&lt;/strong&gt;竟然比&lt;code&gt;Centos&lt;/code&gt;还要大！但按我们&lt;strong&gt;常规&lt;/strong&gt;的想法，&lt;code&gt;Centos&lt;/code&gt;的镜像可能是3或4GB(现在200M)，&lt;code&gt;Tomcat&lt;/code&gt;的镜像可能就200M(现在400M)。这是为什么呢？？&lt;/p&gt;
&lt;p&gt;如果我们在&lt;code&gt;pull&lt;/code&gt;的时候观察得比较仔细的话，可以发现&lt;code&gt;pull&lt;/code&gt;会拉下很多&lt;strong&gt;层&lt;/strong&gt;镜像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/168985468ec65aed?w=1551&amp;amp;h=423&amp;amp;f=png&amp;amp;s=18736&quot; alt=&quot;pull到很多层镜像&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完全&lt;code&gt;pull&lt;/code&gt;下来的之后，我们如果使用&lt;code&gt;docker images&lt;/code&gt;只能查看到&lt;strong&gt;最终&lt;/strong&gt;的镜像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/168985468e91c27e?w=1372&amp;amp;h=121&amp;amp;f=png&amp;amp;s=7148&quot; alt=&quot;只能看到最终我们拉下来的镜像&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们使用&lt;code&gt;docker images -a&lt;/code&gt;命令的话，可以把&lt;strong&gt;中间层镜像&lt;/strong&gt;都查出来：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;理想效果&lt;/strong&gt;：(在镜像列表里边除了tomcat和centos应该还&lt;strong&gt;夹杂&lt;/strong&gt;着名为&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;的镜像)&lt;/li&gt;
&lt;li&gt;遗憾的是：&lt;strong&gt;博主一直没测出效果来，也就是我的镜像列表里没有&lt;/strong&gt;&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;的镜像(怀疑是版本的问题，我的版本是Docker版本是18.09.1，Centos的版本是CentOS Linux release 7.3.1611 。如果知道具体原因的不妨在评论区下告诉我)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/16898546f219aa9c?w=1850&amp;amp;h=159&amp;amp;f=png&amp;amp;s=14112&quot; alt=&quot;理想效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Emmm,我们可以使用&lt;code&gt;history&lt;/code&gt;命令来看看，可以发现Tomcat&lt;strong&gt;包含很多个镜像层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/16898546fe6404e0?w=1920&amp;amp;h=1030&amp;amp;f=png&amp;amp;s=87816&quot; alt=&quot;使用history命令可以发现Tomcat包含很多个镜像层&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;还可以发现一点：Dockerfile有多少条命令，那就有多少个镜像层(不信你数数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说了那么多，就想让大家知道：我们拉取下来的镜像实际上是由很多&lt;strong&gt;中间层镜像&lt;/strong&gt;组成的。&lt;/p&gt;
&lt;p&gt;再结合我们上一篇&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484631&amp;amp;idx=1&amp;amp;sn=ffca3c18cce7392ef96dce268cd7d6df&amp;amp;chksm=ebd745d6dca0ccc0964a4c99afaa030c997ee75379e14b5d7fc0beacc4c59f33318af266a7ce#rd&quot;&gt;Docker入门为什么可以这么简单？&lt;/a&gt;，在解决Tomcat启动时一直卡住问题时，能够发现的是，我们可以使用&lt;code&gt;cd, ls&lt;/code&gt;等基础命令，但无法使用&lt;code&gt;vi&lt;/code&gt;命令(需要我自己去下载)。&lt;/p&gt;
&lt;p&gt;我们可以&lt;strong&gt;推断&lt;/strong&gt;出，&lt;code&gt;pull&lt;/code&gt;下来的镜像由很多层镜像组成【这些镜像都是&lt;strong&gt;精简&lt;/strong&gt;过的(甚至连&lt;code&gt;vi&lt;/code&gt;命令都不支持)】&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为&lt;code&gt;Tomcat&lt;/code&gt;镜像要的基础环境比&lt;code&gt;Centos&lt;/code&gt;镜像要多，所以&lt;code&gt;Tomcat&lt;/code&gt;镜像的&lt;strong&gt;SIZE&lt;/strong&gt;比&lt;code&gt;Centos&lt;/code&gt;要大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于Docker镜像，有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由&lt;code&gt;Dockerfile&lt;/code&gt;生成&lt;/li&gt;
&lt;li&gt;呈现&lt;strong&gt;层级&lt;/strong&gt;结构&lt;/li&gt;
&lt;li&gt;每层镜像包含：镜像文件以及镜像&lt;code&gt;json&lt;/code&gt;元数据信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/29/16898547148440df?w=1874&amp;amp;h=764&amp;amp;f=png&amp;amp;s=289787&quot; alt=&quot;Docker镜像示意图&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.83333333333333&quot;&gt;
&lt;p&gt;图像来源：&lt;a href=&quot;http://open.daocloud.io/allen-tan-docker-xi-lie-zhi-shen-ke-li-jie-docker-jing-xiang-da-xiao/&quot; class=&quot;uri&quot;&gt;http://open.daocloud.io/allen-tan-docker-xi-lie-zhi-shen-ke-li-jie-docker-jing-xiang-da-xiao/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;镜像呈现层级结构&quot;&gt;3.1镜像呈现层级结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;联合文件系统&lt;/strong&gt;(UnionFS)是实现Docker镜像的技术基础。在Docker中一般使用是&lt;strong&gt;AUFS&lt;/strong&gt;(Another Union File System或Advanced Multilayered Unification File System)【具体还是得看宿主机用的什么系统】。&lt;/p&gt;
&lt;p&gt;在搜索中文资料的时候，常常会发现有类似的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;“AUFS是一种 Union FS, 简单来说就是“支持将不同目录挂载到同一个虚拟文件系统下的文件系统”, AUFS支持为每一个成员目录设定只读(Rreadonly)、读写(Readwrite)和写(Whiteout-able)权限。Union FS 可以将一个Readonly的Branch和一个Writeable的Branch联合在一起挂载在同一个文件系统下”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看得我一头雾水....后来去官方文档介绍AUFS：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;AUFS is a union filesystem, which means that it layers multiple directories on a single Linux host and presents them as a single directory. These directories are called branches in AUFS terminology, and layers in Docker terminology&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说白了，还是可以理解成：Docker的镜像的基础是&lt;strong&gt;联合文件系统&lt;/strong&gt;，它支持将文件系统中的修改信息作为一次提交，并&lt;strong&gt;层层叠加&lt;/strong&gt;，外界看到的是&lt;strong&gt;最外层&lt;/strong&gt;的镜像。(比如外界只看到Tomcat镜像，而中间叠加了很多层镜像)&lt;/p&gt;
&lt;p&gt;(这里只是拿AUFS说明，Docker实际上支持很多存储驱动，比如还有&lt;code&gt;devicemapper，overlay2（Ubuntu的14.04.4或更高版本，16.04或更高版本）， overlay，zfs&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;镜像继承共享&quot;&gt;3.1.1镜像继承(共享)&lt;/h3&gt;
&lt;p&gt;Docker镜像可以通过分层来进行&lt;strong&gt;继承&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;hello-world&lt;/code&gt;的Dockerfile镜像&lt;code&gt;FROM scratch&lt;/code&gt;镜像，&lt;code&gt;scratch&lt;/code&gt;在Docker中是一个&lt;strong&gt;基础镜像&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
FROM scratch
COPY hello /
CMD [&quot;/hello&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Centos&lt;/code&gt;的Dockerfile镜像也是&lt;code&gt;FROM scratch&lt;/code&gt;镜像：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
FROM scratch
ADD centos-7-docker.tar.xz /

LABEL org.label-schema.schema-version=&quot;1.0&quot; \
    org.label-schema.name=&quot;CentOS Base Image&quot; \
    org.label-schema.vendor=&quot;CentOS&quot; \
    org.label-schema.license=&quot;GPLv2&quot; \
    org.label-schema.build-date=&quot;20181205&quot;

CMD [&quot;/bin/bash&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么&lt;code&gt;Centos&lt;/code&gt;镜像和&lt;code&gt;hello-world&lt;/code&gt;共享同一个基础镜像层&lt;code&gt;scratch&lt;/code&gt;，提高了&lt;strong&gt;存储效率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;再说个例子，比如我们有一个&lt;code&gt;Centos&lt;/code&gt;镜像，这个镜像大小是&lt;code&gt;202M&lt;/code&gt;。然后，我们基于&lt;code&gt;Centos&lt;/code&gt;镜像&lt;strong&gt;手动&lt;/strong&gt;往里边添加一个&lt;code&gt;Tomcat&lt;/code&gt;(假设这个Tomcat的大小是&lt;code&gt;300M&lt;/code&gt;)，生成一个镜像，总大小就是&lt;code&gt;502M&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;如果仅仅是单纯的累加这两个镜像的大小：&lt;code&gt;202M+502M=704M&lt;/code&gt;，但是由于&lt;strong&gt;镜像复用的存在&lt;/strong&gt;，实际占用的磁盘空间大小是：&lt;code&gt;202M+300M=502M&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;AUFS uses the Copy-on-Write (CoW) strategy to maximize storage efficiency and minimize overhead。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想要了解COW，不妨阅读我之前写过的文章：&lt;/p&gt;
&lt;h2 id=&quot;json文件&quot;&gt;3.2json文件&lt;/h2&gt;
&lt;p&gt;Docker每一层镜像的&lt;code&gt;json&lt;/code&gt;文件，都扮演着一个非常重要的角色，其主要的作用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;记录 Docker 镜像中与容器&lt;strong&gt;动态信息&lt;/strong&gt;相关的内容&lt;/li&gt;
&lt;li&gt;记录父子 Docker 镜像之间真实的&lt;strong&gt;差异&lt;/strong&gt;关系&lt;/li&gt;
&lt;li&gt;弥补 Docker 镜像内容的完整性与动态内容的缺失&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Docker镜像的&lt;code&gt;json&lt;/code&gt;文件可以认为是镜像的&lt;strong&gt;元数据&lt;/strong&gt;信息&lt;/p&gt;

&lt;p&gt;今天简单地聊了一下Docker镜像的一些细节，但没去深入了解，想要继续深入的同学还得通过官方文档等途径去学习哈。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Allen 谈 Docker
&lt;/li&gt;
&lt;li&gt;官方文档介绍AUFS
&lt;/li&gt;
&lt;li&gt;Docker核心实现技术(命名空间&amp;amp;控制组&amp;amp;联合文件系统&amp;amp;Linux网络虚拟化支持)
&lt;/li&gt;
&lt;li&gt;Docker联合文件系统Union File System
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;乐于输出&lt;strong&gt;干货&lt;/strong&gt;的Java技术公众号：Java3y。公众号内有200多篇&lt;strong&gt;原创&lt;/strong&gt;技术文章、海量视频资源、精美脑图，不妨来&lt;strong&gt;关注&lt;/strong&gt;一下！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687efaed8e2c35c?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=21338&quot; alt=&quot;帅的人都关注了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;觉得我的文章写得不错，不妨点一下&lt;strong&gt;赞&lt;/strong&gt;！&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 06:40:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>前言 只有光头才能变强。 文本已收录至我的GitHub仓库，欢迎Star： 'https://github.com/ZhongFuCheng3y/3y' 回顾前面： '为什么需要Docker？' 'D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10334013.html</dc:identifier>
</item>
<item>
<title>Bootstrap 实战之响应式个人博客 （一） - 蔚蓝的蓝</title>
<link>http://www.cnblogs.com/welan/p/10332038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/welan/p/10332038.html</guid>
<description>&lt;h2 id=&quot;一示例&quot;&gt;一、示例&lt;/h2&gt;
&lt;h3 id=&quot;主页&quot;&gt;1、主页&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/index.png&quot; alt=&quot;博客首页&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;博客详情页&quot;&gt;2、博客详情页&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/blog.png&quot; alt=&quot;博客详情页&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在线地址&quot;&gt;3、在线地址&lt;/h3&gt;
&lt;p&gt;在线地址：&lt;a href=&quot;https://weilanhanf.github.io/&quot;&gt;入口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Addition&lt;/strong&gt;：这里使用github-page将自己的静态项目免费部署到线上。&lt;br/&gt;如果你只是做一些简单的静态项目做展示，付出这么大的时间和经济成本去专门购买一台云服务器显然是得不偿失的。github提供了github-page让用户可以免费部署自己的静态站点。更多参考：&lt;a href=&quot;https://pages.github.com/&quot;&gt;github-page&lt;/a&gt;&lt;br/&gt;在本项目的静态站点部署时与其他的代码仓库，提交同步没有太大的区别（&lt;strong&gt;言外之意&lt;/strong&gt;：还是有点不同的）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一点：需要将项目目录名设置为 &lt;strong&gt;”github用户名.github.io”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;第二点：作为一个静态博客站点，需要设置一个&lt;strong&gt;index.html&lt;/strong&gt;或者&lt;strong&gt;default.html&lt;/strong&gt;，作为默认的站点首页。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;：既然想利用免费的github-page就要根据别人的规则。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解释一：一旦将你的项目名称设置为 &lt;strong&gt;”github用户名.github.io”&lt;/strong&gt; 之后，那么github就会自动为你根据你的醒目名称转换分配一个域名，也就是“github用户名.github.io”，比如该静态站点的地址：&lt;a href=&quot;https://weilanhanf.github.io/&quot; class=&quot;uri&quot;&gt;https://weilanhanf.github.io/&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;解释二：通常我们在访问一个url的时候，如果只有web服务器的域名，省略了文件名的形式，比如 &lt;strong&gt;“https://weilanhanf.github.io/”&lt;/strong&gt; ，那么服务器怎么知道要访问那个文件呢？这个url是以&lt;strong&gt;/&lt;/strong&gt;结尾的，那么说明他就要访问一个名叫&lt;strong&gt;“/”&lt;/strong&gt;的目录，由于省略掉了文件名，就 直接访问&lt;strong&gt;index.html&lt;/strong&gt;或者&lt;strong&gt;default.html&lt;/strong&gt;这样的文件了，这个设置根据服务器的不同而不同，大多数情况是这样。那么下面呢？ &lt;strong&gt;”https://weilanhanf.github.io”&lt;/strong&gt; ，直接省略掉“/”，这种写法也是允许的，当没有路径名的时候，就代表访问根目录下事先设置的默认文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Problems&lt;/strong&gt;：unsolved&lt;br/&gt;我在使用github-page搭建静态站点的时候，出现小图标不显示的问题。可能是服务器没配置的原因吧（-_-!!!），还望大家帮忙解决。&lt;br/&gt;上次阿里云上部署Django项目的时候，后台xadmin（bootstrap）管理系统，也有类似小图标的问题，修改&lt;strong&gt;nginx&lt;/strong&gt;配置文件之后，问题解决。参考链接：&lt;a href=&quot;http://newsn.com.cn/say/nginx-apache-conf-svg-fonts.html&quot;&gt;入口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;废话说多了，下面步入正题。&lt;/p&gt;
&lt;h3 id=&quot;响应后首页&quot;&gt;4、响应后首页&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/respon_index.png&quot; alt=&quot;响应后首页&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在点击menu菜单之后，导航栏垂直排列显示&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二项目目录结构&quot;&gt;二、项目目录结构&lt;/h2&gt;
&lt;p&gt;目录简介：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;index.html：首页&lt;/li&gt;
&lt;li&gt;blog.html：博客详情页&lt;/li&gt;
&lt;li&gt;img：图片存储目录&lt;/li&gt;
&lt;li&gt;css/bootstrap.min.css：目录下的样式表文件 bootstrap.min.css ，里面定义了大量的 CSS 规则&lt;/li&gt;
&lt;li&gt;css/main.css：自定义css样式，覆盖bootstrap源文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/directory.png&quot; alt=&quot;项目目录结构&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三引入文件&quot;&gt;三、引入文件&lt;/h2&gt;
&lt;p&gt;Bootstrap 是一个前端开发框架。其实说白了就是一个样式表文件（bootstrap.min.css）和一个 javascript 文件（bootstrap.min.js），简单的博客页面，未使用JavaScript插件，在页面里把它们引入进来后，就可以直接使用里面的 CSS 规则和各种组件了。&lt;br/&gt;这里采用本地引入，也可以使用&lt;strong&gt;远程CDN引入&lt;/strong&gt;，有节省本地网络资源的作用。&lt;br/&gt;BootCDN：&lt;a href=&quot;https://www.bootcdn.cn/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建立文件，以及引入样式表和自定义样式表文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;index&amp;lt;/title&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.min.css&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/main.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;attention&lt;/strong&gt;&lt;br/&gt;注意样式表文件的前后顺序，如果不对，会导致页面无法正常运行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先引入 bootstrap.min.css （Bootstrap的样式表文件）&lt;/li&gt;
&lt;li&gt;然后引入自己写的 css 文件（main.css）&lt;br/&gt;这样才能起到自定义样式覆盖bootsrap样式的作用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;addition&lt;/strong&gt;&lt;br/&gt;另外如果在前端中需要引入大量javaScirpt文件的时候，一般将js文件置于html文件的尾部，这样做的目的是：&lt;br/&gt;在网络不畅的时候会先加载出页面的主体结构，样式布局，这样会给用户一个页面的大概感受，而js文件在整体页面加载出来之后才会加载，使用户浏览此页面的体验尽可能最好。&lt;/p&gt;
&lt;h2 id=&quot;四布局结构&quot;&gt;四、布局结构&lt;/h2&gt;
&lt;p&gt;布局分为几大部分：&lt;br/&gt;&lt;strong&gt;导航栏，左侧菜单栏，中间主体博客列表，右侧推荐位，页尾。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/index_stru.png&quot; alt=&quot;首页布局结构&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五导航栏&quot;&gt;五、导航栏&lt;/h2&gt;
&lt;h3 id=&quot;作用&quot;&gt;1、作用&lt;/h3&gt;
&lt;p&gt;导航条位于页面最顶部，提供整个网站所有页面的链接&lt;/p&gt;
&lt;h3 id=&quot;自定义样式&quot;&gt;2、自定义样式&lt;/h3&gt;
&lt;p&gt;在鼠标悬停的时候，导航栏列表的选项，有背景色样式，为&lt;strong&gt;ul&lt;/strong&gt;列表下的列表项添加&lt;strong&gt;navbar-list&lt;/strong&gt;属性，并在&lt;strong&gt;main.css&lt;/strong&gt;中自定义样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.navbar-list li:hover{
    color: #555;
    background-color: #e7e7e7;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在鼠标点击页面跳转登录和注册页的时候，有背景色样式，为&lt;strong&gt;ul&lt;/strong&gt;列表下的列表项添加&lt;strong&gt;navbar-right&lt;/strong&gt;属性，并在&lt;strong&gt;main.css&lt;/strong&gt;中自定义样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.navbar-right li:active{
    color: #555;
    background-color: #e7e7e7;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码&quot;&gt;3、代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;navbar navbar-default&quot;&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;navbar-header&quot;&amp;gt;
            &amp;lt;a class=&quot;navbar-brand&quot; href=&quot;index.html&quot;&amp;gt;My Blog&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;col-sm-offset-2&quot;&amp;gt;
                &amp;lt;ul class=&quot;nav navbar-nav navbar-list&quot;&amp;gt;
                    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;全部分类&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;语言&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;数据结构&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;网络&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;操作系统&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;算法&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;实战&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;/ul&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;ul class=&quot;nav navbar-nav navbar-right&quot;&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;登陆&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;addition&lt;/strong&gt;：这里使用默认的导航栏样式&lt;strong&gt;nav-default&lt;/strong&gt;，导航栏内容包含在&lt;strong&gt;container&lt;/strong&gt;中，&lt;strong&gt;nav-header&lt;/strong&gt;中为页面的logo或者页面的名称。为了满足强迫症，使导航栏菜单列表与页面博客列表对齐，向右推进两个栅格&lt;strong&gt;col-sm-offset-2&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;效果示例&quot;&gt;4、效果示例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/nav.png&quot; alt=&quot;导航栏&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六左侧菜单&quot;&gt;六、左侧菜单&lt;/h2&gt;
&lt;h3 id=&quot;前言栅格结构&quot;&gt;1、前言：栅格结构&lt;/h3&gt;
&lt;p&gt;如果是自己写 CSS ，实现这个均等排列的效果？例如下面通过设置固定宽度/百分比来处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.item { float:left, width: 300px; /*或者 width: 33%*/ }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实不用关心每一份的宽度是多少像素/百分比，只关心能不能自动地平均划分成多少份，也就是说&lt;strong&gt;页面的划分是否是成比例的&lt;/strong&gt;， Bootstrap 的栅格系统布局就是为了实现&lt;strong&gt;自动计算每一份的宽度&lt;/strong&gt;而诞生的。栅格可以理解为一个安全门，它的总长度可以拉长，可以缩短，但是总的间隔数量是不变的，并且所有间隔的宽度都一样。** Bootstrap 的栅格系统规定了每个页面的宽度被平均划分为 12 等份&lt;strong&gt;，不管整个页面的宽度是 1000像素，还是500像素，都会自动计算每一份（1/12）的宽度是多少。通过给栅格布局内部的元素指定&lt;/strong&gt; class** 为 &lt;strong&gt;col-md-&lt;/strong&gt;份数 ，来告诉它的宽度占据这12份里面的几份。&lt;/p&gt;
&lt;p&gt;更多请参考：&lt;a href=&quot;https://v3.bootcss.com/css/#grid&quot;&gt;Bootstrap中文文档：栅格结构&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码-1&quot;&gt;2、代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;div class=&quot;col-sm-2&quot;&amp;gt;
            &amp;lt;div class=&quot;list-group side-bar&quot;&amp;gt;
                &amp;lt;a class=&quot;list-group-item active&quot; role=&quot;button&quot;&amp;gt;随笔&amp;lt;/a&amp;gt;
                &amp;lt;a class=&quot;list-group-item&quot; role=&quot;button&quot;&amp;gt;随笔&amp;lt;/a&amp;gt;
                &amp;lt;a class=&quot;list-group-item&quot; role=&quot;button&quot;&amp;gt;随笔&amp;lt;/a&amp;gt;
                &amp;lt;a class=&quot;list-group-item&quot; role=&quot;button&quot;&amp;gt;随笔&amp;lt;/a&amp;gt;
                &amp;lt;a class=&quot;list-group-item&quot; role=&quot;button&quot;&amp;gt;随笔&amp;lt;/a&amp;gt;
                &amp;lt;a class=&quot;list-group-item&quot; role=&quot;button&quot;&amp;gt;随笔&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;addition&lt;/strong&gt;：使页面内容包含在&lt;strong&gt;container&lt;/strong&gt;中，使用栅格结构需要&lt;strong&gt;row&lt;/strong&gt;，左侧菜单栏占用两个栅格&lt;strong&gt;col-sm-2&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;自定义样式-1&quot;&gt;3、自定义样式&lt;/h3&gt;
&lt;p&gt;为菜单选项去除默认边框，加圆角，加间距，在选中状态下增加背景色。&lt;br/&gt;在&lt;strong&gt;main.css&lt;/strong&gt;中自定义样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.side-bar .list-group-item {
    border: 0;
    margin-bottom: 5px;
    border-radius: 5px;
}

.side-bar .list-group-item .active {
    background-color: #337ab7;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;效果示例-1&quot;&gt;4、效果示例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/left.png&quot; alt=&quot;导航栏&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;七博客列表&quot;&gt;七、博客列表&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;1、前言&lt;/h3&gt;
&lt;p&gt;博客列表页，通常作为博客详情页的导航，根据每一条列表占据的大小，一页有多少可列表项。列表中包括博客页的&lt;strong&gt;链接，标题，简介，作者，热度，发布时间&lt;/strong&gt;等。&lt;/p&gt;
&lt;h3 id=&quot;代码-2&quot;&gt;2、代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;div class=&quot;col-sm-7&quot;&amp;gt;
            &amp;lt;div class=&quot;blog-list&quot;&amp;gt;
                &amp;lt;div class=&quot;blog-list-item clearfix&quot;&amp;gt;
                    &amp;lt;div class=&quot;col-xs-5&quot;&amp;gt;
                        &amp;lt;img src=&quot;image/blog.png&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;&quot;&amp;gt;
                        &amp;lt;a href=&quot;#&quot; class=&quot;title&quot;&amp;gt;
                            记录点滴，记录成长。用博客记录技术与经验的积累，在这里找到志同道合的朋友，编程的乐趣。
                        &amp;lt;/a&amp;gt;
                        &amp;lt;div class=&quot;info&quot;&amp;gt;
                            &amp;lt;span class=&quot;avatar&quot;&amp;gt;&amp;lt;img src=&quot;image/v2-2d45613b0fb8cdd36f53c3b31d0c6ee8_hd.jpg&quot;
                                                      alt=&quot;avatar&quot;&amp;gt;&amp;lt;/span&amp;gt;
                            &amp;lt;span&amp;gt;散人&amp;lt;/span&amp;gt; |
                            &amp;lt;span&amp;gt;2.8K&amp;lt;/span&amp;gt;
                            &amp;lt;span class=&quot;glyphicon glyphicon-thumbs-up blog-hot&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; |
                            &amp;lt;span&amp;gt;5分钟前&amp;lt;/span&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;addition&lt;/strong&gt;：中间博客列表占用七个栅格&lt;strong&gt;col-sm-7&lt;/strong&gt;，增加&lt;strong&gt;clearfix&lt;/strong&gt;清除浮动，使列表项正常垂直排列。&lt;br/&gt;在博客项每一个列表，又使用栅格系统将博客图片和其他介绍内容分开，分别占用&lt;strong&gt;col-xs-5&lt;/strong&gt; 5和&lt;strong&gt;col-xs-7&lt;/strong&gt; 7个位置，（共5+7=12个，够了）。&lt;/p&gt;
&lt;p&gt;这里使用Bootstrap的组件，一个向上竖起大拇指的手作为热度图标。&lt;br/&gt;更多请参考：&lt;a href=&quot;https://v3.bootcss.com/components/#glyphicons&quot;&gt;Bootstrap中文文档：字体图标&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;自定义样式-2&quot;&gt;3、自定义样式&lt;/h3&gt;
&lt;p&gt;默认的&lt;strong&gt;a&lt;/strong&gt;标签也就是超链接，在鼠标悬停的时候会出现一条下划线，把他设置为 &lt;strong&gt;text-decoration: none;&lt;/strong&gt;，并在后边设置为悬停时颜色变浅。&lt;br/&gt;&lt;strong&gt;img&lt;/strong&gt;元素width默认是auto，设置max-width相当于没设置width，max-width是控制溢出宽度、保证宽度不溢出。为&lt;strong&gt;avatar&lt;/strong&gt;下的&lt;strong&gt;img&lt;/strong&gt;元素设置为内联，宽高，边距。&lt;br/&gt;因此对于，博客图片和博客作者头像，是使用不同的图片设置方式。&lt;br/&gt;为列表项，设置内边距，下边框添加样式增加美观度。第一个元素，和最后一个元素区别对待。&lt;br/&gt;博客简介需要设置为块元素，改变样式，字体大小，字重，悬停变色等。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;main.css&lt;/strong&gt;中自定义样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a:hover{
    text-decoration: none;
}

img{
    display: block;
    max-width: 100%;
    border-radius: 5px;
}

.avatar img{
    display: inline-block;
    width: 18px;
    height: 18px;
    margin-right: 3px;
}

.blog-list-item{
    padding-bottom: 15px;
    padding-top: 15px;
    border-bottom: 1px solid #adadad;
}

.blog-list-item:last-child{
    border-bottom: 0;
}

.blog-list-item:first-child{
    padding-top: 0;
}

.blog-list-item .title{
    display: block;
    font-size: 18px;
    font-weight: bold;
    line-height: 2;
    margin-bottom: 15px;
    color: black;
}

.blog-list-item .title:hover {
    color: #9d9d9d;
}

.blog-list-item .info{
    color: #9d9d9d;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;效果示例-2&quot;&gt;4、效果示例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/blog_list.png&quot; alt=&quot;导航栏&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;八右侧栏&quot;&gt;八、右侧栏&lt;/h2&gt;
&lt;h3 id=&quot;效果示例-3&quot;&gt;1、效果示例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/right.png&quot; alt=&quot;导航栏&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言-1&quot;&gt;2、前言&lt;/h3&gt;
&lt;p&gt;可以看出整个右侧推荐位共分为三部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局搜索框&lt;/li&gt;
&lt;li&gt;广告位&lt;/li&gt;
&lt;li&gt;推荐栏&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码-3&quot;&gt;3、代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;div class=&quot;col-sm-3&quot;&amp;gt;
            &amp;lt;div class=&quot;search-bar&quot;&amp;gt;
                &amp;lt;form role=&quot;form&quot;&amp;gt;
                    &amp;lt;div class=&quot;form-group has-feedback&quot;&amp;gt;
                        &amp;lt;label class=&quot;sr-only&quot; for=&quot;Search&quot;&amp;gt;Search：&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;search&quot; class=&quot;form-control&quot; placeholder=&quot;搜索&quot; id=&quot;Search&quot;&amp;gt;
                        &amp;lt;span class=&quot;glyphicon glyphicon-search form-control-feedback&quot;&amp;gt;&amp;lt;/span&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/form&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;side-bar-card clearfix&quot;&amp;gt;
                &amp;lt;div class=&quot;col-xs-5&quot;&amp;gt;
                    &amp;lt;img src=&quot;image/adver.png&quot;&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;col-xs-7 side-bar-introduction&quot;&amp;gt;
                    &amp;lt;div class=&quot;&quot;&amp;gt;代码改变世界&amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;side-bar-phone&quot;&amp;gt;联系电话：XXXX&amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;side-bar-card side-bar-recommend clearfix&quot;&amp;gt;
                &amp;lt;div class=&quot;side-bar-title&quot;&amp;gt;推荐阅读&amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;side-bar-body&quot;&amp;gt;
                    &amp;lt;div class=&quot;side-bar-list&quot;&amp;gt;
                        &amp;lt;div class=&quot;side-bar-item&quot;&amp;gt;
                            &amp;lt;a href=&quot;#&quot; class=&quot;side-item-title&quot;&amp;gt;浅析Django项目优化&amp;lt;/a&amp;gt;
                            &amp;lt;div class=&quot;side-item-info&quot;&amp;gt;10.4k阅读 | 五天前&amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;side-bar-item&quot;&amp;gt;
                            &amp;lt;a href=&quot;#&quot; class=&quot;side-item-title&quot;&amp;gt;python解释器&amp;lt;/a&amp;gt;
                            &amp;lt;div class=&quot;side-item-info&quot;&amp;gt;0.4k阅读 | 一小时前&amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;side-bar-item&quot;&amp;gt;
                            &amp;lt;a href=&quot;#&quot; class=&quot;side-item-title&quot;&amp;gt;web前段优化策略&amp;lt;/a&amp;gt;
                            &amp;lt;div class=&quot;side-item-info&quot;&amp;gt;2.9k阅读 | 一周前&amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;side-bar-item&quot;&amp;gt;
                            &amp;lt;a href=&quot;#&quot; class=&quot;side-item-title&quot;&amp;gt;浅析Django项目优化&amp;lt;/a&amp;gt;
                            &amp;lt;div class=&quot;side-item-info&quot;&amp;gt;1.4k阅读 | 两小时前&amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;side-bar-item&quot;&amp;gt;
                            &amp;lt;a href=&quot;#&quot; class=&quot;side-item-title&quot;&amp;gt;浅析Django项目优化&amp;lt;/a&amp;gt;
                            &amp;lt;div class=&quot;side-item-info&quot;&amp;gt;4.1k阅读 | 两天前&amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;

                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;addition&lt;/strong&gt;：在左侧菜单栏与中间博客列表分别使用栅格结构&lt;strong&gt;col-sm-2&lt;/strong&gt;和&lt;strong&gt;col-sm-7&lt;/strong&gt;，因测&lt;strong&gt;12-2-7=3&lt;/strong&gt;，右侧栏的大小占栅格结构的&lt;strong&gt;col-sm-3&lt;/strong&gt;，整个栅格系统才算完整。&lt;br/&gt;同样的，我们也需要为右侧栏添加&lt;strong&gt;clearfix&lt;/strong&gt;属性，清除浮动。&lt;br/&gt;全局搜索框添加小图标增加美观和指示作用，&lt;strong&gt;label的作用：label标签是用来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;虽然label内部没有介绍信息，但是label元素却是不可缺少的&lt;/strong&gt;，这是因为：&lt;strong&gt;如果你没有为每个输入控件设置 label 标签，屏幕阅读器将无法正确识别。对于内联表单，可以通过为label 设置 .sr-only 类将其隐藏，但却不可缺少。&lt;/strong&gt;&lt;br/&gt;在广告位的位置同样再次使用栅格系统，使得广告照片&lt;strong&gt;col-xs-5&lt;/strong&gt;和广告其他简介信息&lt;strong&gt;col-xs-7&lt;/strong&gt;分开。&lt;/p&gt;
&lt;p&gt;更多请参考：&lt;a href=&quot;https://v3.bootcss.com/css/#forms&quot;&gt;Bootstrap中文文档：表单&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;自定义样式-3&quot;&gt;4、自定义样式&lt;/h3&gt;
&lt;p&gt;为右侧广告位和推荐阅读增加&lt;strong&gt;backgound&lt;/strong&gt;，修圆角。调整边距位置。&lt;br/&gt;当鼠标悬停推荐列表项时，背景色加深与整体推荐列表形成对比，层次分明，更加美观。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;main.css&lt;/strong&gt;中自定义样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
.side-bar-card{
    background: rgba(0,0,0,.06);
    padding: 15px 0;
    border-radius: 5px;
}

.side-bar-card .side-bar-introduction{
    padding-left: 5px;
    line-height: 1.8;
    color: #9d9d9d;
    font-size: 15px;

}

.side-bar-card .side-bar-phone{
    line-height: 1.5;
    font-size: 13px;
}

.side-bar-recommend{
    margin-top: 10px;
}

.side-bar-card .side-bar-title{
    padding-left: 15px;
    padding-bottom: 15px;
}

.side-bar-recommend .side-bar-list .side-bar-item{
    padding: 15px 15px;
}

.side-bar-recommend .side-bar-list .side-bar-item:hover{
    padding: 15px 15px;
    background-color: rgba(0,0,0, .09);
}

.side-bar-recommend .side-bar-list .side-item-title{
    color: black;
}

.side-bar-recommend .side-bar-list .side-item-title:hover{
        color: #9d9d9d;
}


.side-bar-recommend .side-bar-list .side-item-info{
    color: #9d9d9d;
    font-size: 12px;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;九页尾&quot;&gt;九、页尾&lt;/h2&gt;
&lt;h3 id=&quot;前言-2&quot;&gt;1、前言&lt;/h3&gt;
&lt;p&gt;这部分没什么特别的内容，使用 HTML5 的新增标签 &lt;strong&gt;&amp;lt;footer&amp;gt;&lt;/strong&gt; ,使之更“语义化”，也可以使用Bootstrap的页尾类。&lt;/p&gt;
&lt;h3 id=&quot;代码-4&quot;&gt;2、代码&lt;/h3&gt;
&lt;p&gt;这部分代码，不像左侧菜单，博客列表以及右侧栏那样需要包含&lt;strong&gt;container&lt;/strong&gt;中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;modal-footer&quot;&amp;gt;
    &amp;lt;address class=&quot;text-center&quot;&amp;gt;
        &amp;lt;p&amp;gt;关于博客园 | 联系我们 | 广告服务 | ©2004-2018博客&amp;lt;/p&amp;gt;
        &amp;lt;div href=&quot;#&quot;&amp;gt;first.last@example.com&amp;lt;/div&amp;gt;
    &amp;lt;/address&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义样式-4&quot;&gt;3、自定义样式&lt;/h3&gt;
&lt;p&gt;让博客列表的最后一个元素与页尾离得跟远一些，增加一点外边距。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;main.css&lt;/strong&gt;中自定义样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.modal-footer{
    margin-top: 30px;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;效果示例-4&quot;&gt;4、效果示例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/weilanhanf/Photos/master/Blog/footer.png&quot; alt=&quot;导航栏&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;十源码&quot;&gt;十、源码&lt;/h2&gt;
&lt;p&gt;上述部分如有整理不全请参照源码。&lt;br/&gt;完整源码地址：&lt;a href=&quot;https://github.com/weilanhanf/weilanhanf.github.io&quot; class=&quot;uri&quot;&gt;https://github.com/weilanhanf/weilanhanf.github.io&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 06:38:00 +0000</pubDate>
<dc:creator>蔚蓝的蓝</dc:creator>
<og:description>一、示例 1、主页 2、博客详情页 3、在线地址 在线地址： '入口' Addition ：这里使用github page将自己的静态项目免费部署到线上。 如果你只是做一些简单的静态项目做展示，付出这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/welan/p/10332038.html</dc:identifier>
</item>
<item>
<title>Nginx反向代理理解误区之proxy_cookie_domain - 木子墨</title>
<link>http://www.cnblogs.com/heioray/p/10329532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heioray/p/10329532.html</guid>
<description>&lt;h3 id=&quot;基本内容&quot;&gt;基本内容&lt;/h3&gt;
&lt;p&gt;Nginx做反向代理的时候，我们一般习惯添加proxy_cookie_domain配置，来做cookie的域名转换，比如&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;...
location /api {
   proxy_pass https://b.test.com;
   proxy_cookie_domain b.test.com  a.test.com;
}       
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在之前的博客中我也是这么写的，但是最近在项目中发现，不配置这个属性，依然运转正常，背后冷风阵阵，我发现自己一直以来可能又理解错了这个选项，然后还在这给别人讲。。。&lt;/p&gt;
&lt;p&gt;我们首先来看下proxy_cookie_domain的官方定义，&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Syntax: proxy_cookie_domain off;&lt;br/&gt;proxy_cookie_domain domain replacement;&lt;br/&gt;Default:&lt;br/&gt;proxy_cookie_domain off;&lt;br/&gt;Context: http, server, location&lt;br/&gt;This directive appeared in version 1.1.15.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Sets a text that should be changed in the domain attribute of the “Set-Cookie” header fields of a proxied server response. Suppose a proxied server returned the “Set-Cookie” header field with the attribute “domain=localhost”. The directive proxy_cookie_domain localhost example.org will rewrite this attribute to “domain=example.org”.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来就是&lt;strong&gt;proxy_cookie_domain参数的作用是转换response的set-cookie header中的domain选项，由后端设置的域名domain转换成你的域名replacement，来保证cookie的顺利传递并写入到当前页面中，注意proxy_cookie_domain负责的只是处理response set-cookie头中的domain属性，仅此而已。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是我们知道response在写set-cookie的时候，domain是一个可选项，并不是必填项，所以经常能看到如下这种情况&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/461976/201901/461976-20190129114205786-199803799.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候由于set-cookie本身就没有domain内容，proxy_cookie_domain也就不没有必要了，这也是为什么在部分项目中不配置proxy_cookie_domain依然正常的原因。但是对于一些设置了domain的项目，比如&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/461976/201901/461976-20190129114009046-265641057.png&quot;/&gt;&lt;br/&gt;这种情况下当你用nginx做反向代理的时候，就必须要转换一下了。&lt;/p&gt;
&lt;h3 id=&quot;误区回溯&quot;&gt;误区回溯&lt;/h3&gt;
&lt;p&gt;说到这里，我们再看看之前的错误理解：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“proxy_cookie_domain的作用是实现前后端cookie域名转换，保证顺利传递”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乍一看好像也没错，但是现在想想，理解还是不够啊，因为proxy_cookie_domain的作用是单向的，并不是双向转换的。我们先看下cookie的传递过程，盗一张图先(懒得画了。。。)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/461976/201901/461976-20190129114515894-606101073.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器在发送请求的时候，会在request header中带上cookie项(有内容的话)，此时的cookie是一个字符串，一个key=value并用分号分割的字符串，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/461976/201901/461976-20190129142948891-367731690.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;strong&gt;并不包含任何域名信息&lt;/strong&gt;。这是因为浏览器在设置cookie选项的时候，所选取的内容都是缓存中接口域名下的。然后request的只要请求发送出去之后，cookie中有关domain信息其实是不存在的，它只是一个普通的字符串，随便proxy_pass到任何位置，都会正常携带下去。因此&lt;strong&gt;在前端到后端的request的过程中，proxy_cookie_domain是没用的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而server端在做响应的时候，通过set-cookie的domain属性，可以控制cookie的生效域名目标，做到诸如二级域名cookie分离等等，如果前端接收到的set-cookie的domain和当前域名不一致，或者一级域名不一致(二级域名可以共享一级域名下的cookie)，这个cookie在后续的通信中就是无效的，所以这里才需要去做domain的转换，也就是说&lt;strong&gt;response中set-cookie的domain转换才是有意义的&lt;/strong&gt;，这也正是proxy_cookie_domain的作用所在。&lt;br/&gt;当response的set-cookie中domain不去设置时，cookie顺利传入浏览器中，浏览器会自动设置这个cookie的生效域名为当前域名。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;和这个类似的还有proxy_cookie_path属性，同样的该属性仅作用在修改response set-cookie的path属性，而一般情况下，用的也比较少。&lt;/p&gt;
&lt;h3 id=&quot;唠叨两句&quot;&gt;唠叨两句&lt;/h3&gt;
&lt;p&gt;很多问题，有时候都是太过理所当然的以为它是怎么样的，并且生效了、达到目的了，我们就认为它是这样的了，但往往打脸就会在后面不期而至。多学习，多去关注一些底层的原理，才会发现自己理解的错误，望诸君共勉～&lt;br/&gt;如果错误，欢迎指出～&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 06:21:00 +0000</pubDate>
<dc:creator>木子墨</dc:creator>
<og:description>基本内容 Nginx做反向代理的时候，我们一般习惯添加proxy_cookie_domain配置，来做cookie的域名转换，比如 在之前的博客中我也是这么写的，但是最近在项目中发现，不配置这个属性，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heioray/p/10329532.html</dc:identifier>
</item>
<item>
<title>.NET-记一次架构优化实战与方案-目录 - 陈珙</title>
<link>http://www.cnblogs.com/skychen1218/p/10333841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skychen1218/p/10333841.html</guid>
<description>&lt;p&gt;　　本系列是根据我公司的某块业务优化进行改写的，为了避免触发法律的红线，我对部分代码做了截取并打码。&lt;/p&gt;
&lt;p&gt;　　因为优化方案是针对现有业务的问题情况进行的，不做任何太过过分吹牛逼。一切以基于现有的业务，优化处理已存在的不可避免问题，达到目标效果的作为三个前提原则。&lt;/p&gt;
&lt;p&gt;　　因需要针对现有业务与问题进行展开，业务梳理是不可避免的，第一篇梳理篇主要以做了业务描述与整理。&lt;/p&gt;
&lt;p&gt;　　“程序员的输出是他敲写的代码，那么输入就是他思考好的设计。因此不做设计是不存在，也不可能因此省时间、成本，设计只分优秀的设计和糟糕的设计。”这段话不是我原创的，但是我坚信着这是一条真理，因此我把方案以图文的形式记录，并与大家分享。&lt;/p&gt;
&lt;p&gt;　　无论做任何事有产出才是有意义，而我们的产出无非是代码与文档。文档是描述思考的过程。而代码是记录的是实践结果。文档是知的表现，代码是行的成果。只有结合起来才能达到&lt;strong&gt;知行合一&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　如果该系列文章有任何建议与问题，可在下方评论反馈给我。如果对您有很大的帮助，点击推荐就是对我最大的支持，谢谢&lt;/p&gt;
</description>
<pubDate>Tue, 29 Jan 2019 06:10:00 +0000</pubDate>
<dc:creator>陈珙</dc:creator>
<og:description>前言 本系列是根据我公司的某块业务优化进行改写的，为了避免触发法律的红线，我对部分代码做了截取并打码。 因为优化方案是针对现有业务的问题情况进行的，不做任何太过过分吹牛逼。一切以基于现有的业务，优化处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skychen1218/p/10333841.html</dc:identifier>
</item>
<item>
<title>单例模式 - 不该相遇在秋天</title>
<link>http://www.cnblogs.com/fengyumeng/p/10331566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengyumeng/p/10331566.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;　　单例模式，这个最简单的设计模式，有无数开发者在网络上写过样本，我相信只要混过的，都能闭着眼睛把单例写出来，并不稀奇。&lt;/p&gt;
&lt;p&gt;　　但是很多人写单例，都是背着写出来的，认为写法是固定的，其实并非如此。&lt;/p&gt;
&lt;h3&gt;是戴套还是结扎？&lt;/h3&gt;
&lt;p&gt;　　很多夫妻都会遇到的问题：怎样确保只生一个小孩？&lt;/p&gt;
&lt;p&gt;　　我认为，摆在面前的有两种方式：戴套和结扎。戴套是在外面处理，结扎是在内部处理，都可以达到这个效果，但是哪种更优呢？&lt;/p&gt;
&lt;p&gt;　　接下来我们就探讨一下，单例模式所要解决的问题，与解决问题的思路演变。&lt;/p&gt;
&lt;h3&gt;方案一：调用方处理&lt;/h3&gt;
&lt;p&gt;原始类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class User {
}　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我要确保这个User类只实例化一次，我可以这样子做：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; User user = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; user){
            user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        }
        User user1 &lt;/span&gt;=&lt;span&gt; user;
        User user2 &lt;/span&gt;=&lt;span&gt; user;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样是不是只实例化一次了？ 用一个变量来保存User对象，如果变量是Null就实例化User，（也可以采用反射来实现）。&lt;/p&gt;

&lt;p&gt;　　问题：&lt;/p&gt;
&lt;p&gt;　　如果这样子做的话，程序其他地方也要使用这个对象该怎么办？&lt;/p&gt;
&lt;p&gt;　　必须使用全局变量来保存该对象，得靠程序之间的约定才能保持单例。&lt;/p&gt;

&lt;p&gt;　　然而，全局变量会鼓励开发人员，用许多全局变量指向许多小对象造成不必要的引用污染，并且，对于调用方来说，很累，保持单例，到底是你的事情还是我的事情？&lt;/p&gt;

&lt;p&gt;　　显然，单例模式倾向于内部处理，在外部处理就是普通的程序逻辑处理，并不能称作模式。&lt;/p&gt;
&lt;h3&gt;方案二：内部处理&lt;/h3&gt;
&lt;p&gt;改写后的User类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; User user = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; User() {
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; User getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; user){
            user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一般来说，我们使用的单例模式都是这个样子，私有静态变量保存实例、私有构造器拒绝构造、公有静态方法对外提供实例。&lt;/p&gt;
&lt;p&gt;　　但是当多线程的情况下就会出问题了，当线程A执行到user = new User()这行代码的时候，但还没获得对象（对象的初始化是需要时间的），此时线程B执行到if(null == user)判断，那么线程B的判断结果也是真，于是两个线程都进去各自new了一个User对象，内存中就出现了两个对象。&lt;/p&gt;
&lt;h3&gt;第一次优化：同步锁&lt;/h3&gt;
&lt;p&gt;为了解决多线程场景下单例出现多个实例的问题，我们把getInstance()方法上一个同步锁：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; User getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; user){
            user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不管出现多少个线程，全部给我排队，等上一个线程离开该方法之后，才可进入，这样即可解决问题。&lt;/p&gt;

&lt;p&gt;　　但是这样又衍生出了问题，因为严格来说，只有第一次实例化这个对象的时候需要线程同步，避免出现多个实例，一旦User对象被实例化出来之后，就不需要对多线程进行同步了，同步一个方法可能造成程序执行效率下降一百倍，每次同步会严重拖垮程序性能。&lt;/p&gt;

&lt;p&gt;　　所以同步锁虽然解决了多线程问题，但是付出了性能作为代价，这并不是最优的方案。&lt;/p&gt;
&lt;h3&gt;第二次优化：双重检查加锁&lt;/h3&gt;
&lt;p&gt;既然在方法上加锁得不偿失，那么我就先判断是否是null，是null之后我再对该对象加锁：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; User user = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; User() {
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; User getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; user){
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; user){
                    user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只有第一次实例化的时候user才是null，所以进入代码块只有一次，进去之后，再让所有的线程同步，同步之后再检查一下user是不是null。&lt;/p&gt;

&lt;p&gt;　　这里再次检查有什么意义呢？有意义。&lt;/p&gt;
&lt;p&gt;　　请注意user变量的定义多了一个volatile关键字，该关键字可以让所有使用该变量的线程都能实时更新变量的最新状态。&lt;/p&gt;
&lt;p&gt;　　运行流程：线程AB同时进入第一个判断，然后同步，A先进synchronized，B再外面等，A在里面new了User对象，退出，B再进，此时如果不判断的话，B也会再次new一个，正因为user变量是用volatile来定义的，所以Anew了对象后，B线程的user对象也会更新到最新值，也就不等于null了。&lt;/p&gt;

&lt;p&gt;　　这次优化完美解决了多线程的问题，但是仍然感觉有问题，问题就是怪怪的。。。。&lt;/p&gt;
&lt;p&gt;　　因为解决的方案并不优雅，两个相同的判断，中间再插一根同步锁，显得这段代码对程序员来说有点像修bug填坑，并非是一个漂亮的设计模式。&lt;/p&gt;
&lt;h3&gt;第三次优化：饿汉式单例&lt;/h3&gt;
&lt;p&gt;　　我们从根本上思考：多线程问题主要是由于user对象是Null，多个线程同时去获取实例才引发的麻烦。&lt;/p&gt;
&lt;p&gt;　　如果user对象从一开始就不是Null呢？&lt;/p&gt;
&lt;p&gt;　　好主意！&lt;/p&gt;

&lt;p&gt;立刻改写代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; User() {
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; User getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　直接在变量初始化的时候就实例化对象，利用这个做法，JVM在加载这个类时就会创建User这个对象，并且特意加了final关键字，则user变量的值一旦在初始化之后便不能更改。&lt;/p&gt;
&lt;p&gt;　　这种单例模式也被称作饿汉式单例，因为程序启动后，尽管没有线程来访问，内存中也已经存在了User对象。&lt;/p&gt;

&lt;p&gt;　　经过两个方案，三次优化，目前，这种饿汉写法的单例可以被称作简单优雅并无副作用的单例模式。&lt;/p&gt;

</description>
<pubDate>Tue, 29 Jan 2019 05:58:00 +0000</pubDate>
<dc:creator>不该相遇在秋天</dc:creator>
<og:description>前言 单例模式，这个最简单的设计模式，有无数开发者在网络上写过样本，我相信只要混过的，都能闭着眼睛把单例写出来，并不稀奇。 但是很多人写单例，都是背着写出来的，认为写法是固定的，其实并非如此。 是戴套</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengyumeng/p/10331566.html</dc:identifier>
</item>
</channel>
</rss>