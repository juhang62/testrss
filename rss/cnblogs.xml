<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# 创建含多层分类标签的Excel图表 - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/10670988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/10670988.html</guid>
<description>&lt;p&gt;相较于数据，图表更能直观的体现数据的变化趋势。在数据表格中，同一数据值，可能同时代表不同的数据分类，表现在图表中则是一个数据体现在多个数据分类标签下。通常生成的图表一般默认只有一种分类标签，下面的方法将通过编程的方式来介绍在Excel中如何来生成含多层分类标签的图表。 &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用工具&lt;/strong&gt;：&lt;/span&gt;Spire.XLS for .NET&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;通过官网（&lt;a href=&quot;https://www.e-iceblue.cn/Introduce/Spire-XLS-NET.html&quot;&gt;https://www.e-iceblue.cn/Introduce/Spire-XLS-NET.html&lt;/a&gt; ）下载安装包--解压-安装。在程序中添加引用Spire.Doc.dll，dll文件在安装路径下的bin文件夹中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;通过 Nuget 官网。（&lt;a href=&quot;http://www.nuget.org/packages/Spire.XLS/&quot;&gt;http://www.nuget.org/packages/Spire.XLS/&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;添加引用完成后，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190408153240409-765150622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;C#示例代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Step1:创建工作表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Workbook实例，获取工作表&lt;/span&gt;
Workbook wb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
Worksheet sheet &lt;/span&gt;= wb.Worksheets[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step2:写入数据到表格&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出口前&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出口后&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年份&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2017年&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季度产量\n（万吨）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.21&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.79&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.58&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step3:合并单元格并设置单元格对齐方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2:A4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Merge();
sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5:A9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Merge();
sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2:B5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Merge();
sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B6:B9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Merge();
sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:D9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Style.HorizontalAlignment =&lt;span&gt; HorizontalAlignType.Center;
sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:D9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Style.VerticalAlignment = VerticalAlignType.Center;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step4:添加图表到Excel&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加柱状图表&lt;/span&gt;
Chart chart =&lt;span&gt; sheet.Charts.Add(ExcelChartType.LineMarkers);
chart.ChartTitle &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季度产量（万吨）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表标题     &lt;/span&gt;
chart.PlotArea.Fill.FillType = ShapeFillType.NoFill; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不填充绘图区域（默认填充灰色）&lt;/span&gt;
chart.Legend.Delete();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除图例

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定柱状图表在工作表中的位置及宽度&lt;/span&gt;
chart.LeftColumn = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
chart.TopRow &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
chart.RightColumn &lt;/span&gt;= &lt;span&gt;14&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表系列数据来源&lt;/span&gt;
chart.DataRange = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D2:D9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
chart.SeriesDataFromRange &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints.DefaultDataPoint.DataLabels.HasValue = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].Format.LineProperties.Color =&lt;span&gt; Color.BlueViolet;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列分类标签数据来源&lt;/span&gt;
ChartSerie serie = chart.Series[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
serie.CategoryLabels &lt;/span&gt;= sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2:C9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step5:设置是否显示多层分类标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chart.PrimaryCategoryAxis.MultiLevelLable = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step6: 保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wb.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ExcelVersion.Version2013);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;图表创建结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201904/706090-20190408154337926-102623248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;全部代码:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ecfe6c29-4a8d-45fa-94dc-ad9f4b7e0aa9')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_ecfe6c29-4a8d-45fa-94dc-ad9f4b7e0aa9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ecfe6c29-4a8d-45fa-94dc-ad9f4b7e0aa9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ecfe6c29-4a8d-45fa-94dc-ad9f4b7e0aa9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ecfe6c29-4a8d-45fa-94dc-ad9f4b7e0aa9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ChartWithMultiLevelCategoryLabels_XLS
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Workbook实例，获取工作表&lt;/span&gt;
            Workbook wb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
            Worksheet sheet &lt;/span&gt;= wb.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入数据到工作表&lt;/span&gt;
            sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出口前&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出口后&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年份&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2017年&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4季度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季度产量\n（万吨）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.21&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.79&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.58&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并单元格，设置单元格对齐方式&lt;/span&gt;
            sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2:A4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Merge();
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A5:A9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Merge();
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2:B5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Merge();
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B6:B9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Merge();
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:D9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Style.HorizontalAlignment =&lt;span&gt; HorizontalAlignType.Center;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1:D9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Style.VerticalAlignment =&lt;span&gt; VerticalAlignType.Center;


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加柱状图表&lt;/span&gt;
            Chart chart =&lt;span&gt; sheet.Charts.Add(ExcelChartType.LineMarkers);
            chart.ChartTitle &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季度产量（万吨）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表标题     &lt;/span&gt;
            chart.PlotArea.Fill.FillType = ShapeFillType.NoFill; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不填充绘图区域（默认填充灰色）&lt;/span&gt;
            chart.Legend.Delete();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除图例

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定柱状图表在工作表中的位置及宽度&lt;/span&gt;
            chart.LeftColumn = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
            chart.TopRow &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            chart.RightColumn &lt;/span&gt;= &lt;span&gt;14&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图表系列数据来源&lt;/span&gt;
            chart.DataRange = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D2:D9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            chart.SeriesDataFromRange &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].DataPoints.DefaultDataPoint.DataLabels.HasValue = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            chart.Series[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].Format.LineProperties.Color =&lt;span&gt; Color.BlueViolet;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置系列分类标签数据来源&lt;/span&gt;
            ChartSerie serie = chart.Series[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            serie.CategoryLabels &lt;/span&gt;= sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2:C9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示多层分类标签&lt;/span&gt;
            chart.PrimaryCategoryAxis.MultiLevelLable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
            wb.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ExcelVersion.Version2013);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;（本文完）&lt;/p&gt;

</description>
<pubDate>Mon, 08 Apr 2019 07:52:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<og:description>相较于数据，图表更能直观的体现数据的变化趋势。在数据表格中，同一数据值，可能同时代表不同的数据分类，表现在图表中则是一个数据体现在多个数据分类标签下。通常生成的图表一般默认只有一种分类标签，下面的方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/10670988.html</dc:identifier>
</item>
<item>
<title>一份.NET 容器化的调查小结 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/10670930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/10670930.html</guid>
<description>&lt;p&gt;小编在上个月在微信公众号“dotnet跨平台” 做了一个针对.NET 容器化的调查：&lt;a title=&quot;https://mp.weixin.qq.com/s/oszbuIORT0G8XLLgMZzknw&quot; href=&quot;https://mp.weixin.qq.com/s/oszbuIORT0G8XLLgMZzknw&quot;&gt;https://mp.weixin.qq.com/s/oszbuIORT0G8XLLgMZzknw&lt;/a&gt;，参与人数702人，由于软件定义基础设施方兴未艾，编排和自动化领域kubernetes占据了主体地位，在平时的工作中和身边的同学聊天的过程中很多人对kubernetes 有一种畏惧心理，觉得K8s很难，上周也连续写了几篇关于K8s的文章《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/10658110.html&quot;&gt;基于Kubernetes 构建.NET Core 的技术体系&lt;/a&gt;》和《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/10662958.html&quot;&gt;容器化时代我们应当选择Kubernetes&lt;/a&gt;》。这个调查今天也结束了，所以这里写一篇文章总结一下。&lt;/p&gt;
&lt;h5&gt;调查结果&lt;/h5&gt;
&lt;h6&gt;1. 是否使用.NET Core开发&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190408154454476-815511053.png&quot;&gt;&lt;img width=&quot;765&quot; height=&quot;166&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190408154454842-704389473.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的公众号里用户多是使用.NET，其中已经有不少同学转去做了Java，前端等，使用.NET core的用户83%，这个数据肯定是偏高的，但是从概率角度还是反映了一个趋势，记得2017年初我也在公众里做过类似的调查，当时的数据倒过来的，只有20%的用户在使用.NET Core, 毕竟那时候.NET Core 才发布1.1版本，还缺乏很多API，随着.NET Core 2.0的发布，.NET Core的可用API得到极大改善，很多新项目开始使用.NET Core.&lt;/p&gt;
&lt;h6&gt;2. 是否使用docker 容器化.NET Core&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190408154455468-1553247923.png&quot;&gt;&lt;img width=&quot;768&quot; height=&quot;169&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190408154455883-144629130.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用docker容器化.NET Core的比例下降到了48%，这个数据相比.NET Core的使用人群比例还是超过了50%的，这是需要向大家多多推广的地方了，期望更多的同学能够把容器化技术用起来。&lt;/p&gt;
&lt;h6&gt;3. 是否使用kubernetes（k8s）&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190408154456282-940331666.png&quot;&gt;&lt;img width=&quot;783&quot; height=&quot;176&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190408154456571-1907430644.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在使用k8s的比例只剩下了17%， 这个也是非常类似于2017年的.NET Core调查，相信企业会不断增加对容器技术的投资， 随着K8s的逐步成熟，最新的k8s 1.14 正式支持了Windows Server 2019作为节点， Windows服务器可以正式加入到容器化生产环境，传统的.NET也可以进行容器化。在《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/10662958.html&quot;&gt;容器化时代我们应当选择Kubernetes&lt;/a&gt;》里头已经介绍了我们为什么要拥抱k8s， k8s 是我们构建微服务生态系统的基础设施，.NET Core在容器里的运行效率才是他的优势。&lt;/p&gt;
&lt;p&gt;“大道昌昌，顺之者昌”。容器服务和Docker在企业的IT中正在扮演越来越重要的角色。降低成本和提升效率是容器服务和Docker为企业带来的核心价值，围绕着这两个核心价值，企业将在多个应用场景上加大投入，例如：应用的微服务化、运维流程的标准化、持续集成／部署的自动化、使用开发测试云降低产品研发成本、使用多个云或者混合云降低系统风险等。特别是对于创业公司来说，无论你的业务系统多么小，无论是单体还是微服务，都非常适合使用容器服务来不断降低成本，我公司所有业务都是使用腾讯云容器服务进行调度，还有我也在不断帮助周边的朋友上云，上云不是简单的虚拟机方式把传统的系统搬上云，而应当充分利用云基础设施，老的系统可以进行小改动，使用容器化技术获得系统弹性和降低运维难度，新系统更是可以按照云原生应用进行开发，可参考我写的文章《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/10658110.html&quot;&gt;基于Kubernetes 构建.NET Core 的技术体系&lt;/a&gt;》,Windows 容器化还可以选择微软的Service Fabric，这也是一个牛逼的技术，具体可以参考朱永光写的&lt;a href=&quot;https://mp.weixin.qq.com/s/qq1xRVL68LSgqzTHR7D7RQ&quot;&gt;Service Fabric是什么？，&lt;/a&gt;可惜在容器编排领域已经被k8s 占领。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 07:45:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>小编在上个月在微信公众号“dotnet跨平台” 做了一个针对.NET 容器化的调查：https://mp.weixin.qq.com/s/oszbuIORT0G8XLLgMZzknw，参与人数702人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/10670930.html</dc:identifier>
</item>
<item>
<title>CTF MISC-USB流量分析出题记录 - 晓枫v5</title>
<link>http://www.cnblogs.com/hackxf/p/10670844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hackxf/p/10670844.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;USB接口是目前最为通用的外设接口之一，通过监听该接口的流量，可以得到很多有意思的东西，例如键盘击键，鼠标移动与点击，存储设备的明文传输通信、USB无线网卡网络传输内容等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;usb流量的捕获&quot;&gt;1、USB流量的捕获&lt;/h3&gt;
&lt;p&gt;USB流量的捕获可以使用wireshark自带的工具usbpcap来进行&lt;br/&gt;安装wirshark时勾选上安装usbpcap即可&lt;/p&gt;
&lt;h2 id=&quot;鼠标流量&quot;&gt;1.鼠标流量&lt;/h2&gt;
&lt;p&gt;抓包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408145832956-551325213.png&quot;/&gt;&lt;br/&gt;鼠标移动的轨迹，右键，左键的行为都能捕捉到&lt;br/&gt;(这里有个坑，有的鼠标可能协议不标准、抓到的数据分析不了)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408150903114-1473233842.png&quot;/&gt;&lt;br/&gt;保存为pacp文件&lt;/p&gt;
&lt;p&gt;USB协议的数据部分在Leftover Capture Data域之中，在Linux下可以用tshark命令可以将 leftover capture data单独提取出来 命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tshark -r 7777.pcapng -T fields -e usb.capdata &amp;gt; usbdata.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408151854721-1139953666.png&quot;/&gt;&lt;br/&gt;运行命令并查看usbdata.txt 发现数据包长度为八个字节&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408151919254-1443517947.png&quot;/&gt;&lt;br/&gt;写出解密脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nums = []
keys = open('usb.txt','r')
posx = 0
posy = 0
for line in keys:
    if len(line) != 12 :
         continue
    x = int(line[3:5],16)
    y = int(line[6:8],16)
    if x &amp;gt; 127 :
        x -= 256
    if y &amp;gt; 127 :
        y -= 256
    posx += x
    posy += y
    btn_flag = int(line[0:2],16)  # 1 for left , 2 for right , 0 for nothing
    if btn_flag == 1 :
        print posx , posy
keys.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当btn_flag 取1时 对应鼠标左键、2对应鼠标右键&lt;br/&gt;运行脚本可以得到一系列坐标点&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408152307324-138760101.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到这些点之后，需要将他们画出来，因而需要辅以gnuplot 或者其他的绘图工具，gnuplot的命令为&quot;plot inputfile&quot;，运行如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408152345767-1740974165.png&quot;/&gt;&lt;br/&gt;使用一航大佬的工具&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408152516195-1243202368.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;键盘流量&quot;&gt;键盘流量&lt;/h2&gt;
&lt;p&gt;一样的抓包方式&lt;br/&gt;确定为键盘流量后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tshark -r 1111.pcapng -T fields -e usb.capdata &amp;gt; usbdata.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-

normalKeys = {&quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;,&quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&amp;lt;RET&amp;gt;&quot;,&quot;29&quot;:&quot;&amp;lt;ESC&amp;gt;&quot;,&quot;2a&quot;:&quot;&amp;lt;DEL&amp;gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&amp;lt;SPACE&amp;gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\&quot;,&quot;32&quot;:&quot;&amp;lt;NON&amp;gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;'&quot;,&quot;35&quot;:&quot;&amp;lt;GA&amp;gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;,&quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&amp;lt;CAP&amp;gt;&quot;,&quot;3a&quot;:&quot;&amp;lt;F1&amp;gt;&quot;,&quot;3b&quot;:&quot;&amp;lt;F2&amp;gt;&quot;, &quot;3c&quot;:&quot;&amp;lt;F3&amp;gt;&quot;,&quot;3d&quot;:&quot;&amp;lt;F4&amp;gt;&quot;,&quot;3e&quot;:&quot;&amp;lt;F5&amp;gt;&quot;,&quot;3f&quot;:&quot;&amp;lt;F6&amp;gt;&quot;,&quot;40&quot;:&quot;&amp;lt;F7&amp;gt;&quot;,&quot;41&quot;:&quot;&amp;lt;F8&amp;gt;&quot;,&quot;42&quot;:&quot;&amp;lt;F9&amp;gt;&quot;,&quot;43&quot;:&quot;&amp;lt;F10&amp;gt;&quot;,&quot;44&quot;:&quot;&amp;lt;F11&amp;gt;&quot;,&quot;45&quot;:&quot;&amp;lt;F12&amp;gt;&quot;}
shiftKeys = {&quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;,&quot;28&quot;:&quot;&amp;lt;RET&amp;gt;&quot;,&quot;29&quot;:&quot;&amp;lt;ESC&amp;gt;&quot;,&quot;2a&quot;:&quot;&amp;lt;DEL&amp;gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&amp;lt;SPACE&amp;gt;&quot;,&quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;{&quot;,&quot;30&quot;:&quot;}&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&amp;lt;NON&amp;gt;&quot;,&quot;33&quot;:&quot;\&quot;&quot;,&quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&amp;lt;GA&amp;gt;&quot;,&quot;36&quot;:&quot;&amp;lt;&quot;,&quot;37&quot;:&quot;&amp;gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&amp;lt;CAP&amp;gt;&quot;,&quot;3a&quot;:&quot;&amp;lt;F1&amp;gt;&quot;,&quot;3b&quot;:&quot;&amp;lt;F2&amp;gt;&quot;, &quot;3c&quot;:&quot;&amp;lt;F3&amp;gt;&quot;,&quot;3d&quot;:&quot;&amp;lt;F4&amp;gt;&quot;,&quot;3e&quot;:&quot;&amp;lt;F5&amp;gt;&quot;,&quot;3f&quot;:&quot;&amp;lt;F6&amp;gt;&quot;,&quot;40&quot;:&quot;&amp;lt;F7&amp;gt;&quot;,&quot;41&quot;:&quot;&amp;lt;F8&amp;gt;&quot;,&quot;42&quot;:&quot;&amp;lt;F9&amp;gt;&quot;,&quot;43&quot;:&quot;&amp;lt;F10&amp;gt;&quot;,&quot;44&quot;:&quot;&amp;lt;F11&amp;gt;&quot;,&quot;45&quot;:&quot;&amp;lt;F12&amp;gt;&quot;}
output = []
keys = open('usbdata.txt')
for line in keys:
    try:
        if line[0]!='0' or (line[1]!='0' and line[1]!='2') or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0' or line[6:8]==&quot;00&quot;:
             continue
        if line[6:8] in normalKeys.keys():
            output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]=='2']
        else:
            output += ['[unknown]']
    except:
        pass
keys.close()

flag=0
print(&quot;&quot;.join(output))
for i in range(len(output)):
    try:
        a=output.index('&amp;lt;DEL&amp;gt;')
        del output[a]
        del output[a-1]
    except:
        pass
for i in range(len(output)):
    try:
        if output[i]==&quot;&amp;lt;CAP&amp;gt;&quot;:
            flag+=1
            output.pop(i)
            if flag==2:
                flag=0
        if flag!=0:
            output[i]=output[i].upper()
    except:
        pass
print ('output :' + &quot;&quot;.join(output))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408152837678-1454089250.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接使用大佬的工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408152933671-2043715718.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201904/1275435-20190408152952304-1122568330.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;br/&gt;https://www.jianshu.com/p/92064f2e9dcb&lt;br/&gt;https://www.anquanke.com/post/id/85218&lt;br/&gt;&lt;a href=&quot;https://github.com/WangYihang/UsbMiceDataHacker&quot;&gt;工具&lt;/a&gt;&lt;br/&gt;https://ctf-wiki.github.io/ctf-wiki/misc/traffic/protocols/USB/&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 07:34:00 +0000</pubDate>
<dc:creator>晓枫v5</dc:creator>
<og:description>USB流量分析 USB接口是目前最为通用的外设接口之一，通过监听该接口的流量，可以得到很多有意思的东西，例如键盘击键，鼠标移动与点击，存储设备的明文传输通信、USB无线网卡网络传输内容等。 1、USB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hackxf/p/10670844.html</dc:identifier>
</item>
<item>
<title>Android权限禁止及友好提示用户开通必要权限 - 丁先森</title>
<link>http://www.cnblogs.com/dingxiansen/p/10670707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dingxiansen/p/10670707.html</guid>
<description>&lt;p&gt;Android权限&lt;br/&gt;Android安全架构规定：默认情况下，任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。这包括读写用户的私有数据（联系人，短信，相册，位置）、读写其他应用的文件、执行网络访问、使设备保持唤醒状态等等。&lt;/p&gt;
&lt;p&gt;如果是一些正常的权限(非高危权限)，比如网络访问等在应用清单文件(AndroidManifest.xml)中配置，系统会自动授予，&lt;br/&gt;但是如果有一些高危权限，位置，文件存储，短信等这个时候系统会要求用户授予权限，Android 发出权限请求的方式取决于系统版本：&lt;br/&gt;1、如果设备运行的是Android 6.0（Marshmallow，API 23）或更高版本，并且应用的targetSdkVersion是23或更高版本，则应用将在运行时向用户请求权限(Runtime Permissions)。用户可随时撤销权限，因此应用每次运行时都应该检查自身是否具备所需的权限。&lt;br/&gt;2、如果设备运行的是Android 5.1（LOLLIPOP_MR1，API 22）或更低版本，并且应用的targetSdkVersion是22或更低版本，则系统在用户安装应用时就要求用户授予权限。如果更新应用时又新增了权限，系统会在用户更新应用时要求授予该权限。用户一旦安装应用，他们撤销权限的唯一方式是卸载应用。&lt;/p&gt;
&lt;p&gt;如果我们程序中某些功能，发布一些图片等操作，这个时候避免不了要访问用户设备的图片，但是用户开始的时候禁止了，用户并不知道，这个时候访问就会有问题了，那么怎样去提示用户并且引导用户去授予这些权限呢，看下面的效果(说的再多都不如图来的实际)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8375678-fa17c9ea36e7abdd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/472&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8375678-9d3281e5e1449f7e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/242&quot; alt=&quot;&quot; width=&quot;242&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面就开始撸码了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getpermission() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个日历权限和一个数据读写权限&lt;/span&gt;
        String[] permissions = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[]{Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.READ_PHONE_STATE, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA}; &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        PermissionsUtils.showSystemSetting = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否支持显示系统设置权限设置窗口跳转
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的this不是上下文，是Activity对象！&lt;/span&gt;
        PermissionsUtils.getInstance().chekPermissions(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, permissions, permissionsResult);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先在页面Activity启动之后调用这个方法(注意：数组中的权限可以自己配置，这里我写了四个)&lt;/p&gt;
&lt;p&gt;权限监听接口对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建监听权限的接口对象&lt;/span&gt;
    PermissionsUtils.IPermissionsResult permissionsResult = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PermissionsUtils.IPermissionsResult() {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; passPermissons() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;权限通过执行的方法
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;权限通过验证&lt;/span&gt;
&lt;span&gt;        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; forbitPermissons() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是没有通过权限的时候提示的内容，自定义即可&lt;/span&gt;
            Toast.makeText(mContext, &quot;您没有允许部分权限，可能会导致部分功能不能正常使用，如需正常使用  请允许权限&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
            finish();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Tool.exitApp();&lt;/span&gt;
&lt;span&gt;        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还需要在activity中重写一个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onRequestPermissionsResult(&lt;span&gt;int&lt;/span&gt; requestCode, @NonNull String[] permissions, @NonNull &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] grantResults) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onRequestPermissionsResult(requestCode, permissions, grantResults);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就多一个参数this&lt;/span&gt;
        PermissionsUtils.getInstance().onRequestPermissionsResult(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, requestCode, permissions, grantResults);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;权限以及弹窗设置权限工具类PermissionsUtils.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 权限工具类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PermissionsUtils {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mRequestCode = 100;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;权限请求码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; showSystemSetting = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PermissionsUtils() {
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; PermissionsUtils permissionsUtils;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IPermissionsResult mPermissionsResult;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; PermissionsUtils getInstance() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (permissionsUtils == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            permissionsUtils &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PermissionsUtils();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; permissionsUtils;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; chekPermissions(Activity context, String[] permissions, @NonNull IPermissionsResult permissionsResult) {
        mPermissionsResult &lt;/span&gt;=&lt;span&gt; permissionsResult;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;lt; 23&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.0才用动态权限&lt;/span&gt;
&lt;span&gt;            permissionsResult.passPermissons();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个mPermissionList，逐个判断哪些权限未授予，未授予的权限存储到mPerrrmissionList中&lt;/span&gt;
        List&amp;lt;String&amp;gt; mPermissionList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逐个判断你要的权限是否已经通过&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; permissions.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ContextCompat.checkSelfPermission(context, permissions[i]) !=&lt;span&gt; PackageManager.PERMISSION_GRANTED) {
                mPermissionList.add(permissions[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加还未授予的权限&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;申请权限&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (mPermissionList.size() &amp;gt; 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有权限没有通过，需要申请&lt;/span&gt;
&lt;span&gt;            ActivityCompat.requestPermissions(context, permissions, mRequestCode);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明权限都已经通过，可以做你想做的事情去&lt;/span&gt;
&lt;span&gt;            permissionsResult.passPermissons();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求权限后回调的方法 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数： requestCode  是我们自己定义的权限请求码
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数： permissions  是我们请求的权限名称数组
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数： grantResults 是我们在弹出页面后是否允许权限的标识数组，数组的长度对应的是权限名称数组的长度，数组的数据0表示允许权限，-1表示我们点击了禁止权限&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onRequestPermissionsResult(Activity context, &lt;span&gt;int&lt;/span&gt; requestCode, @NonNull String[] permissions, @NonNull &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] grantResults) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; hasPermissionDismiss = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有权限没有通过&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (mRequestCode ==&lt;span&gt; requestCode) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; grantResults.length; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (grantResults[i] == -1&lt;span&gt;) {
                    hasPermissionDismiss &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有权限没有被允许&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasPermissionDismiss) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (showSystemSetting) {
                    showSystemPermissionsSettingDialog(context);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转到系统设置权限页面，或者直接关闭页面，不让他继续访问&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    mPermissionsResult.forbitPermissons();
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全部权限通过，可以进行下一步操作。。。&lt;/span&gt;
&lt;span&gt;                mPermissionsResult.passPermissons();
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 不再提示权限时的展示对话框
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    AlertDialog mPermissionDialog;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; showSystemPermissionsSettingDialog(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Activity context) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String mPackName =&lt;span&gt; context.getPackageName();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mPermissionDialog == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mPermissionDialog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AlertDialog.Builder(context).setMessage(&quot;已禁用权限，请手动授予&quot;).setPositiveButton(&quot;设置&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DialogInterface.OnClickListener() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onClick(DialogInterface dialog, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; which) {
                    cancelPermissionDialog();
                    Uri packageURI &lt;/span&gt;= Uri.parse(&quot;package:&quot; +&lt;span&gt; mPackName);
                    Intent intent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, packageURI);
                    context.startActivity(intent);
                    context.finish();
                }
            }).setNegativeButton(&lt;/span&gt;&quot;取消&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DialogInterface.OnClickListener() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onClick(DialogInterface dialog, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; which) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭页面或者做其他操作&lt;/span&gt;
&lt;span&gt;                    cancelPermissionDialog();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mContext.finish();&lt;/span&gt;
&lt;span&gt;                    mPermissionsResult.forbitPermissons();
                }
            }).create();
        }
        mPermissionDialog.show();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放在show()之后，不然有些属性是没有效果的，比如height和width
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下代码设置解决弹窗不居中问题，一侧有边距，一侧没有&lt;/span&gt;
        Window dialogWindow =&lt;span&gt; mPermissionDialog.getWindow();
        WindowManager m &lt;/span&gt;=&lt;span&gt; context.getWindowManager();
        Display d &lt;/span&gt;= m.getDefaultDisplay(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取屏幕宽、高&lt;/span&gt;
        WindowManager.LayoutParams p = dialogWindow.getAttributes(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取对话框当前的参数值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置宽度&lt;/span&gt;
        p.width = (&lt;span&gt;int&lt;/span&gt;) (d.getWidth() * 0.95); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 宽度设置为屏幕的0.95&lt;/span&gt;
        p.gravity = Gravity.CENTER;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置位置
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.alpha = 0.8f;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置透明度&lt;/span&gt;
&lt;span&gt;        dialogWindow.setAttributes(p);

    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭对话框&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cancelPermissionDialog() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mPermissionDialog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mPermissionDialog.cancel();
            mPermissionDialog &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPermissionsResult {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; passPermissons();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; forbitPermissons();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上这些代码就可以实现gif图的效果，当然可以自定义任意效果&lt;br/&gt;如果有问题请请联系&lt;a href=&quot;https://links.jianshu.com/go?to=mailto%3Adingchao7323%40qq.com&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;dingchao7323@qq.com&lt;/a&gt;,一起交流，共同进步&lt;/p&gt;

</description>
<pubDate>Mon, 08 Apr 2019 07:19:00 +0000</pubDate>
<dc:creator>丁先森</dc:creator>
<og:description>Android权限 Android安全架构规定：默认情况下，任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。这包括读写用户的私有数据（联系人，短信，相册，位置）、读写其他应用的文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dingxiansen/p/10670707.html</dc:identifier>
</item>
<item>
<title>[数据库锁机制] 深入理解乐观锁、悲观锁以及CAS乐观锁的实现机制原理分析 - 勋爵</title>
<link>http://www.cnblogs.com/X-knight/p/10669934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-knight/p/10669934.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。&lt;/li&gt;
&lt;li&gt;乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。&lt;/li&gt;
&lt;li&gt;本文中也将深入分析一下乐观锁的实现机制，介绍什么是CAS、CAS的应用以及CAS存在的问题等。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（&lt;code&gt;Concurrency control&lt;/code&gt;）是确保及时纠正由并发操作导致的错误的一种机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。下面举例说明并发操作带来的数据不一致性问题：&lt;/p&gt;
&lt;p&gt;现有两处火车票售票点，同时读取某一趟列车车票数据库中车票余额为 X。两处售票点同时卖出一张车票，同时修改余额为 X -1写回数据库，这样就造成了实际卖出两张火车票而数据库中的记录却只少了一张。 产生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。&lt;/p&gt;
&lt;p&gt;封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。&lt;/p&gt;
&lt;h2&gt;一、数据库的锁&lt;/h2&gt;
&lt;blockquote readability=&quot;18.205128205128&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。&lt;/p&gt;
&lt;p&gt;在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;锁的分类(oracle)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、按操作划分，可分为&lt;code&gt;DML锁&lt;/code&gt;、&lt;code&gt;DDL锁&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;二、按锁的粒度划分，可分为&lt;a href=&quot;http://www.hollischuang.com/archives/914&quot;&gt;&lt;code&gt;表级锁&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;http://www.hollischuang.com/archives/914&quot;&gt;&lt;code&gt;行级锁&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;http://www.hollischuang.com/archives/914&quot;&gt;&lt;code&gt;页级锁&lt;/code&gt;&lt;/a&gt;（mysql）&lt;/p&gt;
&lt;p&gt;三、按锁级别划分，可分为&lt;a href=&quot;http://www.hollischuang.com/archives/923&quot;&gt;&lt;code&gt;共享锁&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;http://www.hollischuang.com/archives/923&quot;&gt;&lt;code&gt;排他锁&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四、按加锁方式划分，可分为&lt;code&gt;自动锁&lt;/code&gt;、&lt;code&gt;显示锁&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;五、按使用方式划分，可分为&lt;a href=&quot;http://www.hollischuang.com/archives/934&quot;&gt;&lt;code&gt;乐观锁&lt;/code&gt;&lt;/a&gt;、&lt;code&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/934&quot;&gt;悲观锁&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。&lt;/p&gt;
&lt;p&gt;DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）&lt;/p&gt;
&lt;h3&gt;1.1 锁机制&lt;/h3&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用的锁机制有两种：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;悲观锁&lt;/strong&gt;：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。悲观锁的实现，往往依靠底层提供的锁机制；悲观锁会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;乐观锁&lt;/strong&gt;：假设不会发生并发冲突，每次不加锁而是假设没有冲突而去完成某项操作，只在提交操作时检查是否违反数据完整性。如果因为冲突失败就重试，直到成功为止。乐观锁大多是基于数据版本记录机制实现。为数据增加一个版本标识，比如在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 &lt;/p&gt;
&lt;p&gt;乐观锁的缺点是不能解决脏读的问题。&lt;/p&gt;
&lt;p&gt;在实际生产环境里边,如果并发量不大且不允许脏读，可以使用悲观锁解决并发问题；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;二、悲观锁与乐观锁详解&lt;/h2&gt;
&lt;h3&gt;2.1 悲观锁&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。&lt;br/&gt;悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在数据库中，悲观锁的流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12.753164556962&quot;&gt;
&lt;p&gt;在对任意记录进行修改前，先尝试为该记录加上&lt;a href=&quot;http://www.hollischuang.com/archives/923&quot;&gt;排他锁&lt;/a&gt;（exclusive locking）。&lt;/p&gt;
&lt;p&gt;如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。&lt;/p&gt;
&lt;p&gt;如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。&lt;/p&gt;
&lt;p&gt;其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;MySQL InnoDB中使用悲观锁：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。&lt;code&gt;set autocommit=0;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
//0.开始事务
&lt;span&gt;begin;/begin work;/start transaction; (三者选一就可以)
&lt;/span&gt;//1.查询出商品信息
select status from t_goods where id=1&lt;span&gt; for update;
&lt;/span&gt;//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (&lt;span&gt;null&lt;/span&gt;,1&lt;span&gt;);
&lt;/span&gt;//3.修改商品status为2
update t_goods set status=2&lt;span&gt;;
&lt;/span&gt;//4.提交事务
commit;/commit work;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的查询语句中，我们使用了&lt;code&gt;select…for update&lt;/code&gt;的方式，这样就通过开启&lt;a href=&quot;http://www.hollischuang.com/archives/923&quot;&gt;排他锁&lt;/a&gt;的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。&lt;/p&gt;
&lt;blockquote readability=&quot;7.7631578947368&quot;&gt;
&lt;p&gt;上面我们提到，使用&lt;code&gt;select…for update&lt;/code&gt;会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认&lt;a href=&quot;http://www.hollischuang.com/archives/914&quot;&gt;行级锁&lt;/a&gt;。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;优点与不足&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数&lt;/p&gt;
&lt;h3&gt;2.2 乐观锁&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。&lt;/p&gt;
&lt;p&gt;相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用版本号实现乐观锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.查询出商品信息
select (status,status,version) from t_goods where id=#{id}
&lt;/span&gt;2&lt;span&gt;.根据商品信息生成订单
&lt;/span&gt;3&lt;span&gt;.修改商品status为2
update t_goods 
set status=&lt;/span&gt;2,version=version+1&lt;span&gt;
where id=#{id} and version=#{version};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优点与不足&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。&lt;/p&gt;
&lt;h2&gt;三、CAS详解&lt;/h2&gt;
&lt;p&gt;在说CAS之前，我们不得不提一下Java的线程安全问题。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;线程安全：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，Java是多线程的。但是，Java对多线程的支持其实是一把双刃剑。一旦涉及到多个线程操作共享资源的情况时，处理不好就可能产生线程安全问题。线程安全性可能是非常复杂的，在没有充足的同步的情况下，多个线程中的操作执行顺序是不可预测的。&lt;/p&gt;
&lt;p&gt;Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性。加上复合操作的原子性，我们可以认为Java的线程安全性问题主要关注点有3个：可见性、有序性和原子性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/1003&quot;&gt;Java内存模型&lt;/a&gt;（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题。这里不再详细介绍JMM及锁的其他相关知识。但是我们要讨论一个问题，那就是锁到底是不是有利无弊的？&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1 锁存在的问题&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Java在JDK1.5之前都是靠&lt;strong&gt;&lt;span&gt;&lt;code&gt;synchronized&lt;/code&gt;关键字&lt;/span&gt;&lt;/strong&gt;保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说&lt;strong&gt;&lt;span&gt;&lt;code&gt;synchronized&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;是悲观锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;悲观锁机制存在以下问题：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;1) 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。&lt;/p&gt;
&lt;p&gt;2) 一个线程持有锁会导致其它所有需要此锁的线程挂起。&lt;/p&gt;
&lt;p&gt;3) 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。&lt;/p&gt;
&lt;p&gt;与锁相比，&lt;span&gt;&lt;strong&gt;&lt;code&gt;volatile&lt;/code&gt;变量&lt;/strong&gt;&lt;/span&gt;是一个更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作，但是&lt;strong&gt;&lt;span&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;不能解决原子性问题，因此当一个变量依赖旧值时就不能使用&lt;strong&gt;&lt;span&gt;&lt;code&gt;volatile&lt;/code&gt;变量&lt;/span&gt;&lt;/strong&gt;。因此对于同步最终还是要回到锁机制上来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乐观锁（ &lt;code&gt;Optimistic Locking&lt;/code&gt;）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。&lt;/p&gt;
&lt;p&gt;上面提到的乐观锁的概念中其实已经阐述了他的具体实现细节：&lt;/p&gt;
&lt;p&gt;主要就是两个步骤：&lt;span&gt;冲突检测&lt;/span&gt;和&lt;span&gt;数据更新&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其实现方式有一种比较典型的就是Compare and Swap(&lt;code&gt;CAS&lt;/code&gt;)。&lt;/p&gt;
&lt;h3&gt;3.2 CAS&lt;/h3&gt;
&lt;p&gt;CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。&lt;/p&gt;
&lt;p&gt;CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里再强调一下，乐观锁是一种思想。CAS是这种思想的一种实现方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3.3 Java对CAS的支持&lt;/h3&gt;
&lt;p&gt;JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。j在JDK1.5 中新增&lt;code&gt;java.util.concurrent&lt;/code&gt;(J.U.C)就是建立在CAS之上的。相对于对于&lt;code&gt;synchronized&lt;/code&gt;这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。&lt;/p&gt;
&lt;p&gt;现代的CPU提供了特殊的指令，允许算法执行读-修改-写操作，而无需害怕其他线程同时修改变量，因为如果其他线程修改变量，那么CAS会检测它（并失败），算法可以对该操作重新计算。而 compareAndSet() 就用这些代替了锁定。&lt;/p&gt;
&lt;p&gt;我们以&lt;code&gt;java.util.concurrent&lt;/code&gt;中的&lt;code&gt;AtomicInteger&lt;/code&gt;为例，看一下在没有锁的情况下是如何保证线程安全的。主要理解&lt;code&gt;getAndIncrement&lt;/code&gt;方法，该方法的作用相当于 &lt;code&gt;++i&lt;/code&gt; 操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class AtomicInteger extends Number implements java.io.Serializable {
    
    private volatile int value;
    
    public final int get() {
        return value;
    }
    
    public final int getAndIncrement() {
        for (;;) {
            int current = get();
            int next = current + &lt;/span&gt;1&lt;span&gt;;
            if (compareAndSet(current, next))
                return current;
        }
    }
    
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;字段value需要借助volatile原语，保证线程间的数据是可见的（共享的）。这样在获取变量的值的时候才能直接读取。然后来看看++i是怎么做到的。getAndIncrement采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。而compareAndSet利用JNI来完成CPU指令的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public final boolean compareAndSet(int expect, int update) {   
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;整体的过程就是这样子的，利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。&lt;/p&gt;
&lt;p&gt;而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.4 CAS会导致“ABA问题”：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;strong&gt;ABA问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;aba实际上是乐观锁无法解决脏数据读取的一种体现。CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。&lt;/p&gt;
&lt;p&gt;比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。&lt;/p&gt;
&lt;p&gt;部分乐观锁的实现是通过版本号（&lt;code&gt;version&lt;/code&gt;）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行&lt;code&gt;+1&lt;/code&gt;操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。因此AtomicStampedReference/AtomicMarkableReference就很有用了。&lt;/p&gt;
&lt;p&gt;AtomicMarkableReference 类描述的一个&amp;lt;Object,Boolean&amp;gt;的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;AtomicStampedReference 类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比AtomicMarkableReference 类的&amp;lt;Object,Boolean&amp;gt;，AtomicStampedReference 维护的是一种类似&amp;lt;Object,int&amp;gt;的数据结构，其实就是对对象（引用）的一个并发计数（标记版本戳stamp）。但是与AtomicInteger 不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。&lt;/p&gt;
&lt;h2&gt;REFERENCE：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;整理自以下博客：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.  &lt;a href=&quot;http://www.hollischuang.com/archives/934&quot; target=&quot;_blank&quot;&gt;http://www.hollischuang.com/archives/934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.hollischuang.com/archives/1537&quot; target=&quot;_blank&quot;&gt; http://www.hollischuang.com/archives/1537&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.  &lt;a href=&quot;http://www.cnblogs.com/Mainz/p/3546347.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/Mainz/p/3546347.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.  &lt;a href=&quot;http://www.digpage.com/lock.html&quot; target=&quot;_blank&quot;&gt;http://www.digpage.com/lock.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;a href=&quot;https://chenzhou123520.iteye.com/blog/1863407&quot; target=&quot;_blank&quot;&gt; https://chenzhou123520.iteye.com/blog/1863407&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.  &lt;a href=&quot;https://chenzhou123520.iteye.com/blog/1860954&quot; target=&quot;_blank&quot;&gt;https://chenzhou123520.iteye.com/blog/1860954&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 07:16:00 +0000</pubDate>
<dc:creator>勋爵</dc:creator>
<og:description>前言： 在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-knight/p/10669934.html</dc:identifier>
</item>
<item>
<title>面向对象的思想，谈面试的过程？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10670582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10670582.html</guid>
<description>&lt;h3 id=&quot;h01&quot;&gt;01、&lt;/h3&gt;
&lt;p&gt;很久没有思考过什么是面向对象这个问题了，就好像很久没有吃过烤红薯一样，那股香味究竟是什么，已经很难准确地形容出来了。脑海中只浮现出这样一幅动图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;在这里插入图片描述&quot; src=&quot;https://img-blog.csdnimg.cn/20190408144507701.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前两天，读者秋秋问我：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;二哥，究竟什么是面向对象呢？还有，什么是面向过程。今天去面试的时候，面试官让我用面向对象的思想谈一谈这次面试的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这个问题后，我思考了好一会儿，总觉得面试官的问法有点问题：为什么要用面向对象的思想谈一谈面试的“过程”？&lt;/p&gt;
&lt;p&gt;有点矛盾，有没有？先不管这么多了，且来看看什么是面向对象吧。&lt;/p&gt;
&lt;p&gt;一开始的时候，并没有面向对象，只有面向过程的概念。我们回到秋秋面试的话题上，把面试前（可以降低需求的复杂性）的过程简单地拆解一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;秋秋投递简历&lt;/li&gt;
&lt;li&gt;面试官收到秋秋的简历&lt;/li&gt;
&lt;li&gt;面试官通知秋秋面试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了实现这 3 个步骤，我们定义 3 个方法，并依次调用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;qiuqiuDeliverResume();&lt;/li&gt;
&lt;li&gt;interviewerReceiveResume();&lt;/li&gt;
&lt;li&gt;interviewerNotifyQiuqiu();&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，假如参加面试的不是秋秋，这 3 个方法就要重新定义了（莫抬杠），尽管步骤并没有变。面向对象从另一个角度来解决这个问题，它把对象（对事物的一种抽象描述）作为程序的基本单元。&lt;/p&gt;
&lt;p&gt;回到秋秋面试的例子，用面向对象的思想来实现，就需要先定义 2 个类（类是构建对象的蓝图，里面包含若干的数据和操作这些数据的方法），分别是应聘者和面试官。&lt;/p&gt;
&lt;p&gt;应聘者可以投递简历；面试官可以接收应聘者的简历和通知应聘者前来面试。然后再通过类创建两个对象，分别是秋秋和他的面试官；对象创建成功后，就可以依次调用对应的方法完成上述的 3 个步骤。&lt;/p&gt;
&lt;p&gt;面向对象（英语：Object Oriented，缩写：OO）思想是一种试图降低代码间的依赖，应对复杂性，从而解决代码重用的软件设计思想——恰好解决了面向过程带来的问题。&lt;/p&gt;
&lt;p&gt;面向对象有很多重要的特性，比如说封装、继承和多态。这些概念又该怎么理解呢？所谓一图胜千言，我给你来一张有趣的、形象的。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-abd1258621ae1867.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解了面向对象的思想后，我们来通过具体的代码完成秋秋面试前的 3 个步骤。并对类和对象的相关知识点进行归纳和总结。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;02、&lt;/h3&gt;
&lt;p&gt;先来细致地看一下应聘者类——Candidate.java。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;10&quot;&gt;package com.cmower&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Candidate {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private String name;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;Candidate&lt;span class=&quot;hljs-params&quot;&gt;(String name) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.name = name;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;deliverResume&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;System.out.println(getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;发简历&quot;);&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getName&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return name;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setName&lt;span class=&quot;hljs-params&quot;&gt;(String name) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.name = name;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Candidate 包含了类的 4 个重要概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;成员变量（有时叫做域，有时叫做字段，有时叫做属性）&lt;code&gt;name&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;成员变量访问器（有时叫做 &lt;code&gt;getter/setter&lt;/code&gt;）&lt;code&gt;getName()&lt;/code&gt; 和 &lt;code&gt;setName()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;构造方法（有时叫做构造器）&lt;code&gt;Candidate()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;普通方法 &lt;code&gt;deliverResume()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Candidate 类虽然简单，但却大有学问。&lt;/p&gt;
&lt;p&gt;1）为了保证包名的绝对唯一，Sun 公司建议将域名（绝对是独一无二的）以逆序的形式作为包名——这也是为什么包名经常以 &lt;code&gt;org&lt;/code&gt;、&lt;code&gt;com&lt;/code&gt; 开头的原因（是不是有一种豁然开朗的感觉）。我曾申请过一个域名，叫 cmower.com，所以我个人编写的绝大多数代码都是在 &lt;code&gt;com.cmower&lt;/code&gt;包下。&lt;/p&gt;
&lt;p&gt;2）类的方法定义顺序依次是：构造方法 &amp;gt; 公有（&lt;code&gt;public&lt;/code&gt;）方法或保护（&lt;code&gt;protected&lt;/code&gt;）方法 &amp;gt; 私有（&lt;code&gt;private&lt;/code&gt;）方法 &amp;gt; getter/setter 方法。&lt;/p&gt;
&lt;p&gt;构造方法是创建对象的必经之路，放在首位是必须的。如果只有系统默认的无参构造方法，可忽略。&lt;/p&gt;
&lt;p&gt;公有方法是类的调用者和维护者最关心的方法，应该在比较靠前的位置展示；保护方法虽然只有子类关心，也可能是“模板设计模式”下的核心方法，所以也要靠前；私有方法只对本类可见，一般不需要特别关心，所以往后放；&lt;code&gt;getter/setter&lt;/code&gt; 方法承载的信息价值较低，所以放在类的最后面。&lt;/p&gt;
&lt;p&gt;3）setter 方法中，参数名称与成员变量名称保持一致，采用 &lt;code&gt;this.成员名 = 参数名&lt;/code&gt; 的形式。&lt;/p&gt;
&lt;p&gt;4）成员变量不要用 &lt;code&gt;public&lt;/code&gt; 修饰，尽量用 &lt;code&gt;private&lt;/code&gt; 修饰；如果需要被子类继承，可以用 &lt;code&gt;protected&lt;/code&gt; 修饰。&lt;/p&gt;
&lt;p&gt;在初学 Java 编程的时候，我经常产生一个疑惑：为什么不使用 &lt;code&gt;public&lt;/code&gt; 修饰成员变量呢？这样做不是比 &lt;code&gt;getter/setter&lt;/code&gt; 更方便吗？&lt;/p&gt;
&lt;p&gt;我最先想到的答案是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-489c91cab5dd76c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;解释&lt;/em&gt;：如果只有 &lt;code&gt;private String name&lt;/code&gt; 而没有 &lt;code&gt;getter/setter&lt;/code&gt; 的话，Eclipse 会提示 &lt;code&gt;The value of the field Candidate.name is not used&lt;/code&gt; 的警告。&lt;/p&gt;
&lt;p&gt;当然了，这样的答案过于牵强。那能不能来个靠谱点的答案呢？&lt;/p&gt;
&lt;p&gt;能，为了体现封装的思想：将数据与行为进行分离。封装有什么好处呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;隐藏类的实现细节；&lt;/li&gt;
&lt;li&gt;让使用者只能通过事先定制好的方法（&lt;code&gt;getter/setter&lt;/code&gt;）来访问数据，可以方便地加入控制方法，限制对成员变量的不合理操作；&lt;/li&gt;
&lt;li&gt;便于修改，增强代码的维护性和健壮性；&lt;/li&gt;
&lt;li&gt;提高代码的安全性和规范性；&lt;/li&gt;
&lt;li&gt;使程序更加具备稳定性和可拓展性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过，我对这些严肃的词汇和科学用语实在是提不起半点兴致。那就再换一个答案吧。&lt;/p&gt;
&lt;p&gt;套用《Java 开发实战经典》中举过的一个例子，我们增加一个应聘者年龄的共有成员变量 age。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Candidate {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;int age;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在创建应聘者对象的时候，直接通过类成员变量赋值：&lt;code&gt;new Candidate().age = -99;&lt;/code&gt; 这样赋值是没有任何问题的，但没有实际的意义，年龄是不可能为负数的。为了防止出现这样的错误，可以对它进行封装，也就是私有化，然后在 &lt;code&gt;setter&lt;/code&gt; 方法中对年龄进行判断，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Candidate {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;1&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot; readability=&quot;2&quot;&gt;int age;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setAge&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int age) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (age &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.age = age;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个答案你觉得满意吗？我最开始看到这个答案的时候觉得很满意。但看了《阿里巴巴 Java 开发手册》后（详情截图如下），就觉得不满意了。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-9f6c9649ebf6a8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一，类成员变量使用基本类型很容易造成&lt;code&gt;NullPointException&lt;/code&gt;的错误；第二，在 &lt;code&gt;getter/setter&lt;/code&gt; 增加业务逻辑的确很容易把实际的问题隐藏起来。&lt;/p&gt;
&lt;p&gt;那，好的答案究竟是什么呢？&lt;/p&gt;
&lt;p&gt;如果设置成员变量为 &lt;code&gt;public&lt;/code&gt;，那么每个调用者都可以读写它，但如果以 &lt;code&gt;private&lt;/code&gt; 配合 &lt;code&gt;getter/setter&lt;/code&gt; 的形式访问时，就可以达到“不准访问”、“只读访问”、“读写访问”以及“只写访问”的目的。因为不是每个成员变量都需要 &lt;code&gt;getter/setter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;5）每个类都至少会有一个构造方法。初学者可能会非常疑惑：我的那个类真的没有构造方法啊！&lt;/p&gt;
&lt;p&gt;如果在编写一个类的时候没有编写构造方法，那么系统就会提供一个无参的构造方法，就好像是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Candidate {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private String name;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;Candidate&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当执行 &lt;code&gt;new Candidate()&lt;/code&gt; 的时候，成员变量 name 就会被初始化为 &lt;code&gt;null&lt;/code&gt;。一般情况下，我们会为类设置它必须的构造方法，然后在创建对象的时候对成员变量进行赋值。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;03、&lt;/h3&gt;
&lt;p&gt;再来粗略地看一下面试官类——Interviewer.java。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot; readability=&quot;6&quot;&gt;Interviewer {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;12&quot;&gt;private Candidate candidate;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;Interviewer &lt;span class=&quot;hljs-params&quot;&gt;(Candidate candidate) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.candidate = candidate;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;receviveResume&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;收到&quot; + getCandidate().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;简历&quot;);&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;notifyInterview&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;通知&quot; + getCandidate().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;面试&quot;);&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Candidate &lt;span class=&quot;hljs-title&quot;&gt;getCandidate&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return candidate;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setCandidate&lt;span class=&quot;hljs-params&quot;&gt;(Candidate candidate) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.candidate = candidate;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Interviewer 有一个成员变量 Candidate，一个构造方法，两个共有方法，以及成员变量对应的 &lt;code&gt;getter/setter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（这段代码存在一个严重的问题，你注意到了吗？）&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;04、&lt;/h3&gt;
&lt;p&gt;然后，我们让应聘者发送简历，让面试官接收简历并发送通知。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Candidate qiuqiu = &lt;span class=&quot;hljs-keyword&quot;&gt;new Candidate(&lt;span class=&quot;hljs-string&quot;&gt;&quot;秋秋&quot;);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在初学 Java 的很长一段时间里，我总是搞不清楚什么是“对象”，什么是“引用”，差点因此放弃我的程序生涯。后来，在网上认识了一个大佬，人称老王，是他挽救了我的程序生涯。&lt;/p&gt;
&lt;p&gt;他解释说。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Candidate qiuqiu = new Candidate(&quot;秋秋&quot;);&lt;/code&gt;可以拆分为两行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Candidate qiuqiu;&lt;br/&gt;qiuqiu = &lt;span class=&quot;hljs-keyword&quot;&gt;new Candidate(&lt;span class=&quot;hljs-string&quot;&gt;&quot;秋秋&quot;);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行代码 &lt;code&gt;Candidate qiuqiu;&lt;/code&gt; 中的 qiuqiu 这时候可以称作是对象变量，它暂时还没有引用任何对象，严格意义上，它也不能称为 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;第二行代码 &lt;code&gt;qiuqiu = new Candidate(&quot;秋秋&quot;);&lt;/code&gt; 可以拆分为两个部分，= 号左侧和 = 号右侧。&lt;/p&gt;
&lt;p&gt;右侧的表达式 &lt;code&gt;new Candidate(&quot;秋秋&quot;)&lt;/code&gt; 先执行，执行完后，会在堆上创建了一个 name 为“秋秋”的对象，类型为 Candidate，表达式 &lt;code&gt;new Candidate(&quot;秋秋&quot;)&lt;/code&gt; 的值是新创建对象的引用。&lt;/p&gt;
&lt;p&gt;然后再把这个引用通过 = 操作符赋值给左侧的对象变量 &lt;code&gt;qiuqiu&lt;/code&gt;，赋值后，&lt;code&gt;qiuqiu&lt;/code&gt;就不再是对象变量了，应该称为对象引用。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-a426c1504a567fa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完老王的解释，你会不会情不自禁地“哦，原来如此啊！”反正我当时顿悟的时候是这样的。&lt;/p&gt;
&lt;p&gt;前面提到，Interviewer 类的设计存在一个严重的问题，是什么呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Candidate qiuqiu = &lt;span class=&quot;hljs-keyword&quot;&gt;new Candidate(&lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;秋秋&quot;);&lt;br/&gt;Interviewer interviewer = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;2&quot;&gt;new Interviewer(qiuqiu);&lt;p&gt;interviewer.getCandidate().setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;夏夏&quot;);&lt;br/&gt;System.out.println(qiuqiu.getName());&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码执行完后，你会发现秋秋变成了夏夏，应聘者的私有成员变量 name 竟然被改变了！问题的原因也很简单，qiuqiu 和 &lt;code&gt;interviewer.getCandidate()&lt;/code&gt; 引用了同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-bbaa8b74dbfa1bca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那怎么解决呢？当 &lt;code&gt;getter&lt;/code&gt; 需要返回一个可变对象的引用时，应该先进行克隆（clone）。以下展示了一个非常简单的克隆方案。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot; readability=&quot;2.5&quot;&gt;Interviewer {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;5&quot;&gt;private Candidate candidate;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;Interviewer &lt;span class=&quot;hljs-params&quot;&gt;(Candidate candidate) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.candidate = candidate;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Candidate &lt;span class=&quot;hljs-title&quot;&gt;getCandidate&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;Candidate candidate = &lt;span class=&quot;hljs-keyword&quot;&gt;new Candidate(&lt;span class=&quot;hljs-keyword&quot;&gt;this.candidate.getName());&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return candidate;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h05&quot;&gt;05、&lt;/h3&gt;
&lt;p&gt;这篇文章花了 5 个多小时才写完，此刻我的感觉只有一个字——饿，我要出去吃饭了。吃饭之前，我决定先买个烤红薯吃，重温一下那种久违的香。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 07:06:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>01、 很久没有思考过什么是面向对象这个问题了，就好像很久没有吃过烤红薯一样，那股香味究竟是什么，已经很难准确地形容出来了。脑海中只浮现出这样一幅动图： 前两天，读者秋秋问我： 二哥，究竟什么是面向对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10670582.html</dc:identifier>
</item>
<item>
<title>微信公众号开发C#系列-6、消息管理-普通消息接受处理 - yonghu86</title>
<link>http://www.cnblogs.com/huyong/p/10659473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huyong/p/10659473.html</guid>
<description>&lt;p&gt;通过前面章节的学习，我们已经对微信的开发有了基本的掌握与熟悉，基本可以上手做复杂的应用了。本篇我们将详细讲解微信消息管理中普通消息的接收与处理。当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上。接收普通消息微信官方文档参考：&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140453&quot;&gt;接收普通消息文档API&lt;/a&gt;&lt;br/&gt;消息接收后，就有一个处理或回复的过程，单单发送消息了没有响应也是不人性化的，下面我们就对接收到微信各类型消息分别讲解处理的方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184409392-1083658860.png&quot; alt=&quot;接收普通消息类型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当普通微信用户向公众账号发消息时，微信服务器会先接收到用户发送的消息，然后将用户消息按照指定的XML格式组装好数据，最后POST消息的XML数据包到开发者填写的URL上。&lt;/p&gt;
&lt;p&gt;接收到的普通消息的消息类型目前有以下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文本消息&lt;/li&gt;
&lt;li&gt;图片消息&lt;/li&gt;
&lt;li&gt;语音消息&lt;/li&gt;
&lt;li&gt;视频消息&lt;/li&gt;
&lt;li&gt;小视频消息&lt;/li&gt;
&lt;li&gt;地理位置消息&lt;/li&gt;
&lt;li&gt;链接消息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;每一种消息类型都有其指定的XML数据格式，这7种消息的xml格式请到官方文档查看，有具体的格式定义和属性说明。格式很简单，基本共有属性包括&lt;strong&gt;ToUserName、FromUserName、CreateTime、MsgType、MsgId&lt;/strong&gt;，并且每种类型有自己特殊的属性。&lt;/p&gt;
&lt;p&gt;接收消息的过程其实就是获取post请求的这个xml，然后对这个xml进行分析的过程。post请求的入口还是之前提到的微信公众号接入的那个地址，整个公众号的所有请求都会走这个入口，只是接入时是get请求，其它情况下是post请求。&lt;/p&gt;

&lt;p&gt;微信服务器在将用户的消息发给公众号的开发者服务器地址后，会等待开发者服务器回复响应消息。微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。&lt;/p&gt;
&lt;p&gt;假如服务器无法保证在五秒内处理并回复，必须做出下述回复，这样微信服务器才不会对此作任何处理，并且不会发起重试（这种情况下，可以使用客服消息接口进行异步回复），否则，将出现严重的错误提示。详见下面说明：&lt;/p&gt;
&lt;p&gt;1、（推荐方式）直接回复success&lt;/p&gt;
&lt;p&gt;2、直接回复空串（指字节长度为0的空字符串，而不是XML结构体中content字段的内容为空）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一旦遇到以下情况，微信都会在公众号会话中，向用户下发系统提示“该公众号暂时无法提供服务，请稍后再试”&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1、开发者在5秒内未回复任何内容&lt;/p&gt;
&lt;p&gt;2、开发者回复了异常数据，比如JSON数据等&lt;/p&gt;
&lt;p&gt;另外，请注意，回复图片等多媒体消息时需要预先通过素材管理接口上传临时素材到微信服务器，可以使用素材管理中的临时素材，也可以使用永久素材。&lt;/p&gt;
&lt;p&gt;消息回复目前支持回复文本、图片、图文、语音、视频、音乐，每一种类型的消息都有特定的XML数据格式。这几种回复消息的xml数据格式请参考官方文档，有具体的格式定义和属性说明。格式很简单，基本共有属性包括&lt;strong&gt;ToUserName、FromUserName、CreateTime、MsgType&lt;/strong&gt;，并且每种类型有自己特殊的属性。&lt;/p&gt;

&lt;p&gt;使用Senparc.Weixin框架来快速处理各种接收的普通消息,实现非常简单，自定义一个继承MessageHandler的类，重写这7种类型的方法即可。注意：DefaultResponseMessage必须重写，用于返回没有处理过的消息类型（也可以用于默认消息，如帮助信息等）；其中所有原OnXX的抽象方法已经都改为虚方法，可以不必每个都重写。若不重写，默认返回DefaultResponseMessage方法中的结果。&lt;br/&gt;CustomMessageHandle.cs需要继承Senparc.Weixin.MP.MessageHandlers这个抽象类，并实现部分方法。最初步的CustomMessageHandle.cs代码&lt;br/&gt;可能如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CustomMessageHandler : MessageHandler&amp;lt;CustomMessageContext&amp;gt;
{
    public CustomMessageHandler(Stream inputStream, PostModel postModel)
        : base(inputStream, postModel)
    {

    }

    public override IResponseMessageBase DefaultResponseMessage(IRequestMessageBase requestMessage)
    {
        var responseMessage = base.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;(); //ResponseMessageText也可以是News等其他类型
        responseMessage.Content = &quot;这条消息来自DefaultResponseMessage。&quot;;
        return responseMessage;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到必须要重写实现的抽象方法名为DefaultResponseMessage()，这一条信息用于返回一条的消息，假如对应类型（如语音）的微信消息没有被代码处理，那么默认会返回这里的结果。在DefaultResponseMessage()方法中，我们看到这样一句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var responseMessage = base.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;(); //ResponseMessageText也可以是News等其他类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的CreateResponseMessage方法即创建一个返回对象，T可以为以下类型的任意一个，分别对应了不同的返回类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ResponseMessageText - 对应文本消息&lt;/li&gt;
&lt;li&gt;ResponseMessageNews - 对应图文消息&lt;/li&gt;
&lt;li&gt;ResponseMessageMusic - 对应音乐消息&lt;/li&gt;
&lt;li&gt;ResponseMessageXXX - 其他类型以此类推&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;各种类型的消息我们可以根据我们自己的业务要求进行重写回复，如果没重写就会返回默认的消息（重写默认响应的基础上）。&lt;/p&gt;
&lt;h2 id=&quot;文本消息的接收与回复&quot;&gt;4.1、文本消息的接收与回复&lt;/h2&gt;
&lt;p&gt;文本消息对应的数据包XML格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;xml&amp;gt;
  &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[toUser]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
  &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[fromUser]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
  &amp;lt;CreateTime&amp;gt;1348831860&amp;lt;/CreateTime&amp;gt;
  &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[text]]&amp;gt;&amp;lt;/MsgType&amp;gt;
  &amp;lt;Content&amp;gt;&amp;lt;![CDATA[this is a test]]&amp;gt;&amp;lt;/Content&amp;gt;
  &amp;lt;MsgId&amp;gt;1234567890123456&amp;lt;/MsgId&amp;gt;
&amp;lt;/xml&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;参数              描述
ToUserName      开发者微信号（直接把它当做你的公众号的微信号即可）
FromUserName    发送方帐号（一个OpenID）
CreateTime      消息创建时间 （整型）
MsgType         消息类型，文本为text
Content         文本消息内容
MsgId           消息id，64位整型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理文本消息参考代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 处理文字请求
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnTextRequest(RequestMessageText requestMessage)
{
    //注意：下面泛型ResponseMessageText即返回给客户端的类型，可以根据自己的需要填写ResponseMessageNews等不同类型。
    var responseMessage = CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
 
    var result = new StringBuilder();
    result.AppendFormat(&quot;您刚发送了文本信息：{0}\r\n\r\n&quot;, requestMessage.Content);
 
    if (CurrentMessageContext.RequestMessages.Count &amp;gt; 1)
    {
        result.AppendFormat(&quot;您刚还发送了如下消息（{0}/{1}）：\r\n&quot;, CurrentMessageContext.RequestMessages.Count, CurrentMessageContext.StorageData);
        for (int i = CurrentMessageContext.RequestMessages.Count - 2; i &amp;gt;= 0; i--)
        {
            var historyMessage = CurrentMessageContext.RequestMessages[i];
            result.AppendFormat(&quot;{0} 【{1}】{2}\r\n&quot;,
                                historyMessage.CreateTime.ToShortTimeString(),
                                historyMessage.MsgType.ToString(),
                                (historyMessage is RequestMessageText)
                                    ? (historyMessage as RequestMessageText).Content
                                    : &quot;[非文字类型]&quot;
                );
        }
        result.AppendLine(&quot;\r\n&quot;);
    }
    result.AppendFormat(&quot;如果您在{0}分钟内连续发送消息，记录将被自动保留（当前设置：最多记录{1}条）。过期后记录将会自动清除。\r\n&quot;, WeixinContext.ExpireMinutes, WeixinContext.MaxRecordCount);
    result.AppendLine(&quot;\r\n&quot;);
    result.AppendLine(&quot;您还可以发送【位置】【图片】【语音】【视频】等类型的信息（注意是这几种类型，不是这几个文字），查看不同格式的回复。&quot;);
    responseMessage.Content = result.ToString();
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184450854-84119170.png&quot; alt=&quot;文本消息调试状态展示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184457373-221529344.png&quot; alt=&quot;文本消息回复结果展示&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;图片消息的接收与回复&quot;&gt;4.2、图片消息的接收与回复&lt;/h2&gt;
&lt;p&gt;图片消息对应的数据包XML格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;xml&amp;gt;
  &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[toUser]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
  &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[fromUser]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
  &amp;lt;CreateTime&amp;gt;1348831860&amp;lt;/CreateTime&amp;gt;
  &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[image]]&amp;gt;&amp;lt;/MsgType&amp;gt;
  &amp;lt;PicUrl&amp;gt;&amp;lt;![CDATA[this is a url]]&amp;gt;&amp;lt;/PicUrl&amp;gt;
  &amp;lt;MediaId&amp;gt;&amp;lt;![CDATA[media_id]]&amp;gt;&amp;lt;/MediaId&amp;gt;
  &amp;lt;MsgId&amp;gt;1234567890123456&amp;lt;/MsgId&amp;gt;
&amp;lt;/xml&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;参数              描述

ToUserName      开发者微信号
FromUserName    发送方帐号（一个OpenID）
CreateTime      消息创建时间 （整型）
MsgType         消息类型，图片为image
PicUrl          图片链接（由系统生成）
MediaId         图片消息媒体id，可以调用获取临时素材接口拉取数据。
MsgId           消息id，64位整型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理图片消息参考代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 处理图片请求
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnImageRequest(RequestMessageImage requestMessage)
{
    var responseMessage = CreateResponseMessage&amp;lt;ResponseMessageNews&amp;gt;();
    responseMessage.Articles.Add(new Article()
    {
        Title = &quot;您刚才发送了图片信息&quot;,
        Description = &quot;您发送的图片将会显示在边上&quot;,
        PicUrl = requestMessage.PicUrl,
        Url = &quot;http://blog.rdiframework.net/&quot;
    });
    responseMessage.Articles.Add(new Article()
    {
        Title = &quot;第二条&quot;,
        Description = &quot;第二条带连接的内容&quot;,
        PicUrl = requestMessage.PicUrl,
        Url = &quot;http://blog.rdiframework.net/&quot;
    });

    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面代码中我们返回了用户发送的图片消息，同时加上了链接地址，用户单击消息会自动跳转到指定的URL地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184528349-957767287.png&quot; alt=&quot;图片消息调试状态展示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184536580-1374244970.png&quot; alt=&quot;图片消息回复结果展示&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;语音消息的接收与回复&quot;&gt;4.3、语音消息的接收与回复&lt;/h2&gt;
&lt;p&gt;语音消息对应的数据包XML格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;xml&amp;gt;
  &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[toUser]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
  &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[fromUser]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
  &amp;lt;CreateTime&amp;gt;1357290913&amp;lt;/CreateTime&amp;gt;
  &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[voice]]&amp;gt;&amp;lt;/MsgType&amp;gt;
  &amp;lt;MediaId&amp;gt;&amp;lt;![CDATA[media_id]]&amp;gt;&amp;lt;/MediaId&amp;gt;
  &amp;lt;Format&amp;gt;&amp;lt;![CDATA[Format]]&amp;gt;&amp;lt;/Format&amp;gt;
  &amp;lt;MsgId&amp;gt;1234567890123456&amp;lt;/MsgId&amp;gt;
&amp;lt;/xml&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;参数              描述
ToUserName      开发者微信号
FromUserName    发送方帐号（一个OpenID）
CreateTime      消息创建时间 （整型）
MsgType         语音为voice
MediaId         语音消息媒体id，可以调用获取临时素材接口拉取数据。
Format          语音格式，如amr，speex等
MsgID           消息id，64位整型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;处理语音消息参考代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 处理语音请求
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnVoiceRequest(RequestMessageVoice requestMessage)
{
    //获得当前公众号
    WeixinOfficialAccountEntity account = RDIFrameworkService.Instance.WeixinBasicService.GetOfficialAccountEntity(Id);
    
    var responseMessage = CreateResponseMessage&amp;lt;ResponseMessageMusic&amp;gt;();
    //上传缩略图
    var uploadResult = Senparc.Weixin.MP.AdvancedAPIs.MediaApi.UploadTemporaryMedia(account.AccessToken, UploadMediaFileType.image,Server.GetMapPath(&quot;~/Content/Images/weixing-ma.png&quot;));

    //设置音乐信息
    responseMessage.Music.Title = &quot;天籁之音&quot;;
    responseMessage.Music.Description = &quot;播放您上传的语音&quot;;
    responseMessage.Music.MusicUrl = &quot;http://www.rdiframework.net/resource/25375532.mp3&quot;;
    responseMessage.Music.HQMusicUrl = &quot;http://www.rdiframework.net/Media/GetVoice?mediaId=&quot; + requestMessage.MediaId;
    responseMessage.Music.ThumbMediaId = uploadResult.media_id;
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184606941-1582903071.png&quot; alt=&quot;语音消息调试状态展示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184618005-1721498629.png&quot; alt=&quot;语音消息回复结果展示&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;视频消息的接收与回复&quot;&gt;4.4、视频消息的接收与回复&lt;/h2&gt;
&lt;p&gt;视频消息对应的数据包XML格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;xml&amp;gt;
  &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[toUser]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
  &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[fromUser]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
  &amp;lt;CreateTime&amp;gt;1357290913&amp;lt;/CreateTime&amp;gt;
  &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[video]]&amp;gt;&amp;lt;/MsgType&amp;gt;
  &amp;lt;MediaId&amp;gt;&amp;lt;![CDATA[media_id]]&amp;gt;&amp;lt;/MediaId&amp;gt;
  &amp;lt;ThumbMediaId&amp;gt;&amp;lt;![CDATA[thumb_media_id]]&amp;gt;&amp;lt;/ThumbMediaId&amp;gt;
  &amp;lt;MsgId&amp;gt;1234567890123456&amp;lt;/MsgId&amp;gt;
&amp;lt;/xml&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;参数              描述
ToUserName      开发者微信号
FromUserName    发送方帐号（一个OpenID）
CreateTime      消息创建时间 （整型）
MsgType         视频为video
MediaId         视频消息媒体id，可以调用获取临时素材接口拉取数据。
ThumbMediaId    视频消息缩略图的媒体id，可以调用多媒体文件下载接口拉取数据。
MsgId           消息id，64位整型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理视频消息参考代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 处理视频请求
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnVideoRequest(RequestMessageVideo requestMessage)
{
    var responseMessage = CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
    responseMessage.Content = &quot;您发送了一条视频信息，ID：&quot; + requestMessage.MediaId;
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184644903-1977382296.png&quot; alt=&quot;视频消息调试状态展示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184652607-535098819.png&quot; alt=&quot;视频消息回复结果展示&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小视频消息的接收与回复&quot;&gt;4.5、小视频消息的接收与回复&lt;/h2&gt;
&lt;p&gt;视频与小视频主要区别是在MsgType上，其他的都一样。&lt;/p&gt;
&lt;p&gt;小视频消息对应的数据包XML格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;xml&amp;gt;
  &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[toUser]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
  &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[fromUser]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
  &amp;lt;CreateTime&amp;gt;1357290913&amp;lt;/CreateTime&amp;gt;
  &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[shortvideo]]&amp;gt;&amp;lt;/MsgType&amp;gt;
  &amp;lt;MediaId&amp;gt;&amp;lt;![CDATA[media_id]]&amp;gt;&amp;lt;/MediaId&amp;gt;
  &amp;lt;ThumbMediaId&amp;gt;&amp;lt;![CDATA[thumb_media_id]]&amp;gt;&amp;lt;/ThumbMediaId&amp;gt;
  &amp;lt;MsgId&amp;gt;1234567890123456&amp;lt;/MsgId&amp;gt;
&amp;lt;/xml&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;参数              描述
ToUserName      开发者微信号
FromUserName    发送方帐号（一个OpenID）
CreateTime      消息创建时间 （整型）
MsgType         小视频为shortvideo
MediaId         视频消息媒体id，可以调用获取临时素材接口拉取数据。
ThumbMediaId    视频消息缩略图的媒体id，可以调用获取临时素材接口拉取数据。
MsgId           消息id，64位整型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理小视频消息参考代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public override IResponseMessageBase OnShortVideoRequest(RequestMessageShortVideo requestMessage)
{
    var responseMessage = this.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;();
    responseMessage.Content = &quot;您刚才发送的是小视频&quot;;
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;地理位置消息的接收与回复&quot;&gt;4.6、地理位置消息的接收与回复&lt;/h2&gt;
&lt;p&gt;地理位置消息对应的数据包XML格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;xml&amp;gt;
  &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[toUser]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
  &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[fromUser]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
  &amp;lt;CreateTime&amp;gt;1351776360&amp;lt;/CreateTime&amp;gt;
  &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[location]]&amp;gt;&amp;lt;/MsgType&amp;gt;
  &amp;lt;Location_X&amp;gt;23.134521&amp;lt;/Location_X&amp;gt;
  &amp;lt;Location_Y&amp;gt;113.358803&amp;lt;/Location_Y&amp;gt;
  &amp;lt;Scale&amp;gt;20&amp;lt;/Scale&amp;gt;
  &amp;lt;Label&amp;gt;&amp;lt;![CDATA[位置信息]]&amp;gt;&amp;lt;/Label&amp;gt;
  &amp;lt;MsgId&amp;gt;1234567890123456&amp;lt;/MsgId&amp;gt;
&amp;lt;/xml&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;参数              描述
ToUserName      开发者微信号
FromUserName    发送方帐号（一个OpenID）
CreateTime      消息创建时间 （整型）
MsgType         消息类型，地理位置为location
Location_X      地理位置维度
Location_Y      地理位置经度
Scale           地图缩放大小
Label           地理位置信息
MsgId           消息id，64位整型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理地理位置消息参考代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 处理位置请求
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnLocationRequest(RequestMessageLocation requestMessage)
{
    //返回的是图文消息,是关于地址的图文消息。
    var responseLocation = base.CreateResponseMessage&amp;lt;ResponseMessageNews&amp;gt;();

    var markersList = new List&amp;lt;BaiduMarkers&amp;gt;();
    markersList.Add(new BaiduMarkers()
    {
        Size = BaiduMarkerSize.m,
        Color = &quot;red&quot;,
        Label = &quot;A&quot;,
        Latitude = requestMessage.Location_X,
        Longitude = requestMessage.Location_Y,
    });
    var mapUrl = BaiduMapHelper.GetBaiduStaticMap(requestMessage.Location_Y, requestMessage.Location_X, 1, 13, markersList);
    responseLocation.Articles.Add(new Article()
    {
        Description = string.Format(&quot;您刚才发送了地理位置信息。Location_X:{0},Location_Y:{1},Scale:{2},标签：{3}&quot;, requestMessage.Location_X, requestMessage.Location_Y, requestMessage.Scale, requestMessage.Label),
        PicUrl = SystemInfo.WeChatSiteUrl +&quot;/Content/Images/toplogo.png&quot;,
        Title = &quot;国思软件快速开发框架-地图返回&quot;,
        Url = mapUrl
    });
    return responseLocation;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184722984-839506353.png&quot; alt=&quot;地理位置消息调试状态展示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184729171-863805334.png&quot; alt=&quot;地理位置消息回复结果展示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于回复的消息，我们还可以单击弹出百度地图返回的位置详情，具体应用可据此扩展。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201904/157572-20190405184754907-1556161027.png&quot; alt=&quot;地理位置消息返回消息弹出位置图片&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;链接消息的接收与回复&quot;&gt;4.7、链接消息的接收与回复&lt;/h2&gt;
&lt;p&gt;链接消息对应的数据包XML格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;xml&amp;gt;
  &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[toUser]]&amp;gt;&amp;lt;/ToUserName&amp;gt;
  &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[fromUser]]&amp;gt;&amp;lt;/FromUserName&amp;gt;
  &amp;lt;CreateTime&amp;gt;1351776360&amp;lt;/CreateTime&amp;gt;
  &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[link]]&amp;gt;&amp;lt;/MsgType&amp;gt;
  &amp;lt;Title&amp;gt;&amp;lt;![CDATA[公众平台官网链接]]&amp;gt;&amp;lt;/Title&amp;gt;
  &amp;lt;Description&amp;gt;&amp;lt;![CDATA[公众平台官网链接]]&amp;gt;&amp;lt;/Description&amp;gt;
  &amp;lt;Url&amp;gt;&amp;lt;![CDATA[url]]&amp;gt;&amp;lt;/Url&amp;gt;
  &amp;lt;MsgId&amp;gt;1234567890123456&amp;lt;/MsgId&amp;gt;
&amp;lt;/xml&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;参数  描述
ToUserName      接收方微信号
FromUserName    发送方微信号，若为普通用户，则是一个OpenID
CreateTime      消息创建时间
MsgType         消息类型，链接为link
Title           消息标题
Description     消息描述
Url             消息链接
MsgId           消息id，64位整型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;链接位置消息参考代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 处理链接消息请求
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public override IResponseMessageBase OnLinkRequest(RequestMessageLink requestMessage)
{
    var responseMessage = ResponseMessageBase.CreateFromRequestMessage&amp;lt;ResponseMessageText&amp;gt;(requestMessage);
    responseMessage.Content = string.Format(@&quot;您发送了一条连接信息：
    Title：{0}
    Description:{1}
    Url:{2}&quot;, requestMessage.Title, requestMessage.Description, requestMessage.Url);
    return responseMessage;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1445241432&quot;&gt;微信公众平台技术文档-官方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JeffreySu/WeiXinMPSDK&quot;&gt;Senparc.Weixin SDK + 官网示例源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rdiframework.net/article/169&quot;&gt;RDIFramework.NET ━ .NET快速信息化系统开发框架 ━ 工作流程组件介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rdiframework.net/article/169&quot;&gt;RDIFramework.NET ━ .NET快速信息化系统开发框架 ━ 工作流程组件介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rdiframework.net/article/189&quot;&gt;RDIFramework.NET框架SOA解决方案（集Windows服务、WinForm形式与IIS形式发布）-分布式应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rdiframework.net/article/199&quot;&gt;RDIFramework.NET代码生成器全新V3.5版本发布-重大升级&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;一路走来数个年头，感谢RDIFramework.NET框架的支持者与使用者，大家可以通过下面的地址了解详情。&lt;/p&gt;
&lt;p&gt;RDIFramework.NET官方网站：http://www.rdiframework.net/&lt;/p&gt;
&lt;p&gt;RDIFramework.NET官方博客：http://blog.rdiframework.net/&lt;/p&gt;
&lt;p&gt;同时需要说明的，以后的所有技术文章以官方网站为准，欢迎大家收藏！&lt;/p&gt;
&lt;p&gt;RDIFramework.NET框架由专业团队长期打造、一直在更新、一直在升级，请放心使用！&lt;/p&gt;
&lt;p&gt;欢迎关注RDIFramework.net框架官方公众微信（微信号：guosisoft），及时了解最新动态。&lt;/p&gt;
&lt;p&gt;扫描二维码立即关注&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157572/201812/157572-20181221104008106-2118632537.png&quot; alt=&quot;微信号：guosisoft&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 07:01:00 +0000</pubDate>
<dc:creator>yonghu86</dc:creator>
<og:description>1、概述 通过前面章节的学习，我们已经对微信的开发有了基本的掌握与熟悉，基本可以上手做复杂的应用了。本篇我们将详细讲解微信消息管理中普通消息的接收与处理。当普通微信用户向公众账号发消息时，微信服务器将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huyong/p/10659473.html</dc:identifier>
</item>
<item>
<title>springboot+mybatis+dubbo+aop日志第三篇 - Eric.Chen</title>
<link>http://www.cnblogs.com/lc-chenlong/p/10670343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lc-chenlong/p/10670343.html</guid>
<description>&lt;p&gt;AOP称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;模块提供截取拦截应用程序的拦截器，例如，当执行方法时，可以在执行方法之前或之后添加额外的功能.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;一 AOP的基本概念&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;(1)Aspect(切面):通常是一个类，里面可以定义切入点和通知&lt;/p&gt;
&lt;p&gt;(2)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用&lt;/p&gt;
&lt;p&gt;(3)Advice(通知):AOP在特定的切入点上执行的增强处理，有before,after,afterReturning,afterThrowing,around&lt;/p&gt;
&lt;p&gt;(4)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式&lt;/p&gt;
&lt;p&gt;(5)AOP代理：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二 AOP常用注解&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt; @Aspect - 将类标记为包含通知方法的类。&lt;/p&gt;
&lt;p&gt;        @Pointcut - 将函数标记为切入点&lt;/p&gt;
&lt;p&gt;        execution( expression ) - 涵盖应用通知的方法的表达式。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;@Before Advice&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Before&lt;/code&gt;是一种通知类型（前置），可以确保在方法执行之前运行通知。 以下是&lt;code&gt;@Before&lt;/code&gt;通知(&lt;code&gt;advice&lt;/code&gt;)的语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Pointcut(&quot;execution(* com.demo.controller.*.*(..))&quot;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; controllerPoint(){}&lt;br/&gt;@Before(&lt;/span&gt;&quot;controllerPoint()&quot;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; beforeAdvice(){ &lt;br/&gt;System.out.println(&quot;在方法执行之前输出&quot;);&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;@After Advice&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@After是一种通知类型(后置)，可确保在方法执行后运行通知。 以下是@After通知类的语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
@Pointcut(&quot;execution(* com.demo.controller.*.*(..))&quot;)&lt;span&gt;p&lt;br/&gt;rivate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; controllerPoint(){}&lt;br/&gt;@After(&lt;/span&gt;&quot;controllerPoint()&quot;)&lt;p&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterAdvice(){&lt;br/&gt;System.out.println(&quot;方法执行后输出。&quot;);&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;@After Returning Advice&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@AfterReturning是一种通知类型，可确保方法执行成功后运行通知。 以下是@AfterReturning通知的语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@AfterReturning(pointcut=&quot;execution(* com.demo.controller.*.*(..))&quot;, returning=&quot;retVal&quot;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterReturningAdvice(JoinPoint jp, Object retVal){ &lt;br/&gt;System.out.println(&quot;Method Signature: &quot;  + jp.getSignature()); &lt;br/&gt;System.out.println(&quot;Returning:&quot; + retVal.toString() );&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;
&lt;code&gt;ps：returning&lt;/code&gt;&lt;span&gt; - 要返回的变量的名称。&lt;/span&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;@AfterThrowing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@AfterThrowing是一种通知类型，可以确保在方法抛出异常时运行一个通知&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@AfterThrowing(pointcut=&quot;execution(* com.demo.controller.*.*(..))&quot;, throwing= &quot;error&quot;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterThrowingAdvice(JoinPoint jp, Throwable error){ &lt;br/&gt;System.out.println(&quot;Method Signature: &quot;  + jp.getSignature()); &lt;br/&gt;System.out.println(&quot;Exception: &quot;+error); &lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;
ps：&lt;code&gt;throwing&lt;/code&gt;&lt;span&gt; - 返回的异常名称&lt;/span&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;@Around&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@Around是一种环绕通知，通过环绕通知，我们可以在一个方法内完成前置、后置、异常（@AfterThrowing）等通知所实现的功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
@Around(&quot;controllerPoint()&quot;)&lt;p&gt;&lt;span&gt;public&lt;/span&gt; Object aroundAdvice(ProceedingJoinPoint proceedingJoinPoint){ &lt;br/&gt;System.out.println(&quot;方法开始&quot;); &lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法   &lt;br/&gt;&lt;span&gt;  Object result=jp.proceed(args);  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;  System.out.println(&quot;方法结束&quot;);  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;  return result.toString();  &lt;/span&gt; &lt;br/&gt;}&lt;/span&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;三 使用AOP记录每个servie方法执行日志&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.dubbo.demo.service.aop;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.PrintWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.StringWriter;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.ArrayUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.AfterThrowing;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Around;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Aspect;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Pointcut;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.JSON;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.JSONObject;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.ClassClassPath;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.ClassPool;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.CtClass;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.CtMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.Modifier;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.bytecode.CodeAttribute;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.bytecode.LocalVariableAttribute;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.bytecode.MethodInfo;

@Component
@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogAspect {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(LogAspect.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义切点&lt;/span&gt;
    @Pointcut(&quot;execution(public * com.example.dubbo.demo.service.impl..*.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serviceLog(){}
    
    @Around(&lt;/span&gt;&quot;serviceLog()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object logBefore(ProceedingJoinPoint pj) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口请求的开始时间&lt;/span&gt;
        Long startTimeMillis =&lt;span&gt; System.currentTimeMillis();
        JSONObject paramJson &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.printMethodParams(pj,String.valueOf(startTimeMillis));
        logger.info(&lt;/span&gt;&quot;请求前：{}&quot;&lt;span&gt;,paramJson.toString());
        Object retVal &lt;/span&gt;=&lt;span&gt; pj.proceed();
        
        JSONObject returnJson &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONObject();
        returnJson.put(&lt;/span&gt;&quot;class_name&quot;,paramJson.get(&quot;class_name&quot;&lt;span&gt;));
        returnJson.put(&lt;/span&gt;&quot;method_name&quot;,paramJson.get(&quot;method_name&quot;&lt;span&gt;));
        returnJson.put(&lt;/span&gt;&quot;class_name_method&quot;,paramJson.get(&quot;class_name_method&quot;&lt;span&gt;));
        returnJson.put(&lt;/span&gt;&quot;return_name&quot;&lt;span&gt;,retVal);
        Long endTimeMillis &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        returnJson.put(&lt;/span&gt;&quot;endTimeMillis&quot;&lt;span&gt;,endTimeMillis);
        returnJson.put(&lt;/span&gt;&quot;times&quot;,endTimeMillis -&lt;span&gt; startTimeMillis);
        logger.info(&lt;/span&gt;&quot;请求后：&quot;+&lt;span&gt;returnJson.toString());
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retVal;
        
    }
    
     @AfterThrowing(pointcut &lt;/span&gt;= &quot;serviceLog()&quot;, throwing = &quot;e&quot;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;切点在webpointCut()&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleThrowing(JoinPoint joinPoint, Exception e) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
         Long startTimeMillis &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
         JSONObject paramJson &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.printMethodParams(joinPoint,String.valueOf(startTimeMillis));
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取错误详细信息&lt;/span&gt;
         StringWriter sw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringWriter();
         PrintWriter pw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintWriter(sw);
         e.printStackTrace(pw);
         paramJson.put(&lt;/span&gt;&quot;errorMsg&quot;&lt;span&gt;, e.getMessage());
         paramJson.put(&lt;/span&gt;&quot;StackTrace&quot;&lt;span&gt;, sw.toString());
         logger.info(&lt;/span&gt;&quot;请求错误：&quot;+&lt;span&gt;paramJson.toString());
         pw.flush();   
         sw.flush();   
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 打印类method的名称以及参数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; point 切面
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; JSONObject printMethodParams(JoinPoint point,String startTimeMillis){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(point == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONObject();
        }
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Signature 包含了方法名、申明类型以及地址等信息
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        String class_name &lt;/span&gt;=&lt;span&gt; point.getTarget().getClass().getName();
        String method_name &lt;/span&gt;=&lt;span&gt; point.getSignature().getName();
    
        logger.info(&lt;/span&gt;&quot;class_name = {},startTimeMillis:&quot;+&lt;span&gt;startTimeMillis,class_name);
        logger.info(&lt;/span&gt;&quot;method_name = {},startTimeMillis:&quot;+&lt;span&gt;startTimeMillis,method_name);
 
        JSONObject paramJson &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONObject();
        paramJson.put(&lt;/span&gt;&quot;class_name&quot;&lt;span&gt;,class_name);
        paramJson.put(&lt;/span&gt;&quot;method_name&quot;&lt;span&gt;,method_name);
        paramJson.put(&lt;/span&gt;&quot;startTimeMillis&quot;&lt;span&gt;,startTimeMillis);
        paramJson.put(&lt;/span&gt;&quot;class_name_method&quot;, String.format(&quot;%s.%s&quot;&lt;span&gt;, class_name,method_name));
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 获取方法的参数值数组。
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Object[] method_args &lt;/span&gt;=&lt;span&gt; point.getArgs();
 
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取方法参数名称&lt;/span&gt;
            String[] paramNames =&lt;span&gt; getFieldsName(class_name, method_name);
 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印方法的参数名和参数值&lt;/span&gt;
            String param_name =&lt;span&gt; logParam(paramNames,method_args);
            paramJson.put(&lt;/span&gt;&quot;param_name&quot;&lt;span&gt;,JSONObject.parse(param_name));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; paramJson;
    }
 
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用javassist来获取方法参数名称
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; class_name    类名
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; method_name   方法名
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String[] getFieldsName(String class_name, String method_name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; Class.forName(class_name);
        String clazz_name &lt;/span&gt;=&lt;span&gt; clazz.getName();
        ClassPool pool &lt;/span&gt;=&lt;span&gt; ClassPool.getDefault();
        ClassClassPath classPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassClassPath(clazz);
        pool.insertClassPath(classPath);
 
        CtClass ctClass &lt;/span&gt;=&lt;span&gt; pool.get(clazz_name);
        CtMethod ctMethod &lt;/span&gt;=&lt;span&gt; ctClass.getDeclaredMethod(method_name);
        MethodInfo methodInfo &lt;/span&gt;=&lt;span&gt; ctMethod.getMethodInfo();
        CodeAttribute codeAttribute &lt;/span&gt;=&lt;span&gt; methodInfo.getCodeAttribute();
        LocalVariableAttribute attr &lt;/span&gt;=&lt;span&gt; (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(attr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        String[] paramsArgsName &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[ctMethod.getParameterTypes().length];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是静态方法，则第一就是参数
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不是静态方法，则第一个是&quot;this&quot;，然后才是方法的参数
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我接口中没有写public修饰词，导致我的数组少一位参数，所以再往后一位，原本应该是   XX ? 0 : 1&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; pos = Modifier.isStatic(ctMethod.getModifiers()) ? 0 : 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;paramsArgsName.length;i++&lt;span&gt;){
            paramsArgsName[i] &lt;/span&gt;= attr.variableName(i+&lt;span&gt;pos);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; paramsArgsName;
    }
 
 
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断是否为基本类型：包括String
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz clazz
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  true：是;     false：不是
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isPrimite(Class&amp;lt;?&amp;gt;&lt;span&gt; clazz){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clazz.isPrimitive() || clazz == String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }
 
 
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 打印方法参数值  基本类型直接打印，非基本类型需要重写toString方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; paramsArgsName    方法参数名数组
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; paramsArgsValue   方法参数值数组
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String logParam(String[] paramsArgsName,Object[] paramsArgsValue){
        StringBuffer buffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ArrayUtils.isEmpty(paramsArgsName) ||&lt;span&gt; ArrayUtils.isEmpty(paramsArgsValue)){
            buffer.append(&lt;/span&gt;&quot;{\&quot;noargs\&quot;:\&quot;该方法没有参数\&quot;}&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer.toString();
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;paramsArgsName.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数名&lt;/span&gt;
            String name =&lt;span&gt; paramsArgsName[i];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数值&lt;/span&gt;
            Object value =&lt;span&gt; paramsArgsValue[i];
            buffer.append(&lt;/span&gt;&quot;\&quot;&quot;+name+&quot;\&quot;:&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isPrimite(value.getClass())){
                buffer.append(&lt;/span&gt;&quot;\&quot;&quot;+value+&quot;\&quot;,&quot;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                buffer.append(JSON.toJSONString(value)&lt;/span&gt;+&quot;,&quot;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;{&quot;+buffer.toString().substring(0,buffer.toString().length()-1)+&quot;}&quot;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最后需要再 application.properties文件中添加开启aop的配资&lt;/p&gt;
&lt;p&gt; spring.aop.auto=true&lt;/p&gt;


</description>
<pubDate>Mon, 08 Apr 2019 06:36:00 +0000</pubDate>
<dc:creator>Eric.Chen</dc:creator>
<og:description>AOP称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等等。 Spring AOP模块提供截取拦截应用程序的拦截器，例如，当执行方法时，可以在执行方法之前或之后添加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lc-chenlong/p/10670343.html</dc:identifier>
</item>
<item>
<title>前端概念可视化 - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/10583107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/10583107.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;一句老话说的好：一图胜千言。这句话对学前端也适用，有时候，一个demo被一大堆文字有用的多。下面我就给大家总结几个。&lt;strong&gt;由于文中引用的部分项目仅支持http，下面的iframe中如果出现空白，请移步本文的http地址查看&lt;/strong&gt;👉&lt;a href=&quot;https://www.cnblogs.com/imgss/p/10583107.html&quot;&gt;http://www.cnblogs.com/imgss/p/10583107.html&lt;/a&gt;，或者直接点击给出的原文链接。&lt;/p&gt;
&lt;h3 id=&quot;防抖节流&quot;&gt;防抖/节流&lt;/h3&gt;
&lt;p&gt;将鼠标在灰色方块中移动，可以观察正常触发，防抖（debounce）和节流（throttle）后绘制出的图像的区别。&lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;原项目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，防抖的作用是，在若干秒后如果不再有事件（如滚动，mousemove等）发生，就触发处理函数，如果在这期间又发生了新的事件，则重新计时；节流则是每隔若干秒就触发一次，只是将原来的高频率降低了。&lt;/p&gt;

&lt;h3 id=&quot;是怎么计算的&quot;&gt;'=='是怎么计算的&lt;/h3&gt;
&lt;p&gt;下面的demo给出了当使用 &lt;code&gt;==&lt;/code&gt;时，js引擎是如何对两边的值进行隐式转换，最终得出一个true或者false的,&lt;a href=&quot;https://felix-kling.de/js-loose-comparison/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;规则：以 x==y 为例子&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果x和y的类型相同&lt;br/&gt;1.a. 返回 x === y的结果.&lt;/li&gt;
&lt;li&gt;如果x是 null 而且y 是 undefined, 返回 true&lt;/li&gt;
&lt;li&gt;如果 x 是 undefined 而 y 是 null, 返回 true&lt;/li&gt;
&lt;li&gt;如果 x 是 number 而 y 是 string, 将 y 转换成 number 再比较.&lt;/li&gt;
&lt;li&gt;如果 x 是 string 而 y 是 number, 将 x 转换成 number 再比较.&lt;/li&gt;
&lt;li&gt;如果 x 是 布尔值, 将 x 转换成 number 再比较.&lt;/li&gt;
&lt;li&gt;如果 y 是 布尔值, 将 y 转换成 number 再比较.&lt;/li&gt;
&lt;li&gt;如果 x 是 number，string，symbol三种类型之一， typeof y是 object, 将y转换成原始类型再比较.&lt;/li&gt;
&lt;li&gt;如果 y 是 number，string，symbol三种类型之一， typeof x是 object, 将x转换成原始类型再比较.&lt;/li&gt;
&lt;li&gt;返回 false.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ease-inease-outcubic-bezier&quot;&gt;ease-in,ease-out,cubic-bezier&lt;/h3&gt;
&lt;p&gt;无论是css还是js动画库，绕不开的一个概念就是缓动函数。linear,ease-in,ease-out分别会对动画产生什么效果？下面这个&lt;a href=&quot;http://cubic-bezier.com/&quot;&gt;网站&lt;/a&gt;将缓动函数之间的区别可视化。&lt;/p&gt;

&lt;p&gt;GreenSock提供了更复杂的缓动函数及可视化，地址：&lt;code&gt;https://greensock.com/ease-visualizer&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;bezier曲线&quot;&gt;bezier曲线&lt;/h3&gt;
&lt;p&gt;二阶，三阶贝塞尔曲线的区别是什么，控制点的作用是什么？可以把玩一下下面这个demo，给定3个及以上控制点，生成你想要的曲线。&lt;a href=&quot;https://github.com/Aaaaaaaty/Blog/issues/35&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方法也很简单，首先点击3个及以上的点，然后点击 &lt;strong&gt;绘制&lt;/strong&gt; 即可看到生成bezier曲线的动画。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;进阶阅读：&lt;a href=&quot;https://pomax.github.io/BezierInfo-2/&quot;&gt;A Primer on Bézier Curves&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;svg中的path----mhvlzqtcs&quot;&gt;svg中的path -- m,h,v,l,z,q,t,c,s&lt;/h3&gt;
&lt;p&gt;svg &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;里的那些一个字母的命令看着头昏脑涨？M是啥，L又是啥？下面这个项目来拯救你。&lt;a href=&quot;https://jxnblk.com/paths/?d=M6%2048%20L54%2048%20C44%2032%2056%2022%2044%2010%20S8%2010%2012%2016%20V30%20Z&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配合张鑫旭大神&lt;a href=&quot;https://www.zhangxinxu.com/wordpress/2014/06/deep-understand-svg-path-bezier-curves-command/&quot;&gt;这篇文章&lt;/a&gt;食用更佳。&lt;/p&gt;

&lt;h3 id=&quot;函数调用栈&quot;&gt;函数调用栈&lt;/h3&gt;
&lt;p&gt;当js引擎执行一个函数时，函数调用栈是什么？js从主函数开始，如果函数中又有函数被调用，这个函数入栈，调用结束后出栈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201903/1016471-20190324215808821-1831752983.gif&quot; alt=&quot;1_E3zTWtEOiDWw7d0n7Vp-mA.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家还见过哪些有助于理解前端概念的网站呢，欢迎在评论区留言哦🦉&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 06:11:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>if(window.location.href.slice(0,5) === 'https'){ window.location = window.location.href.replace('htt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/10583107.html</dc:identifier>
</item>
<item>
<title>Reflection 反射 - Swagger-Ranger</title>
<link>http://www.cnblogs.com/Swagger-Ranger/p/10669865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Swagger-Ranger/p/10669865.html</guid>
<description>&lt;h3 id=&quot;反射的定义&quot;&gt;反射的定义&lt;/h3&gt;
&lt;p&gt;反射机制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在程序运行时可以加载，探知，使用编译期间完全未知的类&lt;/li&gt;
&lt;li&gt;程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个加载的类，都能够知道这个类的所有属性和方法；同时任意一个对象也都能够调用它的任意一个方法和属性。同时一个类只有一个反射对象，比如多次调用Class.forName得到的也是相同对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;形象的说：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;使用以下反射代码来获取一个类的对象
Class c = Class.forName(&quot;com.company.project.ClassName&quot;);
当加载完成后，堆内存中就产生了一个ClassName类型的对象，通过这个对象我们就可以看到类的结构，这个就时反射&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反射的作用&quot;&gt;反射的作用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;动态加载类、动态获取类的信息（属性、方法、构造器）&lt;/li&gt;
&lt;li&gt;动态构造对象&lt;/li&gt;
&lt;li&gt;动态调用类和对象的任意方法、构造器&lt;/li&gt;
&lt;li&gt;动态调用和处理属性&lt;/li&gt;
&lt;li&gt;获取泛型信息&lt;/li&gt;
&lt;li&gt;处理注解&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;class类&quot;&gt;Class类&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;public final class Class&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Class类的类表示正在运行的Java应用程序中的类和接口。 枚举是一种类，一个注解是一种接口。 每个数组也属于一个反映为类对象的类，该对象由具有相同元素类型和维数的所有数组共享。 原始Java类型（ boolean ， byte ， char ， short ， int ， long ， float和double ），和关键字void也表示为类对象。Class没有公共构造函数。 相反， Class对象由Java虚拟机自动构建，因为加载了类，并且通过调用类加载器中的defineClass方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的说就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class类十分特殊，用来表示java中类型 (class/interface/enum/annotation/primitive type/void)本身。&lt;/li&gt;
&lt;li&gt;Class类的对象包含了某个被加载类的结构。一个被加载的类对应一个 Class对象&lt;/li&gt;
&lt;li&gt;JVM来创建Class对象，当加载器（class loader）的defineClass()被 JVM调用，JVM 便自动产生一个Class 对象&lt;/li&gt;
&lt;li&gt;Class类是Reflection反射的基础，任何要动态加载，运行的类，都必须先获得对于的Class对象&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;class类的对象获取&quot;&gt;Class类的对象获取&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;.getClass()方法&lt;/li&gt;
&lt;li&gt;Class.forName()方法--使用最多&lt;/li&gt;
&lt;li&gt;.class语法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package JavaCore.Reflection;

/*******************************************************************************
 * @Description: 获取Class对象
 * @Aha-eureka:  Class类是Reflection反射的基础，任何要动态加载，运行的类，都必须先获得对于的Class对象
 ******************************************************************************/
public class Reflection_GetClass {

    public static void main( String[] args ) throws ClassNotFoundException {
        String path = &quot;JavaCore.Reflection.User_Demo&quot;;

        //获取Class的几种方式
        {
            //一个类只有一个Class对象
            Class clazz1 = Class.forName(path);
            Class clazz11=Class.forName(path);

            System.out.println(clazz1.hashCode());//相同hashcode
            System.out.println(clazz11.hashCode());//相同hashcode
        }

        {
            User_Demo user_demo = new User_Demo();
            Class clazz2 = user_demo.getClass();

            Class clazz3 = User_Demo.class;

            System.out.println(clazz2 == clazz3);//true
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取基本数据类型的class对象&quot;&gt;获取基本数据类型的Class对象&lt;/h4&gt;
&lt;p&gt;Class类可以直接获取基本数据类型的Class对象,但是在数组中，&lt;strong&gt;多维的数组就是不同的class对象，不同类型的数组也是不同的class对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    int[] arr0 = new int[5];
    int[] arr01 = new int[15];
    long[] arr02 = new long[15];
    int[][] arr1 = new int[5][5];

    System.out.println(arr0.getClass() + &quot;   &quot; + arr0.getClass().hashCode());//class [I   920011586
    System.out.println(arr01.getClass() + &quot;   &quot; + arr01.getClass().hashCode());//class [I   920011586
    System.out.println(arr02.getClass() + &quot;   &quot; + arr02.getClass().hashCode());//class [J   2017354584
    System.out.println(arr1.getClass() + &quot;   &quot; + arr1.getClass().hashCode());//class [[I   2017354584&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;class-api&quot;&gt;Class API&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;20&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;public String getName()&lt;/td&gt;
&lt;td&gt;返回由类对象表示的实体的名称（类，接口，数组类，原始类型或void），作为String&lt;/td&gt;
&lt;td&gt;返回由类对象表示的实体的名称（类，接口，数组类，原始类型或void），作为String&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;public Field getField(String name)&lt;/td&gt;
&lt;td&gt;获取指定属性名的属性&lt;/td&gt;
&lt;td&gt;注意只能获得public属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;public Field[] getFields()&lt;/td&gt;
&lt;td&gt;获取所有的公共方法的属性数组&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;public Field getDeclaredField(String name)&lt;/td&gt;
&lt;td&gt;返回指定的名字的属性包括私有属性&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;public Field[] getDeclaredFields()&lt;/td&gt;
&lt;td&gt;返回所有的属性数组包括私有的&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;同理...Method/Constructor&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;同理...DeclaredMethods/Constructors&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;10&quot;&gt;&lt;td&gt;public Mehod getDeclaredMethod(String name,Class&amp;lt;?&amp;gt;...parameterTypes&lt;/td&gt;
&lt;td&gt;返回指定参数类型的方法，Class&amp;lt;?&amp;gt;...parameterTypes可变参数参入的是对于类型的Class类&lt;/td&gt;
&lt;td&gt;针对方法的多态性（重载）进行针对的获取,即对于方法有传参则必须传入对于的Class对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;public Constructor&lt;/td&gt;
&lt;td&gt;获取指定传参的构造器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package JavaCore.Reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Reflection_Dynamic {

    static Class clazz;
    static{
        String path = &quot;JavaCore.Reflection.User_Demo&quot;;
        try {
            clazz=Class.forName(path);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    public static void useReflection() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
        //这里newInstance实际就是在调用对于类的无参构造器，如果对于的类没有无参构造器则会抛出InstantiationException
        User_Demo demo = (User_Demo) clazz.newInstance();

        //使用特定的构造器新建对象
        Constructor constructor = User_Demo.class.getDeclaredConstructor(String.class, int.class);
        User_Demo demo1 = (User_Demo) constructor.newInstance(&quot;Swagger&quot;, 26);
        System.out.println(demo1);

        /**
         * 使用反射调用普通方法
         * 1.先获取到Class对象,并获取一个新的对象A
         * 2.然后通过Class对象获得方法对象Method
         * 3.使用Method.invoke(Object A，args...)方法调用类的方法
         */
        User_Demo A = (User_Demo) clazz.newInstance();
        Method method = clazz.getDeclaredMethod(&quot;setName&quot;, String.class);
        method.setAccessible(true);
        method.invoke(A, &quot;Swagger1&quot;);
        System.out.println(A);

        /**
         * 通过反射操作属性
         *
         */
        User_Demo fDemo = (User_Demo) clazz.newInstance();
        Field f = clazz.getDeclaredField(&quot;name&quot;);
        f.setAccessible(true);//使用这个setAccessible(true)来设置可以访问私有方法和属性
        f.set(fDemo, &quot;Ranger&quot;);//
        System.out.println(fDemo);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反射操作泛型&quot;&gt;反射操作泛型&lt;/h3&gt;
&lt;p&gt;Java采用泛型擦除的机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据 的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部 擦除。&lt;br/&gt;为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了ParameterizedType， GenericArrayType，TypeVariable 和WildcardType几种类型来代表不能被归一到Class 类中的类型但是又和原始类型齐名的类型&lt;/p&gt;
&lt;h3 id=&quot;反射操作注解&quot;&gt;反射操作注解&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
        try {
            Class clazz = Class.forName(&quot;类的相对路径和类名&quot;);
            
            //获得类的所有有效注解
            Annotation[] annotations=clazz.getAnnotations();
            for (Annotation a : annotations) {
                System.out.println(a);
            }
            //获得类的指定的注解SxtTable就是一个注解
            SxtTable st = (SxtTable) clazz.getAnnotation(SxtTable.class);
            System.out.println(st.value());
            
            //获得类的属性的注解，columnName(),type(),length()就是SxtTable第一的注解方法或者属性，因为注解就是一种特殊的接口，他的属性值就是调用其方法
            Field f = clazz.getDeclaredField(&quot;studentName&quot;);
            SxtField sxtField = f.getAnnotation(SxtField.class);
            System.out.println(sxtField.columnName()+&quot;--&quot;+sxtField.type()+&quot;--&quot;+sxtField.length());
            
            //根据获得的表名、字段的信息，拼出DDL语句，然后，使用JDBC执行这个SQL，在数据库中生成相关的表
            
        } catch (Exception e) {
            e.printStackTrace();
        }
        
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反射的性能问题&quot;&gt;反射的性能问题&lt;/h3&gt;
&lt;p&gt;反射访问相对正常的访问大概要慢30倍&lt;/p&gt;
&lt;h4 id=&quot;setaccessible&quot;&gt;setAccessible&lt;/h4&gt;
&lt;p&gt;setAccessible设为true：取消反射时的对象安全检查，false则进行安全检查；&lt;br/&gt;当禁止安全检查时就能：&lt;br/&gt;1.访问私有属性&lt;br/&gt;2.同时也能提高反射的运行速度&lt;/p&gt;
&lt;p&gt;如果setAccessible(true)禁用安全检查则能将反射访问效率提升4倍,所以当频繁的调用反射时可以禁用安全检查来提升效率&lt;/p&gt;
&lt;p&gt;本博客为Swagger-Ranger的笔记分享，文中源码地址： https://github.com/Swagger-Ranger&lt;br/&gt;欢迎交流指正，如有侵权请联系作者确认删除： liufei32@outlook.com&lt;/p&gt;
</description>
<pubDate>Mon, 08 Apr 2019 05:06:00 +0000</pubDate>
<dc:creator>Swagger-Ranger</dc:creator>
<og:description>Reflection 反射 [TOC] 反射的定义 反射机制： 在程序运行时可以加载，探知，使用编译期间完全未知的类 程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个加载的类，都能够知道这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Swagger-Ranger/p/10669865.html</dc:identifier>
</item>
</channel>
</rss>