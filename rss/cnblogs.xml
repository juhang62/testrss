<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringSecurity权限管理系统实战—七、处理一些问题 - codermy</title>
<link>http://www.cnblogs.com/codermy/p/13516397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codermy/p/13516397.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/codermy/p/13516372.html&quot;&gt;SpringSecurity权限管理系统实战—一、项目简介和开发环境准备&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/codermy/p/13516369.html&quot;&gt;SpringSecurity权限管理系统实战—二、日志、接口文档等实现&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/codermy/p/13516379.html&quot;&gt;SpringSecurity权限管理系统实战—三、主要页面及接口实现&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/codermy/p/13516385.html&quot;&gt;SpringSecurity权限管理系统实战—四、整合SpringSecurity（上)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/codermy/p/13516388.html&quot;&gt;SpringSecurity权限管理系统实战—五、整合SpringSecurity（下)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/codermy/p/13516394.html&quot;&gt;SpringSecurity权限管理系统实战—六、SpringSecurity整合jwt&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/codermy/p/13516397.html&quot;&gt;SpringSecurity权限管理系统实战—七、处理一些问题&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/HYDCS/article/details/107965522&quot;&gt;SpringSecurity权限管理系统实战—八、AOP 记录用户日志、异常日志&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在写完上一篇文章之后，我又研究了很久。最终我发现似乎我们这个项目不太适合用jwt。layui不像vue那样可以通过axios 全局设置token（或许是我因为我菜，不知道怎么设置，如果有小伙伴有好的办法，欢迎留言告诉我）。&lt;br/&gt;这里稍微介绍下前端怎么操作（vue为例），主要就是拿到token以后将其存储在localstorage或者cookies中，再从localstorage或者cookies中拿到token设置全局的请求头，就可以了。&lt;br/&gt;但是前一篇文章关于jwt的内容是没有问题的，正常的使用也是那样的步骤。&lt;/p&gt;
&lt;h2 id=&quot;具体内容&quot;&gt;具体内容&lt;/h2&gt;
&lt;h3 id=&quot;去除jwt&quot;&gt;去除JWT&lt;/h3&gt;
&lt;p&gt;那么既然不打算再用jwt了，就要老老实实的回去用cookies和session。那么我们需要把我们的项目还原成实战五结束时候的样子。&lt;/p&gt;
&lt;p&gt;这里不是很好解释了，就是把与jwt相关的删除就行了，需要修改的地方有MyAuthenticationSuccessHandler，JwtAuthenticationTokenFilter，SpringSecurityConfig三处，删去有关jwt的内容即可。（不多费篇幅）&lt;/p&gt;
&lt;h3 id=&quot;前端提示信息&quot;&gt;前端提示信息&lt;/h3&gt;
&lt;p&gt;我这里修改了一下登录页面，让其能够在登录失败时，给出提示信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html  xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
        &amp;lt;head&amp;gt;
                &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
                &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
                &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/PearAdmin/admin/css/pearForm.css&quot; /&amp;gt;
                &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/PearAdmin/component/layui/css/layui.css&quot; /&amp;gt;
                &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/PearAdmin/admin/css/pearButton.css&quot; /&amp;gt;
                &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/PearAdmin/assets/login.css&quot; /&amp;gt;
        &amp;lt;/head&amp;gt;
        &amp;lt;body background=&quot;PearAdmin/admin/images/background.svg&quot; &amp;gt;
            &amp;lt;form class=&quot;layui-form&quot; method=&quot;get&quot;&amp;gt;
                        &amp;lt;div class=&quot;layui-form-item&quot;&amp;gt;
                                &amp;lt;img class=&quot;logo&quot; src=&quot;PearAdmin/admin/images/logo.png&quot; /&amp;gt;
                                &amp;lt;div class=&quot;title&quot;&amp;gt;M-S-P Admin&amp;lt;/div&amp;gt;
                                &amp;lt;div class=&quot;desc&quot;&amp;gt;
                                        Spring Security 权 限 管 理 系 统 实 战
                                &amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;layui-form-item&quot;&amp;gt;
                                &amp;lt;input id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;用 户 名 : &quot; type=&quot;text&quot; hover class=&quot;layui-input&quot; required lay-verify=&quot;username&quot;/&amp;gt;
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;layui-form-item&quot;&amp;gt;
                                &amp;lt;input id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密 码 : &quot; type=&quot;password&quot;  hover class=&quot;layui-input&quot; required lay-verify=&quot;password&quot;/&amp;gt;
                        &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;layui-form-item&quot;&amp;gt;
                &amp;lt;input id=&quot;captcha&quot; name=&quot;captcha&quot; placeholder=&quot;验 证 码:&quot; type=&quot;text&quot;  hover class=&quot;layui-verify&quot; style=&quot;border: 1px solid #dcdfe6;&quot; required lay-verify=&quot;captcha&quot;&amp;gt;
                &amp;lt;img id=&quot;captchaImg&quot; src=&quot;/captcha&quot; width=&quot;130px&quot; height=&quot;44px&quot; onclick=&quot;this.src=this.src+'?'+Math.random()&quot; title=&quot;点击刷新&quot;/&amp;gt;
            &amp;lt;/div&amp;gt;

                        &amp;lt;div class=&quot;layui-form-item&quot;&amp;gt;
                                &amp;lt;input type=&quot;checkbox&quot; id=&quot;rememberme&quot; name=&quot;rememberme&quot; title=&quot;记住密码&quot; lay-skin=&quot;primary&quot; checked&amp;gt;
                        &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;layui-form-item&quot;&amp;gt;
                                &amp;lt;button style=&quot;background-color: #5FB878!important;&quot; class=&quot;pear-btn pear-btn-primary login&quot; lay-submit lay-filter=&quot;formLogin&quot;&amp;gt;
                                        登 入
                                &amp;lt;/button&amp;gt;
                        &amp;lt;/div&amp;gt;
                &amp;lt;/form&amp;gt;
                &amp;lt;script src=&quot;/PearAdmin/component/layui/layui.js&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
                &amp;lt;script&amp;gt;
                        layui.use(['form', 'element','jquery'], function() {
                                var form = layui.form;
                                var element = layui.element;
                                var $ = layui.jquery;
                                // $(&quot;body&quot;).on(&quot;click&quot;,&quot;.login&quot;,function(obj){
                                //      location.href=&quot;/api/admin&quot;
                                // })
                                form.verify({
                                        username: function(value) {
                                                if (value.length &amp;lt;= 0 ) {
                                                        return '用户名不能为空';
                                                }
                                        },
                                        password: function (value) {
                                                if (value.length &amp;lt;= 0) {
                                                        return '密码不能为空';
                                                }
                                        },
                                        captcha: function (value) {
                                                if (value.length &amp;lt;= 0) {
                                                        return '验证码不能为空';
                                                }
                                                if (value.length !== 4) {
                                                        return '请输入正确格式的验证码';
                                                }
                                        }
                                })
                                form.on('submit(formLogin)', function() {
                                        $.ajax({
                                                url:'/login',
                                                type:'post',
                                                dataType:'text',
                                                data:{
                                                        username:$('#username').val(),
                                                        password:$('#password').val(),
                                                        captcha:$('#captcha').val(),
                                                        rememberme:$('#rememberme').val()
                                                },
                                                success:function(result){
                                                        var restjson = JSON.parse(result)
                                                        if (restjson.success) {
                                                                // layui.data(&quot;token&quot;, {
                                                                //      key: &quot;Authorization&quot;,
                                                                //      value: &quot;Bearer &quot;+ restjson.jwt
                                                                // });
                                                                layer.msg(restjson.msg,{icon:1,time:1000},function () {
                                                                        location.href = &quot;/&quot;;

                                                                });
                                                        }else {
                                                                layer.msg(restjson.msg,{icon:2,time:1000},function () {
                                                                        $(&quot;#captchaImg&quot;).attr(&quot;src&quot;,&quot;/captcha&quot; + &quot;?&quot; + Math.random());
                                                                });
                                                                return false;
                                                        }
                                                }
                                        })
                                        return false;
                                });
                        })
                &amp;lt;/script&amp;gt;
        &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后端也做了登录失败的处理器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author codermy
 * @createTime 2020/8/2
 */
@Component
public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {

    @Override
    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException {
        httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;);//修改编码格式
        httpServletResponse.setContentType(&quot;application/json&quot;);
        httpServletResponse.getWriter().write(JSON.toJSONString(Result.error().message(e.getMessage())));//返回信息
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AuthenticationFailureHandler是一个抽象的异常类，他的常见子类为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;UsernameNotFoundException 用户找不到
BadCredentialsException 坏的凭据
AccountStatusException 用户状态异常它包含如下子类
AccountExpiredException 账户过期
LockedException 账户锁定
DisabledException 账户不可用
CredentialsExpiredException 证书过期
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都是在用户登录时可能会遇到的异常&lt;/p&gt;
&lt;p&gt;修改后完整的SpringSecurityConfig&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author codermy
 * @createTime 2020/7/15
 */
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private UserDetailsServiceImpl userDetailsService;
    @Autowired
    private VerifyCodeFilter verifyCodeFilter;//验证码拦截器
    @Autowired
    MyAuthenticationSuccessHandler authenticationSuccessHandler;//登录成功逻辑
    @Autowired
    private MyAuthenticationFailureHandler authenticationFailureHandler;//登录失败逻辑
    @Autowired
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;//jwt拦截器
    @Autowired
    private RestAuthenticationEntryPoint restAuthenticationEntryPoint;//无权限拦截器
    @Autowired
    private RestfulAccessDeniedHandler accessDeniedHandler;// 无权访问 JSON 格式的数据



    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring()
                .antMatchers(HttpMethod.GET,
                        &quot;/swagger-resources/**&quot;,
                        &quot;/PearAdmin/**&quot;,
                        &quot;/**/*.html&quot;,
                        &quot;/**/*.css&quot;,
                        &quot;/**/*.js&quot;,
                        &quot;/swagger-ui.html&quot;,
                        &quot;/webjars/**&quot;,
                        &quot;/v2/**&quot;);//放行静态资源
    }

    /**
     * anyRequest          |   匹配所有请求路径
     * access              |   SpringEl表达式结果为true时可以访问
     * anonymous           |   匿名可以访问
     * denyAll             |   用户不能访问
     * fullyAuthenticated  |   用户完全认证可以访问（非remember-me下自动登录）
     * hasAnyAuthority     |   如果有参数，参数表示权限，则其中任何一个权限可以访问
     * hasAnyRole          |   如果有参数，参数表示角色，则其中任何一个角色可以访问
     * hasAuthority        |   如果有参数，参数表示权限，则其权限可以访问
     * hasIpAddress        |   如果有参数，参数表示IP地址，如果用户IP和参数匹配，则可以访问
     * hasRole             |   如果有参数，参数表示角色，则其角色可以访问
     * permitAll           |   用户可以任意访问
     * rememberMe          |   允许通过remember-me登录的用户访问
     * authenticated       |   用户登录后可访问
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);
        http.csrf().disable()//关闭csrf
                // .sessionManagement()// 基于token，所以不需要session
                // .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                // .and()
                .httpBasic().authenticationEntryPoint(restAuthenticationEntryPoint)//未登陆时返回 JSON 格式的数据给前端
                .and()
                .authorizeRequests()
                .antMatchers(&quot;/captcha&quot;).permitAll()//任何人都能访问这个请求
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginPage(&quot;/login.html&quot;)//登录页面 不设限访问
                .loginProcessingUrl(&quot;/login&quot;)//拦截的请求
                .successHandler(authenticationSuccessHandler) // 登录成功
                .failureHandler(authenticationFailureHandler) // 登录失败
                .permitAll()
                .and()
                .rememberMe().rememberMeParameter(&quot;rememberme&quot;)
                // 防止iframe 造成跨域
                .and()
                .headers()
                .frameOptions()
                .disable()
                .and();

        // 禁用缓存
        http.headers().cacheControl();

        // 添加JWT拦截器
        // http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        http.exceptionHandling().accessDeniedHandler(accessDeniedHandler); // 无权访问返回JSON 格式的数据
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }

    /**
     * 身份认证接口
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h3&gt;
&lt;h4 id=&quot;一、springsecurity中的usernamenotfoundexception异常无法被正常捕获&quot;&gt;一、Springsecurity中的UsernameNotFoundException异常无法被正常捕获&lt;/h4&gt;
&lt;p&gt;具体的解释可以看&lt;a href=&quot;https://www.cnblogs.com/gcdd/p/12292335.html&quot;&gt;这篇文章&lt;/a&gt;（非常详细，包括解决方案）&lt;/p&gt;
&lt;p&gt;简而言之，就是我抛出了UsernameNotFoundException异常但是最后会被转换为BadCredentialsException异常。我这里不多做介绍了，上面那篇文章说的非常详细。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200803160335401.gif#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何解决也请参照那篇文章。我所使用的是取巧的方法，就是直接抛出BadCredentialsException异常而不是UsernameNotFoundException异常。因为毕竟最后给出的提示信息是模糊的“用户名或密码错误”，而不是具体到哪个错误了。&lt;/p&gt;
&lt;h4 id=&quot;二、无法统一处理filter中抛出的异常&quot;&gt;二、无法统一处理filter中抛出的异常&lt;/h4&gt;
&lt;p&gt;这个问题主要是和验证码的拦截器有关，前端拿不到验证码错误的提示信息。这里我们可以不用拦截器来处理验证码，可以自定义一个login请求来避开这个问题。&lt;/p&gt;
&lt;p&gt;这个问题也是原本的写法问题吧，其实原本需要用抛这个异常，直接向页面输出提示信息就好了。&lt;/p&gt;
&lt;p&gt;我在找处理方法时找到有两种方法供大家参考&lt;/p&gt;
&lt;h2 id=&quot;后叙&quot;&gt;后叙&lt;/h2&gt;
&lt;p&gt;这篇文章有点乱，博主的文笔真的不太行，所以在描述一些问题的时候可能会有点难以理解。如果小伙伴们在学习过程中有什么问题，欢迎大家加我的qq（在我的码云主页有）我们一起探讨学习。&lt;br/&gt;下一篇文章我们实现用户的操作日志和异常日志功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在&lt;a href=&quot;https://gitee.com/witmy/my-springsecurity-plus&quot;&gt;gitee&lt;/a&gt;和&lt;a href=&quot;https://github.com/witmy/my-springsecurity-plus&quot;&gt;github&lt;/a&gt;中可获取源代码，与本系列文章同步更新&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Aug 2020 00:33:00 +0000</pubDate>
<dc:creator>codermy</dc:creator>
<og:description>目录 SpringSecurity权限管理系统实战—一、项目简介和开发环境准备 SpringSecurity权限管理系统实战—二、日志、接口文档等实现 SpringSecurity权限管理系统实战—三</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codermy/p/13516397.html</dc:identifier>
</item>
<item>
<title>.NET Core + K8S + Apollo 玩转配置中心 - 「圣杰」</title>
<link>http://www.cnblogs.com/sheng-jie/p/use-apollo-with-dotnet-on-k8s.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng-jie/p/use-apollo-with-dotnet-on-k8s.html</guid>
<description>&lt;p&gt;本文接将主要来介绍如何基于Helm快速部署Apollo集群至K8S，并与.NET Core应用进行集成，同时介绍下如何平滑迁移配置到Apollo。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;338.5802711024&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-43736dd236959afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如官网所述：Apollo 是携程打造的开源配置中心，&lt;a href=&quot;https://github.com/ctripcorp/apollo&quot;&gt;GitHub&lt;/a&gt;的星星也快点满22K，因此足见它的成熟度和社区活跃度。因此最近在做配置中心选型的时候，经过一番预演，最终敲定Apollo。&lt;/p&gt;
&lt;p&gt;Apollo作为微服务体系中必不可少的基础服务，其架构设计和基本使用我们不得不有所了解。&lt;/p&gt;
&lt;p&gt;因此本文接下来将主要来介绍如何基于Helm快速部署Apollo集群至K8S，并与.NET Core应用进行集成，同时介绍下如何平滑迁移配置到Apollo。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文具有详细的部署步骤，建议动手实操。&lt;br/&gt;部署Chart包和Demo已上传至GitHub：&lt;a href=&quot;https://github.com/sheng-jie/dotnet.on.k8s/tree/master/K8S.NET.Apollo&quot;&gt;K8S.NET.Apollo&lt;/a&gt;，可收藏备用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在部署之前，需要了解Apollo的基础架构，以便在后续部署工作的展开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-f467670ed9cee888.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Apollo 总体设计&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于其的解读，我这里就不再详细展开，但以下几点还是要有所了解，感兴趣的可以直接看官网详细介绍：&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1&quot;&gt;Apollo配置中心设计&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端&lt;/li&gt;
&lt;li&gt;Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）&lt;/li&gt;
&lt;li&gt;Config Service和Admin Service都是多实例、无状态部署，需要通过注册中心进行服务注册和发现&lt;/li&gt;
&lt;li&gt;注册中心默认采用的是Eureka，在K8S中由Service充当&lt;/li&gt;
&lt;li&gt;Apollo客户端通过注册中心获取Config Service服务列表进行配置读取&lt;/li&gt;
&lt;li&gt;Apollo Portal通过注册中心获取Admin Service服务列表进行配置管理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基于上面对Apollo的介绍，其物理架构总结起来就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每一套环境都必须拥有自己独立的Config Service 和 Admin Service 以及独立ConfigDB。&lt;/li&gt;
&lt;li&gt;多套环境可以公用一套Apollo Portal 进行管理，Portal拥有独立PortalDB。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为Apollo 1.7.0版本增加了基于Kubernetes原生服务发现的部署模式，来替换内置的Eureka，所以在整体部署上有很大简化，同时官方也提供了Helm Charts，让Apollo更加易于开箱即用。下面就以部署一套测试环境为例讲解一下Apollo的部署要点。（部署至本机Docker Desktop Local K8S环境）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;环境要求： Kubernetes 1.10+，Helm 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-e92736ebe551b07b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;31-搭建-apollo-configportal-db&quot;&gt;3.1 搭建 Apollo Config&amp;amp;Portal DB&lt;/h2&gt;
&lt;p&gt;从上图的物理架构上来看，首先要部署好Config DB和PortalDB。关于DB的搭建，建议直接使用&lt;code&gt;bitnami/mysql&lt;/code&gt;chart搭建。搭建步骤如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; helm repo add bitnami https://charts.bitnami.com/bitnami
&amp;gt; helm repo list
&amp;gt; helm repo update
&amp;gt; helm search repo bitnami/mysql
NAME            CHART VERSION   APP VERSION     DESCRIPTION
bitnami/mysql   6.14.8          8.0.21          Chart to create a Highly available MySQL cluster
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行helm包的安装，需要自定义配置文件，也就是&lt;code&gt;values.yaml&lt;/code&gt;。我们可以先行下载 mysql chart包。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;之所以选择将chart包下载到本地，是为了确保后续维护能够基于一致的chart包版本。避免因为执行&lt;code&gt;helm repo update&lt;/code&gt;导致chart包版本自动升级，而不自知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; helm pull bitnami/mysql --untar  //下载并解包
mysql
 ├── Chart.yaml
 ├── ci
 │   └── values-production.yaml
 ├── files
 │   └── docker-entrypoint-initdb.d
 │       └── README.md
 ├── README.md
 ├── templates
 │   ├── initialization-configmap.yaml
 │   ├── master-configmap.yaml
 │   ├── master-statefulset.yaml
 │   ├── master-svc.yaml
 │   ├── NOTES.txt
 │   ├── secrets.yaml
 │   ├── serviceaccount.yaml
 │   ├── servicemonitor.yaml
 │   ├── slave-configmap.yaml
 │   ├── slave-statefulset.yaml
 │   ├── slave-svc.yaml
 │   └── _helpers.tpl
 ├── values-production.yaml
 └── values.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据官网&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97&quot;&gt;分布式部署指南&lt;/a&gt;中所示，其提供了DB的初始化脚本用来分别创建&lt;code&gt;ApolloConfigDB&lt;/code&gt;和&lt;code&gt;ApolloPortalDB&lt;/code&gt;。因此可以直接将以上SQL脚本下载到mysql chart的&lt;code&gt;files/docker-entrypoint-initdb.d&lt;/code&gt;目录下，这样在部署mysql实例时就会自动执行脚本创建数据库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; cd mysql/files/docker-entrypoint-initdb.d
&amp;gt; curl https://raw.githubusercontent.com/ctripcorp/apollo/master/scripts/sql/apolloportaldb.sql &amp;gt; apolloportaldb.sql //下载apolloportaldb.sql
&amp;gt; curl https://raw.githubusercontent.com/ctripcorp/apollo/master/scripts/sql/apolloconfigdb.sql &amp;gt; apolloconfigdb.sql 下载apolloconfigdb.sql
&amp;gt; ls

    Directory: C:\Users\Shengjie\k8s\helm\charts\apollo\mysql\files\docker-entrypoint-initdb.d

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---           8/12/2020 11:01 PM          21291 apolloconfigdb.sql
-a---           8/12/2020 10:56 PM          16278 apolloportaldb.sql
-a---            8/9/2020  6:26 PM            242 README.md
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后复制&lt;code&gt;values.yaml&lt;/code&gt;并命名为&lt;code&gt;dev-mysql-values.yaml&lt;/code&gt;。然后修改核心配置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;global.storageClass=hostpath&lt;br/&gt;可通过&lt;code&gt;kubectl get sc&lt;/code&gt;查看集群支持的storageClass，我这边选择默认的hostpath。其创建的pv的默认回收策略为delete，也就意味着卸载mysql，数据直接删除，这点需要注意！！！如果需要保留测试数据，请更新storageClass。&lt;/li&gt;
&lt;li&gt;root.password=root&lt;br/&gt;修改默认root用户的密码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;修改完毕后，执行以下脚本进行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; kubectl create ns db #创建单独db命名空间
&amp;gt; helm install mysql-apollo . -f dev-mysql-values.yaml -n db
NAME: mysql-apollo
LAST DEPLOYED: Sun Aug 16 11:01:18 2020
NAMESPACE: db
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Please be patient while the chart is being deployed

Tip:

  Watch the deployment status using the command: kubectl get pods -w --namespace db

Services:

  echo Master: mysql-apollo.db.svc.cluster.local:3306
  echo Slave:  mysql-apollo-slave.db.svc.cluster.local:3306

Administrator credentials:

  echo Username: root
  echo Password : $(kubectl get secret --namespace db mysql-apollo -o jsonpath=&quot;{.data.mysql-root-password}&quot; | base64 --decode)

To connect to your database:

  1. Run a pod that you can use as a client:

      kubectl run mysql-apollo-client --rm --tty -i --restart='Never' --image  docker.io/bitnami/mysql:8.0.21-debian-10-r17 --namespace db --command -- bash

  2. To connect to master service (read/write):

      mysql -h mysql-apollo.db.svc.cluster.local -uroot -p my_database

  3. To connect to slave service (read-only):

      mysql -h mysql-apollo-slave.db.svc.cluster.local -uroot -p my_database

To upgrade this helm chart:

  1. Obtain the password as described on the 'Administrator credentials' section and set the 'root.password' parameter as shown below:

      ROOT_PASSWORD=$(kubectl get secret --namespace db mysql-apollo -o jsonpath=&quot;{.data.mysql-root-password}&quot; | base64 --decode)
      helm upgrade mysql-apollo bitnami/mysql --set root.password=$ROOT_PASSWORD

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上面提示，验证数据库成功创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; kubectl run mysql-apollo-client --rm --tty -i --restart='Never' --image  docker.io/bitnami/mysql:8.0.21-debian-10-r17 
--namespace db --command -- bash  # 创建mysql-client pod
I have no name!@mysql-apollo-client:/$ mysql -h mysql-apollo.db.svc.cluster.local -uroot -proot    # 连接至master 节点    
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 61
Server version: 8.0.21 Source distribution

Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&amp;gt; show databases; # 查看databases;
+--------------------+
| Database           |
+--------------------+
| ApolloConfigDB     |
| ApolloPortalDB     |
| information_schema |
| my_database        |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
7 rows in set (0.00 sec)

mysql&amp;gt; use ApolloConfigDB; # 切换至ApolloConfigDB；
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&amp;gt; show tables;  # 查看数据表；
+--------------------------+
| Tables_in_ApolloConfigDB |
+--------------------------+
| AccessKey                |
| App                      |
| AppNamespace             |
| Audit                    |
| Cluster                  |
| Commit                   |
| GrayReleaseRule          |
| Instance                 |
| InstanceConfig           |
| Item                     |
| Namespace                |
| NamespaceLock            |
| Release                  |
| ReleaseHistory           |
| ReleaseMessage           |
| ServerConfig             |
+--------------------------+
16 rows in set (0.01 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，确认Apollo ConfigDB和PortalDB搭建成功。&lt;/p&gt;
&lt;h2 id=&quot;32-搭建-apollo-config-service&quot;&gt;3.2 搭建 Apollo Config Service&lt;/h2&gt;
&lt;p&gt;搭建Apollo Service 需要添加携程官方chart仓库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; helm repo add apollo http://ctripcorp.github.io/apollo/charts
&amp;gt; helm search repo apollo
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
apollo/apollo-portal    0.1.0           1.7.0           A Helm chart for Apollo Portal
apollo/apollo-service   0.1.0           1.7.0           A Helm chart for Apollo Config Service and Apol...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上可知，主要包含两个chart，分别用来部署service和portal。下来研究下apollo/apollo-service 这个chart。老规矩，先把chart包下载下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; helm pull apollo/apollo-service --untar
apollo-service
 ├── Chart.yaml
 ├── templates
 │   ├── deployment-adminservice.yaml
 │   ├── deployment-configservice.yaml
 │   ├── NOTES.txt
 │   ├── service-adminservice.yaml
 │   ├── service-configdb.yaml
 │   ├── service-configservice.yaml
 │   └── _helpers.tpl
 └── values.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的树形图来看，主要就是用来部署config service 和 admin service。紧接着，复制一个&lt;code&gt;values.yaml&lt;/code&gt;，命名为&lt;code&gt;dev-apollo-svc-values.yaml&lt;/code&gt;。主要修改以下配置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;configdb.host=mysql-apollo.db&lt;br/&gt;指定configdb的主机，因为是在集群内部，直接使用服务名即可&lt;/li&gt;
&lt;li&gt;configdb.password=root&lt;br/&gt;指定configdb的秘密&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;修改后的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;configdb:
  name: apollo-configdb
  # apolloconfigdb host
  host: &quot;mysql-apollo.db&quot;
  port: 3306
  dbName: ApolloConfigDB
  # apolloconfigdb user name
  userName: &quot;root&quot;
  # apolloconfigdb password
  password: &quot;root&quot;
....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他配置可以暂定不动，紧接着执行以下命令进行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; kubectl create ns apollo # 创建apollo 命名空间
&amp;gt; helm install --dry-run --debug apollo-dev-svc . -f dev-apollo-svc-values.yaml -n apollo # 测试安装，验证模板生成的资源文件是否有误
&amp;gt; helm install apollo-dev-svc . -f dev-apollo-svc-values.yaml -n apollo
NAME: apollo-dev-svc
LAST DEPLOYED: Sun Aug 16 11:17:38 2020
NAMESPACE: apollo
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Get meta service url for current release by running these commands:
  echo http://apollo-dev-svc-apollo-configservice.apollo:8080      

For local test use:
  export POD_NAME=$(kubectl get pods --namespace apollo -l &quot;app=apollo-dev-svc-apollo-configservice&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
  echo http://127.0.0.1:8080
  kubectl --namespace apollo port-forward $POD_NAME 8080:8080
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要记住上面的meta service url：&lt;code&gt;http://apollo-dev-svc-apollo-configservice.apollo:8080&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那如何确认正确部署了呢：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; kubectl get all -n apollo # 查看apollo命名空间下部署的资源
NAME                                                       READY   STATUS    RESTARTS   AGE
pod/apollo-dev-svc-apollo-adminservice-7d4468ff46-gw6h4    1/1     Running   0          3m26s
pod/apollo-dev-svc-apollo-configservice-58d6c44cd4-n4qk9   1/1     Running   0          3m26s

NAME                                          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
service/apollo-dev-svc-apollo-adminservice    ClusterIP   10.99.251.14     &amp;lt;none&amp;gt;        8090/TCP   3m26s
service/apollo-dev-svc-apollo-configservice   ClusterIP   10.108.121.201   &amp;lt;none&amp;gt;        8080/TCP   3m26s

NAME                                                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/apollo-dev-svc-apollo-adminservice    1/1     1            1           3m26s
deployment.apps/apollo-dev-svc-apollo-configservice   1/1     1            1           3m26s

NAME                                                             DESIRED   CURRENT   READY   AGE
replicaset.apps/apollo-dev-svc-apollo-adminservice-7d4468ff46    1         1         1       3m26s
replicaset.apps/apollo-dev-svc-apollo-configservice-58d6c44cd4   1         1         1       3m26s

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上可知暴露了两个服务configservice和adminservice，来尝试将configservice进行端口转发到本地端口来看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; kubectl port-forward service/apollo-dev-svc-apollo-configservice 8080:8080 -n apollo # 转发configservice到本地服务
Forwarding from 127.0.0.1:8080 -&amp;gt; 8080
Forwarding from [::1]:8080 -&amp;gt; 8080
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用浏览器访问 &lt;a href=&quot;http://localhost:8080&quot;&gt;localhost:8080&lt;/a&gt;，可以看到输出&lt;code&gt;[{&quot;appName&quot;:&quot;apollo-configservice&quot;,&quot;instanceId&quot;:&quot;apollo-configservice:http://apollo.shisheng.wang/config-svc&quot;,&quot;homepageUrl&quot;:&quot;http://apollo.shisheng.wang/config-svc&quot;},{&quot;appName&quot;:&quot;apollo-adminservice&quot;,&quot;instanceId&quot;:&quot;apollo-adminservice:http://apollo.shisheng.wang/admin-svc&quot;,&quot;homepageUrl&quot;:&quot;http://apollo.shisheng.wang/admin-svc&quot;}]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;至此说明，Apollo Service 搭建成功。&lt;/p&gt;
&lt;h2 id=&quot;33-搭建-apollo-portal-service&quot;&gt;3.3 搭建 Apollo Portal Service&lt;/h2&gt;
&lt;p&gt;同样，先来下载portal chart包，并研究下目录结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; helm pull apollo/apollo-portal --untar
apollo-portal
 ├── Chart.yaml
 ├── templates
 │   ├── deployment-portal.yaml
 │   ├── ingress-portal.yaml
 │   ├── NOTES.txt
 │   ├── service-portal.yaml
 │   ├── service-portaldb.yaml
 │   └── _helpers.tpl
 └── values.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上可知，portal 相对来说，主要是构建portal服务，并可以通过ingress暴露服务。复制一个&lt;code&gt;values.yaml&lt;/code&gt;，命名为&lt;code&gt;dev-apollo-portal-values.yaml&lt;/code&gt;。主要修改以下配置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;ingress.enabled=true&lt;/code&gt;&lt;br/&gt;启用ingress，并通过注解设置ingress controller，因为portal是个有状态服务，所以要关注Sessiion状态维持。以下主要是针对nginx-ingress-controller的配置，如果使用的其他的ingress-controller请注意更改。（nginx-ingress-controller的安装，这里就不具体展开了，可以简单执行&lt;code&gt;helm install nginx bitnaim/nginx-ingress-controller&lt;/code&gt; 安装就好了。）&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;ingress:
  enabled: true
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/affinity: &quot;cookie&quot;
    nginx.ingress.kubernetes.io/session-cookie-name: &quot;route&quot;
  hosts:
    - host: &quot;apollo.demo.com&quot;
      paths: [&quot;/&quot;]
  tls: []
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;指定配置源 ，主要是envs和metaServers两个配置项：&lt;br/&gt;&lt;code&gt;config.envs=dev&lt;/code&gt;&lt;br/&gt;&lt;code&gt;config.metaServers.dev=http://apollo-dev-svc-apollo-configservice.apollo:8080&lt;/code&gt;（上面部署apollo service输出的apollo service url）&lt;em&gt;如果同时启用开发、测试和生产环境。可以配置为：&lt;code&gt;envs: &quot;dev,uat,prd&quot;&lt;/code&gt;，metaServers 分别指定对应环境的配置即可。&lt;/em&gt;&lt;br/&gt;以下是只启用开发环境的配置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;config:
  # spring profiles to activate
  profiles: &quot;github,auth&quot;
  # specify the env names, e.g. dev,pro
  envs: &quot;dev&quot;
  # specify the meta servers, e.g.
  # dev: http://apollo-configservice-dev:8080
  # pro: http://apollo-configservice-pro:8080
  metaServers: 
    dev: http://apollo-svc-dev-apollo-configservice.apollo:8080
    # dev: http://apollo.shisheng.wang
  # specify the context path, e.g. /apollo
  contextPath: &quot;&quot;
  # extra config files for apollo-portal, e.g. application-ldap.yml
  files: {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;portaldb.host=mysql-apollo.db &amp;amp; portaldb.password=root&lt;br/&gt;指定portaldb的主机和密码&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;portaldb:
  name: apollo-portaldb
  # apolloportaldb host
  host: mysql-apollo.db
  port: 3306
  dbName: ApolloPortalDB
  # apolloportaldb user name
  userName: root
  # apolloportaldb password
  password: root
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他配置可以暂定不动，紧接着执行以下命令进行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; Helm install --dry-run --debug apollo-dev-portal . -f dev-apollo-portal-values.yaml -n apollo # 测试安装，验证模板生成的资源文件是否有误
&amp;gt; Helm install apollo-dev-portal . -f dev-apollo-portal-values.yaml -n apollo
PS C:\Users\Shengjie\k8s\helm\charts\apollo\apollo-portal&amp;gt; Helm install apollo-dev-portal . -f dev-apollo-portal-values.yaml -n apollo
NAME: apollo-dev-portal
LAST DEPLOYED: Sun Aug 16 11:53:18 2020
NAMESPACE: apollo
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Get apollo portal url by running these commands:
  http://apollo.demo.com/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这一步，如果需要本地可以访问，还需要修改本地hosts，添加&lt;code&gt;127.0.0.1 apollo.demo.com&lt;/code&gt;。然后打开你的Browser输入&lt;a href=&quot;http://apollo.demo.com/&quot;&gt;http://apollo.demo.com/&lt;/a&gt;，就可以访问了。默认用户密码是：[apollo/admin]。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-021717d0f5f8392c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;apollo login page&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上部署的是开发环境，但要想开发环境要访问到config service，我们还需要些小动作。这个时候就需要修改apollo service的chart模板，在&lt;code&gt;template&lt;/code&gt;目录增加&lt;code&gt;ingress-configservice.yaml&lt;/code&gt;文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ingress-configservice.yaml
{{- if .Values.configService.ingress.enabled -}}
{{- $fullName := include &quot;apollo.configService.fullName&quot; . -}}
{{- $svcPort := .Values.configService.service.port -}}
{{- if semverCompare &quot;&amp;gt;=1.14-0&quot; .Capabilities.KubeVersion.GitVersion -}}
apiVersion: networking.k8s.io/v1beta1
{{- else -}}
apiVersion: extensions/v1beta1
{{- end }}
kind: Ingress
metadata:
  name: {{ $fullName }}
  labels:
    {{- include &quot;apollo.service.labels&quot; . | nindent 4 }}
  {{- with .Values.configService.ingress.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
{{- if .Values.configService.ingress.tls }}
  tls:
  {{- range .Values.configService.ingress.tls }}
    - hosts:
      {{- range .hosts }}
        - {{ . | quote }}
      {{- end }}
      secretName: {{ .secretName }}
  {{- end }}
{{- end }}
  rules:
  {{- range .Values.configService.ingress.hosts }}
    - host: {{ .host | quote }}
      http:
        paths:
        {{- range .paths }}
          - path: {{ . }}
            backend:
              serviceName: {{ $fullName }}
              servicePort: {{ $svcPort }}
        {{- end }}
  {{- end }}
{{- end }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后修改&lt;code&gt;values.yaml&lt;/code&gt;在&lt;code&gt;configService&lt;/code&gt;节点下增加&lt;code&gt;ingress&lt;/code&gt;配置选项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;configService:
  name: apollo-configservice
  fullNameOverride: &quot;&quot;
  replicaCount: 2
  containerPort: 8080
  image:
    repository: apolloconfig/apollo-configservice
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  service:
    fullNameOverride: &quot;&quot;
    port: 8080
    targetPort: 8080
    type: ClusterIP
  # 以下为新增ingress配置项  
  ingress:
    enabled: false
    annotations: {}
    hosts:
      - host: &quot;&quot;
        paths: []
    tls: []
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再修改上面我们创建的&lt;code&gt;dev-apollo-svc-values.yaml&lt;/code&gt;下的&lt;code&gt;configService&lt;/code&gt;节点，添加对应&lt;code&gt;ingress&lt;/code&gt;和&lt;code&gt;config.configServiceUrlOverride&lt;/code&gt;配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;configService:
  name: apollo-configservice
  fullNameOverride: &quot;&quot;
  replicaCount: 1
  containerPort: 8080
  image:
    repository: apolloconfig/apollo-configservice
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  service:
    fullNameOverride: &quot;&quot;
    port: 8080
    targetPort: 8080
    type: ClusterIP
  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
      nginx.ingress.kubernetes.io/rewrite-target: /$2
    hosts:
      - host: &quot;apollo.demo.com&quot;
        paths: [&quot;/config-svc(/|$)(.*)&quot;]
    tls: []
  liveness:
    initialDelaySeconds: 100
    periodSeconds: 10
  readiness:
    initialDelaySeconds: 30
    periodSeconds: 5
  config:
    # spring profiles to activate
    profiles: &quot;github,kubernetes&quot;
    # override apollo.config-service.url: config service url to be accessed by apollo-client
    configServiceUrlOverride: &quot;http://apollo.demo.com/config-svc&quot;
    # override apollo.admin-service.url: admin service url to be accessed by apollo-portal
    adminServiceUrlOverride: &quot;&quot;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完毕，执行以下命令升级apollo service：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; helm upgrade apollo-service-dev . -f dev-apollo-svc-values.yaml -n apollo
NAME: apollo-service-dev
LAST DEPLOYED: Tue Aug 18 14:20:41 2020
NAMESPACE: apollo
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Get meta service url for current release by running these commands:
  echo http://apollo-service-dev-apollo-configservice.apollo:8080

For local test use:
  export POD_NAME=$(kubectl get pods --namespace apollo -l &quot;app=apollo-service-dev-apollo-configservice&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
  echo http://127.0.0.1:8080
  kubectl --namespace apollo port-forward $POD_NAME 8080:8080
&amp;gt; curl http://apollo.demo.com/config-svc
[{&quot;appName&quot;:&quot;apollo-configservice&quot;,&quot;instanceId&quot;:&quot;apollo-configservice:http://apollo.demo.com/config-svc&quot;,&quot;homepageUrl&quot;:&quot;http://apollo.demo.com/config-svc&quot;},{&quot;appName&quot;:&quot;apollo-adminservice&quot;,&quot;instanceId&quot;:&quot;apollo-adminservice:http://apollo-service-dev-apollo-adminservice.apollo:8090&quot;,&quot;homepageUrl&quot;:&quot;http://apollo-service-dev-apollo-adminservice.apollo:8090&quot;}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的输出可以看到，现在已经可以通过&lt;code&gt;http://apollo.demo.com/config-svc&lt;/code&gt;读取metaServer配置了，后面本地开发环境就可以通过这个链接来读取Apollo的配置。&lt;/p&gt;

&lt;p&gt;这一部分我就快速带过了，执行以下命令创建项目，并引入&lt;code&gt;apollo&lt;/code&gt;和&lt;code&gt;swagger&lt;/code&gt;相关包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; dotnet new webapi -n K8S.NET.Apollo
&amp;gt; cd K8S.NET.Apollo
&amp;gt; dotnet add package Com.Ctrip.Framework.Apollo.Configuration
&amp;gt; dotnet add package Swashbuckle.AspNetCore

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;appsettings.json&lt;/code&gt;增加&lt;code&gt;apollo&lt;/code&gt;配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{    
    &quot;AllowedHosts&quot;: &quot;*&quot;,
    &quot;apollo&quot;: {
        &quot;AppId&quot;: &quot;test&quot;,
        &quot;MetaServer&quot;: &quot;http://apollo.demo.com/config-svc&quot;,
        &quot;Env&quot;: &quot;Dev&quot;
    }    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;Program.cs&lt;/code&gt;，添加Apollo配置源如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
    Host.CreateDefaultBuilder(args)
    .ConfigureAppConfiguration(configBuilder =&amp;gt;
    {
        configBuilder.AddApollo(configBuilder.Build().GetSection(&quot;apollo&quot;))
            .AddDefault()
            .AddNamespace(&quot;TEST1.connectionstrings&quot;, &quot;ConnectionStrings&quot;)
            .AddNamespace(&quot;logging&quot;, ConfigFileFormat.Json)
            ;
    })
        .ConfigureWebHostDefaults(webBuilder =&amp;gt;
        {
            webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;Startup.cs&lt;/code&gt;，添加Swagger集成，方便测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddSwaggerGen(c =&amp;gt;
    {
        c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo { Title = this.GetType().Namespace, Version = &quot;v1&quot; });
    });
}
// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    app.UseSwagger();
    app.UseSwaggerUI(c =&amp;gt;
    {
        c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, $&quot;{this.GetType().Namespace} V1&quot;);
        c.RoutePrefix = string.Empty;
    });

    //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加&lt;code&gt;ApolloController&lt;/code&gt;，增加以下测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace K8S.NET.Apollo.Controllers
{
    [ApiController]
    [Route(&quot;[controller]/[action]&quot;)]
    public class ApolloController : Controller
    {
        private readonly IConfiguration _configuration;
        public ApolloController(IConfiguration configuration)
        {
            _configuration = configuration;
        }

        [HttpGet(&quot;key&quot;)]
        public IActionResult GetLogLevelSection()
        {
            var key = &quot;Logging:LogLevel&quot;;
            var val = _configuration.GetSection(key).Get&amp;lt;LoggingOptions&amp;gt;();
            return Ok($&quot;{key}:{JsonSerializer.Serialize(val)}&quot;);
        }

        [HttpGet(&quot;key&quot;)]
        public IActionResult GetString(string key)
        {
            var val = _configuration.GetValue&amp;lt;string&amp;gt;(key);
            return Ok($&quot;{key}:{val}&quot;);
        }

        [HttpGet(&quot;key&quot;)]
        public IActionResult GetConnectionStrings(string key)
        {
            var val = _configuration.GetConnectionString(key);
            return Ok($&quot;{key}:{val}&quot;);
        }
    }

    public class LoggingOptions : Dictionary&amp;lt;string, string&amp;gt;
    {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登录Apollo Portal，添加test项目，并增加以下配置，并发布。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-26742654e9fa45fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;增加配置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地调试，就能够获取云端配置，另外Apollo同时会同步一份配置到本地目录：&lt;code&gt;c:/opt/data/test/config-cache&lt;/code&gt;。这样就可以保证即使无法建立云端连接，也可以正常加载本地配置。&lt;br/&gt;执行以下命令，进行配置读取和验证：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; curl https://localhost:5001/Apollo/GetLogLevelSection
Logging:LogLevel:{&quot;Default&quot;:&quot;Information&quot;,&quot;Microsoft&quot;:&quot;Warning&quot;,&quot;Microsoft.Hosting.Lifetime&quot;:&quot;Information&quot;}
&amp;gt; curl https://localhost:5001/Apollo/GetString/key?key=name
name:Shengjie
&amp;gt; curl https://localhost:5001/Apollo/GetConnectionStrings/key?key=Default
Default:Server=mu3ne-mysql;port=3306;database=mu3ne0001;user id=root;password=abc123;AllowLoadLocalInfile=true
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;相信采用Apollo的绝大多数都不是一开始就用的，都是再配置逐渐复杂之后，才进行迁移的。我也不例外，之前是用K8S的ConfigMap来做配置管理。下面就来讲下迁移指南，我将其分为两种模式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;偷懒模式&lt;br/&gt;如果想改动最小，就直接将项目配置继续以Json格式维护到Apollo的私有命名空间下。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-cb5f7cdd209df803.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-365c7ec8ea0774fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureAppConfiguration((context, builder) =&amp;gt;
        {
            builder.AddApollo(builder.Build().GetSection(&quot;apollo&quot;))
                .AddDefault()
                .AddNamespace(&quot;appsettings&quot;,ConfigFileFormat.Json);
        })
        .ConfigureWebHostDefaults(webBuilder =&amp;gt;
        {
            webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;强迫症模式&lt;br/&gt;也有人考虑，既然上Apollo，就要用到它的特性，因此对现有配置就要分门别类。哪些是公用的，哪些是私有的。对于公用的就要定义到公共的命名空间下。公共命名空间的配置格式只有Properties格式，因此需要将Json转为Properties。比如针对&lt;code&gt;Logging&lt;/code&gt;配置可以借助网站 &lt;a href=&quot;https://tools.fromdev.com/json-to-property-converter.html&quot;&gt;json2properties converter&lt;/a&gt;进行在线转换。如下所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-145fd931518f0f42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;json2properties&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果真这样做，你就错了，你会发现最终的日志配置不生效。这是因为&lt;code&gt;properties&lt;/code&gt;格式是以&lt;strong&gt;&lt;code&gt;.&lt;/code&gt;&lt;/strong&gt;进行分割，而.NET Core是用&lt;strong&gt;&lt;code&gt;:&lt;/code&gt;&lt;/strong&gt;来识别节点配置， 因此&lt;code&gt;properties&lt;/code&gt;配置按&lt;strong&gt;&lt;code&gt;:&lt;/code&gt;&lt;/strong&gt;分割就好了，如下所示，以下两种配置等效：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-bd49e8486057cdd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;json 与 properties 相互转换&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上，相信若能够动手实操，你将收获匪浅。&lt;/p&gt;
&lt;p&gt;本文Demo和Chart包的完整配置已上传至Github：&lt;a href=&quot;https://github.com/sheng-jie/dotnet.on.k8s/tree/master/K8S.NET.Apollo&quot;&gt;K8S.NET.Apollo&lt;/a&gt;，请按需取用。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 20 Aug 2020 00:32:00 +0000</pubDate>
<dc:creator>「圣杰」</dc:creator>
<og:description>本文接将主要来介绍如何基于Helm快速部署Apollo集群至K8S，并与.NET Core应用进行集成，同时介绍下如何平滑迁移配置到Apollo。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sheng-jie/p/use-apollo-with-dotnet-on-k8s.html</dc:identifier>
</item>
<item>
<title>完全基于 Java 的开源深度学习平台，亚马逊的大佬带你上手 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13530218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13530218.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础的人群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200819164241906-1445538729.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;strong&gt;DJL-Lanking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列。有幸邀请到了亚马逊 + Apache 的工程师：Lanking（ &lt;a href=&quot;https://github.com/lanking520&quot;&gt;https://github.com/lanking520&lt;/a&gt; ），为我们讲解 DJL —— 完全由 Java 构建的深度学习平台。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;许多年以来，一直都没有为 Java 量身定制的深度学习开发平台。用户必须要进行繁杂的项目配置，构建 class 才能最终打造出属于 Java 的深度学习应用。在那之后，依旧要面临着依赖项匹配维护等各种麻烦的问题。为了解决这个这个痛点，亚马逊开源了 Deep Java Library (DJL)&lt;/p&gt;
&lt;blockquote readability=&quot;1.7605633802817&quot;&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/awslabs/djl/&quot;&gt;https://github.com/awslabs/djl/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://djl.ai/&quot;&gt;https://djl.ai/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个完全使用 Java 构建的深度学习平台。DJL 的开发者们也为它量身定制了各种有意思的运行环境，用户只需要少量配置，甚至直接在线就可以在 Java 上运行深度学习应用。&lt;/p&gt;
&lt;p&gt;为了简化 Java 开发人员在深度学习上的痛点，我们推出了 DJL 未来实验室计划：致力于打造一个极简的 Java 运行环境，创造属于 Java 自己的深度学习工具箱。你可以轻松在线使用，或者离线使用它们来构建你的深度学习应用。我们的目标是，将深度学习更好的贴近 Java 开发者。&lt;/p&gt;
&lt;p&gt;下面将介绍能够让你快速上手 DJL 的在线尝试地址或工具。&lt;/p&gt;
&lt;h2 id=&quot;在线编译：block-runner&quot;&gt;在线编译：Block Runner&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200819164250714-85233242.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.5957446808511&quot;&gt;
&lt;p&gt;在线尝试：&lt;a href=&quot;https://djl.ai/website/demo.html&quot;&gt;https://djl.ai/website/demo.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Block Runner 设计十分简单，它可以直接帮助你在线编译 Java 深度学习代码。如上所示，你只需点击 &lt;code&gt;Run&lt;/code&gt; 就可以执行这些代码。我们提供了多种深度学习引擎供你选择。你可以轻松的在上面完成简单的深度学习运算以及推理任务。当你在构建完成之后，直接点击 &lt;code&gt;Get Template&lt;/code&gt; 就可以获得一份直接在本地就能运行的 gradle 项目。所有的环境都已经配置好了，用编辑器打开就可以跑简单举一个例子，如下是使用 Apache MXNet 模型构建的一份图片分类应用代码，你可以直接复制到在线编辑器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import ai.djl.inference.*;
import ai.djl.modality.*;
import ai.djl.modality.cv.*;
import ai.djl.modality.cv.transform.*;
import ai.djl.modality.cv.translator.*;
import ai.djl.repository.zoo.*;
import ai.djl.translate.*;

String modelUrl = &quot;https://alpha-djl-demos.s3.amazonaws.com/model/djl-blockrunner/mxnet_resnet18.zip?model_name=resnet18_v1&quot;;
Criteria&amp;lt;Image, Classifications&amp;gt; criteria = Criteria.builder()
    .setTypes(Image.class, Classifications.class)
    .optModelUrls(modelUrl)
    .optTranslator(ImageClassificationTranslator.builder()
            .addTransform(new Resize(224, 224))
            .addTransform(new ToTensor())
            .optApplySoftmax(true).build())
    .build();
ZooModel&amp;lt;Image, Classifications&amp;gt; model = ModelZoo.loadModel(criteria);
Predictor&amp;lt;Image, Classifications&amp;gt; predictor = model.newPredictor();
String imageURL = &quot;https://raw.githubusercontent.com/awslabs/djl/master/examples/src/test/resources/kitten.jpg&quot;;
Image image = ImageFactory.getInstance().fromUrl(imageURL);
predictor.predict(image);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在运行后，你会获得如下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
    class: &quot;n02123045 tabby, tabby cat&quot;, probability: 0.41073
    class: &quot;n02124075 Egyptian cat&quot;, probability: 0.29393
    class: &quot;n02123159 tiger cat&quot;, probability: 0.19337
    class: &quot;n02123394 Persian cat&quot;, probability: 0.04586
    class: &quot;n02127052 lynx, catamount&quot;, probability: 0.00911
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，你可以直接点击 &lt;code&gt;Get Template&lt;/code&gt; 在本地运行。是不是很简单！现在这个组建支持 Apache MXNet/PyTorch/TensorFlow 三个后端引擎，后续还会增加更多的支持。&lt;/p&gt;
&lt;p&gt;实现层面上，我们使用了 &lt;a href=&quot;https://codemirror.net/&quot;&gt;CodeMirror&lt;/a&gt; 在线编辑器以及 SpringBoot 进行后端托管。想了解更多，欢迎参阅&lt;a href=&quot;https://github.com/aws-samples/djl-demo/tree/master/web-demo/interactive-console#block-runner&quot;&gt;实现代码&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;在线终端工具：jshell&quot;&gt;在线终端工具：JShell&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200819164301494-1431261512.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.3888888888889&quot;&gt;
&lt;p&gt;在线尝试：&lt;a href=&quot;https://djl.ai/website/demo.html#jshell&quot;&gt;https://djl.ai/website/demo.html#jshell&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JShell 是一个 &lt;a href=&quot;https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8&quot;&gt;JShell&lt;/a&gt; 的改版，包含了 DJL 的特性。你可以直接集成已有的 Java 功能和 DJL 的 class 在线使用。我们为 JShell 提前准备了下面的引入:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import ai.djl.ndarray.NDManager;
import ai.djl.ndarray.NDArray;
import ai.djl.ndarray.types.Shape;
import ai.djl.ndarray.index.NDIndex;
NDManager manager = NDManager.newBaseManager();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后端是基于 SpringBoot 的 server 架构，前端使用了 &lt;a href=&quot;https://xtermjs.org/&quot;&gt;xtermjs&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;目前这个命令行支持如下操作:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;backspace&lt;/code&gt;删除输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;-&lt;/code&gt; 和 &lt;code&gt;-&amp;gt;&lt;/code&gt; 移动光标&lt;/li&gt;
&lt;li&gt;复制/粘贴代码功能&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;clear&lt;/code&gt;进行清屏操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过网页中提供的几种简单案例，你可以轻松使用 &lt;a href=&quot;https://javadoc.io/doc/ai.djl/api/latest/ai/djl/ndarray/NDArray.html&quot;&gt;&lt;code&gt;NDArray&lt;/code&gt;&lt;/a&gt; 来完成你所需要的功能。&lt;/p&gt;
&lt;p&gt;想了解我们是如何构建这个 JShell 应用的，请看&lt;a href=&quot;https://github.com/aws-samples/djl-demo/tree/master/web-demo/interactive-console#jshell&quot;&gt;实现代码&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;java-版的-jupyter-notebook&quot;&gt;Java 版的 Jupyter Notebook&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200819164309050-1224533068.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.76271186440678&quot;&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/awslabs/djl/tree/master/jupyter&quot;&gt;https://github.com/awslabs/djl/tree/master/jupyter&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么？Jupyter Notebook？我们难道说的不是 Python？不！100% 纯 Java11。&lt;/p&gt;
&lt;p&gt;通过 &lt;a href=&quot;https://github.com/SpencerPark/IJava&quot;&gt;Spencer Park’s IJava 项目&lt;/a&gt; 启发, 我们将 DJL 集成在了 Jupyter Notebook 里面。不需要繁杂的配置，直接启动就能用。我们准备了一系列使用 Jupyter Notebook 构建的 &lt;a href=&quot;https://github.com/awslabs/djl/tree/master/jupyter&quot;&gt;Java 深度学习训练以及推理应用 Notebook&lt;/a&gt;。想了解更多就&lt;a href=&quot;http://docs.djl.ai/jupyter/index.html#djl-jupyter-notebooks&quot;&gt;点击这里&lt;/a&gt;吧。&lt;/p&gt;
&lt;p&gt;Java 版本的 Notebook 可以基本实现所有 Jupyter 在 Python 上的特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持每个代码块独立运行&lt;/li&gt;
&lt;li&gt;展示一张图片&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;Tablesaw&lt;/code&gt; 展示一个图表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相比于 Python，Java 的 Notebook 可以直接引入 Maven 的库，这样用户就无需担心项目配置等问题。同时这个 Notebook 也支持在 GPU 环境下运行，你可以轻松使用 Notebook 进行深度学习训练任务。&lt;/p&gt;
&lt;p&gt;通过下面几个 Notebook 可以帮助你快速了解 DJL 的用法以及新特性：&lt;/p&gt;
&lt;p&gt;P.S：我们甚至还准备了基于 Java 的深度学习书，现在还处于预览版阶段，敬请期待。&lt;/p&gt;
&lt;h2 id=&quot;关于-djl-以及未来实验室计划&quot;&gt;关于 DJL 以及未来实验室计划&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200819164318195-1687692974.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DJL 还是一个很年轻的框架，2019 年底发布，2020 年 3 月才真正支持了所有主流的深度学习框架 (TensorFlow、PyTorch MXNet)。你可以轻松的使用 DJL 来训练以及部署你的深度学习模型。它也包含了 70 多种来自 GluonCV、HuggingFace、TorchHub 以及 Keras 的预训练模型。&lt;/p&gt;
&lt;p&gt;关于未来实验室：我们仍旧还有很多功能处于开发阶段，需要大量小伙伴去参与并且体验我们的新功能。下面是几个正在进行中的项目：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;D2L - Java：为&lt;a href=&quot;http://zh.d2l.ai/&quot;&gt;《动手学深度学习》&lt;/a&gt; 打造一本 Java 版本的书&lt;/li&gt;
&lt;li&gt;DJL NLP WordEmbedding：为 DJL 提供更多 word embedding 的接口&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200820083332817-1442324648.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎关注 HelloGitHub 公众号&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Aug 2020 00:32:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础的人群 作者：DJL-Lanking HelloGitHub 推出的《讲解开源项目》系列。有幸邀请到了亚马逊 + Apache 的工程师：Lanking（ https://g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13530218.html</dc:identifier>
</item>
<item>
<title>一个@Transaction哪里来这么多坑？ - 程序员DMZ</title>
<link>http://www.cnblogs.com/daimzh/p/13532990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daimzh/p/13532990.html</guid>
<description>&lt;p&gt;介绍了在使用Spring事务中可能碰到的各种问题。例如事务失效、事务回滚异常、读写分离下事务如何处理等&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;250.5&quot;&gt;

&lt;p&gt;在之前的文章中已经对Spring中的事务做了详细的分析了，这篇文章我们来聊一聊平常工作时使用事务可能出现的一些问题（本文主要针对使用&lt;code&gt;@Transactional&lt;/code&gt;进行事务管理的方式进行讨论）以及对应的解决方案&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;事务失效&lt;/li&gt;
&lt;li&gt;事务回滚相关问题&lt;/li&gt;
&lt;li&gt;读写分离跟事务结合使用时的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事务失效我们一般要从两个方面排查问题&lt;/p&gt;
&lt;h2 id=&quot;数据库层面&quot;&gt;数据库层面&lt;/h2&gt;
&lt;p&gt;数据库层面，数据库使用的存储引擎是否支持事务？默认情况下MySQL数据库使用的是Innodb存储引擎（5.5版本之后），它是支持事务的，但是如果你的表特地修改了存储引擎，例如，你通过下面的语句修改了表使用的存储引擎为&lt;code&gt;MyISAM&lt;/code&gt;，而&lt;code&gt;MyISAM&lt;/code&gt;又是不支持事务的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;alter table table_name engine=myisam;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就会出现“事务失效”的问题了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：修改存储引擎为&lt;code&gt;Innodb&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;业务代码层面&quot;&gt;业务代码层面&lt;/h2&gt;
&lt;p&gt;业务层面的代码是否有问题，这就有很多种可能了&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们要使用Spring的申明式事务，那么需要执行事务的Bean是否已经交由了Spring管理？在代码中的体现就是类上是否有&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;Component&lt;/code&gt;等一系列注解&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;将Bean交由Spring进行管理（添加&lt;code&gt;@Service&lt;/code&gt;注解）&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;@Transactional&lt;/code&gt;注解是否被放在了合适的位置。在上篇文章中我们对Spring中事务失效的原理做了详细的分析，其中也分析了Spring内部是如何解析&lt;code&gt;@Transactional&lt;/code&gt;注解的，我们稍微回顾下代码：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200818152357704.png&quot; alt=&quot;image-20200818152357704&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代码位于：&lt;code&gt;AbstractFallbackTransactionAttributeSource#computeTransactionAttribute&lt;/code&gt;中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，默认情况下你无法使用&lt;code&gt;@Transactional&lt;/code&gt;对一个非public的方法进行事务管理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;修改需要事务管理的方法为&lt;code&gt;public&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;出现了自调用。什么是自调用呢？我们看个例子&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class DmzService {
        
        public void saveAB(A a, B b) {
                saveA(a);
                saveB(b);
        }

        @Transactional
        public void saveA(A a) {
                dao.saveA(a);
        }
        
        @Transactional
        public void saveB(B b){
                dao.saveB(a);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面三个方法都在同一个类&lt;code&gt;DmzService&lt;/code&gt;中，其中&lt;code&gt;saveAB&lt;/code&gt;方法中调用了本类中的&lt;code&gt;saveA&lt;/code&gt;跟&lt;code&gt;saveB&lt;/code&gt;方法，这就是自调用。在上面的例子中&lt;code&gt;saveA&lt;/code&gt;跟&lt;code&gt;saveB&lt;/code&gt;上的事务会失效&lt;/p&gt;
&lt;p&gt;那么自调用为什么会导致事务失效呢？我们知道Spring中事务的实现是依赖于&lt;code&gt;AOP&lt;/code&gt;的，当容器在创建&lt;code&gt;dmzService&lt;/code&gt;这个Bean时，发现这个类中存在了被&lt;code&gt;@Transactional&lt;/code&gt;标注的方法（修饰符为public）那么就需要为这个类创建一个代理对象并放入到容器中，创建的代理对象等价于下面这个类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DmzServiceProxy {

    private DmzService dmzService;

    public DmzServiceProxy(DmzService dmzService) {
        this.dmzService = dmzService;
    }

    public void saveAB(A a, B b) {
        dmzService.saveAB(a, b);
    }

    public void saveA(A a) {
        try {
            // 开启事务
            startTransaction();
            dmzService.saveA(a);
        } catch (Exception e) {
            // 出现异常回滚事务
            rollbackTransaction();
        }
        // 提交事务
        commitTransaction();
    }

    public void saveB(B b) {
        try {
            // 开启事务
            startTransaction();
            dmzService.saveB(b);
        } catch (Exception e) {
            // 出现异常回滚事务
            rollbackTransaction();
        }
        // 提交事务
        commitTransaction();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是一段伪代码，通过&lt;code&gt;startTransaction&lt;/code&gt;、&lt;code&gt;rollbackTransaction&lt;/code&gt;、&lt;code&gt;commitTransaction&lt;/code&gt;这三个方法模拟代理类实现的逻辑。因为目标类&lt;code&gt;DmzService&lt;/code&gt;中的&lt;code&gt;saveA&lt;/code&gt;跟&lt;code&gt;saveB&lt;/code&gt;方法上存在&lt;code&gt;@Transactional&lt;/code&gt;注解，所以会对这两个方法进行拦截并嵌入事务管理的逻辑，同时&lt;code&gt;saveAB&lt;/code&gt;方法上没有&lt;code&gt;@Transactional&lt;/code&gt;，相当于代理类直接调用了目标类中的方法。&lt;/p&gt;
&lt;p&gt;我们会发现当通过代理类调用&lt;code&gt;saveAB&lt;/code&gt;时整个方法的调用链如下：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88.png&quot; alt=&quot;事务失效&quot;/&gt;&lt;p&gt;实际上我们在调用&lt;code&gt;saveA&lt;/code&gt;跟&lt;code&gt;saveB&lt;/code&gt;时调用的是目标类中的方法，这种清空下，事务当然会失效。&lt;/p&gt;
&lt;p&gt;常见的自调用导致的事务失效还有一个例子，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class DmzService {
        @Transactional
        public void save(A a, B b) {
                saveB(b);
        }
        
        @Transactional(propagation = Propagation.REQUIRES_NEW)
        public void saveB(B b){
                dao.saveB(a);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们调用&lt;code&gt;save&lt;/code&gt;方法时，我们预期的执行流程是这样的&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%EF%BC%88%E8%87%AA%E8%B0%83%E7%94%A8requires_new%EF%BC%89.png&quot; alt=&quot;事务失效（自调用requires_new）&quot;/&gt;&lt;p&gt;也就是说两个事务之间互不干扰，每个事务都有自己的开启、回滚、提交操作。&lt;/p&gt;
&lt;p&gt;但根据之前的分析我们知道，实际上在调用saveB方法时，是直接调用的目标类中的saveB方法，在saveB方法前后并不会有事务的开启或者提交、回滚等操作，实际的流程是下面这样的&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%EF%BC%88%E8%87%AA%E8%B0%83%E7%94%A8requires_new%EF%BC%89%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;事务失效（自调用requires_new）执行流程&quot;/&gt;&lt;p&gt;由于saveB方法实际上是由dmzService也就是目标类自己调用的，所以在saveB方法的前后并不会执行事务的相关操作。这也是自调用带来问题的根本原因：&lt;strong&gt;自调用时，调用的是目标类中的方法而不是代理类中的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;自己注入自己，然后显示的调用，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class DmzService {
        // 自己注入自己
        @Autowired
        DmzService dmzService;
        
        @Transactional
        public void save(A a, B b) {
                dmzService.saveB(b);
        }

        @Transactional(propagation = Propagation.REQUIRES_NEW)
        public void saveB(B b){
                dao.saveB(a);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方案看起来不是很优雅&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8.5&quot;&gt;
&lt;p&gt;利用&lt;code&gt;AopContext&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class DmzService {

        @Transactional
        public void save(A a, B b) {
                ((DmzService) AopContext.currentProxy()).saveB(b);
        }

        @Transactional(propagation = Propagation.REQUIRES_NEW)
        public void saveB(B b){
                dao.saveB(a);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用上面这种解决方案需要注意的是，需要在配置类上新增一个配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// exposeProxy=true代表将代理类放入到线程上下文中，默认是false
@EnableAspectJAutoProxy(exposeProxy = true)
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;个人比较喜欢的是第二种方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里我们做个来做个小总结&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一图胜千言&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200818193436327.png&quot; alt=&quot;事务失效的原因&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;回滚相关的问题可以被总结为两句话&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;想回滚的时候事务确提交了&lt;/li&gt;
&lt;li&gt;想提交的时候被标记成只能回滚了（rollback only）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先看第一种情况：&lt;strong&gt;想回滚的时候事务确提交了&lt;/strong&gt;。这种情况往往是程序员对Spring中事务的&lt;code&gt;rollbackFor&lt;/code&gt;属性不够了解导致的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Spring默认抛出了未检查&lt;code&gt;unchecked&lt;/code&gt;异常（继承自 &lt;code&gt;RuntimeException&lt;/code&gt; 的异常）或者 &lt;code&gt;Error&lt;/code&gt;才回滚事务；其他异常不会触发回滚事务，已经执行的SQL会提交掉。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 &lt;code&gt;rollbackFor&lt;/code&gt;属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对应代码其实我们上篇文章也分析过了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200818195112983.png&quot; alt=&quot;image-20200818195112983&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以上代码位于：&lt;code&gt;TransactionAspectSupport#completeTransactionAfterThrowing&lt;/code&gt;方法中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;默认情况下，只有出现&lt;code&gt;RuntimeException&lt;/code&gt;或者&lt;code&gt;Error&lt;/code&gt;才会回滚&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean rollbackOn(Throwable ex) {
    return (ex instanceof RuntimeException || ex instanceof Error);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，如果你想在出现了非&lt;code&gt;RuntimeException&lt;/code&gt;或者&lt;code&gt;Error&lt;/code&gt;时也回滚，请指定回滚时的异常，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(rollbackFor = Exception.class)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种情况：&lt;strong&gt;想提交的时候被标记成只能回滚了（rollback only）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对应的异常信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Transaction rolled back because it has been marked as rollback-only
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来看个例子吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class DmzService {

        @Autowired
        IndexService indexService;

        @Transactional
        public void testRollbackOnly() {
                try {
                        indexService.a();
                } catch (ClassNotFoundException e) {
                        System.out.println(&quot;catch&quot;);
                }
        }
}

@Service
public class IndexService {
        @Transactional(rollbackFor = Exception.class)
        public void a() throws ClassNotFoundException{
                // ......
                throw new ClassNotFoundException();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面这个例子中，&lt;code&gt;DmzService&lt;/code&gt;的&lt;code&gt;testRollbackOnly&lt;/code&gt;方法跟&lt;code&gt;IndexService&lt;/code&gt;的&lt;code&gt;a&lt;/code&gt;方法都开启了事务，并且事务的传播级别为&lt;code&gt;required&lt;/code&gt;，所以当我们在&lt;code&gt;testRollbackOnly&lt;/code&gt;中调用&lt;code&gt;IndexService&lt;/code&gt;的&lt;code&gt;a&lt;/code&gt;方法时这两个方法应当是共用的一个事务。按照这种思路，虽然&lt;code&gt;IndexService&lt;/code&gt;的&lt;code&gt;a&lt;/code&gt;方法抛出了异常，但是我们在&lt;code&gt;testRollbackOnly&lt;/code&gt;将异常捕获了，那么这个事务应该是可以正常提交的，为什么会抛出异常呢？&lt;/p&gt;
&lt;p&gt;如果你看过我之前的源码分析的文章应该知道，在处理回滚时有这么一段代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200819141914200.png&quot; alt=&quot;rollBackOnly设置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在提交时又做了下面这个判断（&lt;em&gt;这个方法我删掉了一些不重要的代码&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200819145706703.png&quot; alt=&quot;commit_rollbackOnly&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到当提交时发现事务已经被标记为rollbackOnly后会进入回滚处理中，并且unexpected传入的为true。在处理回滚时又有下面这段代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200819145933651.png&quot; alt=&quot;抛出异常&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后在这里抛出了这个异常。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以上代码均位于&lt;code&gt;AbstractPlatformTransactionManager&lt;/code&gt;中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结起来，&lt;strong&gt;主要的原因就是因为内部事务回滚时将整个大事务做了一个rollbackOnly的标记&lt;/strong&gt;，所以即使我们在外部事务中catch了抛出的异常，整个事务仍然无法正常提交，并且如果你希望正常提交，Spring还会抛出一个异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;这个解决方案要依赖业务而定，你要明确你想要的结果是什么&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内部事务发生异常，外部事务catch异常后，内部事务自行回滚，不影响外部事务&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;将内部事务的传播级别设置为nested/requires_new均可。在我们的例子中就是做如下修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRES_NEW)
@Transactional(rollbackFor = Exception.class,propagation = Propagation.NESTED)
public void a() throws ClassNotFoundException{
// ......
throw new ClassNotFoundException();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;虽然这两者都能得到上面的结果，但是它们之间还是有不同的。当传播级别为&lt;code&gt;requires_new&lt;/code&gt;时，两个事务完全没有联系，各自都有自己的事务管理机制（开启事务、关闭事务、回滚事务）。但是传播级别为&lt;code&gt;nested&lt;/code&gt;时，实际上只存在一个事务，只是在调用a方法时设置了一个保存点，当a方法回滚时，实际上是回滚到保存点上，并且当外部事务提交时，内部事务才会提交，外部事务如果回滚，内部事务会跟着回滚。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;内部事务发生异常时，外部事务catch异常后，内外两个事务都回滚，但是方法不抛出异常&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional
public void testRollbackOnly() {
try {
   indexService.a();
} catch (ClassNotFoundException e) {
   // 加上这句代码
   TransactionInterceptor.currentTransactionStatus().setRollbackOnly();
}
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;通过显示的设置事务的状态为&lt;code&gt;RollbackOnly&lt;/code&gt;。这样当提交事务时会进入下面这段代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200819154323089.png&quot; alt=&quot;显示回滚&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最大的区别在于处理回滚时第二个参数传入的是false,这意味着回滚是回滚是预期之中的，所以在处理完回滚后并不会抛出异常。&lt;/p&gt;

&lt;p&gt;读写分离一般有两种实现方式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置多数据源&lt;/li&gt;
&lt;li&gt;依赖中间件，如&lt;code&gt;MyCat&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果是配置了多数据源的方式实现了读写分离，那么需要注意的是：&lt;strong&gt;如果开启了一个读写事务，那么必须使用写节点&lt;/strong&gt;，&lt;strong&gt;如果是一个只读事务，那么可以使用读节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是依赖于&lt;code&gt;MyCat&lt;/code&gt;等中间件那么需要注意：&lt;strong&gt;只要开启了事务，事务内的SQL都会使用写节点（依赖于具体中间件的实现，也有可能会允许使用读节点，具体策略需要自行跟DB团队确认）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于上面的结论，我们在使用事务时应该更加谨慎，在没有必要开启事务时尽量不要开启。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;一般我们会在配置文件配置某些约定的方法名字前缀开启不同的事务（或者不开启），但现在随着注解事务的流行，好多开发人员（或者架构师）搭建框架的时候在service类上加上了@Transactional注解，导致整个类都是开启事务的，这样严重影响数据库执行的效率，更重要的是开发人员不重视、或者不知道在查询类的方法上面自己加上@Transactional（propagation=Propagation.NOT_SUPPORTED）就会导致，所有的查询方法实际并没有走从库，导致主库压力过大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其次，关于如果没有对只读事务做优化的话（优化意味着将只读事务路由到读节点），那么&lt;code&gt;@Transactional&lt;/code&gt;注解中的&lt;code&gt;readOnly&lt;/code&gt;属性就应该要慎用。我们使用&lt;code&gt;readOnly&lt;/code&gt;的原本目的是为了将事务标记为只读，这样当MySQL服务端检测到是一个只读事务后就可以做优化，少分配一些资源（例如：只读事务不需要回滚，所以不需要分配undo log段）。但是当配置了读写分离后，可能会可能会导致只读事务内所有的SQL都被路由到了主库，读写分离也就失去了意义。&lt;/p&gt;

&lt;p&gt;本文为事务专栏最后一篇啦！这篇文章主要是总结了工作中事务相关的常见问题，想让大家少走点弯路！希望大家可以认真读完哦，有什么问题可以直接在后台私信我或者加我微信！&lt;/p&gt;
&lt;p&gt;这篇文章也是整个Spring系列的最后一篇文章，之后可能会出一篇源码阅读心得，跟大家聊聊如何学习源码。&lt;/p&gt;
&lt;p&gt;另外今年也给自己定了个小目标，就是完成SSM框架源码的阅读。目前来说Spring是完成，接下来就是SpringMVC跟MyBatis。&lt;/p&gt;
&lt;p&gt;在分析MyBatis前，会从JDBC源码出发，然后就是MyBatis对配置的解析、MyBatis执行流程、MyBatis的缓存、MyBatis的事务管理已及MyBatis的插件机制。&lt;/p&gt;
&lt;p&gt;在学习SpringMVC前，会从TomCat出发，先讲清楚TomCat的原理，我们再来看&lt;code&gt;SpringMVC&lt;/code&gt;。整个来说相比于Spring源码，我觉得应该不算特别难。&lt;/p&gt;
&lt;p&gt;希望在这个过程中可以跟大家一起进步！！！&lt;br/&gt;如果本文对你由帮助的话，记得点个赞吧！也欢迎关注我的公众号，微信搜索：程序员DMZ，或者扫描下方二维码，跟着我一起认认真真学Java,踏踏实实做一个coder。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8lRTUlODUlQUMlRTQlQkMlOTclRTUlOEYlQjcuanBn?x-oss-process=image/format,png&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我叫DMZ，一个在学习路上匍匐前行的小菜鸟！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 20 Aug 2020 00:21:00 +0000</pubDate>
<dc:creator>程序员DMZ</dc:creator>
<og:description>介绍了在使用Spring事务中可能碰到的各种问题。例如事务失效、事务回滚异常、读写分离下事务如何处理等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daimzh/p/13532990.html</dc:identifier>
</item>
<item>
<title>明明已经删除了数据，可是表文件大小依然没变 - 以终为始</title>
<link>http://www.cnblogs.com/michael9/p/13532972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/michael9/p/13532972.html</guid>
<description>&lt;p&gt;对于运行很长时间的数据库来说，往往会出现表占用存储空间过大的问题，可是将许多没用的表删除之后，表文件的大小并没有改变，想解决这个问题，就需要了解 InnoDB 如何回收表空间的。&lt;/p&gt;
&lt;p&gt;对于一张表来说，占用空间重要分为两部分，表结构和表数据。通常来说，表结构定义占用的空间很小。所以空间的问题主要和表数据有关。&lt;/p&gt;
&lt;p&gt;在 MySQL 8.0 前，表结构存储在以 .frm 为后缀的文件里。在 8.0，允许将表结构定义在系统数据表中。&lt;/p&gt;
&lt;h2 id=&quot;关于表数据的存放&quot;&gt;关于表数据的存放&lt;/h2&gt;
&lt;p&gt;可以将表数据存在共享表空间，或者单独的文件中，通过 &lt;code&gt;innodb_file_per_table&lt;/code&gt; 来控制。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果为 OFF ，表示存在系统共享表空间中，和数据字典一起&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果为 ON，每个 InnoDB 表结构存储在 .idb 为后缀的文件中&lt;/p&gt;
&lt;p&gt;在 5.6.6 以后，默认值为 ON.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;建议将该参数设置为 ON，这样在不需要时，通过 drop table 命令，系统就会直接删除该文件。&lt;/p&gt;
&lt;p&gt;但在共享表空间中，即使表删掉，空间也不会回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;truncate = drop + create 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据删除流程&quot;&gt;数据删除流程&lt;/h2&gt;
&lt;p&gt;但有时使用 &lt;code&gt;delete&lt;/code&gt; 删除数据时，仅仅删除的是某些行，但这可能就会出现表空间没有被回收的情况。&lt;/p&gt;
&lt;p&gt;我们知道，MySQL InnoDB 中采用了 B+ 树作为存储数据的结构，也就是常说的索引组织表，并且数据时按照页来存储的。&lt;/p&gt;
&lt;p&gt;在删除数据时，会有两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删除数据页中的某些记录&lt;/li&gt;
&lt;li&gt;删除整个数据页的内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如想要删除 R4 这条记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202008/1861307-20200819200040477-1911824236.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;InnoDB 直接将 R4 这条记录标记为删除，称为可复用的位置。如果之后要插入 ID 在 300 到 700 间的记录时，就会复用该位置。由此可见，磁盘文件的大小并不会减少。&lt;/p&gt;
&lt;p&gt;而且记录的复用，只限于符合范围条件的数据。之后要插入 ID 为 800 的记录，R4 的位置就不能被复用了。&lt;/p&gt;
&lt;p&gt;再比如要是删除了整个数据页的内容，假设删除 R3 R4 R5，为 Page A 数据页。&lt;/p&gt;
&lt;p&gt;这时 InnoDB 就会将整个 Page A 标记为删除状态，之后整个数据都可以被复用，没有范围的限制。比如要插入 ID=50 的内容就可以直接复用。&lt;/p&gt;
&lt;p&gt;并且如果两个相邻的数据页利用率都很小，就会把两个页中的数据合到其中一个页上，另一个页标记为可复用。&lt;/p&gt;
&lt;p&gt;综上，无论是数据行的删除还是数据页的删除，都是将其标记为删除的状态，用于复用，所以文件并不会减小。对应到具体的操作就是使用 &lt;code&gt;delete&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;而且，我们还可以发现，对于第一种删除记录的情况，由于复用时会有范围的限制，所以就会出现很多空隙的情况，比如删除 R4，插入的却是 ID=800.&lt;/p&gt;
&lt;h2 id=&quot;插入操作也会造成空隙&quot;&gt;插入操作也会造成空隙&lt;/h2&gt;
&lt;p&gt;在插入数据时，如果数据按照索引递增顺序插入，索引的结构会是紧凑的。但如果是随机插入的，很可能造成索引数据页分裂。&lt;/p&gt;
&lt;p&gt;比如给已满的 Page A 插入数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202008/1861307-20200819200055254-274384333.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于 Page A 满了，所以要申请 Page B，调整 Page A 的过程到 Page B，这也称为页分裂。&lt;/p&gt;
&lt;p&gt;结束后 Page A 就有了空隙。&lt;/p&gt;
&lt;p&gt;另外对于更新操作也是，先删除再插入，也会造成空隙。&lt;/p&gt;
&lt;p&gt;进而对于大量进行增删改的表，都有可能存在空洞。如果把空洞去掉，自然空间就被释放了。&lt;/p&gt;
&lt;h2 id=&quot;使用重建表&quot;&gt;使用重建表&lt;/h2&gt;
&lt;p&gt;为了把表中的空隙去掉，这时就可以采用重新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据依次插入到 B 表中。&lt;/p&gt;
&lt;p&gt;由于是顺序插入，自然 B 表的空隙不存在，数据页的利用率也更高。之后用表 B 代替表 A，好像起到了收缩表 A 空间的作用。&lt;/p&gt;
&lt;p&gt;具体通过:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter table A engine=InnoDB
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 5.5 版本后，该命令和上面提到的流程差不多，而且 MySQL 会自己完成数据，交换表名，删除旧表的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202008/1861307-20200819200134176-1786964998.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这就有一个问题，在 DDL 中，表 A 不能有更新，此时有数据写入表 A 的话，就会造成数据丢失。&lt;/p&gt;
&lt;p&gt;在 5.6 版本后引入了 Online DDL。&lt;/p&gt;
&lt;h2 id=&quot;online-ddl&quot;&gt;Online DDL&lt;/h2&gt;
&lt;p&gt;Online DDL 在其基础上做了如下的更新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202008/1861307-20200819200152555-1810396263.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重建表的过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建立一个临时文件，扫描表 A 主键的所有数据页。&lt;/li&gt;
&lt;li&gt;用生成的数据页生成 B+ 树，存储到临时文件中。&lt;/li&gt;
&lt;li&gt;生成临时文件时，如果有对 A 的操作，将其记录在日志文件中，对应图中 state 2 的状态。&lt;/li&gt;
&lt;li&gt;临时文件生成后，将日志文件应用到临时文件中，得到与 A 表相同的数据文件，对应 state 3 状态。&lt;/li&gt;
&lt;li&gt;用临时文件替换 A 表的数据文件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于 row log 日志文件存在，可以在重建表示，对表 A 进行 DML 操作。&lt;/p&gt;
&lt;p&gt;需要注意的是，在 alter 语句执行前，会先申请 MDL 写锁，但在拷贝数据前会退化成 MDL 读锁，从而支持 DML 操作。&lt;/p&gt;
&lt;p&gt;至于为什么不大 MDL 去掉，是防止其他线程对这个表同时做 DDL 操作。&lt;/p&gt;
&lt;p&gt;对于大表来说，该操作很耗 IO 和 CPU 资源，所以在线上操作时，要控制操作时间。如果为了保证安全，推荐使用 &lt;a href=&quot;https://github.com/github/gh-ost&quot;&gt;gh-ost&lt;/a&gt; 来迁移。&lt;/p&gt;
&lt;h2 id=&quot;online-和-inplace&quot;&gt;Online 和 inplace&lt;/h2&gt;
&lt;p&gt;首先说一下 inplace 和 copy 的区别：&lt;/p&gt;
&lt;p&gt;在 Online DDL 中，表 A 重建后的数据放在 &lt;code&gt;tmp_file&lt;/code&gt; 中，这个临时文件是在 InnoDB 内部创建出来的。整个 DDL 在 InnoDB 内部完成。进而对于 Server 层来说，并没有数据移动到临时表中，是一个 &quot;原地&quot; 操作，所以叫 &quot;inplace&quot; .&lt;/p&gt;
&lt;p&gt;而在之前普通的 DDL 中，创建后的表 A 是在 tmp_table 是 Server 创建的，所以叫 &quot;copy&quot;&lt;/p&gt;
&lt;p&gt;对应到语句其实就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# alter table t engine=InnoDB 默认为下面
alter table t engine=innodb,ALGORITHM=inplace;

# 走的就是 server 拷贝的过程
alter table t engine=innodb,ALGORITHM=copy;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是 inplace 和 Online 并不是对应关系：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DDL 过程是 Online，则一定是 inplace&lt;/li&gt;
&lt;li&gt;如果是 inplace 的 DDL 不应当是 Online，如在 &amp;lt;= 8.0, 添加全文索引和空间索引就属于这种情况。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;拓展&quot;&gt;拓展&lt;/h2&gt;
&lt;p&gt;说一下 optimize，analyze，alter table 三种重建表之间的区别：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;alter table t engine = InnoDB（也就是 recreate）默认的是 Oline DDL 过程。&lt;/li&gt;
&lt;li&gt;analyze table t 不是重建表，仅仅是对表的索引信息做重新统计，没有修改数据，期间加 MDL 读锁。&lt;/li&gt;
&lt;li&gt;optimize table t 等于上两步的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在事务里面使用 alter table 默认会自动提交事务，保持事务一致性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有时，在重建某张表后，空间不仅没有变小，甚至还变大了一点点。这时因为，重建的这张表本身没有空隙，在 DDL 期间，刚好有一些 DML 执行，引入了一些新的空隙。&lt;/p&gt;
&lt;p&gt;而且 InnoDB 不会把整张表填满，每个页留下 1/16 给后续的更新用，所以可能远离是紧凑的，但重建后变成的稍有空隙。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;现在我们知道，在使用 delete 删除数据时，其实对应的数据行并不是真正的删除，InnoDB 仅仅是将其标记成可复用的状态，所以表空间不会变小。&lt;/p&gt;
&lt;p&gt;通常来说，在标记复用空间时分为两种，一种是仅将某些数据页中的位置标记为删除状态，但这样的位置只会在一定范围内使用，会出现空隙的情况。&lt;/p&gt;
&lt;p&gt;另一种是将整个数据页标记成可复用的状态，这样的数据页没有限制，可直接复用。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以采用重建表的方式，其中在 5.6 版本后，创建表已经支持 Online 的操作，但最后是在业务低峰时使用&lt;/p&gt;
</description>
<pubDate>Thu, 20 Aug 2020 00:14:00 +0000</pubDate>
<dc:creator>以终为始</dc:creator>
<og:description>对于运行很长时间的数据库来说，往往会出现表占用存储空间过大的问题，可是将许多没用的表删除之后，表文件的大小并没有改变，想解决这个问题，就需要了解 InnoDB 如何回收表空间的。 对于一张表来说，占用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/michael9/p/13532972.html</dc:identifier>
</item>
<item>
<title>在.NET Core中使用MongoDB明细教程(3)：Skip, Sort, Limit, Projections - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/13525942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/13525942.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202008/1377250-20200818205326644-42430411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;到目前为止，我们已经讨论了创建文档, 检索文档，现在让我们来研究一下文档排序，指定要跳过或限制返回的文档数量，以及如何进行投影。此篇文章中的实例代码摘录自原文，未像前几篇文章一样进行实际代码的验证。&lt;/p&gt;
&lt;blockquote readability=&quot;1.9138755980861&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;/p&gt;
&lt;p&gt;译文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/13525942.html&quot;&gt;https://www.cnblogs.com/yilezhu/p/13525942.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;英文地址：&lt;a href=&quot;https://www.codementor.io/@pmbanugo/working-with-mongodb-in-net-part-3-skip-sort-limit-and-projections-oqfwncyka&quot;&gt;https://www.codementor.io/@pmbanugo/working-with-mongodb-in-net-part-3-skip-sort-limit-and-projections-oqfwncyka&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;limit&quot;&gt;Limit&lt;/h3&gt;
&lt;p&gt;当我们查询一个文档时，我们有时不想返回所有符合过滤条件的文档，而只返回其中的一部分。这就是&lt;code&gt;limit&lt;/code&gt; 方法的具体应用。对于MongoDB，可以通过调用&lt;code&gt;Find&lt;/code&gt;返回的&lt;code&gt;IFindFluent&lt;/code&gt;的&lt;code&gt;limit&lt;/code&gt;方法来限制文档的数量。因此，如果我查询数据库中年龄小于40岁的学生，我会得到以下信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;S/N: 1        Id: 582489339798f091295b9094, FirstName: Gregor, LastName: Felix
S/N: 2   Id: 582489339798f091295b9095, FirstName: Machiko, LastName: Elkberg
S/N: 3   Id: 582489339798f091295b9096, FirstName: Julie, LastName: Sandal
S/N: 4   Id: 583da304f03a84d4d4f4678d, FirstName: Peter, LastName: Cyborg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了让它把结果限制在最多两个学生，我调用了&lt;code&gt;Limit()&lt;/code&gt;方法，并传递值为2的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;int count = 1;
await collection.Find(x =&amp;gt; x.Age &amp;lt; 40)
    .Limit(2)
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;S/N: {count} \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后得到以下输出，它只返回两个文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;S/N: 1,       Id: 582489339798f091295b9094, FirstName: Gregor, LastName: Felix
S/N: 2,          Id: 582489339798f091295b9095, FirstName: Machiko, LastName: Elkberg
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;skip&quot;&gt;Skip&lt;/h3&gt;
&lt;p&gt;如果我们想告诉数据库要跳过多少文档，我们使用&lt;code&gt;fluent&lt;/code&gt;接口中的&lt;code&gt;skip&lt;/code&gt;方法。因此，它类似于我们之前使用的代码，但是告诉数据库返回年龄小于40的所有代码，并跳过第一个。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;int count = 1;
await collection.Find(x =&amp;gt; x.Age &amp;lt; 40)
    .Skip(1)
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;S/N: {count} \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;S/N: 1,       Id: 582489339798f091295b9095, FirstName: Machiko, LastName: Elkberg
S/N: 2,          Id: 582489339798f091295b9096, FirstName: Julie, LastName: Sandal
S/N: 3,          Id: 583da304f03a84d4d4f4678d, FirstName: Peter, LastName: Cyborg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会注意到&lt;code&gt;Gregor Felix&lt;/code&gt; 被跳过了。使用&lt;code&gt;skip&lt;/code&gt;和&lt;code&gt;sort&lt;/code&gt;，我们可以将分页添加到应用程序中。&lt;/p&gt;
&lt;p&gt;假设我们要检索集合中的每个学生，一个页面上最多显示两个学生。我们可以通过如下过程实现：&lt;/p&gt;
&lt;p&gt;我们可以使用以下代码来完成此操作，并将每个页面的结果打印到控制台：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var client = new MongoClient();

var db = client.GetDatabase(&quot;schoool&quot;);

var collection = db.GetCollection&amp;lt;Student&amp;gt;(&quot;students&quot;);

int currentPage = 1, pageSize = 2;

double totalDocuments = await collection.CountAsync(FilterDefinition&amp;lt;Student&amp;gt;.Empty);
var totalPages = Math.Ceiling(totalDocuments / pageSize);

for (int i = 1; i &amp;lt;= totalPages; i++)
{
    Console.WriteLine($&quot;Page {currentPage}&quot;);
    Console.WriteLine();

    int count = 1;
    await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
        .Skip((currentPage - 1) * pageSize)
        .Limit(pageSize)
        .ForEachAsync(
            student =&amp;gt;
            {
                Console.WriteLine($&quot;S/N: {count}, \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}&quot;);
                count++;
            });

    Console.WriteLine();
    currentPage++;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在控制台窗口中得到以下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;Page 1

S/N: 1,          Id: 58469c732adc9f5370e50c9c, FirstName: Gregor, LastName: Felix
S/N: 2,          Id: 58469c732adc9f5370e50c9d, FirstName: Machiko, LastName: Elkberg

Page 2

S/N: 1,          Id: 58469c732adc9f5370e50c9e, FirstName: Julie, LastName: Sandal
S/N: 2,          Id: 58469c732adc9f5370e50c9f, FirstName: Peter, LastName: Cyborg

Page 3

S/N: 1,          Id: 58469c732adc9f5370e50ca0, FirstName: James, LastName: Cyborg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们得到三个页面，因为我们总共有五个记录，每页最多检索两个文档。&lt;/p&gt;
&lt;h3 id=&quot;sort&quot;&gt;Sort&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;fluent&lt;/code&gt;接口的&lt;code&gt;Sort&lt;/code&gt;方法采用&lt;code&gt;SortDefinition&lt;/code&gt;作为参数，它可以从&lt;code&gt;string&lt;/code&gt;或&lt;code&gt;BsonDocument&lt;/code&gt;隐式转换，就像&lt;code&gt;FilterDefinition&lt;/code&gt;一样。因此，如果我们想使用字符串作为排序定义，按姓氏升序排序，那么它将是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
    .Skip((currentPage - 1) * pageSize)
    .Limit(pageSize)
    .Sort(&quot;{LastName: 1}&quot;)
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;S/N: {count}, \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}, Age: {student.Age}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在字符串中，我们有&lt;code&gt;{LastName:1}&lt;/code&gt;，其中1告诉它升序排序，而-1告诉它按降序排序。如果我们使用前面更新的代码运行应用程序，它会在第一页返回James和Peter作为结果，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page 1

S/N: 1,          Id: 58469c732adc9f5370e50ca0, FirstName: James, LastName: Cyborg, Age: 39
S/N: 2,          Id: 58469c732adc9f5370e50c9f, FirstName: Peter, LastName: Cyborg, Age: 39

Page 2

S/N: 1,          Id: 58469c732adc9f5370e50c9d, FirstName: Machiko, LastName: Elkberg, Age: 23
S/N: 2,          Id: 58469c732adc9f5370e50c9c, FirstName: Gregor, LastName: Felix, Age: 23

Page 3

S/N: 1,          Id: 58469c732adc9f5370e50c9e, FirstName: Julie, LastName: Sandal, Age: 25
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们希望使用&lt;code&gt;BsonDocument&lt;/code&gt;将姓氏按降序排列，则这将是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
    .Skip((currentPage - 1) * pageSize)
    .Limit(pageSize)
    .Sort(new BsonDocument(&quot;LastName&quot;, -1))
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;S/N: {count}, \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}, Age: {student.Age}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给出了与之前结果相反的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page 1

S/N: 1,          Id: 58469c732adc9f5370e50c9e, FirstName: Julie, LastName: Sandal, Age: 25
S/N: 2,          Id: 58469c732adc9f5370e50c9c, FirstName: Gregor, LastName: Felix, Age: 23

Page 2

S/N: 1,          Id: 58469c732adc9f5370e50c9d, FirstName: Machiko, LastName: Elkberg, Age: 23
S/N: 2,          Id: 58469c732adc9f5370e50ca0, FirstName: James, LastName: Cyborg, Age: 39

Page 3

S/N: 1,          Id: 58469c732adc9f5370e50c9f, FirstName: Peter, LastName: Cyborg, Age: 39
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以使用&lt;code&gt;SortDefinitionBuilder&lt;/code&gt;。因此，我们可以使用构建器帮助方法更新代码以创建一个排序定义，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
    .Skip((currentPage - 1) * pageSize)
    .Limit(pageSize)
    .Sort(Builders&amp;lt;Student&amp;gt;.Sort.Descending(&quot;LastName&quot;))
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;S/N: {count}, \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}, Age: {student.Age}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们仍然可以得到相同的结果，我们还可以组合不同字段上的升序和降序列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
    .Skip((currentPage - 1) * pageSize)
    .Limit(pageSize)
    .Sort(Builders&amp;lt;Student&amp;gt;.Sort.Descending(&quot;LastName&quot;).Ascending(&quot;FirstName&quot;))
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;S/N: {count}, \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}, Age: {student.Age}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或使用强类型对象时，使用表达式树：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
    .Skip((currentPage - 1) * pageSize)
    .Limit(pageSize)
    .Sort(Builders&amp;lt;Student&amp;gt;.Sort.Descending(x =&amp;gt; x.LastName).Ascending(x =&amp;gt; x.FirstName))
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;S/N: {count}, \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}, Age: {student.Age}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以使用表达式树来指定对&lt;code&gt;SortBy&lt;/code&gt;, &lt;code&gt;SortByDescending&lt;/code&gt;, &lt;code&gt;ThenBy&lt;/code&gt;和&lt;code&gt;ThenByDescending&lt;/code&gt;FLUENT接口的方法。按照前面的示例，这将被定义为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
    .Skip((currentPage - 1) * pageSize)
    .Limit(pageSize)
    .SortByDescending(x =&amp;gt; x.LastName)
    .ThenBy(x =&amp;gt; x.Age)
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;S/N: {count}, \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}, Age: {student.Age}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大多数情况下，我们将使用强类型对象，因为使用表达式树构建查询要容易得多。&lt;/p&gt;
&lt;h3 id=&quot;projection投影&quot;&gt;Projection投影&lt;/h3&gt;
&lt;p&gt;我们也可以使用fluent接口的&lt;code&gt;Project&lt;/code&gt;方法进行投影。我们指定一个类似于排序和过滤的投影。&lt;/p&gt;
&lt;p&gt;使用表达式树或投影定义会导致稍微不同的行为。不同之处之一是，在使用投影定义语法时，必须明确地告诉它排除&lt;code&gt;_id&lt;/code&gt;字段，否则，它会将其作为结果集的一部分返回。让我们更新代码，只返回&lt;code&gt;FirstName&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
    .Skip((currentPage - 1) * pageSize)
    .Limit(pageSize)
    .SortByDescending(x =&amp;gt; x.LastName)
    .ThenBy(x =&amp;gt; x.Age)
    .Project(&quot;{FirstName: 1}&quot;)
    .ForEachAsync(
        student =&amp;gt;
        {
            Debug.WriteLine($&quot;S/N: {count}, \t Id: {student.Id}, FirstName: {student.FirstName}, LastName: {student.LastName}, Age: {student.Age}&quot;);
            count++;
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用更新的代码，我们的应用程序无法编译。给我们带来了另一个区别：通过投影定义，它隐式地将文档类型从&lt;code&gt;Student&lt;/code&gt;转换为&lt;code&gt;bsondocument&lt;/code&gt;，因此我们得到的是一个fluent对象，其结果将是一个&lt;code&gt;BsonDocument&lt;/code&gt;（即使我们使用的是Student类型）。如果我们想和Student一起工作，我们必须指出我们仍然希望将类型保留为&lt;code&gt;Student&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;.Project&amp;lt;Student&amp;gt;(&quot;{FirstName: 1}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，通过将&lt;code&gt;Student&lt;/code&gt;设置为方法的类型来更新我们的代码，将得到以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page 1

S/N: 1,          Id: 58469c732adc9f5370e50c9e, FirstName: Julie, LastName: , Age: 0
S/N: 2,          Id: 58469c732adc9f5370e50c9c, FirstName: Gregor, LastName: , Age: 0

Page 2

S/N: 1,          Id: 58469c732adc9f5370e50c9d, FirstName: Machiko, LastName: , Age: 0
S/N: 2,          Id: 58469c732adc9f5370e50ca0, FirstName: James, LastName: , Age: 0

Page 3

S/N: 1,          Id: 58469c732adc9f5370e50c9f, FirstName: Peter, LastName: , Age: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以看到，虽然我们只需要&lt;code&gt;FirstName&lt;/code&gt;，但是&lt;code&gt;FirstName&lt;/code&gt;和&lt;code&gt;Id&lt;/code&gt;被返回，而其他的则保持默认值。为了解决这个问题，我们显式地告诉它排除Id字段，并对投影定义进行以下更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;.Project&amp;lt;Student&amp;gt;(&quot;{FirstName: 1, _id: 0}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行它，我们只返回&lt;code&gt;FirstName&lt;/code&gt;，而其他值保持默认值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page 1

S/N: 1,          Id: 000000000000000000000000, FirstName: Julie, LastName: , Age: 0
S/N: 2,          Id: 000000000000000000000000, FirstName: Gregor, LastName: , Age: 0

Page 2

S/N: 1,          Id: 000000000000000000000000, FirstName: Machiko, LastName: , Age: 0
S/N: 2,          Id: 000000000000000000000000, FirstName: James, LastName: , Age: 0

Page 3

S/N: 1,          Id: 000000000000000000000000, FirstName: Peter, LastName: , Age: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以使用投影生成器。&lt;code&gt;.Project&amp;lt;Student&amp;gt;(Builders&amp;lt;Student&amp;gt;.Projection.Include(x =&amp;gt; x.FirstName).Exclude(x =&amp;gt; x.Id))&lt;/code&gt;这与使用定义生成器进行排序和筛选类似。我们也可以使用表达式树进行投影，然后将其投影到不同的结果。以下代码将只返回first 和last name，并将其映射到匿名类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;int count = 1;
await collection.Find(FilterDefinition&amp;lt;Student&amp;gt;.Empty)
    .Project(x =&amp;gt; new {x.FirstName, x.LastName})
    .ForEachAsync(
        student =&amp;gt;
        {
            Console.WriteLine($&quot;{count}. \t FirstName: {student.FirstName} - LastName {student.LastName}&quot;);
            count++;
        });

Console.WriteLine();
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1.    FirstName: Gregor - LastName Felix
2.       FirstName: Machiko - LastName Elkberg
3.       FirstName: Julie - LastName Sandal
4.       FirstName: Peter - LastName Cyborg
5.       FirstName: James - LastName Cyborg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可能已经注意到，我们并没有显式地指明要排除Id，而是与另一种方式不同，这是因为在强类型表达式树中，它同意只返回您指定的那些字段，而排除其他字段。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文带着你一起研究了一下文档的排序，指定要跳过或限制返回的文档数量，以及如何进行投影。此篇文章中的实例代码摘录自原文，未像前几篇文章一样进行实际代码的验证。希望对你有所帮助。&lt;/p&gt;
</description>
<pubDate>Thu, 20 Aug 2020 00:03:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>到目前为止，我们已经讨论了创建文档, 检索文档，现在让我们来研究一下文档排序，指定要跳过或限制返回的文档数量，以及如何进行投影。此篇文章中的实例代码摘录自原文，未像前几篇文章一样进行实际代码的验证。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/13525942.html</dc:identifier>
</item>
<item>
<title>精讲响应式webclient第1篇-响应式非阻塞IO与基础用法 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13532958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13532958.html</guid>
<description>&lt;p&gt;笔者在之前已经写了一系列的关于RestTemplate的文章，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RestTemplate&lt;/code&gt;作为spring-web项目的一部分，在Spring 3.0版本开始被引入。根据Spring官方文档及源码中的介绍，RestTemplate在将来的版本中它可能会被弃用， 作为替代，Spring官方已在Spring 5中引入了WebClient作为非阻塞式Reactive HTTP客户端。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200820075830997-1910618140.png&quot; alt=&quot;RestTemplate在将来的版本中它可能会被弃用&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、什么是响应式非阻塞io&quot;&gt;一、什么是响应式非阻塞IO&lt;/h2&gt;
&lt;p&gt;在开始为大家介绍webClient之前有必要为大家介绍一下响应式非阻塞IO与传统IO之前的区别。我们先留下一个问题：&lt;strong&gt;webClient发送与接收单个HTTP请求比RestTemplate更快么？答案是否定的。&lt;/strong&gt; 看到这里有的同学已经蒙了，既然webClient没有更快，那官方为什么还推荐使用它？听我往下讲。&lt;/p&gt;
&lt;h3 id=&quot;11传统阻塞式io模型&quot;&gt;1.1.传统阻塞式IO模型&lt;/h3&gt;
&lt;p&gt;笔者用相对通俗的话为大家说明一下阻塞IO与非阻塞IO之间的区别。我们以软件开发团队的工作方式来做一个比喻。作为软件开发人员，我们肯定知道软件开发的基本流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目立项与可行性研究&lt;/li&gt;
&lt;li&gt;需求分析与设计&lt;/li&gt;
&lt;li&gt;代码开发&lt;/li&gt;
&lt;li&gt;迭代测试&lt;/li&gt;
&lt;li&gt;上线及配置管理、运维&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200820075831267-976890432.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在以Spring MVC或者struct为代表的框架都是基于sevlet的，其底层IO模型是阻塞IO模型。这种模型就好像你是公司的一个开发人员，上面的所有的5项工作全都由你一个人完成。如果公司有10个人，最多就只能&lt;strong&gt;同时进行&lt;/strong&gt;10个需求。客户需求增多了也没有办法，只能让他们等着。如下图：一个请求占用一个线程，当线程池内的线程都被占用后新来的请求就只能等待。&lt;/p&gt;
&lt;h3 id=&quot;12响应式io模型&quot;&gt;1.2.响应式IO模型&lt;/h3&gt;
&lt;p&gt;spring 社区为了解决Spring MVC的阻塞模型在高并发场景下的性能瓶颈的问题，推出了Spring WebFlux，WebFlux底层实现是久经考验的netty非阻塞IO通信框架。该框架的请求处理与线程交互关系图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200820075831890-443121737.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;boosGroup用于Accetpt连接建立事件并分发请求， workerGroup用于处理I/O读写事件。netty我就不细说了，还是用通俗的方式给大家讲一下：如果通俗的将上图中的各个任务池、线程池的组合比做一个软件开发公司，那么:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目立项及可研，由公司项目经理及顾问来完成&lt;/li&gt;
&lt;li&gt;需求分析与设计，由产品经理和架构师来完成&lt;/li&gt;
&lt;li&gt;代码研发，由项目经理带领开发人员来完成&lt;/li&gt;
&lt;li&gt;迭代测试，由测试团队来完成&lt;/li&gt;
&lt;li&gt;上线及配置管理、运维，可能由专门的devops团队来完成&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样一个公司内的所有人完成分工，就能在有限的资源的情况下,去接触更多的客户，谈更多的需求，合理的分配人力资源，达到并发处理能力最大化的极限水平。相比于一个员工从头到位的负责一个项目，它的组织性更强，分工更明确，合理的利用空闲资源，专业的人最专业的事。&lt;br/&gt;这种人力资源的合理利用及组织方式和非阻塞IO模型有异曲同工之处，通过合理的将请求处理线程及任务进行分类，合理的利用系统的内存、CPU资源，达到单位时间内处理能力的最大化就是异步非阻塞IO的核心用意！ 回到上文给大家留下的问题，webClient处理单个HTTP请求的响应时长并不比RestTemplate更快，但是它处理并发的能力更强。&lt;strong&gt;所以响应式非阻塞IO模型的核心意义在于：提高了单位时间内有限资源下的服务请求的并发处理能力，而不是缩短了单个服务请求的响应时长。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、webclient-的优势&quot;&gt;二、WebClient 的优势&lt;/h2&gt;
&lt;p&gt;上文为大家介绍完IO模型之后，我想大家已经可以明白了。与RestTemplate相比，WebClient优势如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非阻塞响应式IO，单位时间内有限资源下支持更高的并发量&lt;/li&gt;
&lt;li&gt;支持使用Java 8 lambda表达式函数&lt;/li&gt;
&lt;li&gt;同时支持同步、异步与Streaming流式传输场景&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、项目引入webclient&quot;&gt;三、项目引入WebClient&lt;/h2&gt;
&lt;p&gt;使用WebClient需要引入如下的Jar（可以在包含&lt;code&gt;spring-boot-starter-web&lt;/code&gt;的Spring Boot项目中引入）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题又来了，熟悉Spring 开发的朋友应该都知道。spring-boot-starter-webflux和spring-boot-starter-web代表的是两套技术栈&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-starter-web可以实现目前比较成熟的基于servlet技术栈的Spring Boot应用&lt;/li&gt;
&lt;li&gt;spring-boot-starter-webflux可以实现的是底层基于netty的响应式编程的技术栈的Spring Boot应用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二者可以共存么？答案是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作为服务端实现Spring Boot应用而言，二者在应用角度当然是不能共存的。截止20200820我写稿的时间，如果在一个项目里面将二者都引入了，开发服务端应用其实使用的还是spring-boot-starter-web的基于servlet的技术栈。&lt;/li&gt;
&lt;li&gt;作为HTTP客户端而言，如果我们只是要使用WebClient。无论怎样，引入&lt;code&gt;spring-boot-starter-webflux&lt;/code&gt;就对了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、webclient-实例创建与基础用法&quot;&gt;四、WebClient 实例创建与基础用法&lt;/h2&gt;
&lt;p&gt;创建WebClient有如下三种方式，我们来一一为大家介绍。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WebClient.create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WebClient.create(String baseUrl)&lt;/code&gt;：指定了baseUrl，使用该客户端发送请求都基于baseUrl&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WebClient.builder()&lt;/code&gt;返回一个WebClient.Builder，该对象可以做链式调用，传递更多的参数。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7.6214511041009&quot;&gt;
&lt;p&gt;为了方便后续开发测试，首先介绍一个网站给大家。&lt;a href=&quot;http://jsonplaceholder.typicode.com/&quot;&gt;JSONPlaceholder&lt;/a&gt;是一个提供免费的在线REST API的网站，我们在开发时可以使用它提供的url地址测试下网络请求以及请求参数。或者当我们程序需要获取一些模拟数据、模拟图片时也可以使用它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;41-webclientcreate&quot;&gt;4.1. &lt;code&gt;WebClient.create()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;创建WebClient发送GET请求，接收String类型单个Mono对象（Mono英文：单声道、单体）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SimpleTest {

  @Test
  void testSimple()  {
    WebClient webClient = WebClient.create();

    Mono&amp;lt;String&amp;gt; mono = webClient
            .get() // 发送GET 请求
            .uri(&quot;http://jsonplaceholder.typicode.com/posts/1&quot;)  // 请求路径
            .retrieve()    // 获取响应结果
            .bodyToMono(String.class); //响应数据类型转换

    System.out.println(&quot;=====&quot; + mono.block());  
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mono.block()方法仍然是阻塞式的数据响应接收方式，响应式的编程方法我们后面文章会为大家介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200820075832364-35259193.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;42webclientcreatestring-baseurl&quot;&gt;4.2.&lt;code&gt;WebClient.create(String baseUrl)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;上面使用create()无参方法，在指定请求uri时每次都要指定完整的HTTP服务路径，如&quot;&lt;a href=&quot;http://jsonplaceholder.typicode.com/posts/1&quot;&gt;http://jsonplaceholder.typicode.com/posts/1&lt;/a&gt;&quot;。使用&lt;code&gt;WebClient.create(String baseUrl)&lt;/code&gt;可以统一指定一个baseUrl，这样请求指定请求uri时，可以省略baseUrl部分，如&quot;/posts/1&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private WebClient webClient = WebClient.create(&quot;http://jsonplaceholder.typicode.com&quot;);

@Test
void testBaseUrl(){

  Mono&amp;lt;String&amp;gt; mono = webClient
          .get()
          .uri(&quot;/posts/1&quot;)  // 请求路径,注意省略了baseurl部分
          .retrieve()
          .bodyToMono(String.class);

  System.out.println(&quot;=====&quot; + mono.block());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码请求结果，和4.1结果是一样的&lt;/p&gt;
&lt;h3 id=&quot;43webclientbuilder&quot;&gt;4.3.&lt;code&gt;WebClient.builder()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;使用builder()创建WebClient对象，可以一次性传递的参数内容就更加丰富了。cookies、headers等信息都可以使用builder来传递。&lt;br/&gt;场景：比如你请求的服务端使用JWT token，每次请求都需要传递token。如果每次请求都单独去创建一个WebClient，然后指定Token，那就麻烦了。我们可以使用builder在WebClient实例化的时候，统一设置Token。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private WebClient webClient = WebClient
        .builder()
        .defaultHeader(&quot;JWT-Token&quot;, &quot;xxxyyy3fsfsfsff-fjdskfa&quot;)
        .build();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;支持的可选配置如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;uriBuilderFactory&lt;/code&gt;: 自定义UriBuilderFactory灵活配置使用Url&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defaultHeader&lt;/code&gt;: 为HTTP请求设置Headers请求头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defaultCookie&lt;/code&gt;: 为HTTP请求设置Cookies&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defaultRequest&lt;/code&gt;: 自定义Http Request&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter&lt;/code&gt;: 为HTTP请求增加客户端过滤器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exchangeStrategies&lt;/code&gt;: HTTP 读写信息自定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clientConnector&lt;/code&gt;: HTTP客户端连接器设置&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Aug 2020 23:59:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>笔者在之前已经写了一系列的关于RestTemplate的文章，如下： 精讲RestTemplate第1篇-在Spring或非Spring环境下如何使用 精讲RestTemplate第2篇-多种底层HT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13532958.html</dc:identifier>
</item>
<item>
<title>Docker 的前世今生 - 哈喽沃德先生</title>
<link>http://www.cnblogs.com/mrhelloworld/p/docker1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrhelloworld/p/docker1.html</guid>
<description>&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;虚拟化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;要解释清楚 Docker，首先要解释清楚容器（Container）的概念&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。要解释容器的话，就需要从操作系统说起。操作系统太底层，细说的话一两本书都说不清楚。这里就一句话来总结一下：操作系统（Operating System，简称OS）是管理计算机硬件与软件资源的计算机程序，并且为软件运行提供通用服务的系统软件。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着硬件的性能提升，软件种类的丰富，有两种情况变得很常见：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;硬件性能过剩——很多计算机的硬件配置，往往会有大量时间处于硬件资源闲置的状态。例如一般家用电脑，已经是四核、六核的配置了，除了3A游戏、视频制作、3D渲染、高性能计算等特殊应用外，通常有 90% 以上时间 CPU 是闲置的；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;软件冲突——因为业务需要，两个或者多个软件之间冲突，或者需要同一个软件的不同版本。例如早几年做 Web 前端的，要测试网页在不同版本的 IE 上是否能正常显示，然而 Windows 只能装一个版本的 IE。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决软件冲突，只能配置多台计算机，或者很麻烦的在同一台电脑上安装多个操作系统。显然这两个方案都有其缺点：多台计算机成本太高，多操作系统的安装、切换都很麻烦。在硬件性能过剩的时候，&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;硬件虚拟化&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的普及就很自然而然的提出来了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓硬件虚拟化，就是某个特殊的软件，仿真出一台或者多台计算机的各种硬件，用户可以在这一台虚拟机上安装、运行操作系统（一般叫来宾操作系统，Guest OS）和各种应用，并且把 Guest OS 和上面应用软件对硬件资源的访问转发到底层的硬件上来实现。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Guest OS 和上面的应用程序来说，这台虚拟机和普通物理计算机是完全一样没有任何区别的——除了性能可能差一点。全球第一人气的 VMware Workstation 就是这么一个软件，Oracle 的 VirtualBox 以及 Microsoft 的 Virtual PC 都是。这类软件英语有一个专用的单词是 Hypervisor（虚拟机管理程序）。&lt;/p&gt;

&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07c0c2a4587949809675fa8006c13754~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;虚拟机的优点&lt;/span&gt;&lt;/h3&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以把资源分配到不同的虚拟机，达到硬件资源的最大化利用；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比直接在物理机上部署应用，虚拟机更容易扩展应用；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;云服务：通过虚拟机虚拟出不同的物理资源，可以快速搭建云服务。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虚拟化技术主要用来解决高性能的物理硬件产能过剩和老旧的硬件硬件产品产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;

&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;虚拟机的缺点&lt;/span&gt;&lt;/h3&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机的缺点在于 Guest OS 通常会占用不少硬件资源。例如 Windows 安装 VMware 并开机 Guest OS，不运行任何应用的情况下，就需要占用 2 ~ 3G 内存，20 ~ 30G 硬盘空间。而且为了应用系统运行的性能，往往还要给每台虚拟机留出更多的内存容量。虽然不少 Hypervisor 支持动态内存，但基本上都会降低虚拟机的性能。在这样的资源占用情况下，少量的虚拟机还是可以接受的，如果同时运行十多台或数十台虚拟机，硬件资源的浪费就会成倍递增。通常来说，其中相当大一部分甚至全部 Guest OS 都是相同的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能不能所有应用使用同一个操作系统减少硬件资源的浪费，但是又能避免包括运行库在内的软件冲突呢？&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;操作系统层虚拟化——容器&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;概念的提出，就是为了解决这个问题。Docker 就是一个容器的标准化实现。&lt;/p&gt;

&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;容器化&lt;/span&gt;&lt;/h2&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器技术已经发展了很长一段时间了，例如：LXC，BSD Jails，Solaris Zones...&lt;/p&gt;
&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/7868545-5c9e6c9bd22071d7.webp&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器化就是应用程序级别的虚拟化技术。容器提供了将应用程序的代码、运行时、系统工具、系统库和配置打包到一个实例中的标准方法。容器共享一个内核（操作系统），它安装在硬件上。&lt;/p&gt;

&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/docker-containerized-appliction-blue-border_2.png&quot; alt=&quot;&quot;/&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和虚拟机相比，容器有以下优点：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;启动迅速：没有虚拟机硬件的初始化，没有 Guest OS 的启动过程，可以节约很多启动时间，这就是容器的“开箱即用”；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;占用资源少：没有运行 Guest OS 所需的内存开销，无需为虚拟机预留运行内存，无需安装、运行 App 不需要的运行库/操作系统服务，内存占用、存储空间占用都小的多。相同配置的服务器，如果运行虚拟机能运行十多台的，通常可以运行上百个容器毫无压力——当然前提是单个容器应用本身不会消耗太多资源。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Docker 历史&lt;/span&gt;&lt;/h2&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2010 年，几个搞 IT 的年轻人，在美国旧金山成立了一家名叫 &lt;code&gt;dotCloud&lt;/code&gt; 的公司。dotCloud 的平台即服务（Platform-as-a-Service, PaaS）提供商。底层技术上，dotCloud 平台利用了 Linux 的 LXC 容器技术。&lt;/p&gt;

&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/timg1.jpg&quot; alt=&quot;&quot;/&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便创建和管理这些容器，dotCloud 基于 Google 公司推出的 Go 语言开发了一套内部工具，之后被命名为 &lt;code&gt;Docker&lt;/code&gt;。Docker 就是这样诞生的。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LXC 是 Docker 的底层基石，但是在 Docker 0.9 版本的时候，Docker 见异思迁了，引入了基于 Go 语言构建的 Libcontainer 的 execution driver。有了 Libcontainer 这个项目，Docker 不再需要依赖于 Linux 部件（LXC，libvirt，systemd-nspawn...）就可以处理 namespaces、control groups、capabilities、apparmor profiles、network interfaces。这下，LXC 沦为可选项。&lt;/p&gt;
&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/7868545-c27951d5beb766cb.webp&quot; alt=&quot;&quot;/&gt;&lt;p&gt;在 Docker 1.8 中 LXC 被 deprecated，在 Docker 1.10，LXC 彻底出局。Docker 推出 Libcontainer 自己集成了 Linux 内核中的很多特性，作为一个独特、稳定且不受制于 Linux 的 Library，独立的时代终于到来了。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;

&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/timg.jpg&quot; alt=&quot;&quot;/&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如同 Docker 的 Logo 一样，Docker 的思想来源于集装箱。集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来，并且各种各样的货物被集装箱标准化，集装箱与集装箱之间互不影响。那么就不需要专门运送水果的船和专门运送化学用品的船了。只要这些货物封装在不同的集装箱里，就可以用一艘大船把它们都运走。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 技术诞生之后，并没有引起行业的关注。而 dotCloud 公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的软件一开始就是开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。2013 年 3 月，dotCloud 公司的创始人之一，Docker 之父，28 岁的 &lt;strong&gt;&lt;span&gt;「&lt;/span&gt;Solomon Hykes&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; 正式决定，将 Docker 项目开源。&lt;/p&gt;

&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/timg2.jpg&quot; alt=&quot;&quot;/&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不开则已，一开惊人。越来越多的 IT 工程师发现了 Docker 的优点，然后蜂拥而至，加入 Docker 开源社区。Docker 的人气迅速攀升，速度之快，令人瞠目结舌。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源当月， Docker 0.1 版本发布。此后的每一个月， Docker 都会发布一个版本。到 2014 年 6 月 9 日， Docker 1.0 版本正式发布。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的 Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像 Google、微软、Amazon、 VMware 这样的巨头们都对它青睐有加，表示将全力支持。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 火了之后， dotCloud 公司干脆把公司名字也改成了 Docker Inc. 。&lt;/p&gt;

&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;为什么选择 Docker&lt;/span&gt;&lt;/h2&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;更高效的利用系统资源&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;更快速的启动时间&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;一致的运行环境&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现「这段代码在我机器上没问题啊」 这类问题。&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;持续交付和部署&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成（Continuous Integration）系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署（Continuous Delivery/Deployment）系统进行自动部署。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的在生产环境中部署该镜像。&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;更轻松的迁移&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;更轻松的维护和扩展&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。&lt;/p&gt;

&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;容器与虚拟机的比较&lt;/span&gt;&lt;/h2&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。&lt;/p&gt;

&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/docker-containerized-and-vm-transparent-bg.png&quot; alt=&quot;&quot;/&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与传统的虚拟机相比，Docker 优势体现为启动速度快、占用体积小。&lt;/p&gt;
&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/add19471351ab02a597dea48a976213b.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;至此 Docker 概念性相关内容就介绍到这里，下文我们聊聊 Docker 架构及其工作原理。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/1/171cf87f564bc82e?w=433&amp;amp;h=133&amp;amp;f=gif&amp;amp;s=333013&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;知识共享「署名-非商业性使用-禁止演绎 4.0 国际」许可协议&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以通过 &lt;a href=&quot;https://mrhelloworld.com/categories&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;分类&lt;/code&gt;&lt;/a&gt; 查看更多关于 &lt;a href=&quot;https://mrhelloworld.com/categories/docker&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;&lt;/a&gt; 的文章。&lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🤗 您的&lt;code&gt;点赞&lt;/code&gt;和&lt;code&gt;转发&lt;/code&gt;是对我最大的支持。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📢 扫码关注 &lt;code&gt;哈喽沃德先生&lt;/code&gt;「文档 + 视频」每篇文章都配有专门视频讲解，学习更轻松噢 ~&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/27/171b91f4ae03d737?w=500&amp;amp;h=500&amp;amp;f=gif&amp;amp;s=126591&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Wed, 19 Aug 2020 23:47:00 +0000</pubDate>
<dc:creator>哈喽沃德先生</dc:creator>
<og:description>虚拟化 「要解释清楚 Docker，首先要解释清楚容器（Container）的概念」。要解释容器的话，就需要从操作系统说起。操作系统太底层，细说的话一两本书都说不清楚。这里就一句话来总结一下：操作系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrhelloworld/p/docker1.html</dc:identifier>
</item>
<item>
<title>秒杀 2Sum 3Sum 4Sum 算法题  - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13532916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13532916.html</guid>
<description>&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghujl0hs7hg30dc0491kx.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2 Sum 这题是 Leetcode 的第一题，相信大部分小伙伴都听过的吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一道标着 Easy 难度的题，它真的这么简单吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在之前的刷题视频里说过，大家刷题一定要吃透一类题，为什么有的人题目做着越来越少，有的人总觉得刷不完的题，就是因为没有分类吃透。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单纯的追求做题数量是没有意义的，Leetcode 的题目只会越来越多，就像高三时的模考试卷一样做不完，但分类总结，学会解决问题的方式方法，才能遇到新题也不手足无措。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2 Sum&lt;/span&gt;&lt;/h2&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtbxc1gzej30l808g0ti.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题题意就是，给一个数组和一个目标值，让你在这个数组里找到两个数，使得它俩之和等于这个目标值的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如题目中给的例子，目标值是 9，然后数组里 &lt;code&gt;2 + 7 = 9&lt;/code&gt;，于是返回 2 和 7 的下标。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;方法一&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我多年前还不知道时空复杂度的时候，我想这还不简单嘛，就每个组合挨个试一遍呗，也就是两层循环。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来我才知道，这样时间复杂度是很高的，是 &lt;code&gt;O(n^2)&lt;/code&gt;；但另一方面，这种方法的空间复杂度最低，是 &lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;面试时一定要先问面试官，是希望优化时间还是优化空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说我们追求优化时间，但你不能默认面试官也是这么想的，有时候他就是想考你有没有这个意识呢。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个方法能够兼具优化时间和空间那就更好了，比如斐波那契数列这个问题中从递归到 DP 的优化，就是时间和空间的双重优化，不清楚的同学后台回复「递归」快去补课～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下这个代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] twoSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.length; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j &amp;lt; nums.length; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[i] + nums[j] == target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[]{i, j};&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[]{-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;};&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;时间复杂度：O(n^2)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;空间复杂度：O(1)&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喏，这速度不太行诶。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtd5qpe0wj30hz03vwev.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;方法二&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那在我学了 &lt;code&gt;HashMap&lt;/code&gt; 这个数据结构之后呢，我又有了新的想法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt; 或者 &lt;code&gt;HashSet&lt;/code&gt; 的最大优势就是能够用 &lt;code&gt;O(1)&lt;/code&gt; 的时间获取到目标值，那么是不是可以优化方法一的第二个循环呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个思路，假设当前在看 &lt;code&gt;x&lt;/code&gt;，那就是需要把 &lt;code&gt;x&lt;/code&gt; 之前或者之后的数放在 &lt;code&gt;HashSet&lt;/code&gt; 里，然后看下 &lt;code&gt;target - x&lt;/code&gt; 在不在这个 &lt;code&gt;hashSet&lt;/code&gt; 里，如果在的话，那就匹配成功～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;诶这里有个问题，这题要求返回这俩数的下标，可是 &lt;code&gt;HashSet&lt;/code&gt; 里的数是无序的...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就用升级版——&lt;code&gt;HashMap&lt;/code&gt; 嘛～～还不了解 &lt;code&gt;HashMap&lt;/code&gt; 的原理的同学快去公众号后台回复「HashMap」看文章啦。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt; 里记录下数值和它的 &lt;code&gt;index&lt;/code&gt; 这样匹配成功之后就可以顺便得到 &lt;code&gt;index&lt;/code&gt; 了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们&lt;strong&gt;不需要提前记录所有的值&lt;/strong&gt;，只需要&lt;strong&gt;边过数组边记录&lt;/strong&gt;就好了，为了防止重复，我们只在这个当前的数出现之前的数组部分里找另一个数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;code&gt;HashMap&lt;/code&gt; 里记录的是下标 &lt;code&gt;i&lt;/code&gt; 之前的所有出现过的数；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;对于每个 &lt;code&gt;nums[i]&lt;/code&gt; ，我们先检查 &lt;code&gt;target - nums[i]&lt;/code&gt; 是否在这个 &lt;code&gt;map&lt;/code&gt; 里；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果在就直接返回了，如果不在就把当前 &lt;code&gt;i&lt;/code&gt; 的信息加进 &lt;code&gt;map&lt;/code&gt; 里。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] twoSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] res = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];&lt;br/&gt;Map&amp;lt;Integer, Integer&amp;gt; map = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.length; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (map.containsKey(target - nums[i])) {&lt;br/&gt;res[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = map.get(target - nums[i]);&lt;br/&gt;res[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = i;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br/&gt;}&lt;br/&gt;map.put(nums[i], i);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;时间复杂度：O(n)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;空间复杂度：O(n)&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喏，速度提升至 &lt;code&gt;beat 99.96%&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtd5zy0d8j30hv042weu.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;拓展&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是最基本的 &lt;code&gt;2 Sum&lt;/code&gt; 问题，这个题可以有太多的变种了：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果这个数组里有不止一组结果，要求返回所有组合，该怎么做？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果这个数组里有重复元素，又该怎么做？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果这个数组是一个排好序了的数组，那如何利用这个条件呢？- Leetcode 167&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果不是数组而是给一个 &lt;code&gt;BST&lt;/code&gt; ，该怎么在一棵树上找这俩数呢？- Leetcode 653&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里讲一下排序数组这道题，之后会在 &lt;code&gt;BST&lt;/code&gt; 的文章里会讲 653 这题。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;排序数组&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtf6itm65j30mi0bo402.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道排序算法中最快的也需要 &lt;code&gt;O(nlogn)&lt;/code&gt;，所以如果是一个 &lt;code&gt;2 Sum&lt;/code&gt; 问题，那没必要专门排序，因为排序会成为运算的瓶颈。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果题目给的就是个排好序了的数组，那肯定要好好收着了呀！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当数组是排好序的时候，我们可以进一步优化空间，达到 &lt;code&gt;O(n)&lt;/code&gt; 的时间和 &lt;code&gt;O(1)&lt;/code&gt; 的空间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该怎么利用排好序这个性质呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就是说，在 &lt;code&gt;x&lt;/code&gt; 右边的数，都比 &lt;code&gt;x&lt;/code&gt; 要大；在 &lt;code&gt;x&lt;/code&gt; 左边的数，都比 &lt;code&gt;x&lt;/code&gt; 要小。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果 &lt;code&gt;x + y &amp;gt; target&lt;/code&gt;，那么就要 &lt;code&gt;y&lt;/code&gt; 往左走，往小的方向走；&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果 &lt;code&gt;x + y &amp;lt; target&lt;/code&gt;，那么就要 &lt;code&gt;x&lt;/code&gt; 往右走，往大的方向走。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtjsqaugfj30im06wgls.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就是典型的 &lt;code&gt;Two pointer&lt;/code&gt; 算法，两个指针相向而行的情况，我之后也会出文章详细来讲哒。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] twoSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] numbers, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; left = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; right = numbers.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (left &amp;lt; right) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; sum = numbers[left] + numbers[right];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (sum == target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[]{left + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, right + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;}; &lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (sum &amp;lt; target) {&lt;br/&gt;left ++;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;right --;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[]{-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;};&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3 Sum&lt;/span&gt;&lt;/h2&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtf785x1rj30m00bu756.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;3 Sum&lt;/code&gt; 的问题其实就是一个 &lt;code&gt;2 Sum&lt;/code&gt; 的升级版，因为 1 + 2 = 3 嘛。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就是外面一层循环，固定一个值，在剩下的数组里做 &lt;code&gt;2 Sum&lt;/code&gt; 问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正 &lt;code&gt;3 Sum&lt;/code&gt; 怎么着都得 &lt;code&gt;O(n^2)&lt;/code&gt; ，就可以先排序，反正不在乎排序的这点时间了，这样就可以用 &lt;code&gt;Two pointer&lt;/code&gt; 来做了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还需要注意的是，这道题返回的是&lt;strong&gt;数值&lt;/strong&gt;，而非 &lt;code&gt;index&lt;/code&gt;，所以它不需要重复的数值——The solution set must not contain duplicate triplets.&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] nums) {&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;Arrays.sort(nums);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i + &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;lt; nums.length; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; nums[i] == nums[i - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k = nums.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;  &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target = -nums[i];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; k) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[j] + nums[k] == target) {&lt;br/&gt;res.add(Arrays.asList(nums[i], nums[j], nums[k]));&lt;br/&gt;j++;&lt;br/&gt;k--;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; k &amp;amp;&amp;amp; nums[j] == nums[j - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) {&lt;br/&gt;j++;  &lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; k &amp;amp;&amp;amp; nums[k] == nums[k + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) {&lt;br/&gt;k--;  &lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[j] + nums[k] &amp;gt; target) {&lt;br/&gt;k--;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;j++;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4 Sum&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是 &lt;code&gt;4 Sum&lt;/code&gt; 问题啦。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtf90id1nj30mk0c975d.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一题如果只是 &lt;code&gt;O(n^3)&lt;/code&gt; 的解法没什么难的，因为就是在 &lt;code&gt;3 Sum&lt;/code&gt; 的基础上再加一层循环嘛。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果在面试中只做出 &lt;code&gt;O(n^3)&lt;/code&gt; 恐怕就过不了了哦😯&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这 4 个数，可以想成两两的 &lt;code&gt;2 Sum&lt;/code&gt;，先把第一个 &lt;code&gt;2 Sum&lt;/code&gt; 的结果存下来，然后在后续的数组中做第二个 &lt;code&gt;2 Sum&lt;/code&gt;，这样就可以把时间降低到 &lt;code&gt;O(n^2)&lt;/code&gt; 了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要注意的是，为了&lt;strong&gt;避免重复&lt;/strong&gt;，也就是下图的 &lt;code&gt;nums[x] + nums[y] + nums[z] + nums[k]&lt;/code&gt; ，其实和 &lt;code&gt;nums[z] + nums[k] + nums[x] + nums[y]&lt;/code&gt; 并没有区别，所以我们要&lt;strong&gt;限制第二组的两个数要在第一组的两个数之后&lt;/strong&gt;哦。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtjt88465j30lh09ldga.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下代码吧：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target) {&lt;br/&gt;Set&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; set = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;Map&amp;lt;Integer, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt; map = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;Arrays.sort(nums);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.length - &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j &amp;lt; nums.length - &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; currSum = nums[i] + nums[j];&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; pairs = map.getOrDefault(currSum, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;pairs.add(Arrays.asList(i, j));&lt;br/&gt;map.put(currSum, pairs);&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; i &amp;lt; nums.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j &amp;lt; nums.length; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; currSum = nums[i] + nums[j];&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; prevPairs = map.get(target - currSum);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(prevPairs == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(List&amp;lt;Integer&amp;gt; pair : prevPairs) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(pair.get(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &amp;lt; i) {&lt;br/&gt;set.add(Arrays.asList(nums[pair.get(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)], nums[pair.get(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)], nums[i], nums[j]));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(set);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，以上就是 &lt;code&gt;2 Sum&lt;/code&gt; 相关的所有问题啦，如果有收获的话，记得关注我哦～&lt;/p&gt;
</description>
<pubDate>Wed, 19 Aug 2020 22:48:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>2 Sum 这题是 Leetcode 的第一题，相信大部分小伙伴都听过的吧。 作为一道标着 Easy 难度的题，它真的这么简单吗？ 我在之前的刷题视频里说过，大家刷题一定要吃透一类题，为什么有的人题目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13532916.html</dc:identifier>
</item>
<item>
<title>Spring Boot系列（三）：Spring Boot整合Mybatis源码解析 - toby.xu</title>
<link>http://www.cnblogs.com/toby-xu/p/13525320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toby-xu/p/13525320.html</guid>
<description>&lt;h2&gt;一、Mybatis回顾&lt;/h2&gt;
&lt;h3&gt;　　1、MyBatis介绍&lt;/h3&gt;
&lt;p&gt;　　Mybatis是一个半ORM框架，它使用简单的 XML 或注解用于配置和原始映射，将接口和Java的POJOs（普通的Java 对象）映射成数据库中的记录。&lt;/p&gt;
&lt;h3&gt;　　2、Mybatis整体架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200818190628230-899565534.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 二、Spring Boot整合Mybatis + Druid&lt;/h2&gt;
&lt;h3&gt;　　1、在应用中导入maven依赖如下：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 　　　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mybatis &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;database pool&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;druid&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;mysql数据库&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;runtime&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、在应用中加配置&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;① 配置Druid数据源参数：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#配置数据源
spring.datasource.druid.url&lt;/span&gt;=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3306/demo_db?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&lt;/span&gt;
spring.datasource.druid.username=&lt;span&gt;root
spring.datasource.druid.password&lt;/span&gt;=&lt;span&gt;123qwe
spring.datasource.druid.driverClassName&lt;/span&gt;=&lt;span&gt;com.mysql.jdbc.Driver
spring.datasource.druid.initialSize: &lt;/span&gt;5&lt;span&gt;
spring.datasource.druid.minIdle: &lt;/span&gt;5&lt;span&gt;
spring.datasource.druid.maxActive: &lt;/span&gt;20&lt;span&gt;
spring.datasource.druid.maxWait: &lt;/span&gt;60000&lt;span&gt;
spring.datasource.druid.timeBetweenEvictionRunsMillis: &lt;/span&gt;60000&lt;span&gt;
spring.datasource.druid.minEvictableIdleTimeMillis: &lt;/span&gt;300000&lt;span&gt;
spring.datasource.druid.validationQuery: SELECT &lt;/span&gt;1&lt;span&gt; FROM DUAL
spring.datasource.druid.testWhileIdle: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
spring.datasource.druid.testOnBorrow: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
spring.datasource.druid.testOnReturn: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
spring.datasource.druid.poolPreparedStatements: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
spring.datasource.druid.filters: stat,wall
spring.datasource.druid.maxPoolPreparedStatementPerConnectionSize: &lt;/span&gt;20&lt;span&gt;
spring.datasource.druid.useGlobalDataSourceStat: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
spring.datasource.druid.connectionProperties: druid.stat.mergeSql&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;;druid.stat.slowSqlMillis=500&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;② 编写Druid数据源属性接收类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 自定义druid的属性
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@ConfigurationProperties(prefix &lt;/span&gt;= &quot;spring.datasource.druid&quot;&lt;span&gt;)
@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DruidDataSourceProperties {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String url;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String driverClassName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer initialSize;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer maxActive;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer minIdle;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long maxWait;
    ......&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;③ 编写Druid数据源配置类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 自定义druid配置,如不自定义，配置文件设置的属性不生效自行测试
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
@EnableConfigurationProperties(value &lt;/span&gt;= DruidDataSourceProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@MapperScan(basePackages&lt;/span&gt;=&quot;com.toby.mapper&quot;, value=&quot;sqlSessionFactory&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DruidDataSourceConfig {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DruidDataSourceProperties druidDataSourceProperties;

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataSource dataSource() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        DruidDataSource druidDataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DruidDataSource();
        druidDataSource.setUsername(druidDataSourceProperties.getUsername());
        druidDataSource.setPassword(druidDataSourceProperties.getPassword());
        druidDataSource.setUrl(druidDataSourceProperties.getUrl());
        druidDataSource.setDriverClassName(druidDataSourceProperties.getDriverClassName());
        druidDataSource.setInitialSize(druidDataSourceProperties.getInitialSize());
        druidDataSource.setMinIdle(druidDataSourceProperties.getMinIdle());
        druidDataSource.setMaxActive(druidDataSourceProperties.getMaxActive());
        druidDataSource.setMaxWait(druidDataSourceProperties.getMaxWait());
        druidDataSource.setFilters(druidDataSourceProperties.getFilters());
        druidDataSourceProperties.setPoolPreparedStatements(druidDataSourceProperties.getPoolPreparedStatements());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; druidDataSource;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、在应用中加@MapperScan注解，他的主要作用就是扫描basePackage包下面的TobyMapper接口，然后getBean的时候通过JDK的动态代理，生成代理对象，所以我们程序中看到的是TobyMapper接口，其实是被动态代理过的。验证方式很简单，DEUBG到TobyMapper的方法里面，就可以发现其就是个动态代理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: spring boot 启动类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SpringBootApplication
@MapperScan(basePackages&lt;/span&gt;=&quot;com.toby.mapper&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MybatisApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(MybatisApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、源码解析&lt;/h2&gt;
&lt;h3&gt;　　1、Mybatis自动装配&lt;/h3&gt;
&lt;p&gt;　　自动装配的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200820011804252-1335394167.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体详细见&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/toby-xu/p/13521019.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring Boot系列（二）：Spring Boot自动装配原理解析&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;中的Spring Boot自动装配流程图。Mybatis的自动配置类给我们配置了什么组件，我们接下来看下MybatisAutoConfiguration类&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;① SqlSessionFactory：当容器中没有&lt;/strong&gt;SqlSessionFactory这个类型的Bean的时候，Spring就加载该组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200819224626613-87142890.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;② SqlSessionTemplate：同样&lt;/strong&gt;当容器中没有&lt;strong&gt;SqlSessionTemplate&lt;/strong&gt;&lt;strong&gt;这个类型的Bean的时候，Spring就加载该组件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200819224510500-402163018.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　到此SqlSessionFactory和SqlSessionTemplate组件有了。&lt;/p&gt;
&lt;h3&gt;　　2、@MapperScan注解&lt;/h3&gt;
&lt;p&gt;　　@MapperScan注解：他的作用就是扫描basePackages包下面的TobyMapper接口，然后getBean(&quot;tobyMapper&quot;)的时候把该接口通过JDK的动态代理，生成代理对象，用于和数据库打交道。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;① 从@MapperScan入手：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200819225608008-1729839251.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;② 导入了MapperScanner注册类MapperScannerRegistrar：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;它是一个ImportBeanDefinitionRegistrar，Spring在通过@Import导入Bean的时候，会调用其registerBeanDefinitions，往Spring容器中注册bean定义信息，以便后面可以通过getBean获取到被注册进行的bean的定义信息所对应的Bean，其往Spring容器中注册的是MapperFactoryBean类型的Bean定义信息，为什么是MapperFactoryBean类型，而不是TobyMapper类型？原因很简单，Spring容器在getBean的时候，会忽略掉接口，接口是不能new的，而Spring容器默认在实例化的时候就是通过调用beanDefinition的beanClass属性所对应的类的无参构造方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200819230140622-1307208373.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;③ 进去到注册bean定义信息的registerBeanDefinitions方法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200819232046558-169651775.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;④ 进入到ClassPathMapperScanner的doScan，其作用是扫描basePackages所有的包，这里ClassPathMapper Scanner继承了Spring的包扫描ClassPathBeanDefinitionScanner&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200819232959747-1654823658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　重写（覆盖）了判断是否是候选的Component方法isCandidateComponent，因为Spring默认的isCandidateComponent是会过滤掉接口的，显然不满足，所以重写了该方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　/**&lt;/span&gt;&lt;span&gt;
     * Spring默认的,独立的非接口，非抽象类
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
        AnnotationMetadata metadata &lt;/span&gt;=&lt;span&gt; beanDefinition.getMetadata();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (metadata.isIndependent() &amp;amp;&amp;amp; (metadata.isConcrete() ||&lt;span&gt;
                (metadata.isAbstract() &lt;/span&gt;&amp;amp;&amp;amp; metadata.hasAnnotatedMethods(Lookup.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName()))));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * ClassPathMapperScanner的可以是独立的接口
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; beanDefinition.getMetadata().isInterface() &amp;amp;&amp;amp;&lt;span&gt; beanDefinition.getMetadata().isIndependent();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来进入到处理TobyMapper的bean的定义信息方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200820001117633-983955669.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;⑤ 处理TobyMapper的bean定义信息，主要由3个重要改动：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//第一：&lt;/span&gt;&lt;span&gt;修改构造函数为有参的构造函数；&lt;/span&gt;
&lt;span&gt;definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);
&lt;/span&gt;&lt;span&gt;//第二：&lt;/span&gt;&lt;span&gt;修改bean的class为MapperFactoryBean，该MapperFactoryBean是FactoryBean；&lt;/span&gt;
definition.setBeanClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapperFactoryBean.getClass());
&lt;/span&gt;&lt;span&gt;//第三：&lt;/span&gt;&lt;span&gt;修改注入类型为按照类型注入；&lt;/span&gt;
definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到此，扫描TobyMapper的时候，往Spring容器中注册的是beanClass为MapperFactoryBean，一个有参数的构造函数，按照类型注入的这么一个Bean定义信息。&lt;/p&gt;
&lt;h3&gt;　　3、通过getBean(&quot;tobyMapper&quot;)获取TobyMapper的动态代理类&lt;/h3&gt;
&lt;p&gt;　　我们知道，此时的tobyMapper的bean定义信息中的beanClass的属性是MapperFactoryBean.class，而MapperFactoryBean又是一个FactoryBean，FactoryBean的特点就是在getBean的时候会调用其getObject方法；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;① 我们找到MapperFactoryBean的getObject方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200820002956803-213643203.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;② 我们再进入org.apache.ibatis.session.defaults.DefaultSqlSession#getMapper方法，其实已经到了Mybatis的逻辑了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200820003123558-40508414.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;③ 最后调用到org.apache.ibatis.binding.MapperRegistry#getMapper，其实就是创建JDK的动态代理了。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt;&lt;span&gt; type, SqlSession sqlSession) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MapperProxyFactory&amp;lt;T&amp;gt; mapperProxyFactory = (MapperProxyFactory&amp;lt;T&amp;gt;&lt;span&gt;) knownMappers.get(type);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mapperProxyFactory == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建代理实例&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperProxyFactory.newInstance(sqlSession);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Error getting mapper instance. Cause: &quot; +&lt;span&gt; e, e);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200820003537131-1536207265.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　代理的逻辑在org.apache.ibatis.binding.MapperProxy#invoke方法，到此tobyMapper创建完成，可以操作数据库。&lt;/p&gt;
&lt;h2&gt; 四、扫描Mapper和Mapper动态代理对象生成流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200820010532676-456519406.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Aug 2020 17:22:00 +0000</pubDate>
<dc:creator>toby.xu</dc:creator>
<og:description>一、Mybatis回顾 1、MyBatis介绍 Mybatis是一个半ORM框架，它使用简单的 XML 或注解用于配置和原始映射，将接口和Java的POJOs（普通的Java 对象）映射成数据库中的记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toby-xu/p/13525320.html</dc:identifier>
</item>
</channel>
</rss>