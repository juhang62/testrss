<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白学 Python（23）：Excel 基础操作（上） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11880144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11880144.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191118084338987-199788838.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/12/2870915863/&quot;&gt;小白学 Python（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/13/2870915864/&quot;&gt;小白学 Python（2）：基础数据类型（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/15/25090937/&quot;&gt;小白学 Python（3）：基础数据类型（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/17/2392286754/&quot;&gt;小白学 Python（4）：变量基础操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/18/999362065/&quot;&gt;小白学 Python（5）：基础运算符（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/20/2416267271/&quot;&gt;小白学 Python（6）：基础运算符（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/22/979409150/&quot;&gt;小白学 Python（7）：基础流程控制（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/2184234984/&quot;&gt;小白学 Python（8）：基础流程控制（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/3066758654/&quot;&gt;小白学 Python（9）：基础数据结构（列表）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/25/1277177083/&quot;&gt;小白学 Python（10）：基础数据结构（列表）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/26/1783681326/&quot;&gt;小白学 Python（11）：基础数据结构（元组）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/1304658395/&quot;&gt;小白学 Python（12）：基础数据结构（字典）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/2327215405/&quot;&gt;小白学 Python（13）：基础数据结构（字典）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/29/2327215406/&quot;&gt;小白学 Python（14）：基础数据结构（集合）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/30/3105860436/&quot;&gt;小白学 Python（15）：基础数据结构（集合）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/31/3818474124/&quot;&gt;小白学 Python（16）：基础数据类型（函数）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/619492986/&quot;&gt;小白学 Python（17）：基础数据类型（函数）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/3195979051/&quot;&gt;小白学 Python（18）：基础文件操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/3195979051/&quot;&gt;小白学 Python（18）：基础文件操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/03/271169345/&quot;&gt;小白学 Python（19）：基础异常处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/05/1111962512/&quot;&gt;小白学 Python（20）：迭代器基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/06/988349733/&quot;&gt;小白学 Python（21）：生成器基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/07/908307735/&quot;&gt;小白学 Python（22）：time 和 calendar 模块简单使用&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;读取-excel&quot;&gt;读取 Excel&lt;/h2&gt;
&lt;p&gt;不知道各位同学有没有见过有关 Python 操作 Excel 的广告。小编是见过好多次的，还只需 ￥9.9 就能学习，今天小编就为大家带来免费的 Python 操作 Excel 的入门教程。&lt;/p&gt;
&lt;p&gt;仔细看，仔细学，本文价值 ￥9.9 哦~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191118084340115-365070940.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这牛逼吹得我自己都有点脸红。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191118084340317-800589621.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然要操作 Excel ，那我们就需要先建立一个 Excel 。&lt;/p&gt;
&lt;p&gt;首先在 Excel 中创建 3 个 Sheet ，别跟我说不知道什么是 Sheet ，可能你不适合看本篇内容。&lt;/p&gt;
&lt;p&gt;测试使用 Excel 已经上传至代码仓库，有需要的同学可以取用。&lt;/p&gt;
&lt;p&gt;Excel 内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191118084340460-1351752525.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请先暂时忽略右下角的日期时间，这日期时间并无实际作用，仅用来演示使用。&lt;/p&gt;
&lt;p&gt;这是一个 Sheet 的数据，同样的 Sheet 存在 3 个。&lt;/p&gt;
&lt;p&gt;可能各位同学看到这个 Excel 以后大致能猜到小编要干啥了，对，没错，你猜对了，小编就是要算一下平均成绩。&lt;/p&gt;
&lt;p&gt;那么用 Excel 自带的公式来算平均成绩不香么，非要用 Python 算，劳民伤财的。&lt;/p&gt;
&lt;p&gt;Excel 自带的函数确实强大，这个不得不服，但是，我如果要跨 Sheet 的操作呢？本文要玩的骚操作就是要跨 Sheet 计算平均成绩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191118084340599-1331635578.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，我们需要导入第三方模块 &lt;code&gt;xlrd&lt;/code&gt; ，因为是第三方的模块，没有安装的同学需要先安装。在命令行中输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install xlrd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待进度条走完就好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取 workbook：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们需要在代码中打开我们刚才创建的 Excel :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;workbook = xlrd.open_workbook('test.xlsx')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小编这里为了方便，将 &lt;code&gt;test.xlsx&lt;/code&gt; 和代码放在同一目录，实际在操作中需注意文件的路径问题，不管是使用相对路径还是绝对路径，都要写对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sheet 有关操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有关 Sheet 的操作有很多，我们列举几个常用的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 输出所有 sheet 的名字
print(workbook.sheet_names())
# 获取所有的 sheet
print(workbook.sheets())
# 根据索引获取 sheet
print(workbook.sheet_by_index(1))
# 根据名字获取 sheet
print(workbook.sheet_by_name('1班'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果我这里就不演示了，各位同学自己操作下就知道了：）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取行数和列数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sheet1 = workbook.sheets()[0]
# 获取行数
print(sheet1.nrows)
# 获取列数
print(sheet1.ncols)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;6
4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取整行和整列的数据（数据类型为列表）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 获取第 2 行内容
print(sheet1.row_values(1))
# 获取第 3 列内容
print(sheet1.col_values(2))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['小明', 76.0, 85.0, 95.0, '']
['数学', 85.0, 58.0, 96.0, '', '']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取单元格的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cell1 = sheet1.cell(1, 1).value
# 行索引
cell2 = sheet1.row(1)[1].value
cell3 = sheet1.cell(1, 2).value
# 列索引
cell4 = sheet1.col(2)[1].value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;76.0 76.0 85.0 85.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取日期类型数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date_value = xlrd.xldate_as_datetime(sheet1.cell_value(5, 3), workbook.datemode)
print(type(date_value), date_value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class 'datetime.datetime'&amp;gt; 2019-11-07 20:49:05&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是直接通过方法将数据转成了 &lt;code&gt;datetime&lt;/code&gt; 类型， &lt;code&gt;xlrd&lt;/code&gt; 还提供了可以将数据转成元组，然后再将元组转成日期。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date_tulp = xlrd.xldate_as_tuple(sheet1.cell_value(5, 3), workbook.datemode)
print(type(date_tulp), date_tulp)
year, month, day, hour, minute, second = date_tulp
print(datetime.datetime(year, month, day, hour, minute, second))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class 'tuple'&amp;gt; (2019, 11, 7, 20, 49, 5)
2019-11-07 20:49:05&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;今天的重头戏是求平均数，但是我不想在文章里贴代码了，只好请各位同学自己动下手咯~~~&lt;/p&gt;
&lt;p&gt;当然，如果实在搞不定可以访问代码仓库，具体的实现代码小编还是会提交至代码仓库，不过小编还是希望各位同学能独立完成作业~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191118084340734-2113984577.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-excel&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-excel&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 00:44:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我选Python 前文传送门 '小白学 Python（1）：开篇' '小白学 Python（2）：基础数据类型（上）' '小白学 Python（3）：基础数据类型（下）' '小白学 Pyth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11880144.html</dc:identifier>
</item>
<item>
<title>Java升级那么快，多个版本如何灵活切换和管理？ - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/11880130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/11880130.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;近两年，Java 版本升级频繁，感觉刚刚掌握 Java8，写本文时，已听到 java14 的消息，无论是尝鲜新特性(&lt;a href=&quot;https://dayarch.top/p/jdk12-collectors-teeing-api-usage.html&quot;&gt;Java12 中 Collectors.teeing 超强功能使用&lt;/a&gt;)，还是由于项目升级/兼容需要，我们可能都要面临管理多个 Java 版本的情&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;另外 Oracle 自 Java11 开始，更改了用户协议，任何商用都会收费。在写本文时，得到消息「微软宣布加入 OpenJDK」，打不过就选择 OpenJDK。随便 G 一下，当个故事了解就可以&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置单个 Java 环境变量本身没什么技术含量可言，但当需要管理多个 Java 版本，重复配置环境变量显然是非常枯燥的，按照传统的配置方式我们又不能灵活的切换 Java 版本&lt;/p&gt;
&lt;p&gt;那要如何轻松管理与使用多个版本 Java？&lt;/p&gt;
&lt;h2 id=&quot;多版本-java-管理&quot;&gt;多版本 Java 管理&lt;/h2&gt;
&lt;p&gt;显然我们不是第一个有这种困境的人，我所知道的现有方案有三种:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/shyiko/jabba&quot;&gt;Jabba&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jenv/jenv&quot;&gt;jenv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sdkman.io/&quot;&gt;sdkman&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文主要说明如何通过 sdkman 打破我们面临的困境，帮助我们灵活配置与使用 Java&lt;/p&gt;
&lt;h2 id=&quot;sdkman-介绍&quot;&gt;sdkman 介绍&lt;/h2&gt;
&lt;p&gt;SDKMAN 是一个用于在大多数基于 Unix 系统上管理 &lt;strong&gt;多个软件开发工具包&lt;/strong&gt; (Java, Groovy, Scala, Kotlin and Ceylon. Ant, Gradle 等) 的并行版本的工具 。&lt;/p&gt;
&lt;p&gt;它提供了一个方便的命令行接口 (CLI) 和 API，用于&lt;code&gt;安装&lt;/code&gt;、&lt;code&gt;切换&lt;/code&gt;、&lt;code&gt;删除&lt;/code&gt;和&lt;code&gt;列出候选对象&lt;/code&gt;。本文主要通过管理 Java 来说明 sdkman 的使用&lt;/p&gt;
&lt;h2 id=&quot;sdkman-安装&quot;&gt;sdkman 安装&lt;/h2&gt;
&lt;p&gt;在类 unix 平台上安装 sdkman 非常容易。它可以顺利的安装在Mac OSX、Linux、WLS、Cygwin、Solaris和FreeBSD 上，同时还支持Bash和 ZSH shell。&lt;/p&gt;
&lt;p&gt;只需打开一个新终端机并输入:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ curl -s &quot;https://get.sdkman.io&quot; | bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照相应的指令提示，完成相应的操作后继续输入:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里我们就可以验证 sdk 的安装版本了:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk version&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083911760-2063740020.jpg&quot; alt=&quot;sdk version&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图红色框标记显示我当前 sdkman 的版本，每次执行 &lt;code&gt;sdk version&lt;/code&gt; 命令时，都会检查是否会有新版本，如果要更新输入 &lt;code&gt;y&lt;/code&gt; 就可以&lt;/p&gt;
&lt;p&gt;有些系统发行版本不包含 &lt;code&gt;zip&lt;/code&gt; 和 &lt;code&gt;unzip&lt;/code&gt;，如果安装时遇到相关错误，可以输入如下命令安装 &lt;code&gt;zip&lt;/code&gt; 和 &lt;code&gt;unzip&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo apt-get install zip unzip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的安装命令上可以看出，sdkman 默认的安装路径是在&lt;code&gt;$HOME/.sdkman&lt;/code&gt; 下，我们也可以自定义安装路径，只需要指定 &lt;code&gt;SDKMAN_DIR&lt;/code&gt; 变量值就好了:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ export SDKMAN_DIR=&quot;/usr/local/sdkman&quot; &amp;amp;&amp;amp; curl -s &quot;https://get.sdkman.io&quot; | bash
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里 sdkman 的安装就结束了，我们来看看如何使用&lt;/p&gt;
&lt;h2 id=&quot;sdkman-使用教程&quot;&gt;sdkman 使用教程&lt;/h2&gt;
&lt;p&gt;命令行下学习一个新玩意当然是查看它的 help 命令，输入:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdkman help&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083916257-1407053924.jpg&quot; alt=&quot;sdk help&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感觉上图按颜色区分内容后，sdkman 的使用说明也就结束了，我们按照上面的图来详细说明一下使用教程&lt;/p&gt;
&lt;h3 id=&quot;sdk-list&quot;&gt;sdk list&lt;/h3&gt;
&lt;p&gt;先来输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sdk list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083927277-920533277.jpg&quot; alt=&quot;sdk list&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绿色的标记就是 sdkman 集成的所有可用的 candidate，通过按回车「enter」按键，会看到更多可用 candidate&lt;/p&gt;
&lt;p&gt;我们指定 candidate，输入:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk list java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083932946-524640440.jpg&quot; alt=&quot;sdk list java&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看到所有 java 可用的版本 version，以及标识 indentifier，以及状态 status，我已经安装了 java 12 和 11&lt;/p&gt;
&lt;p&gt;有了这些信息做铺垫，我们可以安装任意 sdkman 内置的软件开发包了，继续以 java 为例&lt;/p&gt;
&lt;h3 id=&quot;sdk-install&quot;&gt;sdk install&lt;/h3&gt;
&lt;p&gt;回看 sdkman help 命令的输出，使用 install 命令，我们再安装一个 Java 最新 &lt;code&gt;13.0.1.j9&lt;/code&gt; 版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083934909-685877738.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图你可以看出，绿色标记的内容是 list 命令结果中的 version 值，但是报错不可用，输入&lt;code&gt;indentifier&lt;/code&gt; 编号才能正常下载，这里需要注意&lt;/p&gt;
&lt;p&gt;安装完后，status 就会编程 installed 状态&lt;/p&gt;
&lt;h3 id=&quot;sdk-current&quot;&gt;sdk current&lt;/h3&gt;
&lt;p&gt;当安装多个版本的 java 时，我们输入下面命令获取当前正在用 candidate 的版本&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk current java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083935496-2056679227.jpg&quot; alt=&quot;sdk current java&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sdk-use&quot;&gt;sdk use&lt;/h3&gt;
&lt;p&gt;了解了当前使用版本，如果我们想切换到其他版本, 可以输入:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk use java 12.0.2.j9-adpt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意⚠️: 这里同样是指定的 indentifier 的值&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083936089-1864594049.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sdk-default&quot;&gt;sdk default&lt;/h3&gt;
&lt;p&gt;如果我们想指定某个版本为默认版本，可以输入:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk default java jdk1.8.0_162.jdk&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意⚠️: 这里同样是指定的 indentifier 的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083936675-2115111016.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sdk-uninstall&quot;&gt;sdk uninstall&lt;/h3&gt;
&lt;p&gt;当我们想卸载某个版本可以输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sdk uninstall java 12.0.2.j9-adpt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意⚠️: 这里同样是指定的 indentifier 的值&lt;/p&gt;
&lt;h3 id=&quot;sdk-upgrade&quot;&gt;sdk upgrade&lt;/h3&gt;
&lt;p&gt;如果我们想升级某个 candidate，可以输入:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk upgrade java&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sdk-flush&quot;&gt;sdk flush&lt;/h3&gt;
&lt;p&gt;使用 sdkman 时间变长也会慢慢产生很多缓存内容，我们可以输入&lt;br/&gt;清理广播消息:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk flush broadcast&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清理下载的 sdk 二进制文件(长时间使用后清理，可以节省出很多空间):&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk flush archives&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清理临时文件内容:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sdk flush temp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里 sdkman 的基本使用就已经介绍完了，其实这些命令都不用急，想不起来的时候执行 &lt;code&gt;sdk help&lt;/code&gt; 来临时查看一下就好&lt;/p&gt;
&lt;h2 id=&quot;sdkman-卸载&quot;&gt;sdkman 卸载&lt;/h2&gt;
&lt;p&gt;如果我们不喜欢 sdkman 了，我们也可以轻松的卸载掉它:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ tar zcvf ~/sdkman-backup_$(date +%F-%kh%M).tar.gz -C ~/ .sdkman
$ rm -rf ~/.sdkman&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后打开你的 .bashrc、.bash_profile 和/或者 .profile，找到并删除下面这几行。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!
[[ -s &quot;/home/dudette/.sdkman/bin/sdkman-init.sh&quot; ]] &amp;amp;&amp;amp; source &quot;/home/dudette/.sdkman/bin/sdkman-init.sh&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我用的 zshrc，找到 .zshrc 文件删除掉上面内容即可&lt;/p&gt;
&lt;p&gt;到这里基于 Unix 系统的，有关 sdkman 的安装，使用及下载都已经介绍完了，可以上手试一试了，相信很多小伙伴用的是 Windows，除了 jenv， sdkman 和 Jabba 都有 windows 用户的解决方案:&lt;/p&gt;
&lt;h2 id=&quot;sdkman-windows-解决方案&quot;&gt;sdkman windows 解决方案&lt;/h2&gt;
&lt;p&gt;在 sdkman 官网首页同样为 windows 用户提供了解决方案，小伙伴们找到如下位置查看即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083938952-1092552602.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我看了一下过程，也是很简单，由于手头没有 windows 电脑，这个请小伙伴们自行尝试吧，有问题欢迎留言&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;你现在用的 Java 版本是多少？&lt;/li&gt;
&lt;li&gt;有跟随新版本尝试更多新特性吗？&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;你的灯还亮着吗？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号日拱一兵&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总 | 回复「工具」&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取 | 回复「资料」&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201911/1583165-20191118083943459-1525410464.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 00:40:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>前言 近两年，Java 版本升级频繁，感觉刚刚掌握 Java8，写本文时，已听到 java14 的消息，无论是尝鲜新特性( 'Java12 中 Collectors.teeing 超强功能使用' )，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/11880130.html</dc:identifier>
</item>
<item>
<title>Android Debug 之 Log 最佳实践 - 安卓小煜</title>
<link>http://www.cnblogs.com/nesger/p/11880128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nesger/p/11880128.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文微信公众号「AndroidTraveler」首发。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;在开发过程中，调试是必不可少的一项工作。&lt;/p&gt;
&lt;p&gt;当我们要确定项目的逻辑时，当我们要了解界面的生命周期时，当我们发现新写的逻辑与期望效果不一致时，当我们觉得数据有问题时......&lt;/p&gt;
&lt;p&gt;而调试有两种方式：&lt;/p&gt;
&lt;p&gt;第一种就是使用 debug 模式运行 APP，然后通过断点让程序运行到指定位置进行分析。&lt;/p&gt;
&lt;p&gt;第二种就是打日志的方式，通过观察输出来确定程序是否运行到该位置以及此时的数据。&lt;/p&gt;
&lt;p&gt;本篇文章主要聚焦在第二种方式上面。&lt;/p&gt;
&lt;p&gt;在 Android 里面，打日志使用的系统 API 是 Log，你以为直接使用就完了吗？&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;封装&lt;/h3&gt;
&lt;p&gt;假设你在需要打印日志的地方直接使用系统的 API，那么当遇到下面情况时，会「牵一发而动全身」。&lt;/p&gt;
&lt;p&gt;场景一：如果我打印日志要用三方库的日志 API，那么我要查找项目所有使用位置，并一一替换。&lt;/p&gt;
&lt;p&gt;场景二：如果我希望在开发环境下打印日志，release 环境不打印，这个时候每个位置都需要单独做处理。&lt;/p&gt;
&lt;p&gt;因此我们需要在使用 Log 进行日志打印之前，做一层封装。&lt;/p&gt;
&lt;p&gt;假设我们的类名字为 ZLog，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import android.util.Log;

/**
 * Created on 2019-10-26
 *
 * @author Zengyu.Zhan
 */
public class ZLog {
    public static int v(String tag, String msg) {
        return Log.v(tag, msg);
    }

    public static int d(String tag, String msg) {
        return Log.d(tag, msg);
    }

    public static int i(String tag, String msg) {
        return Log.i(tag, msg);
    }

    public static int w(String tag, String msg) {
        return Log.w(tag, msg);
    }

    public static int e(String tag, String msg) {
        return Log.e(tag, msg);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样处理之后，对于场景一和场景二，我们需要修改的只是 ZLog 这个类，而不需要到具体使用 ZLog 的所有地方去修改。&lt;/p&gt;
&lt;h3 id=&quot;提供日志打印控制&quot;&gt;提供日志打印控制&lt;/h3&gt;
&lt;p&gt;我们知道，日志打印可能包含敏感信息，而且过多的日志打印可能影响 APP 的性能，因此我们一般是在开发时候打开日志，在发布 APP 之前关闭。&lt;/p&gt;
&lt;p&gt;因此我们这边需要提供一个标志位来控制日志的打印与否。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import android.util.Log;

/**
 * Created on 2019-10-26
 *
 * @author Zengyu.Zhan
 */
public class ZLog {
    private static boolean isDebugMode = false;
    public static void setDebugMode(boolean debugMode) {
        isDebugMode = debugMode;
    }

    public static int v(String tag, String msg) {
        return isDebugMode ? Log.v(tag, msg) : -1;
    }

    public static int d(String tag, String msg) {
        return isDebugMode ? Log.d(tag, msg) : -1;
    }

    public static int i(String tag, String msg) {
        return isDebugMode ? Log.i(tag, msg) : -1;
    }

    public static int w(String tag, String msg) {
        return isDebugMode ? Log.w(tag, msg) : -1;
    }

    public static int e(String tag, String msg) {
        return isDebugMode ? Log.e(tag, msg) : -1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认是不开启日志打印，避免开发者忘记设置。&lt;/p&gt;
&lt;h3 id=&quot;普通日志和奔溃栈系统日志在控制台的输出对比&quot;&gt;普通日志和奔溃栈系统日志在控制台的输出对比&lt;/h3&gt;
&lt;p&gt;现在我们在 APP 里面使用 ZLog 打印日志，代码为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ZLog.setDebugMode(true);
ZLog.e(&quot;ZLog&quot;, &quot;just test&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/28/16e10b5ea3882c0c?w=1730&amp;amp;h=66&amp;amp;f=png&amp;amp;s=18549&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们现在增加如下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String nullString = null;
if (nullString.equals(&quot;null&quot;)) {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后控制台会显示空指针异常奔溃栈，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/28/16e10c3cbac99824?w=2608&amp;amp;h=100&amp;amp;f=png&amp;amp;s=43513&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到奔溃栈信息会显示具体是哪个文件出现了空指针，以及具体哪一行。在我们这个例子里面就是 &lt;strong&gt;MainActivity.java&lt;/strong&gt; 的 &lt;strong&gt;24&lt;/strong&gt; 行。&lt;/p&gt;
&lt;p&gt;而且点击蓝色链接光标会直接定位到错误位置。&lt;/p&gt;
&lt;p&gt;如果我们普通的日志也可以点击就跳转到对应位置，对于我们开发来说效率是有很大提升的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/28/16e123bf742de652?w=392&amp;amp;h=426&amp;amp;f=png&amp;amp;s=95153&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;zloghelper&quot;&gt;ZLogHelper&lt;/h3&gt;
&lt;p&gt;既然奔溃栈里面有链接可以跳转，那么我们可以通过栈信息来获取日志的打印位置。&lt;/p&gt;
&lt;p&gt;我们直接上代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZLogHelper {
    private static final int CALL_STACK_INDEX = 1;
    private static final Pattern ANONYMOUS_CLASS = Pattern.compile(&quot;(\\$\\d+)+$&quot;);

    public static String wrapMessage(int stackIndex, String message) {
        // DO NOT switch this to Thread.getCurrentThread().getStackTrace().
        if (stackIndex &amp;lt; 0) {
            stackIndex = CALL_STACK_INDEX;
        }
        StackTraceElement[] stackTrace = new Throwable().getStackTrace();
        if (stackTrace.length &amp;lt;= stackIndex) {
            throw new IllegalStateException(
                    &quot;Synthetic stacktrace didn't have enough elements: are you using proguard?&quot;);
        }
        String clazz = extractClassName(stackTrace[stackIndex]);
        int lineNumber = stackTrace[stackIndex].getLineNumber();
        message = &quot;.(&quot; + clazz + &quot;.java:&quot; + lineNumber + &quot;) - &quot; + message;
        return message;
    }

    /**
     * Extract the class name without any anonymous class suffixes (e.g., {@code Foo$1}
     * becomes {@code Foo}).
     */
    private static String extractClassName(StackTraceElement element) {
        String tag = element.getClassName();
        Matcher m = ANONYMOUS_CLASS.matcher(tag);
        if (m.find()) {
            tag = m.replaceAll(&quot;&quot;);
        }
        return tag.substring(tag.lastIndexOf('.') + 1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们对外提供一个 wrapMessage 方法，看名字就知道是对 Message 进行包装。&lt;/p&gt;
&lt;p&gt;方法里面也是对 StackTraceElement 进行分析。&lt;/p&gt;
&lt;p&gt;这边还做了一个控制，避免 stackIndex 出现负数情况。&lt;/p&gt;
&lt;p&gt;可能有小伙伴会好奇，为什么要把 stackIndex 对外开放呢？&lt;/p&gt;
&lt;p&gt;因为你打印日志的地方不一样，这里的 stackIndex 也需要对应调整。&lt;/p&gt;
&lt;p&gt;方法里面是对 StackTraceElement 做处理，而 StackTraceElement 跟你的方法层级有关系。&lt;/p&gt;
&lt;p&gt;我们以最常用的两种日志打印形式为例，来说明这里的 stackIndex 要怎么传递，以及这个 ZLogHelper 的用法。&lt;/p&gt;
&lt;h4 id=&quot;直接代码使用&quot;&gt;直接代码使用&lt;/h4&gt;
&lt;p&gt;我们在 MainActivity.java 中直接使用，stackIndex 传入 1 即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Log.e(&quot;ZLog&quot;, ZLogHelper.wrapMessage(1, &quot;just test&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/28/16e1270b9240b134?w=1064&amp;amp;h=56&amp;amp;f=png&amp;amp;s=14766&quot;/&gt;&lt;br/&gt;可以看到代码所在的类和行数到显示为链接文本，点击会定位到具体的位置。&lt;/p&gt;
&lt;h4 id=&quot;做了封装的情况&quot;&gt;做了封装的情况&lt;/h4&gt;
&lt;p&gt;一般我们对 Log 都会做封装，因此假设我们有一个 LogUtils 类，我们在 MainActivity.java 里面调用。&lt;/p&gt;
&lt;p&gt;LogUtils.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class LogUtils {
    public static  void loge() {
        Log.e(&quot;ZLog&quot;, ZLogHelper.wrapMessage(2, &quot;just test&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainActivity.java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LogUtils.loge();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看下结果，再来分析。控制台输出如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/28/16e1270e12ff4fdb?w=1084&amp;amp;h=64&amp;amp;f=png&amp;amp;s=16170&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到确实定位到了 MainActivity.java 中的具体使用地方。&lt;/p&gt;
&lt;p&gt;那么为什么这里传入的 stackIndex 跟第一种不一样，是 2 而不是 1 呢？&lt;/p&gt;
&lt;p&gt;其实答案很简单，你改为 1 之后，输出的控制台显示的会定位到 LogUtils 里面的日志打印语句处。在这里就是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Log.e(&quot;ZLog&quot;, ZLogHelper.wrapMessage(2, &quot;just test&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以其实你可以看出一个规律，而这个从代码也可以发现。&lt;/p&gt;
&lt;p&gt;因为代码里面解析调用位置是根据栈来的，对 StackTraceElement 进行分析，因此情况一直接使用，传入 1。而情况二多了一层函数调用，通过 loge 方法做了一层包装。因此需要传入 2。如果你再套一层，那么需要传入 3。了解了这一点，我们下面的工具类相信你就看得懂了。&lt;/p&gt;
&lt;h3 id=&quot;zlog&quot;&gt;ZLog&lt;/h3&gt;
&lt;p&gt;如果你不想自己手动传入 stackIndex，可以直接使用我们提供的工具类 ZLog。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZLog {
    private static boolean isDebugMode = false;
    public static void setDebugMode(boolean debugMode) {
        isDebugMode = debugMode;
    }

    private static boolean isLinkMode = true;
    public static void setLinkMode(boolean linkMode) {
        isLinkMode = linkMode;
    }

    private static final int CALL_STACK_INDEX = 3;

    public static int v(String tag, String msg) {
        return isDebugMode ? Log.v(tag, mapMsg(msg)) : -1;
    }

    public static int d(String tag, String msg) {
        return isDebugMode ? Log.d(tag, mapMsg(msg)) : -1;
    }

    public static int i(String tag, String msg) {
        return isDebugMode ? Log.i(tag, mapMsg(msg)) : -1;
    }

    public static int w(String tag, String msg) {
        return isDebugMode ? Log.w(tag, mapMsg(msg)) : -1;
    }

    public static int e(String tag, String msg) {
        return isDebugMode ? Log.e(tag, mapMsg(msg)) : -1;
    }

    private static String mapMsg(String msg) {
        return isLinkMode ? ZLogHelper.wrapMessage(CALL_STACK_INDEX, msg) : msg;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相信有了前面的知识，小伙伴对于这里为什么传入 3 应该了解了。&lt;/p&gt;
&lt;p&gt;1 的话会定位到&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;return isLinkMode ? ZLogHelper.wrapMessage(CALL_STACK_INDEX, msg) : msg;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2 的话(以 e 为例)会定位到&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;return isDebugMode ? Log.e(tag, mapMsg(msg)) : -1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3 的话才能够定位到外面具体的调用处。&lt;/p&gt;
&lt;h3 id=&quot;优化&quot;&gt;优化&lt;/h3&gt;
&lt;p&gt;我们知道，虽然 ZLog 做了封装，但是我们每次打日志都要传入 ZLog，有点麻烦？&lt;/p&gt;
&lt;p&gt;能否提供一个默认的 TAG，允许对外设置。&lt;/p&gt;
&lt;p&gt;可以的，我们修改如下(以 e 为例)：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static String tag = &quot;ZLOG&quot;;
public static void setTag(String tag) {
    if (!TextUtils.isEmpty(tag)) {
        ZLog.tag = tag;
    }
}

public static int e(String tag, String msg) {
    return isDebugMode ? Log.e(mapTag(tag), mapMsg(msg)) : -1;
}

public static int e(String msg) {
    return isDebugMode ? Log.e(tag, mapMsg(msg)) : -1;
}

private static String mapTag(String tag) {
    return TextUtils.isEmpty(tag) ? ZLog.tag : tag;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;项目实战&quot;&gt;项目实战&lt;/h3&gt;
&lt;p&gt;按照下面两步引入开源库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1. Add the JitPack repository to your build file&lt;/strong&gt;&lt;br/&gt;Add it in your root build.gradle at the end of repositories:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;allprojects {
  repositories {
    ...
    maven { url 'https://jitpack.io' }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 2. Add the dependency&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;dependencies {
  implementation 'com.github.nesger:AndroidWheel:1.0.0'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用时先打开开关：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ZLog.setDebugMode(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以直接使用了。&lt;/p&gt;
&lt;h3 id=&quot;温馨提示&quot;&gt;温馨提示&lt;/h3&gt;
&lt;p&gt;由于带链接的 debug 对性能有一定影响，因此建议开发使用，上线关闭。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;这边在完善一个开源仓库 &lt;a href=&quot;https://github.com/nesger/AndroidWheel&quot;&gt;AndroidWheel&lt;/a&gt;，跟名字一样，避免重复造轮子。&lt;/p&gt;
&lt;p&gt;目前 1.0.0 版本提供日志相关工具类，1.0.1 增加了防抖动 EditText。&lt;/p&gt;
&lt;p&gt;后续会继续更新迭代，功能会更完善更全面。&lt;/p&gt;
&lt;p&gt;觉得不错，欢迎给个 &lt;strong&gt;star&lt;/strong&gt; 哈～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://medium.com/@tauno/android-studio-pro-tip-go-to-source-from-logcat-output-f13bf46411b5&quot;&gt;Android Studio Pro Tip: go to source from logcat output&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/5/16bc08e14696aba3?w=900&amp;amp;h=500&amp;amp;f=png&amp;amp;s=231181&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 00:38:00 +0000</pubDate>
<dc:creator>安卓小煜</dc:creator>
<og:description>本文微信公众号「AndroidTraveler」首发。 背景 在开发过程中，调试是必不可少的一项工作。 当我们要确定项目的逻辑时，当我们要了解界面的生命周期时，当我们发现新写的逻辑与期望效果不一致时，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nesger/p/11880128.html</dc:identifier>
</item>
<item>
<title>怎么把CAT客户端的RootMessageId记录到每条日志中？ - 万猫学社</title>
<link>http://www.cnblogs.com/heihaozi/p/11868528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heihaozi/p/11868528.html</guid>
<description>&lt;h3 id=&quot;什么是rootmessageid&quot;&gt;什么是RootMessageId？&lt;/h3&gt;
&lt;p&gt;为了理解RootMessageId先简单介绍一下CAT的数据结构设计。CAT客户端会将所有消息都封装为一个完整的消息树（MessageTree），消息树可能包括Transaction、Event、Heartbeat、Metric等类型的消息。具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Transaction：适合记录跨越系统边界的程序访问行为,比如远程调用，数据库调用，也适合执行时间较长的业务逻辑监控，Transaction用来记录一段代码的执行时间和次数&lt;/li&gt;
&lt;li&gt;Event：用来记录一件事发生的次数，比如记录系统异常，它和transaction相比缺少了时间的统计，开销比transaction要小&lt;/li&gt;
&lt;li&gt;Heartbeat：表示程序内定期产生的统计信息, 如CPU利用率, 内存利用率, 连接池状态, 系统负载等&lt;/li&gt;
&lt;li&gt;Metric：用于记录业务指标、指标可能包含对一个指标记录次数、记录平均值、记录总和，业务指标最低统计粒度为1分钟&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，Transaction类型的消息可作为消息树节点，而其他消息只可作为消息树的叶子节点，也就是Transaction是一个可嵌套的递归结构。比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/145687/201911/145687-20191115175147379-733473309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息树的每一节点都有一个属性messageId，用来唯一表示节点本身，其构成为：{domain}-{ip}-{timestamp}-{自增index}。另外还有两个属性，分别是parentMessageId, rootMessageId。parentMessageId表示父节点的messageId；&lt;strong&gt;rootMessageId&lt;/strong&gt;则表示整个消息树的根节点的messageId。这两个属性在之后CAT的调用链分析与分布式调用链分析中发挥了关键作用。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么在日志中记录&quot;&gt;为什么在日志中记录？&lt;/h3&gt;
&lt;p&gt;根据RootMessageId可以追踪某一个请求的整个分布式调用链，结合每一条日志快速定位耗费性能的症结，做针对性的性能优化。更加方便地做性能优化，特别是TP95、TP99等指标。&lt;/p&gt;
&lt;p&gt;遇到偶尔发生的bug，是最让人头疼的，只有先从日志中找线索，但是在海量的日志中找到出现bug的那一个请求是很困难的。有了上游API提供的RootMessageId，就可以快速过滤出那次请求的所有日志， 更快速更方便地定位线上bug。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;在日志的什么地方记录&quot;&gt;在日志的什么地方记录？&lt;/h3&gt;
&lt;p&gt;当然是每一句日志上都记录RootMessageId了。有的同学会说，这日志也记录的太多了。当发现线上问题无法定位时，你就会狠日志太少了。其实记录日志不怕多，就怕不全。现在硬盘很便宜了，搞个几T没有问题，另外还可以设置日志清理策略。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;怎么记录到日志中&quot;&gt;怎么记录到日志中？&lt;/h3&gt;
&lt;p&gt;前面说了那么多，终于到了今天的压轴大戏了。实现记录到日志有很多种方式，这里使用的是MDC（Mapped Diagnostic Contexts）。顾名思义，其目的是为了便于我们诊断线上问题而出现的方法工具类，目前我们经常使用的logback和log4j都是支持的。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;只需要在每个请求的入口调用MDC.put方法，把rootMessageId赋值进去就可以了，是不是很简单？示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//在Filter里，从header里获取上下文信息，包括messageId、parentMessageId、rootMessageId
CatContext catContext = new CatContext();
catContext.addProperty(Cat.Context.ROOT, request.getHeader(CatConstants.CAT_HTTP_HEADER_ROOT_MESSAGE_ID));
catContext.addProperty(Cat.Context.PARENT, request.getHeader(CatConstants.CAT_HTTP_HEADER_PARENT_MESSAGE_ID));
catContext.addProperty(Cat.Context.CHILD, request.getHeader(CatConstants.CAT_HTTP_HEADER_CHILD_MESSAGE_ID));
if (catContext.getProperty(Cat.Context.ROOT) == null) {
    //如果调用链的顶端，没有上下文信息，需要生成上下文信息
    Cat.logRemoteCallClient(catContext);
} else {
    Cat.logRemoteCallServer(catContext);
}
MDC.put(&quot;traceId&quot;, catContext.getProperty(Cat.Context.ROOT));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你还不知道怎么集成CAT调用链，可以看看之前的《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88919056&quot;&gt;SpringBoot集成CAT调用链实例&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;然后，在设置日志输出格式的配置文件里增加&lt;code&gt;[%X{traceId}]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Logback的xml配置示例：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;configuration scan=&quot;true&quot;&amp;gt;
    &amp;lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&amp;gt;
            &amp;lt;pattern&amp;gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%X{traceId}] [%-5level] [%-40.36logger{40}:%-4.4line] - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;root level=&quot;INFO&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;CONSOLE&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;log4j的properties配置示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;log4j.rootCategory=INFO,stdout,info,error
log4j.rootLooger=warn,stdout,info,error
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} [%-5p] [%thread] [%X{traceId}]  method:%l - %m%n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 00:32:00 +0000</pubDate>
<dc:creator>万猫学社</dc:creator>
<og:description>在日志中记录RootMessageId，可以更加方便地做性能优化，可以更快速地定位线上bug，那么怎么把CAT客户端的RootMessageId记录到每条日志中？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heihaozi/p/11868528.html</dc:identifier>
</item>
<item>
<title>.NET Core前后端分离快速开发框架(Core.3.0+AntdVue) - 寒空飞箭</title>
<link>http://www.cnblogs.com/coldairarrow/p/11870993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coldairarrow/p/11870993.html</guid>
<description>&lt;p&gt;时间真快，转眼今年又要过去了。回想今年，依次开源发布了&lt;strong&gt;Colder.Fx.Net.AdminLTE(254Star)&lt;/strong&gt;、&lt;strong&gt;Colder.Fx.Core.AdminLTE(335Star)&lt;/strong&gt;、&lt;strong&gt;DotNettySocket(82Star)&lt;/strong&gt;、&lt;strong&gt;IdHelper(47Star)&lt;/strong&gt;，这些框架及组件都是本着以实际出发，实事求是的态度，力求提高开发效率（我自己都是第一个使用者），目前来看反响不错。但是随着前端和后端技术的不断变革，尤其是前端，目前大环境已经是前后端完全分离为主的开发模式，在这样的大环境和必然趋势之下，传统的MVC就显得有些落伍了。在这样的背景下，一款前后端分离的.NET开发框架就显得尤为必要，由此便定了框架的升级目标：&lt;strong&gt;前后端分离&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先后端技术的选择，从目前的数据来看，.NET Core的发展远远快于.NET Framework，最简单的分析就是Colder.Fx.Core.AdminLTE发布比Colder.Fx.Net.AdminLTE晚，但是星星却后来居上而且比前者多30%，并且这个差距在不断扩大，由点及面的分析可以看出我们广大.NET开发人员学习的热情和积极向上的态度，并不是某些人所认为的那么不堪（&lt;strong&gt;走自己的路，让别人说去吧&lt;/strong&gt;）。大环境上微软积极拥抱开源，大力发展.NET Core， 可以说前途一片光明。因此后端决定采用 &lt;strong&gt;.NET Core3.0&lt;/strong&gt; ，不再浪费精力去支持.NET Framework。&lt;/p&gt;
&lt;p&gt;然后是前端技术选择，首选是三大js框架选择，也是从实际出发，Vue相对其它而言更加容易上手，并且功能也毫不逊色，深得各种大小公司喜欢，如果偏要说缺点的话，那就是对TS支持不行，但是即将发布Vue3.0肯定会改变这一缺陷。选择了Vue之后，然后就是UI框架的选择了，这里的选择更多了，我选择了Ant Design Vue，理由便是简洁方便，十分符合我的设计理念。&lt;/p&gt;
&lt;p&gt;技术选型完毕之后便进入研发，由于鄙人前端比较菜，因此需要从头学Vue2.x全家桶，从开始到现在差不多经历3个月，在预期之内。其实学习并使用前端的Vue2.x全家桶并不难，还是比较容易上手的，所以在此给没有前后端分离开发经验的老哥打一记预防针，不要退缩，要知难而上，学习永无止境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;某些老哥可能比较直接粗暴，嫌我BBB唠叨，下面直接上地址&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;代码(GitHub)：&lt;/strong&gt;&lt;a href=&quot;https://github.com/Coldairarrow/Colder.Admin.AntdVue&quot; class=&quot;uri&quot;&gt;https://github.com/Coldairarrow/Colder.Admin.AntdVue&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;文档(GitHub)：&lt;/strong&gt;&lt;a href=&quot;https://github.com/Coldairarrow/Colder.Admin.AntdVue/wiki&quot; class=&quot;uri&quot;&gt;https://github.com/Coldairarrow/Colder.Admin.AntdVue/wiki&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;代码(码云镜像)：&lt;/strong&gt;&lt;a href=&quot;https://gitee.com/Coldairarrow/Colder.Admin.AntdVue&quot; class=&quot;uri&quot;&gt;https://gitee.com/Coldairarrow/Colder.Admin.AntdVue&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;文档(码云镜像)：&lt;/strong&gt;&lt;a href=&quot;https://gitee.com/Coldairarrow/Colder.Admin.AntdVue/wikis&quot; class=&quot;uri&quot;&gt;https://gitee.com/Coldairarrow/Colder.Admin.AntdVue/wikis&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;在线预览地址&lt;/strong&gt;：&lt;a href=&quot;http://coldairarrow.gitee.io/coler.antdvue.preview/#/Home/Introduce&quot; class=&quot;uri&quot;&gt;http://coldairarrow.gitee.io/coler.antdvue.preview/#/Home/Introduce&lt;/a&gt;&lt;br/&gt;由于服务器是阿里云的86服务器，带宽1M小水管，因此将前端部署到码云上了，在此多谢&lt;strong&gt;码云&lt;/strong&gt;，后端部署在阿里云86服务器CentOS7上。整个技术栈使用&lt;strong&gt;.NET Core + PostggreSQL+ Ant Design Vue + CentOS7+Nginx+Dokcer+jenkins&lt;/strong&gt;，囊亏了从快速开发到自动化部署一条龙，开源免费并具有高性能、高移植性、高拓展性（&lt;strong&gt;小公司创业选型+个人接单利器&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;本框架为.NET Core3.0+Ant Design Vue版&lt;/p&gt;
&lt;p&gt;本框架旨在极大的提高开发效率&lt;/p&gt;
&lt;p&gt;使用技术栈：&lt;br/&gt;后端：采用.NET Core平台，ASP.NET Core3.0，C#语言（使用反射等高级技术），Entity FrameworkCore（数据库ORM框架）。&lt;br/&gt;使用数据仓储模式，抽象化数据库操作(CRUD等)、支持事务处理以及分布式事务处理（跨库）&lt;br/&gt;支持数据库读写分离、分库分表及事务(仅支持单表操作,不支持多表) 全面采用Autofac作为IOC容器,面向接口编程,全面解耦&lt;br/&gt;集成多种工具类库以及操作拓展&lt;br/&gt;数据库：支持SqlServer,PostgreSQL,MySQL,Oracle（框架使用简单工厂，工厂方法，抽象工厂，可轻松更换数据库）,Redis作为分布式缓存&lt;br/&gt;前端：Vue2.x全家桶+Ant Design Vue，其中集成常用组件，力求方便项目开发。&lt;/p&gt;
&lt;p&gt;具体技术实施：&lt;br/&gt;项目采用前后端完全分离模式，并采用严格分层模式，极大的增加聚合度，降低耦合度，&lt;br/&gt;提高代码的健壮性，可维护性。&lt;br/&gt;前后端通过JWT进行身份验证,通过数据接口操作数据，统一使用JSON作为数据格式，并使用默认接口签名算法保证接口的安全性。&lt;/p&gt;
&lt;p&gt;功能架构部分详解：&lt;br/&gt;快速开发：此功能为框架的核心，通过选择数据库中的表，就能自动生成对应的实体层、业务逻辑层、控制器、前端页面Vue文件，无需编写代码即可生成基本的CRUD操作。&lt;br/&gt;接口密钥管理：管理接口的密钥，若开启接口签名的规则，则前端需要通过给接口签名才能够正常访问后台接口。&lt;br/&gt;权限管理：使用基本的RBAC权限控制，支持操作权限、接口权限以及数据权限&lt;/p&gt;
&lt;p&gt;框架主要功能及特色如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;用户登录&lt;/td&gt;
&lt;td&gt;用户登录、密码修改&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;系统用户管理&lt;/td&gt;
&lt;td&gt;系统用户管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;角1色管理&lt;/td&gt;
&lt;td&gt;角色管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;部门管理&lt;/td&gt;
&lt;td&gt;部门管理、天然多级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;权限管理&lt;/td&gt;
&lt;td&gt;使用RBAC权限体系，基于角色的权限管理，支持菜单权限、操作权限（按钮权限）、接口权限、数据权限&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;系统日志&lt;/td&gt;
&lt;td&gt;支持多彩控制台、文件、数据库和ElasticSearch记录日志，框架全局异常自动捕捉，多级别记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;快速开发&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;通过数据库直接生成实体层、业务逻辑层、控制器层以及前端页面Vue代码，无需编码即可实现CURD&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;数据库操作封装&lt;/td&gt;
&lt;td&gt;使用基于EF的仓储模式、封装常用的CURD，支持单库事物和分布式事物&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;多数据库支持&lt;/td&gt;
&lt;td&gt;使用基于EF的仓储模式，支持各大主流关系型数据库（SQLServer、MySQL、PostgreSQL和Oracle）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;超强移植性&lt;/td&gt;
&lt;td&gt;使用抽象工厂封装数据库操作层，切换数据库&lt;strong&gt;0&lt;/strong&gt;代码修改&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;支持&lt;strong&gt;软删除&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;一键切换删除模式，支持物理删除和软删除，对业务操作透明&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;缓存支持&lt;/td&gt;
&lt;td&gt;支持系统自带缓存和Redis缓存、封装操作接口、简单易用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;前后端完全分离&lt;/td&gt;
&lt;td&gt;前端使用Vue2.x全家桶+Ant Design Vue，界面简洁美观，组件化开发&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;集成JWT验证&lt;/td&gt;
&lt;td&gt;框架使用JWT作为身份验证，摆脱Cookie苦海，分布式拓展毫无压力&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;集成对外接口签名算法&lt;/td&gt;
&lt;td&gt;框架对外接口可以开启超强严格签名校验（防抵赖、防伪造、防重复调用）,保障系统安全性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;页面响应式&lt;/td&gt;
&lt;td&gt;前端为单页应用，无iframe，各大主流浏览器支持友好&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;拓展&lt;/td&gt;
&lt;td&gt;其它各种帮助类库及插件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其相关版本请看下表：&lt;/p&gt;
&lt;p&gt;后台效果展示如下：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MG22Bd.png&quot; alt=&quot;MG22Bd.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;开发环境要求&quot;&gt;开发环境要求：&lt;/h2&gt;
&lt;p&gt;操作系统：Windows 10&lt;br/&gt;后端开发工具：Visual Studio 2019+&lt;br/&gt;前端开发工具：Visual Studio Code,安装&lt;strong&gt;nodejs&lt;/strong&gt;,&lt;strong&gt;yarn&lt;/strong&gt;&lt;br/&gt;SDK：安装.NET Core SKD 3.0 及以上&lt;br/&gt;数据库：SQLServer2008 R2及以上&lt;/p&gt;
&lt;h2 id=&quot;基础数据库构建&quot;&gt;基础数据库构建：&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据库创建&lt;br/&gt;目录&quot;/docs/初始化文件&quot;中有所需的数据库资料&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MGo70U.png&quot; alt=&quot;MGo70U.png&quot;/&gt;&lt;br/&gt;先手动创建数据库，然后执行对应的SQL脚本即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;连接字符串配置&lt;br/&gt;打开src目录下Colder.Admin.AntdVue的解决方案，如下图&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MGTuB8.png&quot; alt=&quot;MGTuB8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下图所示依次展开05.Coldairarrow.Api/appsettings.json，配置数据库连接字符串，name不用修改，connectionString改为上述创建的数据库（若不清楚数据库连接字符串请自行百度搜索教程）&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/22/Z9fYjI.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据库设计规范&quot;&gt;数据库设计规范&lt;/h2&gt;
&lt;p&gt;由于本框架支持自动生成代码的核心功能，此功能是根据数据库的表结构来生成代码的&lt;br/&gt;因此规定每张表都有一个主键，列名为Id，类型为字符串，实际添加数据时默认使用SnowflakeId(雪花Id,Twitter设计的分布式趋势自增Id,若不清楚请自行百度相关资料)，表中的每个列都需要有描述信息（建议这样操作，若不按照这个标准则需要一些额外的改动才能够成功运行）。每张表都需要&lt;strong&gt;Id、CreateTime、CreatorId、CreatorRealName&lt;/strong&gt;这几个必带字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MG7p2n.png&quot; alt=&quot;MG7p2n.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行&quot;&gt;运行&lt;/h2&gt;
&lt;p&gt;后端：打开解决方案=&amp;gt;还原nuget包=&amp;gt;配置数据库=&amp;gt;运行（05.Coldairarrow.Web设为启动项目）&lt;br/&gt;后台成功运行后会自动打开swagger&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MGHcTO.png&quot; alt=&quot;MGHcTO.png&quot;/&gt;&lt;br/&gt;前端： 确保已安装&lt;strong&gt;nodejs&lt;/strong&gt;和&lt;strong&gt;yarn&lt;/strong&gt;&lt;br/&gt;用VS Code 打开文件夹src\Coldairarrow.Web&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MGHEOP.png&quot; alt=&quot;MGHEOP.png&quot;/&gt;&lt;br/&gt;输入命令：&lt;strong&gt;yarn&lt;/strong&gt;&lt;br/&gt;输入命令：&lt;strong&gt;yarn run serve&lt;/strong&gt;&lt;br/&gt;成功运行后即可打开登录页面&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MGH56I.png&quot; alt=&quot;MGH56I.png&quot;/&gt;&lt;br/&gt;输入账号：Admin，密码：123456进入后台主页&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MG22Bd.png&quot; alt=&quot;MG22Bd.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;全局配置&quot;&gt;全局配置&lt;/h2&gt;
&lt;p&gt;在01.Coldairarrow.Util中的GlobalSwitch类中，设置了各个参数，其中&lt;strong&gt;RunModel&lt;/strong&gt;与&lt;strong&gt;DatabaseType&lt;/strong&gt;需要重点关注一下，其它参数请看注释。&lt;/p&gt;
&lt;h2 id=&quot;快速开发&quot;&gt;快速开发&lt;/h2&gt;
&lt;p&gt;此功能为本框架的核心功能，能够自动生产完整的可运行代码，具体使用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置数据源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首选需要有数据库源，因为代码生成是根据数据库表来生成的。&lt;br/&gt;菜单：开发=&amp;gt;数据库连接&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYpg8P.png&quot; alt=&quot;MYpg8P.png&quot;/&gt;&lt;br/&gt;若列表中没有目标数据源，则添加数据库连接&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYphDg.png&quot; alt=&quot;MYphDg.png&quot;/&gt;&lt;br/&gt;数据连接名、连接字符串、数据库类型即可。添加完成后即可看到连接字符串信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了数据库连接之后，即可进行代码生成。&lt;br/&gt;菜单：开发=&amp;gt;代码生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYpb80.png&quot; alt=&quot;MYpb80.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择数据库，然后勾选需要生成代码的数据库表，点击生成代码会弹出生成选项（这里演示勾选 Base_BuildTest，其余表全是系统基础表，不要勾选，否则会被覆盖，导致异常，请勾选自己的业务表进行生成）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYi3M6.png&quot; alt=&quot;MYi3M6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成选项中可以选择需要生成的类型，默认生成全部：实体层、业务层、接口层（即控制器）和页面（Vue前端页面代码）。&lt;br/&gt;生成区域请输入业务模块名（例如系统叫Base_Manage），请按具体业务填入（必填）&lt;br/&gt;这里示例填写TestManage，点击生成按钮，即可完成代码生成。生成后的代码在项目解决方案中，将代码文件包括进入项目&lt;/p&gt;
&lt;p&gt;默认生成后的文件会被自动包括到解决方案中，若没有则需要点击显示所有文件按钮，即可看到生成后的新文件&lt;/p&gt;
&lt;p&gt;生成的实体层、业务逻辑层、控制器层代码：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYiWJs.png&quot; alt=&quot;MYiWJs.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYFAfA.png&quot; alt=&quot;MYFAfA.png&quot;/&gt;&lt;br/&gt;前端生成的代码：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYiXWR.png&quot; alt=&quot;MYiXWR.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后端代码添加后需要重新编译下（F7），编译后好可以看到有新的接口&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYQYcD.png&quot; alt=&quot;MYQYcD.png&quot;/&gt;&lt;br/&gt;前端生成代码后会自动保存并编译（别的文件修改保存也会自动编译，毕竟编译一次挺慢的），不放心可以Ctrl+C停止，然后再yarn run serve重新运行&lt;/p&gt;
&lt;p&gt;代码生成完毕，但是要展示到菜单上需要进行配置，并且所有业务菜单都是动态的（权限控制）&lt;br/&gt;打开菜单：系统管理=&amp;gt;权限管理=&amp;gt;新建&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYPsUJ.png&quot; alt=&quot;MYPsUJ.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYFUmT.png&quot; alt=&quot;MYFUmT.png&quot;/&gt;&lt;br/&gt;菜单名：即需要显示的菜单名&lt;br/&gt;上级菜单：菜单是多级树状的，可以放在某个菜单下面&lt;br/&gt;类型：可以选择菜单或页面，这里是具体的页面，所以选页面&lt;br/&gt;路径：页面的路径，菜单可以不配置，这里配置为/TestManage/Base_BuildTest/List，这里设置规则为：views文件夹为根路径（即&quot;/&quot;），向下展开依次为/TestManage/Base_BuildTest/List，最后真正的列表页为List.vue文件，表单页为EditForm.vue文件&lt;br/&gt;是否需要权限：若为“否”，则此页面不限制权限，即所有人都能看&lt;br/&gt;图标：菜单显示图标，具体到开发=&amp;gt;图标选择页进行选择&lt;br/&gt;排序：若需要需要对菜单进行排序则设置，默认0，类型为int&lt;br/&gt;页面权限：页面拥有的权限（权限值唯一，作为操作权限即接口权限的依据），详见&lt;strong&gt;权限管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确认保存，然后刷新整个页面（F5），即可看到全新生成的菜单“生成测试”&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYkvqK.png&quot; alt=&quot;MYkvqK.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYAFxI.png&quot; alt=&quot;MYAFxI.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYAVqf.png&quot; alt=&quot;MYAVqf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个代码生成过程，无需编写代码即可完成一张表的CRUD，当然需要根据具体业务中进行相应的修改，本次示例中字段比较少，但是当一张表的字段很多时，那么此功能能够将开发效率提高几个档次。&lt;/p&gt;
&lt;h2 id=&quot;管理员登录&quot;&gt;管理员登录&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MGH56I.png&quot; alt=&quot;MGH56I.png&quot;/&gt;&lt;br/&gt;默认超级管理员账号为：Admin&lt;br/&gt;密码为：123456&lt;/p&gt;
&lt;h2 id=&quot;系统用户管理&quot;&gt;系统用户管理&lt;/h2&gt;
&lt;p&gt;管理系统登录的用户&lt;br/&gt;菜单：系统=&amp;gt;用户管理&lt;br/&gt;点击右侧设置权限&lt;/p&gt;
&lt;h2 id=&quot;系统角色管理&quot;&gt;系统角色管理&lt;/h2&gt;
&lt;p&gt;管理系统角色，角色是权限的载体，合理分配角色有利于权限管理&lt;br/&gt;菜单：系统=&amp;gt;角色管理&lt;br/&gt;操作中可以设置角色的权限，详情见&amp;lt;权限管理&amp;gt;模块&lt;/p&gt;
&lt;h2 id=&quot;权限管理&quot;&gt;权限管理&lt;/h2&gt;
&lt;p&gt;一般情况下，后台管理系统多少会涉及权限管理，因此本框架提供了一个灵活、高效、简洁的权限管理系统。&lt;/p&gt;
&lt;p&gt;首先，权限分为两种，即&lt;strong&gt;操作权限&lt;/strong&gt;和&lt;strong&gt;数据权限&lt;/strong&gt;，其中操作权限主要包括菜单权限和按钮权限，在角色编辑表单中，给角色勾选需要的权限即可，用户可以分配多个角色，继承所有角色的权限。&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYET39.png&quot; alt=&quot;MYET39.png&quot;/&gt;&lt;br/&gt;如上图，按需勾选，有人会疑问为什么只有增、改和删的权限而没有查的权限，其实这里考虑到了当勾选“用户管理”时，就已经默认拥有“查”的权限了，这里再设置“查”权限岂不是多此一举，可以根据实际业务需求添加诸如申请、审核等权限，灵活应用。&lt;br/&gt;这里的树状是和菜单一一对应的，勾选哪些菜单就拥有哪些菜单&lt;/p&gt;
&lt;p&gt;下面介绍下最常用的&lt;strong&gt;按钮权限&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYVTIS.png&quot; alt=&quot;MYVTIS.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，在需要控制权限的按钮使用&lt;strong&gt;v-if=&quot;hasPerm('Base_User.Add')&quot;&lt;/strong&gt;，表示只有当用户拥有权限值&lt;strong&gt;Base_User.Add&lt;/strong&gt;才显示此按钮，权限值就是权限表单中配置的权限值&lt;/p&gt;
&lt;p&gt;这里的按钮级权限控制只能够在前端控制操作入口，若系统对安全性要求较高，则需要控制接口权限&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYZNo8.png&quot; alt=&quot;MYZNo8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，在需要权限控制的接口加上&lt;strong&gt;ApiPermission&lt;/strong&gt;特性即可，参数也为权限值，只有拥有此权限才能访问此接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据权限&lt;/strong&gt;比较复杂，若采用纯SQL方式，那么会更加复杂，本框架全程采用EF作为ORM框架，通过对IQueryable&amp;lt; T &amp;gt;进行过滤，即可完成数据权限控制，详细使用方式见&lt;strong&gt;用户管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;更详细的使用方式，请参考&lt;strong&gt;源代码&lt;/strong&gt;中的&lt;strong&gt;用户管理模块(菜单权限、操作权限、数据权限、联表查询、业务层AOP等使用方式均可参考此模块)&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;接口秘钥管理&quot;&gt;接口秘钥管理&lt;/h2&gt;
&lt;p&gt;作为对外接口签名的AppId和AppSecret管理&lt;br/&gt;菜单：系统=&amp;gt;接口秘钥管理&lt;/p&gt;
&lt;h2 id=&quot;系统日志&quot;&gt;系统日志&lt;/h2&gt;
&lt;p&gt;菜单：系统=&amp;gt;系统日志&lt;/p&gt;
&lt;h2 id=&quot;单库事务&quot;&gt;单库事务&lt;/h2&gt;
&lt;p&gt;使用方式如下:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;BaseBusiness&amp;lt;Base_UnitTest&amp;gt; _baseBus  = new BaseBusiness&amp;lt;Base_UnitTest&amp;gt;();
/*RunTransaction传入执行具体数据库操作的Action,操作中若出现异常会自动回滚事务,业务只需根据返回的transActionRes进行处理,返回类型为元组(bool Success, Exception ex),Success表示事务是否成功,ex为事务失败异常信息*/
var transActionRes = _baseBus.RunTransaction(() =&amp;gt;
{
    var newData = _newData.DeepClone();
    newData.Id = Guid.NewGuid().ToString();
    newData.UserId = IdHelper.GetId();
    newData.UserName = IdHelper.GetId();
    _baseBus.Insert(_newData);
    _baseBus.Insert(newData);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;跨库事务&quot;&gt;跨库事务&lt;/h2&gt;
&lt;p&gt;使用方式如下:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//第一个数据库
IRepository _bus1 = DbFactory.GetRepository();
//另一个数据库
IRepository _bus2 = DbFactory.GetRepository(&quot;BaseDb_Test&quot;);
_bus1.DeleteAll&amp;lt;Base_UnitTest&amp;gt;();
_bus2.DeleteAll&amp;lt;Base_UnitTest&amp;gt;();
Base_UnitTest data1 = new Base_UnitTest
{
    Id = Guid.NewGuid().ToString(),
    UserId = &quot;1&quot;,
    UserName = Guid.NewGuid().ToString()
};
Base_UnitTest data2 = new Base_UnitTest
{
    Id = data1.Id,
    UserId = &quot;1&quot;,
    UserName = Guid.NewGuid().ToString()
};
Base_UnitTest data3 = new Base_UnitTest
{
    Id = Guid.NewGuid().ToString(),
    UserId = &quot;2&quot;,
    UserName = Guid.NewGuid().ToString()
};

new Action(() =&amp;gt;
{
    //创建并执行事务，使用方式与单库一致
    var succcess = DistributedTransactionFactory.GetDistributedTransaction(_bus1, _bus2)
        .RunTransaction(() =&amp;gt;
        {
            _bus1.ExecuteSql(&quot;insert into Base_UnitTest(Id) values('10') &quot;);
            _bus1.Insert(data1);
            _bus1.Insert(data2);
            _bus2.Insert(data1);
            _bus2.Insert(data3);
        });
    Assert.AreEqual(succcess.Success, false);
    Assert.AreEqual(_bus1.GetIQueryable&amp;lt;Base_UnitTest&amp;gt;().Count(), 0);
    Assert.AreEqual(_bus2.GetIQueryable&amp;lt;Base_UnitTest&amp;gt;().Count(), 0);
})();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;读写分离分库分表&quot;&gt;读写分离分库分表&lt;/h2&gt;
&lt;p&gt;本框架支持数据库&lt;strong&gt;读写分离分库分表&lt;/strong&gt;（即&lt;strong&gt;Sharding&lt;/strong&gt;），并且支持主流关系型数据库（SQLServer、Oracle、MySQL、PostgreSQL）,理论上只要EF支持那么本框架支持。&lt;br/&gt;由于技术原因以及结合实际情况，目前本框架仅支持单表的Sharding，即支持单表的CRUD、分页、统计（数量、最大值、最小值、平均值），支持跨库（表分散在不同的数据库中，不同类型数据库也支持）。具体如何使用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Sharding配置&lt;br/&gt;首先、要进行分库分表操作，那么必要的配置必不可少。配置代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;ShardingConfigBootstrapper.Bootstrap()
    //添加数据源
    .AddDataSource(&quot;BaseDb&quot;, DatabaseType.SqlServer, dbBuilder =&amp;gt;
    {
        //添加物理数据库
        dbBuilder.AddPhsicDb(&quot;BaseDb&quot;, ReadWriteType.ReadAndWrite);
    })
    //添加抽象数据库
    .AddAbsDb(&quot;BaseDb&quot;, absTableBuilder =&amp;gt;
    {
        //添加抽象数据表
        absTableBuilder.AddAbsTable(&quot;Base_UnitTest&quot;, tableBuilder =&amp;gt;
        {
            //添加物理数据表
            tableBuilder.AddPhsicTable(&quot;Base_UnitTest_0&quot;, &quot;BaseDb&quot;);
            tableBuilder.AddPhsicTable(&quot;Base_UnitTest_1&quot;, &quot;BaseDb&quot;);
            tableBuilder.AddPhsicTable(&quot;Base_UnitTest_2&quot;, &quot;BaseDb&quot;);
        }, new ModShardingRule(&quot;Base_UnitTest&quot;, &quot;Id&quot;, 3));
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中完成了Sharding的配置：&lt;br/&gt;ShardingConfigBootstrapper.Bootstrap()在一个项目中只能执行一次，所以建议放到Application_Start中（ASP.NET Core中的Startup）&lt;br/&gt;AddDataSource是指添加数据源，数据源可以看做抽象数据库，一个数据源包含了一组同类型的物理数据库，即实际的数据库。一个数据源至少包含一个物理数据库，多个物理数据库需要开启主从复制或主主复制，通过ReadWriteType（写、读、写和读）参数来指定数据库的操作类型，通常将写库作为主库，读库作为从库。同一个数据源中的物理数据库类型相同，表结构也相同。&lt;br/&gt;配置好数据源后就可以通过AddAbsDb来添加抽象数据库，抽象数据库中需要添加抽象数据表。如上抽象表Base_UnitTest对应的物理表就是Base_UnitTest_0、Base_UnitTest_1与Base_UnitTest_2，并且这三张表都属于数据源BaseDb。分表配置当然需要分表规则（即通过一种规则找到具体数据在哪张表中）。&lt;br/&gt;上述代码中使用了最简单的&lt;strong&gt;取模分片规则&lt;/strong&gt;，&lt;br/&gt;源码如下：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/22/Z9MT6f.png&quot;/&gt;&lt;br/&gt;可以看到其使用方式及优缺点。&lt;br/&gt;另外还有&lt;strong&gt;一致性HASH分片规则&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/22/Z9QF74.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;雪花Id的mod分片规则&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/22/Z9Qe91.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述的分片规则各有优劣，都实现IShardingRule接口，实际上只需要实现FindTable方法即可实现自定义分片规则。&lt;br/&gt;实际使用中个人推荐使用&lt;strong&gt;雪花Id的mod分片规&lt;/strong&gt;，这也是为什么前面数据库设计规范中默认使用雪花Id作为数据库主键的原因（PS，之前版本使用GUID作为主键被各种嫌弃，这次看你们怎么说）&lt;img src=&quot;https://s2.ax1x.com/2019/06/22/Z9hrdK.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用方式&lt;br/&gt;配置完成，下面开始使用，使用方式&lt;strong&gt;非常简单&lt;/strong&gt;，与平常使用基本一致&lt;br/&gt;首先获取分片仓储接口IShardingRepository&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;IShardingRepository _db = DbFactory.GetRepository().ToSharding();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后即可进行数据操作：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Base_UnitTest _newData  = new Base_UnitTest
{
    Id = Guid.NewGuid().ToString(),
    UserId = &quot;Admin&quot;,
    UserName = &quot;超级管理员&quot;,
    Age = 22
};
List&amp;lt;Base_UnitTest&amp;gt; _insertList = new List&amp;lt;Base_UnitTest&amp;gt;
{
    new Base_UnitTest
    {
        Id = Guid.NewGuid().ToString(),
        UserId = &quot;Admin1&quot;,
        UserName = &quot;超级管理员1&quot;,
        Age = 22
    },
    new Base_UnitTest
    {
        Id = Guid.NewGuid().ToString(),
        UserId = &quot;Admin2&quot;,
        UserName = &quot;超级管理员2&quot;,
        Age = 22
    }
};
//添加单条数据
_db.Insert(_newData);
//添加多条数据
_db.Insert(_insertList);
//清空表
_db.DeleteAll&amp;lt;Base_UnitTest&amp;gt;();
//删除单条数据
_db.Delete(_newData);
//删除多条数据
_db.Delete(_insertList);
//删除指定数据
_db.Delete&amp;lt;Base_UnitTest&amp;gt;(x =&amp;gt; x.UserId == &quot;Admin2&quot;);
//更新单条数据
_db.Update(_newData);
//更新多条数据
_db.Update(_insertList);
//更新单条数据指定属性
_db.UpdateAny(_newData, new List&amp;lt;string&amp;gt; { &quot;UserName&quot;, &quot;Age&quot; });
//更新多条数据指定属性
_db.UpdateAny(_insertList, new List&amp;lt;string&amp;gt; { &quot;UserName&quot;, &quot;Age&quot; });
//更新指定条件数据
_db.UpdateWhere&amp;lt;Base_UnitTest&amp;gt;(x =&amp;gt; x.UserId == &quot;Admin&quot;, x =&amp;gt;
{
    x.UserId = &quot;Admin2&quot;;
});
//GetList获取表的所有数据
var list=_db.GetList&amp;lt;Base_UnitTest&amp;gt;();
//GetIQPagination获取分页后的数据
var list=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().GetPagination(pagination);
//Max
var max=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Max(x =&amp;gt; x.Age);
//Min
var min=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Min(x =&amp;gt; x.Age);
//Average
var min=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Average(x =&amp;gt; x.Age);
//Count
var min=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Count();
//事务,使用方式与普通事务一致
bool succcess = _db.RunTransaction(() =&amp;gt;
{
    _db.Insert(_newData);
    var newData2 = _newData.DeepClone();
    _db.Insert(newData2);
}).Success;
Assert.AreEqual(succcess, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述操作中表面上是操作Base_UnitTest表，实际上却在按照一定规则使用Base_UnitTest_0~2三张表，使分片对业务&lt;strong&gt;操作透明&lt;/strong&gt;，极大提高开发效率&lt;br/&gt;具体使用方式请参考单元测试源码：&lt;br/&gt;&quot;\src\Coldairarrow.UnitTests\DataRepository\ShardingTest.cs&quot;&lt;/p&gt;

&lt;h2 id=&quot;如何进行联表查询&quot;&gt;如何进行联表查询&lt;/h2&gt;
&lt;p&gt;框架使用EF+LINQ进行联表操作，核心在于对IQueryable&amp;lt; T &amp;gt;的使用，另可网上搜EF+LINQ的相关教程。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;br/&gt;Base_User表左连接Base_Department表获取DepartmentName属性&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//定义数据模型类
public class Base_UserTestDTO : Base_User
{
    public string DepartmentName { get; set; }
}

//即BaseBusiness中的Service
var db = DbFactory.GetRepository();
Expression&amp;lt;Func&amp;lt;Base_User, Base_Department, Base_UserTestDTO&amp;gt;&amp;gt; select = (a, b) =&amp;gt; new Base_UserTestDTO
{
    DepartmentName = b.Name
};
select = select.BuildExtendSelectExpre();
var q = from a in db.GetIQueryable&amp;lt;Base_User&amp;gt;().AsExpandable()
        join b in db.GetIQueryable&amp;lt;Base_Department&amp;gt;() on a.DepartmentId equals b.Id into ab
        from b in ab.DefaultIfEmpty()
        select @select.Invoke(a, b);
//筛选
var where = LinqHelper.True&amp;lt;Base_UserTestDTO&amp;gt;();
where = where.And(x =&amp;gt; x.UserName == &quot;Admin&quot;);

//筛选并获取分页数据
var list = q.Where(where).GetPagination(new Pagination()).ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码可参考&lt;strong&gt;Base_UserBusiness.GetDataList&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何切换数据库类型&quot;&gt;如何切换数据库类型&lt;/h2&gt;
&lt;p&gt;在01.Coldairarrow.Util项目中的GlobalSwitch，将DatabaseType改为需要的即可，对应的数据库连接字符串当然也要改为对应数据库的&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYK1bR.png&quot; alt=&quot;MYK1bR.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何使用多个数据库&quot;&gt;如何使用多个数据库&lt;/h2&gt;
&lt;p&gt;在具体的Business类中重写父类BaseBusiness的构造函数即可，按照自己的需求重写对应的构造函数,同时需要确保数据库连接字符串已添加&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYMFzD.png&quot; alt=&quot;MYMFzD.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYMVLd.png&quot; alt=&quot;MYMVLd.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若需要同时使用多个数据库，或者需要多线程操作数据库，需要使用&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/13/MYMsOJ.png&quot; alt=&quot;MYMsOJ.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;欢迎使用本框架，若觉得不错，请比心&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Coldairarrow/UploadFiles/master/Colder.Fx.Net.AdminLTE/04abaa3d37fa01b4c4058c8163aab6a8.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Github欢迎星星:&lt;a href=&quot;https://github.com/Coldairarrow&quot; class=&quot;uri&quot;&gt;https://github.com/Coldairarrow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园欢迎点赞：&lt;a href=&quot;https://www.cnblogs.com/coldairarrow/&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/coldairarrow/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;QQ群2:579202910&lt;br/&gt;个人QQ:862520575（&lt;strong&gt;欢迎技术支持及商务合作，提供.NET Core + Linux + Nginx+ jenkins + git整套持续集成快速开发平台&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;本人将会对这个快速开发框架不断完善与维护，希望能够帮助到各位&lt;/p&gt;
&lt;p&gt;若遇到任何问题或需要技术支持，请联系我。&lt;/p&gt;
&lt;p&gt;------学习永无止境，技术永无上限，代码就是艺术------&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 00:20:00 +0000</pubDate>
<dc:creator>寒空飞箭</dc:creator>
<og:description>.NET Core前后端分离快速开发框架(Core.3.0+AntdVue) 目录 '引言' '简介' '环境搭建' '开发环境要求' '基础数据库构建' '数据库设计规范' '运行' '使用教程'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coldairarrow/p/11870993.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入[10]：与第三方依赖注入框架的适配 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html</guid>
<description>&lt;p&gt;.NET Core具有一个承载（Hosting）系统，承载需要在后台长时间运行的服务，一个ASP.NET Core应用仅仅是该系统承载的一种服务而已。承载系统总是采用依赖注入的方式来消费它在服务承载过程所需的服务。对于承载系统来说，原始的服务注册总是体现为一个&lt;span&gt;IServiceCollection&lt;/span&gt;集合，最终的依赖注入容器则体现为一个&lt;span&gt;IServiceProvider&lt;/span&gt;对象，如果要将第三方依赖注入框架整合进来，就需要利用它们解决从IServiceCollection集合到IServiceProvider对象之间的适配问题。&lt;/p&gt;

&lt;p&gt;具体来说，我们可以在IServiceCollection集合和IServiceProvider对象之间设置一个针对某个第三方依赖注入框架的&lt;span&gt;ContainerBuilder&lt;/span&gt;对象。我们先利用包含原始服务注册的IServiceCollection集合来创建一个ContainerBuilder对象，再利用该对象来构建作为依赖注入容器的IServiceProvider对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191118081618396-1093565825.png&quot;&gt;&lt;img width=&quot;371&quot; height=&quot;189&quot; title=&quot;4-15&quot; alt=&quot;4-15&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191118081618748-622583109.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如上图所示的两种转换是利用一个&lt;span&gt;IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;&lt;/span&gt;对象完成的。如下面的代码片段所示，IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;接口定义了两个方法，其中&lt;span&gt;CreateBuilder&lt;/span&gt;方法利用指定的IServiceCollection集合创建出对应的ContainerBuilder对象，而&lt;span&gt;CreateServiceProvider&lt;/span&gt;方法则进一步利用这个ContainerBuilder对象创建出作为依赖注入容器的IServiceProvider对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;&lt;span&gt;
{
    TContainerBuilder CreateBuilder(IServiceCollection services);
    IServiceProvider CreateServiceProvider(TContainerBuilder containerBuilder);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.NET Core的承载系统总是利用注册的IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;服务来创建最终作为依赖注入容器的IServiceProvider对象。承载系统默认注册的是如下这个&lt;span&gt;DefaultServiceProviderFactory&lt;/span&gt;类型。如下面的代码片段所示，DefaultServiceProviderFactory对象会直接调用指定IServiceCollection集合的BuildServiceProvider方法创建出对应的IServiceProvider对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultServiceProviderFactory :  IServiceProviderFactory&amp;lt;IServiceCollection&amp;gt;&lt;span&gt;
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DefaultServiceProviderFactory()  : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(ServiceProviderOptions.Default){}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DefaultServiceProviderFactory(ServiceProviderOptions options) =&amp;gt;_options =&lt;span&gt; options;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceCollection CreateBuilder(IServiceCollection services)  =&amp;gt;&lt;span&gt; services;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceProvider CreateServiceProvider( IServiceCollection containerBuilder) =&amp;gt;&lt;span&gt;  containerBuilder.BuildServiceProvider(_options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了让读者朋友对利用注册的IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;服务整合第三方依赖注入框架具有更加深刻的理解，我们来演示一个具体的实例。我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;一个Mini版的依赖注入框架&lt;/a&gt;》创建了一个名为Cat的“迷你版”依赖注入框架，接下来我们将提供一个具体IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;实现类型完成对它的整合。&lt;/p&gt;
&lt;p&gt;我们首先创建一个名为&lt;span&gt;CatBuilder&lt;/span&gt;的类型作为对应的ContainerBuilder。由于需要涉及针对服务范围的创建，我们在CatBuilder类中定了如下两个内嵌的私有类型，其中表示服务范围的ServiceScope对象实际上就是对一个IServiceProvider对象的封装，另一个ServiceScopeFactory类型表示创建该对象的工厂，它是对一个Cat对象的封装。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CatBuilder
{    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceScope : IServiceScope
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceScope(IServiceProvider serviceProvider) =&amp;gt; ServiceProvider =&lt;span&gt; serviceProvider;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceProvider ServiceProvider { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose()=&amp;gt; (ServiceProvider &lt;span&gt;as&lt;/span&gt; IDisposable)?&lt;span&gt;.Dispose();
}

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceScopeFactory : IServiceScopeFactory
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Cat _cat;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceScopeFactory(Cat cat) =&amp;gt; _cat =&lt;span&gt; cat;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceScope CreateScope() =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceScope(_cat);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个CatBuilder对象是对一个Cat对象的封装，它的BuildServiceProvider方法会直接返回这个Cat对象，并作为最终提供的依赖注入容器。CatBuilder在初始化过程中添加了针对IServiceScopeFactory接口的服务注册，具体注册的是根据作为当前子容器的Cat对象创建的ServiceScopeFactory对象。为了实现程序集范围内的批量服务注册，我们为CatBuilder定义了一个Register方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CatBuilder
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Cat _cat;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CatBuilder(Cat cat)
    {
        _cat &lt;/span&gt;=&lt;span&gt; cat;
        _cat.Register&lt;/span&gt;&amp;lt;IServiceScopeFactory&amp;gt;( c =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceScopeFactory(c.CreateChild()), Lifetime.Transient);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceProvider BuildServiceProvider() =&amp;gt;&lt;span&gt; _cat;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CatBuilder Register(Assembly assembly)
    {
        _cat.Register(assembly);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下所示的CatServiceProviderFactory类型实现了IServiceProviderFactory&amp;lt;CatBuilder&amp;gt;接口。在实现的CreateBuilder方法中，我们创建了一个Cat对象，并将指定IServiceCollection集合包含中的服务注册（ServiceDescriptor对象）转换成兼容Cat的服务注册（ServiceRegistry对象）并应用到创建的Cat对象上。我们最终利用这个Cat对象创建出返回的CatBuilder对象。实现的另一个方法CreateServiceProvider返回的是调用CatBuilder对象的CreateServiceProvider方法得到的IServiceProvider对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CatServiceProviderFactory : IServiceProviderFactory&amp;lt;CatBuilder&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CatBuilder CreateBuilder(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; service &lt;span&gt;in&lt;/span&gt;&lt;span&gt; services)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (service.ImplementationFactory != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                cat.Register(service.ServiceType, provider ) &lt;/span&gt;=&amp;gt;&lt;span&gt; service.ImplementationFactory(provider),   service.Lifetime.AsCatLifetime());
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (service.ImplementationInstance != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                cat.Register(service.ServiceType, service.ImplementationInstance);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                cat.Register(service.ServiceType, service.ImplementationType,    service.Lifetime.AsCatLifetime());
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CatBuilder(cat);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceProvider CreateServiceProvider(CatBuilder containerBuilder) =&amp;gt;&lt;span&gt; containerBuilder.BuildServiceProvider();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cat具有.NET Core依赖注入框架一致的服务生命周期表达方式，所以我们在将服务注册从ServiceDescriptor类型转化成ServiceRegistry类型时，可以实现直接完成两种生命周期模式的转换，具体的转换实现在如下这个AsCatLifetime扩展方法中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Extensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Lifetime AsCatLifetime(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; ServiceLifetime lifetime)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; lifetime &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;
        {
            ServiceLifetime.Scoped &lt;/span&gt;=&amp;gt;&lt;span&gt; Lifetime.Self,
            ServiceLifetime.Singleton &lt;/span&gt;=&amp;gt;&lt;span&gt; Lifetime.Root,
            _ &lt;/span&gt;=&amp;gt;&lt;span&gt; Lifetime.Transient,
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们演示如何利用CatServiceProviderFactory来创建作为依赖注入容器的IServiceProvider对象。我们定义了如下的接口和对应的实现类型，其中Foo、Bar、Baz和Qux类型分别实现了对应的接口IFoo、IBar、IBaz和IQux，其中Qux类型上标注了一个MapToAttribute特性注册了与对应接口IQux之间的映射。为了反映Cat对服务实例生命周期的控制，我们让它们派生于同一个基类Base。Base实现了IDisposable接口，我们在其构造函数和实现的Dispose方法中输出相应的文本以确定对应的实例何时被创建和释放。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaz {} 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IQux {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFoobar&amp;lt;T1, T2&amp;gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base : IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Base()  =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instance of {GetType().Name} is created.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose()  =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instance of {GetType().Name} is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : Base, IFoo{ }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar : Base, IBar{ }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Baz : Base, IBaz{ } 
[MapTo(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IQux), Lifetime.Root)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Qux : Base, IQux { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Foobar&amp;lt;T1, T2&amp;gt;: IFoobar&amp;lt;T1,T2&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFoo Foo { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foobar(IFoo foo, IBar bar)
    {
        Foo &lt;/span&gt;=&lt;span&gt; foo;
        Bar &lt;/span&gt;=&lt;span&gt; bar;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下所示的演示程序中，我们创建了一个ServiceCollection集合，并采用三种不同的生命周期模式分别添加了针对IFoo、IBar和IBaz接口的服务注册。我们接下来根据这个ServiceCollection集合创建了一个CatServiceProviderFactory对象，并调用其CreateBuilder方法创建出对应的CatBuilder对象。我们随后调用了CatBuilder对象的Register方法完成了针对当前入口程序集的批量服务注册，其目的在于添加针对IQux/Qux的服务注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar&amp;gt;(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar())
            .AddSingleton&lt;/span&gt;&amp;lt;IBaz&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Baz());

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CatServiceProviderFactory();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder =&lt;span&gt; factory.CreateBuilder(services)
            .Register(Assembly.GetEntryAssembly());
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; container =&lt;span&gt; factory.CreateServiceProvider(builder);

        GetServices();
        GetServices();
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nRoot container is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        (container &lt;/span&gt;&lt;span&gt;as&lt;/span&gt; IDisposable)?&lt;span&gt;.Dispose();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetServices()
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; container.CreateScope())
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nService scope is created.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; child =&lt;span&gt; scope.ServiceProvider;

                child.GetService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;();
                child.GetService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;();
                child.GetService&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;();
                child.GetService&lt;/span&gt;&amp;lt;IQux&amp;gt;&lt;span&gt;();

                child.GetService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;();
                child.GetService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;();
                child.GetService&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;();
                child.GetService&lt;/span&gt;&amp;lt;IQux&amp;gt;&lt;span&gt;();                     
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nService scope is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在调用CatServiceProviderFactory对象的CreateServiceProvider方法创建出作为依赖注入容器的IServiceProvider对象之后，我们先后两次调用了本地方法GetServices方法。GetServices方法会利用这个IServiceProvider对象创建一个服务范围，并利用此服务范围内的IServiceProvider提供两组服务实例。通过CatServiceProviderFactory创建的IServiceProvider对象在最终通过调用其Dispose方法进行释放。该程序运行之后会在控制台上输出如图4-16所示的结果，输出结果体现的服务生命周期与演示程序体现的是完全一致的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191118081619008-1656141611.png&quot;&gt;&lt;img width=&quot;228&quot; height=&quot;454&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191118081619343-18603764.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[1]：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[2]：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[3]：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[4]：一个迷你版DI框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[5]：利用容器提供服务&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[6]：服务注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[7]：服务消费&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[8]：服务实例的生命周期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[9]：实现概述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[10]：与第三方依赖注入框架的适配&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Nov 2019 00:16:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>.NET Core具有一个承载（Hosting）系统，承载需要在后台长时间运行的服务，一个ASP.NET Core应用仅仅是该系统承载的一种服务而已。承载系统总是采用依赖注入的方式来消费它在服务承载过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html</dc:identifier>
</item>
<item>
<title>Spring Security登录验证流程源码解析 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11880050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11880050.html</guid>
<description>&lt;h2 id=&quot;一登录认证基于过滤器链&quot;&gt;一、登录认证基于过滤器链&lt;/h2&gt;
&lt;p&gt;Spring Security的登录验证流程核心就是过滤器链。当一个请求到达时按照过滤器链的顺序依次进行处理，通过所有过滤器链的验证，就可以访问API接口了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075502676-2111501456.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SpringSecurity提供了多种登录认证的方式，由多种Filter过滤器来实现，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BasicAuthenticationFilter实现的是HttpBasic模式的登录认证&lt;/li&gt;
&lt;li&gt;UsernamePasswordAuthenticationFilter实现用户名密码的登录认证&lt;/li&gt;
&lt;li&gt;RememberMeAuthenticationFilter实现登录认证的“记住我”的功能&lt;/li&gt;
&lt;li&gt;SmsCodeAuthenticationFilter实现短信验证码登录认证&lt;/li&gt;
&lt;li&gt;SocialAuthenticationFilter实现社交媒体方式登录认证的处理&lt;/li&gt;
&lt;li&gt;Oauth2AuthenticationProcessingFilter和Oauth2ClientAuthenticationProcessingFilter实现Oauth2的鉴权方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据我们不同的需求实现及配置，不同的Filter会被加载到应用中。&lt;/p&gt;
&lt;h2 id=&quot;二结合源码讲解登录验证流程&quot;&gt;二、结合源码讲解登录验证流程&lt;/h2&gt;
&lt;p&gt;我们就以用户名、密码登录方式为例讲解一下Spring Security的登录认证流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075502911-1503777299.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;usernamepasswordauthenticationfilter&quot;&gt;2.1 UsernamePasswordAuthenticationFilter&lt;/h3&gt;
&lt;p&gt;该过滤器封装用户基本信息（用户名、密码），定义登录表单数据接收相关的信息。如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认的表单用户名密码input框name是username、password&lt;/li&gt;
&lt;li&gt;默认的处理登录请求路径是/login、使用POST方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075503124-1342161489.jpg&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075503345-1925995142.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;abstractauthenticationprocessingfilter的dofilter方法的验证过程&quot;&gt;2.2 AbstractAuthenticationProcessingFilter的doFilter方法的验证过程&lt;/h3&gt;
&lt;p&gt;UsernamePasswordAuthenticationFilter继承自抽象类AbstractAuthenticationProcessingFilter，该抽象类定义了验证成功与验证失败的处理方法。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075504157-488335360.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证成功之后的handler和验证失败之后的handler&quot;&gt;2.3 验证成功之后的Handler和验证失败之后的handler&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075504370-585146482.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说当我们需要自定义验证成功或失败的处理方法时，要去实现AuthenticationSuccessHandler或AuthenticationfailureHandler接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075504962-911422467.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三登录验证内部细节&quot;&gt;三、登录验证内部细节&lt;/h2&gt;
&lt;h3 id=&quot;多种认证方式的管理-providermanager&quot;&gt;3.1多种认证方式的管理 ProviderManager&lt;/h3&gt;
&lt;p&gt;ProviderManager用继承于AuthenticationManager是登录验证的核心类。ProviderManager保管了多个AuthenticationProvider，用于不同类型的登录验证。比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RememberMeAuthenticationProvider定义了“记住我”功能的登录验证逻辑&lt;/li&gt;
&lt;li&gt;DaoAuthenticationProvider加载数据库用户信息，进行用户密码的登录验证&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class ProviderManager implements AuthenticationManager, MessageSourceAware, InitializingBean {
    ……
    private List&amp;lt;AuthenticationProvider&amp;gt; providers;
    ……&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下文是ProviderManager的核心源码，遍历不同登录验证的AuthenticationProvider，只有当这种方式被支持的时候，才执行具体的登录验证逻辑。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075505451-144063866.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;登录认证接口-authenticationprovider&quot;&gt;3.2 登录认证接口 AuthenticationProvider&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public interface AuthenticationProvider {
    Authentication authenticate(Authentication var1) throws AuthenticationException;

    boolean supports(Class&amp;lt;?&amp;gt; var1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AuthenticationProvider的实现类定义了具体的登录验证逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075505942-958390098.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据库加载用户信息-daoauthenticationprovider&quot;&gt;3.3 数据库加载用户信息 DaoAuthenticationProvider&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从数据库获取用户信息源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191118075506207-1185553688.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以当我们需要加载用户信息进行登录验证的时候，我们需要实现&lt;code&gt;UserDetailsService&lt;/code&gt;接口，重写&lt;code&gt;loadUserByUsername&lt;/code&gt;方法，参数是用户输入的用户名。返回值是&lt;code&gt;UserDetails&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Sun, 17 Nov 2019 23:55:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、登录认证基于过滤器链 Spring Security的登录验证流程核心就是过滤器链。当一个请求到达时按照过滤器链的顺序依次进行处理，通过所有过滤器链的验证，就可以访问API接口了。 SpringS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11880050.html</dc:identifier>
</item>
<item>
<title>日问周刊 | 全栈面试汇总 | 第二期 - 山月水风</title>
<link>http://www.cnblogs.com/xianwang/p/11880023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xianwang/p/11880023.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;勤学如春起之苗，不见其增，日有所长；辍学如磨刀之石，不见其损，日有所亏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在 github 上新建了一个仓库 &lt;a href=&quot;https://github.com/shfshanyue/Daily-Question&quot;&gt;日问&lt;/a&gt;，每天至少一个问题。有关全栈，graphql，devops，微服务以及软技能，促进职业成长，欢迎交流。&lt;/p&gt;
&lt;p&gt;以诸葛武侯的诫子书与君共勉&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;夫君子之行，静以修身，俭以养德。非澹泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能治性。&lt;strong&gt;年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;q037linux-有哪些发行版你最喜欢哪一个&quot;&gt;【Q037】linux 有哪些发行版，你最喜欢哪一个&lt;/h2&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;原文链接，欢迎讨论: &lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/38&quot;&gt;【Q037】linux 有哪些发行版，你最喜欢哪一个&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开放问题，不过你至少得知道一个发行版...&lt;/p&gt;
&lt;h2 id=&quot;q036http-状态码中-301302和307有什么区别&quot;&gt;【Q036】http 状态码中 301，302和307有什么区别&lt;/h2&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;原文链接，欢迎讨论: &lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/37&quot;&gt;【Q036】http 状态码中 301，302和307有什么区别&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。&lt;/li&gt;
&lt;li&gt;302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307&lt;/li&gt;
&lt;li&gt;307，Temporary Redirect。临时重定向，在重定向时不会改变 method&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;q035http-常见的状态码有哪些&quot;&gt;【Q035】http 常见的状态码有哪些&lt;/h2&gt;
&lt;blockquote readability=&quot;2.0422535211268&quot;&gt;
&lt;p&gt;原文链接，欢迎讨论: &lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/36&quot;&gt;【Q035】http 常见的状态码有哪些&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;q034如何实现一个-loading-动画&quot;&gt;【Q034】如何实现一个 loading 动画&lt;/h2&gt;
&lt;blockquote readability=&quot;2.0547945205479&quot;&gt;
&lt;p&gt;原文链接，欢迎讨论：&lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/35&quot;&gt;【Q034】如何实现一个 loading 动画&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;q033如何对接口进行限流&quot;&gt;【Q033】如何对接口进行限流]&lt;/h2&gt;
&lt;blockquote readability=&quot;2.1969696969697&quot;&gt;
&lt;p&gt;原文链接，欢迎讨论: &lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/34&quot;&gt;【Q033】如何对接口进行限流&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般采用漏桶算法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;漏桶初始为空&lt;/li&gt;
&lt;li&gt;API 调用是在往漏桶里注水&lt;/li&gt;
&lt;li&gt;漏桶会以一定速率出水&lt;/li&gt;
&lt;li&gt;水满时 API 拒绝调用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/689182/201911/689182-20191118073135511-1200506883.png&quot; alt=&quot;漏桶算法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;redis&lt;/code&gt; 的计数器实现&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计数器初始为空&lt;/li&gt;
&lt;li&gt;API 调用计数器增加&lt;/li&gt;
&lt;li&gt;给计数器设置过期时间，隔段时间清零，视为一定速率出水&lt;/li&gt;
&lt;li&gt;计数器达到上限时，拒绝调用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然，这只是大致思路，这时会有两个问题要注意&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最坏情况下的限流是额定限流速率的2倍&lt;/li&gt;
&lt;li&gt;条件竞争问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不过实际实现时注意以下就好了（话说一般也是调用现成的三方库做限流...)，可以参考我以前的文章 &lt;a href=&quot;https://shanyue.tech/post/rate-limit/&quot; class=&quot;uri&quot;&gt;https://shanyue.tech/post/rate-limit/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;q032js-中什么是-softbind如何实现&quot;&gt;【Q032】js 中什么是 softbind，如何实现&lt;/h2&gt;
&lt;blockquote readability=&quot;1.8987341772152&quot;&gt;
&lt;p&gt;原文链接，欢迎讨论：&lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/33&quot;&gt;【Q032】js 中什么是 softbind，如何实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;q031js-中如何实现-bind&quot;&gt;【Q031】js 中如何实现 bind&lt;/h2&gt;
&lt;blockquote readability=&quot;2.3387096774194&quot;&gt;
&lt;p&gt;原文链接，欢迎讨论: &lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/32&quot;&gt;【Q031】js 中如何实现 bind&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;最简单的 &lt;code&gt;bind&lt;/code&gt; 一行就可以实现，而在实际面试过程中也不会考察你太多的边界条件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Function.prototype.fakeBind = function(obj) {
  return (...args) =&amp;gt; this.apply(obj, args)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function f (arg) {
  console.log(this.a, arg)
}

// output: 3, 4
f.bind({ a: 3 })(4)

// output: 3, 4
f.fakeBind({ a: 3 })(4)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;q030linux-中如何打印所有网络接口&quot;&gt;【Q030】linux 中如何打印所有网络接口&lt;/h2&gt;
&lt;blockquote readability=&quot;1.8589743589744&quot;&gt;
&lt;p&gt;原文链接，欢迎讨论: &lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/31&quot;&gt;【Q030】linux 中如何打印所有网络接口&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ifconfig&quot;&gt;ifconfig&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt; 是最简单最常用，但是打印信息太多了&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ ifconfig&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;netstat&quot;&gt;netstat&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; 与 &lt;code&gt;ip&lt;/code&gt; 也挺好用，特别是它们还可以打印路由表&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ netstat -i&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ip&quot;&gt;ip&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ ip link

$ ip addr&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;q029websocket-如何向特定的用户组推送消息&quot;&gt;【Q029】websocket 如何向特定的用户组推送消息&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;redis&lt;/code&gt; 处维护一个对象，记录每个 group 所对应的 &lt;code&gt;connections&lt;/code&gt;/&lt;code&gt;sockets&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
  'Class:201901': [student1Socket, student2Socket]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 client 刚连入 server 时，便加入某个特定的组，或者叫 room，比如 student01，刚开始连入 server，可能要加入 room：&lt;code&gt;Student:01&lt;/code&gt;，&lt;code&gt;Class:201901&lt;/code&gt;，&lt;code&gt;Group:10086&lt;/code&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues/29&quot;&gt;【Q028】在linux中如何获取登录的用户&lt;/a&gt; &lt;a href=&quot;https://github.com/shfshanyue/Daily-Question/issues?q=is%3Aopen+is%3Aissue+label%3Alinux&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/linux-fabd14&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ who

$ last&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Valve/fingerprintjs2&quot;&gt;fingerprintjs2&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;一图胜千言&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/689182/201911/689182-20191118073136288-1568161934.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;jsonb_pretty&lt;/code&gt; 函数，示例如下&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;&amp;gt; select jsonb_pretty('{&quot;a&quot;: {&quot;b&quot;: 4}}'::jsonb)
+----------------+
| jsonb_pretty   |
|----------------|
| {              |
|     &quot;a&quot;: {     |
|         &quot;b&quot;: 4 |
|     }          |
| }              |
+----------------+
SELECT 1
Time: 0.018s&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/689182/201911/689182-20191118073136847-365437511.jpg&quot; alt=&quot;借用 redis&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个简单的 &lt;code&gt;Promise&lt;/code&gt; 的粗糙实现，关键点在于&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当 &lt;code&gt;pending&lt;/code&gt; 时， &lt;code&gt;thenable&lt;/code&gt; 函数由一个队列维护&lt;/li&gt;
&lt;li&gt;当状态变为 &lt;code&gt;resolved(fulfilled)&lt;/code&gt; 时，队列中所有 &lt;code&gt;thenable&lt;/code&gt; 函数执行&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;resolved&lt;/code&gt; 时， &lt;code&gt;thenable&lt;/code&gt; 函数直接执行&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;rejected&lt;/code&gt; 状态同理&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Prom {
  static resolve (value) {
    if (value &amp;amp;&amp;amp; value.then) {
      return value 
    }
    return new Prom(resolve =&amp;gt; resolve(value))
  }

  constructor (fn) {
    this.value = undefined
    this.reason = undefined
    this.status = 'PENDING'

    // 维护一个 resolve/pending 的函数队列
    this.resolveFns = []
    this.rejectFns = []

    const resolve = (value) =&amp;gt; {
      // 注意此处的 setTimeout
      setTimeout(() =&amp;gt; {
        this.status = 'RESOLVED'
        this.value = value
        this.resolveFns.forEach(({ fn, resolve: res, reject: rej }) =&amp;gt; res(fn(value)))
      })
    }

    const reject = (e) =&amp;gt; {
      setTimeout(() =&amp;gt; {
        this.status = 'REJECTED'
        this.reason = e
        this.rejectFns.forEach(({ fn, resolve: res, reject: rej }) =&amp;gt; rej(fn(e)))
      })
    }

    fn(resolve, reject)
  }


  then (fn) {
    if (this.status === 'RESOLVED') {
      const result = fn(this.value)
      // 需要返回一个 Promise
      // 如果状态为 resolved，直接执行
      return Prom.resolve(result)
    }
    if (this.status === 'PENDING') {
      // 也是返回一个 Promise
      return new Prom((resolve, reject) =&amp;gt; {
        // 推进队列中，resolved 后统一执行
        this.resolveFns.push({ fn, resolve, reject }) 
      })
    }
  }

  catch (fn) {
    if (this.status === 'REJECTED') {
      const result = fn(this.value)
      return Prom.resolve(result)
    }
    if (this.status === 'PENDING') {
      return new Prom((resolve, reject) =&amp;gt; {
        this.rejectFns.push({ fn, resolve, reject }) 
      })
    }
  }
}

Prom.resolve(10).then(o =&amp;gt; o * 10).then(o =&amp;gt; o + 10).then(o =&amp;gt; {
  console.log(o)
})

return new Prom((resolve, reject) =&amp;gt; reject('Error')).catch(e =&amp;gt; {
  console.log('Error', e)
})&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;首参不一样，直接上 API&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;React.cloneElement(
  element,
  [props],
  [...children]
)

React.createElement(
  type,
  [props],
  [...children]
)&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;它一般可以使用第三方库 &lt;a href=&quot;https://github.com/zenorocha/clipboard.js&quot;&gt;clipboard.js&lt;/a&gt; 来实现，源码很简单，可以读一读&lt;/p&gt;
&lt;p&gt;主要有两个要点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选中&lt;/li&gt;
&lt;li&gt;复制&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;选中&quot;&gt;选中&lt;/h3&gt;
&lt;p&gt;选中主要利用了 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Selection&quot;&gt;Selection API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选中的代码如下&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const selection = window.getSelection();
const range = document.createRange();

range.selectNodeContents(element);
selection.removeAllRanges();
selection.addRange(range);

selectedText = selection.toString();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取消选中的代码如下&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;window.getSelection().removeAllRanges();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它有现成的第三方库可以使用: &lt;a href=&quot;https://github.com/zenorocha/select&quot;&gt;select.js&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;复制&quot;&gt;复制&lt;/h3&gt;
&lt;p&gt;复制就比较简单了，&lt;code&gt;execCommand&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;document.exec('copy')&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 17 Nov 2019 23:32:00 +0000</pubDate>
<dc:creator>山月水风</dc:creator>
<og:description>勤学如春起之苗，不见其增，日有所长；辍学如磨刀之石，不见其损，日有所亏。 我在 github 上新建了一个仓库 '日问' ，每天至少一个问题。有关全栈，graphql，devops，微服务以及软技能，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xianwang/p/11880023.html</dc:identifier>
</item>
<item>
<title>Hybrid App: 看看第三方WebViewJavascriptBridge是如何来实现Native和JavaScript交互 - 菩提树下苦思</title>
<link>http://www.cnblogs.com/XYQ-208910/p/11877423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/XYQ-208910/p/11877423.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在前面两篇文章中已经介绍了Native与JavaScript交互的几种方式，依次是JavaScriptCore框架、UI组件UIWebView、WebKit框架，这几种方式都是苹果公司提供的，除了UIWebView在IOS8之后被苹果淘汰了外，其他基本都能很好地满足开发者的使用。作为一个技术人员，每个人心里都有造轮子的想法，可能有时觉得原生的API使用起来感觉还是不够方便，就对苹果原生的API再进行一层封装，这不WebViewJavascriptBridge这个轮子出来了。WebViewJavascriptBridge的star和fork量还是比较高的，仔细看看WebViewJavascriptBridge类文件相当简单，使用起来也很方便，很受开发者欢迎，它的原理还是利用WKWebView或者UIWebView的相关API，通过bridge桥梁来实现OC与JS互相注册和调用。大致结构图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以看出：OC调用JS，JS需要注册函数； JS调用OC，OC需要注册函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/791499/201911/791499-20191117182757073-2129127671.png&quot; alt=&quot;&quot; width=&quot;936&quot; height=&quot;400&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;了解基本原理结构图后，再来看看框架中的类以及它们的作用定义，如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WebViewJavascriptBridge_JS&lt;/strong&gt;：Javascript环境的Bridge初始化和处理。负责接收OC发给Javascript的消息，并且把Javascript环境的消息发送给OC。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WKWebViewJavascriptBridge/WebViewJavascriptBridge&lt;/strong&gt;：主要负责OC环境的消息处理，并且把OC环境的消息发送给Javascript环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WebViewJavascriptBridgeBase&lt;/strong&gt;：主要实现了OC环境的Bridge初始化和处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/791499/201911/791499-20191117194726166-415751773.png&quot; alt=&quot;&quot; width=&quot;937&quot; height=&quot;170&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化桥接器&lt;/span&gt;
+ (instancetype)bridgeForWebView:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)webView;
&lt;/span&gt;+ (instancetype)bridge:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)webView;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置日志相关&lt;/span&gt;
+ (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)enableLogging;
&lt;/span&gt;+ (&lt;span&gt;void&lt;/span&gt;)setLogMaxLength:(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)length;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册函数, handlerName: 函数名称  handler：传递数据的block&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)registerHandler:(NSString*&lt;span&gt;)handlerName handler:(WVJBHandler)handler;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)removeHandler:(NSString*&lt;span&gt;)handlerName;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用函数, handlerName:函数名称 data:参数 responseCallback：接收数据的block &lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)callHandler:(NSString*&lt;span&gt;)handlerName;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)callHandler:(NSString*)handlerName data:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)data;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)callHandler:(NSString*)handlerName data:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)data responseCallback:(WVJBResponseCallback)responseCallback;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置网页代理&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)setWebViewDelegate:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)webViewDelegate;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;禁用超时安全弹框&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)disableJavscriptAlertBoxSafetyTimeout;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用相关知识点 :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OC 调用 JS&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、单纯的调用 JSFunction。&lt;/span&gt;
[self.jsBridge callHandler:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;JSFunction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、调用 JSFunction，并传递给js需要的参数，但不需要 JSFunciton 的返回值。&lt;/span&gt;
[self.jsBridge callHandler:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;JSFunction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg of js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、调用 JSFunction ，并传递给js需要的参数，也需要 JSFunction 的返回值。&lt;/span&gt;
[self.jsBridge callHandler:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;JSFunction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg of js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; responseCallback:^(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; responseData) {
      NSLog(@&quot;%@&quot;,responseData);
}];


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ------------------------------------------------------------------------------- //

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JS 调用 OC

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、JS 单纯的调用 OC 的 OCMethod&lt;/span&gt;
WebViewJavascriptBridge.callHandler(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OCMethod&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、JS 调用 OC 的 OCMethod，并传递给OC需要的参数&lt;/span&gt;
WebViewJavascriptBridge.callHandler(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OCMethod&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg of oc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、JS 调用 OC 的 OCMethod，传递给OC需要的参数，并接受OC的返回值。&lt;/span&gt;
WebViewJavascriptBridge.callHandler(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OCMethod&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg of oc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, function(responseValue){
    alert(responseValue);&lt;br/&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、核心&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使用该框架，还需要完成某些初始化的工作，也即在HTML或者JavaScript文件中，拷贝进官方指定的函数，在函数内进行初始化操作：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;固定格式的函数&lt;/span&gt;
&lt;span&gt;function setupWebViewJavascriptBridge(callback) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (window.WebViewJavascriptBridge) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; callback(WebViewJavascriptBridge); }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (window.WVJBCallbacks) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; window.WVJBCallbacks.push(callback); }
    window.WVJBCallbacks &lt;/span&gt;=&lt;span&gt; [callback];
    var WVJBIframe &lt;/span&gt;= document.createElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    WVJBIframe.style.display &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    WVJBIframe.src &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://__bridge_loaded__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    document.documentElement.appendChild(WVJBIframe);
    setTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;官方说这里主要进行初始化，有两个功能：1、进行JS函数的注册提供OC调用(必须在此实现)   2、JS调用OC在端上注册的函数(不用在此处实现)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里需要说明一下： 至于第2点如果放在这里会立即执行且执行一次。可以挪到某一个js事件中执行，例如按钮事件等，可以频繁触发，后面的使用会有demo演示&lt;/span&gt;
&lt;span&gt;setupWebViewJavascriptBridge(function(bridge) {
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize your app here &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    bridge.registerHandler(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JavaScript_functionName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function(data, responseCallback) {
        responseCallback(data); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递数据给OC&lt;/span&gt;
&lt;span&gt;    })


    bridge.callHandler(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OC_methodName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function responseCallback(responseData) {
        alert(responseData); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收OC的数据&lt;/span&gt;
&lt;span&gt;    })
})    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;四、使用&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Example introduce:  页面有一个原生按钮和H5按钮，点击原生按钮调用JS，切换H5的div背景色；点击H5按钮，调用OC方法，切换原生按钮背景颜色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;完整代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4770c6e9-7cfe-4e32-9398-e6924eab4a63')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_4770c6e9-7cfe-4e32-9398-e6924eab4a63&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4770c6e9-7cfe-4e32-9398-e6924eab4a63&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4770c6e9-7cfe-4e32-9398-e6924eab4a63',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4770c6e9-7cfe-4e32-9398-e6924eab4a63&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  ViewController.m
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  WebViewJavaScriptBridge
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Created by 夏远全 on 2019/11/17.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Copyright © 2019 Beijing Huayue Education Technology Co., Ltd. All rights reserved.
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ViewController.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebViewJavascriptBridge/WebViewJavascriptBridge.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; ViewController ()
@property (nonatomic, strong) WebViewJavascriptBridge &lt;/span&gt;*&lt;span&gt;bridge;
@property (nonatomic, strong) UIButton  &lt;/span&gt;*&lt;span&gt;topButton;
@property (nonatomic, strong) WKWebView &lt;/span&gt;*&lt;span&gt;wkWebView;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController

&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; mark - init

- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建topView&lt;/span&gt;
    CGFloat width =&lt;span&gt; [UIScreen mainScreen].bounds.size.width;
    self.topButton &lt;/span&gt;= [[UIButton alloc] initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, width, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;)];
    self.topButton.titleLabel.numberOfLines &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    self.topButton.backgroundColor &lt;/span&gt;=&lt;span&gt; [UIColor blueColor];
    self.topButton.titleLabel.font &lt;/span&gt;= [UIFont systemFontOfSize:&lt;span&gt;17&lt;/span&gt;&lt;span&gt;];
    [self.topButton setTitle:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;我是TopButton\n点击我调用JS方法，切换div盒子的背景色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; forState:UIControlStateNormal];
    [self.topButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
    [self.topButton addTarget:self action:@selector(topButtonAction) forControlEvents:UIControlEventTouchUpInside];
    

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建wkWebView&lt;/span&gt;
    CGFloat height = [UIScreen mainScreen].bounds.size.height-&lt;span&gt;CGRectGetHeight(self.topButton.frame);
    self.wkWebView &lt;/span&gt;= [[WKWebView alloc] initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, CGRectGetMaxY(self.topButton.frame), width, height)];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加wkWebView视图&lt;/span&gt;
&lt;span&gt;    [self.view addSubview:self.topButton];
    [self.view addSubview:self.wkWebView];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为wkWebView创建桥接器&lt;/span&gt;
    self.bridge =&lt;span&gt; [WebViewJavascriptBridge bridgeForWebView:self.wkWebView];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OC注册方法，提供给JavaScript调用，并给JavaScript传递数据&lt;/span&gt;
    [self.bridge registerHandler:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;updateTopButtonBgColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; handler:^(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; data, WVJBResponseCallback responseCallback) {
        UIColor &lt;/span&gt;*randomColor = [UIColor colorWithRed:arc4random_uniform(&lt;span&gt;255&lt;/span&gt;)/&lt;span&gt;255.0&lt;/span&gt; green:arc4random_uniform(&lt;span&gt;255&lt;/span&gt;)/&lt;span&gt;255.0&lt;/span&gt; blue:arc4random_uniform(&lt;span&gt;255&lt;/span&gt;)/&lt;span&gt;255.0&lt;/span&gt; alpha:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;];
        self.topButton.backgroundColor &lt;/span&gt;=&lt;span&gt; randomColor;
        [self showAlertView:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;JavaScript调用OC ----- success! &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
        responseCallback(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;JavaScript调用OC ----- success! &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以回调给JavaScript一个结果&lt;/span&gt;
&lt;span&gt;    }];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载资源&lt;/span&gt;
    NSString *file = [[NSBundle mainBundle] pathForResource:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ofType:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    NSString &lt;/span&gt;*html =&lt;span&gt; [NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil];
    [self.wkWebView loadHTMLString:html baseURL:nil];
}

&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; mark - remove
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidDisappear:(BOOL)animated {
    [super viewDidDisappear:animated];
    [self.bridge removeHandler:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;updateTopButtonBgColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
}

&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; mark -action
-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)topButtonAction {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用JavaScript函数，传递颜色参数，并接收JavaScript回传的数据&lt;/span&gt;
    NSArray *colors = [NSArray arrayWithObjects:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,nil];
    [self.bridge callHandler:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;updateDivBgColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data:colors[arc4random_uniform(&lt;span&gt;4&lt;/span&gt;)] responseCallback:^(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; responseData) {
        [self showAlertView:responseData];
    }];
}

&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; mark - method
-(&lt;span&gt;void&lt;/span&gt;)showAlertView:(NSString *&lt;span&gt;)message {
    UIAlertController &lt;/span&gt;*aletVc = [UIAlertController alertControllerWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; message:message preferredStyle:UIAlertControllerStyleAlert];
    UIAlertAction &lt;/span&gt;*action = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;知道了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; style:UIAlertActionStyleDefault handler:nil];
    [aletVc addAction:action];
    [self presentViewController:aletVc animated:YES completion:nil];
}


&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;细分步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、创建HTML，完成初始工作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      .divcss&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#F00&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#FFF&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;300px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;200px&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; button_onclick(){
        &lt;/span&gt;&lt;span&gt;//JavaScript&lt;/span&gt;&lt;span&gt;调用OC注册的方法，并接收OC的数据&lt;/span&gt;
&lt;span&gt;        WebViewJavascriptBridge.callHandler(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;updateTopButtonBgColor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(responseValue) {
            alert(responseValue);
        });
    }

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 固定函数 &lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; setupWebViewJavascriptBridge(callback) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (window.WebViewJavascriptBridge) { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; callback(WebViewJavascriptBridge); }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (window.WVJBCallbacks) { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; window.WVJBCallbacks.push(callback); }
        window.WVJBCallbacks &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [callback];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; WVJBIframe &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.createElement(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        WVJBIframe.style.display &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        WVJBIframe.src &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://__bridge_loaded__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        document.documentElement.appendChild(WVJBIframe);
        setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { document.documentElement.removeChild(WVJBIframe) }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化&lt;/span&gt;
&lt;span&gt;    setupWebViewJavascriptBridge(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(bridge){
       
         &lt;/span&gt;&lt;span&gt;//JavaScript&lt;/span&gt;&lt;span&gt;调用OC注册的方法，并接收OC的数据，页面启动后会立即调用且调用一次，我把它放到了上面的👆button_onclick()事件中可以频繁执行&lt;/span&gt;
         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;WebViewJavascriptBridge.callHandler('changeTopButtonBgColor',function(responseValue) {&lt;/span&gt;
             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(responseValue);&lt;/span&gt;
         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;});&lt;/span&gt;
          
         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JavaScript注册函数，提供给OC调用，并传递数据给OC&lt;/span&gt;
&lt;span&gt;         bridge.registerHandler(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;updateDivBgColor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(colorData, responseCallback) {
             alert(colorData);
             document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).style.backgroundColor &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; colorData;
             responseCallback(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OC调用JavaScript ----- success! &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
         });
    });

  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;divcss&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;div&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2 &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align:center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; div盒子 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;button_onclick()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点击调用OC方法，切换TopButton的背景色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、导入头文件，定义控件属性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;头文件&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ViewController.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebViewJavascriptBridge/WebViewJavascriptBridge.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义属性&lt;/span&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; ViewController ()
@property (nonatomic, strong) WebViewJavascriptBridge &lt;/span&gt;*&lt;span&gt;bridge;
@property (nonatomic, strong) UIButton  &lt;/span&gt;*&lt;span&gt;topButton;
@property (nonatomic, strong) WKWebView &lt;/span&gt;*&lt;span&gt;wkWebView;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3、创建控件，并添加到父视图&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建topView&lt;/span&gt;
CGFloat width =&lt;span&gt; [UIScreen mainScreen].bounds.size.width;
self.topButton &lt;/span&gt;= [[UIButton alloc] initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, width, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;)];
self.topButton.titleLabel.numberOfLines &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
self.topButton.backgroundColor &lt;/span&gt;=&lt;span&gt; [UIColor blueColor];
self.topButton.titleLabel.font &lt;/span&gt;= [UIFont systemFontOfSize:&lt;span&gt;17&lt;/span&gt;&lt;span&gt;];
[self.topButton setTitle:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;我是TopButton\n点击我调用JS方法，切换div盒子的背景色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; forState:UIControlStateNormal];
[self.topButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
[self.topButton addTarget:self action:@selector(topButton) forControlEvents:UIControlEventTouchUpInside];
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建wkWebView&lt;/span&gt;
CGFloat height = [UIScreen mainScreen].bounds.size.height-&lt;span&gt;CGRectGetHeight(self.topButton.frame);
self.wkWebView &lt;/span&gt;= [[WKWebView alloc] initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, CGRectGetMaxY(self.topButton.frame), width, height)];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加wkWebView视图&lt;/span&gt;
&lt;span&gt;[self.view addSubview:self.topButton];
[self.view addSubview:self.wkWebView];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4、创建桥接器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为wkWebView创建桥接器&lt;/span&gt;
self.bridge = [WebViewJavascriptBridge bridgeForWebView:self.wkWebView]; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5、JavaScript调用OC： 需要OC注册方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OC注册方法，提供给JavaScript调用，并给JavaScript传递数据&lt;/span&gt;
[self.bridge registerHandler:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;changeTopButtonBgColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; handler:^(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; data, WVJBResponseCallback responseCallback) {
    UIColor &lt;/span&gt;*randomColor = [UIColor colorWithRed:arc4random_uniform(&lt;span&gt;255&lt;/span&gt;)/&lt;span&gt;255.0&lt;/span&gt; green:arc4random_uniform(&lt;span&gt;255&lt;/span&gt;)/&lt;span&gt;255.0&lt;/span&gt; blue:arc4random_uniform(&lt;span&gt;255&lt;/span&gt;)/&lt;span&gt;255.0&lt;/span&gt; alpha:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;];
    self.topButton.backgroundColor &lt;/span&gt;=&lt;span&gt; randomColor;
    [self showAlertView:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;JavaScript调用OC ----- success! &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    responseCallback(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;JavaScript调用OC ----- success! &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以回调给JavaScript一个结果&lt;/span&gt;
}];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6、OC调用JavaScript：需要在HTML中注册JS函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原生按钮事件&lt;/span&gt;
-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)topButtonAction {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用JavaScript函数，传递颜色参数，并接收JavaScript回传的数据&lt;/span&gt;
    NSArray *colors = [NSArray arrayWithObjects:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,nil];
    [self.bridge callHandler:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;updateDivBgColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data:colors[arc4random_uniform(&lt;span&gt;4&lt;/span&gt;)] responseCallback:^(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; responseData) {
        [self showAlertView:responseData];
    }];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;7、加载HTML资源&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载资源&lt;/span&gt;
NSString *file = [[NSBundle mainBundle] pathForResource:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ofType:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
NSString &lt;/span&gt;*html =&lt;span&gt; [NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil];
[self.wkWebView loadHTMLString:html baseURL:nil];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;8、清除工作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要清除注册到桥接器中的函数，否则导致vc无法释放&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidDisappear:(BOOL)animated {
    [super viewDidDisappear:animated];
    [self.bridge removeHandler:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;updateTopButtonBgColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;9、显示结果如下：可以发现TopButton和div的背景色都能频繁改变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/791499/201911/791499-20191118002126662-71666961.gif&quot; alt=&quot;&quot; width=&quot;812&quot; height=&quot;541&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 17 Nov 2019 16:47:00 +0000</pubDate>
<dc:creator>菩提树下苦思</dc:creator>
<og:description>一、简介 在前面两篇文章中已经介绍了Native与JavaScript交互的几种方式，依次是JavaScriptCore框架、UI组件UIWebView、WebKit框架，这几种方式都是苹果公司提供的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/XYQ-208910/p/11877423.html</dc:identifier>
</item>
<item>
<title>012.Kubernetes二进制部署worker节点Flannel - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/11879332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/11879332.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;一 部署flannel&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;1.1 安装flannel&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;kubernetes 要求集群内各节点(包括 master 节点)能通过 Pod 网段互联互通。flannel 使用 vxlan 技术为各节点创建一个可以互通的 Pod 网络，使用的端口为 UDP 8472。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;flanneld 第一次启动时，从 etcd 获取配置的 Pod 网段信息，为本节点分配一个未使用的地址段，然后创建 flannedl.1 网络接口（也可能是其它名称，如 flannel1 等）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;flannel 将分配给自己的 Pod 网段信息写入 /run/flannel/docker 文件，docker 后续使用这个文件中的环境变量设置 docker0 网桥，从而从这个地址段为本节点的所有 Pod 容器分配 IP。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多flannel参考：《008.Docker Flannel+Etcd分布式网络部署》。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：k8smaster01节点已下载相应二进制，可直接分发至node节点。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.2 分发flannel&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# cd /opt/k8s/work
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 work]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  3&lt;/span&gt; [root@k8smaster01 work]# &lt;span&gt;for&lt;/span&gt; node_ip &lt;span&gt;in&lt;/span&gt; ${NODE_IPS[@]}
&lt;span&gt;  4&lt;/span&gt;   &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;     echo &quot;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; ${node_ip}&lt;/span&gt;&quot;
&lt;span&gt;  6&lt;/span&gt;     scp flannel/{flanneld,mk-docker-opts.sh} root@${node_ip}:/opt/k8s/bin/
&lt;span&gt;  7&lt;/span&gt;     ssh root@${node_ip} &quot;&lt;span&gt;chmod +x /opt/k8s/bin/*&lt;/span&gt;&quot;
&lt;span&gt;  8&lt;/span&gt;   done
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;1.3 创建flannel证书和密钥&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：k8smaster01节点已创建flanneld的CA证书请求文件，可直接分发至node节点。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.4 分发证书和私钥&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# cd /opt/k8s/work
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 work]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  3&lt;/span&gt; [root@k8smaster01 work]# &lt;span&gt;for&lt;/span&gt; node_ip &lt;span&gt;in&lt;/span&gt; ${NODE_IPS[@]}
&lt;span&gt;  4&lt;/span&gt;   &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;     echo &quot;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; ${node_ip}&lt;/span&gt;&quot;
&lt;span&gt;  6&lt;/span&gt;     ssh root@${node_ip} &quot;&lt;span&gt;mkdir -p /etc/flanneld/cert&lt;/span&gt;&quot;
&lt;span&gt;  7&lt;/span&gt;     scp flanneld*.pem root@${node_ip}:/etc/flanneld/cert
&lt;span&gt;  8&lt;/span&gt;   done
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;1.5 创建flanneld的systemd&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：k8smaster01节点已创建创建flanneld的systemd，可直接分发至node节点。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.6 分发flannel systemd&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# cd /opt/k8s/work
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 work]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  3&lt;/span&gt; [root@k8smaster01 work]# &lt;span&gt;for&lt;/span&gt; node_ip &lt;span&gt;in&lt;/span&gt; ${NODE_IPS[@]}
&lt;span&gt;  4&lt;/span&gt;   &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;     echo &quot;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; ${node_ip}&lt;/span&gt;&quot;
&lt;span&gt;  6&lt;/span&gt;     scp flanneld.service root@${node_ip}:/etc/systemd/system/
&lt;span&gt;  7&lt;/span&gt;   done
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 align=&quot;left&quot;&gt;二 启动并验证&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1 启动flannel&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# &lt;span&gt;for&lt;/span&gt; node_ip &lt;span&gt;in&lt;/span&gt; ${NODE_IPS[@]}
&lt;span&gt;  3&lt;/span&gt;   &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     echo &quot;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; ${node_ip}&lt;/span&gt;&quot;
&lt;span&gt;  5&lt;/span&gt;     ssh root@${node_ip} &quot;&lt;span&gt;systemctl daemon-reload &amp;amp;&amp;amp; systemctl enable flanneld &amp;amp;&amp;amp; systemctl restart flanneld&lt;/span&gt;&quot;
&lt;span&gt;  6&lt;/span&gt;   done
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;2.2 检查flannel启动&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# &lt;span&gt;for&lt;/span&gt; node_ip &lt;span&gt;in&lt;/span&gt; ${NODE_IPS[@]}
&lt;span&gt;  3&lt;/span&gt;   &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     echo &quot;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; ${node_ip}&lt;/span&gt;&quot;
&lt;span&gt;  5&lt;/span&gt;     ssh root@${node_ip} &quot;&lt;span&gt;systemctl status flanneld|grep Active&lt;/span&gt;&quot;
&lt;span&gt;  6&lt;/span&gt;   done
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235335088-1063296329.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;566&quot; height=&quot;159&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235335342-1229293551.png&quot; border=&quot;0&quot; data-attr-org-src-id=&quot;97CFEAA6E5C947CC80EFF381C0EC8125&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.3 检查pod网段信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# etcdctl \
&lt;span&gt;  3&lt;/span&gt;   --endpoints=${ETCD_ENDPOINTS} \
&lt;span&gt;  4&lt;/span&gt;   --ca-file=/etc/kubernetes/cert/ca.pem \
&lt;span&gt;  5&lt;/span&gt;   --cert-file=/etc/flanneld/cert/flanneld.pem \
&lt;span&gt;  6&lt;/span&gt;   --key-file=/etc/flanneld/cert/flanneld-key.pem \
&lt;span&gt;  7&lt;/span&gt;   get ${FLANNEL_ETCD_PREFIX}/config                   #查看集群 Pod 网段(/16)
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235335480-1030393024.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;592&quot; height=&quot;131&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235335609-2047171228.png&quot; border=&quot;0&quot; data-attr-org-src-id=&quot;BD9FD667C23F44729626E16A112F0591&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# etcdctl \
&lt;span&gt;  3&lt;/span&gt;   --endpoints=${ETCD_ENDPOINTS} \
&lt;span&gt;  4&lt;/span&gt;   --ca-file=/etc/kubernetes/cert/ca.pem \
&lt;span&gt;  5&lt;/span&gt;   --cert-file=/etc/flanneld/cert/flanneld.pem \
&lt;span&gt;  6&lt;/span&gt;   --key-file=/etc/flanneld/cert/flanneld-key.pem \
&lt;span&gt;  7&lt;/span&gt;   ls ${FLANNEL_ETCD_PREFIX}/subnets                   #查看已分配的 Pod 子网段列表(/24)
&lt;span&gt;  8&lt;/span&gt; [root@k8smaster01 ~]# etcdctl \
&lt;span&gt;  9&lt;/span&gt;   --endpoints=${ETCD_ENDPOINTS} \
&lt;span&gt; 10&lt;/span&gt;   --ca-file=/etc/kubernetes/cert/ca.pem \
&lt;span&gt; 11&lt;/span&gt;   --cert-file=/etc/flanneld/cert/flanneld.pem \
&lt;span&gt; 12&lt;/span&gt;   --key-file=/etc/flanneld/cert/flanneld-key.pem \
&lt;span&gt; 13&lt;/span&gt;   get ${FLANNEL_ETCD_PREFIX}/subnets/172.30.8.0-21    #查看某一 Pod 网段对应的节点 IP 和 flannel 接口地址
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235335757-534954434.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;756&quot; height=&quot;418&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235335910-671175630.png&quot; border=&quot;0&quot; data-attr-org-src-id=&quot;5D2B9A0ABBF04132AD3F9900F2D85D93&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;172.30.8.0/21 被分配给节点 k8snode02 （172.24.8.75）；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;VtepMAC 为 k8snode02 节点的 flannel.1 网卡 MAC 地址。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.4 检查flannel网络信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8snode02 ~]# ip addr show
&lt;/pre&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235336095-351533312.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;813&quot; height=&quot;210&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235336232-1946086371.png&quot; border=&quot;0&quot; data-attr-org-src-id=&quot;CD98FF6C972A47799E6732B876C1E1F0&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解释：flannel.1 网卡的地址为分配的 Pod 子网段的第一个 IP（.0），且是 /32 的地址。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;[root@k8smaster01 ~]# ip route show |grep flannel.1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;172.30.8.0/21 via 172.30.8.0 dev flannel.1 onlink&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;172.30.128.0/21 via 172.30.128.0 dev flannel.1 onlink&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;172.30.208.0/21 via 172.30.208.0 dev flannel.1 onlink&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;172.30.216.0/21 via 172.30.216.0 dev flannel.1 onlink&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;到其它节点 Pod 网段请求都被转发到 flannel.1 网卡；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flanneld 根据 etcd 中子网段的信息，如 ${FLANNEL_ETCD_PREFIX}/subnets/172.30.32.0-21 ，来决定进请求发送给哪个节点的互联 IP。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.5 验证各节点flannel&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在各节点上部署 flannel 后，检查是否创建了 flannel 接口(名称可能为 flannel0、flannel.0、flannel.1 等)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# &lt;span&gt;for&lt;/span&gt; all_ip &lt;span&gt;in&lt;/span&gt; ${ALL_IPS[@]}
&lt;span&gt;  3&lt;/span&gt;   &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     echo &quot;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; ${all_ip}&lt;/span&gt;&quot;
&lt;span&gt;  5&lt;/span&gt;     ssh ${all_ip} &quot;&lt;span&gt;/usr/sbin/ip addr show flannel.1|grep -w inet&lt;/span&gt;&quot;
&lt;span&gt;  6&lt;/span&gt;   done
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235336370-26221698.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;539&quot; height=&quot;242&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235336515-1197181747.png&quot; border=&quot;0&quot; data-attr-org-src-id=&quot;96AE5857E5CF4888A4DC1D820E329470&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在各节点上 ping 所有 flannel 接口 IP，确保能通：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# source /opt/k8s/bin/environment.sh
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# &lt;span&gt;for&lt;/span&gt; all_ip &lt;span&gt;in&lt;/span&gt; ${ALL_IPS[@]}
&lt;span&gt;  3&lt;/span&gt;   &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     echo &quot;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; ${all_ip}&lt;/span&gt;&quot;
&lt;span&gt;  5&lt;/span&gt;     ssh ${all_ip} &quot;&lt;span&gt;ping -c 1 172.30.8.0&lt;/span&gt;&quot;
&lt;span&gt;  6&lt;/span&gt;     ssh ${all_ip} &quot;&lt;span&gt;ping -c 1 172.30.32.0&lt;/span&gt;&quot;
&lt;span&gt;  7&lt;/span&gt;     ssh ${all_ip} &quot;&lt;span&gt;ping -c 1 172.30.128.0&lt;/span&gt;&quot;
&lt;span&gt;  8&lt;/span&gt;     ssh ${all_ip} &quot;&lt;span&gt;ping -c 1 172.30.208.0&lt;/span&gt;&quot;
&lt;span&gt;  9&lt;/span&gt;     ssh ${all_ip} &quot;&lt;span&gt;ping -c 1 172.30.216.0&lt;/span&gt;&quot;
&lt;span&gt; 10&lt;/span&gt;   done
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;center&quot; yne-bulb-block=&quot;image&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235336653-286293827.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;477&quot; height=&quot;291&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191117235336781-267908808.png&quot; border=&quot;0&quot; data-attr-org-src-id=&quot;A9552BE4F94540319F2096DEE169744A&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 17 Nov 2019 15:54:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一	部署flannel 1.1 安装flannel kubernetes 要求集群内各节点(包括 master 节点)能通过 Pod 网段互联互通。flannel 使用 vxlan 技术为各节点创建一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itzgr/p/11879332.html</dc:identifier>
</item>
</channel>
</rss>