<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>新手学分布式-动态修改Nginx配置的一些想法 - vikings`s blog</title>
<link>http://www.cnblogs.com/vikings-blog/p/11675270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vikings-blog/p/11675270.html</guid>
<description>&lt;p&gt;本人是分布式的新手，在实际工作中遇到了需要动态修改nginx的需求，因此写下实现过程中的想法。Nginx功能强大且灵活，所以这些权当抛砖引玉，希望可以得到大家的讨论和指点。(具体代码在 &lt;a href=&quot;https://andy-zhangtao.github.io/nginx2svg/&quot; class=&quot;uri&quot;&gt;https://andy-zhangtao.github.io/nginx2svg/&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;Nginx参数众多，并且配置是非灵活，因此要达到完美的自动化配置是一件很有挑战性的事情，这个工具并不能十分完美的自动化调整参数。目前支持自动化修改的参数有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;server&lt;/li&gt;
&lt;li&gt;upstream&lt;/li&gt;
&lt;li&gt;proxy_pass&lt;/li&gt;
&lt;li&gt;root&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面将介绍&lt;code&gt;Nginx2Svg&lt;/code&gt;是如何实现自动化修改参数的。&lt;/p&gt;
&lt;h3 id=&quot;预备知识&quot;&gt;预备知识&lt;/h3&gt;
&lt;p&gt;为了更好的理解&lt;code&gt;Nginx2Svg&lt;/code&gt;，需要一些很简单的预备知识。 首先需要了解Nginx的配置文件格式，一个典型的Nginx配置文件(假设此处Nginx作为7层反向负载使用)看起来应该是下面的样子:&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;# 抄自nginx官网 http://nginx.org/en/docs/example.html
     1  user  www www;
     2
     3  worker_processes  2;
     4
     5  pid /var/run/nginx.pid;
     6
     7  #                          [ debug | info | notice | warn | error | crit ]
     8
     9  error_log  /var/log/nginx.error_log  info;
    10
    11  events {
    12      worker_connections   2000;
    13
    14      # use [ kqueue | epoll | /dev/poll | select | poll ];
    15      use kqueue;
    16  }
    17
    18  http {
    19
    20      include       conf/mime.types;
    21      default_type  application/octet-stream;
    22
    23
    24      log_format main      '$remote_addr - $remote_user [$time_local] '
    25                           '&quot;$request&quot; $status $bytes_sent '
    26                           '&quot;$http_referer&quot; &quot;$http_user_agent&quot; '
    27                           '&quot;$gzip_ratio&quot;';
    28
    29      log_format download  '$remote_addr - $remote_user [$time_local] '
    30                           '&quot;$request&quot; $status $bytes_sent '
    31                           '&quot;$http_referer&quot; &quot;$http_user_agent&quot; '
    32                           '&quot;$http_range&quot; &quot;$sent_http_content_range&quot;';
    33
    34      client_header_timeout  3m;
    35      client_body_timeout    3m;
    36      send_timeout           3m;
    37
    38      client_header_buffer_size    1k;
    39      large_client_header_buffers  4 4k;
    40
    41      gzip on;
    42      gzip_min_length  1100;
    43      gzip_buffers     4 8k;
    44      gzip_types       text/plain;
    45
    46      output_buffers   1 32k;
    47      postpone_output  1460;
    48
    49      sendfile         on;
    50      tcp_nopush       on;
    51      tcp_nodelay      on;
    52      send_lowat       12000;
    53
    54      keepalive_timeout  75 20;
    55
    56      #lingering_time     30;
    57      #lingering_timeout  10;
    58      #reset_timedout_connection  on;
    59
    60
    61      server {
    62          listen        one.example.com;
    63          server_name   one.example.com  www.one.example.com;
    64
    65          access_log   /var/log/nginx.access_log  main;
    66
    67          location / {
    68              proxy_pass         http://127.0.0.1/;
    69              proxy_redirect     off;
    70
    71              proxy_set_header   Host             $host;
    72              proxy_set_header   X-Real-IP        $remote_addr;
    73              #proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;
    74
    75              client_max_body_size       10m;
    76              client_body_buffer_size    128k;
    77
    78              client_body_temp_path      /var/nginx/client_body_temp;
    79
    80              proxy_connect_timeout      70;
    81              proxy_send_timeout         90;
    82              proxy_read_timeout         90;
    83              proxy_send_lowat           12000;
    84
    85              proxy_buffer_size          4k;
    86              proxy_buffers              4 32k;
    87              proxy_busy_buffers_size    64k;
    88              proxy_temp_file_write_size 64k;
    89
    90              proxy_temp_path            /var/nginx/proxy_temp;
    91
    92              charset  koi8-r;
    93          }
    94
    95          error_page  404  /404.html;
    96
    97          location = /404.html {
    98              root  /spool/www;
    99          }
   100
   101          location /old_stuff/ {
   102              rewrite   ^/old_stuff/(.*)$  /new_stuff/$1  permanent;
   103          }
   104
   105          location /download/ {
   106
   107              valid_referers  none  blocked  server_names  *.example.com;
   108
   109              if ($invalid_referer) {
   110                  #rewrite   ^/   http://www.example.com/;
   111                  return   403;
   112              }
   113
   114              #rewrite_log  on;
   115
   116              # rewrite /download/*/mp3/*.any_ext to /download/*/mp3/*.mp3
   117              rewrite ^/(download/.*)/mp3/(.*)\..*$
   118                      /$1/mp3/$2.mp3                   break;
   119
   120              root         /spool/www;
   121              #autoindex    on;
   122              access_log   /var/log/nginx-download.access_log  download;
   123          }
   124
   125          location ~* \.(jpg|jpeg|gif)$ {
   126              root         /spool/www;
   127              access_log   off;
   128              expires      30d;
   129          }
   130      }
   131  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从18行到131行属于&lt;code&gt;http&lt;/code&gt;配置内容，在这部分参数中，第61行到130行属于&lt;code&gt;server&lt;/code&gt;配置内容，(一个server对应一个虚拟主机)，&lt;code&gt;server&lt;/code&gt;的参数属于&lt;code&gt;http&lt;/code&gt;参数的子集，当相同参数出现时，&lt;code&gt;server&lt;/code&gt;优先级会高于&lt;code&gt;http&lt;/code&gt;。按照作用域来做类比，&lt;code&gt;http&lt;/code&gt;就是全局变量，&lt;code&gt;server&lt;/code&gt;就是局部变量。&lt;/p&gt;
&lt;p&gt;所以18行到60行属于全局变量,而61行到130则属于局部变量。 为了简化后面的操作，我们可以简化&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;server&lt;/code&gt;之间的包含关系，如下:&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;     1  user  nginx;
     2  worker_processes  1;
     3
     4  error_log  /var/log/nginx/error.log warn;
     5  pid        /var/run/nginx.pid;
     6
     7
     8  events {
     9      worker_connections  1024;
    10  }
    11
    12
    13  http {
    15      include       /etc/nginx/mime.types;
    16      default_type  application/octet-stream;
    17
    18      log_format main      '$remote_addr - $remote_user [$time_local] '
    19                           '&quot;$request&quot; $status $bytes_sent '
    20                           '&quot;$http_referer&quot; &quot;$http_user_agent&quot; '
    21                           '&quot;$gzip_ratio&quot;';
    22
    23      log_format download  '$remote_addr - $remote_user [$time_local] '
    24                           '&quot;$request&quot; $status $bytes_sent '
    25                           '&quot;$http_referer&quot; &quot;$http_user_agent&quot; '
    26                           '&quot;$http_range&quot; &quot;$sent_http_content_range&quot;';
    27
    28      access_log  /var/log/nginx/access.log  main;
    29
    30      sendfile        on;
    31
    32      keepalive_timeout  65;
    33
    34
    35      server {
    36          listen  80  default_server;
    37          server_name  _;
    38
    39          location /status {
    40              vhost_traffic_status_display;
    41              vhost_traffic_status_display_format html;
    42          }
    43      }
    44
    45      include /etc/nginx/conf.d/*.conf;
    46  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;include&lt;/code&gt;引入其它server配置文件，而上面的内容可以作为&lt;code&gt;nginx.conf&lt;/code&gt;全局默认配置文件，基本就不再修改了。而以后我们所要动态修改的配置文件就是&lt;code&gt;/etc/nginx/conf.d/*.conf&lt;/code&gt;这部分。&lt;/p&gt;
&lt;h3 id=&quot;配置规则&quot;&gt;配置规则&lt;/h3&gt;
&lt;p&gt;如果要达到自动化配置的目标，那么就需要设定一些规则。 下面是为了满足自动化而设置的规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置文件规则
&lt;ul&gt;&lt;li&gt;必须存在server_name。&lt;/li&gt;
&lt;li&gt;文件名以[server name].conf进行命名。 假设server_name为example.com, 则配置文件名就是example.com.conf。&lt;/li&gt;
&lt;li&gt;一个文件&lt;strong&gt;有并且只有&lt;/strong&gt;一个server段&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;配置内容规则
&lt;ul&gt;&lt;li&gt;同一个配置文件中location不重复(正则表达式不在限制范围内)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;解析规则&quot;&gt;解析规则&lt;/h3&gt;
&lt;p&gt;在满足上述两个规则的前提下，我们来看如何实现Nginx参数的自动化配置。首先要明确实现nginx自动化配置的难点在哪里? 基于我的使用经验来看，难点在于以下三点:&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;nginx配置相当灵活，属于&lt;code&gt;非结构化&lt;/code&gt;语义&lt;br/&gt;虽然nginx明确了配置文件的内容和格式，但在配置上可以任意组合(在执行nginx -t或者reload时才会真正验证)。因此配置文件只规定了最低门槛的&lt;code&gt;结构范式&lt;/code&gt;，而并没有规定严谨的配置格式，造成了只要符合语义都可以验证成功。这一点在使用者眼里是非常灵活的优点，但从自动化角度来说则是很大的痛点，因为找不到一个统一的解析格式来理解语义。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;验证和回滚&lt;br/&gt;nginx是基于文本来进行配置的，每一次修改都是通过IO操作生成文本配置文件而后在加载在每个worker中。 因此当验证失败时，如何将新增/删除的内容恢复到上一个版本中，就变成了一个问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;个性化配置&lt;br/&gt;在真实业务场景中，nginx配置必然无法做到一个配置吃遍天。当某些server需要添加个性化配置参数时，如何平衡个性化配置和自动化配置，也变成了一个需要考虑的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当找到上述三个问题的答案时，大体就可以满足自动化配置的要求了。&lt;/p&gt;
&lt;p&gt;首先来看第一个问题。&lt;/p&gt;
&lt;p&gt;如果因为nginx配置灵活而导致正面解析nginx配置文件是一个很困难的事情，那么可以尝试换个角度来理解这个问题。 &lt;strong&gt;如果变化很多而不容易解析，那么就不要让它变化了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体怎么理解呢？ nginx是通过语义来验证的，也就是nginx自身其实对&lt;code&gt;结构&lt;/code&gt;不敏感的(可以反向证明，如果nginx是依赖结构来理解配置的，那么它应该会规定严谨的配置结构)。所以我们可以事先定义好每个配置文件的配置格式，如下:&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;     1
     2
     3  upstream 5d148ba37f325500011770af {
     4      server  xxxxx ;
     5  }
     6
     7
     8  server{
     9
    10    server_name web1.example.com;
    11
    12
    13
    14
    15    location /server1 {
    16      proxy_pass http://5d148ba37f325500011770af;
    17      proxy_set_header X-Real-IP $remote_addr;
    18      proxy_set_header Host $host;
    19      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    20      proxy_next_upstream error timeout http_500 http_502 http_503 http_504 non_idempotent;
    21
    22
    23
    24    }
    25
    26  }
    27&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个配置文件都规定好配置结构如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;upstream&lt;/code&gt;都统一放置在&lt;code&gt;server&lt;/code&gt;之前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server_name&lt;/code&gt;放置在&lt;code&gt;location&lt;/code&gt;之前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy_pass&lt;/code&gt; 放置在每个&lt;code&gt;location&lt;/code&gt;首行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当每个配置文件都满足上述三个条件时，自动化解析程序就可以按照设定好的规则解析并尝试理解每段语义。&lt;/p&gt;
&lt;p&gt;只解析文件还不够，还需要能&lt;code&gt;动态修改&lt;/code&gt;才可以。 再回到上面的配置内容，里面的变量有三部分，按照从上往下依次是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;upstream的server IP列表&lt;/li&gt;
&lt;li&gt;server_name中的domain列表&lt;/li&gt;
&lt;li&gt;location列表&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;动态修改更准确的就是如何动态修改上面三部分值，这三部分的关联关系如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
    +-------------+
    | server_name |
    |   domain1   |
    |   domain2   |                 +-----------------+                 +-----------------+
    |   domain3   |---------------&amp;gt; |    location1    |--------------&amp;gt;  |   upstream1     |
    |   .......   |                 +-----------------+                 +-----------------+
    |   domainN   |
    +-------------+
                                    +-----------------+                 +-----------------+
                                    |    location2    |--------------&amp;gt;  |   upstream2     |
                                    +-----------------+                 +-----------------+


                                    +-----------------+                 +-----------------+
                                    |    locationN    |--------------&amp;gt;  |  upstreamN      |
                                    +-----------------+                 +-----------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同一个组的&lt;code&gt;server_name&lt;/code&gt;共享所有的&lt;code&gt;location&lt;/code&gt;数据，而每一个&lt;code&gt;location&lt;/code&gt;则通过&lt;code&gt;proxy_pass&lt;/code&gt;指向特定的&lt;code&gt;upstream&lt;/code&gt;(可以是不同的，也可以是相同的upstream)。&lt;/p&gt;
&lt;p&gt;从上图可以看出&lt;code&gt;server_name&lt;/code&gt;和&lt;code&gt;location&lt;/code&gt;在一个作用域中(在同一个&lt;code&gt;{}&lt;/code&gt;中)而&lt;code&gt;upstream&lt;/code&gt;则游离在外。&lt;/p&gt;
&lt;p&gt;三个问题中，server_name可以通过&lt;code&gt;server_name&lt;/code&gt;准确定位，&lt;code&gt;location&lt;/code&gt;也可以准确定位，此时如何从&lt;code&gt;location&lt;/code&gt;通过&lt;code&gt;proxy_pass&lt;/code&gt;定位到&lt;code&gt;upstream&lt;/code&gt;则变成了当前的难点。&lt;/p&gt;
&lt;p&gt;在实际使用过程中，我通过添加&lt;code&gt;锚点&lt;/code&gt;来解决这个问题，具体来说就是增加一组&lt;code&gt;upstream&lt;/code&gt;辅助定位数据，例如下图中的数据:&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;     1
     2  ### [5d148ba37f325500011770af]-[/]-[upstream]-[start]
     3  upstream 5d148ba37f325500011770af {
     4      server  xxxxx ;
     5  }
     6  ### [5d148ba37f325500011770af]-[/]-[upstream]-[end]
     7
     8  server{
     9
    10    server_name web1.example.com;
    11
    12
    13
    14
    15    location /server1 {
    16      proxy_pass http://5d148ba37f325500011770af;
    17      proxy_set_header X-Real-IP $remote_addr;
    18      proxy_set_header Host $host;
    19      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    20      proxy_next_upstream error timeout http_500 http_502 http_503 http_504 non_idempotent;
    21
    22
    23
    24    }
    25
    26  }
    27&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二行和第六行就是添加的&lt;code&gt;锚点&lt;/code&gt;。 锚点数据需要满足的条件是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同一个配置文件中不重复&lt;/li&gt;
&lt;li&gt;有良好的区分度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此设计了上述的&lt;code&gt;锚点&lt;/code&gt;数据，其格式如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    ### [5d148ba37f325500011770af]-[/]-[upstream]-[start]
    ----------------------------------------------------
    ### [24位随机数]-[/]-[upstream]-[开始/结束标示]
    ①       ②           ③             ④

    ① 三个#开头
    ② 满足锚点，upstream名称和proxy_pass一致，也就是第二行，第三行和第十六行使用同一个24位随机数
    ③ 固定格式,用来保证和其它注释信息不重复
    ④ start表示upstream开始， end表示upstream结束。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此一个完整的自动化配置流程如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;    // 假设配置web1.example.com的/server1 反向配置

    if web1.example.com.conf 存在
        逐行读取文件内容

        if 找到 server1的location行
            解析 proxy_pass，找到 24位随机数

            从头开始读取文件内容

            if 找到 ### [xxxx]-[/]-[upstream]-[start]
                找到锚点，此行往下两行是ip列表，开始修改
            else
                没找到锚点，配置文件出错，人工介入
        else
            // 当前没有此location配置，新建location和upstream
            新建location配置
            新建相匹配的upstream配置

    else
        // 当前没有此域名配置，新建一个
        创建 web1.example.com.conf，内容按照既定格式创建
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;个性化支持&quot;&gt;个性化支持&lt;/h3&gt;
&lt;p&gt;从上面的解析规则来看，如果要支持个性化支持，那么在理解语义时要做到&lt;code&gt;适可而止&lt;/code&gt;，也就是只需要解析到需要的数据就可以了，其它数据原样复制。例如用户在&lt;code&gt;location&lt;/code&gt;中添加了个性化参数(需要满足&lt;code&gt;配置规则第三条&lt;/code&gt;)，那么只要解析出&lt;code&gt;proxy_pass&lt;/code&gt;就可以，后续的数据原样复制不要做变更。&lt;/p&gt;
</description>
<pubDate>Tue, 15 Oct 2019 00:16:00 +0000</pubDate>
<dc:creator>vikings`s blog</dc:creator>
<og:description>本人是分布式的新手，在实际工作中遇到了需要动态修改nginx的需求，因此写下实现过程中的想法。Nginx功能强大且灵活，所以这些权当抛砖引玉，希望可以得到大家的讨论和指点。(具体代码在 https:/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vikings-blog/p/11675270.html</dc:identifier>
</item>
<item>
<title>MongoDB 走马观花(全面解读篇) - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/11675233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/11675233.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201910/242916-20191013234822169-1254227887.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;MongoDB 是一款流行的开源文档型数据库，从它的命名来看，确实是有一定野心的。&lt;br/&gt;MongoDB 的原名一开始&lt;strong&gt;来自于 英文单词&quot;Humongous&quot;, 中文含义是指&quot;庞大&quot;&lt;/strong&gt;，即命名者的意图是可以处理大规模的数据。&lt;/p&gt;
&lt;p&gt;但笔者更喜欢称呼它为 &quot;芒果&quot;数据库，除了译音更加相近之外，原因还来自于这几年使用 MongoDB 的两层感觉：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第一层感受是&quot;爽&quot;，使用这个文档数据库的特点是几乎不受什么限制，一方面Json文档式的结构更容易理解，而无Schema约束也让DDL管理更加简单，一切都可以很快速的进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二层感受是&quot;酸爽&quot;，这点相信干运维或是支撑性工作的兄弟感受会比较深刻，MongoDB 由于入门体验&quot;太过于友好&quot;，导致一些团队认为用好这个数据库是个很简单的事情，所以开发兄弟在存量系统上埋一些坑也是正常的事情。&lt;br/&gt;所谓交付一时爽，维护火葬场.. 当然了，这句话可能有些过。 但这里的潜台词是：与传统的RDBMS数据库一样，MongoDB 在使用上也需要认真的考量和看护，不然的化，会遇到更多的坑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，尽管文档数据库在选型上会让一些团队望而却步，仍然不阻碍该数据库所获得的一些支持，比如 DB-Engine 上的排名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201910/242916-20191013235025745-527250473.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图-DBEngine排名&lt;/p&gt;
&lt;p&gt;在全部的排名中，MongoDB 长期排在第5位(文档数据库排名第1位)，同时也是最受欢迎的 NoSQL 数据库。&lt;br/&gt;另外，MongoDB 的社区一直比较活跃，加上商业上的驱动(MongoDB于2017年在纳斯达克上市)，这些因素都推动了该开源数据库的发展。&lt;/p&gt;
&lt;p&gt;如果对于 MongoDB的发展史感兴趣，可以参考下&lt;a href=&quot;https://www.infoq.cn/article/XBME_sTIRA5fA8NDCaGj&quot;&gt;没有一个技术天生完美，MongoDB 十年发展全纪录&lt;/a&gt;这篇文章。&lt;/p&gt;
&lt;p&gt;MongoDB 数据库的一些特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面向文档存储，基于JSON/BSON 可表示灵活的数据结构&lt;/li&gt;
&lt;li&gt;动态 DDL能力，没有强Schema约束，支持快速迭代&lt;/li&gt;
&lt;li&gt;高性能计算，提供基于内存的快速数据查询&lt;/li&gt;
&lt;li&gt;容易扩展，利用数据分片可以支持海量数据存储&lt;/li&gt;
&lt;li&gt;丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。&lt;/li&gt;
&lt;li&gt;跨平台版本、支持多语言SDK..&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假定你是初次了解 MongoDB，下面的内容将能帮助你对该数据库技术的全貌产生一定的了解。&lt;/p&gt;
&lt;h2 id=&quot;二基本模型&quot;&gt;二、基本模型&lt;/h2&gt;
&lt;p&gt;数据结构对于一个软件来说是至关重要的，MongoDB 在概念模型上参考了 SQL数据库，但并非完全相同。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于这点，也有人说，MongoDB 是 NoSQL中最像SQL的数据库..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下表所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;collection&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;document&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;column&lt;/td&gt;
&lt;td&gt;field&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;database 数据库，与SQL的数据库(database)概念相同，一个数据库包含多个集合(表)&lt;/li&gt;
&lt;li&gt;collection 集合，相当于SQL中的表(table)，一个集合可以存放多个文档(行)。 不同之处就在于集合的结构(schema)是动态的，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何schema的校验。&lt;/li&gt;
&lt;li&gt;document 文档，相当于SQL中的行(row)，一个文档由多个字段(列)组成，并采用bson(json)格式表示。&lt;/li&gt;
&lt;li&gt;field 字段，相当于SQL中的列(column)，相比普通column的差别在于field的类型可以更加灵活，比如支持嵌套的文档、数组。&lt;br/&gt;此外，MongoDB中字段的类型是固定的、区分大小写、并且文档中的字段也是有序的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，SQL 还有一些其他的概念，对应关系如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;primary key&lt;/td&gt;
&lt;td&gt;_id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;foreign key&lt;/td&gt;
&lt;td&gt;reference&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;view&lt;/td&gt;
&lt;td&gt;view&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;join&lt;/td&gt;
&lt;td&gt;$lookup&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;transaction&lt;/td&gt;
&lt;td&gt;trasaction&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;group by&lt;/td&gt;
&lt;td&gt;aggregation&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;_id 主键，MongoDB 默认使用一个_id 字段来保证文档的唯一性。&lt;/li&gt;
&lt;li&gt;reference 引用，勉强可以对应于 外键(foreign key) 的概念，之所以是勉强是因为 reference 并没有实现任何外键的约束，而只是由客户端(driver)自动进行关联查询、转换的一个特殊类型。&lt;/li&gt;
&lt;li&gt;view 视图，MongoDB 3.4 开始支持视图，和 SQL 的视图没有什么差异，视图是基于表/集合之上进行动态查询的一层对象，可以是虚拟的，也可以是物理的(物化视图)。&lt;/li&gt;
&lt;li&gt;index 索引，与SQL 的索引相同。&lt;/li&gt;
&lt;li&gt;$lookup，这是一个聚合操作符，可以用于实现类似 SQL-join 连接的功能&lt;/li&gt;
&lt;li&gt;transaction 事务，从 MongoDB 4.0 版本开始，提供了对于事务的支持&lt;/li&gt;
&lt;li&gt;aggregation 聚合，MongoDB 提供了强大的聚合计算框架，group by 是其中的一类聚合操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bson-数据类型&quot;&gt;BSON 数据类型&lt;/h3&gt;
&lt;p&gt;MongoDB 文档可以使用 Javascript 对象表示，从格式上讲，是基于 JSON 的。&lt;/p&gt;
&lt;p&gt;一个典型的文档如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;_id&quot;: 1,
  &quot;name&quot; : { &quot;first&quot; : &quot;John&quot;, &quot;last&quot; : &quot;Backus&quot; },
  &quot;contribs&quot; : [ &quot;Fortran&quot;, &quot;ALGOL&quot;, &quot;Backus-Naur Form&quot;, &quot;FP&quot; ],
  &quot;awards&quot; : [
    {
      &quot;award&quot; : &quot;W.W. McDowell Award&quot;,
      &quot;year&quot; : 1967,
      &quot;by&quot; : &quot;IEEE Computer Society&quot;
    }, {
      &quot;award&quot; : &quot;Draper Prize&quot;,
      &quot;year&quot; : 1993,
      &quot;by&quot; : &quot;National Academy of Engineering&quot;
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;曾经，JSON 的出现及流行让 Web 2.0 的数据传输变得非常简单，所以使用 JSON 语法是非常容易让开发者接受的。&lt;br/&gt;但是 JSON 也有自己的短板，比如无法支持像日期这样的特定数据类型，因此 MongoDB 实际上使用的是一种扩展式的JSON，叫 BSON(Binary JSON)。&lt;/p&gt;
&lt;p&gt;BSON 所支持的数据类型包括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201910/242916-20191013235044329-1532573800.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图-BSON类型&lt;/p&gt;
&lt;h3 id=&quot;分布式id&quot;&gt;分布式ID&lt;/h3&gt;
&lt;p&gt;在单机时代，大多数应用可以使用数据库自增式ID 来作为主键。 传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。&lt;/p&gt;
&lt;p&gt;为了实现分布式数据ID的唯一性保证，应用开发者提出了自己的方案，而大多数方案中都会将ID分段生成，如著名的 snowflake 算法中就同时使用了时间戳、机器号、进程号以及随机数来保证唯一性。&lt;/p&gt;
&lt;p&gt;MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。&lt;br/&gt;_id 的生成规则如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201910/242916-20191013235053613-434845396.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图-ObjecteID&lt;/p&gt;
&lt;p&gt;其中包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4-byte Unix 时间戳&lt;/li&gt;
&lt;li&gt;3-byte 机器 ID&lt;/li&gt;
&lt;li&gt;2-byte 进程 ID&lt;/li&gt;
&lt;li&gt;3-byte 计数器(初始化随机)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得一提的是 _id 的生成实质上是由客户端(Driver)生成的，这样可以获得更好的随机性，同时降低服务端的负载。&lt;br/&gt;当然服务端也会检测写入的文档是否包含_id 字段，如果没有就生成一个。&lt;/p&gt;
&lt;h2 id=&quot;三操作语法&quot;&gt;三、操作语法&lt;/h2&gt;
&lt;p&gt;除了文档模型本身，对于数据的操作命令也是基于JSON/BSON 格式的语法。&lt;/p&gt;
&lt;p&gt;比如插入文档的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.insert(
{
  title: &quot;My first blog post&quot;,
  published: new Date(),
  tags: [ &quot;NoSQL&quot;, &quot;MongoDB&quot; ],
  type: &quot;Work&quot;,
  author : &quot;James&quot;,
  viewCount: 25,
  commentCount: 2
}
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行文档查找：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.find({author : &quot;James&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新文档的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.update(
   {&quot;_id&quot; : ObjectId(&quot;5c61301c15338f68639e6802&quot;)},
   {&quot;$inc&quot;: {&quot;viewCount&quot;: 3} }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除文档的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.remove({&quot;_id&quot;:
     ObjectId(&quot;5c612b2f15338f68639e67d5&quot;)})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在传统的SQL语法中，可以限定返回的字段，MongoDB可以使用Projection来表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.find({&quot;author&quot;: &quot;James&quot;}, 
    {&quot;_id&quot;: 1, &quot;title&quot;: 1, &quot;author&quot;: 1})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现简单的分页查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.find({})
    .sort({&quot;viewCount&quot; : -1})
    .skip(10).limit(5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种基于BSON/JSON 的语法格式并不复杂，它的表达能力或许要比SQL更加强大。&lt;br/&gt;与 MongoDB 做法类似的还有 ElasticSearch，后者是搜索数据库的佼佼者。&lt;/p&gt;
&lt;p&gt;关于文档操作与 SQL方式完整的对比，官方的文档描述得比较详细：&lt;br/&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/sql-comparison/&quot; class=&quot;uri&quot;&gt;https://docs.mongodb.com/manual/reference/sql-comparison/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么，一个有趣的问题是 MongoDB 能不能用 SQL进行查询？&lt;/p&gt;
&lt;p&gt;当然是可以！&lt;/p&gt;
&lt;p&gt;但需要注意这些功能并不是 MongoDB 原生自带的，而需要借由第三方工具平台实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端使用SQL，可以使用 mongobooster、studio3t 这样的工具&lt;/li&gt;
&lt;li&gt;服务端的话，可以看看 presto 之类的一些平台..&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四索引&quot;&gt;四、索引&lt;/h2&gt;
&lt;p&gt;无疑，索引是一个数据库的关键能力，MongoDB 支持非常丰富的索引类型。&lt;br/&gt;利用这些索引，可以实现快速的数据查找，而索引的类型和特性则是针对不同的应用场景设计的。&lt;/p&gt;
&lt;p&gt;索引的技术实现依赖于底层的存储引擎，在当前的版本中 MongoDB 使用 wiredTiger 作为默认的引擎。&lt;br/&gt;在索引的实现上使用了 B+树的结构，这与其他的传统数据库并没有什么不同。&lt;br/&gt;所以这是个好消息，&lt;strong&gt;大部分基于SQL数据库的一些索引调优技巧在 MongoDB 上仍然是可行的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201910/242916-20191013235107623-326553681.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图-B+树&lt;/p&gt;
&lt;p&gt;使用 ensureIndexes 可以为集合声明一个普通的索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.ensureIndex({author: 1})&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;author后面的数字 1 代表升序，如果是降序则是 -1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现复合式(compound)的索引，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.ensureIndex({type: 1, published: 1})&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只有对于复合式索引时，索引键的顺序才变得有意义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果索引的字段是数组类型，该索引就自动成为数组(multikey)索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.book.ensureIndex({tags: 1})&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;MongoDB 可以在复合索引上包含数组的字段，但最多只能包含一个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;索引特性&quot;&gt;索引特性&lt;/h3&gt;
&lt;p&gt;在声明索引时，还可以通过一些参数化选项来为索引赋予一定的特性，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;unique=true，表示一个唯一性索引&lt;/li&gt;
&lt;li&gt;expireAfterSeconds=3600，表示这是一个TTL索引，并且数据将在1小时后老化&lt;/li&gt;
&lt;li&gt;sparse=true，表示稀疏的索引，仅索引非空(non-null)字段的文档&lt;/li&gt;
&lt;li&gt;partialFilterExpression: { rating: { $gt: 5 }，条件式索引，即满足计算条件的文档才进行索引&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;索引分类&quot;&gt;索引分类&lt;/h3&gt;
&lt;p&gt;除了普通索引之外，MongoDB 支持的类型还包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哈希(HASH)索引，哈希是另一种快速检索的数据结构，MongoDB 的 HASH 类型分片键会使用哈希索引。&lt;/li&gt;
&lt;li&gt;地理空间索引，用于支持快速的地理空间查询，如寻找附近1公里的商家。&lt;/li&gt;
&lt;li&gt;文本索引，用于支持快速的全文检索&lt;/li&gt;
&lt;li&gt;模糊索引(Wildcard Index)，一种基于匹配规则的灵活式索引，在4.2版本开始引入。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;索引评估调优&quot;&gt;索引评估、调优&lt;/h3&gt;
&lt;p&gt;使用 explain() 命令可以用于查询计划分析，进一步评估索引的效果。&lt;br/&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; db.test.explain().find( { a : 5 } )

{
  &quot;queryPlanner&quot; : {
    ...
    &quot;winningPlan&quot; : {
      &quot;stage&quot; : &quot;FETCH&quot;,
      &quot;inputStage&quot; : {
        &quot;stage&quot; : &quot;IXSCAN&quot;,
        &quot;keyPattern&quot; : {
            &quot;a&quot; : 5
        },
        &quot;indexName&quot; : &quot;a_1&quot;,
        &quot;isMultiKey&quot; : false,
        &quot;direction&quot; : &quot;forward&quot;,
        &quot;indexBounds&quot; : {&quot;a&quot; : [&quot;[5.0, 5.0]&quot;]}
        }
    }},
   ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果 winningPlan 中可以看出执行计划是否高效，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;未能命中索引的结果，会显示COLLSCAN&lt;/li&gt;
&lt;li&gt;命中索引的结果，使用IXSCAN&lt;/li&gt;
&lt;li&gt;出现了内存排序，显示为 SORT&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于 explain 的结果说明，可以进一步参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/explain-results/index.html&quot; class=&quot;uri&quot;&gt;https://docs.mongodb.com/manual/reference/explain-results/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;五集群&quot;&gt;五、集群&lt;/h2&gt;
&lt;p&gt;在大数据领域常常提到的4V特征中，Volume(数据量大)是首当其冲被提及的。&lt;br/&gt;由于单机垂直扩展能力的局限，水平扩展的方式则显得更加的靠谱。 MongoDB 自带了这种能力，可以将数据存储到多个机器上以提供更大的容量和负载能力。&lt;br/&gt;此外，同时为了保证数据的高可用，MongoDB 采用副本集的方式来实现数据复制。&lt;/p&gt;
&lt;p&gt;一个典型的MongoDB集群架构会同时采用分片+副本集的方式，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201910/242916-20191013235121473-508176774.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图-MongoDB 分片集群(Shard Cluster)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;数据分片（Shards）&lt;br/&gt;分片用于存储真正的集群数据，可以是一个单独的 Mongod实例，也可以是一个副本集。 生产环境下Shard一般是一个 Replica Set，以防止该数据片的单点故障。&lt;br/&gt;对于分片集合(sharded collection)来说，每个分片上都存储了集合的一部分数据(按照分片键切分)，如果集合没有分片，那么该集合的数据都存储在数据库的 Primary Shard中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;配置服务器（Config Servers）&lt;br/&gt;保存集群的元数据（metadata），包含各个Shard的路由规则，配置服务器由一个副本集(ReplicaSet)组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;查询路由（Query Routers）&lt;br/&gt;Mongos是 Sharded Cluster 的访问入口，其本身并不持久化数据 。Mongos启动后，会从 Config Server 加载元数据，开始提供服务，并将用户的请求正确路由到对应的Shard。&lt;br/&gt;Sharding 集群可以部署多个 Mongos 以分担客户端请求的压力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分片机制&quot;&gt;分片机制&lt;/h3&gt;
&lt;p&gt;下面的几个细节，对于理解和应用 MongoDB 的分片机制比较重要，所以有必要提及一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 数据如何切分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，基于分片切分后的数据块称为 chunk，一个分片后的集合会包含多个 chunk，每个 chunk 位于哪个分片(Shard) 则记录在 Config Server(配置服务器)上。&lt;br/&gt;Mongos 在操作分片集合时，会自动根据分片键找到对应的 chunk，并向该 chunk 所在的分片发起操作请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据是根据分片策略来进行切分的，而分片策略则由 分片键(ShardKey)+分片算法(ShardStrategy)组成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MongoDB 支持两种分片算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;范围分片&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201803/242916-20180313215414431-1794878366.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，假设集合根据x字段来分片，x的取值范围为[minKey, maxKey]（x为整型，这里的minKey、maxKey为整型的最小值和最大值），将整个取值范围划分为多个chunk，每个chunk（默认配置为64MB）包含其中一小段的数据：&lt;br/&gt;如Chunk1包含x的取值在[minKey, -75)的所有文档，而Chunk2包含x取值在[-75, 25)之间的所有文档...&lt;/p&gt;
&lt;p&gt;范围分片能很好的满足&lt;strong&gt;范围查询&lt;/strong&gt;的需求，比如想查询x的值在[-30, 10]之间的所有文档，这时 Mongos 直接能将请求路由到 Chunk2，就能查询出所有符合条件的文档。 范围分片的缺点在于，如果 ShardKey 有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个chunk，无法扩展写的能力，比如使用_id作为 ShardKey，而MongoDB自动生成的id高位是时间戳，是持续递增的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哈希分片&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201803/242916-20180313215452408-135734433.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hash分片是根据用户的 ShardKey 先计算出hash值（64bit整型），再根据hash值按照&lt;strong&gt;范围分片&lt;/strong&gt;的策略将文档分布到不同的 chunk。&lt;br/&gt;由于 hash值的计算是随机的，因此 Hash 分片具有很好的离散性，可以将数据随机分发到不同的 chunk 上。 Hash 分片可以充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要查询多个 chunk 才能找出满足条件的文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 如何保证均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如前面的说明中，数据是分布在不同的 chunk上的，而 chunk 则会分配到不同的分片上，那么如何保证分片上的 数据(chunk) 是均衡的呢？&lt;br/&gt;在真实的场景中，会存在下面两种情况：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;A. 全预分配，chunk 的数量和 shard 都是预先定义好的，比如 10个shard，存储1000个chunk，那么每个shard 分别拥有100个chunk。&lt;br/&gt;此时集群已经是均衡的状态(这里假定)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;B. 非预分配，这种情况则比较复杂，一般当一个 chunk 太大时会产生分裂(split)，不断分裂的结果会导致不均衡；或者动态扩容增加分片时，也会出现不均衡的状态。 这种不均衡的状态由集群均衡器进行检测，一旦发现了不均衡则执行 chunk数据的搬迁达到均衡。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MongoDB 的数据均衡器运行于 Primary Config Server(配置服务器的主节点)上，而该节点也同时会控制 Chunk 数据的搬迁流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201803/242916-20180313215634205-450783831.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图-数据自动均衡&lt;/p&gt;
&lt;p&gt;对于数据的不均衡是根据两个分片上的 Chunk 个数差异来判定的，阈值对应表如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Fewer than 20&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;20-79&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;80 and greater&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;MongoDB 的数据迁移对集群性能存在一定影响，这点无法避免，目前的规避手段只能是将&lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/#sharding-schedule-balancing-window&quot;&gt;均衡窗口&lt;/a&gt;对齐到业务闲时段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 应用高可用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用节点可以通过同时连接多个 Mongos 来实现高可用，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201910/242916-20191013235137136-1930411436.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图- mongos 高可用&lt;/p&gt;
&lt;p&gt;当然，连接高可用的功能是由 Driver 实现的。&lt;/p&gt;
&lt;h3 id=&quot;副本集&quot;&gt;副本集&lt;/h3&gt;
&lt;p&gt;副本集又是另一个话题，实质上除了前面架构图所体现的，副本集可以作为 Shard Cluster 中的一个Shard(片)之外，对于规模较小的业务来说，也可以使用一个单副本集的方式进行部署。&lt;br/&gt;MongoDB 的副本集采取了一主多从的结构，即一个Primary Node + N* Secondary Node的方式，数据从主节点写入，并复制到多个备节点。&lt;/p&gt;
&lt;p&gt;典型的架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201803/242916-20180313214746630-2040647850.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用副本集，我们可以实现：：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库高可用，主节点宕机后，由备节点自动选举成为新的主节点；&lt;/li&gt;
&lt;li&gt;读写分离，读请求可以分流到备节点，减轻主节点的单点压力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请注意，读写分离只能增加集群&quot;读&quot;的能力，对于写负载非常高的情况却无能为力。&lt;br/&gt;对此需求，使用分片集群并增加分片，或者提升数据库节点的磁盘IO、CPU能力可以取得一定效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选举&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MongoDB 副本集通过 Raft 算法来完成主节点的选举，这个环节在初始化的时候会自动完成，如下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config = {
    _id : &quot;my_replica_set&quot;,
    members : [
        {_id : 0, host : &quot;rs1.example.net:27017&quot;},
        {_id : 1, host : &quot;rs2.example.net:27017&quot;},
        {_id : 2, host : &quot;rs3.example.net:27017&quot;},
  ]
}
rs.initiate(config)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;initiate 命令用于实现副本集的初始化，在选举完成后，通过 isMaster()命令就可以看到选举的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; db.isMaster()

{
    &quot;hosts&quot; : [
    &quot;192.168.100.1:27030&quot;,
    &quot;192.168.100.2:27030&quot;,
    &quot;192.168.100.3:27030&quot;
    ],
    &quot;setName&quot; : &quot;myReplSet&quot;,
    &quot;setVersion&quot; : 1,
    &quot;ismaster&quot; : true,
    &quot;secondary&quot; : false,
    &quot;primary&quot; : &quot;192.168.100.1:27030&quot;,
    &quot;me&quot; : &quot;192.168.100.1:27030&quot;,
    &quot;electionId&quot; : ObjectId(&quot;7fffffff0000000000000001&quot;),
    &quot;ok&quot; : 1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;受 Raft算法的影响，主节点的选举需要满足&quot;大多数&quot;原则，可以参考下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;因此，为了避免出现平票的情况，副本集的部署一般采用是基数个节点，比如3个，正所谓三人行必有我师..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;心跳&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在高可用的实现机制中，心跳(heartbeat)是非常关键的，判断一个节点是否宕机就取决于这个节点的心跳是否还是正常的。&lt;br/&gt;副本集中的每个节点上都会定时向其他节点发送心跳，以此来感知其他节点的变化，比如是否失效、或者角色发生了变化。&lt;br/&gt;利用心跳，MongoDB 副本集实现了自动故障转移的功能，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201803/242916-20180313214956548-1867816349.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，节点会每2秒向其他节点发出心跳，这其中包括了主节点。 如果备节点在10秒内没有收到主节点的响应就会主动发起选举。&lt;br/&gt;此时新一轮选举开始，新的主节点会产生并接管原来主节点的业务。 整个过程对于上层是透明的，应用并不需要感知，因为 Mongos 会自动发现这些变化。&lt;br/&gt;如果应用仅仅使用了单个副本集，那么就会由 Driver 层来自动完成处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主节点和备节点的数据是通过日志(oplog)复制来实现的，这很类似于 mysql 的 binlog。&lt;br/&gt;在每一个副本集的节点中，都会存在一个名为local.oplog.rs的特殊集合。 当 Primary 上的写操作完成后，会向该集合中写入一条oplog，&lt;br/&gt;而 Secondary 则持续从 Primary 拉取新的 oplog 并在本地进行回放以达到同步的目的。&lt;/p&gt;
&lt;p&gt;下面，看看一条 oplog 的具体形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
&quot;ts&quot; : Timestamp(1446011584, 2),
&quot;h&quot; : NumberLong(&quot;1687359108795812092&quot;),
&quot;v&quot; : 2,
&quot;op&quot; : &quot;i&quot;,
&quot;ns&quot; : &quot;test.nosql&quot;,
&quot;o&quot; : { &quot;_id&quot; : ObjectId(&quot;563062c0b085733f34ab4129&quot;), &quot;name&quot; : &quot;mongodb&quot;, &quot;score&quot; : &quot;100&quot; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的一些关键字段有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ts 操作的 optime，该字段不仅仅包含了操作的时间戳(timestamp)，还包含一个自增的计数器值。&lt;/li&gt;
&lt;li&gt;h 操作的全局唯一表示&lt;/li&gt;
&lt;li&gt;v oplog 的版本信息&lt;/li&gt;
&lt;li&gt;op 操作类型，比如 i=insert,u=update..&lt;/li&gt;
&lt;li&gt;ns 操作集合，形式为 database.collection&lt;/li&gt;
&lt;li&gt;o 指具体的操作内容，对于一个 insert 操作，则包含了整个文档的内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MongoDB 对于 oplog 的设计是比较仔细的，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;oplog 必须保证有序，通过 optime 来保证。&lt;/li&gt;
&lt;li&gt;oplog 必须包含能够进行数据回放的完整信息。&lt;/li&gt;
&lt;li&gt;oplog 必须是幂等的，即多次回放同一条日志产生的结果相同。&lt;/li&gt;
&lt;li&gt;oplog 集合是固定大小的，为了避免对空间占用太大，旧的 oplog 记录会被滚动式的清理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有兴趣的读者，可以参考官方文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/core/replica-set-oplog/index.html&quot; class=&quot;uri&quot;&gt;https://docs.mongodb.com/manual/core/replica-set-oplog/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;六事务与一致性&quot;&gt;六、事务与一致性&lt;/h2&gt;
&lt;p&gt;一直以来，&quot;不支持事务&quot; 是 MongoDB 一直被诟病的问题，当然也可以说这是 NoSQL 数据库的一种权衡(放弃事务，追求高性能、高可扩展)&lt;br/&gt;但实质上，MongoDB 很早就有事务的概念，但是这个事务只能是针对单文档的，即单个文档的操作是有原子性保证的。&lt;br/&gt;在4.0 版本之后，MongoDB 开始支持多文档的事务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4.0 版本支持副本集范围的多文档事务。&lt;/li&gt;
&lt;li&gt;4.2 版本支持跨分片的多文档事务(基于两阶段提交)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在事务的隔离性上，MongoDB 支持快照(snapshot)的隔离级别，可以避免脏读、不可重复读和幻读。&lt;br/&gt;尽管有了真正意义上的事务功能，但多文档事务对于性能有一定的影响，应用应该在充分评估后再做选用。&lt;/p&gt;
&lt;h3 id=&quot;一致性&quot;&gt;一致性&lt;/h3&gt;
&lt;p&gt;一致性是一个复杂的话题，而一致性更多从应用角度上提出的，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;向系统写入一条数据，应该能够马上读到写入的这个数据。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在分布式架构的CAP理论以及许多延续的观点中提到，由于网络分区的存在，要求系统在一致性和可用性之间做出选择，而不能两者兼得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201910/242916-20191013235157992-1841212933.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 -CAP理论&lt;/p&gt;
&lt;p&gt;在 MongoDB 中，这个选择是可以由开发者来定的。 MongoDB 允许客户端为其操作设定一定的级别或者偏好，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;read preference&lt;br/&gt;读取偏好，可指定读主节点、读备节点，或者是优先读主、优先读备、取最近的节点&lt;/li&gt;
&lt;li&gt;write concern&lt;br/&gt;写关注，指定写入结果达到什么状态时才返回，可以为无应答(none)、应答(ack)，或者是大多数节点完成了数据复制等等&lt;/li&gt;
&lt;li&gt;read concern&lt;br/&gt;读关注，指定读取的数据版本处于怎样的状态，可以为读本地、读大多数节点写入，或者是线性读(linearizable)等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用不同的设定将会产生对于C(一致性)、A(可用性)的不同的抉择，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将读偏好设置为 primary，此时读写都在主节点上。 这保证了数据的一致性，但一旦主节点宕机会导致失败(可用性降低)&lt;/li&gt;
&lt;li&gt;将读偏好设置为 secondaryPrefered，此时写主，优先读备，可用性提高了，但数据存在延迟(出现不一致)&lt;/li&gt;
&lt;li&gt;将读写关注都设置为 majority(大多数)，一致性提升了，但可用性也同时降低了(节点失效会导致大多数写失败)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于这种权衡的讨论会一直存在，而 MongoDB 除了提供多样化的选择之外，其主要是通过复制、基于心跳的自动failover等机制来降低系统发生故障时产生的影响，从而提升整体的可用性。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文主要揭示了 MongoDB 多个方面的细节，同时在使用体验上也借助 SQL 的概念做了一些对比。&lt;br/&gt;从笔者的角度看，MongoDB 的发展性是很强的，其灵活快速的开发模式、天生自带分布式等能力弥补了传统型SQL数据库的缺陷。当然，目前的 NewSQL 本质上也貌似在以&quot;模仿的方式&quot;弥补这些缺陷。&lt;/p&gt;
&lt;p&gt;希望本文的内容对你能有些参考。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Oct 2019 23:40:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 一、简介 MongoDB 是一款流行的开源文档型数据库，从它的命名来看，确实是有一定野心的。 MongoDB 的原名一开始 来自于 英文单词'Humongous', 中文含义是指'庞大'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/littleatp/p/11675233.html</dc:identifier>
</item>
<item>
<title>利用 SASS 简化 `nth-child` 样式的生成 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/generate_nth_child_style_using_sass.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/generate_nth_child_style_using_sass.html</guid>
<description>&lt;p&gt;考察如下的 HTML 片段，通过 CSS 的 &lt;code&gt;nth-child()&lt;/code&gt; 伪选择器实现列表的颜色循环，比如每三个一次循环。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-text-html-basic&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;1&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;2&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;3&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;4&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;5&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;6&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很容易地，我们能得出如下样式代码：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; {
  &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n + 1&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  }
  &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n + 2&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  }
  &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n + 3&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上，只三种颜色循环，简单情况下可这样处理。但样式多起来之后，上面代码显得很臃肿且不易维护。&lt;/p&gt;
&lt;p&gt;既然是使用 SASS，很容易想到可通过编写循环语句来将其简化。&lt;/p&gt;
&lt;p&gt;循环过程就是遍历一个预设的颜色列表，为每一个颜色生成相应的样式。&lt;/p&gt;
&lt;h2&gt;List &amp;amp; Map&lt;/h2&gt;
&lt;p&gt;首先需要定义一个对象来保存预设的颜色列表，SASS 中的 &lt;a href=&quot;https://sass-lang.com/documentation/values/lists&quot; rel=&quot;nofollow&quot;&gt;Lists&lt;/a&gt; 可满足条件。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用上面的 list:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
  &lt;span class=&quot;pl-e&quot;&gt;.color-&lt;/span&gt;#{$color} {
    &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译后输出：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-css&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-e&quot;&gt;.color-indigo&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;;
}

&lt;span class=&quot;pl-e&quot;&gt;.color-red&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;;
}

&lt;span class=&quot;pl-e&quot;&gt;.color-green&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，也可以定义 &lt;a href=&quot;https://sass-lang.com/documentation/values/maps&quot; rel=&quot;nofollow&quot;&gt;Map&lt;/a&gt; 类型，为每种颜色指定名字，这样使用的时候比较语义：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: (
  &quot;indigo&quot;: indigo,
  &quot;red&quot;: red,
  &quot;green&quot;: green
);

&lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt;, $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
  &lt;span class=&quot;pl-e&quot;&gt;.color-&lt;/span&gt;#{$name} {
    &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;索引&lt;/h2&gt;
&lt;p&gt;列表对象及其遍历如上，现在还需要在遍历过程中获得一个 index 索引值，用于生成 &lt;code&gt;3*n+index&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;index()&lt;/code&gt; 函数可以达到目的：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: (&lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
  $&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;dex($&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;, $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;pl-e&quot;&gt;.color-&lt;/span&gt;#{$index} {
    &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译后输出：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-css&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-e&quot;&gt;.color-1&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;;
}

&lt;span class=&quot;pl-e&quot;&gt;.color-2&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;;
}

&lt;span class=&quot;pl-e&quot;&gt;.color-3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成 &lt;code&gt;nth-child&lt;/code&gt; 样式&lt;/h2&gt;
&lt;p&gt;结合上面所有，可以得出生成 &lt;code&gt;nth-child&lt;/code&gt; 样式的代码：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: (&lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
    $&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;dex($&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;, $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n&lt;/span&gt; + #{$i&lt;span class=&quot;pl-c1&quot;&gt;n&lt;/span&gt;dex}) {
      &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译后输出：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-css&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n + 1&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;;
}
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n + 2&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;;
}
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n + 3&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到 &lt;code&gt;nth-child(3n + #{$index})&lt;/code&gt; 中的 &lt;code&gt;3&lt;/code&gt; 是硬编码。既然我们的颜色是在一个数组中，所以我们是知道总个数的，也就能替换掉这里硬编码的写法。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;length()&lt;/code&gt; 函数可获得 list 的长度。改进后的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: (&lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
    $&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;dex($&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;, $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(#{le&lt;span class=&quot;pl-c1&quot;&gt;n&lt;/span&gt;gth($colors)}n + #{$index}) {
      &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，如果后续有颜色增加，或顺序的调整，我们只需要更新 &lt;code&gt;$colors&lt;/code&gt; 变量的值即可。&lt;/p&gt;

&lt;p&gt;进一步，我们可以将上面遍历生成 &lt;code&gt;nth-child&lt;/code&gt; 的代码抽取成 mixin，这样可以被其他地方使用。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: (&lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;@mixin&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;nth-color&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
    $&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;dex($&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;, $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(#{le&lt;span class=&quot;pl-c1&quot;&gt;n&lt;/span&gt;gth($colors)}n + #{$index}) {
      &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    }
  }
}

&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;@include&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;nth-color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;mixin 的优化&lt;/h2&gt;
&lt;p&gt;但像上面这样还不能达到完全公用，因为 mixin 中使用了 &lt;code&gt;li&lt;/code&gt; 选择器，不是所有需要 &lt;code&gt;nth-child&lt;/code&gt; 样式的地方，都使用的 &lt;code&gt;li&lt;/code&gt; 元素，所以此处需要进行优化，使得 mixin 中的这部分内容灵活一点，以适用不同的使用环境。&lt;/p&gt;
&lt;p&gt;首先，使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 父选择器便可快速解决，这样生成的样式便由包含这个 mixin 的选择器决定了。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: (&lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;@mixin&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;nth-color&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
    $&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;dex($&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;, $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(#{le&lt;span class=&quot;pl-c1&quot;&gt;n&lt;/span&gt;gth($colors)}n + #{$index}) {
      &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    }
  }
}

&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; {
  &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;@include&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;nth-color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;诚然，这样修改过后，确实可以将该 mixin 使用于多个地方了。&lt;/p&gt;
&lt;p&gt;但考虑这么一种情况，因为上面列表比较简单，更加常见的情况是，列表中是另外复杂的元素，而不是单纯的一个元素，比如像下面这样：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-text-html-basic&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;className&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;item&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt;&amp;gt;title&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;desc goes here...&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;className&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;item&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt;&amp;gt;title&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;desc goes here...&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;className&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;item&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt;&amp;gt;title&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;desc goes here...&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在想针对列表元素中的 &lt;code&gt;h3&lt;/code&gt; 进行颜色的设置，即 &lt;code&gt;nth-child&lt;/code&gt; 中设置的 &lt;code&gt;color&lt;/code&gt; 只针对 &lt;code&gt;h3&lt;/code&gt; 而不是整个 &lt;code&gt;li&lt;/code&gt; 元素。&lt;/p&gt;
&lt;p&gt;结合前面的优化，似乎可以这样写：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
$colors: (indigo, red, green);

@mixin nth-color {
  @each $color in $colors {
    $index: index($colors, $color);
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;    &amp;amp;:nth-child(#{length($colors)}n + #{$index}) {&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    &amp;amp;:nth-child(#{length($colors)}n + #{$index}) h3{&lt;/span&gt;
      color: $color;
    }
  }
}

ul {
  li {
    @include nth-color;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译后的结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-css&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+1&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;;
}
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+2&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;;
}
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+3&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从结果来看，达到了目标。但又在 &lt;code&gt;nth-color&lt;/code&gt; 这个 mixin 中引入了 &lt;code&gt;h3&lt;/code&gt;，使其变得不再通用，问题又回到了之前。&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;&amp;amp;&lt;/code&gt; 只解决了 &lt;code&gt;nth-child&lt;/code&gt; 父级嵌套的问题，对于 &lt;code&gt;nth-child&lt;/code&gt; 后面还需要自定义选择器的情况，就需要用别的方式进一步优化。&lt;/p&gt;
&lt;h2&gt;给 &lt;code&gt;@mixin&lt;/code&gt; 传参&lt;/h2&gt;
&lt;p&gt;mixin 是可以接收参数的，通过外部传递选择器进来，可以达到将 &lt;code&gt;h3&lt;/code&gt; 从 mixin 从剥离的目的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;@mixin&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;nth-color&lt;/span&gt;($&lt;span class=&quot;pl-smi&quot;&gt;child&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
    $&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;dex($&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;, $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(#{le&lt;span class=&quot;pl-c1&quot;&gt;n&lt;/span&gt;gth($colors)}n + #{$index}) #{$child}{
      &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    }
  }
}

&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; {
  &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;@include&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;nth-color&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;h3&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;从 &lt;code&gt;@mixin&lt;/code&gt; 将参数传递到外面&lt;/h2&gt;
&lt;p&gt;最后，&lt;code&gt;nth-color&lt;/code&gt; 这个 mixin 还有一处不够灵活的地方，便是其样式内容。&lt;/p&gt;
&lt;p&gt;现在在其中写死了只有一个 &lt;code&gt;color: $color;&lt;/code&gt; 属性，也就是说，使用该 mixin 的地方只能用它来设置元素的字色。如果 mixin 能够将颜色传递出来，这样外部使用的时候就可以用到其他属性上，更加的灵活了。&lt;/p&gt;
&lt;p&gt;SASS 确实也提供了这么种机制，即 mixin 能够身外传递参数，借助 &lt;a href=&quot;https://sass-lang.com/documentation/at-rules/mixin#passing-arguments-to-content-blocks&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;@content&lt;/code&gt;&lt;/a&gt; 指令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@content&lt;/code&gt; 指令指代调用 mixin 时书写的模式内容部分。如下的代码直观展示了其功能：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
@mixin nth-color($child) {
  @each $color in $colors {
    $index: index($colors, $color);
    &amp;amp;:nth-child(#{length($colors)}n + #{$index}) #{$child}{
      color: $color;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      @content;&lt;/span&gt;
    }
  }
}

ul {
  li {
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;    @include nth-color(&quot;h3&quot;)&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    @include nth-color(&quot;h3&quot;){&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      border:1px solid orange;&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    };&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译后内容为：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-css&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+1&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;;
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;border&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;1&lt;span class=&quot;pl-k&quot;&gt;px&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;orange&lt;/span&gt;;
}
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+2&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;;
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;border&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;1&lt;span class=&quot;pl-k&quot;&gt;px&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;orange&lt;/span&gt;;
}
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+3&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;;
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;border&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;1&lt;span class=&quot;pl-k&quot;&gt;px&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;orange&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，外部书写的 &lt;code&gt;border: 1px solid orange;&lt;/code&gt; 通过 &lt;code&gt;@content&lt;/code&gt; 指代而放进了每个 &lt;code&gt;nth-child&lt;/code&gt; 样式中。只是这个 &lt;code&gt;border&lt;/code&gt; 的颜色现在还是写死的 &lt;code&gt;orange&lt;/code&gt;，现在来将其设置成跟随相应的字色，即跟着 &lt;code&gt;color&lt;/code&gt; 属性走。&lt;/p&gt;
&lt;p&gt;当我们使用 &lt;code&gt;@content(&amp;lt;arguments...&amp;gt;)&lt;/code&gt; 形式的 &lt;code&gt;@content&lt;/code&gt; 时，可以传递一些参数，外部调用该 mixin 时需要使用如下形式来获取传递的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@include &amp;lt;name&amp;gt; using (&amp;lt;arguments...&amp;gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;最终的 mixin&lt;/h2&gt;
&lt;p&gt;所以，最终版的代码为：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sass&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
$&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;: (&lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;@mixin&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;nth-color&lt;/span&gt;($&lt;span class=&quot;pl-smi&quot;&gt;child&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;@each&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; $&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt; {
    $&lt;span class=&quot;pl-smi&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;dex($&lt;span class=&quot;pl-smi&quot;&gt;colors&lt;/span&gt;, $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(#{le&lt;span class=&quot;pl-c1&quot;&gt;n&lt;/span&gt;gth($colors)}n + #{$index}) #{$child} {
      &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: $&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
      @&lt;span class=&quot;pl-ent&quot;&gt;content&lt;/span&gt; ($color)&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    }
  }
}

&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; {
  &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;@include&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;nth-color&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;h3&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;) us&lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt;g($&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;) {
      &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;border&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;1&lt;span class=&quot;pl-k&quot;&gt;px&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;solid&lt;/span&gt; #{$&lt;span class=&quot;pl-smi&quot;&gt;color&lt;/span&gt;}&lt;span class=&quot;pl-ii&quot;&gt;;&lt;/span&gt;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译后得到的 CSS：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-css&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+1&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;;
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;border&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;1&lt;span class=&quot;pl-k&quot;&gt;px&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;indigo&lt;/span&gt;;
}
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+2&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;;
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;border&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;1&lt;span class=&quot;pl-k&quot;&gt;px&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;red&lt;/span&gt;;
}
&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;:nth-child&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3n+3&lt;/span&gt;) &lt;span class=&quot;pl-ent&quot;&gt;h3&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;color&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;;
  &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;border&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;1&lt;span class=&quot;pl-k&quot;&gt;px&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;green&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;通过将生成 &lt;code&gt;nth-child&lt;/code&gt; 样式的规则自动化的过程中，顺带使用了 SASS 中另外一些特性，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义和使用数组及对象&lt;/li&gt;
&lt;li&gt;数组及对象的遍历&lt;/li&gt;
&lt;li&gt;遍历过程中索引的获取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@mixin&lt;/code&gt; 的使用，参数的传递&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@mixin&lt;/code&gt; 中 &lt;code&gt;@content&lt;/code&gt; 的使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@mixin&lt;/code&gt; 中向外传递参数&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Mon, 14 Oct 2019 19:05:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>考察如下的 HTML 片段，通过 CSS 的 nth child() 伪选择器实现列表的颜色循环，比如每三个一次循环。 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt; &amp;lt;li</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/generate_nth_child_style_using_sass.html</dc:identifier>
</item>
<item>
<title>死磕 java线程系列之线程池深入解析——体系结构 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11674974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11674974.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191014235212691-871123946.png&quot; alt=&quot;ThreadPoolExecutor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（手机横屏看源码更方便）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;注：java源码分析部分如无特殊说明均基于 java8 版本。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Java的线程池是块硬骨头，对线程池的源码做深入研究不仅能提高对Java整个并发编程的理解，也能提高自己在面试中的表现，增加被录取的可能性。&lt;/p&gt;
&lt;p&gt;本系列将分成很多个章节，本章作为线程池的第一章将对整个线程池体系做一个总览。&lt;/p&gt;
&lt;h2 id=&quot;体系结构&quot;&gt;体系结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191014235212898-1737390136.png&quot; alt=&quot;ThreadPoolExecutor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图列举了线程池中非常重要的接口和类：&lt;/p&gt;
&lt;p&gt;（1）Executor，线程池顶级接口；&lt;/p&gt;
&lt;p&gt;（2）ExecutorService，线程池次级接口，对Executor做了一些扩展，增加一些功能；&lt;/p&gt;
&lt;p&gt;（3）ScheduledExecutorService，对ExecutorService做了一些扩展，增加一些定时任务相关的功能；&lt;/p&gt;
&lt;p&gt;（4）AbstractExecutorService，抽象类，运用模板方法设计模式实现了一部分方法；&lt;/p&gt;
&lt;p&gt;（5）ThreadPoolExecutor，普通线程池类，这也是我们通常所说的线程池，包含最基本的一些线程池操作相关的方法实现；&lt;/p&gt;
&lt;p&gt;（6）ScheduledThreadPoolExecutor，定时任务线程池类，用于实现定时任务相关功能；&lt;/p&gt;
&lt;p&gt;（7）ForkJoinPool，新型线程池类，java7中新增的线程池类，基于工作窃取理论实现，运用于大任务拆小任务、任务无限多的场景；&lt;/p&gt;
&lt;p&gt;（8）Executors，线程池工具类，定义了一些快速实现线程池的方法（谨慎使用）；&lt;/p&gt;
&lt;h2 id=&quot;executor&quot;&gt;Executor&lt;/h2&gt;
&lt;p&gt;线程池顶级接口，只定义了一个执行无返回值任务的方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Executor {
    // 执行无返回值任务【本篇文章由公众号“彤哥读源码”原创】
    void execute(Runnable command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;executorservice&quot;&gt;ExecutorService&lt;/h2&gt;
&lt;p&gt;线程池次级接口，对Executor做了一些扩展，主要增加了关闭线程池、执行有返回值任务、批量执行任务的方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ExecutorService extends Executor {
    // 关闭线程池，不再接受新任务，但已经提交的任务会执行完成
    void shutdown();

    // 立即关闭线程池，尝试停止正在运行的任务，未执行的任务将不再执行
    // 被迫停止及未执行的任务将以列表的形式返回
    List&amp;lt;Runnable&amp;gt; shutdownNow();

    // 检查线程池是否已关闭
    boolean isShutdown();

    // 检查线程池是否已终止，只有在shutdown()或shutdownNow()之后调用才有可能为true
    boolean isTerminated();
    
    // 在指定时间内线程池达到终止状态了才会返回true
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    
    // 执行有返回值的任务，任务的返回值为task.call()的结果
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);

    // 执行有返回值的任务，任务的返回值为这里传入的result
    // 当然只有当任务执行完成了调用get()时才会返回
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);
    
    // 执行有返回值的任务，任务的返回值为null
    // 当然只有当任务执行完成了调用get()时才会返回
    Future&amp;lt;?&amp;gt; submit(Runnable task);

    // 批量执行任务，只有当这些任务都完成了这个方法才会返回
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException;

    // 在指定时间内批量执行任务，未执行完成的任务将被取消
    // 这里的timeout是所有任务的总时间，不是单个任务的时间
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
    
    // 返回任意一个已完成任务的执行结果，未执行完成的任务将被取消
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException;

    // 在指定时间内如果有任务已完成，则返回任意一个已完成任务的执行结果，未执行完成的任务将被取消
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;scheduledexecutorservice&quot;&gt;ScheduledExecutorService&lt;/h2&gt;
&lt;p&gt;对ExecutorService做了一些扩展，增加一些定时任务相关的功能，主要包含两大类：执行一次，重复多次执行。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ScheduledExecutorService extends ExecutorService {

    // 在指定延时后执行一次
    public ScheduledFuture&amp;lt;?&amp;gt; schedule(Runnable command,
                                       long delay, TimeUnit unit);
    // 在指定延时后执行一次
    public &amp;lt;V&amp;gt; ScheduledFuture&amp;lt;V&amp;gt; schedule(Callable&amp;lt;V&amp;gt; callable,
                                           long delay, TimeUnit unit);
                                           
    // 在指定延时后开始执行，并在之后以指定时间间隔重复执行（间隔不包含任务执行的时间）
    // 相当于之后的延时以任务开始计算【本篇文章由公众号“彤哥读源码”原创】
    public ScheduledFuture&amp;lt;?&amp;gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);

    // 在指定延时后开始执行，并在之后以指定延时重复执行（间隔包含任务执行的时间）
    // 相当于之后的延时以任务结束计算
    public ScheduledFuture&amp;lt;?&amp;gt; scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;abstractexecutorservice&quot;&gt;AbstractExecutorService&lt;/h2&gt;
&lt;p&gt;抽象类，运用模板方法设计模式实现了一部分方法，主要为执行有返回值任务、批量执行任务的方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractExecutorService implements ExecutorService {

    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&amp;lt;T&amp;gt;(runnable, value);
    }

    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) {
        return new FutureTask&amp;lt;T&amp;gt;(callable);
    }

    public Future&amp;lt;?&amp;gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException {
        // 略...
    }

    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
        // 略...
    }

    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException {
        // 略...
    }

    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
        // 略...
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里的submit()方法对传入的任务都包装成了FutureTask来进行处理，这是什么东西呢？欢迎关注后面的章节。&lt;/p&gt;
&lt;h2 id=&quot;threadpoolexecutor&quot;&gt;ThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;普通线程池类，这也是我们通常所说的线程池，包含最基本的一些线程池操作相关的方法实现。&lt;/p&gt;
&lt;p&gt;线程池的主要实现逻辑都在这里面，比如线程的创建、任务的处理、拒绝策略等，我们后面单独分析这个类。&lt;/p&gt;
&lt;h2 id=&quot;scheduledthreadpoolexecutor&quot;&gt;ScheduledThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;定时任务线程池类，用于实现定时任务相关功能，将任务包装成定时任务，并按照定时策略来执行，我们后面单独分析这个类。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;问题：你知道定时任务线程池类使用的是什么队列吗？&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;forkjoinpool&quot;&gt;ForkJoinPool&lt;/h2&gt;
&lt;p&gt;新型线程池类，java7中新增的线程池类，这个线程池与Go中的线程模型特别类似，都是基于工作窃取理论，特别适合于处理归并排序这种先分后合的场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191014235213108-608696662.png&quot; alt=&quot;ThreadPoolExecutor&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;executors&quot;&gt;Executors&lt;/h2&gt;
&lt;p&gt;线程池工具类，定义了一系列快速实现线程池的方法——newXXX()，不过阿里手册是不建议使用这个类来新建线程池的，彤哥我并不这么认为，只要能掌握其源码，知道其利敝偶尔还是可以用的，后面我们再来说这个事。&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;无彩蛋不欢，今天的问题是&lt;strong&gt;定时任务线程池用的是哪种队列来实现的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：延时队列。定时任务线程池中并没有直接使用并发集合中的DelayQueue，而是自己又实现了一个DelayedWorkQueue，不过跟DelayQueue的实现原理是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延时队列使用什么数据结构来实现的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：堆（DelayQueue中使用的是优先级队列，而优先级队列使用的堆；DelayedWorkQueue直接使用的堆）。&lt;/p&gt;
&lt;p&gt;关于延时队列、优先级队列和堆的相关内容点击下面的链接直达：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/IOTwwgaOdMpZl-6QM0HlVQ&quot;&gt;死磕 java集合之DelayQueue源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/kGKS7WXWbf-ME1_Hr3Fpgw&quot;&gt;死磕 java集合之PriorityQueue源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/AF2tMHfofG8b51yIyaIReg&quot;&gt;拜托，面试别再问我堆（排序）了！&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191014235213333-926110766.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Oct 2019 15:52:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>（手机横屏看源码更方便） 注：java源码分析部分如无特殊说明均基于 java8 版本。 简介 Java的线程池是块硬骨头，对线程池的源码做深入研究不仅能提高对Java整个并发编程的理解，也能提高自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11674974.html</dc:identifier>
</item>
<item>
<title>Rust入坑指南：核心概念 - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/11674913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/11674913.html</guid>
<description>&lt;p&gt;如果说前面的坑我们一直在用小铲子挖的话，那么今天的坑就是用挖掘机挖的。&lt;/p&gt;
&lt;p&gt;今天要介绍的是Rust的一个核心概念：Ownership。全文将分为什么是Ownership以及Ownership的传递类型两部分。&lt;/p&gt;
&lt;h3 id=&quot;什么是ownership&quot;&gt;什么是Ownership&lt;/h3&gt;
&lt;p&gt;每种编程语言都有自己的一套内存管理的方法。有些需要显式的分配和回收内存（如C），有些语言则依赖于垃圾回收器来回收不使用的内存（如Java）。而Rust不属于以上任何一种，它有一套自己的内存管理规则，叫做Ownership。&lt;/p&gt;
&lt;p&gt;在具体介绍Ownership之前，我想要先声明一点。&lt;a href=&quot;https://jackeyzhe.github.io/2019/10/08/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E5%B8%B8%E8%A7%84%E5%A5%97%E8%B7%AF/&quot;&gt;Rust入坑指南：常规套路&lt;/a&gt;一文中介绍的数据类型，其数据都是存储在栈中。而像String或一些自定义的复杂数据结构（我们以后会对它们进行详细介绍），其数据则存储在堆内存中。明确了这一点后，我们来看下Ownership的规则有哪些。&lt;/p&gt;
&lt;h4 id=&quot;ownership的规则&quot;&gt;Ownership的规则&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在Rust中，每一个值都有对应的变量，这个变量称为值的owner&lt;/li&gt;
&lt;li&gt;一个值在某一时刻只能有一个owner&lt;/li&gt;
&lt;li&gt;当owner超出作用域后，值会被销毁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三条规则非常重要，记住他们会帮助你更好的理解本文。&lt;/p&gt;
&lt;h4 id=&quot;变量作用域&quot;&gt;变量作用域&lt;/h4&gt;
&lt;p&gt;Ownership的规则中，有一条是owner超过范围后，值会被销毁。那么owner的范围又是如何定义的呢？在Rust中，花括号通常是变量范围作用域的标志。最常见的在一个函数中，变量s的范围从定义开始生效，直到函数结束，变量失效。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn main() {                      // s is not valid here, it’s not yet declared
    let s = &quot;hello&quot;;   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个这和其他大多数编程语言很像，对于大多数编程语言，都是从变量定义开始，为变量分配内存。而回收内存则是八仙过海各显神通。对于有依赖GC的语言来说，并不需要关心内存的回收。而有些语言则需要显式回收内存。显式回收就会存在一定的问题，比如忘记回收或者重复回收。为了对开发者更加友好，Rust使用自动回收内存的方法，即在变量超出作用域时，回收为该变量分配的内存。&lt;/p&gt;
&lt;h3 id=&quot;ownership的移动&quot;&gt;Ownership的移动&lt;/h3&gt;
&lt;p&gt;前面我们提到，花括号通常是变量作用域隔离的标志（即Ownership失效）。除了花括号以外，还有其他的一些情况会使Ownership发生变化，先来看两段代码。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;let x = 5;
let y = x;
println!(&quot;x: {}&quot;, x);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
println!(&quot;s1: {}&quot;, s1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;作者注：双冒号是Rust中函数引用的标志，上面的意思是引用String中的from函数，这个函数通常用来构建一个字符串对象。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这两段代码看起来唯一的区别就是变量的类型，第一段使用的是整数型，第二段使用的是字符串型。而执行结果却是第一段可以正常打印x的值，第二段却报错了。这是什么原因呢？&lt;/p&gt;
&lt;p&gt;我们来分析一下代码。对于第一段代码，首先有个整数值5，赋给了变量x，然后把x的值copy了一份，又赋值给了y。最后我们成功打印x。看起来比较符合逻辑。实际上Rust也是这么操作的。&lt;/p&gt;
&lt;p&gt;对于第二段代码我们想象中，也可以是这样的过程，但实际上Rust并不是这样做的。先来说原因：对于较大的对象来说，这样的复制是非常浪费空间和时间的。那么Rust中实际情况是怎么样呢？&lt;/p&gt;
&lt;p&gt;首先，我们需要了解Rust中String类型的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1570639634/Blog/rust/03/trpl04-01.svg&quot; alt=&quot;String结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中左侧是String对象的结构，包括指向内容的指针、长度和容量。这里长度和容量相同，我们暂时先不关注。后面详细介绍String类型时会提到两者的区别。这部分内容都存储在栈内存中。右侧部分是字符串的内容，这部分存储在堆内存中。&lt;/p&gt;
&lt;p&gt;有的朋友可能想到了，既然复制内容会造成资源浪费，那我只复制结构这部分好了，内容再多，我复制的内容长度也是可控的，而且也是在栈中复制，和整数类型类似。这个方法听起啦不错，我们来分析一下。按照上面这种说法，内存结构大概是这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1570721759/Blog/rust/03/trpl04-02.svg&quot; alt=&quot;String-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种会有什么问题呢？还记得Ownership的规则吗？owner超出作用域时，回收其数据所占用的内存。在这个例子中，当函数执行结束时，s1和s2同时超出作用域，那么上图中右侧这块内存就会被释放两次。这也会产生不可预知的bug。&lt;/p&gt;
&lt;p&gt;Rust为了解决这一问题，在执行&lt;code&gt;let s2 = s1;&lt;/code&gt;这句代码时，认为s1已经超出了作用域，即右侧的内容的owner已经变成了s2，也可以说s1的ownership转移给了s2。也就是下图所示的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1570722292/Blog/rust/03/trpl04-03.svg&quot; alt=&quot;String-real&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;另一种实现clone&quot;&gt;另一种实现：clone&lt;/h4&gt;
&lt;p&gt;如果你确实需要深度拷贝，即复制堆内存中的数据。Rust也可以做到，它提供了一个公共方法叫做clone。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;clone的方法执行后，内存结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1570722578/Blog/rust/03/trpl04-04.svg&quot; alt=&quot;String-clone&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;函数间转移&quot;&gt;函数间转移&lt;/h4&gt;
&lt;p&gt;前面我们聊到的是Ownership在String之间转移，在函数间也是一样的。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn main() {
    let s = String::from(&quot;hello&quot;);  // s 作用域开始

    takes_ownership(s);             // s's 的值进入函数
                                    // ... s在这里已经无效

} // s在这之前已经失效
fn takes_ownership(some_string: String) { // some_string 作用域开始
    println!(&quot;{}&quot;, some_string);
} // some_string 超出作用域并调用了drop函数
  // 内存被释放&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那有没有办法在执行takes_ownership函数后使s继续生效呢？一般我们会想到在函数中将ownership还回来。然后很自然的就想到我们之前介绍的函数的返回值。既然传参可以转移ownership，那么返回值应该也可以。于是我们可以这样操作：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn main() {
    let s1 = String::from(&quot;hello&quot;);     // s2 comes into scope

    let s2 = takes_and_gives_back(s1);  // s1 被转移到函数中
                                        // takes_and_gives_back，
                                        // 将ownership还给s2
} // s2超出作用域，内存被回收，s1在之前已经失效


// takes_and_gives_back 接收一个字符串然后返回一个
fn takes_and_gives_back(a_string: String) -&amp;gt; String { // a_string 开始作用域

    a_string  // a_string 被返回，ownership转移到函数外
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样做是可以实现我们的需求，但是有点太麻烦了，幸好Rust也觉得这样很麻烦。它为我们提供了另一种方法：引用（&lt;em&gt;references&lt;/em&gt;）。&lt;/p&gt;
&lt;h3 id=&quot;引用和借用&quot;&gt;引用和借用&lt;/h3&gt;
&lt;p&gt;引用的方法很简单，只需要加一个&lt;code&gt;&amp;amp;&lt;/code&gt;符。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;amp;String) -&amp;gt; usize {
    s.len()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种形式可以在没有ownership的情况下访问某个值。其原理如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1570724291/Blog/rust/03/trpl04-05.svg&quot; alt=&quot;references&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个例子和我们在前面写的例子很相似。仔细观察会发现一些端倪。主要有两点不同：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在传入参数的时候，s1前面加了&amp;amp;符。这意味着我们创建了一个s1的引用，它并不是数据的owner，因此在它超出作用域时也不会销毁数据。&lt;/li&gt;
&lt;li&gt;函数在接收参数时，变量类型String前也加了&amp;amp;符。这表示参数要接收的是一个字符串的引用对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们把函数中接收引用的参数称为借用。就像实际生活中我写完了作业，可以借给你抄一下，但它不属于你，抄完你还要还给我。（友情提示：非紧急情况不要抄作业）&lt;/p&gt;
&lt;p&gt;另外还需要注意，我的作业可以借给你抄，但是你不能改我写的作业，我本来写对了你给我改错了，以后我还怎么借给你？所以，在calculate_length中，s是不可以修改的。&lt;/p&gt;
&lt;h4 id=&quot;可修改引用&quot;&gt;可修改引用&lt;/h4&gt;
&lt;p&gt;如果我发现我写错了，让你帮我改一下怎么办？我授权给你，让你帮忙修改，你也需要表示能帮我修改就可以了。Rust也有办法。还记得我们前面介绍的可变变量和不可变变量吗？引用也是类似，我们可以使用mut关键字使引用可修改。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;amp;mut s);
}

fn change(some_string: &amp;amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就能在函数中对引用的值进行修改了。不过这里还要注意一点，在同一作用域内，对于同一个值，只能有一个可修改的引用。这也是因为Rust不想有并发修改数据的情况出现。&lt;/p&gt;
&lt;p&gt;如果需要使用多个可修改引用，我们可以自己创建新的作用域：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;amp;mut s;

} // r1 超出作用域

let r2 = &amp;amp;mut s;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一个冲突就是“读写冲突”，即不可变引用和可变引用之间的限制。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;amp;s; // no problem
let r2 = &amp;amp;s; // no problem
let r3 = &amp;amp;mut s; // BIG PROBLEM

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的代码在编译时也会报错。这是因为不可变引用不希望在被使用之前，其指向的值被修改。这里只要稍微处理一下就可以了：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;amp;s; // no problem
let r2 = &amp;amp;s; // no problem
println!(&quot;{} and {}&quot;, r1, r2);
// r1 和 r2 不再使用

let r3 = &amp;amp;mut s; // no problem
println!(&quot;{}&quot;, r3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Rust编译器会在第一个print语句之后判断出r1和r2不会再被使用，此时r3还没有创建，它们的作用域不会有交集。所以这段代码是合法的。&lt;/p&gt;
&lt;h3 id=&quot;空指针&quot;&gt;空指针&lt;/h3&gt;
&lt;p&gt;对于可操作指针的编程语言来讲，最令人头疼的问题也许就是空指针了。通常情况是，在回收内存以后，又使用了指向这块内存的指针。而Rust的编译器帮助我们避免了这个问题（再次感谢Rust编译器）。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&amp;gt; &amp;amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;amp;s
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看一下上面这个例子。在dangle函数中，返回值是字符串s的引用。但是在函数结束时，s的内存已经被回收了。所以s的引用就成了空指针。此时就会报expected lifetime parameter的编译错误。&lt;/p&gt;
&lt;h3 id=&quot;另一种引用slice&quot;&gt;另一种引用：Slice&lt;/h3&gt;
&lt;p&gt;除了引用之外，还有另一种没有ownership的数据类型叫做Slice。Slice是一种使用集合中一段序列的引用。&lt;/p&gt;
&lt;p&gt;这里通过一个简单的例子来说明Slice的使用方法。假设我们需要得到给你字符串中的第一个单词。你会怎么做？其实很简单，遍历每个字符，如果遇到空格，就返回之前遍历过的字符的集合。&lt;/p&gt;
&lt;p&gt;对字符串的遍历方法我来剧透一下，as_bytes函数可以把字符串分解成字节数组，iter是返回集合中每个元素的方法，enumerate是提取这些元素，并且返回(元素位置,元素值)这样的二元组的方法。这样是不是可以写出来了。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn first_word(s: &amp;amp;String) -&amp;gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来，感受下这个例子，虽然它返回的是第一个空格的位置，但是只要会字符串截取，还是可以达到目的的。不过不能剧透字符串截取了，不然暴露不出问题。&lt;/p&gt;
&lt;p&gt;这么写的问题在哪呢？来看一下main函数。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;amp;s);

    s.clear();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里在获取空格位置后，对字符串s做了一个clear操作，也就是把s清空了。但word仍然是5，此时我们再去对截取s的前5个字符就会出问题。可能有人认为自己不会这么蠢，但是你愿意相信你的好（zhu）伙（dui）伴（you）也不会这么做吗？我是不相信的。那怎么办呢？这时候slice就要登场了。&lt;/p&gt;
&lt;p&gt;使用slice可以获取字符串的一段字符序列。例如&lt;code&gt;&amp;amp;s[0..5]&lt;/code&gt;可以获取字符串s的前5个字符。其中0为起始字符的位置下标，5是结束字符位置的下标加1。也就是说slice的区间是一个左闭右开区间。&lt;/p&gt;
&lt;p&gt;slice还有一些规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果起始位置是0，则可以省略。也就是说&lt;code&gt;&amp;amp;s[0..2]&lt;/code&gt;和&lt;code&gt;&amp;amp;s[..2]&lt;/code&gt;等价&lt;/li&gt;
&lt;li&gt;如果起始位置是集合序列末尾位置，也可以省略。即&lt;code&gt;&amp;amp;s[3..len]&lt;/code&gt;和&lt;code&gt;&amp;amp;s[3..]&lt;/code&gt;等价&lt;/li&gt;
&lt;li&gt;根据以上两条，我们还可以得出&lt;code&gt;&amp;amp;s[0..len]&lt;/code&gt;和&lt;code&gt;&amp;amp;s[..]&lt;/code&gt;等价&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里需要注意的是，我们截取字符串时，其边界必须是UTF-8字符。&lt;/p&gt;
&lt;p&gt;有了slice，就可以解决我们的问题了&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn first_word(s: &amp;amp;String) -&amp;gt; &amp;amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;amp;s[0..i];
        }
    }

    &amp;amp;s[..]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们在main函数中对s执行clear操作时，编译器就不同意了。没错，又是万能的编译器。&lt;/p&gt;
&lt;p&gt;除了slice除了可以作用于字符串以外，还可以作用于其他集合，例如：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;let a = [1, 2, 3, 4, 5];

let slice = &amp;amp;a[1..3];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于集合，我们以后会有更加详细的介绍。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文介绍的Ownership特性对于理解Rust来讲非常重要。我们介绍了什么是Ownership，Ownership的转移，以及不占用Ownership的数据类型Reference和Slice。&lt;/p&gt;
&lt;p&gt;怎么样？是不是感觉今天的坑非常给力？如果之前在地下一层的话，那现在已经到地下三层了。所以请各位注意安全，有序降落。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Oct 2019 15:32:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>如果说前面的坑我们一直在用小铲子挖的话，那么今天的坑就是用挖掘机挖的。&lt;! more 今天要介绍的是Rust的一个核心概念：Ownership。全文将分为什么是Ownership以及Ownership</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/11674913.html</dc:identifier>
</item>
<item>
<title>分库分表(5) ---SpringBoot + ShardingSphere 实现分库分表 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11673493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11673493.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;有关分库分表前面写了四篇博客:&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11608222.html&quot;&gt;分库分表(1) --- 理论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11629883.html&quot;&gt;分库分表(2) --- ShardingSphere(理论)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11656205.html&quot;&gt;分库分表(3) ---SpringBoot + ShardingSphere实现读写分离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11651163.html&quot;&gt;分库分表(4) ---SpringBoot + ShardingSphere 实现分表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇博客通过ShardingSphere&lt;code&gt;实现分库分表&lt;/code&gt;，并在文章最下方附上项目&lt;code&gt;Github地址&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一项目概述&quot;&gt;&lt;span&gt;一、项目概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;技术架构&quot;&gt;1、技术架构&lt;/h4&gt;
&lt;p&gt;项目总体技术选型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SpringBoot2.0.6 + shardingsphere4.0.0-RC1 + Maven3.5.4  + MySQL + lombok(插件)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;项目说明&quot;&gt;2、项目说明&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;场景&lt;/code&gt; 在实际开发中，如果表的数据过大我们需要把一张表拆分成多张表，也可以垂直切分把一个库拆分成多个库，这里就是通过ShardingSphere实现&lt;code&gt;分库分表&lt;/code&gt;功能。&lt;/p&gt;
&lt;h4 id=&quot;数据库设计&quot;&gt;3、数据库设计&lt;/h4&gt;
&lt;p&gt;这里有个设计了两个库 &lt;code&gt;ds0&lt;/code&gt; 和 &lt;code&gt;ds1&lt;/code&gt;，每个库中有两个表&lt;code&gt;tab_user0&lt;/code&gt; 和 &lt;code&gt;tab_user1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ds0库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191014193639269-230175212.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ds1库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191014193649751-736195635.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的创建表SQL也会放到GitHub项目里&lt;/p&gt;

&lt;h2 id=&quot;二核心代码&quot;&gt;&lt;span&gt;二、核心代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 完整的代码会放到GitHub上，这里只放一些核心代码。&lt;/p&gt;
&lt;h4 id=&quot;application.properties&quot;&gt;1、application.properties&lt;/h4&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;server.port=8084

#指定mybatis信息
mybatis.config-location=classpath:mybatis-config.xml
#打印sql
spring.shardingsphere.props.sql.show=true

spring.shardingsphere.datasource.names=ds0,ds1

spring.shardingsphere.datasource.ds0.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.ds0.url=jdbc:mysql://47.99.203.55:3306/ds0?characterEncoding=utf-8
spring.shardingsphere.datasource.ds0.username=root
spring.shardingsphere.datasource.ds0.password=123456

spring.shardingsphere.datasource.ds1.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.ds1.url=jdbc:mysql://47.99.203.55:3306/ds1?characterEncoding=utf-8
spring.shardingsphere.datasource.ds1.username=root
spring.shardingsphere.datasource.ds1.password=123456

#根据年龄分库
spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column=age
spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression=ds$-&amp;gt;{age % 2}
#根据id分表
spring.shardingsphere.sharding.tables.tab_user.actual-data-nodes=ds$-&amp;gt;{0..1}.tab_user$-&amp;gt;{0..1}
spring.shardingsphere.sharding.tables.tab_user.table-strategy.inline.sharding-column=id
spring.shardingsphere.sharding.tables.tab_user.table-strategy.inline.algorithm-expression=tab_user$-&amp;gt;{id % 2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sharding-JDBC可以通过&lt;code&gt;Java&lt;/code&gt;，&lt;code&gt;YAML&lt;/code&gt;，&lt;code&gt;Spring命名空间&lt;/code&gt;和&lt;code&gt;Spring Boot Starter&lt;/code&gt;四种方式配置，开发者可根据场景选择适合的配置方式。具体可以看官网。&lt;/p&gt;
&lt;h4 id=&quot;usercontroller&quot;&gt;2、UserController&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * 模拟插入数据
     */
    List&amp;lt;User&amp;gt; userList = Lists.newArrayList();
    /**
     * 初始化插入数据
     */
    @PostConstruct
    private void getData() {
        userList.add(new User(1L,&quot;小小&quot;, &quot;女&quot;, 3));
        userList.add(new User(2L,&quot;爸爸&quot;, &quot;男&quot;, 30));
        userList.add(new User(3L,&quot;妈妈&quot;, &quot;女&quot;, 28));
        userList.add(new User(4L,&quot;爷爷&quot;, &quot;男&quot;, 64));
        userList.add(new User(5L,&quot;奶奶&quot;, &quot;女&quot;, 62));
    }
    /**
     * @Description: 批量保存用户
     */
    @PostMapping(&quot;save-user&quot;)
    public Object saveUser() {
        return userService.insertForeach(userList);
    }
    /**
     * @Description: 获取用户列表
     */
    @GetMapping(&quot;list-user&quot;)
    public Object listUser() {
        return userService.list();
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三测试验证&quot;&gt;&lt;span&gt;三、测试验证&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;批量插入数据&quot;&gt;1、批量插入数据&lt;/h4&gt;
&lt;p&gt;请求接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localhost:8084/save-user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以从商品接口代码中可以看出，它会批量插入5条数据。我们先看控制台输出SQL语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191014193958255-984204288.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以从SQL语句可以看出 &lt;strong&gt;ds0&lt;/strong&gt; 和 &lt;strong&gt;ds1&lt;/strong&gt; 库中都插入了数据。&lt;/p&gt;
&lt;p&gt;我们再来看数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ds0.tab_user0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191014194112856-1815322205.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ds0.tab_user1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191014194536294-534144947.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ds1.tab_user0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191014194544830-1729440572.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ds1.tab_user1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191014194553598-572433744.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成分库分表插入数据。&lt;/p&gt;
&lt;h4 id=&quot;获取数据&quot;&gt;2、获取数据&lt;/h4&gt;
&lt;p&gt;这里获取列表接口的SQL，这里对SQL做了order排序操作，具体ShardingSphere分表实现order操作的原理可以看上面一篇博客。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;  select *  from tab_user order by age  &amp;lt;!--根据年龄排序--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求接口结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191014194611502-1843756299.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看出虽然已经分库分表，但依然可以将多表数据聚合在一起并可以支持按&lt;strong&gt;age排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; ShardingSphere并不支持&lt;code&gt;CASE WHEN&lt;/code&gt;、&lt;code&gt;HAVING&lt;/code&gt;、&lt;code&gt;UNION (ALL)&lt;/code&gt;，&lt;code&gt;有限支持子查询&lt;/code&gt;。这个官网有详细说明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github地址&lt;/code&gt;：&lt;a href=&quot;https://github.com/yudiandemingzi/spring-boot-sharding-sphere&quot; class=&quot;uri&quot;&gt;https://github.com/yudiandemingzi/spring-boot-sharding-sphere&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://shardingsphere.apache.org/document/current/cn/overview/&quot;&gt;ShardingSphere中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://shardingsphere.apache.org/&quot;&gt;ShardingSphere官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://github.com/apache/incubator-shardingsphere&quot;&gt;Shardingsphere Github库&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(20）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 14 Oct 2019 14:59:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>分库分表(5) ShardingSphere实现分库分表 有关分库分表前面写了四篇博客: 1、 '分库分表(1) 理论' 2、 '分库分表(2) ShardingSphere(理论)' 3、 '分库分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11673493.html</dc:identifier>
</item>
<item>
<title>Django框架篇-4.路由层 - 郭少</title>
<link>http://www.cnblogs.com/897463196-a/p/11674769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/897463196-a/p/11674769.html</guid>
<description>[unable to retrieve full-text content]URL配置（URLconf）就像Django 所支撑网站的目录。它的本质是URL与要为该URL调用的视图函数之间的映射表；你就是以这种方式告诉Django，对于客户端发来的某个URL调用哪一段逻辑代码对应执行。 简单的路由配置 注意： 1、使用URL，必须先将应用程序中的视图函数导入到urls.py</description>
<pubDate>Mon, 14 Oct 2019 14:56:00 +0000</pubDate>
<dc:creator>郭少</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https://www.cnblogs.com/897463196-a/p/11674769.html</dc:identifier>
</item>
<item>
<title>Spring 源码阅读 一 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11674684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11674684.html</guid>
<description>&lt;p&gt;终于,有一天我也来看Spring的源码了,看了一阵之后感觉心情那叫一个舒畅,对Spring底层的实现也有了进一步的了解, 最直观的感受就是Spring的命名风格很赞,很长,真的长到使人见名知意, 闲言少叙,开始整理笔记了&lt;/p&gt;
&lt;h3 id=&quot;程序的入口&quot;&gt;程序的入口&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进这个&lt;code&gt;AnnotationConfigApplicationContext()&lt;/code&gt;程序的启动入口, 注解配置的应用上下文.主要做了下面的三件事&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用本类无参构造方法&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;register(annotatedClasses)&lt;/code&gt; 将我们传递进来的配置类注册进&lt;code&gt;BeanFactory&lt;/code&gt;的&lt;code&gt;BeanDefinitionMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;刷新容器&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;... annotatedClasses) {
        this();
        register(annotatedClasses);
        refresh();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建beanfactory&quot;&gt;创建BeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191014223256299-675993675.png&quot; alt=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191014223256299-675993675.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先调用本类的无参构造方法,&lt;strong&gt;,通过上图,可以看到,&lt;code&gt;AnnotationConfigAllicationContext&lt;/code&gt;的父类是&lt;code&gt;GenericApplicationContext&lt;/code&gt;但是,在执行本类的无参构造方法时会先执行父类的无参构造方法.它父类的无参构造方法我贴在下面&lt;/strong&gt;,就做了一件事,初始化了&lt;strong&gt;Spring的BeanFactory,没错就是Spring的Bean工厂,由于两者的继承关系,我们就任务,&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;的Bean工厂被初始化了&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public GenericApplicationContext() {
        this.beanFactory = new DefaultListableBeanFactory();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;创建annotatedbeandefinitionreader加载&quot;&gt;创建&lt;code&gt;AnnotatedBeanDefinitionReader&lt;/code&gt;加载&lt;/h3&gt;
&lt;p&gt;接着回到这个构造方法的源码我贴在下面, 这个构造方法主要做了两件事&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为应用的上下文创建reader读取器, &lt;strong&gt;读取被添加了注解的类信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;实例化了一个Scanner, 这个Scanner可以用去做包扫描的工作,但是Spring根据我们的配置信息去进行包扫描的工作时,并没有使用这个扫描器,而是自己new 了一个,&lt;strong&gt;当前的扫描器可以理解成是方便程序员使用而创建的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public AnnotationConfigApplicationContext() {
        this.reader = new AnnotatedBeanDefinitionReader(this); 
        this.scanner = new ClassPathBeanDefinitionScanner(this);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面跟进&lt;code&gt;AnnotatedBeanDefinitionReader&lt;/code&gt;扫描器的创建过程,经过几个没有重要逻辑的方法,我们会进入&lt;code&gt;registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source)&lt;/code&gt;,下面是源码： &lt;strong&gt;这算是Spring初始化的一个小高潮了!!!&lt;/strong&gt;,为啥这样说呢? 因下面的逻辑中,为&lt;code&gt;Spring&lt;/code&gt;初始化过程中,构建BeanFactory提供了几个&lt;strong&gt;开天辟地性质的&lt;code&gt;RootBeanDefinition&lt;/code&gt;&lt;/strong&gt;``&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是在为&lt;code&gt;BeanFactory&lt;/code&gt;添加了两个大组件
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AnnotationAwareOrderComparator&lt;/code&gt;用于解析&lt;code&gt;@Order&lt;/code&gt; 和 &lt;code&gt;@Priorty&lt;/code&gt;注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContextAnnotationAutowireCandidateResolver&lt;/code&gt; 提供了懒加载的支持&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;然后就是往&lt;code&gt;BeanFactory&lt;/code&gt;中的&lt;code&gt;BeanDefinitionMap&lt;/code&gt;中添加了6个&lt;code&gt;RootBeanDefinition&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ConfigurationClassPostProcessor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Set&amp;lt;BeanDefinitionHolder&amp;gt; registerAnnotationConfigProcessors(
        BeanDefinitionRegistry registry, @Nullable Object source) {

    //   得到bean工厂
    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
    if (beanFactory != null) {
        if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
            //  给Bean工厂添加原材料
            //  AnnotationAwareOrderComparator 主要能解析@Order注解和@Priority
            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
        }
        if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
            //  ContextAnnotationAutowireCandidateResolver 提供处理懒加载(Lazy)相关的功能
            beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
        }
    }
    //   作用是方便传递参数BeanDefinitionHolder
    Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefs = new LinkedHashSet&amp;lt;&amp;gt;(8);
    // BeanDefinition的注册，这里很重要，需要理解注册每个bean的类型
    //   就是判断工厂中有没有包含 CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME 名称的bean, Spring在启动时,工厂肯定是空的返回false , 加上! 表示ture
    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {//configuration_annotation_processor_bean_name
        //   注意: 下面的ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor,间接实现了 BeanFactoryPostProcessor bean工厂的后置处理器
        //   RootBeanDefinition可以理解成 描述Spring内部类的Definition

        //   除了通过AnnotationedBeanDefinitionReader把 加上了注解的类加载成bean,下面的第二种方式, 通过new RootBeanDefinition, 进而将 XXX.class起来注册进bean工厂
        //   这是使用第二种方式, 通过new Spring自己实现的BeanDefinition接口的类,将java转换成 Bean 然后put进BeanFactory的BeanDefinitionMap中
        //   下面的111-666 就是最先放置进去的6个Spring的RootBean对象
        //   ---111---------------------------
        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
        def.setSource(source);
        //   跟进去 registerPostProcessor
        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        //AutowiredAnnotationBeanPostProcessor 实现了 MergedBeanDefinitionPostProcessor
        //MergedBeanDefinitionPostProcessor 最终实现了 BeanPostProcessor
        //   ---222---------------------------
        RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
        def.setSource(source);
        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        //   ---333---------------------------
        RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
        def.setSource(source);
        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
    if (jsr250Present &amp;amp;&amp;amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {

        //   ---444---------------------------
        RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
        def.setSource(source);
        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
    if (jpaPresent &amp;amp;&amp;amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
        RootBeanDefinition def = new RootBeanDefinition();
        try {
            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
                    AnnotationConfigUtils.class.getClassLoader()));
        }
        catch (ClassNotFoundException ex) {
            throw new IllegalStateException(
                    &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
        }
        def.setSource(source);
        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
    }

    if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
        //   ---555---------------------------

        RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
        def.setSource(source);
        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
    }

    if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
        //   ---666---------------------------
        RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
        def.setSource(source);
        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
    }

    return beanDefs;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中有来如下两个亮点:&lt;/p&gt;
&lt;h3 id=&quot;亮点1rootbeandefinition&quot;&gt;&lt;strong&gt;亮点1:&lt;code&gt;RootBeanDefinition&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;首先涉及到的知识点就是,Spring有哪几种方式将对象转成&lt;code&gt;BeanDefinition&lt;/code&gt;? 其实是有两种,第一种就是让Spring通过Scanner去扫描包解析程序员提供的添加了注解的类,这是个自动完成的过程,第二种就是&lt;code&gt;Spring&lt;/code&gt;通过new &lt;code&gt;RootBeanDefinition&lt;/code&gt;等诸多的&lt;code&gt;BeanDefinition&lt;/code&gt;接口的实现类, 然后将Spring原生的对象当成参数传递进去进而转换成&lt;code&gt;BeanDefinition&lt;/code&gt;, 当然,&lt;code&gt;Spring&lt;/code&gt;在这里选择的就是第二种方法&lt;/p&gt;
&lt;h3 id=&quot;亮点2configurationclasspostprocessor&quot;&gt;&lt;strong&gt;亮点2:&lt;code&gt;ConfigurationClassPostProcessor&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这个类很牛,为什么这么说呢? 先看一下他的继承类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191014223255758-1792965804.png&quot; alt=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191014223255758-1792965804.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没错,他是6个&lt;code&gt;RootBeanDefinition&lt;/code&gt;中唯一的一个实现&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;的,其他的五个&lt;code&gt;RootBeanDifinition&lt;/code&gt;实现的都是&lt;code&gt;BeanPostProcessor&lt;/code&gt;, 其实也不用懵逼,只要我们整明白这里说的&lt;code&gt;BeanPostProcessor&lt;/code&gt;和&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;的作用就好了,然后在这里我用下面的两个模块解释&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;beanpostprocessor&quot;&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;接口的抽象方法源码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanPostProcessor {

@Nullable
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
@Nullable
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个方法名,见名知意: 第一个会在 对象的 &lt;code&gt;constructor&lt;/code&gt; 之后,&lt;code&gt;init()&lt;/code&gt;方法之前调用&lt;/p&gt;
&lt;p&gt;第二个会在&lt;code&gt;init()&lt;/code&gt;方法之后调用&lt;/p&gt;
&lt;p&gt;但是,大家可以发现,它的调用时机都是在构造方法执行之后进行拦截,这时候&lt;code&gt;BeanDefinition&lt;/code&gt;已经被实例化了&lt;/p&gt;
&lt;h4 id=&quot;beanfactorypostprocessor&quot;&gt;&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface BeanFactoryPostProcessor {

    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它就比较厉害了, &lt;strong&gt;这也是Spring牛的地方,它不仅仅会替我们维护这些Bean,而且还通过当前的&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;,为程序员开放一个缺口,让程序员可以参与到Bean的创建过程中来,为什么这样说呢, 其实大家可以看到,它唯一的抽象方法中的入参位置上是谁? 没错,就是BeanFactory, Bean工厂都给我们了,那不是想干啥干啥?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次,它的作用时机是执行Bean的构造方法之前&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最直接的应用场景: 当一个单例的Bean依赖 多例的Bean时,我们多次通过 应用的上下文获取出来的单例bean的hashcode都是唯一的这没错,但是紧接着打印它依赖的多例对象的hashcode同样是相同的,这种单例失效的问题,就可以根据这个知识点从容解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前面说的&lt;code&gt;ConfigurationClassPostProcessor&lt;/code&gt;就是&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;的实现类,并且它也不辱使命, 完美的使用作用时机不同的特点,在程序员提供的配置类的构造方法调用之前,就先入为主,围棋生成了 cglib代理对象&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;接着看代码,回到上面的代码,我们看如何将&lt;code&gt;RootBeanDefinition&lt;/code&gt;注册进&lt;code&gt;BeanFactory&lt;/code&gt;, 我从上面截取一行代码放在这里&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //   跟进去 registerPostProcessor
        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进这个&lt;code&gt;registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static BeanDefinitionHolder registerPostProcessor(
        BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {

    definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
    //   registerBeanDefinition()
    registry.registerBeanDefinition(beanName, definition);
    return new BeanDefinitionHolder(definition, beanName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们关注这个&lt;code&gt;registry.registerBeanDefinition(beanName, definition);&lt;/code&gt; , 可以看到,其实这个&lt;code&gt;registerBeanDefinition()&lt;/code&gt;是&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;的抽象方法,我们要找的是它的实现类,那问题来了, 是谁实现他呢? &lt;strong&gt;可以回到博客顶部,看看第一个图,没错Spring的BeanFactory,也就是&lt;code&gt;DefualtListableBeanFactory&lt;/code&gt;实现了这个接口,虽然有点意外,一个工厂竟然还是一个注册器,但是这也是事实情况, 看看这个工厂是如何做的吧&lt;/strong&gt; .原函数很长,我截取了部分源码如下: 它的解释我写在源码的下面&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
            throws BeanDefinitionStoreException {
            ...
            else {
                //   添加进入容器中, 最终的结果就是,这个map中存在哪些类,Spring的IOC中就有哪些类
                // Still in startup registration phase
                this.beanDefinitionMap.put(beanName, beanDefinition);
                //   单独使用一个list存放名字
                this.beanDefinitionNames.add(beanName);

                this.manualSingletonNames.remove(beanName);
            }
            this.frozenBeanDefinitionNames = null;
        }

        if (existingDefinition != null || containsSingleton(beanName)) {
            resetBeanDefinition(beanName);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,他将一开始的6个&lt;code&gt;RootBeanDefinition&lt;/code&gt;全都都put进了一个map中, 下面这个map&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = new ConcurrentHashMap&amp;lt;&amp;gt;(256);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;key就是beanName, value就是BeanDefinition&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这也是迄今为止我们遇到的第一个map, 这个map是BeanFactory的一个组件,但是它可不是传说中的IOC容器,大家也看到了它里面存放的是BeanDefinition,而不是Bean&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;将配置类注册进beanfactory&quot;&gt;将配置类注册进&lt;code&gt;BeanFactory&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;回到一开始&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;的&lt;code&gt;register(annotatedClasses);&lt;/code&gt;方法,然后一路往下跟,会经过几个没有什么重要逻辑的方法, 然后来到这里&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void register(Class&amp;lt;?&amp;gt;... annotatedClasses) {
    for (Class&amp;lt;?&amp;gt; annotatedClass : annotatedClasses) {
        //  继续跟进去
        registerBean(annotatedClass);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码,我们可以回想,&lt;code&gt;annotatedClasses&lt;/code&gt;这个可变长度的参数,其实就是我们在&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;中传递进来的主配置类&lt;code&gt;MainConfig&lt;/code&gt;, 也就是说,这个主配置类是可以存在多个的&lt;/p&gt;
&lt;p&gt;接着往下跟&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;T&amp;gt; void doRegisterBean(Class&amp;lt;T&amp;gt; annotatedClass, @Nullable Supplier&amp;lt;T&amp;gt; instanceSupplier, @Nullable String name,
            @Nullable Class&amp;lt;? extends Annotation&amp;gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
        // 可以将当前类理解成一个方便参数传递的封装类
        // 意为: 被加上注解的通用的BD
        // 将传递进来的 主配置类封装进 这个AnnotatedGenericBeanDefinition
        AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);

        if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
            return;
        }

        abd.setInstanceSupplier(instanceSupplier);

        // 解析出它的元数据
        ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
        // 设置它的作用域
        abd.setScope(scopeMetadata.getScopeName());
        // 名称生成器, 目的是为BeanDefinition取个名字,因为这个BD最终被存放到一个map中,
        // 默认情况下@Configuration(value = &quot;XXX&quot;) 这个value有值,就是使用这个当成名字
        // 都这就使用 类名首字母小写当成名字
        String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

        // 处理bean上的通用注解, @Lazy  @Dependon @Primary role等
        AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);

        if (qualifiers != null) {
            for (Class&amp;lt;? extends Annotation&amp;gt; qualifier : qualifiers) {
 
                if (Primary.class == qualifier) {
                    abd.setPrimary(true);
                }
                //懒加载，前面加过
                else if (Lazy.class == qualifier) {
                    abd.setLazyInit(true);
                }
                else {
            
                    abd.addQualifier(new AutowireCandidateQualifier(qualifier));
                }
            }
        }

        for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
            customizer.customize(abd);
        }
        // 理解成方便参数传递的封装类
        BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd,beanName);
  
        definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
        // 我们关注的重点, 注册BeanDefinition
        BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的函数的主要作用如下: &lt;strong&gt;将我们通过&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;构造函数传递进来的主配置类封装进了AnnotatedGenericBeanDefinition中,然后解析它身上的其他注解完成属性的赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着跟进&lt;code&gt;registerBeanDefinition()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void registerBeanDefinition(
            BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
            throws BeanDefinitionStoreException {

        //   再来这个方法之前封装了一个 difinitionHolder , 然后在这里又把它拆分开传递给了下面的函数
        // Register bean definition under primary name.
        String beanName = definitionHolder.getBeanName();
        //   在当前的BeanDefinitionReaderUtils中使用
        registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

        // Register aliases for bean name, if any.
        String[] aliases = definitionHolder.getAliases();
        if (aliases != null) {
            for (String alias : aliases) {
                registry.registerAlias(beanName, alias);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续跟进&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是有回到了上面注册6大&lt;code&gt;RootBeanDefinition&lt;/code&gt;的逻辑中,&lt;strong&gt;将我们的主配置类注册进&lt;code&gt;BeanFactory&lt;/code&gt;的&lt;code&gt;BeanDefinitionMap&lt;/code&gt;中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
</description>
<pubDate>Mon, 14 Oct 2019 14:34:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>终于,有一天我也来看Spring的源码了,看了一阵之后感觉心情那叫一个舒畅,对Spring底层的实现也有了进一步的了解, 最直观的感受就是Spring的命名风格很赞,很长,真的长到使人见名知意, 闲言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11674684.html</dc:identifier>
</item>
<item>
<title>Java读源码之Thread - freshchen</title>
<link>http://www.cnblogs.com/freshchen/p/11674575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freshchen/p/11674575.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;JDK版本：1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读了Object的源码，wait和notify方法与线程联系紧密，而且多线程已经是必备知识，那保持习惯，就从多线程的源头Thread类开始读起吧。由于该类比较长，只读重要部分&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;h3 id=&quot;类声明和重要属性&quot;&gt;类声明和重要属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package java.lang;

public class Thread implements Runnable {

    private volatile String name;
    // 优先级
    private int            priority;
    //是否后台
    private boolean     daemon = false;
    /* JVM state */
    private boolean     stillborn = false;
    // 要跑的任务
    private Runnable target;
    // 线程组
    private ThreadGroup group;
    // 上下文加载器
    private ClassLoader contextClassLoader;
    // 权限控制上下文
    private AccessControlContext inheritedAccessControlContext;
    // 线程默认名字“Thread-{{ threadInitNumber }}”
    private static int threadInitNumber;
    // 局部变量，每个线程拥有各自独立的副本
    ThreadLocal.ThreadLocalMap threadLocals = null;
    // 有时候局部变量需要被子线程继承
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    // 线程初始化时申请的JVM栈大小
    private long stackSize;
    // 线程ID
    private long tid;
    // 线程init之后的ID
    private static long threadSeqNumber;
    // 0就是线程还处于NEW状态，没start
    private volatile int threadStatus = 0;
    // 给LockSupport.park用的需要竞争的对象
    volatile Object parkBlocker;
    // 给中断用的需要竞争的对象
    private volatile Interruptible blocker;
    // 线程最小优先级
    public final static int MIN_PRIORITY = 1;
    // 线程默认优先级
    public final static int NORM_PRIORITY = 5;
    // 线程最大优先级
    public final static int MAX_PRIORITY = 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;java线程有几种状态&quot;&gt;Java线程有几种状态？&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Thread类中的枚举
public enum State {
    // 线程刚创建出来还没start
    NEW,
    // 线程在JVM中运行了，需要去竞争资源，例如CPU
    RUNNABLE,
    // 线程等待获取对象监视器锁，损被别人拿着就阻塞
    BLOCKED,
    // 线程进入等待池了，等待觉醒
    WAITING,
    // 指定了超时时间
    TIMED_WAITING,
    // 线程终止
    TERMINATED;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这个图可以帮助理解Java线程的生命周期，&lt;strong&gt;这个图要会画&lt;/strong&gt;！面试中被问到，当时画的很不专业，难受！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/freshchen/resource/img/thread-status.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建&quot;&gt;创建&lt;/h3&gt;
&lt;p&gt;那么线程如何进入初始New状态呢？让我们来看看构造，头皮发麻，怎么有七八个构造，这里只贴了一个&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Thread() {
    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还好都是调用init()方法，怕怕的点开了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize, AccessControlContext acc,
                  boolean inheritThreadLocals) {
    if (name == null) {
        throw new NullPointerException(&quot;name cannot be null&quot;);
    }

    this.name = name;
    // 获取当前线程，也就是需要被创建线程的爸爸
    Thread parent = currentThread();
    SecurityManager security = System.getSecurityManager();
    if (g == null) {
        // 通过security获取线程组，其实就是拿的当前线程的组
        if (security != null) {
            g = security.getThreadGroup();
        }

        // 获取当前线程的组，这下确保肯定有线程组了
        if (g == null) {
            g = parent.getThreadGroup();
        }
    }

    // check一下组是否存在和是否有线程组修改权限
    g.checkAccess();

    // 子类执行权限检查，子类不能重写一些不是final的敏感方法
    if (security != null) {
        if (isCCLOverridden(getClass())) {
            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
        }
    }
    // 组里未启动的线程数加1，长时间不启动就会被回收
    g.addUnstarted();
    // 线程的组，是否后台，优先级，初始全和当前线程一样
    this.group = g;
    this.daemon = parent.isDaemon();
    this.priority = parent.getPriority();
    if (security == null || isCCLOverridden(parent.getClass()))
        // 子类重写check没过或者就没有security，这里要check下是不是连装载的权限都没有
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    // 访问控制上下文初始化
    this.inheritedAccessControlContext =
        acc != null ? acc : AccessController.getContext();
    // 任务初始化
    this.target = target;
    // 设置权限
    setPriority(priority);
    // 如果有需要继承的ThreadLocal局部变量就copy一下
    if (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    // 初始化JVM中待创建线程的栈大小
    this.stackSize = stackSize;

    // threadSeqNumber线程号加1
    tid = nextThreadID();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;
&lt;p&gt;现在线程已经是NEW状态了，我们还需要调用start方法，让线程进入RUNNABLE状态，真正在JVM中快乐的跑起来，当获得了执行任务所需要的资源后，JVM便会调用target（Runnable）的run方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：我们永远不要对同一个线程对象执行两次start方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized void start() {
    // 0就是NEW状态
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    // 把当前线程加到线程组的线程数组中，然后nthreads线程数加1，nUnstartedThreads没起的线程数减1
    group.add(this);

    boolean started = false;
    // 请求资源
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
    // 起失败啦，把当前线程从线程组的线程数组中删除，然后nthreads减1，nUnstartedThreads加1
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            // start0出问题会自己打印堆栈信息
        }
    }
}

private native void start0();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;终止&quot;&gt;终止&lt;/h3&gt;
&lt;p&gt;现在我们的线程已经到RUNNABLE状态了，一切顺利的话任务执行完成，自动进入TERMINATED状态，天有不测风云，我们还会再各个状态因为异常到达TERMINATED状态。&lt;/p&gt;
&lt;p&gt;Thread类为我们提供了interrupt方法，可以设置中断标志位，设置了中断之后不一定有影响，还需要满足一定的条件才能发挥作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RUNNABLE&lt;/strong&gt;状态下
&lt;ul&gt;&lt;li&gt;默认什么都不会发生，需要代码中循环检查 中断标志位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WAITING&lt;/strong&gt;/&lt;strong&gt;TIMED_WAITING&lt;/strong&gt;状态下
&lt;ul&gt;&lt;li&gt;这两个状态下，会从对象等待池中出来，等拿到监视器锁会抛出&lt;strong&gt;InterruptedException&lt;/strong&gt;异常，然后中断标志位被清空。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BLOCKED&lt;/strong&gt;状态下
&lt;ul&gt;&lt;li&gt;如果线程在等待锁，对线程对象调用interrupt()只是会设置线程的中断标志位，&lt;strong&gt;线程依然会处于BLOCKED状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NEW&lt;/strong&gt;/&lt;strong&gt;TERMINATE&lt;/strong&gt;状态下
&lt;ul&gt;&lt;li&gt;啥也不发生&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 设置别的线程中断
public void interrupt() {
    if (this != Thread.currentThread())
        checkAccess();
    // 拿一个可中断对象Interruptible的锁
    synchronized (blockerLock) {
        Interruptible b = blocker;
        if (b != null) {
            interrupt0();           // 设置中断标志位
            b.interrupt(this);
            return;
        }
    }
    interrupt0();
}

// 获取当前线程中断标志位，然后重置中断标志位
public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}

// 检查线程中断标志位
public boolean isInterrupted() {
    return isInterrupted(false);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;等待&quot;&gt;等待&lt;/h3&gt;
&lt;p&gt;主线已经做完了，下面来看下支线任务，同样重要哦。从线程状态图看到，RUNNABLE状态可以变成BLOCKED，WAITING或TIMED_WAITING。&lt;/p&gt;
&lt;p&gt;其中BLOCKED主要是同步方法竞争锁等同步资源造成的，而TIMED_WAITING主要是加了超时时间，其他和WAITING的内容差不多，唯一多了一个sleep方法。&lt;/p&gt;
&lt;h4 id=&quot;sleep&quot;&gt;sleep&lt;/h4&gt;
&lt;p&gt;果不其然，sleep方法和Object.wait方法如出一辙，都是调用本地方法，提供毫秒和纳秒两种级别的控制，唯一区别就是，&lt;strong&gt;sleep不会放弃任何占用的监视器锁&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static native void sleep(long millis) throws InterruptedException;

// 纳秒级别控制
public static void sleep(long millis, int nanos) throws InterruptedException {
    if (millis &amp;lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (nanos &amp;lt; 0 || nanos &amp;gt; 999999) {
        throw new IllegalArgumentException(
            &quot;nanosecond timeout value out of range&quot;);
    }

    if (nanos &amp;gt;= 500000 || (nanos != 0 &amp;amp;&amp;amp; millis == 0)) {
        millis++;
    }

    sleep(millis);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;join&quot;&gt;join&lt;/h4&gt;
&lt;p&gt;join方法会让线程进入WAITING，等待另一个线程的终止，整个方法和Object.wait方法也是很像，而且实现中也用到了wait&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final synchronized void join(long millis) throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis &amp;lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (millis == 0) {
        // 判断调用join的线程是否活着，这里的活着是指RUNNABLE,BLOCKED,WAITING,TIMED_WAITING这四种状态，如果活着就一直等着，wait(0)意味着无限等
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay &amp;lt;= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}

// 纳秒级别控制
public final synchronized void join(long millis, int nanos)
    throws InterruptedException {

    if (millis &amp;lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (nanos &amp;lt; 0 || nanos &amp;gt; 999999) {
        throw new IllegalArgumentException(
            &quot;nanosecond timeout value out of range&quot;);
    }

    if (nanos &amp;gt;= 500000 || (nanos != 0 &amp;amp;&amp;amp; millis == 0)) {
        millis++;
    }

    join(millis);
}

public final void join() throws InterruptedException {
    join(0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他方法&quot;&gt;其他方法&lt;/h3&gt;
&lt;h4 id=&quot;yield&quot;&gt;yield&lt;/h4&gt;
&lt;p&gt;告诉操作系统的调度器：我的cpu可以先让给其他线程,但是我占有的同步资源不让。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，调度器可以不理会这个信息&lt;/strong&gt;。这个方法几乎没用，调试并发bug可能能派上用场&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static native void yield();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;setpriority&quot;&gt;setPriority&lt;/h4&gt;
&lt;p&gt;有些场景是需要根据线程的优先级来调度的，优先级越大越先执行，最大10，默认5，最小1&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void setPriority(int newPriority) {
    ThreadGroup g;
    checkAccess();
    if (newPriority &amp;gt; MAX_PRIORITY || newPriority &amp;lt; MIN_PRIORITY) {
        throw new IllegalArgumentException();
    }
    if((g = getThreadGroup()) != null) {
        // 如果设置的优先级，比线程所属线程组中优先级的最大值还大，我们需要更新最大值
        if (newPriority &amp;gt; g.getMaxPriority()) {
            newPriority = g.getMaxPriority();
        }
        // 本地方法
        setPriority0(priority = newPriority);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;弃用方法&quot;&gt;弃用方法&lt;/h3&gt;
&lt;p&gt;有些熟悉的方法已经被弃用了，我们要避免使用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Deprecated
public final void stop()
@Deprecated
public final synchronized void stop(Throwable obj)
@Deprecated
public void destroy()
@Deprecated
public final void suspend()
@Deprecated
public final void resume()
@Deprecated
public native int countStackFrames()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;
&lt;h4 id=&quot;interrupt&quot;&gt;interrupt()&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadInterruptTest {

    /**
     * 如果我们同时调用了notify和interrupt方法，程序有可能正常执行结束，有可能抛出异常结束,
     * 原因是不管是因为notify还是interrupt,线程离开了等待池，都需要去竞争锁,
     * 如果interrupt调用瞬间拿到锁，notify还没有调用，就抛中断异常
     * 如果是interrupt调用瞬间拿不到锁，此时中断标志位被重置，然后notify把线程拉到正常轨道，就继续执行不抛中断异常
     */
    private static void testInterrupt() {
        Object object = new Object();
        Thread thread1 = new Thread(() -&amp;gt; {
            synchronized (object) {
                try {
                    object.wait();
                    System.out.println(&quot;我还活着！&quot;);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                }

            }

        });

        thread1.start();

        new Thread(() -&amp;gt; {
            // 只为了演示，实际很少用到这些方法，而且我们在执行中断的同步代码块中最好不要做别的事情，例如这里的notify
            synchronized (object) {
                thread1.interrupt();
                object.notify();
            }
        }).start();
    }

    public static void main(String[] args) {
        for (int i = 0; i &amp;lt;5 ; i++) {
            ThreadInterruptTest.testInterrupt();
        }

    }
}
/**
 * 输出：
 * 我还活着！
 * java.lang.InterruptedException
 *  at java.lang.Object.wait(Native Method)
 *  at java.lang.Object.wait(Object.java:502)
 *  at study.ThreadInterruptTest.lambda$testInterrupt$0(ThreadInterruptTest.java:15)
 *  at java.lang.Thread.run(Thread.java:748)
 * java.lang.InterruptedException
 *  at java.lang.Object.wait(Native Method)
 *  at java.lang.Object.wait(Object.java:502)
 *  at study.ThreadInterruptTest.lambda$testInterrupt$0(ThreadInterruptTest.java:15)
 *  at java.lang.Thread.run(Thread.java:748)
 * 我还活着！
 * java.lang.InterruptedException
 *  at java.lang.Object.wait(Native Method)
 *  at java.lang.Object.wait(Object.java:502)
 *  at study.ThreadInterruptTest.lambda$testInterrupt$0(ThreadInterruptTest.java:15)
 *  at java.lang.Thread.run(Thread.java:748)
 *
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;join-1&quot;&gt;join()&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadJoinTest {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&amp;gt; {
            System.out.println(&quot;你好&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;你更好！&quot;);
        });

        thread1.start();

        new Thread(() -&amp;gt; {
            System.out.println(&quot;你也好&quot;);
            try {
                thread1.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;你最好！！&quot;);
        }).start();
    }

    /**
     * 输出：
     * 你好
     * 你也好
     * 你更好！
     * 你最好！！
     */
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 14 Oct 2019 14:14:00 +0000</pubDate>
<dc:creator>freshchen</dc:creator>
<og:description>前言 JDK版本：1.8 阅读了Object的源码，wait和notify方法与线程联系紧密，而且多线程已经是必备知识，那保持习惯，就从多线程的源头Thread类开始读起吧。由于该类比较长，只读重要部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/freshchen/p/11674575.html</dc:identifier>
</item>
<item>
<title>操作系统——文件管理 - W❤L</title>
<link>http://www.cnblogs.com/xxwang1018/p/11674472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxwang1018/p/11674472.html</guid>
<description>&lt;h2 id=&quot;文件与文件系统&quot;&gt;1.1文件与文件系统&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）数据项&lt;/p&gt;
&lt;p&gt;在文件系统中，数据项是最低级的数据组织形式。分为两种类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基本数据项。描述一个对象某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位，又称字段。除了数据名还有数据类型&lt;/li&gt;
&lt;li&gt;组合数据项。由若干基本数据项组成&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;数据项的名字和类型共同定义了数据项的“型”，表征一个实体在数据项上的数据称为“值”&lt;/p&gt;
&lt;p&gt;2）记录&lt;/p&gt;
&lt;p&gt;记录是一组相关数据项的集合，用于描述一个对象在某方面的属性&lt;/p&gt;
&lt;p&gt;一个记录应包含哪些数据项取决于需要描述对象的哪个方面&lt;/p&gt;
&lt;p&gt;唯一标识一个记录的一个或多个数据项称为&lt;u&gt;关键字&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;3）文件&lt;/p&gt;
&lt;p&gt;文件是具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件&lt;/p&gt;
&lt;p&gt;有结构文件由若干个相关记录组成，无结构文件看成是一个字符流&lt;/p&gt;
&lt;p&gt;文件是文件系统中最大的数据单位&lt;/p&gt;
&lt;p&gt;文件属性包括：文件类型、文件长度、文件的物理地址、文件的建立时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、文件系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）定义&lt;/p&gt;
&lt;p&gt;文件系统是操作系统用于明确磁盘或分区上的文件的方法和数据结构，即在磁盘上组织文件的方法；也指用于存储文件的磁盘或分区，或文件系统种类&lt;/p&gt;
&lt;p&gt;操作系统中负责管理和存储文件信息的软件机构称为&lt;u&gt;文件管理系统，简称文件系统&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构&lt;/p&gt;
&lt;p&gt;从系统角度来看，文件系统是对文件存储器空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等&lt;/p&gt;
&lt;p&gt;2）文件系统的层次结构&lt;/p&gt;
&lt;p&gt;文件系统的模型可分为三个层次：最底层是对象及其属性，中间层是对对象进行操纵和管理的软件集合，最高层是文件系统提供给用户的接口&lt;/p&gt;
&lt;p&gt;文件系统管理的对象：文件、目录、磁盘存储空间&lt;/p&gt;
&lt;p&gt;与文件系统有关的软件分为四个层次：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;I/O控制层。文件系统的最底层，主要由磁盘驱动程序组成&lt;/li&gt;
&lt;li&gt;基本文件系统层。处理内存与磁盘之间数据块的交换&lt;/li&gt;
&lt;li&gt;基本 I/O管理程序。完成与磁盘 I/O有关的事务&lt;/li&gt;
&lt;li&gt;逻辑文件系统。处理与文件和记录相关的操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文件系统的接口：命令接口，程序接口&lt;/p&gt;
&lt;h2 id=&quot;文件的逻辑结构&quot;&gt;1.2文件的逻辑结构&lt;/h2&gt;
&lt;p&gt;用户看到的文件称为逻辑文件，它由一系列逻辑记录组成。从用户角度看，文件的逻辑记录是能被存取的基本单位&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、顺序文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;排列方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;串结构：按&lt;u&gt;存入时间的先后&lt;/u&gt;排序。对串结构文件进行检索时，每次都必须从头开始，逐个查找&lt;/li&gt;
&lt;li&gt;顺序结构：按&lt;u&gt;关键字&lt;/u&gt;排序。检索时可利用有效的查找算法，如折半查找、跳步查找等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最佳应用场合是对文件中的记录进行批量存取&lt;/li&gt;
&lt;li&gt;所有逻辑文件中顺序文件的存取效率最高&lt;/li&gt;
&lt;li&gt;顺序存储设备（如磁带）只能存储顺序存储文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户查找或修改单个记录需要在记录中逐个查找&lt;/li&gt;
&lt;li&gt;增删一个记录很困难&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、索引文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;出现原因：变长记录文件查找一个记录必须从第一个记录查起，耗时很长&lt;/p&gt;
&lt;p&gt;为变长记录文件建立一张索引表，主文件中的每个记录在索引表中设置一个表项，包括&lt;u&gt;指向记录的指针和记录的长度&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;索引表按关键字排序，其本身也是一个定长记录的顺序文件。这样就把对变长记录顺序文件的顺序检索变为对定长记录索引文件的随机检索&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/14/KS0hCt.jpg&quot; alt=&quot;KS0hCt.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将需要顺序查找的文件改造成可随即查找的文件，提高了查找速度&lt;/li&gt;
&lt;li&gt;记录的插入、删除非常方便&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：除了主文件，还需配置一张索引表，每个记录都要有一个索引项，增加了存储开销&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、索引顺序文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本克服了边长记录顺序文件不能随机访问，以及不便于记录插入、删除的缺点，但&lt;u&gt;记录仍按关键字排序&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;增加了两个新特征：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;引入文件索引表，通过该表能实现对顺序文件的随机访问&lt;/li&gt;
&lt;li&gt;增加溢出文件，记录增加的、删除的、修改的记录&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;1）一级索引顺序文件&lt;/p&gt;
&lt;p&gt;首先将变长记录顺序文件的所有记录分为若干组（如50个一组），然后为顺序文件建立一张索引表，并为每组的第一个记录在索引表中建立一个索引项，包括该记录的关键字和指向该记录的指针&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/14/KSDo7Q.jpg&quot; alt=&quot;KSDo7Q.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对索引顺序文件进行检索时，先利用用户提供的关键字和某种查找算法检索索引表，找到该记录所在组；然后利用顺序查找法查找主文件，直到找到记录&lt;/p&gt;
&lt;p&gt;2）两级索引顺序文件&lt;/p&gt;
&lt;p&gt;先为文件建立一张低级索引表，若干记录一组；再为低级索引表建立一张高级索引表，若干低级索引表一组。每个表项存放的是低级索引表每组第一个表项的关键字以及指向该表项的指针&lt;/p&gt;
&lt;h2 id=&quot;文件目录&quot;&gt;1.3文件目录&lt;/h2&gt;
&lt;p&gt;对目录管理的要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现”按名存取“&lt;/li&gt;
&lt;li&gt;提高对目录的检索速度&lt;/li&gt;
&lt;li&gt;文件共享&lt;/li&gt;
&lt;li&gt;允许文件重名&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;1、文件控制块和索引节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）文件控制块&lt;/p&gt;
&lt;p&gt;文件控制块中应包括三类信息：基本信息，存取控制信息，使用信息&lt;/p&gt;
&lt;p&gt;基本信息包括：文件名，文件物理位置，文件逻辑结构，文件物理结构&lt;/p&gt;
&lt;p&gt;存取控制信息包括：文件主、核准用户、一般用户的存取权限&lt;/p&gt;
&lt;p&gt;使用信息包括：文件的建立日期和时间，文件上次修改的日期和时间，当前使用信息&lt;/p&gt;
&lt;p&gt;2）索引结点&lt;/p&gt;
&lt;p&gt;在检索目录文件的过程中只用到了文件名，仅当其中的文件名和指定查找的文件名匹配时，才从该目录文件中读取文件的物理地址&lt;/p&gt;
&lt;p&gt;为使检索更高效，系统把文件名和文件描述信息分开，将文件描述信息单独形成一个称为索引结点的数据结构&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;磁盘索引结点：存放在磁盘上的索引结点。每个文件有唯一的磁盘索引结点&lt;/li&gt;
&lt;li&gt;内存索引结点：存放在内存中的索引结点。当文件被打开时，要将磁盘索引结点拷贝到内存索引结点中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;2、单级文件目录和两级文件目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）单级文件目录&lt;/p&gt;
&lt;p&gt;整个文件系统只建立一张目录表，每个文件占一个目录项，每个目录项含文件名、文件扩展名、文件长度、文件类型、文件物理地址及其他文件属性。此外还设置一个状态位表示文件是否空闲&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/14/KSo0je.jpg&quot; alt=&quot;KSo0je.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建立新文件时，先检索所有的目录项以保证新文件名在目录中唯一。然后从目录表中找出一个空白目录项，填入新文件的信息并置状态位为 1。删除文件时，先从目录中找到该文件的目录项，回收文件所占存储空间，再清除目录项&lt;/p&gt;
&lt;p&gt;优点：简单&lt;/p&gt;
&lt;p&gt;缺点：只能实现按名存取，查找速度慢，不允许重名，不便于实现文件共享&lt;/p&gt;
&lt;p&gt;2）两级文件目录&lt;/p&gt;
&lt;p&gt;为每个用户建立一个单独的用户文件目录 UFD，它由用户所有文件的文件控制块组成&lt;/p&gt;
&lt;p&gt;系统中建立一个主文件目录 MFD，MFD中每个用户目录文件都占有一个目录项，包括用户名和指向该用户目录文件的指针&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/14/KSoDnH.jpg&quot; alt=&quot;KSoDnH.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在两级目录文件中，如果用户希望有自己的 UFD，可请求系统为自己建立；当不再需要时请求系统管理员撤销即可。有了 UFD后，用户想增删文件，OS只需检查该用户的 UFD，然后执行相关操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、树形目录结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电脑日常使用的结构即树形目录结构。以 Linux为例，方框代表目录文件，圆圈代表数据文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/14/KSTZKe.jpg&quot; alt=&quot;KSTZKe.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）路径名&lt;/p&gt;
&lt;p&gt;在树形结构中，从根目录到任何数据文件都只有唯一的路&lt;/p&gt;
&lt;p&gt;该路径从主目录开始，把全部目录文件名与数据文件名用”/“连接起来你，构成该数据文件唯一的路径名&lt;/p&gt;
&lt;p&gt;2）当前目录&lt;/p&gt;
&lt;p&gt;进程运行时访问的文件大多局限于某个范围，每次从主目录开始查找极不方便，于是为进程设置一个”当前目录“，进程对各文件的访问都相当于当前目录进行&lt;/p&gt;
&lt;p&gt;从当前目录到数据文件构成的路径叫相对路径名&lt;/p&gt;
&lt;p&gt;从主目录开始的路径名叫绝对路径名&lt;/p&gt;
&lt;h2 id=&quot;文件共享&quot;&gt;1.4文件共享&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、基于有向无循环图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;树形结构目录不适合文件共享&lt;/p&gt;
&lt;p&gt;如果允许一个文件可以有多个父目录，即有多个属于不同用户的多个目录，同时指向同一个文件，虽然会破坏树的特性，但这些用户可用对称的方式实现文件共享而不必通过其属主目录访问&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;如何建立父目录与共享文件间的链接？&lt;/p&gt;
&lt;p&gt;&lt;u&gt;方法一&lt;/u&gt;：&lt;/p&gt;
&lt;p&gt;如果文件目录中包含的是文件的物理地址，即文件所在盘块的盘号，链接时必须将文件的物理地址拷贝到父目录中&lt;/p&gt;
&lt;p&gt;但以后父目录向文件中添加新内容时必然相应增加新的盘块，这些新增盘块只会出现在执行了操作的目录中，新增的内容不能被共享&lt;/p&gt;
&lt;p&gt;&lt;u&gt;方法二&lt;/u&gt;：&lt;/p&gt;
&lt;p&gt;在文件目录中只设置文件名和指向相应索引结点的指针&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/14/KSOqeS.jpg&quot; alt=&quot;KSOqeS.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，用户 Wang和 Lee的文件目录中都设置有指向共享文件的索引结点指针，任何用户对共享文件的操作都会引起相应结点内容的改变，这些改变对用户可见，从而能让用户共享&lt;/p&gt;
&lt;p&gt;索引结点中有一个链接计数 count，表示链接到本索引结点上的用户目录项的数目&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当某用户 C创建一个文件，并有其它用户 B共享该文件。当 C删除文件时，也删除了该文件的索引结点，会导致 B的指针悬空，执行的操作半途而废&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/14/KSjC9A.jpg&quot; alt=&quot;KSjC9A.jpg&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、利用符号链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）基本思想&lt;/p&gt;
&lt;p&gt;允许一个文件或子目录有多个父目录，但仅有一个作为主父目录，其它父目录通过符号链接方式与之相链接&lt;/p&gt;
&lt;p&gt;这样的好处是属主结构（实线连接起来的结构）仍然是简单树，对文件的删除、查找更为方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/14/KpB6c6.png&quot; alt=&quot;KpB6c6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）实现&lt;/p&gt;
&lt;p&gt;为使链接父目录 D5能共享文件 F，可以由系统创建一个 LINK类型的新文件，取名 F，并将 F写入链接父目录 D5中，以实现 D5与 F8的链接。新文件 F中只包含被链接文件 F8的路径名&lt;/p&gt;
&lt;p&gt;当用户通过 D5访问被链接的文件 F8，且正要读 LINK类新文件时，此要求被 OS截获，OS根据新文件中的路径名找到文件 F8进行操作。这样就实现了用户 B对文件 F的共享&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只有文件主才拥有指向其索引结点的指针，共享该文件的其它用户只有该文件的路径名&lt;/li&gt;
&lt;li&gt;当文件拥有者删除共享文件后，其他用户会因为系统找不到该文件而访问失败，然后删除符号链而不会有任何影响&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其他用户读共享文件时，系统根据给定的文件路径名逐个分量查找目录，开销甚大，且增加了启动磁盘的频率&lt;/li&gt;
&lt;li&gt;要为每个共享用户建立一条符号链，耗费一定的磁盘空间&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;文件保护&quot;&gt;1.5文件保护&lt;/h2&gt;
&lt;p&gt;为了防止文件共享可能会导致的&lt;u&gt;文件被破坏或未经核准的用户修改文件&lt;/u&gt;，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此必须在文件系统中建立相应的文件保护机制&lt;/p&gt;
&lt;p&gt;文件保护通过&lt;u&gt;口令保护、加密保护和访问控制&lt;/u&gt;等方式实现。其中，&lt;u&gt;口令保护和加密保护是为了防止用户文件被他人存取或窃取，而访问控制用于控制用户对文件的访问方式&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、访问类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对文件的保护可以从限制对文件的访问类型出发。可加以控制的访问类型主要有以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读：从文件中读&lt;/li&gt;
&lt;li&gt;写：向文件中写&lt;/li&gt;
&lt;li&gt;执行：将文件装入内存并执行&lt;/li&gt;
&lt;li&gt;添加：将新信息添加到文件结尾部分&lt;/li&gt;
&lt;li&gt;删除：删除文件，释放空间&lt;/li&gt;
&lt;li&gt;列表清单：列出文件名和文件属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统程序调用低层系统调用来实现&lt;/p&gt;
&lt;p&gt;保护可以只在低层提供。例如，复制文件可利用一系列的读请求来完成，这样具有读访问的用户同时也具有复制和打印的权限&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、访问控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最普通方法是为每个文件和目录增加一个访问控制列表，以规定每个用户名及其所允许的访问类型&lt;/p&gt;
&lt;p&gt;这种方法的优点是可以使用复杂的访问方法，缺点是长度无法预期并且可能导致复杂的空间管理。可使用&lt;u&gt;精简的访问列表&lt;/u&gt;可以解决这个问题，精简的访问列表包括&lt;u&gt;拥有者、组和其他&lt;/u&gt;三种用户类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拥有者：创建文件的用户。&lt;/li&gt;
&lt;li&gt;组：一组需要共享文件且具有类似访问的用户。&lt;/li&gt;
&lt;li&gt;其他：系统内的所有其他用户。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只需用三个域写出访问列表中三类用户的访问权限：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件拥有者在创建文件时，说明创建者用户名及所在的组名；系统在创建文件时也将文件主的名字、所属组名写在该文件的 FCB中&lt;/li&gt;
&lt;li&gt;用户访问该文件时，按照拥有者所拥有的权限访问文件，如果用户和拥有者在同一个用户组则按照同组权限访问，否则只能按其他用户权限访问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;口令和密码是另外两种访问控制方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;口令指用户在建立一个文件时提供一个口令，系统为其建立 FCB时附上相应口令，同时通知允许共享该文件的其他用户。用户请求访问时必须提供相应口令&lt;/li&gt;
&lt;li&gt;密码指用户对文件进行加密，文件被访问时需要使用密钥&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现代操作系统常用的文件保护方法，是将访问控制列表与用户、组和其他成员访问控制方案一起组合使用&lt;/li&gt;
&lt;li&gt;对于多级目录结构而言，不仅需要保护单个文件，而且还需要保护子目录内的文件, 即需要提供目录保护机制。目录操作与文件操作并不相同，因此需要不同的保护机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;文件系统层次结构&quot;&gt;2.1文件系统层次结构&lt;/h2&gt;
&lt;p&gt;1、用户调用接口&lt;/p&gt;
&lt;p&gt;文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件，建立、删除目录等&lt;/p&gt;
&lt;p&gt;此层由若干程序模块组成，每一模块对应一条系统调用，用户发出系统调用时，控制即转入相应的模块&lt;/p&gt;
&lt;p&gt;2、文件目录系统&lt;/p&gt;
&lt;p&gt;文件目录系统的主要功能是管理文件目录，其任务有管理活跃文件目录表、管理读写状态信息表、管理用户进程的打开文件表、管理与组织在存储设备上的文件目录结构、调用下一级存取控制模块&lt;/p&gt;
&lt;p&gt;3、存取控制验证&lt;/p&gt;
&lt;p&gt;实现文件保护主要由该级软件完成，它把用户的访问要求与FCB中指示的访问控制权限进行比较，以确认访问的合法性&lt;/p&gt;
&lt;p&gt;4、逻辑文件系统与文件信息缓冲区&lt;/p&gt;
&lt;p&gt;逻辑文件系统与文件信息缓冲区的主要功能是根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号&lt;/p&gt;
&lt;p&gt;5、物理文件系统&lt;/p&gt;
&lt;p&gt;物理文件系统的主要功能是把逻辑记录所在的相对块号转换成实际的物理地址&lt;/p&gt;
&lt;p&gt;6、分配模块&lt;/p&gt;
&lt;p&gt;分配模块的主要功能是把逻辑记录所在的相对块号转换成实际的物理地址&lt;/p&gt;
&lt;p&gt;7、设备管理程序模块&lt;/p&gt;
&lt;p&gt;设备管理程序模块的主要功能是分配设备、分配设备读写用缓冲区、磁盘调度、启动设备、处理设备中断、释放设备读写缓冲区、释放设备等&lt;/p&gt;
&lt;h2 id=&quot;目录实现&quot;&gt;2.2目录实现&lt;/h2&gt;
&lt;p&gt;目录分配和目录管理算法的选择对文件系统的效率、性能和可靠性有很大的影响&lt;/p&gt;
&lt;p&gt;1、线性列表&lt;/p&gt;
&lt;p&gt;最为简单的目录实现算法就是使用存储文件名和数据块指针的线性列表，这种方法编程简单但是运行时较为费时&lt;/p&gt;
&lt;p&gt;要创建新文件，必须首先搜索目录以确定没有同样名称的文件存在，接着，在目录后增加一个新条目，要删除文件时，根据给定文件名搜索目录，接着释放分配给他的空间，如果需要重用目录条目，可以有许多办法，可以将目录条目标记为不再使用或者可以将它加到空闲目录条目上&lt;/p&gt;
&lt;p&gt;2、哈希表&lt;/p&gt;
&lt;p&gt;用于文件目录的另一个数据结构就是哈希表，采用这种方法时，处理使用线性列表存储目录条目，还使用了哈希数据结构。哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针，大大减小了目录搜索时间&lt;/p&gt;
&lt;p&gt;哈希表的最大困难就是其通常固定的大小和哈希函数对大小的依赖性&lt;/p&gt;
&lt;h2 id=&quot;文件实现&quot;&gt;2.3文件实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、文件分配方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方式有三种：连续分配、链接分配和索引分配。有的系统对三种方式都支持，但是更普遍的是一个系统只提供一种方法支持&lt;/p&gt;
&lt;p&gt;1）连续分配&lt;/p&gt;
&lt;p&gt;连续分配方法要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序，这种排序使作业访问磁盘时需要的寻道数和寻道时间最小&lt;/p&gt;
&lt;p&gt;文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。如果文件有 n块长并从位置 b开始，那么该文件将占 b，b + 1，b + 2，…，b + n - 1&lt;/p&gt;
&lt;p&gt;一个文件的目录条目包括开始块的地址和该文件所分配区域的长度&lt;/p&gt;
&lt;p&gt;连续分配支持顺序访问和直接访问&lt;/p&gt;
&lt;p&gt;优点：实现简单、存取速度快&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件长度不宜动态增加，因为一个文件末尾后的盘块可能已经分配给其他文件，一旦需要增加就需要大量移动盘块&lt;/li&gt;
&lt;li&gt;反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似），并且很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2）链接分配&lt;/p&gt;
&lt;p&gt;链接分配解决了连续分配的碎片和文件大小问题&lt;/p&gt;
&lt;p&gt;采用链接分配，每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，除最后一个盘块外，每个盘块都有指向下一个盘块的指针，这些指针对用户是透明的&lt;/p&gt;
&lt;p&gt;目录包括文件第一块的指针和最后一块的指针。创建新文件时，目录中会增加一个新条目&lt;/p&gt;
&lt;p&gt;链接分配中每个目录项都有一个指向文件首块的指针，该指针初始化为 NULL 以表示空文件，大小字段为0。写文件会通过空闲空间管理系统找到空闲块，将该块链接到文件的尾部，以便于写入；读文件则通过块到块的指针进行读操作&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;链接分配方式没有外部碎片，空闲空间列表上的任何块都可以用来满足请求&lt;/li&gt;
&lt;li&gt;创建文件时并不需要说明文件大小，只要有空闲块文件就可以创建，也无需合并磁盘空间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无法直接访问盘块，只能通过指针顺序访问文件，以及盘块指针消耗了一定的存储空间&lt;/li&gt;
&lt;li&gt;链接分配方式的稳定性也是一个问题&lt;/li&gt;
&lt;li&gt;系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3）索引分配&lt;/p&gt;
&lt;p&gt;链接分配解决了连续分配的外部碎片和文件大小管理的问题，但是链接分配不能有效支持直接访问（FAT除外），索引分配解决了这个问题&lt;/p&gt;
&lt;p&gt;索引分配把每个文件的所有的盘块号都集中在一起构成索引块。每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第 i 个条目指向文件的第 i 个块，目录条目包括索引块的地址，要读第 i 块，通过索引块的第 i 个条目的指针来查找和读入所需的块&lt;/p&gt;
&lt;p&gt;创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目&lt;/p&gt;
&lt;p&gt;优点：索引分配支持直接访问，且没有外部碎片问题&lt;/p&gt;
&lt;p&gt;缺点：索引块的分配增加了系统存储空间的开销&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。可以采用以下机制来处理这个问题：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;链接方案：一个索引块通常为一个磁盘块，因此本身能直接读写。为了处理大文件，可以将多个索引块链接起来&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;多层索引：多层索引使第一层索引块指向第二层的索引块，第二层的索引块再指向文件块。这种方法根据最大文件的大小的要求，可以继续到第三层或第四层。例如，4096B的块，能在索引块中存入1024个4B的指针。两层索引允许1048576个数据块，即允许最大文件为4G&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;混合索引：将多种索引分配方式相结合的分配方式。&lt;em&gt;例如，系统既采用直接地址又采用单级索引分配方式或两级索引分配方式&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此外，访问文件需要两次访问外存——首先要读取索引块的内容，然后在访问具体的磁盘块。因而降低了文件的存取速度，为了解决这一问题，通常将文件的索引块读入内存的缓冲区，以加快文件的访问速度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、文件存储器空间管理&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;文件存储管理空间的划分与初始化&lt;/p&gt;
&lt;p&gt;一般来说，一个文件存储在一个文件卷中。文件卷可以是物理盘的一部分，也可以是整个物理盘，支持超大型文件的文件卷也可以是有多个物理盘组成。&lt;/p&gt;
&lt;p&gt;在一个文件卷中，文件数据信息的空间（文件区）和存放文件控制信息FCB的空间（目录区）是分离的。由于存在很多种类的文件表示和存放格式，所以现代操作系统中一般都有很多不同的文件管理模块，通过他们可以访问不同格式的逻辑卷中的文件。逻辑卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放逻辑卷信息的超级块。&lt;/p&gt;
&lt;p&gt;文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织，分配与回收等问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1）空闲表法&lt;/p&gt;
&lt;p&gt;空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间&lt;/p&gt;
&lt;p&gt;系统为外存上的所有空闲区建立一张空闲盘块表，每个空闲区对应一个空闲表项，其中包括表项序号、该空闲区第一个盘块号、该区的空闲盘块数等信息。再将所有空闲区按其起始盘块号递增的次序排列&lt;/p&gt;
&lt;p&gt;空闲盘区的分配与内存的动态分配类似，同样是采用首次适应算法、循环首次适应算法等。例如，在系统为某新创建的文件分配空闲盘块时，先顺序的检索空闲盘块表的各表项，直至找到第一个其大小能满足要求的空闲区，再将该盘区分配给用户（进程），同时修改空闲盘块表&lt;/p&gt;
&lt;p&gt;系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法，即要考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应予以合并&lt;/p&gt;
&lt;p&gt;2）空闲链表法&lt;/p&gt;
&lt;p&gt;将所有空闲盘区拉成一条空闲链，根据构成连所有的基本元素不同，可以把链表分成两种形式：空闲盘块链和空闲盘区链&lt;/p&gt;
&lt;p&gt;①空闲盘块链是将磁盘上所有空闲空间以盘块为单位拉成一条链&lt;/p&gt;
&lt;p&gt;当用户因创建文件而请求分配存储空间时，系统从链首开始，一次摘下适当数目的空闲盘块分配给用户。当用户因删除文件而释放存储空间时，系统将回收的盘块一次并入空闲盘块链的末尾&lt;/p&gt;
&lt;p&gt;优点：分配和回收一个盘块很简单&lt;/p&gt;
&lt;p&gt;缺点：为一个文件分配盘块时，可能要重复多次操作&lt;/p&gt;
&lt;p&gt;②空闲盘区链是将磁盘上所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链&lt;/p&gt;
&lt;p&gt;在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数）的信息。分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将回收区域相邻接的空闲盘区相合并&lt;/p&gt;
&lt;p&gt;3）位视图法&lt;/p&gt;
&lt;p&gt;位视图是利用二进制的移位来表示磁盘中的一个盘块的使用情况&lt;/p&gt;
&lt;p&gt;磁盘上所有的盘块都有一个二进制位与之对应，当其值为0时，表示对应的盘块空闲；当其值为1时，表示对应的盘块已分配&lt;/p&gt;
&lt;p&gt;盘块的分配：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;顺序扫描位视图，从中找出一个或一组其值为0的二进制位&lt;/li&gt;
&lt;li&gt;将所找到的一个或一组二进制位，转换成与之对应的盘块号。假定找到的其值为0的二进制位，位于位视图的第 i 行，第 j 列，则其相应的盘块号硬干下式计算：b = n * ( i - 1) + j&lt;/li&gt;
&lt;li&gt;修改位视图，令 map[ i , j ] = 1&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;盘块的回收：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将回收盘块的盘块号转换成位视图中的行号和列号&lt;/li&gt;
&lt;li&gt;修改位视图，令 map[ i , j ] = 0&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;4）成组链接法&lt;/p&gt;
&lt;p&gt;空闲表法和空闲链表法都不适用于大型文件系统，因为会造成空闲表或空闲链表太大&lt;/p&gt;
&lt;p&gt;UNIX系统中采用成组链接法，这种方法结合了空闲表和空闲链表法两种方法，克服了表太大的缺点&lt;/p&gt;
&lt;p&gt;思想：把顺序的 n个空闲扇区地址保存在第一个空闲扇区内，其后一个空闲扇区则保存另一顺序空闲扇区的地址，如此继续直至所有空闲扇区均予以链接。系统只需要保存一个指向第一个空闲扇区的指针&lt;/p&gt;
&lt;p&gt;表示文件存储器空闲空间的位向量表或第一个成组链块以及卷中的目录区、文件区划分都需要存放在辅存储器中，一般放在卷头位置，UNIX系统中叫超级块。在对卷中文件进行操作前，超级块需要预先读入系统空间的主存，并且经常保持主存超级块与辅存卷中超级块的一致性&lt;/p&gt;

&lt;h2 id=&quot;磁盘的结构&quot;&gt;3.1磁盘的结构&lt;/h2&gt;
&lt;p&gt;磁盘是表面涂有磁性物质的金属或塑料构成的圆形盘片&lt;/p&gt;
&lt;p&gt;通常一个称为磁头的导体线圈从磁盘中存取数据。在读/写操作期间，磁头固定，磁盘在下面高速旋转&lt;/p&gt;
&lt;p&gt;磁盘盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽，一个盘面上有上千个磁道&lt;/p&gt;
&lt;p&gt;磁道又划分为几百个扇区，每个扇区固定存储大小，一个扇区称为一个盘块&lt;/p&gt;
&lt;p&gt;相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误&lt;/p&gt;
&lt;p&gt;由于扇区按固定圆心角划分，所以密度从外道向内道递增，磁盘的存储能力受限于最内道的最大记录密度&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;磁盘安装在一个磁盘驱动器中，它由磁头臂、用于旋转磁盘的主轴和用于数据输入/输出的电子设备组成。多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同且一起移动。所有盘片上相对位置相同的磁道组成柱面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扇区就是磁盘可寻址的最小存储单位，磁盘地址用“柱面号 ● 盘面号 ● 扇区号（或块号）”表示&lt;/p&gt;
&lt;p&gt;磁盘按不同方式可以分为若干类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;磁头相对于盘片的径向方向固定的称为固定头磁盘，每个磁道一个磁头&lt;/li&gt;
&lt;li&gt;磁头可移动的称为活动头磁盘，磁头臂可以来回伸缩定位磁道&lt;/li&gt;
&lt;li&gt;磁盘永久固定在磁盘驱动器内的称为固定盘磁盘&lt;/li&gt;
&lt;li&gt;可移动和替换的称为可换盘磁盘&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;磁盘调度算法&quot;&gt;3.2磁盘调度算法&lt;/h2&gt;
&lt;p&gt;一次磁盘读写操作的时间由&lt;u&gt;寻找（寻道）时间、延迟时间和传输时间&lt;/u&gt;决定：&lt;br/&gt;①寻找时间Ts&lt;/p&gt;
&lt;p&gt;活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间&lt;/p&gt;
&lt;p&gt;这个时间除跨越 n条磁道的时间外，还包括启动磁臂的时间 s，即：Ts = m * n + s&lt;/p&gt;
&lt;p&gt;m为与磁盘驱动器速度有关的常数，约为0.2ms，磁臂的启动时间约为2ms&lt;/p&gt;
&lt;p&gt;②延迟时间Tr&lt;/p&gt;
&lt;p&gt;磁头定位到某一磁道的扇区（块号）所需要的时间&lt;/p&gt;
&lt;p&gt;设磁盘的旋转速度为r，则：Tr = 1 / 2r&lt;/p&gt;
&lt;p&gt;对于硬盘，典型的旋转速度为5400r/m，相当于一周11.1m，则Tr为5.55ms；对于软盘，其旋转速度在300600r/m之间，则Tr为50100ms&lt;/p&gt;
&lt;p&gt;③传输时间Tt&lt;/p&gt;
&lt;p&gt;从磁盘读出或向磁盘写入数据所经历的时间&lt;/p&gt;
&lt;p&gt;这个时间取决于每次所读/写的字节数b和磁盘的旋转速度：Tt = b / r * N&lt;/p&gt;
&lt;p&gt;r为磁盘每秒钟的转数，N为一个磁道上的字节数&lt;/p&gt;
&lt;p&gt;在磁盘存取时间的计算中，&lt;u&gt;寻道时间与磁盘调度算法相关&lt;/u&gt;，而&lt;u&gt;延迟时间和传输时间与磁盘旋转速度线性相关&lt;/u&gt;，所以在硬件上，转速是磁盘性能的一个非常重要的参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、先来先服务（FCFS）算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FCFS算法根据进程请求访问磁盘的先后顺序进行调度处理&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;缺点：如果有大量进程竞争使用磁盘，那么该算法在性能上往往低于随即调度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、最短寻找时间优先（SSTF）算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSTF选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道&lt;/p&gt;
&lt;p&gt;优点：每次的寻找时间最短。当然总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比FCFS算法更好的性能&lt;/p&gt;
&lt;p&gt;缺点：会产生饥饿现象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、扫描（SCAN）算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又称电梯调度算法&lt;/p&gt;
&lt;p&gt;SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象&lt;/p&gt;
&lt;p&gt;SCAN算法对最扫描过的区域不公平，在访问局部性方面不如 FCFS算法和 SSTF算法好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、循环扫描（C-SCAN）算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在扫面算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求&lt;/p&gt;
&lt;p&gt;SCAN算法偏向于处理接近最里或最外层磁道的访问请求，所以使用C-SCAN算法来避免这个问题&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;采用 SCAN算法和 C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点&lt;/p&gt;
&lt;p&gt;这种形式的 SCAN算法和 C-SCAN算法成为 LOOK和 C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;磁盘的管理&quot;&gt;3.3磁盘的管理&lt;/h2&gt;
&lt;p&gt;1、磁盘初始化&lt;/p&gt;
&lt;p&gt;一个新的磁盘只是一个含有磁性记录材料的空白盘&lt;/p&gt;
&lt;p&gt;在磁盘能存储数据之前，它必须分成扇区以便磁盘控制器能进行读和写操作，这个过程称为低级初始化（物理分区）&lt;/p&gt;
&lt;p&gt;低级初始化为磁盘的每个扇区采用特别的数据结构。每个扇区的数据结构通常由头、数据区域和尾部组成，头部和尾部包含一个初始化为空的目录&lt;/p&gt;
&lt;p&gt;2、引导块&lt;/p&gt;
&lt;p&gt;计算机启动时需要运行一个初始化程序（自举程序），它初始化 CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，该自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，从而开始操作系统的运行&lt;/p&gt;
&lt;p&gt;自举程序通常保存在 ROM中，为了避免改变自举程序需要改变 ROM硬件的问题，只在 ROM中保留很小的自举装入程序，将完整功能的自举程序保存在磁盘的启动块上。启动块位于磁盘的固定位，拥有启动分区的磁盘称为自动磁盘或者系统磁盘&lt;/p&gt;
&lt;p&gt;3、坏块&lt;/p&gt;
&lt;p&gt;由于磁盘有移动部件且容错能力弱，所以容易导致一个或多个扇区损坏。部分磁盘甚至从出厂时就有坏扇区&lt;/p&gt;
&lt;p&gt;根据所使用的磁盘和控制器，对这些块有多种处理方式：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于简单磁盘，如电子集成驱动器，坏扇区可手工处理，如 MS-DOS的 Format命令执行逻辑格式化时便会扫描磁盘以检查坏扇区，坏扇区在 FAT表会标明，因此程序不会使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于复杂磁盘，如小型计算机系统接口，其控制器维护一个磁盘坏块链表，该链表在出厂前进行低级格式化时就初始化，并在磁盘的整个使用过程中不断更新。低级格式化将一些块保留作为备用，对操作系统透明。控制器可以用块来逻辑地替代坏块，这种方案称为扇区备用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对坏块的处实质上就是用某种机制使系统不去使用坏块。坏块属于硬件故障，操作系统无法修复坏块&lt;/p&gt;
</description>
<pubDate>Mon, 14 Oct 2019 13:57:00 +0000</pubDate>
<dc:creator>W❤L</dc:creator>
<og:description>[toc] 一、文件系统 1.1文件与文件系统 1、文件 1）数据项 在文件系统中，数据项是最低级的数据组织形式。分为两种类型： 1. 基本数据项。描述一个对象某种属性的字符集，是数据组织中可以命名的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xxwang1018/p/11674472.html</dc:identifier>
</item>
</channel>
</rss>