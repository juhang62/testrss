<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>OI中的线性代数(填坑中) - Destiny—</title>
<link>http://www.cnblogs.com/kgxw0430/p/10297011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kgxw0430/p/10297011.html</guid>
<description>[unable to retrieve full-text content]矩阵与矩阵的基本运算 定义： 行向量：矩阵的某一行所形成的向量。 列向量：矩阵的某一列所形成的向量。 线性组合与基底： 加法运算 减法运算 转置 矩阵乘法 矩阵乘法的分配律 A(B+C)=AB+AC (B+C)A=BA+CA 矩阵乘法的结合律 ABC=A（BC） 不满足交换律 单位矩阵 逆矩阵 行列</description>
<pubDate>Mon, 21 Jan 2019 07:50:00 +0000</pubDate>
<dc:creator>Destiny—</dc:creator>
<og:description>矩阵与矩阵的基本运算 定义： 行向量：矩阵的某一行所形成的向量。 列向量：矩阵的某一列所形成的向量。 线性组合与基底： 加法运算 减法运算 转置 矩阵乘法 矩阵乘法的分配律 A(B+C)=AB+AC </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kgxw0430/p/10297011.html</dc:identifier>
</item>
<item>
<title>考眼力 - longaotian</title>
<link>http://www.cnblogs.com/zaixialongaotian/p/10299149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaixialongaotian/p/10299149.html</guid>
<description>&lt;p class=&quot;timuss&quot;&gt;题目内容：&lt;/p&gt;
&lt;p&gt; gmbh{4d850d5c3c2756f67b91cbe8f046eebd} &lt;/p&gt;
&lt;p&gt;try to find the flag&lt;/p&gt;

&lt;p&gt;看到gmbh发现偏移，按照gmbh=flag发现字母向左发生偏移，字母全部向左移动一位即可得到flag。&lt;/p&gt;

&lt;p&gt;flag：flag{4c850c5b3b2756e67a91bad8e046ddac}&lt;/p&gt;
&lt;p&gt;总结：偏移&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 07:49:00 +0000</pubDate>
<dc:creator>longaotian</dc:creator>
<og:description>题目内容： gmbh{4d850d5c3c2756f67b91cbe8f046eebd} try to find the flag 看到gmbh发现偏移，按照g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaixialongaotian/p/10299149.html</dc:identifier>
</item>
<item>
<title>JS设计模式一：单例模式 - JoeJoan</title>
<link>http://www.cnblogs.com/Joe-and-Joan/p/10299125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Joe-and-Joan/p/10299125.html</guid>
<description>&lt;p&gt;    单例模式也称作为单子模式，更多的也叫做单体模式。为软件设计中较为简单但是最为常用的一种设计模式。&lt;/p&gt;

&lt;p&gt;    下面是维基百科对单例模式的介绍：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;    在应用单例模式时，生成单例的类必须保证只有一个实例的存在，很多时候整个系统只需要拥有一个全局对象，才有利于协调系统整体的行为。比如在整个系统的配置文件中，配置数据有一个单例对象进行统一读取和修改，其他对象需要配置数据的时候也统一通过该单例对象来获取配置数据，这样就可以简化复杂环境下的配置管理。&lt;/div&gt;
&lt;p&gt;    单例模式的思路是：一个类能返回一个对象的引用（并且永远是同一个）和一个获得该实例的方法（静态方法，通常使用 getInstance 名称）。那么当我们调用这个方法时，如果类持有的引用不为空就返回该引用，否者就创建该类的实例，并且将实例引用赋值给该类保持的那个引用再返回。同时将该类的构造函数定义为私有方法，避免其他函数使用该构造函数来实例化对象，只通过该类的静态方法来得到该类的唯一实例。&lt;/p&gt;

&lt;p&gt;    对于 JS 来说，巨大的灵活性使得其可以有多种方式实现单例模式，使用闭包方式来模拟私有数据，按照其思路可得：&lt;/p&gt;
&lt;div&gt;&lt;br/&gt;&lt;div id=&quot;codeText&quot; class=&quot;codeText&quot; readability=&quot;57&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; single = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; unique;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( unique ===&lt;span&gt; undefined ){
            unique &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Construct();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unique;
    }
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Construct(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... 生成单例的构造函数的代码&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        getInstance : getInstance
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    以上，unique便是返回对象的引用，而 getInstance便是静态方法获得实例。Construct 便是创建实例的构造函数。&lt;/p&gt;
&lt;p&gt;    可以通过 single.getInstance() 来获取到单例，并且每次调用均获取到同一个单例。这就是 单例模式 所实现的效果。&lt;/p&gt;

&lt;p&gt;    不过，对于JS来说，显然以上循规蹈矩的方式显得过于笨重，在不同的场景以不同的方式实现单体模式正是 JS 的优势&lt;/p&gt;
&lt;h2&gt;    实现1： 最简单的对象字面量&lt;/h2&gt;
&lt;div&gt;
&lt;div id=&quot;codeText&quot; class=&quot;codeText&quot;&gt;
&lt;ol class=&quot;dp-css&quot; start=&quot;1&quot;&gt;&lt;li&gt;var singleton = {&lt;/li&gt;
&lt;li&gt;        attr : 1,&lt;/li&gt;
&lt;li&gt;        method : function(){ return this.attr; }&lt;/li&gt;
&lt;li&gt;    }&lt;/li&gt;
&lt;li&gt;var t1 = singleton ;&lt;/li&gt;
&lt;li&gt;var t2 = singleton ;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;    那么很显然的， t1 === t2 。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;    十分简单，并且非常使用，不足之处在于没有什么封装性，所有的属性方法都是暴露的。对于一些需要使用私有变量的情况就显得心有余而力不足了。当然在对于 this 的问题上也是有一定弊端的。&lt;/p&gt;
&lt;h2&gt;    实现2：构造函数内部判断&lt;/h2&gt;
&lt;p&gt;    其实和最初的JS实现有点类似，不过是将对是否已经存在该类的实例的判断放入构造函数内部。&lt;/p&gt;
&lt;div&gt;&lt;br/&gt;&lt;div id=&quot;codeText&quot; class=&quot;codeText&quot;&gt;
&lt;ol class=&quot;dp-css&quot; start=&quot;1&quot;&gt;&lt;li&gt;function Construct(){&lt;/li&gt;
&lt;li&gt;    // 确保只有单例&lt;/li&gt;
&lt;li&gt;    if( Construct.unique !== undefined ){&lt;/li&gt;
&lt;li&gt;        return Construct.unique; &lt;/li&gt;
&lt;li&gt;    }&lt;/li&gt;
&lt;li&gt;    // 其他代码&lt;/li&gt;
&lt;li&gt;    this.name = &quot;NYF&quot;;&lt;/li&gt;
&lt;li&gt;    this.age=&quot;24&quot;;&lt;/li&gt;
&lt;li&gt;    Construct.unique = this;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;var t1 = new Construct() ;&lt;/li&gt;
&lt;li&gt;var t2 = new Construct() ;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    那么也有的， t1 === t2 。&lt;/p&gt;
&lt;p&gt;    也是非常简单，无非就是提出一个属性来做判断，但是该方式也没有安全性，一旦我在外部修改了Construct的unique属性，那么单例模式也就被破坏了。&lt;/p&gt;

&lt;h2&gt;    实现3 : 闭包方式    &lt;/h2&gt;
&lt;p&gt;    对于大着 灵活 牌子的JS来说，任何问题都能找到 n 种答案，只不过让我自己去掂量孰优孰劣而已，下面就简单的举几个使用闭包实现单例模式的方法，无非也就是将创建了的单例缓存而已。&lt;/p&gt;
&lt;div&gt;&lt;br/&gt;&lt;div id=&quot;codeText&quot; class=&quot;codeText&quot; readability=&quot;56.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; single = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; unique;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Construct(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... 生成单例的构造函数的代码&lt;/span&gt;
&lt;span&gt;    }
    unique &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Constuct();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unique;
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    只要 每次讲 var t1 = single; var t2 = single;即可。 与对象字面量方式类似。不过相对而言更安全一点，当然也不是绝对安全。&lt;/p&gt;
&lt;p&gt;    如果希望会用调用 single() 方式来使用，那么也只需要将内部的 return 改为&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unique;
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    以上方式也可以使用 new 的方式来进行（形式主义的赶脚）。当然这边只是给了闭包的一种例子而已，也可以在 Construct 中判断单例是否存在 等等。 各种方式在各个不同情况做好选着即可。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;    总的来说，单例模式相对而言是各大模式中较为简单的，但是单例模式也是较为常用并且很有用的模式。在JS中尤为突出（每个对象字面量都可以看做是一个单例么~）。&lt;/p&gt;
&lt;p&gt;    记住，是否严格的只需要一个实例对象的类（虽然JS没有类的概念），那么就要考虑使用单例模式。&lt;/p&gt;
&lt;p&gt;    使用数据缓存来存储该单例，用作判断单例是否已经生成，是单例模式主要的实现思路。&lt;/p&gt;

&lt;p&gt;demo：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心思路：&lt;/strong&gt;利用Javascript的作用域，形成闭包，从而可以创建私有变量（假设我们将这个私有变量取名为instance），然后将创建的实例赋予这个私有变量instance就ok了。每当想创建这个类的实例时，先判断instance是否已经引用了存在的实例，如果没有引用，即这个类没有被创建实例，so创建一个实例，然后将其赋予给instance；如果instance已经引用，即已存在了该类的实例，so无需再创建，直接使用这个instance就ok了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;执行匿名函数，防止命名空间污染。在匿名函数中，首先定义个上述提到的私有变量instance以及一个类。这个类，我假设它有名字(name)和年龄(age)两个属性字段以及一个输出他们名字的方(displayInfo)哈。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;第二步：&lt;/strong&gt;利用return + 对象字面量，将我们想，向外暴露的东东，往外抛。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，&lt;/strong&gt;合并第一步第二步的代码就形成了一个单例模式啦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来，&lt;/strong&gt;我们检验一下写的这个单例模式。在上述代码中，在类SupposeClass中加入console.log，如果只创建了它的一个实例，那么就只会打印一个日志哦。&lt;/p&gt;
&lt;p&gt;调用两次getInstance方法，看看打印几条记录~&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; singletonAccepter=(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SupposeClass(args){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; args = args||&lt;span&gt;{};
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name= args.name||'Monkey'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age= args.age||24&lt;span&gt;;
        console.log(&lt;/span&gt;'this is created!'&lt;span&gt;)
    }
    SupposeClass.prototype&lt;/span&gt;=&lt;span&gt;{
        constructor:SupposeClass,
        displayInfo:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            console.log(&lt;/span&gt;'name:'+&lt;span&gt;this&lt;/span&gt;.name+' age:'+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age);
        }
    };

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
    name:&lt;/span&gt;'SupposeClass'&lt;span&gt;,
    getInstance:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(args){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(instance===&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            instance&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SupposeClass(args);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }
};

})();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a=&lt;span&gt;singletonAccepter.getInstance();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;singletonAccepter.getInstance();
a.displayInfo();
console.log(a&lt;/span&gt;===b);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201901/1486391-20190121154636724-258415904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Mon, 21 Jan 2019 07:47:00 +0000</pubDate>
<dc:creator>JoeJoan</dc:creator>
<og:description>单例模式 单例模式也称作为单子模式，更多的也叫做单体模式。为软件设计中较为简单但是最为常用的一种设计模式。 下面是维基百科对单例模式的介绍： 在应用单例模式时，生成单例的类必须保证只有一个实例的存在，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Joe-and-Joan/p/10299125.html</dc:identifier>
</item>
<item>
<title>以太坊技术分析 - 链客区块链技术社区</title>
<link>http://www.cnblogs.com/liankexing/p/10299037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liankexing/p/10299037.html</guid>
<description>&lt;p&gt;　　　　我是链客区块链技术问答社区，链客将做到有问必答！！&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;以太坊（&lt;/span&gt;Ethereum）是2013年底由一个叫作 Vitalik Buterin 的90后小伙子提出来的技术。以太坊和比特币相似，是一个开源的，基于区块链技术的分布式计算平台，它强调自己是一个智能合约系统 。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;通常只要有一套密钥系统，也就是加密系统，让交易可跟踪，这种结构就可以称为&lt;/span&gt;“智能合约”。基本上所有的虚拟货币都是这样的结构。所以智能合约也就是一套生成虚拟货币的系统， 它的本质和比特币是一样的，只不过，你可以在这个平台里自己生成任意多个不同的比特币系统而已 。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;为了支持这个系统，&lt;/span&gt;Vitalik和他的团队在2014年的7月至8月间，针对公众销售了他们自己的以太坊系统上的货币——以太币（Ether，简称ETH）。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;以太坊有三大特色：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;1. 以太坊的管理更加严密&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;虽然以太坊的管理不是公司制的，是协会制的，而且是非盈利的。但是，和比特币比起来它的管理更加严密，而且它提供以太币给系统开发者和系统升级者。如果你能帮这个以太坊系统找到&lt;/span&gt;Bug（系统漏洞），它都会奖励以太币给你。这样的话，无疑就使得更多的开发者有更高的积极性去维护以太坊的生态系统。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2. 以太坊通过成立联盟，保证应用的开放和标准化&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;以太坊的第二个特色是成立了企业以太坊联盟（&lt;/span&gt; Enterprise Ethereum Alliance，EEA ）。 这些联盟的成员一起来开发以太坊应用，而且能保证以太坊应用的开放和标准化。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;联盟成员很强大，既有美国康奈尔大学在内的学校，又有像&lt;/span&gt;ConsenSys这样的著名的区块链应用开发者，还有大量的大公司，包括微软、英特尔、三星、丰田、JP摩根、埃森哲等等，这些大企业都是以太坊应用的积极引入者，而且借助以太坊来开放应用，为自己的企业客户提供服务。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;3. 企业可以借助以太坊来发行自己的虚拟货币完成融资&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Mon, 21 Jan 2019 07:36:00 +0000</pubDate>
<dc:creator>链客区块链技术社区</dc:creator>
<og:description>我是链客区块链技术问答社区，链客将做到有问必答！！ 以太坊（Ethereum）是2013年底由一个叫作 Vitalik Buterin 的90后小伙子提出来的技术。以太坊和比特币相似，是一个开源的，基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liankexing/p/10299037.html</dc:identifier>
</item>
<item>
<title>Spire高效稳定的.NET组件 - 山治先生</title>
<link>http://www.cnblogs.com/EminemJK/p/10298684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EminemJK/p/10298684.html</guid>
<description>&lt;p&gt;　　年末将至，又到了一年一度的收集发票时间，平时零零碎碎的花钱都是不在意开发票，现在好了，到处找发票来报销，简直头大，&lt;/p&gt;
&lt;p&gt;                                                                    &lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201901/720686-20190121141241211-1425015713.png&quot; alt=&quot;&quot; width=&quot;243&quot; height=&quot;147&quot;/&gt;&lt;/p&gt;
&lt;p&gt;东拼西凑，终于搞定了全部发票，大伙多余的发票，麻烦艾特我一下啊，不限日期，能开发票的都可以，谢谢啦。&lt;strong&gt;&lt;span&gt;文章后有彩蛋~&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201901/720686-20190121141557986-825293871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这么多的发票，一张一张打印，要浪费我多少时间，就想着&lt;span&gt;&lt;strong&gt;合并这些PDF文件（发票）一起打印，节省时间。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还寻思这网上找一个软件来使使，都很（méi）委（līang）婉（xīn）的想收费，在线转PDF的还给我打水印，恰巧今天公司网速不行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来吧，自己搞！程序猿没有什么不可能！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Spire.PDF&lt;/h2&gt;
&lt;p&gt;　　NPOI、DocX、Epplus……这些开源且免费的优秀组件，大家应该是耳熟能详的，而Spire是一款企业级的收费组件，Spire.PDF for .NET&lt;/p&gt;
&lt;p&gt;是一个专业的PDF组件，用于在.NET应用程序中创建，编写，编辑，处理和阅读PDF文件，功能十分丰富…………&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;提取关键词：&lt;/span&gt;收费、稳定、高效 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体我不再过多的啰嗦了，详细我推荐看这篇&lt;span&gt;《 &lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pengze0902/p/6125570.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;高效而稳定的企业级.NET Office 组件Spire（.NET组件介绍之二）&lt;/span&gt;&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;合并PDF&lt;/h3&gt;
&lt;p&gt;　　回到今天的问题，合并发票，合并PDF，然后一次性打印。其实吧，主要代码就两行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; doc =&lt;span&gt; PdfDocument.MergeFiles(allFiles.ToArray());
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  doc.Save(DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyyMMddHHmmss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, FileFormat.PDF);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，你们输出之后会发现，很（méi）漂（līang）亮（xīn）的水印：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201901/720686-20190121143256394-1747867529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“Evaluation Warning：The document was created with Spire.PDF for .NET”&lt;/p&gt;
&lt;p&gt;简直玷污我心爱的发票！！！！&lt;/p&gt;
&lt;h3&gt;解决&lt;/h3&gt;
&lt;p&gt;　　既然隐藏不了，那合并的第一页加入一个空页不就行了？！生成PDF后，然后从第二页开始打印或是删去第一页不就行了？！就这么干！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; first = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PdfDocument();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             first.AppendPage();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入一个空页&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; idx = &lt;span&gt;0&lt;/span&gt;; idx &amp;lt; allFiles.Count; idx++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; next = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PdfDocument(allFiles[idx]);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;                first.AppendPage(next); 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;             first.SaveToFile(DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyyMMddHHmmss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, FileFormat.PDF);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201901/720686-20190121143857989-863474824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201901/720686-20190121145014750-1668259481.png&quot; alt=&quot;&quot; width=&quot;699&quot; height=&quot;549&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201901/720686-20190121150034709-232978511.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;728&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                           &lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201901/720686-20190121145153524-640226180.png&quot; alt=&quot;&quot; width=&quot;180&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201901/720686-20190121145053918-310989418.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要的下载去用吧。👉 &lt;a href=&quot;https://files-cdn.cnblogs.com/files/EminemJK/PDFMerge.zip&quot; target=&quot;_blank&quot;&gt;PDFMerge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工具很简单，就不放到Git上去了，源码：&lt;/p&gt;
&lt;p&gt;界面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('124aa7a7-dbc5-44cc-b2eb-bba92186c38c')&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_124aa7a7-dbc5-44cc-b2eb-bba92186c38c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_124aa7a7-dbc5-44cc-b2eb-bba92186c38c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('124aa7a7-dbc5-44cc-b2eb-bba92186c38c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_124aa7a7-dbc5-44cc-b2eb-bba92186c38c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 合并PDF
{
    &lt;/span&gt;&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; mainForm
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 必需的设计器变量。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; System.ComponentModel.IContainer components = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 清理所有正在使用的资源。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;disposing&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;如果应释放托管资源，为 true；否则为 false。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; disposing)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (disposing &amp;amp;&amp;amp; (components != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;))
            {
                components.Dispose();
            }
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.Dispose(disposing);
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Windows 窗体设计器生成的代码

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设计器支持所需的方法 - 不要修改
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用代码编辑器修改此方法的内容。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitializeComponent()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.components = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.ComponentModel.Container();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnAdd = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.Button();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnMerge = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.Button();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bgw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.ComponentModel.BackgroundWorker();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ListView();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ColumnHeader()));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.statusStrip1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.StatusStrip();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.progressBar = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ToolStripProgressBar();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tipStatu = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ToolStripStatusLabel();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.contextMenuStrip1 = &lt;span&gt;new&lt;/span&gt; System.Windows.Forms.ContextMenuStrip(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.components);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnRemove = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ToolStripMenuItem();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.statusStrip1.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contextMenuStrip1.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; btnAdd
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.btnAdd.Location = &lt;span&gt;new&lt;/span&gt; System.Drawing.Point(&lt;span&gt;409&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnAdd.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btnAdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnAdd.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;67&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnAdd.TabIndex = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnAdd.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnAdd.UseVisualStyleBackColor = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnAdd.Click += &lt;span&gt;new&lt;/span&gt; System.EventHandler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btnSearch_Click);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; btnMerge
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.btnMerge.Font = &lt;span&gt;new&lt;/span&gt; System.Drawing.Font(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((&lt;span&gt;byte&lt;/span&gt;)(&lt;span&gt;134&lt;/span&gt;&lt;span&gt;)));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnMerge.Location = &lt;span&gt;new&lt;/span&gt; System.Drawing.Point(&lt;span&gt;409&lt;/span&gt;, &lt;span&gt;43&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnMerge.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btnMerge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnMerge.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;67&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnMerge.TabIndex = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnMerge.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始合并&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnMerge.UseVisualStyleBackColor = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnMerge.Click += &lt;span&gt;new&lt;/span&gt; System.EventHandler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btnMerge_Click);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bgw
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.bgw.WorkerReportsProgress = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bgw.DoWork += &lt;span&gt;new&lt;/span&gt; System.ComponentModel.DoWorkEventHandler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bgw_DoWork);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bgw.ProgressChanged += &lt;span&gt;new&lt;/span&gt; System.ComponentModel.ProgressChangedEventHandler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bgw_ProgressChanged);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bgw.RunWorkerCompleted += &lt;span&gt;new&lt;/span&gt; System.ComponentModel.RunWorkerCompletedEventHandler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bgw_RunWorkerCompleted);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; listView1
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.listView1.Columns.AddRange(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ColumnHeader[] {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.columnHeader1});
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.ContextMenuStrip = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contextMenuStrip1;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.FullRowSelect = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.GridLines = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.Location = &lt;span&gt;new&lt;/span&gt; System.Drawing.Point(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.MultiSelect = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;listView1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;391&lt;/span&gt;, &lt;span&gt;190&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.TabIndex = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.UseCompatibleStateImageBehavior = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.View =&lt;span&gt; System.Windows.Forms.View.Details;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; columnHeader1
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.columnHeader1.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.columnHeader1.Width = &lt;span&gt;350&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; statusStrip1
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.statusStrip1.Items.AddRange(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ToolStripItem[] {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.progressBar,
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tipStatu});
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.statusStrip1.Location = &lt;span&gt;new&lt;/span&gt; System.Drawing.Point(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;205&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.statusStrip1.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;statusStrip1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.statusStrip1.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;488&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.statusStrip1.TabIndex = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.statusStrip1.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;statusStrip1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; progressBar
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.progressBar.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;progressBar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.progressBar.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tipStatu
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.tipStatu.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tipStatu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tipStatu.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;27&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tipStatu.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0/0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; contextMenuStrip1
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.contextMenuStrip1.Items.AddRange(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ToolStripItem[] {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btnRemove});
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.contextMenuStrip1.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contextMenuStrip1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.contextMenuStrip1.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;101&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; btnRemove
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.btnRemove.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btnRemove&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnRemove.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;180&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnRemove.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;移除&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnRemove.Click += &lt;span&gt;new&lt;/span&gt; System.EventHandler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btnRemove_Click);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; mainForm
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;this&lt;/span&gt;.AutoScaleDimensions = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Drawing.SizeF(6F, 12F);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.AutoScaleMode =&lt;span&gt; System.Windows.Forms.AutoScaleMode.Font;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ClientSize = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;488&lt;/span&gt;, &lt;span&gt;227&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.statusStrip1);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.listView1);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btnMerge);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btnAdd);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.FormBorderStyle =&lt;span&gt; System.Windows.Forms.FormBorderStyle.FixedDialog;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.MaximizeBox = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.MaximumSize = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;504&lt;/span&gt;, &lt;span&gt;266&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.MinimumSize = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;504&lt;/span&gt;, &lt;span&gt;266&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mainForm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.StartPosition =&lt;span&gt; System.Windows.Forms.FormStartPosition.CenterScreen;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PDF Merge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.statusStrip1.ResumeLayout(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.statusStrip1.PerformLayout();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.contextMenuStrip1.ResumeLayout(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ResumeLayout(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PerformLayout();

        }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.Button btnAdd;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.Button btnMerge;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.ComponentModel.BackgroundWorker bgw;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ListView listView1;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ColumnHeader columnHeader1;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.StatusStrip statusStrip1;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ToolStripProgressBar progressBar;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ToolStripStatusLabel tipStatu;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ContextMenuStrip contextMenuStrip1;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; System.Windows.Forms.ToolStripMenuItem btnRemove;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;后台：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7df9c42d-3302-47e9-8aa4-931305d09b2e')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_7df9c42d-3302-47e9-8aa4-931305d09b2e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7df9c42d-3302-47e9-8aa4-931305d09b2e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7df9c42d-3302-47e9-8aa4-931305d09b2e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7df9c42d-3302-47e9-8aa4-931305d09b2e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Pdf;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 合并PDF
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; mainForm : Form
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; mainForm()
        {
            InitializeComponent();
        }

        List&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; allFiles = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnSearch_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            OpenFileDialog openFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OpenFileDialog();
            openFile.Filter &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PDF文件|*.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            openFile.Multiselect &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (openFile.ShowDialog() ==&lt;span&gt; DialogResult.OK)
            {
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fi &lt;span&gt;in&lt;/span&gt;&lt;span&gt; openFile.FileNames)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (allFiles.Contains(fi))
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.Items.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListViewItem(fi));
                    allFiles.Add(fi);
                }
                progressBar.Minimum &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                progressBar.Maximum &lt;/span&gt;=&lt;span&gt; allFiles.Count;
            }
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnMerge_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;bgw.IsBusy)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (allFiles.Count&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                {
                    MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请至少选择 2 个PDF文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                CtrlStatu(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                bgw.RunWorkerAsync();
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CtrlStatu(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; b)
        {
            listView1.Enabled &lt;/span&gt;=&lt;span&gt; b;
            btnMerge.Enabled &lt;/span&gt;=&lt;span&gt; b;
            btnAdd.Enabled &lt;/span&gt;=&lt;span&gt; b;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bgw_DoWork(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, DoWorkEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; first = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PdfDocument();
            first.AppendPage();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入一个空页&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; idx = &lt;span&gt;0&lt;/span&gt;; idx &amp;lt; allFiles.Count; idx++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; next = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PdfDocument(allFiles[idx]);
                first.AppendPage(next);
                ReportInfo(idx &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, allFiles.Count);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            }
            first.SaveToFile(DateTime.Now.ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyyMMddHHmmss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.PDF);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 输出消息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ReportInfo(&lt;span&gt;int&lt;/span&gt; idx,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            bgw.ReportProgress(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, idx + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; count);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bgw_ProgressChanged(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ProgressChangedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userState =&lt;span&gt; e.UserState.ToString();
            tipStatu.Text &lt;/span&gt;=&lt;span&gt; userState;
            progressBar.Value &lt;/span&gt;= Convert.ToInt32(userState.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bgw_RunWorkerCompleted(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RunWorkerCompletedEventArgs e)
        {
            tipStatu.Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;合并完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            CtrlStatu(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnRemove_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.listView1.SelectedItems.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; idx = &lt;span&gt;this&lt;/span&gt;.listView1.SelectedItems[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Index;
                allFiles.Remove(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listView1.SelectedItems[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Text);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.listView1.Items[idx].Remove();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 21 Jan 2019 07:09:00 +0000</pubDate>
<dc:creator>山治先生</dc:creator>
<og:description>年末将至，又到了一年一度的收集发票时间，平时零零碎碎的花钱都是不在意开发票，现在好了，到处找发票来报销，简直头大， 东拼西凑，终于搞定了全部发票，大伙多余的发票，麻烦艾特我一下啊，不限日期，能开发票的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EminemJK/p/10298684.html</dc:identifier>
</item>
<item>
<title>日志服务Python消费组实战（三）：实时跨域监测多日志库数据 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10298718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10298718.html</guid>
<description>&lt;h2 id=&quot;1&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont684108.i0.5ff64d123PYKr8&quot;&gt;解决问题&lt;/h2&gt;
&lt;p&gt;使用日志服务进行数据处理与传递的过程中，你是否遇到如下监测场景不能很好的解决：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;特定数据上传到日志服务中需要检查数据内的异常情况，而没有现成监控工具？&lt;/li&gt;
&lt;li&gt;需要检索数据里面的关键字，但数据没有建立索引，无法使用日志服务的告警功能？&lt;/li&gt;
&lt;li&gt;数据监测要求实时性（&amp;lt;5秒，例如Web访问500错误），而特定功能都有一定延迟（1分钟以上）？&lt;/li&gt;
&lt;li&gt;存在多个域的多个日志库（例如每个Region的错误文件对应的日志库），数据量不大，但监控逻辑类似，每个目标都要监控与配置，比较繁琐？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果是的，您可以考虑使用日志服务Python消费组进行跨域实时数据监控，本文主要介绍如何使用消费组实时监控多个域中的多个日志库中的异常数据，并进行下一步告警动作。可以很好解决以上问题，并利用消费组的特点，达到自动平衡、负载均衡和高可用性。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/1e990fc183d60441f1fb2ef975439ef0dc3fed7d.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;协同消费库（Consumer Library）是对日志服务中日志进行消费的高级模式，提供了消费组（ConsumerGroup）的概念对消费端进行抽象和管理，和直接使用SDK进行数据读取的区别在于，用户无需关心日志服务的实现细节，只需要专注于业务逻辑，另外，消费者之间的负载均衡、failover等用户也都无需关心。&lt;/p&gt;
&lt;p&gt;消费组（Consumer Group） - 一个消费组由多个消费者构成，同一个消费组下面的消费者共同消费一个logstore中的数据，消费者之间不会重复消费数据。&lt;br/&gt;消费者（Consumer） - 消费组的构成单元，实际承担消费任务，同一个消费组下面的消费者名称必须不同。&lt;/p&gt;
&lt;p&gt;在日志服务中，一个logstore下面会有多个shard，协同消费库的功能就是将shard分配给一个消费组下面的消费者，分配方式遵循以下原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个shard只会分配到一个消费者。&lt;/li&gt;
&lt;li&gt;一个消费者可以同时拥有多个shard。&lt;br/&gt;新的消费者加入一个消费组，这个消费组下面的shard从属关系会调整，以达到消费负载均衡的目的，但是上面的分配原则不会变，分配过程对用户透明。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;协同消费库的另一个功能是保存checkpoint，方便程序故障恢复时能接着从断点继续消费，从而保证数据不会被重复消费。&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;使用消费组进行实时分发&lt;/h2&gt;
&lt;p&gt;这里我们描述用Python使用消费组进行编程，实时跨域监测多个域的多个日志库，全文或特定字段检查&lt;br/&gt;注意：本篇文章的相关代码可能会更新，最新版本在这里可以找到：Github样例.&lt;/p&gt;
&lt;h3 id=&quot;4&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;环境&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建议程序运行在靠近源日志库同Region下的ECS上，并使用局域网服务入口，这样好处是网络速度最快，其次是读取没有外网费用产生。&lt;/li&gt;
&lt;li&gt;强烈推荐PyPy3来运行本程序，而不是使用标准CPython解释器。&lt;/li&gt;
&lt;li&gt;日志服务的Python SDK可以如下安装：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;shell hljs sql&quot;&gt;pypy3 -m pip &lt;span class=&quot;hljs-keyword&quot;&gt;install aliyun-&lt;span class=&quot;hljs-keyword&quot;&gt;log-python-sdk -U&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多SLS Python SDK的使用手册，可以参考这里&lt;/p&gt;
&lt;h3 id=&quot;5&quot;&gt;程序配置&lt;/h3&gt;
&lt;p&gt;如下展示如何配置程序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置程序日志文件，以便后续测试或者诊断可能的问题（跳过，具体参考样例）。&lt;/li&gt;
&lt;li&gt;基本的日志服务连接与消费组的配置选项。&lt;/li&gt;
&lt;li&gt;目标Logstore的一些连接信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;请仔细阅读代码中相关注释并根据需要调整选项：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;注意，配置了多个endpoint、project、logstore，需要用分号分隔，并且一一对应；如果一个project下有多个logstore需要检测，可以将他们直接用逗号分隔。如下是一个检测3个Region下的4个Logstore的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;json hljs&quot;&gt;export SLS_ENDPOINTS=cn-hangzhou.log.aliyuncs.com;cn-beijing.log.aliyuncs.com;cn-qingdao.log.aliyuncs.com
export SLS_PROJECTS=project&lt;span class=&quot;hljs-number&quot;&gt;1;project&lt;span class=&quot;hljs-number&quot;&gt;2;project&lt;span class=&quot;hljs-number&quot;&gt;3
export SLS_LOGSTORES=logstore&lt;span class=&quot;hljs-number&quot;&gt;1;logstore&lt;span class=&quot;hljs-number&quot;&gt;2;logstore&lt;span class=&quot;hljs-number&quot;&gt;3_&lt;span class=&quot;hljs-number&quot;&gt;1,logstore&lt;span class=&quot;hljs-number&quot;&gt;3_&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6&quot;&gt;数据监测&lt;/h3&gt;
&lt;p&gt;如下代码展示如何构建一个关键字检测器，针对数据中的目标字段进行检测，您也可以修改逻辑设定为符合需要的场景（例如多个字段的组合关系等）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;KeywordMonitor&lt;span class=&quot;hljs-params&quot;&gt;(ConsumerProcessorBase):
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;
    this consumer will keep monitor with k-v fields. like {&quot;content&quot;: &quot;error&quot;}
    &quot;&quot;&quot;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;span class=&quot;hljs-params&quot;&gt;(self, keywords=None, logstore=None):
        super(KeywordMonitor, self).__init__()  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7&quot;&gt;控制逻辑&lt;/h3&gt;
&lt;p&gt;如下展示如何控制多个消费者，并管理退出命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;():
    exeuctor, options, keywords = get_monitor_option()

    logger.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;*** start to consume data...&quot;)
    workers = []

    &lt;span class=&quot;hljs-keyword&quot;&gt;for option &lt;span class=&quot;hljs-keyword&quot;&gt;in options:
        worker = ConsumerWorker(KeywordMonitor, option, args=(keywords,) )
        workers.append(worker)
        worker.start()

    &lt;span class=&quot;hljs-keyword&quot;&gt;try:
        &lt;span class=&quot;hljs-keyword&quot;&gt;for i, worker &lt;span class=&quot;hljs-keyword&quot;&gt;in enumerate(workers):
            &lt;span class=&quot;hljs-keyword&quot;&gt;while worker.is_alive():
                worker.join(timeout=&lt;span class=&quot;hljs-number&quot;&gt;60)
            logger.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;worker project: {0} logstore: {1} exit unexpected, try to shutdown it&quot;.format(
                options[i].project, options[i].logstore))
            worker.shutdown()
    &lt;span class=&quot;hljs-keyword&quot;&gt;except KeyboardInterrupt:
        logger.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;*** try to exit **** &quot;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;for worker &lt;span class=&quot;hljs-keyword&quot;&gt;in workers:
            worker.shutdown()

        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;8&quot;&gt;启动&lt;/h3&gt;
&lt;p&gt;假设程序命名为&quot;monitor_keyword.py&quot;，可以如下启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;export SLS_ENDPOINTS=cn-hangzhou.&lt;span class=&quot;hljs-built_in&quot;&gt;log.aliyuncs.com;cn-beijing.&lt;span class=&quot;hljs-built_in&quot;&gt;log.aliyuncs.com;cn-qingdao.&lt;span class=&quot;hljs-built_in&quot;&gt;log.aliyuncs.com
&lt;span class=&quot;hljs-keyword&quot;&gt;export SLS_PROJECTS=project1;project2;project3
&lt;span class=&quot;hljs-keyword&quot;&gt;export SLS_LOGSTORES=logstore1;logstore2;logstore3_1,logstore3_2

&lt;span class=&quot;hljs-keyword&quot;&gt;export SLS_AK_ID=&amp;lt;YOUR AK ID&amp;gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;export SLS_AK_KEY=&amp;lt;YOUR AK KEY&amp;gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;export SLS_CG=&amp;lt;消费组名，可以简单命名为&lt;span class=&quot;hljs-string&quot;&gt;&quot;dispatch_data&quot;&amp;gt;

pypy3 monitor_keyword.py&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;9&quot;&gt;性能考虑&lt;/h2&gt;
&lt;h3 id=&quot;10&quot;&gt;启动多个消费者&lt;/h3&gt;
&lt;p&gt;如果您的目标logstore存在多个shard，或者您的目标监测日志库较多，您可以进行一定划分并并启动多次程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell hljs nginx&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;注意:&lt;br/&gt;所有消费者使用了同一个消费组的名字和不同的消费者名字（因为消费者名以进程ID为后缀）。&lt;br/&gt;但数据量较大或者目标日志库较多时，单个消费者的速度可能无法满足需求，且因为Python的GIL的原因，只能用到一个CPU核。强烈建议您根据目标日志库的Shard数以及CPU的数量进行划分，启动多次以便重复利用CPU资源。&lt;/p&gt;
&lt;h3 id=&quot;11&quot;&gt;性能吞吐&lt;/h3&gt;
&lt;p&gt;基于测试，在没有带宽限制、接收端速率限制（如Splunk端）的情况下，以推进硬件用&lt;code&gt;pypy3&lt;/code&gt;运行上述样例，单个消费者占用大约&lt;code&gt;10%的单核CPU&lt;/code&gt;下可以消费达到&lt;code&gt;5 MB/s&lt;/code&gt;原始日志的速率。因此，理论上可以达到&lt;code&gt;50 MB/s&lt;/code&gt;原始日志&lt;code&gt;每个CPU核&lt;/code&gt;，也就是&lt;code&gt;每个CPU核每天可以消费4TB原始日志&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意: 这个数据依赖带宽、硬件参数等。&lt;/p&gt;
&lt;h3 id=&quot;12&quot;&gt;高可用性&lt;/h3&gt;
&lt;p&gt;消费组会将检测点（check-point）保存在服务器端，当一个消费者停止，另外一个消费者将自动接管并从断点继续消费。&lt;/p&gt;
&lt;p&gt;可以在不同机器上启动消费者，这样当一台机器停止或者损坏的清下，其他机器上的消费者可以自动接管并从断点进行消费。&lt;/p&gt;
&lt;p&gt;理论上，为了备用，也可以启动大于shard数量的消费者。&lt;/p&gt;
&lt;h2 id=&quot;13&quot;&gt;其他&lt;/h2&gt;
&lt;h3 id=&quot;14&quot;&gt;限制与约束&lt;/h3&gt;
&lt;p&gt;每一个日志库（logstore）最多可以配置10个消费组，如果遇到错误&lt;code&gt;ConsumerGroupQuotaExceed&lt;/code&gt;则表示遇到限制，建议在控制台端删除一些不用的消费组。&lt;/p&gt;
&lt;h3 id=&quot;15&quot;&gt;监测&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在控制台查看消费组状态&lt;/li&gt;
&lt;li&gt;通过云监控查看消费组延迟，并配置报警&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;16&quot;&gt;Https&lt;/h3&gt;
&lt;p&gt;如果服务入口（endpoint）配置为&lt;code&gt;https://&lt;/code&gt;前缀，如&lt;code&gt;https://cn-beijing.log.aliyuncs.com&lt;/code&gt;，程序与SLS的连接将自动使用HTTPS加密。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont684108.i1.5ff64d123PYKr8&quot;&gt;服务器证书&lt;code&gt;*.aliyuncs.com&lt;/code&gt;是GlobalSign签发，默认大多数Linux/Windows的机器会自动信任此证书。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont684108.i1.5ff64d123PYKr8&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/684108?utm_content=g_1000038831&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 06:58:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>解决问题 使用日志服务进行数据处理与传递的过程中，你是否遇到如下监测场景不能很好的解决： 如果是的，您可以考虑使用日志服务Python消费组进行跨域实时数据监控，本文主要介绍如何使用消费组实时监控多个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10298718.html</dc:identifier>
</item>
<item>
<title>互联网轻量级框架SSM-查缺补漏第九天 - 爱打程序的篮球员</title>
<link>http://www.cnblogs.com/shiboinfo/p/10298423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shiboinfo/p/10298423.html</guid>
<description>&lt;p&gt;　　简言：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第九章 Spring Ioc的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　IoC（Inversion of Control）控制反转：比如想喝橙汁，在没有饮品店的日子，最直观的做法是买果汁机、橙汁。这是你自己“主动”创造的过程，也就是一杯橙汁需要主动创造。然而到了今时今日，由于饮品店的盛行，已经没必要自己去榨橙汁了。饮品店提供给你橙汁，这一过程你没有去“主动”创造，但是也完全达到了你的要求。这就是&lt;span&gt;控制反转&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　在Spring中，它会认为一切Java类都是资源，而资源都是Bean，容纳这些Bean的是Spring所提供的IoC容器，所以Spring是一种基于Bean的编程。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Spring ioc 容器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入（Dependency Injection，DI），简单的说，Ioc容器是用来存放一些实例的，通过依赖注入，将实例注入Ioc容器，此时你不需要去主动创建实例，只需要从Ioc容器中取就好了。&lt;/p&gt;
&lt;p&gt;　　Spring IoC容器的设计主要基于&lt;span&gt;BeanFactory&lt;/span&gt;和&lt;span&gt;ApplicationContext&lt;/span&gt;两个接口。ApplicationContext是BeanFactory的子接口之一，换句话说BeanFactory是Spring IoC容器说定义的最底层接口，而ApplicationContext是其高级接口之一。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Spring IoC容器的初始化和依赖注入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　过程：先定义Bean，然后初始化Bean，然后依赖注入Spring IoC容器。&lt;/p&gt;
&lt;p&gt;　　Bean的定义：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Resource定位&lt;/span&gt;，这步是Spring Ioc根据开发者的配置，进行资源定位。在Spring的开发过程中，开发者通过XML或注解进行配置。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;BeanDefinition的载入&lt;/span&gt;，这个时候只是将Resource定位到的信息，保存到Bean定义（BeanDefinition）中，此时部位创建Bean的实例。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;BeanDefinition的注册&lt;/span&gt;，这个过程就是将BeanDefinition的信息发布到Spring Ioc 容器中。&lt;span&gt;注意，此时仍旧没有对应的Bean的实例创建&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　Bean的初始化：&lt;/p&gt;
&lt;p&gt;　　Spring Bean还有一个配置选项——lazy-init，其含义及时是否初始化Spring Bean（意思是时候采用懒汉模式）。默认值为false，默认会自动初始化Bean。如果将其设置为true，那么只有当我们使用Spring IoC容器的getBean方法获取它时，它才会进行Bean的初始化，完成依赖注入。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Spring Bean的生命周期&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一下是Spring Bean的生命周期过程：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1498798/201901/1498798-20190121103252745-1036894847.png&quot; alt=&quot;&quot; width=&quot;1019&quot; height=&quot;720&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;第十一章 面向切面编程（AOP）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果说IoC是Spring的核心，那么面向切面编程就是Spring最为重要的功能之一了，在数据库事务中，切面编程被广泛使用。&lt;/p&gt;
&lt;p&gt;　　AOP：通过动态代理模式，带来管控各个对象操作的切面环境，管理包括日志、数据库事务等操作，让我们拥有可以在反射原有对象方法之前正常返回、异常返回时候插入自己的路基代码的能力，有时候甚至取代原有方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1498798/201901/1498798-20190121111817126-1276246682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　相关概念：&lt;/p&gt;
&lt;p&gt;　　1.切面（Aspect）&lt;/p&gt;
&lt;p&gt;　　切面就是在一个怎么杨的环境中工作。在动态代理中可以把它理解成一个拦截器。&lt;/p&gt;
&lt;p&gt;　　2.通知（Advice）&lt;/p&gt;
&lt;p&gt;　　通知是切面开启后，切面的方法，它根据在代理对象真实方法调用前、后的顺序和逻辑区分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前置通知（Before）：在动态代理反射原有对象或者执行环绕通知前执行的通知功能。&lt;/li&gt;
&lt;li&gt;后置通知（After）：在动态代理反射原有对象方法或者执行环绕通知后执行的通知功能。&lt;span&gt;无论是否抛出一行，它都会被执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;返回通知（AfterReturning）：在动态代理对象反射原有对象方法或者执行环绕通知后，正常返回（无异常）执行的通知功能。&lt;/li&gt;
&lt;li&gt;异常通知（AfterThrowing）：在动态代理对象反射原有对象方法或者执行环绕通知后，产生异常执行的通知功能。&lt;/li&gt;
&lt;li&gt;环绕通知（Around）：在动态代理中，它可以取代当前被拦截对象的方法，提供回调原有被拦截对象的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　3.引入（Introduction）&lt;/p&gt;
&lt;p&gt;　　允许我们在现有的类里添加自定义的类和方法。&lt;/p&gt;
&lt;p&gt;　　4.切点（Pointcut）&lt;/p&gt;
&lt;p&gt;　　告诉SpringAOP在什么时候启动拦截并&lt;span&gt;织入&lt;/span&gt;对应的流程中，因为并不是所有的开发都需要启动AOP的，它往往通过正则表达式进行限定。&lt;/p&gt;
&lt;p&gt;　　5.连接点（join point）&lt;/p&gt;
&lt;p&gt;　　连接点对应的是具体需要拦截的东西，比如通过切点的正则表达式去判断哪些方法是连接点，从而织入对应的通知。&lt;/p&gt;
&lt;p&gt;　　6.织入（Weaving）&lt;/p&gt;
&lt;p&gt;　　织入是一个生成代理对象并将切面内容放入到流程中的流程。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 06:11:00 +0000</pubDate>
<dc:creator>爱打程序的篮球员</dc:creator>
<og:description>简言： 第九章 Spring Ioc的概念 IoC（Inversion of Control）控制反转：比如想喝橙汁，在没有饮品店的日子，最直观的做法是买果汁机、橙汁。这是你自己“</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shiboinfo/p/10298423.html</dc:identifier>
</item>
<item>
<title>JavaScript原生封装ajax请求和Jquery中的ajax请求 - 陌上花早</title>
<link>http://www.cnblogs.com/xwkj/p/10298400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xwkj/p/10298400.html</guid>
<description>&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;前言：ajax的神奇之处在于JavaScript 可在不重载页面的情况与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。Ajax 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），当然也可同步，这样就可使网页从服务器请求少量的信息，而不是整个页面。Ajax使我们的项目更小、更快，更友好，在前端开发有很高的地位，也是面试题的热点。本次测试是在localhost本地环境。&lt;/p&gt;
&lt;h4 id=&quot;原生ajax&quot;&gt;1、原生ajax&lt;/h4&gt;
&lt;h5 id=&quot;html前端代码get请求方式&quot;&gt;（1）html前端代码get请求方式&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;创建一个ajax实例xhr&lt;/li&gt;
&lt;li&gt;open()方法传入三个参数，第一个是请求方式（一般为get和post），第二个参数是请求地址，第三个布尔值，true代表异步，false代表同步&lt;/li&gt;
&lt;li&gt;send发送数据（get用不上，get发送的数据一般在链接后面，所以为显式传值，形式为键值对）&lt;/li&gt;
&lt;li&gt;绑定监听函数判断状态码&lt;/li&gt;
&lt;li&gt;xhr.responseText得到返回数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        var xhr = new XMLHttpRequest()   
        xhr.open(&quot;GET&quot;,&quot;js/text.js&quot;,true)   
        xhr.send()                                      
        xhr.onreadystatechange = function(){      //
            if(xhr.readyState === 4&amp;amp;&amp;amp; xhr.status === 200){   
                var data = xhr.responseText   
                var datas = JSON.parse(data)    
                console.log(datas) 
            }
        }
        &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;控制台输出&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190118180232980.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;html前端代码post请求方式&quot;&gt;（2）html前端代码post请求方式&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;post传递方式需要设置头信息，实测简单的请求不设置也是可以&lt;/li&gt;
&lt;li&gt;这里的传值是放在send()方法里面的，所以为隐式传值，其他的都和get相同&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        var xhr = new XMLHttpRequest()   
        xhr.open(&quot;POST&quot;,&quot;js/text.js&quot;,true)   
        xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); 
        xhr.send()                                    
        xhr.onreadystatechange = function(){     
            if(xhr.readyState === 4&amp;amp;&amp;amp; xhr.status === 200){  
                var data = xhr.responseText    
                var datas = JSON.parse(data)   
                console.log(datas)   
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;控制台输出&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190118180232980.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;被请求js代码&quot;&gt;（3）被请求js代码&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
{
    &quot;name&quot;:&quot;小明&quot;,
    &quot;age&quot;:24,
    &quot;array&quot;:[1,51,3,4,4,6,64]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数封装&quot;&gt;2、函数封装&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;            function Ajax(type, url, data, success){
           
            var xhr = null;   // 初始化xhr
            if(window.XMLHttpRequest){    //兼容IE
                xhr = new XMLHttpRequest();
            } else {
                xhr = new ActiveXObject('Microsoft.XMLHTTP')
            }
         
            var type = type.toUpperCase();
           
            var random = Math.random(); //创建随机数
         
            if(type == 'GET'){
                if(data){
                    xhr.open('GET', url + '?' + data, true);  //如果有数据就拼接
                } else {
                    xhr.open('GET', url + '?t=' + random, true);  //如果没有数据就传入一个随机数
                }
                xhr.send();
         
            } else if(type == 'POST'){
                xhr.open('POST', url, true);
                xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
                xhr.send(data);
            }
         
            
            xhr.onreadystatechange = function(){     // 创建监听函数
                if(xhr.readyState == 4&amp;amp;&amp;amp;xhr.status == 200){
                        success(xhr.responseText);
                    } 
                }
        }
         
        Ajax('get', 'js/text.js', &quot;&quot;, function(data){   //调用函数
            console.log(JSON.parse(data));
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;被请求js代码-1&quot;&gt;（2）被请求js代码&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;
{
    &quot;name&quot;:&quot;小明&quot;,
    &quot;age&quot;:24,
    &quot;array&quot;:[1,51,3,4,4,6,64]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;控制台输出&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190118180232980.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jquery中的ajax先引入jquery&quot;&gt;3、Jquery中的Ajax（先引入Jquery）&lt;/h4&gt;
&lt;h5 id=&quot;前端简单的js代码&quot;&gt;（1）前端简单的JS代码&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;jquery中的ajax是被库封装好了的，我们直接用即可，下面是简单的ajax请求，它也有很多参数，但基础的就这些了&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$.ajax({
            url:&quot;./js/text.js&quot;,   
            type:&quot;GET&quot;,      
            dataType:&quot;json&quot;,  
            success:function(data){  
                console.log(data)
            },
            error:function(res){  
                console.log(&quot;请求失败！&quot;)
            }
        })&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;被请求js代码-2&quot;&gt;（2）被请求js代码&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;
{
    &quot;name&quot;:&quot;小明&quot;,
    &quot;age&quot;:24,
    &quot;array&quot;:[1,51,3,4,4,6,64]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;控制台输出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190118180232980.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以上如有不对之处，请大家多多指正，谢谢！&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 21 Jan 2019 06:07:00 +0000</pubDate>
<dc:creator>陌上花早</dc:creator>
<og:description>前言：ajax的神奇之处在于JavaScript 可在不重载页面的情况与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。Ajax 在浏览器与 Web 服务器之间使用异步</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xwkj/p/10298400.html</dc:identifier>
</item>
<item>
<title>SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言 - 於清樂</title>
<link>http://www.cnblogs.com/kirito-c/p/10269485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kirito-c/p/10269485.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;个人笔记，如有错误烦请指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SQLAlchemy 是一个用 Python 实现的 ORM （Object Relational Mapping）框架，它由多个组件构成，这些组件可以单独使用，也能独立使用。它的组件层次结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/968138/201901/968138-20190120090336742-1073786018.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中最常用的组件，应该是 &lt;strong&gt;ORM&lt;/strong&gt; 和 &lt;strong&gt;SQL 表达式语言&lt;/strong&gt;，这两者既可以独立使用，也能结合使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ORM&lt;/strong&gt; 的好处在于它&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自动处理了数据库和 Python 对象之间的映射关系，屏蔽了两套系统之间的差异。程序员不需要再编写复杂的 SQL 语句，直接操作 Python 对象就行。&lt;/li&gt;
&lt;li&gt;屏蔽了各数据库之间的差异，更换底层数据库不需要修改 SQL 语句，改下配置就行。&lt;/li&gt;
&lt;li&gt;使数据库结构文档化，models 定义很清晰地描述了数据库的结构。&lt;/li&gt;
&lt;li&gt;避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为 Bug，也方便维护。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是 ORM 需要消耗额外的性能来处理对象关系映射，此外用 ORM 做多表关联查询或复杂 SQL 查询时，效率低下。因此它适用于场景不太复杂，性能要求不太苛刻的场景。&lt;/p&gt;
&lt;p&gt;都说 ORM 学习成本高，我自己也更倾向于直接使用 SQL 语句（毕竟更熟悉），因此这一篇笔记不涉及 ORM 部分，只记录 SQLAlchemy 的 Engine 与 SQL 表达式语言。&lt;/p&gt;
&lt;h3 id=&quot;一直接使用-engine-和-connections&quot;&gt;一、直接使用 &lt;a href=&quot;https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine&quot;&gt;Engine&lt;/a&gt; 和 Connections&lt;/h3&gt;
&lt;p&gt;第一步是创建数据库引擎实例：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sqlalchemy import create_engine

engine = create_engine('sqlite:///:memory:', 
                    echo=True,  # echo=True 表示打印出自动生成的 SQL 语句（通过 logging）
                    pool_size=5,  # 连接池容量，默认为 5，生产环境下太小，需要修改。
                    # 下面是 connection 回收的时间限制，默认 -1 不回收
                    pool_recyle=7200)   # 超过 2 小时就重新连接（MySQL 默认的连接最大闲置时间为 8 小时）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;create_engine&lt;/code&gt; 接受的第一个参数是数据库 URI，格式为 &lt;code&gt;dialect[+driver]://user:password@host/dbname[?key=value..]&lt;/code&gt;，dialect 是具体的数据库名称，driver 是驱动名称。key-value 是可选的参数。举例：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# PostgreSQL
postgresql+psycopg2://scott:tiger@localhost/dbtest

# MySQL + PyMySQL（或者用更快的  mysqlclient）
mysql+pymysql://scott:tiger@localhost/dbtest

# sqlite 内存数据库
# 注意 sqlite 要用三个斜杠，表示不存在 hostname，sqlite://&amp;lt;nohostname&amp;gt;/&amp;lt;path&amp;gt;
sqlite:///:memory:

# sqlite 文件数据库
# 四个斜杠是因为文件的绝对路径以 / 开头：/home/ryan/Codes/Python/dbtest.db
sqlite:////home/ryan/Codes/Python/dbtest.db

# SQL Server + pyodbc
# 首选基于 dsn 的连接，dsn 的配置请搜索hhh
mssql+pyodbc://scott:tiger@some_dsn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引擎创建后，我们就可以直接获取 connection，然后执行 SQL 语句了。这种用法相当于把 SQLAlchemy 当成带 log 的数据库连接池使用：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;with engine.connect() as conn:
    res = conn.execute(&quot;select username from users&quot;)  # 无参直接使用

    # 使用问号作占位符，前提是下层的 DBAPI 支持。更好的方式是使用 text()，这个后面说
    conn.execute(&quot;INSERT INTO table (id, value) VALUES (?, ?)&quot;, 1, &quot;v1&quot;)  # 参数不需要包装成元组

    # 查询返回的是 ResultProxy 对象，有和 dbapi 相同的 fetchone()、fetchall()、first() 等方法，还有一些拓展方法
    for row in result:
        print(&quot;username:&quot;, row['username'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是要注意的是，connection 的 execute 是自动提交的（autocommit），这就像在 shell 里打开一个数据库客户端一样，分号结尾的 SQL 会被自动提交。&lt;br/&gt;只有在 &lt;code&gt;BEGIN TRANSACTION&lt;/code&gt; 内部，&lt;code&gt;AUTOCOMMIT&lt;/code&gt; 会被临时设置为 &lt;code&gt;FALSE&lt;/code&gt;，可以通过如下方法开始一个内部事务：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def transaction_a(connection):
    trans = connection.begin()  # 开启一个 transaction
    try:
        # do sthings
        trans.commit()  # 这里需要手动提交
    except:
        trans.rollback()  # 出现异常则 rollback
        raise
# do other things

with engine.connect() as conn:
    transaction_a(conn)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用-text-构建-sql&quot;&gt;1. 使用 &lt;a href=&quot;https://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.text&quot;&gt;text()&lt;/a&gt; 构建 SQL&lt;/h4&gt;
&lt;p&gt;相比直接使用 string，text() 的优势在于它：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供了统一的参数绑定语法，与具体的 DBAPI 无关。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 1. 参数绑定语法
from sqlalchemy import text

result = connection.execute(
            # 使用 :key 做占位符
            text('select * from table where id &amp;lt; :id and typeName=:type'),
            {'id': 2,'type':'USER_TABLE'})  # 用 dict 传参数，更易读

# 2. 参数类型指定
from sqlalchemy import DateTime

date_param=datetime.today()+timedelta(days=-1*10)
sql=&quot;delete from caw_job_alarm_log  where alarm_time&amp;lt;:alarm_time_param&quot;

# bindparams 是 bindparam 的列表，bindparam 则提供参数的一些额外信息（类型、值、限制等）
t=text(sql, bindparams=[bindparam('alarm_time_param', type_=DateTime, required=True)])
connection.execute(t, {&quot;alarm_time_param&quot;: date_param})&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;可以很方便地转换 Result 中列的类型&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;stmt = text(&quot;SELECT * FROM table&quot;,
            # 使用 typemap 指定将 id 列映射为 Integer 类型，name 映射为 String 类型
            typemap={'id': Integer, 'name': String},
          )&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二sql-表达式语言&quot;&gt;二、SQL 表达式语言&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;复杂的 SQL 查询可以直接用 raw sql 写，而增删改一般都是单表操作，用 SQL 表达式语言最方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SQLAlchemy 表达式语言是一个使用 Python 结构表示关系数据库结构和表达式的系统。&lt;/p&gt;
&lt;h4 id=&quot;定义并创建表&quot;&gt;1. 定义并创建表&lt;/h4&gt;
&lt;p&gt;SQL 表达式语言使用 Table 来定义表，而表的列则用 Column 定义。Column 总是关联到一个 Table 对象上。&lt;/p&gt;
&lt;p&gt;一组 Table 对象以及它们的子对象的集合就被称作「数据库元数据（database metadata）」。metadata 就像你的网页分类收藏夹，相关的 Table 放在一个 metadata 中。&lt;/p&gt;
&lt;p&gt;下面是创建元数据（一组相关联的表）的例子，：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sqlalchemy import Table, Column, Integer, String, MetaData, ForeignKey

metadata = MetaData()  # 先创建元数据（收藏夹）

users = Table('user', metadata,  # 创建 user 表，并放到 metadata 中
              Column('id', Integer, primary_key=True),
              Column('name', String),
              Column('fullname', String)
             )

addresses = Table('address', metadata,
                  Column('id', Integer, primary_key=True),
                  Column('user_id', None, ForeignKey('user.id')),  # 外键，引用 user 表的 id 列
                  Column('email_address', String, nullable=False)
                 )

metadata.create_all(engine)  # 使用 engine 创建 metadata 内的所有 Tables（会检测表是否已经存在，所以可以重复调用）&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;增删改语句&quot;&gt;2. 增删改语句&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;增&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 方法一，使用 values 传参
ins = users.insert().values(name=&quot;Jack&quot;, fullname=&quot;Jack Jones&quot;)  # 可以通过 str(ins) 查看自动生成的 sql
connection.execute(ins)

# 方法二，参数传递给 execute()
conn.execute(users.insert(), id=2, name='wendy', fullname='Wendy Williams')

# 方法三，批量 INSERT，相当于 executemany
conn.execute(addresses.insert(), [  # 插入到 addresses 表
    {'user_id': 1, 'email_address': 'jack@yahoo.com'},  # 传入 dict 列表
    {'user_id': 1, 'email_address': 'jack@msn.com'},
    {'user_id': 2, 'email_address': 'www@www.org'},
    {'user_id': 2, 'email_address': 'wendy@aol.com'}
])

# 此外，通过使用 bindparam，INSERT 还可以执行更复杂的操作
stmt = users.insert() \
         .values(name=bindparam('_name') + &quot; .. name&quot;)  # string 拼接
conn.execute(stmt, [
        {'id':4, '_name':'name1'},
        {'id':5, '_name':'name2'},
        {'id':6, '_name':'name3'},
     ])&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;删&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;_table.delete() \
        .where(_table.c.f1==value1) \
        .where(_table.c.f2==value2)  # where 指定条件&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;改&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 举例
stmt = users.update() \
             .where(users.c.name == 'jack') \
             .values(name='tom')
conn.execute(stmt)

# 批量更新
stmt = users.update().\
             where(users.c.name == bindparam('oldname')).\
             values(name=bindparam('newname'))
conn.execute(stmt, [
     {'oldname':'jack', 'newname':'ed'},
     {'oldname':'wendy', 'newname':'mary'},
     {'oldname':'jim', 'newname':'jake'},
     ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，所有的条件都是通过 &lt;code&gt;where&lt;/code&gt; 指定的，它和后面 ORM 的 filter 接受的参数是一样的。（详细的会在第二篇文章里讲）&lt;/p&gt;
&lt;p&gt;查询暂时略过（因为感觉手写 sql 更方便。。）&lt;/p&gt;
&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
</description>
<pubDate>Mon, 21 Jan 2019 06:02:00 +0000</pubDate>
<dc:creator>於清樂</dc:creator>
<og:description>个人笔记，如有错误烦请指正。 SQLAlchemy 是一个用 Python 实现的 ORM （Object Relational Mapping）框架，它由多个组件构成，这些组件可以单独使用，也能独立</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kirito-c/p/10269485.html</dc:identifier>
</item>
<item>
<title>Docker安装+HelloWorld+运行Tomcat - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10298320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10298320.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只有光头才能变强。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.9545454545455&quot;&gt;
&lt;p&gt;文本已收录至我的GitHub仓库，欢迎Star：&lt;a href=&quot;https://github.com/ZhongFuCheng3y/3y&quot; class=&quot;uri&quot;&gt;https://github.com/ZhongFuCheng3y/3y&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇已经讲解了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484584&amp;amp;idx=1&amp;amp;sn=9af3a77887595e53206ff4120b350d8d&amp;amp;chksm=ebd745a9dca0ccbf20e3c1979b232a2004c8156192ae20858599506d683120a95a2366f4e4be&amp;amp;token=1712662964&amp;amp;lang=zh_CN#rd&quot;&gt;为什么需要Docker？&lt;/a&gt;，相信大家已经对Docker有一个简单的认识了。&lt;/p&gt;
&lt;p&gt;这篇我来讲讲Docker入门的相关概念和常用的命令，跟大家一起入门Docker！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/13/16845ec0be468871?w=520&amp;amp;h=472&amp;amp;f=png&amp;amp;s=53079&quot; alt=&quot;Docker&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一般从零学习一门技术(语言)，都是从HelloWorld开始的，但这次我&lt;strong&gt;偏不&lt;/strong&gt;。我先来讲讲Docker的相关术语~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;镜像&lt;/li&gt;
&lt;li&gt;容器&lt;/li&gt;
&lt;li&gt;仓库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在之前分享的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484574&amp;amp;idx=1&amp;amp;sn=9ce4589efc377ba0f93e7513969164d9&amp;amp;chksm=ebd7459fdca0cc893f64895f536277bd4a024721b022382875197e87cc727495e4dd458ea337&amp;amp;token=221324962&amp;amp;lang=zh_CN#rd&quot;&gt;Docker科普文&lt;/a&gt;，也通俗易懂地讲解了这三个术语：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;镜像、容器、仓库的概念可以&lt;strong&gt;类比&lt;/strong&gt;代码、进程、github&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;如果让我来给完全不懂Docker解释这三个术语，我会这样做：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;镜像就是镜像，我们重装系统/搞虚拟机的时候都要用镜像，没镜像哪来系统&lt;/li&gt;
&lt;li&gt;我们安装完镜像，就可以跑起来一个系统(Windows也好、Centos也好)，于是我们就可以愉快地使用我们&lt;strong&gt;通过镜像&lt;/strong&gt;安装好的系统了。
&lt;ul&gt;&lt;li&gt;在Docker中，通过镜像运行起来的东西叫做&lt;strong&gt;容器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;仓库就是&lt;strong&gt;专门&lt;/strong&gt;存放镜像的地方&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;镜像(image)【image除了图片/图像的意思外，还有镜像的意思】&lt;/p&gt;
&lt;p&gt;容器(container)通过镜像运行起来的实例&lt;/p&gt;
&lt;p&gt;仓库(reposity)专门存放镜像的地方&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先需要&lt;strong&gt;明确自己所使用的环境&lt;/strong&gt;，就我而言，我使用的是&lt;code&gt;CentOS 7&lt;/code&gt;。据我所知，&lt;code&gt;CentOS 7&lt;/code&gt;和&lt;code&gt;CentOS 6.8&lt;/code&gt;在安装中都是有&lt;strong&gt;区别&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;所以，如果你想跟着我一起安装Docker，先明确自己的版本是否是&lt;code&gt;CentOS 7&lt;/code&gt;，如果不是只能找其他的教程来进行安装。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
cat /etc/redhat-release

// 结果

CentOS Linux release 7.3.1611 (Core)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装docker&quot;&gt;2.1安装Docker&lt;/h2&gt;
&lt;p&gt;首先我们需要安装GCC相关的环境：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// 安装GCC相关的环境

yum -y install gcc

yum -y install gcc-c++
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果曾经安装过Docker(旧版本)的话，得先卸载，如果没有安装过，跳过这一步：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// 卸载旧Docker版本

yum -y remove docker docker-common docker-selinux docker-engine
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装Docker需要的依赖软件包：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// 安装Docker需要的依赖软件包：

yum install -y yum-utils device-mapper-persistent-data lvm2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置stable镜像仓库(&lt;strong&gt;注意&lt;/strong&gt;：我们这里使用国内的镜像地址【因为Docker 官网给出的地址在国外，太慢了！】)&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// 设置stable镜像仓库：

yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新yum软件包索引：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// 更新yum软件包索引：

yum makecache fast
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装DOCKER CE(注意：Docker分为CE版和EE版，一般我们用CE版就够用了)&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// 安装DOCKER CE：

yum -y install docker-ce

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动Docker&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// 启动Docker

systemctl start docker
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;helloworld走起&quot;&gt;2.2HelloWorld走起&lt;/h2&gt;
&lt;p&gt;到上面为止，我们已经启动了Docker，下面我们检验一下我们运行的Docker是否正常。&lt;/p&gt;
&lt;p&gt;首先，我们可以看看下载回来的Docker版本：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// 查看Docker的版本

docker version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/13/16845ec0bf24a237?w=1920&amp;amp;h=1030&amp;amp;f=png&amp;amp;s=39869&quot; alt=&quot;我下载的Docker版本&quot;/&gt;&lt;/p&gt;
&lt;p&gt;版本都查到了，说明Docker是运行起来的啦。我们来一发HelloWorld：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
// docker的HelloWorld

docker run hello-world

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/13/16845ec0bef32f3e?w=1920&amp;amp;h=1030&amp;amp;f=png&amp;amp;s=64774&quot; alt=&quot;Docker中的HelloWorld&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单解释：&lt;code&gt;docker run hello-world&lt;/code&gt;这条命令&lt;strong&gt;指示&lt;/strong&gt;Docker去运行&lt;code&gt;hello-world&lt;/code&gt;这个镜像，但是我们本地没有这份镜像啊。所以Docker就去&lt;code&gt;DockerHub&lt;/code&gt;拉取了一份&lt;code&gt;hello-world&lt;/code&gt;镜像，并运行起来了(生成容器)。这个&lt;code&gt;hello-world&lt;/code&gt;容器的功能就是一句话：&lt;code&gt;Hello from Docker!&lt;/code&gt;。所以我们在屏幕上就可以看到这句话了。&lt;/p&gt;
&lt;h2 id=&quot;配置加速器&quot;&gt;2.3配置加速器&lt;/h2&gt;
&lt;p&gt;由于安装的Docker默认是去&lt;code&gt;Docker Hub&lt;/code&gt;找我们想要的镜像的，我们知道国外肯定没国内的快，所以我们一般会配置一个加速器&lt;/p&gt;
&lt;p&gt;国内的镜像仓库一般我们使用的有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阿里云&lt;/li&gt;
&lt;li&gt;网易云&lt;/li&gt;
&lt;li&gt;&lt;code&gt;// 等等&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先，我们到&lt;a href=&quot;https://promotion.aliyun.com/ntms/act/kubernetes.html&quot; class=&quot;uri&quot;&gt;https://promotion.aliyun.com/ntms/act/kubernetes.html&lt;/a&gt;搜索一下镜像，比如&lt;code&gt;Tomcat&lt;/code&gt; (这就需要我们注册/登录一个阿里云账号)&lt;/p&gt;
&lt;p&gt;随后，我们可以在&lt;code&gt;镜像加速器&lt;/code&gt;上找到我们的url：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/13/16845ec0c0fcb73b?w=1323&amp;amp;h=899&amp;amp;f=png&amp;amp;s=25620&quot; alt=&quot;镜像加速地址&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们依照阿里云给出的教程，就可以配置加速器了。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;


mkdir -p /etc/docker


tee /etc/docker/daemon.json &amp;lt;&amp;lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://cubmirje.mirror.aliyuncs.com&quot;]
}
EOF


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让配置生效，并重启Docker&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
systemctl daemon-reload

systemctl restart docker
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不知道大家学到这里，觉得怎么样。如果是我，我肯定觉得&lt;strong&gt;没意思&lt;/strong&gt;。搞了个HelloWorld案例，就打印了一句话，&lt;strong&gt;没意思&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;假如说，要在一台全新的系统上将Tomcat跑起来。我们需要做以下的事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装Java，配置环境变量&lt;/li&gt;
&lt;li&gt;安装Tomcat&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果我们用了Docker，我们是这样做的：直接在仓库里拉一份tomcat的镜像下来，将镜像跑起来就，就完事了！&lt;/p&gt;
&lt;p&gt;拉取Tomcat镜像：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
docker pull tomcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/13/16845ec0bcb927a7?w=1403&amp;amp;h=484&amp;amp;f=png&amp;amp;s=21248&quot; alt=&quot;拉取Tomcat镜像&quot;/&gt;&lt;/p&gt;
&lt;p&gt;docker images查看是否有拉取到的tomcat&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
docker image ls

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拉取到的Tomcat镜像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/13/16845ec0bd297bcd?w=1452&amp;amp;h=61&amp;amp;f=png&amp;amp;s=4041&quot; alt=&quot;拉取到的Tomcat镜像&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行这个Tomcat镜像，生成容器&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
docker run -it -p 9999:8080 tomcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以发现，这个&lt;strong&gt;Tomcat运行起来了&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/13/16845ec122125438?w=1895&amp;amp;h=996&amp;amp;f=png&amp;amp;s=75460&quot; alt=&quot;Tomcat运行起来了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(&lt;strong&gt;滚犊子&lt;/strong&gt;，没运行起来，踩坑了！，一直卡在&lt;code&gt;INFO: Deploying web application directory&lt;/code&gt;这句话上了。我还一直想，为啥我访问不到呢，才发现没运行起来)&lt;/p&gt;
&lt;h2 id=&quot;解决docker运行tomcat卡住的问题&quot;&gt;3.1解决docker运行Tomcat卡住的问题&lt;/h2&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;docker+tomcat 启动时非常慢，一般正常启动几十秒的，发现docker+tomcat启动竟需要几分钟，不可思议&lt;/p&gt;
&lt;p&gt;根本原因是 SecureRandom 这个 jre 的工具类的问题。那为什么 SecureRandom generateSeed 这么慢，甚至挂在 Linux 操作系统呢？&lt;/p&gt;
&lt;p&gt;Tomcat 7/8 都使用 org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom 类产生安全随机类 SecureRandom 的实例作为会话 ID。&lt;/p&gt;
&lt;p&gt;SecureRandom generateSeed 使用 /dev/random 生成种子。但是 /dev/random 是一个&lt;strong&gt;阻塞数字生成器&lt;/strong&gt;，如果它&lt;strong&gt;没有足够的随机数据提供，它就一直等&lt;/strong&gt;，这迫使 JVM 等待&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，我们先以后台的方式运行Tomcat镜像：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
docker run -tid  tomcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以bash的方式进入到容器中：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
docker exec -it 4a471223bfc4(为你正在运行容器的id) /bin/bash
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为容器安装vim：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
apt-get update


apt-get install vim
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改对应的&lt;code&gt;java.security&lt;/code&gt;文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
cd /docker-java-home/jre/lib/security

vim  java.security
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到 &lt;code&gt;securerandom.source=file:/dev/random&lt;/code&gt;，修改为&lt;code&gt;securerandom.source=file:/dev/./urandom&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Tomcat镜像下创建一个属于我们自己的Tomcat镜像(这个镜像安装了vim，修改了配置文件)&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
docker commit -m &quot;change java.security&quot; -a &quot;3y&quot; 4a471223bfc4(为当前容器的id) mytomcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是我们就生成了mytomcat镜像，就可以使用mytomcat：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
docker run -it -p:9999:8080 mytomcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/13/16845ec122790d1b?w=1749&amp;amp;h=949&amp;amp;f=png&amp;amp;s=73441&quot; alt=&quot;使用Docker容器成功启动Tomcat&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;docker 启动tomcat慢的解决方法
&lt;/li&gt;
&lt;li&gt;JRE /dev/random阻塞
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;除了Tomcat，大家还可以去拉个mysql、redis、centos等等镜像来玩玩~~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Docker的命令无非就是对&lt;strong&gt;镜像、对容器进行增删改查&lt;/strong&gt;。我是不太喜欢拉出每个命令来写文章的，所以这些命令还是大家自行学习吧~~&lt;/p&gt;
&lt;p&gt;之前收集资料的时候，我也找到了一张关于Docker的思维导图，对着来看看，感觉就没问题了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/21/1686ef34b0bf9033?w=2946&amp;amp;h=4602&amp;amp;f=png&amp;amp;s=974466&quot; alt=&quot;Docker的思维导图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关注我的公众号，回复 脑图 即可获取原图(&lt;code&gt;.xmind和.png&lt;/code&gt;格式)&lt;/p&gt;

&lt;p&gt;留下几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们知道Tomcat运行起来需要Java的支持，那么我们在Docker拉取下来的Tomcat镜像是不是也有Java环境呢？&lt;/li&gt;
&lt;li&gt;容器退出了(好比Linux进程退出了)，容器的数据就没了，我们想要保留容器内的数据，怎么办？&lt;/li&gt;
&lt;li&gt;从上面我们可以看出，通过commit可以在&lt;strong&gt;原有的容器基础上&lt;/strong&gt;，创建出属于我们自己的镜像，还有其他方式创建新的镜像吗？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;乐于输出&lt;strong&gt;干货&lt;/strong&gt;的Java技术公众号：Java3y。公众号内有200多篇&lt;strong&gt;原创&lt;/strong&gt;技术文章、海量视频资源、精美脑图，不妨来&lt;strong&gt;关注&lt;/strong&gt;一下！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/6/16823120a9a51060?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=21338&quot; alt=&quot;帅的人都关注了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;觉得我的文章写得不错，不妨点一下&lt;strong&gt;赞&lt;/strong&gt;！&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 05:53:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>前言 只有光头才能变强。 文本已收录至我的GitHub仓库，欢迎Star： 'https://github.com/ZhongFuCheng3y/3y' 上一篇已经讲解了 '为什么需要Docker？'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10298320.html</dc:identifier>
</item>
</channel>
</rss>