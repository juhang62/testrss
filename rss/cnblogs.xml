<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一文搞懂 Linux network namespace - CloudDeveloper</title>
<link>http://www.cnblogs.com/bakari/p/10443484.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/10443484.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文首发于我的公众号 &lt;strong&gt;CloudDeveloper(ID: cloud_dev)&lt;/strong&gt;，专注于干货分享，号内有大量书籍和视频资源，后台回复&lt;strong&gt;「1024」&lt;/strong&gt;即可领取，欢迎大家关注，二维码文末可以扫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文通过 IP 命令操作来简单介绍 network namespace 的基本概念和用法。深入了解可以看看我之前写的两篇文章 Docker 基础技术之 Linux namespace 详解 和 Docker 基础技术之 Linux namespace 源码分析。&lt;/p&gt;
&lt;p&gt;和 network namespace 相关的操作的子命令是 &lt;code&gt;ip netns&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;ip-netns-add-xx-创建一个-namespace&quot;&gt;1. ip netns add xx 创建一个 namespace&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# ip netns add net1
# ip netns ls
net1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ip-netns-exec-xx-yy-在新-namespace-xx-中执行-yy-命令&quot;&gt;2. ip netns exec xx yy 在新 namespace xx 中执行 yy 命令&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# ip netns exec net1 ip addr 
1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state DOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
# ip netns exec net1 bash // 在 net1 中打开一个shell终端
# ip addr // 在net1中的shell终端
1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state DOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
# exit // 退出net1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面 bash 不好区分是当前是在哪个 shell，可以采用下面的方法解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ip netns exec net1 /bin/bash --rcfile &amp;lt;(echo &quot;PS1=\&quot;namespace net1&amp;gt; \&quot;&quot;)
namespace net1&amp;gt; ping www.baidu.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个 namespace 在创建的时候会自动创建一个回环接口 &lt;code&gt;lo&lt;/code&gt; ，默认不启用，可以通过 &lt;code&gt;ip link set lo up&lt;/code&gt; 启用。&lt;/p&gt;
&lt;h2 id=&quot;network-namespace-之间的通信&quot;&gt;3. network namespace 之间的通信&lt;/h2&gt;
&lt;p&gt;新创建的 namespace 默认不能和主机网络，以及其他 namespace 通信。&lt;/p&gt;
&lt;p&gt;可以使用 Linux 提供的 &lt;code&gt;veth pair&lt;/code&gt; 来完成通信。下面显示两个 namespace 之间通信的网络拓扑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/431521/201902/431521-20190227142355100-1278014944.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ip-link-add-type-veth-创建-veth-pair&quot;&gt;3.1 ip link add type veth 创建 veth pair&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# ip link add type veth
# ip link
3: veth0@veth1: &amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 1a:53:39:5a:26:12 brd ff:ff:ff:ff:ff:ff
4: veth1@veth0: &amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 46:df:46:1f:bf:d6 brd ff:ff:ff:ff:ff:ff&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用命令 &lt;code&gt;ip link add xxx type veth peer name yyy&lt;/code&gt; 指定 veth pair 的名字。&lt;/p&gt;
&lt;h3 id=&quot;ip-link-set-xx-netns-yy-将-veth-xx-加入到-namespace-yy-中&quot;&gt;3.2 ip link set xx netns yy 将 veth xx 加入到 namespace yy 中&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# ip link set veth0 netns net0
# ip link set veth1 netns net1
#
# ip netns exec net0 ip addr
1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state DOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
10: veth0@if11: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether 1a:53:39:5a:26:12 brd ff:ff:ff:ff:ff:ff link-netnsid 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;给-veth-pair-配上-ip-地址&quot;&gt;3.3 给 veth pair 配上 ip 地址&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# ip netns exec net0 ip link set veth0 up
# ip netns exec net0 ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
10: veth0@if11: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state LOWERLAYERDOWN group default qlen 1000
    link/ether 1a:53:39:5a:26:12 brd ff:ff:ff:ff:ff:ff link-netnsid 1
# ip netns exec net0 ip addr add 10.1.1.1/24 dev veth0
# ip netns exec net0 ip route
10.1.1.0/24 dev veth0  proto kernel  scope link  src 10.1.1.1 linkdown
#
# ip netns exec net1 ip link set veth1 up
# ip netns exec net1 ip addr add 10.1.1.2/24 dev veth1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在配完 ip 之后，还自动生成了对应的路由表信息。&lt;/p&gt;
&lt;h3 id=&quot;ping-测试两个-namespace-的连通性&quot;&gt;3.4. ping 测试两个 namespace 的连通性&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# ip netns exec net0 ping 10.1.1.2
PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data.
64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.069 ms
64 bytes from 10.1.1.2: icmp_seq=2 ttl=64 time=0.054 ms
64 bytes from 10.1.1.2: icmp_seq=3 ttl=64 time=0.053 ms
64 bytes from 10.1.1.2: icmp_seq=4 ttl=64 time=0.053 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Done!&lt;/p&gt;
&lt;h2 id=&quot;多个不同-namespace-之间的通信&quot;&gt;4. 多个不同 namespace 之间的通信&lt;/h2&gt;
&lt;p&gt;2 个 namespace 之间通信可以借助 &lt;code&gt;veth pair&lt;/code&gt; ，多个 namespace 之间的通信则可以使用 bridge 来转接，不然每两个 namespace 都去配 &lt;code&gt;veth pair&lt;/code&gt; 将会是一件麻烦的事。下面就看看如何使用 bridge 来转接。&lt;/p&gt;
&lt;p&gt;拓扑图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/431521/201902/431521-20190227142421153-1920620786.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用-ip-link-和-brctl-创建-bridge&quot;&gt;4.1 使用 ip link 和 brctl 创建 bridge&lt;/h3&gt;
&lt;p&gt;通常 Linux 中和 bridge 有关的操作是使用命令 &lt;code&gt;brctl&lt;/code&gt; (&lt;code&gt;yum install -y bridge-utils&lt;/code&gt; ) 。但为了前后照应，这里都用 ip 相关的命令来操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 建立一个 bridge
# ip link add br0 type bridge
# ip link set dev br0 up
9: br0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
    link/ether 42:55:ed:eb:a0:07 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::4055:edff:feeb:a007/64 scope link
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建-veth-pair&quot;&gt;4.2 创建 veth pair&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//（1）创建 3 个 veth pair
# ip link add type veth
# ip link add type veth
# ip link add type veth&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将-veth-pair-的一头挂到-namespace-中一头挂到-bridge-上并设-ip-地址&quot;&gt;4.3 将 veth pair 的一头挂到 namespace 中，一头挂到 bridge 上，并设 IP 地址&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// （1）配置第 1 个 net0
# ip link set dev veth1 netns net0
# ip netns exec net0 ip link set dev veth1 name eth0
# ip netns exec net0 ip addr add 10.0.1.1/24 dev eth0
# ip netns exec net0 ip link set dev eth0 up
#
# ip link set dev veth0 master br0
# ip link set dev veth0 up

// （2）配置第 2 个 net1
# ip link set dev veth3 netns net1
# ip netns exec net1 ip link set dev veth3 name eth0
# ip netns exec net1 ip addr add 10.0.1.2/24 dev eth0
# ip netns exec net1 ip link set dev eth0 up
#
# ip link set dev veth2 master br0
# ip link set dev veth2 up

// （3）配置第 3 个 net2
# ip link set dev veth5 netns net2
# ip netns exec net2 ip link set dev veth5 name eth0
# ip netns exec net2 ip addr add 10.0.1.3/24 dev eth0
# ip netns exec net2 ip link set dev eth0 up
# 
# ip link set dev veth4 master br0
# ip link set dev veth4 up&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样之后，竟然通不了，经查阅 &lt;a href=&quot;https://segmentfault.com/q/1010000010011053/a-1020000010025650&quot;&gt;参见&lt;/a&gt; ，是因为&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;原因是因为系统为bridge开启了iptables功能，导致所有经过br0的数据包都要受iptables里面规则的限制，而docker为了安全性（我的系统安装了 docker），将iptables里面filter表的FORWARD链的默认策略设置成了drop，于是所有不符合docker规则的数据包都不会被forward，导致你这种情况ping不通。&lt;/p&gt;
&lt;p&gt;解决办法有两个，二选一：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关闭系统bridge的iptables功能，这样数据包转发就不受iptables影响了：echo 0 &amp;gt; /proc/sys/net/bridge/bridge-nf-call-iptables&lt;/li&gt;
&lt;li&gt;为br0添加一条iptables规则，让经过br0的包能被forward：iptables -A FORWARD -i br0 -j ACCEPT&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一种方法不确定会不会影响docker，建议用第二种方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我采用以下方法解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;iptables -A FORWARD -i br0 -j ACCEPT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ip netns exec net0 ping -c 2 10.0.1.2
PING 10.0.1.2 (10.0.1.2) 56(84) bytes of data.
64 bytes from 10.0.1.2: icmp_seq=1 ttl=64 time=0.071 ms
64 bytes from 10.0.1.2: icmp_seq=2 ttl=64 time=0.072 ms

--- 10.0.1.2 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.071/0.071/0.072/0.008 ms

# ip netns exec net0 ping -c 2 10.0.1.3
PING 10.0.1.3 (10.0.1.3) 56(84) bytes of data.
64 bytes from 10.0.1.3: icmp_seq=1 ttl=64 time=0.071 ms
64 bytes from 10.0.1.3: icmp_seq=2 ttl=64 time=0.087 ms

--- 10.0.1.3 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.071/0.079/0.087/0.008 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Done!&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我的公众号 &lt;strong&gt;CloudDeveloper(ID: cloud_dev)&lt;/strong&gt;，号内有大量书籍和视频资源，后台回复&lt;strong&gt;「1024」&lt;/strong&gt;即可领取，分享的内容包括但不限于云计算虚拟化、容器、OpenStack、K8S、雾计算、网络、工具、SDN、OVS、DPDK、Linux、Go、Python、C/C++编程技术等内容，欢迎大家关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/431521/201902/431521-20190226110944696-1998049166.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 07:58:00 +0000</pubDate>
<dc:creator>CloudDeveloper</dc:creator>
<og:description>本文首发于我的公众号 CloudDeveloper(ID: cloud_dev) ，专注于干货分享，号内有大量书籍和视频资源，后台回复 「1024」 即可领取，欢迎大家关注，二维码文末可以扫。 本文通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/10443484.html</dc:identifier>
</item>
<item>
<title>CSS学习笔记之z-index属性 - 路漫漫我不畏</title>
<link>http://www.cnblogs.com/huwt/p/10439415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huwt/p/10439415.html</guid>
<description>&lt;h3&gt;一、前言&lt;/h3&gt;

&lt;p&gt;　　网页显示实际上是三维的，我们直观看到的有x轴和y轴，但在网页布局上还有一个z轴。&lt;/p&gt;
&lt;p&gt;　　对于&lt;a href=&quot;https://www.cnblogs.com/huwt/p/10436468.html&quot; target=&quot;_blank&quot;&gt;定位元素&lt;/a&gt;，我们使用top、right、left、bottom来实现元素在x-y平面上的定位，但为了表示布局的三维立体概念，还引入了z-index，z-index属性用来设置元素的堆叠顺序，拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的上方。&lt;/p&gt;
&lt;h4&gt;　　z-index有三个参数：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;auto：默认值，相当于未设置z-index，可看作z-index: 0&lt;/li&gt;
&lt;li&gt;number：无单位数字，用来设置z-index大小&lt;/li&gt;
&lt;li&gt;inherit：继承父元素的z-index属性值&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;举个小栗子热热身&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: red; position: relative;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: black; position: relative; top: -50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个div向上移动50px，与第一个div产生了重叠部分，显示情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227130730010-114439751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二个div显示在了第一个div上方，也就是重叠部分第二个div遮住了第一个div，现在给第一个div添加z-index属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: red; position: relative; z-index: 1;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: black; position: relative; top: -50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 我们将第一个div的z-index属性设置为1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227131348044-746543734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时我们发现第一个div遮住了第二个div，下面我们将逐步介绍定位元素属性z-index。&lt;/p&gt;

&lt;h3&gt;二、z-index只对定位元素奏效&lt;/h3&gt;

&lt;h4&gt;　　定位元素（position 属性值为 relative 或 absolute 或 fixed）可以理解为具有x、y、z坐标的元素。如果定位元素没有显示给出z-index属性，那么它的z-index默认值为0。&lt;/h4&gt;
&lt;h4&gt;　　如果一个元素不是定位元素，那给它设置z-index属性也是无效的。&lt;/h4&gt;
&lt;h4&gt;栗子来了&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: red; z-index: 5;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: black; position: relative; top: -50px; z-index: 1;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 第一个div的z-index设置为5，第二个div的z-index设置为1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227135337277-407555948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到第二个div覆盖了第一个div，虽然第一个div的z-index属性值更大，但它不是定位属性，所以它的z-index不起作用。&lt;/p&gt;

&lt;h3&gt;三、非定位元素与非定位元素，以及相同z-index的堆叠顺序比较&lt;/h3&gt;

&lt;h4&gt;　　如果两个元素都为非定位元素，或者两个定位元素的z-index值相等，那么按照文档流的顺序，后写的元素将覆盖先写的元素。&lt;/h4&gt;
&lt;h4&gt;两个栗子接住&lt;/h4&gt;
&lt;p&gt;1. 两个都未设置z-index的定位元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: red; position: relative;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: black; position: relative; top: -50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后写的这个div（背景为black）覆盖了先写的div（背景为red）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227140730778-1147114754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 两个非定位元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: black; margin-top: -50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 后写的这个div（背景为black）覆盖了先写的div（背景为red）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227141011471-200487579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 四、定位元素与非定位元素的堆叠顺序&lt;/h3&gt;

&lt;h4&gt;　　如果定位元素未设置z-index或者z-index为正数，那么此类该定位元素的堆叠顺序大于非定位元素；如果定位元素z-index为负数,那么此类定位元素堆叠顺序小于非定位元素。&lt;/h4&gt;
&lt;h4&gt;栗如&lt;/h4&gt;
&lt;p&gt;第一个定位元素div的z-index为正数，第二个为非定位元素div，第一个定位元素div的z-index为负数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: green; position: relative; top: 50px; z-index: 1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: black; position: relative; top: -50px; z-index: -1;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; z-index为正数的定位元素覆盖了非定位元素，非定位元素覆盖了 z-index为负数的定位元素&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227142609559-1132108932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 五、父子及兄弟的堆叠顺序&lt;/h3&gt;

&lt;h4&gt;　　1. 如果父元素设置了z-index且不是默认值auto，无论子元素的z-index为何值，子元素堆叠顺序永远大于其父元素；&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: 200px; background-color: green; position: relative; top: 50px; z-index: 100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: blue; position: relative; z-index: -10;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 虽然子div的z-index值小于其父div，但子div仍显示在了父div的上方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227145055884-1368808999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;　　2. 如果父元素未设置z-index或值为auto，那么当子元素z-index为负数时，父元素堆叠顺序将大于子元素，否则子元素堆叠顺序大于父元素&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: 200px; background-color: green; position: relative; top: 50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: blue; position: relative; z-index: -1;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;父元素未设置z-index，子元素z-index为-1，可以看到子元素被父元素覆盖了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227150018363-1360402503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 　　3. 无论父元素的z-index如何，兄弟元素间的z-index值都可相互比较，z-index值越大堆叠顺序越高&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: 200px; background-color: green; position: relative; top: 50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: red; position: relative; z-index: 2;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: black; position: relative; z-index: 1; top: -50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一个子元素的z-index大于第二个子元素的z-index，所以第一个子元素覆盖第二个子元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227151117671-177072574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;　　3. 对于父元素及兄弟元素之外的其它元素，子元素的堆叠顺序由其父元素的z-index决定。&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;position: relative; z-index: 10;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: red; position: relative; z-index: 2;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;position: relative; z-index: 5;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; background-color: black; position: relative; z-index: 3; top: -50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 尽管背景为红色的子div元素z-index小于背景为黑色的子div元素，但红色仍覆盖了黑色，就是因为红色div的父元素z-index大于黑色div的父元素&lt;/p&gt;
&lt;p&gt;所以无论黑色子div的z-index多大，它的堆叠顺序始终小于红色div&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227152402728-1963171388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;六、最后&lt;/h3&gt;
&lt;p&gt; 感谢博主&lt;a href=&quot;https://home.cnblogs.com/u/dolphinX/&quot; target=&quot;_blank&quot;&gt;谦行&lt;/a&gt;的博客：&lt;a href=&quot;https://www.cnblogs.com/dolphinX/p/3262469.html&quot; target=&quot;_blank&quot;&gt;z-index应用简单总结&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如有错误或不足之处还望指出探讨，十分感谢！&lt;/p&gt;

</description>
<pubDate>Wed, 27 Feb 2019 07:30:00 +0000</pubDate>
<dc:creator>路漫漫我不畏</dc:creator>
<og:description>一、前言 网页显示实际上是三维的，我们直观看到的有x轴和y轴，但在网页布局上还有一个z轴。 对于定位元素，我们使用top、right、left、bottom来实现元素在x-y平面上的定位，但为了表示布</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huwt/p/10439415.html</dc:identifier>
</item>
<item>
<title>权限管理系统之主子表页面维护及事务处理 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/10443844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/10443844.html</guid>
<description>&lt;p&gt;上一博客搭建了项目框架并集成了日志、mybatis、分页，并实现了用户表显示页面的分页，昨天把单个表的增删改查功能实现，并复制粘贴完成了角色表、权限表的增删改查，今天实现主子表一对多关系的页面维护。&lt;/p&gt;
&lt;p&gt;一、问题解决&lt;/p&gt;
&lt;p&gt;上一博客中使用spring集成pagehelper进行分页，但在使用的过程中会出现下面的bug，后来又改成了使用springboot集成的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3a423db7-3214-4210-8f94-fb2e9abed553')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3a423db7-3214-4210-8f94-fb2e9abed553&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3a423db7-3214-4210-8f94-fb2e9abed553&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3a423db7-3214-4210-8f94-fb2e9abed553',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3a423db7-3214-4210-8f94-fb2e9abed553&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
java.lang.NoSuchMethodError: org.apache.ibatis.reflection.MetaObject.forObject(Ljava/lang/Object;Lorg/apache/ibatis/reflection/factory/ObjectFactory;Lorg/apache/ibatis/reflection/wrapper/ObjectWrapperFactory;)Lorg/apache/ibatis/reflection/&lt;span&gt;MetaObject;
    at com.github.pagehelper.SqlUtil.forObject(SqlUtil.java:&lt;/span&gt;78) ~[pagehelper-3.4.2.jar:?&lt;span&gt;]
    at com.github.pagehelper.SqlUtil.getsqlSource(SqlUtil.java:&lt;/span&gt;517) ~[pagehelper-3.4.2.jar:?&lt;span&gt;]
    at com.github.pagehelper.SqlUtil.getMappedStatement(SqlUtil.java:&lt;/span&gt;440) ~[pagehelper-3.4.2.jar:?&lt;span&gt;]
    at com.github.pagehelper.SqlUtil.processCountMappedStatement(SqlUtil.java:&lt;/span&gt;143) ~[pagehelper-3.4.2.jar:?&lt;span&gt;]
    at com.github.pagehelper.PageHelper.intercept(PageHelper.java:&lt;/span&gt;140) ~[pagehelper-3.4.2.jar:?&lt;span&gt;]
    at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:&lt;/span&gt;61) ~[mybatis-3.4.6.jar:3.4.6&lt;span&gt;]
    at com.sun.proxy.$Proxy84.query(Unknown Source) &lt;/span&gt;~[?:?&lt;span&gt;]
    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:&lt;/span&gt;148) ~[mybatis-3.4.6.jar:3.4.6&lt;span&gt;]
    at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:&lt;/span&gt;141) ~[mybatis-3.4.6.jar:3.4.6&lt;span&gt;]
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) &lt;/span&gt;~[?:1.8&lt;span&gt;.0_201]
    at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) &lt;/span&gt;~[?:1.8&lt;span&gt;.0_201]
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) &lt;/span&gt;~[?:1.8&lt;span&gt;.0_201]
    at java.lang.reflect.Method.invoke(Unknown Source) &lt;/span&gt;~[?:1.8&lt;span&gt;.0_201]
    at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:&lt;/span&gt;433) ~[mybatis-spring-1.3.2.jar:1.3.2&lt;span&gt;]
    at com.sun.proxy.$Proxy71.selectList(Unknown Source) &lt;/span&gt;~[?:?&lt;span&gt;]
    at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:&lt;/span&gt;230) ~[mybatis-spring-1.3.2.jar:1.3.2&lt;span&gt;]
    at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:&lt;/span&gt;139) ~[mybatis-3.4.6.jar:3.4.6&lt;span&gt;]
    at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:&lt;/span&gt;76) ~[mybatis-3.4.6.jar:3.4.6&lt;span&gt;]
    at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:&lt;/span&gt;59) ~[mybatis-3.4.6.jar:3.4.6&lt;span&gt;]
    at com.sun.proxy.$Proxy72.getUsers(Unknown Source) &lt;/span&gt;~[?:?&lt;span&gt;]
    at com.example.service.impl.UserServiceImpl.getUsers(UserServiceImpl.java:&lt;/span&gt;31) ~[classes/:?&lt;span&gt;]
    at com.example.controller.UserController.getUsers(UserController.java:&lt;/span&gt;94) ~[classes/:?&lt;span&gt;]
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) &lt;/span&gt;~[?:1.8&lt;span&gt;.0_201]
    at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) &lt;/span&gt;~[?:1.8&lt;span&gt;.0_201]
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) &lt;/span&gt;~[?:1.8&lt;span&gt;.0_201]
    at java.lang.reflect.Method.invoke(Unknown Source) &lt;/span&gt;~[?:1.8&lt;span&gt;.0_201]
    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:&lt;/span&gt;189) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:&lt;/span&gt;138) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:&lt;/span&gt;102) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:&lt;/span&gt;895) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:&lt;/span&gt;800) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:&lt;/span&gt;87) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:&lt;/span&gt;1038) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:&lt;/span&gt;942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:&lt;/span&gt;1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:&lt;/span&gt;897) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:&lt;/span&gt;634) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:&lt;/span&gt;882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:&lt;/span&gt;741) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:&lt;/span&gt;231) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:&lt;/span&gt;166) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:&lt;/span&gt;53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:&lt;/span&gt;193) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:&lt;/span&gt;166) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:&lt;/span&gt;99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:&lt;/span&gt;107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:&lt;/span&gt;193) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:&lt;/span&gt;166) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:&lt;/span&gt;92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:&lt;/span&gt;107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:&lt;/span&gt;193) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:&lt;/span&gt;166) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:&lt;/span&gt;93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:&lt;/span&gt;107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:&lt;/span&gt;193) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:&lt;/span&gt;166) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:&lt;/span&gt;200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:&lt;/span&gt;107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5&lt;span&gt;.RELEASE]
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:&lt;/span&gt;193) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:&lt;/span&gt;166) ~[tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:&lt;/span&gt;200) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:&lt;/span&gt;96) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:&lt;/span&gt;490) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:&lt;/span&gt;139) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:&lt;/span&gt;92) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:&lt;/span&gt;74) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:&lt;/span&gt;343) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:&lt;/span&gt;408) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:&lt;/span&gt;66) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:&lt;/span&gt;834) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:&lt;/span&gt;1415) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:&lt;/span&gt;49) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) [&lt;/span&gt;?:1.8&lt;span&gt;.0_201]
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) [&lt;/span&gt;?:1.8&lt;span&gt;.0_201]
    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:&lt;/span&gt;61) [tomcat-embed-core-9.0.16.jar:9.0.16&lt;span&gt;]
    at java.lang.Thread.run(Unknown Source) [&lt;/span&gt;?:1.8.0_201]
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;去除上一博客分页引入的依赖，在pom.xml中引入pagehelper-spring-boot-starter依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c66b6580-5424-4408-861a-f004af9e11eb')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_c66b6580-5424-4408-861a-f004af9e11eb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c66b6580-5424-4408-861a-f004af9e11eb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c66b6580-5424-4408-861a-f004af9e11eb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c66b6580-5424-4408-861a-f004af9e11eb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.github.pagehelper&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pagehelper-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.github.pagehelper&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pagehelper-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在application.properties中设置pagehelper的属性，同时要去前面在mybatis-config.xml中pagehelper的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#pagehelper
pagehelper.helperDialect=mysql
pagehelper.reasonable=true
pagehelper.support-methods-arguments=true
pagehelper.params=count=countSql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、父子表页面维护&lt;/p&gt;
&lt;p&gt;数据库表有一对一、一对多、多对多的关系，用户与角色、角色与资源等，这里增加了两个中间表：user_role、role_permission表，既然有这两个表，就要对这两张表进行维护，那怎么维护，用户操作习惯是怎样，这个思考了好久，可能智者见智仁者见仁，这里以用户角色列下我实现的方式，先贴上实现的效果页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201902/733213-20190227144843888-421577485.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201902/733213-20190227144130427-273512011.jpg&quot; alt=&quot;&quot; width=&quot;751&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201902/733213-20190227144302488-1071984000.jpg&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户在用户表中点击选择角色会弹出图2底部的弹窗，显示已有的角色，点击添加角色时，会弹出图2顶部的弹窗，显示用户未关联的角色，用户可以选择角色点击添加按钮之后，在顶部会将选中的角色去除，选择完毕关闭顶部弹窗时会刷新底部弹窗，显示用户的角色。用户可以对关联角色进行删除。不难发现，上面的弹框表格样式与角色管理页面样式差不多，其实都是用的角色管理页面，两个弹窗的业务也都在一个js中，主要是因为我比较懒，不想再增加页面了。角色与权限的关系维护也与这个一样，复制粘贴用户角色的实现然后修改完成。&lt;/p&gt;
&lt;p&gt;三、事务管理&lt;/p&gt;
&lt;p&gt;主子表带来一个问题就是当删除主表数据时需要也要把子表关联的数据也删除，比如用户页面，删除用户就需要把用户与角色关联表中相应的用户数据也删除。在springboot处理事务只需要在main方法类中开启全局事务，然后在对应的类或方法上声明事务。&lt;/p&gt;
&lt;p&gt;1.开启事务&lt;/p&gt;
&lt;p&gt;在main方法类中使用@EnableTransactionManagement注解开启事务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@ComponentScan(basePackages = {&quot;com.example.*&quot;&lt;span&gt;})
@SpringBootApplication
@EnableTransactionManagement 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ManageApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ManageApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.在类或方法上声明事务&lt;/p&gt;
&lt;p&gt;使用@Transactional注解在类、方法上声明事务。删除用户的时候需要删除关联表中的角色信息，这里在删除用户的方法上声明了事务，为了测试事务，在删除关联表时抛出了RuntimeException异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @Transactional(propagation&lt;/span&gt;=&lt;span&gt;Propagation.REQUIRED) 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean delUser(String id) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        String[]  ids&lt;/span&gt;=id.split(&quot;,&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ids.length&amp;gt;0&lt;span&gt;)
        {
            userMapper.delUser(ids);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;ids.length;i++&lt;span&gt;)
            {
                delRoles(ids[i],&lt;/span&gt;&quot;&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;注释&quot;&lt;span&gt;);
            }
        }        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用户编号001的用户关联的是有角色的，在点击删除时会报删除失败！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201902/733213-20190227150603238-822292245.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201902/733213-20190227150514643-197416915.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四、小结&lt;/p&gt;
&lt;p&gt;目前已实现了3个单表用户表、角色表、权限表的增删改查以及两个用户角色、角色权限关联表的维护，后续就是了解shiro框架的使用和项目的优化重构。&lt;/p&gt;

</description>
<pubDate>Wed, 27 Feb 2019 07:09:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>上一博客搭建了项目框架并集成了日志、mybatis、分页，并实现了用户表显示页面的分页，昨天把单个表的增删改查功能实现，并复制粘贴完成了角色表、权限表的增删改查，今天实现主子表一对多关系的页面维护。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/10443844.html</dc:identifier>
</item>
<item>
<title>轻量级.NET CORE ORM框架Insql使用教程 - rainrcn</title>
<link>http://www.cnblogs.com/rainrcn/p/10443611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainrcn/p/10443611.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Insql 国人开发，是一款汲取 Mybatis 优点的.NET ORM 框架。追求简单直观，使用自由灵活等特点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://rainrcn.github.io/insql&quot; class=&quot;uri&quot;&gt;https://rainrcn.github.io/insql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此 ORM 是以 Mybatis 的 Sql 配置方式，以 Dapper 为对象映射的基础上建立。喜欢写 SQL 的同学们肯定会喜欢的。另外因为对象映射使用 Dapper 的关系，所以性能上不用过多担心。&lt;/p&gt;
&lt;h3 id=&quot;创建项目&quot;&gt;创建项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/86219/201902/86219-20190227144440903-2126221674.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板选择&lt;code&gt;Api&lt;/code&gt;或&lt;code&gt;Web应用程序&lt;/code&gt;，如果会自己大家结构选择&lt;code&gt;空&lt;/code&gt;也是可以的。&lt;/p&gt;
&lt;p&gt;在项目上鼠标右键选择&lt;code&gt;管理Nuget程序包&lt;/code&gt;,搜索&lt;code&gt;Insql&lt;/code&gt;并添加安装，Insql 包自带 SqlServer 数据库连接，如果需要 MySql 数据库，需要另外安装&lt;code&gt;Insql.MySql&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/86219/201902/86219-20190227144452683-760035254.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;打开&lt;code&gt;Startup.cs&lt;/code&gt;，在&lt;code&gt;ConfigureServices&lt;/code&gt;中加入&lt;code&gt;AddInsql&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddInsql();

    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Insql 就已经可以开始用了。&lt;/p&gt;
&lt;p&gt;在项目下创建&lt;code&gt;Domain&lt;/code&gt;目录，并创建&lt;code&gt;UserDbContext.cs&lt;/code&gt; &lt;code&gt;UserDbContext.insql.xml&lt;/code&gt; &lt;code&gt;UserPo.cs&lt;/code&gt; &lt;code&gt;RolePo.cs&lt;/code&gt; 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/86219/201902/86219-20190227144501392-1495649667.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UserDbContext.insql.xml&lt;/code&gt; 要右键属性选择嵌入式资源&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/86219/201902/86219-20190227144511282-200001736.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;写代码&quot;&gt;写代码&lt;/h3&gt;
&lt;h4 id=&quot;创建数据库模型类-userpo.cs-rolepo.cs&quot;&gt;1. 创建数据库模型类 &lt;code&gt;UserPo.cs&lt;/code&gt; &lt;code&gt;RolePo.cs&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class UserPo
{
    public string UserId { get; set; }

    public string UserName { get; set; }

    public DateTime CreateTime { get; set; }
}

public class RolePo
{
    public string RoleCode { get; set; }

    public string RoleName { get; set; }

    public int RoleOrder { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建usedbcontext.insql.xmlsql-配置&quot;&gt;2. 创建&lt;code&gt;UseDbContext.insql.xml&lt;/code&gt;SQL 配置&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;insql type=&quot;InsqlExample.Domain.Context.UserDbContext,InsqlExample&quot; &amp;gt;

  &amp;lt;!--定义UserPo类型数据库字段到对象属性映射--&amp;gt;
  &amp;lt;map type=&quot;InsqlExample.Domain.Model.UserPo,InsqlExample&quot;&amp;gt;
    &amp;lt;key name=&quot;user_id&quot; to=&quot;UserId&quot; /&amp;gt;
    &amp;lt;column name=&quot;user_name&quot; to=&quot;UserName&quot; /&amp;gt;
    &amp;lt;column name=&quot;create_time&quot; to=&quot;CreateTime&quot; /&amp;gt;
  &amp;lt;/map&amp;gt;

  &amp;lt;map type=&quot;InsqlExample.Domain.Model.RolePo,InsqlExample&quot;&amp;gt;
    &amp;lt;key name=&quot;role_code&quot; to=&quot;RoleCode&quot; /&amp;gt;
    &amp;lt;column name=&quot;role_name&quot; to=&quot;RoleName&quot; /&amp;gt;
    &amp;lt;column name=&quot;role_order&quot; to=&quot;RoleOrder&quot; /&amp;gt;
  &amp;lt;/map&amp;gt;

  &amp;lt;select id=&quot;GetUser&quot;&amp;gt;
    select * from user_info where user_id = @userId
  &amp;lt;/select&amp;gt;

  &amp;lt;insert id=&quot;InsertUser&quot;&amp;gt;
    insert into user_info (user_id,user_name,create_time) value (@UserId,@UserName,@CreateTime)
  &amp;lt;/insert&amp;gt;

  &amp;lt;update id=&quot;UpdateUser&quot;&amp;gt;
    update user_info
    &amp;lt;set&amp;gt;
      &amp;lt;if test=&quot;UserName != null&quot;&amp;gt;
        user_name = @UserName,
      &amp;lt;/if&amp;gt;
    &amp;lt;/set&amp;gt;
    where user_id = @UserId
  &amp;lt;/update&amp;gt;

  &amp;lt;delete id=&quot;DeleteUser&quot;&amp;gt;
    delete from user_info where user_id = @userId
  &amp;lt;/delete&amp;gt;

  &amp;lt;select id=&quot;GetRoleList&quot;&amp;gt;
    select * from role_info order by role_order
  &amp;lt;/select&amp;gt;
&amp;lt;/insql&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;select&lt;/code&gt;,&lt;code&gt;insert&lt;/code&gt;,&lt;code&gt;update&lt;/code&gt;,&lt;code&gt;delete&lt;/code&gt; 分别代表增删改查，可以看到在&lt;code&gt;update&lt;/code&gt;中有特殊 xml 元素，可以进项目文档查看详细说明，有 Mybatis 经验的同学自然就理解了&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建userdbcontext数据上下文&quot;&gt;3. 创建&lt;code&gt;UserDbContext&lt;/code&gt;数据上下文&lt;/h4&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class UserDbContext : DbContext
{
    public UserDbContext(DbContextOptions&amp;lt;UserDbContext&amp;gt; options) : base(options)
    {
    }

    public UserPo GetUser(string userId)
    {
        //&quot;GetUser&quot;对应 select上的id,
        //第二个查询参数支持 PlainObject和 IDictionary&amp;lt;string,object&amp;gt;两种类型
        return this.Query&amp;lt;UserPo&amp;gt;(&quot;GetUser&quot;, new { userId }).SingleOrDefault();
    }

    public void InsertUser(UserPo user)
    {
        this.Execute(nameof(InsertUser), user);
    }

    public void UpdateUser(UserPo user)
    {
        this.Execute(nameof(UpdateUser), user);
    }

    public void DeleteUser(string userId)
    {
        this.Execute(nameof(DeleteUser), new { userId });
    }

    public IEnumerable&amp;lt;RolePo&amp;gt; GetRoleList()
    {
        return this.Query&amp;lt;RolePo&amp;gt;(&quot;GetRoleList&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;别忘了在&lt;code&gt;Startup.cs&lt;/code&gt;中注册 UserDbContext。 命名空间 using Insql;一下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddInsql();

    services.AddInsqlDbContext&amp;lt;UserDbContext&amp;gt;(options =&amp;gt;
    {
        //这里代表这个上下文使用这个SqlServer数据库
        options.UseSqlServer(&quot;这里是连接字符串&quot;);
    });

    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增删改查这就 OK 了。然后我们可以在 Controller 或者 Service 中直接注入 UserDbContext 来用。&lt;/p&gt;
&lt;h4 id=&quot;在valuescontroller.cs中使用userdbcontext&quot;&gt;4. 在&lt;code&gt;ValuesController.cs&lt;/code&gt;中使用UserDbContext&lt;/h4&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{
    private readonly UserDbContext dbContext;

    public ValuesController(UserDbContext dbContext)
    {
        this.dbContext = dbContext;
    }

    [HttpGet]
    public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
    {
        //查询用户
        var user1 = this.dbContext.GetUser(&quot;tome&quot;);

        //增加用户
        this.dbContext.InsertUser(new UserPo
        {
            UserId = Guid.NewGuid().ToString(),
            UserName = &quot;tom&quot;,
            CreateTime = DateTime.Now
        });

        //查询角色列表
        var roleList = this.dbContext.GetRoleList();

        //....其他的不演示了

        //还可以这样用，通过dbContext直接调用sql，和在DbContext里面写方法一样的
        var userJerry = this.dbContext.Query&amp;lt;UserPo&amp;gt;(&quot;GetUser&quot;, new { userId = &quot;jerry&quot; });

        return new string[] { &quot;value1&quot;, &quot;value2&quot; };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;行这就完事了。&lt;/p&gt;
&lt;p&gt;可以去看看项目文档，支持功能还挺多的。代码生成器也有。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 06:46:00 +0000</pubDate>
<dc:creator>rainrcn</dc:creator>
<og:description>Insql 国人开发，是一款汲取 Mybatis 优点的.NET ORM 框架。追求简单直观，使用自由灵活等特点。 项目主页： 'https://rainrcn.github.io/insql' 此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rainrcn/p/10443611.html</dc:identifier>
</item>
<item>
<title>zookeeper实现动态感知服务器上下线 - ゞ .邓澎波</title>
<link>http://www.cnblogs.com/dengpengbo/p/10443547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dengpengbo/p/10443547.html</guid>
<description>&lt;p&gt;  在实际的生产环境中我们一般都是集群环境部署的，同一个程序我们会部署在相同的几台服务器中，这时我们可以通过负载均衡服务器去调度，但是我们并不能很快速的获知哪台服务器挂掉了，这时我们就可以使用zookeeper来解决这个问题。&lt;/p&gt;

&lt;p&gt;  动态感知其实利用的就是zookeeper的watch功能，我们先来看下常规的负载均衡服务器的结构&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190226164559283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;再来看下我们用zookeeper实现的结构&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190226164643678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;文字描述&quot;&gt;&lt;strong&gt;文字描述：&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;感知上线&quot;&gt;1.感知上线&lt;/h3&gt;
&lt;p&gt;  当服务器启动的时候通过程序知道后会同时在zookeeper的servers节点下创建一个新的短暂有序节点来存储当前服务器的信息。客户端通过对servers节点的watch可以立马知道有新的服务器上线了&lt;/p&gt;
&lt;h3 id=&quot;感知下线&quot;&gt;2.感知下线&lt;/h3&gt;
&lt;p&gt;  当我们有个服务器下线后，对应的servers下的短暂有序节点会被删除，此时watch servers节点的客户端也能立马知道哪个服务器下线了，能够及时将访问列表中对应的服务器信息移除，从而实现及时感知服务器的变化。&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;代码实现&lt;/h2&gt;
&lt;h3 id=&quot;服务器端代码&quot;&gt;服务器端代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.dpb.dynamic;

import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;

/**
 * 服务器端代码
 * @author dengp
 *
 */
public class DistributedServer {

    private static final String connectString = &quot;192.168.88.121:2181,192.168.88.122:2181,192.168.88.123:2181&quot;;
    private static final int sessionTimeout = 2000;
    private static final String parentNode = &quot;/servers&quot;;

    private ZooKeeper zk = null;

    /**
     * 创建到zk的客户端连接
     * 
     * @throws Exception
     */
    public void getConnect() throws Exception {
        zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                // 收到事件通知后的回调函数（应该是我们自己的事件处理逻辑）
                System.out.println(event.getType() + &quot;---&quot; + event.getPath());
                try {
                    zk.getChildren(&quot;/&quot;, true);
                } catch (Exception e) {
                }
            }
        });

    }

    /**
     * 向zk集群注册服务器信息
     * 
     * @param hostname
     * @throws Exception
     */
    public void registerServer(String hostname) throws Exception {

        String create = zk.create(parentNode + &quot;/server&quot;, hostname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        System.out.println(hostname + &quot;is online..&quot; + create);

    }

    /**
     * 业务功能
     * 
     * @throws InterruptedException
     */
    public void handleBussiness(String hostname) throws InterruptedException {
        System.out.println(hostname + &quot;start working.....&quot;);
        Thread.sleep(Long.MAX_VALUE);
    }

    public static void main(String[] args) throws Exception {

        // 获取zk连接
        DistributedServer server = new DistributedServer();
        server.getConnect();

        // 利用zk连接注册服务器信息
        server.registerServer(args[0]);

        // 启动业务功能
        server.handleBussiness(args[0]);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;客户端代码&quot;&gt;客户端代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.dpb.dynamic;

import java.util.ArrayList;
import java.util.List;

import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
/**
 * 客户端：通过zookeeper获取服务器地址
 * @author 波波烤鸭
 *
 */
public class DistributedClient {

    private static final String connectString = &quot;192.168.88.121:2181,192.168.88.122:2181,192.168.88.123:2181&quot;;
    private static final int sessionTimeout = 2000;
    private static final String parentNode = &quot;/servers&quot;;
    // 注意:加volatile的意义何在？
    private volatile List&amp;lt;String&amp;gt; serverList;
    private ZooKeeper zk = null;

    /**
     * 创建到zk的客户端连接
     * 
     * @throws Exception
     */
    public void getConnect() throws Exception {
        zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                // 收到事件通知后的回调函数（应该是我们自己的事件处理逻辑）
                try {
                    //重新更新服务器列表，并且注册了监听
                    getServerList();
                } catch (Exception e) {
                }
            }
        });

    }

    /**
     * 获取服务器信息列表
     * 
     * @throws Exception
     */
    public void getServerList() throws Exception {

        // 获取服务器子节点信息，并且对父节点进行监听
        List&amp;lt;String&amp;gt; children = zk.getChildren(parentNode, true);

        // 先创建一个局部的list来存服务器信息
        List&amp;lt;String&amp;gt; servers = new ArrayList&amp;lt;String&amp;gt;();
        for (String child : children) {
            // child只是子节点的节点名
            byte[] data = zk.getData(parentNode + &quot;/&quot; + child, false, null);
            servers.add(new String(data));
        }
        // 把servers赋值给成员变量serverList，已提供给各业务线程使用
        serverList = servers;
        
        //打印服务器列表
        System.out.println(serverList);
        
    }

    /**
     * 业务功能
     * 
     * @throws InterruptedException
     */
    public void handleBussiness() throws InterruptedException {
        System.out.println(&quot;client start working.....&quot;);
        Thread.sleep(Long.MAX_VALUE);
    }
    
    public static void main(String[] args) throws Exception {
        // 获取zk连接
        DistributedClient client = new DistributedClient();
        client.getConnect();
        // 获取servers的子节点信息（并监听），从中获取服务器信息列表
        client.getServerList();
        // 业务线程启动
        client.handleBussiness();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;h4 id=&quot;在zookeeper中的下创建一个servers永久节点&quot;&gt;1.在zookeeper中的/下创建一个servers永久节点&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 1] create /servers servers
Created /servers&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;启动三个服务器&quot;&gt;1.启动三个服务器&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190226170229293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190226170449540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;再启动另外两个&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190226170550727.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;启动一个客户端&quot;&gt;3.启动一个客户端&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190226170657224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;关闭一个服务器然后在新开一个服务器观察&quot;&gt;4.关闭一个服务器然后在新开一个服务器观察&lt;/h4&gt;
&lt;p&gt;关掉server01后客户端立马打印如下信息&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190226170810641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;更新了服务器列表，移除了server01&lt;br/&gt;再开启一个server04服务器查看&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190226171006414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;客户端获取到了刚刚上线的服务器。&lt;br/&gt;ok~本文到此结束。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 06:35:00 +0000</pubDate>
<dc:creator>ゞ .邓澎波</dc:creator>
<og:description>  在实际的生产环境中我们一般都是集群环境部署的，同一个程序我们会部署在相同的几台服务器中，这时我们可以通过负载均衡服务器去调度，但是我们并不能很快速的获知哪台服务器挂掉了，这时我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dengpengbo/p/10443547.html</dc:identifier>
</item>
<item>
<title>带你了解CSRF和XSS（一） - anyhoo</title>
<link>http://www.cnblogs.com/anyhoo/p/10443517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anyhoo/p/10443517.html</guid>
<description>&lt;p&gt;　　浏览器的同源策略限制了一些跨域行为，但仍有些特例（img、iframe、script标签）不受跨域限制，这就给XSS攻击创造了机会（这完全不是同源策略的锅，一定是程序员的锅）。&lt;/p&gt;
&lt;p&gt;　　在讲下面的内容前，还是要提一下Cookie，Cookie是用来辨别用户身份的重要依据。来做个形象的比喻，有一天，小A去了一家新开的理发店，店里的托尼老师不认识小A，于是小A就办了一张VIP卡，当小A第二次去这家理发店的时候，店里的托尼老师刷了下小A的卡，想起来了你是小A啊，今天搞什么样的造型啊~ Cookie就是那张VIP卡，用于辨别用户身份。&lt;/p&gt;
&lt;p&gt;　　Cookie包含以下几个属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000047/201902/1000047-20190227142843774-1872021491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　采用 Name = Value 的键值对形式存储数据，Name是唯一的&lt;/p&gt;
&lt;p&gt;　　Domain：域名，限制哪些域名下可以使用（该VIP卡仅限本店使用）&lt;/p&gt;
&lt;p&gt;　　Path：路径，只有这个路径前缀的才可用（该VIP卡仅限烫头）&lt;/p&gt;
&lt;p&gt;　　Expires：过期时间（该VIP卡有效期一年）&lt;/p&gt;
&lt;p&gt;　　HTTP（HTTPOnly）：只有浏览器请求时，才会在请求头中带着，JavaScript无法读写&lt;/p&gt;
&lt;p&gt;　　Secure：非HTTPS请求时不带&lt;/p&gt;
&lt;p&gt;　　SameSite：用于定义cookie如何跨域发送&lt;/p&gt;
&lt;p&gt;　　Cookie就先简单说到这里，回到XSS攻击，后续讲到的XSS和CSRF攻击都会围绕着怎么获取Cookie来举例。&lt;/p&gt;

&lt;p&gt;　　XSS（Cross-site-Script跨站脚本攻击），通常是带有页面可解析内容的数据未经处理直接插入到页面上解析造成的。XSS根据攻击脚本的引入位置来区分为存储型XSS、反射型XSS以及MXSS（也叫DOM XSS）三种。&lt;/p&gt;
&lt;p&gt;         根据上面的描述来举个例子：&lt;br/&gt;         假设有一个论坛存在XSS漏洞，用户小A在该论坛的一篇帖子中留言到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000047/201902/1000047-20190227142935682-1042493928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当小A写的留言被该论坛保存下来之后，如果有其他的用户看到了这条评论（相当于打开了这个页面，执行了hark.js，hark.js里面内容大致是获取Cookie，发送请求），那么这些用户的Cookie都会发送到小A事先写好的信息收集网站中进行保存，然后小A就可以用这些Cookie进行登录啦。&lt;/p&gt;
&lt;p&gt;　　上述这种XSS攻击属于存储型，提交的代码会被存储在服务器端，下次请求目标网站时不用再提交XSS代码。所以这种类型的主要原因是前端提交的数据未经处理直接存储到数据库，然后从数据库中读取出来后直接插入到页面中导致的。&lt;/p&gt;

&lt;p&gt;继续讲故事：&lt;/p&gt;
&lt;p&gt;         假设有一个网站lalala存在XSS漏洞，网址是http://www.lalala.com。然后有一天小A在邮件里发现一封邮件，内容是一张你懂得图片然后配下面的标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000047/201902/1000047-20190227143106108-1877578569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　小A好奇啊，然后就点了进去，如果在此之前小A登录过lalala网站，那么他的Cookie就被盗走了。&lt;/p&gt;
&lt;p&gt;　　这种XSS攻击属于反射型，发出请求时，XSS代码出现在URL中，作为输入提交到服务器，服务器解析后响应，XSS代码随着响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫做反射型XSS。&lt;/p&gt;

&lt;p&gt;　　MXSS则是在渲染DOM属性时将攻击脚本插入DOM属性中被解析而导致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000047/201902/1000047-20190227143125701-161276374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，三种类型的XSS攻击都描述完了，你看确实都是程序员的锅吧。&lt;/p&gt;
&lt;p&gt;         服务端可以做以下动作：&lt;/p&gt;
&lt;p&gt;         1、刚刚上面讲到Cookie中有个属性时HTTP，设置为True，不允许JavaScript读取cookies，但该属性只适配部分浏览器。对于HTTPS可以设置Secure&lt;/p&gt;
&lt;p&gt;         2、处理富文本框输入内容，进行XSS过滤，过滤类似script、iframe、form等标签以及转义存储&lt;/p&gt;
&lt;p&gt;         客户端可以做以下动作：&lt;/p&gt;
&lt;p&gt;         1、输入检查，和服务端一样都要做。&lt;br/&gt;         2、输出检查，编码转义，如果使用jquery，就是那些append、html、before、after等，插入DOM的方法需要注意。现今大部分的MV*框架在模板（view层）会自动处理XSS问题。&lt;/p&gt;

&lt;p&gt;         XSS攻击的危害是很大的，像上面的例子注入script可以执行任何的JS代码(意味着可以获取cookie等信息了)，注入style可以把页面全部弄崩。尤其是具有评论功能的网站需要注意防范此类攻击，不要相信客户端发送过来的任何数据！还有就是不要乱点开奇奇怪怪的链接啦~&lt;/p&gt;

</description>
<pubDate>Wed, 27 Feb 2019 06:33:00 +0000</pubDate>
<dc:creator>anyhoo</dc:creator>
<og:description>浏览器的同源策略限制了一些跨域行为，但仍有些特例（img、iframe、script标签）不受跨域限制，这就给XSS攻击创造了机会（这完全不是同源策略的锅，一定是程序员的锅）。 在讲下面的内容前，还是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anyhoo/p/10443517.html</dc:identifier>
</item>
<item>
<title>你所听到的技术原理、技术本质到底是什么？ - 风象南</title>
<link>http://www.cnblogs.com/yuboon/p/10443398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuboon/p/10443398.html</guid>
<description>&lt;p&gt;职场的程序员们或多或少都受到过前辈或领导的指点，应该都听过这么一句话 “学技术不能光会搭建个环境，使几个API，&lt;strong&gt;要学习了解技术的本质”&lt;/strong&gt;。可能实际听得比较多的是 &lt;strong&gt;“学习技术原理”&lt;/strong&gt;这句。所以这两个点都会说到，会说一说区别及联系。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;原理，何为原理，技术原理到底在学什么？&lt;/p&gt;
&lt;p&gt;本质，何为本质，怎么就算了解掌握技术本质了？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文就来码一码技术原理和技术本质这两个东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、技术原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先说一下「技术原理」这个词，这个应该大家都很熟悉，每每提起甚至感到一丝丝痛苦和折磨，一线互联网公司面试官的最爱，经常拿来挑逗一下面试者，&quot;知道xx技术的实现原理吗？能不能说一说&quot;。&lt;/p&gt;
&lt;p&gt;技术原理即技术背后的 &lt;strong&gt;实现思想、架构设计、代码 &lt;/strong&gt;，学习一个技术的实现原理就是学习这三个方面的内容。&lt;/p&gt;
&lt;p&gt;这三个方面也是层层递进的关系，越来越具体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，思想是宏观的东西，构建起整个技术的理论支撑；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;其次，架构是思想的进一步推敲和论证的产物；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;最后，就是代码了，结合思想和架构设计变成一行行的可执行代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，你看技术原理的路线图和目标就出来了，&lt;strong&gt;第一，学习思想构建起宏观概念 ；第二，学习整体架构及局部架构掌握整体结构的组成和相互之间的关系；第三，学习代码的实现和逻辑。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;举例说明一下，学习 &quot;HashMap原理&quot;，这时候首先应该构建起的是它的数据结构知识即哈希表的概念和特点（其实如果再拔高一点，应当是先建立起各种数据结构和相互之间区别、特点及相关算法的思想和理论知识，当然这个要求就稍微高一些了），然后架构设计因为这是一个具体的类，所以这部分就是类中包含的核心方法及作用，最后就是深入代码，学习具体的代码实现逻辑，比如put方法是怎么存入数据的，又在什么情况下会进行扩容等等。&lt;/p&gt;
&lt;p&gt;如果没有前面部分的思想和理论做支撑， 不建议直接上来就进入到代码细节，会学的很痛苦比较挣扎。发现概念和理论上的盲区，应及时补上，然后在继续代码的学习。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;二、技术本质&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说完技术原理，下面看技术本质。简单理解，&lt;strong&gt;技术的本质就是解决问题&lt;/strong&gt;，将解决问题的前因后果分别具体化研究，展开来说本质就是除过上面说到的技术原理之外，还应该包括 &lt;strong&gt;技术所解决的核心问题 &lt;/strong&gt;和 &lt;strong&gt;应用场景 &lt;/strong&gt;以及 &lt;strong&gt;存在什么样的优势和不足&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总结一下，就是以下3点内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、技术解决的核心问题和应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、技术原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、技术特性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以，你看学习技术本质的路线图和目标也就出来了，&lt;strong&gt;第一，掌握&lt;/strong&gt;技术解决的核心问题和应用场景，即搞明白它可以用来干什么；第二，研究&lt;strong&gt;技术原理，&lt;/strong&gt;&lt;strong&gt;即&lt;/strong&gt;搞明白它为什么可以做到；第三，了解它的技术特性，&lt;strong&gt;&lt;strong&gt;即&lt;/strong&gt;&lt;/strong&gt;搞明白它的优势在哪里。&lt;/p&gt;
&lt;p&gt;拿redis来说，它解决的核心问题是提供高性能的内存数据缓存服务。虽说官方认为它还可以用作数据库和消息代理，但实际应用中更多作为数据的缓存服务。&lt;/p&gt;
&lt;p&gt;技术原理上面专门做了介绍了，读者可以类比理解，这里就不在展开了。&lt;/p&gt;
&lt;p&gt;技术特性即是该项技术与相关其他类似技术相比有什么牛逼的地方，拿redis和memcached比，多数据类型的支持就算redis的一个特性，持久化能力的支持也算是一个特性。特性在做技术选型的时候往往有着至关重要的作用。&lt;/p&gt;
&lt;p&gt;搞清楚一门技术以上4点内容，才算得掌握到技术的本质。&lt;strong&gt;我们再学习技术原理的时候，不妨再加把劲，窥一窥它的技术本质。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;再带大家理解一下「本质」这个词，下面这句是摘自网上的一句话&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;IPFS本质上是一种内容可寻址、版本化、点对点超媒体的分布式存储、传输协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从面上看更像是一句定义，告诉你什么是IPFS，但是加上了本质二字，就让这句话看起来不是那么的简单，而支撑本质二字的背后就是IPFS这个技术的是内容可寻址，具有可以版本化、点对点、分布式传输的特性，解决的核心问题和应用场景就是标准化数据传输过程。&lt;/p&gt;
&lt;p&gt;所以作者一定是窥透了这技术背后的本质内容而总结出这么一句话。希望这里没有让你看糊涂。&lt;/p&gt;
&lt;p&gt;当我们再看到“xx的本质是xx”这种类似的话的时候，希望大家能多思考思考这句话中本质背后的支撑是什么，有点跑题了，收回来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看到，&lt;strong&gt;技术本质包含了技术原理&lt;/strong&gt;，也就是一种包含关系。&lt;/p&gt;
&lt;p&gt;本文就是理清技术原理、技术本质的真正含义和关系，经常我们对这些看似都懂的概念不去深究，而实际上真正搞明白这些东西能够帮助我们搭建自己的知识体系，而且知识结构脉络十分清晰，不易混淆。在学习一门新技术或深入研究一门技术的时候也会有一个清晰的方向和目标。&lt;/p&gt;
&lt;p&gt;最后，随着学的东西越来越多，越往后大家就越会发现概念和理论（也就是思想）的重要性，有清晰的概念和理论体系作为支撑，能让我们的学习事半功倍。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 06:15:00 +0000</pubDate>
<dc:creator>风象南</dc:creator>
<og:description>职场的程序员们或多或少都受到过前辈或领导的指点，应该都听过这么一句话 “学技术不能光会搭建个环境，使几个API，要学习了解技术的本质”。可能实际听得比较多的是 “学习技术原理”这句。所以这两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuboon/p/10443398.html</dc:identifier>
</item>
<item>
<title>使用Peach简化Socket网络通讯协议开发 - 假正经哥哥</title>
<link>http://www.cnblogs.com/xuanye/p/a-lightweight-and-fast-socket-lib-base-on-dotnetty.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuanye/p/a-lightweight-and-fast-socket-lib-base-on-dotnetty.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/697065c1ly1g0ky6oxiznj21hc0gohdu.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Peach是基于&lt;a href=&quot;https://github.com/Azure/DotNetty&quot;&gt;DotNetty&lt;/a&gt;的Socket网络通讯帮助类库，可以帮助开发者简化使用DotNetty，关于DotNetty可参考我之前的&lt;a href=&quot;http://xuanye.github.io/dotnetty-quickstart/&quot;&gt;这篇文章&lt;/a&gt;。&lt;br/&gt;Peach内置实现了一个基于文本协议的CommandLineProtocol，下面的实例以这个协议展开，最后以&lt;a href=&quot;https://github.com/dotbpe/dotbpe&quot;&gt;DotBPE&lt;/a&gt;中Amp协议来介绍下如何扩展自定义协议。&lt;/p&gt;
&lt;p&gt;Github地址: &lt;a href=&quot;https://github.com/xuanye/Peach&quot; class=&quot;uri&quot;&gt;https://github.com/xuanye/Peach&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;添加引用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dotnet nuget add Peach&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要使用Peach编写网络程序，一般只需要三个步骤&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;实现协议传输消息IMessage&lt;/li&gt;
&lt;li&gt;实现协议打包和解包逻辑IProtocol&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;实现ISocketService完成服务端逻辑编写&lt;p&gt;在快速开始的实例中，我们使用内置的CommandLineProtocol，所以省去了步骤1,2让我们开始吧！&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;服务端&quot;&gt;1 服务端&lt;/h2&gt;
&lt;h3 id=&quot;实现myservice&quot;&gt;1.1 实现MyService&lt;/h3&gt;
&lt;p&gt;可分别重写&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;OnConnected&lt;/code&gt; 有客户端连接上的事件&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnDisConnected&lt;/code&gt; 客户端断开连接时的事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnReceive&lt;/code&gt; 收到客户端消息的事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnException&lt;/code&gt; 发生异常时的事件，如异常断开&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class MyService : Peach.AbsSocketService&amp;lt;Peach.Messaging.CommandLineMessage&amp;gt;
{
    private readonly ILogger&amp;lt;MyService&amp;gt; _logger;

    public MyService(ILogger&amp;lt;MyService&amp;gt; logger)
    {
        _logger = logger;
    }
    public override void OnConnected(ISocketContext&amp;lt;CommandLineMessage&amp;gt; context)
    {
        _logger.LogInformation(&quot;client connected from {0}&quot;, context.RemoteEndPoint);
        base.OnConnected(context);
    }

    public override void OnDisconnected(ISocketContext&amp;lt;CommandLineMessage&amp;gt; context)
    {
        _logger.LogInformation(&quot;client disconnected from {0}&quot;, context.RemoteEndPoint);
        base.OnDisconnected(context);
    }

    public override void OnException(ISocketContext&amp;lt;CommandLineMessage&amp;gt; context, Exception ex)
    {
        _logger.LogError(ex,&quot;client from {0}, occ error {1}&quot;, context.RemoteEndPoint,ex.Message);
        base.OnException(context, ex);
    }

    public override void OnReceive(ISocketContext&amp;lt;CommandLineMessage&amp;gt; context, CommandLineMessage msg)
    {
        string replyMessage = string.Empty;
        string replyCmd = string.Empty;
        switch (msg.Command)
        {
            case &quot;echo&quot;:
                replyMessage = msg.Parameters[0];
                replyCmd = &quot;echo&quot;;
                break;
            case &quot;init&quot;:
                replyMessage = &quot;ok&quot;;
                replyCmd = &quot;init_reply&quot;;

                break;
            default:
                replyMessage = &quot;error unknow command&quot;;
                break;
        }


        Task.Run(async () =&amp;gt;
        {
            await context.SendAsync(new CommandLineMessage(replyCmd, replyMessage));
        });
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;挂载服务&quot;&gt;2. 挂载服务&lt;/h3&gt;
&lt;p&gt;服务默认挂载在5566端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void Main(string[] args)
{
    var builder = new HostBuilder()          
    .ConfigureServices((context,services) =&amp;gt;
    {
        //协议
        services.AddSingleton&amp;lt;IProtocol&amp;lt;CommandLineMessage&amp;gt;, CommandLineProtocol&amp;gt;();
        //挂载服务逻辑
        services.AddSingleton&amp;lt;ISocketService&amp;lt;CommandLineMessage&amp;gt;, MyService&amp;gt;();
        //添加挂载的宿主服务
        services.AddTcpServer&amp;lt;CommandLineMessage&amp;gt;();
    })
    .ConfigureLogging(
        logger =&amp;gt;
        {                   
            logger.AddConsole();
        }
    );
    builder.RunConsoleAsync().Wait();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;客户端&quot;&gt;2. 客户端&lt;/h2&gt;
&lt;h3 id=&quot;使用内置的tcpclient&quot;&gt;2.1 使用内置的TcpClient&lt;/h3&gt;
&lt;p&gt;监听接收消息和链接的消息，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TcpClient&amp;lt;CommandLineMessage&amp;gt; client = new TcpClient&amp;lt;CommandLineMessage&amp;gt;(new CommandLineProtocol());
client.OnReceived += Client_OnReceived;
client.OnConnected += Client_OnConnected;

Task.Run(async () =&amp;gt;
{
    //连接服务器
    var socketContext = await client.ConnectAsync(new IPEndPoint(Hey.IPUtility.GetLocalIntranetIP(), 5566));
    //发送消息
    var initCmd = new Hey.Messaging.CommandLineMessage(&quot;init&quot;);
    await socketContext.SendAsync(initCmd);
}).Wait();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可用的事件:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;OnReceived&lt;/code&gt; 当收到服务端消息时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnError&lt;/code&gt; 当通讯发生异常时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnConnected&lt;/code&gt; 当连接上服务器时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnDisconnected&lt;/code&gt; 当与服务端断开链接时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnIdleState&lt;/code&gt; 链接闲置时触发，一般在此事件中发送心跳包&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;自定义协议&quot;&gt;3. 自定义协议&lt;/h2&gt;
&lt;p&gt;Peach支持使用自定义协议，扩展协议需要自行实现两个接口:&lt;/p&gt;
&lt;h3 id=&quot;imessage-接口&quot;&gt;3.1. IMessage 接口&lt;/h3&gt;
&lt;p&gt;实现类具体实现通讯消息的内容载体，只需实现如何获取消息长度的属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IMessage
{
    int Length { get;  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;iprotocol-接口&quot;&gt;3.2. IProtocol 接口&lt;/h3&gt;
&lt;p&gt;实现类需要描述消息头信息和具体打包解包逻辑，头信息描述参见&lt;code&gt;ProtocolMeta&lt;/code&gt;字段描述&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 协议接口
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;TMessage&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
public interface IProtocol&amp;lt;TMessage&amp;gt;
    where TMessage :  Messaging.IMessage
{
    ProtocolMeta GetProtocolMeta();

    TMessage Parse(Buffer.IBufferReader reader);

    void Pack(Buffer.IBufferWriter writer, TMessage message);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;amp协议&quot;&gt;3.3 Amp协议&lt;/h3&gt;
&lt;p&gt;为了更好让读者理解自定义协议的操作，这里以DotBPE中的Amp协议为例，来具体讲解一下，先来看下Amp协议的说明:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      0        1 2 3 4   5 6 7 8     9     10 11 12 13   1415      16171819    20    &amp;lt;length&amp;gt;-21
+------------+----------+---------+------+-------------+---------+---------+--------+------------+
| &amp;lt;ver/argc&amp;gt; | &amp;lt;length&amp;gt; |  &amp;lt;seq&amp;gt;  |&amp;lt;type&amp;gt;| &amp;lt;serviceId&amp;gt; | &amp;lt;msgId&amp;gt; |  &amp;lt;code&amp;gt; | &amp;lt;codec&amp;gt;|   &amp;lt;data&amp;gt;   |
+------------+----------+---------+------+-------------+---------+---------+--------+------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Amp协议固定包头上21个字节，说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ver/argc = 版本 固定填1&lt;/li&gt;
&lt;li&gt;length = 为总包长&lt;/li&gt;
&lt;li&gt;seq = 请求序列号&lt;/li&gt;
&lt;li&gt;type = 消息类型
&lt;ul&gt;&lt;li&gt;1 = Request 请求消息&lt;/li&gt;
&lt;li&gt;2 = Response 响应消息&lt;/li&gt;
&lt;li&gt;3 = Notify 通知消息&lt;/li&gt;
&lt;li&gt;4 = OneWayRequest 调用不关心返回值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;serId = serviceId 服务号&lt;/li&gt;
&lt;li&gt;msgId = msgId 消息ID&lt;/li&gt;
&lt;li&gt;code = 当 type = 0 （请求时）固定传0 ，其他即为响应码，如果响应码不为0 则认为请求失败，具体错误码再定义&lt;/li&gt;
&lt;li&gt;codecType = 编码方式 0=默认 Protobuf 1=MessagePack 2=JSON&lt;/li&gt;
&lt;li&gt;data = 实际的业务数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ampmessage实现&quot;&gt;3.3.1 AmpMessage实现&lt;/h3&gt;
&lt;p&gt;为了避免干扰因素，这里的代码去除了一些，辅助行的字段和方法，AmpMessage其实是主要用于描述头信息的，并且包含body的buffer数据 &lt;code&gt;Data&lt;/code&gt;字段，并实现获取消息体Length的方法（用于发送消息时，计算缓冲区）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class AmpMessage :  Peach.Messaging.IMessage
    {
       /// &amp;lt;summary&amp;gt;
        /// 第一个版本为18个字节头固定长度
        /// &amp;lt;/summary&amp;gt;
        public const int VERSION_0_HEAD_LENGTH = 18;
        /// &amp;lt;summary&amp;gt;
        /// 现有版本21个字节头固定长度
        /// &amp;lt;/summary&amp;gt;
        public const int VERSION_1_HEAD_LENGTH = 21;
        /// &amp;lt;summary&amp;gt;
        /// 状态码
        /// &amp;lt;/summary&amp;gt;
        public int Code { get; set; }

        //0 默认为Protobuf 1 MessagePack 2 = JSON
        public CodecType CodecType { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 实际的请求数据
        /// &amp;lt;/summary&amp;gt;
        public byte[] Data { get; set; }

        public int Length {
            get
            {
                var hl = Version == 0 ? VERSION_0_HEAD_LENGTH : VERSION_1_HEAD_LENGTH;
                if(Data == null)
                {
                    return hl;
                }

                return hl + this.Data.Length;
            }
        }
        
        /// &amp;lt;summary&amp;gt;
        /// 消息标识
        /// &amp;lt;/summary&amp;gt;
        public string Id =&amp;gt; $&quot;{ServiceId}|{MessageId}|{Sequence}&quot;;
        /// &amp;lt;summary&amp;gt;
        /// 调用服务的唯一消息号 确定哪个方法
        /// &amp;lt;/summary&amp;gt;
        public ushort MessageId { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 请求的序列号
        /// &amp;lt;/summary&amp;gt;
        public int Sequence { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 调用服务的唯一服务号 确定哪个服务
        /// &amp;lt;/summary&amp;gt;
        public int ServiceId { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 协议版本0/1
        /// &amp;lt;/summary&amp;gt;
        public byte Version { get; set; }

        public InvokeMessageType InvokeMessageType { get; set; }
    }
    
    public enum InvokeMessageType : byte
    {
        Request = 1,
        Response = 2,
        Notify = 3,
        OnewayRequest=4 //请求且不等待回复
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ampprotocol的实现&quot;&gt;3.3.2 AmpProtocol的实现&lt;/h3&gt;
&lt;p&gt;AmpProtocol中的实现主要是对ProtocolMeta描述，代码中已有详细注释，至于打包和解包，就是根据协议Write或者Read对应的数据类型即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
    /// Amp Protocol
    /// &amp;lt;/summary&amp;gt;
    public class AmpProtocol : IProtocol&amp;lt;AmpMessage&amp;gt;
    {
        private readonly ISerializer _serializer;

        public AmpProtocol(ISerializer serializer)
        {
            this._serializer = serializer;
        }

        static readonly ProtocolMeta AMP_PROTOCOL_META = new ProtocolMeta
        {
            InitialBytesToStrip = 0, //读取时需要跳过的字节数
            LengthAdjustment = -5, //包实际长度的纠正，如果包长包括包头和包体，则要减去Length之前的部分
            LengthFieldLength = 4, //长度字段的字节数 整型为4个字节
            LengthFieldOffset = 1, //长度属性的起始（偏移）位
            MaxFrameLength = int.MaxValue, //最大的数据包字节数
            HeartbeatInterval = 30 * 1000 // 30秒没消息发一个心跳包
        };

        public ProtocolMeta GetProtocolMeta()
        {
            return AMP_PROTOCOL_META;
        }

        public void Pack(IBufferWriter writer, AmpMessage message)
        {
            writer.WriteByte(message.Version);
            writer.WriteInt(message.Length);
            writer.WriteInt(message.Sequence);
            writer.WriteByte((byte)message.InvokeMessageType);

            if (message.Version == 0)
            {
                writer.WriteUShort((ushort)message.ServiceId);
            }
            else
            {
                writer.WriteInt(message.ServiceId);
            }
            writer.WriteUShort(message.MessageId);
            writer.WriteInt(message.Code);
            if(message.Version == 1)
            {
                writer.WriteByte(_serializer.CodecType);
            }

            if (message.Data != null)
            {
                writer.WriteBytes(message.Data);
            }
        }

        public AmpMessage Parse(IBufferReader reader)
        {
            if (reader.ReadableBytes == 0)
            {
                return null;
            }

            var msg = new AmpMessage {Version = reader.ReadByte()};

            int headLength;
            if (msg.Version == 0 )
            {
                headLength = AmpMessage.VERSION_0_HEAD_LENGTH;
                if (reader.ReadableBytes &amp;lt; AmpMessage.VERSION_0_HEAD_LENGTH - 1)
                {
                    throw new RpcCodecException($&quot;decode error ,ReadableBytes={reader.ReadableBytes+1},HEAD_LENGTH={AmpMessage.VERSION_0_HEAD_LENGTH}&quot;);
                }
            }
            else if (msg.Version == 1 )
            {
                headLength = AmpMessage.VERSION_1_HEAD_LENGTH;
                if (reader.ReadableBytes &amp;lt; AmpMessage.VERSION_1_HEAD_LENGTH - 1)
                {
                    throw new RpcCodecException($&quot;decode error ,ReadableBytes={reader.ReadableBytes+1},HEAD_LENGTH={AmpMessage.VERSION_1_HEAD_LENGTH}&quot;);
                }
            }
            else
            {
                throw new RpcCodecException($&quot;decode error ,{msg.Version} is not support&quot;);
            }

            var length = reader.ReadInt();
            msg.Sequence = reader.ReadInt();
            var type = reader.ReadByte();
            msg.InvokeMessageType = (InvokeMessageType)Enum.ToObject(typeof(InvokeMessageType), type);


            msg.ServiceId = msg.Version == 0 ? reader.ReadUShort() : reader.ReadInt();


            msg.MessageId = reader.ReadUShort();
            msg.Code = reader.ReadInt();

            if (msg.Version == 1)
            {
                byte codeType = reader.ReadByte();
                if (codeType != this._serializer.CodecType)
                {
                    throw  new RpcCodecException($&quot;CodecType:{codeType} is not Match {this._serializer.CodecType}&quot;);
                }
                msg.CodecType = (CodecType)Enum.ToObject(typeof(CodecType), codeType);
            }
            else
            {
                msg.CodecType = CodecType.Protobuf;
            }

            int left = length - headLength;
            if (left &amp;gt; 0)
            {
                if (left &amp;gt; reader.ReadableBytes)
                {
                    throw new RpcCodecException(&quot;message not long enough!&quot;);
                }
                msg.Data = new byte[left];
                reader.ReadBytes(msg.Data);
            }
            return msg;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;后记&quot;&gt;4. 后记&lt;/h2&gt;
&lt;p&gt;Peach的产生主要是源于对DotBPE的重构，因为在其他项目中有关于通讯的其他需求，所以这块虽然比较简单，也可比较独立，所以单独开了一个库来实现对DotNetty的封装。另外欢迎各位dotnet core的同学一起学习交流 QQ群号：699044833&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 06:13:00 +0000</pubDate>
<dc:creator>假正经哥哥</dc:creator>
<og:description>Peach是基于[DotNetty][1]的Socket网络通讯帮助类库，可以帮助开发者简化使用DotNetty，关于DotNetty可参考我之前的[这篇文章][2]。 Peach内置实现了一个基于文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuanye/p/a-lightweight-and-fast-socket-lib-base-on-dotnetty.html</dc:identifier>
</item>
<item>
<title>从2015年百度站长的一则公告回头看百度的骚操作 - Julian_酱</title>
<link>http://www.cnblogs.com/mi12205599/p/10439409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mi12205599/p/10439409.html</guid>
<description>&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;         百度曾&lt;a href=&quot;https://ziyuan.baidu.com/wiki/404&quot; target=&quot;_blank&quot;&gt;公告&lt;/a&gt;于2015年6月25日正式取消Referer中关于关键词的显示。&lt;a title=&quot;百度取消Referer中关键词显示 公告&quot; href=&quot;https://ziyuan.baidu.com/wiki/404&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1.什么是Referer？有什么作用？&lt;/h3&gt;
&lt;p&gt;          Referer请求头包含浏览器进入到当前页时前一页的地址（如果存在），用于在当前请求中体现前一页的信息。Referer标头允许服务器识别人们访问它们的位置，并可以使用该数据进行分析，记录或优化缓存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Referer请求头由浏览器自动添加&lt;/li&gt;
&lt;li&gt;Referer无形中提供了很多功能： 防盗链、站点优化；同时也衍生了一些安全和隐私性问题&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.为什么要取消Referer中关键词的显示？&lt;/h3&gt;
&lt;p&gt;          根据Referer的作用，按照常规做法，在我们从百度关键词搜索结果&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=8&amp;amp;rsv_bp=1&amp;amp;tn=25017023_10_pg&amp;amp;wd=referer&quot; target=&quot;_blank&quot;&gt;页面A&lt;/a&gt; 进入某站点目标页B，进入B页面的Referer请求头包含页面A地址。&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201902/587720-20190227130053174-746536879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该请求存在被运营商劫持、DNS劫持、广告劫持的风险：网络传输链路节点能从Referer中轻松拿到用户的百度关键词信息，是一个较大的隐私风险。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;        不是说百度完成全站HTTPS化吗？怎么还会有DNS劫持，请注意，是百度全站完成HTTPS化，并不是目标站点完成HTTPS， 该请求可能还是一个HTTP请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;         百度在完成全站HTTPS化后决心 在隐私性上更进一步，因此宣布全面取消Referer关键词显示。&lt;/p&gt;

&lt;h3&gt;3. Referer的变化对生态链各方造成了什么影响？&lt;/h3&gt;
&lt;p&gt;            BAT形成中国互联网界上三座大山，各自形成了独立的护城河和生态链，老虎一声吼，地球抖一抖。 很多公司依赖百度的搜索功能提供增值服务，形成了完整的产业链。&lt;/p&gt;
&lt;p&gt;百度全面取消Referer关键词显示的技术实现给各方造成了影响&lt;span&gt;（注意，百度是取消了Referer中关键词的显示，不是去掉了Referer）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  　①  从终端用户角度看，我们从词条搜索结果A进入某站点目标页B，中间会发生浏览器跳转，这在网速慢的时候很明显。&lt;/p&gt;
&lt;p&gt; 　 ②  DNS劫持者和一些公共WIFI&lt;/p&gt;
&lt;p&gt;　　　    影响最大的应该是DNS劫持者和一些公共WIFI，百度这块的隐私数据已经彻底被掐断。&lt;/p&gt;
&lt;p&gt;　  ③ 一些实力差的网盟将退出历史舞台&lt;/p&gt;
&lt;p&gt;　　　　许多号称有大数据背景的网盟本质上来说，都是从百度的搜索行为拿数据。从百度启用HTTPS，取消REFERER中的关键字以后，大量依靠这款数据的网盟公司在短期内广告展现质量会迅速下降。还有有一些广告联盟的大块广告分销商就是做DNS劫持的，这些网盟恐怕以后日子更不好过了。&lt;/p&gt;
&lt;p&gt;      ④ 统计工具&lt;/p&gt;
&lt;p&gt;    　　   无法获取Referer中的关键字以后，除了知道一个流量来自百度以外其他无从知晓。所以百度的搜索份额还是保留在统计中的，但是无法基于此做进一步分析了。 缺失搜索数据的统计工具，是挖掘不出多少价值的。百度关闭了一扇门，打开了一扇窗，百度提供了自有的百度系统计工具和API 开放给第三方工具进行后续挖掘。 &lt;/p&gt;

&lt;h3&gt;4. 技术角度分析是怎样完成这样的骚操作的？&lt;/h3&gt;
&lt;p&gt;        依照上面常规的请求图： A-&amp;gt;B； 当我们点击A页面中连接跳转到B页面，B页面里面Referer值就是A页面地址。&lt;/p&gt;
&lt;p&gt;　　Referer 是浏览器自动添加的，不能删除，那可考虑在进入B网页时&lt;strong&gt;“&lt;/strong&gt;替换”Referer。&lt;/p&gt;
&lt;p&gt;　　百度引入了&lt;strong&gt;中间页P&lt;/strong&gt;来完成这个&lt;strong&gt;“&lt;/strong&gt;替换”操作：  A-&amp;gt;P-&amp;gt;B， B的Referer已经变成了网页P。&lt;/p&gt;

&lt;p&gt;下图演示了&lt;strong&gt;&lt;em&gt;从&lt;/em&gt;&lt;em&gt;&lt;strong&gt;百&lt;/strong&gt;度搜索结果页面A，选中任意一个结果链接进入目标站点网页B的过程&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;div&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201902/587720-20190227132642478-520100258.png&quot; alt=&quot;&quot;/&gt;

&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt; 由于有了这个中间页P，那么关键词的显示与否就由百度站点一手控制了&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt; 中间页P由百度生成，P页面的Referer正是A，但是我们无法抓取P请求（域名也在百度）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt; 进入着陆页B的Referer请求头是中间页P，而P的关键词信息已经加密。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;使用Fiddler验证（搜索关键词 WebDissector）:&lt;/p&gt;
&lt;p&gt;     ①  网页A中的原始搜索结果链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201902/587720-20190226194044107-364110015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;      ② 点击任意结果链接时原始链接被附加了 &amp;amp;wd=&amp;amp;eqid=******* , 形成完整的中间页P&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201902/587720-20190226194104351-1716925299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 仔细探究中间页P的响应体：&lt;/p&gt;
&lt;div readability=&quot;26.856213017751&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;content &lt;/span&gt;&lt;span&gt;= &quot;always&quot;&lt;/span&gt;&lt;span&gt;
name &lt;/span&gt;&lt;span&gt;= &quot;referrer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (window.opener &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; window.opener.bds &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; window.opener.bds.pdc &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; window.opener.bds.pdc.sendLinkLog) {
        window.opener.bds.pdc.sendLinkLog();
    }
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; timeout &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;bdlksmp&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.test(window.location.href)) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; reg &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;bdlksmp=([^=&amp;amp;]+)&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;,
        matches &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; window.location.href.match(reg);
    timeout &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; matches[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt; matches[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] : &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
};
setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    window.location.replace(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.webdissector.cn/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}, timeout);
window.opener &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;noscript&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;META &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;refresh&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;0;URL='https://www.webdissector.cn/'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;noscript&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码的功能大致是：如果浏览器支持Javascript，则通过js跳转到目标页面，如果浏览器不支持Javascript，那么也能通过最后的Meta标签让浏览器实现跳转。&lt;/p&gt;

&lt;p&gt;　　中间页P的url：www.baidu.com/link?url=g19mr6kuOtd-rH0lnHN1SRvGiCevp5qQam2vVd-X4WNPesjKS1uRiu98tV49REXl&amp;amp;&lt;strong&gt;wd=&amp;amp;eqid=b03f3d7e00007893000000025a911952&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;　　可以看到原来的wd（代表原始搜索词）已经隐藏，后面的eqid值是加密后的word，&lt;/p&gt;
&lt;p&gt;     （单一搜索结果页面被附加的是同一个eqid）。&lt;/p&gt;

&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;　　讲完了技术实现，百度真是用心良苦，回归应用，流量关键词作为站长关注的首选重点，是数字营销和用户行为分析领域中必须玩转的技术功能点。&lt;/p&gt;
&lt;div readability=&quot;9.7106109324759&quot;&gt;       百度云为了满足站长获取网站流量关键词的数据分析需求提供了精细化的百度搜索Referer关键词数据服务，在百度云网络环境内提供实时和批量获取API，站长通过提供其网站Referer关键词的eqid可以获取对应的Referer关键词： &lt;a href=&quot;https://cloud.baidu.com/solution/marketing/referer.html&quot; target=&quot;_blank&quot;&gt;API文档&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 27 Feb 2019 06:05:00 +0000</pubDate>
<dc:creator>Julian_酱</dc:creator>
<og:description>背景 百度曾公告于2015年6月25日正式取消Referer中关于关键词的显示。 1.什么是Referer？有什么作用？ Referer请求头包含浏览器进入到当前页时前一页的地址（如果存在），用于在当</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mi12205599/p/10439409.html</dc:identifier>
</item>
<item>
<title>Docker最全教程之树莓派和Docker（十五） - 雪雁</title>
<link>http://www.cnblogs.com/codelove/p/10443221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codelove/p/10443221.html</guid>
<description>&lt;p&gt;树莓派（Raspberry Pi）是一台卡片电脑（只有信用卡大小），我们可以使用树莓派做很多事情，比如智能家居的中控、航空器、BT下载器、挖矿机、智能机器人、小型服务器（花生壳+网站）等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前，支持 Linux 的 IoT 设备越来越多，比如本文中的树莓派。而Docker，在物联网这块，也提供了一个优秀的解决方案。一方面，真正做到了一次编译，到处运行（包括各种loT设备），而且还很轻量，另一方面，镜像的差异化更新可以减轻低带宽网络上的压力, 减少连接设备所需的时间量和降低故障概率，使更频繁地应用更新成为可能。同时，Docker在边缘计算这块也大有可为。物联网这块，这是个长远的话题，我们后续再来探讨。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227133640833-1988611150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;什么是树莓派&lt;/h2&gt;
&lt;p&gt;树莓派（Raspberry Pi）是一台卡片电脑（只有信用卡大小），其系统基于Linux。可以安装Windows 10 IoT。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;树莓派虽小，可是五脏俱全！连上网线，接上鼠标键盘显示器，就是一台微型电脑了！我们可以使用树莓派做很多事情，比如智能家居的中控、航空器、BT下载器、挖矿机、智能机器人、小型服务器（花生壳+网站）等等。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.raspberrypi.org/&quot; href=&quot;https://www.raspberrypi.org/&quot; target=&quot;_blank&quot;&gt;https://www.raspberrypi.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;树莓派官网有很多实验项目，有兴趣的朋友可以去多多尝试：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://projects.raspberrypi.org/zh-CN/projects&quot; href=&quot;https://projects.raspberrypi.org/zh-CN/projects&quot; target=&quot;_blank&quot;&gt;https://projects.raspberrypi.org/zh-CN/projects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227133843727-1702957263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;树莓派的价格也非常便宜，基本上200多就可以入手一台，具体大家可以上淘宝：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227133921146-353141260.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227133933368-1462400221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相关参数（3B+）如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227133949037-1562318664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;艺术照看过了，我们上几张实景图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134039115-158431423.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134106523-805116161.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.3328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Mt5QjqkFG0poNgJx5V3S9ibav9TYQibZuXHRRgrSbOHqxVgo7XQIlDRjnHWym6uon4TZWMkE42K84BKlAQicRHOicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;开启SSH&lt;/h2&gt;
&lt;p&gt;SSH我们在之前已经讲过，主要是用于远程登录。不过在自带的树莓派系统之中，开启SSH比较简单。我们可以使用sudo raspi-config 进入配置界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134151821-1114884348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后选择【Advanced Options】：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134205793-1590365975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;选择【A4 SSH】来启用SSH服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134227828-1903384384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;安装Docker&lt;/h2&gt;
&lt;p&gt;和之前一样，我们使用ssh来安装Docker。这里我们使用快捷脚本安装：&lt;/p&gt;
&lt;p&gt;1. 使用ssh连接树莓派&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134245369-250982922.png&quot; alt=&quot;&quot;/&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.3480791618160652&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Mt5QjqkFG0poNgJx5V3S9ibav9TYQibZuXl2e2vpAaAD9cEJLOhPzl13P594vVCnVNCRX92UribNqGKnrBdyJSjrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;859&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 使用快捷脚本安装。&lt;/p&gt;
&lt;p&gt;如有疑问，可以回顾之前的教程，这里我们直接执行以下脚本：&lt;/p&gt;
&lt;p&gt;curl -fsSL https://get.docker.com -o get-docker.sh&lt;/p&gt;
&lt;p&gt;sh get-docker.sh&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134415189-1905118410.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;“dpkg ”是“Debian Packager ”的简写。为 “Debian” 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自“Debian”的“Linux ”发行版都使用 “dpkg”，例如 “Ubuntu”、“Knoppix ”等。dpkg是Debian软件包管理器的基础，在刚才安装docker时，dpkg被中断，我们可以使用“sudo dpkg --configure -a”命令来重新配置和释放所有的软件包。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134433840-1374070540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.27727645611156687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Mt5QjqkFG0poNgJx5V3S9ibav9TYQibZuXfBMnEHbVJBNRvVBibSPibzgHGBj3Bp4zLuXLFZXiaVkmCU8QVjSTuHvsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1219&quot;/&gt; &lt;/p&gt;
&lt;p&gt;然后再次执行安装脚本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134455333-868340263.jpg&quot; alt=&quot;&quot;/&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.27727645611156687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Mt5QjqkFG0poNgJx5V3S9ibav9TYQibZuXaIvFq0TH9UMCqc7YJZA62OggFaVMx2MdhGukviamwbSlAd52psYxElA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1219&quot;/&gt;&lt;/p&gt;

&lt;p&gt;直到安装成功： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134515607-443585677.png&quot; alt=&quot;&quot;/&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6835443037974683&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Mt5QjqkFG0poNgJx5V3S9ibav9TYQibZuXfmkHhCYgPNpEzfhkbI1Ew1LCzVic1wgic9QM9AWia0lgyGic8L8RjBliauA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;553&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;运行.&lt;/strong&gt;&lt;strong&gt;NET Core Demo&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Docker在物联网这块，提供了一个优秀的解决方案。一方面，真正做到了一次编译，到处运行（包括各种loT设备），而且还很轻量，另一方面，镜像的差异化更新可以减轻低带宽网络上的压力, 减少连接设备所需的时间量和降低故障概率，使更频繁地应用更新成为可能。同时，Docker在边缘计算这块也大有可为。这里，我们不做深入的挖掘，后续我会专门讲述。&lt;/p&gt;
&lt;p&gt;Docker安装成功后，我们可以运行一个demo，来检测下我们的成果——比如运行.NET Core 的官方Demo，具体命令如下所示：&lt;/p&gt;
&lt;p&gt;docker run --name aspnetcore_sample --rm -it -p 8000:80 microsoft/dotnet-samples:aspnetapp&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134535490-2088114767.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;主机端口我们绑定了8000端口，因此我们可以通过IP和端口访问aspnetcore_sample：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201902/70544-20190227134554208-223705494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问速度非常快，在某些场景下，我们可以配合花生壳基于树莓派搭建一个简单的站点，然后利用容器的特级权限来搞些不一样的事情。说到容器特级权限，接下来我们在TeamCity的搭建教程中来穿插讲解。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 05:47:00 +0000</pubDate>
<dc:creator>雪雁</dc:creator>
<og:description>前言 树莓派（Raspberry Pi）是一台卡片电脑（只有信用卡大小），我们可以使用树莓派做很多事情，比如智能家居的中控、航空器、BT下载器、挖矿机、智能机器人、小型服务器（花生壳+网站）等等。 目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codelove/p/10443221.html</dc:identifier>
</item>
</channel>
</rss>