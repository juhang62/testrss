<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【深入学习MySQL】MySQL的索引结构为什么使用B+树？ - 编程迷思</title>
<link>http://www.cnblogs.com/kismetv/p/11582214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kismetv/p/11582214.html</guid>
<description>&lt;h2 align=&quot;center&quot;&gt;前言&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作索引结构(这里不考虑hash等其他索引)。本文将从最普通的二叉查找树开始，逐步说明各种树解决的问题以及面临的新问题，从而说明MySQL为什么选择B+树作为索引结构。&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/11582214.html#t1&quot;&gt;一、二叉查找树(BST)：不平衡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/11582214.html#t2&quot;&gt;二、平衡二叉树(AVL)：旋转耗时&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/11582214.html#t3&quot;&gt;三、红黑树：树太高&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/11582214.html#t4&quot;&gt;四、B树：为磁盘而生&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/11582214.html#t5&quot;&gt;五、B+树&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/11582214.html#t6&quot;&gt;六、感受B+树的威力&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/11582214.html#t7&quot;&gt;七、总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;二叉查找树(BST，Binary Search Tree)，也叫二叉排序树，在二叉树的基础上需要满足：任意节点的左子树上所有节点值不大于根节点的值，任意节点的右子树上所有节点值不小于根节点的值。如下是一颗BST(&lt;a href=&quot;https://blog.csdn.net/qq_25940921/article/details/82183093&quot; target=&quot;_blank&quot;&gt;图片来源&lt;/a&gt;)。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1174710/201909/1174710-20190925074809219-1463846213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当需要快速查找时，将数据存储在BST是一种常见的选择，因为此时查询时间取决于树高，平均时间复杂度是O(lgn)。然而，&lt;strong&gt;BST&lt;/strong&gt;&lt;strong&gt;可能长歪而变得不平衡&lt;/strong&gt;，如下图所示(&lt;a href=&quot;https://blog.csdn.net/qq_25940921/article/details/82183093&quot; target=&quot;_blank&quot;&gt;图片来源&lt;/a&gt;)，此时BST退化为链表，时间复杂度退化为O(n)。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，引入了平衡二叉树。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1174710/201909/1174710-20190925074822219-428720198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;AVL树是严格的平衡二叉树，所有节点的左右子树高度差不能超过1；AVL树查找、插入和删除在平均和最坏情况下都是O(lgn)。&lt;/p&gt;
&lt;p&gt;AVL实现平衡的关键在于旋转操作：插入和删除可能破坏二叉树的平衡，此时需要通过一次或多次树旋转来重新平衡这个树。当插入数据时，最多只需要1次旋转(单旋转或双旋转)；但是当删除数据时，会导致树失衡，AVL需要维护从被删除节点到根节点这条路径上所有节点的平衡，旋转的量级为O(lgn)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于旋转的耗时，AVL&lt;/strong&gt;&lt;strong&gt;树在删除数据时效率很低&lt;/strong&gt;；在删除操作较多时，维护平衡所需的代价可能高于其带来的好处，因此AVL实际使用并不广泛。&lt;/p&gt;

&lt;p&gt;与AVL树相比，红黑树并不追求严格的平衡，而是大致的平衡：只是确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。从实现来看，红黑树最大的特点是每个节点都属于两种颜色(红色或黑色)之一，且节点颜色的划分需要满足特定的规则(具体规则略)。红黑树示例如下（&lt;a href=&quot;https://www.jianshu.com/p/1dbbee88c9d9&quot; target=&quot;_blank&quot;&gt;图片来源&lt;/a&gt;）：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1174710/201909/1174710-20190925074849294-796902926.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;与AVL树相比，红黑树的查询效率会有所下降，这是因为树的平衡性变差，高度更高。但红黑树的删除效率大大提高了，因为红黑树同时引入了颜色，当插入或删除数据时，只需要进行O(1)次数的旋转以及变色就能保证基本的平衡，不需要像AVL树进行O(lgn)次数的旋转。总的来说，红黑树的统计性能高于AVL。&lt;/p&gt;
&lt;p&gt;因此，在实际应用中，AVL树的使用相对较少，而红黑树的使用非常广泛。例如，Java中的TreeMap使用红黑树存储排序键值对；Java8中的HashMap使用链表+红黑树解决哈希冲突问题(当冲突节点较少时，使用链表，当冲突节点较多时，使用红黑树)。&lt;/p&gt;
&lt;p&gt;对于数据在内存中的情况（如上述的TreeMap和HashMap），红黑树的表现是非常优异的。但是&lt;strong&gt;对于数据在磁盘等辅助存储设备中的情况（如&lt;/strong&gt;&lt;strong&gt;MySQL&lt;/strong&gt;&lt;strong&gt;等数据库），红黑树并不擅长，因为红黑树长得还是太高了&lt;/strong&gt;。当数据在磁盘中时，磁盘IO会成为最大的性能瓶颈，设计的目标应该是尽量减少IO次数；而树的高度越高，增删改查所需要的IO次数也越多，会严重影响性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B&lt;/strong&gt;&lt;strong&gt;树也称B-&lt;/strong&gt;&lt;strong&gt;树(&lt;/strong&gt;&lt;strong&gt;其中-&lt;/strong&gt;&lt;strong&gt;不是减号)&lt;/strong&gt;&lt;strong&gt;，是为磁盘等辅存设备设计的多路平衡查找树，与二叉树相比，B&lt;/strong&gt;&lt;strong&gt;树的每个非叶节点可以有多个子树。&lt;/strong&gt;因此，当总节点数量相同时，B树的高度远远小于AVL树和红黑树(B树是一颗“矮胖子”)，磁盘IO次数大大减少。&lt;/p&gt;
&lt;p&gt;定义B树最重要的概念是阶数(Order)，对于一颗m阶B树，需要满足以下条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个节点最多包含 m 个子节点。&lt;/li&gt;
&lt;li&gt;如果根节点包含子节点，则至少包含 2 个子节点；除根节点外，每个非叶节点至少包含 m/2 个子节点。&lt;/li&gt;
&lt;li&gt;拥有 k 个子节点的非叶节点将包含 k - 1 条记录。&lt;/li&gt;
&lt;li&gt;所有叶节点都在同一层中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看出，B树的定义，主要是对非叶结点的子节点数量和记录数量的限制。&lt;/p&gt;
&lt;p&gt;下图是一个3阶B树的例子（&lt;a href=&quot;https://www.2cto.com/net/201808/773535.html&quot; target=&quot;_blank&quot;&gt;图片来源&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1174710/201909/1174710-20190925074904497-1088606861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B树的优势除了树高小，还有对访问局部性原理的利用。所谓局部性原理，是指当一个数据被使用时，其附近的数据有较大概率在短时间内被使用。B树将键相近的数据存储在同一个节点，当访问其中某个数据时，数据库会将该整个节点读到缓存中；当它临近的数据紧接着被访问时，可以直接在缓存中读取，无需进行磁盘IO；换句话说，B树的缓存命中率更高。&lt;/p&gt;
&lt;p&gt;B树在数据库中有一些应用，如mongodb的索引使用了B树结构。但是在很多数据库应用中，使用了是B树的变种B+树。&lt;/p&gt;

&lt;p&gt;B+树也是多路平衡查找树，其与B树的区别主要在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;B树中每个节点（包括叶节点和非叶节点）都存储真实的数据，B+树中只有叶子节点存储真实的数据，非叶节点只存储键。在MySQL中，这里所说的真实数据，可能是行的全部数据（如Innodb的聚簇索引），也可能只是行的主键（如Innodb的辅助索引），或者是行所在的地址（如MyIsam的非聚簇索引）。&lt;/li&gt;
&lt;li&gt;B树中一条记录只会出现一次，不会重复出现，而B+树的键则可能重复重现——一定会在叶节点出现，也可能在非叶节点重复出现。&lt;/li&gt;
&lt;li&gt;B+树的叶节点之间通过双向链表链接。&lt;/li&gt;
&lt;li&gt;B树中的非叶节点，记录数比子节点个数少1；而B+树中记录数与子节点个数相同。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由此，B+树与B树相比，有以下优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;更少的IO次数：&lt;/strong&gt;&lt;/span&gt;B+树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比B数多很多（即阶m更大），因此B+树的高度更低，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;更适于范围查询：&lt;/strong&gt;&lt;/span&gt;在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要对链表进行遍历即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;更稳定的查询效率：&lt;/span&gt;&lt;/strong&gt;B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;B+树也存在劣势：由于键会重复出现，因此会占用更多的空间。但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树的在数据库中的使用比B树更加广泛。&lt;/p&gt;

&lt;p&gt;前面说到，B树/B+树与红黑树等二叉树相比，最大的优势在于树高更小。实际上，对于Innodb的B+索引来说，树的高度一般在2-4层。下面来进行一些具体的估算。&lt;/p&gt;
&lt;p&gt;树的高度是由阶数决定的，阶数越大树越矮；而阶数的大小又取决于每个节点可以存储多少条记录。Innodb中每个节点使用一个页(page)，页的大小为16KB，其中元数据只占大约128字节左右(包括文件管理头信息、页面头信息等等)，大多数空间都用来存储数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于非叶节点，记录只包含索引的键和指向下一层节点的指针。假设每个非叶节点页面存储1000条记录，则每条记录大约占用16字节；当索引是整型或较短的字符串时，这个假设是合理的。延伸一下，我们经常听到建议说索引列长度不应过大，原因就在这里：索引列太长，每个节点包含的记录数太少，会导致树太高，索引的效果会大打折扣，而且索引还会浪费更多的空间。&lt;/li&gt;
&lt;li&gt;对于叶节点，记录包含了索引的键和值(值可能是行的主键、一行完整数据等，具体见前文)，数据量更大。这里假设每个叶节点页面存储100条记录(实际上，当索引为聚簇索引时，这个数字可能不足100；当索引为辅助索引时，这个数字可能远大于100；可以根据实际情况进行估算)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于一颗3层B+树，第一层(根节点)有1个页面，可以存储1000条记录；第二层有1000个页面，可以存储1000*1000条记录；第三层(叶节点)有1000*1000个页面，每个页面可以存储100条记录，因此可以存储1000*1000*100条记录，即1亿条。而对于二叉树，存储1亿条记录则需要26层左右。&lt;/p&gt;

&lt;p&gt;最后，总结一下各种树解决的问题以及面临的新问题：&lt;/p&gt;
&lt;p&gt;1)       二叉查找树(BST)：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表；&lt;/p&gt;
&lt;p&gt;2)       平衡二叉树(AVL)：通过旋转解决了平衡的问题，但是旋转操作效率太低；&lt;/p&gt;
&lt;p&gt;3)       红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多；&lt;/p&gt;
&lt;p&gt;4)       B树：通过将二叉树改为多路平衡查找树，解决了树过高的问题；&lt;/p&gt;
&lt;p&gt;5)       B+树：在B树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。&lt;/p&gt;

&lt;p&gt;《MySQL技术内幕：InnoDB存储引擎》&lt;/p&gt;
&lt;p&gt;《MySQL运维内参》&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/54102723&lt;/p&gt;
&lt;p&gt;https://cloud.tencent.com/developer/article/1425604&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/whoamiyang/article/details/51926985&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/37436ed14cc6&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/CrankZ/article/details/83301702&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/gaochundong/p/btree_and_bplustree.html&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;创作不易，如果文章对你有帮助，就点个赞、评个论呗~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创作不易，如果文章对你有帮助，就点个赞、评个论呗~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创作不易，如果文章对你有帮助，就点个赞、评个论呗~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Sep 2019 00:33:00 +0000</pubDate>
<dc:creator>编程迷思</dc:creator>
<og:description>在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作索引结构(这里不考虑hash等其他索引)。本文将从最普通的二叉查找树开始，逐步说明各种树解决的问题以及面临的新问题，从而说明MySQ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kismetv/p/11582214.html</dc:identifier>
</item>
<item>
<title>Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来 - __yuanhao</title>
<link>http://www.cnblogs.com/yuanhao-1999/p/11582265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanhao-1999/p/11582265.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;谷歌为了帮助开发者解决 Android 架构设计问题，在 Google I/O 2017 发布一套帮助开发者解决 Android 架构设计的方案：Android Architecture Components，而我们的 Room 正是这套方案的两大模块之一。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义：数据库解决方案&lt;/li&gt;
&lt;li&gt;组成：Database、Entity、DAO&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;p&gt;为了方便开发者进行学习和理解，Google 在 GitHub 上上传了一系列的 Android Architecture Components 开源代码：&lt;a href=&quot;https://github.com/googlesamples/android-architecture-components&quot;&gt;googlesamples/android-architecture-components&lt;/a&gt; 本文就是通过解析这套范例的第一部分：&lt;a href=&quot;https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample&quot;&gt;BasicRxJavaSample&lt;/a&gt; 来对 Room 的使用进行分析。&lt;/p&gt;
&lt;p&gt;关于本文中的代码以及后续文章中的代码，我已经上传至我的 GitHub 欢迎大家围观、star&lt;br/&gt;详见-&amp;gt; &lt;a href=&quot;https://github.com/FishInWater-1999/ArchitectureComponentsStudy&quot;&gt;FishInWater-1999/ArchitectureComponentsStudy&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h4 id=&quot;为什么我们要学-room&quot;&gt;为什么我们要学 Room&lt;/h4&gt;
&lt;p&gt;相比于我们直接使用传统方式，如果直接使用 &lt;code&gt;Java&lt;/code&gt; 代码进行 &lt;code&gt;SQLite&lt;/code&gt; 操作，每次都需要手写大量重复的代码，对于我们最求梦想的程序员来说，这种无聊的过程简直是一种折磨。于是，&lt;code&gt;Room&lt;/code&gt; 也就应运而生了&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它通过注解处理器的形式，将繁琐无趣的代码封装起来，我们只需要添加一个简单的注解，就可以完成一系列复杂的功能！&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先我们需要了解下 &lt;code&gt;Room&lt;/code&gt; 的基本组成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们已经说过 Room 的使用，主要由 Database、Entity、DAO 三大部分组成，那么这三大组成部分又分别是什么呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Database：创建一个由 Room 管理的数据库，并在其中自定义所需要操作的数据库表&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;要求&quot;&gt;要求：&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;   1. 必须是abstract类而且的extends RoomDatabase。

   2. 必须在类头的注释中包含与数据库关联的实体列表(Entity对应的类)。

   3. 包含一个具有0个参数的抽象方法，并返回用@Dao注解的类。&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;使用&quot;&gt;使用：&lt;/h6&gt;
&lt;p&gt;通过单例模式实现，你可以通过静态 getInstance(...) 方法，获取数据库实例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public static UsersDatabase getInstance(Context context)&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Entity：数据库中，某个表的实体类，如：&lt;br/&gt;&lt;code&gt;@Entity(tableName = &quot;users&quot;)&lt;/code&gt;&lt;br/&gt;&lt;code&gt;public class User {...}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DAO：具体访问数据库的方法的接口&lt;br/&gt;&lt;code&gt;@Dao&lt;/code&gt;&lt;br/&gt;&lt;code&gt;public interface UserDao {...}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;basicrxjavasample-源码解析&quot;&gt;# BasicRxJavaSample 源码解析&lt;/h2&gt;
&lt;p&gt;由于是源码解析，那我就以：从基础的类开始，一层层向上，抽丝剥茧，最后融为一体的方式，给大家进行解析。那么现在就让我们开始吧。&lt;/p&gt;
&lt;h4 id=&quot;表的搭建&quot;&gt;表的搭建&lt;/h4&gt;
&lt;p&gt;Room 作为一个 Android 数据库操作的注解集合，最基本操作就是对我们数据库进行的。所以，先让我们试着建立一张名为 “users” 的数据表&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 应用测试的表结构模型
 */
@Entity(tableName = &quot;users&quot;)// 表名注解
public class User {

    /**
     * 主键
     * 由于主键不能为空，所以需要 @NonNull 注解
     */
    @NonNull
    @PrimaryKey
    @ColumnInfo(name = &quot;userid&quot;)// Room 列注解
    private String mId;

    /**
     * 用户名
     * 普通列
     */
    @ColumnInfo(name = &quot;username&quot;)
    private String mUserName;

    /**
     * 构造方法
     * 设置为 @Ignore 将其忽视
     * 这样以来，这个注解方法就不会被传入 Room 中，做相应处理
     * @param mUserName
     */
    @Ignore
    public User(String mUserName){
        this.mId    = UUID.randomUUID().toString();
        this.mUserName = mUserName;
    }

    /**
     * 我们发现与上个方法不同，该方法没有标记 @Ignore 标签
     * 
     * 所以编译时该方法会被传入 Room 中相应的注解处理器，做相应处理
     * 这里的处理应该是 add 新数据
     * @param id
     * @param userName
     */
    public User(String id, String userName) {
        this.mId = id;
        this.mUserName = userName;
    }

    public String getId() {
        return mId;
    }

    public String getUserName() {
        return mUserName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先在表头部分，我们就见到了之前说过的 &lt;code&gt;@Entity(...)&lt;/code&gt; 标签，之前说过该标签表示数据库中某个表的实体类，我们查看它的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface Entity {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从中我们可以知道该注解实在编译注解所在的类时触发的，这是我们注意到 Google 对该类的介绍是：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;Marks a class as an entity. This class will have a mapping SQLite table in the database.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可知当注解所在的类，比如我们的这个 &lt;code&gt;User&lt;/code&gt; 类编译时，相应的注解处理器就会调用其内部相应的代码，建立一个名为 &lt;code&gt;users&lt;/code&gt; （在 &lt;code&gt;@Entity(tableName = &quot;users&quot;)&lt;/code&gt; 中传入的数据表 ）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们再往下看：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@ColumnInfo(name = &quot;userid&quot;) ：该注解注解的数据成员，将会在表中生成相应的名为：&lt;code&gt;userid&lt;/code&gt; 的列&lt;/li&gt;
&lt;li&gt;@PrimaryKey ：顾名思义该注解与&lt;code&gt;@ColumnInfo(name = &quot;...&quot;)&lt;/code&gt; 注解一起使用，表示表中的主键，这里要注意一点，在 &lt;code&gt;@Entity&lt;/code&gt; 的源码中强调：Each entity must have at least 1 field annotated with {@link PrimaryKey}. 也就是说一个被 &lt;code&gt;@Entity(...)&lt;/code&gt; 标注的数据表类中至少要有一个主键&lt;/li&gt;
&lt;li&gt;@Ignore ：被该注解注释的数据成员、方法，将会被注解处理器忽略，不进行处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们发现，代码中有存在两个构造方法，为什么 GoogleSample 中会存在这种看似多此一举的情况呢？我们再仔细观察就会发想，上方的构造方法标记了 &lt;code&gt;@Ignore&lt;/code&gt; 标签，而下方的构造方法却没有。由于在 &lt;code&gt;@Entity&lt;/code&gt; 标注的类中，构造方法和列属性的 &lt;code&gt;get()&lt;/code&gt; 方法都会被注解处理器自动识别处理。我们就不难想到，Google 之所以这样设计，是因为我们于是需要创建临时的 &lt;code&gt;User&lt;/code&gt; 对象，但我们又不希望 &lt;code&gt;@Entity&lt;/code&gt; 在我们调用构造方法时，就将其存入数据库。所以我们就有了这个被 &lt;code&gt;@Ignore&lt;/code&gt; 的构造方法，用于创建不被自动存入数据库的临时对象，等到我们想将这个对象存入数据库时，调用&lt;code&gt;User(String id, String userName)&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h4 id=&quot;userdao&quot;&gt;UserDao&lt;/h4&gt;
&lt;p&gt;上面我们通过 &lt;code&gt;@Entity&lt;/code&gt; 建立了一张 &lt;code&gt;users&lt;/code&gt; 表，下面就让我们用 &lt;code&gt;@Dao&lt;/code&gt; 注解来变写 &lt;code&gt;UserDao&lt;/code&gt; 接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Dao
public interface UserDao {

    /**
     * 为了简便，我们只在表中存入1个用户信息
     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可
     * @return
     */
    @Query(&quot;SELECT * FROM Users LIMIT 1&quot;)
    Flowable&amp;lt;User&amp;gt; getUser();

    /**
     * 想数据库中插入一条 User 对象
     * 若数据库中已存在，则将其替换
     * @param user
     * @return
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    Completable insertUser(User user);

    /**
     * 清空所有数据
     */
    @Query(&quot;DELETE FROM Users&quot;)
    void deleteAllUsers();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照我们正常编写的习惯，我们会在该类中，编写相应的数据库操作代码。但与之不同的是采用 &lt;code&gt;Room&lt;/code&gt; 之后，我们将其变为一个接口类，并且只需要编写和设定相应的标签即可，不用再去关心存储操作的具体实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 为了简便，我们只在表中存入1个用户信息
     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可
     * @return
     */
    @Query(&quot;SELECT * FROM Users LIMIT 1&quot;)
    Flowable&amp;lt;User&amp;gt; getUser();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们看到，该查询方法使用的是 &lt;code&gt;@Query&lt;/code&gt; 注解，那么这个注解的具体功能是什么呢？Google 官方对它的解释是：在一个被标注了 &lt;code&gt;@Dao&lt;/code&gt; 标签的类中，用于查询的方法。顾名思义被该注解标注的方法，会被 &lt;code&gt;Room&lt;/code&gt; 的注解处理器识别，当作一个数据查询方法，至于具体的查询逻辑并不需要我们关心，我们只需要将 &lt;code&gt;SQL 语句&lt;/code&gt; 作为参数，传入 &lt;code&gt;@Query(...)&lt;/code&gt; 中即可。之后我们发现，该方法返回的是一个背压 &lt;code&gt;Flowable&amp;lt;...&amp;gt;&lt;/code&gt; 类型的对象，这是为了防止表中数据过多，读取速率远大于接收数据，从而导致内存溢出的问题，具体详见 &lt;code&gt;RxJava&lt;/code&gt; 的教程，这里我就不赘述了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 想数据库中插入一条 User 对象
     * 若数据库中已存在，则将其替换
     * @param user
     * @return
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    Completable insertUser(User user);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到，上述方法被 &lt;code&gt;@Insert&lt;/code&gt; 注解所标注，从名字就能看出，这将会是一个插入方法。顾名思义被 &lt;code&gt;@Insert&lt;/code&gt; 标注的方法，会用于向数据库中插入数据，唯一让我们迷茫的是括号中的这个 &lt;code&gt;onConflict&lt;/code&gt; 参数，&lt;code&gt;onConflict&lt;/code&gt; 意为“冲突”，再联想下我们日常生活中的数据库操作，就不难想到：这是用来设定，当插入数据库中的数据，与原数据发生冲突时的处理方法。这里我们传入的是 &lt;code&gt;OnConflictStrategy.REPLACE&lt;/code&gt; ，意为“如果数据发生冲突，则用其替换掉原数据”，除此之外还有很多相应操作的参数，比如&lt;code&gt;ROLLBACK&lt;/code&gt; &lt;code&gt;ABORT&lt;/code&gt; 等，篇幅原因就不详细说明了，大家可以自行查阅官方文档。还有一点值得说的是这个 &lt;code&gt;Completable&lt;/code&gt; ，该返回值是 &lt;code&gt;RxJava&lt;/code&gt; 的基本类型，它只处理 &lt;code&gt;onComplete&lt;/code&gt; &lt;code&gt;onError&lt;/code&gt; 事件，可以看成是Rx的Runnable。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 清空所有数据
     */
    @Query(&quot;DELETE FROM Users&quot;)
    void deleteAllUsers();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后这个方法就是清空 &lt;code&gt;users&lt;/code&gt; 表中的所有内容，很简单，这里就不做说明了。唯一需要注意的是，这里使用了 &lt;code&gt;DELETE FROM 表名&lt;/code&gt; 的形式，而不是 &lt;code&gt;truncate table 表名&lt;/code&gt; ，区别就在于：效率上&lt;code&gt;truncate&lt;/code&gt;比&lt;code&gt;delete&lt;/code&gt;快，但&lt;code&gt;truncate&lt;/code&gt; 相当于保留表的结构，重新创建了这个表，所以删除后不记录日志，不可以恢复数据。&lt;/p&gt;
&lt;h4 id=&quot;usersdatabase&quot;&gt;UsersDatabase&lt;/h4&gt;
&lt;p&gt;有关于 &lt;code&gt;Room&lt;/code&gt; 的三大组成我们已经讲完了两个，现在就让我们看看最后一个 &lt;code&gt;@Database&lt;/code&gt; 注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Database(entities = {User.class}, version = 1, exportSchema = false)
public abstract class UsersDatabase extends RoomDatabase {
    /**
     * 单例模式
     * volatile 确保线程安全
     * 线程安全意味着改对象会被许多线程使用
     * 可以被看作是一种 “程度较轻的 synchronized”
     */
    private static volatile UsersDatabase INSTANCE;

    /**
     * 该方法由于获得 DataBase 对象
     * abstract
     * @return
     */
    public abstract UserDao userDao();

    public static UsersDatabase getInstance(Context context) {
        // 若为空则进行实例化
        // 否则直接返回
        if (INSTANCE == null) {
            synchronized (UsersDatabase.class) {
                if (INSTANCE == null){
                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),
                            UsersDatabase.class, &quot;Sample.db&quot;)
                            .build();
                }
            }
        }
        return INSTANCE;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老样子， &lt;code&gt;Google&lt;/code&gt; 定义中是这么写的：将一个类标记为 &lt;code&gt;Room&lt;/code&gt; 数据库。顾名思义，我们需要在标记了该标签的类里，做具体的数据库操作，比如数据库的建立、版本更新等等。我们看到，我们向其中传入了多个参数，包括：&lt;code&gt;entities&lt;/code&gt; 以数组结构，标记一系列数据库中的表，这个例子中我们只有一个 &lt;code&gt;User&lt;/code&gt; 表，所以只传入一个； &lt;code&gt;version&lt;/code&gt; 数据库版本；&lt;code&gt;exportSchema&lt;/code&gt; 用于历史版本库的导出&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 单例模式
     * volatile 确保线程安全
     * 线程安全意味着改对象会被许多线程使用
     * 可以被看作是一种 “程度较轻的 synchronized”
     */
    private static volatile UsersDatabase INSTANCE;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出这是一个单例模式，用于创建一个全局可获得的 UsersDatabase 对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static UsersDatabase getInstance(Context context) {
        // 若为空则进行实例化
        // 否则直接返回
        if (INSTANCE == null) {
            synchronized (UsersDatabase.class) {
                if (INSTANCE == null){
                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),
                            UsersDatabase.class, &quot;Sample.db&quot;)
                            .build();
                }
            }
        }
        return INSTANCE;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是单例模式对象 INSTANCE 的获得方法，不明白的同学可以去看我这篇 &lt;a href=&quot;https://blog.csdn.net/qq_43377749/article/details/96324909&quot;&gt;单例模式-全局可用的 context 对象，这一篇就够了&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;userdatasource&quot;&gt;UserDataSource&lt;/h4&gt;
&lt;p&gt;我们可以看到：绝大多数的数据库操作方法，都定义在了 &lt;code&gt;UserDao&lt;/code&gt; 中，虽然一般注解类的方法不会被继承，但是有些被特殊标记的方法可能会被继承，但是我们之后要建立的很多功能类中，都需要去调用 &lt;code&gt;UserDao&lt;/code&gt; 里的方法。所以我们这里定义 &lt;code&gt;UserDataSource&lt;/code&gt; 接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface UserDataSource {

    /**
     * 从数据库中读取信息
     * 由于读取速率可能 远大于 观察者处理速率，故使用背压 Flowable 模式
     * Flowable：https://www.jianshu.com/p/ff8167c1d191/
     */
    Flowable&amp;lt;User&amp;gt; getUser();


    /**
     * 将数据写入数据库中
     * 如果数据已经存在则进行更新
     * Completable 可以看作是 RxJava 的 Runnale 接口
     * 但他只能调用 onComplete 和 onError 方法，不能进行 map、flatMap 等操作
     * Completable：https://www.jianshu.com/p/45309538ad94
     */
    Completable insertOrUpdateUser(User user);


    /**
     * 删除所有表中所有 User 对象
     */
    void  deleteAllUsers();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该接口很简单，就是一个工具，方法和 &lt;code&gt;UserDao&lt;/code&gt; 一摸一样，这里我们就不赘述了。&lt;/p&gt;
&lt;h4 id=&quot;localuserdatasource&quot;&gt;LocalUserDataSource&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LocalUserDataSource implements UserDataSource {

    private final UserDao mUserDao;

    public LocalUserDataSource(UserDao userDao) {
        this.mUserDao = userDao;
    }

    @Override
    public Flowable&amp;lt;User&amp;gt; getUser() {
        return mUserDao.getUser();
    }

    @Override
    public Completable insertOrUpdateUser(User user) {
        return mUserDao.insertUser(user);
    }

    @Override
    public void deleteAllUsers() {
        mUserDao.deleteAllUsers();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看看官方的解析：“使用 &lt;code&gt;Room&lt;/code&gt; 数据库作为一个数据源。”即通过该类的对象所持有的 &lt;code&gt;UserDao&lt;/code&gt; 对象，进行数据库的增删改查操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;到此为止，有关于 Room 对数据库的操作部分就讲完了，接下来我们进行视图层搭建的解析。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;userviewmodel&quot;&gt;UserViewModel&lt;/h4&gt;
&lt;p&gt;首先我们先实现 &lt;code&gt;ViewModel&lt;/code&gt; 类，那什么是 &lt;code&gt;ViewModel&lt;/code&gt; 类呢？从字面上理解的话，它肯定是跟视图 &lt;code&gt;View&lt;/code&gt; 以及数据 &lt;code&gt;Model&lt;/code&gt; 相关的。其实正像它字面意思一样，它是负责准备和管理和UI组件 &lt;code&gt;Fragment/Activity&lt;/code&gt; 相关的数据类，也就是说 &lt;code&gt;ViewModel&lt;/code&gt; 是用来管理UI相关的数据的，同时 &lt;code&gt;ViewModel&lt;/code&gt; 还可以用来负责UI组件间的通信。那么现在就来看看他的具体实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserViewModel extends ViewModel {

    /**
     * UserDataSource 接口
     */
    private final UserDataSource mDataSource;

    private User mUser;

    public UserViewModel(UserDataSource dataSource){
        this.mDataSource = dataSource;
    }

    /**
     * 从数据库中读取所有 user 名称
     * @return 背压形式发出所有 User 的名字
     *
     * 由于数据库中 User 量可能很大，可能会因为背压导致内存溢出
     * 故采用 Flowable 模式，取代 Observable
     */
    public Flowable&amp;lt;String&amp;gt; getUserName(){
        return mDataSource.getUser()
                .map(new Function&amp;lt;User, String&amp;gt;() {
                    @Override
                    public String apply(User user) throws Exception {
                        return user.getUserName();
                    }
                });
    }

    /**
     * 更新/添加 数据
     *
     * 判断是否为空，若为空则创建新 User 进行存储
     * 若不为空，说明该 User 存在，这获得其主键 'getId()' 和传入的新 Name 拼接，生成新 User 存储
     * 通过 insertOrUpdateUser 接口，返回 Comparable 对象，监听是否存储成功
     * @param userName
     * @return
     */
    public Completable updateUserName(String userName) {
        mUser = mUser == null
                ? new User(userName)
                : new User(mUser.getId(), userName);
        return mDataSource.insertOrUpdateUser(mUser);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码结构非常简单，&lt;code&gt;mDataSource&lt;/code&gt; 就是我们前面建立的 &lt;code&gt;UserDataSource&lt;/code&gt; 接口对象，由于我们的数据库操作控制类：&lt;code&gt;LocalUserDataSource&lt;/code&gt; 是通过是实现该接口的，所以我们就可以在外部将 &lt;code&gt;LocalUserDataSource&lt;/code&gt; 对象传入，从而对他的方法进行相应的回调，也就是先实现了所需的数据库操作。每个方法的功能，我已经在注释中给出，这里就不再赘述&lt;/p&gt;
&lt;h4 id=&quot;viewmodelfactory&quot;&gt;ViewModelFactory&lt;/h4&gt;
&lt;p&gt;有上面我们可以看到，我们已经有了进行数据处理的 &lt;code&gt;ViewModel&lt;/code&gt; 类，那么我们这里的 &lt;code&gt;ViewModelFactory&lt;/code&gt; 类又有什么作用呢？让我们先看下范例中的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ViewModelFactory implements ViewModelProvider.Factory {

    private final UserDataSource mDataSource;

    public ViewModelFactory(UserDataSource dataSource) {
        mDataSource = dataSource;
    }

    // 你需要通过 ViewModelProvider.Factory 的 create 方法来创建(自定义的) ViewModel
    // 参考文档：https://medium.com/koderlabs/viewmodel-with-viewmodelprovider-factory-the-creator-of-viewmodel-8fabfec1aa4f
    @Override
    public &amp;lt;T extends ViewModel&amp;gt; T create(@NonNull Class&amp;lt;T&amp;gt; modelClass) {
        // 为什么这里用 isAssignableFrom 来判断传入的 modelClass 类的类型， 而不直接用 isInstance 判断？
        // 答：二者功能一样，但如果传入值（modelClass 为空）则 isInstance 会报错奔溃，而 isAssignableFrom 不会
        if (modelClass.isAssignableFrom(UserViewModel.class)) {
            return (T) new UserViewModel(mDataSource);
        }
        throw new IllegalArgumentException(&quot;Unknown ViewModel class&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ViewModelFactory&lt;/code&gt; 继承自 &lt;code&gt;ViewModelProvider.Factory&lt;/code&gt; ，它负责帮你创建 &lt;code&gt;ViewModel&lt;/code&gt; 实例。但你也许会问，我们不是已经有了 &lt;code&gt;ViewModel&lt;/code&gt; 的构造方法了吗？在用 &lt;code&gt;ViewModelFactory&lt;/code&gt; 不是多此一举？如果还不熟悉 &lt;code&gt;ViewModelFactory&lt;/code&gt; 有关内容的，可以看下这篇：&lt;a href=&quot;https://blog.csdn.net/qq_43377749/article/details/100856599&quot;&gt;ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;injection&quot;&gt;Injection&lt;/h4&gt;
&lt;p&gt;关于 &lt;code&gt;Injection&lt;/code&gt; ，这是个帮助类，它和 Room 的逻辑功能并没有关系。&lt;code&gt;Sample&lt;/code&gt; 中将其独立出来用于各个对象、类型的注入，先让我们看下该类的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Injection {

    /**
     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象
     * @param context
     * @return
     */
    public static UserDataSource provideUserDateSource(Context context) {
        // 获得 RoomDatabase
        UsersDatabase database = UsersDatabase.getInstance(context);
        // 将可操作 UserDao 传入
        // 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作
        return new LocalUserDataSource(database.userDao());
    }

    /**
     * 获得 ViewModelFactory 对象
     * 为 ViewModel 实例化作准备
     * @param context
     * @return
     */
    public static ViewModelFactory provideViewModelFactory(Context context) {
        UserDataSource dataSource = provideUserDateSource(context);
        return new ViewModelFactory(dataSource);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该类有两个方法组成，实现了各个类型数据相互间的转换，想再让我们先看下第一个方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象
     * @param context
     * @return
     */
    public static UserDataSource provideUserDateSource(Context context) {
        // 获得 RoomDatabase
        UsersDatabase database = UsersDatabase.getInstance(context);
        // 将可操作 UserDao 传入
        // 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作
        return new LocalUserDataSource(database.userDao());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该方法中，我们首先接到了我们的 &lt;code&gt;context&lt;/code&gt; 对象，通过 &lt;code&gt;UsersDatabase.getInstance(context)&lt;/code&gt; 方法，让 &lt;code&gt;database&lt;/code&gt; 持有 &lt;code&gt;context&lt;/code&gt; ，实现数据库的链接和初始化。同时放回一个 &lt;code&gt;LocalUserDataSource&lt;/code&gt; 对象，这样一来我们就可以对数据表中的内容惊醒相应的操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 获得 ViewModelFactory 对象
     * 为 ViewModel 实例化作准备
     * @param context
     * @return
     */
    public static ViewModelFactory provideViewModelFactory(Context context) {
        UserDataSource dataSource = provideUserDateSource(context);
        return new ViewModelFactory(dataSource);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法的功能非常明确，就是为我们实例化出一个 &lt;code&gt;ViewModelFactory&lt;/code&gt; 对象，为我们往后创建 &lt;code&gt;ViewModel&lt;/code&gt; 作准备。可以看到，这里我们调用了前面的 &lt;code&gt;provideUserDateSource&lt;/code&gt; 方法，通过该方法获得了对数据库操作的 &lt;code&gt;LocalUserDataSource&lt;/code&gt; 对象，这里我们就看到了单例模式使用的先见性，使得数据库不会被反复的创建、连接。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;好了，至此所有准备工作都已经完成，让我们开始视图层 UserActivity 的调用&lt;/li&gt;
&lt;li&gt;由于 &lt;code&gt;UserActivity&lt;/code&gt; 的内容较多我就不贴完整的代码，我们逐步进行讲解&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;准备数据成员&quot;&gt;准备数据成员&lt;/h4&gt;
&lt;p&gt;首先我们准备了所需的给类数据成员：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private static final String TAG = UserActivity.class.getSimpleName();

    private TextView mUserName;

    private EditText mUserNameInput;

    private Button mUpdateButton;
    // 一个 ViewModel 用于获得 Activity &amp;amp; Fragment 实例
    private ViewModelFactory mViewModelFactory;
    // 用于访问数据库
    private UserViewModel mViewModel;
    // disposable 是订阅事件，可以用来取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。
    private final CompositeDisposable mDisposable = new CompositeDisposable();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先界面操作的各个控件&lt;/li&gt;
&lt;li&gt;接这就是 &lt;code&gt;mViewModelFactory&lt;/code&gt; 、 &lt;code&gt;mViewModel&lt;/code&gt; 两个数据成员，用于负责数据源的操作&lt;/li&gt;
&lt;li&gt;再就是一个 &lt;code&gt;CompositeDisposable&lt;/code&gt; 对象，用于管理订阅事件，防止 Activity 结束后，订阅仍在进行的情况&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;oncreate&quot;&gt;onCreate&lt;/h4&gt;
&lt;p&gt;控件、数据源层、数据库等的初始化&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_user);

        mUserName = findViewById(R.id.user_name);
        mUserNameInput = findViewById(R.id.user_name_input);
        mUpdateButton = findViewById(R.id.update_user);

        // 实例化 ViewModelFactory 对象，准备实例化 ViewModel
        mViewModelFactory = Injection.provideViewModelFactory(this);
        mViewModel = new ViewModelProvider(this, mViewModelFactory).get(UserViewModel.class);
        mUpdateButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                updateUserName();
            }
        });
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先是各类控件的初始化&lt;/li&gt;
&lt;li&gt;接着是 &lt;code&gt;ViewModel&lt;/code&gt; 的初始化，在这过程中，也就实现了数据库的链接&lt;/li&gt;
&lt;li&gt;用户信息按钮监听器绑定，点击执行 &lt;code&gt;updateUserName&lt;/code&gt; 方法如下&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;updateusername&quot;&gt;updateUserName&lt;/h4&gt;
&lt;p&gt;修改数据库中用户信息&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private void updateUserName() {
        String userName = mUserNameInput.getText().toString();
        // 在完成用户名更新之前禁用“更新”按钮
        mUpdateButton.setEnabled(false);
        // 开启观察者模式
        // 更新用户信息，结束后重新开启按钮
        mDisposable.add(mViewModel.updateUserName(userName)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Action() {
            @Override
            public void run() throws Exception {
                mUpdateButton.setEnabled(true);
            }
        }, new Consumer&amp;lt;Throwable&amp;gt;() {
            @Override
            public void accept(Throwable throwable) throws Exception {
                Log.d(TAG, &quot;accept: Unable to update username&quot;);
            }
        }));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;获得新的用户名&lt;/li&gt;
&lt;li&gt;将按钮设为不可点击&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;io&lt;/code&gt; 线程中访问数据库进行修改&lt;/li&gt;
&lt;li&gt;切换到主线程进行相应处理，比如让按钮恢复到可点击状态&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;onstart&quot;&gt;onStart&lt;/h4&gt;
&lt;p&gt;初始化用户信息，修改 &lt;code&gt;UI&lt;/code&gt; 界面内容&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    protected void onStart() {
        super.onStart();
        // 观察者模式
        // 通过 ViewModel 从数据库中读取 UserName 显示
        // 如果读取失败，显示错误信息
        mDisposable.add(mViewModel.getUserName()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Consumer&amp;lt;String&amp;gt;() {
            @Override
            public void accept(String s) throws Exception {
                mUserName.setText(s);
            }
        }, new Consumer&amp;lt;Throwable&amp;gt;() {
            @Override
            public void accept(Throwable throwable) throws Exception {
                Log.e(TAG, &quot;Unable to update username&quot;);
            }
        }));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;io&lt;/code&gt; 线程中进行数据库访问&lt;/li&gt;
&lt;li&gt;切换到主线程，修改 &lt;code&gt;UI&lt;/code&gt; 信息&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;onstop&quot;&gt;onStop&lt;/h4&gt;
&lt;p&gt;取消订阅&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    protected void onStop() {
        super.onStop();
        // 取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。
        mDisposable.clear();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过我们之前实例化的 &lt;code&gt;CompositeDisposable&lt;/code&gt; 对象，解除订阅关系&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h4 id=&quot;demo-地址&quot;&gt;Demo 地址&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/FishInWater-1999/ArchitectureComponentsStudy&quot;&gt;ArchitectureComponentsStudy&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;学会使用 &lt;code&gt;Android Architecture Components&lt;/code&gt; 提供的组件简化我们的开发，能够使我们开发的应用模块更解耦更稳定，视图与数据持久层分离，以及更好的扩展性与灵活性。最后，码字不易，别忘了点个关注哦&lt;/p&gt;
</description>
<pubDate>Wed, 25 Sep 2019 00:31:00 +0000</pubDate>
<dc:creator>__yuanhao</dc:creator>
<og:description>相比于我们直接使用传统方式，如果直接使用 `Java` 代码进行 `SQLite` 操作，每次都需要手写大量重复的代码，对于我们最求梦想的程序员来说，这种无聊的过程简直是一种折磨。于是，`Room`</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanhao-1999/p/11582265.html</dc:identifier>
</item>
<item>
<title>和微信公众号编辑器战斗的日子 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11579918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11579918.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190924180656600-1941410313.jpg&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;br/&gt;作者：&lt;strong&gt;灵魂画师牧码&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.5714285714286&quot;&gt;
&lt;p&gt;本文提到的 Markdown Nice 体验地址：&lt;strong&gt;&lt;a href=&quot;https://mdnice.com&quot; class=&quot;uri&quot;&gt;https://mdnice.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公元 2019 年，微信公众号排版能力孱弱，始终为运营者所诟病，秀米、135 编辑器等工具割据一方。&lt;/p&gt;
&lt;p&gt;但无论是微信原生工具，还是其他编辑器，都让创作者不得不将有限的创作经历分散到排版设计上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 解决排版的灵丹妙药，应运而生。&lt;/p&gt;
&lt;h2 id=&quot;一引子&quot;&gt;一、引子&lt;/h2&gt;
&lt;h3 id=&quot;markdown-是什么&quot;&gt;1.1 Markdown 是什么？&lt;/h3&gt;
&lt;p&gt;Markdown 是一种排版语法，拥有极简的输入方式和极低的学习成本。&lt;/p&gt;
&lt;p&gt;富含了标题、引用、加粗、链接、图片、代码段、公式等一切在文字创作中需要的排版格式。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;拥有它，让人专注于内容本身，而不被格式所打扰。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E8%AF%B7%E5%8B%BF%E6%89%93%E6%89%B0_20190923093136.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;怎么和微信公众号结合&quot;&gt;1.2 怎么和微信公众号结合？&lt;/h3&gt;
&lt;p&gt;这么优秀的排版语法，可是微信公众号也不支持呀。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;别急！Markdown Nice 来帮你解决问题！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;markdown-nice-是什么&quot;&gt;1.3 Markdown Nice 是什么？&lt;/h3&gt;
&lt;p&gt;一款开源 Markdown 编辑器，写完后即排版成功，复制即可粘贴到微信公众号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;So what？ 只有这点么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然不是！Nice宝宝你还有什么特性呀？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E4%B9%96%E5%B7%A7_20190923093136.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持图床、脚注、代码、公式&lt;/li&gt;
&lt;li&gt;支持 8 种排版主题和 7 种代码主题&lt;/li&gt;
&lt;li&gt;支持自定义样式，可提交主题供人瞻仰&lt;/li&gt;
&lt;li&gt;除了公众号外，还支持知乎、掘金、博客园和CSDN等平台&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我颜值高呀&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E5%AE%8C%E6%95%B4%E9%A1%B5%E9%9D%A2_20190923093136.png&quot; alt=&quot;完整界面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这么多优秀的特性摆在你面前，还在等什么？&lt;/p&gt;
&lt;p&gt;地址：&lt;code&gt;https://mdnice.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快让你的微信排版 Nice 起来！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二正文&quot;&gt;二、正文&lt;/h2&gt;
&lt;p&gt;&lt;del&gt;没想到你还在看&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;咳咳、、、&lt;/p&gt;
&lt;p&gt;不要小看Nice宝宝我，为了能够使用 Markdown 进行公众号排版，我可是和微信公众号编辑器做了半年的斗争，才赢得了现在的战果！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E8%88%92%E6%9C%8D%E4%B8%8D_20190923093136.gif&quot; alt=&quot;激烈斗争&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想听听我是如何战斗的？下面且听我娓娓道来！&lt;/p&gt;
&lt;h3 id=&quot;战斗序章&quot;&gt;2.1 战斗序章&lt;/h3&gt;
&lt;p&gt;微信公众号编辑器源于百度 FEX 前端团队的开源的 &lt;a href=&quot;http://ueditor.baidu.com&quot; title=&quot;ueditor&quot;&gt;ueditor&lt;/a&gt; 项目，这可是宝宝我扒取了网页代码发现的，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/ueditor_20190923093136.png&quot; alt=&quot;浏览器检查元素&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 ueditor 是富文本编辑器，所以我即将面临的是 &lt;code&gt;markdown-&amp;gt;富文本&lt;/code&gt; 的转换战役，在开源界或者软件界这种转换战役有了相当多的优秀实现。比如：&lt;/p&gt;
&lt;p&gt;但是上述工具都存在一个问题，没有很好地将 &lt;strong&gt;CSS 样式&lt;/strong&gt;融入富文本中，进而适配微信编辑器，以至于国内其他各大平台的富文本编辑器。&lt;/p&gt;
&lt;p&gt;那么有没有尝试弥补这一问题的工具呢？其实是有的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;但是上述工具也各自有不完美的地方，于是Nice宝宝我发现了这个契机，把自己生产了出来，解决一切不完美！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Markdown Nice 是一个开源项目，由很多开源技术合体而成，其中主要包括：&lt;/p&gt;
&lt;p&gt;注：下文会提到上述某些开源库，开源库具体作用请参考此处。&lt;/p&gt;
&lt;p&gt;在拥有上述技术傍身之后，我向微信编辑器宣战，打响了战斗第一枪！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E6%9D%A5%E5%90%A7_20190923093136.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;战斗第一枪代码主题&quot;&gt;2.2 战斗第一枪：代码主题&lt;/h3&gt;
&lt;p&gt;微信公众号在2018年以前，是完全不支持代码块的，目前的支持也很单一，并且存在代码字体较大的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说来很气，微信公众号编辑器的开发者，就木有想过&lt;strong&gt;代码块对程序员群体是多么重要么&lt;/strong&gt;？？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E9%97%AE%E5%8F%B7_20190923093136.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为此我找来了&lt;code&gt;highlight.js&lt;/code&gt;代码高亮神器，帮助解决代码主题单一的问题。&lt;/p&gt;
&lt;p&gt;经过一定的筛选后，最终选定了 atom-one-dark、atom-one-light、monikai、GitHub、vs2015、xcode 和微信代码主题共 7 个代码样式供大家选择。&lt;/p&gt;
&lt;p&gt;其中微信代码主题由于其不属于&lt;code&gt;highlight.js&lt;/code&gt;的归属范畴，故而其结构需要从微信公众号编辑器源码中获取，下面两张图展示了如何获取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E8%8E%B7%E5%8F%96iframe%E7%9A%84id_20190923093136.png&quot; alt=&quot;获取iframe的id&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E4%BB%A3%E7%A0%81%E6%BA%90%E7%A0%81_20190923093136.png&quot; alt=&quot;微信代码块源码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;highlight.js&lt;/code&gt; 与 &lt;code&gt;markdown-it&lt;/code&gt; 解析器是关联使用的，故而工具中存在 2 个 markdown 解析器，分别用于解析微信代码主题和其他代码主题，&lt;a href=&quot;https://github.com/zhning12/markdown-nice/blob/master/src/utils/helper.js#L55-L133&quot; title=&quot;源码参考&quot;&gt;源码参考&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;除了上述问题外，很多技术类公众号代码中会存在：&lt;strong&gt;一行代码过长导致的多行显示问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;该问题使用以下 CSS 代码即可解决：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;pre code {
  display: -webkit-box !important
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比效果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E4%BB%A3%E7%A0%81%E6%8D%A2%E8%A1%8C%E5%92%8C%E4%B8%8D%E6%8D%A2%E8%A1%8C%E5%AF%B9%E6%AF%94_20190923093136.jpg&quot; alt=&quot;代码换行和不换行对比&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从此以后使用 Markdown Nice 的同志们代码更美观啦！&lt;/p&gt;
&lt;h3 id=&quot;战斗第二枪图片上传&quot;&gt;2.3 战斗第二枪：图片上传&lt;/h3&gt;
&lt;p&gt;一篇好的文章怎么可以没有图片？&lt;/p&gt;
&lt;p&gt;（某些技术人员说：我的就没有）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E5%9C%A8%E4%B8%8B%E8%BE%93%E4%BA%86_20190923093136.gif&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;图片管理是每一个成熟编辑器都会遇到的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nice 宝宝最开始使用 &lt;a href=&quot;https://sm.ms/&quot; title=&quot;SM.MS&quot;&gt;SM.MS&lt;/a&gt; 图床，该图床由一位大佬在运维，非常感谢！&lt;/p&gt;
&lt;p&gt;使用该图床虽然能够上传图片，但是粘贴到微信编辑器时，失败率极高（&lt;strong&gt;想踩死微信编辑器&lt;/strong&gt;），如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5_20190923093136.png&quot; alt=&quot;图片上传失败&quot;/&gt;&lt;/p&gt;
&lt;p&gt;真是{喜闻乐见|hē hē hē hē}呀！&lt;/p&gt;
&lt;p&gt;为了解决上述问题，Markdown Nice 先后支持了自定义阿里云和七牛云图床，通过购买阿里云和七牛云的服务使用自建图床。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是！让使用者自己配置，尽管有配置文档，但是整个配置过程复杂无比，简直惨绝人寰！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E5%90%90%E8%A1%80%E8%BA%AB%E4%BA%A1_20190923093136.jpg&quot; alt=&quot;吐血身亡&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，Nice 宝宝又使用自己的账号，自建图床，设定保存时间为一天，提供临时排版使用的 mdnice 图床。至此，工具中的图片上传支持情况如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;mdnice&lt;/td&gt;
&lt;td&gt;免费&lt;/td&gt;
&lt;td&gt;1天&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SM.MS&lt;/td&gt;
&lt;td&gt;免费&lt;/td&gt;
&lt;td&gt;长期&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;阿里云&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://cn.aliyun.com/product/oss&quot; title=&quot;参考&quot;&gt;参考&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;自定义&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;七牛云&lt;/td&gt;
&lt;td&gt;10G免费&lt;/td&gt;
&lt;td&gt;自定义&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E5%9B%9B%E7%A7%8D%E5%9B%BE%E5%BA%8A_20190923093136.png&quot; alt=&quot;四种图床&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这场图床的战役中，最大的难度在于需要阅读阿里云 OSS 和七牛云 KODO 的文档，并且使用其开源出来的工具包 ali-oss 和 qiniu-js 。&lt;/p&gt;
&lt;p&gt;这其中又涉及到了 FormData、file对象、base64 和 blob 之间的神奇转换，&lt;a href=&quot;https://github.com/zhning12/markdown-nice/blob/master/src/component/Dialog/ImageDialog.js&quot; title=&quot;源码参考&quot;&gt;源码参考&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;总之，这场战斗打的不亦乐乎。&lt;/p&gt;
&lt;h3 id=&quot;战斗第三枪数学公式&quot;&gt;2.4 战斗第三枪：数学公式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;微信公众号排版中，数学公式是一个噩梦！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为微信编辑器做了以下三件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不支持公式编辑&lt;/li&gt;
&lt;li&gt;不支持 html 和 css 生成的公式，因为字体无法导入&lt;/li&gt;
&lt;li&gt;不支持 svg，放入后提示失败&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这三件事情简直像魔鬼的步伐，把公式需求者放在光滑的地板上摩擦、摩擦....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E6%91%A9%E6%93%A6%E6%91%A9%E6%93%A6_20190923093136.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前唯一可行的方案就是将公式转换成图片，再将图片直接贴到公众号里，Nice宝宝觉得自己这个想法简直是完美！&lt;/p&gt;
&lt;p&gt;但是，怎么做呢......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E6%B2%89%E6%80%9D_20190923093136.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;忽然灵机一动，想到了朋友曾经推荐的一个转换公式网站 &lt;a href=&quot;https://www.codecogs.com/latex/eqneditor.php&quot; title=&quot;codecogs&quot;&gt;codecogs&lt;/a&gt;，这个网站能够做到将任意公式转换成png图片并给出可访问链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/codecogs_20190923093136.png&quot; alt=&quot;codecogs&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是由于图片稳定性，无法直接使用该链接，会存在和第二场战役一样，图片粘贴失败的情况，让人苦不堪言。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个问题该怎么解决呢？&lt;strong&gt;如果能够自建公式转png图片服务就好了。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;有没有这样的开源库？&lt;strong&gt;有！MathJax-node 就可以！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是Nice宝宝自建后台服务，封装 RESTful 接口供前端调用，实现了公式转图片的功能！经过测试，完全可以使用，粘贴后再根据排版情况调整图片大小即可。&lt;/p&gt;
&lt;p&gt;其中对于大量公式的转换，前端合理使用了异步请求，并非一个个转换而是并行执行，&lt;strong&gt;性能上达到了10个公式也能2秒转换完毕的效果&lt;/strong&gt;，完全可用于公式排版。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E8%BD%AC%E5%85%AC%E5%BC%8F_20190923093137.gif&quot; alt=&quot;转公式&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;战斗第四枪微信外链转脚注&quot;&gt;2.5 战斗第四枪：微信外链转脚注&lt;/h3&gt;
&lt;p&gt;众所周知（不知道也得知道），微信不支持外链，除了域名为&lt;code&gt;https://mp.weixin.qq.com/&lt;/code&gt;的合法链接外，其他的链接出现后都会被自动删除。&lt;/p&gt;
&lt;p&gt;而添加外链的唯一官方方式就是在阅读全文处，当然，直接将链接本身放到文中或者制作二维码图片也是可以的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而 Nice 宝宝则提供了将微信外链转为脚注的方式解决该问题，是不是很优雅呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/fine_20190923093136.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中链接和脚注的使用区别如下：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;链接：[文字](链接 &quot;文字&quot;)
脚注：[文字](脚注解释 &quot;脚注名字&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里又涉及到了一个常见的问题，就是很多公众号作者的文章中，原来在其他平台发布时都是链接，而到这里排版时需要进行挨个修改，实在是让人头大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A9%E4%BA%BA%E5%A4%B4%E5%A4%A7_20190923093136.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是Nice宝宝我又做了一个小改进，就是在粘贴文章的时候会自动监测是否存在外链，并提示作者是否一键转成脚注，这样就不必手工修改了，赞不赞！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E8%87%AA%E5%8A%A8%E8%BD%AC%E8%84%9A%E6%B3%A8_20190923093136.gif&quot; alt=&quot;自动转脚注&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;战役总结&quot;&gt;2.6 战役总结&lt;/h3&gt;
&lt;p&gt;和微信公众号编辑器对抗，是个极其有意思的过程。除了上述提到的问题之外，还有很多的细节点需要注意，在此就不一一讨论了，感兴趣欢迎阅读源码。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Markdown Nice 的战斗之旅还远远没有结束，官网制作、浏览器插件、本地工具和排版纠正等功能蓄势待发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三谈点和战斗无关的&quot;&gt;三、谈点和战斗无关的&lt;/h2&gt;
&lt;h3 id=&quot;设计理念&quot;&gt;3.1 设计理念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;大多数人而言，内容重于排版，排版重于设计。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内容是吸引读者的核心，所以最重要。&lt;/p&gt;
&lt;p&gt;而排版与设计之间的比较，作为一个曾经的微信美术编辑，随着排版经验的增多，发现文章的效果并不在于额外的花边、点缀。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;整齐、舒服、简单是硬道理!&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;内容排版与设计&quot;&gt;3.2 内容、排版与设计&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设计 = 排版 + 创意&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;因为：大多数人不会获取创意，或认为创意成本过高。&lt;/p&gt;
&lt;p&gt;所以：大多数人不做设计，富文本设计不适合单纯的内容编辑者。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;虽然：大多数人也不会排版，或认为排版成本过高。&lt;/p&gt;
&lt;p&gt;但是：&lt;strong&gt;Markdown Nice 将用户从排版中释放出来，只关注内容本身。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于开源&quot;&gt;3.3 关于开源&lt;/h3&gt;
&lt;p&gt;开源是个既简单又困难的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;说简单是因为&lt;/strong&gt;：笔记、书单、工具、平台所有有价值的东西都可以在 GitHub 中输出，做起来很简单&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;说困难是因为&lt;/strong&gt;：努力做到对别人有价值，始终坚持输出，做起来很困难&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正如上面描述的那样，做开源其实是在做一款产品，有可能是技术产品（比如 redis、ant design），也有可能是业务产品（比如 Markdown Nice），只有做好了才可能对别人产生价值。&lt;/p&gt;
&lt;p&gt;做产品的过程曲折而漫长，对照 Markdown Nice 开发过程，可以看到以下的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;要有一个 idea，并且验证其可行性和必要性，去和同类产品比较，做到心中有数&lt;/li&gt;
&lt;li&gt;抓住痛点，掌握核心价值，站在用户角度思考，多听反馈意见&lt;/li&gt;
&lt;li&gt;螺旋上升，不断迭代，产出精品&lt;/li&gt;
&lt;li&gt;最最重要一点，&lt;strong&gt;做产品不只要写代码，还要宣传呀！！酒香也怕巷子深！！&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参与开源，一路走来，甚是不易，望君珍惜。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最后，感谢每一位开源参与者，欢迎更多人参与到开源中来，还有好多代码等着有人来写呢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://draw-wechat.oss-cn-hangzhou.aliyuncs.com/%E8%B5%B7%E6%9D%A5%E5%B9%B2%E6%B4%BB_20190923093136.gif&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Wed, 25 Sep 2019 00:17:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：灵魂画师牧码 本文提到的 Markdown Nice 体验地址： https://mdnice.com 公元 2019 年，微信公众号排版能力孱弱，始终为运营者所诟病，秀米、135 编辑器等工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11579918.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 3.0 : 二十五. TagHelper - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore_25.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore_25.html</guid>
<description>&lt;p&gt;　　什么是TagHelper？这是ASP.NET Core 中新出现的一个名词，它的作用是使服务器端代码可以在Razor 文件中参与创建和呈现HTML 元素。(&lt;a href=&quot;https://www.cnblogs.com/FlyLolo/p/ASPNETCore2_0.html&quot;&gt;ASP.NET Core 系列目录&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;　　上面的解释有点拗口？那么换一个名词，HtmlHelper大家都知道吧，在ASP.NET Core中，TagHelper类似HtmlHelper，但可以说是青出于蓝而胜于蓝。那么TagHelper的作用也就大概明白了吧。&lt;/p&gt;
&lt;p&gt;首先通过一个例子看一下TagHelper是怎么使用的，看看它和HtmlHelper有什么区别。新建一个Book类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book
    {
        [Display(Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Code { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
[Display(Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建对应的Controller和Action：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookController : Controller
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: /&amp;lt;controller&amp;gt;/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;new&lt;/span&gt; Book() { Code = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后就是View了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@model Book
@{
    Layout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}
@Html.LabelFor(m &lt;/span&gt;=&amp;gt;&lt;span&gt; m.Name)
@Html.EditorFor(m &lt;/span&gt;=&amp;gt;&lt;span&gt; m.Name)
&lt;/span&gt;&amp;lt;br /&amp;gt;
&amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
&amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里分别通过HtmlHelper和TagHelper两种方式实现了一个文本和输入框的显示。查看网页源代码，可以看到二者生成的HTML如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Name&amp;lt;/label&amp;gt;
&amp;lt;input &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-box single-line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Name&amp;lt;/label&amp;gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前看起来二者差不多，从工作量上来看也是区别不大。现在功能实现了，需要做一些样式处理。简单举个例子，现在希望Book的编号（Code）对应的label的颜色设置为红色，定义了一个css如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;style type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    .codeColor {
        color:red;
    }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后准备把这个样式应用到label上，这时如果是HtmlHelper就很有可能会被问：“class写在哪”，估计好多人都被问过。然后我们告诉他可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Html.LabelFor(m=&amp;gt;m.Name,&lt;span&gt;new&lt;/span&gt; {@class=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端工程师添加后达到了想要的效果，但同时表示记不住这个写法，下次可能还会问。&lt;/p&gt;
&lt;p&gt;如果是TagHelper就方便了，告诉他可以像平时给Html的标签添加class一样操作即可，也就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端工程师表示这种写法“真是太友好了”。同样对于Form及验证，比较一下两种写法的不同，HtmlHelper版：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@using (Html.BeginForm(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FormMethod.Post)){    
@Html.LabelFor(m &lt;/span&gt;=&amp;gt;&lt;span&gt; m.Code)
    @Html.EditorFor(m &lt;/span&gt;=&amp;gt; m.Code)    @Html.ValidationMessageFor(m =&amp;gt; m.Code)    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TagHelper版：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;form asp-action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; asp-controller=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
    &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在有这样的需求，用于显示Book的编号的label不止要添加名为codeColor的css样式，还要给书的编号自动添加一个前缀，例如“BJ”。&lt;/p&gt;
&lt;p&gt;对于这样的需求，希望可以通过一个简单的标记，然后由TagHelper自动实现。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;label show-type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;1001&lt;/span&gt;&amp;lt;/label&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义了一个属性“show-type”，用于标识这个label的显示类别，“1001”为假定的图书编号。通过这样的设置方式，将来如果需求有变化，需要对编号的显示做更多的修饰，只需修改对应的TagHelper即可，而页面部分不需要做任何调整。&lt;/p&gt;
&lt;p&gt;系统提供了方便的自定义TagHelper的方式，就是继承系统提供的TagHelper类，并重写它的Process/ProcessAsync方法，例如下面的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LabelTagHelper : TagHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (output.Attributes.TryGetAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; TagHelperAttribute showTypeAttribute))
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (showTypeAttribute.Value.ToString().Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                {
                    output.Attributes.SetAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content = output.Content.IsModified ? output.Content.GetContent() : (&lt;span&gt;await&lt;/span&gt;&lt;span&gt; output.GetChildContentAsync()).GetContent(); ;
                    output.Content.SetContent(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; content);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先判断label是否被设置了show-type=&quot;bookCode&quot;，然后获取当前label的Content内容，将其添加前缀“BJ”后作为此label的Content的新内容。注意一下Content的获取方式，如果它没有被修改，凭感觉直接通过output.Content.GetContent()获取到的内容是空的。&lt;/p&gt;
&lt;p&gt;访问index页面，可以看到改标签已被处理，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201909/548134-20190924195003686-1380523059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备注：a.关于获取show-type的值，还可以有其他方式，下文会讲到。&lt;/p&gt;
&lt;p&gt;b.从规范化命名的角度，建议将自定义的TagHelper其命名为XXXagHelper这样的格式。&lt;/p&gt;

&lt;p&gt;TagHelper自定义之后需要将其注册一下，否则它是不会生效的。打开_ViewImports.cshtml，默认为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using TagHelperDemo
@using TagHelperDemo.Models
@addTagHelper &lt;/span&gt;*, Microsoft.AspNetCore.Mvc.TagHelpers
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在最下面添加一条&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@addTagHelper *, TagHelperDemo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后添加的这一句话是什么意思呢？也就是将程序集TagHelperDemo（即第二个参数）中的所有TagHelper（第一个参数为“*”，即所有）全部启用。假如还定义了一个PasswordTagHelper，但只想只添加LabelTagHelper，可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@addTagHelper TagHelperDemo.TagHelpers. LabelTagHelper, TagHelperDemo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想添加所有自定义的TagHelper，但要去除LabelTagHelper呢？&lt;/p&gt;
&lt;p&gt;那么可以先添加所有，再去除这个LabelTagHelper。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@addTagHelper *&lt;span&gt;, TagHelperDemo
@removeTagHelper TagHelperDemo.TagHelpers. LabelTagHelper, TagHelperDemo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在项目中，可能不止使用label标签来显示Book的Code，还有可能会是p、span等类型的标签，现在的需求是，无论是上述哪一种标签，都要实现添加css和前缀的功能。&lt;/p&gt;
&lt;p&gt;现在将index.cshtml中新增一个p标签如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;p show-type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;1002&lt;/span&gt;&amp;lt;/p&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;访问这个页面发现1002未被处理。这是因为我们定义的TagHelper名为LabelTagHelper，在默认的情况下只会处理label标签。当然也可以做特殊设置，例如下面代码的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    [HtmlTargetElement(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LabelTagHelper : TagHelper
    {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代码省略&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过“&lt;span lang=&quot;EN-US&quot;&gt;[HtmlTargetElement(&lt;span lang=&quot;EN-US&quot;&gt;&quot;p&quot;&lt;span lang=&quot;EN-US&quot;&gt;)]”指定本&lt;span lang=&quot;EN-US&quot;&gt;TagHelper只能被使用于&lt;span lang=&quot;EN-US&quot;&gt;p标签。再次访问此页面，发现&lt;span lang=&quot;EN-US&quot;&gt;p标签被处理了，而&lt;span lang=&quot;EN-US&quot;&gt;label未被处理。这说明这样的显式指定的优先级要高于默认的名称匹配。除了设置指定标签，还可以有一些其他的辅助设置：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[HtmlTargetElement(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Attributes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParentTag = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LabelTagHelper : TagHelper
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以这样写，会匹配p标签，要求该标签拥有show-type属性，并且父标签为div。这几个条件是“and”的关系。如果还想匹配label标签，可以添加对label的设置，例如下面代码这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[HtmlTargetElement(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Attributes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParentTag = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[HtmlTargetElement(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Attributes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParentTag = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LabelTagHelper : TagHelper
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个HtmlTargetElement的关系是“or”。通过这样的设置，可以极大的缩小目标标签的范围。&lt;/p&gt;
&lt;p&gt;但是这样设置之后，这个TagHelper的名字再叫LabelTagHelper就不合适了，例如可以改为BookCodeTagHelper，最终代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
[HtmlTargetElement(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Attributes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParentTag = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[HtmlTargetElement(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Attributes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParentTag = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookCodeTagHelper : TagHelper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (output.Attributes.TryGetAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; TagHelperAttribute showTypeAttribute))
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (showTypeAttribute.Value.ToString().Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                output.Attributes.SetAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content = output.Content.IsModified ?&lt;span&gt; output.Content.GetContent() :
                                    (&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; output.GetChildContentAsync()).GetContent(); ;
                output.Content.SetContent(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; content);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想使个别Html标签屏蔽TagHelper的作用，可以使用“!”。例如下面两个标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;!label show-type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;1001&lt;/span&gt;&amp;lt;/label&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上一节最终形成了一个名为BookCodeTagHelper的TagHelper，我们知道LabelTagHelper是可以按名称默认匹配label标签的，那么是否可以自定义一个BookCode标签呢？在index.cshtml中添加这样的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;BookCode&amp;gt;&lt;span&gt;1003&lt;/span&gt;&amp;lt;/BookCode&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于自定义bookcode标签的目的就是专门显示Book的Code，所以也不必添加show-type属性了。然后修改BookCodeTagHelper，修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookCodeTagHelper : TagHelper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        output.Attributes.SetAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content = output.Content.IsModified ?&lt;span&gt; output.Content.GetContent() :
                            (&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; output.GetChildContentAsync()).GetContent(); ;
        output.Content.SetContent(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; content);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;去掉了两个HtmlTargetElement设置并取消了对show-type的判断，访问index页面查看新建的bookcode标签是否会被处理，结果是没有被处理。这是为什么呢？&lt;/p&gt;
&lt;p&gt;这是由于TagHelper会将采用Pascal 大小写格式的类和属性名将转换为各自相应的短横线格式。即“BookCode”对应“book-code”，获取标签的属性值，同样遵循这样的规则。所以将标签改为如下写法即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;book-code&amp;gt;&lt;span&gt;1003&lt;/span&gt;&amp;lt;/book-code&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次运行测试，发现这个新标签被成功处理。查看网页源代码，被处理后的Html代码是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;book-code &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;TJ1003&amp;lt;/book-code&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想将其改变为label，可以在BookCodeTagHelper中通过指定TagName实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookCodeTagHelper : TagHelper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Book { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        output.TagName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        output.Attributes.SetAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content = output.Content.IsModified ?&lt;span&gt; output.Content.GetContent() :
                            (&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; output.GetChildContentAsync()).GetContent(); ;
        output.Content.SetContent(Book.Prefix &lt;/span&gt;+&lt;span&gt; content);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;假如现在的新需求是图书编码的前缀不再固定为“BJ”了，需要在标签中定义，例如这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;book-code prefix=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SH&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;1003&lt;/span&gt;&amp;lt;/book-code&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要获取prefix的值，在上面的例子中采用的是TryGetAttribute方法，其实还有简单的方式，修改BookCodeTagHelper，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookCodeTagHelper : TagHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Prefix { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
        {
            output.Attributes.SetAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content = output.Content.IsModified ?&lt;span&gt; output.Content.GetContent() :
                                (&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; output.GetChildContentAsync()).GetContent(); ;
            output.Content.SetContent(Prefix &lt;/span&gt;+&lt;span&gt; content);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标签中的prefix的值会自动赋值给BookCodeTagHelper.Prefix，是不是更方便了。那么如果是Model中的值呢？假如Book类有一个属性“public string Prefix { get; set; } ”，这和传入一个字符串没什么区别，那么可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;book-code prefix=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@Model.Prefix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;1003&lt;/span&gt;&amp;lt;/book-code&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种传值方式不止是支持字符串，将Model整体传入也是支持的，将标签修改如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;book-code book=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@Model&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;1003&lt;/span&gt;&amp;lt;/book-code&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改BookCodeTagHelper代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookCodeTagHelper : TagHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Book { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
        {
            output.Attributes.SetAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;codeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content = output.Content.IsModified ?&lt;span&gt; output.Content.GetContent() :
                                (&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; output.GetChildContentAsync()).GetContent(); ;
            output.Content.SetContent(Book.Prefix &lt;/span&gt;+&lt;span&gt; content);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前面的几个例子都是对满足条件的标签的修改，TagHelper也可以取消对应标签的输出，例如存在这样一个标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div simple-type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不想让它出现在生成的Html中，可以这样处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[HtmlTargetElement(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Attributes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;simple-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Simple1TagHelpers : TagHelper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SimpleType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process(TagHelperContext context, TagHelperOutput output)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SimpleType.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以是其他一些判断规则&lt;/span&gt;
&lt;span&gt;        {
            output.SuppressOutput();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在TagHelper中，可以用TagBuilder来辅助生成标签，例如存在如下两个div：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div simple-type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div simple-type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;想在div中添加Html元素可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[HtmlTargetElement(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Attributes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;simple-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Simple1TagHelpers : TagHelper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SimpleType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process(TagHelperContext context, TagHelperOutput output)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SimpleType.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        {
            output.Content.SetHtmlContent(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;Simple2&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (SimpleType.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; TagBuilder(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            p.InnerHtml.Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            output.Content.SetHtmlContent(p);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过TagBuilder生成了一个新的p标签，并将它插入到div中。&lt;/p&gt;

</description>
<pubDate>Wed, 25 Sep 2019 00:07:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<og:description>什么是TagHelper？这是ASP.NET Core&amp;#160;中新出现的一个名词，它的作用是使服务器端代码可以在Razor&amp;#160;文件中参与创建和呈现HTML&amp;#160;元素。(ASP.NET</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FlyLolo/p/ASPNETCore_25.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 3.0 使用gRPC - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/11581967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/11581967.html</guid>
<description>&lt;h2 id=&quot;一.简介&quot;&gt;一.简介&lt;/h2&gt;
&lt;p&gt;gRPC 是一个由Google开源的，跨语言的，高性能的远程过程调用（RPC）框架。 gRPC使客户端和服务端应用程序可以透明地进行通信，并简化了连接系统的构建。它使用HTTP/2作为通信协议，使用 Protocol Buffers 作为序列化协议。&lt;/p&gt;
&lt;p&gt;它的主要优点：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;现代高性能轻量级 RPC 框架。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;约定优先的 API 开发，默认使用 Protocol Buffers 作为描述语言，允许与语言无关的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;可用于多种语言的工具，以生成强类型的服务器和客户端。&lt;/li&gt;
&lt;li&gt;支持客户端，服务器和双向调用。&lt;/li&gt;
&lt;li&gt;通过Protocol Buffers二进制序列化减少网络使用。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 HTTP/2 进行传输&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些优点使gRPC非常适合：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高性能轻量级微服务。&lt;/li&gt;
&lt;li&gt;需要多种编程语言同时使用的项目。&lt;/li&gt;
&lt;li&gt;需要处理流式请求或响应的点对点实时服务。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;摘自&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/grpc/index?view=aspnetcore-3.0&quot;&gt;微软官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;支持的语言如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234755499-1863013281.png&quot; alt=&quot;1569301484094&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二.grpc-on-.net-core&quot;&gt;二.gRPC on .NET Core&lt;/h2&gt;
&lt;p&gt;gRPC 现在可以非常简单的在 .NET Core 和 ASP.NET Core 中使用，在 .NET Core 上的实现的开源地址：&lt;a href=&quot;https://github.com/grpc/grpc-dotnet&quot; class=&quot;uri&quot;&gt;https://github.com/grpc/grpc-dotnet&lt;/a&gt; ，它目前由微软官方 ASP.NET 项目的人员进行维护，良好的接入 .NET Core 生态。&lt;/p&gt;
&lt;p&gt;.NET Core 的 gRPC 功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/Grpc.AspNetCore&quot;&gt;Grpc.AspNetCore&lt;/a&gt; 一个用于在ASP.NET Core承载gRPC服务的框架，将 gRPC和ASP.NET Core 功能集成在一起，如：日志、依赖注入、身份认证和授权。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/Grpc.Net.Client&quot;&gt;Grpc.Net.Client&lt;/a&gt; 基于HttpClient （HttpClient现已支持HTTP/2）的 gRPC客户端&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/Grpc.Net.ClientFactory&quot;&gt;Grpc.Net.ClientFactory&lt;/a&gt; 与gRPC客户端集成的&lt;code&gt;HttpClientFactory&lt;/code&gt;，允许对gRPC客户端进行集中配置，并使用DI注入到应用程序中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三.使用-asp.net-core-创建-grpc-服务&quot;&gt;三.使用 ASP.NET Core 创建 gRPC 服务&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;通过 Visual Studio 2019 （16.3.0）提供的模板，可以快速创建 gRPC 服务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234754807-732602146.png&quot; alt=&quot;1569332979179&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来&lt;strong&gt;扒拉一下&lt;/strong&gt;默认源码包含了什么东东。&lt;/p&gt;
&lt;p&gt;① 配置文件 &lt;code&gt;appsettings.json&lt;/code&gt; ，多了Kestrel 启用 HTTP/2 的配置，因为 gRPC 是基于 HTTP/2 来通信的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234754416-679737848.png&quot; alt=&quot;1569333539435&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② PB协议文件 &lt;code&gt;greet.proto&lt;/code&gt; 用于自动生成服务、客户端和消息（表示传递的数据）的C# Class&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234754077-53622389.png&quot; alt=&quot;1569333899754&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 服务类 &lt;code&gt;GreeterService&lt;/code&gt; ，服务类集成的 &lt;code&gt;Greeter.GreeterBase&lt;/code&gt; 来自于根据proto文件自动生成的，生成的类在 &lt;code&gt;obj\Debug\netcoreapp3.0&lt;/code&gt;目录下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234753655-896205852.png&quot; alt=&quot;1569334077321&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自动生成的类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234753250-1705253610.png&quot; alt=&quot;1569334149194&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④ &lt;code&gt;Startup.cs&lt;/code&gt;类，将 gRPC服务添加到了终结点路由中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234752792-1544548080.png&quot; alt=&quot;1569334239963&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤ csproj 项目文件，包含了 proto 文件引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234752357-1059183834.png&quot; alt=&quot;1569334307823&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.运行&lt;/p&gt;
&lt;p&gt;第一次运行会提示是否信任证书，点击“是”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234751992-7321873.png&quot; alt=&quot;1569334375312&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234751672-255029188.png&quot; alt=&quot;1569334392704&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为HTTP/2需要HTTPS，尽管HTTP/2协议没有明确规定需要HTTPS，但是为了安全在浏览器实现上都要求了HTTPS，所以现在的HTTP/2和HTTPS基本都是一对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234751314-757648680.png&quot; alt=&quot;1569334575324&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四.-创建-grpc-客户端&quot;&gt;四. 创建 gRPC 客户端&lt;/h2&gt;
&lt;p&gt;1.添加一个.NET Core 控制台应用程序&lt;/p&gt;
&lt;p&gt;2.通过nuget添加包：Grpc.Net.Client、Google.Protobuf、Grpc.Tools&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234751002-87270253.png&quot; alt=&quot;1569335021283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.将服务的 proto 文件复制到客户端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234750652-338305571.png&quot; alt=&quot;1569335104139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.编辑客户端项目文件，添加关于proto文件的描述&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;Protobuf Include=&quot;Protos\greet.proto&quot; GrpcServices=&quot;Client&quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意 &lt;code&gt;GrpcServices=&quot;Client&quot;&lt;/code&gt; 这里是Client和服务是不一样的&lt;/p&gt;
&lt;p&gt;5.生成客户端项目可以通过proto文件生成类&lt;/p&gt;
&lt;p&gt;6.添加客户端调用代码&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static async Task Main(string[] args)
{
    var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);
    var client = new Greeter.GreeterClient(channel);
    var reply = await client.SayHelloAsync(
        new HelloRequest { Name = &quot;晓晨&quot; });
    Console.WriteLine(&quot;Greeter 服务返回数据: &quot; + reply.Message);
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7.先启动服务，然后运行客户端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234750257-1553045042.png&quot; alt=&quot;1569335521902&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到，客户端成功调用了服务，收到了返回的消息。&lt;/p&gt;
&lt;h2 id=&quot;五.自己动手写一个服务&quot;&gt;五.自己动手写一个服务&lt;/h2&gt;
&lt;p&gt;前面我们使用的 Greeter 服务是由模板自动给我们创建的，现在我们来自己动手写一个服务。&lt;/p&gt;
&lt;p&gt;编写一个“撸猫服务”&lt;/p&gt;
&lt;p&gt;1.定义 proto 文件 &lt;code&gt;LuCat.proto&lt;/code&gt;，并在csproj项目文件中添加描述&lt;/p&gt;
&lt;pre class=&quot;protobuf&quot;&gt;
&lt;code&gt;syntax = &quot;proto3&quot;;

option csharp_namespace = &quot;AspNetCoregRpcService&quot;;

import &quot;google/protobuf/empty.proto&quot;;
package LuCat; //定义包名

//定义服务
service LuCat{
    //定义吸猫方法
    rpc SuckingCat(google.protobuf.Empty) returns(SuckingCatResult);
}

message SuckingCatResult{
    string message=1;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.实现服务 &lt;code&gt;LuCatService.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class LuCatService:LuCat.LuCatBase
{
    private static readonly List&amp;lt;string&amp;gt; Cats=new List&amp;lt;string&amp;gt;(){&quot;英短银渐层&quot;,&quot;英短金渐层&quot;,&quot;美短&quot;,&quot;蓝猫&quot;,&quot;狸花猫&quot;,&quot;橘猫&quot;};
    private static readonly Random Rand=new Random(DateTime.Now.Millisecond);
    public override Task&amp;lt;SuckingCatResult&amp;gt; SuckingCat(Empty request, ServerCallContext context)
    {
        return Task.FromResult(new SuckingCatResult()
        {
            Message = $&quot;您吸了一只{Cats[Rand.Next(0, Cats.Count)]}&quot;
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.在 &lt;code&gt;Startup&lt;/code&gt;终结点路由中注册&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;endpoints.MapGrpcService&amp;lt;LuCatService&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.添加客户端调用&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var catClient = new LuCat.LuCatClient(channel);
var catReply = await catClient.SuckingCatAsync(new Empty());
Console.WriteLine(&quot;调用撸猫服务：&quot;+ catReply.Message);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.运行测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234749807-47668575.png&quot; alt=&quot;1569338919789&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六.实际使用中的技巧&quot;&gt;六.实际使用中的技巧&lt;/h2&gt;
&lt;h3 id=&quot;技巧1&quot;&gt;技巧1&lt;/h3&gt;
&lt;p&gt;上面章节的操作步骤中，我们需要在服务和客户端之间复制proto，这是一个可以省略掉的步骤。&lt;/p&gt;
&lt;p&gt;1.复制 Protos 文件夹到解决方案根目录（sln文件所在目录）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234749417-1182495616.png&quot; alt=&quot;1569335816218&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.删除客户端和服务项目中的 Protos 文件夹&lt;/p&gt;
&lt;p&gt;3.在客户端项目文件csproj中添加关于proto文件的描述&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;Protobuf Include=&quot;..\..\Protos\greet.proto&quot; GrpcServices=&quot;Client&quot; Link=&quot;Protos\greet.proto&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.在服务项目文件csproj中添加关于proto文件的描述&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;Protobuf Include=&quot;..\..\Protos\greet.proto&quot; GrpcServices=&quot;Server&quot; Link=&quot;Protos\greet.proto&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在实际项目中，请自己计算相对路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5.这样两个项目都是使用的一个proto文件，只用维护这一个文件即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234749075-849093.png&quot; alt=&quot;1569336339344&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;技巧2&quot;&gt;技巧2&lt;/h3&gt;
&lt;p&gt;我们在实际项目中使用，肯定有多个 proto 文件，难道我们每添加一个 proto 文件都要去更新 csproj文件？&lt;/p&gt;
&lt;p&gt;我们可以使用MSBuild变量来帮我们完成，我们将 csproj 项目文件中引入proto文件信息进行修改。&lt;/p&gt;
&lt;p&gt;服务端：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;Protobuf Include=&quot;..\..\Protos\*.proto&quot; GrpcServices=&quot;Server&quot; Link=&quot;Protos\%(RecursiveDir)%(Filename)%(Extension)&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;Protobuf Include=&quot;..\..\Protos\*.proto&quot; GrpcServices=&quot;Client&quot; Link=&quot;Protos\%(RecursiveDir)%(Filename)%(Extension)&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201909/668104-20190924234748602-416924373.png&quot; alt=&quot;1569339140058&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;七.总结&quot;&gt;七.总结&lt;/h2&gt;
&lt;p&gt;gRPC 现目前是一款非常成熟的高性能RPC框架，当前的生态是非常好的，很多公司的产品或者开源项目都有在使用gRPC，有了它，相信可以让我们更容易的构建.NET Core 微服务，可以让 .NET Core 更好的接入 gRPC 生态。不得不说这是 .NET Core 3.0 带来的最令人振奋的特性之一。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote readability=&quot;5.25&quot;&gt;
&lt;p&gt;如果大家无法访问proto3说明文档，这里提供一个&lt;a href=&quot;https://raw.githubusercontent.com/stulzq/BlogDemos/master/AspNetCoreGrpc/Language%20Guide%20(proto3)%20%C2%A0_%C2%A0%20Protocol%20Buffers%20%C2%A0_%C2%A0%20Google%20Developers.mhtml&quot;&gt;离线网页版&lt;/a&gt;（请&lt;strong&gt;另存为&lt;/strong&gt;下载后用Chrome打开）&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 24 Sep 2019 23:42:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<og:description>一.简介 gRPC 是一个由Google开源的，跨语言的，高性能的远程过程调用（RPC）框架。 gRPC使客户端和服务端应用程序可以透明地进行通信，并简化了连接系统的构建。它使用HTTP/2作为通信协</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stulzq/p/11581967.html</dc:identifier>
</item>
<item>
<title>Django-多对多关系的三种创建方式-forms组件使用-cookie与session-08 - suwanbin</title>
<link>http://www.cnblogs.com/suwanbin/p/11582114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suwanbin/p/11582114.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关系表可能还会有一个关系创建时间字段（这条关联记录什么时候添加的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;全自动：django 自动创建第三张表
&lt;ul&gt;&lt;li&gt;利用 ManyToManyField()&lt;/li&gt;
&lt;li&gt;优点：不需要手动创建第三张表&lt;/li&gt;
&lt;li&gt;不足：由于第三张表不是你手动创建的，也就意味着第三张表中&lt;strong&gt;字段是固定的，无法做扩展&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;纯手动：手动创建第三张表
&lt;ul&gt;&lt;li&gt;优点：第三张表可以任意扩展字段&lt;/li&gt;
&lt;li&gt;不足：查询不方便，基于双下划线、对象的反向查询都不支持了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;半自动：指定关联表和第三张表的关系
&lt;ul&gt;&lt;li&gt;优点：可以自定义字段，依旧支持基于双下划线、对象的反向查询&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 1.第一种 django orm 自动帮我们创建
class Book(models.Model):
    name = models.CharField(max_length=32)
    authors = models.ManyToManyField(to='Author')

    
class Author(models.Model):
    name = models.CharField(max_length=32)


# 2.第二种纯手动创建第三张表
class Book(models.Model):
    name = models.CharField(max_length=32)


class Author(models.Model):
    name = models.CharField(max_length=32)


class Book2Author(models.Model):
    book = models.ForeignKey(to='Book')
    author = models.ForeignKey(to='Author')
    info = models.CharField(max_length=32)


# 3.第三种半自动创建第三张表(可扩展性高，并且能够符合orm查询)
class Book(models.Model):
    name = models.CharField(max_length=32)
    # 第三种创建表的方式
    authors = models.ManyToManyField(to='Author', through='Book2Author', through_fields=('book', 'author'))
# through 告诉 django orm 书籍表和作者表的多对多关系是通过 Book2Author 来记录的
# through fields 告诉 django orm 记录关系时用过 Book2Author 表中的 book 字段 和 author字段 来记录的（第一个参数 book 是  关联表查 book 所依赖的字段）
# 但是，多对多字段的 add set remove clear 四个方法就用不了了


class Author(models.Model):
    name = models.CharField(max_length=32)


# book = models.ManyToManyField(to='Book',through='Book2Author',through_fields=('author','book'))


class Book2Author(models.Model):
    book = models.ForeignKey(to='Book')
    author = models.ForeignKey(to='Author')
    info = models.CharField(max_length=32)&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;科普：&lt;/strong&gt;前后端都可以校验数据，前端可以不做，但是&lt;strong&gt;后端必须要做！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;登录功能手写推理过程&quot;&gt;登录功能手写推理过程&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;在页面上搭框架             &amp;gt;&amp;gt;&amp;gt;     渲染页面
后端接收数据并校验         &amp;gt;&amp;gt;&amp;gt;     校验数据
展示错误信息给前端页面     &amp;gt;&amp;gt;&amp;gt;     展示信息（span 标签写报错信息）&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;整段代码可以放过来&quot;&gt;整段代码可以放过来&lt;/h3&gt;
&lt;h2 id=&quot;forms-组件使用&quot;&gt;forms 组件使用&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;forms 组件能够直接帮你完成上面的三步操作&lt;/p&gt;
&lt;p&gt;还能给你把校验不通过的数据保留在表单中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在前端渲染标签组件&lt;/li&gt;
&lt;li&gt;支持在前端与后端进行双重数据校验&lt;/li&gt;
&lt;li&gt;自定义展示错误提示信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这一般是用在前后端不分离项目中的&lt;/p&gt;
&lt;h3 id=&quot;forms-后端定义规则并校验结果&quot;&gt;forms 后端定义规则并校验结果&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;6.5&quot;&gt;
&lt;p&gt;写一个继承了 forms.Form 的类&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写校验规则&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;写法和写模型表类极其相似，但是 forms 组件的字段有约束，模型表类的字段没有约束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django import forms


class LoginForm(forms.Form):
    username = forms.CharField(max_length=8,min_length=3)  # 用户名最长八位最短三位
    password = forms.CharField(max_length=8,min_length=5)  # 密码最长八位最短五位
    email = forms.EmailField()  # email必须是邮箱格式&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本使用&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将需要校验的数据，以字典的方式传递给自定义的类，实例化产生对象&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;form_obj = views.LoginForm({'username':'jason','password':'123','email':'123'})&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何查看数据是否全部合法&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;form_obj.is_valid()&lt;/code&gt; ，只有所有的数据都符合要求 才会是True&lt;/p&gt;
&lt;p&gt;&lt;code&gt;False&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何查看错误原因&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;form_obj.errors&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;{
    'password': ['Ensure this value has at least 5 characters (it has 3).'], 
    'email': ['Enter a valid email address.']
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何查看校验通过的数据&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;&lt;code&gt;form_obj.cleaned_data&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{'username': 'jason'}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;forms-前端渲染标签组件&quot;&gt;forms 前端渲染标签组件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;渲染页面&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;p&amp;gt;第一种渲染页面的方式(封装程度太高 一般只用于本地测试  通常不适用)&amp;lt;/p&amp;gt;
{{ form_obj.as_p }}  
{{ form_obj.as_ul }}
{{ form_obj.as_table }}
                
&amp;lt;p&amp;gt;第二种渲染页面的方式(可扩展性较高 书写麻烦)&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;{{ form_obj.username.label }}{{ form_obj.username }}&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;{{ form_obj.password.label }}{{ form_obj.password }}&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;{{ form_obj.email.label }}{{ form_obj.email }}&amp;lt;/p&amp;gt;
                
&amp;lt;p&amp;gt;第三种渲染页面的方式(推荐)&amp;lt;/p&amp;gt;
{% for foo in form_obj %}
    &amp;lt;p&amp;gt;{{ foo.label }}{{ foo }}&amp;lt;/p&amp;gt;
{% endfor %}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;展示错误信息&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;默认是 ul 套 li ，可能有多个报错，我们索引取 0，取消它的 ul li 标签嵌套&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;{% for foo in form_obj %}
    &amp;lt;p&amp;gt;{{ foo.label }}:{{ foo }}
    &amp;lt;span&amp;gt;{{ foo.errors.0 }}&amp;lt;/span&amp;gt;
    &amp;lt;/p&amp;gt;
{% endfor %}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;forms 组件在帮你渲染页面的时候 &lt;strong&gt;只会渲染获取用户输入的标签&lt;/strong&gt; 提交按钮需要你手动添加&lt;/li&gt;
&lt;li&gt;input 框的 label 注释 &lt;strong&gt;不指定的情况下 默认用的是类中 字段的首字母大写&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;forms-组件其他知识点服务器端的&quot;&gt;forms 组件其他知识点（服务器端的）&lt;/h2&gt;
&lt;h3 id=&quot;在-python-console-测试&quot;&gt;在 python console 测试&lt;/h3&gt;
&lt;p&gt;类似于django 里的 测试环境（就不需要再自己手动写测试文件的那堆配置了）&lt;/p&gt;
&lt;h4 id=&quot;校验数据&quot;&gt;校验数据&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Form对象 实例化 参数 是一个大字典&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011011472-231308887.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;forms-组件数据校验规则&quot;&gt;forms 组件数据校验规则&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;从上往下依次取值校验&lt;/li&gt;
&lt;li&gt;校验通过的放到 cleaned_data&lt;/li&gt;
&lt;li&gt;校验失败的放到 errors&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br/&gt;form 中&lt;strong&gt;所有的字段默认都是必须传值的&lt;/strong&gt;（required=True）&lt;/p&gt;
&lt;p&gt;只要有一个字段不通过，&lt;code&gt;form_obj.is_valid()&lt;/code&gt; 的结果就是 False，所有字段都校验通过了才会返回 True&lt;/p&gt;
&lt;p&gt;校验数据的时候可以多传（多传的数据不会做任何的校验 &amp;gt;&amp;gt; &amp;gt; 不会影响 form 校验规则）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011032346-738944974.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;其他几个常见字段类型&quot;&gt;其他几个常见字段类型&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    # 单选的radio框
    gender = forms.ChoiceField(
        choices=((1, &quot;男&quot;), (2, &quot;女&quot;), (3, &quot;保密&quot;)),
        label=&quot;性别&quot;,
        initial=3,
        widget=forms.widgets.RadioSelect()
    )
    # 单选select
    hobby = forms.ChoiceField(
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;),),
        label=&quot;爱好&quot;,
        initial=3,
        widget=forms.widgets.Select()
    )
    # 多选的select框
    hobby1 = forms.MultipleChoiceField(
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;),),
        label=&quot;爱好&quot;,
        initial=[1, 3],
        widget=forms.widgets.SelectMultiple()
    )
    # 单选的checkbox
    keep = forms.ChoiceField(
        label=&quot;是否记住密码&quot;,
        initial=&quot;checked&quot;,
        widget=forms.widgets.CheckboxInput()
    )
    # 多选的checkbox
    hobby2 = forms.MultipleChoiceField(
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;),),
        label=&quot;爱好&quot;,
        initial=[1, 3],
        widget=forms.widgets.CheckboxSelectMultiple()
    )
    
    phone = forms.CharField(
        validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')],
    )&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;forms-所有内置字段类型&quot;&gt;forms 所有内置字段类型&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Field
    required=True,               是否允许为空
    widget=None,                 HTML插件
    label=None,                  用于生成Label标签或显示内容
    initial=None,                初始值
    help_text='',                帮助信息(在标签旁边显示)
    error_messages=None,         错误信息 {'required': '不能为空', 'invalid': '格式错误'}
    validators=[],               自定义验证规则
    localize=False,              是否支持本地化
    disabled=False,              是否可以编辑
    label_suffix=None            Label内容后缀
 
 
CharField(Field)
    max_length=None,             最大长度
    min_length=None,             最小长度
    strip=True                   是否移除用户输入空白
 
IntegerField(Field)
    max_value=None,              最大值
    min_value=None,              最小值
 
FloatField(IntegerField)
    ...
 
DecimalField(IntegerField)
    max_value=None,              最大值
    min_value=None,              最小值
    max_digits=None,             总长度
    decimal_places=None,         小数位长度
 
BaseTemporalField(Field)
    input_formats=None          时间格式化   
 
DateField(BaseTemporalField)    格式：2015-09-01
TimeField(BaseTemporalField)    格式：11:12
DateTimeField(BaseTemporalField)格式：2015-09-01 11:12
 
DurationField(Field)            时间间隔：%d %H:%M:%S.%f
    ...
 
RegexField(CharField)
    regex,                      自定制正则表达式
    max_length=None,            最大长度
    min_length=None,            最小长度
    error_message=None,         忽略，错误信息使用 error_messages={'invalid': '...'}
 
EmailField(CharField)      
    ...
 
FileField(Field)
    allow_empty_file=False     是否允许空文件
 
ImageField(FileField)      
    ...
    注：需要PIL模块，pip3 install Pillow
    以上两个字典使用时，需要注意两点：
        - form表单中 enctype=&quot;multipart/form-data&quot;
        - view函数中 obj = MyForm(request.POST, request.FILES)
 
URLField(Field)
    ...
 
 
BooleanField(Field)  
    ...
 
NullBooleanField(BooleanField)
    ...
 
ChoiceField(Field)
    ...
    choices=(),                选项，如：choices = ((0,'上海'),(1,'北京'),)
    required=True,             是否必填
    widget=None,               插件，默认select插件
    label=None,                Label内容
    initial=None,              初始值
    help_text='',              帮助提示
 
 
ModelChoiceField(ChoiceField)
    ...                        django.forms.models.ModelChoiceField
    queryset,                  # 查询数据库中的数据
    empty_label=&quot;---------&quot;,   # 默认空显示内容
    to_field_name=None,        # HTML中value的值对应的字段
    limit_choices_to=None      # ModelForm中对queryset二次筛选
     
ModelMultipleChoiceField(ModelChoiceField)
    ...                        django.forms.models.ModelMultipleChoiceField
 
 
     
TypedChoiceField(ChoiceField)
    coerce = lambda val: val   对选中的值进行一次转换
    empty_value= ''            空值的默认值
 
MultipleChoiceField(ChoiceField)
    ...
 
TypedMultipleChoiceField(MultipleChoiceField)
    coerce = lambda val: val   对选中的每一个值进行一次转换
    empty_value= ''            空值的默认值
 
ComboField(Field)
    fields=()                  使用多个验证，如下：即验证最大长度20，又验证邮箱格式
                               fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),])
 
MultiValueField(Field)
    PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用
 
SplitDateTimeField(MultiValueField)
    input_date_formats=None,   格式列表：['%Y--%m--%d', '%m%d/%Y', '%m/%d/%y']
    input_time_formats=None    格式列表：['%H:%M:%S', '%H:%M:%S.%f', '%H:%M']
 
FilePathField(ChoiceField)     文件选项，目录下文件显示在页面中
    path,                      文件夹路径
    match=None,                正则匹配
    recursive=False,           递归下面的文件夹
    allow_files=True,          允许文件
    allow_folders=False,       允许文件夹
    required=True,
    widget=None,
    label=None,
    initial=None,
    help_text=''
 
GenericIPAddressField
    protocol='both',           both,ipv4,ipv6支持的IP格式
    unpack_ipv4=False          解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用
 
SlugField(CharField)           数字，字母，下划线，减号（连字符）
    ...
 
UUIDField(CharField)           uuid类型&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;forms-组件字段常见参数&quot;&gt;forms 组件字段常见参数&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 基本都渲染成 HTML 标签的属性（H5 对这些属性有支持）
max_length      最大长度
min_length      最小长度
required        是否必填
label           注释信息
initial         初始值（对应的是 value）

error_messages  报错信息
widget          控制标签属性和样式

。。。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;前端取消浏览器校验&quot;&gt;前端取消浏览器校验&lt;/h4&gt;
&lt;p&gt;给 form 标签加个 自定义属性 novalidate 即可（ &lt;code&gt;&amp;lt;form action=&quot;&quot; method=&quot;post&quot; novalidate&amp;gt;&amp;lt;/form&amp;gt;&lt;/code&gt;）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;forms 组件校验数据数据自带保留数据功能，让用户可以基于原来的数据做修改（不合法数据依旧保留在页面的表单中）&lt;/p&gt;
&lt;p&gt;forms 组件 在后端的这套校验功能依旧生效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;error_messages-定义中文报错提示&quot;&gt;error_messages 定义中文报错提示&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011055263-735111576.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;required-允许字段不填&quot;&gt;required 允许字段不填&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;required=False&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011122015-1594059638.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用正则来约束&quot;&gt;使用正则来约束&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django import forms
from django.core.validators import RegexValidator

class LoginForm(forms.Form):
    password = forms.CharField(
        max_length=8,  # 密码最长八位最短五位
        min_length=5,
        label='密码',
        error_messages={
            'max_length': '密码最大八位',
            'min_length': '密码最小五位',
            'required': '密码不能为空'
        },
        required=False,
        validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')]
    )

# 其他代码....  &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;密码密文-指定渲染标签的-class-等属性应用样式&quot;&gt;密码密文 指定渲染标签的 class 等属性（应用样式） &lt;code&gt;*****&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django import forms
from django.forms import widgets


class LoginForm(forms.Form):
    username = forms.CharField(max_length=8, min_length=3, label='用户名', initial='tankdsb',
                               error_messages={
                                   'max_length': '用户名最大八位',
                                   'min_length': '用户名最小三位',
                                   'required': '用户名不能为空'
                               }, widget=widgets.TextInput()
                               )  # 用户名最长八位最短三位
    password = forms.CharField(max_length=8, min_length=5, label='密码', error_messages={
        'max_length': '密码最大八位',
        'min_length': '密码最小五位',
        'required': '密码不能为空'
    },
                               widget=widgets.PasswordInput(attrs={'class': 'form-control c1 c2', 'username': 'jason'})  # 指定渲染出来标签的属性（可以指定 class 配合 bootstrap 使用）
                               )  # 密码最长八位最短五位&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;渲染在页面上的 HTML&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011136420-1453400236.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;forms-组件钩子函数&quot;&gt;forms 组件钩子函数&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以&lt;strong&gt;自定义校验规则&lt;/strong&gt;（定制化业务需求）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hook 钩子&lt;/p&gt;
&lt;h4 id=&quot;全局钩子&quot;&gt;全局钩子&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;针对多个字段&lt;/strong&gt;作额外的校验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;校验用户两次密码（注册）是否一致&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 全局钩子(针对多个字段做额外的校验)    校验用户两次密码是否一致
class LoginForm(forms.Form):
    def clean(self):
        password = self.cleaned_data.get('password')
        confirm_password = self.cleaned_data.get('confirm_password')
        if not password == confirm_password:
            self.add_error('confirm_password','两次密码不一致')
        return self.cleaned_data&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;局部钩子&quot;&gt;局部钩子&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;针对某一个字段&lt;/strong&gt;作额外校验（一定要有一个返回值（源码里面要用到））&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 用法:在自定义的form类中书写方法即可
# 局部钩子(针对某一个字段做额外的校验)   校验用户名中不能包含666 一旦包含 提示
class LoginForm(forms.Form):
    def clean_username(self):
        username = self.cleaned_data.get('username')
        if '666' in username:
            self.add_error('username','光喊666是不行的 你得自己上')
        return username&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;forms-校验最终版&quot;&gt;forms 校验最终版&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;后端 forms 如何指定并校验（前端渲染基本就上面的固定写法，连样式都是在后端指定上 class 或者直接指定属性加去的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.shortcuts import render, HttpResponse, redirect
from django.core.exceptions import ValidationError


# Create your views here.
def login(request):
    errors = {'username': '', 'password': ''}
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        if 'jpm' in username:
            errors['username'] = '不符合社会主义核心价值观'
        if len(password) &amp;lt; 3:
            errors['password'] = '太短了 不安全!'
    return render(request, 'login.html', locals())


from django import forms
from django.core.validators import RegexValidator
from django.forms import widgets


class LoginForm(forms.Form):
    username = forms.CharField(max_length=8, min_length=3, label='用户名', initial='tankdsb',
                               error_messages={
                                   'max_length': '用户名最大八位',
                                   'min_length': '用户名最小三位',
                                   'required': '用户名不能为空'
                               }, widget=widgets.TextInput()
                               )  # 用户名最长八位最短三位
    password = forms.CharField(max_length=8, min_length=5, label='密码', error_messages={
        'max_length': '密码最大八位',
        'min_length': '密码最小五位',
        'required': '密码不能为空'
    },
                               widget=widgets.PasswordInput(attrs={'class': 'form-control c1 c2', 'username': 'jason'})
                               )  # 密码最长八位最短五位
    confirm_password = forms.CharField(max_length=8, min_length=5, label='确认密码', error_messages={
        'max_length': '确认密码最大八位',
        'min_length': '确认密码最小五位',
        'required': '确认密码不能为空'
    }, required=False, validators=[RegexValidator(r'^[0-9]+$', '请输入数字'),
                                   RegexValidator(r'^159[0-9]+$', '数字必须以159开头')])  # 密码最长八位最短五位
    email = forms.EmailField(label='邮箱', error_messages={
        'required': '邮箱不能为空',
        'invalid': '邮箱格式不正确'
    })  # email必须是邮箱格式

    # 局部钩子(针对某一个字段做额外的校验)   校验用户名中不能包含666 一旦包含 提示
    def clean_username(self):
        username = self.cleaned_data.get('username')
        if '666' in username:
            # raise ValidationError('奥术大师就卡的凯撒就肯定会')
            self.add_error('username', '光喊666是不行的 你得自己上')
        return username

    # 全局钩子(针对多个字段做额外的校验)    校验用户两次密码是否一致
    def clean(self):
        password = self.cleaned_data.get('password')
        confirm_password = self.cleaned_data.get('confirm_password')
        if not password == confirm_password:
            self.add_error('confirm_password', '两次密码不一致')
        return self.cleaned_data


def reg(request):
    # 1 现生成一个空的自定义类的对象
    form_obj = LoginForm()
    # 2 将该对象传递给前端页面
    if request.method == 'POST':
        # 3 获取前端post请求提交过来的数据
        # print(request.POST)  # 由于request.POST其实也是一个字典 所有可以直接传给LoginForm
        form_obj = LoginForm(request.POST)
        # 4 校验数据  让forms组件帮你去校验
        if form_obj.is_valid():
            # 5 如果数据全部通过 应该写入数据库
            pass
        # 6 如果不通过 一个像前端展示错误信息
    return render(request, 'reg.html', locals())


def lg(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        if username == 'jason' and password == '123':
            # 先获取url中get请求携带的参数
            old_url = request.GET.get('next')
            # 判断用户是直接访问的登陆页面 还是从别的页面的调过来
            if old_url:
                obj = redirect(old_url)
            else:
                # 如果用户直接访问的登陆页面 那么登陆完成之后 直接跳到网站的首页
                obj = redirect('/home/')
            obj.set_cookie('name', 'jason', max_age=30)  # 浏览器上就会保存键值对name:jason
            return obj
    return render(request, 'lg.html')


from functools import wraps


def login_auth(func):
    @wraps(func)
    def inner(request, *args, **kwargs):
        # 从request中获取cookie
        # print(request.path)
        # print(request.get_full_path())
        target_url = request.get_full_path()
        if request.COOKIES.get('name'):
            res = func(request, *args, **kwargs)
            return res
        else:
            return redirect('/lg/?next=%s' % target_url)

    return inner


@login_auth
def home(request):
    # # 先校验客户端cookie中有没有你写入的键值对
    # if request.COOKIES.get('name'):
    #     return HttpResponse('home页面 只有登录了才能看')
    # return redirect('/lg/')
    return HttpResponse('home页面 只有登录了才能看')


@login_auth
def index(request):
    return HttpResponse(&quot;index页面 只有登录了才能访问&quot;)


@login_auth
def xxx(request):
    return HttpResponse('xxx页面 登陆之后才能看')


def logout(request):
    obj = redirect('/lg/')
    obj.delete_cookie('name')
    return obj


def set_session(request):
    # request.session['name'] = 'jason'
    # request.session['name1'] = 'jason1'
    # request.session['name2'] = 'jason2'
    # request.session['name3'] = 'jason3'
    request.session['xxx'] = 'xxx'
    request.session.set_expiry(30)
    return HttpResponse('set_session')


def get_session(request):
    # print(request.session.get('name'))
    # print(request.session.get('name1'))
    # print(request.session.get('name2'))
    # print(request.session.get('name3'))
    print(request.session.get('xxx'))
    return HttpResponse('set_session')


def delete_session(request):
    # request.session.delete('xxx')
    request.session.flush()
    return HttpResponse('delete_session')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;forms-校验源码分析&quot;&gt;forms 校验源码分析&lt;/h2&gt;
&lt;p&gt;从 &lt;code&gt;form_obj.is_valid()&lt;/code&gt; 作为起点开始探究&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心部分代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011221509-797224606.png&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于 http 协议是无状态的，无法记录用户状态，所以出现了 cookie 和 session 来识别并保存用户状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;cookie-工作原理&quot;&gt;cookie 工作原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;cookie 就是保存在客户端浏览器上的键值对&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当你登录成功之后，浏览器上会保存一些信息，下次再访问的时候，就会带着这些信息去访问服务端，服务端通过这些信息来识别出你的身份&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;cookie 虽然是写在客户端浏览器上的，但其其实是服务端设置的&lt;/p&gt;
&lt;p&gt;浏览器可以选择不服从命令 禁止写 cookie （设置，禁用 cookie）&lt;/p&gt;
&lt;p&gt;不让写 cookie 的话，所有要保存登录状态的页面都不能登录成功&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;查看 cookie 的三种方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011247341-963142603.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;session-工作原理&quot;&gt;session 工作原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;session 是保存在服务端的键值对&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;session 虽然是保存在服务器上的键值对，但是他是依赖于 cookie 工作的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;工作原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端返回给浏览器一个随机的字符串，浏览器以键值对的形式保存（sessionid:随机字符串）&lt;/li&gt;
&lt;li&gt;浏览器在访问服务端的时候，就会将这个随机字符串携带上，后端获取随机字符串与后端的记录作对比（随机字符串1:数据1）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何操作-cookie&quot;&gt;如何操作 cookie&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;django 返回给客户端浏览器的都必须是 HttpResponse 对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面的两种写法是等同的&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 目前接触过的写法
return HttpResponse()
return render()
return redirect()


# 等同于下面的写法
obj1 = HttpResponse()
return obj1
obj2 = render()
return obj2
obj3 = redirect()
return obj3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务端常见的-cookie-操作&quot;&gt;服务端常见的 cookie 操作&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;设置cookie利用的就是HttpResponse对象
    obj1.set_cookie('k1','v1')
        
获取cookie
    request.COOKIE.get()
        
删除cookie
    obj1.delete_cookie(&quot;k1&quot;)
        
设置超时时间
    max_age=None, 超时时间
    expires=None, 超时时间(IE requires expires, so set it if hasn't been already.)
        &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小练习&quot;&gt;小练习&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;根据 cookie 的存取操作，做个登录验证功能（登录后才能访问某几个页面）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;思考：&lt;/strong&gt;很显然，有的页面（实际场景肯定不止一个函数要这样的）未登录不能访问，那我们要写一个&lt;strong&gt;登录验证装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;装饰器参数：request, *args, **kwargs （request 如果用位置参数接取不是很方便，直接当做第一个参数好取一些）&lt;/p&gt;
&lt;h4 id=&quot;记录跳转到登录页面前请求的地址&quot;&gt;记录跳转到登录页面前请求的地址&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;记录用户未登录时访问的地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;利用 get 塞参数给登录页（一般这个不会 塞给 cookie）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;登录验证装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import wraps


def login_auth(func):
    @wraps(func)
    def inner(request,*args,**kwargs):
        # 从request中获取cookie
        # print(request.path)
        # print(request.get_full_path())
        target_url = request.get_full_path()
        if request.COOKIES.get('name'):
            res = func(request,*args,**kwargs)
            return res
        else:
            return redirect('/lg/?next=%s'%target_url)
    return inner
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何操作-session&quot;&gt;如何操作 session&lt;/h2&gt;
&lt;p&gt;当成一个 字典 来操作就行了&lt;/p&gt;
&lt;h3 id=&quot;设置-session&quot;&gt;设置 session&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;request.session['name'] = 'value'&lt;/code&gt; 这句话发生了最起码三件事&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;django 内部自动生成一个随机字符串&lt;/li&gt;
&lt;li&gt;将随机字符串和你要保存的数据写入 django_session 表中（先在内存中生成一个缓存记录 等到经过中间件的时候才会真正地执行）&lt;/li&gt;
&lt;li&gt;将产生的随机字符串发送给浏览器，写入 cookie（sessionid: 随机字符）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;要保证有 ... django_session 表，没有的话执行 数据库迁移命令生成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011321572-2088613225.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取-session&quot;&gt;获取 session&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;request.session.get('name')&lt;/code&gt; 这句话发生了几件事&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;django 内部会自动从请求信息中获取到随机字符串&lt;/li&gt;
&lt;li&gt;拿着随机字符串去 django_session 表中比对&lt;/li&gt;
&lt;li&gt;一旦对应上了，就将对应的数据解析出来，放到request.session 中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;django_session 的特点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;django session 默认的&lt;strong&gt;过期时间&lt;/strong&gt;是 14 天&lt;/p&gt;
&lt;p&gt;django_session 表中的一条记录（行）针对一个浏览器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190925011335191-1514051897.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除-session&quot;&gt;删除 session&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 删除当前会话的所有Session数据
request.session.delete()  # 删除的是浏览器的sessionid信息
        　　
# 删除当前的会话数据并删除会话的Cookie。
request.session.flush()  # 将浏览器和服务端全部删除
    这用于确保前面的会话数据不可以再次被用户的浏览器访问
    例如，django.contrib.auth.logout() 函数中就会调用它。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置-session-超时时间&quot;&gt;设置 session 超时时间&lt;/h3&gt;
&lt;p&gt;每次登录都会重新计算 超时时间&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 设置会话 Session 和 Cookie 的超时时间
request.session.set_expiry(value)
    * 如果value是个整数，session会在些秒数后失效。
    * 如果value是个datatime或timedelta，session就会在这个时间后失效。
    * 如果value是0,用户关闭浏览器session就会失效。
    * 如果value是None,session会依赖全局session失效策略。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在django 项目中有参数不好传时，可以放在 session 里，就全局变量一样，直接从 session 里拿就能拿到了&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 24 Sep 2019 17:15:00 +0000</pubDate>
<dc:creator>suwanbin</dc:creator>
<og:description>[TOC] 表模型类多对多关系的三种创建方式 关系表可能还会有一个关系创建时间字段（这条关联记录什么时候添加的） 1. 全自动：django 自动创建第三张表 利用 ManyToManyField()</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suwanbin/p/11582114.html</dc:identifier>
</item>
<item>
<title>睡梦中被拉起来执行Spring事务 - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/break-up-for-execute-spring-tx-in-a-dream.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/break-up-for-execute-spring-tx-in-a-dream.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;梦中惊醒&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;在Tomcat的线程池里，有这样一个线程，自打出生后，从来不去干活儿，有好多次走出线程池“这座大山”去看世界的机会，都被他拱手让给了弟兄们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;弟兄们给他取了个名字叫二师兄。没错，好吃懒做，饱了睡，醒了吃。这不，又迷迷糊糊睡着了，还打呼噜呢。&lt;/p&gt;&lt;p&gt;“快起来，起来，干活去了”，有人在喊他。只见二师兄转转身，不耐烦道，“叫别人去，叫别人去”。&lt;/p&gt;&lt;p&gt;“哪还有别人呢”，突然声音高了八度。二师兄觉得不对劲儿啊，转身一看，原来是大管家亲自来了，吓得他赶紧跳起来向外跑去。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;远方来客&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;二师兄来到大门外，看到一众人马已在此等候，他哪见过这场面啊，心里不免有些忐忑，强装镇定道，“你们领头儿的是谁，出来自我介绍下吧”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;眼见三个人下了马走上前来，第一位说道，“我是来自Spring家族的，叫Controller”。第二位说道，“我也是来自Spring家族，叫Service”。&lt;/p&gt;&lt;p&gt;“我是来自MyBatis家族，叫Mapper”，第三位说道，“我们结拜为异姓三兄弟，奉主人之命，前来执行任务”。&lt;/p&gt;&lt;p&gt;二师兄虽然没“见过世面”，但是在睡不着时总听弟兄们说起这些，嗯，是他们，准没错。“诸位都请下马随我来吧”。&lt;/p&gt;&lt;p&gt;大伙都跟着二师兄来到了Tomcat的大宅子的后院的西厢房的二堂里。二师兄招呼大家坐下，给他们端茶倒水，让诸位稍作休息。&lt;/p&gt;&lt;p&gt;老大来到二师兄面前道，“我们此行的目的是要到数据库山村进行交流学习，还请你做我们的向导，带领大伙一同前往”。&lt;/p&gt;&lt;p&gt;二师兄自然没去过数据库山村，但听说那里地处深山老林，一路崎岖陡峭，便不想带他们去。于是就准备吓唬吓唬他们，让他们自己打退堂鼓。&lt;/p&gt;&lt;p&gt;“数据库山村着实遥远，要翻过几座大山，走上几天几夜，关键一到夜里有豺狼虎豹出没，还听说绣花鞋都成精了，出来吃人啊”，二师兄道。&lt;/p&gt;&lt;p&gt;“不入虎穴，焉得虎子。我们兄弟既然来了，就不怕这些”，老二说道。“二哥说的对，我们不怕。来一个杀一个，来两个杀一双”，老三补充道。&lt;/p&gt;&lt;p&gt;二师兄一看这阵势，不去是不行了，就借故先出来了，去寻求帮助啊。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;新式武器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;一会儿功夫，只见二师兄咧着嘴、带着标志的憨笑向这边跑来，一边喊着，“三位哥哥，新式武器，新式武器，我们有救了，有救了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;三兄弟一脸问号、有点莫名。老大道，“十八般兵器我们都带了，莫非你说的是第十九种”？“快拿出来，让我们见识见识”，老三接着道。&lt;/p&gt;&lt;p&gt;二师兄道，“这新式武器啊，它不是个兵器，是一种工具。其实事情原本是这样的。。。”。三兄弟听完二师兄的解说后明白了。&lt;/p&gt;&lt;p&gt;原来是Tomcat王府为了加强与周边的联系，就趁着前几天315的活动，在“五环外”的PDD上购买了“乡村版”的无绳电话，正好数据库山村也购买了，前几天已经收到货，调试好可以使用了。&lt;/p&gt;&lt;p&gt;“你们这次正好赶巧了，可以试试这个无绳电话，通过电话交流，不用再跑一趟了”，二师兄道。三兄弟只是听说过，但从没用过，有点迫不及待的想见见这“高科技”。&lt;/p&gt;&lt;p&gt;二师兄随即带领着大伙朝“机房”方向走去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;有点意思&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;大伙来到机房，看着无绳电话都很兴奋，但是没人会用，都望着二师兄。二师兄哪会用呢，只好翻箱倒柜找出了说明书，可惜自己看不懂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;老二对着自己的管家说道，“你来负责，找一些能工巧匠，好好研究研究说明书，把这电话搞定”。管家找出了平时爱捣鼓的那些队友，把说明书给了他们。&lt;/p&gt;&lt;p&gt;果然，片刻功夫，有个队友表示大概明白了，可以尝试一把。于是二师兄就给了他数据库山村的“联系方式”，他接着一顿操作猛如虎，把大伙整的一愣一愣的。&lt;/p&gt;&lt;p&gt;还别说，竟然通了，按照说明书上讲的，这就相当于建立了一条和数据库山村的“连接”，然后还要把这个连接设置成“不可自动挂断”，OK，搞定了。就把这个队友称为“接线员”吧。&lt;/p&gt;&lt;p&gt;接线员把电话交给了管家，管家心想这毕竟是Tomcat府上的东西，自己不能喧宾夺主，于是就把电话给了二师兄。二师兄道，“好，承蒙诸位看得起在下，那我就宣布本次交流开始”。又把电话给了管家。&lt;/p&gt;&lt;p&gt;领导先讲话这是自古以来的规矩，管家确认电话畅通后，就交给了自己的领导。于是老二Service通过老三Mapper，使用这个电话，终于和数据库山村“村长”MySql通上话了，一番寒暄过后，终于可以一对一的交流了。&lt;/p&gt;&lt;p&gt;队友1从管家处领取电话，坐到桌子前，打开本子，拿起电话，一面和对方沟通，一面记录一些东西。一段时间以后，他和对方互相道谢，结束了交流。&lt;/p&gt;&lt;p&gt;队友2从管家处领取电话，和对方进行了交流。接着队友3从管家处领取电话，又进行了长时间的交流。管家一看，电话快没电了，就把电话交给了自己的领导。&lt;/p&gt;&lt;p&gt;老二Service和村长MySql又是一番“互相吹捧”，最后约定改日再聊。然后就把电话又给了管家，管家确认没有人再使用了，于是就挂断了电话。&lt;/p&gt;&lt;p&gt;眼见天色已晚，二师兄安顿好大家，把电话拿去充电后，自己也去休息了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;意外收获&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;第二天一大早，老二让管家负责好今天的交流，自己就去找二师兄了。在管家的指导下，交流有条不紊的进行着。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;半上午的时候，老二匆匆忙忙的回来了，拿出一个纸条，上面写着数据库山村的另一个电话号码，让管家帮他拨通这个号码。&lt;/p&gt;&lt;p&gt;管家一看，队友正在用电话交流着呢，但是领导的事情又不能违抗，让队友挂断电话放弃交流也不太合适啊。突然脑中一道灵光闪过。&lt;/p&gt;&lt;p&gt;记得昨天研究说明书时，看到过呼叫保持这种技术，就是让当前通话保持住，然后再开启一个全新的通话，等新的通话结束后，原来保持住的通话可以恢复。&lt;/p&gt;&lt;p&gt;管家让接线员进行处理，一番操作后成功了，只不过为啥是个女人的声音，哦，管家意识到这可能是个“私人”电话，于是识趣的和大家一起“慢慢地”向门外走去。&lt;/p&gt;&lt;p&gt;看样子自己的领导和那个女的很熟悉。这会是谁呢？管家一时也整不明白。一番脑细胞碰撞后，仿佛有了一点眉目，那应该是领导的一个笔友，平时都是书信来往。&lt;/p&gt;&lt;p&gt;管家总是去帮忙寄信和收信，既然是数据库山村的人，那平时都应该交流的是SQL优化啥的相关话题吧。当然，这是猜的，因为私拆领导信件犯法。&lt;/p&gt;&lt;p&gt;好长时间之后，领导终于完事了，把电话交给了管家。管家挂断了和这个女人的通话，并把之前保持住的那个通话进行了恢复，然后让队友继续之前的学术交流。&lt;/p&gt;&lt;p&gt;领导心里美滋滋的，我猜他一定在想什么时候还有活动啊，也去买个无绳电话。这样可以多和笔友进行“学术交流”了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;演员谢幕&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;异姓三兄弟都是我们的老朋友，再熟悉不过了。二师兄呢是一个线程，说明Spring事务的执行是和当前线程相关联的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;老二Service的管家其实就是事务管理器，负责事务的整体工作。接线员可以认为是DataSource，负责和数据库建立一条连接（Connection）。&lt;/p&gt;&lt;p&gt;把电话设置为不可自动挂断，表示的是把数据库连接设置为不自动提交事务，需要注意的是，这个设置是由事务管理器来操作的，而不是接线员。&lt;/p&gt;&lt;p&gt;开头的领导讲话，接下来的队友1/2/3的学术交流，还有最后的领导吹捧，其实是4个标有@Transactional注解的方法。且在第1个方法里调用了其它3个方法。&lt;/p&gt;&lt;p&gt;他们用的都是同一通电话在交流，说明4个方法的执行用的是同一个和数据库的连接，即一根绳子上的蚂蚱。最后管家挂断电话，表明是事务管理器提交了事务。&lt;/p&gt;&lt;p&gt;在第二天时，把当前通话进行呼叫保持，即对应于把当前线程上正在运行的事务挂起。拨通领导的私人电话，对应于当前线程新建一条到数据库的连接，即一个全新的事务。&lt;/p&gt;&lt;p&gt;管家挂断了领导的私人通话，即提交了这个新事务。然后恢复之前被保持的那个通话，即恢复之前那个被挂起的事务，使它重新成为当前线程正在运行的事务。&lt;/p&gt;&lt;p&gt;最后，领导没有买无绳电话，而是直接买了智能手机，并下载了微信。哈哈，你懂的。&lt;/p&gt;&lt;p&gt;PS：本文只是宏观描述，实际的事务代码执行比这要复杂一些。&lt;/p&gt;


&lt;p&gt;（END）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号和知识星球的二维码，欢迎关注！&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg&quot; alt=&quot;&quot;/&gt;      &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Sep 2019 16:29:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>梦中惊醒 在Tomcat的线程池里，有这样一个线程，自打出生后，从来不去干活儿，有好多次走出线程池“这座大山”去看世界的机会，都被他拱手让给了弟兄们。弟兄们给他取了个名字叫二师兄。没错，好吃懒做，饱了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/break-up-for-execute-spring-tx-in-a-dream.html</dc:identifier>
</item>
<item>
<title>众咖云集的 PyCon 2019 上海站，大佬们都讲了啥 - zkqiang</title>
<link>http://www.cnblogs.com/zkqiang/p/11581994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zkqiang/p/11581994.html</guid>
<description>&lt;p&gt;9 月 21 号周六，我参加了 PyCon China 2019 上海站，这是每年一届的 Python 中国开发者大会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922124621.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今年的上海站比往年的阵容扩大很多，「流畅的 Python」作者、Flask 作者及核心维护者、PyCharm 开发者等等大佬都登台演讲。&lt;/p&gt;
&lt;p&gt;本文将总结一下我观看的演讲，但并不会深入和完整，如有感兴趣的主题，可以等待官方后续放出的视频，我的公众号到时候也会转载。&lt;/p&gt;
&lt;h2 id=&quot;python-%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E7%BE%8E&quot;&gt;Python 的永恒之美&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922124620.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「流畅的 Python」作者 Luciano Ramalho，作为首场演讲的嘉宾，他的讲题围绕着 Python 之禅（PEP 20: The Zen of Python），结合了国际象棋、围棋、甚至易经，再次诠释 Python 语法的优美之处。&lt;/p&gt;
&lt;p&gt;他还表示 Python 非常适合女性开发，介绍了 Python 开发团队拥有很多女性加入，顺带调侃了 Python 作者 Guido 在演讲中只回答女性的提问。&lt;/p&gt;
&lt;h2 id=&quot;%E9%80%9A%E8%BF%87-azure-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB&quot;&gt;通过 Azure 实现图片分类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922131825.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二场是由微软开发者 Dave Glover，介绍如何使用 Python 与微软 Azure 的免费云服务，构建一套 IoT 图片分类系统，并演示了开发一个水果分类功能，将不同水果的图片进行简单训练后，就可以用于超市收银台快速计算不同水果的价格（不过现场似乎因为音画不同步，导致有些小意外...）。&lt;/p&gt;
&lt;p&gt;另外下午场微软 VS Code 还现场发布了在 Python 领域的新功能，具体可见公众号次条推送。&lt;/p&gt;
&lt;h2 id=&quot;aws-serverless-%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BC%80%E5%8F%91&quot;&gt;AWS Serverless 一站式开发&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922141104.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结束了前两场英语听力后（翻译在文末吐槽），第三场是来自宝岛台湾的谢洪恩，他是 AWS 无服务器与容器专家解决方案架构师。他介绍了 AWS 近几年在 Serverless 领域发布的新技术，主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AWS Lambda&lt;/li&gt;
&lt;li&gt;AWS SAR（Serverless Application Repository）&lt;/li&gt;
&lt;li&gt;AWS CDK（Cloud Development Kit）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;利用这些技术让 Python 开发者在无服务器的情况下，完成一站式开发部署（也支持其它多种语言），并且还介绍了在微服务框架中的应用。&lt;/p&gt;
&lt;p&gt;另外在下午场中，谢老师还进行了三个小时的 AWS WorkShop 专场，现场指导开发者们，在 AWS CDK 中从零开始完成一个完整项目。但可惜由于时间冲突，我没有选择参加。&lt;/p&gt;
&lt;h2 id=&quot;flask-%E4%BD%9C%E8%80%85%E8%B0%88%E8%B0%83%E8%AF%95&quot;&gt;Flask 作者谈调试&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922141939.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flask、Werkzeug、Jinja2、Click 等开源项目的作者 Armin Ronacher，讲述他在 Python 调试方面的新看法，并通过最近使用 Rust 语言的开发经历，发现了 Python 在性能上较慢反而对调试有帮助。&lt;/p&gt;
&lt;p&gt;遗憾的是他英语语速很快，PPT 文字内容也比较少，我并没有听懂太多细节，需要等待视频再复习一波。&lt;/p&gt;
&lt;h2 id=&quot;%E5%9C%A8%E8%B0%83%E8%AF%95%E4%B8%8A%E7%9A%84%E6%96%B0%E5%AE%9E%E7%8E%B0&quot;&gt;在调试上的新实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922142519.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上午最后一场，是由 Google 软件工程师、《捕蛇者说》播客创始人 laike9m 演讲，同样是调试的话题，但他带来的是一个新思路，以及已经实现的开源库 ——&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://github.com/laike9m/Cyberbrain&quot;&gt;Cyberbrain&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主要思路是对目标变量进行追踪，通过可视化界面查看变量从初始化一直到目标行的过程，从而帮助快速定位 BUG。&lt;/p&gt;
&lt;p&gt;以下是一段示例代码：&lt;/p&gt;
&lt;pre data-language=&quot;python&quot;&gt;
&lt;code class=&quot;hljs lang-python&quot; data-language=&quot;python&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;func_f&lt;span class=&quot;hljs-params&quot;&gt;(bar):
    x = len(bar)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return x

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;func_c&lt;span class=&quot;hljs-params&quot;&gt;(baa):
    baa.append(&lt;span class=&quot;hljs-literal&quot;&gt;None)
    baa.append(&lt;span class=&quot;hljs-string&quot;&gt;'?')

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;func_a&lt;span class=&quot;hljs-params&quot;&gt;(foo):
    &lt;span class=&quot;hljs-keyword&quot;&gt;for i &lt;span class=&quot;hljs-keyword&quot;&gt;in range(&lt;span class=&quot;hljs-number&quot;&gt;2): &lt;span class=&quot;hljs-keyword&quot;&gt;pass
    ba = [foo]
    func_c(ba)
    foo = func_f(ba)
    cyberbrain.register(foo)

&lt;span class=&quot;hljs-keyword&quot;&gt;import cyberbrain
cyberbrain.init()
fo = &lt;span class=&quot;hljs-number&quot;&gt;1
func_a(fo)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过对&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code data-backticks=&quot;1&quot;&gt;foo&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 变量的注册，可以产生以下输出：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922162303.jpeg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且支持持久化存储，即使在服务器上也可以 DEBUG。&lt;/p&gt;
&lt;h2 id=&quot;aiops-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E4%B8%8E-python&quot;&gt;AIOps 数据中台与 Python&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922163054.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下午场都是同时开始的分会场，所以我只能选择听自己感兴趣的场次。&lt;/p&gt;
&lt;p&gt;最近两年“中台”概念比较火，我公司也已经有中台，所以我首场选择了这个中台话题的场次，嘉宾是来自阿里云日志服务的丁来强。&lt;/p&gt;
&lt;p&gt;他演讲的内容主要是介绍目前市面上众多 AIOps 平台，并介绍如何通过开源的 AIOps 搭建数据中台，来解决数据收集、算法处理海量日志等以往需要大量人工的问题。&lt;/p&gt;
&lt;p&gt;至于 Ops 的未来趋势，他表示：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;根据 Gartner 的报告，AIOps 将在未来 5-10 年落地开花，并集中统一各种 Ops 平台（Dev、IT、Net、Sec）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;django-%E4%B8%AD%E8%BF%90%E7%94%A8-graphql&quot;&gt;Django 中运用 GraphQL&lt;/h2&gt;
&lt;p&gt;先介绍一下 GraphQL，它是 Facebook 发布 API 查询语言，旨在提供 RestFul 架构体系的替代方案，但一直鲜有人用，甚至鲜有人知。&lt;/p&gt;
&lt;p&gt;目前 RestFul API 存在的问题是，返回的数据结构和类型都是后端定义，前端需求变化，后端也要随之改变，如果是中大型项目，改动接口是会产生大量连带工作量。&lt;/p&gt;
&lt;p&gt;而 GraphQL 就是解决这一痛点，它实现了前端可以自定义请求字段与结构，而后端则专心处理请求逻辑与数据库映射。具体不再多介绍，可查阅相关资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922172502.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LeetCode 后端架构师李齐雨，介绍了 LeetCode 在最近两年，已经将十几万行 Django 代码构成的所有接口，更换为了 GraphQL。&lt;/p&gt;
&lt;p&gt;更换后的好处则如上面所介绍，让接口迭代更加灵活。他主要分享的是期间遇到的一些问题，以及如何攻克，比如数据转换、查询性能优化等。&lt;/p&gt;
&lt;p&gt;不过他也直言，如果对接口性能要求很高，建议暂时不要使用 GraphQL。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9E%84%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4&quot;&gt;构建自动化测试集群&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922180928.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一场是网易 Airtest 团队负责人杨柳，前半部分是介绍 Airtest 这一开源的自动化测试框架，在跨平台特别是 App、手游这方面的优势，框架集成的图像识别、控件识别大幅增加了自动化能力。&lt;/p&gt;
&lt;p&gt;后半部分是分享网易游戏如何将自动化测试逐步扩展为大规模测试集群，并且介绍了如何使用 3x4 小型机柜，实现一个企业级、私有化的测试解决方案。&lt;/p&gt;
&lt;h2 id=&quot;%E9%80%9A%E8%BF%87-python-%E6%9E%84%E5%BB%BA-rpc&quot;&gt;通过 Python 构建 RPC&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922183157.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来自饿了么的资深工程师张汝家，先是介绍了 thrift 这一款 RPC 协议，在目前微服务架构中的应用，以及目前 Python 实现的 thriftpy 和 thriftpy2 的区别和各自的应用场景。&lt;/p&gt;
&lt;p&gt;然后他分享了使用 thriftpy 构建一套 RPC 协议架构的过程，中间不同分层该如何设计，并且其中一些通信与传输问题是如何解决的。&lt;/p&gt;
&lt;h2 id=&quot;%E9%97%AA%E7%94%B5%E6%BC%94%E8%AE%B2&quot;&gt;闪电演讲&lt;/h2&gt;
&lt;p&gt;最后的场次，是本届 PyCon 设置的新环节，每位嘉宾只有 5 分钟时间演讲，可惜部分嘉宾超时未完成演讲，实际效果欠佳。&lt;/p&gt;
&lt;p&gt;不过有一个印象深刻的主题是将 C/C++ 代码转换为 .pyd 文件，Python 可直接调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zkqiang.cn/images/20190922184628.jpg-slim&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;演讲者是上海韦纳科技的韦泽华，他实现了此功能并开源名为&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://github.com/nanoric/c2py&quot;&gt;c2py&lt;/a&gt;，该项目与之前类似功能的 Swig 相比，c2py 更加易用，不需要像 Swig 写接口文件，just run c2py &amp;amp; build。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E6%9C%AC%E6%AC%A1%E5%A4%A7%E4%BC%9A%E7%9A%84%E8%A7%82%E5%90%8E%E6%84%9F&quot;&gt;本次大会的观后感&lt;/h2&gt;
&lt;p&gt;相较于往期有非常大的进步，主要是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本届大咖云集，通过多位著名项目核心开发者的分享，学习他们在各自领域中独到的见解；&lt;/li&gt;
&lt;li&gt;分会场的设立，充分扩大了演讲的主题范围，也满足了不同方向的开发者不同的关注点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但依然有部分遗憾之处，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一场半程，某赞助商的 AI 翻译就莫名罢工，并且一上午都没有再启动，导致我等英语苦手，对三位国外大佬的演讲吸收量大减；&lt;/li&gt;
&lt;li&gt;WorkShop 设置在下午分会场，如果选择了就相当于无缘同时间段的三场演讲，纠结之下我只能放弃参与。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总体本届还是收获满满，票价超值了，也看出主办方想办好 PyCon China 的决心，希望明年再加油，PyCon 明年见！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;所有图片来自 PyCon China 官方拍摄&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文属于原创内容，首发于微信公众号「&lt;strong&gt;面向人生编程&lt;/strong&gt;」，如需转载请在公众号后台留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627229/201909/1627229-20190905233933463-849327926.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关注后回复以下信息获取更多资源&lt;br/&gt;回复【资料】获取 Python / Java 等学习资源&lt;br/&gt;回复【插件】获取爬虫常用的 Chrome 插件&lt;br/&gt;回复【知乎】获取最新知乎模拟登录&lt;/p&gt;
</description>
<pubDate>Tue, 24 Sep 2019 16:01:00 +0000</pubDate>
<dc:creator>zkqiang</dc:creator>
<og:description>PyCon China 是一年一度的 Python 中国开发者大会，今年上海站国内外大佬云集，「流畅的 Python」作者、Flask 作者及核心维护者、PyCharm 开发者等等大佬都登台演讲。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zkqiang/p/11581994.html</dc:identifier>
</item>
<item>
<title>Kylin配置Spark并构建Cube - CREATE_17</title>
<link>http://www.cnblogs.com/createboke/p/11581915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/createboke/p/11581915.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;HDP版本：2.6.4.0&lt;/p&gt;
&lt;p&gt;Kylin版本：2.5.1&lt;/p&gt;
&lt;p&gt;机器：三台 CentOS-7，8G 内存&lt;/p&gt;
&lt;p&gt;Kylin 的计算引擎除了 MapReduce ，还有速度更快的 Spark ，本文就以 Kylin 自带的示例 kylin_sales_cube 来测试一下 Spark 构建 Cube 的速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一配置kylin的相关spark参数&quot;&gt;一、配置Kylin的相关Spark参数&lt;/h3&gt;
&lt;p&gt;在运行 Spark cubing 前，建议查看一下这些配置并根据集群的情况进行自定义。下面是建议配置，开启了 Spark 动态资源分配：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;## Spark conf (default is in spark/conf/spark-defaults.conf)
kylin.engine.spark-conf.spark.master=yarn
kylin.engine.spark-conf.spark.submit.deployMode=cluster
kylin.engine.spark-conf.spark.yarn.queue=default
kylin.engine.spark-conf.spark.driver.memory=2G
kylin.engine.spark-conf.spark.executor.memory=4G
kylin.engine.spark-conf.spark.executor.instances=40
kylin.engine.spark-conf.spark.yarn.executor.memoryOverhead=1024
kylin.engine.spark-conf.spark.shuffle.service.enabled=true
kylin.engine.spark-conf.spark.eventLog.enabled=true
kylin.engine.spark-conf.spark.eventLog.dir=hdfs\:///kylin/spark-history
kylin.engine.spark-conf.spark.history.fs.logDirectory=hdfs\:///kylin/spark-history
#kylin.engine.spark-conf.spark.hadoop.yarn.timeline-service.enabled=false
#
#### Spark conf for specific job
#kylin.engine.spark-conf-mergedict.spark.executor.memory=6G
#kylin.engine.spark-conf-mergedict.spark.memory.fraction=0.2
#
## manually upload spark-assembly jar to HDFS and then set this property will avoid repeatedly uploading jar
## at runtime
kylin.engine.spark-conf.spark.yarn.archive=hdfs://node71.data:8020/kylin/spark/spark-libs.jar
kylin.engine.spark-conf.spark.io.compression.codec=org.apache.spark.io.SnappyCompressionCodec
#
## 如果是HDP版本，请取消下述三行配置的注释
kylin.engine.spark-conf.spark.driver.extraJavaOptions=-Dhdp.version=current
kylin.engine.spark-conf.spark.yarn.am.extraJavaOptions=-Dhdp.version=current
kylin.engine.spark-conf.spark.executor.extraJavaOptions=-Dhdp.version=current&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 kylin.engine.spark-conf.spark.yarn.archive 配置是指定了 Kylin 引擎要运行的 jar 包，该 jar 包需要自己生成且上传到 HDFS 。由于我执行 Kylin 服务的用户是 kylin，所以要先切换到 kylin 用户下去执行。命令如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;su - kylin
cd /usr/hdp/2.6.4.0-91/kylin
# 生成spark-libs.jar文件
jar cv0f spark-libs.jar -C $KYLIN_HOME/spark/jars/ ./
# 上传到HDFS上的指定目录
hadoop fs -mkdir -p /kylin/spark/
hadoop fs -put spark-libs.jar /kylin/spark/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二修改cube的配置&quot;&gt;二、修改Cube的配置&lt;/h3&gt;
&lt;p&gt;配置好 Kylin 的相关 Spark 参数后，接下来我们需要将 Cube 的计算引擎修改为 Spark ，修改步骤如下：&lt;/p&gt;
&lt;p&gt;先指定 Kylin 自带的生成 Cube 脚本：sh ${KYLIN_HOME}/bin/sample.sh ，会在 Kylin Web 页面上加载出两个 Cube 。&lt;/p&gt;
&lt;p&gt;接着访问我们的 Kylin Web UI ，然后点击 Model -&amp;gt; Action -&amp;gt; Edit 按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233437551-1357394889.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击第五步：Advanced Setting，往下划动页面，更改 Cube Engine 类型，将 MapReduce 更改为 Spark。然后保存配置修改。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233439785-1903830236.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233440548-282800982.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 “Next” 进入 “Configuration Overwrites” 页面，点击 “+Property” 添加属性 “kylin.engine.spark.rdd-partition-cut-mb” 其值为 “500” （理由如下）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233441651-1662586959.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;样例 cube 有两个耗尽内存的度量: “COUNT DISTINCT” 和 “TOPN(100)”；当源数据较小时，他们的大小估计的不太准确: 预估的大小会比真实的大很多，导致了更多的 RDD partitions 被切分，使得 build 的速度降低。500 对于其是一个较为合理的数字。点击 “Next” 和 “Save” 保存 cube。&lt;/p&gt;
&lt;p&gt;对于没有”COUNT DISTINCT” 和 “TOPN” 的 cube，请保留默认配置。&lt;/p&gt;
&lt;h3 id=&quot;三构建cube&quot;&gt;三、构建Cube&lt;/h3&gt;
&lt;p&gt;保存好修改后的 cube 配置后，点击 Action -&amp;gt; Build，选择构建的起始时间（一定要确保起始时间内有数据，否则构建 cube 无意义），然后开始构建 cube 。&lt;/p&gt;
&lt;p&gt;在构建 cube 的过程中，可以打开 Yarn ResourceManager UI 来查看任务状态。当 cube 构建到 第七步 时，可以打开 Spark 的 UI 网页，它会显示每一个 stage 的进度以及详细的信息。&lt;/p&gt;
&lt;p&gt;Kylin 是使用的自己内部的 Spark ，所以我们还需要额外地启动 Spark History Server 。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;${KYLIN_HOME}/spark/sbin/start-history-server.sh hdfs://&amp;lt;namenode_host&amp;gt;:8020/kylin/spark-history&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问：&lt;a href=&quot;http://ip:18080/&quot; class=&quot;uri&quot;&gt;http://ip:18080/&lt;/a&gt; ，可以看到 Spark 构建 Cube 的 job 详细信息，该信息对疑难解答和性能调整有极大的帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233444362-967990823.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四faq&quot;&gt;四、FAQ&lt;/h3&gt;
&lt;p&gt;在使用 Spark 构建 Cube 的过程中，遇到了两个错误，都解决了，特此记录一下，让大家明白，公众号内都是满满的干货。&lt;/p&gt;
&lt;h4 id=&quot;spark-on-yarn-配置调整&quot;&gt;1、Spark on Yarn 配置调整&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;报错内容：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Required executor memory (4096+1024 MB) is above the max threshold (4096 MB) of this cluster! Please check the values of 'yarn.scheduler.maximum-allocation-mb' and/or 'yarn.nodemanager.resource.memory-mb'.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233450535-588947060.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据报错日志分析，任务所需的执行内存（4096 + 1024MB）高于了此集群最大的阈值。可以调整Spark任务的执行内存或者是Yarn的相关配置。&lt;/p&gt;
&lt;p&gt;Spark任务所需的执行内存（4096 + 1024MB）对应的配置分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;kylin.engine.spark-conf.spark.executor.memory=4G&lt;/li&gt;
&lt;li&gt;kylin.engine.spark-conf.spark.yarn.executor.memoryOverhead=1024&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Yarn相关配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;yarn.nodemanager.resource.memory-mb：NodeManager是YARN中单个节点的代理，它需要与应用程序的ApplicationMaster和集群管理者ResourceManager交互。该属性代表该节点Yarn可使用的物理内存总量。&lt;/li&gt;
&lt;li&gt;yarn.scheduler.maximum-allocation-mb：代表单个任务可申请的最大物理内存量。该配置值不能大于yarn.nodemanager.resource.memory-mb配置值大小。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以调整 Yarn 配置为例，调整 yarn.scheduler.maximum-allocation-mb 大小，由于依赖于 yarn.nodemanager.resource.memory-mb ，所以两个配置都调整为比执行内存（4096+1024 MB）大的数值，比如：5888 MB 。&lt;/p&gt;
&lt;h4 id=&quot;构建-cube-第八步convert-cuboid-data-to-hfile-报错&quot;&gt;2、构建 Cube 第八步：Convert Cuboid Data to HFile 报错&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;报错内容：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.lang.NoClassDefFoundError: Could not initialize class org.apache.hadoop.hbase.io.hfile.HFile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233453614-1236875030.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kylin.engine.spark-conf.spark.yarn.archive 参数值指定的 spark-libs.jar 文件缺少 HBase 相关的类文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于缺失 HBase 相关的类文件比较多，参照 Kylin 官网给出的解决方式依旧报找不到类文件，所以我将 HBase 相关的 jar 包都添加到了 spark-libs.jar 里面。如果你已经生成了 spark-libs.jar 并上传到了 HDFS，那么你需要重新打包上传。具体操作步骤如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;su - kylin
cd /usr/hdp/2.6.4.0-91/kylin
cp -r /usr/hdp/2.6.4.0-91/hbase/lib/hbase* /usr/hdp/2.6.4.0-91/kylin/spark/jars/
rm -rf spark-libs.jar;jar cv0f spark-libs.jar -C spark/jars/ ./
hadoop fs -rm -r /kylin/spark/spark-libs.jar    
hadoop fs -put spark-libs.jar /kylin/spark/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后切换到 Kylin Web 页面，继续构建 Cube 。&lt;/p&gt;
&lt;h3 id=&quot;五spark与mapreduce的对比&quot;&gt;五、Spark与MapReduce的对比&lt;/h3&gt;
&lt;p&gt;使用 Spark 构建 Cube 共耗时约 7 分钟，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233456692-1759279943.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 MapReduce 构建 Cube 共耗时约 15 分钟，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233459012-406215248.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是使用 Spark 构建 cube 快，还快不少！&lt;/p&gt;
&lt;h3 id=&quot;六总结&quot;&gt;六、总结&lt;/h3&gt;
&lt;p&gt;本篇文章主要介绍了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何配置 Kylin 的相关 Spark 参数&lt;/li&gt;
&lt;li&gt;如何更改 Cube 的计算引擎&lt;/li&gt;
&lt;li&gt;生成 spark-libs.jar 包并上传到 HDFS&lt;/li&gt;
&lt;li&gt;Spark 构建 Cube 过程中的 FAQ&lt;/li&gt;
&lt;li&gt;Spark 与 MapReduce 构建 Cube 的速度对比&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文参考链接：&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201909/1117352-20190924233508522-793666479.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Sep 2019 15:35:00 +0000</pubDate>
<dc:creator>CREATE_17</dc:creator>
<og:description>HDP版本：2.6.4.0 Kylin版本：2.5.1 机器：三台 CentOS 7，8G 内存 Kylin 的计算引擎除了 MapReduce ，还有速度更快的 Spark ，本文就以 Kylin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/createboke/p/11581915.html</dc:identifier>
</item>
<item>
<title>C#基础之委托 - 七彩石头</title>
<link>http://www.cnblogs.com/qcst123/p/11575557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcst123/p/11575557.html</guid>
<description>&lt;p&gt;  通过以下思维导图，学习委托的基本概念，后面着重讲解委托的运用，希望通过最简单的方式收获更多的知识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/775745/201909/775745-20190923221310748-1275714217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.委托的各种写法&lt;/h3&gt;
&lt;p&gt;1、委托 委托名=new 委托（会调用的方法名); 委托名（参数）;&lt;/p&gt;
&lt;p&gt;2、委托 委托名 =会调用的方法名; 委托名（参数）；&lt;/p&gt;
&lt;p&gt;3、匿名方法：委托 委托名=delegate(参数）{会调用的方法体};委托名（参数）；&lt;/p&gt;
&lt;p&gt;4、拉姆达表达式：委托 委托名=（（参数1，。。参数n）=&amp;gt;{会调用的方法体}）；委托名（参数）；&lt;/p&gt;
&lt;p&gt;5、用Action&amp;lt;T&amp;gt;和Func&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;p&gt;Action&amp;lt;参数1, 参数2,&amp;gt; 委托名= ((参数1，参数2) =&amp;gt; {不带返回值的方法体 });委托名（参数1，参数2）；&lt;/p&gt;
&lt;p&gt;Func&amp;lt;参数1, 参数2, 返回值&amp;gt; 委托名= ((参数1，参数2) =&amp;gt; {带返回值的方法体 });返回值=委托名（参数1，参数2）；&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Call(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2);
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleMath
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 乘法方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Multiply(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 *&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 除法方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Divide(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 /&lt;span&gt; num2;
    }
}


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------第一种写法------------------------&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        Call objCall = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Call(SimpleMath.Multiply);
        Call objCall1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Call(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleMath().Divide);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------第二种写法------------------------&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        Call objCall =&lt;span&gt; SimpleMath.Multiply;
        Call objCall1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleMath().Divide;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------第三种写法------------------------&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        Call objCall = &lt;span&gt;delegate&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a *&lt;span&gt; b;
        };
        Call objCall1 &lt;/span&gt;= &lt;span&gt;delegate&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a /&lt;span&gt; b;
        };
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------第四种写法------------------------&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        Call objCall =((&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b)=&amp;gt; { &lt;span&gt;return&lt;/span&gt; a*&lt;span&gt;b;});
        Call objCall1 &lt;/span&gt;= ((&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) =&amp;gt; { &lt;span&gt;return&lt;/span&gt; a /&lt;span&gt; b; });
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------第五种写法------------------------&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt; objCall = ((a, b) =&amp;gt; { &lt;span&gt;return&lt;/span&gt; a *&lt;span&gt; b; });
        Func&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt; objCall1 = ((a, b) =&amp;gt; { &lt;span&gt;return&lt;/span&gt; a /&lt;span&gt; b; });
        Action&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt; ob = ((a, b) =&amp;gt; { Console.WriteLine(a *&lt;span&gt; b); });
        ob(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;----------------------------------------------------&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        
        &lt;span&gt;int&lt;/span&gt; result = objCall(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result1 = objCall1(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        System.Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结果1为 {0},结果2为{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, result,result1);
        Console.ReadKey();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.委托的运用&lt;/h3&gt;
&lt;h4&gt;委托的运用记住两点：&lt;/h4&gt;
&lt;p&gt;1.将方法当作参数实例化委托对象；&lt;/p&gt;
&lt;p&gt; 2.将方法的参数传递给委托对象，以实现实际的方法调用。&lt;/p&gt;
&lt;h4&gt;委托常用场景：&lt;/h4&gt;
&lt;p&gt;1.模板方法：&lt;/p&gt;
&lt;p&gt; 如以下定义类CalculateFactory，用于定义各种计算方法，然后通过Calculate方法暴露出来给外界使用，而Calculate方法通过传入委托对象new Calculate(x1.Add)来实现对Add方法的调用。这是委托模板方法使用较简单的一种形式，它还可以有很多变种。&lt;/p&gt;
&lt;p&gt;  下面这段程序不用委托完全可以实现同样的逻辑，为什么要“故弄玄虚”呢？因为示例是为了说明委托作为模板方法的用法，故而用了最简单的一种，实际运用过程中，通常与设计模式相结合，以实现代码的高复用低耦合。进一步延伸，实际设计模式中也较少用委托，而用接口、抽象类来实现“模板方法”的功能，具体要怎么用是看个人习惯和便捷程度。委托用的最多的场景是下面要介绍的回调方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            CalculateFactory x1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalculateFactory();
            CalculateFactory x2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalculateFactory();
            x1.Calculate(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Calculate(x1.Add));
            x2.Calculate(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Calculate(x2.Reduce));
            Console.ReadKey();
        }
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Calculate(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalculateFactory
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Calculate(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b, Calculate calculateDelegae)
        {
            calculateDelegae(a, b);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is a+b={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a +&lt;span&gt; b));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Reduce(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is a-b={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a -&lt;span&gt; b));
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.回调方法：&lt;/p&gt;
&lt;p&gt;  回调方法与模板方法并不是并列的两种类型，其本质都是一样的，即将方法当成参数传递并调用，是通过应用场景来分类的。主调方法（调用回调方法的方法体）在满足某种条件或完成某种逻辑后去调用的方法，称为回调方法。将上面示例改造成含有回调方法的程序。&lt;/p&gt;
&lt;p&gt;示例：这里既用到了模板方法，也用到了回调方法。示例代码来源于刘铁猛大师的示例，在此表示感谢。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            ProductFactory productFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProductFactory();
            WrapFactory wrapFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WrapFactory();

            Func&lt;/span&gt;&amp;lt;Product&amp;gt; func1 = &lt;span&gt;new&lt;/span&gt; Func&amp;lt;Product&amp;gt;&lt;span&gt;(productFactory.MakePizza);
            Func&lt;/span&gt;&amp;lt;Product&amp;gt; func2 = &lt;span&gt;new&lt;/span&gt; Func&amp;lt;Product&amp;gt;&lt;span&gt;(productFactory.MakeToyCar);

            Logger logger &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Logger();
            Action&lt;/span&gt;&amp;lt;Product&amp;gt; log = &lt;span&gt;new&lt;/span&gt; Action&amp;lt;Product&amp;gt;(logger.Log); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Log的委托;&lt;/span&gt;
&lt;span&gt;
            Box box1 &lt;/span&gt;=&lt;span&gt; wrapFactory.WrapProduct(func1, log);
            Box box2 &lt;/span&gt;=&lt;span&gt; wrapFactory.WrapProduct(func2, log);

            Console.WriteLine(box1.Product.Name);

        }
        &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Product &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产品类&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        }
        &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Box &lt;span&gt;//&lt;/span&gt;&lt;span&gt;盒子类&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Product Product { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        }
        &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Logger
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Log(Product product)
            {
                Console.WriteLine(product.Price);
            }
        }
        &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; WrapFactory  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;包装工厂&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Box WrapProduct(Func&amp;lt;Product&amp;gt; getProduct, Action&amp;lt;Product&amp;gt;&lt;span&gt; logCallback)
            {
                Box box &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Box();
                Product product &lt;/span&gt;=&lt;span&gt; getProduct.Invoke();//此处使用的是间接的同步调用，如果使用间接异步调用用BeginInvoke();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (product.Price &amp;gt; &lt;span&gt;50&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果产品价格大于50，就执行回调方法;&lt;/span&gt;
&lt;span&gt;                {
                    logCallback(product);
                }
                box.Product &lt;/span&gt;=&lt;span&gt; product;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; box;
            }
        }
        &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ProductFactory  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产品工厂&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product MakePizza()
            {
                Product product &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product();
                product.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pizza&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                product.Price &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
            }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product MakeToyCar()
            {
                Product product &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product();
                product.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ToyCar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                product.Price &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.总结&lt;/h3&gt;
&lt;p&gt;   委托基础内容基本就是这些，回调方法在实际使用中也是最多的，上面回调方法的示例是有实用价值的，需要好好体会。委托还有多播委托等进阶应用，在此不作介绍，但需要了解其概念，以便碰到相应场景时翻翻资料能找到解决方案。&lt;/p&gt;

</description>
<pubDate>Tue, 24 Sep 2019 15:10:00 +0000</pubDate>
<dc:creator>七彩石头</dc:creator>
<og:description>通过以下思维导图，学习委托的基本概念，后面着重讲解委托的运用，希望通过最简单的方式收获更多的知识。 1.委托的各种写法 1、委托 委托名=new 委托（会调用的方法名); 委托名（参数）; 2、委托</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qcst123/p/11575557.html</dc:identifier>
</item>
</channel>
</rss>