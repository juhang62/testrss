<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>通俗易懂的来讲讲js的函数执行上下文 - 进击的蘑菇</title>
<link>http://www.cnblogs.com/ad-mushroom/p/10501088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ad-mushroom/p/10501088.html</guid>
<description>&lt;p&gt;&lt;span&gt;0、开场白&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在平时编写JavaScript代码时，我们并不会和执行上下文直接接触，但是想要彻底搞懂JavaScript函数的话，执行上下文是我们绕不过去的一个知识点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、执行上下文栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　JavaScript在对一个函数的每次调用，都会创建一个执行上下文，然后基于这个执行上下文运行函数体内的代码。一个函数可能会创建无数的执行上下文，因为对函数的每次调用（即使在函数内部调用自己）都会创建一个具有新状态的上下文。&lt;/p&gt;
&lt;p&gt;　　当函数a执行的时候，会创建一个函数a的执行上下文，然后执行函数a中的代码，在函数a中调用另一个函数b的时候，当前a函数的执行会暂停下来，它的执行上下文也不会消失，然后创建一个函数b的执行上下文，执行函数b中的代码。从这个例子可以看出，JavaScript需要对函数的执行上下文进行有序的管理，有一种数据结构特别符合这种场景，它就是栈，所以JavaScript中管理执行上下文的就是执行上下文栈，有时也叫它调用栈。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、执行上下文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为什么调用函数的时候要创建一个执行上下文？因为JavaScript要保存一些函数调用时的信息，比如传入的参数、谁调用的。&lt;/p&gt;
&lt;p&gt;　　执行上下文是由JavaScript的一个内部实现，类似于一个简单的对象，这个对象拥有三个属性：变量对象，作用域链，this。下图展示了一个执行上下文的结构&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/717109/201903/717109-20190309141742482-562094503.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、变量对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　变量对象是与执行上下文相关的数据作用域。它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明。&lt;strong&gt;变量对象是一个抽象概念&lt;/strong&gt;。对于不同的上下文类型，使用不同的对象。比如，在全局上下文中变量对象就是全局对象本身；当函数被调用的时候，则会&lt;strong&gt;创建一个活动对象来作为变量对象使用&lt;/strong&gt;。函数调用创建的活动对象，会比全局对象多一些属性，例如：形参、arguments。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、作用域链　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　作用域链的作用就是用来查找自由变量的，如果一个变量在函数自身的作用域（活动对象）中没有找到，那么将会查找它外层函数的作用域（活动对象），以此类推。在函数体内没有定义，需要搜索作用域链的变量叫做自由变量。&lt;/p&gt;
&lt;p&gt;　　关于作用域链最关键的一条信息就是，&lt;strong&gt;在创建函数的时候会保存外层函数的作用域链，这个保存下来的作用域链会在将来函数调用时用来查找变量&lt;/strong&gt;。在函数调用时，将当前函数的活动对象拼接在创建函数时保存的外层函数作用域链开头，然后保存在执行上下文的作用域链属性中，方便函数体内的自由变量进行变量查找。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、闭包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在计算机科学中，闭包，又称词法闭包或函数闭包，是引用了自由变量的函数。&lt;/p&gt;
&lt;p&gt;　　在JavaScript中，函数是第一级，就是说函数可以作为函数的参数、可以作为函数的返回值、可以赋值给变量。这是一个很强大的语言特性，不过它会引起两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当函数作为返回值时，这个函数内部的自由变量的解析问题。&lt;/li&gt;
&lt;li&gt;当函数作为参数传递时，这个函数内部的自由变量的解析问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　接下来通过两段代码来说清楚这两个问题，先来看第一段代码，在全局环境中声明一个foo函数，foo函数里声明一个变量x等于10，然后返回一个函数，这个函数内部打印了x，执行foo函数，把返回值赋值给了back，在全局环境中声明一个变量x＝20，此时执行back函数，会打印出来多少？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = 10&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(x);
  };
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; back =&lt;span&gt; foo();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = 20&lt;span&gt;;
back();&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　要想知道打印出来的x等于多少，只需要知道变量x的查找顺序就行。back函数是定义在foo函数内部的，在定义的时候，会保存foo函数的作用域链，然后在back函数执行的时候，会把自己的活动对象拼接在foo函数作用域链的开头，所以变量x的查找顺序是back函数的活动对象，这是个空对象，没找到x，然后接着查找第二级，也就是foo函数的活动对象，里面有x，等于10，所以最后打印出来的结果是10。foo函数已经执行完了，它的执行上下文应该消失了，为什么还能找到foo函数执行时的活动对象呢？因为在JavaScript中，如果有外部引用使用了活动对象里的属性，这个活动对象并不会被回收掉。我画了张图帮助大家理解一下这个执行过程：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/717109/201903/717109-20190309145521871-1139688953.png&quot; alt=&quot;&quot; width=&quot;1056&quot; height=&quot;711&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第二段代码描述的是函数作为参数传递时的场景：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  console.log(x);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (foo) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = 20&lt;span&gt;;
  foo();
}
b(foo);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　原理和上面一样，我也画了张图帮助大家理解一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717109/201903/717109-20190309150225236-325621319.png&quot; alt=&quot;&quot; width=&quot;1067&quot; height=&quot;735&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在JavaScript中，所有函数的执行都是基于这两种基础的模型的，无非就是变量多一些，嵌套深一些，查找的过程长一点，希望大家以后能看到代码时就能在脑海中呈现出代码的执行过程，变量的查找过程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、this&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　执行上下文中还有最后一个this属性没讲，很多JavaScript初学者被this搞的晕头转向，这里我会帮大家理清楚this的所有情况，以后不用再怕this了。&lt;/p&gt;
&lt;p&gt;　　在JavaScript中，this是关键字，它不是变量，所以它不会参与到变量的解析过程，也就是说不会去查找作用域链。当JavaScript在执行代码时遇到this时，它会直接从执行上下文中拿到this的值，不用做任何查找。&lt;/p&gt;
&lt;p&gt;　　this的值只在创建执行上下文的时候进行确定，确定之后不会更改。可能有人会反驳，this指向可以修改的呀，那是在进入函数体执行代码之前修改的，进入函数体之后就不能修改了。&lt;/p&gt;
&lt;p&gt;　　在全局环境中，this的值就是全局对象。&lt;/p&gt;
&lt;p&gt;　　在函数中，this的值一共有四种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;作为构造函数调用时，this指向构造函数创建的对象&lt;/li&gt;
&lt;li&gt;作为对象的方法调用时，指向该对象&lt;/li&gt;
&lt;li&gt;作为函数调用时，指向全局对象，严格模式下为undefined&lt;/li&gt;
&lt;li&gt;call、apply、bind调用时，指向传入的第一个参数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　到此为止，和JavaScript函数执行上下文有关的知识点我都介绍完了，希望这篇文章能够帮你更深刻的认识JavaScript的函数。&lt;/p&gt;

&lt;p&gt;　　参考资料：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-262.htm&quot; target=&quot;_blank&quot;&gt;https://www.ecma-international.org/publications/standards/Ecma-262.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://lzw.me/pages/ecmascript/#117&quot; target=&quot;_blank&quot;&gt;中文版ECMA规范&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 09 Mar 2019 07:35:00 +0000</pubDate>
<dc:creator>进击的蘑菇</dc:creator>
<og:description>0、开场白 在平时编写JavaScript代码时，我们并不会和执行上下文直接接触，但是想要彻底搞懂JavaScript函数的话，执行上下文是我们绕不过去的一个知识点。 1、执行上下文栈 JavaScr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ad-mushroom/p/10501088.html</dc:identifier>
</item>
<item>
<title>【RAY TRACING THE REST OF YOUR LIFE 超详解】 光线追踪 3-3 蒙特卡罗 (三) - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10500918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10500918.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开学人倍忙，趁着第二周周末，我们继续图形相关的博客&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;Preface&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天我们来介绍一些理论方面的东西，为Monte Carlo 应用到我们的光线追踪器做铺垫&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们今天会介绍两章的东西，因为有一章内容太过简单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇目的原版内容 &lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/gallery/1415234.html&quot; target=&quot;_blank&quot;&gt;见相册&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个东西你点上去会有页数的，不要看混了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190309151359048-1624258915.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;402&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;ready&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看这一篇您需要具备以下知识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 了解重要性采样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 二重积分，基础微分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. （半）球坐标系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 光线追踪基本原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 立体角（solid angle），现在普及一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先类比二维空间的圆，假设我们在二维空间内定义了一个单位圆，我们截取圆上的一段弧AB，它对应的圆心角为∠α&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且我们知道弧长 = α*R，那么整个周长就是C = 2*π*R&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们三维空间，仍然有类似的定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190309102304749-1212765345.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;记粉色区域为A &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;立体角&lt;/span&gt;&lt;/strong&gt;的单位是&lt;strong&gt;&lt;span&gt;球面度&lt;/span&gt;&lt;/strong&gt;（sr），1sr定义为球面上一块面积（A）为R&lt;sup&gt;2&lt;/sup&gt;的区域，从球心看过去的三维角度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类比于二维圆上的圆弧和圆心角，那块面积区域为三维弧度，面积区域相对于球心在三维坐标系下的张角即为立体角&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;立体角计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Ω = ∫∫&lt;/span&gt;&lt;sub&gt;A&lt;/sub&gt; (sinθ)&lt;span&gt;dθdφ&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A为三维弧度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，θ代表经度，φ代表维度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个球面的立体角为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ω = &lt;span&gt;∫&lt;/span&gt;&lt;sub&gt;0-&amp;gt;2π &lt;/sub&gt;&lt;span&gt;dφ ∫&lt;/span&gt;&lt;sub&gt;0-&amp;gt;π&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;(sinθ)&lt;span&gt;dθ&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ω = 2π*2 = 4π&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;content&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们之前的光线追踪器中有一个过程是获取一个三维空间的随机方向，我们利用单位球体内的随机点来代表该方向，那么我们今天用Monte Carlo 来实现相同的效果&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Chapter2 MC Integration on the Sphere of Directions&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们需要定义一个2D的pdf函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们假定下面这个积分适用于任意方向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;∫cos&lt;sup&gt;2&lt;/sup&gt;θdθ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在MC积分下，我们应该做 cos&lt;sup&gt;2&lt;/sup&gt;θ/&lt;em&gt;p(direction) &lt;/em&gt;的采样&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这里的direction在我们的环境中如何定义的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要在极坐标系下进行定义，&lt;/span&gt;&lt;span&gt;&lt;em&gt;p&lt;/em&gt;是关于θ和φ的一个函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，不管你怎么整，一定要记住，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设计&lt;/span&gt;&lt;span&gt;一个pdf函数，它的积分必须是1，并且pdf代表着该方向被采样的相对概率&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看一下之前我们的随机函数（模板和异常可忽略）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
template&amp;lt;typename T = lvgm::precision&amp;gt;
    &lt;span&gt;const&lt;/span&gt; lvgm::vec3&amp;lt;T&amp;gt;&lt;span&gt; random_unit_sphere()    
        {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (typeid(T) == typeid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;))
            {
            std::cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;integer doesn't have a random number from 0 to 1\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;integer doesn't have a random number from 0 to 1\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }

        lvgm::vec3&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
            {
            p &lt;/span&gt;= &lt;span&gt;2.0&lt;/span&gt;*lvgm::vec3&amp;lt;T&amp;gt;(rand01(), rand01(), rand01()) - lvgm::vec3&amp;lt;T&amp;gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (dot(p, p) &amp;gt;= &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这得到的是单位球体内部的随机三维点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们要得到球体表面的三维空间点，那么我们只需要单位化一下即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是return &lt;em&gt;p&lt;/em&gt;的单位化向量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，能够代表这些球体表面点的pdf函数应该是什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作为单位球体表面点的均匀密度，用立体角的方式定义均匀密度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即单位立体角的球面度/整个球体对应的球面度，也就是1/球体面积 或者 1/4π&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果被积函数我们选取上面的cos&lt;sup&gt;2&lt;/sup&gt;θ，θ为随机方向与z轴的夹角，那么程序如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sphereMC()
{
    auto pdf &lt;/span&gt;= []() {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; / (&lt;span&gt;4&lt;/span&gt; *&lt;span&gt; π); };
    size_t n{ &lt;/span&gt;&lt;span&gt;10000000&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sum{ &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i)
    {
        dvec3 d &lt;/span&gt;=&lt;span&gt; random_unit_sphere().ret_unitization();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; cosine = d.z()*&lt;span&gt;d.z();
        sum &lt;/span&gt;+= cosine /&lt;span&gt; pdf();
    }
    stds cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; sum / n &amp;lt;&amp;lt;&lt;span&gt; stds endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;答案是 4π/3，&lt;/span&gt;&lt;span&gt;绝对没毛病&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; Chapter3 Light Scaterring&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上本书中，我们基于表面或者次表面实现散射光线，这是一个普适模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，更自然的方式是概率，该光线多大概率被吸收了？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设 　 光线反射概率为A&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么　光线被吸收的概率就为 1-A&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的A其实代表之前材质中的albedo(latin for whiteness)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Albedo代表着某些反射形式的反射比例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们实现玻璃材质的时候，albedo伴随着入射光线方向的变化而变化，进而计算相应变化的像素值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在大多数的基于物理的渲染器，我们将用一组波长表示浅色而不是RGB，我们用长中短波长来代表RGB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果实现光散射，那么我们可以基于立体角设计一个pdf来描述光线散射方向分布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我将其称为散射pdf：&lt;span&gt;&lt;em&gt;&lt;strong&gt;s&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;（&lt;em&gt;&lt;strong&gt;direction&lt;/strong&gt;&lt;/em&gt;），这个散射pdf也会随着入射方向的变化而变化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以这个表面色彩就数量（wavelength）而言有如下积分形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;color =  &lt;span&gt;∫&lt;/span&gt;A * s(direction) * color(direction) dθ　　　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;[公式1]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意的是：A 和 s()都是依赖于观察方向的，当然，color也随着观察方向的变化而变化,A 和 s()也可能随着表面或体内部的位置而变化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果我们将Monte Carlo应用到上面的积分的话，那么我们得到如下的统计估计公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Color = (A * &lt;em&gt;&lt;strong&gt;s(direction)&lt;/strong&gt;&lt;/em&gt; * &lt;em&gt;&lt;strong&gt;color(direction&lt;/strong&gt;&lt;/em&gt;)) / &lt;em&gt;&lt;strong&gt;p(direction)　　&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;[公式2]&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的&lt;strong&gt;&lt;em&gt;p(direction)&lt;/em&gt;&lt;/strong&gt;是方向参数随机模拟生成的一个pdf函数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于Lambertian材质表面，我们假定其密度是呈余弦规律的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;so, 一个Lambertian表面的p()是正比于cosθ，而θ是光线方向和表面法线的夹角，还需要注意一点：所有设计的pdf函数在定义域内的积分必须是1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们还知道，对于磨砂表面来说，入射光线和表面法线的夹角不会超过90°，所以，我们定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于 cosθ &amp;lt; 0 的情况，我们设定&lt;em&gt;&lt;strong&gt;s(direction)&lt;/strong&gt;&lt;/em&gt; = &lt;em&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以有效区间为半球面，而基于半球的cos积分为π,这个怎么理解呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还记得already中的球面度吗？我们那时候说过那个区域A的微分形式（基于球坐标）为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dA = sinθ dθdφ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，半球面积 = &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190309141510023-1499052111.jpg&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;333&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，Lambertian表面散射pdf为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;　　s(direction)&lt;/strong&gt;&lt;/em&gt; = cosθ / π　　　　　　　　&lt;span&gt;&lt;strong&gt;[公式3]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们采样也使用同样的pdf函数，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即： p(direction) = cosθ/π　　　　　　　　　　&lt;span&gt;&lt;strong&gt;[公式4]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么分子分母可以消去，就得到了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Color = A * color(direction)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;书中表示的是 Color = A * s(direction),不是很明白意图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;联立公式2、3、4，难道不是约分剩下color()了么？？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这是我们原始的color函数中的设定，但我们现在需要概括一下完整的形式，以便我们可以向重要方向发送额外的光线，例如朝向灯光。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果你看过其他相关书籍，你可能会看到双向反射分布函数（BRDF）描述的反射。 它的表示形式非常简单：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BRDF =  A * s(direction) / cosθ　　　　　　&lt;span&gt;&lt;strong&gt;[公式5]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，对于朗伯表面，BRDF = A / Pi。&lt;span&gt;&lt;strong&gt;（联立公式3、5可得）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的表达方式和BRDF之间的转换很容易。而对于参与媒体（卷），我们的反照率通常被称为散射反照率，而我们的反照片通常被称为相位函数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这一篇主要讲一些理论相关的东西，可能没什么直观感受，但是下一篇学习的时候就需要用到这些东西了，没感觉的也没关系，结合下一篇可能会体会更深刻一点&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 07:16:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>Monte Carlo 光散射理论</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10500918.html</dc:identifier>
</item>
<item>
<title>Abp vNext 切换MySql数据库 - James.Ying</title>
<link>http://www.cnblogs.com/inday/p/abp-vNext-for-Mysql.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/inday/p/abp-vNext-for-Mysql.html</guid>
<description>&lt;p&gt;Abp vNext是Abp的下一代版本，目前还在经一步完善，代码已经全部重写了，好的东西保留了下来，去除了很多笨重的东西，从官宣来看，Abp vNext主要是为了以后微服务架构而诞生的。&lt;/p&gt;
&lt;p&gt;从源码来看，Abp vNext已经支持了多种数据库，Sql Server，MySql，PostgreSql等。默认情况下，你创建的项目使用的是Sql Server版本，如果需要切换到MySql的话，仅需要：&lt;/p&gt;
&lt;p&gt;第一步，在你的EntityFrameworkCore（Abp的EF框架模块，用来创建DbContext，数据迁移用的）中，从NuGet中安装&lt;code&gt;Volo.Abp.EntifyFrameworkCore.MySql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步，打开&lt;code&gt;TGDbContextFactory.cs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第三部，修改代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public TGDbContext CreateDbContext(string[] args)
{
    var configuration = BuildConfiguration();

    var builder = new DbContextOptionsBuilder&amp;lt;TGDbContext&amp;gt;()
        
        .UseSqlServer(configuration.GetConnectionString(&quot;Default&quot;));

    return new TGDbContext(builder.Options);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public TGDbContext CreateDbContext(string[] args)
{
    var configuration = BuildConfiguration();

    var builder = new DbContextOptionsBuilder&amp;lt;TGDbContext&amp;gt;()
        
        .UseMySQL(configuration.GetConnectionString(&quot;Default&quot;));

    return new TGDbContext(builder.Options);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原本以为这样就能ok的，update-database的时候一堆错误，去issue上看了下，都有这个问题，有人建议用Pomele的MySql驱动，还提了PR，当我今天(3月9号)去看的时候PR已经通过，但Nuget包还未更新。&lt;/p&gt;
&lt;p&gt;自给自足丰衣足食，自己来吧，其实非常简单&lt;/p&gt;
&lt;p&gt;先去掉刚引入的&lt;code&gt;Volo.Abp.EntityFrameworkCore.MySql&lt;/code&gt;,然后引入&lt;code&gt;Pomelo.EntityFrameworkCore.MySql&lt;/code&gt;,随后上述代码改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public TGDbContext CreateDbContext(string[] args)
{
    var configuration = BuildConfiguration();

    var builder = new DbContextOptionsBuilder&amp;lt;TGDbContext&amp;gt;()
        
        .UseMySql(configuration.GetConnectionString(&quot;Default&quot;));

    return new TGDbContext(builder.Options);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok，简单改造完成，我们再来update-database，我们的创建顺利的完成了。&lt;/p&gt;
&lt;p&gt;你以为结束了吗，幼稚！默认启动的时候他还是会选择Sql Server，我们看下代码，在&lt;code&gt;Web&lt;/code&gt;项目下的&lt;code&gt;xxWebModule.cs&lt;/code&gt;，xx是你的项目名，这个是我们web的Module文件，我们知道Abp是一个Module加载的框架。在这个项目中同样引入&lt;code&gt;Pomelo.EntityFrameworkCore.MySql&lt;/code&gt;，随后修改&lt;code&gt;ConfigureDatabaseServices&lt;/code&gt;方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void ConfigureDatabaseServices()
{
    Configure&amp;lt;AbpDbContextOptions&amp;gt;(options =&amp;gt;
    {
        options.Configure(context =&amp;gt;
        {
            if (context.ExistingConnection != null)
            {
                context.DbContextOptions.UseMySql(context.ExistingConnection);
            }
            else
            {
                context.DbContextOptions.UseMySql(context.ConnectionString);
            }
        });
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改完以上的代码，你就可以顺利启动Abp vNext for MySql了。&lt;/p&gt;
&lt;p&gt;改的不是很优雅，毕竟下一个版本应该会解决这个问题。之前用Abp Core做了小程序并放到了生产环境，启动慢了点，但是运行什么都比较稳定，开发也比较便捷，看了Abp vNext后，感觉一种小清新，相信在不久之后，我会使用它放到生产环境。其实一些老鸟的话，自己都有自己的框架，说实在的，Abp的好处就在于能够让大家有一种统一的快速的开发方式。&lt;/p&gt;
&lt;p&gt;PS：陪儿子写字写了3个小时，写1个字发呆5分钟以上，能理解这种痛苦吗？&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 07:06:00 +0000</pubDate>
<dc:creator>James.Ying</dc:creator>
<og:description>Abp vNext是Abp的下一代版本，目前还在经一步完善，代码已经全部重写了，好的东西保留了下来，去除了很多笨重的东西，从官宣来看，Abp vNext主要是为了以后微服务架构而诞生的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/inday/p/abp-vNext-for-Mysql.html</dc:identifier>
</item>
<item>
<title>持续迭代的电商可视化运营页面生成系统 - 大转转FE</title>
<link>http://www.cnblogs.com/zhuanzhuanfe/p/10500786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuanzhuanfe/p/10500786.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上个月在前端早读课做了一次关于“可视化运营页面生成系统”的live，本篇文章是这次live的文字记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在电商领域，活动运营扮演着极为重要的角色，一场成功的运营活动甚至可以为公司创造数千亿的成交额。所以，服务好运营同学，是技术团队必须要做好的重中之重。纵观转转发展的几年时间内，随着公司规模增长，运营团队成员呈现急速扩充趋势。相对的，技术侧资源紧张的弊端则日益凸显，如何用极少的人力hold住大量的运营需求，相信不止转转，每一个高速增长中企业都有着类似的诉求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144816340-245704563.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而本场live中，我们将会从运营活动的基本特性出发, 透过实际应用案例，推断出活动页面生成系统的核心需求，最后引申出一套维护成本低，可持续&quot;自我进化“的活动页面生成系统，因为这个叫法过于拗口，所以下面我们将简称为可视化系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144827722-660268622.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先明确一点，这套系统是服务于公司内的运营同学帮助他们提高产出效率的工具。注意，“公司内”这一点非常之重要，因为他给定了一个子集。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大家看第一条，类比于大家都熟悉的标准的运营模型AAARR(获取用户, 提高活跃度, 提高留存率，获取收入，自传播)，因为我们作为一个逐渐打磨产品的创业公司，现阶段运营其实是用户获取，激发活跃，提高转化率这三个方面的，这就是我们的子集，换言之裂变玩法，自传播这块就暂时不需要投入太多精力去做。&lt;/li&gt;
&lt;li&gt;第二点，最快速度，最低成本，质量尚可，众所众知，大部分运营活动经常卡某个时间点上线或者追热点，而且持续时间很短，所以投入太多资源打磨产品是没有必要也不现实的。&lt;/li&gt;
&lt;li&gt;第三点，多端投放，渠道投放进行引流，所以其实这种需求对于运营这块快速兼容各种app是有很高要求的，因为瞬时峰值很大，所以结构要设计的尽可能简单，这点咱们放在后面的部分详细谈。&lt;/li&gt;
&lt;li&gt;然后第四点，也是最重要的部分，公司方向慢变量，运营效果快变量。借用何帆老师在变量里面提到的变量的观点，快变量很好理解啊，今天我们发放了一笔优惠券，4毛100块，过了两天发现运营搞得特别好，全国人民都知道这事了，但是花的钱太多了，怎么办？动态的需要调整。金额，中奖几率，法律条款，文案，甚至图片颜色，一位富有经验的运营同学需要时时的监控数据的变化并进行快速调整，而且常常半夜守在公司，所以大家在碰到运营汪低三下四的求着改文案的时候，也千万要体谅一下他们。&lt;br/&gt;公司发展慢变量，这个就厉害了，他是指公司战略层面进行调整， 持续增长，变现能力，一切经营活动都是紧扣一个主题进行的。如果想在一个阶段内支撑好某个旋律，就一定要有快速跟进甚至打好提前量的思维。有人说这个是不是太虚了。好，让我们来看一组数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144839659-95979856.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边的图是周末统计出来的我们可视化平台上面的组件使用情况，最内圈上面的两种颜色是我特别追加上去的，较浅的代表2017-2018年上半年红包发放组件占整体活动页面的比例，大概是40%-50%之间，而18年下半年急降至不足20%，相反，对于商品展示流组件的需求大大提升。这是由于公司战略由拉新用户逐渐倾斜于订单转化率的大格局导致的，如果前瞻性的定制了大量红包组件的功能，最后的结果可能是很糟的，中台面临的最尴尬问题，辛辛苦苦做出来东西但是没人用。这种滋味并不好受。&lt;/p&gt;
&lt;p&gt;眼尖的同学已经注意到了，除了说明公司大战略变化对于可视化平台组件需求的影响，这张图片还有几个更有趣的数据，红包组件，图片组件，商品组件在该平台的使用率分别达到了79%， 71%和20%。而这三个高频组件组织在一起使用率高达72%。换言之，这三个组件提供了可视化平台3/4的能力。如果您是一个小型电商公司，开发好这三种组件混搭布局的方案足以解放大半研发成本。&lt;br/&gt;还是想象不出来？让我们看下实际样例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144847469-1622200158.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看着各种花哨的页面，但其实本质上面就是三种组件组合成的专题页面，看吧，在电商领域，做好了这三个组件，你的可视化系统已经能够生存下来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144856791-1388947439.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好，讲了一些业务层面的东西，现在足以支撑起我们做技术上的选型与判断了，我们思考一个最核心的问题，可视化系统的技术难点究竟在哪？像axure一样的自由布局方案？事件流编辑器？组件的协同工作？谈到可视化编辑大家第一反应一定是上面印象。但是相对的，复杂的技术对于研发投入，维护成本似乎不低。甚至对使用者来说门槛也显得比较高，借用业界的一句灵魂拷问来说：不会写前端的人就会用sketch了吗？。而且，而且业务迭代频繁，接口不统一，各种问题都会让情况变的复杂。公司在变，时代在变，设计一套系统以不变应万变，难。&lt;/p&gt;
&lt;p&gt;所以，我们决定做的简单一点，做一个专注于页面生成发布，组件粗粒度编辑器（就像前面提到的三种组件），同时，通过持续迭代和自定义组件赋予她无穷的可能性。面向运营，也拥抱开发者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144904852-1250070214.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生存还远远不够，回顾一下标题，持续迭代的的电商可视化运营页面生成系统。是的，我们不但要生存下去，还要迭代，发展起来。所以我们提出了在这三大组件上面的渐进式开发策略，下沉到各个业务线上，一步一步的迭代出各种垂类组件。还是有点抽象？没关系，咱们再具体一点。&lt;/p&gt;
&lt;p&gt;左边是我们的双十一预热抽奖页面，这是一个典型的与业务同学一同混合开发专题活动，在第一次迭代过程应用了图片组件，商品流组件和自制抽奖。而后分别定制了推荐组件和秒杀组件进行替换。抽奖组件最开始是全部内容接口写死的，但随着之后的活动我们开发了接口的配置项，奖项配置，皮肤配置等等。这个过程是全程持续交付的。运营同学可以通过我们的可视化编辑器随时调整，所以在我们的方案里，可视化平台的核心也是一个组件化交付平台。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144930275-1041153571.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面开始基本就是干货了，我将重点讲一下我们的可视化平台魔方系统，工作原理及架构图，可视化仿真器以及插件系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144937236-446940966.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先来看下我们的主界面，分成预览区域和编辑区域两部分。魔方的特色在于左侧预览区域采用了“仿真器”的设计结构，能够做到逻辑，样式100%与发布后的专题保持一致，并且不需要额外的代码，而且最重要的一点在于，她不借助与任何后端服务。&lt;br/&gt;然后编辑区域则是中规中矩的组件树，页面级别设置，和组件设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144943924-2130301502.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说完了主界面，让我们看下整体的架构，其实这套系统和编译器结构稍稍有点类似，简单的可以划分成预览编辑层，页面生成层和组件层三个部分。每个专题在编辑时会生成一个json文件用以描述该专题的配置信息，然后生成层读入这个json文件，通过webpack打包成一个完整的静态页面，是的，魔方系统从稳定性方面考虑，并没有借助任何ssr或后端模板技术，纯粹是通过webpack进行打包构建的。组件层则是通过npm安装在服务器上，供动态加载器和专题生成器调用，这两块我们一会再详细说。而最下层的核心技术栈则提供了整体的编译脚本和统一版本的第三方依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309144956833-668371949.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好，让我们看下仿真器这块，说仿真之前，其实我们需要先解释一下页面生成了什么、第一段代码其实就是生成器的核心渲染逻辑简化版，返回一个组件列表并且注入相应的数据。在生成层的逻辑中，我们以在生成模板执行构建命令，利用环境变量将专题json读入，通过分析生成下面左侧的代码，通过宏替换注入模板，最后通过webpack构建打包成最终产物。&lt;/p&gt;
&lt;p&gt;而仿真器则是在一个iframe中内置了一个空的模板, 通过父层向iframe注入js(动态加载库)，并修改全局widgetsMap，右下所示。最后通过setState重新渲染页面。整个过程是无需后端参与的。&lt;/p&gt;
&lt;p&gt;关于动态加载库，可以类比code split技术想象成需要哪个组件就请求哪段代码，这里篇幅有限，暂时不展开谈论，感兴趣的可以关注大转转FE进行互动讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309145005483-1470561232.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于分享及其他native拓展能力来说，各个app提供的API并不相同，甚至在某些容器中没有相应的功能，为了让模拟器正常工作，我们需要一种抹平多端差异的公共库，使得各端不会抛出错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309145014368-1529819892.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说完了模拟器，我们想聊一下组件系统，前文说过，可视化平台的核心也是一个组件化交付平台。如果开发一个组件的门槛过高就会导致开发者抛弃这套系统。所以我们设计的一个组件将是下面的样子。&lt;/p&gt;
&lt;p&gt;我们的组件分成两个部分，即组件实体和配置项，在最初的组件开发过程中，不需要任何配置项，魔方组件就是一个普通的react组件，上手的成本非常低。而随着版本迭代，越来越多的配置项进去，我们提供了一套简洁的api用于快速增加配置项。关于配置项这里，我们也尝试过采用json来描述，最后从灵活性上面来看略微不满足需求。而且可拓展性不足。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309145019496-796414393.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;魔方提供了一套内置的api用以轻松的完成某些动作，我总结了一下大概如上6类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309145031527-475290945.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了让开发人员方便的进行定制组件的调试，我们又设计了一套组件开发的sdk工具集，大概包括下面四个方面，第一：第三方库集合，包含全部魔方组件依赖的第三方库，在初始化一次后，任何组件编译过程中不会重新安装。第二，面向开发者透明的构建脚本生成器，用以进行组件的本地化测试构建。第三，一个简易的编辑模拟器，用于开发时测试Config到Preview的数据流动。最后，还有一个用于快速创建项目的组件脚手架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309145039182-652571626.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在组件管理这块，我们采用monorepo+安装时构建的策略来处理组件包的。组件管理的最让人头疼的地方在于组件所依赖的其他第三方npm包的管理，利用monorepo来组织代码可以使结构更加清晰，权限明确，全部组件共享构建脚本使得底层优化更加可控，安装时构建更可以确保第三方组件不会重复或多版本引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309145047254-1131732012.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于第三方的依赖的打包，我们采用一种多层的优化策略，按重要程度划分成4个类型，金字塔最上面的是必要且稳定的一类，比如react，antd，这种是通过dllplugin打包成一个js，所有的专题均引用这一个js。其次是部分组件依赖的，组件构建时extrenal掉，当专题生成时打包进专题内，比如无限滚动插件。还有一种会频繁更新，采用外链直接引用的方式，而其他未知组件，是禁止添加到项目源码中的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201903/1203274-20190309145054527-437177576.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说了这么多实现细节，再说点我们的梦想，从最开始的架构图其实可以看出，魔方的本质是可视化生成json，然后读取json生成静态页面，实际通过描述甚至可以组装成native页面，微信小城序，产出存在着各种的可能。我们也会陆续尝试向这个方向探索，然后回顾一下我们的仿真器，我认为可以在生成页面时进行预渲染提升速度，最后就是随着公司规模扩大现在看起来单机构建效率不足，所以我们会考虑利用分布式构建来提升效率。&lt;/p&gt;
&lt;p&gt;好了，总结一下本次live的观点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;运营活动有很多特征，比如我们的电商公司：图片，商品流和红包是运营的核心要素。&lt;/li&gt;
&lt;li&gt;运营活动千变万化，以不变应万变很难，所以让可视化系统保持生命力的关键是持续迭代和支持插件。&lt;/li&gt;
&lt;li&gt;魔方的工作方式是通过可视化编辑器生成json，通过json注入模板生成静态页面。&lt;/li&gt;
&lt;li&gt;开放插件及定制能力需要完善的配套系统。&lt;/li&gt;
&lt;li&gt;插件系统棘手的难点在于第三方依赖的管理。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 09 Mar 2019 07:02:00 +0000</pubDate>
<dc:creator>大转转FE</dc:creator>
<og:description>上个月在前端早读课做了一次关于“可视化运营页面生成系统”的live，本篇文章是这次live的文字记录。 在电商领域，活动运营扮演着极为重要的角色，一场成功的运营活动甚至可以为公司创造数千亿的成交额。所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuanzhuanfe/p/10500786.html</dc:identifier>
</item>
<item>
<title>async await 使用笔记 - wust_hy</title>
<link>http://www.cnblogs.com/wust-hy/p/10500826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wust-hy/p/10500826.html</guid>
<description>&lt;p&gt;　　JavaScript的网络请求异步的，即网络请求不会阻塞当前 js 代码的继续执行，而是通过回调的方式，网络请求的代码块中注入回调函数，当网络请求完成，会触发相应的事件，通过触发事件来执行注册的回调函数。回调的执行时间是不确定的，因此会影响程序的执行逻辑，另一方面，如果回调依赖过多，或导致很深的回调嵌套，使代码的可读性和可维护性降低。&lt;/p&gt;
&lt;p&gt;　　async await 是 es7 中的新语法，基于 promise，使异步调用扁平化。&lt;/p&gt;
&lt;p&gt;　　async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法异步执行完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; asyncFunctionName(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     const response =&lt;span&gt;await fetch(url,options);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     const result =&lt;span&gt;await response.text();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSON.parse( result );
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　asyncFunction 返回的返回值会通过 Promise.resolve()封装成 Promise 对象，通过 Promise.then（）来获取return 的返回值。&lt;/p&gt;
&lt;p&gt;　　await 等待的是一个实际返回值，同时await 不仅仅用于等待 Promise对象，它可以用于等待任何表达式的返回，因此await后面实际是可以接普通函数的调用或者直接量的。如果await 等到的不是一个promise对象，那await 表达式后面的运算结果就是它等到的值；如果await 等到的是一个promise对象，await 就会阻塞当前 js 的继续执行，等着 promise 对象 reslove,得到 resolve 的值，作为await 表达式的运算结果。&lt;/p&gt;
&lt;p&gt;　　因为await 会阻塞代码的运行，所以await 必须放在async 函数体中，而async 函数的调用不会造成阻塞，它内部所有的阻塞都被封装在一个 promise 对象中异步执行。&lt;/p&gt;
&lt;p&gt;　　async await的优势对比promise在于处理then链。在async函数体中，可以把对异步返回值得处理程序放在 await 后面，程序会依次执行，可以像写同步代码一样写异步回调。&lt;/p&gt;
&lt;p&gt;　　注意点：await 等待的promise 对象，运行时可能会reject ,所以最好将await 放在 try{ } catch 代码块中。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 async ()=&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        const response &lt;/span&gt;=&lt;span&gt;  await  felch(url,options); 
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err=&amp;gt;&lt;span&gt;{
        console.log(err)
    })
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对比 promise 链式调用&lt;/span&gt;
&lt;span&gt;    
    promise.then().&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;() 
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 09 Mar 2019 06:59:00 +0000</pubDate>
<dc:creator>wust_hy</dc:creator>
<og:description>JavaScript的网络请求异步的，即网络请求不会阻塞当前 js 代码的继续执行，而是通过回调的方式，网络请求的代码块中注入回调函数，当网络请求完成，会触发相应的事件，通过触发事件来执行注册的回调函</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wust-hy/p/10500826.html</dc:identifier>
</item>
<item>
<title>Shiro源码分析之SecurityManager对象获取 - ゞ .邓澎波</title>
<link>http://www.cnblogs.com/dengpengbo/p/10500827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dengpengbo/p/10500827.html</guid>
<description>&lt;p&gt;@&lt;br/&gt;  上篇文章&lt;a href=&quot;https://blog.csdn.net/qq_38526573/article/details/88360084&quot;&gt;Shiro源码分析之获取SecurityManager工厂获取&lt;/a&gt;我们介绍了SecurityManager工厂的获取步骤，本文在此基础上来分析下SecurityManager对象产生的过程。&lt;/p&gt;

&lt;h2 id=&quot;securitymanager接口介绍&quot;&gt;1.SecurityManager接口介绍&lt;/h2&gt;
&lt;p&gt;  SecurityManager安全管理器,是Shiro的核心,继承了三个接口，其定义的方法如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface SecurityManager extends Authenticator, Authorizer, SessionManager {
    // 登录
    Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException;
    // 注销   
    void logout(Subject subject);
    // 获取Subject对象
    Subject createSubject(SubjectContext context);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文重点不是分析SecurityManager的结构,所以此处略过。&lt;/p&gt;
&lt;h2 id=&quot;securitymanager实例化时序图&quot;&gt;2.SecurityManager实例化时序图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309105205487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;3.源码分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3.1.AbstractFactory&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public T getInstance() {
     T instance;
     // 判断是否是单例，默认就是单例
     if (isSingleton()) {
         if (this.singletonInstance == null) {
            // 创建实例
             this.singletonInstance = createInstance();
         }
         instance = this.singletonInstance;
     } else {
         instance = createInstance();
     }
     if (instance == null) {
         String msg = &quot;Factory 'createInstance' implementation returned a null object.&quot;;
         throw new IllegalStateException(msg);
     }
     return instance;
 }
// 模板模式  定义抽象方法，交给子类实现
protected abstract T createInstance();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.2 IniFactorySupport&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public T createInstance() {
    // 获取Ini对象 该对象在获取SecurityManager工厂的时候被实例化了
    Ini ini = resolveIni();

    T instance;

    if (CollectionUtils.isEmpty(ini)) {
        log.debug(&quot;No populated Ini available.  Creating a default instance.&quot;);
        instance = createDefaultInstance();
        if (instance == null) {
            String msg = getClass().getName() + &quot; implementation did not return a default instance in &quot; +
                    &quot;the event of a null/empty Ini configuration.  This is required to support the &quot; +
                    &quot;Factory interface.  Please check your implementation.&quot;;
            throw new IllegalStateException(msg);
        }
    } else {
        log.debug(&quot;Creating instance from Ini [&quot; + ini + &quot;]&quot;);
        // 创建实例
        instance = createInstance(ini);
        if (instance == null) {
            String msg = getClass().getName() + &quot; implementation did not return a constructed instance from &quot; +
                    &quot;the createInstance(Ini) method implementation.&quot;;
            throw new IllegalStateException(msg);
        }
    }

    return instance;
}
// 抽象方法 进入子类中查看
protected abstract T createInstance(Ini ini);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.3 IniSecurityManagerFactory&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected SecurityManager createInstance(Ini ini) {
     if (CollectionUtils.isEmpty(ini)) {
         throw new NullPointerException(&quot;Ini argument cannot be null or empty.&quot;);
     }
     // 通过createSecurityManager获取实例
     SecurityManager securityManager = createSecurityManager(ini);
     if (securityManager == null) {
         String msg = SecurityManager.class + &quot; instance cannot be null.&quot;;
         throw new ConfigurationException(msg);
     }
     return securityManager;
 }

 private SecurityManager createSecurityManager(Ini ini) {
     // 获取Ini中保存的shiro.ini文件中的section的 main信息
     Ini.Section mainSection = ini.getSection(MAIN_SECTION_NAME);
     if (CollectionUtils.isEmpty(mainSection)) {
         //try the default: 默认是 &quot;&quot;
         mainSection = ini.getSection(Ini.DEFAULT_SECTION_NAME);
     }
     return createSecurityManager(ini, mainSection);
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.4 进入createSecurityManager方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private SecurityManager createSecurityManager(Ini ini, Ini.Section mainSection) {
    // 创建默认的 SecurityManager和IniRealm 跳转到3.4.1
    Map&amp;lt;String, ?&amp;gt; defaults = createDefaults(ini, mainSection);
    // 绑定对象到SecurityManager对象
    Map&amp;lt;String, ?&amp;gt; objects = buildInstances(mainSection, defaults);
    // 从objects 中获取SecurityManager对象
    SecurityManager securityManager = getSecurityManagerBean();
    // 判断是否自动应用realm
    boolean autoApplyRealms = isAutoApplyRealms(securityManager);
    // 因为我们在shiro.ini中配置了users所以前面创建了IniRealm所以为true
    if (autoApplyRealms) {
        //realms and realm factory might have been created - pull them out first so we can
        //initialize the securityManager:
        Collection&amp;lt;Realm&amp;gt; realms = getRealms(objects);
        //set them on the SecurityManager
        if (!CollectionUtils.isEmpty(realms)) {
            // 将IniRealm绑定到了SecurityManager中
            applyRealmsToSecurityManager(realms, securityManager);
        }
    }
    // 初始化Realm 跳至 3.5处
    initRealms(securityManager);

    return securityManager;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.4.1 此处需要进入createDefaults查看&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Map&amp;lt;String, ?&amp;gt; createDefaults(Ini ini, Ini.Section mainSection) {
     Map&amp;lt;String, Object&amp;gt; defaults = new LinkedHashMap&amp;lt;String, Object&amp;gt;();
    // 此处的代码 实例化了SecurityManager 对象 
    // 3.4.2进入createDefaultInstance查看
     SecurityManager securityManager = createDefaultInstance();
     defaults.put(SECURITY_MANAGER_NAME, securityManager);
    // 判断ini中是否隐含的有realm 3.4.3查看
     if (shouldImplicitlyCreateRealm(ini)) {
        // 创建realm 查看createRealm方法 3.4.4查看
         Realm realm = createRealm(ini);
         if (realm != null) {
             defaults.put(INI_REALM_NAME, realm);
         }
     }

     return defaults;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.4.2 createDefaultInstance方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected SecurityManager createDefaultInstance() {
    // SecurityManager模式的实现是DefaultSecurityManager实例
    return new DefaultSecurityManager();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.4.3 shouldImplicitlyCreateRealm方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected boolean shouldImplicitlyCreateRealm(Ini ini) {
    // 返回结果的判断条件是 ini不为空同时(ini中包含roles或者users)就为true
    return !CollectionUtils.isEmpty(ini) &amp;amp;&amp;amp;
            (!CollectionUtils.isEmpty(ini.getSection(IniRealm.ROLES_SECTION_NAME)) ||
                    !CollectionUtils.isEmpty(ini.getSection(IniRealm.USERS_SECTION_NAME)));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.4.4 createRealm&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; protected Realm createRealm(Ini ini) {
    // 我们可以看到实例化的是IniRealm对象
     IniRealm realm = new IniRealm(ini);
     realm.setName(INI_REALM_NAME);
     return realm;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.5 initRealms&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void initRealms(SecurityManager securityManager) {
    Collection&amp;lt;Realm&amp;gt; realms = getRealms(securityManager);
    if (!CollectionUtils.isEmpty(realms)) {
        LifecycleUtils.init(realms);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.6 LifecycleUtils&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void init(Collection c) throws ShiroException {
    if (c == null || c.isEmpty()) {
        return;
    }
    for (Object o : c) {
        init(o);
    }
}

public static void init(Object o) throws ShiroException {
    if (o instanceof Initializable) {
        init((Initializable) o);
    }
}

public static void init(Initializable initializable) throws ShiroException {
    initializable.init();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.7AuthorizingRealm&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void init() {
    //trigger obtaining the authorization cache if possible
    getAvailableAuthorizationCache();
    onInit(); // 进入IniRealm中
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.8 IniRealm&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void onInit() {
     // This is an in-memory realm only - no need for an additional cache when we're already
     // as memory-efficient as we can be.
     String resourcePath = getResourcePath();

     if (CollectionUtils.isEmpty(this.users) &amp;amp;&amp;amp; CollectionUtils.isEmpty(this.roles)) {
         //no account data manually populated - try the resource path:
         if (StringUtils.hasText(resourcePath)) {
             log.debug(&quot;Resource path {} defined.  Creating INI instance.&quot;, resourcePath);
             Ini ini = Ini.fromResourcePath(resourcePath);
             // 核心方法进入
             processDefinitions(ini);
         } else {
             throw new IllegalStateException(&quot;No resource path was specified.  Cannot load account data.&quot;);
         }
     } else {
         if (StringUtils.hasText(resourcePath)) {
             log.warn(&quot;Users or Roles are already populated.  Resource path property will be ignored.&quot;);
         }
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;processDefinitions&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void processDefinitions(Ini ini) {
    if (CollectionUtils.isEmpty(ini)) {
        log.warn(&quot;{} defined, but the ini instance is null or empty.&quot;, getClass().getSimpleName());
        return;
    }

    Ini.Section rolesSection = ini.getSection(ROLES_SECTION_NAME);
    if (!CollectionUtils.isEmpty(rolesSection)) {
        log.debug(&quot;Discovered the [{}] section.  Processing...&quot;, ROLES_SECTION_NAME);
        // 处理角色信息
        processRoleDefinitions(rolesSection);
    }

    Ini.Section usersSection = ini.getSection(USERS_SECTION_NAME);
    if (!CollectionUtils.isEmpty(usersSection)) {
        log.debug(&quot;Discovered the [{}] section.  Processing...&quot;, USERS_SECTION_NAME);
        // 处理用户信息
        processUserDefinitions(usersSection);
    } else {
        log.info(&quot;{} defined, but there is no [{}] section defined.  This realm will not be populated with any &quot; +
                &quot;users and it is assumed that they will be populated programatically.  Users must be defined &quot; +
                &quot;for this Realm instance to be useful.&quot;, getClass().getSimpleName(), USERS_SECTION_NAME);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.9 TextConfigurationRealm&lt;/strong&gt;&lt;br/&gt;processRoleDefinitions&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void processRoleDefinitions(Map&amp;lt;String, String&amp;gt; roleDefs) {
    if (roleDefs == null || roleDefs.isEmpty()) {
        return;
    }

    for (String rolename : roleDefs.keySet()) {
        String value = roleDefs.get(rolename);

        SimpleRole role = getRole(rolename);
        if (role == null) {
            role = new SimpleRole(rolename);
            // 添加角色
            add(role);
        }

        Set&amp;lt;Permission&amp;gt; permissions = PermissionUtils.resolveDelimitedPermissions(value, getPermissionResolver());
        // 添加权限
        role.setPermissions(permissions);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;processUserDefinitions&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void processUserDefinitions(Map&amp;lt;String, String&amp;gt; userDefs) {
    if (userDefs == null || userDefs.isEmpty()) {
        return;
    }

    for (String username : userDefs.keySet()) {

        String value = userDefs.get(username);

        String[] passwordAndRolesArray = StringUtils.split(value);

        String password = passwordAndRolesArray[0];

        SimpleAccount account = getUser(username);
        if (account == null) {
            account = new SimpleAccount(username, password, getName());
            //添加账号
            add(account);
        }
        account.setCredentials(password);

        if (passwordAndRolesArray.length &amp;gt; 1) {
            for (int i = 1; i &amp;lt; passwordAndRolesArray.length; i++) {
                String rolename = passwordAndRolesArray[i];
                account.addRole(rolename);

                SimpleRole role = getRole(rolename);
                if (role != null) {
                    account.addObjectPermissions(role.getPermissions());
                }
            }
        } else {
            account.setRoles(null);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.10 SimpleAccountRealm&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void add(SimpleRole role) {
    roles.put(role.getName(), role);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; protected void add(SimpleAccount account) {
     String username = getUsername(account);
     this.users.put(username, account);
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309120219386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后回到createSecurityManager方法中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private SecurityManager createSecurityManager(Ini ini, Ini.Section mainSection) {
    // 创建默认的 SecurityManager和IniRealm 
    Map&amp;lt;String, ?&amp;gt; defaults = createDefaults(ini, mainSection);
    // 绑定对象到SecurityManager对象
    Map&amp;lt;String, ?&amp;gt; objects = buildInstances(mainSection, defaults);
    // 从objects 中获取SecurityManager对象
    SecurityManager securityManager = getSecurityManagerBean();
    // 判断是否自动应用realm
    boolean autoApplyRealms = isAutoApplyRealms(securityManager);
    // 因为我们在shiro.ini中配置了users所以前面创建了IniRealm所以为true
    if (autoApplyRealms) {
        //realms and realm factory might have been created - pull them out first so we can
        //initialize the securityManager:
        Collection&amp;lt;Realm&amp;gt; realms = getRealms(objects);
        //set them on the SecurityManager
        if (!CollectionUtils.isEmpty(realms)) {
            // 将IniRealm绑定到了SecurityManager中
            applyRealmsToSecurityManager(realms, securityManager);
        }
    }
    // 初始化Realm 
    initRealms(securityManager);

    return securityManager;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化SecurityManager完成&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4.总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;SecurityManager默认实例的是DefaultSecurityManager&lt;/li&gt;
&lt;li&gt;如果我们在shiro.ini配置文件配置了[Users]的话那么会自动创建IniRealm&lt;/li&gt;
&lt;li&gt;创建的IniRealm会被绑定到SecurityManager对象中，并且会将账号密码保存到SimpleAccountRealm的User集合中，认证的时候会从此对象中获取&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 09 Mar 2019 06:59:00 +0000</pubDate>
<dc:creator>ゞ .邓澎波</dc:creator>
<og:description>@[toc]   上篇文章 'Shiro源码分析之获取SecurityManager工厂获取' 我们介绍了SecurityManager工厂的获取步骤，本文在此基础上来分析下Sec</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dengpengbo/p/10500827.html</dc:identifier>
</item>
<item>
<title>ES6基础（二） - 行千里之狗</title>
<link>http://www.cnblogs.com/zhen-prz/p/10487992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhen-prz/p/10487992.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、ES6字符串扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;字符串模板&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在传统的JavaScript语言中，输出模板通常是这样写的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306185931914-199720703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这种写法繁琐不方便，于是ES6中引入了字符串模板解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306190154787-1624666332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用反引号（`）标识。他可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。&lt;/p&gt;
&lt;p&gt;如果使用模板字符串表示多行字符串，所有的空格和缩进都会保留在输出当中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306190722324-2006996963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&amp;lt;ul&amp;gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306190924372-837451375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板字符串中嵌入变量，需要将变量名写在${}之中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306191612591-2143257483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大括号内部可以放入任意JavaScript表达式，可以进行计算，以及引用对象属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306191822167-16563456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板字符中还能调用函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306191942364-1985357735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。&lt;/p&gt;
&lt;p&gt;如果模板字符串中的变量没有声明，将会报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306192318052-251923657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板字符串甚至还能嵌套。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306192423910-294015169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　&lt;span&gt;includes(), startsWith(), endsWith() &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;在JavaScript中只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。而ES6中有提供了三种新方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--includes()&lt;/strong&gt;：返回布尔值，表示是否找到了参数字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--startsWith()&lt;/strong&gt;：返回布尔值，表示参数数字字符串是否在原字符串的头部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--endsWith()&lt;/strong&gt; ：返回布尔值，表示参数数字字符串是否在原字符串的尾部。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306193802444-1306784001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这三个方法都是支持第二个参数，表示开始搜索的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306193855496-355737531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。&lt;/p&gt;
&lt;p&gt;  　&lt;strong&gt;　&lt;span&gt;repeat()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;repeat方法返回一个新字符串，表示将原字符串重复n次。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306194246533-1164206849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果参数是小数，那么会被取整，且不会进行四舍五入，小数点后的书都会被舍弃掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306194332296-1993439233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果repeat的参数是负数或者Infinity，会报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306194439891-1834472164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，如果参数是 0 到 -1 之间的小数，则等同于 0 ，这是因为会先进行取整运算。0 到 -1 之间的小数，取整以后等于 -0，repeat视同为 0 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306194648630-1669421648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数NaN等同于 0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306194735952-2099847557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果repeat的参数是字符串，则会先转换成数字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306194826895-1488235404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　&lt;span&gt;padStart()，padEnd()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;padStart()用于头部补齐，padEnd()用于尾部补齐。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306195041192-282384985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的长度，第二个参数是用来补全的字符串。&lt;/p&gt;
&lt;p&gt;如果 原字符串的长度大于或等于最大的长度，则字符串不生效，返回原字符串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306195352101-500587766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果用来补齐的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出部分的补全字符串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306195516751-1308177387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果省略第二个参数，默认使用空格补齐长度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190306195644308-721639890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、正则的扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;RegExp 构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在ES5中，&lt;strong&gt;RegExp&lt;/strong&gt;构造函数的参数有两种情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种是：参数是字符串，这是第二个参数表示正则表达式的修饰符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190309140212858-262331180.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二种是：参数是正则表达式，这时会返回一个原有正则表达式的拷贝。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190309140318421-1872441007.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，在ES5中不允许此时使用第二个参数添加修饰符，否则就会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190309140437728-944384652.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;所以，在ES6中就改变咯额这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1536089/201903/1536089-20190309140808973-978821120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的代码中，原有的正则对象的修饰符是ig，他会被第二个参数i覆盖。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   　　字符串的正则方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;字符串对象共有4种方法，可以使用正则表达式：&lt;span&gt;&lt;strong&gt;match()、replace()、search()、split()&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这4种方法咋语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全部定义在RegExp对象上。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;String.prototype.match&lt;/code&gt;&lt;/span&gt; 调用 &lt;span&gt;&lt;code&gt;RegExp.prototype[Symbol.match]&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;String.prototype.replace&lt;/code&gt;&lt;/span&gt; 调用 &lt;span&gt;&lt;code&gt;RegExp.prototype[Symbol.replace]&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;String.prototype.search&lt;/code&gt;&lt;/span&gt; 调用 &lt;span&gt;&lt;code&gt;RegExp.prototype[Symbol.search]&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;String.prototype.split&lt;/code&gt;&lt;/span&gt; 调用 &lt;span&gt;&lt;code&gt;RegExp.prototype[Symbol.split]&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 09 Mar 2019 06:20:00 +0000</pubDate>
<dc:creator>行千里之狗</dc:creator>
<og:description>一、ES6字符串扩展 字符串模板 在传统的JavaScript语言中，输出模板通常是这样写的。 上面这种写法繁琐不方便，于是ES6中引入了字符串模板解决这个问题。 用反引号（`）标识。他可以当做普通字</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhen-prz/p/10487992.html</dc:identifier>
</item>
<item>
<title>从零开始学TensorFlow - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10500623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10500623.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只有光头才能变强。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.9545454545455&quot;&gt;
&lt;p&gt;文本已收录至我的GitHub仓库，欢迎Star：&lt;a href=&quot;https://github.com/ZhongFuCheng3y/3y&quot; class=&quot;uri&quot;&gt;https://github.com/ZhongFuCheng3y/3y&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UmRQS3N.png&quot; alt=&quot;TensorFlow logo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近在学习TensorFlow的相关知识，了解了TensorFlow一些基础的知识，现在周末有空了，就写写一些笔记，记录一下自己的成长~&lt;/p&gt;
&lt;p&gt;总的来说，TensorFlow还是一个比较新的技术，有兴趣的同学不妨跟着我的笔记，一起学学呗(反正没坏处)~&lt;/p&gt;
&lt;p&gt;前面回顾：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;知识背景：没有Python基础，没有机器学习基础，可以说是真正从零学TensorFlow的了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一安装tensorflow所需要的环境&quot;&gt;一、安装Tensorflow所需要的环境&lt;/h2&gt;
&lt;h3 id=&quot;安装python环境&quot;&gt;1.1安装Python环境&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;使用环境：&lt;strong&gt;Mac&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Python有好多个版本，在Mac中自带的Python版本是&lt;code&gt;2.7&lt;/code&gt;，但相对而言比较老了。现在一般用&lt;code&gt;Python3.x&lt;/code&gt;了，本次下载的版本是&lt;code&gt;3.5.6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我安装Python所使用方法的大致步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装Homebrew&lt;/li&gt;
&lt;li&gt;安装pyenv&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;.bash_profile&lt;/code&gt;添加环境变量&lt;/li&gt;
&lt;li&gt;让环境变量生效&lt;/li&gt;
&lt;li&gt;安装&lt;code&gt;3.X版本python&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;详情可参考如下的链接(总的来说，我根据下面的教程一下子就安装了我想要的Python版本，还是非常不错的。)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mac下安装多版本python：
&lt;/li&gt;
&lt;li&gt;pyenv相关的命令(常用的pyenv命令):
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在安装Python的时候也发现了一个小知识点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mac一般使用bash作为默认的shell，会有好几个环境变量，其中&lt;code&gt;etc/profile&lt;/code&gt;是&lt;strong&gt;系统级&lt;/strong&gt;的，还有几个&lt;strong&gt;用户级别&lt;/strong&gt;的环境变量，比如说：&lt;code&gt;~/.bash_profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果修改的是系统级别的环境变量，也就是&lt;code&gt;etc/profile&lt;/code&gt;，在保存的时候只能是&lt;code&gt;:wq&lt;/code&gt;!覆盖，不然会出现readonly错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(至于TensorFlow和numpy依赖的下载，这里我就不说了，就两条命令就搞掂啦)&lt;/p&gt;
&lt;h3 id=&quot;pycharm编辑器&quot;&gt;1.2PyCharm编辑器&lt;/h3&gt;
&lt;p&gt;Java有&lt;code&gt;IDEA&lt;/code&gt;神器，同样的，Python也有&lt;code&gt;PyCharm&lt;/code&gt;，同样是JetBrains出产的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我在之前从来没使用过PyCharm，也没写过一句的Python代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把Pycharm安装好了之后，我想当然就&lt;code&gt;new project&lt;/code&gt;去用了，然后就&lt;code&gt;next,next,next&lt;/code&gt;，当成IDEA来用。但发现了一个问题：我在之前&lt;strong&gt;明明装好了&lt;/strong&gt;TensorFlow和numpy的依赖，在PyCharm环境下却&lt;strong&gt;识别不出来&lt;/strong&gt;！在&lt;strong&gt;命令行&lt;/strong&gt;窗口下，依赖是存在的！&lt;/p&gt;
&lt;p&gt;后来才发现：如果用PyCharm去new一个project，会&lt;strong&gt;默认建一个解析器&lt;/strong&gt;在当前的项目目录下。而PyCharm会遵守“就近原则”使用当前项目路径下的解析器。而我们添加的依赖(TensorFlow、numpy)是在我们安装Python的路径下的，这就导致了在命令行下找到依赖，而在PyCharm中找不到依赖。&lt;/p&gt;
&lt;p&gt;解决也很简单：在PyCharm&lt;strong&gt;指定&lt;/strong&gt;一下我们安装Python的路径，切换一下就好了。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关于pip安装第三方库，但pycharm中却无法识别的问题；以及pycharm安装第三方库的方法解析
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二体验tensorflow&quot;&gt;二、体验TensorFlow&lt;/h2&gt;
&lt;p&gt;好的，我们现在已经安装好TensorFlow所需要的环境了！(看起来好简单，但还是花了我不少时间....)&lt;/p&gt;
&lt;p&gt;官网的Demo链接(需要科学上网)：&lt;/p&gt;
&lt;p&gt;首先我们来看一下这个例子可以干些什么：我们有非常多张的图片(&lt;strong&gt;数据集&lt;/strong&gt;)，这些图片有不同的类型(比如衣服、鞋子、裤子，&lt;strong&gt;一共有10种类型&lt;/strong&gt;)，把这些数据集扔进我们的神经网络里头，生成出&lt;strong&gt;模型&lt;/strong&gt;。有了模型以后，当我们再将类似的图片扔进去，这个模型可以帮我们&lt;strong&gt;预测&lt;/strong&gt;这张图片是衣服还是鞋子还是裤子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/vBX9dIm.png&quot; alt=&quot;数据集&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后，我跟着官网的代码跑了一(代码我都只是一步一步&lt;strong&gt;复制粘贴&lt;/strong&gt;)，最后跑起来：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# TensorFlow and tf.keras
import tensorflow as tf
from tensorflow import keras

# Helper libraries
import numpy as np

print(tf.__version__)

# 加载数据、区分出测试数据和训练数据
# 注意：如果已经下过，重复下载的话，可能会出现EOFError: Compressed file ended before the end-of-stream marker was reached错误

fashion_mnist = keras.datasets.fashion_mnist
(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()

# 分类的列表
class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

# 查看数据的值
print(train_images.shape)  # 样本的shape(可以看出有多少条样本、维度)
print(len(train_labels))  # label的个数，有多少个样本，就应该有多少个label
print(train_labels)  # label的值，对应上面分类列表(从0到9)


# 对测试数据和训练数据进行预处理(实际上就是归一化)
train_images = train_images / 255.0
test_images = test_images / 255.0

# 设置层  (初始处理)--- 建立神经层
model = keras.Sequential([
    keras.layers.Flatten(input_shape=(28, 28)),
    keras.layers.Dense(128, activation=tf.nn.relu),
    keras.layers.Dense(10, activation=tf.nn.softmax)
])


# 损失函数、优化器、指标
model.compile(optimizer=tf.train.AdamOptimizer(),
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# 将训练集丢进去，训练出模型(Model)
model.fit(train_images, train_labels, epochs=5)

# 将测试数据丢到模型中，评估一下得分(准确率)
test_loss, test_acc = model.evaluate(test_images, test_labels)
print('Test accuracy:', test_acc)

# 评估完准确率以后，我们可以对测试数据进行预测
predictions = model.predict(test_images)

# 选第一个样本预测后的得出最有可能结果
print(np.argmax(predictions[0]))

# 对比结果
print(test_labels[0])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跑出来的结果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(后期注释：这是TensorFlow的版本)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.12.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(后期注释：这是TensorFlow下载数据集的日志)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/train-labels-idx1-ubyte.gz
32768/29515 [=================================] - 0s 3us/step
Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/train-images-idx3-ubyte.gz

26427392/26421880 [==============================] - 12s 0us/step
Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/t10k-labels-idx1-ubyte.gz
8192/5148 [===============================================] - 0s 0us/step
Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/t10k-images-idx3-ubyte.gz

4423680/4422102 [==============================] - 2s 0us/step&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(后期注释：样本的shape)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(60000, 28, 28)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(后期注释：样本有多少条，对应的label就有多少条)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;60000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(后期注释：label的值是从0-9，表示有九种类别)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[9 0 0 ... 3 0 5]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(后期注释：开始训练)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Epoch 1/5
2019-02-19 14:00:46.842852: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA

60000/60000 [==============================] - 4s 65us/step - loss: 0.4995 - acc: 0.8246
Epoch 2/5
60000/60000 [==============================] - 4s 62us/step - loss: 0.3734 - acc: 0.8655
Epoch 3/5
60000/60000 [==============================] - 4s 63us/step - loss: 0.3346 - acc: 0.8788
Epoch 4/5
60000/60000 [==============================] - 4s 63us/step - loss: 0.3102 - acc: 0.8861
Epoch 5/5
60000/60000 [==============================] - 4s 63us/step - loss: 0.2918 - acc: 0.8916

10000/10000 [==============================] - 0s 36us/step&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(后期注释：预测出来的精确度)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Test accuracy: 0.8514&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(后期注释：选第一个样本进行预测，并对比实际的结果)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;9
9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TensorFlow官网的例子(需要科学上网才能进..)&lt;/li&gt;
&lt;li&gt;Tensorflow学习笔记之一：训练你的第一个神经网络——基础分类
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结一下使用tensorflow的步骤&quot;&gt;2.1总结一下使用TensorFlow的步骤&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;加载&lt;/strong&gt;数据：使用dataset的api加载数据，并将数据集&lt;strong&gt;分成&lt;/strong&gt;训练数据和测试数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;检查&lt;/strong&gt;数据：检查&lt;strong&gt;dataSet&lt;/strong&gt;的数据有没有问题(例如，样本的记录数、label的记录数等)&lt;/li&gt;
&lt;li&gt;对数据&lt;strong&gt;预处理&lt;/strong&gt;：对测试数据和训练数据进行&lt;strong&gt;归一化&lt;/strong&gt;处理，目的：减少因为数值的大小所带来的影响(&lt;strong&gt;一般我们会将值都缩小在一个小的范围内&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建立神经网络&lt;/strong&gt;：(输入层、隐藏层、输出层)&lt;/li&gt;
&lt;li&gt;为模型定义损失函数、优化器、指标&lt;/li&gt;
&lt;li&gt;将训练数据丢进我们的神经网络中，生成出Model&lt;/li&gt;
&lt;li&gt;将测试数据丢进我们生成好的Model进行&lt;strong&gt;评估&lt;/strong&gt;，预测出我们的准确率&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三tensorflow介绍&quot;&gt;三、TensorFlow介绍&lt;/h2&gt;
&lt;h3 id=&quot;什么是tensorflow&quot;&gt;3.1什么是TensorFlow&lt;/h3&gt;
&lt;p&gt;如果去Google搜关键字“TensorFlow”，那可能你会看到这么一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;An open source machine learning framework for everyone.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错，TensorFlow就是一个机器学习的&lt;strong&gt;框架&lt;/strong&gt;。至于框架，相信大家也比较好理解了；类比到Java，比如说我们的Spring框架给我们封装了好多好用的API，简化我们的开发(想想当年写Servlet的时候！)&lt;/p&gt;
&lt;p&gt;TensorFlow作为机器学习的框架，同样也给我们封装了好多好用的API，能够&lt;strong&gt;降低&lt;/strong&gt;学习机器学习的&lt;strong&gt;门槛&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就拿上面的例子来说，没想到&lt;strong&gt;那么少的代码&lt;/strong&gt;就可以跑机器学习的“HelloWorld”了！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至于机器学习和神经网络的相关基础，我&lt;strong&gt;强烈&lt;/strong&gt;建议读读这两篇文章！通俗易懂的&lt;strong&gt;科普&lt;/strong&gt;文章：&lt;/p&gt;
&lt;h3 id=&quot;tensorflow的架构&quot;&gt;3.2TensorFlow的架构&lt;/h3&gt;
&lt;p&gt;我们可以发现上面的Demo所用的基础语言是Python，但不要认为TensorFlow就是Python的一个框架。我看到过一个比喻，觉得写得挺好的，粘贴一下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Python 和 Tensorflow 之间的联系，可以类比 Javascript 和 HTML 之间的关系。Javascript 是一种全功能的编程语言，可以实现各种出色的效果。HTML 是用于表示某种类型的实用计算抽象（这里指的是可由 Web 浏览器呈现的内容）的框架。Javascript 在交互式网页中的作用是&lt;strong&gt;组装浏览器看到的 HTML 对象&lt;/strong&gt;，然后在需要时通过将其更新为新的 HTML 来与其交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面再来看看TensorFlow的架构图(Python&lt;strong&gt;只是&lt;/strong&gt;对TensorFlow进行了封装)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/eS0a1M4.png&quot; alt=&quot;Python封装了TensorFlow引擎&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TensorFlow的引擎也是分了很多模块的(这里我们简单了解一下)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4i1Rc1N.png&quot; alt=&quot;TensorFlow架构&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;总结一下这篇文章：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装TensorFlow必要的环境&lt;/li&gt;
&lt;li&gt;跟着官方文档，&lt;strong&gt;体验&lt;/strong&gt;一下TensorFlow(机器学习)的“HelloWorld”
&lt;ul&gt;&lt;li&gt;根据给出的例子，&lt;strong&gt;猜出&lt;/strong&gt;使用TensorFlow(机器学习)时需要做哪些步骤&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TensorFlow就是一个机器学习(深度学习)的框架，提供了很多&lt;strong&gt;实用&lt;/strong&gt;的API方便我们去玩机器学习(深度学习)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相信看到这里，很多人都跟我之前一样，&lt;strong&gt;一脸懵逼&lt;/strong&gt;。对官方给出的例子中的API不熟悉，去查阅相关资料的时候又发现有好多机器学习相关的&lt;strong&gt;术语&lt;/strong&gt;，对这些术语又不了解。然后就循环懵逼..&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
while(true){
    // 循环懵逼..
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实回想&lt;strong&gt;刚学Java的时候&lt;/strong&gt;，也是这么一个过程，当你从屏幕看到“HelloWorld”了以后，&lt;strong&gt;大概率&lt;/strong&gt;来说也是不了解相关的API具体做了什么事(甚至连API都不知道是啥意思)。但花一段时间去学习了以后，就会发现，原来HelloWorld是真的简单！&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public static void main(String[] args) {

    System.out.println(&quot;Hello World&quot;);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后续我会继续更新我学习TensorFlow时的一些&lt;strong&gt;笔记&lt;/strong&gt;，有兴趣的小伙伴不妨跟着我一起学习~&lt;/p&gt;
&lt;p&gt;另外，从文章的开头我也已经说了，我对Python、机器学习都是没有相关基础的，如果有写错的地方不妨在评论区留言指正。&lt;/p&gt;
&lt;p&gt;下一篇预告：TensorFlow是什么意思？Tensor？Flow？介绍TensorFlow一些最基础的知识以及常见的机器学习术语。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;乐于输出&lt;strong&gt;干货&lt;/strong&gt;的Java技术公众号：Java3y。公众号内有200多篇&lt;strong&gt;原创&lt;/strong&gt;技术文章、海量视频资源、精美脑图，不妨来&lt;strong&gt;关注&lt;/strong&gt;一下！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/M73xIhZ.jpg&quot; alt=&quot;帅的人都关注了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;觉得我的文章写得不错，不妨点一下&lt;strong&gt;赞&lt;/strong&gt;！&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 06:19:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>前言 只有光头才能变强。 文本已收录至我的GitHub仓库，欢迎Star： 'https://github.com/ZhongFuCheng3y/3y' 最近在学习TensorFlow的相关知识，了解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10500623.html</dc:identifier>
</item>
<item>
<title>WebApi管理和性能测试工具WebApiBenchmarks - smark</title>
<link>http://www.cnblogs.com/smark/p/10500551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/10500551.html</guid>
<description>&lt;p&gt;&lt;span&gt;说到WebApi管理和测试工具其实已经非常多的了，Postman、Swagger等在管理和维护上都非常出色；在性能测试方面也有不少的工具如:wrk,bombardier,http_load和ab等等。不过这些工具都具有单一性，管理和维护好的在性能测试上比较低效，对于性能测试好的在管理和维护上不理想！以下主要介绍一款基于&lt;code&gt;dotnet core&lt;/code&gt;开发的&lt;code&gt;WebApiBenchmarks&lt;/code&gt;工具，这个工具可以对webapi进行管理和维护并提供高效的性能测试能力，接下来来先预览一下这个小工具再进行详细介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/RPkWhzS.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_2&quot;&gt;功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持简单的服务管理，可以随时对不同服务的API进行单元和压力测试&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持分类的方式管理测试用例，用例支持定义GET,POST,DELETE和PUT等操作的定义&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;提供高效的性能测试支持，在4核的PC上可以达到20W rps的测试效能；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持多API同时压测，并显示相关性能指标数据进行参考和对比&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h2_3&quot;&gt;部署&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;工具可以运行在安装有.net core 2.1或更高版本的Linux和Windows下，工具以http服务的方式启动，通过浏览器访问进行相关操作。 下载工具:&lt;a href=&quot;https://github.com/IKende/WebApiBenchmark&quot;&gt;https://github.com/IKende/WebApiBenchmark&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_4&quot;&gt;&lt;span&gt;运行&lt;/span&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;dotnet &lt;span class=&quot;hljs-selector-tag&quot;&gt;BeetleX&lt;span class=&quot;hljs-selector-class&quot;&gt;.WebApiBenchmarks&lt;span class=&quot;hljs-selector-class&quot;&gt;.dll

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;./webapibenchmark.sh

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;dotnet &lt;span class=&quot;hljs-selector-tag&quot;&gt;BeetleX&lt;span class=&quot;hljs-selector-class&quot;&gt;.WebApiBenchmarks&lt;span class=&quot;hljs-selector-class&quot;&gt;.dll

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;webapibenchmark&lt;span class=&quot;hljs-selector-class&quot;&gt;.bat

&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h2_5&quot;&gt;端口冲突&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;工具默认使用9090端口，如果端口被占则无法启用服务，这个时候需要修改&lt;code&gt;HttpConfig.json&lt;/code&gt;文件中的端口配置&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;hljs bash&quot;&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;Host&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;Port&quot;: 9090,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;SSL&quot;: &lt;span class=&quot;hljs-literal&quot;&gt;false,

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h2_6&quot;&gt;打开工具&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;工具运行后可以浏览器访问相关地址打开工具，本机访问&lt;code&gt;http://localhost:9090/&lt;/code&gt;其他电脑访问&lt;code&gt;http://ipaddress:9090/&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_7&quot;&gt;添加服务地址&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;工具可以维护多个服务地址，所有的测试都必须选择对应的地址才能运行测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/21RxUqG.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址必须是一个可用的http服务Url&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_8&quot;&gt;添加测试用例&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;工具支持GET,POST,DELETE和PUT请求定义，可以根据实际情况定义QueryString和Header值，并针对POST和PUT设置相应的Body内容。具体操作界面如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/uEy21gA.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在编辑界面下面有个测试按钮，可以即刻测试API的调用情况；选择相应的服务地址点击测试即可在下方看到完整的返回结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/09D4kOS.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_9&quot;&gt;批量单元测试&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;工具支持批量执行测试用例，并在测试用例上显示具体的执行结果；只要选择需要测试的用例点击单元测试即可:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/dLFurrb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2_10&quot;&gt;性能测试&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;性能测试是组件提供的最重要功能，为了确保性能测试的效率；组件重写了一个轻量化的HttpClient,通过这个HttpClient即使在低配置的电脑上也可以进行高效率的压力测试。测试前需要选择相应的服务地址和单元测试用例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/rfEBobs.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h3_11&quot;&gt;测试参数设置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;工具提供两种测试方式，分别是基于时间和总请求数据，选择对应的测试方式设置相应的测试数值即可；用户数是指同时请求的数量，工具限制设置最大2000，设置完成后点击开始按钮即可进行测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/k7yuUeR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h3_12&quot;&gt;测试结果&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;工具会实时反映测试的情况，主要包括HTTP响应状态和响应延时分布情况，如果同时压测多个API，则明细里会实时显示每个API的响应状态和响应延时情况。具体如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/vo2iBzO.png&quot; alt=&quot;&quot;/&gt; &lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://i.imgur.com/EVQvfOb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 06:03:00 +0000</pubDate>
<dc:creator>smark</dc:creator>
<og:description>说到WebApi管理和测试工具其实已经非常多的了，Postman、Swagger等在管理和维护上都非常出色；在性能测试方面也有不少的工具如:wrk,bombardier,http_load和ab等等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smark/p/10500551.html</dc:identifier>
</item>
<item>
<title>使用JDBC连接数据库的一些BUG - Turtle_Zhang</title>
<link>http://www.cnblogs.com/zhh19981104/p/10500151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhh19981104/p/10500151.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;题记：前几天用JDBC连接MYSQL数据库的时候，出现了一些BUG，有代码层次的，也有设置层次的，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　下面的解决方法时我目前所遇到的，后期如果还有遇到的会进行补充。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、出现：&lt;span&gt;远程mysql_java.sql.SQLException: null, message from server: &quot;Host 'xxx' is not allowed to connect&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;很明显的意思就是当前数据库不允许我们进行远程连接。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　远程的机器B不允许机器A访问他的数据库。也就是说，我们要解决这个问题，就是要让机器B的数据库允许&lt;/span&gt;机器A访问，就搞定啦；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　立刻到cmd窗口中使用 &amp;gt;mysql -uroot  -proot -h192.168.1.88 -P3306 -Ddb10来连接服务器会显示错误，说明确实是无法通过远程连接到数据库的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　【当初设置的时候没有保存截图，这里就没有放图了，但是有Err的明星错误的】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;注意:前提是使用  &amp;gt;mysql -uroot -proot   这条指令是可以连接到数据库的，不然就是你的环境变量或者是数据库的安装有问题了。&lt;a href=&quot;https://www.cnblogs.com/ayyl/p/5978418.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;MYSQL的安装请点击&lt;/span&gt;&lt;/a&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309113157855-70873457.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;当进入到这个界面我们就可以进行对应的解决方案了&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;　　第一步：输入  use mysql&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　第二步：输入 show tables;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309113751295-383852900.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;再输入相关指令：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;　　第一步：select host from user;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　第二步：update user set host ='%' where user='root';&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　第三步：select host form user;   [检查一下是否更新成功]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309114119772-1132592552.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　然后进入计算机的服务界面，重新启动MYSQL的服务就可以了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309114709449-569856401.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;再去cmd窗口使用远程连接，进入mysql目录就可以成功了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309115057016-2122073012.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;小结：当时整数据库的时候全部用了开发工具，也没有注意到该数据库是否允许远程连接的，一直都是进行本地连接，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　直到后面使用JDBC来连接数据库进行操作的时候才发现这个原因，有点懵懵的，哈哈&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: com/mysql/jdbc/Driver : Unsupported major.minor version 52.0&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;上面这个错误是因为导入的用来连接的jar包和我们当前项目的jdk版本是不一样的，导致版本不一致而出错了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309130743974-1940095152.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span&gt;出现问题原因-----&lt;span&gt;分析&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;{&lt;/strong&gt; JDK版本不一致的问题 &lt;strong&gt;}&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;　　在eclipse中开发的项目有个Java build path中可以配置的JDK&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　java compiler中可以配置compiler level{eclipse&amp;gt;windows&amp;gt;preferences&amp;gt;java&amp;gt;compiler&amp;gt;compiler compliance level}&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;　　build path的JDK版本是你开发的时候编译器需要使用到的，就是你在eclipse中开发代码，给你提示报错的，编译的过程；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　java compiler compliance level中&lt;strong&gt;配置的编译版本号&lt;/strong&gt;，这个编译版本号的作用是，你这个项目将来开发完毕之后，要放到&lt;strong&gt;服务器&lt;/strong&gt;上运行，那个服务器上JDK的运行版本。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　问题就是，build path中配置1.7的JDK，java compiler compliance level中配置的1.7，但是程序运行需要的是1.8的JDK，就报了那个错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　在eclipse中进行开发的时候，build path 中JDK进行类库的编译（就是你使用类在不在这个JDK中),&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　java compiler compliance level是对这个项目语法的编译（就是你的项目中语法的正确与否），在开发的过程中，这两个地方是都起作用的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;span&gt;　&lt;strong&gt;总结:&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;build path 和 java complier compliance level和服务器配置的JDK保持一致，就不会出现任何问题的&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;这个问题的解决方法也是很简单的，首先去查看自己的导入的jar包是在哪个jdk版本下面运行的，然后再更改我们项目的jdk版本号，或者是换用和我们一样版本号的jar包就可以解决了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 这里我导入的是在jdk8上运行的jar包，所以我将我的项目改为jdk8的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 查看我的项目目前的版本是：1.7的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309132148300-685218264.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　第一步、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309131721403-1367488674.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;第二步、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309132038551-2074397454.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　第三步、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309132459363-892446883.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这个时候再查看我们的项目JDK版本是1.8的了。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、上面是解决了由于版本不一致的情况，但是当我运行的时候，会报下面的错误：　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　manual loading of the driver class is generally unnecessary.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309132927420-461084502.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这个就很简单了，白问翻译过来都知道了，就是要换用新的类了，将使用com.mysql.jdbc.Drive的换为com.mysql.cj.jdbc.Driver即可，这是由于我当前使用的是最新的jdbc驱动包，里面的API有跟新了&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、当我把API换为新的了，但是运行的时候又出错了，这回的错是：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value '???ú±ê×??±??' is unrecognized or represents more than one time zone.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265195/201903/1265195-20190309133134967-1799002406.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;仔细阅读，发现是与时间设置相关，仔细研究后发现，是因为新版的Mysql中的时区默认设置与本地时区之间是不同的，因此会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　解决方法即为&lt;span&gt;修改时区设置即可&lt;/span&gt;，可以在连接数据库的url的最后添加这样一段代码 &lt;span&gt;&lt;code&gt;?serverTimezone=UTC&lt;/code&gt;&lt;/span&gt; ，就可以解决问题了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;事例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原来报错的：String url = &quot;jdbc:mysql://176.129.8.53:3306/db10&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　改正后的：String url = &quot;jdbc:mysql://176.129.8.53:3306/db10?serverTimezone=UTC&quot;;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：这是对使用MYSQL的JDBC驱动包进行数据库的操作的时候总结出来的一些解决方案，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;然后分享出来自己当时的一步一步的解决步骤，肯定是不全的，但是就目前而言是可以解决一大部分的错误的了，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;希望可以帮到到家解决对应的BUG，少走一些弯路，谢谢。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　   　2019-03-09 13:46:08&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 05:48:00 +0000</pubDate>
<dc:creator>Turtle_Zhang</dc:creator>
<og:description>题记：前几天用JDBC连接MYSQL数据库的时候，出现了一些BUG，有代码层次的，也有设置层次的， 下面的解决方法时我目前所遇到的，后期如果还有遇到的会进行补充。 一、出现：远程mysql_java.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhh19981104/p/10500151.html</dc:identifier>
</item>
</channel>
</rss>