<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>瞬间教你学会使用java中list的retainAll方法 - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/12892150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/12892150.html</guid>
<description>&lt;h3 id=&quot;retainall方法简介&quot;&gt;retainAll方法简介&lt;/h3&gt;
&lt;p&gt;当我们有两个list集合的时候，我们可以使用retainAll方法求得两个list集合的子集。retainAll是Collection接口中提供的一个方法，各个实现类有自己的实现方式，我们这里介绍ArrayList的实现方式。&lt;/p&gt;
&lt;h3 id=&quot;retainall源码深入&quot;&gt;retainAll源码深入&lt;/h3&gt;
&lt;p&gt;可以看到collection接口中的retainAll方法，需要传入一个集合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean retainAll(Collection&amp;lt;?&amp;gt; c);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入arrayList的方法实现。可以看到如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public boolean retainAll(Collection&amp;lt;?&amp;gt; c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由以上代码可知，传入的集合不能为null。接下来看看batchRemove方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private boolean batchRemove(Collection&amp;lt;?&amp;gt; c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r &amp;lt; size; r++)
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            }
            if (w != size) {
                // clear to let GC do its work
                for (int i = w; i &amp;lt; size; i++)
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到上述方法的流程如下：&lt;br/&gt;首先获得当前对象的所有元素，然后通过r和w变量标记两个集合公共元素的个数。初始化标志位为false。然后进入循环遍历当前集合，如果传入的集合中包含当前集合的元素，就直接将这个元素保存下来。最后到finally块中，如果r不等于size，证明在循环的过程中出现了异常，然后将剩余的元素进行复制，重新计算数组的剩余元素值。如果剩余的元素值不等于size，则将多余的位置进行清空。更改modcount的值。这个modcount是父类abstarctlist的值，初始值为0，集合中的内容没修改一次则增加1。最后重新设置size的大小。返回是否修改值。&lt;/p&gt;
&lt;h3 id=&quot;retainall返回值的说明&quot;&gt;retainAll返回值的说明&lt;/h3&gt;
&lt;p&gt;这里有两个说明。&lt;br/&gt;第一个：如果集合A数组的大小没有改变，则返回false。如果集合A和集合B是完全相同的集合，也会返回false。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
        ArrayList&amp;lt;String&amp;gt; list1= new ArrayList&amp;lt;String&amp;gt;();
        list1.add(&quot;123&quot;);
        ArrayList&amp;lt;String&amp;gt; list2= new ArrayList&amp;lt;String&amp;gt;();
        list2.add(&quot;123&quot;);
        System.out.println(list1.retainAll(list2)); 
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码会返回false。&lt;br/&gt;第二个：两个集合没有交集，会返回true。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
        ArrayList&amp;lt;String&amp;gt; list1= new ArrayList&amp;lt;String&amp;gt;();
        list1.add(&quot;123&quot;);
        ArrayList&amp;lt;String&amp;gt; list2= new ArrayList&amp;lt;String&amp;gt;();
        list2.add(&quot;12345&quot;);
        System.out.println(list1.retainAll(list2));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码会返回true。&lt;br/&gt;总结：当集合A的大小改变的时候返回的是True,大小没有改变的时候返回的是False。&lt;/p&gt;
&lt;h3 id=&quot;retainall的判断方法&quot;&gt;retainAll的判断方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
        ArrayList&amp;lt;String&amp;gt; list1= new ArrayList&amp;lt;String&amp;gt;();
        list1.add(&quot;123&quot;);
        ArrayList&amp;lt;String&amp;gt; list2= new ArrayList&amp;lt;String&amp;gt;();
        list2.add(&quot;123&quot;);
        list1.retainAll(list2);
        if(list1.size()&amp;gt;0){
            System.out.println(&quot;有交集&quot;);
        }else{
            System.out.println(&quot;没有交集&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过判断集合的大小，来确定是否存在交集。不能通过方法返回的True和False来判断。&lt;/p&gt;
&lt;h3 id=&quot;retainall的实际效果使用&quot;&gt;retainAll的实际效果使用&lt;/h3&gt;
&lt;p&gt;我们声明两个集合，通过调用retainAll，保留两个集合的交集。最后再看输出的效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        Collection collection1 = new ArrayList();
        collection1.add(&quot;a&quot;);
        collection1.add(&quot;b&quot;);
        collection1.add(&quot;c&quot;);
        Collection collection2 = new ArrayList();
        collection2.add(&quot;ab&quot;);
        collection2.add(&quot;abc&quot;);
        collection2.add('a');
        System.out.println(collection1);
        boolean flag = collection1.retainAll(collection2);
        System.out.println(flag);
        System.out.println(collection1);
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[a, b, c]
true
[a]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保留了两个结合的交集。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;list的retainAll方法的介绍和分析到此结束，文中难免有不足之处，望大家指正交流。&lt;/p&gt;
</description>
<pubDate>Fri, 15 May 2020 00:29:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>retainAll方法简介 当我们有两个list集合的时候，我们可以使用retainAll方法求得两个list集合的子集。retainAll是Collection接口中提供的一个方法，各个实现类有自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jichi/p/12892150.html</dc:identifier>
</item>
<item>
<title>超过百万的StackOverflow Flutter 问题-第二期 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/12892707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/12892707.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075908150-167854096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;老孟导读：一个月前分享的《超过百万的StackOverflow Flutter 问题-第一期》受到很多朋友的喜欢，非常感谢大家的支持，在文章末尾有第一期的链接，希望此文能对你有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;no-connected-devices&quot;&gt;No connected devices&lt;/h2&gt;
&lt;p&gt;这个问题估计大部分都遇到过，解决方法如下：&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;执行&lt;code&gt;flutter doctor&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Doctor summary (to see all details, run flutter doctor -v):
[✓] Flutter (Channel stable, v1.12.13+hotfix.9, on Mac OS X 10.14.6 18G1012,
    locale zh-Hans-CN)
 
[!] Android toolchain - develop for Android devices (Android SDK version 29.0.2)
    ! Some Android licenses not accepted.  To resolve this, run: flutter doctor
      --android-licenses
[✓] Xcode - develop for iOS and macOS (Xcode 11.3.1)
[✓] Android Studio (version 3.5)
[✓] Connected device (1 available)

! Doctor found issues in 1 category.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保证没有红色的叉。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;启动手机或者模拟器（Android系统大于16），开启&lt;code&gt;USB 调试&lt;/code&gt;模式，不同手机开启方法略有不同，以华为手机为例：进入设置-&amp;gt;系统-&amp;gt;关于手机，快速连续点击版本号5次，提示打开&lt;code&gt;开发者模式&lt;/code&gt;，返回设置，此时会出现&lt;code&gt;开发人员选项&lt;/code&gt;菜单，进入，打开&lt;code&gt;开发人员选项&lt;/code&gt;和&lt;code&gt;USB 调试&lt;/code&gt;，弹出授权菜单，同意即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打开Android Studio，查看连接的手机：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075908674-613252020.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果依然无法连接手机，打开Android Studio设置界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075908893-1178419334.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择最近的API。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;到此基本就可以解决了，如果还无法连接，那基本就是&lt;code&gt;adb&lt;/code&gt;的问题，很可能是&lt;code&gt;adb&lt;/code&gt;端口被占用，关于&lt;code&gt;adb&lt;/code&gt;的解决方案可百度，引起&lt;code&gt;adb&lt;/code&gt;问题有很多种情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;创建toast提示&quot;&gt;创建Toast提示&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;Material Design&lt;/strong&gt;设计规范中&lt;strong&gt;Snackbars&lt;/strong&gt;就是Toast提示，Snackbar用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Scaffold.of(context).showSnackBar(SnackBar(
      content: Text(&quot;Sending Message&quot;),
    ));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075909443-771541386.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个效果在国内来不是很接受，所以一般使用第三方插件&lt;a href=&quot;https://pub.flutter-io.cn/packages/fluttertoast&quot;&gt;fluttertoast&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fluttertoast.showToast(
        msg: &quot;This is Toast messaget&quot;,
        toastLength: Toast.LENGTH_SHORT,
        gravity: ToastGravity.CENTER,
        timeInSecForIos: 1
    );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075909670-758026513.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建一个圆角button&quot;&gt;创建一个圆角Button&lt;/h2&gt;
&lt;p&gt;创建圆角Button的方式有很多种，下面介绍几种简单的：&lt;/p&gt;
&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;FlatButton&lt;/code&gt; 和 &lt;code&gt;RaisedButton&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;shape: RoundedRectangleBorder(
  borderRadius: BorderRadius.circular(18.0),
  side: BorderSide(color: Colors.red)
),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075909867-887509435.jpg&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;使用&lt;code&gt;ClipRRect&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ClipRRect(
  borderRadius: BorderRadius.circular(40),
  child: RaisedButton(
    onPressed: () {},
    child: Text(&quot;Button&quot;),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;使用&lt;code&gt;ButtonTheme&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ButtonTheme(
  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
  child: RaisedButton(
    onPressed: () {},
    child: Text(&quot;Button&quot;),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;添加启动页&quot;&gt;添加启动页&lt;/h2&gt;
&lt;p&gt;Flutter应用程序启动时会出现一段时间的白屏，因为程序要启动引擎，所以App第一次启动比较慢，在原生端会显示一段时间的白色启动页，我们把这个白色启动页做为应用程序的启动页，替换为自己的图片，此方案的启动页只能是一张图片，无法交互，如果需要启动页有交互效果建议使用Flutter做。&lt;/p&gt;
&lt;p&gt;Android端替换启动页图片，打开android/app/src/main/res/drawable/launch_background.xml文件，效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!-- Modify this file to customize your launch splash screen --&amp;gt;
&amp;lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt;
    &amp;lt;item android:drawable=&quot;@android:color/white&quot; /&amp;gt;

    &amp;lt;!-- You can insert your own image assets here --&amp;gt;
    &amp;lt;!-- &amp;lt;item&amp;gt;
        &amp;lt;bitmap
            android:gravity=&quot;center&quot;
            android:src=&quot;@mipmap/launch_image&quot; /&amp;gt;
    &amp;lt;/item&amp;gt; --&amp;gt;
&amp;lt;/layer-list&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!-- Modify this file to customize your launch splash screen --&amp;gt;
&amp;lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt;
    
    &amp;lt;item&amp;gt;
        &amp;lt;bitmap
            android:gravity=&quot;center&quot;
            android:src=&quot;@drawable/splash&quot; /&amp;gt;
    &amp;lt;/item&amp;gt;
&amp;lt;/layer-list&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;splash.png&lt;/code&gt;图片拷贝到drawable文件夹下。&lt;/p&gt;
&lt;p&gt;iOS端，打开ios/Runner/Assets.xcassets/LaunchImage.imageset下面的3张LaunchImage.png图片替换，保持名称不变。&lt;/p&gt;
&lt;h2 id=&quot;修改应用程序的包名bundleidentifier&quot;&gt;修改应用程序的包名/BundleIdentifier&lt;/h2&gt;
&lt;p&gt;Android平台上打开android/app/build.gradle：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;defaultConfig {
    applicationId &quot;com.example.fluttersample&quot;
    minSdkVersion 16
    targetSdkVersion 28
    versionCode flutterVersionCode.toInteger()
    versionName flutterVersionName
    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;strong&gt;applicationId&lt;/strong&gt;属性即可。&lt;/p&gt;
&lt;p&gt;iOS平台打开ios/Runner/Info.plist，修改CFBundleIdentifier的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;&amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER)&amp;lt;/string&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何给一个控件添加边框&quot;&gt;如何给一个控件添加边框&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;new Container(
  margin: const EdgeInsets.all(15.0),
  padding: const EdgeInsets.all(3.0),
  decoration: BoxDecoration(
    border: Border.all(color: Colors.blueAccent)
  ),
  child: Text(&quot;My Awesome Border&quot;),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075910070-1499282756.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;让button充满父组件&quot;&gt;让Button充满父组件&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;SizedBox.expand(
  child: RaisedButton(...),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;SizedBox(
  width: double.infinity,
  // height: double.infinity,
  child: RaisedButton(...),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ConstrainedBox(
    constraints: const BoxConstraints(minWidth: double.infinity),
    child: RaisedButton(...),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ButtonTheme(
  minWidth: double.infinity,
  child: MaterialButton(
    onPressed: () {},
    child: Text('Raised Button'),
  ),
),
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何在column中添加listview&quot;&gt;如何在Column中添加ListView&lt;/h2&gt;
&lt;p&gt;给ListView指定高度：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Column(
  children: &amp;lt;Widget&amp;gt;[
    Container(
      height: 50,
      child: ListView(),
    )
  ],
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者铺满Column：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Column(
  children: &amp;lt;Widget&amp;gt;[
     Expanded(
      child: horizontalList,
    )
  ],
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何给图片添加圆角&quot;&gt;如何给图片添加圆角&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ClipRRect(
    borderRadius: BorderRadius.circular(8.0),
    child: Image.network(
        '',
    ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CircleAvatar(
  radius: 20,
  backgroundImage: NetworkImage('https://via.placeholder.com/140x100')
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;ClipOval(
  child: Image.network(
    &quot;image_url&quot;,
    height: 100,
    width: 100,
    fit: BoxFit.cover,
  ),
),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Container(
        width: 100.0,
        height: 150.0,
        decoration: BoxDecoration(
          image: DecorationImage(
                fit: BoxFit.cover,
                image: NetworkImage('Path to your image')
              ),
          borderRadius: BorderRadius.all(Radius.circular(8.0)),
          color: Colors.redAccent,
        ),
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何去掉textfield的下划线&quot;&gt;如何去掉TextField的下划线&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;InputDecoration(
    border: InputBorder.none,
    hintText: 'Username',
  ),
),
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如果防止ui随着手机的旋转而在横竖屏间切换&quot;&gt;如果防止UI随着手机的旋转而在横竖屏间切换&lt;/h2&gt;
&lt;p&gt;设置支持的方向：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
      SystemChrome.setPreferredOrientations([
        DeviceOrientation.portraitUp,
        DeviceOrientation.portraitDown,
      ]);
      return new MaterialApp(...);
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开ios/Runner/Info.plist，设置支持的方向：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;&amp;lt;array&amp;gt;
    &amp;lt;string&amp;gt;UIInterfaceOrientationPortrait&amp;lt;/string&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;显示隐藏控件&quot;&gt;显示/隐藏控件&lt;/h2&gt;
&lt;p&gt;使用Opacity&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Opacity(
  opacity: .0,
  child: ,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Visibility(
  visible: false,
  child: ,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Offstage(
  offstage: true,
  child: ,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何截取android的返回按键并处理&quot;&gt;如何截取Android的返回按键并处理&lt;/h2&gt;
&lt;p&gt;使用&lt;a href=&quot;http://laomengit.com/flutter/widgets/WillPopScope.html&quot;&gt;&lt;strong&gt;WillPopScope&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
Widget build(BuildContext context) {
  return new WillPopScope(
    onWillPop: () async =&amp;gt; false,
    child: new Scaffold(
      appBar: new AppBar(
        title: new Text(&quot;data&quot;),
        leading: new IconButton(
          icon: new Icon(Icons.ac_unit),
          onPressed: () =&amp;gt; Navigator.of(context).pop(),
        ),
      ),
    ),
  );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何设置raisedbutton控件的width&quot;&gt;如何设置RaisedButton控件的width&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;ButtonTheme(
  minWidth: 200.0,
  height: 100.0,
  child: RaisedButton(
    onPressed: () {},
    child: Text(&quot;test&quot;),
  ),
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SizedBox(
  width: 100, // specific value
  child: RaisedButton(...)
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置appbar的height&quot;&gt;设置AppBar的height&lt;/h2&gt;
&lt;p&gt;使用&lt;strong&gt;PreferredSize&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Example',
      home: Scaffold(
        appBar: PreferredSize(
          preferredSize: Size.fromHeight(50.0), // here the desired height
          child: AppBar(
            // ...
          )
        ),
        body: // ...
      )
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何格式化时间&quot;&gt;如何格式化时间&lt;/h2&gt;
&lt;p&gt;Dart API本身没有格式化时间的接口，使用&lt;a href=&quot;https://pub.flutter-io.cn/packages/intl&quot;&gt;intl&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;import 'package:intl/intl.dart';

DateTime now = DateTime.now();
String formattedDate = DateFormat('yyyy-MM-dd – kk:mm').format(now);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通过list绘制一组控件&quot;&gt;通过List绘制一组控件&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Widget getTextWidgets(List&amp;lt;String&amp;gt; strings)
  {
    List&amp;lt;Widget&amp;gt; list = new List&amp;lt;Widget&amp;gt;();
    for(var i = 0; i &amp;lt; strings.length; i++){
        list.add(new Text(strings[i]));
    }
    return new Row(children: list);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Row(children: strings.map((item) =&amp;gt; new Text(item)).toList())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var list = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]; 

child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &amp;lt;Widget&amp;gt;[
             for(var item in list ) Text(item)
          ],
        ),    
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何设置gridview中组件的height&quot;&gt;如何设置GridView中组件的height&lt;/h2&gt;
&lt;p&gt;使用&lt;strong&gt;childAspectRatio&lt;/strong&gt;，设置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MyHomePage extends StatefulWidget {
  MyHomePage({Key key, this.title}) : super(key: key);

  final String title;

  @override
  _MyHomePageState createState() =&amp;gt; new _MyHomePageState();
}

class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {
  List&amp;lt;String&amp;gt; widgetList = ['A', 'B', 'C'];

  @override
  Widget build(BuildContext context) {
    var size = MediaQuery.of(context).size;

    /*24 is for notification bar on Android*/
    final double itemHeight = (size.height - kToolbarHeight - 24) / 2;
    final double itemWidth = size.width / 2;

    return new Scaffold(
      appBar: new AppBar(
        title: new Text(widget.title),
      ),
      body: new Container(
        child: new GridView.count(
          crossAxisCount: 2,
          childAspectRatio: (itemWidth / itemHeight),
          controller: new ScrollController(keepScrollOffset: false),
          shrinkWrap: true,
          scrollDirection: Axis.vertical,
          children: widgetList.map((String value) {
            return new Container(
              color: Colors.green,
              margin: new EdgeInsets.all(1.0),
              child: new Center(
                child: new Text(
                  value,
                  style: new TextStyle(
                    fontSize: 50.0,
                    color: Colors.white,
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何修改状态条颜色&quot;&gt;如何修改状态条颜色&lt;/h2&gt;
&lt;p&gt;使用&lt;a href=&quot;https://pub.flutter-io.cn/packages/flutter_statusbarcolor&quot;&gt;&lt;strong&gt;flutter_statusbarcolor&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;import 'package:flutter_statusbarcolor/flutter_statusbarcolor.dart';

void main() =&amp;gt; runApp(new MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    FlutterStatusbarcolor.setStatusBarColor(Colors.white);
    return MaterialApp(
      title: app_title,
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: HomePage(title: home_title),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(
  statusBarColor: Colors.white
));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;column的子控件底部居中，左对齐&quot;&gt;Column的子控件底部居中，左对齐&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;return Column(
  crossAxisAlignment: CrossAxisAlignment.center,
  mainAxisSize: MainAxisSize.max,
  mainAxisAlignment: MainAxisAlignment.end,
  children: &amp;lt;Widget&amp;gt;[
      //your elements here
  ],
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（近200个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075910393-1521132770.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200515075910647-938699085.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Thu, 14 May 2020 23:59:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：一个月前分享的《超过百万的StackOverflow Flutter 问题 第一期》受到很多朋友的喜欢，非常感谢大家的支持，在文章末尾有第一期的链接，希望此文能对你有所帮助。 No conn</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/12892707.html</dc:identifier>
</item>
<item>
<title>看完这篇操作系统，和面试官扯皮就没问题了 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/12892684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/12892684.html</guid>
<description>&lt;h2 id=&quot;解释一下什么是操作系统&quot;&gt;解释一下什么是操作系统&lt;/h2&gt;
&lt;p&gt;操作系统是运行在计算机上最重要的一种&lt;code&gt;软件&lt;/code&gt;，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071659861-410484655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常情况下，计算机上会运行着许多应用程序，它们都需要对内存和 CPU 进行交互，操作系统的目的就是为了保证这些访问和交互能够准确无误的进行。&lt;/p&gt;
&lt;h2 id=&quot;解释一下操作系统的主要目的是什么&quot;&gt;解释一下操作系统的主要目的是什么&lt;/h2&gt;
&lt;p&gt;操作系统是一种软件，它的主要目的有三种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。&lt;/li&gt;
&lt;li&gt;提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。&lt;/li&gt;
&lt;li&gt;为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;操作系统的种类有哪些&quot;&gt;操作系统的种类有哪些&lt;/h2&gt;
&lt;p&gt;操作系统通常预装在你购买计算机之前。大部分用户都会使用默认的操作系统，但是你也可以升级甚至更改操作系统。但是一般常见的操作系统只有三种：&lt;strong&gt;Windows、macOS 和 Linux&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;操作系统结构&quot;&gt;操作系统结构&lt;/h2&gt;
&lt;h3 id=&quot;单体系统&quot;&gt;单体系统&lt;/h3&gt;
&lt;p&gt;在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序，这种系统称为单体系统。&lt;/p&gt;
&lt;p&gt;在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中&lt;/p&gt;
&lt;p&gt;在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071711050-395565283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如 I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做 &lt;code&gt;共享库(shared library)&lt;/code&gt;，在 Windows 中则被称为 &lt;code&gt;动态链接库(Dynamic Link Library,DLL)&lt;/code&gt;。他们的扩展名为 &lt;code&gt;.dll&lt;/code&gt;，在 &lt;code&gt;C:\Windows\system32&lt;/code&gt; 目录下存在 1000 多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。&lt;/p&gt;
&lt;h3 id=&quot;分层系统&quot;&gt;分层系统&lt;/h3&gt;
&lt;p&gt;分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071718973-1742617191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;微内核&quot;&gt;微内核&lt;/h3&gt;
&lt;p&gt;为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 --- 微内核 --- 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MINIX 3&lt;/code&gt; 是微内核的代表作，它的具体结构如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071734770-959987217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问 I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O 设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O 端口，并声称一个内核调用，这样就完成了一次调用过程。&lt;/p&gt;
&lt;h3 id=&quot;客户-服务器模式&quot;&gt;客户-服务器模式&lt;/h3&gt;
&lt;p&gt;微内核思想的策略是把进程划分为两类：&lt;code&gt;服务器&lt;/code&gt;，每个服务器用来提供服务；&lt;code&gt;客户端&lt;/code&gt;，使用这些服务。这个模式就是所谓的 &lt;code&gt;客户-服务器&lt;/code&gt;模式。&lt;/p&gt;
&lt;p&gt;客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071743420-1257701829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。&lt;/p&gt;
&lt;h2 id=&quot;什么是按需分页&quot;&gt;什么是按需分页&lt;/h2&gt;
&lt;p&gt;在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种&lt;code&gt;虚拟内存&lt;/code&gt;的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，也就发生了&lt;code&gt;缺页异常&lt;/code&gt;，操作系统才会将磁盘页面复制到内存中。&lt;/p&gt;
&lt;h2 id=&quot;多处理系统的优势&quot;&gt;多处理系统的优势&lt;/h2&gt;
&lt;p&gt;随着处理器的不断增加，我们的计算机系统由单机系统变为了多处理系统，多处理系统的吞吐量比较高，多处理系统拥有多个并行的处理器，这些处理器共享时钟、内存、总线、外围设备等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071750852-2011069228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多处理系统由于可以共享资源，因此可以开源节流，省钱。整个系统的可靠性也随之提高。&lt;/p&gt;
&lt;h2 id=&quot;什么是内核&quot;&gt;什么是内核&lt;/h2&gt;
&lt;p&gt;在计算机中，内核是一个计算机程序，它是操作系统的核心，可以控制操作系统中所有的内容。内核通常是在 boot loader 装载程序之前加载的第一个程序。&lt;/p&gt;
&lt;p&gt;这里还需要了解一下什么是 &lt;code&gt;boot loader&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;boot loader 又被称为引导加载程序，它是一个程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS 会执行一些初始测试，然后将控制权转移到引导加载程序所在的&lt;code&gt;主引导记录(MBR)&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是实时系统&quot;&gt;什么是实时系统&lt;/h2&gt;
&lt;p&gt;实时操作系统对时间做出了严格的要求，实时操作系统分为两种：&lt;strong&gt;硬实时和软实时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;硬实时操作系统&lt;/code&gt;规定某个动作必须在规定的时刻内完成或发生，比如汽车生产车间，焊接机器必须在某一时刻内完成焊接，焊接的太早或者太晚都会对汽车造成永久性伤害。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;软实时操作系统&lt;/code&gt;虽然不希望偶尔违反最终的时限要求，但是仍然可以接受。并且不会引起任何永久性伤害。比如数字音频、多媒体、手机都是属于软实时操作系统。&lt;/p&gt;
&lt;p&gt;你可以简单理解硬实时和软实时的两个指标：&lt;strong&gt;是否在时刻内必须完成以及是否造成严重损害&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;什么是虚拟内存&quot;&gt;什么是虚拟内存&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;虚拟内存&lt;/code&gt;是一种内存分配方案，是一项可以用来辅助内存分配的机制。我们知道，应用程序是按页装载进内存中的。但并不是所有的页都会装载到内存中，计算机中的硬件和软件会将数据从 RAM 临时传输到磁盘中来弥补内存的不足。如果没有虚拟内存的话，一旦你将计算机内存填满后，计算机会对你说&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071803308-424659045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;呃，不，&lt;strong&gt;对不起，您无法再加载任何应用程序，请关闭另一个应用程序以加载新的应用程序&lt;/strong&gt;。对于虚拟内存，计算机可以执行操作是查看内存中最近未使用过的区域，然后将其复制到硬盘上。虚拟内存通过复制技术实现了 &lt;strong&gt;妹子，你快来看哥哥能装这么多程序&lt;/strong&gt; 的资本。复制是自动进行的，你无法感知到它的存在。&lt;/p&gt;
&lt;h2 id=&quot;什么是进程和进程表&quot;&gt;什么是进程和进程表&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;进程&lt;/code&gt;就是正在执行程序的实例，比如说 Web 程序就是一个进程，shell 也是一个进程，文章编辑器 typora 也是一个进程。&lt;/p&gt;
&lt;p&gt;操作系统负责管理所有正在运行的进程，操作系统会为每个进程分配特定的时间来占用 CPU，操作系统还会为每个进程分配特定的资源。&lt;/p&gt;
&lt;p&gt;操作系统为了跟踪每个进程的活动状态，维护了一个&lt;code&gt;进程表&lt;/code&gt;。在进程表的内部，列出了每个进程的状态以及每个进程使用的资源等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://courses.cs.vt.edu/csonline/OS/Lessons/Processes/index.html&quot;&gt;http://courses.cs.vt.edu/csonline/OS/Lessons/Processes/index.html&lt;/a&gt; 这个网站上面有一个关于进程状态轮转的动画，做的真是太好了。&lt;/p&gt;
&lt;h2 id=&quot;什么是线程，线程和进程的区别&quot;&gt;什么是线程，线程和进程的区别&lt;/h2&gt;
&lt;p&gt;这又是一道老生常谈的问题了，从操作系统的角度来回答一下吧。&lt;/p&gt;
&lt;p&gt;我们上面说到进程是正在运行的程序的实例，而线程其实就是进程中的单条流向，因为线程具有进程中的某些属性，所以线程又被称为轻量级的进程。浏览器如果是一个进程的话，那么浏览器下面的每个 tab 页可以看作是一个个的线程。&lt;/p&gt;
&lt;p&gt;下面是线程和进程持有资源的区别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071813686-341668732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程不像进程那样具有很强的独立性，线程之间会共享数据&lt;/p&gt;
&lt;p&gt;创建线程的开销要比进程小很多，因为创建线程仅仅需要&lt;code&gt;堆栈指针&lt;/code&gt;和&lt;code&gt;程序计数器&lt;/code&gt;就可以了，而创建进程需要操作系统分配新的地址空间，数据资源等，这个开销比较大。&lt;/p&gt;
&lt;h2 id=&quot;使用多线程的好处是什么&quot;&gt;使用多线程的好处是什么&lt;/h2&gt;
&lt;p&gt;多线程是程序员不得不知的基本素养之一，所以，下面我们给出一些多线程编程的好处&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;能够提高对用户的响应顺序&lt;/li&gt;
&lt;li&gt;在流程中的资源共享&lt;/li&gt;
&lt;li&gt;比较经济适用&lt;/li&gt;
&lt;li&gt;能够对多线程架构有深入的理解&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么是-rr-调度算法&quot;&gt;什么是 RR 调度算法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RR(round-robin)&lt;/code&gt; 调度算法主要针对分时系统，RR 的调度算法会把时间片以相同的部分并循环的分配给每个进程，RR 调度算法没有优先级的概念。这种算法的实现比较简单，而且每个线程都会占有时间片，并不存在线程饥饿的问题。&lt;/p&gt;
&lt;h2 id=&quot;导致系统出现死锁的情况&quot;&gt;导致系统出现死锁的情况&lt;/h2&gt;
&lt;p&gt;死锁的出现需要同时满足下面四个条件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;互斥(Mutual Exclusion)&lt;/code&gt;：一次只能有一个进程使用资源。如果另一个进程请求该资源，则必须延迟请求进程，直到释放该资源为止。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;保持并等待(Hold and Wait)&lt;/code&gt;：必须存在一个进程，该进程至少持有一个资源，并且正在等待获取其他进程当前所持有的资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;无抢占(No Preemption)&lt;/code&gt;：资源不能被抢占，也就是说，在进程完成其任务之后，只能由拥有它的进程自动释放资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;循环等待(Circular Wait)&lt;/code&gt; ：必须存在一组 {p0，p1，..... pn} 的等待进程，使 p0 等待 p1 持有的资源，p1 等待由 p2 持有的资源， pn-1 正在等待由 pn 持有的资源，而 pn 正在等待由 p0 持有的资源。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;raid-的不同级别&quot;&gt;RAID 的不同级别&lt;/h2&gt;
&lt;p&gt;RAID 称为 &lt;code&gt;磁盘冗余阵列&lt;/code&gt;，简称 &lt;code&gt;磁盘阵列&lt;/code&gt;。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。&lt;/p&gt;
&lt;p&gt;RAID 有不同的级别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RAID 0 - 无容错的条带化磁盘阵列&lt;/li&gt;
&lt;li&gt;RAID 1 - 镜像和双工&lt;/li&gt;
&lt;li&gt;RAID 2 - 内存式纠错码&lt;/li&gt;
&lt;li&gt;RAID 3 - 比特交错奇偶校验&lt;/li&gt;
&lt;li&gt;RAID 4 - 块交错奇偶校验&lt;/li&gt;
&lt;li&gt;RAID 5 - 块交错分布式奇偶校验&lt;/li&gt;
&lt;li&gt;RAID 6 - P + Q冗余&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么是-dma&quot;&gt;什么是 DMA&lt;/h2&gt;
&lt;p&gt;DMA 的中文名称是&lt;code&gt;直接内存访问&lt;/code&gt;，它意味着 CPU 授予 I/O 模块权限在不涉及 CPU 的情况下读取或写入内存。也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。由于 DMA 设备可以直接在内存之间传输数据，而不是使用 CPU 作为中介，因此可以缓解总线上的拥塞。DMA 通过允许 CPU 执行任务，同时 DMA 系统通过系统和内存总线传输数据来提高系统并发性。&lt;/p&gt;
&lt;h2 id=&quot;多线程编程的好处是什么&quot;&gt;多线程编程的好处是什么&lt;/h2&gt;
&lt;p&gt;对不起，我忍不住想偷笑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515071952119-961934356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说直白点，为什么单线程能够处理的却要用多线程来处理？当然是为了提高程序的&lt;s&gt;装逼&lt;/s&gt;并行能力了。多线程&lt;code&gt;在某些情况下&lt;/code&gt;能够使你程序运行的更快，这也是为什么多核 CPU 会出现，但是多核 CPU 的出现会导致数据的一致性问题，不过这些问题程序员就能解决。另一个角度来说，多线程编程能够提高程序员的编程能力和编程思维。同时也能提高程序员的管理能力，你如果把每条线程流当作罗老师时间管理的女主一样，能够及时协调好所有P友的关系，那你也是超神程序员了，所以，是谁说程序员不会做管理的？Doug Lea 大佬牛逼！！！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps：Doug Lea 大佬开发的 JUC 工具包，此处不加狗头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是设备驱动程序&quot;&gt;什么是设备驱动程序&lt;/h2&gt;
&lt;p&gt;在计算机中，设备驱动程序是一种计算机程序，它能够控制或者操作连接到计算机的特定设备。驱动程序提供了与硬件进行交互的软件接口，使操作系统和其他计算机程序能够访问特定设备，不用需要了解其硬件的具体构造。&lt;/p&gt;
&lt;h2 id=&quot;进程间的通信方式&quot;&gt;进程间的通信方式&lt;/h2&gt;
&lt;h3 id=&quot;通信概念&quot;&gt;通信概念&lt;/h3&gt;
&lt;p&gt;进程间的通信方式比较多，首先你需要理解下面这几个概念&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;竞态条件：即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为&lt;code&gt;竞态条件(race condition)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;临界区：不仅&lt;code&gt;共享资源&lt;/code&gt;会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：&lt;strong&gt;禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写&lt;/strong&gt;。换句话说，我们需要一种 &lt;code&gt;互斥(mutual exclusion)&lt;/code&gt; 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。&lt;/p&gt;
&lt;p&gt;一个好的解决方案，应该包含下面四种条件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;任何时候两个进程不能同时处于临界区&lt;/li&gt;
&lt;li&gt;不应对 CPU 的速度和数量做任何假设&lt;/li&gt;
&lt;li&gt;位于临界区外的进程不得阻塞其他进程&lt;/li&gt;
&lt;li&gt;不能使任何进程无限等待进入临界区&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515072002996-174255777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;忙等互斥：当一个进程在对资源进行修改时，其他进程必须进行等待，进程之间要具有互斥性，我们讨论的解决方案其实都是基于忙等互斥提出的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;进程间的通信用专业一点的术语来表示就是 &lt;code&gt;Inter Process Communication，IPC&lt;/code&gt;，它主要有下面几种通信方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515072010442-655494220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;消息传递&lt;/code&gt;：消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行通信；消息传递分为发送方和接收方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;先进先出队列&lt;/code&gt;：先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;管道&lt;/code&gt;：管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工，需要另外一个管道。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;直接通信&lt;/code&gt;：在这种进程通信的方式中，进程与进程之间只存在一条链接，进程间要明确通信双方的命名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;间接通信&lt;/code&gt;：间接通信是通信双方不会直接建立连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中放置消息，并且可以从中删除消息，以此达到进程间通信的目的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;消息队列&lt;/code&gt;：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程之间提供全双工的通信连接。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;共享内存&lt;/code&gt;：共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;进程间状态模型&quot;&gt;进程间状态模型&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cat chapter1 chapter2 chapter3 | grep tree
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个进程是 &lt;code&gt;cat&lt;/code&gt;，将三个文件级联并输出。第二个进程是 &lt;code&gt;grep&lt;/code&gt;，它从输入中选择具有包含关键字 &lt;code&gt;tree&lt;/code&gt; 的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的 CPU 时间片），可能会发生下面这种情况，&lt;code&gt;grep&lt;/code&gt; 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞 grep 进程，直到输入完毕。&lt;/p&gt;
&lt;p&gt;当一个进程开始运行时，它可能会经历下面这几种状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515072028565-300912062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中会涉及三种状态&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;运行态&lt;/code&gt;，运行态指的就是进程实际占用 CPU 时间片运行时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;就绪态&lt;/code&gt;，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;阻塞态&lt;/code&gt;，除非某种外部事件发生，否则进程不能运行&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程&lt;code&gt;可运行&lt;/code&gt;，但是第二种情况没有获得 CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU 空闲时也不能运行。&lt;/p&gt;
&lt;p&gt;三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生&lt;code&gt;状态1&lt;/code&gt;的轮转，在某些系统中进程执行系统调用，例如 &lt;code&gt;pause&lt;/code&gt;，来获取一个阻塞的状态。在其他系统中包括 UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。&lt;/p&gt;
&lt;p&gt;转换 2 和转换 3 都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换 2 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得 CPU 时间片的时候了，就会发生转换 3。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点&lt;/strong&gt;。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换 4。如果此时没有其他进程在运行，则立刻触发转换 3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU 空闲后再轮到它运行。&lt;/p&gt;
&lt;h2 id=&quot;调度算法都有哪些&quot;&gt;调度算法都有哪些&lt;/h2&gt;
&lt;p&gt;调度算法分为三大类：批处理中的调度、交互系统中的调度、实时系统中的调度&lt;/p&gt;
&lt;h3 id=&quot;批处理中的调度&quot;&gt;批处理中的调度&lt;/h3&gt;
&lt;h4 id=&quot;先来先服务&quot;&gt;先来先服务&lt;/h4&gt;
&lt;p&gt;很像是先到先得。。。可能最简单的非抢占式调度算法的设计就是 &lt;code&gt;先来先服务(first-come,first-serverd)&lt;/code&gt;。使用此算法，将按照请求顺序为进程分配 CPU。最基本的，会有一个就绪进程的等待队列。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515072039914-962597249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。&lt;/p&gt;
&lt;p&gt;不过，先来先服务也是有缺点的，那就是没有优先级的关系，试想一下，如果有 100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等 100 个 I/O 进程运行完毕才会等到一个 CPU 密集型进程运行，这在实际情况下根本不可能，所以需要优先级或者抢占式进程的出现来优先选择重要的进程运行。&lt;/p&gt;
&lt;h4 id=&quot;最短作业优先&quot;&gt;最短作业优先&lt;/h4&gt;
&lt;p&gt;批处理中，第二种调度算法是 &lt;code&gt;最短作业优先(Shortest Job First)&lt;/code&gt;，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515072121852-1067573736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图 a 所示，这里有 4 个作业 A、B、C、D ，运行时间分别为 8、4、4、4 分钟。若按图中的次序运行，则 A 的周转时间为 8 分钟，B 为 12 分钟，C 为 16 分钟，D 为 20 分钟，平均时间内为 14 分钟。&lt;/p&gt;
&lt;p&gt;现在考虑使用最短作业优先算法运行 4 个作业，如上图 b 所示，目前的周转时间分别为 4、8、12、20，平均为 11 分钟，可以证明最短作业优先是最优的。考虑有 4 个作业的情况，其运行时间分别为 a、b、c、d。第一个作业在时间 a 结束，第二个在时间 a + b 结束，以此类推。平均周转时间为 (4a + 3b + 2c + d) / 4 。显然 a 对平均值的影响最大，所以 a 应该是最短优先作业，其次是 b，然后是 c ，最后是 d 它就只能影响自己的周转时间了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;最短剩余时间优先&quot;&gt;最短剩余时间优先&lt;/h4&gt;
&lt;p&gt;最短作业优先的抢占式版本被称作为 &lt;code&gt;最短剩余时间优先(Shortest Remaining Time Next)&lt;/code&gt; 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。&lt;/p&gt;
&lt;h3 id=&quot;交互式系统中的调度&quot;&gt;交互式系统中的调度&lt;/h3&gt;
&lt;p&gt;交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度&lt;/p&gt;
&lt;h4 id=&quot;轮询调度&quot;&gt;轮询调度&lt;/h4&gt;
&lt;p&gt;一种最古老、最简单、最公平并且最广泛使用的算法就是 &lt;code&gt;轮询算法(round-robin)&lt;/code&gt;。每个进程都会被分配一个时间段，称为&lt;code&gt;时间片(quantum)&lt;/code&gt;，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515072134156-665548691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;优先级调度&quot;&gt;优先级调度&lt;/h4&gt;
&lt;p&gt;事实情况是不是所有的进程都是优先级相等的。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了&lt;code&gt;优先级调度(priority scheduling)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515072141095-420267844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。&lt;/p&gt;
&lt;p&gt;但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。&lt;/p&gt;
&lt;h4 id=&quot;最短进程优先&quot;&gt;最短进程优先&lt;/h4&gt;
&lt;p&gt;对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，一种方式是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 &lt;code&gt;T0&lt;/code&gt;，现在假设测量到其下一次运行时间为 &lt;code&gt;T1&lt;/code&gt;，可以用两个值的加权来改进估计时间，即&lt;code&gt;aT0+ (1- 1)T1&lt;/code&gt;。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515072149014-1378644999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。&lt;/p&gt;
&lt;p&gt;有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作 &lt;code&gt;老化(aging)&lt;/code&gt;。这种方法会使用很多预测值基于当前值的情况。&lt;/p&gt;
&lt;h4 id=&quot;彩票调度&quot;&gt;彩票调度&lt;/h4&gt;
&lt;p&gt;有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 &lt;code&gt;彩票调度(lottery scheduling)&lt;/code&gt;算法。他的基本思想为进程提供各种系统资源的&lt;code&gt;彩票&lt;/code&gt;。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得资源。比如在 CPU 进行调度时，系统可以每秒持有 50 次抽奖，每个中奖进程会获得额外运行时间的奖励。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以把彩票理解为 buff，这个 buff 有 15% 的几率能让你产生 &lt;code&gt;速度之靴&lt;/code&gt; 的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;公平分享调度&quot;&gt;公平分享调度&lt;/h4&gt;
&lt;p&gt;如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。&lt;/p&gt;
&lt;p&gt;为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。&lt;/p&gt;
&lt;h2 id=&quot;页面置换算法都有哪些&quot;&gt;页面置换算法都有哪些&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;最优算法&lt;/td&gt;
&lt;td&gt;不可实现，但可以用作基准&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NRU(最近未使用) 算法&lt;/td&gt;
&lt;td&gt;和 LRU 算法很相似&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;FIFO(先进先出) 算法&lt;/td&gt;
&lt;td&gt;有可能会抛弃重要的页面&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;第二次机会算法&lt;/td&gt;
&lt;td&gt;比 FIFO 有较大的改善&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;时钟算法&lt;/td&gt;
&lt;td&gt;实际使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LRU(最近最少)算法&lt;/td&gt;
&lt;td&gt;比较优秀，但是很难实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NFU(最不经常食用)算法&lt;/td&gt;
&lt;td&gt;和 LRU 很类似&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;老化算法&lt;/td&gt;
&lt;td&gt;近似 LRU 的高效算法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;工作集算法&lt;/td&gt;
&lt;td&gt;实施起来开销很大&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;工作集时钟算法&lt;/td&gt;
&lt;td&gt;比较有效的算法&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;最优算法&lt;/code&gt;在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，&lt;code&gt;因此实际上该算法不能使用&lt;/code&gt;。然而，它可以作为衡量其他算法的标准。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NRU&lt;/code&gt; 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIFO&lt;/code&gt; 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;第二次机会&lt;/code&gt;算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;时钟&lt;/code&gt; 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LRU&lt;/code&gt; 算法是一个非常优秀的算法，但是没有&lt;code&gt;特殊的硬件(TLB)&lt;/code&gt;很难实现。如果没有硬件，就不能使用 LRU 算法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NFU&lt;/code&gt; 算法是一种近似于 LRU 的算法，它的性能不是非常好。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;老化&lt;/code&gt; 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择&lt;/li&gt;
&lt;li&gt;最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。&lt;code&gt;WSClock&lt;/code&gt; 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;最好的算法是老化算法和WSClock算法&lt;/strong&gt;。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。&lt;/p&gt;
&lt;h2 id=&quot;影响调度程序的指标是什么&quot;&gt;影响调度程序的指标是什么&lt;/h2&gt;
&lt;p&gt;会有下面几个因素决定调度程序的好坏&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU 使用率：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CPU 正在执行任务（即不处于空闲状态）的时间百分比。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;等待时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是进程轮流执行的时间，也就是进程切换的时间&lt;/p&gt;
&lt;p&gt;单位时间内完成进程的数量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是从提交流程到获得有用输出所经过的时间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;周转时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从提交流程到完成流程所经过的时间。&lt;/p&gt;
&lt;h2 id=&quot;什么是僵尸进程&quot;&gt;什么是僵尸进程&lt;/h2&gt;
&lt;p&gt;僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。僵尸进程通常发生在父子关系的进程中，由于父进程仍需要读取其子进程的退出状态所造成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200515073122009-1254205867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 May 2020 23:31:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>解释一下什么是操作系统 操作系统是运行在计算机上最重要的一种 ，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层 通常情况下，计算机上会运行着许多应用程序，它们都需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/12892684.html</dc:identifier>
</item>
<item>
<title>比AtomicLong更优秀的LongAdder确定不来了解一下吗？ - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12892695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12892695.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;前言&lt;/h3&gt;
&lt;h3&gt;&lt;img title=&quot;思维导图.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308ae3062595?w=1112&amp;amp;h=599&amp;amp;f=png&amp;amp;s=87589&quot; alt=&quot;思维导图.png&quot;/&gt;思维导图.png&lt;/h3&gt;
&lt;p&gt;文章中所有&lt;code&gt;高清无码图片&lt;/code&gt;在&lt;strong&gt;公众号号回复:&lt;/strong&gt; &lt;code&gt;图片666&lt;/code&gt; 即可查阅, 可直接关注公众号：&lt;code&gt;壹枝花算不算浪漫&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最近阿里巴巴发布了&lt;code&gt;Java开发手册(泰山版)&lt;/code&gt; (&lt;strong&gt;公众号回复：&lt;/strong&gt; &lt;code&gt;开发手册&lt;/code&gt; 可收到&lt;code&gt;阿里巴巴开发手册(泰山版 2020.4.22发布).pdf&lt;/code&gt;)，其中第&lt;code&gt;17条&lt;/code&gt;写到：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;阿里巴巴开发手册.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308ae3ccd92b?w=765&amp;amp;h=157&amp;amp;f=png&amp;amp;s=48204&quot; alt=&quot;阿里巴巴开发手册.png&quot;/&gt;阿里巴巴开发手册.png&lt;/h3&gt;
&lt;p&gt;对于&lt;code&gt;Java项目中&lt;/code&gt;计数统计的一些需求，&lt;strong&gt;如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在大多数项目及开源组件中，计数统计使用最多的仍然还是&lt;code&gt;AtomicLong&lt;/code&gt;，虽然是阿里巴巴这样说，但是我们仍然要根据使用场景来决定是否使用&lt;code&gt;LongAdder&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;今天主要是来讲讲&lt;code&gt;LongAdder&lt;/code&gt;的&lt;strong&gt;实现原理&lt;/strong&gt;，还是老方式，通过&lt;strong&gt;图文&lt;/strong&gt;一步步解开&lt;code&gt;LongAdder&lt;/code&gt;神秘的面纱，通过此篇文章你会了解到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;为什么AtomicLong在高并发场景下性能急剧下降？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LongAdder为什么快？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LongAdder实现原理（图文分析）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AtomicLong是否可以被遗弃或替换？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;本文代码全部基于JDK 1.8，建议边看文章边看源码更加利于消化&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;hatomiclong&quot;&gt;AtomicLong&lt;/h3&gt;
&lt;p&gt;当我们在进行计数统计的时，通常会使用&lt;code&gt;AtomicLong&lt;/code&gt;来实现。&lt;code&gt;AtomicLong&lt;/code&gt;能保证并发情况下计数的准确性，其内部通过&lt;code&gt;CAS&lt;/code&gt;来解决并发安全性的问题。&lt;/p&gt;
&lt;h4 id=&quot;hatomiclong-1&quot;&gt;AtomicLong实现原理&lt;/h4&gt;
&lt;p&gt;说到线程安全的计数统计工具类，肯定少不了&lt;code&gt;Atomic&lt;/code&gt;下的几个原子类。&lt;code&gt;AtomicLong&lt;/code&gt;就是&lt;strong&gt;juc包&lt;/strong&gt;下重要的&lt;strong&gt;原子类&lt;/strong&gt;，在并发情况下可以对长整形类型数据进行原子操作，&lt;strong&gt;保证并发情况下数据的安全性。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;AtomicLong &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Number &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;java.&lt;span class=&quot;hljs-title&quot;&gt;io.&lt;span class=&quot;hljs-title&quot;&gt;Serializable {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;long &lt;span class=&quot;hljs-title&quot;&gt;incrementAndGet&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return unsafe.getAndAddLong(&lt;span class=&quot;hljs-keyword&quot;&gt;this, valueOffset, &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1L) + &lt;span class=&quot;hljs-number&quot; readability=&quot;4&quot;&gt;1L;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;long &lt;span class=&quot;hljs-title&quot;&gt;decrementAndGet&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return unsafe.getAndAddLong(&lt;span class=&quot;hljs-keyword&quot;&gt;this, valueOffset, -&lt;span class=&quot;hljs-number&quot;&gt;1L) - &lt;span class=&quot;hljs-number&quot;&gt;1L;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在计数的过程中，一般使用&lt;code&gt;incrementAndGet()&lt;/code&gt;和&lt;code&gt;decrementAndGet()&lt;/code&gt;进行加一和减一操作，这里调用了&lt;code&gt;Unsafe&lt;/code&gt;类中的&lt;code&gt;getAndAddLong()&lt;/code&gt;方法进行操作。&lt;/p&gt;
&lt;p&gt;接着看看&lt;code&gt;unsafe.getAndAddLong()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Unsafe {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;long &lt;span class=&quot;hljs-title&quot;&gt;getAndAddLong&lt;span class=&quot;hljs-params&quot;&gt;(Object var1, &lt;span class=&quot;hljs-keyword&quot;&gt;long var2, &lt;span class=&quot;hljs-keyword&quot;&gt;long var4) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long var6;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;do {&lt;br/&gt;var6 = &lt;span class=&quot;hljs-keyword&quot;&gt;this.getLongVolatile(var1, var2);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot; readability=&quot;2.5&quot;&gt;while(!&lt;span class=&quot;hljs-keyword&quot; readability=&quot;5&quot;&gt;this.compareAndSwapLong(var1, var2, var6, var6 + var4));&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return var6;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;native &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;compareAndSwapLong&lt;span class=&quot;hljs-params&quot;&gt;(Object var1, &lt;span class=&quot;hljs-keyword&quot;&gt;long var2, &lt;span class=&quot;hljs-keyword&quot;&gt;long var4, &lt;span class=&quot;hljs-keyword&quot;&gt;long var6);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里直接进行&lt;strong&gt;CAS+自旋&lt;/strong&gt;操作更新&lt;code&gt;AtomicLong&lt;/code&gt;中的&lt;code&gt;valu&lt;/code&gt;e值，进而保证&lt;code&gt;value&lt;/code&gt;值的&lt;strong&gt;原子性更新&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;hatomiclong-2&quot;&gt;AtomicLong瓶颈分析&lt;/h4&gt;
&lt;p&gt;如上代码所示，我们在使用&lt;strong&gt;CAS + 自旋&lt;/strong&gt;的过程中，在高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时&lt;code&gt;AtomicLong&lt;/code&gt;的自旋会成为瓶颈。&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;AtomicLong瓶颈分析.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308aed36c0d9?w=915&amp;amp;h=452&amp;amp;f=png&amp;amp;s=59676&quot; alt=&quot;AtomicLong瓶颈分析.png&quot;/&gt;AtomicLong瓶颈分析.png&lt;/h3&gt;
&lt;p&gt;如上图所示，高并发场景下&lt;code&gt;AtomicLong&lt;/code&gt;性能会急剧下降，我们后面也会举例说明。&lt;/p&gt;
&lt;p&gt;那么高并发下计数的需求有没有更好的替代方案呢？在&lt;code&gt;JDK8&lt;/code&gt; 中 &lt;code&gt;Doug Lea&lt;/code&gt;大神 新写了一个&lt;code&gt;LongAdder&lt;/code&gt;来解决此问题，我们后面来看&lt;code&gt;LongAdder&lt;/code&gt;是如何优化的。&lt;/p&gt;
&lt;h3 id=&quot;hlongadder&quot;&gt;LongAdder&lt;/h3&gt;
&lt;h4 id=&quot;hlongadderatomiclong&quot;&gt;LongAdder和AtomicLong性能测试&lt;/h4&gt;
&lt;p&gt;我们说了很多&lt;code&gt;LongAdder&lt;/code&gt;上性能优于&lt;code&gt;AtomicLong&lt;/code&gt;，到底是不是呢？一切还是以代码说话：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;CAS原理图.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308aea24866f?w=2398&amp;amp;h=892&amp;amp;f=png&amp;amp;s=155944&quot; alt=&quot;CAS原理图.png&quot;/&gt;CAS原理图.png&lt;/h3&gt;
&lt;p&gt;这里可以看到随着并发的增加，&lt;code&gt;AtomicLong&lt;/code&gt;性能是急剧下降的，耗时是&lt;code&gt;LongAdder&lt;/code&gt;的数倍。至于原因我们还是接着往后看。&lt;/p&gt;
&lt;h4 id=&quot;hlongadder-1&quot;&gt;LongAdder为什么这么快&lt;/h4&gt;
&lt;p&gt;先看下&lt;code&gt;LongAdder&lt;/code&gt;的操作原理图：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;YUnlDO.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/172130a211237c9d?w=928&amp;amp;h=542&amp;amp;f=png&amp;amp;s=81903&quot; alt=&quot;YUnlDO.png&quot;/&gt;YUnlDO.png&lt;/h3&gt;
&lt;p&gt;既然说到&lt;code&gt;LongAdder&lt;/code&gt;可以显著提升高并发环境下的性能，那么它是如何做到的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、 设计思想上，&lt;code&gt;LongAdder&lt;/code&gt;采用&quot;分段&quot;的方式降低&lt;code&gt;CAS&lt;/code&gt;失败的频次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里先简单的说下&lt;code&gt;LongAdder&lt;/code&gt;的思路，后面还会详述&lt;code&gt;LongAdder&lt;/code&gt;的原理。&lt;/p&gt;
&lt;p&gt;我们知道，&lt;code&gt;AtomicLong&lt;/code&gt;中有个内部变量&lt;code&gt;value&lt;/code&gt;保存着实际的&lt;code&gt;long&lt;/code&gt;值，所有的操作都是针对该变量进行。也就是说，高并发环境下，&lt;code&gt;value&lt;/code&gt;变量其实是一个&lt;strong&gt;热点数据&lt;/strong&gt;，也就是&lt;strong&gt;N个线程竞争一个热点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LongAdder&lt;/code&gt;的基本思路就是&lt;strong&gt;分散热点&lt;/strong&gt;，将&lt;code&gt;value&lt;/code&gt;值的新增操作分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个&lt;code&gt;value&lt;/code&gt;值进行&lt;code&gt;CAS&lt;/code&gt;操作，这样热点就被分散了，冲突的概率就小很多。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LongAdder&lt;/code&gt;有一个全局变量&lt;code&gt;volatile long base&lt;/code&gt;值，当并发不高的情况下都是通过&lt;code&gt;CAS&lt;/code&gt;来直接操作&lt;code&gt;base&lt;/code&gt;值，如果&lt;code&gt;CAS&lt;/code&gt;失败，则针对&lt;code&gt;LongAdder&lt;/code&gt;中的&lt;code&gt;Cell[]&lt;/code&gt;数组中的&lt;code&gt;Cell&lt;/code&gt;进行&lt;code&gt;CA&lt;/code&gt;S操作，减少失败的概率。&lt;/p&gt;
&lt;p&gt;例如当前类中&lt;code&gt;base = 10&lt;/code&gt;，有三个线程进行&lt;code&gt;CAS&lt;/code&gt;原子性的&lt;strong&gt;+1操作&lt;/strong&gt;，&lt;strong&gt;线程一执行成功，此时base=11&lt;/strong&gt;，&lt;strong&gt;线程二、线程三执行失败后&lt;/strong&gt;开始针对于&lt;code&gt;Cell[]&lt;/code&gt;数组中的&lt;code&gt;Cell&lt;/code&gt;元素进行&lt;strong&gt;+1操作&lt;/strong&gt;，同样也是&lt;code&gt;CAS&lt;/code&gt;操作，此时数组&lt;code&gt;index=1&lt;/code&gt;和&lt;code&gt;index=2&lt;/code&gt;中&lt;code&gt;Cell&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;都被设置为了1.&lt;/p&gt;
&lt;p&gt;执行完成后，统计累加数据：&lt;code&gt;sum = 11 + 1 + 1 = 13&lt;/code&gt;，利用&lt;code&gt;LongAdder&lt;/code&gt;进行累加的操作就执行完了，流程图如下：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;分段加锁思路.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308aedee5ea8?w=1078&amp;amp;h=489&amp;amp;f=png&amp;amp;s=76001&quot; alt=&quot;分段加锁思路.png&quot;/&gt;分段加锁思路.png&lt;/h3&gt;
&lt;p&gt;如果要获取真正的&lt;code&gt;long&lt;/code&gt;值，只要将各个槽中的变量值累加返回。这种分段的做法类似于&lt;code&gt;JDK7&lt;/code&gt;中&lt;code&gt;ConcurrentHashMap&lt;/code&gt;的分段锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用Contended注解来消除伪共享&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;LongAdder&lt;/code&gt; 的父类 &lt;code&gt;Striped64&lt;/code&gt; 中存在一个 &lt;code&gt;volatile Cell[] cells;&lt;/code&gt; 数组，其长度是&lt;strong&gt;2 的幂次方&lt;/strong&gt;，每个&lt;code&gt;Cell&lt;/code&gt;都使用 &lt;code&gt;@Contended&lt;/code&gt; 注解进行修饰，而&lt;code&gt;@Contended&lt;/code&gt;注解可以进行&lt;strong&gt;缓存行填充&lt;/strong&gt;，从而解决&lt;strong&gt;伪共享问题&lt;/strong&gt;。伪共享会导致缓存行失效，缓存一致性开销变大。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@sun.misc.Contended &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Cell {&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;伪共享&lt;/strong&gt;指的是多个线程同时读写同一个缓存行的不同变量时导致的 &lt;code&gt;CPU缓存失效&lt;/code&gt;。尽管这些变量之间没有任何关系，但由于在主内存中邻近，存在于同一个缓存行之中，它们的相互覆盖会导致频繁的缓存未命中，引发性能下降。这里对于伪共享我只是提一下概念，并不会深入去讲解，大家可以自行查阅一些资料。&lt;/p&gt;
&lt;p&gt;解决伪共享的方法一般都是使用&lt;strong&gt;直接填充&lt;/strong&gt;，我们只需要保证不同线程的变量存在于不同的 &lt;code&gt;CacheLine&lt;/code&gt; 即可，使用多余的字节来填充可以做点这一点，这样就不会出现伪共享问题。例如在&lt;code&gt;Disruptor队列&lt;/code&gt;的设计中就有类似设计(可参考我之前的博客文章：&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/9de47cad4514a8b4fbe81511daa3a56f.html&quot;&gt;Disruptor学习笔记&lt;/a&gt;&lt;/strong&gt;)：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;缓存行填充代码.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308beaed8f31?w=1170&amp;amp;h=463&amp;amp;f=png&amp;amp;s=44473&quot; alt=&quot;缓存行填充代码.png&quot;/&gt;缓存行填充代码.png &lt;img title=&quot;缓存行填充.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308be1d0c1ee?w=842&amp;amp;h=522&amp;amp;f=png&amp;amp;s=75595&quot; alt=&quot;缓存行填充.png&quot;/&gt;缓存行填充.png&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;Striped64&lt;/code&gt;类中我们可以看看&lt;code&gt;Doug Lea&lt;/code&gt;在&lt;code&gt;Cell&lt;/code&gt;上加的注释也有说明这一点：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;Cell注释.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/172130996532f95f?w=2162&amp;amp;h=1098&amp;amp;f=png&amp;amp;s=245351&quot; alt=&quot;Cell注释.png&quot;/&gt;Cell注释.png&lt;/h3&gt;
&lt;p&gt;红框中的翻译如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cell&lt;/code&gt;类是&lt;code&gt;AtomicLong&lt;/code&gt;添加了&lt;code&gt;padded（via@sun.misc.compended)&lt;/code&gt;来消除&lt;strong&gt;伪共享&lt;/strong&gt;的变种版本。缓存行填充对于大多数原子来说是繁琐的，因为它们通常不规则地分散在内存中，因此彼此之间不会有太大的干扰。但是，驻留在数组中的原子对象往往彼此相邻，因此在没有这种预防措施的情况下，通常会共享缓存行数据（对性能有巨大的负面影响）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、惰性求值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LongAdder&lt;/code&gt;只有在使用&lt;code&gt;longValue()&lt;/code&gt;获取当前累加值时才会真正的去结算计数的数据，&lt;code&gt;longValue()&lt;/code&gt;方法底层就是调用&lt;code&gt;sum()&lt;/code&gt;方法，对&lt;code&gt;base&lt;/code&gt;和&lt;code&gt;Cell数组&lt;/code&gt;的数据累加然后返回，做到数据写入和读取分离。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;AtomicLong&lt;/code&gt;使用&lt;code&gt;incrementAndGet()&lt;/code&gt;每次都会返回&lt;code&gt;long&lt;/code&gt;类型的计数值，每次递增后还会伴随着数据返回，增加了额外的开销。&lt;/p&gt;
&lt;h4 id=&quot;hlongadder-2&quot;&gt;LongAdder实现原理&lt;/h4&gt;
&lt;p&gt;之前说了，&lt;code&gt;AtomicLong&lt;/code&gt;是多个线程针对单个&lt;strong&gt;热点值value进行原子操作&lt;/strong&gt;。而&lt;code&gt;LongAdder&lt;/code&gt;是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行&lt;code&gt;CAS操作&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;比如有三个线程同时对value增加1，那么value = 1 + 1 + 1 = 3&lt;/p&gt;
&lt;p&gt;但是对于LongAdder来说，内部有一个base变量，一个Cell[]数组。&lt;br/&gt;base变量：非竞态条件下，直接累加到该变量上&lt;br/&gt;Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中&lt;br/&gt;最终结果的计算是下面这个形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;value = base + &lt;span class=&quot;katex&quot;&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;hlongadder-3&quot;&gt;LongAdder源码剖析&lt;/h4&gt;
&lt;p&gt;前面已经用图分析了&lt;code&gt;LongAdder&lt;/code&gt;高性能的原理，我们继续看下&lt;code&gt;LongAdder&lt;/code&gt;实现的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;LongAdder &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Striped64 &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;Serializable {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;increment&lt;span class=&quot;hljs-params&quot; readability=&quot;8.5&quot;&gt;() {&lt;br/&gt;add(&lt;span class=&quot;hljs-number&quot; readability=&quot;17&quot;&gt;1L);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;add&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long x) {&lt;br/&gt;Cell[] as; &lt;span class=&quot;hljs-keyword&quot;&gt;long b, v; &lt;span class=&quot;hljs-keyword&quot;&gt;int m; Cell a;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((as = cells) != &lt;span class=&quot;hljs-keyword&quot;&gt;null || !casBase(b = base, b + x)) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean uncontended = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (as == &lt;span class=&quot;hljs-keyword&quot;&gt;null || (m = as.length - &lt;span class=&quot;hljs-number&quot;&gt;1) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0 ||&lt;br/&gt;(a = as[getProbe() &amp;amp; m]) == &lt;span class=&quot;hljs-keyword&quot;&gt;null ||&lt;br/&gt;!(uncontended = a.cas(v = a.value, v + x)))&lt;br/&gt;longAccumulate(x, &lt;span class=&quot;hljs-keyword&quot;&gt;null, uncontended);&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;casBase&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long cmp, &lt;span class=&quot;hljs-keyword&quot;&gt;long val) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return UNSAFE.compareAndSwapLong(&lt;span class=&quot;hljs-keyword&quot;&gt;this, BASE, cmp, val);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般我们进行计数时都会使用&lt;code&gt;increment()&lt;/code&gt;方法，每次进行&lt;strong&gt;+1操作&lt;/strong&gt;，&lt;code&gt;increment()&lt;/code&gt;会直接调用&lt;code&gt;add()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;as 表示cells引用&lt;/li&gt;
&lt;li&gt;b 表示获取的base值&lt;/li&gt;
&lt;li&gt;v 表示 期望值,&lt;/li&gt;
&lt;li&gt;m 表示 cells 数组的长度&lt;/li&gt;
&lt;li&gt;a 表示当前线程命中的cell单元格&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;条件分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件一：as == null || (m = as.length - 1) &amp;lt; 0&lt;/strong&gt;&lt;br/&gt;此条件成立说明cells数组未初始化。如果不成立则说明cells数组已经完成初始化，对应的线程需要找到Cell数组中的元素去写值。&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;条件一.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308c444a8dd4?w=1113&amp;amp;h=542&amp;amp;f=png&amp;amp;s=54480&quot; alt=&quot;条件一.png&quot;/&gt;条件一.png&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;条件二：(a = as[getProbe() &amp;amp; m]) == null&lt;/strong&gt;&lt;br/&gt;getProbe()获取当前线程的hash值，m表示cells长度-1，cells长度是2的幂次方数，原因之前也讲到过，与数组长度取模可以转化为按位与运算，提升计算性能。&lt;/p&gt;
&lt;p&gt;当条件成立时说明当前线程通过hash计算出来数组位置处的cell为空，进一步去执行longAccumulate()方法。如果不成立则说明对应的cell不为空，下一步将要将x值通过CAS操作添加到cell中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件三：!(uncontended = a.cas(v = a.value, v + x)&lt;/strong&gt;&lt;br/&gt;主要看a.cas(v = a.value, v + x)，接着条件二，说明当前线程hash与数组长度取模计算出的位置的cell有值，此时直接尝试一次CAS操作，如果成功则退出if条件，失败则继续往下执行longAccumulate()方法。&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;条件二/条件三.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/17213099667b01ef?w=1057&amp;amp;h=480&amp;amp;f=png&amp;amp;s=44545&quot; alt=&quot;条件二/条件三.png&quot;/&gt;条件二/条件三.png&lt;/h3&gt;
&lt;p&gt;接着往下看核心的&lt;code&gt;longAccumulate()&lt;/code&gt;方法，代码很长，后面会一步步分析，先上代码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.atomic.Striped64.&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;longAccumulate&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long x, LongBinaryOperator fn, &lt;span class=&quot;hljs-keyword&quot;&gt;boolean wasUncontended) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int h;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((h = getProbe()) == &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;br/&gt;ThreadLocalRandom.current();&lt;br/&gt;h = getProbe();&lt;br/&gt;wasUncontended = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean collide = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (;;) {&lt;br/&gt;Cell[] as; Cell a; &lt;span class=&quot;hljs-keyword&quot;&gt;int n; &lt;span class=&quot;hljs-keyword&quot;&gt;long v;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((as = cells) != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; (n = as.length) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((a = as[(n - &lt;span class=&quot;hljs-number&quot;&gt;1) &amp;amp; h]) == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;br/&gt;Cell r = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell(x);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean created = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;Cell[] rs; &lt;span class=&quot;hljs-keyword&quot;&gt;int m, j;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((rs = cells) != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; (m = rs.length) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; rs[j = (m - &lt;span class=&quot;hljs-number&quot;&gt;1) &amp;amp; h] == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {&lt;br/&gt;rs[j] = r;&lt;br/&gt;created = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally {&lt;br/&gt;cellsBusy = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (created)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;collide = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (!wasUncontended)&lt;br/&gt;wasUncontended = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (a.cas(v = a.value, ((fn == &lt;span class=&quot;hljs-keyword&quot;&gt;null) ? v + x : fn.applyAsLong(v, x))))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (n &amp;gt;= NCPU || cells != as)&lt;br/&gt;collide = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (!collide)&lt;br/&gt;collide = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cells == as) {&lt;br/&gt;Cell[] rs = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell[n &amp;lt;&amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; n; ++i)&lt;br/&gt;rs[i] = as[i];&lt;br/&gt;cells = rs;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally {&lt;br/&gt;cellsBusy = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;}&lt;br/&gt;collide = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue;&lt;br/&gt;}&lt;br/&gt;h = advanceProbe(h);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; cells == as &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean init = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cells == as) {&lt;br/&gt;Cell[] rs = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell[&lt;span class=&quot;hljs-number&quot;&gt;2];&lt;br/&gt;rs[h &amp;amp; &lt;span class=&quot;hljs-number&quot;&gt;1] = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell(x);&lt;br/&gt;cells = rs;&lt;br/&gt;init = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally {&lt;br/&gt;cellsBusy = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (init)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (casBase(v = base, ((fn == &lt;span class=&quot;hljs-keyword&quot;&gt;null) ? v + x : fn.applyAsLong(v, x))))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;                          &lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很长，&lt;code&gt;if else&lt;/code&gt;分支很多，除此看肯定会很头疼。这里一点点分析，然后结合画图一步步了解其中实现原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们首先要清楚执行这个方法的前置条件，它们是或的关系，如上面条件一、二、三&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;cells数组没有初始化&lt;/li&gt;
&lt;li&gt;cells数组已经初始化，但是当前线程对应的cell数据为空&lt;/li&gt;
&lt;li&gt;cells数组已经初始化， 当前线程对应的cell数据为空，且CAS操作+1失败&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;longAccumulate()方法的入参：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;long x 需要增加的值，一般默认都是1&lt;/li&gt;
&lt;li&gt;LongBinaryOperator fn 默认传递的是null&lt;/li&gt;
&lt;li&gt;wasUncontended竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是false&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;然后再看下Striped64中一些变量或者方法的定义：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;base: 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上&lt;/li&gt;
&lt;li&gt;collide：表示扩容意向，false 一定不会扩容，true可能会扩容。&lt;/li&gt;
&lt;li&gt;cellsBusy：初始化cells或者扩容cells需要获取锁, 0:表示无锁状态 1:表示其他线程已经持有了锁&lt;/li&gt;
&lt;li&gt;casCellsBusy(): 通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true&lt;/li&gt;
&lt;li&gt;NCPU：当前计算机CPU数量，Cell数组扩容时会使用到&lt;/li&gt;
&lt;li&gt;getProbe(): 获取当前线程的hash值&lt;/li&gt;
&lt;li&gt;advanceProbe(): 重置当前线程的hash值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;接着开始正式解析longAccumulate()源码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot; readability=&quot;2.5&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot; readability=&quot;5&quot;&gt;long PROBE;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((h = getProbe()) == &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;br/&gt;ThreadLocalRandom.current();&lt;br/&gt;h = getProbe();&lt;br/&gt;wasUncontended = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;getProbe&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return UNSAFE.getInt(Thread.currentThread(), PROBE);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们上面说过&lt;code&gt;getProbe()&lt;/code&gt;方法是为了获取当前线程的&lt;code&gt;hash值&lt;/code&gt;，具体实现是通过&lt;code&gt;UNSAFE.getInt()&lt;/code&gt;实现的，&lt;code&gt;PROBE&lt;/code&gt;是在初始化时候获取当前线程&lt;code&gt;threadLocalRandomProbe&lt;/code&gt;的值。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注：Unsafe.getInt()有三个重载方法getInt(Object o, long offset)、getInt(long address) 和getIntVolatile(long address)，都是从指定的位置获取变量的值，只不过第一个的offset是相对于对象o的相对偏移量，第二个address是绝对地址偏移量。如果第一个方法中o为null是，offset也会被作为绝对偏移量。第三个则是带有volatile语义的load读操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果当前线程的&lt;strong&gt;hash值h=getProbe()为0，0与任何数取模都是0，会固定到数组第一个位置&lt;/strong&gt;，所以这里做了优化，使用&lt;code&gt;ThreadLocalRandom&lt;/code&gt;为当前线程重新计算一个&lt;code&gt;hash&lt;/code&gt;值。最后设置&lt;code&gt;wasUncontended = true&lt;/code&gt;，这里含义是重新计算了当前线程的&lt;code&gt;hash&lt;/code&gt;后认为此次不算是一次竞争。&lt;code&gt;hash&lt;/code&gt;值被重置就好比一个全新的线程一样，所以设置了竞争状态为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以画图理解为：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;wasUncontended设置说明.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308c83719db8?w=1309&amp;amp;h=519&amp;amp;f=png&amp;amp;s=80218&quot; alt=&quot;wasUncontended设置说明.png&quot;/&gt;wasUncontended设置说明.png&lt;/h3&gt;
&lt;p&gt;接着执行&lt;code&gt;for循环&lt;/code&gt;，我们可以把&lt;code&gt;for循环&lt;/code&gt;代码拆分一下，每个&lt;code&gt;if条件&lt;/code&gt;算作一个&lt;code&gt;CASE&lt;/code&gt;来分析：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;longAccumulate&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot; readability=&quot;4&quot;&gt;long x, LongBinaryOperator fn, &lt;span class=&quot;hljs-keyword&quot; readability=&quot;8&quot;&gt;boolean wasUncontended) {&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (;;) {&lt;br/&gt;Cell[] as; Cell a; &lt;span class=&quot;hljs-keyword&quot;&gt;int n; &lt;span class=&quot;hljs-keyword&quot;&gt;long v;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((as = cells) != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; (n = as.length) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; cells == as &amp;amp;&amp;amp; casCellsBusy()) {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (casBase(v = base, ((fn == &lt;span class=&quot;hljs-keyword&quot;&gt;null) ? v + x : fn.applyAsLong(v, x))))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，第一个&lt;code&gt;if语句代表CASE1&lt;/code&gt;，里面再有&lt;code&gt;if判断&lt;/code&gt;会以&lt;code&gt;CASE1.1&lt;/code&gt;这种形式来讲解，下面接着的&lt;code&gt;else if&lt;/code&gt;为&lt;code&gt;CASE2&lt;/code&gt;， 最后一个为&lt;code&gt;CASE3&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;hcase1&quot;&gt;&lt;strong&gt;CASE1执行条件&lt;/strong&gt;：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((as = cells) != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; (n = as.length) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cells数组&lt;/code&gt;不为空，且数组长度大于0的情况会执行&lt;code&gt;CASE1&lt;/code&gt;，&lt;code&gt;CASE1&lt;/code&gt;的实现细节代码较多，放到最后面讲解。&lt;/p&gt;
&lt;h5 id=&quot;hcase2&quot;&gt;&lt;strong&gt;CASE2执行条件和实现原理&lt;/strong&gt;：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; cells == as &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean init = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cells == as) {&lt;br/&gt;Cell[] rs = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell[&lt;span class=&quot;hljs-number&quot;&gt;2];&lt;br/&gt;rs[h &amp;amp; &lt;span class=&quot;hljs-number&quot;&gt;1] = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell(x);&lt;br/&gt;cells = rs;&lt;br/&gt;init = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally {&lt;br/&gt;cellsBusy = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (init)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CASE2&lt;/code&gt; 标识&lt;code&gt;cells数组&lt;/code&gt;还未初始化，因为判断&lt;code&gt;cells == as&lt;/code&gt;，这个代表当前线程到了这里获取的&lt;code&gt;cells&lt;/code&gt;还是之前的一致。我们可以先看这个&lt;code&gt;case&lt;/code&gt;，最后再回头看最为麻烦的&lt;code&gt;CASE1&lt;/code&gt;实现逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cellsBusy&lt;/code&gt;上面说了是加锁的状态，初始化&lt;code&gt;cells数组&lt;/code&gt;和扩容的时候都要获取加锁的状态，这个是通过&lt;code&gt;CAS&lt;/code&gt;来实现的，为0代表无锁状态，为1代表其他线程已经持有锁了。&lt;code&gt;cells==as&lt;/code&gt;代表当前线程持有的数组未进行修改过，&lt;code&gt;casCellsBusy()&lt;/code&gt;通过&lt;code&gt;CAS操作&lt;/code&gt;去获取锁。但是里面的&lt;code&gt;if条件&lt;/code&gt;又再次判断了&lt;code&gt;cell==as&lt;/code&gt;，这一点是不是很奇怪？通过画图来说明下问题：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;cells==as双重判断说明.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308ca3505c34?w=1007&amp;amp;h=550&amp;amp;f=png&amp;amp;s=51496&quot; alt=&quot;cells==as双重判断说明.png&quot;/&gt;cells==as双重判断说明.png&lt;/h3&gt;
&lt;p&gt;如果上面条件都执行成功就会执行数组的初始化及赋值操作， &lt;code&gt;Cell[] rs = new Cell[2]&lt;/code&gt;表示数组的长度为2，&lt;code&gt;rs[h &amp;amp; 1] = new Cell(x)&lt;/code&gt; 表示创建一个新的&lt;code&gt;Cell元素&lt;/code&gt;，&lt;strong&gt;value是x值，默认为1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h &amp;amp; 1&lt;/code&gt;类似于我们之前&lt;code&gt;HashMap&lt;/code&gt;或者&lt;code&gt;ThreadLocal&lt;/code&gt;里面经常用到的计算散列桶&lt;code&gt;index&lt;/code&gt;的算法，通常都是&lt;code&gt;hash &amp;amp; (table.len - 1)&lt;/code&gt;，这里就不做过多解释了。 执行完成后直接退出&lt;code&gt;for循环&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;hcase3&quot;&gt;&lt;strong&gt;CASE3执行条件和实现原理&lt;/strong&gt;：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (casBase(v = base, ((fn == &lt;span class=&quot;hljs-keyword&quot;&gt;null) ? v + x : fn.applyAsLong(v, x))))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入到这里说明&lt;code&gt;cells&lt;/code&gt;正在或者已经初始化过了，执行&lt;code&gt;caseBase()&lt;/code&gt;方法，通过&lt;code&gt;CAS操作&lt;/code&gt;来修改&lt;code&gt;base&lt;/code&gt;的值，如果修改成功则跳出循环，这个&lt;code&gt;CAS&lt;/code&gt;E只有在初始化&lt;code&gt;Cell数组&lt;/code&gt;的时候，多个线程尝试&lt;code&gt;CAS&lt;/code&gt;修改&lt;code&gt;cellsBusy&lt;/code&gt;加锁的时候，失败的线程会走到这个分支，然后直接&lt;code&gt;CAS&lt;/code&gt;修改&lt;code&gt;base&lt;/code&gt;数据。&lt;/p&gt;
&lt;h5 id=&quot;hcase1-1&quot;&gt;&lt;strong&gt;CASE1 实现原理&lt;/strong&gt;：&lt;/h5&gt;
&lt;p&gt;分析完了&lt;code&gt;CASE2和CASE3&lt;/code&gt;，我们再折头回看一下&lt;code&gt;CASE1&lt;/code&gt;，进入&lt;code&gt;CASE1&lt;/code&gt;的前提是：&lt;code&gt;cells数组&lt;/code&gt;不为空，已经完成了初始化赋值操作。&lt;/p&gt;
&lt;p&gt;接着还是一点点往下拆分代码，首先看第一个判断分支&lt;code&gt;CASE1.1&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((a = as[(n - &lt;span class=&quot;hljs-number&quot;&gt;1) &amp;amp; h]) == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;br/&gt;Cell r = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell(x);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean created = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;Cell[] rs; &lt;span class=&quot;hljs-keyword&quot;&gt;int m, j;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((rs = cells) != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; (m = rs.length) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; rs[j = (m - &lt;span class=&quot;hljs-number&quot;&gt;1) &amp;amp; h] == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {&lt;br/&gt;rs[j] = r;&lt;br/&gt;created = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally {&lt;br/&gt;cellsBusy = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (created)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;collide = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个if条件中&lt;code&gt;(a = as[(n - 1) &amp;amp; h]) == null&lt;/code&gt;代表当前线程对应的数组下标位置的&lt;code&gt;cell&lt;/code&gt;数据为&lt;code&gt;null&lt;/code&gt;，代表没有线程在此处创建&lt;code&gt;Cell&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;接着判断&lt;code&gt;cellsBusy==0&lt;/code&gt;，代表当前锁未被占用。然后新创建&lt;code&gt;Cell对象&lt;/code&gt;，接着又判断了一遍&lt;code&gt;cellsBusy == 0&lt;/code&gt;，然后执行&lt;code&gt;casCellsBusy()&lt;/code&gt;尝试通过CAS操作修改&lt;code&gt;cellsBusy=1&lt;/code&gt;，加锁成功后修改扩容意向&lt;code&gt;collide = false;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (;;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((rs = cells) != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; (m = rs.length) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; rs[j = (m - &lt;span class=&quot;hljs-number&quot;&gt;1) &amp;amp; h] == &lt;span class=&quot;hljs-keyword&quot; readability=&quot;1&quot;&gt;null) {&lt;br/&gt;rs[j] = r;&lt;br/&gt;created = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;2&quot;&gt;true;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (created)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码判断当前线程&lt;code&gt;hash&lt;/code&gt;后指向的数据位置元素是否为空，如果为空则将&lt;code&gt;cell&lt;/code&gt;数据放入数组中，跳出循环。如果不为空则继续循环。&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;CASE1.1.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308d56966b00?w=1261&amp;amp;h=528&amp;amp;f=png&amp;amp;s=67009&quot; alt=&quot;CASE1.1.png&quot;/&gt;CASE1.1.png&lt;/h3&gt;
&lt;p&gt;继续往下看代码，&lt;strong&gt;CASE1.2&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (!wasUncontended)&lt;br/&gt;wasUncontended = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;p&gt;h = advanceProbe(h);&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;wasUncontended&lt;/code&gt;表示&lt;code&gt;cells&lt;/code&gt;初始化后，当前线程竞争修改失败&lt;code&gt;wasUncontended =false&lt;/code&gt;，这里只是重新设置了这个值为&lt;code&gt;true&lt;/code&gt;，紧接着执行&lt;code&gt;advanceProbe(h)&lt;/code&gt;重置当前线程的&lt;code&gt;hash&lt;/code&gt;，重新循环。&lt;/p&gt;
&lt;p&gt;接着看&lt;strong&gt;CASE1.3&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (a.cas(v = a.value, ((fn == &lt;span class=&quot;hljs-keyword&quot;&gt;null) ? v + x : fn.applyAsLong(v, x))))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;CASE1.3&lt;/code&gt;说明当前线程对应的数组中有了数据，也重置过&lt;code&gt;hash值&lt;/code&gt;，这时通过CAS操作尝试对当前数中的&lt;code&gt;value值&lt;/code&gt;进行累加x操作，x默认为1，如果&lt;code&gt;CAS&lt;/code&gt;成功则直接跳出循环。&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;CASE1.3.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721309968058cfd?w=976&amp;amp;h=381&amp;amp;f=png&amp;amp;s=32669&quot; alt=&quot;CASE1.3.png&quot;/&gt;CASE1.3.png&lt;/h3&gt;
&lt;p&gt;接着看&lt;strong&gt;CASE1.4：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (n &amp;gt;= NCPU || cells != as)&lt;br/&gt;collide = &lt;span class=&quot;hljs-keyword&quot;&gt;false;    &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;cells数组&lt;/code&gt;的长度达到了&lt;code&gt;CPU核心数&lt;/code&gt;，或者&lt;code&gt;cells&lt;/code&gt;扩容了，设置扩容意向&lt;code&gt;collide为false&lt;/code&gt;并通过下面的&lt;code&gt;h = advanceProbe(h)&lt;/code&gt;方法修改线程的&lt;code&gt;probe&lt;/code&gt;再重新尝试&lt;/p&gt;
&lt;p&gt;至于这里为什么要提出和&lt;code&gt;CPU数量&lt;/code&gt;做判断的问题：每个线程会通过线程对&lt;code&gt;cells[threadHash%cells.length]&lt;/code&gt;位置的&lt;code&gt;Cell&lt;/code&gt;对象中的&lt;code&gt;value&lt;/code&gt;做累加，这样相当于将线程绑定到了&lt;code&gt;cells&lt;/code&gt;中的某个&lt;code&gt;cell&lt;/code&gt;对象上，如果超过&lt;code&gt;CPU数量&lt;/code&gt;的时候就不再扩容是因为&lt;code&gt;CPU&lt;/code&gt;的数量代表了机器处理能力，当超过&lt;code&gt;CPU&lt;/code&gt;数量时，多出来的&lt;code&gt;cells&lt;/code&gt;数组元素没有太大作用。&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;多线程更新Cell.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308eef669188?w=971&amp;amp;h=636&amp;amp;f=png&amp;amp;s=43034&quot; alt=&quot;多线程更新Cell.png&quot;/&gt;多线程更新Cell.png&lt;/h3&gt;
&lt;p&gt;接着看&lt;strong&gt;CASE1.5&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (!collide)&lt;br/&gt;collide = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果扩容意向&lt;code&gt;collide&lt;/code&gt;是&lt;code&gt;false&lt;/code&gt;则修改它为&lt;code&gt;true&lt;/code&gt;，然后重新计算当前线程的&lt;code&gt;hash&lt;/code&gt;值继续循环，在&lt;code&gt;CASE1.4&lt;/code&gt;中，如果当前数组的长度已经大于了&lt;code&gt;CPU&lt;/code&gt;的核数，就会再次设置扩容意向&lt;code&gt;collide=false&lt;/code&gt;，这里的意义是保证扩容意向为&lt;code&gt;false&lt;/code&gt;后不再继续往后执行&lt;code&gt;CASE1.6&lt;/code&gt;的扩容操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着看CASE1.6分支：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (cellsBusy == &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cells == as) {&lt;br/&gt;Cell[] rs = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell[n &amp;lt;&amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; n; ++i)&lt;br/&gt;rs[i] = as[i];&lt;br/&gt;cells = rs;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally {&lt;br/&gt;cellsBusy = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;}&lt;br/&gt;collide = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面执行的其实是扩容逻辑，首先是判断通过&lt;code&gt;CAS&lt;/code&gt;改变&lt;code&gt;cellsBusy&lt;/code&gt;来尝试加锁，如果&lt;code&gt;CAS&lt;/code&gt;成功则代表获取锁成功，继续向下执行，判断当前的&lt;code&gt;cells&lt;/code&gt;数组和最先赋值的&lt;code&gt;as&lt;/code&gt;是同一个，代表没有被其他线程扩容过，然后进行扩容，扩容大小为之前的容量的两倍，这里用的按位左移1位来操作的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Cell[] rs = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cell[n &amp;lt;&amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1];&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩容后再将之前数组的元素拷贝到新数组中，释放锁设置&lt;code&gt;cellsBusy = 0&lt;/code&gt;，设置扩容状态，然后继续循环执行。&lt;/p&gt;
&lt;p&gt;到了这里，我们已经分析完了&lt;code&gt;longAccumulate()&lt;/code&gt;所有的逻辑，逻辑分支挺多，仔细分析看看其实还是挺清晰的，流程图如下：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;流程图.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/1721308e871bc27b?w=1225&amp;amp;h=741&amp;amp;f=png&amp;amp;s=155351&quot; alt=&quot;流程图.png&quot;/&gt;流程图.png&lt;/h3&gt;
&lt;p&gt;我们再举一些线程执行的例子里面场景覆盖不全，大家可以按照这种模式自己模拟场景分析代码流程：&lt;/p&gt;
&lt;h3&gt;&lt;img title=&quot;多线程执行示例.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/14/172130996970124c?w=1647&amp;amp;h=502&amp;amp;f=png&amp;amp;s=123404&quot; alt=&quot;多线程执行示例.png&quot;/&gt;多线程执行示例.png&lt;/h3&gt;
&lt;p&gt;如有问题也请及时指出，我会第一时间更正，不胜感激！&lt;/p&gt;
&lt;h4 id=&quot;hlongaddersum&quot;&gt;LongAdder的sum方法&lt;/h4&gt;
&lt;p&gt;当我们最终获取计数器值时，我们可以使用&lt;code&gt;LongAdder.longValue()&lt;/code&gt;方法，其内部就是使用&lt;code&gt;sum&lt;/code&gt;方法来汇总数据的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.atomic.LongAdder.sum()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;long &lt;span class=&quot;hljs-title&quot;&gt;sum&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;Cell[] as = cells; Cell a;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long sum = base;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (as != &lt;span class=&quot;hljs-keyword&quot;&gt;null) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; as.length; ++i) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if ((a = as[i]) != &lt;span class=&quot;hljs-keyword&quot;&gt;null)&lt;br/&gt;sum += a.value;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return sum;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现很简单，base + &lt;span class=&quot;katex&quot;&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALYAAABCCAYAAAD68ywLAAAPSElEQVR4Xu2dCdDV0xvHnxQtBqk3yTZitJhR0avGkgjZSxTtU5KtREpFJmQppbJnGSFpT6KVaTHEVKZso40KISEqS4jM58ycO+e97v2d8/vd333fe997nhnz7/3f33LOc773Oc95nu/z3Ar79u3bJ168BsqZBip4YJezFfXTURrwwPZAKJca8MAul8vqJ5V1YG/cuFEeffRR+eeff+Syyy6Tiy++WL755huZOXOmfPrpp1K9enU588wzpXXr1lK1alW/Il4DsWggq8D+66+/pG3btnLRRRfJkiVL5Oeff1Z/z5kzR4G5VatW8tprr8nHH38sffr0kauuuiqWSfmHeA1kFdhvvvmmTJw4UV5++WW59dZb5cMPP1QaHzp0qLLQyPvvvy9DhgyRI444QqZMmeJXxGsgFg1kFdh9+/aV4uJi6datm7LOSKdOneSGG25IDH7ZsmVy9913y6GHHqqstxevgTg0kFVgY6GPO+44+e677+S6665T4wW8gFgL/verr76qXJMHHnggjjn5Z3gNlE64b8aMGfLEE0/I0UcfLZMmTUqo/d9//5UrrrhC+d79+/eXyy+/3C+J10AsGsiqxdYjvOOOO+S9995TIL7lllsSA//kk08EdwWZNWuWFBUVxTIp/xCvgawDmzCf9q+HDx8uLVu2TGj9scceU4A+5ZRTZNy4cerwuG7dOrn33nv9yngNZKSBrAN7w4YN0rt375T+NQfJb7/9VkVMLrzwQmXRr732WrnyyiszmpS/2Wsg68CePXu2PPLII3L88cfLhAkTSmhcA3vkyJGyatUqFeueOnWqVKlSxa+M10BGGsg6sJ999ll55ZVXlFVu165dicES59aRkFq1asnYsWPlmGOOyWhC/mavATSQdWD/8ccfsmPHDjnyyCNTanzPnj0qxQ6g999/f78qXgOxaCDrwI5llP4hXgMhNeCBHVJh/vL80IAHdn6skx9lSA14YIdUmL88PzTgge24TpSG/vDDD/L111/L1q1bFb+cA3GTJk2kcuXKiaf89NNP8vbbb6uYfGkJY/v999/l119/VZz2gw8+2OnVUBp+++032b17t9SoUaNchVk9sC0QAMTwx+fOnavAk0qg3cI5h/Ny8803K9CXBgX3mWeekQULFqj3aoFv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&quot; alt=&quot;&quot;/&gt;，遍历&lt;code&gt;cells&lt;/code&gt;数组中的值，然后累加。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;hatomiclong-3&quot;&gt;AtomicLong可以弃用了吗？&lt;/h4&gt;
&lt;p&gt;看上去&lt;code&gt;LongAdder&lt;/code&gt;的性能全面超越了&lt;code&gt;AtomicLong&lt;/code&gt;，而且阿里巴巴开发手册也提及到 &lt;strong&gt;推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观 锁的重试次数）&lt;/strong&gt;，但是我们真的就可以舍弃掉&lt;code&gt;LongAdder&lt;/code&gt;了吗？&lt;/p&gt;
&lt;p&gt;当然不是，我们需要看场景来使用，如果是并发不太高的系统，使用&lt;code&gt;AtomicLong&lt;/code&gt;可能会更好一些，而且内存需求也会小一些。&lt;/p&gt;
&lt;p&gt;我们看过&lt;code&gt;sum()&lt;/code&gt;方法后可以知道&lt;code&gt;LongAdder&lt;/code&gt;在统计的时候如果有并发更新，可能导致统计的数据有误差。&lt;/p&gt;
&lt;p&gt;而在高并发统计计数的场景下，才更适合使用&lt;code&gt;LongAdder&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LongAdder&lt;/code&gt;中最核心的思想就是利用空间来换时间，将热点&lt;code&gt;value&lt;/code&gt;分散成一个&lt;strong&gt;Cell列表来承接并发的CAS&lt;/strong&gt;，以此来提升性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LongAdder&lt;/code&gt;的原理及实现都很简单，但其设计的思想值得我们品味和学习。&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;img title=&quot;YDzI1K.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/5/15/172156170348497e?w=900&amp;amp;h=383&amp;amp;f=png&amp;amp;s=111301&quot; alt=&quot;YDzI1K.png&quot;/&gt;YDzI1K.png&lt;/h3&gt;
</description>
<pubDate>Thu, 14 May 2020 23:29:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 思维导图.png 文章中所有高清无码图片在公众号号回复: 图片666 即可查阅, 可直接关注公众号：壹枝花算不算浪漫 最近阿里巴巴发布了Java开发手册(泰山版) (公众号回复： 开发手册 可收</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12892695.html</dc:identifier>
</item>
<item>
<title>面试官在“逗”你系列：数组去重你会几种呀？ - 胡哥有话说</title>
<link>http://www.cnblogs.com/justbecoder/p/12892675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justbecoder/p/12892675.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;数组去重是一个老生常谈的话题，也是前端童鞋在面试时的一道高频题。本文将深入的探索数组去重的原理及实现，为各位小伙伴提供&lt;code&gt;多种&lt;/code&gt;可以&lt;code&gt;反手“调戏”&lt;/code&gt;面试官的解决方案。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;话不多说，上去就来一梭子...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数组去重核心原理&quot;&gt;数组去重核心原理&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;价值100W的核心原理上来就给你了...，记得留言点赞鸭！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;一般我们都会创建临时变量tmp，存储不重复的元素（以数组元素存储或对象的键来存储）；&lt;/li&gt;
&lt;li&gt;遍历待去重数组arr，依次判断tmp中是否包含该元素；&lt;/li&gt;
&lt;li&gt;若tmp中不存在该元素，则放入；否则跳过不处理。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;基本上无论什么样的实现，其核心皆是如此（判断是否已存在）。不行你就留言，咱们可以&lt;code&gt;battle&lt;/code&gt;一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;经典去重方案一：&quot;&gt;经典去重方案一：&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;设置tmp为对象，对象的键存储数组元素的值，最终返回对象的所有键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;function array_unique (arr) {
  if (arr.length === 0) {
    return arr
  }
  let tmp = {}
  let len = arr.length
  for (let i = 0; i &amp;lt; len; i++) {
    if (tmp[arr[i]] === undefined) {
      tmp[arr[i]] = i
    }
  }
  return Object.keys(tmp)
}

// 调用数组去重
let arr = [1, 2, 3, 1, 2]
let newArr = array_unique(arr)
console.log(newArr) // ['1', '2', '3']
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你采用这种方式来回答面试官的话，你就陷入了他在内心中早早设下的陷阱：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你这种方式能区分数字和字符串吗？能区分&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;'undefined'&lt;/code&gt;吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你现在返回的数据类型还和原有的数据类型一致吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;带着面试官的疑问，我们来看另外一种经典去重方式。&lt;/p&gt;
&lt;h2 id=&quot;经典去重方式二：&quot;&gt;经典去重方式二：&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;设置tmp为数组，数组中存储唯一的元素，最终返回tmp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;function array_unique (arr) {
  let len = arr.length
  if (!len) {
    return []
  }
  let tmp = []
  for (let i = 0; i &amp;lt; len; i++) {
    // 判断数组arr的元素是否在数组tmp中
    if (tmp.indexOf(arr[i]) === -1) {
      tmp.push(arr[i])
    }
  }
  return tmp
}
let arr = [1, 2, 3, '1', 2, undefined, undefined, 'undefined']
let newArr = array_unique(arr)
console.log(newArr) // [1, 2, 3, '1', undefined, 'undefined']
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;此刻，内心是否窃喜！&lt;/p&gt;
&lt;p&gt;But, 如果你这么考虑，又陷入了面试官的另一个陷阱：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你这方式能筛选NaN吗？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;好吧，面试官最大，再考虑！&lt;/p&gt;
&lt;h3 id=&quot;数组去重方式三：&quot;&gt;数组去重方式三：&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;原理还是同去重方式二，只不过我们使用ES6的&lt;code&gt;includes&lt;/code&gt;替换&lt;code&gt;indexOf&lt;/code&gt;方法，&lt;/p&gt;
&lt;p&gt;includes() 方法，判断数组中是否包含某个元素，如果包含返回true，否则返回false&lt;/p&gt;
&lt;p&gt;就是这么so easy!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;function array_unique (arr) {
  let len = arr.length
  if (!len) {
    return []
  }
  let tmp = []
  for (let i = 0; i &amp;lt; len; i++) {
    // 判断数组arr的元素是否在数组tmp中
    if (!tmp.includes(arr[i]) {
      tmp.push(arr[i])
    }
  }
  return tmp
}
let arr = [1, 2, 3, '1', 2, undefined, undefined,  'undefined', NaN, NaN]
let newArr = array_unique(arr)
console.log(newArr) // [1, 2, 3, '1', undefined, 'undefined', NaN]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;此刻，你以为就结束吗？不，不可能！&lt;/p&gt;
&lt;p&gt;面试官的坑已经在前面等你很久了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你的这个筛选方式能区分对象吗？如{}、{a: 1}&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;有没有想把自己的四十米大砍刀拿出来，&lt;code&gt;neng屎&lt;/code&gt;面试官！（图就不配了，自己脑补吧...）&lt;br/&gt;然而，什么都做不了，继续想吧...&lt;/p&gt;
&lt;h2 id=&quot;数组去重方式四：&quot;&gt;数组去重方式四：&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;原理同上，我们要继续换一个判断数组是否包含某元素的方法：```findIndex``&lt;/p&gt;
&lt;p&gt;&lt;code&gt;findIndex&lt;/code&gt;查询数组是否包含某元素，如果存在返回元素的索引，否则返回-1。它比indexOf更加先进的地方在于能传入&lt;code&gt;callback&lt;/code&gt;，按约定方式查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;function array_unique (arr) {
  let len = arr.length
  if (!len) {
    return []
  }
  let tmp = []
  for (let i = 0; i &amp;lt; len; i++) {
    // 判断数组arr的元素是否在数组tmp中
    if (tmp.findIndex((v) =&amp;gt; JSON.stringify(v) === JSON.stringify(arr[i])) !== -1) {
      tmp.push(arr[i])
    }
  }
  return tmp
}
let arr = [1, 2, 3, '1', 2, undefined, undefined,  'undefined', NaN, NaN, {}, {}, {a: 1}, {a: 1}]
let newArr = array_unique(arr)
console.log(newArr) // [1, 2, 3, '1', undefined, 'undefined', NaN, {}, {a: 1}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;终于成功啦！来来来，可以潇洒的问面试官，“您还有问题没有？”&lt;/p&gt;
&lt;p&gt;当然，主动挑衅面试官，是要承担风险呦，有可能会因为你眨眼的时候，先眨了右眼被挂掉了...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;判断数组是否包含某元素的几种方式：&quot;&gt;判断数组是否包含某元素的几种方式：&lt;/h2&gt;
&lt;p&gt;给大家列个表格，好区分几个方法的作用，&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法\是否可检测&lt;/th&gt;
&lt;th&gt;null&lt;/th&gt;
&lt;th&gt;undefined&lt;/th&gt;
&lt;th&gt;NaN&lt;/th&gt;
&lt;th&gt;{}&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;indexOf&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;includes&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;findIndex&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;需传入特定的callback&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;数组去重这道面试题，考察的知识点还是非常多的。首先是对数组的常用方法要比较熟悉，还有其他的如NaN与NaN不相等，{}与{}不相等等知识点，以及灵活多变的思维逻辑。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当然，数组去重还有其他的多种实现方式，欢迎各位小伙伴留言交流！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;收藏&lt;/code&gt;呦，关注胡哥有话说，学习前端不迷路，欢迎多多留言交流...&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;胡哥有话说，一个有技术，有情怀的胡哥！现任京东前端攻城狮一枚。&lt;/p&gt;
&lt;p&gt;胡哥有话说，专注于大前端技术领域，分享前端系统架构，框架实现原理，最新最高效的技术实践！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 14 May 2020 23:09:00 +0000</pubDate>
<dc:creator>胡哥有话说</dc:creator>
<og:description>前言 数组去重是一个老生常谈的话题，也是前端童鞋在面试时的一道高频题。本文将深入的探索数组去重的原理及实现，为各位小伙伴提供 可以 面试官的解决方案。 话不多说，上去就来一梭子... 数组去重核心原理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justbecoder/p/12892675.html</dc:identifier>
</item>
<item>
<title>深度学习中的序列模型演变及学习笔记（含RNN/LSTM/GRU/Seq2Seq/Attention机制） - FinTecher</title>
<link>http://www.cnblogs.com/zhengzhicong/p/12890660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengzhicong/p/12890660.html</guid>
<description>&lt;p&gt;深度学习中的序列模型已经广泛应用于自然语言处理（例如机器翻译等）、语音识别、序列生成、序列分析等众多领域！本文主要介绍深度学习中序列模型的演变路径。一、循环神经网络RNN 二、长短期记忆网络LSTM 三、GRU 四、RNN/LSTM/GRU的变体结构 五、注意力机制 六、应用&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;192.6429675425&quot;&gt;
&lt;p&gt;【说在前面】本人博客新手一枚，象牙塔的老白，职业场的小白。以下内容仅为个人见解，欢迎批评指正，不喜勿喷！[认真看图][认真看图]&lt;/p&gt;
&lt;p&gt;【补充说明】深度学习中的序列模型已经广泛应用于自然语言处理（例如机器翻译等）、语音识别、序列生成、序列分析等众多领域！&lt;/p&gt;
&lt;p&gt;【再说一句】本文主要介绍深度学习中序列模型的演变路径，和往常一样，不会详细介绍各算法的具体实现，望理解！&lt;/p&gt;
&lt;h2&gt;一、循环神经网络RNN&lt;/h2&gt;
&lt;h3&gt;1. RNN标准结构&lt;/h3&gt;
&lt;p&gt;传统神经网络的前一个输入和后一个输入是完全没有关系的，不能处理序列信息（即前一个输入和后一个输入是有关系的）。&lt;/p&gt;
&lt;p&gt;循环神经网络RNN解决了以上问题，整体结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514183455629-1323647136.png&quot; alt=&quot;&quot; width=&quot;581&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. RNN系列结构&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;多对一：&lt;/strong&gt;例如情感分析，需要多个时间步长的输入，但是只需要单个输出（即实现分类）。整体结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514185019686-2028757740.png&quot; alt=&quot;&quot; width=&quot;250&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一对多：&lt;/strong&gt;例如音乐生成，只需要单个输入（即输入类别），但是需要输出整个序列。整体结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514185126963-1755878657.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514225813287-1410247895.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多对多：&lt;/strong&gt;例如实时分类，输入序列与输出序列的长度是一样的。整体结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514185200283-99039539.png&quot; alt=&quot;&quot; width=&quot;265&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多对多：&lt;/strong&gt;例如机器翻译，输入序列与输出序列的长度是不一样的。整体结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514231439605-839840678.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、长短期记忆网络LSTM&lt;/h2&gt;
&lt;p&gt;LSTM是RNN的一种变体，RNN由于梯度消失只有短期记忆，而LSTM网络通过精妙的门控制，一定程度上缓解了梯度消失的问题。&lt;/p&gt;
&lt;p&gt;在标准RNN中，神经网络模块只有一个非常简单的结构，例如一个tanh层。整体结构如图所示：&lt;/p&gt;
&lt;div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514190233090-740535861.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;而LSTM得神经网络模块具有不同的结构，LSTM包含遗忘门、输入门和输出门，增加了非线性的相互作用。整体结构如图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514190253387-1738630067.png&quot; alt=&quot;&quot; width=&quot;431&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、GRU&lt;/h2&gt;
&lt;p&gt;GRU是LSTM的一种变体，也是为了解决梯度消失（即长期记忆问题）而提出来的。相较于LSTM，GRU的网络结构更加简单，且效果很好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514221211893-1226752906.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、RNN/LSTM/GRU的变体结构&lt;/h2&gt;
&lt;h3&gt;1. 双向循环神经网络&lt;/h3&gt;
&lt;p&gt;例如命名实体识别：判断句子中Teddy是否是人名，如果只从前面几个词是无法得知Teddy是否是人名，如果能有后面的信息就很好判断了。&lt;/p&gt;
&lt;p&gt;双向循环神经网络中的网络单元可以是RNN、LSTM和GRU，均适用这种变体结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514221755955-33402982.png&quot; alt=&quot;&quot; width=&quot;451&quot; height=&quot;158&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 深层循环神经网络&lt;/h3&gt;
&lt;p&gt;顾名思义，就是多个循环神经网络的堆叠，循环神经网络可以采用RNN、LSTM和GRU，均适用这种变体结构。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514222523293-66739878.png&quot; alt=&quot;&quot; width=&quot;280&quot; height=&quot;194&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3. Seq2Seq架构：非常火热&lt;/h3&gt;
&lt;p&gt;又叫Encoder-Decoder模型，适用于输入与输出个数不一样相等的情况（即多对多的循环神经网络，&lt;strong&gt;适用于机器翻译等场景&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;其中，Encoder编码器和Decoder解码器可以使用RNN、LSTM和GRU，均适用这种变体结构。&lt;/p&gt;
&lt;p&gt;同时，这种结构也可以与双向、深层的变体结构同时使用，不冲突的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514185551652-273675211.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514225456355-592976435.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里多提一句，例如给图像添加描述这样的应用场景，图中对应的描述为“一只猫站在椅子上”，同样可以采用Encoder-Decoder模型。&lt;/p&gt;
&lt;h2&gt; 五、注意力机制&lt;/h2&gt;
&lt;h3&gt;1. Seq2Seq + Attention机制介绍&lt;/h3&gt;
&lt;p&gt;需要注意到，LSTM、GRU、双向变体结构、深层变体结构和Seq2Seq变体结构，只能说一定程度上缓解了梯度消失问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提出问题：&lt;/strong&gt;在做机器翻译时，专家学者们发现，在Seq2Seq结构中，Encoder把所有的输入序列都编码成一个统一的语义向量context，然后再由Decoder解码。其中，context自然也就成了限制模型性能的瓶颈，当要翻译的句子较长时，一个 context 可能存不下那么多信息。同时，只使用编码器的最后一个隐藏层状态，似乎不是很合理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;因此，引入了Attention机制（将有限的认知资源集中到最重要的地方）。在生成 Target 序列的每个词时，用到的中间语义向量 context 是 Source 序列通过Encoder的隐藏层的加权和，而不是只用Encoder最后一个时刻的输出作为context，这样就能保证在解码不同词的时候，Source 序列对现在解码词的贡献是不一样的。例如，Decoder 在解码&quot;machine&quot;时，&quot;机&quot;和&quot;器&quot;提供的权重要更大一些，同样，在解码&quot;learning&quot;时，&quot;学&quot;和&quot;习&quot;提供的权重相应的会更大一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现步骤：&lt;/strong&gt;（1）衡量编码中第 j 阶段的隐含层状态和解码时第 i 阶段的相关性（有很多种打分方式，这里不细讲）；（2）通过相关性的打分为编码中的不同阶段分配不同的权重；（3）解码中第 i 阶段输入的语义向量context就来自于编码中不同阶段的隐含层状态的加权和。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200514234438909-1855536263.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;294&quot;/&gt; &lt;/p&gt;
&lt;p&gt;补充说明一下，衡量相关性的打分方式主要包括以下几种，具体不展开了：&lt;/p&gt;
&lt;h3&gt;2. 层次注意力机制Hierarchical Attention&lt;/h3&gt;
&lt;p&gt;能够反映文档的层次结构。模型在单词和句子级别分别设计了两个注意力机制，这样做能够在构建文档表示时区别地对待这些内容。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515001250808-1879427509.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;477&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3. 自注意力机制Self-Attention：只有一个Seq&lt;/h3&gt;
&lt;p&gt;是关联单个序列中不同位置的注意力机制，从而计算序列的交互表示。已被证明在很多领域十分有效，例如机器阅读、图像描述生成等。&lt;/p&gt;
&lt;p&gt;以机器阅读为例，当前单词为红色，蓝色阴影的大小表示激活程度，自注意力机制使得能够学习当前单词和句子前一部分词之间的相关性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515002615532-938768815.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;补充说明，以图像描述生成为例，注意力权重的可视化清楚地表明了模型关注的图像的哪些区域以便输出某个单词：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515002725425-1766941584.png&quot; alt=&quot;&quot; width=&quot;489&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4. Fairseq：基于卷积神经网络的Seq2Seq + Attention机制&lt;/h3&gt;
&lt;p&gt;Facebook人工智能实验室提出基于卷积神经网络的Seq2Seq架构，将RNN替换为带有门控单元的CNN（相较于RNN，CNN工作不依赖于上一时间步的结果，所以可以做到最大程度的并行计算，提升训练速度），提升效果的同时大幅加快了模型训练速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515005501544-904818220.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;522&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5. Transformer：使用self-attention代替原有的RNN及CNN&lt;/h3&gt;
&lt;p&gt;以上Attention model虽然解决了输入seq仅有一个context vector的缺点，但仍存在一些问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;context vector计算的是输入seq、目标seq间的关联，却忽略了输入seq中文字间的关联、目标seq中文字间的关联性。&lt;/li&gt;
&lt;li&gt;Attention model中使用的RNN无法平行化处理，导致训练时间长，使用的CNN实际上是透过大量的layer去解决局部信息的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Google提出一种叫做”transformer”的模型，透过self-attention、multi-head的概念去解决上述缺点，完全舍弃了RNN、CNN的构架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515003534158-1618351867.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得一提的是，Google后续提出了BERT模型，在11个任务中取得了最好的效果，是深度学习在nlp领域又一个里程碑式的工作。&lt;/p&gt;
&lt;h3&gt;6. Memory-based Attention&lt;/h3&gt;
&lt;p&gt;在 NLP 的一些任务上，比如问答匹配任务，答案往往与问题间接相关。因此，基本的注意力技术就显得很无力了，这时候就体现了Memory-based Attention的强大之处。例如可以通过迭代内存更新（也称为多跳）来模拟时间推理过程，以逐步引导注意到答案的正确位置。&lt;/p&gt;
&lt;h3&gt;7. Soft/Hard Attention&lt;/h3&gt;
&lt;p&gt;简单说就是Soft Attention打分之后分配的权重取值在0到1之间，而Hard Attention取值为0或者1。&lt;/p&gt;
&lt;h3&gt;8. Global/Local Attention&lt;/h3&gt;
&lt;p&gt;这个也很好理解，就是采用全局或者局部的注意力机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515003932237-1510462108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、应用&lt;/h2&gt;
&lt;h3&gt;1. 自然语言处理&lt;/h3&gt;
&lt;p&gt;例如机器翻译、问答系统、文本分类、情绪分析、命名实体识别、创作乐曲等。&lt;/p&gt;
&lt;h3&gt;2. 图像处理&lt;/h3&gt;
&lt;p&gt;例如多媒体描述、局部图像补全、通过低分辨率的图像还原高分辨率图像等。&lt;/p&gt;
&lt;h3&gt;3. 智能推荐&lt;/h3&gt;
&lt;p&gt;例如用于用户行为分析，即将注意力权重分配给用户的交互项目，以更有效地捕捉长期和短期的兴趣。&lt;/p&gt;
&lt;h3&gt;4. 其他&lt;/h3&gt;
&lt;p&gt;本文参考大佬：https://github.com/yuquanle/Attention-Mechanisms-paper/blob/master/Attention-mechanisms-paper.md&lt;/p&gt;

&lt;p&gt;如果你对智能推荐感兴趣，欢迎先浏览我的另几篇随笔：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12817941.html&quot;&gt;智能推荐算法演变及学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您对数据挖掘感兴趣，欢迎浏览我的另几篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12728491.html&quot;&gt;数据挖掘比赛/项目全流程介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您对人工智能算法感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12670260.html&quot;&gt;人工智能新手入门学习路线和学习资源合集（含AI综述/python/机器学习/深度学习/tensorflow）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的应届毕业生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650878.html&quot;&gt;如果你是一个计算机领域的应届生，你如何准备求职面试？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的本科生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650191.html&quot;&gt;如果你是一个计算机领域的本科生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的研究生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650369.html&quot;&gt;如果你是一个计算机领域的研究生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你对金融科技感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12657428.html&quot;&gt;如果你想了解金融科技，不妨先了解金融科技有哪些可能？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之后博主将持续分享各大算法的学习思路和学习笔记：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12641421.html&quot;&gt;hello world: 我的博客写作思路&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 14 May 2020 17:56:00 +0000</pubDate>
<dc:creator>FinTecher</dc:creator>
<og:description>深度学习中的序列模型已经广泛应用于自然语言处理（例如机器翻译等）、语音识别、序列生成、序列分析等众多领域！本文主要介绍深度学习中序列模型的演变路径。一、循环神经网络RNN 二、长短期记忆网络LSTM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhengzhicong/p/12890660.html</dc:identifier>
</item>
<item>
<title>软件设计模式学习（十六）代理模式 - STYeeQan</title>
<link>http://www.cnblogs.com/Yee-Q/p/12891869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yee-Q/p/12891869.html</guid>
<description>&lt;br/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当直接访问某些对象存在问题时，可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。&lt;/p&gt;
&lt;/blockquote&gt;&lt;br/&gt;&lt;h2 id=&quot;模式动机&quot;&gt;模式动机&lt;/h2&gt;
&lt;p&gt;某些情况下，一个客户不想或不能直接引用一个对象，此时可以通过一个称之为代理的第三者实现间接引用。代理对象在客户端和目标对象之间起到中介作用，并且可以通过代理对象去掉客户不能看到的内容和添加客户需要的额外服务。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;模式定义&quot;&gt;模式定义&lt;/h2&gt;
&lt;p&gt;给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做 Proxy 或 Surrogate，它是一种对象结构模式。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;模式结构&quot;&gt;模式结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200514223526581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5faGFuZHNvbWU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Subject（抽象主题角色）&lt;/p&gt;
&lt;p&gt;声明了真实主题和代理主题的公共接口，这样一来在任何使用真实主题的地方都可以使用代理主题。客户端针对抽象主题角色编程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;Proxy（代理主题角色）&lt;/p&gt;
&lt;p&gt;代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题角色。&lt;/p&gt;
&lt;p&gt;代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候替代真实主体。&lt;/p&gt;
&lt;p&gt;代理主题角色还可以控制对真实主题的使用，负责在需要时创建和删除真实主题对象，并对真实主题对象的使用加以约束。&lt;/p&gt;
&lt;p&gt;代理角色通常在客户端调用所引用的真实主题操作之前或之后执行其他操作，而不仅仅只是单纯调用真实主题对象中的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;RealSubject（真实主题角色）&lt;/p&gt;
&lt;p&gt;真实主题角色定义了代理角色所代表的真实对象，真实主题角色中实现真实的业务，客户端通过代理主题角色间接调用真实主题角色中定义的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;&lt;h2 id=&quot;模式实例与解析&quot;&gt;模式实例与解析&lt;/h2&gt;
&lt;p&gt;在一个论坛已注册用户和游客权限不同，已注册用户拥有发帖、修改注册信息、修改自己帖子等功能；而游客只能看到别人发的贴子，没有其他权限。本实例中我们使用代理模式中的保护代理，该代理用于控制对一个对象的访问，可以给不同用户提供不同级别的使用权限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020051422355133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5faGFuZHNvbWU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;18&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;抽象主题角色 AbstractPermission（抽象权限类）&lt;/p&gt;
&lt;p&gt;AbstractPermission 作为抽象权限类，充当抽象主题角色，在其中声明了真实主题角色所提供的业务方法，它是真实主题角色和代理主题角色的公共接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface AbstractPermission {

    public void modifyUserInfo();

    public void viewNote();

    public void publishNote();

    public void modifyNote();

    public void setLevel(int level);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;真实主题角色 RealPermission（真实权限类）&lt;/p&gt;
&lt;p&gt;RealPermission 是真实主题角色，它实现了在抽象主题角色中定义的方法，由于种种原因客户端无法访问其中内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RealPermission implements AbstractPermission {

    @Override
    public void modifyUserInfo() {
        System.out.println(&quot;修改用户信息&quot;);
    }

    @Override
    public void viewNote() { }

    @Override
    public void publishNote() {
        System.out.println(&quot;发布新帖&quot;);
    }

    @Override
    public void modifyNote() {
        System.out.println(&quot;修改发帖内容&quot;);
    }

    @Override
    public void setLevel(int level) { }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;代理主题角色 PermissionProxy（权限代理类）&lt;/p&gt;
&lt;p&gt;PermissionProxy 是代理主题角色，它也实现了抽象主题角色接口，同时在 PermissionProxy 中定义了一个 RealPermission 对象，用于调用 RealPermission 中定义的真实业务方法。通过引入 PermissionProxy 类来对系统的使用权限进行控制，这就是保护代理的用途。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class PermissionProxy implements AbstractPermission {

    private RealPermission permission = new RealPermission();
    private int level = 0;

    @Override
    public void modifyUserInfo() {
        if (0 == level) {
            System.out.println(&quot;对不起，你没有该权限&quot;);
        } else if (1 == level) {
            permission.modifyUserInfo();
        }
    }

    @Override
    public void viewNote() {
        System.out.println(&quot;查看帖子&quot;);
    }

    @Override
    public void publishNote() {
        if (0 == level) {
            System.out.println(&quot;对不起，你没有该权限&quot;);
        } else if (1 == level) {
            permission.publishNote();
        }
    }

    @Override
    public void modifyNote() {
        if (0 == level) {
            System.out.println(&quot;对不起，你没有该权限&quot;);
        } else if (1 == level) {
            permission.modifyNote();
        }
    }

    @Override
    public void setLevel(int level) {
        this.level = level;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;客户端测试类 Client&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {

    public static void main(String[] args) {

        AbstractPermission permission = new PermissionProxy();

        permission.modifyUserInfo();
        permission.viewNote();
        permission.publishNote();
        permission.modifyNote();

        System.out.println(&quot;-------------------------&quot;);

        permission.setLevel(1);
        permission.modifyUserInfo();
        permission.viewNote();
        permission.publishNote();
        permission.modifyNote();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;运行结果&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200514223749530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5faGFuZHNvbWU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代理类可以对用户访问权限进行控制，因此有些用户无权调用真实业务类的某些方法，当用户权限改变时，则可以访问这些方法。如果需要增加并使用新的代理类，首先将新增代理类作为抽象主题角色的子类，实现在抽象主题中声明的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;&lt;h2 id=&quot;模式优缺点&quot;&gt;模式优缺点&lt;/h2&gt;
&lt;p&gt;代理模式优点如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代理模式能协调调用者和被调用者，在一定程度上降低了系统的耦合度&lt;/li&gt;
&lt;li&gt;远程代理使客户端能访问在远程机器上的对象&lt;/li&gt;
&lt;li&gt;虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高速度&lt;/li&gt;
&lt;li&gt;保护代理可以控制对真实对象的使用权限&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代理模式缺点如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于在客户端和真实主题之间增加了代理对象，因此可能会造成请求的处理速度变慢。&lt;/li&gt;
&lt;li&gt;有些代理模式的实现十分复杂。&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;&lt;h2 id=&quot;模式使用环境&quot;&gt;模式使用环境&lt;/h2&gt;
&lt;p&gt;根据代理模式的使用目的，常见的代理模式有以下几个类型。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;远程（Remote）代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机，也可以是另一台主机。&lt;/li&gt;
&lt;li&gt;虚拟（Virtual）代理：如果需要创建一个资源消耗较大的对象，可以先创建一个消耗较小的对象来表示，真实对象只在需要时才会被真正创建。&lt;/li&gt;
&lt;li&gt;Copy-on-Write代理：它是虚拟代理的一种，把复杂操作延迟到只在客户端真正需要时才执行。&lt;/li&gt;
&lt;li&gt;保护（Protect or Access）代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。&lt;/li&gt;
&lt;li&gt;缓冲（Cache）代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户可以共享这些结果。&lt;/li&gt;
&lt;li&gt;防火墙（FireWall）代理：保护目标不让恶意用户接近&lt;/li&gt;
&lt;li&gt;同步化（Synchronization）代理：使几个用户能同时使用一个对象而没有冲突&lt;/li&gt;
&lt;li&gt;智能（Smart Reference）引用：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;&lt;h2 id=&quot;静态代理&quot;&gt;静态代理&lt;/h2&gt;
&lt;p&gt;所谓静态代理，就是由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的 .class 文件就已经生成。简单来说，上述的实例就属于静态代理，PermissionProxy 代理类是我们定义好的，在程序运行之前就已经编译完成。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;动态代理&quot;&gt;动态代理&lt;/h2&gt;
&lt;p&gt;传统的代理模式中，客户端通过 ProxySubject 调用 RealSubject 类的方法，同时还在代理类中封装了其他方法，可以处理一些其他问题。如果按照这种方法使用代理模式，那么真实主题角色必须是是事先已经存在的，并将其作为代理对象的内部成员属性。如果一个真实主题角色必须对应一个代理主题角色，这将导致系统中的类的个数急剧增加，因此需要想办法减少系统中类的个数。&lt;/p&gt;
&lt;p&gt;Java 自带的基于接口的动态代理（即只能实现接口的代理）能在运行时根据我们在 Java 代码中的指示动态生成的代理类，其实现相关类位于 java.lang.reflect 包，运行时动态地对某些东西作代理，主要涉及两个类&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;10.5&quot;&gt;
&lt;p&gt;InvocationHandler 接口&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;InvocationHandler is the interface implemented by the invocation handler of a proxy instance.&lt;br/&gt;Each proxy instance has an associated invocation handler.When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;InvocationHandler 是由代理实例的调用处理程序实现的接口。每个代理实例都有一个关联的调用处理程序。InvocationHandler 接口中定义了 invoke 方法，当代理实例调用某个方法时，该方法的调用将被编码并调度到其调用处理程序的 invoke 方法处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 *      处理代理实例上的方法调用并返回结果
 *      proxy 表示动态代理类
 *      method 表示需要代理的方法
 *      args 表示代理方法的参数数组
 */
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;Proxy 类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 *      该类提供了用于为接口创建代理实例的静态方法
 */
public class Proxy implements java.io.Serializable {
    ...
     /**
      * 根据传入的接口类型返回一个动态创建的代理类实例
      * loader 表示被代理类的类加载器
      * interfaces 表示被代理类实现的接口列表（与真实主题类的接口列表一致）
      * h 表示所指派的调用处理程序类
      */
        public static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h) {
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面通过一个简单实例来学习动态代理，现在有两个真实主题类分别是 RealSubjectA 和 RealSubjectB，它们对于抽象主题类中定义的抽象方法 request() 提供了不同的实现，在不增加新的代理类的情况下，使得客户端通过一个代理类来动态选择所代理的真实主题对象&lt;/p&gt;
&lt;ol readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;抽象主题接口 AbstractSubject&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface AbstractSubject {

    public void request();

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;真实主题类一 RealSubjectA&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RealSubjectA implements AbstractSubject {

    @Override
    public void request() {
        System.out.println(&quot;真实主题类A&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;真实主题类二 RealSubjectB&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RealSubjectB implements AbstractSubject {

    @Override
    public void request() {
        System.out.println(&quot;真实主题类B&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;动态代理类 DynamicProxy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DynamicProxy implements InvocationHandler {

    private Object obj;

    public DynamicProxy() {}

    public DynamicProxy(Object obj) {
        this.obj = obj;
    }

    //  实现 invoke() 方法，调用在真实主题类中定义的方法
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        System.out.println(&quot;调用之前&quot;);
        //  利用反射调用方法，如果方法没有返回值则为 null
        Object result = method.invoke(obj, args);
        System.out.println(&quot;调用之后&quot;);
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;客户端测试类 Client&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {

    public static void main(String[] args) {

        AbstractSubject subject = new RealSubjectA();
        InvocationHandler handler = new DynamicProxy(subject);
        AbstractSubject subjectProxy = (AbstractSubject) Proxy.newProxyInstance(subject.getClass().getClassLoader(),
                subject.getClass().getInterfaces(), handler);
        subjectProxy.request();

        System.out.println(&quot;-----------------------------&quot;);

        subject = new RealSubjectB();
        handler = new DynamicProxy(subject);
        subjectProxy = (AbstractSubject) Proxy.newProxyInstance(subject.getClass().getClassLoader(),
                subject.getClass().getInterfaces(), handler);
        subjectProxy.request();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200514223822589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5faGFuZHNvbWU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;</description>
<pubDate>Thu, 14 May 2020 14:41:00 +0000</pubDate>
<dc:creator>STYeeQan</dc:creator>
<og:description>当直接访问某些对象存在问题时，可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。 模式动机 某些情况下，一个客户不想或不能直接引用一个对象，此时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yee-Q/p/12891869.html</dc:identifier>
</item>
<item>
<title>分布式锁-Redission-Lock锁的使用与原理 - 农夫三拳有点疼~</title>
<link>http://www.cnblogs.com/songjilong/p/12891787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songjilong/p/12891787.html</guid>
<description>&lt;p&gt;添加 Maven 依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.12.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加配置类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class MyRedissonConfig {
    @Bean(destroyMethod = &quot;shutdown&quot;)
    RedissonClient redisson() throws IOException {
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://192.168.56.10:6379&quot;);
        return Redisson.create(config);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本使用代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/hello&quot;)
@ResponseBody
public String hello() {
    //获取Lock锁，设置锁的名称
    RLock lock = redisson.getLock(&quot;my-lock&quot;);
    //开启
    lock.lock();
    try {
        System.out.println(&quot;上锁：&quot; + Thread.currentThread().getId());
        //模拟业务处理20秒
        TimeUnit.SECONDS.sleep(20);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }finally {
        System.out.println(&quot;解锁：&quot; + Thread.currentThread().getId());
        //释放
        lock.unlock();
    }
    return &quot;hello&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;当我们发送 &lt;code&gt;/hello&lt;/code&gt; 请求后等待 20 秒得到响应结果，会在 Redis 中存储锁的信息（如下图所示），期间，其它用户发送 &lt;code&gt;/hello&lt;/code&gt; 请求时会被阻塞，只有前一个请求结束后释放锁，当前请求才会进入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200514203408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考1：如果在业务处理过程中程序突然终止，锁没有得到释放，是否会一直阻塞下去？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过实验，在业务处理的20秒中，将服务手动停止，刷新 Redis 中 my-lock 的信息，发现 TTL 不断的减小，直到失效，发送其它请求能够正常执行，这说明，即使不释放锁，Redis 设置的过期时间到了也会自动删除锁的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//获取当前线程id
long threadId = Thread.currentThread().getId();
//获取此线程的锁
Long ttl = tryAcquire(leaseTime, unit, threadId);
//如果获取不到，则说明锁已经释放了，直接返回
if (ttl == null) {
    return;
}
while (true) {
    ttl = tryAcquire(leaseTime, unit, threadId);
    //判断是否能获取到锁
    if (ttl == null) {
        break;
    }
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;思考2：过期时间是多少？如果我们的业务处理时间超过了过期时间，岂不是还没处理完就把锁的信息给删了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正常启动服务访问 &lt;code&gt;/hello&lt;/code&gt;，刷新 my-lock 的信息，我们发现，TTL 每次减少到 20 就再次变为 30，直到业务处理完成，my-lock 被删除。查找相关源代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;while (true) {
    //尝试获取锁
    ttl = tryAcquire(leaseTime, unit, threadId);
    //如果获取不到，说明执行该线程执行结束，就终止循环
    if (ttl == null) {
        break;
    }

    //如果获取到了就继续循环
    if (ttl &amp;gt;= 0) {
        try {
            future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            if (interruptibly) {
                throw e;
            }
            future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
        }
    } else {
        if (interruptibly) {
            future.getNow().getLatch().acquire();
        } else {
            future.getNow().getLatch().acquireUninterruptibly();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续深入源码可以看到，如果不指定锁的时间，就默认为 30 秒，它有一个好听的名字：看门狗&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private long lockWatchdogTimeout = 30 * 1000;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要占领锁，就会启动一个定时任务：每隔一段时间重新给锁设置过期时间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected RFuture&amp;lt;Boolean&amp;gt; renewExpirationAsync(long threadId) {
    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; +
                &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                &quot;return 1; &quot; +
            &quot;end; &quot; +
            &quot;return 0;&quot;,
        Collections.&amp;lt;Object&amp;gt;singletonList(getName()), 
        internalLockLeaseTime, getLockName(threadId));
    //internalLockLeaseTime就是看门狗的时间
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每隔多长久刷新一下呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//获取看门狗的时间，赋值给自己
this.internalLockLeaseTime = xxx.getLockWatchdogTimeout();
public long getLockWatchdogTimeout() {
    return lockWatchdogTimeout;
}

Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {
    @Override
    public void run(Timeout timeout) throws Exception {
        ...
    }
    //使用的时候除3，也就是10秒刷新一次
}, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;思考三：如何自定义过期时间？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;lock() 方法还有一个重载方法，可以传入过期时间和单位&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;void lock(long leaseTime, TimeUnit unit);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将之前的代码修改，设置为 15 秒，重启服务再测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;lock.lock(15, TimeUnit.SECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 &lt;code&gt;/hello&lt;/code&gt;，刷新 Redis 中 my-lock 的信息会发现，TTL 从 15 减到 0，然后锁信息过期，并不会出现之前的 10秒一刷新，查看源码会发现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private &amp;lt;T&amp;gt; RFuture&amp;lt;Long&amp;gt; tryAcquireAsync(long leaseTime, TimeUnit unit, long threadId) {
    //如果传入了过期时间，则直接执行tryLockInnerAsync里面的Lua脚本
    if (leaseTime != -1) {
        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
    }
    //没有传入过期时间，执行下面的逻辑
    RFuture&amp;lt;Long&amp;gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
    ttlRemainingFuture.onComplete((ttlRemaining, e) -&amp;gt; {
        //有异常，直接返回
        if (e != null) {
            return;
        }
        if (ttlRemaining == null) {
            //刷新过期时间
            scheduleExpirationRenewal(threadId);
        }
    });
    return ttlRemainingFuture;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;1、lock 锁是线程阻塞的&lt;/p&gt;
&lt;p&gt;2、使用 lock 的无参方法，锁的默认时间是 30 秒，并且会每隔 10 秒刷新为 30 秒，只要业务没执行完，就会一直续期，如果执行完成或者突然中止，则不会再续期，达到过期时间就释放锁&lt;/p&gt;
&lt;p&gt;3、使用 lock 的有参方法指定时间，到达指定时间会自动解锁，因此设置的时间必须大于业务执行时间，否则，业务没执行完，锁就会被释放&lt;/p&gt;
&lt;p&gt;4、推荐使用指定时间的方式，省掉了续期操作，但需要合理设置过期时间，不能过早的使锁释放&lt;/p&gt;
</description>
<pubDate>Thu, 14 May 2020 14:25:00 +0000</pubDate>
<dc:creator>农夫三拳有点疼~</dc:creator>
<og:description>环境准备 添加 Maven 依赖 添加配置类 基本使用代码如下： 分析 当我们发送 请求后等待 20 秒得到响应结果，会在 Redis 中存储锁的信息（如下图所示），期间，其它用户发送 请求时会被阻塞</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songjilong/p/12891787.html</dc:identifier>
</item>
<item>
<title>计算机网络——如何保证网络传输的安全性 - 特务依昂</title>
<link>http://www.cnblogs.com/tuyang1129/p/12891346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tuyang1129/p/12891346.html</guid>
<description>&lt;p&gt;  前几天在面试时，被问到了如何保证网络数据传输的安全性的问题，当时对这一块没怎么研究过，所以当时并没有回答出来。所以，今天花了点时间，研究了一下这方面的内容。这篇博客就来简单说一说保证网络传输安全性的一些方式。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;21-安全传输需要解决的问题&quot;&gt;2.1 安全传输需要解决的问题&lt;/h2&gt;
&lt;p&gt;  先有问题，才有解决方案，所以我们先来讨论一下，网络传输中，需要解决哪些问题，才能保证安全。需要解决的问题大致有如下三个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;发送方鉴别&lt;/strong&gt;：确保接收到的数据，确实是由我们认为的那个人（或主机）发送来的，而不是其他人以虚假身份发送的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报文完整性&lt;/strong&gt;：确保我们接收到的报文就是发送方发送的初始报文，而没有被第三方进行篡改；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据机密性&lt;/strong&gt;：确保报文即使被其他人截获，也无法读出其中的信息，也就是要对数据加密；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  如果上面三个问题都得到了解决，那我们基本上就可以保证数据传输是安全的。下面我们就针对上面三个问题，来谈一谈解决方案。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;22-非对称加密与对称加密&quot;&gt;2.2 非对称加密与对称加密&lt;/h2&gt;
&lt;p&gt;  在网络安全中，有两个非常重要的概念，就是&lt;strong&gt;对称加密&lt;/strong&gt;和&lt;strong&gt;非对称加密&lt;/strong&gt;，后面要谈的所有方案，都离不开这两种机制。所以，在了解具体解决问题的方案前，我们先来了解这两个概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（一）对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  对称加密的原理很简单，就是数据的发送方和接收方共享一个加密数据的密钥，使用这个密钥加密的数据，可以使用这个密钥进行解密。而这个密钥是隐私的，只有数据的发送方和接收方知道，这也就意味着，其他人如果截获了数据，由于这个数据使用了密钥加密，而它没有这个密钥，所有无法解析出原始数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（二）非对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  非对称加密系统中，参与加密解密的共有两个——&lt;strong&gt;公钥&lt;/strong&gt;和&lt;strong&gt;私钥&lt;/strong&gt;，使用私钥加密的数据，只能用公钥解密，而使用公钥加密的数据，只能用私钥解出。在非对称加密系统中，每一台主机都有自己的私钥和公钥，私钥只有自己知道，而公钥是公开的，可以让所有主机知道。发送方在发送数据时，使用接收方的公钥进行加密，而接收方使用自己的私钥进行解密，即可完成隐私的数据传输。如果数据被其它人截获，但是因为它没有接收方的私钥，所以无法解析出数据。&lt;/p&gt;
&lt;p&gt;  非对称加密能够工作的一个前提是，必须确保发送方拿到的公钥，就是接收方的公钥，而不是其他人发送来的假公钥，如果公钥是假的，那么这个机制也就失去了意义。在实际应用中，解决这个问题的方式就是，每一台主机的公钥和私钥，都是由官方机构所分配的，这些机构被称为&lt;strong&gt;认证中心&lt;/strong&gt;（&lt;code&gt;CA&lt;/code&gt;）。&lt;code&gt;CA&lt;/code&gt;在分配公钥私钥时，会严格地验证身份，然后对身份进行绑定，而我们在获取公钥时，通过&lt;code&gt;CA&lt;/code&gt;获取，即可保证获取到的公钥就是接收方的。&lt;/p&gt;
&lt;p&gt;  需要注意的一点是，&lt;strong&gt;非对称加密的效率一般比较低，而对称加密的效率相对较高&lt;/strong&gt;。下面，开始正式讨论解决上面三个问题的方案。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;23-解决数据机密性&quot;&gt;2.3 解决数据机密性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（一）非对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发送方获取接受方的公钥，使用公钥对需要发送的数据进行加密，然后发送；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接受方接收到后，使用自己的私钥进行解密，解析出数据；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;总结：因为只有接受方知道自己的私钥，所以只有接受方能读出数据。但是，非对称加密的执行效率比较低，所以每一次数据传输都使用非对称加密，&lt;strong&gt;响应速度将会比较慢&lt;/strong&gt;；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（二）非对称加密 + 对称加密（多次传输）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  为了解决非对称加密效率较低的问题，我们可以使用对称加密，但是同步对称加密的密钥，却需要依赖于非对称加密：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发送方随机生成一个密钥，然后获取接受方的公钥，使用公钥加密这个密钥，发送给接受方；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接收方接收到加密的密钥后，使用自己的私钥解析出密钥，此时双方就完成了密钥同步；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;之后双方发送的所有数据，都可以使用这个密钥进行加密解密；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;总结：由于私钥只有接收方自己知道，所以这个密钥不会被其他人截获；同时使用对称加密的速度，要高于非对称加密，所以解决了上一个方案效率不高的问题；&lt;strong&gt;需要注意，一般密钥都比较短，所以使用非对称加密对密钥进行加密，一般比直接加密数据更快，而且只需要进行一次，所以速度能够显著提高&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  &lt;code&gt;HTTPS&lt;/code&gt;依赖于&lt;code&gt;SSL&lt;/code&gt;保证数据传输的安全性，而&lt;code&gt;SSL&lt;/code&gt;就是使用类似机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（三）非对称加密 + 对称加密（单次传输）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  如果发送方只是需要向接收方发送一次数据，那先进行一次密钥同步可能有些浪费时间，可以使用如下方案解决：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发送方随机生成一个密钥，然后使用这个密钥对数据进行加密；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发送方使用接收方的公钥对数据密钥进行加密，然后将加密的数据和加密的密钥发送；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接收方首先使用自己的私钥解析出密钥，然后使用解析出的密钥将数据解析出来；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;总结：此方案适合于进行单次数据发送，因为不需要进行密钥的同步，而是将密钥与数据一同发送；同时，这个密钥使用了接收方的公钥加密，所以这个密钥只有接收方自己能解析出来，而其他人解析不出密钥，自然无法解析数据；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;h2 id=&quot;24-同时解决发送方鉴别和报文完整性&quot;&gt;2.4 同时解决发送方鉴别和报文完整性&lt;/h2&gt;
&lt;p&gt;  下面我们来说说解决发送方鉴别和报文完整性的方案。有一个经典的方案能够同时解决这两个问题，其过程如下：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发送方使用一个&lt;code&gt;hash&lt;/code&gt;算法（如&lt;code&gt;MD5&lt;/code&gt;、&lt;code&gt;SHA-1&lt;/code&gt;），计算需要发送的数据的&lt;code&gt;hash&lt;/code&gt;值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用自己的私钥，对计算出的&lt;code&gt;hash&lt;/code&gt;值进行加密；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将原始数据和加密后的&lt;code&gt;hash&lt;/code&gt;值发送到接收方；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接收方使用发送方的公钥解析出加密后的&lt;code&gt;hash&lt;/code&gt;值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用与发送方相同的&lt;code&gt;hash&lt;/code&gt;算法，计算接收到的数据的&lt;code&gt;hash&lt;/code&gt;值，与解析出的&lt;code&gt;hash&lt;/code&gt;值进行比较；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;若这两个&lt;code&gt;hash&lt;/code&gt;值一致，表示这个数据并没有被篡改；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;1、首先，hash值是用发送方的私钥加密，私钥只有发送方自己知道，如果接收方能够使用发送方的公钥解密，那就说明这个数据就是预期中的发送方发的，不可能是其他人发的，于是完成了发送方鉴别；&lt;/p&gt;
&lt;p&gt;2、接收方使用同样的hash算法，计算原始数据的hash值，如果这个hash值与解密后的hash值一致，则就能保证这个数据没有被篡改；&lt;/p&gt;
&lt;p&gt;上面两步中，但凡有一步出现了错误，就认为这是一个脏数据；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  这个方案被称为&lt;strong&gt;数字签名&lt;/strong&gt;。为什么是计算出&lt;code&gt;hash&lt;/code&gt;值，对&lt;code&gt;hash&lt;/code&gt;值加密，而不是直接使用私钥对数据加密？这是因为&lt;code&gt;hash&lt;/code&gt;值比较小，加密解密比较快。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;25-同时解决三个问题的方案&quot;&gt;2.5 同时解决三个问题的方案&lt;/h2&gt;
&lt;p&gt;  上面提到的三个问题中，但凡有一个没有解决，数据传输都是不可靠的，这里我们就通过上面提到的几个办法，来同时解决三个问题。办法很简单，直接将上面解决方案进行整合即可：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先，我们使用&lt;code&gt;2.4&lt;/code&gt;中所提出的办法，对数据进行处理，也就是计算&lt;code&gt;hash&lt;/code&gt;，然后使用自己的私钥加密&lt;code&gt;hash&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后，将第一步计算出的&lt;code&gt;hash&lt;/code&gt;与原始数据组合，使用&lt;code&gt;2.3&lt;/code&gt;中提出的非对称加密 + 对称加密的方式，进行加密，加密之后再进行发送，保证数据的隐秘性；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接收方接收到数据后，使用&lt;code&gt;2.3&lt;/code&gt;中的过程对数据解密，得到原始数据和加密后的&lt;code&gt;hash&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;2.4&lt;/code&gt;中的方式完成发送方鉴别以及数据完整性校验；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;总结：上面的方式非常简单，就是将我们之前提过的加密，以及2.4中的方案组合，以此来同时解决三个问题。这是一个非常常用的方案，比如安全的邮件传输协议的实现就使用了类似方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;h2 id=&quot;26-解决发送方鉴别的其他方案&quot;&gt;2.6 解决发送方鉴别的其他方案&lt;/h2&gt;
&lt;p&gt;  假设接收方和发送方有一个共享的密钥，则可以使用以下方式进行身份鉴别：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发送方向接收方发送自己的身份，比如发送一个“我是xxx”；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接收方为了验证不是其他人发送的虚假数据，向发送方发送一个随机数，这个随机数短时间内不会重复；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发送方使用它们共享的密钥，对这个随机数加密后发回接收方；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接收方接收后，使用密钥解密，如果确实是自己之前发送出去的随机数，即可确认对方身份；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  这里存在的问题是如何让接收方和发送方有一个共享密钥，其实就可以通过&lt;code&gt;2.3&lt;/code&gt;节中第二个方案提到的，使用非对称加密的方式同步密钥。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;1、由于密钥只有发送方和接收方知晓，所以如果发送方能够将加密后的随机数发回，即可确认它的身份；&lt;/p&gt;
&lt;p&gt;2、为什么不直接使用加密后的身份信息发送，而是使用随机数？因为如果这个加密后的身份数据被截获，其他人不需要进行解密，只需要向接收方发送这个加密后的身份，即可伪造自己的身份；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;h2 id=&quot;27-解决数据完整性的其他方案&quot;&gt;2.7 解决数据完整性的其他方案&lt;/h2&gt;
&lt;p&gt;  假设发送方和接收方有一个共享的密钥，则可以使用如下步骤保证数据完整性：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发送方将原始数据与密钥拼接，然后计算拼接后的&lt;code&gt;hash&lt;/code&gt;值，将这个&lt;code&gt;hash&lt;/code&gt;值与原始数据一同发送；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接收方接收到后，同样将原始数据和密钥拼接，并计算&lt;code&gt;hash&lt;/code&gt;值，然后与发来的&lt;code&gt;hash&lt;/code&gt;值比较；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;若&lt;code&gt;hash&lt;/code&gt;值一致，可以保证这个数据没有修改，否则就是被篡改的数据；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;总结：由于拼接进原始数据的密钥只有传输双方知道，这个hash值只有它们双方能计算出来，所以如果hash值不一致，即可认为数据是有问题的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  这个方案叫&lt;strong&gt;报文鉴别码&lt;/strong&gt;，和前面提过的数字签名有些类似，但是不同的是，这个方案中，并不需要对发送的数据进行加密，只是计算&lt;code&gt;hash&lt;/code&gt;作为鉴别码，只要保证密钥不被窃取，即可保证数据的完整性。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;28-如何防止发送方自己发送虚假数据&quot;&gt;2.8 如何防止发送方自己发送虚假数据&lt;/h2&gt;
&lt;p&gt;  需要注意的一点是，我们上面所提出的方案，都是针对第三方侵入的解决方法，也就是防止除发送方和接收方外，有其他人对数据传输做手脚。但是，如果发送方自己篡改数据，或伪造数据，然后发送，这应该怎么解决呢？接收方如何能够识别出接收到的数据就是原始数据，而不是发送方自己篡改或发送的虚假数据呢？这是我最近一直在想的问题。&lt;/p&gt;
&lt;p&gt;  在这种情况下，我们需要考虑的是，发送数据的用户可以做到什么程度？由于发送数据的设备就在发送者手上，是不是意味着数据发送过程中的密钥等信息，用户是可以通过一些手段看到的？如果是可以，那上面所说的机制应该就没法保证安全性了。但是，本人水平有限，并不清楚有户对于发送到自己设备上的数据，可以窃取到什么程度。希望了解这个问题的人能够为我解答。&lt;/p&gt;
&lt;p&gt;  当然，上面的机制可能没办法保证完全可靠，但是也有很大的效果。比如说报文鉴别码就能解决用户自己篡改自己的数据这个问题。如果用户没有获取到密钥，则它自然无法发送虚假数据，因为没有密钥就没有办法计算出虚假数据的&lt;code&gt;hash&lt;/code&gt;。虽然用户可能可以通过一些手段，获取到这个密钥，但是过程是应该是非常复杂的，这就对窃取的技术要求非常高，所以在大部分情况下可以保证数据不被篡改。&lt;/p&gt;
&lt;p&gt;  说实话，对于用户自己发送虚假数据这个问题，由于我知识水平不足，一直无法想清楚，网上也没有找到相关的资料，所以上面的描述都是基于我目前的理解。如果有了解这个问题相关知识，以及解决方案的，麻烦告知。&lt;/p&gt;
&lt;p&gt;  以上就对数据的安全传输方案做了一个大致的介绍，归根到底，就是基于数据隐秘性，报文完整性以及发送方鉴别这三个问题，这三者缺一不可，只有全部解决，才能保证传输的可靠。&lt;/p&gt;
&lt;p&gt;  希望上面的内容对需要了解这一方面的人有所帮助，若存在错误或不足，也欢迎指正。&lt;/p&gt;
&lt;br/&gt;&lt;ul&gt;&lt;li&gt;《计算机网络——自顶向下方法（原书第七版）》&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 14 May 2020 12:58:00 +0000</pubDate>
<dc:creator>特务依昂</dc:creator>
<og:description>一、前言 前几天在面试时，被问到了如何保证网络数据传输的安全性的问题，当时对这一块没怎么研究过，所以当时并没有回答出来。所以，今天花了点时间，研究了一下这方面的内容。这篇博客就来简单说一说保证网络传输</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tuyang1129/p/12891346.html</dc:identifier>
</item>
<item>
<title>从卷积拆分和分组的角度看CNN模型的演化 - shine-lee</title>
<link>http://www.cnblogs.com/shine-lee/p/12891278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shine-lee/p/12891278.html</guid>
<description>&lt;p&gt;博客：&lt;a href=&quot;https://www.cnblogs.com/shine-lee/&quot;&gt;博客园&lt;/a&gt; | &lt;a href=&quot;https://blog.csdn.net/blogshinelee&quot;&gt;CSDN&lt;/a&gt; | &lt;a href=&quot;https://blog.shinelee.me/&quot;&gt;blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如题，这篇文章将尝试从卷积拆分的角度看一看各种经典CNN backbone网络module是如何演进的，为了视角的统一，仅分析单条路径上的卷积形式。&lt;/p&gt;

&lt;p&gt;方便起见，对常规卷积操作，做如下定义，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt;：输入尺寸，长&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt; 宽&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt; ，令长宽相同，即&lt;span class=&quot;math inline&quot;&gt;\(I = H = W\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;：输入channel数，可以看成是tensor的高&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;：卷积核尺寸&lt;span class=&quot;math inline&quot;&gt;\(K \times K\)&lt;/span&gt;，channel数与输入channel数相同，为&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;：卷积核个数&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;：卷积得到的feature map尺寸&lt;span class=&quot;math inline&quot;&gt;\(F \times F\)&lt;/span&gt;，channel数与卷积核个数相同，为&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，输入为&lt;span class=&quot;math inline&quot;&gt;\(M \times I \times I\)&lt;/span&gt;的tensor，卷积核为&lt;span class=&quot;math inline&quot;&gt;\(N \times M \times K \times K\)&lt;/span&gt;的tensor，feature map为&lt;span class=&quot;math inline&quot;&gt;\(N \times F \times F\)&lt;/span&gt;的tensor，所以常规卷积的计算量为&lt;/p&gt;
&lt;p&gt;\[FLOPS = K \times K \times M \times N \times F \times F \]&lt;/p&gt;
&lt;p&gt;特别地，如果仅考虑SAME padding且&lt;span class=&quot;math inline&quot;&gt;\(stride = 1\)&lt;/span&gt;的情况，则&lt;span class=&quot;math inline&quot;&gt;\(F = I\)&lt;/span&gt;，则计算量等价为&lt;/p&gt;
&lt;p&gt;\[FLOPS = K \times K \times M \times N \times I \times I \]&lt;/p&gt;
&lt;p&gt;可以看成是&lt;span class=&quot;math inline&quot;&gt;\((K \times K \times M) \times (N \times I \times I)\)&lt;/span&gt;，前一个括号为卷积中一次内积运算的计算量，后一个括号为需要多少次内积运算。&lt;/p&gt;
&lt;p&gt;参数量为&lt;/p&gt;
&lt;p&gt;\[\#Params = N \times M \times K \times K \]&lt;/p&gt;

&lt;p&gt;总览SqueezeNet、MobileNet V1 V2、ShuffleNet等各种轻量化网络，可以看成对卷积核&lt;span class=&quot;math inline&quot;&gt;\(M \times K \times K\)&lt;/span&gt; 进行了各种拆分或分组（同时引入激活函数），这些拆分和分组通常会减少参数量和计算量，这就为进一步增加卷积核数量&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;让出了空间，同时这种结构上的变化也是一种正则，通过上述变化来获得性能和计算量之间的平衡。&lt;/p&gt;
&lt;p&gt;这些变化，从整体上看，相当于对原始&lt;span class=&quot;math inline&quot;&gt;\(FLOPS = K \times K \times M \times N \times I \times I\)&lt;/span&gt;做了各种变换。&lt;/p&gt;
&lt;p&gt;下面就从这个视角进行一下疏理，简洁起见，只列出其中发生改变的因子项，&lt;/p&gt;
&lt;ul readability=&quot;28&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Group Convolution（AlexNet）&lt;/strong&gt;，对输入进行分组，卷积核数量不变，但channel数减少，相当于&lt;/p&gt;
&lt;p&gt;\[M \rightarrow \frac{M}{G} \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/01/08/FLPc1x.png&quot; alt=&quot;Convolution VS Group Convolution&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;大卷积核替换为多个堆叠的小核（VGG）&lt;/strong&gt;，比如&lt;span class=&quot;math inline&quot;&gt;\(5\times 5\)&lt;/span&gt;替换为2个&lt;span class=&quot;math inline&quot;&gt;\(3\times 3\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(7\times 7\)&lt;/span&gt;替换为3个&lt;span class=&quot;math inline&quot;&gt;\(3\times 3\)&lt;/span&gt;，保持感受野不变的同时，减少参数量和计算量，相当于把 大数乘积 变成 小数乘积之和，&lt;/p&gt;
&lt;p&gt;\[(K \times K) \rightarrow (k \times k + \dots + k \times k) \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/14/YDA7Mq.png&quot; alt=&quot;https://discuss.pytorch.org/t/dynamic-structure-of-cnn/45870/2&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Factorized Convolution（Inception V2）&lt;/strong&gt;，二维卷积变为行列分别卷积，先行卷积再列卷积，&lt;/p&gt;
&lt;p&gt;\[(K \times K) \rightarrow (K \times 1 + 1 \times K) \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/25/8jioCt.png&quot; alt=&quot;source: http://arxiv.org/abs/1512.00567&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;Fire module（SqueezeNet）&lt;/strong&gt;，pointwise+ReLU+(pointwise + 3x3 conv)+ReLU，pointwise降维，同时将一定比例的&lt;span class=&quot;math inline&quot;&gt;\(3\times 3\)&lt;/span&gt;卷积替换为为&lt;span class=&quot;math inline&quot;&gt;\(1 \times 1\)&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;\[(K \times K \times M \times N) \rightarrow (M \times \frac{N}{t} + \frac{N}{t} \times (1-p)N + K \times K \times \frac{N}{t} \times pN) \\ K = 3 \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/14/YDE40K.png&quot; alt=&quot;https://arxiv.org/abs/1602.07360&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;Bottleneck（ResNet）&lt;/strong&gt;，&lt;strong&gt;pointwise+BN ReLU+3x3 conv+BN ReLU+pointwise&lt;/strong&gt;，类似于对channel维做SVD，&lt;/p&gt;
&lt;p&gt;\[(K \times K \times M \times N) \rightarrow (M \times \frac{N}{t} + K \times K \times \frac{N}{t} \times \frac{N}{t} + \frac{N}{t} \times N) \\ t = 4 \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/21/3K34c8.png&quot; alt=&quot;https://arxiv.org/abs/1512.03385&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;ResNeXt Block（ResNeXt）&lt;/strong&gt;，相当于引入了group &lt;span class=&quot;math inline&quot;&gt;\(3\times 3\)&lt;/span&gt; convolution的bottleneck，&lt;/p&gt;
&lt;p&gt;\[(K \times K \times M \times N) \rightarrow (M \times \frac{N}{t} + K \times K \times \frac{N}{tG} \times \frac{N}{t} + \frac{N}{t} \times N) \\t = 2, \ G = 32 \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/14/YDZxJg.png&quot; alt=&quot;https://arxiv.org/abs/1611.05431&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Depthwise Separable Convolution（MobileNet V1）&lt;/strong&gt;，&lt;strong&gt;depthwise +BN ReLU + pointwise + BN ReLU&lt;/strong&gt;，相当于将channel维单独分解出去，&lt;/p&gt;
&lt;p&gt;\[(K \times K \times N) \rightarrow (K \times K + N) \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/14/YDmdCF.png&quot; alt=&quot;https://mc.ai/review-xception-with-depthwise-separable-convolution-better-than-inception-v3-image/&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Separable Convolution（Xception）&lt;/strong&gt;，&lt;strong&gt;pointwise + depthwise + BN ReLU&lt;/strong&gt;，也相当于将channel维分解出去，但前后顺序不同（但因为是连续堆叠，其实跟基本Depthwise Separable Convolution等价），同时移除了两者间的ReLU，&lt;/p&gt;
&lt;p&gt;\[(K \times K \times M) \rightarrow (M + K \times K) \]&lt;/p&gt;
&lt;p&gt;但实际在实现时还是depthwise + pointwise + ReLU。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/14/YDmf8e.png&quot; alt=&quot;https://mc.ai/review-xception-with-depthwise-separable-convolution-better-than-inception-v3-image/&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;pointwise group convolution and channel shuffle（ShuffleNet）&lt;/strong&gt;，&lt;strong&gt;group pointwise+BN ReLU+Channel Shuffle+depthwise+BN+group pointwise+BN&lt;/strong&gt;，相当于bottleneck中2个pointwise引入相同的group，同时&lt;span class=&quot;math inline&quot;&gt;\(3\times 3\)&lt;/span&gt; conv变成depthwise，也就是说3个卷积层都group了，这会阻碍不同channel间（分组间）的信息交流，所以在第一个group pointwise后加入了channel shuffle，即&lt;/p&gt;
&lt;p&gt;\[(K \times K \times M \times N) \rightarrow (\frac{M}{G} \times \frac{N}{t} + channel \ shuffle +K \times K \times \frac{N}{t} + \frac{N}{tG} \times N) \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/14/YDuvBn.png&quot; alt=&quot;https://arxiv.org/abs/1707.01083&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;Inverted Linear Bottleneck（MobileNet V2）&lt;/strong&gt;，bottleneck是先通过pointwise降维、再卷积、再升维，Inverted bottleneck是先升维、再卷积、再降维，&lt;strong&gt;pointwise+BN ReLU6+depthwise+BN ReLU6+pointwise+BN&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;\[(K \times K \times M \times N) \rightarrow (M \times tM + K \times K \times tM + tM \times N) \\t = 6 \]&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/14/YD1DJ0.png&quot; alt=&quot;https://arxiv.org/abs/1801.04381&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后小结一下，早期的CNN由一个个常规卷积层堆叠而成，而后，开始模块化，由一个个 module构成，module的演化，可以看成是不停地在常规卷积的计算量&lt;span class=&quot;math inline&quot;&gt;\(FLOPS = K \times K \times M \times N \times I \times I\)&lt;/span&gt;上做文章。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;拆分&lt;/strong&gt;：卷积核是个3 D 的tensor，可以在不同维度上进行拆分，行列可拆分，高也可拆分，还可以拆分成多段串联（类似SVD）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分组&lt;/strong&gt;：如果多个卷积核放在一起，可以构成4D的tensor，增加的这一数量维上可以分组group。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同拆分和分组的方式排列组合就构成了各种各样的module。&lt;/p&gt;
</description>
<pubDate>Thu, 14 May 2020 12:42:00 +0000</pubDate>
<dc:creator>shine-lee</dc:creator>
<og:description>博客： &amp;quot;博客园&amp;quot; | &amp;quot;CSDN&amp;quot; | &amp;quot;blog&amp;quot; 写在前面 如题，这篇文章将尝试从卷积拆分的角度看一看各种经典CNN backbone</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shine-lee/p/12891278.html</dc:identifier>
</item>
</channel>
</rss>