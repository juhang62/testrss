<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>免费稳定图床最佳实践：PicGo+GitHub+jsDeliver 极简教程 - 蜗牛互联网</title>
<link>http://www.cnblogs.com/huayonglun/p/14333211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huayonglun/p/14333211.html</guid>
<description>&lt;h2 id=&quot;一、下载-picgo&quot;&gt;一、下载 PicGo&lt;/h2&gt;
&lt;p&gt;PicGo 是啥？顾名思义，它是一个快速上传图片并获取 图片 URL 链接的工具。&lt;/p&gt;
&lt;p&gt;目前支持七牛、腾讯云、阿里云和 GitHub 等图床。该工具代码已在 GitHub 开源，读者可以自行去下载。&lt;/p&gt;
&lt;p&gt;考虑到网络问题，mac 用户后台回复 picgo_dmg 获取高速下载链接。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2021/dmg/292263/1610785259608-1aebc9d6-bf82-468e-ad31-064d165d3ade.dmg&quot; target=&quot;_blank&quot;&gt;📎PicGo-2.2.2.dmg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载完成后，应用列表会有这么一个图标，点击就启动了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huayonglun/cdn_image001/img/1610785381453-176f47e3-f259-4e30-ae59-d98072baaaef-20210116211040479.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PicGo 默认只出现在顶部菜单栏，点击软件图标会显示已上传的图片列表，点击图片会复制链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huayonglun/cdn_image001/img/1610785560440-bee9dd34-45d0-4081-83ce-7150f0b2d2be-20210116211111752.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右击图标，打开详细窗口，我们可以对图床做下配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huayonglun/cdn_image001/img/1610786569046-1e987e9a-98f2-4d8f-b4e7-dd1b3bc6d85b-20210116211140992.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、图床配置&quot;&gt;二、图床配置&lt;/h2&gt;
&lt;p&gt;点击图床设置-GitHub 图床，可以看到需要配置以下信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huayonglun/cdn_image001/img/1610786849004-9b255dad-7ad2-4535-bb7a-52a2106632a8-20210116211226093.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;必选项：&lt;/p&gt;
&lt;ul readability=&quot;3.4423897581792&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;仓库名：用户名/图床仓库名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分支名：主干分支即可，&lt;strong&gt;GitHub 主干分支近期从 master 改为了 main&lt;/strong&gt;，所以这里要添 main，否则上传图片时会异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Token：PicGo 访问你 GitHub 仓库的令牌，需要你在 GitHub 个人设置里生成，下文会提到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;存储路径：仓库下的具体路径。如果名称不存在，PicGo 会在图片上传时自动创建文件夹。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;自定义域名：默认访问 GItHub 资源，但由于 GitHub 访问特别慢，影响图片加载速度。因此接入免费开源的 CDN 加速服务 &lt;strong&gt;jsdelivr。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、github-接入&quot;&gt;三、GitHub 接入&lt;/h2&gt;
&lt;h3 id=&quot;31-创建仓库&quot;&gt;3.1 创建仓库&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huayonglun/cdn_image001/img/1610797667093-64c89cf3-bbd1-411b-987d-e4ae6d13ffd6-20210116211308597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-获取-token&quot;&gt;3.2 获取 Token&lt;/h3&gt;
&lt;p&gt;获取路径：S&lt;strong&gt;ettings&lt;/strong&gt; --&amp;gt; &lt;strong&gt;Developer settings&lt;/strong&gt; --&amp;gt; &lt;strong&gt;Personal access tokens&lt;/strong&gt; --&amp;gt; &lt;strong&gt;New personal access token&lt;/strong&gt; --&amp;gt; &lt;strong&gt;copy token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huayonglun/cdn_image001/img/1610797352744-d515fbd7-3a71-455d-ada3-91490fdf9555-20210116211341369.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huayonglun/cdn_image001/img/1610797621225-6e3202a3-1c0d-4ba6-b0c4-bf4026b95f98-20210116211421765.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将生成的 token 填写到第二节里的配置里，图床即可投入使用。&lt;/p&gt;
&lt;h2 id=&quot;四、图床使用&quot;&gt;四、图床使用&lt;/h2&gt;
&lt;p&gt;将图片拖入详细窗口或者顶部缩略图标里，即可完成图片上传，链接会复制到剪贴板，使用的时候直接粘贴就好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huayonglun/cdn_image001/img/1610797896196-31cf65db-d4f1-447a-a5f6-9bd1fea19c5e-20210116211450510.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种组装的图床工具简单又好用吧，如果对你也有用的话，可以给我&lt;strong&gt;点个赞&lt;/strong&gt;，&lt;strong&gt;点个在看&lt;/strong&gt;，也可以分享给身边朋友，非常感谢读者朋友。&lt;/p&gt;
&lt;p&gt;我是蜗牛，正在互联网上疯狂爬行，下期见。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/woniu666/tech_doc/about_woniu&quot; target=&quot;_blank&quot;&gt;我是蜗牛，Java 后端开发，正在互联网上疯狂爬行，欢迎一起来爬。我们下期再见！微信搜“蜗牛互联网”回复“1024”领取我整理的 Java 程序员必备的学习资料。&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jan 2021 00:16:00 +0000</pubDate>
<dc:creator>蜗牛互联网</dc:creator>
<og:description>一、下载 PicGo PicGo 是啥？顾名思义，它是一个快速上传图片并获取 图片 URL 链接的工具。 目前支持七牛、腾讯云、阿里云和 GitHub 等图床。该工具代码已在 GitHub 开源，读者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huayonglun/p/14333211.html</dc:identifier>
</item>
<item>
<title>jackson学习之二：jackson-core - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14333204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14333204.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章汇总&quot;&gt;系列文章汇总&lt;/h3&gt;
&lt;h3 id=&quot;关于jackson-core&quot;&gt;关于jackson-core&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文主要内容是&lt;span&gt;jackson-core库&lt;/span&gt;，这是个低阶API库，提供流式解析工具&lt;span&gt;JsonParser&lt;/span&gt;，流式生成工具&lt;span&gt;JsonGenerator&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;在日常的序列化和反序列化处理中，最常用的是&lt;span&gt;jackson-annotations&lt;/span&gt;和&lt;span&gt;jackson-databind&lt;/span&gt;，而jackson-core由于它提供的API过于基础，我们大多数情况下是用不上的；&lt;/li&gt;
&lt;li&gt;尽管jackson-databind负责序列化和反序列化处理，但它的底层实现是调用了jackson-core的API；&lt;/li&gt;
&lt;li&gt;本着万丈高楼平地起的原则，本文咱们通过实战了解神秘的jackson-core，了解整个jackson的序列化和反序列化基本原理；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;jacksondemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210127080923850-1727906878.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建父子工程&quot;&gt;创建父子工程&lt;/h3&gt;
&lt;p&gt;创建名为&lt;span&gt;jacksondemo&lt;/span&gt;的maven工程，这是个父子结构的工程，其pom.xml内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jacksondemo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;core&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;beans&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;databind&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.11.0&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.7&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.10&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新增子工程beans&quot;&gt;新增子工程beans&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在父工程jscksondemo下新增名为&lt;span&gt;beans&lt;/span&gt;的子工程，这里面是一些常量和Pojo类；&lt;/li&gt;
&lt;li&gt;增加定义常量的类Constant.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.jacksondemo.beans;

public class Constant {
    /**
     * 该字符串的值是个网络地址，该地址对应的内容是个JSON
     */
    public final static String TEST_JSON_DATA_URL = &quot;https://raw.githubusercontent.com/zq2599/blog_demos/master/files/twitteer_message.json&quot;;
    /**
     * 用来验证反序列化的JSON字符串
     */
    public final static String TEST_JSON_STR = &quot;{\n&quot; +
            &quot;  \&quot;id\&quot;:1125687077,\n&quot; +
            &quot;  \&quot;text\&quot;:\&quot;@stroughtonsmith You need to add a \\\&quot;Favourites\\\&quot; tab to TC/iPhone. Like what TwitterFon did. I can't WAIT for your Twitter App!! :) Any ETA?\&quot;,\n&quot; +
            &quot;  \&quot;fromUserId\&quot;:855523, \n&quot; +
            &quot;  \&quot;toUserId\&quot;:815309,\n&quot; +
            &quot;  \&quot;languageCode\&quot;:\&quot;en\&quot;\n&quot; +
            &quot;}&quot;;
    /**
     * 用来验证序列化的TwitterEntry实例
     */
    public final static TwitterEntry TEST_OBJECT = new TwitterEntry();
    /**
     * 准备好TEST_OBJECT对象的各个参数
     */
    static {
        TEST_OBJECT.setId(123456L);
        TEST_OBJECT.setFromUserId(101);
        TEST_OBJECT.setToUserId(102);
        TEST_OBJECT.setText(&quot;this is a message for serializer test&quot;);
        TEST_OBJECT.setLanguageCode(&quot;zh&quot;);
    }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;增加一个Pojo，对应的是一条推特消息：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.jacksondemo.beans;
/**
 * @Description: 推特消息bean
 * @author: willzhao E-mail: zq2599@gmail.com
 * @date: 2020/7/4 16:24
 */
public class TwitterEntry {
    /**
     * 推特消息id
     */
    long id;
    /**
     * 消息内容
     */
    String text;    /**
     * 消息创建者
     */
    int fromUserId;
    /**
     * 消息接收者
     */
    int toUserId;
    /**
     * 语言类型
     */
    String languageCode;    public long getId() {
        return id;
    }    public void setId(long id) {
        this.id = id;
    }    public String getText() {
        return text;
    }    public void setText(String text) {
        this.text = text;
    }    public int getFromUserId() {
        return fromUserId;
    }    public void setFromUserId(int fromUserId) {
        this.fromUserId = fromUserId;
    }    public int getToUserId() {
        return toUserId;
    }    public void setToUserId(int toUserId) {
        this.toUserId = toUserId;
    }    public String getLanguageCode() {
        return languageCode;
    }    public void setLanguageCode(String languageCode) {
        this.languageCode = languageCode;
    }    public TwitterEntry() {
    }    public String toString() {
        return &quot;[Tweet, id: &quot;+id+&quot;, text='&quot;+text+&quot;', from: &quot;+fromUserId+&quot;, to: &quot;+toUserId+&quot;, lang: &quot;+languageCode+&quot;]&quot;;
    }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;以上就是准备工作了，接下来开始实战jackson-core；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;jsonfactory线程安全吗&quot;&gt;JsonFactory线程安全吗?&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JsonFactory是否是线程安全的，这是编码前要弄清楚的问题，因为&lt;span&gt;JsonParser&lt;/span&gt;和&lt;span&gt;JsonGenerator&lt;/span&gt;的创建都离不开JsonFactory；&lt;/li&gt;
&lt;li&gt;如下图红框所示，jackson官方文档中明确指出&lt;span&gt;JsonFactory是线程安全的&lt;/span&gt;，可以放心的作为全局变量给多线程同时使用：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210127080924250-2034290652.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 官方文档地址：&lt;a href=&quot;http://fasterxml.github.io/jackson-core/javadoc/2.11/&quot; target=&quot;_blank&quot;&gt;http://fasterxml.github.io/jackson-core/javadoc/2.11/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;jackson-core实战&quot;&gt;jackson-core实战&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;新建子工程&lt;span&gt;core&lt;/span&gt;，pom.xml如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;jacksondemo&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;core&amp;lt;/artifactId&amp;gt;
    &amp;lt;name&amp;gt;core&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for jackson core use&amp;lt;/description&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;8&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;8&amp;lt;/target&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;beans&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;新建StreamingDemo类，这里面是调用jackson-core的API进行序列化和反序列化的所有demo，如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.jacksondemo.core;

import com.bolingcavalry.jacksondemo.beans.TwitterEntry;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URL;

/**
 * @Description: jackson低阶方法的使用
 * @author: willzhao E-mail: zq2599@gmail.com
 * @date: 2020/7/4 15:50
 */
public class StreamingDemo {

    private static final Logger logger = LoggerFactory.getLogger(StreamingDemo.class);

    JsonFactory jsonFactory = new JsonFactory();

    /**
     * 该字符串的值是个网络地址，该地址对应的内容是个JSON
     */
    final static String TEST_JSON_DATA_URL = &quot;https://raw.githubusercontent.com/zq2599/blog_demos/master/files/twitteer_message.json&quot;;

    /**
     * 用来验证反序列化的JSON字符串
     */
    final static String TEST_JSON_STR = &quot;{\n&quot; +
            &quot;  \&quot;id\&quot;:1125687077,\n&quot; +
            &quot;  \&quot;text\&quot;:\&quot;@stroughtonsmith You need to add a \\\&quot;Favourites\\\&quot; tab to TC/iPhone. Like what TwitterFon did. I can't WAIT for your Twitter App!! :) Any ETA?\&quot;,\n&quot; +
            &quot;  \&quot;fromUserId\&quot;:855523, \n&quot; +
            &quot;  \&quot;toUserId\&quot;:815309,\n&quot; +
            &quot;  \&quot;languageCode\&quot;:\&quot;en\&quot;\n&quot; +
            &quot;}&quot;;

    /**
     * 用来验证序列化的TwitterEntry实例
     */
    final static TwitterEntry TEST_OBJECT = new TwitterEntry();

    /**
     * 准备好TEST_OBJECT对象的各个参数
     */
    static {
        TEST_OBJECT.setId(123456L);
        TEST_OBJECT.setFromUserId(101);
        TEST_OBJECT.setToUserId(102);
        TEST_OBJECT.setText(&quot;this is a message for serializer test&quot;);
        TEST_OBJECT.setLanguageCode(&quot;zh&quot;);
    }


    /**
     * 反序列化测试(JSON -&amp;gt; Object)，入参是JSON字符串
     * @param json JSON字符串
     * @return
     * @throws IOException
     */
    public TwitterEntry deserializeJSONStr(String json) throws IOException {

        JsonParser jsonParser = jsonFactory.createParser(json);

        if (jsonParser.nextToken() != JsonToken.START_OBJECT) {
            jsonParser.close();
            logger.error(&quot;起始位置没有大括号&quot;);
            throw new IOException(&quot;起始位置没有大括号&quot;);
        }

        TwitterEntry result = new TwitterEntry();

        try {
            // Iterate over object fields:
            while (jsonParser.nextToken() != JsonToken.END_OBJECT) {

                String fieldName = jsonParser.getCurrentName();

                logger.info(&quot;正在解析字段 [{}]&quot;, jsonParser.getCurrentName());

                // 解析下一个
                jsonParser.nextToken();

                switch (fieldName) {
                    case &quot;id&quot;:
                        result.setId(jsonParser.getLongValue());
                        break;
                    case &quot;text&quot;:
                        result.setText(jsonParser.getText());
                        break;
                    case &quot;fromUserId&quot;:
                        result.setFromUserId(jsonParser.getIntValue());
                        break;
                    case &quot;toUserId&quot;:
                        result.setToUserId(jsonParser.getIntValue());
                        break;
                    case &quot;languageCode&quot;:
                        result.setLanguageCode(jsonParser.getText());
                        break;
                    default:
                        logger.error(&quot;未知字段 '&quot; + fieldName + &quot;'&quot;);
                        throw new IOException(&quot;未知字段 '&quot; + fieldName + &quot;'&quot;);
                }
            }
        } catch (IOException e) {
            logger.error(&quot;反序列化出现异常 :&quot;, e);
        } finally {
            jsonParser.close(); // important to close both parser and underlying File reader
        }

        return result;
    }

    /**
     * 反序列化测试(JSON -&amp;gt; Object)，入参是JSON字符串
     * @param url JSON字符串的网络地址
     * @return
     * @throws IOException
     */
    public TwitterEntry deserializeJSONFromUrl(String url) throws IOException {
        // 从网络上取得JSON字符串
        String json = IOUtils.toString(new URL(TEST_JSON_DATA_URL), JsonEncoding.UTF8.name());

        logger.info(&quot;从网络取得JSON数据 :\n{}&quot;, json);

        if(StringUtils.isNotBlank(json)) {
            return deserializeJSONStr(json);
        } else {
            logger.error(&quot;从网络获取JSON数据失败&quot;);
            return null;
        }
    }


    /**
     * 序列化测试(Object -&amp;gt; JSON)
     * @param twitterEntry
     * @return 由对象序列化得到的JSON字符串
     */
    public String serialize(TwitterEntry twitterEntry) throws IOException{
        String rlt = null;
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        JsonGenerator jsonGenerator = jsonFactory.createGenerator(byteArrayOutputStream, JsonEncoding.UTF8);

        try {
            jsonGenerator.useDefaultPrettyPrinter();

            jsonGenerator.writeStartObject();
            jsonGenerator.writeNumberField(&quot;id&quot;, twitterEntry.getId());
            jsonGenerator.writeStringField(&quot;text&quot;, twitterEntry.getText());
            jsonGenerator.writeNumberField(&quot;fromUserId&quot;, twitterEntry.getFromUserId());
            jsonGenerator.writeNumberField(&quot;toUserId&quot;, twitterEntry.getToUserId());
            jsonGenerator.writeStringField(&quot;languageCode&quot;, twitterEntry.getLanguageCode());
            jsonGenerator.writeEndObject();
        } catch (IOException e) {
            logger.error(&quot;序列化出现异常 :&quot;, e);
        } finally {
            jsonGenerator.close();
        }

        // 一定要在
        rlt = byteArrayOutputStream.toString();

        return rlt;
    }


    public static void main(String[] args) throws Exception {

        StreamingDemo streamingDemo = new StreamingDemo();

        // 执行一次对象转JSON操作
        logger.info(&quot;********************执行一次对象转JSON操作********************&quot;);
        String serializeResult = streamingDemo.serialize(TEST_OBJECT);
        logger.info(&quot;序列化结果是JSON字符串 : \n{}\n\n&quot;, serializeResult);

        // 用本地字符串执行一次JSON转对象操作
        logger.info(&quot;********************执行一次本地JSON反序列化操作********************&quot;);
        TwitterEntry deserializeResult = streamingDemo.deserializeJSONStr(TEST_JSON_STR);
        logger.info(&quot;\n本地JSON反序列化结果是个java实例 : \n{}\n\n&quot;, deserializeResult);

        // 用网络地址执行一次JSON转对象操作
        logger.info(&quot;********************执行一次网络JSON反序列化操作********************&quot;);
        deserializeResult = streamingDemo.deserializeJSONFromUrl(TEST_JSON_DATA_URL);
        logger.info(&quot;\n网络JSON反序列化结果是个java实例 : \n{}&quot;, deserializeResult);

        ObjectMapper a;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;上述代码可见JsonParser负责将JSON解析成对象的变量值，核心是循环处理JSON中的所有内容；&lt;/li&gt;
&lt;li&gt;JsonGenerator负责将对象的变量写入JSON的各个属性，这里是开发者自行决定要处理哪些字段；&lt;/li&gt;
&lt;li&gt;不论是JsonParser还是JsonGenerator，大家都可以感觉到工作量很大，需要开发者自己动手实现对象和JSON字段的关系映射，实际应用中不需要咱们这样辛苦的编码，jackson的另外两个库(annonation的databind)已经帮我们完成了大量工作，上述代码只是揭示最基础的jackson执行原理；&lt;/li&gt;
&lt;li&gt;执行StreamingDemo类，得到结果如下，序列化和反序列化都成功了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210127080924885-1826047696.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以上就是jackson-core的基本功能，咱们了解了jackson最底层的工作原理，接下来的文章会继续实践更多操作；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸-1&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 27 Jan 2021 00:09:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14333204.html</dc:identifier>
</item>
<item>
<title>使用bandit对目标python代码进行安全函数扫描 - DechinPhy</title>
<link>http://www.cnblogs.com/dechinphy/p/bandit.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dechinphy/p/bandit.html</guid>
<description>&lt;p&gt;本文介绍了python安全危险函数扫描工具bandit的数种使用方法与技巧，同时也分析了bandit在实际项目中的性能表现，给予了读者是否在python开发项目中引入bandit的启发思考。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;281.72058823529&quot;&gt;

&lt;p&gt;在一些对python开源库代码的安全扫描中，我们有可能需要分析库中所使用到的函数是否会对代码的执行环境造成一些非预期的影响。典型的例如python的沙箱逃逸问题，通过一些python的第三方库可以执行系统shell命令，而这就不在python的沙箱防护范围之内了。关于python的沙箱逃逸问题，这里不作展开，这也是困扰业界多年的一个问题，连python官方也提过python的沙箱是没有完美的防护方案的，这里仅作为一个背景案例使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# subprocess_Popen.py

import subprocess
import uuid

subprocess.Popen('touch ' + str(uuid.uuid1()) +'.txt', shell = True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里演示的功能是使用&lt;code&gt;subprocess&lt;/code&gt;函数库开启一个系统&lt;code&gt;shell&lt;/code&gt;，并执行一个&lt;code&gt;touch&lt;/code&gt;的指令，可以生成一个指定文件名的文件，类似于&lt;code&gt;mkdir&lt;/code&gt;产生一个文件夹。我们可以看到这个文件成功执行后会在当前的目录下生成一个&lt;code&gt;uuid&lt;/code&gt;随机命名的txt文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ python3 subprocess_Popen.py 
[dechin@dechin-manjaro bandit_test]$ ll
总用量 4
-rw-r--r-- 1 dechin dechin   0  1月 26 23:03 b7aa0fc8-5fe7-11eb-b5d3-058313e110e4.txt
-rw-r--r-- 1 dechin dechin 123  1月 26 23:03 subprocess_Popen.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，本次的关注点并不在与这个函数执行了什么功能，而是这个函数中用到了&lt;code&gt;subprocess&lt;/code&gt;这个函数库。按照python的语言特点，当你的系统中如果存在这样的一个模块引用了&lt;code&gt;subprocess&lt;/code&gt;库，那么任何可以调用该功能模块的函数，都可以调用到&lt;code&gt;subprocess&lt;/code&gt;这个函数，以下是另外一个&lt;code&gt;恶意用户的python代码&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# bad.py

from subprocess_Popen import subprocess as subprocess

subprocess.Popen('touch bad.txt', shell = True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该代码的目的是在不直接&lt;code&gt;import subprocess&lt;/code&gt;的条件下，通过前面创建好的&lt;code&gt;subprocess_Popen.py&lt;/code&gt;来进行搭桥调用&lt;code&gt;subprocess&lt;/code&gt;的功能函数。这个脚本的执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ python3 bad.py 
[dechin@dechin-manjaro bandit_test]$ ll
总用量 12
-rw-r--r-- 1 dechin dechin    0  1月 26 23:13 0fda7ede-5fe9-11eb-80a8-ad279ab4e0a6.txt
-rw-r--r-- 1 dechin dechin    0  1月 26 23:03 b7aa0fc8-5fe7-11eb-b5d3-058313e110e4.txt
-rw-r--r-- 1 dechin dechin  113  1月 26 23:13 bad.py
-rw-r--r-- 1 dechin dechin    0  1月 26 23:13 bad.txt
drwxr-xr-x 2 dechin dechin 4096  1月 26 23:13 __pycache__
-rw-r--r-- 1 dechin dechin  123  1月 26 23:03 subprocess_Popen.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个结果意味着，我们成功的使用&lt;code&gt;bad.py&lt;/code&gt;调用了&lt;code&gt;subprocess_Popen.py&lt;/code&gt;中所引用的&lt;code&gt;subprocess&lt;/code&gt;，成功&lt;code&gt;touch&lt;/code&gt;了一个&lt;code&gt;bad.txt&lt;/code&gt;的文件。&lt;/p&gt;
&lt;p&gt;到这里我们的背景案例演示结束，但我们需要重新梳理这些案例中所包含的逻辑：我们原本是希望在自己的系统中不引入python的沙箱逃逸问题，我们会对其他人传递过来的代码进行扫描，如使用下文中将要介绍的&lt;code&gt;bandit&lt;/code&gt;工具来屏蔽&lt;code&gt;subprocess&lt;/code&gt;等&quot;危险函数&quot;。而如果我们在自己写的python库或者引入的第三方python库中存在类似于&lt;code&gt;subprocess&lt;/code&gt;的引用，这就会导致我们的屏蔽失效，用户可以任意的通过这些引用的搭桥直接调用&lt;code&gt;subprocess&lt;/code&gt;的函数功能。因此，在特殊的条件要求下，我们需要对自己的代码进行安全函数扫描，以免为其他人的系统带来不可预期的安全风险。&lt;code&gt;bandit&lt;/code&gt;只是其中的一种安全函数扫描的工具，接下来我们介绍一下其基本安装和使用方法。&lt;/p&gt;

&lt;p&gt;这里直接使用&lt;code&gt;pip&lt;/code&gt;来安装&lt;code&gt;bandit&lt;/code&gt;，有需要的也可以从源码直接安装。关于在&lt;code&gt;pip&lt;/code&gt;的使用中配置国内镜像源的方法，可以参考这篇&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/line-profiler.html&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;中对python安装第三方库的介绍。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ python3 -m pip install bandit
Collecting bandit
  Downloading bandit-1.7.0-py3-none-any.whl (115 kB)
     |████████████████████████████████| 115 kB 101 kB/s 
Requirement already satisfied: PyYAML&amp;gt;=5.3.1 in /home/dechin/anaconda3/lib/python3.8/site-packages (from bandit) (5.3.1)
Collecting GitPython&amp;gt;=1.0.1
  Downloading GitPython-3.1.12-py3-none-any.whl (159 kB)
     |████████████████████████████████| 159 kB 28 kB/s 
Requirement already satisfied: six&amp;gt;=1.10.0 in /home/dechin/anaconda3/lib/python3.8/site-packages (from bandit) (1.15.0)
Collecting stevedore&amp;gt;=1.20.0
  Downloading stevedore-3.3.0-py3-none-any.whl (49 kB)
     |████████████████████████████████| 49 kB 25 kB/s 
Collecting gitdb&amp;lt;5,&amp;gt;=4.0.1
  Downloading gitdb-4.0.5-py3-none-any.whl (63 kB)
     |████████████████████████████████| 63 kB 28 kB/s 
Collecting pbr!=2.1.0,&amp;gt;=2.0.0
  Downloading pbr-5.5.1-py2.py3-none-any.whl (106 kB)
     |████████████████████████████████| 106 kB 26 kB/s 
Collecting smmap&amp;lt;4,&amp;gt;=3.0.1
  Downloading smmap-3.0.5-py2.py3-none-any.whl (25 kB)
Installing collected packages: smmap, gitdb, GitPython, pbr, stevedore, bandit
Successfully installed GitPython-3.1.12 bandit-1.7.0 gitdb-4.0.5 pbr-5.5.1 smmap-3.0.5 stevedore-3.3.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装结束之后，可以通过以下指令验证是否安装成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ bandit -h
usage: bandit [-h] [-r] [-a {file,vuln}] [-n CONTEXT_LINES] [-c CONFIG_FILE] [-p PROFILE] [-t TESTS] [-s SKIPS] [-l] [-i] [-f {csv,custom,html,json,screen,txt,xml,yaml}] [--msg-template MSG_TEMPLATE] [-o [OUTPUT_FILE]] [-v] [-d] [-q]
              [--ignore-nosec] [-x EXCLUDED_PATHS] [-b BASELINE] [--ini INI_PATH] [--exit-zero] [--version]
              [targets [targets ...]]

Bandit - a Python source code security analyzer

positional arguments:
  targets               source file(s) or directory(s) to be tested

optional arguments:
  -h, --help            show this help message and exit
  -r, --recursive       find and process files in subdirectories
  -a {file,vuln}, --aggregate {file,vuln}
                        aggregate output by vulnerability (default) or by filename
  -n CONTEXT_LINES, --number CONTEXT_LINES
                        maximum number of code lines to output for each issue
  -c CONFIG_FILE, --configfile CONFIG_FILE
                        optional config file to use for selecting plugins and overriding defaults
  -p PROFILE, --profile PROFILE
                        profile to use (defaults to executing all tests)
  -t TESTS, --tests TESTS
                        comma-separated list of test IDs to run
  -s SKIPS, --skip SKIPS
                        comma-separated list of test IDs to skip
  -l, --level           report only issues of a given severity level or higher (-l for LOW, -ll for MEDIUM, -lll for HIGH)
  -i, --confidence      report only issues of a given confidence level or higher (-i for LOW, -ii for MEDIUM, -iii for HIGH)
  -f {csv,custom,html,json,screen,txt,xml,yaml}, --format {csv,custom,html,json,screen,txt,xml,yaml}
                        specify output format
  --msg-template MSG_TEMPLATE
                        specify output message template (only usable with --format custom), see CUSTOM FORMAT section for list of available values
  -o [OUTPUT_FILE], --output [OUTPUT_FILE]
                        write report to filename
  -v, --verbose         output extra information like excluded and included files
  -d, --debug           turn on debug mode
  -q, --quiet, --silent
                        only show output in the case of an error
  --ignore-nosec        do not skip lines with # nosec comments
  -x EXCLUDED_PATHS, --exclude EXCLUDED_PATHS
                        comma-separated list of paths (glob patterns supported) to exclude from scan (note that these are in addition to the excluded paths provided in the config file) (default:
                        .svn,CVS,.bzr,.hg,.git,__pycache__,.tox,.eggs,*.egg)
  -b BASELINE, --baseline BASELINE
                        path of a baseline report to compare against (only JSON-formatted files are accepted)
  --ini INI_PATH        path to a .bandit file that supplies command line arguments
  --exit-zero           exit with 0, even with results found
  --version             show program's version number and exit

CUSTOM FORMATTING
-----------------

Available tags:

    {abspath}, {relpath}, {line},  {test_id},
    {severity}, {msg}, {confidence}, {range}

Example usage:

    Default template:
    bandit -r examples/ --format custom --msg-template \
    &quot;{abspath}:{line}: {test_id}[bandit]: {severity}: {msg}&quot;

    Provides same output as:
    bandit -r examples/ --format custom

    Tags can also be formatted in python string.format() style:
    bandit -r examples/ --format custom --msg-template \
    &quot;{relpath:20.20s}: {line:03}: {test_id:^8}: DEFECT: {msg:&amp;gt;20}&quot;

    See python documentation for more information about formatting style:
    https://docs.python.org/3/library/string.html

The following tests were discovered and loaded:
-----------------------------------------------
        B101    assert_used
        B102    exec_used
        B103    set_bad_file_permissions
        B104    hardcoded_bind_all_interfaces
        B105    hardcoded_password_string
        B106    hardcoded_password_funcarg
        B107    hardcoded_password_default
        B108    hardcoded_tmp_directory
        B110    try_except_pass
        B112    try_except_continue
        B201    flask_debug_true
        B301    pickle
        B302    marshal
        B303    md5
        B304    ciphers
        B305    cipher_modes
        B306    mktemp_q
        B307    eval
        B308    mark_safe
        B309    httpsconnection
        B310    urllib_urlopen
        B311    random
        B312    telnetlib
        B313    xml_bad_cElementTree
        B314    xml_bad_ElementTree
        B315    xml_bad_expatreader
        B316    xml_bad_expatbuilder
        B317    xml_bad_sax
        B318    xml_bad_minidom
        B319    xml_bad_pulldom
        B320    xml_bad_etree
        B321    ftplib
        B323    unverified_context
        B324    hashlib_new_insecure_functions
        B325    tempnam
        B401    import_telnetlib
        B402    import_ftplib
        B403    import_pickle
        B404    import_subprocess
        B405    import_xml_etree
        B406    import_xml_sax
        B407    import_xml_expat
        B408    import_xml_minidom
        B409    import_xml_pulldom
        B410    import_lxml
        B411    import_xmlrpclib
        B412    import_httpoxy
        B413    import_pycrypto
        B501    request_with_no_cert_validation
        B502    ssl_with_bad_version
        B503    ssl_with_bad_defaults
        B504    ssl_with_no_version
        B505    weak_cryptographic_key
        B506    yaml_load
        B507    ssh_no_host_key_verification
        B601    paramiko_calls
        B602    subprocess_popen_with_shell_equals_true
        B603    subprocess_without_shell_equals_true
        B604    any_other_function_with_shell_equals_true
        B605    start_process_with_a_shell
        B606    start_process_with_no_shell
        B607    start_process_with_partial_path
        B608    hardcoded_sql_expressions
        B609    linux_commands_wildcard_injection
        B610    django_extra_used
        B611    django_rawsql_used
        B701    jinja2_autoescape_false
        B702    use_of_mako_templates
        B703    django_mark_safe
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个列表中的屏蔽函数我们可以看出所谓的&quot;危险函数&quot;到底都有哪些，比如常用的&lt;code&gt;subprocess&lt;/code&gt;和&lt;code&gt;random&lt;/code&gt;都被包含在内。&lt;code&gt;subprocess&lt;/code&gt;是因为其对shell的调用而被列为&quot;危险函数&quot;，而&lt;code&gt;random&lt;/code&gt;则是因为其伪随机数的性质(这里简单说明一下，现在一般推荐使用&lt;code&gt;secrets&lt;/code&gt;中的所谓安全随机数，但是实际上只有量子叠加测量才能够真正实现真随机数)。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;直接对&lt;code&gt;py&lt;/code&gt;文件进行扫描：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ bandit subprocess_Popen.py 
[main]  INFO    profile include tests: None
[main]  INFO    profile exclude tests: None
[main]  INFO    cli include tests: None
[main]  INFO    cli exclude tests: None
[main]  INFO    running on Python 3.8.5
[node_visitor]  INFO    Unable to find qualified name for module: subprocess_Popen.py
Run started:2021-01-26 15:31:00.425603

Test results:
&amp;gt;&amp;gt; Issue: [B404:blacklist] Consider possible security implications associated with subprocess module.
   Severity: Low   Confidence: High
   Location: subprocess_Popen.py:3
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_imports.html#b404-import-subprocess
2
3       import subprocess
4       import uuid

--------------------------------------------------
&amp;gt;&amp;gt; Issue: [B602:subprocess_popen_with_shell_equals_true] subprocess call with shell=True identified, security issue.
   Severity: High   Confidence: High
   Location: subprocess_Popen.py:6
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b602_subprocess_popen_with_shell_equals_true.html
5
6       subprocess.Popen('touch ' + str(uuid.uuid1()) +'.txt', shell = True)

--------------------------------------------------

Code scanned:
        Total lines of code: 3
        Total lines skipped (#nosec): 0

Run metrics:
        Total issues (by severity):
                Undefined: 0.0
                Low: 1.0
                Medium: 0.0
                High: 1.0
        Total issues (by confidence):
                Undefined: 0.0
                Low: 0.0
                Medium: 0.0
                High: 2.0
Files skipped (0):
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过对刚才所创建的调用了危险函数&lt;code&gt;subprocess&lt;/code&gt;的py文件&lt;code&gt;subprocess_Popen.py&lt;/code&gt;的扫描，我们识别出了其中的&quot;危险函数&quot;，注意这里的&lt;code&gt;Issue&lt;/code&gt;编号是&lt;code&gt;602&lt;/code&gt;，定级是&lt;code&gt;Severity: Low Confidence: High&lt;/code&gt;。但是如果我们用&lt;code&gt;bandit&lt;/code&gt;去扫描利用了其他函数对危险函数的调用搭桥来二次调用的&lt;code&gt;bad.py&lt;/code&gt;文件，我们发现是另外一种结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ bandit bad.py 
[main]  INFO    profile include tests: None
[main]  INFO    profile exclude tests: None
[main]  INFO    cli include tests: None
[main]  INFO    cli exclude tests: None
[main]  INFO    running on Python 3.8.5
[node_visitor]  INFO    Unable to find qualified name for module: bad.py
Run started:2021-01-26 15:30:47.370468

Test results:                                                                                                                                                                                                                               
&amp;gt;&amp;gt; Issue: [B404:blacklist] Consider possible security implications associated with subprocess module.
   Severity: Low   Confidence: High                                                                                                                                                                                                         
   Location: bad.py:3                                                                                                                                                                                                                       
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_imports.html#b404-import-subprocess                                                                                                                              
2
3       from subprocess_Popen import subprocess as subprocess
4
5       subprocess.Popen('touch bad.txt', shell = True)

--------------------------------------------------
&amp;gt;&amp;gt; Issue: [B604:any_other_function_with_shell_equals_true] Function call with shell=True parameter identified, possible security issue.
   Severity: Medium   Confidence: Low                                                                                                                                                                                                       
   Location: bad.py:5                                                                                                                                                                                                                       
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b604_any_other_function_with_shell_equals_true.html                                                                                                                           
4
5       subprocess.Popen('touch bad.txt', shell = True)

--------------------------------------------------

Code scanned:                                                                                                                                                                                                                               
        Total lines of code: 2
        Total lines skipped (#nosec): 0

Run metrics:                                                                                                                                                                                                                                
        Total issues (by severity):
                Undefined: 0.0
                Low: 1.0
                Medium: 1.0
                High: 0.0
        Total issues (by confidence):
                Undefined: 0.0
                Low: 1.0
                Medium: 0.0
                High: 1.0
Files skipped (0):
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里虽然实现的功能跟上面那个例子是一样的，但是这里的&lt;code&gt;Issue&lt;/code&gt;编号为&lt;code&gt;604&lt;/code&gt;，定级也变成了&lt;code&gt;Severity: Medium Confidence: Low&lt;/code&gt;。这里的关键并不是定级变成了什么，而是定级被改变了，这是因为&lt;code&gt;bandit&lt;/code&gt;是通过对字符串的处理来识别危险函数的，因此对于这种二次调用的特殊场景，&lt;code&gt;bandit&lt;/code&gt;不一定都能够准确的识别出来对危险函数的调用，甚至可能出现二次调用后，完全无法识别风险函数的使用的可能性。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;扫描一个目录下的所有&lt;code&gt;py&lt;/code&gt;文件，并将结果写入&lt;code&gt;txt&lt;/code&gt;文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ bandit *.py -o test_bandit.txt -f txt
[main]  INFO    profile include tests: None
[main]  INFO    profile exclude tests: None
[main]  INFO    cli include tests: None
[main]  INFO    cli exclude tests: None
[main]  INFO    running on Python 3.8.5
[node_visitor]  INFO    Unable to find qualified name for module: bad.py
[node_visitor]  INFO    Unable to find qualified name for module: subprocess_Popen.py
[text]  INFO    Text output written to file: test_bandit.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该案例就扫描了当前目录下的所有py文件，其实就是&lt;code&gt;bad.py&lt;/code&gt;和&lt;code&gt;subprocess_Popen.py&lt;/code&gt;这两个，并且将最终的扫描结果保存至&lt;code&gt;test_bandit.txt&lt;/code&gt;文件中，这里我们就不展示txt文件的具体内容，大概就是将上一章节的两个执行结果进行了整合。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;扫描一个目录下的多层文件夹中的&lt;code&gt;py&lt;/code&gt;文件，并将结果写入&lt;code&gt;html&lt;/code&gt;文件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;假如我们有如下所示的一个目录结构需要进行扫描测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ tree
.
├── bad.py
├── bad.txt
├── level2
│   └── test_random.py
├── subprocess_Popen.py
├── test_bandit.html
└── test_bandit.txt

1 directory, 6 files
[dechin@dechin-manjaro bandit_test]$ cat level2/test_random.py 
# test_bandit.py

import random

a = random.random()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以在当前目录下执行如下指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ bandit -r . -f html -o test_bandit.html
[main]  INFO    profile include tests: None
[main]  INFO    profile exclude tests: None
[main]  INFO    cli include tests: None
[main]  INFO    cli exclude tests: None
[main]  INFO    running on Python 3.8.5
[html]  INFO    HTML output written to file: test_bandit.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们得到的结果是一个&lt;code&gt;test_bandit.html&lt;/code&gt;文件，文件内容如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210127001057303-1480466876.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;使用配置文件禁用部分&lt;code&gt;Issue&lt;/code&gt;&lt;br/&gt;在执行目录下创建一个&lt;code&gt;.bandit&lt;/code&gt;文件，作如下配置就可以避免对&lt;code&gt;B404&lt;/code&gt;的审查：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[bandit]
skips: B404
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行的扫描结果如下图所示，我们可以看到&lt;code&gt;B404&lt;/code&gt;相关的Issue已经不在列表中了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210127002705147-437046495.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;在&lt;code&gt;py&lt;/code&gt;文件中直接逃避&lt;code&gt;bandit&lt;/code&gt;审计&lt;br/&gt;在待扫描的py文件的对应风险函数后加上如下注释，即可在&lt;code&gt;bandit&lt;/code&gt;审计过程中自动忽略：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# bad.py

from subprocess_Popen import subprocess as sb

sb.Popen('touch bad.txt', shell = 1) # nosec
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以看到最终的审计结果中，&lt;code&gt;B604&lt;/code&gt;也随之而不见了，如下图所示。从这个案例中我们也可以知悉，&lt;code&gt;bandit&lt;/code&gt;并不是一个用来作安全防护的工具，仅仅是用来做比较初步的python代码安全函数使用规范的审查工作，而扫描出来的问题是否处理，其实最终还是取决于开发者自己。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210127004434716-314274217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;众所周知python语言的性能是极其受限的，因此bandit的性能也有可能十分的低下，这里让我们来定量的测试一下bandit的性能到底在什么水准。首先我们创建一个10000行的py文件，内容全部为危险函数的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# gen.py

import os

with open('test_bandit_power.py', 'w') as py_file:
    py_file.write('import subprocess as sb\n')
    for i in range(10000):
        py_file.write('sb.Popen(\'whoami\', shell = 1)\n')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过执行&lt;code&gt;python3 gen.py&lt;/code&gt;就可以生成一个10000行的危险函数文件&lt;code&gt;test_bandit_power.py&lt;/code&gt;，大约300KB的大小。此时我们针对这单个的文件进行&lt;code&gt;bandit&lt;/code&gt;扫描测试，我们发现这个过程极为漫长，并且生成了大量的错误日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro bandit_test]$ time bandit test_bandit_power.py -f html -o test_power.html
[main]  INFO    profile include tests: None
[main]  INFO    profile exclude tests: None
[main]  INFO    cli include tests: None
[main]  INFO    cli exclude tests: None
[main]  INFO    running on Python 3.8.5
[node_visitor]  INFO    Unable to find qualified name for module: test_bandit_power.py
[html]  INFO    HTML output written to file: test_power.html

real    0m6.239s
user    0m6.082s
sys     0m0.150s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以简单估算，如果10000行的代码都需要&lt;code&gt;6s&lt;/code&gt;的时间来进行扫描，那么对于比较大的项目的&lt;code&gt;1000000+&lt;/code&gt;的代码的扫描时间，则有可能达到&lt;code&gt;10min&lt;/code&gt;往上，这个时间虽然也不是特别长，但是对于大型的项目而言这绝对不是一个非常高效的选择。&lt;/p&gt;

&lt;p&gt;在一些对安全性要求较高的开发项目中，有可能会禁止使用危险函数，如&lt;code&gt;subprocess&lt;/code&gt;等。而&lt;code&gt;bandit&lt;/code&gt;的作用旨在通过对代码的扫描自动化的给出安全危险函数分析意见，至于是否采纳，还是以不同项目的管理者需求为准。同时经过我们的测试发现，&lt;code&gt;bandit&lt;/code&gt;在实际使用场景下性能表现并不如意，因此在大型项目中我们并不推荐使用，如果一定要使用也可以考虑进行针对性的配置。&lt;/p&gt;

&lt;p&gt;本文首发链接为：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/bandit.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/p/bandit.html&lt;/a&gt;&lt;br/&gt;作者ID：DechinPhy&lt;br/&gt;更多原著文章请参考：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 26 Jan 2021 17:08:00 +0000</pubDate>
<dc:creator>DechinPhy</dc:creator>
<og:description>本文介绍了python安全危险函数扫描工具bandit的数种使用方法与技巧，同时也分析了bandit在实际项目中的性能表现，给予了读者是否在python开发项目中引入bandit的启发思考。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dechinphy/p/bandit.html</dc:identifier>
</item>
<item>
<title>Elasticsearch从入门到放弃：浅谈算分 - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/14333109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/14333109.html</guid>
<description>&lt;p&gt;今天来聊一个 Elasticsearch 的另一个关键概念——相关性算分。在查询 API 的结果中，我们经常会看到 &lt;code&gt;_score&lt;/code&gt; 这个字段，它就是用来表示相关性算分的字段，而相关性就是描述一个文档和查询语句的匹配程度。&lt;/p&gt;
&lt;p&gt;打分的本质其实就是排序，Elasticsearch 会把最符合用户需求的文档排在最前面。&lt;/p&gt;
&lt;p&gt;在 Elasticsearch 5.0 之前，相关性算分算法采用的是 TF-IDF 算法，而在5.0之后采用的是 BM 25 算法。听到这也许你会比较疑惑，想知道这两个算法到底是怎么样的。别急，下面我们来具体了解一下。&lt;/p&gt;
&lt;h3 id=&quot;tf-idf&quot;&gt;TF-IDF&lt;/h3&gt;
&lt;p&gt;首先来看字面意思，TF 是 Term Frequency 的缩写，也就是词频。IDF 是 Inverse Document Frequency 的缩写，也就是逆文档频率。&lt;/p&gt;
&lt;h4 id=&quot;词频&quot;&gt;词频&lt;/h4&gt;
&lt;p&gt;词频比较好理解，就是要搜索的目标单词在文档中出现的频率。算式为检索词出现的次数除以文档的总字数。最简单的相关性算法就是将检索词进行分词后对他们的词频进行相加。例如，我要搜索“我的算法”，其相关性就可以表示为：&lt;/p&gt;
&lt;p&gt;TF(我) + TF(的) + TF(算法)&lt;/p&gt;
&lt;p&gt;但这里也有些问题，像“的”这样的词，虽然出现的次数很多，但是对贡献的相关度几乎没有用处。所以在考虑相关度时不应该考虑他们，对于这类词，我们统称为 Stop Word。&lt;/p&gt;
&lt;h4 id=&quot;逆文档频率&quot;&gt;逆文档频率&lt;/h4&gt;
&lt;p&gt;聊完了 TF，我们再来看看 IDF，在了解逆文档频率之前，首先需要知道什么是文档频率，也就是 DF。&lt;/p&gt;
&lt;p&gt;DF 其实是检索词在所有文档中出现的频率。例如，“我”在较多的文档中出现，“的”在非常多的文档中都会出现，而“算法”只会在较少的文档中出现。这就是文档频率，那逆文档频率，简单理解就是：&lt;/p&gt;
&lt;p&gt;log(全部文档数 / 检索词出现过的文档总数)&lt;/p&gt;
&lt;p&gt;针对上面的例子，我们将它更具体的呈现一下。假设我们文档总数为1亿，出现“我”字的文档有5000万，那么它的 IDF 就是 log(2) = 1 。“的”在1亿文档中都有出现，IDF 就是 log(1) = 0，而算法只在20万个文档中出现，那么它的 IDF 就是 log(500) ，大约是8.96。&lt;/p&gt;
&lt;p&gt;由此可见，IDF 越大的单词越重要。&lt;/p&gt;
&lt;p&gt;好了，现在各位 TF 和 IDF 应该都有一定的了解了，那么 TF-IDF 本质上就是对 TF 进行一个加权求和。&lt;/p&gt;
&lt;p&gt;TF(我) * IDF(我) + TF(的) * IDF(的) + TF(算法) * IDF(算法)&lt;/p&gt;
&lt;h3 id=&quot;bm-25&quot;&gt;BM 25&lt;/h3&gt;
&lt;p&gt;BM25可以看作是对 TF-IDF 的一个优化，其优化的效果是，当 TF 无限增加时， TF-IDF 的结果会随之增加，而 BM 25 的结果会趋近于一个数值。这就限制了一个 term 对于检索词整体相关性的影响。&lt;/p&gt;
&lt;p&gt;BM25算法的公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1611591823/Blog/ES/06/1713353-fc89dbc4421949c6.png&quot; alt=&quot;BM25&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要详细了解BM25算法的同学可以参考这篇文章&lt;a href=&quot;https://opensourceconnections.com/blog/2015/10/16/bm25-the-next-generation-of-lucene-relevation/&quot; target=&quot;_blank&quot;&gt;BM25 The Next Generation of Lucene Relevance&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;explain-api&quot;&gt;Explain API&lt;/h3&gt;
&lt;p&gt;如果想要了解一个查询是如何进行打分的，我们可以使用 Elasticsearch 提供的 Explain API，其用法非常简单，只需要在参数中增加&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&quot;explain&quot;: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在 path 中增加 &lt;code&gt;_explain&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -X GET &quot;localhost:9200/my-index-000001/_explain/0?pretty&quot; -H 'Content-Type: application/json' -d'
{
  &quot;query&quot; : {
    &quot;match&quot; : { &quot;message&quot; : &quot;elasticsearch&quot; }
  }
}
'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，返回结果中就会有一个 &lt;code&gt;explanation&lt;/code&gt; 字段，用来描述具体的算分过程。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;关于 Elasticsearch 的算分，相信各位也有一个初步的认识了，如果感兴趣的话也可以自己进行更加深入的研究，也欢迎各位和我一起交流。&lt;/p&gt;
</description>
<pubDate>Tue, 26 Jan 2021 16:28:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>今天来聊一个 Elasticsearch 的另一个关键概念——相关性算分。在查询 API 的结果中，我们经常会看到 _score 这个字段，它就是用来表示相关性算分的字段，而相关性就是描述一个文档和查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/14333109.html</dc:identifier>
</item>
<item>
<title>dotnet cli 5.0 新特性——dotnet tool search - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14332998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14332998.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;.NET 5.0 SDK 的发布，给 dotnet cli 引入了一个新的特性，&lt;code&gt;dotnet tool search&lt;/code&gt;，主要用于搜索 Nuget 上的 dotnet tool，这个命令会搜索 tool 的名称以及一些元数据， titles, descriptions, 和 tags&lt;/p&gt;
&lt;h2 id=&quot;search&quot;&gt;Search&lt;/h2&gt;
&lt;h3 id=&quot;synopsis&quot;&gt;Synopsis&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;dotnet tool search [--detail] [--prerelease]&lt;br/&gt;[--skip ] [--take ]&lt;/p&gt;
&lt;p&gt;dotnet tool search -h|--help&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以通过 &lt;code&gt;dotnet tool search -h&lt;/code&gt; 查看支持的参数，支持的参数如下：&lt;/p&gt;
&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;来看几个简单的示例：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;dotnet tool search &amp;lt;keyword&amp;gt;&lt;/code&gt; 进行最基本的搜索，&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;dotnet tool search &amp;lt;keyword&amp;gt; --skip &amp;lt;skip&amp;gt; --take &amp;lt;take&amp;gt;&lt;/code&gt; 来进行分页查询&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210126232000018-1108843325.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;dotnet tool search &amp;lt;keyword&amp;gt; --take 1 --detail&lt;/code&gt; 查询详细信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210126231927765-1797568363.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;这个功能从 .NET 5.0 SDK 之后才支持，它的实现方式倒是很简单，直接调用了 Nuget 的接口，通过 &lt;code&gt;packageType=dotnettool&lt;/code&gt; 只查询 dotnet tool&lt;/p&gt;
&lt;p&gt;用抓包工具抓个包看看，search 的时候做了什么，search 的时候会调用 nuget 的接口，接口调用情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210126233743636-1573464557.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这个我们即使不完全记得 package tool 的类型，我们也可以通过命令进行查询，方便了很多&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
</description>
<pubDate>Tue, 26 Jan 2021 15:38:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>dotnet cli 5.0 新特性——dotnet tool search Intro .NET 5.0 SDK 的发布，给 dotnet cli 引入了一个新的特性，dotnet tool sea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14332998.html</dc:identifier>
</item>
<item>
<title>HTML5与CSS3知识点总结 - Robod丶</title>
<link>http://www.cnblogs.com/robod/p/14332916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robod/p/14332916.html</guid>
<description>&lt;blockquote readability=&quot;5.556862745098&quot;&gt;
&lt;p&gt;&lt;strong&gt;好好学习，天天向上&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;本文已收录至我的Github仓库&lt;a href=&quot;https://github.com/RobodLee/DayDayUP&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;DayDayUP&lt;/strong&gt;&lt;/a&gt;：github.com/RobodLee/DayDayUP，欢迎Star&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113201713&quot; target=&quot;_blank&quot;&gt;⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113201713&quot; target=&quot;_blank&quot;&gt;原文链接：https://blog.csdn.net/weixin_43461520/article/details/113201713&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113201713&quot; target=&quot;_blank&quot;&gt;⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;html5新增标签&quot;&gt;HTML5新增标签&lt;/h2&gt;
&lt;p&gt;HTML5针对以前的不足，新增了一些新的标签、表单以及表单属性等。&lt;/p&gt;
&lt;h3 id=&quot;语义化标签&quot;&gt;语义化标签&lt;/h3&gt;
&lt;p&gt;之前在做布局的使用，使用了大量的div，这些div都是没有语义的，我们不能很轻易的就判断出某个div大致是什么内容，所以在HTML5中新增了语义化标签来弥补这个缺陷，现在我们可以根据标签名去推断出其大致内容，方便代码的阅读，而且使用语义化标签也可以提高被搜索引擎检索的概率。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;：头部标签&lt;br/&gt;&lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;：导航标签&lt;br/&gt;&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;：内容标签&lt;br/&gt;&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;：定义文档某个区域&lt;br/&gt;&lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;：侧边栏标签&lt;br/&gt;&lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;：尾部标签&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/34f163c8c6de0ebcad53dae07163b6d5.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;多媒体标签&quot;&gt;多媒体标签&lt;/h3&gt;
&lt;p&gt;HTML5原生支持音视频文件的播放，其中音频标签和视频标签的使用方式基本一致 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;autdio&amp;gt;&lt;/code&gt;：音频&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;标签支持三种音频格式，分别是MP3、Wav以及Ogg，其中MP3格式所有的浏览器都支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;语法：
&amp;lt;audio src=&quot;文件地址&quot; controls=&quot;controls&quot;&amp;gt;&amp;lt;/audio&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;标签常见属性👇&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;autoplay&lt;/td&gt;
&lt;td&gt;autoplay&lt;/td&gt;
&lt;td&gt;表示音频在就绪后马上播放&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;controls&lt;/td&gt;
&lt;td&gt;controls&lt;/td&gt;
&lt;td&gt;表示向用户显示控件，比如播放按钮&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;loop&lt;/td&gt;
&lt;td&gt;loop&lt;/td&gt;
&lt;td&gt;循环播放，即每当音频结束时重新开始播放&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src&lt;/td&gt;
&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;要播放的音频的url&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;：视频&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;标签支持三种视频格式，分别是MP4、WebM以及Ogg，其中MP4格式所有的浏览器都支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;语法：
&amp;lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&amp;gt;&amp;lt;/video&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;标签有很多属性，比较常见的有👇&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;autoplay&lt;/td&gt;
&lt;td&gt;autoplay&lt;/td&gt;
&lt;td&gt;视频就绪自动播放(谷歌浏览器不会自动播放，需要添加muted属性来自动播放)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;controls&lt;/td&gt;
&lt;td&gt;controls&lt;/td&gt;
&lt;td&gt;向用户显示播放控件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;pixels(像素)&lt;/td&gt;
&lt;td&gt;设置播放器宽度&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;pixels(像素)&lt;/td&gt;
&lt;td&gt;设置播放器高度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;loop&lt;/td&gt;
&lt;td&gt;loop&lt;/td&gt;
&lt;td&gt;插放完是否继续播放该视频，循环播放&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;preload&lt;/td&gt;
&lt;td&gt;auto(预先加载视频)&lt;br/&gt;none(不加载视频)&lt;/td&gt;
&lt;td&gt;规定是否预加载视频 (如果有了 autoplay 就忽略该属性)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;src&lt;/td&gt;
&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;视频ur地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;poster&lt;/td&gt;
&lt;td&gt;图片的url&lt;/td&gt;
&lt;td&gt;加载等待的画面图片&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;muted&lt;/td&gt;
&lt;td&gt;muted&lt;/td&gt;
&lt;td&gt;静音插放&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;input表单&quot;&gt;input表单&lt;/h3&gt;
&lt;p&gt;在HTML5中，增加了一些新的input类型，使其语义化更加明显。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type=&quot;email&quot;&lt;/td&gt;
&lt;td&gt;限制用户输入必须为Email类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type=&quot;url&quot;&lt;/td&gt;
&lt;td&gt;限制用户输入必须为URL类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type=&quot;date&quot;&lt;/td&gt;
&lt;td&gt;限制用户输入必须为日期类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type=&quot;time&quot;&lt;/td&gt;
&lt;td&gt;限制用户输入必须为时间类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type=&quot;month&quot;&lt;/td&gt;
&lt;td&gt;限制用户输入必须为月类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type=&quot;week&quot;&lt;/td&gt;
&lt;td&gt;限制用户输入必须为周类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type=&quot;number&quot;&lt;/td&gt;
&lt;td&gt;限制用户输入必须为数字类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type=&quot;tel&quot;&lt;/td&gt;
&lt;td&gt;手机号码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type=&quot;search&quot;&lt;/td&gt;
&lt;td&gt;搜索框&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type=&quot;color&quot;&lt;/td&gt;
&lt;td&gt;生成一个颜色选择表单&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;HTML5中不仅新增了一些input类型，还新增了一些表单属性👇&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;required&lt;/td&gt;
&lt;td&gt;required&lt;/td&gt;
&lt;td&gt;表单拥有该属性表示其内容不能为空，必填&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;placeholder&lt;/td&gt;
&lt;td&gt;提示文本&lt;/td&gt;
&lt;td&gt;表单的提示信息，存在默认值将不显示&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;autofocus&lt;/td&gt;
&lt;td&gt;autofocus&lt;/td&gt;
&lt;td&gt;自动聚焦属性，页面加载完成自动聚焦到指定表单&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;autocomplete&lt;/td&gt;
&lt;td&gt;off / on&lt;/td&gt;
&lt;td&gt;当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。默认已经打开，如autocomplete=&quot;on&quot;，关闭autocomplete=&quot;off，需要放在表单内，同时加上name属性，并且提交成功过&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;multiple&lt;/td&gt;
&lt;td&gt;multiple&lt;/td&gt;
&lt;td&gt;可以多选文件提交&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;css3新增选择器&quot;&gt;CSS3新增选择器&lt;/h2&gt;
&lt;h3 id=&quot;属性选择器&quot;&gt;属性选择器&lt;/h3&gt;
&lt;p&gt;属性选择器可以在不用借助于类或者id选择器的情况下直接&lt;strong&gt;根据元素特定属性来选择元素&lt;/strong&gt;，它的&lt;strong&gt;权重为10&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;E[att]&lt;/code&gt;：选择具有&lt;strong&gt;att&lt;/strong&gt;属性的&lt;strong&gt;E&lt;/strong&gt;元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 将具有value属性的按钮1中文字颜色修改为红色，按钮2因为不具有value属性，所以文字颜色没有改变 --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        input[value] {
            color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;button&quot; value=&quot;按钮1&quot;&amp;gt;
    &amp;lt;input type=&quot;button&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/fa674ca7cbfb28b598238a959803bf48.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;E[att=&quot;val&quot;]&lt;/code&gt;：选择具有&lt;strong&gt;att&lt;/strong&gt;属性且属性值等于&lt;strong&gt;val&lt;/strong&gt;的&lt;strong&gt;E&lt;/strong&gt;元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 将value属性值为 “按钮2” 的button的文字颜色修改为蓝色 --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        input[value=&quot;按钮2&quot;] {
            color: blue;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;button&quot; value=&quot;按钮1&quot;&amp;gt;
    &amp;lt;input type=&quot;button&quot; value=&quot;按钮2&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/2aa60a8675a88888168bcd1387ac4c0a.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;E[att^=&quot;val&quot;]&lt;/code&gt;：匹配具有&lt;strong&gt;att&lt;/strong&gt;属性且值以&lt;strong&gt;val&lt;/strong&gt;开头的&lt;strong&gt;E&lt;/strong&gt;元素&lt;br/&gt;&lt;code&gt;E[att$=&quot;val&quot;]&lt;/code&gt;：匹配具有&lt;strong&gt;att&lt;/strong&gt;属性且值以&lt;strong&gt;val&lt;/strong&gt;结尾的&lt;strong&gt;E&lt;/strong&gt;元素&lt;br/&gt;&lt;code&gt;E[att*=&quot;val&quot;]&lt;/code&gt;：匹配具有&lt;strong&gt;att&lt;/strong&gt;属性且值中含有&lt;strong&gt;val&lt;/strong&gt;的&lt;strong&gt;E&lt;/strong&gt;元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;结构伪类选择器&quot;&gt;结构伪类选择器&lt;/h3&gt;
&lt;p&gt;结构伪类选择器主要&lt;strong&gt;根据文档结构来选择元素&lt;/strong&gt;，常用于&lt;strong&gt;根据父级元素选择里面的子元素&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;E: first-child&lt;/code&gt;：匹配父元素中的第一个子元素E&lt;br/&gt;&lt;code&gt;E: last-child&lt;/code&gt;：匹配父元素中最后一个E元素&lt;br/&gt;&lt;code&gt;E: nth-child(n)&lt;/code&gt;：匹配父元素中的第n个子元素E，n也可以是关键字&lt;strong&gt;even偶数&lt;/strong&gt;、&lt;strong&gt;odd奇数&lt;/strong&gt;，如果直接写字母n则表示选择所有的子元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        ul li:first-child {
            background-color: skyblue;
        }
        ul li:last-child {
            background-color: aquamarine;
        }
        ul li:nth-child(2) {
            background-color: blueviolet;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;欢迎关注&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;微信公众号：&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;Robod&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/98aff0c6c6715d6f2acd40780b6bc2ab.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;E: first-of-type&lt;/code&gt;：指定类型E的第一个&lt;br/&gt;&lt;code&gt;E: last-of-type&lt;/code&gt;：指定类型E的最后&lt;br/&gt;&lt;code&gt;E: nth-of-type(n)&lt;/code&gt;：指定类型E的第n个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这三个和上面三个使用起来类似，不过还是有一点区别的，&lt;strong&gt;nth-child&lt;/strong&gt;是对父元素里面所有子元素排序选择(序号是固定的)先找到第n个孩子，然后看看是否和E匹配；而&lt;strong&gt;nth-of-type&lt;/strong&gt;则是对父元素里面指定子元素进行排序选择，先去匹配E，然后再根据E找第n个子元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        ul li:nth-child(1) {
            /* 先对ul里的所有子元素排序，找到序号为1的元素，发现是p标签而不是li，所以样式不生效 */
            background-color: skyblue;
        }
        div li:nth-of-type(1) {
            /* 先匹配对应的li元素，对li元素进行排序，排序后选择第一个li */
            background-color: skyblue;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;p&amp;gt;微信公众号：Robod&amp;lt;/p&amp;gt;     &amp;lt;!-- 序号是1 --&amp;gt;
        &amp;lt;li&amp;gt;欢迎关注&amp;lt;/li&amp;gt;            &amp;lt;!-- 序号是2 --&amp;gt;
        &amp;lt;li&amp;gt;微信公众号：&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;Robod&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;p&amp;lt;/p&amp;gt;
        &amp;lt;li&amp;gt;li1&amp;lt;/li&amp;gt;    &amp;lt;!-- 序号是1 --&amp;gt;    
        &amp;lt;li&amp;gt;li2&amp;lt;/li&amp;gt;    &amp;lt;!-- 序号是2 --&amp;gt;  
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b4c2827bc51ec6f49bd332dc3e915d30.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;伪元素选择器&quot;&gt;伪元素选择器&lt;/h3&gt;
&lt;p&gt;有的时候我们只需要一个简单的标签，如果用HTML做的话就会使代码结构变得复杂，这时候就可以用伪元素选择器，它可以帮助我们利用CSS创建新标签元素，从而简化HTML结构。伪元素选择器有两个，分别是&lt;code&gt;::before&lt;/code&gt;（在元素内部的前面插入内容）和&lt;code&gt;::after&lt;/code&gt;（在元素内部的后面添加内容），需要注意的是它们创建的元素是&lt;strong&gt;行内元素&lt;/strong&gt;，而且在文档树里面是找不到的，这两个选择器必须要有&lt;strong&gt;content&lt;/strong&gt;属性(可以没有值)，伪元素选择器的&lt;strong&gt;权重是1&lt;/strong&gt;，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--语法：
        element::before{}
--&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            position: relative;
            width: 300px;
            height: 200px;
            background-color: aquamarine;
        }
        div::before {
            content: '微信公众号';
        }
        div::after {
            position: absolute;
            font-size: 30px;
            content: &quot;Robod&quot;;
            right: 10px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        :
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/581c476973fc59fd664f8186d95ff6fd.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;css3新特性&quot;&gt;CSS3新特性&lt;/h2&gt;
&lt;h3 id=&quot;css3盒模型&quot;&gt;CSS3盒模型&lt;/h3&gt;
&lt;p&gt;之前我们在定义盒子大小的时候，指定了width属性，可是盒子实际的宽度并不是width，padding和border都会将盒子撑大，也就是实际的盒子宽度是&lt;strong&gt;width+padding+border&lt;/strong&gt;，而现在可以用&lt;code&gt;box-sizing&lt;/code&gt;来指定盒模型，box-sizing属性有以下两个值。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;content-box&lt;/code&gt;：这个是默认值，盒子的宽度是&lt;strong&gt;width+padding+border&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;border-box&lt;/code&gt;：盒子的大小为&lt;strong&gt;width&lt;/strong&gt;属性的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        .box1 {
            width: 400px;
            height: 100px;
            border: 20px solid red;
            background-color: aqua;
            padding: 10px;
            box-sizing: content-box;
        }
        .box2 {
            width: 400px;
            height: 100px;
            border: 20px solid green;
            background-color: blanchedalmond;
            padding: 10px;
            box-sizing: border-box;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box1&quot;&amp;gt;请小伙伴们给我的文章来个赞！&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box2&quot;&amp;gt;欢迎关注微信公众号：Robod&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/d98a8a94981e45cacfe9a10830ce8bff.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;css3滤镜filter&quot;&gt;CSS3滤镜filter&lt;/h3&gt;
&lt;p&gt;filter属性将模糊或颜色偏移等图形效果应用于元素，通常用于调整图像，背景和边框的渲染。常用的几个函数如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8.7695749440716&quot;&gt;
&lt;p&gt;&lt;code&gt;filter: blur(5px)&lt;/code&gt; 该函数用来对图片进行模糊处理，数值越大图片越模糊&lt;br/&gt;&lt;code&gt;filter: contrast(200%)&lt;/code&gt; 调整图像的对比度，0%会全黑，100%图像不变，超过100%更低的对比度&lt;br/&gt;&lt;code&gt;filter: grayscale(80%)&lt;/code&gt; 将图像转换为灰度图像，100%完全转为灰度图像，0%图像无变化&lt;br/&gt;&lt;code&gt;filter: hue-rotate(90deg)&lt;/code&gt; 给图像应用色相旋转&lt;/p&gt;
&lt;p&gt;还有其它的一些可以参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/filter&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/filter&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;calc函数&quot;&gt;calc()函数&lt;/h3&gt;
&lt;p&gt;calc()函数可以在声明CSS属性值时执行一些计算，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;width: calc(100% - 30px);              &amp;lt;!-- 表示比父盒子小30像素 --&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;css3过渡&quot;&gt;CSS3过渡&lt;/h3&gt;
&lt;p&gt;过渡动画是从一个状态渐渐的过渡到另外一个状态，通常和&lt;strong&gt;:hover&lt;/strong&gt;一起搭配使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/*语法：*/
transition:要过渡的属性 花费时间 运动曲线 何时开始
/*参数说明 */
1、属性：想要变化的css属性,宽度高度背景颜色内外边距都可以，如果想要所有的属性都变化过渡,写一个 all 即可
2、花费时间：单位是秒(必须写单位)比如0.5s
3、运动曲线：默认是ease(逐渐慢下来，可以省略)，还可以是linear(匀速)，ease-in(加速)，ease-out(减速)，ease-in-out(先加速后减速)
4、何时开始：单位是秒(必须写单位)，可以设置延迟触发时间默认是0s(可以省略)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 50px;
            height: 50px;
            background-color: aqua;
            /* 如果要写多个属性，用逗号隔开即可 */
            /* transition: width 1s ease-in-out .5s,height 1s ease-in-out .5s; */
            /* 如果所有的属性都要过渡，写 all 即可 */
            transition: all 1s ease-in-out .5s;
        }
        div:hover {
            width: 100px;
            height: 100px;
            background-color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;微信公众号：Robod&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/ab46aa1ff4d53e757a017c5b09091061.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2d转换&quot;&gt;2D转换&lt;/h2&gt;
&lt;h3 id=&quot;移动translation&quot;&gt;移动translation&lt;/h3&gt;
&lt;p&gt;2D移动是2D转换里面的一种功能，可以改变元素在页面中的位置，类似定位。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/*第一个参数是x方向移动的距离，第二个参数是y方向移动的距离，可以是百分比，值可以为0但不能没有*/
transform: translate(20px,0); 
/*也可以分开写，👆的一行等同于👇两行*/
transfrom: translateX(20px);
transform: translateY(30px);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;translate的优点就是&lt;strong&gt;不会影响到其它元素的位置&lt;/strong&gt;，如果单位不是px而是百分比的话，表示的就是自身元素的百分比，这种移动方式&lt;strong&gt;对行内标签是没有效果&lt;/strong&gt;的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        div:first-child {
            width: 100px;
            height: 100px;
            background-color: red;
            transform: translate(50%,20px);
        }
        div:last-child {
            width: 100px;
            height: 100px;
            background-color: aquamarine;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/24d5064e56d06b07bb82de52b5b5224a.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;旋转rotate&quot;&gt;旋转rotate&lt;/h3&gt;
&lt;p&gt;2D旋转指的是让元素在二维平面内顺时针或者逆时针旋转。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- rotate中度数的单位是deg，顺时针是正数，逆时针是负数 --&amp;gt;
&amp;lt;!-- transfrom: rotate(度数); --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        img {
            transition: all 1s;
        }
        img:hover {
            transform: rotate(360deg);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;img src=&quot;./images/robod.png&quot; alt=&quot;&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c0ff79e2a6a3b1cfe95d40a72d281429.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在是以元素的中心为旋转点进行旋转，这也是默认的旋转点，也可以通过&lt;code&gt;transfrom-origin&lt;/code&gt;属性更改旋转点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 两个参数分别是x方向和y方向的位置，可以是像素也可以是方位名词 --&amp;gt;
&amp;lt;!-- transfrom-origin: x y; --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        img {
            transform-origin: 50px bottom;
            transition: all 1s;
        }
        img:hover {
            transform: rotate(90deg);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;img src=&quot;./images/robod.png&quot; alt=&quot;&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/6b9d62ea942261cd8abe689b98e9eedb.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;缩放scale&quot;&gt;缩放scale&lt;/h3&gt;
&lt;p&gt;缩放的意思就是可以放大和缩小，可以用&lt;code&gt;scale&lt;/code&gt;来设置缩放，这种方式相较于直接修改宽高而言优势就是&lt;strong&gt;不影响其它盒子&lt;/strong&gt;，和rotate一样，也可以通过&lt;strong&gt;transform-origin&lt;/strong&gt;属性来修改缩放中心。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 第一个参数表示宽缩放为原来的m倍，第二个参数表示高缩放为原来的n倍，如果只填一个参数代表宽高同时缩放为原来的x倍
transform: scale(m,n);
transform: scale(x); --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        img {
            transition: all 1s;
            transform-origin: right bottom;
        }
        img:hover {
            transform: scale(.5);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;img src=&quot;./images/robod.png&quot; alt=&quot;&quot;&amp;gt;
    &amp;lt;p&amp;gt;微信公众号：Robod&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b6d153899b5ce313f4b82e808b556841.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;上述的几个转换方式是可以同时使用的，中间用空格隔开即可&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transform: translate() rotate() scale()...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，书写顺序会影响转换的效果，比如先旋转会改变坐标轴方向，所以在同时有位移和其它属性的时候，位移要放在最前面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;css3-动画&quot;&gt;CSS3 动画&lt;/h2&gt;
&lt;p&gt;动画(animation)是CSS3中具有颠覆性的特征之一，可以通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果，相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。&lt;/p&gt;
&lt;h3 id=&quot;动画的基本使用&quot;&gt;动画的基本使用&lt;/h3&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;动画序列&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在学习动画之前，要先明确&lt;strong&gt;动画序列&lt;/strong&gt;这个概念👇&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;0%&lt;/strong&gt;是动画的&lt;strong&gt;开始&lt;/strong&gt;，&lt;strong&gt;100%&lt;/strong&gt;是动画的结束（0%~100%代表不同阶段的动画，都可以设置）。这样的规则就是动画序列。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;@keyframes&lt;/code&gt;中规定某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果。&lt;/li&gt;
&lt;li&gt;动画是使元素从一种样式逐渐变化为另一种样式的效果。您可以改变任意多的样式任意多的&lt;strong&gt;次数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;请用百分比来规定变化发生的时间，或用关键词 &quot;&lt;strong&gt;from&lt;/strong&gt;&quot; 和 &quot;&lt;strong&gt;to&lt;/strong&gt;&quot; ，等同于0%和100%。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;1、使用@keyframes定义动画&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;@keyframes 自定义的动画名称 {
    0% {
        xxxxxx；
    }
    100% {
        xxxxxxx；
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;2、元素使用动画&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给需要使用动画的元素添加&lt;code&gt;animation-name&lt;/code&gt;(调用动画)以及&lt;code&gt;animation-duration&lt;/code&gt;(持续时间)这两个属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        @keyframes robod_animation {
            0% {
                transform: rotate(0) scale(1);
            }
            to {
                transform: rotate(90deg) scale(0.5);
            }
        }
        img {
            animation-name: robod_animation;
            animation-duration: 2s;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;img src=&quot;./images/robod.png&quot; alt=&quot;&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/9c25efeaad092b5755126c80e88e38f9.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;常用动画属性&quot;&gt;常用动画属性&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定动画&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;animation&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;所有动画属性的简写属性，除了animation-play-state属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;animation-name&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定@keyframes动画的名称（必须）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;animation-duration&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定动画完成一个周期所花费的秒或毫秒，默认是0（必须）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;animation-timing-funtion&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定动画的速度曲线，默认是 “ease”&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;animation-delay&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定动画何时开始，默认是0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;animation-iteration-count&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定动画被播放的次数，默认是1，还有infinite(无限循环)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;animation-direction&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定动画是否在下一周期逆向播放，默认是“normal”，alternate逆播放&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;animation-play-state&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定动画是否正在运行或暂停，默认是 “running”，还有 “paused”&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;animation-fill-mode&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;规定动画结束后状态，保持forwards，回到起始backwards&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;动画属性也可以采用简写的方式：&lt;/p&gt;
&lt;p&gt;animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态;&lt;/p&gt;
&lt;p&gt;需要注意的是，简写属性里面不包含&lt;strong&gt;animation-play-state&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;速度曲线&quot;&gt;速度曲线&lt;/h3&gt;
&lt;p&gt;上面提到了一个&lt;strong&gt;animation-timing-funtion&lt;/strong&gt;属性用来设置动画的速度曲线，该属性的值一共有6个：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;linear&lt;/td&gt;
&lt;td&gt;动画从头到尾的速度是相同的，匀速&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ease&lt;/td&gt;
&lt;td&gt;默认，动画以低速开始，然后加快，在结束前变慢&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ease-in&lt;/td&gt;
&lt;td&gt;动画以低速开始&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ease-out&lt;/td&gt;
&lt;td&gt;动画以低速结束&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ease-in-out&lt;/td&gt;
&lt;td&gt;动画以低速开始和结束&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;steps()&lt;/td&gt;
&lt;td&gt;指定了时间函数中的间隔数量（步长）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;前面几个都很好理解，这个步长的意思就是整个操作划分为多少步，然后一步一步执行，类似于那种一格一格的进度条的感觉，可以做一些有意思的动画。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        @keyframes steeeep {
            from {
                width: 0;
            }
            to {
                width: 160px;
            }
        }
        div {
            width: 160px;
            overflow: hidden;
            white-space: nowrap;
            font-size: 10px;
            background-color: aqua;
            animation: steeeep 2s steps(15) backwards;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        欢迎关注微信公众号：Robod
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c833addb483297dd6b005ca020181862.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3d转换&quot;&gt;3D转换&lt;/h2&gt;
&lt;h3 id=&quot;透视-perspective&quot;&gt;透视 perspective&lt;/h3&gt;
&lt;p&gt;在了解3D转换之前首要要明确一个概念——“&lt;strong&gt;透视&lt;/strong&gt;”，电脑屏幕是二维的，我们没办法直接看到立体的东西，如果要想看到物体在Z轴上的变化，就得使用&lt;strong&gt;透视&lt;/strong&gt;，透视又称&lt;strong&gt;视距&lt;/strong&gt;，其实就是3D的东西投影在2D平面的效果，下图中的&lt;strong&gt;d&lt;/strong&gt;就是透视，当物体不变时，透视越大，在屏幕上看到的就越小，透视越小，在屏幕上看到的就越大，所谓&lt;strong&gt;近大远小&lt;/strong&gt;。透视的&lt;strong&gt;单位是px&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7ea3e9df5ba0646292d4e5db1a4038b0.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3d移动-translate3d&quot;&gt;3D移动 translate3d&lt;/h3&gt;
&lt;p&gt;3D移动和2D移动类似，只不过是多了个Z轴。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/*这三个参数分别代表在xyz轴要移动的距离，z轴一般以px为单位*/
transform: translate3d(x , y , z);
/*也可以分开写*/
translate: translateX(x);
translate: translateY(y);
translate: translateZ(z);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先给需要移动的元素的父元素添加透视，在透视固定的情况下，改变translateZ的大小，就会改变元素在屏幕上的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            perspective: 500px;
        }
        div {
            width: 200px;
            height: 200px;
            background-color: aquamarine;
            margin: 0 auto;
            transform: translateZ(100px);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3f066eee6f8db05c6bbb66bddfd44a31.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3d旋转-rotate3d&quot;&gt;3D旋转 rotate3d&lt;/h3&gt;
&lt;p&gt;3D旋转指可以让元素在三维平面内沿着x轴，y轴，z轴或者自定义轴进行旋转。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;transform: rotateX(45deg);      /*沿x轴正方向旋转45度*/
transform: rotateY(45deg);      /*沿y轴正方向旋转45度*/
transform: rotateZ(45deg);      /*沿z轴正方向旋转45度*/
transform: rotate3d(1,1,0,45deg);       /*沿着x轴与y轴的对角线旋转45度*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么哪一个方向是旋转正方向呢？这里有一个技巧，就是&lt;strong&gt;左手准则&lt;/strong&gt;，左手大拇指指向某一个轴的正方向，手指弯曲的方向就是旋转的正方向，反之就是反方向。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a3927612cdd2554e6fde70224af7c10e.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            perspective: 500px;
        }
        img {
            transition: all 1s;
        }
        img:hover:first-child {
            transform: rotateX(45deg);
        }
        img:hover:nth-child(2) {
            transform: rotateY(45deg);
        }
        img:hover:nth-child(3) {
            transform: rotateZ(45deg);
        }
        img:hover:last-child {
            transform: rotate3d(1,1,0,45deg);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;img src=&quot;./images/robod.png&quot; alt=&quot;&quot;&amp;gt;
    &amp;lt;img src=&quot;./images/robod.png&quot; alt=&quot;&quot;&amp;gt;
    &amp;lt;img src=&quot;./images/robod.png&quot; alt=&quot;&quot;&amp;gt;
    &amp;lt;img src=&quot;./images/robod.png&quot; alt=&quot;&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/62c103544f6f532bdea34ad2c581385a.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3d呈现-transform-style&quot;&gt;3D呈现 transform-style&lt;/h3&gt;
&lt;p&gt;3D呈现就是用来控制子元素是否开启三维立体环境，默认是&lt;strong&gt;transform-style: flat&lt;/strong&gt;(不开启)，如果想开启，可以修改为&lt;code&gt;transform-style: preserve-3d&lt;/code&gt;。注意：&lt;strong&gt;代码是写给父元素的，但影响的子元素&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            perspective: 500px;
        }
        .box1 {
            width: 200px;
            height: 200px;
            transition: all 2s;
            transform-style: preserve-3d; /*和transform-style: flat*/
        }
        .box2 {
            width: 100%;
            height: 100%;
            background-color: aqua;
            transform: rotateX(45deg);
        }
        .box1:hover {
            transform: rotateY(45deg);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box1&quot;&amp;gt;
        &amp;lt;div class=&quot;box2&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中的例子，先看一下&lt;strong&gt;transform-style: flat&lt;/strong&gt;的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/4898e3ab6dbf46013cec708c9cc2f0c7.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当鼠标移到上面的时候，先是由本来的绕x轴旋转45度的状态转换为普通的平面图，再由平面图绕y轴进行旋转，这显然不是我们想要的效果。&lt;/p&gt;
&lt;p&gt;再来看看&lt;strong&gt;transform-style: preserve-3d&lt;/strong&gt;的效果👇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/338dd8c740b1b3204d2e07caf06cb75c.gif#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就是三维的转换效果了，直接由绕x轴旋转45度的状态直接再绕y轴旋转45度。&lt;/p&gt;
&lt;h2 id=&quot;浏览器私有前缀&quot;&gt;浏览器私有前缀&lt;/h2&gt;
&lt;p&gt;浏览器私有前缀是为了兼容老版本的写法，比较新的版本的浏览器无须忝加。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-moz-&lt;/code&gt;：代表 firefox浏览器的私有属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ms-&lt;/code&gt;：代表ie浏览器私有属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-webkit-&lt;/code&gt;：代表 safari、chrome私有属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o-&lt;/code&gt;：代表Opera私有属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如圆角属性就可以这样写👇&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;-moz-border-radius: 10px;
-webkit-border-radius: 10px;
border-radius: 10px;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好了，这就是我这段时间学习HTML5和CSS3所总结出来的一些知识点，一方面是怕我自己以后忘了可以拿来复习使用，另一方面也是希望可以帮助到一起学习的小伙伴们！&lt;/p&gt;
&lt;blockquote readability=&quot;9.0650406504065&quot;&gt;
&lt;p&gt;码字不易，可以的话，给我来个&lt;code&gt;点赞&lt;/code&gt;，&lt;code&gt;收藏&lt;/code&gt;，&lt;code&gt;关注&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果你喜欢我的文章，欢迎关注微信公众号 &lt;strong&gt;『 &lt;span&gt;R&lt;/span&gt; &lt;span&gt;o&lt;/span&gt; &lt;span&gt;b&lt;/span&gt; &lt;span&gt;o&lt;/span&gt; &lt;span&gt;d&lt;/span&gt; 』&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;本文已收录至我的Github仓库&lt;a href=&quot;https://github.com/RobodLee/DayDayUP&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;DayDayUP&lt;/strong&gt;&lt;/a&gt;：github.com/RobodLee/DayDayUP，欢迎Star&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113201713&quot; target=&quot;_blank&quot;&gt;⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113201713&quot; target=&quot;_blank&quot;&gt;原文链接：https://blog.csdn.net/weixin_43461520/article/details/113201713&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43461520/article/details/113201713&quot; target=&quot;_blank&quot;&gt;⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/QRcode2.0.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Jan 2021 15:12:00 +0000</pubDate>
<dc:creator>Robod丶</dc:creator>
<og:description>HTML常用标签总结 手摸手带你学CSS 好好学习，天天向上 本文已收录至我的Github仓库DayDayUP：github.com/RobodLee/DayDayUP，欢迎Star ⭐⭐⭐⭐⭐⭐⭐⭐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/robod/p/14332916.html</dc:identifier>
</item>
<item>
<title>从软件(Java/hotspot/Linux)到硬件(硬件架构)分析互斥操作的本质 - 执生</title>
<link>http://www.cnblogs.com/lqlqlq/p/14330313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lqlqlq/p/14330313.html</guid>
<description>&lt;p&gt;先上结论：&lt;/p&gt;
&lt;p&gt;一切互斥操作的依赖是 自旋锁（spin_lock），互斥量（semaphore）等其他需要队列的实现均需要自选锁保证临界区互斥访问。&lt;/p&gt;
&lt;p&gt;而自旋锁需要xcmpchg等类似的可提供CAS操作的硬件指令提供原子性 和 可见性，（xcmpchg会锁总线或缓存行，一切会锁总线或缓存行的操作都会刷StoreBuffer，起到写屏障的操作）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;所以，任意的互斥操作，无论是 java 层面，hotspot层面，linux层面 的根本依赖都是 xcmpchg 等硬件指令&lt;/span&gt;&lt;/strong&gt;。java算是上层，需要依赖hotspot和linux嵌入的汇编完成xcmpchg的调用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所有同步手段的根本是硬件，软件是辅助手段，软件和硬件的交界面是用于并发控制的硬件指令（如 cmpchg, 带lock前缀的指令，lwsync, sfence 等）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整个依赖链条：&lt;/p&gt;
&lt;p&gt;1. Java 的并发工具包 JUC 中大部分同步工具类依赖 AQS 为他们提供队列服务和资源控制服务。&lt;/p&gt;
&lt;p&gt;2. AQS 依赖 LockSupport 的 park 和 unpark 为他提供线程休眠唤醒操作&lt;/p&gt;
&lt;p&gt;3. LockSupport 的 park 和 unpark 是依赖 JVM（此处语境讨论 Hotspot）调用操作系统的  pthread_mutex_lock 和 pthread_cond_wait ， 前者是保护后者和 counter 变量的互斥锁，保证只有一个线程操作 counter 变量和 condtion 上的等待队列&lt;/p&gt;
&lt;p&gt;4. pthread_mutex_wait 依赖于 操作系统的 futex 机制，多个用户态的线程（Java线程，即Mutator）通过用户空间相同，物理页共享，共同争抢受写屏障增强，线程可见性强的资源变量。如果抢不到，需要用 futex_wait 系统调用，具体是委托内核查看该变量是否还是 futex_wait 的入参（争抢失败后的值），如果是，则让内核将自己从 runqueue（Linux下的就绪进程队列）摘下来，并且状态设为 TASK_INTERRUABLE，表示不需要继续执行，但是可以用信号唤醒，如果不是，返回用户空间，再次争抢&lt;/p&gt;
&lt;p&gt;5. futex_wait 和 futex_wakeup 依赖 spin_lock保护桶bucket，其实保护bucket上的一整条链表&lt;/p&gt;
&lt;p&gt;6. 操作系统的 down , up 依赖 spin_lock 保护等待队列和资源变量&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; 硬件层&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;预备知识：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写屏障&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;简化微机架构（Intel X86）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126173307460-1762768207.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;403&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 无写屏障：&lt;/p&gt;
&lt;p&gt;　　1.假设有变量var&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126173706015-30545588.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　2. CPU A(进程/线程A) 修改 var = 1&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126173756835-1826169514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3. CPU C(进程/线程C) 读取到 var = 3， 无法立刻得到 A 的修改&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126173939142-1391104513.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有写屏障（A,B,C任意CPU在修改完某个变量后均使用写屏障）：&lt;/p&gt;
&lt;p&gt;　　上面的微机架构可以简化成：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126174156440-1466387728.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;321&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　1.A修改var&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126174317851-1888322916.png&quot; alt=&quot;&quot; width=&quot;449&quot; height=&quot;323&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2.C立刻可见&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126174400181-1980030222.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;303&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用写屏障类似：&lt;/p&gt;
&lt;p&gt;　　var = 1;&lt;/p&gt;
&lt;p&gt;　　write_fence_here(); // 写屏障&lt;/p&gt;
&lt;p&gt;作用只是将 storeBuffer中的内容马上刷出到 自己的高速缓存中，因为高速缓存有MESI缓存一致性协议，所以其他CPU读取该变量，将是一直的新值（即使穿透缓存直接读取内存也是一样一致）&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 操作系统层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 自旋锁和队列锁（一般互斥量是队列锁）&lt;/span&gt;&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.自旋锁简化：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSet(期望的旧值, 新值)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自旋锁在Linux中写作 spin_lock ，spin 本身有“连轴转”的意思。自旋锁的本质是获取不到资源就一直空转。&lt;/p&gt;
&lt;p&gt;compareAndSet : 类似下面代码，但是被包装成 一条硬件指令，所以是原子的，在他执行的中间，不能有别的CPU插手这个内存的操作。&lt;/p&gt;
&lt;p&gt;并且CAS要么全部完成，要么不执行，不能只执行一半，因为他是一条锁了总线或缓存行的硬件指令。在SMP条件下，如果不锁总线或缓存行，指令也不是原子的，比如ADD（read-write-read），只有微操作是原子的。&lt;/p&gt;
&lt;p&gt;比如将某个值打入某个寄存器中(write)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; compareAndSet (期望的旧值, 新值) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (变量值 ==&lt;span&gt; 期望的旧值) {
             变量 &lt;/span&gt;=&lt;span&gt; 新值；
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2. 队列锁简化：&lt;/p&gt;
&lt;p&gt;addToQueue： 将线程/进程的TCB/PCB(在linux是task_struct)，放入等待队列，当持有资源的线程释放资源的时候会唤醒等待队列中线程（PCB/TCP就是代表进程/线程的结构）。&lt;/p&gt;
&lt;p&gt;　　　　　　    并且将进程/线程的 状态设为非运行状态（linux中一般使用TASK_INTERRUPTABLE）, 并从就绪队列上摘下来（Linux上是runqueue）&lt;/p&gt;
&lt;p&gt;schedule ：当前线程已设置为非运行状态，所以会选择其他线程占用CPU， 当前线程在此点睡眠&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;compareAndSet(期望旧值,新值)) { // 尝试获取资源，如：compareAndSet(原资源数，原资源数 - 1)
            addToQueue(当前线程PCB/TCB); // 获取不到就进入等待队列
            schedule();// 睡眠，让出CPU
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;为什么说互斥量（队列锁）依赖自旋锁？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  &lt;span&gt;假设有以下情况：（互斥量对应资源初始值=1）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126183424859-561215223.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　如此一来，明明有资源，但是线程B却无法被唤醒。&lt;/p&gt;
&lt;p&gt;   究其原因，是因为B的 检测资源-挂入等待队列-睡眠 这三个阶段，不是原子的。线程A 可以修改资源，让资源变成1。&lt;/p&gt;
&lt;p&gt;　线程A对资源的操作插入到了线程B的操作之中，使得B的操作集合中语句&lt;span&gt;前后所处的状态不一致&lt;/span&gt;，即非原子的，受干扰的（区别于事物原子性）。&lt;/p&gt;

&lt;p&gt;   可以使用自旋锁保护 资源，在读取资源时，其他线程不能修改资源，那么释放操作就会被放到睡眠之后：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126214254398-390532575.png&quot; alt=&quot;&quot; width=&quot;698&quot; height=&quot;493&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;





&lt;p&gt; 　　为何可以使用自旋锁？ 因为自旋锁不涉及队列，如果线程无法获取自旋锁，就在CPU 上空转，直到获取为止，不需要队列去存储他们，所以不会出现多个线程修改一个队列的情况。&lt;/p&gt;
&lt;p&gt;也不会睡眠，所以也不会出现因为睡眠而错过资源的情况，像上二张图就是错过资源的情况，自选锁一直都在争抢。&lt;/p&gt;
&lt;p&gt;　　但是自旋锁的局限性也很大，空转，无意义的CPU时间被浪费。所以只有竞争不是很激烈，以及占用锁时间不长的情况，才使用自旋锁。&lt;/p&gt;
&lt;p&gt;　　这里的对队列操作，只是简单地读取一下变量，和在链表上挂一个节点，很快。&lt;/p&gt;
&lt;p&gt;　　在Linux（3.0.7）下的实现：&lt;/p&gt;
&lt;p&gt;　　up 操作是释放互斥量资源，down 操作是获取互斥量资源&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126194724590-1044184316.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126194957839-1053360876.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;265&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;futex（fast user mutex）：之所以称为 user mutex，是因为多个用户态线程通过一块共享内存存储代表资源的变量，多个用户态线程对这个资源的操作是原子性的，这是在用户态的操作。&lt;/p&gt;
&lt;p&gt;当用户线程发现自己争抢不到资源，才委托系统调用帮自己检查一下这个变量还是不是刚才读到的变量，如果是就当前线程休眠，所以是在用户态判断是否可以获取资源，不行再使用系统调用陷入内核态。比如说，我有一块内存页，被A,B两个线程共享，这个内存页里有个变量 var ，表示资源的个数，一开始是1。线程A和B都是通过CAS型的硬件指令去设置这个资源，即操作是原子性的。假如一开始A，CAS 抢夺成功，资源var 变成 0。资源B 直接通过自己的页面映射表去到这个共享的物理页，读取一下，发现是0，那么当前表示无资源可用。B将会使用系统调用，委托操作系统检查，这个资源是不是还是0，如果是就将自己休眠，否则B退出内核态回到用户态。为什么要委托操作系统再检查一次呢？因为有可能A已经释放资源了，B只要再CAS一次就能获得资源。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126212402923-737995741.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126212333924-451615460.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;406&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;futex 机制的实现比较简单，基于散列表：&lt;/p&gt;
&lt;p&gt;每一个futex_key代表一个共享变量，即资源。&lt;/p&gt;
&lt;p&gt;每一个节点包裹着 futex_key&lt;/p&gt;
&lt;p&gt;每一个futex_bucket代表一个hash桶，也就是hash表中的某个位置&lt;/p&gt;
&lt;p&gt;一个 futex_bucket 的链表中，有不同节点，说明有不同资源。比如说，“萤石” 是一种资源，“红石”也是一种资源，他们的数量所代表的变量（地址）的节点会存在于下图的同一个链表上&lt;/p&gt;
&lt;p&gt;每个bucket都有一个 锁 可以被自旋锁 锁定，锁的单位是 一个 bucket上的链表，所以当一种资源需要加锁，会锁到链表上的其他资源。&lt;/p&gt;
&lt;p&gt;设计者这么做其实并不过分，因为一个桶中的链表长度并不是很长，而且spin_lock是短时间锁，将锁粒度控制在整个散列表一个锁和每个节点一个锁之间，是对空间和时间的权衡。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126212523569-1446026071.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;futex在 线程处于内核态 ，读取资源 之前，会用 spin_lock 锁住 bucket，读取资源后发现没有资源会把自己挂入等待队列，然后释放spin_lock 。&lt;/p&gt;
&lt;p&gt;持有资源的线程在唤醒等待队列中线程之前，同样要用 spin_lock 锁住同样位置的 bucket。&lt;/p&gt;
&lt;p&gt;下图是 futex 的互斥机制，可能会有疑问：获取资源不用算进去吗？&lt;/p&gt;
&lt;p&gt;这和程序顺序有关，释放资源肯定在唤醒之前的，这是必须遵循的，因为释放完资源才会去唤醒进程去争夺&lt;/p&gt;
&lt;p&gt;那么唤醒等待队列这个操作可能在 被自旋锁保护区域的上面或者下面。&lt;/p&gt;
&lt;p&gt;如果在上面，那么资源在唤醒之前就释放了，保护区里肯定可以得到资源，免于睡眠。&lt;/p&gt;
&lt;p&gt;如果在下面，那么无论资源在唤醒之前的哪个位置，就算是在保护区里也好，只要是释放了就行。因为唤醒操作在保护区之后，而保护区里，要休眠进程已经挂到等待队列。&lt;/p&gt;
&lt;p&gt;所以唤醒操作必能唤醒要休眠进程，因为他在 入队操作之后，他能找到那些休眠的进程，从而唤醒他们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126214111724-710559861.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;448&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再向上一层看， pthread_mutex_wait 和 pthread_cond_wait，这两个函数是 Hotspot 实现 park 函数依赖的操作系统层面接口。而park函数是 LockSupport.park 方法的本地方法实现。&lt;/p&gt;
&lt;p&gt;其中 pthread_cond_wait 是把 Java线程（java应用线程，即Mutator）放入到一个等待队列，这个队列称为条件队列。对应LockSupport.park 方法。&lt;/p&gt;
&lt;p&gt;还有一个与之对应的解锁方法，pthread_cond_signal ，是唤醒这个队列上的线程。那么怎么保证对这个等待队列的操作是互斥的呢？如果不互斥，就可能发生下面这钟典型的写覆盖并发问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126220039220-1560341790.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;563&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;依赖的是 pthread_mutex_lock, 要操作队列之前先获取互斥量，操作完释放互斥量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pthread_mutex_lock(&amp;amp;&lt;span&gt;mutex);
pthread_cond_wait(&lt;/span&gt;&amp;amp;&lt;span&gt;queue);
pthread_mutex_unlock(&lt;/span&gt;&amp;amp;mutex);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pthread_mutex_lock 依赖的是上面所说的，futex, 所以 pthread_mutex_lock 就是上面说的，先在用户态读取资源，如果没资源了，就调用 SYS futex 系统调用&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;jvm（hotspot）层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;到这里，操作系统和java层面差不多要连起来了，我们再通过LockSupport向上走。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在 调用LockSupport.unpark 之后调用LockSupport.park 的话，线程不会休眠。这个点很重要，没有这个点 ，JUC中的AQS无法正常工作。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;伪代码：xchg相比xcmpchg不会比较，而是直接原子设置相应内存单元的值。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;park () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之前有资源，直接返回，并且把资源消耗掉&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (xchg(&amp;amp;counter ,1, 0) == 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 准备操作 票据和队列&lt;/span&gt;
&lt;span&gt;        pthread_mutex_lock();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可能之前 获取 mutex 的线程给予了 资源
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须要有这一句，否则可能错过释放了的资源，永远无法被唤醒&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (counter == 1&lt;span&gt;) {
            counter &lt;/span&gt;= 0&lt;span&gt;;
            pthread_mutex_unlock();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        pthread_cond_wait();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这句为什么在 pthread_cond_wait 之后呢？
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为这里是线程被唤醒之后的地方，其他线程给了一个资源，当前线程才被唤醒
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 既然被唤醒了，就要去消耗这个资源，这样一唤醒(资源+1)，一睡眠(资源-1)。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扯平之后就是当前线程的 继续运行状态&lt;/span&gt;
        counter = 0&lt;span&gt;;
        pthread_mutex_unlock();
    }

    unpark () {
        pthread_mutex_lock();
        counter &lt;/span&gt;= 1&lt;span&gt;;
        writeBarrierHere();
        pthread_cond_signal();
        pthread_mutex_unlock();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到刚才的问题：为什么unpark 之后 park 不会休眠在 AQS 中起到关键作用？&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;java层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设线程A是已经获取资源，要释放资源的线程&lt;/p&gt;
&lt;p&gt;B是尝试获取资源的线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126223616485-2056843522.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;479&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt;线程A对应下面两处代码： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126222825564-324962343.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;线程B对应下面两处代码。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126223655034-1041550163.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 极端一段假设：当线程B执行到下面的绿色处，A执行完成他 release 方法中的两处代码&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126223009875-964792311.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126222825564-324962343.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;虽然A释放了资源，但是B还是判断要休眠，于是调用LockSupport.park。于是虽然有资源但是B还是调用了park&lt;/p&gt;
&lt;p&gt;B真的就这样休眠了吗？不会，奥秘在unparkSuccessor。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126224021920-1899069684.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;他会unpark 头节点的后继。B在调用 acquireQueued之前已经在队列中，所以B的线程会被调用 LockSupport.unpark(B);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850839/202101/1850839-20210126224143295-1491698034.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;于是B在下次调用 LockSupport.park 的时候不会休眠，可以接着争抢资源！&lt;/p&gt;

&lt;p&gt;最后，JUC中的绝大多是同步工具，如Semaphore 和 CountDownLatch 都是依赖AQS的。整个JAVA应用层面到硬件原理层面的同步体系至此介绍完毕。&lt;/p&gt;



















</description>
<pubDate>Tue, 26 Jan 2021 14:50:00 +0000</pubDate>
<dc:creator>执生</dc:creator>
<og:description>先上结论： 一切互斥操作的依赖是 自旋锁（spin_lock），互斥量（semaphore）等其他需要队列的实现均需要自选锁保证临界区互斥访问。 而自旋锁需要xcmpchg等类似的可提供CAS操作的硬</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lqlqlq/p/14330313.html</dc:identifier>
</item>
<item>
<title>linux GPU上多个buffer间的同步之ww_mutex、dma_fence的使用 笔记 - -Yaong-</title>
<link>http://www.cnblogs.com/yaongtime/p/14332526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaongtime/p/14332526.html</guid>
<description>
&lt;p&gt;&lt;span&gt;WW-Mutexes&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在GPU中一次Render可能会涉及到对多个buffer的引用。&lt;/p&gt;
&lt;p&gt;所以在command buffer提交到GPU前，需要等到所有依赖的buffer可用。&lt;/p&gt;
&lt;p&gt;因为这些buffer可能被多个设备或进程所共享，所以相比单个buffer，增加了deadlock的风险。&lt;/p&gt;
&lt;p&gt;这不能简单地通过一个 buffer mutex锁来等待buffer可用，因为这些buffer通常受控于应用程序.&lt;/p&gt;
&lt;p&gt;比如Vertex shader中用到的vertex data： input attributes buffer 和 vertex index buffer，或者是fragment shader中用到的texel buffer、uniform buffer等，以及用作render的frambuffer。&lt;/p&gt;
&lt;p&gt;所以没有一个机制能保证这些buffer以相同的顺序出现在各个共享进程中。&lt;/p&gt;
&lt;p&gt;为解决这样的问题linux kernel中引入了WW-Mutexes锁。&lt;/p&gt;
&lt;p&gt;WW-Mutexes与mutex是本质上是相同的，加锁的方式也类似。&lt;/p&gt;

&lt;p&gt;WW-Mutexes的工作机制大概是，首先将要引用的buffer的锁加入到一个list里面，然后依次对list中的锁进行上锁操作，对单个锁的获取可能会失败，即该锁已被其他人占用。&lt;/p&gt;
&lt;p&gt;当出现锁获取失败时，接下来WW-Mutexes会有分两种情况来解决冲突：&lt;/p&gt;
&lt;p&gt;1.如果当前正在加锁的进程（transaction）比已加锁的进程新（younger），那么当前进程的加锁操作会被终止，停止之前释放（unlock）已成功获取到的锁，然后等待重新对list的锁进行再次加锁操作。&lt;/p&gt;
&lt;p&gt;2.如果当前正在加锁的进程（transaction）比已加锁的进程旧（older），那么当前进程会等待，直到占用该锁的进程释放锁。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;p&gt;    lock-list: B0, B1, B2, B3&lt;/p&gt;
&lt;p&gt;    locked:    B0, B1, B2&lt;/p&gt;
&lt;p&gt;    locking:   B3&lt;/p&gt;
&lt;p&gt;B:&lt;/p&gt;
&lt;p&gt;    lock-list: B1, B3, B4&lt;/p&gt;
&lt;p&gt;    locked:    B3&lt;/p&gt;
&lt;p&gt;    locking:   B1&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;1.如上有A、B两个进程，假如B比A晚（younger）启动，B进程正在对B1进行加锁，但是B1已被A进程上锁了，所以B进程加锁失败，因为B比A新，所以B需要释放到它已获取到的锁B4，然后重新等待对B1，B3，B4的加锁。&lt;/p&gt;
&lt;p&gt;2.相反，如果B比A早（older）启动，那么B对B1加锁失败后，B会等待，直到B1被A释放。接着看A的情况，A正在对B3进行加锁（假设A在B开始等待后对B3加锁），但B3已被B锁住，按同样的规则，这是A比B新，那么A要被中断，并释放掉已获取到的B0、B1、B2，并重新开始下一轮对B0, B1, B2, B3进行加锁。因为A释放掉B1，那么B就能停止等待，获取到B1了。一旦获取到B lock-list中所有buffer的锁后，B就能对这些buffer进行相应的操作，完毕后再释放掉所有的锁，A进程也就有机会重新获取到所需的锁了。&lt;/p&gt;

&lt;p&gt;使用方法：&lt;/p&gt;


&lt;div readability=&quot;110&quot;&gt;
&lt;p&gt;/* 静态初始化一个 ww_class */&lt;/p&gt;
&lt;p&gt;static DEFINE_WW_CLASS(ww_class);&lt;/p&gt;

&lt;p&gt;/* 要被加锁的对象，在其中嵌入 struct ww_mutex lock */&lt;/p&gt;
&lt;p&gt;struct obj {&lt;/p&gt;
&lt;p&gt;      struct ww_mutex lock;&lt;/p&gt;
&lt;p&gt;      /* obj data */&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;/* 需要获取的对象组成的list */&lt;/p&gt;
&lt;p&gt;struct obj_entry {&lt;/p&gt;
&lt;p&gt;      struct list_head head;&lt;/p&gt;
&lt;p&gt;      struct obj *obj;&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;int lock_objs(struct list_head *list, struct ww_acquire_ctx *ctx)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;      struct obj *res_obj = NULL;&lt;/p&gt;
&lt;p&gt;      struct obj_entry *contended_entry = NULL;&lt;/p&gt;
&lt;p&gt;      struct obj_entry *entry;&lt;/p&gt;


&lt;p&gt;     /* 加锁前对ww_acquire_ctx进行初始化 */&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;ww_acquire_init(ctx, &amp;amp;ww_class);&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;retry:&lt;/p&gt;
&lt;p&gt;      /* 一次从list中取出要加锁的对象，并对其进行加锁操作 */&lt;/p&gt;
&lt;p&gt;      list_for_each_entry (entry, list, head) {&lt;/p&gt;
&lt;p&gt;              if (entry-&amp;gt;obj == res_obj) {&lt;/p&gt;
&lt;p&gt;                      res_obj = NULL;&lt;/p&gt;
&lt;p&gt;                      continue;&lt;/p&gt;
&lt;p&gt;              }&lt;/p&gt;
&lt;p&gt;          /* 加锁操作，如果出现冲突，且当前进程较旧，会等待在 ww_mutex_lock()中，与mutex_lock()类似 */&lt;/p&gt;
&lt;p&gt;              ret = &lt;strong&gt;ww_mutex_lock(&amp;amp;entry-&amp;gt;obj-&amp;gt;lock, ctx);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;              if (ret &amp;lt; 0) {&lt;/p&gt;
&lt;p&gt;            /* 加锁失败，并且当前进行较新，当前进行将被终止继续获取剩余的锁，记录下冲突对象 */&lt;/p&gt;
&lt;p&gt;                      contended_entry = entry;&lt;/p&gt;
&lt;p&gt;                      goto err;&lt;/p&gt;
&lt;p&gt;              }&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;

&lt;p&gt;      ww_acquire_done(ctx);&lt;/p&gt;
&lt;p&gt;      return 0;&lt;/p&gt;

&lt;p&gt;err:&lt;/p&gt;
&lt;p&gt;      /* 在进行下一轮加锁前，释放掉已获取到的锁 */&lt;/p&gt;
&lt;p&gt;      list_for_each_entry_continue_reverse (entry, list, head)&lt;/p&gt;
&lt;p&gt;              &lt;strong&gt;ww_mutex_unlock&lt;/strong&gt;(&amp;amp;entry-&amp;gt;obj-&amp;gt;lock); /* 与mutex_unlock类似 */&lt;/p&gt;

&lt;p&gt;      if (res_obj)&lt;/p&gt;
&lt;p&gt;              ww_mutex_unlock(&amp;amp;res_obj-&amp;gt;lock);&lt;/p&gt;

&lt;p&gt;      if (ret == -EDEADLK) {&lt;/p&gt;
&lt;p&gt;        /* 在开始下一轮的加锁前，使用ww_mutex_lock_slow()获取上一轮有冲突的锁，ww_mutex_lock_slow()会一直休眠，直到该锁可用为止 */&lt;/p&gt;
&lt;p&gt;              /* we lost out in a seqno race, lock and retry.. */&lt;/p&gt;
&lt;p&gt;              &lt;strong&gt;ww_mutex_lock_slow&lt;/strong&gt;(&amp;amp;contended_entry-&amp;gt;obj-&amp;gt;lock, ctx);&lt;/p&gt;
&lt;p&gt;              res_obj = contended_entry-&amp;gt;obj;&lt;/p&gt;
&lt;p&gt;        /* 跳转到下一轮的加锁操作 */&lt;/p&gt;
&lt;p&gt;              goto retry;&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;      ww_acquire_fini(ctx);&lt;/p&gt;

&lt;p&gt;      return ret;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;void unlock_objs(struct list_head *list, struct ww_acquire_ctx *ctx)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    struct obj_entry *entry;&lt;/p&gt;

&lt;p&gt;    list_for_each_entry (entry, list, head)&lt;/p&gt;
&lt;p&gt;        ww_mutex_unlock(&amp;amp;entry-&amp;gt;obj-&amp;gt;lock);  //依次释放list中的锁&lt;/p&gt;

&lt;p&gt;    ww_acquire_fini(ctx);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;dma_resv&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;GEM object主要是提供了graphics memory manager，正是前文中提到的GPU buffer对象（linux kernel中还有其他的buffer管理对象）。&lt;/p&gt;
&lt;p&gt;本文主要整理了GEM的中用到的同步方法，不对其他方面做讲解。&lt;/p&gt;
&lt;p&gt;GEM中主要用到WW-Mutexes和dma-fence来做同步，而这两者被封装到dma_resv中。&lt;/p&gt;
&lt;p&gt;而dma_resv实际上是提供了所谓的隐式同步（implicit synchronization、implicit fence）。&lt;/p&gt;
&lt;p&gt;reservation object提供了管理共享和独占fence的机制。&lt;/p&gt;
&lt;p&gt;一个reservation object上只能添加一个独占fence（通常对于写操作），或添加多个共享fence（读操作）。&lt;/p&gt;
&lt;p&gt;这类似于RCU的概念，一个reservation object管理的对象能支持并发的read操作，但是只支持同时一个写入操作。&lt;/p&gt;

&lt;p&gt;Dma-fence是用在kernel内部的跨设备（cross-device）的DMA操作同步原语，比如GPU向framebuffer做rendering，而displaying在读取framebuffer前需要确保GPU已完成rendering操作，即读操作之前，确保写操作已完成。&lt;/p&gt;
&lt;p&gt;Dma-fence通常有两种状态，signaled 和 unsignaled。在这里，通常unsignaled表示buffer还在被使用，signaled表示buffer已使用完毕。&lt;/p&gt;
&lt;p&gt;因为Dma-fence是为跨设备间的同步而设计，这里有多种使用dma-fence方式：&lt;/p&gt;
&lt;p&gt;1、explicit fencing：单个dma-fence通过以文件描述符（file descriptor）的形式暴露给用户层，用户层可以把该文件描述符传递给其他进程，因为是对应用层可见的，所以叫这类dma-fence为explicit fencing。&lt;/p&gt;
&lt;p&gt;2、implicit fencing：其实就是对用户层不可见的dma-fence，通常存储在dma_resv中，在通过dma_buf在内核中传递。&lt;/p&gt;

&lt;p&gt;GEM buffer object的定义如下（省略了与本文无关的成员）：&lt;/p&gt;
&lt;div readability=&quot;27&quot;&gt;
&lt;p&gt;struct drm_gem_object {&lt;/p&gt;
&lt;p&gt;    … …&lt;/p&gt;
&lt;p&gt;  struct dma_resv *resv;&lt;/p&gt;
&lt;p&gt;  struct dma_resv _resv;&lt;/p&gt;
&lt;p&gt;    … …&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;resv&lt;/p&gt;
&lt;p&gt;    Pointer to reservation object associated with the this GEM object.&lt;/p&gt;
&lt;p&gt;    Normally (resv == &amp;amp;**_resv**) except for imported GEM objects.&lt;/p&gt;
&lt;p&gt;_resv&lt;/p&gt;
&lt;p&gt;    A reservation object for this GEM object.&lt;/p&gt;
&lt;p&gt;    This is unused for imported GEM objects.&lt;/p&gt;

&lt;p&gt;GEM中对WW-Mutexes和dma-fence是通过dma_resv来实现的，dma_resv的定义如下：&lt;/p&gt;
&lt;p&gt;struct dma_resv {&lt;/p&gt;
&lt;p&gt;    struct ww_mutex lock;&lt;/p&gt;
&lt;p&gt;    seqcount_ww_mutex_t seq;&lt;/p&gt;

&lt;p&gt;    struct dma_fence __rcu *fence_excl;&lt;/p&gt;
&lt;p&gt;    struct dma_resv_list __rcu *fence;&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;我们最终要关注的对象实际上是dma_resv。&lt;/p&gt;
&lt;p&gt;简单的说，我们关注的buffer对象，在这里就是一个GEM对象，而这个GEM对象的同步操作是由GEM中的dma_resv提供的。&lt;/p&gt;
&lt;p&gt;因为在这片文章中，不会涉及buffer同步以为的内容（例如backing memory），所以接下来在讨论dma_resv时，实际上就是在讨论单个GEM对象的同步，也即是单个buffer对象的同步。&lt;/p&gt;

&lt;p&gt;前文已将谈到，在GPU的操作中涉及到多buffer的同步互斥问题，需要一次性准备好GPU的pipeline上所需要的buffer。&lt;/p&gt;
&lt;p&gt;当使用这组buffer时，很可能这组buffer也被其他人使用。&lt;/p&gt;
&lt;p&gt;如果针对单个buffer加锁（如mutex），会有死锁的风险（deadlock），比如A、B两个进程都需要同时引用两个buffer，分别对两个buffer加锁，A获得buffer0，B获得buffer1，当A在对buffer1加锁就会死锁，同样的B也会在加锁buffer0时死锁。&lt;/p&gt;
&lt;p&gt;所以就引入了WW-Mutexes来解决这样的冲突，Linux DRM中的GEM提供了对WW-Mutexes的支持。。&lt;/p&gt;
&lt;p&gt;进一步，我们发现在GPU上，对buffer的操作有读有写，比如texture buffer、uniform buffer是只读的，framebuffer可读可写。&lt;/p&gt;
&lt;p&gt;写操作必须是独占式的，但读操作却可以被共享，所以又引入了dma-fence来达到这样的目的。&lt;/p&gt;
&lt;p&gt;dma_resv把WW-Mutexes和dma-fence相结合，达到多buffer间同步的最优化。&lt;/p&gt;

&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;kernel中已经做了很好的封装，涉及到几个函数的调用，我总结的步骤如下：&lt;/p&gt;
&lt;p&gt;1、调用drm_gem_lock_reservations()获取GPU一次rendering所用到的buffer的锁ww_mutex&lt;/p&gt;
&lt;p&gt;2、成功获取到所有buffer的ww_mutex锁后，针对每个buffer在GPU中的使用情况添加不同的dma-fence，&lt;/p&gt;
&lt;p&gt;     如果GPU中会读取某个buffer，则通过函数dma_resv_add_shared_fence()添加一个共享dma-fence；&lt;/p&gt;
&lt;p&gt;     如果GPU会写每个buffer，则通过函数dma_resv_add_excl_fence()添加一个独占的dma-fence。&lt;/p&gt;
&lt;p&gt;      注意在调用dma_resv_add_excl_fence()前，需要确保在这之前添加的share fence均处于unsignaled状态，就是确保写之前，读操作已全比完成。&lt;/p&gt;
&lt;p&gt;3、完成fence的添加后，调用drm_gem_unlock_reservations()释放这组buffer的ww_mutex&lt;/p&gt;
&lt;p&gt;4、接下来，当其他进程或设备要对某个buffer做操作前，需要判断dma-fence的情况。&lt;/p&gt;
&lt;p&gt;     假如我要读取framebuffer的内容用于屏幕显示，那就是读之前，需要确保写结束，调用函数dma_resv_get_excl_rcu(), 读取独占dma-fence，确保其为unsignaled状态。&lt;/p&gt;
&lt;p&gt;     例如，我们看看KMS的atomic中的plane frambuffer 的操作：&lt;/p&gt;
&lt;p&gt;     读取独占dma-fence：&lt;/p&gt;

&lt;div readability=&quot;28&quot;&gt;
&lt;p&gt;  int drm_gem_fb_prepare_fb(struct drm_plane *plane,&lt;/p&gt;
&lt;p&gt;                  struct drm_plane_state *state)&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;        struct drm_gem_object *obj;&lt;/p&gt;
&lt;p&gt;        struct dma_fence *fence;&lt;/p&gt;

&lt;p&gt;        if (!state-&amp;gt;fb)&lt;/p&gt;
&lt;p&gt;            return 0;&lt;/p&gt;

&lt;p&gt;        obj = drm_gem_fb_get_obj(state-&amp;gt;fb, 0);&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;&lt;span&gt;fence = dma_resv_get_excl_rcu(obj-&amp;gt;resv);&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        drm_atomic_set_fence_for_plane(state, fence);&lt;/p&gt;

&lt;p&gt;        return 0;&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;     在KMS的atomic操作中，会等待独占dma-fence被signal，代码如下：&lt;/p&gt;

&lt;div readability=&quot;56&quot;&gt;
&lt;p&gt;    int drm_atomic_helper_wait_for_fences(struct drm_device *dev,&lt;/p&gt;
&lt;p&gt;                          struct drm_atomic_state *state,&lt;/p&gt;
&lt;p&gt;                          bool pre_swap)&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;        struct drm_plane *plane;&lt;/p&gt;
&lt;p&gt;        struct drm_plane_state *new_plane_state;&lt;/p&gt;
&lt;p&gt;        int i, ret;&lt;/p&gt;


&lt;p&gt;        for_each_new_plane_in_state(state, plane, new_plane_state, i) {&lt;/p&gt;
&lt;p&gt;            if (!new_plane_state-&amp;gt;fence)&lt;/p&gt;
&lt;p&gt;                continue;&lt;/p&gt;


&lt;p&gt;            WARN_ON(!new_plane_state-&amp;gt;fb);&lt;/p&gt;


&lt;p&gt;            /*&lt;/p&gt;
&lt;p&gt;             * If waiting for fences pre-swap (ie: nonblock), userspace can&lt;/p&gt;
&lt;p&gt;             * still interrupt the operation. Instead of blocking until the&lt;/p&gt;
&lt;p&gt;             * timer expires, make the wait interruptible.&lt;/p&gt;
&lt;p&gt;             */&lt;/p&gt;
&lt;p&gt;            &lt;span&gt;&lt;strong&gt;ret = dma_fence_wait(new_plane_state-&amp;gt;fence, pre_swap);&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            if (ret)&lt;/p&gt;
&lt;p&gt;                return ret;&lt;/p&gt;


&lt;p&gt;            dma_fence_put(new_plane_state-&amp;gt;fence);&lt;/p&gt;
&lt;p&gt;            new_plane_state-&amp;gt;fence = NULL;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;


&lt;p&gt;        return 0;&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;代码简析：&lt;/p&gt;
&lt;p&gt;函数drm_gem_lock_reservations()的加锁过程就是，上文中提到的ww_mutexes的典型用法代码如下：&lt;/p&gt;
&lt;div readability=&quot;68&quot;&gt;
&lt;p&gt;int&lt;/p&gt;
&lt;p&gt;drm_gem_lock_reservations(struct drm_gem_object **objs, int count,&lt;/p&gt;
&lt;p&gt;              struct ww_acquire_ctx *acquire_ctx)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    int contended = -1;&lt;/p&gt;
&lt;p&gt;    int i, ret;&lt;/p&gt;

&lt;p&gt;   &lt;strong&gt; ww_acquire_init(acquire_ctx, &amp;amp;reservation_ww_class);&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;retry:&lt;/p&gt;
&lt;p&gt;    if (contended != -1) {&lt;/p&gt;
&lt;p&gt;        struct drm_gem_object *obj = objs[contended];&lt;/p&gt;

&lt;p&gt;        ret = &lt;strong&gt;dma_resv_lock_slow_interruptible&lt;/strong&gt;(obj-&amp;gt;resv,&lt;/p&gt;
&lt;p&gt;                                 acquire_ctx);&lt;/p&gt;
&lt;p&gt;        if (ret) {&lt;/p&gt;
&lt;p&gt;            ww_acquire_done(acquire_ctx);&lt;/p&gt;
&lt;p&gt;            return ret;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    for (i = 0; i &amp;lt; count; i++) {&lt;/p&gt;
&lt;p&gt;        if (i == contended)&lt;/p&gt;
&lt;p&gt;            continue;&lt;/p&gt;

&lt;p&gt;        ret = &lt;strong&gt;dma_resv_lock_interruptible&lt;/strong&gt;(objs[i]-&amp;gt;resv,&lt;/p&gt;
&lt;p&gt;                                acquire_ctx);&lt;/p&gt;
&lt;p&gt;        if (ret) {&lt;/p&gt;
&lt;p&gt;            int j;&lt;/p&gt;

&lt;p&gt;            for (j = 0; j &amp;lt; i; j++)&lt;/p&gt;
&lt;p&gt;                &lt;strong&gt;dma_resv_unlock&lt;/strong&gt;(objs[j]-&amp;gt;resv);&lt;/p&gt;

&lt;p&gt;            if (contended != -1 &amp;amp;&amp;amp; contended &amp;gt;= i)&lt;/p&gt;
&lt;p&gt;                dma_resv_unlock(objs[contended]-&amp;gt;resv);&lt;/p&gt;

&lt;p&gt;            if (ret == -EDEADLK) {&lt;/p&gt;
&lt;p&gt;                contended = i;&lt;/p&gt;
&lt;p&gt;                goto retry;&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;

&lt;p&gt;            ww_acquire_done(acquire_ctx);&lt;/p&gt;
&lt;p&gt;            return ret;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;ww_acquire_done&lt;/strong&gt;(acquire_ctx);&lt;/p&gt;

&lt;p&gt;    return 0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;参考文档：&lt;/p&gt;



</description>
<pubDate>Tue, 26 Jan 2021 13:50:00 +0000</pubDate>
<dc:creator>-Yaong-</dc:creator>
<og:description>原文链接：https://www.cnblogs.com/yaongtime/p/14111134.html WW-Mutexes 在GPU中一次Render可能会涉及到对多个buffer的引用。 所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yaongtime/p/14332526.html</dc:identifier>
</item>
<item>
<title>什么是中台系统？ - nylgwn</title>
<link>http://www.cnblogs.com/nylgwn/p/14332567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nylgwn/p/14332567.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://www.hualigs.cn/image/600bff207f997.jpg&quot; class=&quot;desc_img&quot;/&gt;说起中台的背景，最先想到的应该是阿里巴巴提出的“大中台、小前台”战略。阿里CEO张勇在2015年12月7日以公司内部信的方式，正式从公司集团层面提出了”大中台、小前台”的中台战略，该战略的价值为：前台可敏捷快速适应瞬息万变的市场，中台集合集团的技术和数据能力，对前台进行强力支撑。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;98.700256739409&quot;&gt;
&lt;p&gt;查看百度指数，“中台”两字的搜索量从2019年5月21日后开始陡增。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/987359/202101/987359-20210126212128529-1112269134.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这天发生了什么？这天腾讯召开了“腾讯全球数字生态大会”，在会上，多位腾讯高管提到”开放中台能力，拥抱产品互联网“。至此，“中台”2个字开始频繁出现在资讯报道、公众号文章和知乎上。&lt;br/&gt;在2019年5月21日后的2个月内，在百度指数中，与“中台“相关的高频搜索词有：什么是中台系统、中台是什么意思、数据中台、中台系统、系统、互联网中台是什么意思、中台产品经理，业务中台、中台战略、中台概念、数据中泰、什么是中台部门、数据中台是什么意思，等等。从搜索词上可以看出，搜索去向的相关词，大部分还集中在“what”的阶段，即“什么是中台”，“中台是什么意思”，“什么是中台系统“的阶段。&lt;/p&gt;
&lt;p&gt;本文，将试着回答”什么是中台系统“（中台的概念很多，本文主要讨论的是“业务中台”）&lt;/p&gt;
&lt;h2 id=&quot;一、中台概念产生的背景&quot;&gt;一、中台概念产生的背景&lt;/h2&gt;
&lt;h3 id=&quot;11、阿里的大中台，小前台战略&quot;&gt;1.1、阿里的“大中台，小前台”战略&lt;/h3&gt;
&lt;p&gt;说起中台的背景，最先想到的应该是阿里巴巴提出的“大中台、小前台”战略。阿里CEO张勇在2015年12月7日以公司内部信的方式，正式从公司集团层面提出了”大中台、小前台”的中台战略，该战略的价值为：前台可敏捷快速适应瞬息万变的市场，中台集合集团的技术和数据能力，对前台进行强力支撑。&lt;br/&gt;参考 《企业IT架构转型之道》书中第1章的描述，阿里中台的产生历程，实际上是阿里共享业务事业部演进历程，阿里并非凭空提出来1个“中台战略”，实际上是阿里一直都在对“中台”进行演化推进；演进到了2015年，中台战略不管是组织架构上，还是从技术和业务上，趋已成熟，顺势把“中台概念”归纳总结出来，并作为公司的1个战略。&lt;/p&gt;
&lt;h3 id=&quot;12、阿里共享业务事业部的发展史&quot;&gt;1.2、阿里共享业务事业部的发展史&lt;/h3&gt;
&lt;p&gt;根据《企业IT架构转型之道》的描述，阿里共享业务事业部共经历了3个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第1阶段：淘宝技术团队，作为淘宝网的技术团队，同时支撑淘宝和天猫的业务；&lt;/li&gt;
&lt;li&gt;第2阶段：淘宝技术团队改组为共享业务事业部，同时满足淘宝和天猫高压态势的业务支撑，夹缝生存；&lt;/li&gt;
&lt;li&gt;第3阶段：因聚划算的出现，集团层面决定三大电商平台（淘宝、天猫、1688）与聚划算对接，必须通过共享业务事业部，从此，共享业务事业部有了1个极强的业务抓手，并使之成为阿里巴巴集团业务的核心业务平台；&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/987359/202101/987359-20210126212431426-100373564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;共享业务事业部，就是阿里巴巴中台（更确切说，是”业务中台“）的雏形。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;13、中台解决什么问题&quot;&gt;1.3、中台解决什么问题&lt;/h3&gt;
&lt;p&gt;从阿里共享业务事业部的发展史可以看出，共享服务架构解决是企业”烟囱式“系统建设带来的3大弊端：重复功能建设和维护带来的重复投资、打通烟囱式系统间交互的集成和协作成本高昂、不利于业务沉淀和持续发展。共享服务架构的建设，摆脱了”烟囱式“系统建设方式所带来的种种发展桎梏。&lt;/p&gt;
&lt;h2 id=&quot;二、中台的本质和价值&quot;&gt;二、中台的本质和价值&lt;/h2&gt;
&lt;h3 id=&quot;21、中台的本质&quot;&gt;2.1、中台的本质&lt;/h3&gt;
&lt;p&gt;中台的本质：共性服务与资源的有效复用，概括为四个字就是：&lt;strong&gt;服务复用&lt;/strong&gt;。&lt;br/&gt;BAT各家定义的”中台“，从本质上，均可概况为服务复用。&lt;br/&gt;在2019年腾讯全球数字生态大会上，CSIG事业群总裁汤道生提到的数据中台和技术中台。其中提到“我们的用户中台，可以为客户提供用户增长、用户沟通、用户数据保护、会员管理等完整工具。以汽车行业为例，利用用户中台，我们为车企打造了智慧车销方案，覆盖售前、售中、售后全周期，提升车企获客、待客、留客的效能”&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/987359/202101/987359-20210126212700702-2072408568.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22、中台的价值&quot;&gt;2.2、中台的价值&lt;/h3&gt;
&lt;p&gt;中台的价值，即服务复用后的直接结果：“&lt;strong&gt;降本增效&lt;/strong&gt;”。&lt;br/&gt;降本增效，可以从下面几点理解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共性业务的无需重复投资建设，建设成本和维护成本降低；&lt;/li&gt;
&lt;li&gt;可以快速进行服务能力迭代，高效支撑前端业务变化；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、公司要不要做中台？&quot;&gt;三、公司要不要做中台？&lt;/h2&gt;
&lt;p&gt;从百度指数可以看出，2019年“中台”这个词很热，比较夺人眼球的资讯标题有：公司不做中台，会死吗？笔者的回答是：不会死，而且要做之前，先要判断“要不要做中台”&lt;br/&gt;回顾近期各家对中台的阐述，大家对中台的理解和定义还处在百家争鸣的阶段。笔者认为，要不要做中台，按照顺序，可以问下面2个问题：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在公司内部，有没有共性业务？&lt;br/&gt;这是前提条件，一定要在集团（公司）内部，找到共性业务或需求，最好是有较多的内部共性业务和需求。&lt;br/&gt;在目前的大厂中，共性业务最多的是2家：阿里巴巴和滴滴出行。阿里巴巴有大量的电商系统，比如天猫，淘宝，1688，闲鱼等，电商系统的共性部分包括商品中心、订单中心、用户中心、支付中心、物流中心等；滴滴出行有大量的打车系统，比如快车，出租车，专车，豪华车，代价等，打车系统的共性部分包括：司机端、乘客端、订单中心、计费中心等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;有没有需要快速响应的业务需求？&lt;br/&gt;因为在进行第1步的共性能力抽离过程中，也是需要耗费大量成本的；在考虑需不需要建中台时，需要考虑未来的收益；如果前端的业务经常需要变动，特别地，新的业务类型和之前的业务相似度很大时，就需要考虑通过中台的方式来支撑了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果以上2个问题的答案都是肯定的，那么就可以考虑建中台了。&lt;/p&gt;
&lt;h2 id=&quot;四、结语&quot;&gt;四、结语&lt;/h2&gt;
&lt;p&gt;中台的概念非常多，最热的三个中台概念是，业务中台、数据中台和技术中台。各个中台概念的解构思路类似，本文从业务中台的产生的背景、中台的价值以及要不要做业务中台这三个方面，给出了笔者的个人思考和理解。&lt;br/&gt;后续，继续推出第2篇“怎么建中台？”以及第3篇“为什么说所有中台都是业务中台”。&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;br/&gt;&lt;a href=&quot;https://www.sohu.com/a/321073156_114819&quot; target=&quot;_blank&quot;&gt;中台到达是个什么鬼？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/57717433&quot; target=&quot;_blank&quot;&gt;互联网公司中所谓中台是怎么定义的？&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 26 Jan 2021 13:36:00 +0000</pubDate>
<dc:creator>nylgwn</dc:creator>
<og:description>查看百度指数，“中台”两字的搜索量从2019年5月21日后开始陡增。 这天发生了什么？这天腾讯召开了“腾讯全球数字生态大会”，在会上，多位腾讯高管提到”开放中台能力，拥抱产品互联网“。至此，“中台”2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nylgwn/p/14332567.html</dc:identifier>
</item>
<item>
<title>Redis 实战 —— 07. 复制、处理故障、事务及性能优化 - 满赋诸机</title>
<link>http://www.cnblogs.com/manfuzhuji/p/14332498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/manfuzhuji/p/14332498.html</guid>
<description>&lt;h4 id=&quot;复制简介-p61&quot;&gt;复制简介 &lt;code&gt;P61&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;关系型数据库通常会使用一个主服务器 (master) 向多个从服务器 (slave) 发送更新，并使用从服务器来处理所有读请求。 &lt;code&gt;Redis&lt;/code&gt; 也采用了同样的方法实现自己的复制特性，并将其用作扩展性能的一种手段。 &lt;code&gt;P69&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在接收到主服务器发送的数据初始副本 (initial copy of the data) 之后，客户端每次向主服务器进行写入时，从服务器都会实时地得到更新。 &lt;code&gt;P69&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;复制-p62&quot;&gt;复制 &lt;code&gt;P62&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;对于一个正在运行的 &lt;code&gt;Redis&lt;/code&gt; 服务器，用户可以通过发送 &lt;code&gt;SLAVEOF NO ONE&lt;/code&gt; 命令来让服务器终止复制操作，不再接受主服务器的数据更新；也可以通过发送 &lt;code&gt;SLAVEOF host port&lt;/code&gt; 命令来让服务器开始复制一个新的主服务器。 &lt;code&gt;P69&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;配置选项&quot;&gt;配置选项&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# 设置本机为指定服务器的从服务器
#
# slaveof &amp;lt;master-host&amp;gt; &amp;lt;master-port&amp;gt;

# 当主服务器设置了密码保护时（用 requirepass 指定的密码）
# 从服务器服务连接主服务器需要设置相应的密码
#
# masterauth &amp;lt;master-password&amp;gt;


# 当从服务器 与主服务器失去连接 或者 正在进行复制 时
# yes: 从服务器会继续响应客户端的请求（默认 yes）
# no: 除了 INFO 和 SLAVOF 命令之外的任何请求都会
#     返回一个错误 &quot;SYNC with master in progress&quot;
#
slave-serve-stale-data yes

# 从服务器每隔一定时间会向主服务器发送 ping
# 默认 10 秒
#
# repl-ping-slave-period 10

# ping 回复 或 主服务器批量数据传输 超时时长
# 默认 60 秒
# 确保 repl-timeout 大于 repl-ping-slave-period
#
# repl-timeout 60
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;从服务器连接主服务器时的步骤-p70&quot;&gt;从服务器连接主服务器时的步骤 &lt;code&gt;P70&lt;/code&gt;&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;步骤&lt;/th&gt;
&lt;th&gt;主服务器操作&lt;/th&gt;
&lt;th&gt;从服务器操作&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;（等待命令进入）&lt;/td&gt;
&lt;td&gt;连接（或者重连）主服务器，发送 &lt;code&gt;SYNC&lt;/code&gt; 命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;开始执行 &lt;code&gt;BGSAVE&lt;/code&gt; ，并使用缓冲区记录 &lt;code&gt;BGSAVE&lt;/code&gt; 之后执行所有写命令&lt;/td&gt;
&lt;td&gt;根据配置选项 (&lt;code&gt;slave-serve-stale-data&lt;/code&gt;) 来决定是继续使用现有的数据（如果有的话）来处理客户端的命令请求，还是向客户端返回错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;code&gt;BGSAVE&lt;/code&gt; 执行完毕，向从服务器发送快照文件，并在发送期间继续使用缓冲区记录被执行的写命令&lt;/td&gt;
&lt;td&gt;丢弃所有旧数据（如果有的话），开始载入主服务器发来的快照文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;快照文件发送完毕，开始向从服务器发送存储在缓冲区里面的写命令&lt;/td&gt;
&lt;td&gt;完成对快照文件的解释操作，像往常一样开始接受命令请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;缓冲区存储的写命令发送完毕；从现在开始，每执行一个写命令，就向从服务器发送相同的写命令&lt;/td&gt;
&lt;td&gt;执行主服务器发来的所有存储在缓冲区里面的写命令；并从现在开始，接受并执行主服务器传来的每个写命令&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在实际中最好让主服务器只使用 &lt;code&gt;50% ~ 65%&lt;/code&gt; 的内存，留下 &lt;code&gt;30% ~ 45%&lt;/code&gt; 的内存用于执行 &lt;code&gt;BGSAVE&lt;/code&gt; 命令和创建记录写命令的缓冲区。 &lt;code&gt;P70&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从服务器在进行同步时，会清空自己的所有数据。&lt;/strong&gt; &lt;code&gt;P70&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Redis&lt;/code&gt; 不支持主主复制 (master-master replication)&lt;/strong&gt; &lt;code&gt;P71&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当一个从服务器连接一个已有的主服务器时，有时可以重用已有的快照文件：&lt;/strong&gt; &lt;code&gt;P71&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;步骤 3 尚未执行：所有从服务器都会接收到相同的快照文件和相同的缓冲区写命令&lt;/li&gt;
&lt;li&gt;步骤 3 正在执行或已经执行完毕：当主服务器与比较早进行连接的从服务器执行完复制所需的 5 个步骤之后，主服务器会与新连接的从服务器执行一次新的步骤 1 至步骤 5&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;主从链-p71&quot;&gt;主从链 &lt;code&gt;P71&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; 的主服务器和从服务器没有什么特别不同的地方，所以从服务器也可以拥有自己的从服务器，并由此形成主从链 (master/slave chaining) 。 &lt;code&gt;P71&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不过，如果从服务器 &lt;code&gt;X&lt;/code&gt; 拥有从服务器 &lt;code&gt;Y&lt;/code&gt; ，那么当从服务器 &lt;code&gt;X&lt;/code&gt; 在执行步骤 4 时，它将断开与从服务器 &lt;code&gt;Y&lt;/code&gt; 的连接，导致从服务器 &lt;code&gt;Y&lt;/code&gt; 需要重新连接并重新同步。 &lt;code&gt;P71&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当读请求比写请求重要，且读请求的数量远远超过一台 &lt;code&gt;Redis&lt;/code&gt; 服务器可以处理的范围时，就需要添加新的从服务器来处理读请求。随着负载不断上升，主服务器可能会无法快速地更新所有从服务器，或者因为重新连接和重新同步从服务器而导致系统超载。为了缓解这个问题，可以创建一个由 &lt;code&gt;Redis&lt;/code&gt; 主从节点 (master/slave node) 组成的中间层来分担主服务器的复制工作。 &lt;code&gt;P71&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过同时使用复制和 &lt;code&gt;AOF&lt;/code&gt; 持久化，用户可以增强 &lt;code&gt;Redis&lt;/code&gt; 对于系统崩溃的抵抗能力。 &lt;code&gt;P73&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;处理系统故障&quot;&gt;处理系统故障&lt;/h4&gt;
&lt;h5 id=&quot;验证快照文件和-aof-文件&quot;&gt;验证快照文件和 &lt;code&gt;AOF&lt;/code&gt; 文件&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;redis-check-aof [--fix] &amp;lt;file.aof&amp;gt;&lt;/code&gt; 可以检查 &lt;code&gt;AOF&lt;/code&gt; 文件，并且可以进行修复：将第一个出错命令（大部分情况下在文件末尾）及之后的所有命令删除。 &lt;code&gt;P74&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-check-dump &amp;lt;dump.rdb&amp;gt;&lt;/code&gt; 可以检查快照文件。快照文件目前无法进行修复，因为快照文件本身进行了压缩。 &lt;code&gt;P74&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;事务&quot;&gt;事务&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; 事务的作用： &lt;code&gt;P76&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;防止数据出错&lt;/li&gt;
&lt;li&gt;在某些情况下提升性能。利用事务一次性发送多个命令，然后等待所有回复出现实现流水线 (pipeline)。通过减少客户端与 &lt;code&gt;Redis&lt;/code&gt; 服务器之间的网络通信次数来提升 &lt;code&gt;Redis&lt;/code&gt; 在执行多个命令时的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关系数据库事务与 &lt;code&gt;Redis&lt;/code&gt; 事务的区别： &lt;code&gt;P76&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关系数据库：先向数据库服务器发送 &lt;code&gt;BEGIN&lt;/code&gt; ，然后执行各个相互一致 (consistent) 的读写操作，最后可以选择发送 &lt;code&gt;COMMIT&lt;/code&gt; 来确认之前的修改，或者发送 &lt;code&gt;ROLLBACK&lt;/code&gt; 来放弃之前的修改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt; ：以特殊命令 &lt;code&gt;MULTI&lt;/code&gt; 开始，然后传入多个命令，最后以 &lt;code&gt;EXEC&lt;/code&gt; 结束，并依次执行传入的命令。&lt;code&gt;Redis&lt;/code&gt; 事务不能以一致的形式读取数据，使得某一类型的问题难以解决，且无法实现二阶段提交。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过使用 &lt;code&gt;WATCH&lt;/code&gt;, &lt;code&gt;MULTI/EXEC&lt;/code&gt;, &lt;code&gt;UNWATCH/DISCARD&lt;/code&gt; 等命令，程序可以在执行某些重要操作时，通过确保自己正在使用的数据没有发生变化来避免出错。 &lt;code&gt;P78&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WATCH&lt;/code&gt;: 使用 &lt;code&gt;WATCh&lt;/code&gt; 对键进行监视之后，直到用户执行 &lt;code&gt;EXEC&lt;/code&gt; 的这段时间里面，如果有其他客户端抢先对任何被监视的键进行了替换、更新或删除等操作，那么当用户尝试执行 &lt;code&gt;EXEC&lt;/code&gt; 时，事务将失败并返回一个错误。（之后用户可选择重试事务或者放弃事务）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UNWATCH&lt;/code&gt;: 可以在 &lt;code&gt;WATCH&lt;/code&gt; 执行之后、 &lt;code&gt;MULTI&lt;/code&gt; 执行之前对连接进行重置 (reset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DISCARD&lt;/code&gt;: 可以在 &lt;code&gt;MULTI&lt;/code&gt; 执行之后、 &lt;code&gt;EXEC&lt;/code&gt; 执行之前对连接进行重置，即取消 &lt;code&gt;WATCH&lt;/code&gt; 并清空所有已入队命令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么 &lt;code&gt;Redis&lt;/code&gt; 没有实现典型的加锁功能？ &lt;code&gt;P82&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加锁是悲观锁，持有锁的客户端运行越慢，等待解锁的客户端被阻塞的时间越长&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WATCH&lt;/code&gt; 是乐观锁，客户端不必等待取得锁，只需要在事务执行失败时重试即可，乐观锁可以提高并发能力&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;非事务型流水线-non-transactional-pipeline&quot;&gt;非事务型流水线 (non-transactional pipeline)&lt;/h4&gt;
&lt;p&gt;对于无需事务的大量操作可以使用非事务型流水线，可以避免事务消耗资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Python&lt;/code&gt; 中通过修改入参即可将事务改为非事务型流水线，而 &lt;code&gt;Go&lt;/code&gt; 中根据具体框架的不同，可能需要手动封装流水线的处理逻辑。&lt;/p&gt;
&lt;h4 id=&quot;性能优化&quot;&gt;性能优化&lt;/h4&gt;
&lt;p&gt;要对 &lt;code&gt;Redis&lt;/code&gt; 的性能进行优化，首先需要弄清楚各种类型的 &lt;code&gt;Redis&lt;/code&gt; 命令能跑多块，而这一点可以通过调用 &lt;code&gt;Redis&lt;/code&gt; 附带的性能测试程序 &lt;code&gt;redis-benchmark&lt;/code&gt; 得知。 &lt;code&gt;P85&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;切记不要将输出结果看作是应用程序的实际性能，因为 &lt;code&gt;redis-benchmark&lt;/code&gt; 不会处理执行命令所获得的命令回复，所以它节约了大量用于对命令回复进行语法分析的时间。 &lt;code&gt;P86&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;可能影响性能的原因-p86&quot;&gt;可能影响性能的原因 &lt;code&gt;P86&lt;/code&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;未使用流水线：可视情况适当使用流水线&lt;/li&gt;
&lt;li&gt;对于每个命令或每组命令都创建了新的连接：使用连接池重用 &lt;code&gt;Redis&lt;/code&gt; 连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt; 的数据结构或命令不合理（&lt;code&gt;value&lt;/code&gt; 非常大，使用 &lt;code&gt;keys, hgetall&lt;/code&gt; 等）：优化数据结构和命令&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;3.5044247787611&quot;&gt;
&lt;p&gt;本文首发于公众号：满赋诸机（&lt;a href=&quot;https://mp.weixin.qq.com/s/sTPKmNwyTZagMsnX-8UCow&quot; target=&quot;_blank&quot;&gt;点击查看原文&lt;/a&gt;） 开源在 GitHub ：&lt;a href=&quot;https://github.com/idealism-xxm/reading-notes/tree/master/redis-in-action&quot; target=&quot;_blank&quot;&gt;reading-notes/redis-in-action&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/16055078/103480735-02019200-4e11-11eb-91a2-70a687781033.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 26 Jan 2021 13:21:00 +0000</pubDate>
<dc:creator>满赋诸机</dc:creator>
<og:description>复制简介 P61 关系型数据库通常会使用一个主服务器 (master) 向多个从服务器 (slave) 发送更新，并使用从服务器来处理所有读请求。 Redis 也采用了同样的方法实现自己的复制特性，并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/manfuzhuji/p/14332498.html</dc:identifier>
</item>
</channel>
</rss>