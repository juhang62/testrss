<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>跨平台导PDF，结合wkhtmltopdf很顺手 - Code综艺圈</title>
<link>http://www.cnblogs.com/zoe-zyq/p/14311462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zoe-zyq/p/14311462.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;好东西要分享，之前一直在使用wkhtmltopdf进行pdf文件的生成，常用的方式就是先安装wkhtmltopdf，然后在程序中用命令的方式将对应的html生成pdf文件，简单而且方便；但重复的编码使得想在wkhtmltopdf基础上进行封装，偶然间发现有小伙伴已经封装的还不错啦，常用的功能都已经实现，源码地址：&lt;a href=&quot;https://github.com/fpanaccia/Wkhtmltopdf.NetCore%E3%80%82&quot; target=&quot;_blank&quot;&gt;https://github.com/fpanaccia/Wkhtmltopdf.NetCore。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者将其打包成Nuget包(Wkhtmltopdf.NetCore)，直接引入使用即可；&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;既然用到了.NetCore，肯定就要考虑到跨平台兼容性，对于wkhtmltopdf之前一直是在Windows上使用，还没有在其他平台尝试；这个包封装的行不行，拉出来遛遛就知道啦，接下来就试试：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 建个API项目，引入包和兼容对应平台的wkhtmltopdf执行文件&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/kGnSEIbPalQt7Mr.png&quot; alt=&quot;image-20210120162314648&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注： 默认依赖的wkhtmltopdf执行文件需要存放在Rotativa目录下，可以自定义名称，如果自定义，需要再注册服务时指定对应的文件名；这里的wkhtmltopdf已经根据不同平台进行编译打包了，无需安装，这些文件在源码那就有；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.创建PDFTestController控制器，添加如下接口进行测试&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;首先把生成pdf的服务注入进来，后续直接使用就可以啦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/hnwxUcX7yAfQ1ND.png&quot; alt=&quot;image-20210120162846169&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就开始写接口啦，这里只是测试，代码冗余没有考虑，在实际项目中小伙伴可以根据自己需求进行封装；&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ExportPDFByHtml 接口，用html直接生成pdf文件，但这里没有保存，以文件流的形式访问，通过浏览器查看文件，可以自行下载；html模板在实际开发过程中可以单独用文件存储；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/9NamlnOkU5cq6J7.png&quot; alt=&quot;image-20210120163444523&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SavePDFByHtml接口，直接保存文件，文件名可以根据需要进行自定义；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/cNby2BjJuwgH45I.png&quot; alt=&quot;image-20210120163838699&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;TestMarginAndPageSize接口，设置Margin和PageSize参数，其他参数也可以设置；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/AelgDiVLR4yBuSt.png&quot; alt=&quot;image-20210120164237413&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConvertOptions默认封装了以下属性，小伙伴也可以自定义扩展，只要继承IConvertOptions即可，这里就不演示的，因为官方有对应的案例，下伙伴下去搞搞，wkhtmltopdf的参数挺多的，都可以进行封装使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/N1PGeUsrgyiJZOD.png&quot; alt=&quot;image-20210120170024098&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ExportByRazorView使用Razor视图的方式进行pdf文件生成，此库已经支持cshtml文件的读取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/RqwYMACEBkm86Tu.png&quot; alt=&quot;image-20210120164613249&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据指定视图生成对应的pdf效果，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/6zbF7hQWBnNYpcI.png&quot; alt=&quot;image-20210120164735123&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;ExportByRazorViewData数据动态绑定，既然支持视图，那就应该支持Razor语法，一般常用的就是数据绑定了，上面是静态的，接下来来个动态绑定的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/6iXDqYBfCIazumc.png&quot; alt=&quot;image-20210120165238787&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据指定视图生成对应的pdf效果，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/h2yPlNFoduV4D5j.png&quot; alt=&quot;image-20210120165449173&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上基本的使用演示就说那么多，使用还是很简单，小伙伴后续可以根据自己的需要进行相关扩展；当然还有其他功能，比如设置页眉/页脚等，作者提供有对应的案例；这里不说那么多，不然又是长文。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3. 小伙伴用的时候可能会遇到的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;11.1742013261&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在开发调试运行项目时，会报找不到wkhtmltopdf文件，那是因为运行时的确找不到对应的文件，将对应Rotativa下的文件设置为始终复制即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/WdbQ84evxTMzoPK.png&quot; alt=&quot;image-20210120170946016&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;在Windows下怎么玩都没问题啦，开始发布到Linux(我用的centos 7)，我擦，莫名其妙的错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/rgToKyha5dWJlDp.png&quot; alt=&quot;image-20210120171410682&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看见这个错我懵的，一顿搜索猛如虎，还是没找到答案；冷静下来，重新捋捋，原来是自己在犯傻；&lt;/p&gt;
&lt;p&gt;两个问题需要解决，1.上传到Linux下的wkhtmltopdf没有给执行权限；2.可能环境缺少对应的依赖库；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置可执行权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Linux环境下，可以通过&lt;code&gt;ll&lt;/code&gt;命令查看权限，刚开始是没有权限的，只需要执行&lt;code&gt;chmod 777 wkhtmltopdf&lt;/code&gt; 命令，执行权限就有了，如下图中红框中的x就是可执行权限；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/T3toLA9MvRcnQbm.png&quot; alt=&quot;image-20210120171951473&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装缺少的依赖库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可执行权限开启之后，别急着去访问页面，这样可能还是错误。因为可能缺少依赖库，那咋知道缺少呢，我是直接执行wkhtmltopdf，执行成功就没啥，不成功就会报缺少相关依赖，然后直接安装就行啦；执行&lt;code&gt;./wkhtmltopdf https://www.baidu.com ./test.pdf&lt;/code&gt;试试就知道啦，因为wkhtmltopdf本身是可以单独运行的，并不依赖我们写的程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.4572748267898&quot;&gt;
&lt;p&gt;当执行成功之后，然后开始访问接口导出功能，如果不出意外，遇到中文就产生乱码啦，那是因为Linux环境下缺少相关的字体文件，将对应的字体文件拷贝到Linux上即可，字体我找好了，下载地址如下：&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1jikC0DUkpEzpXL5ysjEQPA&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1jikC0DUkpEzpXL5ysjEQPA&lt;/a&gt; 提取码: &lt;strong&gt;tn4j&lt;/strong&gt; ；&lt;/p&gt;
&lt;p&gt;将下载下来的字体解压，然后拷贝到Linux下的 /usr/share/fonts目录下即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​ &lt;img src=&quot;https://i.loli.net/2021/01/20/kOMq1LByhX6J53b.png&quot; alt=&quot;image-20210120173348468&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后这样应该就没啥问题啦，剩下的就交给小伙伴自己摸索搞实践吧；&lt;/p&gt;
&lt;p&gt;​此文源码地址：&lt;a href=&quot;https://github.com/zyq025/DotNetCoreStudyDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/zyq025/DotNetCoreStudyDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​wkhtmltopdf官网地址​：&lt;a href=&quot;https://wkhtmltopdf.org/&quot; target=&quot;_blank&quot;&gt;https://wkhtmltopdf.org/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;使用还是很简单的，常规的需求没啥问题，如果需要功能定制化，小伙伴可以参考源码，自己封装一个(封装思路不难的)； 如果小伙伴有比较好的导出库，免费开源的那种，一起分享出来玩玩。&lt;/p&gt;
&lt;p&gt;一个被程序搞丑的帅小伙，关注&quot;Code综艺圈&quot;，识别关注跟我一起学~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/t2lia73ALKoHJs9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jan 2021 00:48:00 +0000</pubDate>
<dc:creator>Code综艺圈</dc:creator>
<og:description>前言 好东西要分享，之前一直在使用wkhtmltopdf进行pdf文件的生成，常用的方式就是先安装wkhtmltopdf，然后在程序中用命令的方式将对应的html生成pdf文件，简单而且方便；但重复的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zoe-zyq/p/14311462.html</dc:identifier>
</item>
<item>
<title>CodeMonkey少儿编程第2章 turnTo对象 - icuic</title>
<link>http://www.cnblogs.com/outs/p/14311451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/outs/p/14311451.html</guid>
<description>&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;了解&lt;strong&gt;对象&lt;/strong&gt;的概念&lt;/li&gt;
&lt;li&gt;了解&lt;strong&gt;方法&lt;/strong&gt;与&lt;strong&gt;对象&lt;/strong&gt;的关系&lt;/li&gt;
&lt;li&gt;掌握turnTo指令的用法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在开始本章的学习之前，我们先来复习一下上一章的知识点。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;在第1章中，我们学会了在这个游戏中最简单的两个指令。&lt;br/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;step x&lt;p&gt;其中，x既可以是正数，也可以是负数。x是正数时，上述指令可以实现让小猴子向前移动x步的功能，为负数时则是倒着走，也就是向后移动。&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;turn y&lt;p&gt;其中，y可以取值为left、right或是45这样具体的角度数值，它们分别表示让小猴子向左、向右旋转，或是向左旋转45度。&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过这两个简单的指令，我们不难总结出指令的一般格式如下：&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;指令 参数&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一定要注意的是，指令与参数之间的空格是不可以省略的。不然，计算机就看不明白了。&lt;/p&gt;
&lt;h2 id=&quot;turnto&quot;&gt;turnTo&lt;/h2&gt;
&lt;p&gt;对于turn指令，你会不会觉得使用起来不是很方便，尤其是在需要给出具体角度数据作为参数时。那么，有没有更简单好用的指令可以替代turn呢？&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;答案是有的。人类总是习惯于偷懒，所以，在这个游戏中，我们又给出了一个名叫turnTo的指令。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;它的用法如下，它同样遵循“&lt;strong&gt;指令 参数&lt;/strong&gt;”的格式。&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;turnTo 对象&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上指令可以让小猴子直接转向你指定的对象，而不必给出具体的角度数值。&lt;/p&gt;
&lt;h2 id=&quot;对象&quot;&gt;对象&lt;/h2&gt;
&lt;p&gt;这里出现了一个新的名词——对象。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;要怎么理解对象这一概念呢？你可以暂时地把对象当作物体去理解，游戏中出现的每一个物体，都是一个对象。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;每个对象都有自己独一无二的名字，把鼠标移动到相应的对象上，它的名字就会显示出来。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codemonkey.com/class/9kcpf&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/508474/202101/508474-20210122082315339-1150072426.gif&quot; alt=&quot;objects&quot; title=&quot;点击体验CodeMonkey&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了简化代码的输入，点击任一对象，它的名字就会自动书写在右侧的代码输入区里了。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;说起对象，还有两个与之相关的新名词，&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;属性是指对象的性质，拿香蕉这个对象来说，颜色就是这个对象的一个属性。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;再举一个属性的例子。让我们考虑人这一个对象，那么，他的身高、体重、性别等，也都是这个对象的属性。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;接着再介绍方法。方法就是指一个对象所能够完成的动作，譬如游戏中的小猴子monkey和即将出场的新朋友——乌龟turtle，这两个对象都能够完成移动step、旋转turn以及转向turnTo的动作，所以我们就说，step、turn、和turnTo是这两个对象所拥有的方法。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;为方便理解，再举一个方法的例子。还是考虑人这一个对象，人能够吃饭、走路、工作，所以我们就说，吃饭、走路、工作分别是人这一对象所拥有的三种不同的方法。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;问题来了，既然乌龟turtle也能够完成移动step、旋转turn以及转向turnTo的动作，可是我们要如何通过代码去控制它执行这些动作呢？&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;如何让乌龟turtle移动呢，换句话说就是，如何才能调用turtle的step方法呢，格式如下：&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;turtle.step x&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述的指令将能够控制乌龟turtle，让它移动x步。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;那么，依此类推，我们很容易得到如下的指令：&lt;/p&gt;
&lt;p&gt;不难想到,&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;monkey.step x&lt;p&gt;让小猴子移动x步，等同于前一章的step x&lt;/p&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;monkey.turn y&lt;p&gt;让小猴子旋转，等同于前一章的turn y&lt;/p&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;monkey.turnTo z&lt;p&gt;让小猴子转向z，等同于turnTo z&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;怎么样，是不是对上一章的内容又有了更深层次的理解了？&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;现在让我们来总结一下如何调用&lt;strong&gt;对象&lt;/strong&gt;的&lt;strong&gt;方法&lt;/strong&gt;：&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象名.方法名&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过以上的指令格式，可以调用对象的方法。&lt;/p&gt;
&lt;p&gt;虽然目前暂时还不会用到对象的属性，但可以先了解一下如何使用对象的属性：&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象名.属性名&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们通过上述的指令格式，使用对象的属性。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;如果你对上述内容还不能很好的理解，那就暂时先放一下，通过后续的学习，你会逐渐理解的。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;好了，本章的内容就学习到这里了。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;现在通过以下关卡来检验一下今天的学习效果吧。&lt;/p&gt;
&lt;h2 id=&quot;作业&quot;&gt;作业&lt;/h2&gt;
&lt;h2 id=&quot;本章小结&quot;&gt;本章小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;turnTo指令可以实现转向。&lt;/li&gt;
&lt;li&gt;乌龟turtle和小猴子monkey一样，都可以完成step、turn和turnTo动作。&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;对象.方法&lt;/strong&gt;和&lt;strong&gt;对象.属性&lt;/strong&gt;的方式，我们可以访问&lt;strong&gt;对象&lt;/strong&gt;的&lt;strong&gt;方法&lt;/strong&gt;和&lt;strong&gt;属性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;问答&quot;&gt;问答&lt;/h2&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;孩子还不太理解“对象”等概念怎么办？&lt;/p&gt;&lt;p&gt;不用担心，本章只是先引出&lt;strong&gt;对象&lt;/strong&gt;这一编程中的基本概念，目前孩子知道有这么一个概念就行了。&lt;br/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;为什么不给出每一关的通关代码？&lt;/p&gt;&lt;p&gt;通关的过程也是检验孩子对所学知识的掌握情况的过程，要引导孩子思考，不要直接给他答案。&lt;br/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如何访问CodeMonkey？&lt;/p&gt;&lt;p&gt;使用电脑浏览器访问http://dwz.date/dY5Y即可。&lt;br/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 22 Jan 2021 00:40:00 +0000</pubDate>
<dc:creator>icuic</dc:creator>
<og:description>目标 了解对象的概念 了解方法与对象的关系 掌握turnTo指令的用法 在开始本章的学习之前，我们先来复习一下上一章的知识点。 在第1章中，我们学会了在这个游戏中最简单的两个指令。 step x 其中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/outs/p/14311451.html</dc:identifier>
</item>
<item>
<title>1.搭建Hadoop实验平台 - 奔跑的猫哥</title>
<link>http://www.cnblogs.com/zxzkb/p/14311440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxzkb/p/14311440.html</guid>
<description>[unable to retrieve full-text content]节点功能规划 操作系统：CentOS7.2（1511） Java JDK版本：jdk-8u65-linux-x64.tar.gz Hadoop版本：hadoop-2.8.3.tar.gz 下载地址： 链接：https://pan.baidu.com/s/1iQfjO-d2ojA6mAeOOKb6CA</description>
<pubDate>Fri, 22 Jan 2021 00:37:00 +0000</pubDate>
<dc:creator>奔跑的猫哥</dc:creator>
<dc:identifier>http://www.cnblogs.com/zxzkb/p/14311440.html</dc:identifier>
</item>
<item>
<title>Dubbo的设计理念原来就藏在这三张图中 - 中间件兴趣圈</title>
<link>http://www.cnblogs.com/dingwpmz/p/14311439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dingwpmz/p/14311439.html</guid>
<description>&lt;p&gt;Dubbo在众多的微服务框架中脱颖而出，占据RPC服务框架的半壁江山，非常具有普适性，熟练掌握 Dubbo的应用技巧后深刻理解其内部实现原理，让大家能更好的掌控工作，助力职场，特别能让大家在面试中脱颖而出。&lt;/p&gt;
&lt;p&gt;那Dubbo内部的设计理念，实现原理是什么呢？&lt;/p&gt;
&lt;p&gt;本文将结合官方提供的3张图，从如下三个方面介绍其内部的核心实现、以及如何指导实践。&lt;/p&gt;
&lt;h2 id=&quot;1、服务注册与发现机制&quot;&gt;1、服务注册与发现机制&lt;/h2&gt;
&lt;p&gt;Dubbo的服务注册与发现机制如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116210800489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在Dubbo中存在4类角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Registry&lt;br/&gt;注册中心。&lt;/li&gt;
&lt;li&gt;Consumer&lt;br/&gt;服务调用者、消费端。&lt;/li&gt;
&lt;li&gt;Provider&lt;br/&gt;服务提供者。&lt;/li&gt;
&lt;li&gt;Monitor&lt;br/&gt;监控中心。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的交互流程包括如下关键步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务提供者在启动的时候向注册中心进行注册。&lt;/li&gt;
&lt;li&gt;消息消费者在启动的时候向注册中心订阅指定服务，注册中心将以某种机制（推或拉）模式告知消费端服务提供者列表。&lt;/li&gt;
&lt;li&gt;当服务提供者数量变化（服务提供者扩容、缩容、宕机等因素），注册中心需要以某种方式(推或拉)告知消费端，以便消费端进行正常的负载均衡。&lt;/li&gt;
&lt;li&gt;服务提供者、服务消费者向监控中心汇报TPS等调用数据，以便监控中心进行可视化展示等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Dubbo官方提供了多种注册中心，接下来将以使用最为普遍的Zookeeper进一步介绍注册中心的原理。&lt;/p&gt;
&lt;p&gt;首先我们来看一下Zookeeper注册中心中的数据存储目录结构，从目录结构来窥探其实现机制。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116210830727.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Dubbo Zookeeper注册中心，其目录组织结构为 /dubbo/{ServiceName}，再每一个服务名称下会有4个目录：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;providers&lt;br/&gt;服务提供者列表。&lt;/li&gt;
&lt;li&gt;consumers&lt;br/&gt;消费者列表&lt;/li&gt;
&lt;li&gt;routers&lt;br/&gt;路由规则列表，关于一个服务可以设置多个路由规则。&lt;/li&gt;
&lt;li&gt;configurators&lt;br/&gt;动态配置条目。在Dubbo中可以在不重启消费者、服务提供者的前提下动态修改服务提供者、服务消费者的配置，例如修改线程的数量，超时时间等参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于Zookeeper注册中心的实现细节如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务提供者启动时会向注册中心注册，主要是在对应服务的providers目录下增加一条记录(&lt;strong&gt;临时节点&lt;/strong&gt;)，同时监听 configurators节点。&lt;/li&gt;
&lt;li&gt;服务消费者启动时会向注册中心订阅，主要是在对应服务的consumers目录下增加一条记录(&lt;strong&gt;临时节点&lt;/strong&gt;)，同时监听 configurators、routers 目录。&lt;/li&gt;
&lt;li&gt;由于当有新的服务提供者上线后 providers 目录会增加一条记录，消费者能立马收到一个服务提供者列表变化的通知，得以将最新的服务提供者列表推送给服务调用方(消费端)；如果一个服务提供者宕机，由于创建的节点是临时节点，Zookeeper会将该节点移除，同样会触发事件，消费端得知最新的服务提供者列表，从而实现路由的动态注册与发现。&lt;/li&gt;
&lt;li&gt;当Dubbo新版本上线后，如果需要进行灰度发布，可以通过dubbo-admin等管理平台添加路由规则，最终会写入到指定服务的router节点(持久节点)，服务调用方会监听该节点的变化，从而感知最新的路由规则，将其用于服务提供者的筛选，从而实现灰度发布等功能。&lt;/li&gt;
&lt;li&gt;configurators 节点的运作机制与 router 节点一样，就不重复介绍。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;扩展思考&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1、如果注册中心全部宕机，对整个服务体系会有什么影响？&lt;/p&gt;
&lt;p&gt;如果整个注册中心全部宕机，整个&lt;strong&gt;服务调用&lt;/strong&gt;能正常工作，不会影响现有的服务消费者调用，但消费端无法发现新注册的服务提供者。&lt;/p&gt;
&lt;p&gt;2、如果注册中心内存溢出或频繁发生 Full Gc，对整个集群又会带来什么影响呢？&lt;/p&gt;
&lt;p&gt;如果频繁发生Full GC，并且如果Full GC的时间超过了Zookeeper会话的过期时间，将会造成&lt;strong&gt;非常严重的影响&lt;/strong&gt;，会触发所有临时节点被删除，消费端将无法感知服务提供者的存在，影响服务调用，将大面积抛出 No provider 等错误。&lt;strong&gt;正所谓成也临时节点、败也临时节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了避免Full Gc带来的严重后果，用于Dubbo注册中心的Zookeeper，一定会要独享，并及时做好内存、CPU等的监控与告警。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、服务调用&quot;&gt;2、服务调用&lt;/h2&gt;
&lt;p&gt;Dubbo的服务调用设计十分优雅，其实现原理如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116210853206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;服务调用，重点阐述客户端发起一个RPC服务调用时的所有实现细节，包括&lt;strong&gt;服务发现&lt;/strong&gt;、&lt;strong&gt;故障转移&lt;/strong&gt;、&lt;strong&gt;路由转发&lt;/strong&gt;、&lt;strong&gt;负载均衡&lt;/strong&gt;等方面，是Dubbo实现灰度发布的理论基础。&lt;/p&gt;
&lt;h4 id=&quot;21-服务发现&quot;&gt;2.1 服务发现&lt;/h4&gt;
&lt;p&gt;客户端在向服务端发起请求时，首先需要知道的是当前有哪些可用的服务提供者，通常有两种服务发现机制：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;静态化配置&lt;br/&gt;不妨回想一下，在Dubbo等微服务框架出现之前，一个模块调用另外一个模块通常的做法是使用一个配置文件，将服务提供的列表配置配置在配置文件中，客户端从按照配置文件中的列表进行沦陷。&lt;/p&gt;
&lt;p&gt;其&lt;strong&gt;弊端&lt;/strong&gt;也非常明显：如果需要调用的服务众多，配置文件会变得臃肿，对扩容缩容的管理、机器宕机等变更不友好，管理非常困难。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;动态发现&lt;/p&gt;
&lt;p&gt;通常基于注册中心实现服务的注册与动态发现，由于上文已详细介绍，在这里就不累述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;22-负载均衡&quot;&gt;2.2 负载均衡&lt;/h4&gt;
&lt;p&gt;客户端通过服务发现机制，能动态发现当前存活的服务提供者列表，接下来要考虑的是如果从服务提供者列表中选择一个服务提供者发起调用，这就是所谓的&lt;strong&gt;负载均衡&lt;/strong&gt;，即 LoadBalance。&lt;/p&gt;
&lt;p&gt;在Dubbo中默认提供了随机、加权随机、最少活跃连接、一致性Hash等负载均衡算法。&lt;/p&gt;
&lt;h4 id=&quot;23-路由机制&quot;&gt;2.3 路由机制&lt;/h4&gt;
&lt;p&gt;其实Dubbo中不仅提供了负载均衡机制，还提供了智能路由机制，这是实现&lt;strong&gt;Dubbo灰度发布&lt;/strong&gt;的理论基础。&lt;/p&gt;
&lt;p&gt;所谓的路由机制，是在服务提供者列表中，再设置一定的规则，进行过滤选择，负载均衡时只从路由过滤规则筛选出来的服务提供者列表中选择，为了更加形象的阐述路由机制的工作原理，给出如下示意图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116210919335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;上述设置了一条路由规则，即查询机构ID为102的查询用户请求信息，请发送到新版本，即192168.3.102上，那主要在进行负载均衡之前先执行路由规则，从原始的服务提供者列表者按照路由规则进行过滤，从中挑选出符合要求的提供者列表，然后再进行负载均衡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由机制的核心理念&lt;/strong&gt;：在进行&lt;strong&gt;负载均衡之前&lt;/strong&gt;先对&lt;strong&gt;服务提供者列表&lt;/strong&gt;运用&lt;strong&gt;路由规则&lt;/strong&gt;，得出一个参与负载均衡的提供者列表。&lt;/p&gt;
&lt;h4 id=&quot;24-故障转移&quot;&gt;2.4 故障转移&lt;/h4&gt;
&lt;p&gt;远程服务调用通常涉及到网络等因素，客户端向服务提供者发起RPC请求调用时并不一定100%成功，当调用失败后该采用何种策略呢？&lt;/p&gt;
&lt;p&gt;Dubbo提供了如下策略：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;failover&lt;br/&gt;失败后选择另外一台服务提供者进行重试，重试次数可配置，通常适合&lt;strong&gt;实现幂等服务的场景&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;failfast&lt;/p&gt;
&lt;p&gt;快速失败，失败后立即返回错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;failsafe&lt;br/&gt;调用失败后打印错误日志，返回成功，通常&lt;strong&gt;用于记录审计日志等场景&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;failback&lt;br/&gt;调用失败后，返回成功，但会在后台定时无限次重试，重启后不再重试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;forking&lt;br/&gt;并发调用，收到第一个响应结果后返回给客户端。通常适合&lt;strong&gt;实时性要求比较高的场景&lt;/strong&gt;，但浪费服务器资源，通常可以通过forks参数设置并发调用度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3、线程派发机制&quot;&gt;3、线程派发机制&lt;/h2&gt;
&lt;p&gt;Dubbo的通信线程模型入下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116210947560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;31-网络通信协议&quot;&gt;3.1 网络通信协议&lt;/h4&gt;
&lt;p&gt;网络传输通常需要自定义通信协议，通常采用 &lt;strong&gt;Header + Body 的协议设计理念&lt;/strong&gt;，并且 Header 长度固定，并且包含一个长度字段，用于记录整个协议包的大小。&lt;/p&gt;
&lt;p&gt;网络传输为了提高传输效率，可以采取对传输数据进行压缩，通常是对 body 进行序列化与压缩。&lt;/p&gt;
&lt;p&gt;Dubbo支持目前支持 java、compactedjava、nativejava、fastjson、fst、hessian2、kryo等序列化协议。&lt;/p&gt;
&lt;h4 id=&quot;32-线程派发机制&quot;&gt;3.2 线程派发机制&lt;/h4&gt;
&lt;p&gt;在Dubbo中默认会创建200个线程用于处理业务方法，所谓的线程派发机制就是IO线程如何决定何种请求转发到哪类线程中执行。&lt;/p&gt;
&lt;p&gt;目前Dubbo中&lt;strong&gt;所有的心跳包、网络读写在IO线程中执行&lt;/strong&gt;，无法通过配置进行修改。&lt;/p&gt;
&lt;p&gt;Dubbo提供了如下几种线程派发机制(Dispatcher)：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;all&lt;br/&gt;所有的请求转发到业务线程池中执行（除IO读写、心跳包）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;message&lt;br/&gt;只有请求事件在线程池中执行，其他在IO线程上执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;connection&lt;br/&gt;请求事件在线程池中执行，&lt;strong&gt;连接、断开连接事件排队执行（含一个线程的线程池）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;direct&lt;/p&gt;
&lt;p&gt;所有请求直接在IO线程中执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;温馨提示：有关线程模型，网络通信模式，可以参考笔者如下这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程派发机制之所有会有多种策略，主要是考虑&lt;strong&gt;线程切换&lt;/strong&gt;带来的开销是否能容忍，即线程切换带来的开销小于多线程处理带来的提升。&lt;/p&gt;
&lt;p&gt;例如在Dubbo中，对心跳包只需直接返回PONG包（OK），逻辑非常简单，如果将其转换到业务线程池，并不能带来性能提升，反而因为需要线程切换，带来性能损耗，故在IO线程中直接发送响应包是一个非常可取的做法。&lt;/p&gt;
&lt;p&gt;在网络编程中需要遵循一条&lt;strong&gt;最佳实践&lt;/strong&gt;：&lt;strong&gt;IO线程中不能有阻塞操作，阻塞操作需要转发到业务线程池&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;好了，本文就介绍到这里了，&lt;strong&gt;您的点赞与转发&lt;/strong&gt;是对我持续输出高质量文章最大的鼓励。&lt;/p&gt;
&lt;p&gt;欢迎关注公众号『中间件兴趣圈』，共同探究源码，交流高并发、架构经验，回复 PDF 更是可获取大量学习资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-62325a67a593e2649766657cba2d9647778.JPEG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jan 2021 00:33:00 +0000</pubDate>
<dc:creator>中间件兴趣圈</dc:creator>
<og:description>Dubbo在众多的微服务框架中脱颖而出，占据RPC服务框架的半壁江山，非常具有普适性，熟练掌握 Dubbo的应用技巧后深刻理解其内部实现原理，让大家能更好的掌控工作，助力职场，特别能让大家在面试中脱颖</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dingwpmz/p/14311439.html</dc:identifier>
</item>
<item>
<title>单元测试基础 - 老於`</title>
<link>http://www.cnblogs.com/hunternet/p/14311421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/14311421.html</guid>
<description>&lt;h4 id=&quot;11单元测试的定义&quot;&gt;1.1单元测试的定义&lt;/h4&gt;
&lt;p&gt;单元测试就是针对一个工作单元设计的测试，这里的“工作单元”是指对一个工作方法的要求。&lt;br/&gt;单元测试是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试用于判断某个特定条件(或场景)下某个特定函数的行为。&lt;/p&gt;
&lt;p&gt;例：&lt;br/&gt;你可能把一个很大的值放入一个有序list中去，然后确认该值出现在list的尾部。或者，你可能会从字符串中删除匹配某种模式的字符，然后确认字符串确实不再包含这些字符了。&lt;br/&gt;&lt;strong&gt;执行单元测试，就是为了证明某段代码的行为和开发者所期望的一致！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;  //被测方法
  public double Add(double a, double b)
  {
      return a + b;
  }      
  
  //测试方法
  [Test]
  public void AddTest()
  {
      double result = new Calculator().Add(14, 15);
      Assert.AreEqual(30,result);
  }    
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;12工作单元&quot;&gt;1.2工作单元&lt;/h4&gt;
&lt;p&gt;调用系统的一个公共方法到产生一个测试可见的最终结果,其间这个系统发生的行为总称为一个工作单元。我们通过系统的公共AP和行为就可以观察到一个可见的最终结果,无需查看系统的内部状态。一个最终结果可以是以下任何一种形式。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;被调用的公共方法回一个值(一个返回值不为空的函数)&lt;/li&gt;
&lt;li&gt;在方法调用的前后,系统的状态或行为有可见的变化,这种变化无需查询私有状态即可判断。(例如:一个以前不存在的用户可以登入系统,或者一个状态机系统的属性发生变化。)&lt;/li&gt;
&lt;li&gt;调用了一个不受测试控制的第三方系统,这个第三方系统不返回任何值,或者返回值都被忽略。(例如:调用一个第三方日志系统,这个系统不是你编写的,而且你也没有源代码。)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很多人觉得被测试的工作单元应该尽可能的小。我却不这么看，我认为工作单元这个概念意味着一个单元既可以小到只包含一个方法,也可以大到包括实现某个功能的多个类和函数。如果你的工作单元很大，却但是其最终结果对用户可见度高，易于维护也未尝不是好的测试，相反如果试图把工作单元缩到最小,最后会不得不伪造一堆东西反而会增加测试的复杂度，适得其反。&lt;/p&gt;
&lt;h3 id=&quot;2什么不是单元测试&quot;&gt;2.什么不是单元测试&lt;/h3&gt;
&lt;p&gt;单元测试其实是一门很基础也很简单的技术，然而在单元测试实践过程中，往往会对单元测试产生一些误区，进而写出一些不是单元测试的&quot;单元测试&quot; ，其中常见的主要有以下三种。&lt;/p&gt;
&lt;h4 id=&quot;21-跨边界的测试&quot;&gt;2.1 跨边界的测试&lt;/h4&gt;
&lt;p&gt;单元测试背后的思想是，仅测试这个方法中的内容，测试失败时不希望必须穿过基层代码、数据库表或者第三方产品的文档去寻找可能的答案！&lt;br/&gt;当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界，失败时会很难找到缺陷的代码。&lt;br/&gt;测试跨边界时还会产生另一个问题，当边界是一个共享资源时，如数据库。与团队的其他开发人员共享资源时，可能会污染他们的测试结果！&lt;/p&gt;
&lt;h4 id=&quot;22-不具有针对性的测试&quot;&gt;2.2 不具有针对性的测试&lt;/h4&gt;
&lt;p&gt;如果发现所编写的测试对一件以上的事情进行了测试，就可能违反了“单一职责原则”。从单元测试的角度来看，这意味着这些测试是难以理解的非针对性测试。随着时间的推移，向类或方法种添加了更多的不恰当的功能后，这些测试可能会变的非常脆弱。诊断问题也将变得极具有挑战性。&lt;br/&gt;如：StringUtility中计算一个特定字符在字符串中出现的次数，它没有说明这个字符在字符串中处于什么位置也没有说明除了这个字符出现多少次之外的其他任何信息，那么这些功能就应该由StringUtility类的其它方法提供！同样，StringUtility类也不应该处理数字、日期或复杂数据类型的功能！&lt;/p&gt;
&lt;h4 id=&quot;23-不可预测的测试&quot;&gt;2.3 不可预测的测试&lt;/h4&gt;
&lt;p&gt;单元测试应当是可预测的。在针对一组给定的输入参数调用一个类的方法时，其结果应当总是一致的。有时，这一原则可能看起来很难遵守。例如：正在编写一个日用品交易程序，黄金的价格可能上午九时是一个值，14时就会变成另一个值。&lt;br/&gt;而好的设计原则就是将不可预测的数据的功能抽象到一个可以在单元测试中模拟(Mock)的类或方法中&lt;/p&gt;
&lt;h4 id=&quot;24-集成测试&quot;&gt;2.4 集成测试&lt;/h4&gt;
&lt;p&gt;其实上面三种测试已经到了集成测试的领域。任何测试,如果它运行速度不快,结果不稳定,或者要用到被测试单元的一个或多个真实依赖物,我们就认为它是集成测试。&lt;br/&gt;集成测试是对一个工作单元进行的测试,这个测试对被测试的工作单元没有完全的控制,并使用该单元的一个或多个真实依赖物,例如时间、网络、数据库、线程或随机数产生器等。&lt;br/&gt;集成测试本身并不是一种坏事，反而其具有和单元测试一样高的地位，但是在实践过程中我们把集成测试和单元测试分离开来还是很重要的。&lt;/p&gt;
&lt;h3 id=&quot;3优秀的单元测试有哪些特性&quot;&gt;3.优秀的单元测试有哪些特性&lt;/h3&gt;
&lt;p&gt;单元测试是非常有魔力的魔法，也是一把双刃剑。使用得当，可以很有效的提高我们的编码质量，提升研发效率，但是如果使用不恰当亦会浪费大量的时间在测试编码、维护和调试上从而影响代码和整个项目，徒劳而无功！&lt;br/&gt;因此做好单元测试至关重要！而想要做好单元测试，我们首先应该知道优秀的单元测试有哪些特性。&lt;br/&gt;一个好的单元测试一定是有以下几个特性的&lt;br/&gt;• 自动化&lt;br/&gt;• 彻底的&lt;br/&gt;• 可重复的&lt;br/&gt;• 独立的&lt;br/&gt;• 专业的&lt;br/&gt;回顾一下自己以前写过的单元测试问自己几个问题。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它是不是可以自动化一键运行、并且可以重复运行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;几个月后它是不是仍可以运行、并且得到期望的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它是否可以在几分钟内运行结束&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在运行之前你是否不需要需要进行一系列的配置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每次运行是否能够得到相同的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;外部的系统因素是否不会影响你的测试结果&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试代码是否很简单就可以编写完成&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果针对以上问题有任何一个的回答是“否”，那么你应该好好的思考一下到底如何去做好单元测试。&lt;/p&gt;
&lt;h3 id=&quot;4-如何进行单元测试&quot;&gt;4. 如何进行单元测试&lt;/h3&gt;
&lt;p&gt;对于一个方法或者类，乍一看就能找出其隐藏深处的bug是很不容易的，因此在bug挖掘方面通常会有一些经验和套路，来指导我们更好的进行单元测试。&lt;/p&gt;
&lt;h4 id=&quot;31-测试哪些内容&quot;&gt;3.1 测试哪些内容&lt;/h4&gt;
&lt;p&gt;一般来说有六个值得测试的具体方面，可以把这六个方面统称为Right-BICEP:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Right——结果&lt;br/&gt;对于单元测试测试而言,首要的也是最明显的任务就是查看所期望的结果是否正确，例如判断一个方法的返回值是否为序列中的最大值......&lt;/li&gt;
&lt;li&gt;B——边界条件&lt;br/&gt;找边界条件是做单元测试中最有价值的工作之一,因为bug一般就出现在边界上。关于边界条件2会有详细总结&lt;/li&gt;
&lt;li&gt;I——检查反向关联&lt;br/&gt;对于一些方法,我们可以使用反向的逻辑关系来验证它们。例如,你可以用对结果进行平方的方式来检查一个计算平方根的函数,然后测试结果是否和原数据很接近&lt;/li&gt;
&lt;li&gt;C——交叉检查&lt;br/&gt;有些时候我们实现一个问题会有不同的算法，在生产系统中我们使用一种算法，而在测试中我们可以使用另一种算法来验证其结果是否一致。&lt;/li&gt;
&lt;li&gt;E——强制产生错误条件&lt;br/&gt;在实际运行过程中,有时候会发生一些意外的难以避免的错误，例如磁盘会满,网络连线会断开.....从而导致程序崩溃。我们应该在测试中强制引发错误,来测试代码是否能够按照预期处理这些异常。&lt;/li&gt;
&lt;li&gt;P——是否满足性能条件&lt;br/&gt;性能同样是我们测试过程中需要验证的指标&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;32-注意边界条件&quot;&gt;3.2 注意边界条件&lt;/h4&gt;
&lt;p&gt;代码中的许多Bug经常出现在边界条件附近，对于边界条件的测试我们可以从CORRECT七个方面进行考虑&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一致性----值是否满足预期的格式&lt;/li&gt;
&lt;li&gt;有序性----一组值是否满足预期的排序要求&lt;/li&gt;
&lt;li&gt;区间性----值是否在一个合理的最大值最小值范围内&lt;/li&gt;
&lt;li&gt;引用、耦合性----代码是否引用了一些不受代码本身直接控制的外部因素&lt;/li&gt;
&lt;li&gt;存在性----值是否存在（例如：非Null，非零，存在于某个集合中）&lt;/li&gt;
&lt;li&gt;基数性----是否恰好具有足够的值&lt;/li&gt;
&lt;li&gt;时间性----所有事情是否都按照顺序发生的？是否在正确的时间、是否及时&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;33-使用mock对象&quot;&gt;3.3 使用Mock对象&lt;/h4&gt;
&lt;p&gt;单元测试的目标是验证我们的工作单元，但是如果这个工作单元依赖一些其他的对象或是一些难以操控的东西，比如网络、数据库等。这时我们就要使用mock对象，使得在运行UT的时候使用的那些难以操控的东西实际上是我们mock的对象，而我们mock的对象则可以按照我们的意愿返回一些值用于测试。通俗来讲，Mock对象就是真实对象在我们调试期间的测试品。&lt;strong&gt;对于外部对象内的逻辑我们并不关心，我们只需要让它给我们返回我们想要的值，来验证我们的业务逻辑即可&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;IFileExtensionManager fileManager;

public bool IsValidFileName(){
    //获取文件扩展名
    string extName=fileManager.GetExtName();
    if(extName==&quot;jpg&quot;){
        return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上示例，假设从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。&lt;br/&gt;注意，这里我们要测试的逻辑是如果扩展名是jpg就返回true，否则返回false。而对于fileManager.GetExtName()方法内部的逻辑是什么样的的我们是不关心的，我们只需要mock这个方法使其返回我们想要的值就可以了。&lt;br/&gt;关于具体如何去mock工作单元中的一些外部依赖，会在存根与模拟对象里面详细进行总结。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文总结了什么是单元测试、什么不是单元测试以及优秀的单元测试有哪些特性，简单介绍了如何进行单元测试。&lt;br/&gt;编写差劲的单元测试是没有意义的，我看到过很多公司尝试去实践单元测试，但最终要么在某个阶段放弃了,要么并没有真正执行单元测试。最终还是依赖集成测试或者人工测试来发现问题，不得不以失败而告终，并堂而皇之的认为单元测试是一个耗时好力而无功的鸡肋东西。&lt;br/&gt;因此如果你想要真正的去实践单元测试，那么必须充分的理解到底什么是单元测试，已经如何去更好的进行实践优秀的单元测试。&lt;br/&gt;而对于如何更好的去实践单元测试，后续会结合实践用更多的篇幅去总结分享。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jan 2021 00:07:00 +0000</pubDate>
<dc:creator>老於`</dc:creator>
<og:description>1.1单元测试的定义 单元测试就是针对一个工作单元设计的测试，这里的“工作单元”是指对一个工作方法的要求。 单元测试是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。通常而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunternet/p/14311421.html</dc:identifier>
</item>
<item>
<title>MyBatis初级实战之六：一对多关联查询 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14311404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14311404.html</guid>
<description>[unable to retrieve full-text content]欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等； 本篇概览 本文是《MyBatis初级实战》系列的第六篇，继续实践从多表获取数据； 回顾上一篇，</description>
<pubDate>Thu, 21 Jan 2021 23:48:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<dc:identifier>http://www.cnblogs.com/bolingcavalry/p/14311404.html</dc:identifier>
</item>
<item>
<title>日志到底该如何打印？ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/14311382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/14311382.html</guid>
<description>&lt;p&gt;最近在做新项目，一直在加班，期间遇到很多问题，我把一部分归类为设计原则的问题，当然，这里的设计原则不是特指那个SOLID五大原则，这里是指更广义的设计原则，不喜勿喷。&lt;/p&gt;
&lt;p&gt;今天，我们来看第一个问题: 日志到底该如何打印？&lt;/p&gt;
&lt;p&gt;咋一看，这个问题很简单，其实不然，我随手写几个，您看看。&lt;/p&gt;
&lt;p&gt;log.error(&quot;xxxxx&quot;);&lt;/p&gt;
&lt;p&gt;log.error(e.getMessage());&lt;/p&gt;
&lt;p&gt;log.error(&quot;xxxxx&quot;, e.getMessage());&lt;/p&gt;
&lt;p&gt;log.error(&quot;xxxxx {}&quot;, e.message());&lt;/p&gt;
&lt;p&gt;log.error(&quot;xxxxx {}&quot;, e);&lt;/p&gt;
&lt;p&gt;好了，就随便写这么多，地铁上打字不太方便，您认为上面那些日志打印方式哪些是正确的？&lt;/p&gt;
&lt;p&gt;实话说，没有正确的，全是错的。怎么样，是不是踩坑了，是不是给别人埋过这样的坑。&lt;/p&gt;
&lt;p&gt;那么，怎么打印日志才是正确的呢？&lt;/p&gt;
&lt;p&gt;如果您使用的是slf4j，那么，只有下面这一种是正确的:&lt;/p&gt;
&lt;p&gt;log.error(&quot;xxxxx, userId={}, xxParam={}&quot;, userId, xxParam, e);&lt;/p&gt;
&lt;p&gt;首先，打印日志必须带上上下文信息，比如，用户ID，关键参数，同时，如果是捕获异常里面打印的日志，必须把原来的e打印出来，否则，排查日志想死的心都有了。&lt;/p&gt;
&lt;p&gt;比如，我最近就遇到一个同学，他把远程调用用一个try catch包着，并在catch中捕获了异常，打印了日志&quot;远程调用错误xxx&quot;，呵呵，有一次请求失败，非要说远程调用失败，对方出错了，对方说我没收到请求呀，两人撕逼，最后找到我，我一看这代码，说了一句，把e打印出来再重新调用，结果可想而知，他自己空指针了，呵呵了。&lt;/p&gt;
&lt;p&gt;再说回上面的打印方式，有的同学可能会质疑，前面引号里明明是两个大括号，后面却出现3个变量，确定这个e能打印出来？&lt;/p&gt;
&lt;p&gt;你是在怀疑我吗？自己看源码去。源码中已经明确写了如果最后一个参数是Exception类型，就不会参与字符串格式化，会单独拿出来打印，同时，可以打印出堆栈信息。看源码去吧，我在地铁上，就不截图了。&lt;/p&gt;
&lt;p&gt;你以为本篇文章就结束了吗？那你就错了。&lt;/p&gt;
&lt;p&gt;有没有更优雅的日志打印方式呢？&lt;/p&gt;
&lt;p&gt;我认为，最好的日志是以解决问题的方式打印日志。&lt;/p&gt;
&lt;p&gt;怎么理解呢？&lt;/p&gt;
&lt;p&gt;我们以服务注册为例，当注册中心地址不通的时候，我们能不能这样打印呢？&lt;/p&gt;
&lt;p&gt;&quot;从 112.112.112.112 到注册中心 113.113.113.113的网络不通，请检查注册中心是否启动，网络防火墙是否畅通，balabala&quot;。&lt;/p&gt;
&lt;p&gt;这样的方式就比较好，给使用者提供解决方案，你只要按着给出的方案排查一下，大概率就能解决了你的问题，这才是最优雅的打印姿势。&lt;/p&gt;
&lt;p&gt;好了，今天的内容就到这里，嗐，差点坐过站。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jan 2021 22:39:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>最近在做新项目，一直在加班，期间遇到很多问题，我把一部分归类为设计原则的问题，当然，这里的设计原则不是特指那个SOLID五大原则，这里是指更广义的设计原则，不喜勿喷。 今天，我们来看第一个问题: 日志</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/14311382.html</dc:identifier>
</item>
<item>
<title>Dubbo中的统一契约是如何实现的？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14311281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14311281.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;之前，很多小伙伴私信我：如何才能快速的掌握Dubbo的核心原理和源码。所以，我写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjU0OTM1OA==&amp;amp;mid=2247490192&amp;amp;idx=1&amp;amp;sn=afedf86349f76c864f42b2b48a245c62&amp;amp;chksm=cf55ad91f8222487088c333cb7160dd63496f9754c5533dbc868d9ac875101cc67dc1483c0da&amp;amp;token=1511921100&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;我是如何在短期内快速掌握Dubbo的原理和源码的（纯干货）？&lt;/a&gt;》。对于Dubbo的源码解析系列文章，我也在思考如何让源码解析的文章变得更加简单易懂，所以，我调整了写Dubbo源码解析文章的策略，力求让小伙伴们能够以更简单、易懂的方式彻底掌握Dubbo源码。今天，我们先说说Dubbo中的统一契约是如何实现的。&lt;/p&gt;
&lt;p&gt;文章已收录到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sunshinelyz/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://github.com/sunshinelyz/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/binghe001/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://gitee.com/binghe001/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;不得不说的url&quot;&gt;不得不说的URL&lt;/h2&gt;
&lt;p&gt;URL全称为统一资源定位符，它能够在互联网中定位到唯一的一个网络地址。URL的格式如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;protocol://username:password@host:port/path?key=value&amp;amp;key=value
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，各个部分的简要说明如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;protocol：URL的协议。最常见的协议就是HTTP和HTTPS，其他的还有FTP、WS、FILE、SMTP等。&lt;/li&gt;
&lt;li&gt;username：用户名。&lt;/li&gt;
&lt;li&gt;password：密码。&lt;/li&gt;
&lt;li&gt;host：主机，通常是域名或者IP地址。&lt;/li&gt;
&lt;li&gt;port：主机的端口号。&lt;/li&gt;
&lt;li&gt;path：请求的目标文件的路径。&lt;/li&gt;
&lt;li&gt;parameters：请求的具体参数信息，这里为key=value&amp;amp;key=value。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是我们互联网中的URL的简单说明。&lt;/p&gt;
&lt;p&gt;那么，在Dubbo内部，大量的方法接收的参数都是以URL进行封装的，那么，URL在Dubbo内部到底起到了什么作用呢？我们继续往下看。&lt;/p&gt;
&lt;h2 id=&quot;dubbo中的url&quot;&gt;Dubbo中的URL&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;总的来说，在Dubbo内部，服务提供者Provider会将自身的相关信息封装成URL注册到Zookeeper或其他注册中心中，从而对外暴露自己提供的服务。而服务消费者Consumer也会通过URL的形式向Zookeeper或其他注册中心订阅自己想要调用的服务。而在Dubbo的SPI实现中，URL又会参与扩展实现的逻辑处理。所以说，URL在Dubbo的实现中是非常重要的。也可以这么说，Dubbo中的URL就是Dubbo的统一契约。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来看一下Dubbo中的URL具体长什么样吧，通过调试Dubbo自带Provider的示例源码，我们可以看到在Dubbo中的URL如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;dubbo://192.168.175.1:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;amp;application=dubbo-demo-annotation-provider&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=org.apache.dubbo.demo.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=15012&amp;amp;release=&amp;amp;side=provider&amp;amp;timestamp=1610857629484
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这也是Provider注册到Zookeeper或者其他注册中心的信息。各个部分的说明如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dubbo：使用的是dubbo协议。&lt;/li&gt;
&lt;li&gt;host：主机的IP地址为192.168.175.1。&lt;/li&gt;
&lt;li&gt;port：端口号为20880。&lt;/li&gt;
&lt;li&gt;path：这里的请求路径为：org.apache.dubbo.demo.DemoService&lt;/li&gt;
&lt;li&gt;parameters：请求的参数信息，这里为：anyhost=true&amp;amp;application=dubbo-demo-annotation-provider&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=org.apache.dubbo.demo.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=15012&amp;amp;release=&amp;amp;side=provider&amp;amp;timestamp=1610857629484。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然Dubbo是向Zookeeper或其他注册中心注册这些信息的，那Dubbo内部是如何对URL进行封装的呢。&lt;/p&gt;
&lt;p&gt;在dubbo-common模块中，有一个URL类专门用于封装URL，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117200650477.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在URL类中，我们来看一个核心构造函数，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public URL(String protocol,
           String username,
           String password,
           String host,
           int port,
           String path,
           Map&amp;lt;String, String&amp;gt; parameters,
           Map&amp;lt;String, Map&amp;lt;String, String&amp;gt;&amp;gt; methodParameters) {
    if (StringUtils.isEmpty(username)
        &amp;amp;&amp;amp; StringUtils.isNotEmpty(password)) {
        throw new IllegalArgumentException(&quot;Invalid url, password without username!&quot;);
    }
    this.protocol = protocol;
    this.username = username;
    this.password = password;
    this.host = host;
    this.port = Math.max(port, 0);
    this.address = getAddress(this.host, this.port);

    // trim the beginning &quot;/&quot;
    while (path != null &amp;amp;&amp;amp; path.startsWith(&quot;/&quot;)) {
        path = path.substring(1);
    }
    this.path = path;
    if (parameters == null) {
        parameters = new HashMap&amp;lt;&amp;gt;();
    } else {
        parameters = new HashMap&amp;lt;&amp;gt;(parameters);
    }
    this.parameters = Collections.unmodifiableMap(parameters);
    this.methodParameters = Collections.unmodifiableMap(methodParameters);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，Dubbo对于URL的核心封装，基本与互联网中的URL封装是一致的。&lt;/p&gt;
&lt;p&gt;在Dubbo的dubbo-common模块提供了处理URL的工具类：URLBuilder和URLStrParser。如下所示。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203338682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个类的实现还是比较简单的，小伙伴们可以自行阅读Dubbo的源码。&lt;/p&gt;
&lt;p&gt;接下来，我们一起来看看在Dubbo内部，URL是如何实现统一契约的？&lt;/p&gt;
&lt;h2 id=&quot;dubbo中url的实际应用&quot;&gt;Dubbo中URL的实际应用&lt;/h2&gt;
&lt;p&gt;这里，我们主要通过三方面来简单聊聊URL在Dubbo内部的实际应用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URL在SPI中的应用。&lt;/li&gt;
&lt;li&gt;URL在服务注册中的应用。&lt;/li&gt;
&lt;li&gt;URL在服务发现中的应用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;url在spi中的应用&quot;&gt;URL在SPI中的应用&lt;/h3&gt;
&lt;p&gt;稍微了解过Dubbo的小伙伴都知道，Dubbo具有高度的可扩展性，而这种扩展性是基于Dubbo自身的SPI来实现的。在Dubbo实现的SPI中，URL又起到了非常重要的作用。&lt;/p&gt;
&lt;p&gt;在Dubbo SPI的实现中，一个典型的场景就是被@Adaptive注解修饰的接口方法，例如，在dubbo-registry-api 模块中的RegistryFactory接口中的getRegistry()方法上被@Adaptive({&quot;protocol&quot;})注解修饰。如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203350901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明RegistryFactory接口中的getRegistry()方法是一个适配器方法，Dubbo在运行的过程中，会为getRegistry()方法动态生成&lt;code&gt;RegistryFactory$Adaptive&lt;/code&gt;类型。例如，生成的&lt;code&gt;RegistryFactory$Adaptive&lt;/code&gt;类型如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RegistryFactory$Adaptive
              implements RegistryFactory { 
    public Registry getRegistry(org.apache.dubbo.common.URL arg0) { 
        if (arg0 == null) throw new IllegalArgumentException(&quot;&quot;); 
        org.apache.dubbo.common.URL url = arg0; 
        String extName = (url.getProtocol() == null ? &quot;dubbo&quot; :  url.getProtocol()); 
        if (extName == null) 
            throw new IllegalStateException(&quot;&quot;); 
        RegistryFactory extension = (RegistryFactory) ExtensionLoader.getExtensionLoader(RegistryFactory.class).getExtension(extName); 
        return extension.getRegistry(arg0); 
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码相对来说还是比较容易理解的，生成的RegistryFactory$Adaptive会自动实现getRegistry()方法，在getRegistry()方法中，会获取URL中的protocol参数来确定URL的协议，如果获取的protocol为空，则使用默认的dubbo协议，有了这个协议，就能够通过SPI动态加载具体的扩展实现类。&lt;/p&gt;
&lt;p&gt;我们在Dubbo的dubbo-registry-api模块中找到RegistryProtocol类，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203401969.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到其中的getRegistry()方法并打上断点，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203412138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，debug启动Dubbo的Provider示例，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203422217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，此时使用的protocol协议为zookeeper。有关Dubbo中SPI的实现，我们后面再详细剖析，今天，小伙伴们有个大致的了解即可。&lt;/p&gt;
&lt;h3 id=&quot;url在服务注册中的应用&quot;&gt;URL在服务注册中的应用&lt;/h3&gt;
&lt;p&gt;在Dubbo中的服务注册实现中，URL同样起到了非常重要的作用。这里，我使用的注册中心是Zookeeper，所以，我们在dubbo-registry-zookeeper模块中找到ZookeeperRegistry类，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203433148.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到其中的doRegister()方法，打上断点，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021011720344271.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;debug启动Dubbo自带的provider示例，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203451683.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在注册到Zookeeper中的URL中，包含了protocol协议、host主机名、port端口号、path请求路径，parameters参数等信息。&lt;/p&gt;
&lt;h3 id=&quot;url在服务发现中的应用&quot;&gt;URL在服务发现中的应用&lt;/h3&gt;
&lt;p&gt;Dubbo中服务的消费者Consumer在启动时，会向Zookeeper注册中心订阅自身需要调用的服务，那具体是如何通过URL订阅的呢？我们同样在dubbo-registry-zookeeper模块中的ZookeeperRegistry类中找到doSubscribe()方法。在doSubscribe()方法中打上断点，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203504728.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动Dubbo自带的Consumer示例，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117203514749.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，Dubbo的Consumer会向Zookeeper传入如下参数进行服务的订阅操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;consumer://192.168.175.1/org.apache.dubbo.demo.DemoService?application=dubbo-demo-annotation-consumer&amp;amp;category=providers,configurators,routers&amp;amp;dubbo=2.0.2&amp;amp;init=false&amp;amp;interface=org.apache.dubbo.demo.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=15184&amp;amp;side=consumer&amp;amp;sticky=false&amp;amp;timestamp=1610860963037
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的protocol为consumer，表示订阅协议。category表示要订阅的分类，这里是providers,configurators,routers三个分类。interface表示要订阅的接口服务，这里是org.apache.dubbo.demo.DemoService。methods表示要订阅的方法，这里是sayHello,sayHelloAsync。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有一点需要注意的是：在服务注册的过程中，Dubbo会将URL转化为Zookeeper路径将信息注册到Zookeeper中；在服务发现的过程中，Dubbo会将URL转化为Zookeeper路径，从而监听Zookeeper目录的变化来订阅相关的服务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总之，在Dubbo内部通过URL实现了统一的契约。你学会了吗？&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，大家有啥问题可以在下方留言，也可以加我微信：sun_shine_lyz，一起交流技术，一起进阶，一起牛逼~~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jan 2021 16:44:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 之前，很多小伙伴私信我：如何才能快速的掌握Dubbo的核心原理和源码。所以，我写了一篇《我是如何在短期内快速掌握Dubbo的原理和源码的（纯干货）？》。对于Dubbo的源码解析系列文章，我也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14311281.html</dc:identifier>
</item>
<item>
<title>playwright自动化项目搭建 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/14311181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/14311181.html</guid>
<description>[unable to retrieve full-text content]这是关于playwright系列介绍的最后一篇。搭建基于 playwright 的自动化项目。</description>
<pubDate>Thu, 21 Jan 2021 15:45:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:identifier>http://www.cnblogs.com/fnng/p/14311181.html</dc:identifier>
</item>
<item>
<title>利用容器逃逸实现远程登录k8s集群节点 - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/14311155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/14311155.html</guid>
<description>&lt;p&gt;某天，&lt;/p&gt;
&lt;p&gt;某鱼说要吃瞄，&lt;/p&gt;
&lt;p&gt;于是......&lt;/p&gt;
&lt;p&gt;李国宝：边缘计算k8s集群SuperEdge初体验&lt;br/&gt;​&lt;br/&gt;zhuanlan.zhihu.com&lt;br/&gt;图标&lt;/p&gt;
&lt;p&gt;照着上一篇文章来说，我这边边缘计算集群有一堆节点。&lt;/p&gt;
&lt;p&gt;每个节点都在不同的网络环境下。&lt;/p&gt;
&lt;p&gt;他们的共同点都是可以访问内网，&lt;/p&gt;
&lt;p&gt;部分是某云学生主机，&lt;/p&gt;
&lt;p&gt;部分是跑在家庭网络环境下的虚拟机，&lt;/p&gt;
&lt;p&gt;甚至假设中还有一些是树莓派之类的机器。&lt;/p&gt;
&lt;p&gt;所以他们另一个共同点是，基本都没有公网IP。&lt;/p&gt;
&lt;p&gt;这样一来，我要实现远程登录到某些节点搞事的时候，&lt;/p&gt;
&lt;p&gt;只有内网穿透这一条路子了。&lt;/p&gt;
&lt;p&gt;使用frp进行内网穿透 - 少数派&lt;br/&gt;​&lt;br/&gt;sspai.com&lt;br/&gt;图标&lt;br/&gt;&lt;a href=&quot;https://github.com/fatedier/frp&quot; target=&quot;_blank&quot;&gt;https://github.com/fatedier/frp&lt;/a&gt;&lt;br/&gt;​&lt;br/&gt;github.com&lt;/p&gt;
&lt;p&gt;内网穿透倒没什么，在公司使用这货长期跑了两年垮大洋穿透也很稳定。&lt;/p&gt;
&lt;p&gt;只是...&lt;/p&gt;
&lt;p&gt;只是...&lt;/p&gt;
&lt;p&gt;只是...&lt;/p&gt;
&lt;p&gt;要一台台机器配置一次，要维护一个稳定的公网服务器作为桥接。&lt;/p&gt;
&lt;p&gt;就是...麻烦了点。&lt;/p&gt;
&lt;p&gt;然后想了下。&lt;/p&gt;
&lt;p&gt;当前的kube superedge边缘计算集群本身就实现了4层和7层的内网穿透，&lt;/p&gt;
&lt;p&gt;理论上直接使用它的能力也可以做到远程登录的。&lt;/p&gt;
&lt;p&gt;于是开始研究了一下怎么实现在只有kubectl环境的机器上，&lt;/p&gt;
&lt;p&gt;直接登录k8s容器集群的node节点。&lt;/p&gt;
&lt;p&gt;搜了一波之后首先发现的是这个项目。&lt;/p&gt;
&lt;p&gt;A kubectl plugin to SSH into Kubernetes nodes using a SSH jump host Pod&lt;br/&gt;​&lt;br/&gt;github.com&lt;br/&gt;看描述和需求来说，完全符合我的要求。&lt;/p&gt;
&lt;p&gt;$ kubectl krew install ssh-jump&lt;br/&gt;照着教程配置好插件，装好环境之后实践了一下。&lt;/p&gt;
&lt;p&gt;....&lt;/p&gt;
&lt;p&gt;一切都好，就是连不上去。&lt;/p&gt;
&lt;p&gt;蛋疼了...&lt;/p&gt;
&lt;p&gt;接着又找了一波，发现了一个Redhat老哥的博客。&lt;/p&gt;
&lt;p&gt;A consistent, provider-agnostic way to SSH into any Kubernetes node&lt;/p&gt;
&lt;p&gt;完美。&lt;/p&gt;
&lt;p&gt;我想要的就是这个。&lt;/p&gt;
&lt;p&gt;看了下插件代码。luksa/kubectl-plugins看了下插件代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luksa/kubectl-plugins/blob/master/kubectl-ssh&quot; target=&quot;_blank&quot;&gt;https://github.com/luksa/kubectl-plugins/blob/master/kubectl-ssh&lt;/a&gt;&lt;br/&gt;​&lt;br/&gt;github.com&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/usr/bin/env bash

set -e

ssh_node() {
  node=$1
  if [ &quot;$node&quot; = &quot;&quot; ]; then
    node=$(kubectl get node -o name | sed 's/node\///' | tr '\n' ' ')
    node=${node::-1}

    if [[ &quot;$node&quot; =~ &quot; &quot; ]]; then
      echo &quot;Node name must be specified. Choose one of: [$node]&quot;
      exit 1
    else
      echo &quot;Single-node cluster detected. Defaulting to node $node&quot;
    fi
  fi

  pod=$(
    kubectl create -o name -f - &amp;lt;&amp;lt;EOF
apiVersion: v1
kind: Pod
metadata:
  generateName: ssh-node-
  labels:
    plugin: ssh-node
spec:
  nodeName: $node
  containers:
  - name: ssh-node
    image: busybox
    imagePullPolicy: IfNotPresent
    command: [&quot;chroot&quot;, &quot;/host&quot;]
    tty: true
    stdin: true
    stdinOnce: true
    securityContext:
      privileged: true
    volumeMounts:
    - name: host
      mountPath: /host
  volumes:
  - name: host
    hostPath:
      path: /
  hostNetwork: true
  hostIPC: true
  hostPID: true
  restartPolicy: Never
EOF
  )

  deletePod() {
    kubectl delete $pod --wait=false
  }
  trap deletePod EXIT

  echo &quot;Created $pod&quot;
  echo &quot;Waiting for container to start...&quot;
  kubectl wait --for=condition=Ready $pod &amp;gt;/dev/null
  kubectl attach -it $pod -c ssh-node

}

ssh_pod() {
  # TODO: improve this
  if [ &quot;$1&quot; == &quot;&quot; ]; then
    echo &quot;Pod name must be specified.&quot;
    exit 1
  fi
  kubectl exec -it &quot;$@&quot; bash || (
    echo &quot;Running bash in pod failed; trying with sh&quot;
    kubectl exec -it &quot;$@&quot; sh
  )
}

print_usage() {
  echo &quot;Provider-agnostic way of opening a remote shell to a Kubernetes node.&quot;
  echo
  echo &quot;Enables you to access a node even when it doesn't run an SSH server or&quot;
  echo &quot;when you don't have the required credentials. Also, the way you log in&quot;
  echo &quot;is always the same, regardless of what provides the Kubernetes cluster&quot;
  echo &quot;(e.g. Minikube, Kind, Docker Desktop, GKE, AKS, EKS, ...)&quot;
  echo
  echo &quot;You must have cluster-admin rights to use this plugin.&quot;
  echo
  echo &quot;The primary focus of this plugin is to provide access to nodes, but it&quot;
  echo &quot;also provides a quick way of running a shell inside a pod.&quot;
  echo
  echo &quot;Examples: &quot;
  echo &quot;  # Open a shell to node of a single-node cluster (e.g. Docker Desktop)&quot;
  echo &quot;  kubectl ssh node&quot;
  echo
  echo &quot;  # Open a shell to node of a multi-node cluster (e.g. GKE)&quot;
  echo &quot;  kubectl ssh node my-worker-node-1&quot;
  echo
  echo &quot;  # Open a shell to a pod&quot;
  echo &quot;  kubectl ssh pod my-pod&quot;
  echo
  echo &quot;Usage:&quot;
  echo &quot;  kubectl ssh node [nodeName]&quot;
  echo &quot;  kubectl ssh pod [podName] [-n namespace] [-c container]&quot;
  exit 0
}

if [ &quot;$1&quot; == &quot;--help&quot; ]; then
  print_usage
fi

if [[ &quot;$1&quot; == node/* ]]; then
  ssh_node ${1:5}
elif [ &quot;$1&quot; == &quot;node&quot; ]; then
  ssh_node $2
elif [[ &quot;$1&quot; == pod/* ]]; then
  ssh_pod &quot;$@&quot;
elif [ &quot;$1&quot; == &quot;pod&quot; ]; then
  shift
  ssh_pod &quot;$@&quot;
else
  print_usage
fi


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;认真看了一下这个脚本。&lt;/p&gt;
&lt;p&gt;直呼人才啊。&lt;/p&gt;
&lt;p&gt;果然是玩Linux的老哥啊。&lt;/p&gt;
&lt;p&gt;牛逼啊。&lt;/p&gt;
&lt;p&gt;太牛逼了。&lt;/p&gt;
&lt;p&gt;太有趣了。&lt;/p&gt;
&lt;p&gt;额。&lt;/p&gt;
&lt;p&gt;讲人话。&lt;/p&gt;
&lt;p&gt;这个脚本使用busybox镜像启动了容器实例，&lt;/p&gt;
&lt;p&gt;通过chroot到 /host + 把宿主机所有文件挂在到容器实例的方式，&lt;/p&gt;
&lt;p&gt;实现了在容器实例直接对宿主机系统一对一“Copy”（可能表达不太准确），&lt;/p&gt;
&lt;p&gt;进而实现直接在这个容器实例中操作宿主机的所有资源。&lt;/p&gt;
&lt;p&gt;是的，所有资源。&lt;/p&gt;
&lt;p&gt;是的，所有资源。&lt;/p&gt;
&lt;p&gt;是的，所有资源。&lt;/p&gt;
&lt;p&gt;着这里直接能看到其他程序的进程，&lt;/p&gt;
&lt;p&gt;免密码直接操作其他用户的数据。&lt;/p&gt;
&lt;p&gt;所谓，&lt;/p&gt;
&lt;p&gt;这就是容器逃逸。&lt;/p&gt;
&lt;p&gt;然后....&lt;/p&gt;
&lt;p&gt;我们的目的确实也达到了。&lt;/p&gt;
&lt;p&gt;通过这种方式确实可以直接实现登录任意一台k8s node节点，&lt;/p&gt;
&lt;p&gt;再也不需要密码和授权。&lt;/p&gt;
&lt;p&gt;总结。&lt;/p&gt;
&lt;p&gt;很好玩。&lt;/p&gt;
&lt;p&gt;不明镜像确实有风险。&lt;/p&gt;
&lt;p&gt;这个世界一直都不太安全。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;docker 容器逃逸漏洞（CVE-2020-15257）风险通告&lt;/p&gt;
&lt;p&gt;容器逃逸技术概览 - DockOne.io&lt;/p&gt;
&lt;p&gt;rambo1412：容器逃逸技术概览&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jan 2021 15:37:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<og:description>某天， 某鱼说要吃瞄， 于是...... 李国宝：边缘计算k8s集群SuperEdge初体验 ​ zhuanlan.zhihu.com 图标 照着上一篇文章来说，我这边边缘计算集群有一堆节点。 每个节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liguobao/p/14311155.html</dc:identifier>
</item>
</channel>
</rss>