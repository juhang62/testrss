<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于 HTML5 WebGL + WebVR 的 3D 虚实现实可视化培训系统 - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/12159507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/12159507.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2019 年 &lt;strong&gt;VR&lt;/strong&gt;, &lt;strong&gt;AR&lt;/strong&gt;, &lt;strong&gt;XR&lt;/strong&gt;, &lt;strong&gt;5G&lt;/strong&gt;, &lt;strong&gt;工业互联网&lt;/strong&gt;等名词频繁出现在我们的视野中，信息的分享与虚实的结合已经成为大势所趋，&lt;strong&gt;5G&lt;/strong&gt; 是新一代信息通信技术升级的重要方向，工业互联网是制造业转型升级的发展趋势。本文所讲的 &lt;strong&gt;VR&lt;/strong&gt; 是机械制造业与设备的又一次交流，当技术新星遇上制造潮流，无疑将成为制造业，工控业等行业数字化转型的重要驱动力。&lt;strong&gt;“5G + VR + 工业互联网”&lt;/strong&gt;必将成为新的一年不变的话题，如何将当前工业中遇到的问题通过&lt;strong&gt;虚拟现实&lt;/strong&gt;结合起来，让我们可以更近的去交流，去感受技术带给我们的变化。在今年苹果的发布会上，相信大家都知道苹果的 &lt;strong&gt;5G&lt;/strong&gt; 手机没有问世，说明 &lt;strong&gt;5G&lt;/strong&gt; 的应用和发展还处在快速发展的阶段，但是手机结合 &lt;strong&gt;AR&lt;/strong&gt; 功能的 APP 已经早就问世，&lt;strong&gt;5G&lt;/strong&gt; 的速度加上 &lt;strong&gt;AR, VR&lt;/strong&gt; 的身临其境，让我们感受到的不仅仅是技术的革新，更是让我们感受到技术在不同领域的实际应用场景，我相信 2020 年新的一年必定是 &lt;strong&gt;“5G + VR + 工业互联网”&lt;/strong&gt; 应用的又一个新的开始，本文接下来所讲的就是 &lt;strong&gt;&lt;a href=&quot;https://hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT for Web&lt;/a&gt; &lt;/strong&gt;结合 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;WebVR&lt;/strong&gt;&lt;/a&gt; 开发的具体应用案例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统预览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;预览地址：&lt;strong&gt;&lt;a href=&quot;http://www.hightopo.com/demo/vr-training/&quot; target=&quot;_blank&quot;&gt;基于 HTML5 WebGL 与 WebVR 3D 虚实现实的可视化培训系统&lt;/a&gt;   &lt;/strong&gt;&lt;a href=&quot;http://www.hightopo.com/demo/vr-training/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;http://www.hightopo.com/demo/vr-training/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VR 拆解还原&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142740798-574522666.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VR 操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142752415-1341192767.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VR 场景切换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142800168-40154469.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PC 端拆解还原&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142811234-1780951321.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PC 端考试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105142823944-1537887484.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该系统共分为三个实际应用层面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;三维培训:&lt;/strong&gt; 用户通过 mb 端手指触摸或者 pc 端鼠标拖拽可以将设备拆解开来，之后可以通过一键还原来将设备还原到最初的状态，或者可以通过拆解 or 还原按钮查看设备自动拆解的过程以及拆解之后自动还原的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;考试系统:&lt;/strong&gt; 这部分是考验你对设备拆解的熟悉程度，在第一步的三维培训之后，可以在该系统中考核你对拆解过程的了解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VR 模式:&lt;/strong&gt; 该部分便是三维场景结合 WebVR 的具体实现应用，在进入 VR 之后可以通过操作 VR 手柄，进行设备的拆解还原。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文章主要讲解第三部分的 &lt;strong&gt;VR&lt;/strong&gt; 模式，让我们了解如何结合 &lt;strong&gt;HT&lt;/strong&gt; 来搭建 &lt;strong&gt;VR&lt;/strong&gt; 场景。下面描述了 &lt;strong&gt;VR&lt;/strong&gt; 中的主要操作，没有进入 &lt;strong&gt;VR&lt;/strong&gt; 的时候不会出现如下所说的六个按钮操作，在点击进入 &lt;strong&gt;WebVR&lt;/strong&gt; 时，系统自动显示出 &lt;strong&gt;VR&lt;/strong&gt; 场景里的六个操作按钮，反之退出 &lt;strong&gt;VR&lt;/strong&gt; 时，系统也会自动隐藏三维中的六个操作按钮，&lt;strong&gt;VR&lt;/strong&gt; 中的主要操作如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;设备切换:&lt;/strong&gt; 顾名思义，可以通过手柄射线对准场景中左侧列表，按动板机进行场景设备切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作切换:&lt;/strong&gt; VR 中对设备有如下两种操作，可以通过右下角的模式按钮点击切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平移模式:&lt;/strong&gt; 该模式下，用户可以对准设备并且按动板机将设备从一个位置移动到另一个位置，并且可以通过触摸触摸板来拉近和拉远设备零件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抓取模式:&lt;/strong&gt; 该模式下，用户可以对准设备并且按动板机将设备抓取过来，抓取过来之后，可以通过触摸触摸板来旋转以及放大或者缩小零件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一键还原:&lt;/strong&gt; 将设备各部分零件还原到最初始的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆解动画:&lt;/strong&gt; 将设备的各部分零件通过之前预定好的位置按步骤一步一步拆解开来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;还原动画:&lt;/strong&gt; 该操作可以理解为拆解动画的倒放，即将拆解的过程逆序还原。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线框切换:&lt;/strong&gt; HT 支持将设备节点的三角面表示出来，可以具体的看到该设备的线框轮廓。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;系统开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三维场景&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;HT&lt;/strong&gt; 支持 &lt;strong&gt;obj&lt;/strong&gt; 模型的导入，&lt;strong&gt;VR&lt;/strong&gt; 场景所出现的设备零件均为 obj 模型，由于需要在之后进行设备的拆解，所以建模的时候需要分别对设备的各部分零件进行建模，而不是对设备整体进行建模，如果对设备整体建模那么在 HT 的场景中就是一个 &lt;strong&gt;Data&lt;/strong&gt; 节点，从而不能对零件进行拆解，如果拆解开来，那么在 HT 中可以加载多个 obj 则就有多个 Data 节点，有多个零件的 Data 节点之后就可以对设备零件进行移动或者其它旋转操作，具体的 Data 在 HT 的含义可以参考 &lt;strong&gt;&lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/datamodel/ht-datamodel-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 数据模型手册&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下为导入场景中的 &lt;strong&gt;obj&lt;/strong&gt; 模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105143425677-1331933726.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出我们导入 &lt;strong&gt;obj&lt;/strong&gt; 之后零件之间是分散的，所以需要对零件的初始位置进行调整，从而调整出一个由许多零件构成的完整设备，当然调整不可能通过代码来调整，对应的有三维编辑器可以调整，进行拖拖拽拽将不同零件拼凑起来，如下为组合之后的设备整体：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105143443083-1142217726.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VR 搭建&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;VR&lt;/strong&gt; 场景的搭建是在第一步的基础上进行搭建，上面所说的只在 VR 场景中显示的按钮也是在场景中进行搭建，在正常的场景时候我们可以隐藏掉对应的节点，&lt;strong&gt;node.s('3d.visible', false)&lt;/strong&gt; 上面的代码就是 HT 中在三维下面隐藏三维节点的代码，因为进入 VR 和离开 VR 的时候，HT 内部会派发出对应的状态告诉用户此时已经进入 VR 或者此时已经离开 VR，相应伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 // graph3dView 为 HT 中的三维场景视图容器
 2 // vr 获取挂载在 graph3dView 上的 vr 对象
 3 var vr = graph3dView.vr;
 4 vr.mp(function(e) {
 5     // property 对应的 vr 事件类型，detail 此时事件的状态
 6     var property = e.property;
 7     var detail = e.newValue;
 8     // present 代表此时进入或者离开 VR 场景
 9     if (property === 'present') {
10         // 此时 detail 为 true 表示进入 vr，false 表示离开 vr
11         if (detail) {
12             // 执行显示 vr 场景中需要显示的节点操作
13         } else {
14             // 执行隐藏 vr 场景中需要隐藏的节点操作
15         }
16     }
17 });
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面 property 在 &lt;strong&gt;HT&lt;/strong&gt; 总共会派发出以下几种类型，主要是包括 &lt;strong&gt;VR&lt;/strong&gt; 的状态和手柄的操作类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;enable:&lt;/strong&gt; vr 的 enable 信息发生变化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;present:&lt;/strong&gt; vr 的 present 信息发生变化，表明进出 vr 世界&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.pose:&lt;/strong&gt; 手柄位置或旋转发生变动，参数 id，position，rotation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.axes:&lt;/strong&gt; 手柄中间的转盘触摸点位变动，参数 id，axes；其中 axes 格式形如：[ 0.2, 0.7 ]，分辨表示横纵百分比&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.button.thumbpad:&lt;/strong&gt; thumbpad 按键被按下，参数 id，state，其中 state 包含 down 跟 up 两种&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.button.trigger:&lt;/strong&gt; trigger 按键被按下，参数 id，state，其中 state 包含 down 跟 up 两种&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.button.grips:&lt;/strong&gt; grips 按键被按下，参数 id，state，其中 state 包含 down 跟 up 两种&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamepad.button.menu:&lt;/strong&gt; menu 按键被按下，参数 id，state，其中 state 包含 down 跟 up 两种&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;VR 中有一个关键的配置就是&lt;strong&gt;比例尺&lt;/strong&gt;，因为 VR 里面的单位是和现实中的长度单位是一致的，我们戴着头盔往前走 1m 那么对应在 HT 三维场景中需要往前走多远这需要一个对应关系，HT 提供的 VR 插件中会提供一个 &lt;strong&gt;measureOflength&lt;/strong&gt; 的配置项，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 var vr_config = {
2     measureOflength: 0.01,
3 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面 0.01 代表的意思就是 HT 场景中的单位长度 1 代表现实场景的 0.01 米，所以如果此时现实场景你戴着头盔往前移动 1m，那么 HT 中对应的视角会往前移动 100 个单位，所以如果需要搭建 VR 场景要注意场景的模型建模比例和现实世界是相差多少，按照统一的比例来建模，不然在 VR 场景中会出现设备大小不一的问题，导致出现错觉，如下对比图，左侧是 0.01 的比例，射线的小点很小，右侧是是 0.001 的比例导致射线的小点变大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105143842424-724429196.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HT&lt;/strong&gt; 中已经对浏览器提供的 &lt;strong&gt;WebVR&lt;/strong&gt; 相关接口的 API 进行了封装，包括获取设备 &lt;strong&gt;navigator.getVRDisplays()&lt;/strong&gt; 这是进入 VR 世界的第一步，如果此时执行此代码返回的结果为空代表获取 VR 设备失败，那么之后更不用说了，以及获取手柄信息 &lt;strong&gt;navigator.getGamepads()&lt;/strong&gt;，用户可以通过在浏览器控制台敲入上面两行代码，查看浏览器是否已经获取到了 VR 设备信息和 VR 手柄信息，如果返回为空则说明获取失败。HT 只要通过执行 &lt;strong&gt;graph3dView.vr.enable = true&lt;/strong&gt; 就可以开启 &lt;strong&gt;VR&lt;/strong&gt;，当然用户不用执行该代码，HT 提供的 &lt;strong&gt;VR 插件&lt;/strong&gt;也会提供对应的配置项 &lt;strong&gt;vrEnable: true&lt;/strong&gt; 来代表开启 VR，对应的配置也挂在在上面的 &lt;strong&gt;vr_config&lt;/strong&gt; 对象内，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1 var vr_config = {
2     measureOflength: 0.01,
3     vrEnable: true, // 代表开启 VR
4 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在该展示的系统中有直接在 &lt;strong&gt;VR 中切换场景&lt;/strong&gt;的功能，由于每个场景的 &lt;strong&gt;vr_config&lt;/strong&gt; 中的&lt;strong&gt;配置项值&lt;/strong&gt;可能会有差别，例如第一个场景的 &lt;strong&gt;measureOflength&lt;/strong&gt; 比例尺的大小为 0.01，可能第二个场景的比例尺大小 &lt;strong&gt;measureOflength&lt;/strong&gt; 就变成了 0.02，所以 VR 插件提供一个&lt;strong&gt;销毁的功能&lt;/strong&gt;，用来销毁上一个场景的资源，销毁场景的资源&lt;strong&gt;包括清空上一个场景的所有节点&lt;/strong&gt;，所以在加载新的场景时，&lt;strong&gt;不需要再执行清空场景节点的操作，即不需要执行 dataModel.clear()&lt;/strong&gt;，因为 VR 提供的销毁功能已经都清空了，手柄和射线都是场景中的一个 Data 节点，所以在新的场景不需要额外的清除手柄和射线这两个节点，故插件帮你管理场景的节点。在调用销毁功能之后，可以调用 &lt;strong&gt;graph3dView&lt;/strong&gt; 的序列化函数 &lt;strong&gt;graph3dView.deserialize('场景资源json地址')&lt;/strong&gt; 来序列化新的场景 json 文件，在序列化完成的回调函数中，可以根据新的场景修改此时 &lt;strong&gt;vr_config&lt;/strong&gt; 的值，然后再次调用 &lt;strong&gt;graph3dView.initVRForScene()&lt;/strong&gt; 来再次初始化 &lt;strong&gt;VR&lt;/strong&gt; 场景。相关的步骤伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 // window.GVR 是在调用 graph3dView.initVRForScene() 之后初始化的一个全局 VR 插件变量 用于用户获取插件对象
 2 window.GVR.destory();
 3 // 执行新的场景序列化操作
 4 graph3dView.deserialize('场景资源json地址',
 5 function(json, dm, g3d, datas) {
 6     // 修改新的场景比例尺为 0.02
 7     window.vr_config.measureOflength = 0.02;
 8     // 修改新的 VR 场景初始化视角
 9     window.vr_config.vrEye = ht.Default.clone(g3d.getEye());;
10     // 再次初始化 VR 场景
11     graph3dView.initVRForScene()
12 });
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当然 HT 提供的 VR 插件还有很多的配置项，方便用户更好的调整 VR 场景，包括刷地形，场景移动方式，场景操作方式都可以通过配置进行配置，利用 HT 进行 VR 搭建主要流程如下流程图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105144250023-798470602.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的流程图，我们大体可以了解配合 HT 提供的 VR 插件如何进行快速的搭建 VR 场景。&lt;/p&gt;
&lt;p&gt;目前谷歌浏览器和火狐浏览器都很友好的支持 VR，可以通过火狐官网提供的 &lt;strong&gt;&lt;a href=&quot;https://mdn.github.io/webvr-tests/raw-webgl-controller-example/&quot; target=&quot;_blank&quot;&gt;WebVR Demo&lt;/a&gt;&lt;/strong&gt; 在线感受下官方提供的 VR 场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拆解规则&lt;/strong&gt;&lt;br/&gt;从文章前面的部分效果图可以看到我们每个场景的设备都有拆解，并且每个设备的零件数量，零件位置，零件拆解的方向，偏移的长短都是不一致的，所以不可能通过代码来将上面的偏移长短，偏移方向写死，需要制定一套拆解规则来帮助我们可以更方便制作每个场景的拆解动画，这样只需要设计师根据与程序约定好的拆解规则进行配置就可以配置出不同场景不同设备的拆解动画。该系统的拆解分为两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单体移动:&lt;/strong&gt; 单个设备零件沿着父节点位置和该节点位置的连接线方向移动&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合移动:&lt;/strong&gt; 多个设备零件的组合沿着某个方向移动，组合移动之后，设备零件可以在组合移动之后的位置进行再沿着某个方向进行移动，可以无限进行嵌套，即组合之后还可以组合移动，或者单体移动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单体移动示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105144416446-2116016256.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;组合移动示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105144424686-1193050562.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 HT 中可以通过 &lt;strong&gt;data.setDisplayName('名称')&lt;/strong&gt; 来给节点设置名称，这里约定通过不同设备的名称，来获取到不同设备的偏移信息，例如 &lt;strong&gt;data.setDisplayName('1-0.5-1000')&lt;/strong&gt; 该名称就是和设计师约定好的配置规则，&lt;strong&gt;1&lt;/strong&gt; 代表拆解步骤的第一步执行，当然场景中可以有多个 1，即第一步同时拆解这些零件 &lt;strong&gt;0.5&lt;/strong&gt; 代表朝着父节点的方向偏移自己位置和父节点位置连接线长度的 &lt;strong&gt;50%&lt;/strong&gt;。&lt;strong&gt;1000&lt;/strong&gt; 代表偏移的过程持续 &lt;strong&gt;1000&lt;/strong&gt; 毫秒，当然之后可以约定旋转以及旋转的角度等信息。设计师知道这些配置规则之后便可以通过可视化编辑器进行不同零件的配置，这样程序方面只需要写一套通用的逻辑就可以对不同的设备进行拆解和还原。&lt;/p&gt;
&lt;p&gt;系统中维护了一个&lt;strong&gt;队列&lt;/strong&gt;和一个&lt;strong&gt;栈&lt;/strong&gt;，&lt;strong&gt;队列&lt;/strong&gt;用来记录&lt;strong&gt;拆解顺序&lt;/strong&gt;，&lt;strong&gt;栈&lt;/strong&gt;用来记录&lt;strong&gt;还原顺序&lt;/strong&gt;。拆解的过程通过配置的序号，按顺序推进队列，采用队列的数据结构便是因为队列&lt;strong&gt;先进先出&lt;/strong&gt;的特点，第一个压入队列的零件则第一个执行，最后压入队列的零件最后一个执行拆解顺序。拆解出队列的零件则同时压入栈，采用&lt;strong&gt;栈&lt;/strong&gt;记录还原顺序是因为&lt;strong&gt;先进后出&lt;/strong&gt;的特点，即第一个执行完拆解的零件，在还原的时候却是最后一个执行还原的动作。所以上述采用的不同数据结构便是为了更好的记录数据。以下为相关 js 伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 // 记录拆解顺序
 2 const queue = [];
 3 // 记录还原顺序
 4 const stack = [];
 5 // each 循环中用来记录拆解队列 queue 顺序
 6 dataModel.each((node) = &amp;gt;{
 7     const displayName = node.getDisplayName();
 8     if (displayName) {
 9         const[index, distancePer, during] = displayName.split('-');
10         if (index !== void 0) {
11             if (queue[index]) {
12                 if (queue[index] instanceof Array) {
13                     queue[index].push(node);
14                 } else {
15                     const tempNode = queue[index];
16                     queue[index] = [tempNode, node];
17                 }
18             } else {
19                 queue[index] = node;
20             }
21         }
22     }
23 });
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;相关逻辑如下流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105144657640-773804926.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的约定，设计师可以使用可视化编辑器来配置不同零件的移动规则，大大提高了动画的制作效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码分析&lt;/strong&gt;&lt;br/&gt;该部分主要对拆解还原动画的代码进行分析，主要采用&lt;strong&gt;向量&lt;/strong&gt;和部分&lt;strong&gt;三角函数&lt;/strong&gt;的概念来计算不同零件在三维空间的位置，初始的时候需要记录下每个零件在前面所有组合移动之后的初始移动位置向量，以及零件没有组合移动之前的初始位置向量，获取这两个位置向量目的是一是为了零件拆解在前面所说组合之后移动，和零件在拆解之后恢复到一整个设备形态的初始位置，两个位置向量都有重要的作用，以下为相关伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 // Vector3 为 HT 封装的三维向量
 2 const Vector3 = ht.Math.Vector3;
 3 // 记录第一个重要位置向量
 4 node.a('relativeP3Vec', new Vector3(node.p3()));
 5 // node 当前零件节点
 6 // moveQueue 为移动顺序在 node 之前的，并且为 node 节点的祖先节点
 7 for (let i = 0, l = moveQueue.length; i &amp;lt; l; i++) {
 8     const moveNode = moveQueue[i],
 9     parentMoveNode = moveNode.getParent();
10     if (parentMoveNode) {
11         const[, distancePer] = moveNode.getDisplayName().split('-');
12         moveNode.a('defP3', moveNode.p3()) moveNode.p3(new Vector3().lerpVectors(new Vector3(moveNode.p3()), new Vector3(parentMoveNode.p3()), distancePer).toArray());
13     }
14 }
15 // 记录组合节点移动之后的第二个重要相对位置向量
16 node.a('relativeP3Vec', new Vector3(node.p3()));
17 // 逆序还原组合的父节点位置
18 for (let i = moveQueue.length - 1; i &amp;gt;= 0; i--) {
19     const moveNode = moveQueue[i];
20     moveNode.p3(moveNode.a('defP3'));
21     moveNode.a('defP3', undefined);
22 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由于在场景拆解过程中需要设置设备零件节点不可选择，所以需要记录下不可选择之前的零件是否可选择状态，用来恢复节点初始状态，相关伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 dm3d.each((node) = &amp;gt;{
2     node.a('defSelectable', node.s('3d.selectable'));
3 });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文中所示的线框效果为 HT 核心包支持的线框模式，可以通过如下代码进行配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
dm3d.each((data) = &amp;gt;{
    if (data.s('shape3d') &amp;amp;&amp;amp; data.s('shape3d').startsWith('models/')) {
        data.s({
            'shape3d.transparent': true,
            'shape3d.opacity': 0, // 目的为隐藏原本的模型
            'wf.geometry': true, // 开启线框模式
            'wf.combineTriangle': 2, // 线框三角面合并类型
            'wf.color': 'rgba(96,172,252,0.3)' // 线框颜色
        });
    }
});
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上述 &lt;strong&gt;wf.combineTriangle&lt;/strong&gt; 主要包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;false,0:&lt;/strong&gt; 不合并三角形&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;true,1:&lt;/strong&gt; 合并相邻三角为四边面，原来的效果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2:&lt;/strong&gt; 融合所有联通的共面三角面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3:&lt;/strong&gt; 根据法线信息融合所有平滑三角面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;VR 软件以及硬件安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本系统采用的 &lt;strong&gt;VR&lt;/strong&gt; 硬件设备为 &lt;strong&gt;HTC VIVE&lt;/strong&gt; 接下来讲的是&lt;strong&gt;安装 HTC VIVE&lt;/strong&gt; 的过程和步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：撮合 HTC VIVE 和电脑主机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到 &lt;strong&gt;&lt;a href=&quot;http://dl4.htc.com/web_materials/Manual/Vive/Vive_User_Guide_CHS.pdf?_ga=1.149353653.2032797701.1485487239&quot; target=&quot;_blank&quot;&gt;HTC&lt;/a&gt;&lt;/strong&gt; 官网找到连接指南，然后按照步骤安装即可，我们只需看以下截图部分的目录即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145036715-2070027276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：下载软件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到 &lt;a href=&quot;https://store.steampowered.com/steamvr&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Steam&lt;/strong&gt;&lt;/a&gt; 官网下载 Steam，下载完 Steam 可以在 Steam 中下载 Stream VR。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：打开 Stream VR 检查设备状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开 Stream VR，会出现以下画面，这是用来表示 HTC VIVE 头显的工作状态的，通过图标我们即可查看头显、手柄控制器和定位器等配件的工作情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145114732-1920946188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步：选择房间设置模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果您的房间位置比较大可以选择第一项，我选择的模式为第二项，站立模式。建议选择一种房间规模，可以完整的进行设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145129413-365702223.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五步：将头盔、两个手柄控制器放置在两个定位器可视范围内，建立定位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145145432-1249286427.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六步：校准头盔中心点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该步为设置头盔默认的朝向。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145159214-1567347883.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第七步：定位地面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将两个手柄控制器放置在定位器可视范围内，然后点击电脑屏幕上的按钮“校准地面”，等待系统校准&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145213015-1912931312.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第八步：进入 Steam VR 自带房间进行测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置完毕之后可以进入 Steam VR 自带的房间进行体验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br/&gt;当人们谈起 &lt;strong&gt;5G&lt;/strong&gt; 时代的新应用，&lt;strong&gt;VR、AR&lt;/strong&gt; 总是一大热门话题。4G 时代移动网络已经足以承载起高清视频，那么 5G 时代理所当然就能传输数据量更大的沉浸式 VR、AR 影像。因此，不少人将 5G 视为 VR、AR 崛起的踏板，随时随地&lt;strong&gt;身临&lt;/strong&gt;天涯海角，似乎并非是遥不可及的梦。当前 4G 网络应用在 VR/AR 上会带来大约 70ms 的时延，这个时延会导致体验者存在眩晕感，而 5G 数据传输的延迟可达到毫秒级，可以有效解决数据时延带来的眩晕感，有助于 VR/AR 的大规模应用。目前随着 5G 网络的逐渐普及，VR/AR 产业正逐步走向复苏，市场热情在逐渐升温，虚拟现实游戏、虚拟现实现场直播等都是 5G 在 VR/AR 上的具体应用。在科技进步的今天，安全也是一个重要的话题，VR 结合&lt;strong&gt;仿真&lt;/strong&gt;的应用也是大势所趋，&lt;strong&gt;仿真&lt;/strong&gt;可以让用户真实切身感受，例如&lt;strong&gt;消防预警&lt;/strong&gt;，&lt;strong&gt;管道预警&lt;/strong&gt;，可以让用户在 VR 世界中体验消防灭火等消防员的操作，让用户沉浸在 VR 世界中感受到火灾来临时怎么进行实际操作。所以 VR 带来的应用远远不止仿真，模拟等体验，更多带来的是能为人们提供真实的实际作用，而不是噱头。&lt;/p&gt;
&lt;p&gt;程序手机端运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145334221-547944883.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/591709/202001/591709-20200105145343983-1500045311.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jan 2020 00:36:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>前言 2019 年 VR, AR, XR, 5G, 工业互联网等名词频繁出现在我们的视野中，信息的分享与虚实的结合已经成为大势所趋，5G&amp;#160;是新一代信息通信技术升级的重要方向，工业互联网是制造</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htdaydayup/p/12159507.html</dc:identifier>
</item>
<item>
<title>JAVA8学习——Stream底层的实现（学习过程） - dawa大娃bigbaby</title>
<link>http://www.cnblogs.com/bigbaby/p/12159495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigbaby/p/12159495.html</guid>
<description>&lt;p&gt;Stream接口实现了 BaseStream 接口，我们先来看看BaseStream的定义&lt;/p&gt;
&lt;h2 id=&quot;basestream&quot;&gt;BaseStream&lt;/h2&gt;
&lt;p&gt;BaseStream是所有流的父类接口。&lt;/p&gt;
&lt;h3 id=&quot;对javadoc做一次解读了解提供的所有方法&quot;&gt;对JavaDoc做一次解读，了解提供的所有方法。&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Base interface for streams, which are sequences of elements supporting
 * sequential and parallel aggregate operations.  The following example
 * illustrates an aggregate operation using the stream types {@link Stream}
 * and {@link IntStream}, computing the sum of the weights of the red widgets:
 *
 * &amp;lt;pre&amp;gt;{@code
 *     int sum = widgets.stream()
 *                      .filter(w -&amp;gt; w.getColor() == RED)
 *                      .mapToInt(w -&amp;gt; w.getWeight())
 *                      .sum();
 * }&amp;lt;/pre&amp;gt;
 *
 * See the class documentation for {@link Stream} and the package documentation
 * for &amp;lt;a href=&quot;package-summary.html&quot;&amp;gt;java.util.stream&amp;lt;/a&amp;gt; for additional
 * specification of streams, stream operations, stream pipelines, and
 * parallelism, which governs the behavior of all stream types.
 
 
 *
 * @param &amp;lt;T&amp;gt; the type of the stream elements
 * @param &amp;lt;S&amp;gt; the type of of the stream implementing {@code BaseStream}
 S 代表中间操作产生的新的流操作。
 
 * @since 1.8
 * @see Stream
 * @see IntStream
 * @see LongStream
 * @see DoubleStream
 * @see &amp;lt;a href=&quot;package-summary.html&quot;&amp;gt;java.util.stream&amp;lt;/a&amp;gt;
 */

public interface BaseStream&amp;lt;T, S extends BaseStream&amp;lt;T, S&amp;gt;&amp;gt;
        extends AutoCloseable {
    /**
     * Returns an iterator for the elements of this stream.
     *
     * &amp;lt;p&amp;gt;This is a &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;terminal
     * operation&amp;lt;/a&amp;gt;.
     *
     * @return the element iterator for this stream
     */
    Iterator&amp;lt;T&amp;gt; iterator(); //迭代器 ，针对于流中元素类型*（T）的迭代器

    /**
     * Returns a spliterator for the elements of this stream.
     *
     * &amp;lt;p&amp;gt;This is a &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;terminal
     * operation&amp;lt;/a&amp;gt;.
     *
     * @return the element spliterator for this stream
     */
    Spliterator&amp;lt;T&amp;gt; spliterator(); //分割迭代器， 流中的核心的操作。

    /**
     * Returns whether this stream, if a terminal operation were to be executed,
     * would execute in parallel.  Calling this method after invoking an
     * terminal stream operation method may yield unpredictable results.
     *
     * @return {@code true} if this stream would execute in parallel if executed
     */
    boolean isParallel(); //是否并行

    /**
     * Returns an equivalent stream that is sequential.  May return
     * itself, either because the stream was already sequential, or because
     * the underlying stream state was modified to be sequential.，.
     返回一个等价的串行流，有可能返回流本身，或者是流修改成串行流的
     *
     * &amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;intermediate
     * operation&amp;lt;/a&amp;gt;.
     *
     * @return a sequential stream
     */
    S sequential();   //返回值为S：流，新的流对象

    /**
     * Returns an equivalent stream that is parallel.  May return
     * itself, either because the stream was already parallel, or because
     * the underlying stream state was modified to be parallel.
     *
     * &amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;intermediate
     * operation&amp;lt;/a&amp;gt;.
     *
     * @return a parallel stream
     */
    S parallel();

    /**
     * Returns an equivalent stream that is
     * &amp;lt;a href=&quot;package-summary.html#Ordering&quot;&amp;gt;unordered&amp;lt;/a&amp;gt;.  May return
     * itself, either because the stream was already unordered, or because
     * the underlying stream state was modified to be unordered.
     *
     * &amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;intermediate
     * operation&amp;lt;/a&amp;gt;.
     *
     * @return an unordered stream
     */
    S unordered();

    /**
     * Returns an equivalent stream with an additional close handler.  Close
     * handlers are run when the {@link #close()} method
     * is called on the stream, and are executed in the order they were
     * added.  All close handlers are run, even if earlier close handlers throw
     * exceptions.  If any close handler throws an exception, the first
     * exception thrown will be relayed to the caller of {@code close()}, with
     * any remaining exceptions added to that exception as suppressed exceptions
     * (unless one of the remaining exceptions is the same exception as the
     * first exception, since an exception cannot suppress itself.)  May
     * return itself.
     返回值为流。流中带了一个关闭处理器、关闭处理器调用的是 close（）方法。
     按照被添加的顺序去关闭。
     *
     * &amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;intermediate
     * operation&amp;lt;/a&amp;gt;.
     *
     * @param closeHandler A task to execute when the stream is closed
     * @return a stream with a handler that is run if the stream is closed
     */
    S onClose(Runnable closeHandler);

    /**
     * Closes this stream, causing all close handlers for this stream pipeline
     * to be called.
     *
     * @see AutoCloseable#close()
     */
    @Override
    void close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对onclose关闭处理器做单独的认识&quot;&gt;对onClose关闭处理器做单独的认识&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StreamTest2 {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;);
//        list.stream().onClose(()-&amp;gt; System.out.println(&quot;aaa&quot;)).onClose(()-&amp;gt; System.out.println(&quot;bbb&quot;)).forEach(System.out::println);

        try (Stream&amp;lt;String&amp;gt; stream = list.stream()){
            stream.onClose(()-&amp;gt; {
                System.out.println(&quot;aaa&quot;);
                throw new NullPointerException(&quot;first Exception&quot;);
            }).onClose(()-&amp;gt;{
                System.out.println(&quot;bbb&quot;);
                throw new ArithmeticException(&quot;first Exception&quot;);
            }).forEach(System.out::println);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.lang.NullPointerException: first Exception
    at com.dawa.jdk8.StreamTest2.lambda$main$0(StreamTest2.java:21)
    at java.util.stream.Streams$1.run(Streams.java:850)
    at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323)
    at com.dawa.jdk8.StreamTest2.main(StreamTest2.java:26)
    Suppressed: java.lang.ArithmeticException: first Exception
        at com.dawa.jdk8.StreamTest2.lambda$main$1(StreamTest2.java:24)
        at java.util.stream.Streams$1.run(Streams.java:854)
        ... 2 more&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;几种可能的情况&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;//运行结果就可以看到 aa,bbb被调用。&lt;/li&gt;
&lt;li&gt;//也可以看到压制异常&lt;/li&gt;
&lt;li&gt;//如果两个地方的异常是相同的异常对象，则第二个异常不会被压制。因为异常是自己不会压制自己的。&lt;/li&gt;
&lt;li&gt;//如果是同一种异常，但是不是同一个异常，还是会压制的。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;备注：遇到问题，javadoc里面已经写的很清楚了。往往每个人都伸手可得的内容，容易最被忽视掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;stream源码分析&quot;&gt;Stream源码分析&lt;/h2&gt;
&lt;p&gt;引入Example，跟源码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;);
        list.stream().forEach(System.out::println);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stream&quot;&gt;1. stream()&lt;/h3&gt;
&lt;p&gt;来自Collection接口中的默认方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     /**
     * Returns a sequential {@code Stream} with this collection as its source.
     *
     * &amp;lt;p&amp;gt;This method should be overridden when the {@link #spliterator()}
     * method cannot return a spliterator that is {@code IMMUTABLE},
     * {@code CONCURRENT}, or &amp;lt;em&amp;gt;late-binding&amp;lt;/em&amp;gt;. (See {@link #spliterator()}
     * for details.)
     当这个 spliterator（）无法返回这三个（不可变的，并行的，延迟绑定的）类型中的一个的话，
     这个方法需要被重写。
     *
     * @implSpec
     * The default implementation creates a sequential {@code Stream} from the
     * collection's {@code Spliterator}.
     返回一个针对于当前元素的一个串行流。
     *
     * @return a sequential {@code Stream} over the elements in this collection
     * @since 1.8
     */
    default Stream&amp;lt;E&amp;gt; stream() {
        return StreamSupport.stream(spliterator(), false);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，这里就要先了解一下spliterator()这个方法是怎么实现的。&lt;/p&gt;
&lt;h4 id=&quot;spliterator的源码实现&quot;&gt;spliterator()的源码实现&lt;/h4&gt;
&lt;p&gt;实现方法和stream（）一样，在Collection接口中的默认方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * Creates a {@link Spliterator} over the elements in this collection.
     *
     * Implementations should document characteristic values reported by the
     * spliterator.  Such characteristic values are not required to be reported
     * if the spliterator reports {@link Spliterator#SIZED} and this collection
     * contains no elements.
     Spliterator#SIZED，集合，固定大小，并且没有值。的时候是不用报告的。
     
     --备注：和collectors的characteristic特性值
     
     *
     * &amp;lt;p&amp;gt;The default implementation should be overridden by subclasses that
     * can return a more efficient spliterator.  In order to
     * preserve expected laziness behavior for the {@link #stream()} and
     * {@link #parallelStream()}} methods, spliterators should either have the
     * characteristic of {@code IMMUTABLE} or {@code CONCURRENT}, or be
     * &amp;lt;em&amp;gt;&amp;lt;a href=&quot;Spliterator.html#binding&quot;&amp;gt;late-binding&amp;lt;/a&amp;gt;&amp;lt;/em&amp;gt;.
     * If none of these is practical, the overriding class should describe the
     * spliterator's documented policy of binding and structural interference,
     * and should override the {@link #stream()} and {@link #parallelStream()}
     * methods to create streams using a {@code Supplier} of the spliterator,
     * as in:
     默认的实现，应该被子类所重写。为了保留期望的stream（）的延迟行为。分割迭代器的特性值 只有在满足{@code IMMUTABLE} or {@code CONCURRENT}的时候，才是具有延迟行为的。
     如果上面条件都无法做的话，重写的类应该去描述这个分割迭代器的文档
     并且重写。
     用下面的这种方式去定义。
     
     * &amp;lt;pre&amp;gt;{@code
     *     Stream&amp;lt;E&amp;gt; s = StreamSupport.stream(() -&amp;gt; spliterator(), spliteratorCharacteristics)
     * }&amp;lt;/pre&amp;gt;
     * &amp;lt;p&amp;gt;These requirements ensure that streams produced by the
     * {@link #stream()} and {@link #parallelStream()} methods will reflect the
     * contents of the collection as of initiation of the terminal stream
     * operation.
     这些要求确保了由这两个方法生成的流，反应了流的内容 （在终止流操作执行的一瞬间）
     *
     * @implSpec
     * The default implementation creates a
     * &amp;lt;em&amp;gt;&amp;lt;a href=&quot;Spliterator.html#binding&quot;&amp;gt;late-binding&amp;lt;/a&amp;gt;&amp;lt;/em&amp;gt; spliterator
     * from the collections's {@code Iterator}.  The spliterator inherits the
     * &amp;lt;em&amp;gt;fail-fast&amp;lt;/em&amp;gt; properties of the collection's iterator.
     默认的实现 从集合的迭代器中，创建一个延迟绑定的分割迭代器。  分割迭代器会继承迭代器的快速失败的属性。
     
     * &amp;lt;p&amp;gt;
     * The created {@code Spliterator} reports {@link Spliterator#SIZED}.
     创建的分割迭代器，会携带一个 Spliterator#SIZED （固定大小的）的特性值
     *
     * @implNote
     * The created {@code Spliterator} additionally reports
     * {@link Spliterator#SUBSIZED}.
     还会额外的增加一个Spliterator#SUBSIZED（子大小）的确定。
     
     *
     * &amp;lt;p&amp;gt;If a spliterator covers no elements then the reporting of additional
     * characteristic values, beyond that of {@code SIZED} and {@code SUBSIZED},
     * does not aid clients to control, specialize or simplify computation.
     * However, this does enable shared use of an immutable and empty
     * spliterator instance (see {@link Spliterators#emptySpliterator()}) for
     * empty collections, and enables clients to determine if such a spliterator
     * covers no elements.
     如果分割迭代器里面没有元素，那么除了 {@code SIZED} and {@code SUBSIZED}之外其他的特性，对于计算的控制是没有帮助作用的。 不过可以促进空的迭代器的共享使用。 参见： Spliterators#emptySpliterator()、
     对于一个空的迭代器可以判断是不是没有元素
     
     *
     * @return a {@code Spliterator} over the elements in this collection
     * @since 1.8
     */
    @Override
    default Spliterator&amp;lt;E&amp;gt; spliterator() {
        return Spliterators.spliterator(this, 0);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，到底什么是分割迭代器？ Spliterator&lt;/p&gt;
&lt;h4 id=&quot;到底什么是分割迭代器-spliterator类&quot;&gt;到底什么是分割迭代器 —— Spliterator类&lt;/h4&gt;
&lt;p&gt;和Collector收集器一样，同时提供了collector接口和 Collectors的工具类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class Spliterators {}
public interface Spliterator&amp;lt;T&amp;gt; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;我们先来看看spliterator接口的javadoc&quot;&gt;我们先来看看Spliterator接口的javadoc&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * An object for traversing and partitioning elements of a source.  The source
 * of elements covered by a Spliterator could be, for example, an array, a
 * {@link Collection}, an IO channel, or a generator function.
 一个分割迭代器，是一个对象，用于对源中的元素进行遍历和分区。
 源可以是：数组，集合，或者IO通道
 *
 * &amp;lt;p&amp;gt;A Spliterator may traverse elements individually ({@link
 * #tryAdvance tryAdvance()}) or sequentially in bulk
 * ({@link #forEachRemaining forEachRemaining()}).
 一个迭代器可以一个一个的去遍历。tryAdvance()
 也可以以块的方式去遍历。 forEachRemaining()
 
 *
 * &amp;lt;p&amp;gt;A Spliterator may also partition off some of its elements (using
 * {@link #trySplit}) as another Spliterator, to be used in
 * possibly-parallel operations.  Operations using a Spliterator that
 * cannot split, or does so in a highly imbalanced or inefficient
 * manner, are unlikely to benefit from parallelism.  Traversal
 * and splitting exhaust elements; each Spliterator is useful for only a single
 * bulk computation.
 也可以使用 trySplit（） 对元素进行分区，形成一个新的元素迭代器。也可以以并行的方式去操作。
 使用Spliterator的操作，是不能分割，或者效率非常低的分割， 如果用并行的话，不会获得很大的收益。
 （比如，100个元素，分区分为 2+98，这种的就是非常低效的。就无法利用并行的优势了。）
 
 每一个分割迭代器，只对自己特定的块有用。
 *
 * &amp;lt;p&amp;gt;A Spliterator also reports a set of {@link #characteristics()} of its
 * structure, source, and elements from among {@link #ORDERED},
 * {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED}, {@link #NONNULL},
 * {@link #IMMUTABLE}, {@link #CONCURRENT}, and {@link #SUBSIZED}. These may
 * be employed by Spliterator clients to control, specialize or simplify
 * computation.  For example, a Spliterator for a {@link Collection} would
 * report {@code SIZED}, a Spliterator for a {@link Set} would report
 * {@code DISTINCT}, and a Spliterator for a {@link SortedSet} would also
 * report {@code SORTED}.  Characteristics are reported as a simple unioned bit
 * set.
 分割迭代器还会 设置 特性值 
  {@link #ORDERED}, 
  {@link #DISTINCT}, 
  {@link #SORTED}, 
  {@link #SIZED}, 
  {@link #NONNULL},
  {@link #IMMUTABLE}, 
  {@link #CONCURRENT}, 
  {@link #SUBSIZED}.
  这些属性用来控制特定的某些计算。
  
  比如说，一个 Collection就需要SIZED特性值
  Set需要DISTINCT
 
 *
 * Some characteristics additionally constrain method behavior; for example if
 * {@code ORDERED}, traversal methods must conform to their documented ordering.
 * New characteristics may be defined in the future, so implementors should not
 * assign meanings to unlisted values.
 不要给没有列出来的值赋予新的含义。
 
 *
 * &amp;lt;p&amp;gt;&amp;lt;a name=&quot;binding&quot;&amp;gt;A Spliterator that does not report {@code IMMUTABLE} or
 * {@code CONCURRENT} is expected to have a documented policy concerning:
 * when the spliterator &amp;lt;em&amp;gt;binds&amp;lt;/em&amp;gt; to the element source; and detection of
 * structural interference of the element source detected after binding.&amp;lt;/a&amp;gt;  A
 * &amp;lt;em&amp;gt;late-binding&amp;lt;/em&amp;gt; Spliterator binds to the source of elements at the
 * point of first traversal, first split, or first query for estimated size,
 * rather than at the time the Spliterator is created.  A Spliterator that is
 * not &amp;lt;em&amp;gt;late-binding&amp;lt;/em&amp;gt; binds to the source of elements at the point of
 * construction or first invocation of any method.  Modifications made to the
 * source prior to binding are reflected when the Spliterator is traversed.
 * After binding a Spliterator should, on a best-effort basis, throw
 * {@link ConcurrentModificationException} if structural interference is
 * detected.  Spliterators that do this are called &amp;lt;em&amp;gt;fail-fast&amp;lt;/em&amp;gt;.  The
 * bulk traversal method ({@link #forEachRemaining forEachRemaining()}) of a
 * Spliterator may optimize traversal and check for structural interference
 * after all elements have been traversed, rather than checking per-element and
 * failing immediately.
 并不是说一个迭代器在创建的时候就被绑定到源上面了。而是在满足首次遍历，首次分割，首次查询的时候，才进行绑定。

ConcurrentModificationException，在绑定之前操作，会出现这一行的异常。
叫做 快速失败。
 
 *
 * &amp;lt;p&amp;gt;Spliterators can provide an estimate of the number of remaining elements
 * via the {@link #estimateSize} method.  Ideally, as reflected in characteristic
 * {@link #SIZED}, this value corresponds exactly to the number of elements
 * that would be encountered in a successful traversal.  However, even when not
 * exactly known, an estimated value value may still be useful to operations
 * being performed on the source, such as helping to determine whether it is
 * preferable to split further or traverse the remaining elements sequentially.
 *
 * &amp;lt;p&amp;gt;Despite their obvious utility in parallel algorithms, spliterators are not
 * expected to be thread-safe; instead, implementations of parallel algorithms
 * using spliterators should ensure that the spliterator is only used by one
 * thread at a time.  This is generally easy to attain via &amp;lt;em&amp;gt;serial
 * thread-confinement&amp;lt;/em&amp;gt;, which often is a natural consequence of typical
 * parallel algorithms that work by recursive decomposition.  A thread calling
 * {@link #trySplit()} may hand over the returned Spliterator to another thread,
 * which in turn may traverse or further split that Spliterator.  The behaviour
 * of splitting and traversal is undefined if two or more threads operate
 * concurrently on the same spliterator.  If the original thread hands a
 * spliterator off to another thread for processing, it is best if that handoff
 * occurs before any elements are consumed with {@link #tryAdvance(Consumer)
 * tryAdvance()}, as certain guarantees (such as the accuracy of
 * {@link #estimateSize()} for {@code SIZED} spliterators) are only valid before
 * traversal has begun.
 *
 serial-thread-confinement : 线程安全围栏
 
 * &amp;lt;p&amp;gt;Primitive subtype specializations of {@code Spliterator} are provided for
 * {@link OfInt int}, {@link OfLong long}, and {@link OfDouble double} values.
 * The subtype default implementations of
 * {@link Spliterator#tryAdvance(java.util.function.Consumer)}
 * and {@link Spliterator#forEachRemaining(java.util.function.Consumer)} box
 * primitive values to instances of their corresponding wrapper class.  Such
 * boxing may undermine any performance advantages gained by using the primitive
 * specializations.  To avoid boxing, the corresponding primitive-based methods
 * should be used.  
 tryAdvance()方法和forEachRemaining() 
 提供了原生子类型的特化， int, long, doule 等，子类型默认的实现。
 避免包装类型装箱拆箱操作。
 如下。
 
 For example, 如下特化版本. 
 * {@link Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)}
 * and {@link Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}
 * should be used in preference to
 * {@link Spliterator.OfInt#tryAdvance(java.util.function.Consumer)} and
 * {@link Spliterator.OfInt#forEachRemaining(java.util.function.Consumer)}.
 * Traversal of primitive values using boxing-based methods
 * {@link #tryAdvance tryAdvance()} and
 * {@link #forEachRemaining(java.util.function.Consumer) forEachRemaining()}
 * does not affect the order in which the values, transformed to boxed values,
 * are encountered.

 
 *
 * @apiNote
 * &amp;lt;p&amp;gt;Spliterators, like {@code Iterator}s, are for traversing the elements of
 * a source.  The {@code Spliterator} API was designed to support efficient
 * parallel traversal in addition to sequential traversal, by supporting
 * decomposition as well as single-element iteration.  In addition, the
 * protocol for accessing elements via a Spliterator is designed to impose
 * smaller per-element overhead than {@code Iterator}, an d to avoid the inherent
 * race involved in having separate methods for {@code hasNext()} and
 * {@code next()}.
 Spliterator支持高效的，并行的操作。
 支持解耦，分解，氮元素的遍历。
 此外，通过accessing协议。。。 相对于 Iterator，遍历元素的时候成本更低。
 原因： 之前的{@code hasNext()} and {@code next()}.搭配使用存在竞争。
 现在直接使用一个tryAdvance()方法就解决了这两个方法实现的事情。 
 
 
 *
 * &amp;lt;p&amp;gt;For mutable sources, arbitrary and non-deterministic behavior may occur if
 * the source is structurally interfered with (elements added, replaced, or
 * removed) between the time that the Spliterator binds to its data source and
 * the end of traversal.  For example, such interference will produce arbitrary,
 * non-deterministic results when using the {@code java.util.stream} framework.
 如果源在结构上被修改了（增删改），在绑定迭代器之后和执行完毕之前这段时间内进行任意修改。
 行为就是不确定的了。 
 所以在使用流框架的时候，要求源是不可变的
 
 *
 * &amp;lt;p&amp;gt;Structural interference of a source can be managed in the following ways
 * (in approximate order of decreasing desirability):
 源结构上的修改，是可以通过如下几个方式去修改的
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;The source cannot be structurally interfered with.
 如，源是不允许被修改的。
 * &amp;lt;br&amp;gt;For example, an instance of
 * {@link java.util.concurrent.CopyOnWriteArrayList} is an immutable source.
 * A Spliterator created from the source reports a characteristic of
 * {@code IMMUTABLE}.&amp;lt;/li&amp;gt;
如：CopyOnWriteArrayList是一个不可变的源。

先拷贝，再追加。  （但是效率会下降。）适合读多写少的操作。
 
 
 * &amp;lt;li&amp;gt;The source manages concurrent modifications.
 源本身自己去管理并发。
 * &amp;lt;br&amp;gt;For example, a key set of a {@link java.util.concurrent.ConcurrentHashMap}
 * is a concurrent source.  A Spliterator created from the source reports a
 * characteristic of {@code CONCURRENT}.&amp;lt;/li&amp;gt;
 如：ConcurrentHashMap 。 创建的是并发源
 
 * &amp;lt;li&amp;gt;The mutable source provides a late-binding and fail-fast Spliterator.
 * &amp;lt;br&amp;gt;Late binding narrows the window during which interference can affect
 * the calculation; fail-fast detects, on a best-effort basis, that structural
 * interference has occurred after traversal has commenced and throws
 * {@link ConcurrentModificationException}.  For example, {@link ArrayList},
 * and many other non-concurrent {@code Collection} classes in the JDK, provide
 * a late-binding, fail-fast spliterator.&amp;lt;/li&amp;gt;
 可变的源提供了延迟绑定和快速失败的迭代分割器。
 会限制时间点的缩短。
 如果在遍历中修改，则会抛出ConcurrentModificationException。
 
 * &amp;lt;li&amp;gt;The mutable source provides a non-late-binding but fail-fast Spliterator.
 * &amp;lt;br&amp;gt;The source increases the likelihood of throwing
 * {@code ConcurrentModificationException} since the window of potential
 * interference is larger.&amp;lt;/li&amp;gt;
 
 
 * &amp;lt;li&amp;gt;The mutable source provides a late-binding and non-fail-fast Spliterator.
 * &amp;lt;br&amp;gt;The source risks arbitrary, non-deterministic behavior after traversal
 * has commenced since interference is not detected.
 
 
 * &amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;The mutable source provides a non-late-binding and non-fail-fast
 * Spliterator.
 * &amp;lt;br&amp;gt;The source increases the risk of arbitrary, non-deterministic behavior
 * since non-detected interference may occur after construction.
 * &amp;lt;/li&amp;gt;
 总结。
 1. 源是不是并发的
 2. 是不是快速绑定的，是不是快速失败的（2*2 组合的四种情况。）
 
 * &amp;lt;/ul&amp;gt;
 *
 
 串行案例
 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Example.&amp;lt;/b&amp;gt; Here is a class (not a very useful one, except
 * for illustration) that maintains an array in which the actual data
 * are held in even locations, and unrelated tag data are held in odd
 * locations. Its Spliterator ignores the tags.
 如：类维护了一个数组。 实际的数据是在偶数的位置上存放。不想管的标签数据是存放在奇数位置上。
 
 *
 * &amp;lt;pre&amp;gt; {@code
 * class TaggedArray&amp;lt;T&amp;gt; {
 *   private final Object[] elements; // immutable after construction
 *   TaggedArray(T[] data, Object[] tags) {
 *     int size = data.length;
 *     if (tags.length != size) throw new IllegalArgumentException();
 *     this.elements = new Object[2 * size];
 *     for (int i = 0, j = 0; i &amp;lt; size; ++i) {
 *       elements[j++] = data[i];
 *       elements[j++] = tags[i];
 *     }
 *   }
 *
 *   public Spliterator&amp;lt;T&amp;gt; spliterator() {
 *     return new TaggedArraySpliterator&amp;lt;&amp;gt;(elements, 0, elements.length);
 *   }
 *
 *   static class TaggedArraySpliterator&amp;lt;T&amp;gt; implements Spliterator&amp;lt;T&amp;gt; {
 *     private final Object[] array;
 *     private int origin; // current index, advanced on split or traversal
 *     private final int fence; // one past the greatest index
 *
 *     TaggedArraySpliterator(Object[] array, int origin, int fence) {
 *       this.array = array; this.origin = origin; this.fence = fence;
 *     }
 *
 *     public void forEachRemaining(Consumer&amp;lt;? super T&amp;gt; action) {
 *       for (; origin &amp;lt; fence; origin += 2)
 *         action.accept((T) array[origin]);
 *     }
 *
 *     public boolean tryAdvance(Consumer&amp;lt;? super T&amp;gt; action) {
 *       if (origin &amp;lt; fence) {
 *         action.accept((T) array[origin]);
 *         origin += 2;
 *         return true;
 *       }
 *       else // cannot advance
 *         return false;
 *     }
 *
 *     public Spliterator&amp;lt;T&amp;gt; trySplit() {
 *       int lo = origin; // divide range in half
 *       int mid = ((lo + fence) &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; ~1; // force midpoint to be even
 *       if (lo &amp;lt; mid) { // split out left half
 *         origin = mid; // reset this Spliterator's origin
 *         return new TaggedArraySpliterator&amp;lt;&amp;gt;(array, lo, mid);
 *       }
 *       else       // too small to split
 *         return null;
 *     }
 *
 *     public long estimateSize() {
 *       return (long)((fence - origin) / 2);
 *     }
 *
 *     public int characteristics() {
 *       return ORDERED | SIZED | IMMUTABLE | SUBSIZED;
 *     }
 *   }
 * }}&amp;lt;/pre&amp;gt;
 *
 
 并行案例：
 * &amp;lt;p&amp;gt;As an example how a parallel computation framework, such as the
 * {@code java.util.stream} package, would use Spliterator in a parallel
 * computation, here is one way to implement an associated parallel forEach,
 * that illustrates the primary usage idiom of splitting off subtasks until
 * the estimated amount of work is small enough to perform
 * sequentially. Here we assume that the order of processing across
 * subtasks doesn't matter; different (forked) tasks may further split
 * and process elements concurrently in undetermined order.  This
 * example uses a {@link java.util.concurrent.CountedCompleter};
 * similar usages apply to other parallel task constructions.
 *
 * &amp;lt;pre&amp;gt;{@code
 * static &amp;lt;T&amp;gt; void parEach(TaggedArray&amp;lt;T&amp;gt; a, Consumer&amp;lt;T&amp;gt; action) {
 *   Spliterator&amp;lt;T&amp;gt; s = a.spliterator();
 *   long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);
 *   new ParEach(null, s, action, targetBatchSize).invoke();
 * }
 *
 * static class ParEach&amp;lt;T&amp;gt; extends CountedCompleter&amp;lt;Void&amp;gt; {
 *   final Spliterator&amp;lt;T&amp;gt; spliterator;
 *   final Consumer&amp;lt;T&amp;gt; action;
 *   final long targetBatchSize;
 *
 *   ParEach(ParEach&amp;lt;T&amp;gt; parent, Spliterator&amp;lt;T&amp;gt; spliterator,
 *           Consumer&amp;lt;T&amp;gt; action, long targetBatchSize) {
 *     super(parent);
 *     this.spliterator = spliterator; this.action = action;
 *     this.targetBatchSize = targetBatchSize;
 *   }
 *
 *   public void compute() {
 *     Spliterator&amp;lt;T&amp;gt; sub;
 *     while (spliterator.estimateSize() &amp;gt; targetBatchSize &amp;amp;&amp;amp;
 *            (sub = spliterator.trySplit()) != null) {
 *       addToPendingCount(1);
 *       new ParEach&amp;lt;&amp;gt;(this, sub, action, targetBatchSize).fork();
 *     }
 *     spliterator.forEachRemaining(action);
 *     propagateCompletion();
 *   }
 * }}&amp;lt;/pre&amp;gt;
 *
 * @implNote
 * If the boolean system property {@code org.openjdk.java.util.stream.tripwire}
 * is set to {@code true} then diagnostic warnings are reported if boxing of
 * primitive values occur when operating on primitive subtype specializations.
 *
 * @param &amp;lt;T&amp;gt; the type of elements returned by this Spliterator
 *
 * @see Collection
 * @since 1.8
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;serial-thread-confinement&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;我们再来看看spliterator类中的方法&quot;&gt;我们再来看看Spliterator类中的方法&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;tryAdvance() 尝试遍历，对元素执行动作。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * If a remaining element exists, performs the given action on it,
     * returning {@code true}; else returns {@code false}.  If this
     * Spliterator is {@link #ORDERED} the action is performed on the
     * next element in encounter order.  Exceptions thrown by the
     * action are relayed to the caller.
     *
     * @param action The action
     * @return {@code false} if no remaining elements existed
     * upon entry to this method, else {@code true}.
     * @throws NullPointerException if the specified action is null
     */
    boolean tryAdvance(Consumer&amp;lt;? super T&amp;gt; action);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;forEachRemaining() 。通过函数式接口 调用tryAdvance().&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * Performs the given action for each remaining element, sequentially in
     * the current thread, until all elements have been processed or the action
     * throws an exception.  If this Spliterator is {@link #ORDERED}, actions
     * are performed in encounter order.  Exceptions thrown by the action
     * are relayed to the caller.
     *
     * @implSpec
     * The default implementation repeatedly invokes {@link #tryAdvance} until
     * it returns {@code false}.  It should be overridden whenever possible.
     *
     * @param action The action
     * @throws NullPointerException if the specified action is null
     */
    default void forEachRemaining(Consumer&amp;lt;? super T&amp;gt; action) {
        do { } while (tryAdvance(action));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;trySplit() 尝试进行分割&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * If this spliterator can be partitioned, returns a Spliterator
     * covering elements, that will, upon return from this method, not
     * be covered by this Spliterator.
     如果这个分割迭代器能够被进行分割。就会返回一个 涵盖这个元素的Spliterator，
     分割出来的新的Spliterator可能会被继续分割，剩下的继续又当前的Spliterator涵盖
     *
     * &amp;lt;p&amp;gt;If this Spliterator is {@link #ORDERED}, the returned Spliterator
     * must cover a strict prefix of the elements.
     如果  Spliterator is {@link #ORDERED}。返回的必须是ORDERED的
     
     *
     * &amp;lt;p&amp;gt;Unless this Spliterator covers an infinite number of elements,
     * repeated calls to {@code trySplit()} must eventually return {@code null}.
     除非这个 Spliterator 涵盖的事一个无限的元素。 
     否则，必须被确认返回个数是确定的。
     重复的去继续分割，分割到不能再分割。 （一定会有这样的情况。）
     
     * Upon non-null return:
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;the value reported for {@code estimateSize()} before splitting,
     * must, after splitting, be greater than or equal to {@code estimateSize()}
     * for this and the returned Spliterator; and&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;if this Spliterator is {@code SUBSIZED}, then {@code estimateSize()}
     * for this spliterator before splitting must be equal to the sum of
     * {@code estimateSize()} for this and the returned Spliterator after
     * splitting.&amp;lt;/li&amp;gt;
     * &amp;lt;/ul&amp;gt;
     如果不会空：
     分割前的  estimateSize()的返回值，必须大于等于分割之后estimateSize()的返回值。
     
     如果 Spliterator is {@code SUBSIZED}，那么 分割之前  estimateSize()的大小，必须等于 分割之后的 estimateSize() 和返回来的值的大小。（分割前后：必须 8 = 4+4.）
     
     *
     * &amp;lt;p&amp;gt;This method may return {@code null} for any reason,
     * including emptiness, inability to split after traversal has
     * commenced, data structure constraints, and efficiency
     * considerations.
     这个放个出于以下原因，都会返回Null值
     1. emptiness
     
     *
     * @apiNote
     * An ideal {@code trySplit} method efficiently (without
     * traversal) divides its elements exactly in half, allowing
     * balanced parallel computation.  Many departures from this ideal
     * remain highly effective; for example, only approximately
     * splitting an approximately balanced tree, or for a tree in
     * which leaf nodes may contain either one or two elements,
     * failing to further split these nodes.  However, large
     * deviations in balance and/or overly inefficient {@code
     * trySplit} mechanics typically result in poor parallel
     * performance.
     @API文档
     一种理想的trySplit()方法，会恰好将元素分为两半。允许平衡的并行计算。
     很多情况下违背了这种理想的情况。
     比如说：只是分割一个嫉妒不平衡的一个数，数中只有两个节点。等。不能再次进行分割。
     然而，很不平衡的这种机制，会导致并发效率的极度降低。
     
     *
     * @return a {@code Spliterator} covering some portion of the
     * elements, or {@code null} if this spliterator cannot be split
     返回一个Spliterator
     
     */
    Spliterator&amp;lt;T&amp;gt; trySplit();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;estimateSize() 估算大小。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * Returns an estimate of the number of elements that would be
     * encountered by a {@link #forEachRemaining} traversal, or returns {@link
     * Long#MAX_VALUE} if infinite, unknown, or too expensive to compute.
     返回元素数量的估算值。（会被forEachRemaining 遍历的元素）
     infinite, unknown, or too expensive to compute.这几种情况会返回：MAX_VALUE
     
     *
     * &amp;lt;p&amp;gt;If this Spliterator is {@link #SIZED} and has not yet been partially
     * traversed or split, or this Spliterator is {@link #SUBSIZED} and has
     * not yet been partially traversed, this estimate must be an accurate
     * count of elements that would be encountered by a complete traversal.
     * Otherwise, this estimate may be arbitrarily inaccurate, but must decrease
     * as specified across invocations of {@link #trySplit}.
     如果Spliterator是SIZED 或者是SUBSIZED 。那个 这个元素的estimate值一定是精确的。
     然而，必须要减少 trySplit 的调用。
     
     *
     * @apiNote
     * Even an inexact estimate is often useful and inexpensive to compute.
     * For example, a sub-spliterator of an approximately balanced binary tree
     * may return a value that estimates the number of elements to be half of
     * that of its parent; if the root Spliterator does not maintain an
     * accurate count, it could estimate size to be the power of two
     * corresponding to its maximum depth.
     甚至一个不太精确的估算，也是有用的。
     
     *
     * @return the estimated size, or {@code Long.MAX_VALUE} if infinite,
     *         unknown, or too expensive to compute.
     */
    long estimateSize();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;getExactSizeIfKnown() 如果知道的话就会返回确定的大小。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * Convenience method that returns {@link #estimateSize()} if this
     * Spliterator is {@link #SIZED}, else {@code -1}.
     如果Spliterator是SIZED的话， estimateSize就会返回确定的大小。
     
     * @implSpec
     * The default implementation returns the result of {@code estimateSize()}
     * if the Spliterator reports a characteristic of {@code SIZED}, and
     * {@code -1} otherwise.
     *
     * @return the exact size, if known, else {@code -1}.
     */
    default long getExactSizeIfKnown() {
        return (characteristics() &amp;amp; SIZED) == 0 ? -1L : estimateSize();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;characteristics() 特性值。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * Returns a set of characteristics of this Spliterator and its
     * elements. The result is represented as ORed values from {@link
     * #ORDERED}, {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED},
     * {@link #NONNULL}, {@link #IMMUTABLE}, {@link #CONCURRENT},
     * {@link #SUBSIZED}.  Repeated calls to {@code characteristics()} on
     * a given spliterator, prior to or in-between calls to {@code trySplit},
     * should always return the same result.
     返回这个Spliterator的特性值的集合。
     {@link#ORDERED},
     {@link #DISTINCT}, 
     {@link #SORTED}, 
     {@link #SIZED},
     {@link #NONNULL},
     {@link #IMMUTABLE}, 
     {@link #CONCURRENT},
     {@link #SUBSIZED}
     这8个，在下面有定义。
     
     *
     * &amp;lt;p&amp;gt;If a Spliterator reports an inconsistent set of
     * characteristics (either those returned from a single invocation
     * or across multiple invocations), no guarantees can be made
     * about any computation using this Spliterator.
     *
     * @apiNote The characteristics of a given spliterator before splitting
     * may differ from the characteristics after splitting.  For specific
     * examples see the characteristic values {@link #SIZED}, {@link #SUBSIZED}
     * and {@link #CONCURRENT}.
     具体的例子看下面的说明。
     
     *
     * @return a representation of characteristics
     */
    int characteristics();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;hasCharacteristics(int characteristics) 查看是否包含给定的特性值&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * Returns {@code true} if this Spliterator's {@link
     * #characteristics} contain all of the given characteristics.
     *
     * @implSpec
     * The default implementation returns true if the corresponding bits
     * of the given characteristics are set.
     *
     * @param characteristics the characteristics to check for
     * @return {@code true} if all the specified characteristics are present,
     * else {@code false}
     */
    default boolean hasCharacteristics(int characteristics) {
        return (characteristics() &amp;amp; characteristics) == characteristics;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;getComparator() ：抛出一个不可实现的状态异常。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * If this Spliterator's source is {@link #SORTED} by a {@link Comparator},
     * returns that {@code Comparator}. If the source is {@code SORTED} in
     * {@linkplain Comparable natural order}, returns {@code null}.  Otherwise,
     * if the source is not {@code SORTED}, throws {@link IllegalStateException}.
     如果源是有序的，返回用于排序的  Comparator
     如果是按照自然排序的，就返回空 （就不需要比较器）
     否则就抛出异常，
     *
     * @implSpec
     * The default implementation always throws {@link IllegalStateException}.
     *
     * @return a Comparator, or {@code null} if the elements are sorted in the
     * natural order.
     * @throws IllegalStateException if the spliterator does not report
     *         a characteristic of {@code SORTED}.
     */
    default Comparator&amp;lt;? super T&amp;gt; getComparator() {
        throw new IllegalStateException();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;8个特性值&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ORDERED
DISTINCT
SORTED
SIZED
NONNULL
IMMUTABLE
CONCURRENT
SUBSIZED
   //更多的是用在并发的时候，指定执行哪些内容。
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;我们再来看看spliterator中的8种characteristic&quot;&gt;我们再来看看Spliterator中的8种Characteristic&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * Characteristic value signifying that an encounter order is defined for
     * elements. If so, this Spliterator guarantees that method
     * {@link #trySplit} splits a strict prefix of elements, that method
     * {@link #tryAdvance} steps by one element in prefix order, and that
     * {@link #forEachRemaining} performs actions in encounter order.
     *
     * &amp;lt;p&amp;gt;A {@link Collection} has an encounter order if the corresponding
     * {@link Collection#iterator} documents an order. If so, the encounter
     * order is the same as the documented order. Otherwise, a collection does
     * not have an encounter order.
     *
     * @apiNote Encounter order is guaranteed to be ascending index order for
     * any {@link List}. But no order is guaranteed for hash-based collections
     * such as {@link HashSet}. Clients of a Spliterator that reports
     * {@code ORDERED} are expected to preserve ordering constraints in
     * non-commutative parallel computations.
     */
    public static final int ORDERED    = 0x00000010;

    /**
     * Characteristic value signifying that, for each pair of
     * encountered elements {@code x, y}, {@code !x.equals(y)}. This
     * applies for example, to a Spliterator based on a {@link Set}.
     */
    public static final int DISTINCT   = 0x00000001;

    /**
     * Characteristic value signifying that encounter order follows a defined
     * sort order. If so, method {@link #getComparator()} returns the associated
     * Comparator, or {@code null} if all elements are {@link Comparable} and
     * are sorted by their natural ordering.
     *
     * &amp;lt;p&amp;gt;A Spliterator that reports {@code SORTED} must also report
     * {@code ORDERED}.
     *
     * @apiNote The spliterators for {@code Collection} classes in the JDK that
     * implement {@link NavigableSet} or {@link SortedSet} report {@code SORTED}.
     */
    public static final int SORTED     = 0x00000004;

    /**
     * Characteristic value signifying that the value returned from
     * {@code estimateSize()} prior to traversal or splitting represents a
     * finite size that, in the absence of structural source modification,
     * represents an exact count of the number of elements that would be
     * encountered by a complete traversal.
     在执行遍历或者分割之前，由estimateSize返回的值，表示一个有序的大小。
     表示元素的数量的精确的值。
     *
     * @apiNote Most Spliterators for Collections, that cover all elements of a
     * {@code Collection} report this characteristic. Sub-spliterators, such as
     * those for {@link HashSet}, that cover a sub-set of elements and
     * approximate their reported size do not.
     大部分对于Collections的分割迭代器，一般都会有这个特性值。
     */

    public static final int SIZED      = 0x00000040;

    /**
     * Characteristic value signifying that the source guarantees that
     * encountered elements will not be {@code null}. (This applies,
     * for example, to most concurrent collections, queues, and maps.)
     */
    public static final int NONNULL    = 0x00000100;

    /**
     * Characteristic value signifying that the element source cannot be
     * structurally modified; that is, elements cannot be added, replaced, or
     * removed, so such changes cannot occur during traversal. A Spliterator
     * that does not report {@code IMMUTABLE} or {@code CONCURRENT} is expected
     * to have a documented policy (for example throwing
     * {@link ConcurrentModificationException}) concerning structural
     * interference detected during traversal.
     指定元素的源是不能被修改的，不能被（be added, replaced, or removed）。
     
     在执行的时候，如果发现被修改，没有返回，则会抛出ConcurrentModificationException并发修改异常。
     */
    public static final int IMMUTABLE  = 0x00000400;

    /**
     * Characteristic value signifying that the element source may be safely
     * concurrently modified (allowing additions, replacements, and/or removals)
     * by multiple threads without external synchronization. If so, the
     * Spliterator is expected to have a documented policy concerning the impact
     * of modifications during traversal.
     表示元素的源能够安全的被并发修改。允许 modified (allowing additions, replacements, and/or removals)。
     不需要外部的同步化的操作。Spliterator的提供了允许被修改的策略。
     
     *
     * &amp;lt;p&amp;gt;A top-level Spliterator should not report both {@code CONCURRENT} and
     * {@code SIZED}, since the finite size, if known, may change if the source
     * is concurrently modified during traversal. Such a Spliterator is
     * inconsistent and no guarantees can be made about any computation using
     * that Spliterator. Sub-spliterators may report {@code SIZED} if the
     * sub-split size is known and additions or removals to the source are not
     * reflected when traversing.
     顶层的Spliterator 不应该同时返回：{@code CONCURRENT} and {@code SIZED}。
     因为两者之间存在一定的矛盾性。
     这个的Spliterator 是不一直到，
     得到的Sub-spliterators 可能会返回SIZED。
     
     
     *
     * @apiNote Most concurrent collections maintain a consistency policy
     * guaranteeing accuracy with respect to elements present at the point of
     * Spliterator construction, but possibly not reflecting subsequent
     * additions or removals.
     大多是的这种并发性的集合，都会被维护一定的策略。
     ：原有的Spliterator ，不会去影响子的Spliterator
     */
    public static final int CONCURRENT = 0x00001000;

    /**
     * Characteristic value signifying that all Spliterators resulting from
     * {@code trySplit()} will be both {@link #SIZED} and {@link #SUBSIZED}.
     * (This means that all child Spliterators, whether direct or indirect, will
     * be {@code SIZED}.)
     
     *
     * &amp;lt;p&amp;gt;A Spliterator that does not report {@code SIZED} as required by
     * {@code SUBSIZED} is inconsistent and no guarantees can be made about any
     * computation using that Spliterator.
     A Spliterator如果没有返回要求的SIZED。 是没有明确的保证的。
     *
     * @apiNote Some spliterators, such as the top-level spliterator for an
     * approximately balanced binary tree, will report {@code SIZED} but not
     * {@code SUBSIZED}, since it is common to know the size of the entire tree
     * but not the exact sizes of subtrees.
     有一些Spliterator。如二叉树的整个树的大小，我们得知总的数，但是不知道子的数。
     */
    public static final int SUBSIZED = 0x00004000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是关于spliterator的interface所有内容。&lt;/p&gt;
&lt;p&gt;Spliterator都支持哪些事情？上面的8个方法。就是具体功能的实现。&lt;/p&gt;
&lt;h4 id=&quot;ofprimitive&quot;&gt;OfPrimitive&lt;/h4&gt;
&lt;p&gt;专门针对于原生的迭代器（int, long, double）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * A Spliterator specialized for primitive values.
     *
     * @param &amp;lt;T&amp;gt; the type of elements returned by this Spliterator.  The
     * type must be a wrapper type for a primitive type, such as {@code Integer}
     * for the primitive {@code int} type.
     * @param &amp;lt;T_CONS&amp;gt; the type of primitive consumer.  The type must be a
     * primitive specialization of {@link java.util.function.Consumer} for
     * {@code T}, such as {@link java.util.function.IntConsumer} for
     * {@code Integer}.
     * @param &amp;lt;T_SPLITR&amp;gt; the type of primitive Spliterator.  The type must be
     * a primitive specialization of Spliterator for {@code T}, such as
     * {@link Spliterator.OfInt} for {@code Integer}.
     *
     * @see Spliterator.OfInt
     * @see Spliterator.OfLong
     * @see Spliterator.OfDouble
     * @since 1.8
     */
public interface OfPrimitive&amp;lt;T, T_CONS, T_SPLITR extends Spliterator.OfPrimitive&amp;lt;T, T_CONS, T_SPLITR&amp;gt;&amp;gt;
            extends Spliterator&amp;lt;T&amp;gt; {
        @Override
        T_SPLITR trySplit();

        /**
         * If a remaining element exists, performs the given action on it,
         * returning {@code true}; else returns {@code false}.  If this
         * Spliterator is {@link #ORDERED} the action is performed on the
         * next element in encounter order.  Exceptions thrown by the
         * action are relayed to the caller.
         *
         * @param action The action
         * @return {@code false} if no remaining elements existed
         * upon entry to this method, else {@code true}.
         * @throws NullPointerException if the specified action is null
         */
        @SuppressWarnings(&quot;overloads&quot;)
        boolean tryAdvance(T_CONS action);

        /**
         * Performs the given action for each remaining element, sequentially in
         * the current thread, until all elements have been processed or the
         * action throws an exception.  If this Spliterator is {@link #ORDERED},
         * actions are performed in encounter order.  Exceptions thrown by the
         * action are relayed to the caller.
         *
         * @implSpec
         * The default implementation repeatedly invokes {@link #tryAdvance}
         * until it returns {@code false}.  It should be overridden whenever
         * possible.
         *
         * @param action The action
         * @throws NullPointerException if the specified action is null
         */
        @SuppressWarnings(&quot;overloads&quot;)
        default void forEachRemaining(T_CONS action) {
            do { } while (tryAdvance(action));
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提供了三个特化版本。实现了OfPrimitive接口。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;OfInt&lt;/li&gt;
&lt;li&gt;OfLong&lt;/li&gt;
&lt;li&gt;OfDouble&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;ofint&quot;&gt;OfInt&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface OfInt extends OfPrimitive&amp;lt;Integer, IntConsumer, OfInt&amp;gt; {

        @Override
        OfInt trySplit();

        @Override
        boolean tryAdvance(IntConsumer action);

        @Override
        default void forEachRemaining(IntConsumer action) {
            do { } while (tryAdvance(action));
        }

        /**
         * {@inheritDoc}
         * @implSpec
         * If the action is an instance of {@code IntConsumer} then it is cast
         * to {@code IntConsumer} and passed to
         * {@link #tryAdvance(java.util.function.IntConsumer)}; otherwise
         * the action is adapted to an instance of {@code IntConsumer}, by
         * boxing the argument of {@code IntConsumer}, and then passed to
         * {@link #tryAdvance(java.util.function.IntConsumer)}.
         */
        @Override
        default boolean tryAdvance(Consumer&amp;lt;? super Integer&amp;gt; action) {
            if (action instanceof IntConsumer) {
                return tryAdvance((IntConsumer) action);
            }
            else {
                if (Tripwire.ENABLED)
                    Tripwire.trip(getClass(),
                                  &quot;{0} calling Spliterator.OfInt.tryAdvance((IntConsumer) action::accept)&quot;);
                return tryAdvance((IntConsumer) action::accept);
            }
        }

        /**
         * {@inheritDoc}
         * @implSpec
         * If the action is an instance of {@code IntConsumer} then it is cast
         * to {@code IntConsumer} and passed to
         * {@link #forEachRemaining(java.util.function.IntConsumer)}; otherwise
         * the action is adapted to an instance of {@code IntConsumer}, by
         * boxing the argument of {@code IntConsumer}, and then passed to
         * {@link #forEachRemaining(java.util.function.IntConsumer)}.
         */
        @Override
        default void forEachRemaining(Consumer&amp;lt;? super Integer&amp;gt; action) {
            if (action instanceof IntConsumer) {
                forEachRemaining((IntConsumer) action);
            }
            else {
                if (Tripwire.ENABLED)
                    Tripwire.trip(getClass(),
                                  &quot;{0} calling Spliterator.OfInt.forEachRemaining((IntConsumer) action::accept)&quot;);
                forEachRemaining((IntConsumer) action::accept);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;问题：要知道Consumer和IntConsumer是没有任何继承关系的话，他们是怎么实现类型转换的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; default boolean tryAdvance(Consumer&amp;lt;? super Integer&amp;gt; action) {
            if (action instanceof IntConsumer) {
                return tryAdvance((IntConsumer) action);
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是纯粹的面向对象的，这种现象是完全不能够存在的。&lt;/p&gt;
&lt;p&gt;但是如果是在这函数式编程的情况下，是能够存在的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;java中存在自动装箱和拆箱的操作 （int-&amp;gt;Integer）&lt;/li&gt;
&lt;li&gt;强制类型的转换在纯粹的面向对象是一定要存在继承关系的，根本原因还在于函数式编程的lambda上面&lt;/li&gt;
&lt;li&gt;lambda的一切信息都是通过上下文推断出来的。（对于同一个lambda表达式，在不同类型中可能推断出来的结果是不同的。在函数式编程中，这种现象是存在的。）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;用代码来解释。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 07 Jan 2020 00:25:00 +0000</pubDate>
<dc:creator>dawa大娃bigbaby</dc:creator>
<og:description>Stream底层的实现 Stream接口实现了 BaseStream 接口，我们先来看看BaseStream的定义 BaseStream BaseStream是所有流的父类接口。 对JavaDoc做一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigbaby/p/12159495.html</dc:identifier>
</item>
<item>
<title>「每日五分钟，玩转JVM」：指针压缩 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12159433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12159433.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;29&quot;&gt;
&lt;h3 id=&quot;h64jvm32jvm&quot;&gt;&lt;span&gt;64位JVM和32位JVM&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;最初的时候，JVM是32位的，但是随着64位系统的兴起，JVM也迎来了从32位到64位的转换，32位的JVM对比64位的内存容量比较有限，但是我们使用64位虚拟机的同时，也带来了一个问题，64位下的JVM中的对象会比32位中的对象多占用1.5倍的内存空间，这是我们不想看到的（又要马儿跑，又要马儿不吃草可还行？），但是机智的程序员不会屈服，所以在JDK 1.6的版本后，我们在64位中的JVM中可以开启指针压缩（UseCompressedOops）来压缩我们对象指针的大小来帮助我们节约内存空间，拿JDK 8来说，这个指令是默认开启的。&lt;/p&gt;
&lt;p&gt;如果我想要知道我们电脑上安装的JVM是32位的还是64位的，可以通过下面的这个命令去查看&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-09-11-121750.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;如果我们的系统是64位的，当我们输入&lt;code&gt;java -d32&lt;/code&gt;的时候会提示不支持32位的JVM，或者我们通过&lt;code&gt;java -version&lt;/code&gt;也可以看到：&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-09-11-121938.png&quot; alt=&quot;image-20190911201937600&quot; title=&quot;image-20190911201937600&quot;/&gt;image-20190911201937600
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;指针压缩&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当我们启用了&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;之后，我们原本的OOP（Ordinary Object Pointer，普通对象指针）就会被压缩，当然也不是所有的对象都会被压缩，只有 以下几种的对象才会被压缩&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对象的&lt;strong&gt;全局静态变量&lt;/strong&gt;（类属性）&lt;/p&gt;
&lt;p&gt;对象头信息&lt;/p&gt;
&lt;p&gt;对象的引用类型&lt;/p&gt;
&lt;p&gt;对象数组类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而以下几种对象则不能被压缩：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;指向PermGen的Class对象指针&lt;/p&gt;
&lt;p&gt;局部变量&lt;/p&gt;
&lt;p&gt;传参&lt;/p&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;p&gt;NULL指针&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;指针压缩的大概原理：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过对齐，还有偏移量将64位指针压缩成32位。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;零基压缩是针对压缩解压动作的进一步优化。 它通过&lt;strong&gt;改变正常指针的随机地址分配特性&lt;/strong&gt;，&lt;strong&gt;强制堆地址从零开始分配&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-09-11-123526.png&quot; alt=&quot;image-20190911203525671&quot; title=&quot;image-20190911203525671&quot;/&gt;image-20190911203525671
&lt;p&gt;这里需要注意：32位HotSpot VM是不支持UseCompressedOops参数的，只有64位HotSpot VM才支持。&lt;/p&gt;
&lt;h3 id=&quot;h32bit64bit&quot;&gt;&lt;span&gt;下面是32bit和64bit下的压缩或者不压缩所占的大小~&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-09-11-141738.png&quot; alt=&quot;image-20190911221738200&quot; title=&quot;image-20190911221738200&quot;/&gt;image-20190911221738200
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;在内存结构中的不同&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-23-151212.png&quot; alt=&quot;image-20190823231212050&quot; title=&quot;image-20190823231212050&quot;/&gt;image-20190823231212050
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;公众号&lt;/span&gt;&lt;/h3&gt;

&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1528535/202001/1528535-20200107064620474-1790652425.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 22:47:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>64位JVM和32位JVM 最初的时候，JVM是32位的，但是随着64位系统的兴起，JVM也迎来了从32位到64位的转换，32位的JVM对比64位的内存容量比较有限，但是我们使用64位虚拟机的同时，也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12159433.html</dc:identifier>
</item>
<item>
<title>Linux磁盘管理之LVM - qiuhom</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12156146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12156146.html</guid>
<description>&lt;p&gt;　　一、LVM介绍&lt;/p&gt;
&lt;p&gt;　　在我们管理Linux磁盘的时候，通常会遇到这么一种情况。在最初规划Linux的磁盘的时候，我们给某个分区划分了一定量的磁盘空间，使用一段时间后，发现我们规划的磁盘空间不足了，这个时候怎么办？我们肯定要想办法给扩容呀，找一块磁盘分区，格式化，然后挂载，然后把数据拷贝到新加的磁盘上，然后把原有的磁盘卸载掉，通常我们是这样做的。这样一来虽然达到了扩容的目的，但是费时费力；如果第二次扩容，空间还是不够，我们又要重复上面的步骤；如果分配的磁盘空间过大，使用了很久才发现它根本用不到那么多空间，这个时候是不是又要调整呀，听着就感觉很繁琐。这时候你肯定要想有没有那种可挂载上一块盘，我们利用某种管理手段，可以在线的调整磁盘的空间，这样有节约了时间，也可实现弹性管理磁盘。对，lvm就有这样的功能。&lt;/p&gt;
&lt;p&gt;　　LVM（logical volume manager）逻辑卷管理，它可以弹性的管理文件系统的容量，LVM的工作原理是将一个或多个底层块设备组织成一个逻辑设备，这个逻辑设备可以在未来新增或移除其他的分区到这个逻辑设备中，从而实现了弹性管理磁盘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200106142621241-675975898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　PV：物理卷（physical volume）；物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备（如raid），是LVM的基本储存逻辑块，但和基本的物理存储介质（如分区，磁盘等）比较，却包含有与LVM相关的管理参数&lt;/p&gt;
&lt;p&gt;　　VG：卷组（volume group）LVM卷组类似于非LVM系统中的物理硬盘，尤其物理卷组成，可以在卷组上创建一个或多个LVM分区（逻辑卷），LVM卷组由一个或多个物理卷组成&lt;/p&gt;
&lt;p&gt;　　LV：逻辑卷（logical volume）LVM的逻辑卷类似非LVM系统中的硬盘分区，在逻辑卷之上可以创建文件系统。&lt;/p&gt;
&lt;p&gt;　　LVM就是将一些零碎的磁盘分区（PV）合并成一个较大的磁盘（VG），然后在根据需要对这个较大的磁盘（VG）进行划分成不同的大小分区（LV），这些小的分区（LV）是可以动态的扩展和缩小的，这就是LVM的逻辑卷管理过程。所谓LVM的大磁盘就是将许多PV整合成的VG，那么这个大磁盘最大可达到多少容量呢？我们知道在文件系统里面数据存储的最小单位是块（block），不过在LVM当中数据储存的最小单位是PE，PE的的作用同block的作用一样，需要注意到是LVM默认使用的PE大小是4M，而LVM的VG最多能包含65534个PE，也就是说默认LVM的VG会有4×65534M/1024M=256G，所以PE的大小决定了VG的最大容量，当然我们在创建VG的时候可指定PE大小，从而来决定VG的大小。&lt;/p&gt;
&lt;p&gt;　　二、LVM实现&lt;/p&gt;
&lt;p&gt;　　1）前期准备几块硬盘或者分区来模拟PV&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;70&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   50G  0 disk 
├─sda1   8:1    0    2G  0 part /boot
├─sda2   8:2    0    2G  0 part [SWAP]
└─sda3   8:3    0   46G  0 part /
sdb      8:16   0   50G  0 disk 
sr0     11:0    1  792M  0 rom  
[root@test-centos7-node1 ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x6180123f.

Command (m for help): p

Disk /dev/sdb: 53.7 GB, 53687091200 bytes, 104857600 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x6180123f

   Device Boot      Start         End      Blocks   Id  System

Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 
First sector (2048-104857599, default 2048): 
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-104857599, default 104857599): +10G
Partition 1 of type Linux and of size 10 GiB is set

Command (m for help): p

Disk /dev/sdb: 53.7 GB, 53687091200 bytes, 104857600 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x6180123f

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    20973567    10485760   83  Linux

Command (m for help): t
Selected partition 1
Hex code (type L to list all codes): 8e
Changed type of partition 'Linux' to 'Linux LVM'

Command (m for help): n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): p
Partition number (2-4, default 2): 
First sector (20973568-104857599, default 20973568): 
Using default value 20973568
Last sector, +sectors or +size{K,M,G} (20973568-104857599, default 104857599): +10G
Partition 2 of type Linux and of size 10 GiB is set

Command (m for help): t
Partition number (1,2, default 2): 
Hex code (type L to list all codes): 8e
Changed type of partition 'Linux' to 'Linux LVM'

Command (m for help): n
Partition type:
   p   primary (2 primary, 0 extended, 2 free)
   e   extended
Select (default p): p
Partition number (3,4, default 3): 
First sector (41945088-104857599, default 41945088): 
Using default value 41945088
Last sector, +sectors or +size{K,M,G} (41945088-104857599, default 104857599): +10G
Partition 3 of type Linux and of size 10 GiB is set

Command (m for help): t
Partition number (1-3, default 3): 
Hex code (type L to list all codes): 8e 
Changed type of partition 'Linux' to 'Linux LVM'

Command (m for help): p

Disk /dev/sdb: 53.7 GB, 53687091200 bytes, 104857600 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x6180123f

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    20973567    10485760   8e  Linux LVM
/dev/sdb2        20973568    41945087    10485760   8e  Linux LVM
/dev/sdb3        41945088    62916607    10485760   8e  Linux LVM

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
[root@test-centos7-node1 ~]# lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   50G  0 disk 
├─sda1   8:1    0    2G  0 part /boot
├─sda2   8:2    0    2G  0 part [SWAP]
└─sda3   8:3    0   46G  0 part /
sdb      8:16   0   50G  0 disk 
├─sdb1   8:17   0   10G  0 part 
├─sdb2   8:18   0   10G  0 part 
└─sdb3   8:19   0   10G  0 part 
sr0     11:0    1  792M  0 rom  
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这里是用的分区来模拟硬盘当作PV，这里需要注意一点，就是我们分区完保存后，可能存在不同不到问题，就是我们分区完用lsblk看不到分区，可用 partprobe来同步分区信息。centos6 使用partx  -a /dev/sdb来增加分区同步到内存，如果是删除某个分区，就需要执行partx -d -nr # /dev/sdb  此命令表示从/dev/sdb的分区信息中删除sdb#分区信息，并同步到内存中。这里还需要注意一点的是我们分区的类型要选8e 表示Linux LVM&lt;/p&gt;
&lt;p&gt;　　2）装lvm2这个包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# lvs
-bash: lvs: command not found
[root@test-centos7-node1 ~]# yum info  lvm2  
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Available Packages
Name        : lvm2
Arch        : x86_64
Epoch       : 7
Version     : 2.02.185
Release     : 2.el7_7.2
Size        : 1.3 M
Repo        : updates/7/x86_64
Summary     : Userland logical volume management tools
URL         : http://sources.redhat.com/lvm2
License     : GPLv2
Description : LVM2 includes all of the support for handling read/write operations on
            : physical volumes (hard disks, RAID-Systems, magneto optical, etc.,
            : multiple devices (MD), see mdadm(8) or even loop devices, see
            : losetup(8)), creating volume groups (kind of virtual disks) from one
            : or more physical volumes and creating one or more logical volumes
            : (kind of logical partitions) in volume groups.

[root@test-centos7-node1 ~]# yum install lvm2 -y
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package lvm2.x86_64 7:2.02.185-2.el7_7.2 will be installed
--&amp;gt; Processing Dependency: lvm2-libs = 7:2.02.185-2.el7_7.2 for package: 7:lvm2-2.02.185-2.el7_7.2.x86_64
--&amp;gt; Processing Dependency: device-mapper-persistent-data &amp;gt;= 0.7.0-0.1.rc6 for package: 7:lvm2-2.02.185-2.el7_7.2.x86_64
--&amp;gt; Processing Dependency: liblvm2app.so.2.2(Base)(64bit) for package: 7:lvm2-2.02.185-2.el7_7.2.x86_64
--&amp;gt; Processing Dependency: libdevmapper.so.1.02(DM_1_02_141)(64bit) for package: 7:lvm2-2.02.185-2.el7_7.2.x86_64
--&amp;gt; Processing Dependency: libdevmapper-event.so.1.02(Base)(64bit) for package: 7:lvm2-2.02.185-2.el7_7.2.x86_64
--&amp;gt; Processing Dependency: liblvm2app.so.2.2()(64bit) for package: 7:lvm2-2.02.185-2.el7_7.2.x86_64
--&amp;gt; Processing Dependency: libdevmapper-event.so.1.02()(64bit) for package: 7:lvm2-2.02.185-2.el7_7.2.x86_64
--&amp;gt; Running transaction check
---&amp;gt; Package device-mapper-event-libs.x86_64 7:1.02.158-2.el7_7.2 will be installed
---&amp;gt; Package device-mapper-libs.x86_64 7:1.02.140-8.el7 will be updated
--&amp;gt; Processing Dependency: device-mapper-libs = 7:1.02.140-8.el7 for package: 7:device-mapper-1.02.140-8.el7.x86_64
---&amp;gt; Package device-mapper-libs.x86_64 7:1.02.158-2.el7_7.2 will be an update
---&amp;gt; Package device-mapper-persistent-data.x86_64 0:0.8.5-1.el7 will be installed
---&amp;gt; Package lvm2-libs.x86_64 7:2.02.185-2.el7_7.2 will be installed
--&amp;gt; Processing Dependency: device-mapper-event = 7:1.02.158-2.el7_7.2 for package: 7:lvm2-libs-2.02.185-2.el7_7.2.x86_64
--&amp;gt; Running transaction check
---&amp;gt; Package device-mapper.x86_64 7:1.02.140-8.el7 will be updated
---&amp;gt; Package device-mapper.x86_64 7:1.02.158-2.el7_7.2 will be an update
---&amp;gt; Package device-mapper-event.x86_64 7:1.02.158-2.el7_7.2 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

============================================================================================================================
 Package                                   Arch               Version                             Repository           Size
============================================================================================================================
Installing:
 lvm2                                      x86_64             7:2.02.185-2.el7_7.2                updates             1.3 M
Installing for dependencies:
 device-mapper-event                       x86_64             7:1.02.158-2.el7_7.2                updates             190 k
 device-mapper-event-libs                  x86_64             7:1.02.158-2.el7_7.2                updates             189 k
 device-mapper-persistent-data             x86_64             0.8.5-1.el7                         base                423 k
 lvm2-libs                                 x86_64             7:2.02.185-2.el7_7.2                updates             1.1 M
Updating for dependencies:
 device-mapper                             x86_64             7:1.02.158-2.el7_7.2                updates             294 k
 device-mapper-libs                        x86_64             7:1.02.158-2.el7_7.2                updates             322 k

Transaction Summary
============================================================================================================================
Install  1 Package  (+4 Dependent packages)
Upgrade             ( 2 Dependent packages)

Total download size: 3.8 M
Downloading packages:
Delta RPMs disabled because /usr/bin/applydeltarpm not installed.
(1/7): device-mapper-event-1.02.158-2.el7_7.2.x86_64.rpm                                             | 190 kB  00:00:00     
(2/7): device-mapper-event-libs-1.02.158-2.el7_7.2.x86_64.rpm                                        | 189 kB  00:00:00     
(3/7): device-mapper-libs-1.02.158-2.el7_7.2.x86_64.rpm                                              | 322 kB  00:00:00     
(4/7): lvm2-2.02.185-2.el7_7.2.x86_64.rpm                                                            | 1.3 MB  00:00:00     
(5/7): device-mapper-1.02.158-2.el7_7.2.x86_64.rpm                                                   | 294 kB  00:00:00     
(6/7): lvm2-libs-2.02.185-2.el7_7.2.x86_64.rpm                                                       | 1.1 MB  00:00:00     
(7/7): device-mapper-persistent-data-0.8.5-1.el7.x86_64.rpm                                          | 423 kB  00:00:00     
----------------------------------------------------------------------------------------------------------------------------
Total                                                                                       4.3 MB/s | 3.8 MB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Updating   : 7:device-mapper-1.02.158-2.el7_7.2.x86_64                                                                1/9 
  Updating   : 7:device-mapper-libs-1.02.158-2.el7_7.2.x86_64                                                           2/9 
  Installing : 7:device-mapper-event-libs-1.02.158-2.el7_7.2.x86_64                                                     3/9 
  Installing : 7:device-mapper-event-1.02.158-2.el7_7.2.x86_64                                                          4/9 
  Installing : 7:lvm2-libs-2.02.185-2.el7_7.2.x86_64                                                                    5/9 
  Installing : device-mapper-persistent-data-0.8.5-1.el7.x86_64                                                         6/9 
  Installing : 7:lvm2-2.02.185-2.el7_7.2.x86_64                                                                         7/9 
Created symlink from /etc/systemd/system/sysinit.target.wants/lvm2-lvmpolld.socket to /usr/lib/systemd/system/lvm2-lvmpolld.socket.
  Cleanup    : 7:device-mapper-1.02.140-8.el7.x86_64                                                                    8/9 
  Cleanup    : 7:device-mapper-libs-1.02.140-8.el7.x86_64                                                               9/9 
  Verifying  : 7:device-mapper-libs-1.02.158-2.el7_7.2.x86_64                                                           1/9 
  Verifying  : 7:device-mapper-1.02.158-2.el7_7.2.x86_64                                                                2/9 
  Verifying  : device-mapper-persistent-data-0.8.5-1.el7.x86_64                                                         3/9 
  Verifying  : 7:lvm2-2.02.185-2.el7_7.2.x86_64                                                                         4/9 
  Verifying  : 7:lvm2-libs-2.02.185-2.el7_7.2.x86_64                                                                    5/9 
  Verifying  : 7:device-mapper-event-1.02.158-2.el7_7.2.x86_64                                                          6/9 
  Verifying  : 7:device-mapper-event-libs-1.02.158-2.el7_7.2.x86_64                                                     7/9 
  Verifying  : 7:device-mapper-1.02.140-8.el7.x86_64                                                                    8/9 
  Verifying  : 7:device-mapper-libs-1.02.140-8.el7.x86_64                                                               9/9 

Installed:
  lvm2.x86_64 7:2.02.185-2.el7_7.2                                                                                          

Dependency Installed:
  device-mapper-event.x86_64 7:1.02.158-2.el7_7.2             device-mapper-event-libs.x86_64 7:1.02.158-2.el7_7.2         
  device-mapper-persistent-data.x86_64 0:0.8.5-1.el7          lvm2-libs.x86_64 7:2.02.185-2.el7_7.2                        

Dependency Updated:
  device-mapper.x86_64 7:1.02.158-2.el7_7.2                  device-mapper-libs.x86_64 7:1.02.158-2.el7_7.2                 

Complete!
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：最小化安装系统默认系统上没有安装这个包的，所以我们需要把这个包装上才可创建LVM&lt;/p&gt;
&lt;p&gt;　　3）创建PV&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# pvcreate /dev/sdb{1,2,3}
  Physical volume &quot;/dev/sdb1&quot; successfully created.
  Physical volume &quot;/dev/sdb2&quot; successfully created.
  Physical volume &quot;/dev/sdb3&quot; successfully created.
[root@test-centos7-node1 ~]# pvscan 
  PV /dev/sdb1                      lvm2 [10.00 GiB]
  PV /dev/sdb3                      lvm2 [10.00 GiB]
  PV /dev/sdb2                      lvm2 [10.00 GiB]
  Total: 3 [30.00 GiB] / in use: 0 [0   ] / in no VG: 3 [30.00 GiB]
[root@test-centos7-node1 ~]# pvs
  PV         VG Fmt  Attr PSize  PFree 
  /dev/sdb1     lvm2 ---  10.00g 10.00g
  /dev/sdb2     lvm2 ---  10.00g 10.00g
  /dev/sdb3     lvm2 ---  10.00g 10.00g
[root@test-centos7-node1 ~]# pvdisplay 
  &quot;/dev/sdb1&quot; is a new physical volume of &quot;10.00 GiB&quot;
  --- NEW Physical volume ---
  PV Name               /dev/sdb1
  VG Name               
  PV Size               10.00 GiB
  Allocatable           NO
  PE Size               0   
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               MsszES-YPdm-YGQl-7rgg-B6gX-Q4xu-T8m1gz
   
  &quot;/dev/sdb3&quot; is a new physical volume of &quot;10.00 GiB&quot;
  --- NEW Physical volume ---
  PV Name               /dev/sdb3
  VG Name               
  PV Size               10.00 GiB
  Allocatable           NO
  PE Size               0   
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               BMMx8p-zu9O-ns61-G9DU-iKMR-NmZO-crCjlR
   
  &quot;/dev/sdb2&quot; is a new physical volume of &quot;10.00 GiB&quot;
  --- NEW Physical volume ---
  PV Name               /dev/sdb2
  VG Name               
  PV Size               10.00 GiB
  Allocatable           NO
  PE Size               0   
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               LPynpW-twlu-fxwg-OlCT-jA2A-R5UI-fvqWLj
   
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：pvcreate 命令表示创建PV 后面跟硬盘或分区对应的设备文件，pvscan 命令作用是搜索系统里面任何具有PV属性的磁碟，PV属性就是通过pvcreate创建过的磁碟，pvs是查看pv简要情况，pvdisplay 查看pv的详细信息。当然我们要移除某块盘，让其不具备PV属性，可以用pvremove + 磁盘的设备文件路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# pvremove /dev/sdb3
  Labels on physical volume &quot;/dev/sdb3&quot; successfully wiped.
[root@test-centos7-node1 ~]# pvs
  PV         VG Fmt  Attr PSize  PFree 
  /dev/sdb1     lvm2 ---  10.00g 10.00g
  /dev/sdb2     lvm2 ---  10.00g 10.00g
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：移除pv的前提是它没有在任何VG里面才可做移除，否则移除不了&lt;/p&gt;
&lt;p&gt;　　4）创建VG&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# pvs
  PV         VG Fmt  Attr PSize  PFree 
  /dev/sdb1     lvm2 ---  10.00g 10.00g
  /dev/sdb2     lvm2 ---  10.00g 10.00g
[root@test-centos7-node1 ~]# pvcreate /dev/sdb3
  Physical volume &quot;/dev/sdb3&quot; successfully created.
[root@test-centos7-node1 ~]# pvs
  PV         VG Fmt  Attr PSize  PFree 
  /dev/sdb1     lvm2 ---  10.00g 10.00g
  /dev/sdb2     lvm2 ---  10.00g 10.00g
  /dev/sdb3     lvm2 ---  10.00g 10.00g
[root@test-centos7-node1 ~]# vgcreate test -s 8M /dev/sdb{1,2,3}
  Volume group &quot;test&quot; successfully created
[root@test-centos7-node1 ~]# vgs
  VG   #PV #LV #SN Attr   VSize   VFree  
  test   3   0   0 wz--n- &amp;lt;29.98g &amp;lt;29.98g
[root@test-centos7-node1 ~]# vgscan
  Reading volume groups from cache.
  Found volume group &quot;test&quot; using metadata type lvm2
[root@test-centos7-node1 ~]# vgdisplay 
  --- Volume group ---
  VG Name               test
  System ID             
  Format                lvm2
  Metadata Areas        3
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                3
  Act PV                3
  VG Size               &amp;lt;29.98 GiB
  PE Size               8.00 MiB
  Total PE              3837
  Alloc PE / Size       0 / 0   
  Free  PE / Size       3837 / &amp;lt;29.98 GiB
  VG UUID               31vxAP-L5jb-8Yxm-25m2-LdD0-ee8R-sdTjum
   
[root@test-centos7-node1 ~]# vgreduce test /dev/sdb3
  Removed &quot;/dev/sdb3&quot; from volume group &quot;test&quot;
[root@test-centos7-node1 ~]# vgs
  VG   #PV #LV #SN Attr   VSize  VFree 
  test   2   0   0 wz--n- 19.98g 19.98g
[root@test-centos7-node1 ~]# vgcreate test2 /dev/sdb3
  Volume group &quot;test2&quot; successfully created
[root@test-centos7-node1 ~]# vgs
  VG    #PV #LV #SN Attr   VSize   VFree  
  test    2   0   0 wz--n-  19.98g  19.98g
  test2   1   0   0 wz--n- &amp;lt;10.00g &amp;lt;10.00g
[root@test-centos7-node1 ~]# vgdisplay test2
  --- Volume group ---
  VG Name               test2
  System ID             
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               &amp;lt;10.00 GiB
  PE Size               4.00 MiB
  Total PE              2559
  Alloc PE / Size       0 / 0   
  Free  PE / Size       2559 / &amp;lt;10.00 GiB
  VG UUID               rc94SP-JAlk-63Rw-n5xz-qB0d-grnT-ItrMvT
   
[root@test-centos7-node1 ~]# vgremove test2
  Volume group &quot;test2&quot; successfully removed
[root@test-centos7-node1 ~]# vgs
  VG   #PV #LV #SN Attr   VSize  VFree 
  test   2   0   0 wz--n- 19.98g 19.98g
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：同样的vgcreate 表示创建VG 其用法格式是vgcreate  VGNAME [option] 储存设备路径 其中-s表示指定PE的大小，VGNAME表示VG的名称，需要说明的是，指定名称不能和系统现有的VG名称相同；vgs查看系统上所有VG的简要信息，vgscan搜寻系统上面是否有VG，vgdisplay查看所有VG的详细信息，当然此例中只有一个，我们也可在后面指定查看某个VG的详细信息，只需要指定其VG名称即可；有关vg的命令有很多其中vgreduce的作用是在VG内移除PV，vgremove的作用是删除一个VG，这两个命令都需要在其后指定要操作的VG名称&lt;/p&gt;
&lt;p&gt;　　5）创建LV&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# lvs
[root@test-centos7-node1 ~]# lvcreate -L 2G -n aaa test
  Logical volume &quot;aaa&quot; created.
[root@test-centos7-node1 ~]# lvcreate -L 3G -n bbb test 
  Logical volume &quot;bbb&quot; created.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  aaa  test -wi-a----- 2.00g                                                    
  bbb  test -wi-a----- 3.00g                                                    
[root@test-centos7-node1 ~]# lvscan 
  ACTIVE            '/dev/test/aaa' [2.00 GiB] inherit
  ACTIVE            '/dev/test/bbb' [3.00 GiB] inherit
[root@test-centos7-node1 ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/test/aaa
  LV Name                aaa
  VG Name                test
  LV UUID                R9weh0-D85B-rMcW-oYSM-dAQb-gIQh-RXxITP
  LV Write Access        read/write
  LV Creation host, time test-centos7-node1, 2020-01-06 09:05:23 -0500
  LV Status              available
  # open                 0
  LV Size                2.00 GiB
  Current LE             256
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:0
   
  --- Logical volume ---
  LV Path                /dev/test/bbb
  LV Name                bbb
  VG Name                test
  LV UUID                LYwvZj-ogpf-nwtF-mja6-xwwl-A24W-BslJOu
  LV Write Access        read/write
  LV Creation host, time test-centos7-node1, 2020-01-06 09:05:34 -0500
  LV Status              available
  # open                 0
  LV Size                3.00 GiB
  Current LE             384
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:1
   
[root@test-centos7-node1 ~]# lvresize -L +4G /dev/test/aaa 
  Size of logical volume test/aaa changed from 2.00 GiB (256 extents) to 6.00 GiB (768 extents).
  Logical volume test/aaa successfully resized.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  aaa  test -wi-a----- 6.00g                                                    
  bbb  test -wi-a----- 3.00g                                                    
[root@test-centos7-node1 ~]# lvresize -L -1G /dev/test/bbb
  WARNING: Reducing active logical volume to 2.00 GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce test/bbb? [y/n]: y
  Size of logical volume test/bbb changed from 3.00 GiB (384 extents) to 2.00 GiB (256 extents).
  Logical volume test/bbb successfully resized.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  aaa  test -wi-a----- 6.00g                                                    
  bbb  test -wi-a----- 2.00g                                                    
[root@test-centos7-node1 ~]# lvreduce -L 3G /dev/test/aaa   
  WARNING: Reducing active logical volume to 3.00 GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce test/aaa? [y/n]: y
  Size of logical volume test/aaa changed from 6.00 GiB (768 extents) to 3.00 GiB (384 extents).
  Logical volume test/aaa successfully resized.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  aaa  test -wi-a----- 3.00g                                                    
  bbb  test -wi-a----- 2.00g                                                    
[root@test-centos7-node1 ~]# lvreduce -L -1G /dev/test/aaa  
  WARNING: Reducing active logical volume to 2.00 GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce test/aaa? [y/n]: y
  Size of logical volume test/aaa changed from 3.00 GiB (384 extents) to 2.00 GiB (256 extents).
  Logical volume test/aaa successfully resized.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  aaa  test -wi-a----- 2.00g                                                    
  bbb  test -wi-a----- 2.00g                                                    
[root@test-centos7-node1 ~]# lvremove /dev/test/bbb
Do you really want to remove active logical volume test/bbb? [y/n]: y
  Logical volume &quot;bbb&quot; successfully removed
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  aaa  test -wi-a----- 2.00g                                                    
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：lvcreate 命令作用是创建LV 其中-L表示指定LV的大小，-n表示lv的名称 最后跟VG的名称，表示从那个VG上创建LV；lvs 命令作用是查看系统所有的lv简要信息 ；lvdisplay 查看LV的详细信息，后面可以跟VG的名称表示查看指定VG上的所有LV的详细信息；lvreduce 命令作用是缩减指定LV里的空间，如果指定的大小是负数如-3M 表示缩减3M  如果指定的是 3M 则表示缩减至3M ，这个需要注意，还有这个命令指定大小不能以类似+4M来指定；lvresize此命令的作用是调整LV的容量大小，这个命令指定调整大小+表示增加多少，-表示减少多少，若没有+/-表示调整到指定大小，lvresize和lvreduce这两个命令后面都是跟的lv对应设备的路径（其实不是真的设备路径，是设备的软连接路径），不能指定其名称；lvremove命令作用是删除指定的LV,若指定的是vg名，表示删除该VG上的所有LV，若需要删除某个LV 需要指定其对应设备路径。&lt;/p&gt;
&lt;p&gt;　　到此lvm就已经实现，后续就可以直接格式化，然后挂载使用了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# vgs
  VG   #PV #LV #SN Attr   VSize  VFree 
  test   2   0   0 wz--n- 19.98g 19.98g
[root@test-centos7-node1 ~]# lvcreate -l 100%FREE -n xxx test
WARNING: xfs signature detected on /dev/test/xxx at offset 0. Wipe it? [y/n]: y
  Wiping xfs signature on /dev/test/xxx.
  Logical volume &quot;xxx&quot; created.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  xxx  test -wi-a----- 19.98g                                                    
[root@test-centos7-node1 ~]# mkfs.xfs -f /dev/test/xxx 
meta-data=/dev/test/xxx          isize=512    agcount=4, agsize=1309696 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=5238784, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@test-centos7-node1 ~]# lsblk
NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda            8:0    0   50G  0 disk 
├─sda1         8:1    0    2G  0 part /boot
├─sda2         8:2    0    2G  0 part [SWAP]
└─sda3         8:3    0   46G  0 part /
sdb            8:16   0   50G  0 disk 
├─sdb1         8:17   0   10G  0 part 
│ └─test-xxx 253:0    0   20G  0 lvm  
├─sdb2         8:18   0   10G  0 part 
│ └─test-xxx 253:0    0   20G  0 lvm  
└─sdb3         8:19   0   10G  0 part 
sr0           11:0    1  792M  0 rom  
[root@test-centos7-node1 ~]# mount /dev/test/xxx /mnt
[root@test-centos7-node1 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda3              46G  1.6G   45G   4% /
devtmpfs              1.9G     0  1.9G   0% /dev
tmpfs                 1.9G     0  1.9G   0% /dev/shm
tmpfs                 1.9G  8.6M  1.9G   1% /run
tmpfs                 1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1             2.0G  135M  1.9G   7% /boot
tmpfs                 378M     0  378M   0% /run/user/0
/dev/mapper/test-xxx   20G   33M   20G   1% /mnt
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　三、扩容LV&lt;/p&gt;
&lt;p&gt;　　1）创建PV，并将其加入到VG中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# pvs
  PV         VG   Fmt  Attr PSize PFree
  /dev/sdb1  test lvm2 a--  9.99g    0 
  /dev/sdb2  test lvm2 a--  9.99g    0 
[root@test-centos7-node1 ~]# vgdisplay 
  --- Volume group ---
  VG Name               test
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  28
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                1
  Open LV               1
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               19.98 GiB
  PE Size               8.00 MiB
  Total PE              2558
  Alloc PE / Size       2558 / 19.98 GiB
  Free  PE / Size       0 / 0   
  VG UUID               31vxAP-L5jb-8Yxm-25m2-LdD0-ee8R-sdTjum
   
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：从上面的信息可以看到VG的大小是19.98G 也就是两块PV的大小。现在我们新创建一个pv，然后加到vg里&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# pvs
  PV         VG   Fmt  Attr PSize PFree
  /dev/sdb1  test lvm2 a--  9.99g    0 
  /dev/sdb2  test lvm2 a--  9.99g    0 
[root@test-centos7-node1 ~]# pvcreate  /dev/sdb3
  Physical volume &quot;/dev/sdb3&quot; successfully created.
[root@test-centos7-node1 ~]# pvs
  PV         VG   Fmt  Attr PSize  PFree 
  /dev/sdb1  test lvm2 a--   9.99g     0 
  /dev/sdb2  test lvm2 a--   9.99g     0 
  /dev/sdb3       lvm2 ---  10.00g 10.00g
[root@test-centos7-node1 ~]# vgs
  VG   #PV #LV #SN Attr   VSize  VFree
  test   2   1   0 wz--n- 19.98g    0 
[root@test-centos7-node1 ~]# vgextend test /dev/sdb3
  Volume group &quot;test&quot; successfully extended
[root@test-centos7-node1 ~]# vgs
  VG   #PV #LV #SN Attr   VSize   VFree
  test   3   1   0 wz--n- &amp;lt;29.98g 9.99g
[root@test-centos7-node1 ~]# vgdisplay 
  --- Volume group ---
  VG Name               test
  System ID             
  Format                lvm2
  Metadata Areas        3
  Metadata Sequence No  31
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                1
  Open LV               1
  Max PV                0
  Cur PV                3
  Act PV                3
  VG Size               &amp;lt;29.98 GiB
  PE Size               8.00 MiB
  Total PE              3837
  Alloc PE / Size       2558 / 19.98 GiB
  Free  PE / Size       1279 / 9.99 GiB
  VG UUID               31vxAP-L5jb-8Yxm-25m2-LdD0-ee8R-sdTjum
   
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：vgextend命令作用是将指定pv加入到指定VG中，VG指定其名称即可，pv需指定其设备路径&lt;/p&gt;
&lt;p&gt;　　2）将新加的VG的PE加入到xxx LV里&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# vgs
  VG   #PV #LV #SN Attr   VSize   VFree
  test   3   1   0 wz--n- &amp;lt;29.98g 9.99g
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  xxx  test -wi-ao---- 19.98g                                                    
[root@test-centos7-node1 ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/test/xxx
  LV Name                xxx
  VG Name                test
  LV UUID                ihOo41-gh1L-eSHK-iLXY-UGfF-J6uI-UmVWhF
  LV Write Access        read/write
  LV Creation host, time test-centos7-node1, 2020-01-06 10:00:08 -0500
  LV Status              available
  # open                 1
  LV Size                19.98 GiB
  Current LE             2558
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:0
   
[root@test-centos7-node1 ~]# lvextend -l +100%FREE /dev/test/xxx 
  Size of logical volume test/xxx changed from 19.98 GiB (2558 extents) to &amp;lt;29.98 GiB (3837 extents).
  Logical volume test/xxx successfully resized.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  xxx  test -wi-ao---- &amp;lt;29.98g                                                    
[root@test-centos7-node1 ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/test/xxx
  LV Name                xxx
  VG Name                test
  LV UUID                ihOo41-gh1L-eSHK-iLXY-UGfF-J6uI-UmVWhF
  LV Write Access        read/write
  LV Creation host, time test-centos7-node1, 2020-01-06 10:00:08 -0500
  LV Status              available
  # open                 1
  LV Size                &amp;lt;29.98 GiB
  Current LE             3837
  Segments               3
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:0
   
[root@test-centos7-node1 ~]# vgs
  VG   #PV #LV #SN Attr   VSize   VFree
  test   3   1   0 wz--n- &amp;lt;29.98g    0 
[root@test-centos7-node1 ~]# lsblk
NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda            8:0    0   50G  0 disk 
├─sda1         8:1    0    2G  0 part /boot
├─sda2         8:2    0    2G  0 part [SWAP]
└─sda3         8:3    0   46G  0 part /
sdb            8:16   0   50G  0 disk 
├─sdb1         8:17   0   10G  0 part 
│ └─test-xxx 253:0    0   30G  0 lvm  /mnt
├─sdb2         8:18   0   10G  0 part 
│ └─test-xxx 253:0    0   30G  0 lvm  /mnt
└─sdb3         8:19   0   10G  0 part 
  └─test-xxx 253:0    0   30G  0 lvm  /mnt
sr0           11:0    1  792M  0 rom  
[root@test-centos7-node1 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda3              46G  1.6G   45G   4% /
devtmpfs              1.9G     0  1.9G   0% /dev
tmpfs                 1.9G     0  1.9G   0% /dev/shm
tmpfs                 1.9G  8.6M  1.9G   1% /run
tmpfs                 1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1             2.0G  135M  1.9G   7% /boot
tmpfs                 378M     0  378M   0% /run/user/0
/dev/mapper/test-xxx   20G   33M   20G   1% /mnt
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到lvs里的空间已经加上去，lvextend命令作用是将指定VG里的空间添加到指定的lv中，上面的例子是把VG里的所有空闲空间添加到/dev/test/xxx里，当然还有一种情况在VG还有空余的空间，我们可以用lvresize 来调整lv的大小；从上面的信息可以看到我们把新的空间加入到VG和Lv中后，df 看挂载点空间却没有增加，接下来我们通过resize2fs将文件系统同步到增大的空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# resize2fs /dev/test/xxx 
resize2fs 1.42.9 (28-Dec-2013)
resize2fs: Bad magic number in super-block while trying to open /dev/test/xxx
Couldn't find valid filesystem superblock.
[root@test-centos7-node1 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda3              46G  1.6G   45G   4% /
devtmpfs              1.9G     0  1.9G   0% /dev
tmpfs                 1.9G     0  1.9G   0% /dev/shm
tmpfs                 1.9G  8.6M  1.9G   1% /run
tmpfs                 1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1             2.0G  135M  1.9G   7% /boot
tmpfs                 378M     0  378M   0% /run/user/0
/dev/mapper/test-xxx   20G   33M   20G   1% /mnt
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：看来用此命令不行，因为resize2fs这个命令针对ext系列的文件系统，xfs需要用 xfs_growfs来调整&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# xfs_growfs /dev/test/xxx 
meta-data=/dev/mapper/test-xxx   isize=512    agcount=4, agsize=1309696 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0 spinodes=0
data     =                       bsize=4096   blocks=5238784, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal               bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
data blocks changed from 5238784 to 7858176
[root@test-centos7-node1 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda3              46G  1.6G   45G   4% /
devtmpfs              1.9G     0  1.9G   0% /dev
tmpfs                 1.9G     0  1.9G   0% /dev/shm
tmpfs                 1.9G  8.6M  1.9G   1% /run
tmpfs                 1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1             2.0G  135M  1.9G   7% /boot
tmpfs                 378M     0  378M   0% /run/user/0
/dev/mapper/test-xxx   30G   33M   30G   1% /mnt
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　四、缩减LV（xfs文件系统）&lt;/p&gt;
&lt;p&gt;　　1）卸载已经挂好的LV&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda3              46G  1.6G   45G   4% /
devtmpfs              1.9G     0  1.9G   0% /dev
tmpfs                 1.9G     0  1.9G   0% /dev/shm
tmpfs                 1.9G  8.6M  1.9G   1% /run
tmpfs                 1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1             2.0G  135M  1.9G   7% /boot
tmpfs                 378M     0  378M   0% /run/user/0
/dev/mapper/test-xxx   30G   33M   30G   1% /mnt
[root@test-centos7-node1 ~]# umount /mnt
[root@test-centos7-node1 ~]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda3        46G  1.6G   45G   4% /
devtmpfs        1.9G     0  1.9G   0% /dev
tmpfs           1.9G     0  1.9G   0% /dev/shm
tmpfs           1.9G  8.6M  1.9G   1% /run
tmpfs           1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1       2.0G  135M  1.9G   7% /boot
tmpfs           378M     0  378M   0% /run/user/0
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）强制进行磁盘检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# xfs_repair -n /dev/test/xxx 
Phase 1 - find and verify superblock...
Phase 2 - using internal log
        - zero log...
        - scan filesystem freespace and inode maps...
        - found root inode chunk
Phase 3 - for each AG...
        - scan (but don't clear) agi unlinked lists...
        - process known inodes and perform inode discovery...
        - agno = 0
        - agno = 1
        - agno = 2
        - agno = 3
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
        - agno = 0
        - agno = 1
        - agno = 2
        - agno = 3
No modify flag set, skipping phase 5
Phase 6 - check inode connectivity...
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify link counts...
No modify flag set, skipping filesystem flush and exiting.
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：ext系列文件系统可e2fsck命令检查&lt;/p&gt;
&lt;p&gt;　　3）调整lv大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# lvreduce -L -10G /dev/test/xxx 
  WARNING: Reducing active logical volume to &amp;lt;19.98 GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce test/xxx? [y/n]: y
  Size of logical volume test/xxx changed from &amp;lt;29.98 GiB (3837 extents) to &amp;lt;19.98 GiB (2557 extents).
  Logical volume test/xxx successfully resized.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  xxx  test -wi-a----- &amp;lt;19.98g                                                    
[root@test-centos7-node1 ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/test/xxx
  LV Name                xxx
  VG Name                test
  LV UUID                uhZZaz-Odd9-ibwY-2Z1Z-ZmNY-eZF7-0lXERT
  LV Write Access        read/write
  LV Creation host, time test-centos7-node1, 2020-01-06 10:32:42 -0500
  LV Status              available
  # open                 0
  LV Size                &amp;lt;19.98 GiB
  Current LE             2557
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:0
   
[root@test-centos7-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）挂载&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# mount /dev/test/xxx /mnt
mount: /dev/mapper/test-xxx: can't read superblock
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：做到这里发现一个问题，xfs文件系统是不支持逻辑卷缩减的，为什么呢？xfs的文件系统调整命令是xfs_growfs 这个命令只支持增大的操作。我们在调整lv大小的时候实际上是把文件系统给破坏了，要想缩减空间，就必须重新格式化后在挂载，这样一来如果原有的盘里有数据就丢了。所以xfs上做LV的缩减没有意义&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# mkfs.xfs /dev/test/xxx -f
meta-data=/dev/test/xxx          isize=512    agcount=4, agsize=1309184 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=5236736, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@test-centos7-node1 ~]# mount  /dev/test/xxx  /mnt
[root@test-centos7-node1 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda3              46G  1.6G   45G   4% /
devtmpfs              1.9G     0  1.9G   0% /dev
tmpfs                 1.9G     0  1.9G   0% /dev/shm
tmpfs                 1.9G  8.6M  1.9G   1% /run
tmpfs                 1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1             2.0G  135M  1.9G   7% /boot
tmpfs                 378M     0  378M   0% /run/user/0
/dev/mapper/test-xxx   20G   33M   20G   1% /mnt
[root@test-centos7-node1 ~]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　五、缩减LV（ext系列文件系统）&lt;/p&gt;
&lt;p&gt;　　1）卸载已挂载的LV&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# df -Th
Filesystem           Type      Size  Used Avail Use% Mounted on
/dev/sda3            xfs        46G  1.6G   45G   4% /
devtmpfs             devtmpfs  1.9G     0  1.9G   0% /dev
tmpfs                tmpfs     1.9G     0  1.9G   0% /dev/shm
tmpfs                tmpfs     1.9G  8.6M  1.9G   1% /run
tmpfs                tmpfs     1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1            xfs       2.0G  135M  1.9G   7% /boot
tmpfs                tmpfs     378M     0  378M   0% /run/user/0
/dev/mapper/test-xxx ext4       20G   45M   19G   1% /mnt
[root@test-centos7-node1 ~]# umount /mnt
[root@test-centos7-node1 ~]# df -Th     
Filesystem     Type      Size  Used Avail Use% Mounted on
/dev/sda3      xfs        46G  1.6G   45G   4% /
devtmpfs       devtmpfs  1.9G     0  1.9G   0% /dev
tmpfs          tmpfs     1.9G     0  1.9G   0% /dev/shm
tmpfs          tmpfs     1.9G  8.6M  1.9G   1% /run
tmpfs          tmpfs     1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1      xfs       2.0G  135M  1.9G   7% /boot
tmpfs          tmpfs     378M     0  378M   0% /run/user/0
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）强制执行磁盘检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# e2fsck -f /dev/test/xxx 
e2fsck 1.42.9 (28-Dec-2013)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/test/xxx: 11/1310720 files (0.0% non-contiguous), 126322/5236736 blocks
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这一步我们在不执行的话，直接下一步它也会提示我们先做磁盘检测&lt;/p&gt;
&lt;p&gt;　　3）调整文件系统大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# resize2fs /dev/test/xxx 12G
resize2fs 1.42.9 (28-Dec-2013)
Resizing the filesystem on /dev/test/xxx to 3145728 (4k) blocks.
The filesystem on /dev/test/xxx is now 3145728 blocks long.

[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）调整LV的大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# lvreduce -L 12G /dev/test/xxx 
  WARNING: Reducing active logical volume to 12.00 GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce test/xxx? [y/n]: y
  Size of logical volume test/xxx changed from &amp;lt;19.98 GiB (2557 extents) to 12.00 GiB (1536 extents).
  Logical volume test/xxx successfully resized.
[root@test-centos7-node1 ~]# lvs
  LV   VG   Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  xxx  test -wi-a----- 12.00g                                                    
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　说明：这里缩减到的空间需同文件系统的大小一致或者缩减后的空间比文件系统调整的空间要大才行，这样才不能损坏文件系统，切记不能比文件系统调整的空间还小，小了，在缩减空间的时候就破坏了文件系统，会导致后续的挂载无法进行。&lt;/p&gt;
&lt;p&gt;　　5）挂载&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# mount /dev/test/xxx /mnt
[root@test-centos7-node1 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda3              46G  1.6G   45G   4% /
devtmpfs              1.9G     0  1.9G   0% /dev
tmpfs                 1.9G     0  1.9G   0% /dev/shm
tmpfs                 1.9G  8.6M  1.9G   1% /run
tmpfs                 1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda1             2.0G  135M  1.9G   7% /boot
tmpfs                 378M     0  378M   0% /run/user/0
/dev/mapper/test-xxx   12G   41M   12G   1% /mnt
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 06 Jan 2020 17:30:00 +0000</pubDate>
<dc:creator>qiuhom</dc:creator>
<og:description>一、LVM介绍 在我们管理Linux磁盘的时候，通常会遇到这么一种情况。在最初规划Linux的磁盘的时候，我们给某个分区划分了一定量的磁盘空间，使用一段时间后，发现我们规划的磁盘空间不足了，这个时候怎</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12156146.html</dc:identifier>
</item>
<item>
<title>数据库中间件分片算法之enum - BuddyYuan</title>
<link>http://www.cnblogs.com/buddy-yuan/p/12159216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buddy-yuan/p/12159216.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;最近挺焦虑的，不知道未来该做什么，方向又是什么。只能用&lt;code&gt;别慌，月亮也正在大海的某处迷茫。&lt;/code&gt;来安慰下自己。不过学习的初心咱们还是不要忘记。今天我们学习的是enum分片算法。&lt;/p&gt;
&lt;p&gt;1.hash分区算法&lt;br/&gt;2.stringhash分区算法&lt;br/&gt;&lt;code&gt;3.enum分区算法&lt;/code&gt;&lt;br/&gt;4.numberrange分区算法&lt;br/&gt;5.patternrange分区算法&lt;br/&gt;6.date分区算法&lt;br/&gt;7.jumpstringhash算法&lt;/p&gt;
&lt;h4 id=&quot;enum分区算法的配置&quot;&gt;enum分区算法的配置&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;tableRule name=&quot;rule_enum&quot;&amp;gt;
        &amp;lt;rule&amp;gt;
            &amp;lt;columns&amp;gt;code&amp;lt;/columns&amp;gt;
            &amp;lt;algorithm&amp;gt;func_enum&amp;lt;/algorithm&amp;gt;
        &amp;lt;/rule&amp;gt;
    &amp;lt;/tableRule&amp;gt;

&amp;lt;function name=&quot;enum&quot; class=&quot;enum&quot;&amp;gt;
&amp;lt;property name=&quot;mapFile&quot;&amp;gt;partition.txt&amp;lt;/property&amp;gt;
&amp;lt;property name=&quot;defaultNode&quot;&amp;gt;0&amp;lt;/property&amp;gt;
&amp;lt;property name=&quot;type&quot;&amp;gt;0&amp;lt;/property&amp;gt;
&amp;lt;/function&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enum和之前的hash算法一样。需要在rule.xml中配置tableRule和function。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;tableRule标签，name对应的是规则的名字，而rule标签中的columns则对应的分片字段，这个字段必须和表中的字段一致。algorithm则代表了执行分片函数的名字。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;function标签，name代表分片算法的名字，算法的名字要和上面的tableRule中的标签相对应。class：指定分片算法实现类。property指定了对应分片算法的参数。不同的算法参数不同。&lt;/li&gt;
&lt;li&gt;mapFile:指定配置文件名。其格式将在下面做详细说明。&lt;/li&gt;
&lt;li&gt;defaultNode：指定默认节点号。默认值为-1，不指定默认节点。&lt;/li&gt;
&lt;li&gt;type：指定配置文件中key的类型。0：整型； 其它：字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;mapfile文件格式配置如下：&lt;br/&gt;a.type=0，&lt;br/&gt;int1=node0&lt;br/&gt;int2=node1&lt;/p&gt;
&lt;p&gt;a.type=其他&lt;br/&gt;string1=node0&lt;br/&gt;string2=node1&lt;/p&gt;
&lt;h4 id=&quot;启动加载配置&quot;&gt;1.启动加载配置&lt;/h4&gt;
&lt;p&gt;当启动的时候，会先根据type的值判断是字符串还是数字。然后把mapfile中配置的值加载到内存中，形成一个映射表。&lt;br/&gt;例如上面的配置中type=0，就可以判断是数字，然后查看mapFile对应的文件partition.txt，可以查到:&lt;br/&gt;10000=0&lt;br/&gt;10010=1&lt;br/&gt;也就是枚举值10000，就存放在分片1上，而枚举值10010，就存放在分片2上。&lt;/p&gt;
&lt;h4 id=&quot;运行过程&quot;&gt;2.运行过程&lt;/h4&gt;
&lt;p&gt;当在运行的过程中，如果有用户通过查询code=10000或者是code=10001的时候，就会访问这个枚举算法。根据上面的映射表直接查询得到分片的编号。&lt;/p&gt;
&lt;h4 id=&quot;我们建表来测试一下&quot;&gt;3.我们建表来测试一下。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/5/16f75e66bcaf8c46?w=897&amp;amp;h=774&amp;amp;f=png&amp;amp;s=47712&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过创建test_enum表，我们插入三条数据，分别是code=10000,10010,10020，可以看到10000被存放在分片1上，10010被存放在分片2上。这个和我们在partition.txt中配置的文件一样。当我们插入10020的时候，因为枚举值不存在，它会选择默认的分片节点dn1。这里不会因为错误而报错。&lt;br/&gt;枚举在使用的时候，需要把已知的全部罗列出来。但是也有劣势，就是可能罗列不全，在这个时候把不在枚举定义范围的数字存放到默认节点是一个没有办法的办法，如果突然因为某个新版本上线，出现一些新的枚举类型而没有及时更新，会导致默认节点数据快速膨胀。此时就需要进行扩容，然后实现局部数据迁移。&lt;/p&gt;
&lt;h4 id=&quot;注意事项&quot;&gt;注意事项&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;mapfile文件不包含“=”的行将被跳过.&lt;/li&gt;
&lt;li&gt;重复的枚举值的分区数据节点以最后一个配置为准。&lt;/li&gt;
&lt;li&gt;分片字段为该枚举类型。&lt;/li&gt;
&lt;li&gt;分片字段为NULL时，数据落在defaultNode节点上，若此时defaultNode没有配置，则会报错;当真实存在于mysql的字段值为not null的时候,报错 &quot;Sharding column can't be null when the table in MySQL column is not null&quot;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;今天介绍的枚举算法较为简单。后续将继续带来剩下几种算法，谢谢支持！&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 16:23:00 +0000</pubDate>
<dc:creator>BuddyYuan</dc:creator>
<og:description>前言 最近挺焦虑的，不知道未来该做什么，方向又是什么。只能用 来安慰下自己。不过学习的初心咱们还是不要忘记。今天我们学习的是enum分片算法。 1.hash分区算法 2.stringhash分区算法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buddy-yuan/p/12159216.html</dc:identifier>
</item>
<item>
<title>东拼西凑完成一个“前端框架”(5) - Tabs操作 - CharlesShang</title>
<link>http://www.cnblogs.com/xinwang/p/12159153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinwang/p/12159153.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;Tabs页面完成的基本操作完成，但是功能还不够完备：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Tab页打开过多超出的如何处理？&lt;/li&gt;
&lt;li&gt;Tab页关闭所有、关闭其它操作&lt;/li&gt;
&lt;li&gt;Tab页刷新操作&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;设计&quot;&gt;设计&lt;/h2&gt;
&lt;p&gt;这里参考&lt;a href=&quot;https://www.layui.com/admin/std/dist/views/&quot;&gt;LayUIAdmin&lt;/a&gt;的设计方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;Tab栏左右未知可以动态调整&lt;/li&gt;
&lt;li&gt;打开的标签页面超出时，调整位置到指定标签页显示&lt;/li&gt;
&lt;li&gt;左右滑动不同范围的标签页&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12817403-328366490850b154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;布局&quot;&gt;布局&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Tab栏左右位置可以调整，那么Tab栏的定位是绝对定位&lt;/li&gt;
&lt;li&gt;左右调整动画 &lt;code&gt;transaction&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;h4 id=&quot;html&quot;&gt;HTML&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;···
 &amp;lt;div class=&quot;ls-tab-container&quot;&amp;gt;
    &amp;lt;div class=&quot;header flex&quot;&amp;gt;
        &amp;lt;!--left--&amp;gt;
        &amp;lt;div class=&quot;tab-operate tab-operate-left&quot;&amp;gt;
            &amp;lt;a class=&quot;fa fa-2x fa-angle-double-left opt-left&quot;&amp;gt;&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!--titles--&amp;gt;
        &amp;lt;div class=&quot;ls-tab-titles flex&quot;&amp;gt;
            &amp;lt;div class=&quot;tab-title active&quot; data-id=&quot;0&quot;&amp;gt;
                &amp;lt;span class=&quot;title&quot;&amp;gt;
                    &amp;lt;i class=&quot;ls-icon ls-icon-home&quot;&amp;gt;&amp;lt;/i&amp;gt;
                &amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!--right--&amp;gt;
        &amp;lt;div class=&quot;tab-operate tab-operate-right&quot;&amp;gt;
            &amp;lt;a class=&quot;fa fa-2x fa-angle-double-right opt-right&quot;&amp;gt;&amp;lt;/a&amp;gt;
            &amp;lt;a class=&quot;fa fa-2x fa-angle-double-down&quot;&amp;gt;
                &amp;lt;div class=&quot;dropdown-panel&quot;&amp;gt;
                    &amp;lt;ul&amp;gt;
                        &amp;lt;li class=&quot;opt&quot; data-opt=&quot;refresh&quot;&amp;gt;刷新&amp;lt;/li&amp;gt;
                        &amp;lt;li class=&quot;opt&quot; data-opt=&quot;closeOthers&quot;&amp;gt;关闭其它&amp;lt;/li&amp;gt;
                        &amp;lt;li class=&quot;opt&quot; data-opt=&quot;closeAll&quot;&amp;gt;全部关闭&amp;lt;/li&amp;gt;
                    &amp;lt;/ul&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
···
&amp;lt;/div&amp;gt;
···&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;css&quot;&gt;CSS&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--Tabs栏--&amp;gt;
.ls-tab-container .ls-tab-titles {
    position: absolute;
    left: 39px;
    right: 78px;
    overflow: hidden;
    transition: all 300ms ease-in;
    -webkit-transition: all 300ms ease-in;
}
&amp;lt;!--操作--&amp;gt;

.tab-operate {
    position: absolute;
    display: flex;
    text-align: center;
    border-bottom: 1px solid #e6e6e6;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 0 6px rgba(196, 199, 202, 0.35);
    z-index: 8;
}

.tab-operate .fa:hover {
    background: rgba(238, 238, 238, .6);
    cursor: pointer;
}

.tab-operate.tab-operate-left {
    left: 0;
}

.tab-operate.tab-operate-right {
    right: 0;
}

.tab-operate .fa {
    color: #666;
    font-size: 22px;
    line-height: 36px;
    width: 38px;
    display: inline-block;
}

.tab-operate-left .fa {
    border-right: 1px solid rgb(230, 230, 230, .8);
}

.tab-operate-right .fa {
    border-left: 1px solid rgb(230, 230, 230, .8);
    position: relative;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;效果&quot;&gt;效果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12817403-95ff5a887297ab6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;下拉菜单&quot;&gt;下拉菜单&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;鼠标经过最右侧操作按钮时展示下拉菜单，思路很简单就算用伪类 &lt;code&gt;hover&lt;/code&gt; 实现，但是在利用&lt;code&gt;transaction&lt;/code&gt;做动画的过程中发现，&lt;code&gt;display&lt;/code&gt; 属性与 &lt;code&gt;transaction&lt;/code&gt; 属性冲突，解决方式是通过 &lt;code&gt;height:0;overflow:hidden;&lt;/code&gt; 来实现动画：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;.dropdown-panel {
    background: #fff;
    position: absolute;
    width: 120px;
    right: 0;
    font-size: 13px;
    transition: top 200ms ease-in, opacity 200ms ease-in;
    -webkit-transition: top 200ms ease-in, opacity 200ms ease-in;
    border-radius: 4px;
    top: 46px;
    height: 0;
    opacity: 0;
    overflow: hidden;
    box-shadow: 0 0 6px rgba(196, 199, 202, .35);
}

.tab-operate-right .fa:hover .dropdown-panel {
    top: 37px;
    opacity: 1;
    height: auto;
    border: 1px solid rgb(230, 230, 230, .8);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;效果预览&quot;&gt;效果预览&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12817403-3902a5671f06c4b0.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;4.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;操作&quot;&gt;操作&lt;/h2&gt;
&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12817403-6be5c1b7cac77f5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;如图所示 打开多个标签页时只要把超出的部分利用 &lt;code&gt;Tab栏&lt;/code&gt; 的 &lt;code&gt;margin-left&lt;/code&gt; 属性补回来就可以实现：&lt;br/&gt;&lt;code&gt;margin-left: (Tab栏.Offset().Left+Tabs栏.Width() - TabItem.Offset().Left-TabItem.Width()) + 'px'&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;关键代码实现&quot;&gt;关键代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 激活Tab时触发
···
// 位置调整
var pleft = $tab.offset().left + 39;
var pright = $tab.offset().left + $tab.width() - 80;
var cleft = $tabTitle.offset().left;
var cright = cleft + $tabTitle.width() + 30;
var cmgLeft = parseFloat($tabTitle.parent().css(&quot;margin-left&quot;).replace(&quot;px&quot;, &quot;&quot;));

if (cleft &amp;lt; pleft) {
    cmgLeft = (cmgLeft + pleft - cleft);
    $tabTitle.parent().css(&quot;margin-left&quot;, cmgLeft + &quot;px&quot;);
} else if (cright &amp;gt; pright) {
    cmgLeft = (cmgLeft + pright - cright);
    $tabTitle.parent().css(&quot;margin-left&quot;, cmgLeft + &quot;px&quot;);
}
···&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;左右滑动&quot;&gt;左右滑动&lt;/h2&gt;
&lt;h3 id=&quot;思路-1&quot;&gt;思路&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;分页的思想：把Tabs栏的宽度类比为 &lt;code&gt;PageSize[分页大小]&lt;/code&gt; , 打开标签页占用的总长度类比为 &lt;code&gt;TotalCount[总数]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;关键代码实现-1&quot;&gt;关键代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;
/**
 * 翻页
 * @param {页码}} pageIndex 
 */
var changePage = function(diff) {
    // 容器宽度
    var cWidth = $('.ls-tab-container').width() - 119;
    var $firstTitle = $('.ls-tab-titles .tab-title:first'),
        $lastTitle = $('.ls-tab-titles .tab-title:last');
    // 内容宽度
    var tsWidth = $lastTitle.offset().left -
        $firstTitle.offset().left +
        $lastTitle.width() + 30;
    var curPage = $title_container.attr(&quot;cur-p&quot;);

    // 容器 margin-left 用于计算当前页码
    var cmgLeft = parseFloat($title_container.css(&quot;margin-left&quot;).replace(&quot;px&quot;, &quot;&quot;));
    curPage = Math.floor(Math.abs(cmgLeft) / cWidth) + 1;

    var totalPage = Math.floor(tsWidth / cWidth) + (tsWidth % cWidth &amp;gt; 0 ? 1 : 0);
    curPage = curPage + diff;
    if (curPage &amp;gt;= totalPage) {
        curPage = totalPage;
        $title_container
            .css(&quot;margin-left&quot;, (1 - totalPage) * cWidth + &quot;px&quot;)
            .attr(&quot;cur-p&quot;, totalPage);
    } else if (curPage &amp;lt;= 1) {
        curPage = 1;
        $title_container
            .css(&quot;margin-left&quot;, &quot;0px&quot;)
            .attr(&quot;cur-p&quot;, &quot;1&quot;);
    } else {
        $title_container
            .css(&quot;margin-left&quot;, (1 - curPage) * cWidth + &quot;px&quot;)
            .attr(&quot;cur-p&quot;, curPage);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;效果预览-1&quot;&gt;效果预览&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12817403-a2ea54da206acbeb.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;5.gif&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;欢迎批评指正&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;源码地址&quot;&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LaosanShang/ls-admin-frontend&quot; class=&quot;uri&quot;&gt;https://github.com/LaosanShang/ls-admin-frontend&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 15:54:00 +0000</pubDate>
<dc:creator>CharlesShang</dc:creator>
<og:description>目录 &amp;quot;东拼西凑完成一个后台 ”前端框架“ (1) 布局&amp;quot; &amp;quot;东拼西凑完成一个后台 ”前端框架“ (2) 字体图标&amp;quot; &amp;quot;东拼西凑完成一个“前端框架”(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xinwang/p/12159153.html</dc:identifier>
</item>
<item>
<title>用实例理解设计模式——代理模式（Python版） - 西加加先生</title>
<link>http://www.cnblogs.com/ghostlee/p/12159107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ghostlee/p/12159107.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;代理模式&lt;/code&gt;：&lt;strong&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理模式分为：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;静态代理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态代理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;由下面三部分组成&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;抽象角色&lt;/code&gt;&lt;/strong&gt;：通过接口或抽象类声明真实角色实现的业务方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;代理角色&lt;/code&gt;&lt;/strong&gt;：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;真实角色&lt;/code&gt;&lt;/strong&gt;：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。&lt;/p&gt;
&lt;h2 id=&quot;静态代理&quot;&gt;静态代理&lt;/h2&gt;
&lt;p&gt;在程序运行前，就已经确定代理类和委托类的关系的代理方式，被称为&lt;code&gt;静态代理&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例：&lt;strong&gt;小明请律师进行诉讼&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;诉讼流程可抽象为&lt;code&gt;ILawsuit&lt;/code&gt;类，如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import abc
class ILawsuit(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def submit(self):   # 提交申请
        pass
    @abc.abstractmethod
    def burden(self):   # 进行举证
        pass
    @abc.abstractmethod
    def defend(self):   # 开始辩护
        pass    
    @abc.abstractmethod
    def finish(self):   # 诉讼完成
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小明为具体诉讼人，可写为&lt;code&gt;Litigant&lt;/code&gt;类，如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Litigant(ILawsuit):       # 继承于ILawsuit
    def __init__(self, name):
        self.name = name
    def submit(self):
        print(f'{self.name}申请仲裁！')
    def burden(self):
        print('证据如下：XXXXXX') 
    def defend(self):
        print('辩护过程：XXXXXX')  
    def finish(self):
        print('诉讼结果如下：XXXXXX')     &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;律师可写为&lt;code&gt;Lawyer&lt;/code&gt;类，如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Lawyer(ILawsuit):     # 继承于ILawsuit
    def __init__(self, litigant):
        self.litigant = litigant    # 具体诉讼人 
    def submit(self):
        self.litigant.submit()
    def burden(self):
        self.litigant.burden()
    def defend(self):
        self.litigant.defend()
    def finish(self):
        self.litigant.finish()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;诉讼过程，可表示为：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if __name__ == '__main__':
    xiaoming = Litigant('小明')       
    lawyer = Lawyer(xiaoming)       
    lawyer.submit()     # 律师提交诉讼申请
    lawyer.burden()     # 律师进行举证
    lawyer.defend()     # 律师替小明辩护
    lawyer.finish()     # 完成诉讼
    
# 输出结果
小明申请仲裁！
证据如下：XXXXXX
辩护过程：XXXXXX
诉讼结果如下：XXXXXX&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;静态代理的优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;：业务类只需要关注业务逻辑本身，保证了业务类的重用性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;：代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。&lt;/p&gt;
&lt;h2 id=&quot;动态代理&quot;&gt;动态代理&lt;/h2&gt;
&lt;p&gt;代理类在程序运行时创建的代理方式被称为 &lt;code&gt;动态代理&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;也就是说，这种情况下，代理类并不是在代码中定义的，而是在运行时根据我们在代码中的&lt;code&gt;指示&lt;/code&gt;动态生成的。&lt;/p&gt;
&lt;p&gt;同样，我们举例说明：&lt;/p&gt;
&lt;p&gt;通常我们调用REST API通常可能是这样的：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import urllib
import json

def fetch_resource(resource_id):
    opener = urllib.urlopen('http://remote.server/api/resource/' + resource_id)
    if opener.code != 200:
        raise RuntimeError('invalid return code!')
    content = opener.read()
    try:
        return json.loads(content)
    except ValueError:
        return content&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于每一个REST操作，都会有类似的代码。差别仅在于API的地址和HTTP method（GET、POST、等）。此时，可以引入一个&lt;code&gt;GetProxy&lt;/code&gt;，可以代替我们实现这些繁杂的工作。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import urllib
import json

class GetProxy(object):
    def __getattr__(self, api_path):
        def _rest_fetch(*paras):
            opener = urllib.urlopen('http://remote.server/api/' + api_path + '/' + '/'.join(resource_id))
            if opener.code != 200:
                raise RuntimeError('invalid return code!')
            content = opener.read()
            try:
                return json.loads(content)
            except ValueError:
                return content

        return _rest_fetch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，新的调用方式如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;proxy = GetProxy()

# 调用API
proxy.user(123) # http://remote.server/api/user/123
proxy.resource('switch', 456) # http://remote.server/api/resource/switch/456&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，通过动态代理，极大简化了调用过程。&lt;/p&gt;
&lt;p&gt;相比于静态代理， 动态代理的优势在于可以&lt;strong&gt;很方便的对代理类的函数进行统一的处理&lt;/strong&gt;，而不用修改每个代理类的函数。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;http://adolph.cc/15712984956484.html&lt;br/&gt;https://blog.zhangyu.so/python/2016/02/24/design-patterns-of-python-proxy/&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019122212244550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RnX2xlZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 15:34:00 +0000</pubDate>
<dc:creator>西加加先生</dc:creator>
<og:description>： 为其他对象提供一种代理以控制对这个对象的访问。 在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 代理模式分为： 静态代理 动态代理 由</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ghostlee/p/12159107.html</dc:identifier>
</item>
<item>
<title>.NET Core 3.1和WorkerServices构建Windows服务 - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/12159091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/12159091.html</guid>
<description>&lt;blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;ASP.NET Core 3增加了一个非常有意思的功能&lt;strong&gt;Worker Service&lt;/strong&gt;.他是一个ASP.NET Core模板,他允许我们创建托管长期的运行的后台服务,这些服务具体实现&lt;strong&gt;IHostedService&lt;/strong&gt;接口的后台任务逻辑,他被成为&quot;托管服务&quot;.同时他们可以部署到windows中Windows服务，以及Linux守护程序.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;创建一个托管服务&quot;&gt;创建一个托管服务&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们通过命令行界面中的dotnet new 命令。通过如下代码创建一个名为&lt;strong&gt;customWorker&lt;/strong&gt;的WorkerService的应用。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
dotnet new worker -o customWorker
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Program.cs:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace WorkerServiceDemo
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureServices((hostContext, services) =&amp;gt;
                {
                    services.AddHostedService&amp;lt;Worker&amp;gt;();
                });
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Worker:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BackgroundService&lt;/strong&gt;是实现了&lt;strong&gt;IHostedService&lt;/strong&gt;的基类.调用 &lt;strong&gt;ExecuteAsync(CancellationToken)&lt;/strong&gt; 来运行后台服务。实现返回一个Task,其表示后台服务整个生存期.在 &lt;strong&gt;ExeuteAsync&lt;/strong&gt;(例如通过调用await)之前,不会启动任何其他服务.避免在&lt;em&gt;ExecuteAsync&lt;/em&gt;中执行长时间的阻塞初始化. &lt;strong&gt;StopAsync(CancellationToekn)&lt;/strong&gt; 中的主机块等待完成&lt;em&gt;ExecuteAsync&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;调用 IHostedService.StopAsync 时，将触发取消令牌。 当激发取消令牌以便正常关闭服务时，ExecuteAsync 的实现应立即完成。 否则，服务将在关闭超时后不正常关闭。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace WorkerServiceDemo
{
    public class Worker : BackgroundService
    {
        private readonly ILogger&amp;lt;Worker&amp;gt; _logger;

        public Worker(ILogger&amp;lt;Worker&amp;gt; logger)
        {
            _logger = logger;
        }

        public override async Task StartAsync(CancellationToken cancellationToken)
        {
            await base.StartAsync(cancellationToken);
        }

        public override async Task StopAsync(CancellationToken cancellationToken)
        {
            await base.StopAsync(cancellationToken);
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                _logger.LogInformation(&quot;Worker running at: {time}&quot;, DateTimeOffset.Now);
                await Task.Delay(1000, stoppingToken);
            }
        }

        public override void Dispose()
        {
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;已使用AddHostedService扩展方法在 &lt;em&gt;IHostBuilder.ConfigureServices&lt;/em&gt;（Program.cs）中注册该服务。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
 services.AddHostedService&amp;lt;Worker&amp;gt;();
 &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;workerservices部署到windows服务&quot;&gt;WorkerServices部署到Windows服务&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装 WorkerServices模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1098068/202001/1098068-20200106232053082-1864393521.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在IHostBuilder使用UseWindowsService扩展方法&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;


namespace WorkerServiceDemo
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args)
        {
            return Host.CreateDefaultBuilder(args)
               
                .ConfigureServices((hostContext, services) =&amp;gt;
                {
                    services.AddHostedService&amp;lt;Worker&amp;gt;();
                }).UseWindowsService(); ;

        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以部署我们的windows服务了。&lt;/p&gt;
&lt;p&gt;发布方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用sc.exe工具&lt;/li&gt;
&lt;li&gt;直接部署exe文件&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;发布windows服务&quot;&gt;发布Windows服务&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
dotnet restore
dotnet publish
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sc.exe部署&quot;&gt;sc.exe部署&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
sc.exe create DemoWorker binpath= publish\xxxx.exe
sc.exe start WorkerServicesName
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部署exe文件&quot;&gt;部署exe文件&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
WorkerServicesName.exe install
WorkerServicesName.exe start
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用sc.exe停止和删除&quot;&gt;使用sc.exe停止和删除&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
sc.exe stop WorkerServicesName 
sc.exe delete WorkerServicesName 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;非sc.exe停止和删除&quot;&gt;非sc.exe停止和删除&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
WorkerServicesName stop  
WorkerServicesName uninstall
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/windows-service?view=aspnetcore-3.1&amp;amp;tabs=visual-studio&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/windows-service?view=aspnetcore-3.1&amp;amp;tabs=visual-studio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hueifeng/BlogSample/tree/master/src/WorkerServiceDemo&quot; class=&quot;uri&quot;&gt;https://github.com/hueifeng/BlogSample/tree/master/src/WorkerServiceDemo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 15:22:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>介绍 ASP.NET Core 3增加了一个非常有意思的功能 Worker Service .他是一个ASP.NET Core模板,他允许我们创建托管长期的运行的后台服务,这些服务具体实现 IHost</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/12159091.html</dc:identifier>
</item>
<item>
<title>[技术翻译]使用Nuxt生成静态网站 - 小磊哥er</title>
<link>http://www.cnblogs.com/yzsunlei/p/12159076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yzsunlei/p/12159076.html</guid>
<description>&lt;p&gt;本周再来翻译一些技术文章，本次预计翻译三篇文章如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6.5911949685535&quot;&gt;
&lt;p&gt;我翻译的技术文章都放在一个github仓库中，如果觉得有用请点击star收藏。我为什么要创建这个git仓库？目的是通过翻译国外的web相关的技术文章来学习和跟进web发展的新思想和新技术。git仓库地址：&lt;a href=&quot;https://github.com/yzsunlei/javascript-article-translate&quot; class=&quot;uri&quot;&gt;https://github.com/yzsunlei/javascript-article-translate&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静态网站如今再次流行起来了。信息站和品牌宣传站不再需要使用WordPress之类的内容管理系统来动态更新。&lt;/p&gt;
&lt;p&gt;使用静态网站生成器，您可以从无源CMS，API等动态源以及Markdown文件等文件中获取内容。&lt;/p&gt;
&lt;p&gt;Nuxt是基于Vue.js的出色的静态网站生成器，可轻松用于构建静态网站。使用Nuxt，从动态内容构建静态网站所需要做的就是创建模板，以从API和Markdown文件等动态源动态显示内容。然后，在Nuxt配置文件中，我们静态定义路由，以便它可以通过相同的路由将内容生成为静态文件。&lt;/p&gt;
&lt;p&gt;在本文中，我们将使用Nuxt构建新闻网站，并将使用&lt;code&gt;https://newsapi.org/&lt;/code&gt;的News API 作为内容。您必须先了解Vue.js，然后才能使用Nuxt建立网站，因为Nuxt是基于Vue.js的框架。&lt;/p&gt;
&lt;p&gt;首先，我们在News API网站上注册API密钥。如果我们只想获取头条新闻，它是免费的。我们开始来使用Nuxt CLI构建网站。我们通过键入以下命令来运行：&lt;/p&gt;
&lt;pre class=&quot;vuejs&quot;&gt;
&lt;code&gt;npx create-nuxt-app news-website&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将在news-website文件夹中创建初始项目文件。运行该向导时，我们不为服务器端框架选择任何内容，不为UI框架选择任何内容，不为测试框架选择任何内容，不为Nuxt模式选择通用文件，最后根据您的情况选择是否包含Axios请求库，使用lint进行代码整理和prettify进行代码美化。&lt;/p&gt;
&lt;p&gt;接下来，我们需要安装一些软件包。我们需要&lt;code&gt;@nuxtjs/dotenv&lt;/code&gt;用于在本地读取环境变量的程序包和&lt;code&gt;country-list&lt;/code&gt;用于在我们的网站上获取国家列表的库。要安装它们，我们运行：&lt;/p&gt;
&lt;pre class=&quot;vuejs&quot;&gt;
&lt;code&gt;npm i @nuxtjs/dotenv country-list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以开始建立我们的网站了。在default.vue文件中，我们将现有代码替换为：&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;  
  &amp;lt;div&amp;gt;
    &amp;lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&amp;gt;
      &amp;lt;nuxt-link class=&quot;navbar-brand&quot; to=&quot;/&quot;&amp;gt;News Website&amp;lt;/nuxt-link&amp;gt;
      &amp;lt;button
        class=&quot;navbar-toggler&quot;
        type=&quot;button&quot;
        data-toggle=&quot;collapse&quot;
        data-target=&quot;#navbarSupportedContent&quot;
        aria-controls=&quot;navbarSupportedContent&quot;
        aria-expanded=&quot;false&quot;
        aria-label=&quot;Toggle navigation&quot;
      &amp;gt;
        &amp;lt;span class=&quot;navbar-toggler-icon&quot;&amp;gt;&amp;lt;/span&amp;gt;
      &amp;lt;/button&amp;gt; &amp;lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&amp;gt;
        &amp;lt;ul class=&quot;navbar-nav mr-auto&quot;&amp;gt;
          &amp;lt;li class=&quot;nav-item active&quot;&amp;gt;
            &amp;lt;nuxt-link class=&quot;nav-link&quot; to=&quot;/&quot;&amp;gt;Home&amp;lt;/nuxt-link&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;li class=&quot;nav-item dropdown&quot;&amp;gt;
            &amp;lt;a
              class=&quot;nav-link dropdown-toggle&quot;
              href=&quot;#&quot;
              id=&quot;navbarDropdown&quot;
              role=&quot;button&quot;
              data-toggle=&quot;dropdown&quot;
              aria-haspopup=&quot;true&quot;
              aria-expanded=&quot;false&quot;
            &amp;gt;Headliny by Country&amp;lt;/a&amp;gt;
            &amp;lt;div class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&amp;gt;
              &amp;lt;nuxt-link
                class=&quot;dropdown-item&quot;
                :to=&quot;`/headlines/${c.code}`&quot;
                v-for=&quot;(c, i) of countries&quot;
                :key=&quot;i&quot;
              &amp;gt;{{c.name}}&amp;lt;/nuxt-link&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/nav&amp;gt;
    &amp;lt;nuxt /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { requestsMixin } from &quot;~/mixins/requestsMixin&quot;;
const { getData } = require(&quot;country-list&quot;);

export default {
  mixins: [requestsMixin],
  data() {
    return {
      countries: getData()
    };
  }
};
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
.bg-light {
  background-color: lightcoral !important;
}
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是用于定义我们网站布局的文件。我们在此处添加了Bootstrap导航栏。该栏包含主页链接和国家列表的下拉列表。这些nuxt-link组件都是指向页面的链接，这些页面用于在生成静态文件时获取国家/地区的标题。可以通过调用函数从该部分的country-list包中获取国家。在本节中，我们通过覆盖类的默认颜色来更改导航栏的背景颜色。本部分底部的组件将显示我们的内容。&lt;/p&gt;
&lt;pre class=&quot;vuejs&quot;&gt;
&lt;code&gt;scriptgetDatastyle.bg-lightnuxttemplate&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们创建一个mixins文件夹并创建一个名为requestsMixin.jsfile的文件。在其中，我们添加：&lt;/p&gt;
&lt;pre class=&quot;vuejs&quot;&gt;
&lt;code&gt;const APIURL = &quot;https://newsapi.org/v2&quot;;  
const axios = require(&quot;axios&quot;);
export const requestsMixin = {  
  methods: {  
    getHeadlines(country) {  
      return axios.get(  
        `${APIURL}/top-headlines?country=${country}&amp;amp;apiKey=${process.env.VUE_APP_APIKEY}`  
      );  
    }, getEverything(keyword) {  
      return axios.get(  
        `${APIURL}/everything?q=${keyword}&amp;amp;apiKey=${process.env.VUE_APP_APIKEY}`  
      );  
    }  
  }  
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该文件包含用于从News API获取按国家/地区和关键字作为标题的代码。&lt;/p&gt;
&lt;p&gt;然后，在pages文件夹中，我们创建headlines文件夹，然后在文件headlines夹中，创建_countryCode.vue文件。在文件中，我们添加：&lt;/p&gt;
&lt;pre class=&quot;vuejs&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;  
  &amp;lt;div class=&quot;container&quot;&amp;gt;  
    &amp;lt;h1 class=&quot;text-center&quot;&amp;gt;Headlines in {{getCountryName()}}&amp;lt;/h1&amp;gt;  
    &amp;lt;div v-if=&quot;headlines.length &amp;gt; 0&quot;&amp;gt;  
      &amp;lt;div class=&quot;card&quot; v-for=&quot;(h, i) of headlines&quot; :key=&quot;i&quot;&amp;gt;  
        &amp;lt;div class=&quot;card-body&quot;&amp;gt;  
          &amp;lt;h5 class=&quot;card-title&quot;&amp;gt;{{h.title}}&amp;lt;/h5&amp;gt;  
          &amp;lt;p class=&quot;card-text&quot;&amp;gt;{{h.content}}&amp;lt;/p&amp;gt;  
          &amp;lt;button class=&quot;btn btn-primary&quot; :href=&quot;h.url&quot; target=&quot;_blank&quot; variant=&quot;primary&quot;&amp;gt;Read&amp;lt;/button&amp;gt;  
        &amp;lt;/div&amp;gt;  
        &amp;lt;img :src=&quot;h.urlToImage&quot; class=&quot;card-img-bottom&quot; /&amp;gt;  
      &amp;lt;/div&amp;gt;  
    &amp;lt;/div&amp;gt;  
    &amp;lt;div v-else&amp;gt;  
      &amp;lt;h2 class=&quot;text-center&quot;&amp;gt;No headlines found.&amp;lt;/h2&amp;gt;  
    &amp;lt;/div&amp;gt;  
  &amp;lt;/div&amp;gt;  
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;  
import { requestsMixin } from &quot;~/mixins/requestsMixin&quot;;  
const { getData } = require(&quot;country-list&quot;);

export default {  
  mixins: [requestsMixin],  
  data() {  
    return {  
      headlines: [],  
      countries: getData()  
    };  
  },  
  beforeMount() {  
    this.getHeadlinesByCountry();  
  },  
  methods: {  
    async getHeadlinesByCountry() {  
      this.country = this.$route.params.countryCode;  
      const { data } = await this.getHeadlines(this.country);  
      this.headlines = data.articles;  
    }, 

    getCountryName() {  
      const country = this.countries.find(  
        c =&amp;gt; c.code == this.$route.params.countryCode  
      );  
      return country ? country.name : &quot;&quot;;  
    }  
  }  
};  
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该文件中，我们接受route参数，countryCode然后从该位置调用我们之前制作并包含在此组件中的&lt;code&gt;this.getHeadlines&lt;/code&gt;函数，requestsMixin以从News API获取标题。然后结果将显示在该template部分的Bootstrap卡中。在模板中，我们通过从country-list数据中找到国家名称来获得国家名称。如果找不到标题，我们会显示一条消息。通常，如果要制作一个接受URL参数的页面，则必须制作一个带有下划线作为第一个字符以及所需URL参数的变量名的文件。因此，在此示例中，_countryCode.vue中我们将countryCode使用该参数&lt;code&gt;this.$route.params.countryCode&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来，index.vue在pages文件夹中，将现有代码替换为：&lt;/p&gt;
&lt;pre class=&quot;vuejs&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;  
  &amp;lt;div class=&quot;container&quot;&amp;gt;  
    &amp;lt;h1 class=&quot;text-center&quot;&amp;gt;Home&amp;lt;/h1&amp;gt;  
    &amp;lt;div class=&quot;card&quot; v-for=&quot;(h, i) of headlines&quot; :key=&quot;i&quot;&amp;gt;  
      &amp;lt;div class=&quot;card-body&quot;&amp;gt;  
        &amp;lt;h5 class=&quot;card-title&quot;&amp;gt;{{h.title}}&amp;lt;/h5&amp;gt;  
        &amp;lt;p class=&quot;card-text&quot;&amp;gt;{{h.content}}&amp;lt;/p&amp;gt;  
        &amp;lt;button class=&quot;btn btn-primary&quot; :href=&quot;h.url&quot; target=&quot;_blank&quot; variant=&quot;primary&quot;&amp;gt;Read&amp;lt;/button&amp;gt;  
      &amp;lt;/div&amp;gt;  
      &amp;lt;img :src=&quot;h.urlToImage&quot; class=&quot;card-img-bottom&quot; /&amp;gt;  
    &amp;lt;/div&amp;gt;  
  &amp;lt;/div&amp;gt;  
&amp;lt;/template&amp;gt;  
&amp;lt;script&amp;gt;  
import { requestsMixin } from &quot;~/mixins/requestsMixin&quot;;  
const { getData } = require(&quot;country-list&quot;);

export default {  
  mixins: [requestsMixin],  
  data() {  
    return {  
      headlines: []  
    };  
  },  
  beforeMount() {  
    this.getHeadlinesByCountry();  
  },  
  methods: {  
    async getHeadlinesByCountry() {  
      const { data } = await this.getHeadlines(&quot;us&quot;);  
      this.headlines = data.articles;  
    }  
  }  
};  
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;  
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这使我们可以在主页上显示美国的标题。它的工作原理与_countryCode.vue页面相似，不同之处在于，我们仅获得美国的头条新闻，而不接受URL参数来根据URL获得来自不同国家/地区的头条新闻。&lt;/p&gt;
&lt;p&gt;接下来，我们create-env.js在项目的根文件夹中创建一个，并添加以下内容：&lt;/p&gt;
&lt;pre class=&quot;vuejs&quot;&gt;
&lt;code&gt;const fs = require('fs')  
fs.writeFileSync('./.env', `API_KEY=${process.env.API_KEY}`)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这使我们可以部署到Netlify，因为我们需要.env根据输入的环境变量动态创建文件。另外，我们.env手动创建文件，然后将API_KEY键作为键，将News API API键作为值。&lt;/p&gt;
&lt;p&gt;接下来的nuxt.config.js，我们将现有代码替换为：&lt;/p&gt;
&lt;pre class=&quot;vuejs&quot;&gt;
&lt;code&gt;require(&quot;dotenv&quot;).config();  
const { getData } = require(&quot;country-list&quot;);

export default {  
  mode: &quot;universal&quot;,  
  /*  
   ** Headers of the page  
   */  
  head: {  
    title: &quot;News Website&quot;,  
    meta: [  
      { charset: &quot;utf-8&quot; },  
      { name: &quot;viewport&quot;, content: &quot;width=device-width, initial-scale=1&quot; },  
      {  
        hid: &quot;description&quot;,  
        name: &quot;description&quot;,  
        content: process.env.npm_package_description || &quot;&quot;  
      }  
    ],  
    link: [  
      { rel: &quot;icon&quot;, type: &quot;image/x-icon&quot;, href: &quot;/favicon.ico&quot; },  
      {  
        rel: &quot;stylesheet&quot;,  
        href:  
         &quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot;  
      }  
    ],  
    script: [  
      { src: &quot;https://code.jquery.com/jquery-3.3.1.slim.min.js&quot; },  
      {  
        src:  
          &quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js&quot;  
      },  
      {  
        src:  
          &quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js&quot;  
      }  
    ]  
  },  
  /*  
   ** Customize the progress-bar color  
   */  
  loading: { color: &quot;#fff&quot; },  
  /*  
   ** Global CSS  
   */  
  css: [],  
  /*  
   ** Plugins to load before mounting the App  
   */  
  plugins: [],  
  /*  
   ** Nuxt.js dev-modules  
   */  
  buildModules: [],  
  /*  
   ** Nuxt.js modules  
   */  
  modules: [  
    // Doc: https://axios.nuxtjs.org/usage    
    &quot;@nuxtjs/axios&quot;,  
    &quot;@nuxtjs/dotenv&quot;  
  ],  
  /*  
   ** Axios module configuration  
   ** See https://axios.nuxtjs.org/options
   */  
  axios: {},  
  /*  
   ** Build configuration  
   */  
  build: {  
    /*  
     ** You can extend webpack config here  
     */  
    extend(config, ctx) {}  
  },  
  env: {  
    apiKey: process.env.API_KEY || &quot;&quot;  
  },  
  router: {  
    routes: [  
      {  
        name: &quot;index&quot;,  
        path: &quot;/&quot;,  
        component: &quot;pages/index.vue&quot;  
      },  
      {  
        name: &quot;headlines-id&quot;,  
        path: &quot;/headlines/:countryCode?&quot;,  
        component: &quot;pages/headlines/_countryCode.vue&quot;  
      }  
    ]  
  },  
  generate: {  
    routes() {  
      return getData().map(d =&amp;gt; `headlines/${d.code}`);  
    }  
  }  
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在head对象中，我们更改了title以便显示所需的标题而不是默认标题。在link中，我们添加了Bootstrap CSS，在script中，我们添加了Bootstrap JavaScript文件和jQuery，它们是Bootstrap的依赖项。由于我们要构建静态站点，因此不能使用BootstrapVue，因为它是动态的。我们不希望在生成的输出中使用任何动态JavaScript，因此我们必须使用普通的Bootstrap。在modules中，我们添加&quot;@nuxtjs/dotenv&quot;了从.env创建到Nuxt应用程序的文件中读取环境变量的功能。我们还进行了添加，require(&quot;dotenv&quot;).config();以便我们可以将process.env.API_KEY其添加到此配置文件中。我们必须这样做，所以我们不必检入.env文件。在里面env部分，我们有了apiKey: process.env.API_KEY || &quot;&quot;，这是通过使用读取.env文件中的API KEY而获得的dotenv。&lt;/p&gt;
&lt;p&gt;在router中，我们定义了动态路由，以便当用户单击具有给定URL的链接或单击具有此类URL的链接时可以查看它们。Nuxt还使用这些路由来生成静态文件。在generate中，我们定义了Nuxt遍历的路径，以生成静态网站的静态文件。在这种情况下，路由数组由我们之前创建的标题页面的路由组成。它将遍历它们以获取它们的数据，然后渲染它们并从渲染的结果生成文件。文件夹结构将与路线相对应。因此，由于我们path是/headlines/:countryCode，因此生成的工件将具有该headlines文件夹以及所有国家/地区代码作为子文件夹的名称，并且在每个文件夹内将有一个index.html 与呈现的内容。&lt;/p&gt;
&lt;p&gt;现在，我们准备将我们的网站部署到Netlify。通过转到&lt;code&gt;https://www.netlify.com/&lt;/code&gt;创建一个Netlify帐户。免费计划将满足我们的需求。然后将代码提交到托管在GitHub，Gitlab或Bitbucket上的Git存储库。然后，当您登录Netlify时，单击Git中的New site。从那里，您可以添加托管在其中一项服务中的Git存储库。然后，当要求您输入Build Command时，输入&lt;code&gt;node ./create-env.js &amp;amp;&amp;amp; npm run generate&lt;/code&gt;，发布目录将为dist。&lt;/p&gt;
&lt;p&gt;之后，将.env文件中的API密钥输入到网站设置的“环境变量”部分，您可以通过单击“构建和部署”菜单上的“环境”链接来进入。输入API_KEY作为密钥，然后输入News API API密钥作为值。然后单击保存按钮。&lt;/p&gt;
&lt;p&gt;一旦将所有内容提交并推送到由GitHub，Gitlab或Bitbucket托管的Git存储库中，Netlify将自动构建和部署。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://dev.to/aumayeung/generate-static-websites-with-nuxt-1ia1&quot; class=&quot;uri&quot;&gt;https://dev.to/aumayeung/generate-static-websites-with-nuxt-1ia1&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 15:17:00 +0000</pubDate>
<dc:creator>小磊哥er</dc:creator>
<og:description>本周再来翻译一些技术文章，本次预计翻译三篇文章如下： &amp;quot;04.[译]使用Nuxt生成静态网站&amp;quot; ( &amp;quot;Generate Static Websites with Nuxt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yzsunlei/p/12159076.html</dc:identifier>
</item>
<item>
<title>2019年终总结&amp;小半年流媒体服务器开发经验总结 - 艾露米婭娜</title>
<link>http://www.cnblogs.com/ailumiyana/p/12159065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ailumiyana/p/12159065.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;时间转瞬即逝，转眼间19年已经过去了，人愈来愈来老，却不见人心和物质的提升，期望2020年能有一个崭新的自己。&lt;/p&gt;
&lt;p&gt;今年因为发展原因，从嵌入式跳槽做互联网后端了，干了一年突然转行，自己也很纠结这么做对不对，但归根结底我只是选择了做自己想做的事情，从事自己想做的工作罢了。&lt;/p&gt;
&lt;p&gt;虽然过来后发现也不并算真正意义上的后端工作，用到的后端技术并不多，主要时间挣扎在了流媒体的开发，音视频的编解码，滤波、硬件加速、rtp、音视频格式(aac、pcm、h264)、另外主管选择了开源的ffmpeg库、这些七七八八的东西够你折磨了。。&lt;/p&gt;
&lt;h2 id=&quot;年开发小结&quot;&gt;19年开发小结&lt;/h2&gt;
&lt;h3 id=&quot;流媒体服务框架设计&quot;&gt;流媒体服务框架设计&lt;/h3&gt;
&lt;p&gt;基于公司项目需求设计流媒体服务器，考虑到扩展性，采用了主流的多进程模型便于后期做分布式，同时解耦业务层与音视频处理层，便于更替音视频处理方案。&lt;/p&gt;
&lt;h3 id=&quot;登录服开发&quot;&gt;登录服开发&lt;/h3&gt;
&lt;p&gt;基于公共协议栈，管理用户登录、连接音视频服务、用户数据缓存、用户出入音视频服务动态等、迎合docker特点、单独用户数据缓存存储用户数据。&lt;/p&gt;
&lt;h3 id=&quot;ffmpeg音视频服务开发&quot;&gt;ffmpeg音视频服务开发&lt;/h3&gt;
&lt;p&gt;主要包括音视频相关内容的开发，也是开发投入时间最长的服务，主要经历了以下过程。&lt;/p&gt;
&lt;p&gt;1)、最初基于ffmpeg的h264软解实现服务demo.&lt;/p&gt;
&lt;p&gt;2)、然后尝试基于英特尔vaapi硬件加速驱动做h264硬解，对解码视频帧做软件overlay滤波进行音视频合成，再做vaapi硬编码。&lt;br/&gt;优点是此流程软件实现上会更为简洁快速，也比较稳定。&lt;br/&gt;但是后面发现系统会时不时crash。从系统日志上没有找到相关日志，于是进行了长期的软件模块排除法检查问题原因，做了解码、解码+滤波、滤波+编码等单元模块组挂机测试，仍然无法找到系统crash问题原因。&lt;br/&gt;同时也在微软的github仓库提交了bug/issue，但是回复较慢。&lt;/p&gt;
&lt;p&gt;3)、起初怀疑是vaapi驱动问题，于是尝试使用英特尔qsv硬件加速驱动硬解，对解码视频帧做硬件overlay_qsv滤波进行音视频合成，再做qsv硬编码。&lt;br/&gt;优点是音视频处理全交付于gpu处理，省下大片cpu时间。缺点是硬件帧上下文关系密切，做视频自动切换上，需要做更多软件处理，编码上略微复杂。&lt;br/&gt;可惜系统crash问题依然存在。&lt;/p&gt;
&lt;p&gt;4)、ffmpeg原生工具命令行测试系统crash问题，发现确实有这个问题，而且更换很多个ffmpeg版本都会出现，只是概率可能会有浮动：快的几分钟到几小时crash、慢的一星期可能不会出现，但是不改任何参数再次尝试依然可能crash.&lt;/p&gt;
&lt;p&gt;5)、移植音视频服务从linux到windows系统下、经过长期测试windows下运行intel加速方案确实没有系统宕机问题了、同时因为登录服基于muduo库实现，移植复杂，改将登录服打包进docker容器运行。&lt;/p&gt;
&lt;p&gt;6)、完善及优化音视频服务框架及功能。包括：添加适当rtp缓存解决公网环境udp包波动问题、添加音视频同步机制、增加相应业务功能接口。&lt;/p&gt;
&lt;p&gt;7)、移植到微服务框架，进一步增强程序扩展性。&lt;/p&gt;
&lt;h3 id=&quot;音视频控制&quot;&gt;音视频控制&lt;/h3&gt;
&lt;p&gt;1、创建房间：单机能创建的房间数量是有限的，但是要控制画质流畅不丢帧，瓶颈在于视频合成流数量和硬件性能(核心数越多可以适当降低丢帧率，intel驱动性能瓶颈)、&lt;br/&gt;可以堆音视频服务机器解决这个问题，但是体感性价比并不高。&lt;/p&gt;
&lt;p&gt;2、直播房间的增、删、改、查。&lt;/p&gt;
&lt;p&gt;3、多路流输入下、可指定流合成数量、或者、自动根据流数量合成。&lt;/p&gt;
&lt;p&gt;4、 去除音频回音、单条流的音频开关。&lt;/p&gt;
&lt;p&gt;5、 配置视频profile level、 获取帧率、丢包率等。&lt;/p&gt;
&lt;p&gt;6、其他。&lt;/p&gt;
&lt;h2 id=&quot;流媒体服务开发小结&quot;&gt;流媒体服务开发小结&lt;/h2&gt;
&lt;h3 id=&quot;rtp处理&quot;&gt;rtp处理&lt;/h3&gt;
&lt;p&gt;rtp完全是自己解的，没有用ffmpeg的avformat库，这样我更便于管理网络处理部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/202001/1384555-20200106231141184-1564959477.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是udp在公网上可能存在网络抖动问题，服务端接收到的udp包不一定能按序到达，也可能存在丢包等问题，你需要开一块rtp缓存，按seq做最小堆。我直接用的golang的heap包实现的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;然后实际上也可以按相对时间戳来heap的compare，这样也方便你做音视频同步，记录第一个到达的rtp包时间戳、后续rtp的时间戳按timestamp的增量做时钟的换算，换算成一个浮点时间来排序。&lt;br/&gt;例如 h264 90000的时钟 、 30的帧率 、 : 那么 3000时间戳增量 代表 3000 / 90000 = 33.33333ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后就是rtp时间的同步 : av_rtp_handler所有rtp包都带了我一个换算出来的相对时间戳的、 我只需要将音视频的包做一次最小堆插入、每次去取堆顶时间戳最小的rtp包即可、 是音频包就丢进音频解码器、视频包就丢进视频解码器。&lt;/p&gt;
&lt;h3 id=&quot;视频的合成音视频缓冲区&quot;&gt;视频的合成&amp;amp;音视频缓冲区&lt;/h3&gt;
&lt;p&gt;我想了很久音视频进行合成结构后发现有一个很重要的东西、那就是音视频帧的缓冲区、而且这个缓冲区真的很重要、它能做到以下效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、控制帧率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2、解决多路流的音视频帧抖动问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、 通过一个定时器、你能很方便的控制帧率、例如隔33ms往合成器发送一组音视频帧进行合成即可。修改帧率你只需要更改定时器的种子值。&lt;/p&gt;
&lt;p&gt;2、消抖、每路流到达的时间肯定是不稳定的、可能通道3一下子除了了5包数据、一下子来了10帧数据、而其他路还只有1到2帧或者没有、但是你要保持实时性肯定不能把所有帧全部保存下来、所以你必须控制每路的缓冲大小得把挤出来的非I帧删掉、注意是&lt;code&gt;非I帧&lt;/code&gt;不然可能会花屏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/202001/1384555-20200106231131687-358886319.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就是音视频合成、音频用amix、视频用overlay、&lt;/p&gt;
&lt;p&gt;视频帧合成麻烦在qsv有一个硬件帧上下文、&lt;code&gt;qsvframecontext&lt;/code&gt;每次做屏幕的&lt;code&gt;自动切换&lt;/code&gt;、或者&lt;code&gt;屏幕位置交换&lt;/code&gt;、需要重新生成filter、而你就需要费工夫去更新这个&lt;code&gt;qsvframecontext&lt;/code&gt; 极为麻烦、后面想到的方法是设计一张ffmpeg filter输入的映射&lt;/p&gt;
&lt;p&gt;就是在不该ffmpeg滤波器描述符的情况下、而是直接交换filter的输入位置。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个草图将就下： 相当于 就是打乱正当的输入顺序、做一张映射、这样子不用更改filter的描述符即可做滤波器的切换，要便利极多！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/202001/1384555-20200106231123554-822782447.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;音频合成没什么好说的、就是每路的输出可能不能包含自己的通道声音、不然可能存在回音、你只需要弄个set记录需要合成的流输入id的集合、合成的时候把自己的id去掉再合成就行了。&lt;/p&gt;
&lt;h3 id=&quot;音视频编码&quot;&gt;音视频编码&lt;/h3&gt;
&lt;p&gt;编码好像没什么重点东西、打包的时候打上个合适的时间戳即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/202001/1384555-20200106231114592-936760168.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;回顾19展望20&quot;&gt;回顾19展望20&lt;/h2&gt;
&lt;p&gt;今年其实挺累的、第一次一个人从零写了一整套流媒体服务、以及整个系统框架的搭建、最后也学习了主流后端框架、移植到了微服务框架上。虽然做了很多事但是收获也多多。希望未来能有更好的发展。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jan 2020 15:12:00 +0000</pubDate>
<dc:creator>艾露米婭娜</dc:creator>
<og:description>2019年终总结&amp;amp;小半年流媒体服务器开发经验总结 [toc] 时间转瞬即逝，转眼间19年已经过去了，人愈来愈来老，却不见人心和物质的提升，期望2020年能有一个崭新的自己。 今年因为发展原因，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ailumiyana/p/12159065.html</dc:identifier>
</item>
</channel>
</rss>