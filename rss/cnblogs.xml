<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>牙疼真要命，牙坏真烧钱 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10166473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10166473.html</guid>
<description>&lt;p&gt;个人博客原文：&lt;br/&gt;&lt;a href=&quot;http://www.liebrother.com:8080/tooth&quot;&gt;牙疼真要命，牙坏真烧钱&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20180109.jpg?imageView2/1/w/960/h/520/interlace/1/q/100&quot; alt=&quot;景&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;牙齿真折腾。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;周末回了一趟老家。看标题就知道去干嘛了，治牙去了。从小牙齿就不好，年纪轻轻就装了 4 颗牙套。。。这一次又是蛀牙，3 颗牙套最近松了，没什么注意，导致里面的牙齿细菌滋生，又蛀牙了，而且蛀得不轻，基本上已经坏死，只能根管治疗，然后重新装 3 颗牙套，一个牙套 1800 块，3 个就 5400 块。。。病不起。&lt;/p&gt;
&lt;p&gt;一朋友前段时间他去洗牙，医生发现他有将近 10 颗牙需要补，这次他知道我要回老家看牙医，因为我在这个牙医已经看了十几年了，家里人都在他那里看，口碑一直不错，技术也过硬，所以他就跟我一起去看牙齿。他的牙齿外面看起来挺完整的，给医生看完，发现其实很多个牙齿都蛀了，但都是蛀一丁点，所以都需要处理，大概处理了十几个，补了将近一个小时，最后花了 2000 块。&lt;/p&gt;
&lt;p&gt;有些朋友同事问我为啥不在深圳看牙医，有医保，可以报销。其实不仅仅是钱的问题，一方面是在深圳看医生相对来说比较困难，网上预约经常预约不到好的时间；另一方面是医生不知道技术怎么样？有人会问在深圳大医院肯定技术牛逼，这真不好说，高中因为咽喉炎以及胃的问题，看了大大小小的医生，真不见得在大医院的医生就很牛逼，并且老家这个医生很靠谱、技术不马虎、很是靠谱，以前的牙是他做的，坏了让他弄也比较好处理。还有一些是老家也不远，从深圳坐高铁 2 个多小时就到了。&lt;/p&gt;
&lt;p&gt;我这副坏牙齿也不能给大家来介绍如何保护好牙齿，说了你们也不信，连我自己都不信。。。虽然我一直吃完饭就漱口，睡前也刷牙，但是还是没法保护好牙齿。那就给大家科普一下刚刚学习的知名刷牙方法：&lt;strong&gt;巴氏刷牙法&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法&quot;&gt;方法：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;握好牙刷：拇指前伸比“赞”手势；&lt;/li&gt;
&lt;li&gt;牙刷的方向要对准牙齿与牙龈交接地方，刷毛与牙齿呈 45-60 度角，定位好牙刷后，作短距离的水平运动，2到3颗前后来回刷约 10 次；&lt;/li&gt;
&lt;li&gt;刷牙步骤：右后方颊侧开始，刷到左边;然后左边咬合面、左边舌侧再回到右边舌侧，然后右边咬合面；&lt;/li&gt;
&lt;li&gt;刷后牙舌侧时：左手刷右边后牙舌侧，右手刷左边后牙舌侧；&lt;/li&gt;
&lt;li&gt;刷颊侧时：刷右边颊侧时用右手，刷左边颊侧时用左手；&lt;/li&gt;
&lt;li&gt;刷完上面牙齿，用同样的方法刷下面牙齿。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;注意&quot;&gt;注意：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;刷牙颈部龈缘时，以 45 度角，做上下提拉颤动，不做来回刷；&lt;/li&gt;
&lt;li&gt;刷牙早晚各一次，每次不少于 3 分钟。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;巴氏刷牙法信息来自百度百科。&lt;/p&gt;
&lt;p&gt;希望大家重视起自己的牙齿，让自己牙齿健康起来。我也要好好保护好牙齿，以后有亲身经历哪些好的措施再分享给大家。大家对保护好牙齿有没有一些实用的方法，求介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com:8080/upload/df81ac224abe46b38131a0e78f4dcf9c_wechat.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 15:35:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>简单介绍巴氏刷牙法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10166473.html</dc:identifier>
</item>
<item>
<title>深入浅出Paxos算法 - Super Flanky</title>
<link>http://www.cnblogs.com/SuperFlanky/p/10165945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SuperFlanky/p/10165945.html</guid>
<description>&lt;p&gt;&lt;span&gt;Paxos&lt;span&gt;算法是用来解决分布式系统中，如何就某个值达成一致的算法。它晦涩难懂的程度完全可以跟它的重要程度相匹敌。目前关于&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;算法的介绍已经非常多，但却很少有人能对&lt;/span&gt;&lt;span&gt;P2c&lt;/span&gt;&lt;span&gt;提出自己的见解，大多数是和稀泥式的人云亦云。但我相信真理是越辩越明的，只有旗帜鲜明的亮出自己的观点，供大家讨论，才能学到东西。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我个人认为理解&lt;/span&gt;Paxos&lt;span&gt;有两个关键：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;为什么要对提案进行顺序编号（或者说更大的编号意味着什么）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;为什么&lt;/span&gt;Promise&lt;span&gt;能保证一致性（答案隐含在第&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;点中）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;假设有一组服务器保存了用户的余额，初始是&lt;/span&gt;100&lt;span&gt;块，现在用户提交了两个订单，一个订单是消费&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;元，一个订单是充值&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;元。由于网络错误和延迟等原因，导致一部分服务器只收到了第一个订单（余额更新为&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;元），一部分服务器只收到了第二个订单（余额更新为&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt;元），还有一部分服务器两个订单都接收到了（余额更新为&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;&lt;span&gt;元），这三者无法就最终余额达成一致。这就是一致性问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一致性算法并不保证所有提出的值都是正确的（这可能是安全管理员的职责）。我们假设所有提交的值都是正确的，算法需要对到底该选哪个做出决策，并使决策的结果被所有参与者获悉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在正式开始介绍&lt;/span&gt;Paxos&lt;span&gt;所面临的难题前，为了表述方便，先提一下&lt;/span&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;span&gt;算法中的三个角色，后面会比较频繁的用到：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Proposer&lt;span&gt;：议案发起者。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Acceptor&lt;span&gt;：决策者，可以批准议案。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Learner&lt;span&gt;：最终决策的学习者。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们虚拟一个一致性问题的场景：有一个用户小绿，现在要对他的姓氏信息进行修改，此时有多个不同的议案被提出，如何就最终的结果达成一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先看一下下面这种最简单的情况：&lt;/span&gt;A1&lt;span&gt;接受了&lt;/span&gt;&lt;span&gt;Pa&lt;/span&gt;&lt;span&gt;的议案“赵”，&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;接受了&lt;/span&gt;&lt;span&gt;Pb&lt;/span&gt;&lt;span&gt;的议案“钱”，那么最终小绿应该姓什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223214114933-295510977.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;答案很简单：超过半数的的议案就是最终的选定值。小绿应该姓&lt;/span&gt;“钱”！在议案提交后，&lt;span&gt;Pa&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Pb&lt;/span&gt;&lt;span&gt;只要查询一下小绿姓氏，很容易就能查到 “钱”的数量超过半数，因此&lt;/span&gt;&lt;span&gt;Pb&lt;/span&gt;&lt;span&gt;的议案将会返回“成功”，&lt;/span&gt;&lt;span&gt;Pa&lt;/span&gt;&lt;span&gt;的议案将会返回“失败”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;P0&lt;/strong&gt;&lt;strong&gt;. &lt;span&gt;当集群中，超过半数的&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;接受了一个议案，那我们就可以说这个议案被选定了（&lt;/span&gt;&lt;span&gt;Chosen&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P0&lt;span&gt;已经是一个完备的一致性算法，保证了&lt;/span&gt;&lt;span&gt;P0&lt;/span&gt;&lt;span&gt;也就解决了一致性问题。但是&lt;/span&gt;&lt;span&gt;P0&lt;/span&gt;&lt;span&gt;的实用性不佳，一个议案想被半数以上的&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;接受是一件极其困难的事情！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;看下面这种情况：&lt;/span&gt;A1&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;分别接受了“赵”，“钱”，“孙”，结果没有任何一个议案形成多数派，所有的议案都将返回“失败”。议案的数量越多，那议案被选定的概率就越低，这显然是没法容忍的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223214145901-723283848.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要解决这个问题，必须&lt;strong&gt;&lt;span&gt;允许一个&lt;/span&gt;Acceptor&lt;span&gt;接受多个议案，后接受的议案可以覆盖掉之前接受的议案&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如下图所示，&lt;/span&gt; A1&lt;span&gt;已经接受了“赵”，&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;已经接受了“钱”，此时&lt;/span&gt;&lt;span&gt;Pc&lt;/span&gt;&lt;span&gt;提出了“孙”，并被&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;接受，这样就解决了无法形成多数派的问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223214230083-1090702561.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但现在又会面临下图中的新问题：&lt;/span&gt;A1&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;已经接受了“赵”，此时我们认为“赵”是被选定的，但此时偏偏&lt;/span&gt;&lt;span&gt;Pb&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Pc&lt;/span&gt;&lt;span&gt;不识时务，&lt;/span&gt;&lt;span&gt;Pb&lt;/span&gt;&lt;span&gt;向&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;提出了“钱”，&lt;/span&gt;&lt;span&gt;Pc&lt;/span&gt;&lt;span&gt;向&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;提出了“孙”。这样就从一致性状态，又回到了不一致的状态&lt;/span&gt;…这显然破坏了一致性&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223214248264-2104471363.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Paxos&lt;span&gt;就是在上述背景下产生的，&lt;/span&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;span&gt;要实现的目标的是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;一次选举必须要选定一个议案（不能出现所有议案都被拒绝的情况）&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一次选举必须只选定一个议案（不能出现两个议案有不同的值，却都被选定的情况）&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先，&lt;/span&gt;Paxos&lt;span&gt;算法的必须要能满足第一个条件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;P1&lt;span&gt;：一个&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;必须接受它收到的第一个议案。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要满足这个条件实在太过简单了，方法略。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是我个人对这个条件的理解，为什么必须满足这个条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;假设只有一个&lt;/span&gt;Acceptor&lt;span&gt;，只有一个&lt;/span&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;。如果&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;出于某些原因拒绝了&lt;/span&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;的议案，那必然导致&lt;/span&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;span&gt;的目标&lt;/span&gt;&lt;span&gt;T1&lt;/span&gt;&lt;span&gt;无法达成。因此可以认为目标&lt;/span&gt;&lt;span&gt;T1&lt;/span&gt;&lt;span&gt;隐含了&lt;/span&gt;&lt;span&gt;P1&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在开始&lt;/span&gt;P2&lt;span&gt;的推导的前，为了区分不同议案，需要先对每个&lt;/span&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;的议案进行编号，编号时必须保证每个议案的编号具有唯一性（不讨论实现方法），而且编号是不断增大的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Paxos&lt;span&gt;的目标&lt;/span&gt;&lt;span&gt;T2&lt;/span&gt;&lt;span&gt;隐含了&lt;/span&gt;&lt;span&gt;P2&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;P2&lt;span&gt;：如果一个值为&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;的议案被选定了，那么被选定的更大编号的议案，它的值必须也是&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P2&lt;span&gt;很容易理解，除了其中的一个形容词“更大编号的”，这个形容词很扎眼，为什么只对更大编号的议案进行限制，更小的编号怎么办？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;老头子给的解释很简单&lt;/span&gt;“&lt;span&gt;By induction on proposal number&lt;/span&gt;&lt;span&gt;”（如果不看论文后半部分，没人知道他在说什么&lt;/span&gt;…）我说一下我自己的理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先把&lt;/span&gt;“更大编号的”几个字换成“其他的”，我们称它为&lt;span&gt;P2S&lt;/span&gt;&lt;span&gt;。那么&lt;/span&gt;&lt;span&gt;P2S&lt;/span&gt;&lt;span&gt;能否满足&lt;/span&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;span&gt;的目标？答案是肯定的。然后比较&lt;/span&gt;&lt;span&gt;P2&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;P2S&lt;/span&gt;&lt;span&gt;，谁的约束更强？这得看“更小的编号”是怎么处理的，从论文后面的推演来看更小编号的议案绝对不允许被选定！！！因此满足&lt;/span&gt;&lt;span&gt;P2&lt;/span&gt;&lt;span&gt;的议案是&lt;/span&gt;&lt;span&gt;P2S&lt;/span&gt;&lt;span&gt;的一个子集。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;显而易见，&lt;/span&gt;P2S&lt;span&gt;和&lt;/span&gt;&lt;span&gt;P2&lt;/span&gt;&lt;span&gt;都能满足&lt;/span&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;span&gt;目标。换句话说，能满足&lt;/span&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;span&gt;目标的办法很多，但我们只选其中一个办法就&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;了。不过，要选最简单的办法（看完后面就知道了）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总之，现在我们可以得出一个结论：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果&lt;/span&gt;P1&lt;span&gt;和&lt;/span&gt;&lt;span&gt;P2&lt;/span&gt;&lt;span&gt;都能够被满足，那么&lt;/span&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;span&gt;的两个目标就能够达成。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你对上面这个结论没有异议，那么就说明你已经充分理解了&lt;/span&gt;P1&lt;span&gt;和&lt;/span&gt;&lt;span&gt;P2&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来就需要想办法，如何才能满足&lt;/span&gt;P2&lt;span&gt;：议案在选定前，都要先被&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;接受，因此要满足&lt;/span&gt;&lt;span&gt;P2&lt;/span&gt;&lt;span&gt;，我们只要满足下面的条件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;P2a&lt;span&gt;：如果一个值为&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;的议案被选定了，那么&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;接受的更大编号的议案，它的值必须也是&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P2a&lt;span&gt;是&lt;/span&gt;&lt;span&gt;P2&lt;/span&gt;&lt;span&gt;的充分条件，但是&lt;/span&gt;&lt;span&gt;P2a&lt;/span&gt;&lt;span&gt;存在一个大麻烦：当一个议案被选定后，一部分&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;无法立刻获得通知。例如下图中&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;已经接受了“赵”，这时“赵”就被选定了，此时&lt;/span&gt;&lt;span&gt;Pb&lt;/span&gt;&lt;span&gt;向&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;提出了一个议案“钱”，这是&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;接受的第一个议案，为了满足&lt;/span&gt;&lt;span&gt;P1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;必须接受这个议案，此时就会导致&lt;/span&gt;&lt;span&gt;P2a&lt;/span&gt;&lt;span&gt;无法被满足了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223214329129-749112384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为了解决上述的问题，我们想一下：要是此时不让&lt;/span&gt;Pb&lt;span&gt;提出“钱”这个议案，而是提出“赵”这议案就万事大吉了。顺着这个思路，我们得到了&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;P2b&lt;span&gt;：如果一个值为&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;的议案被选定了，那么&lt;/span&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;提出的更大编号的议案，它的值必须也是&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P2b&lt;span&gt;是一个比&lt;/span&gt;&lt;span&gt;P2a&lt;/span&gt;&lt;span&gt;更强的约束，也就是说&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;P2a&lt;/span&gt;&lt;span&gt;的充分条件，只要能满足&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;，那&lt;/span&gt;&lt;span&gt;P2a&lt;/span&gt;&lt;span&gt;就自动满足。但&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;很难被满足，考虑下图这种情况，&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;接受了议案“赵”，&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;即将接受议案“赵”，此时&lt;/span&gt;&lt;span&gt;Pb&lt;/span&gt;&lt;span&gt;提出了一个议案“钱”，这种情况下我们又会遇到跟&lt;/span&gt;&lt;span&gt;P2a&lt;/span&gt;&lt;span&gt;完全相同的麻烦。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223214351962-825276522.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;很明显，要想满足&lt;/span&gt;P2b&lt;span&gt;，我们必需让&lt;/span&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;拥有“预测未来”的能力，这听起来像在讲鬼故事，后面会想办法解决这一点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在介绍如何&lt;/span&gt;“预测未来”之前，我们必须先确定&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;在提出一个议案时，它的值该如何选取，因为取值的方法决定了“预测”的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一个理所当然的取值方法：找到一个&lt;/span&gt;Acceptor&lt;span&gt;的多数派的集合，集合内被接受的议案的值都是&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;，此时&lt;/span&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;提出一个新的议案，议案的值必须也是&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;；如果没有这样的多数派集合，那&lt;/span&gt;&lt;span&gt;Proposer&lt;/span&gt;&lt;span&gt;就任意提。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这个取值方法，完全能符合&lt;/span&gt;P2b&lt;span&gt;，这是一目了然的，但问题出在 “预测”上，我们必须能预测到即将形成多数派的那个议案，如果有谁能做到那就真的是在讲鬼故事了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Proposal&lt;span&gt;提出议案的正确姿势：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;P2c&lt;span&gt;：在所有&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;中，任意选取半数以上的&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;集合，我们称这个集合为&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;Proposal&lt;/span&gt;&lt;span&gt;新提出的议案（简称&lt;/span&gt;&lt;span&gt;Pnew&lt;/span&gt;&lt;span&gt;）必须符合下面两个条件之一：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;1） &lt;strong&gt;&lt;span&gt;如果&lt;/span&gt;S&lt;span&gt;中所有&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;都没有接受过议案的话，那么&lt;/span&gt;&lt;span&gt;Pnew&lt;/span&gt;&lt;span&gt;的编号保证唯一性和递增即可，&lt;/span&gt;&lt;span&gt;Pnew&lt;/span&gt;&lt;span&gt;的值可以是任意值。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;2） &lt;strong&gt;&lt;span&gt;如果&lt;/span&gt;S&lt;span&gt;中有一个或多个&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;曾经接受过议案的话，要先找出其中编号最大的那个议案，假设它的编号为&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;，值为&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;。那么&lt;/span&gt;&lt;span&gt;Pnew&lt;/span&gt;&lt;span&gt;的编号必须大于&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Pnew&lt;/span&gt;&lt;span&gt;的值必须等于&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P2c&lt;span&gt;提出议案的规则有点复杂，它真的能满足&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;吗？至少看上去不是那么一目了然&lt;/span&gt;…..&lt;span&gt;老头子用了归纳法来证明&lt;/span&gt;&lt;span&gt;P2c&lt;/span&gt;&lt;span&gt;能满足&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;，但效果不佳，没什么人能看懂，所以下面的证明过程即使你看不懂也必要太沮丧（后面会给出图文解释）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;证明题&lt;strong&gt;（注意！前方高能）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;已知议案&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215218597-849983708.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;是集合中第一个被选定的议案，接受这个议案的&lt;/span&gt;&lt;span&gt;Acceptor集合为&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215314653-678705694.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;，在满足&lt;/span&gt;P2c的规则2的情况下，提出了一个新的议案&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215405948-1542619181.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;，&lt;/span&gt;n&amp;gt;m，证明&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215427095-2105033965.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步，证明初始成立：当议案的编号&lt;/span&gt;n = m+1时，证明&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215444160-1998773470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因为&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215503787-1036347976.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;15&quot;&gt;&lt;span&gt;是第一个被选定的议案，因此在&lt;/span&gt;m+1提出之前，m必然是集群当中编号最大的议案&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;根据&lt;/span&gt;P2c的规则2，议案&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215602345-1025060935.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;能够被提出，是因为存在一个多数派集合&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215635332-273670301.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;，这个集合中，编号最大的议案的值为&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215659808-1311455912.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;。因为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215916722-1593598307.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;和&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215937356-369889834.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;都是多数派集合，所以他们必定存在交集。交集中的&lt;/span&gt;&lt;span&gt;Acceptor必定都接受了&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215953146-18525522.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;m是整个集群最大的编号，当然也就是&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215635332-273670301.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;中最大的编号，根据&lt;/span&gt;&lt;span&gt;P2c的规则2，&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215659808-1311455912.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;必定等于&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220101136-910931244.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;第二步，当&lt;/span&gt;n &amp;gt; m+1时，假设编号从m+1到n-1的议案的值都是&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220101136-910931244.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;，证明&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215444160-1998773470.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;编号为&lt;/span&gt;m+1到n-1的议案提出后，我们没办法判断究竟那一个议案会被选定，但有一点是可以肯定的：所有接受了&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220101136-910931244.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;的&lt;/span&gt;Acceptor构成了一个新的集合&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220453563-225156920.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;，这个集合包含了集合&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215916722-1593598307.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;中的所有&lt;/span&gt;Acceptor，&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220453563-225156920.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;显然是一个多数派集合，这个集合接受的议案的编号在&lt;/span&gt;m到n-1之间，而且值为&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220101136-910931244.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;。没有包含在集合&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220453563-225156920.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;Acceptor所接受的议案一定小于m。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;根据&lt;/span&gt;P2c的规则2，议案&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215405948-1542619181.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;能够被提出，那么一定存在一个多数派集合&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215635332-273670301.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;，因为&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215916722-1593598307.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;和&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215937356-369889834.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;都是多数派集合，所以他们必定存在交集。交集中的议案的最大编号一定大于等于&lt;/span&gt;m，小于等于n-1。因此集合&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215635332-273670301.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;中编号最大的议案一定位于交集内。根据&lt;/span&gt;P2c的规则，&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223215659808-1311455912.png&quot; alt=&quot;&quot;/&gt;必定等于&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220101136-910931244.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这个证明过程，如果你能看懂，请受我三跪。。。&lt;/p&gt;
&lt;p&gt;接下来，上图，举例说明。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设有一个议案（&lt;/span&gt;3&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）提交后，这个议案成为了被&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;集群选定的第一个议案 ，那此时集群的状态可能会如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220908033-233541879.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一共5&lt;span&gt;个&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;，有&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;接受了议案（&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;），刚刚过半。此时有一个编号为&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;的议案要提出，根据&lt;/span&gt;&lt;span&gt;P2c&lt;/span&gt;&lt;span&gt;的规则&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，首先选一个过半的集合，就选上图中蓝色线圈出来的&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A4&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;A5&lt;/span&gt;&lt;span&gt;好了（任意选），这个集合中编号最大的议案是（&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;），因此新提出的议案必定为（&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）。符合&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;议案（&lt;/span&gt;4&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）提出后，集群的状态可能是下面这样：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220937975-523998612.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;此时再提出编号为&lt;/span&gt;5&lt;span&gt;或&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;的议案，这个议案的值必定也是&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;（不信的话请举出反例），符合&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;。依此类推。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;由此可证，&lt;/span&gt;P2c&lt;span&gt;是能够满足&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;的！！！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;想想看&lt;/span&gt;P2&lt;span&gt;，&lt;/span&gt;&lt;span&gt;P2a&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;中为什么一定要有“更大编号的”这几个扎眼的字眼，此时你应该能有一点感觉了，可能你会把它理解成“后提出的”，如果你是这样理解的话，请往下看。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有些童鞋肯定早就已经想到了：当议案（&lt;/span&gt;3&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）提交后，这个议案成为了被&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;集群选定的第一个议案，此时集群的状态有没有可能是下面这样？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223220957191-53717709.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意，这时议案（&lt;/span&gt;4&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Vb&lt;/span&gt;&lt;span&gt;）才是集群当中的编号最大的议案，要是这样就糟糕了！当我们提出编号为&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;的议案时，它的取值就有可能是&lt;/span&gt;&lt;span&gt;Vb&lt;/span&gt;&lt;span&gt;，导致无法满足&lt;/span&gt;&lt;span&gt;P2b&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为了保证不出现这种情况，就要用到前面提到的&lt;/span&gt;“预测未来”的能力。跟&lt;span&gt;P2c&lt;/span&gt;&lt;span&gt;的议案规则相配套的，需要预测的未来是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当一个议案在提出时（即使已经在发送的半路上了），它必须能够知道当前已经提出的议案的最大编号。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这样的话，议案（&lt;/span&gt;3&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）提交时，就会知道有一个（&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Vb&lt;/span&gt;&lt;span&gt;）的议案已经提交了，然后将自己的编号改成&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;或更大编号提交，一切就完美了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是你知道的，我们并不可能真的预测未来，换个思路，议案肯定是要提交给&lt;/span&gt;Acceptor&lt;span&gt;的，只要由&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;来保证议案编号的顺序就&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;了。于是有：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;议案（&lt;/span&gt;n&lt;span&gt;，&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;）在提出前，必须将自己的编号通知给半数以上的&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;收到通知的&lt;/span&gt;Acceptor&lt;span&gt;将&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;跟自己之前收到的通知进行比较，如果&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;更大，就将&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;确认为最大编号&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;strong&gt;当&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;半数以上&lt;/span&gt;Acceptor&lt;span&gt;确认&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;是最大编号时，议案（&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;）才能正式提交。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个编号不同的议案，不可能同时被确认为最大编号，证明略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是实际环境上，上面的条件还不足以保证议案被接受的顺序，比如议案（&lt;/span&gt;n&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）被确认为最大编号后，开始向&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;发送，此时（&lt;/span&gt;&lt;span&gt;n+1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Vb&lt;/span&gt;&lt;span&gt;）提出，由于网络速度的原因，（&lt;/span&gt;&lt;span&gt;n+1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Vb&lt;/span&gt;&lt;span&gt;）可能比（&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）更早被&lt;/span&gt;&lt;span&gt;Acceptor&lt;/span&gt;&lt;span&gt;接收到。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此&lt;strong&gt;Acceptor&lt;span&gt;收到一个新的编号&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;，在确认&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;比自己之前收到的编号大时，必须做出承诺（&lt;/span&gt;&lt;span&gt;Promise&lt;/span&gt;&lt;span&gt;）：不再接受比&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;小的议案&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个承诺会导致部分漏网之鱼（在发送途中被抢走最大编号的议案），无法形成多数派。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如下图所示：有一个在途的议案（&lt;/span&gt;1&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;），当&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;A3&lt;/span&gt;&lt;span&gt;对议案（&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Vb&lt;/span&gt;&lt;span&gt;）做出承诺的同时，（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）就失去了形成多数派的权利。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223221018748-1231846776.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;至此，我们就形成了一个完整的算法（具体实现请自行搜索&lt;/span&gt;PhxPaxos&lt;span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;算法原文中，将&lt;/span&gt;Promise&lt;span&gt;看做是&lt;/span&gt;&lt;span&gt;P2c&lt;/span&gt;&lt;span&gt;的具体实现，而我们将&lt;/span&gt;&lt;span&gt;Promise&lt;/span&gt;&lt;span&gt;看成是弥补&lt;/span&gt;&lt;span&gt;P2c&lt;/span&gt;&lt;span&gt;的补充条件。这两者没有质的差别，只是角度不同，我个人认为后一种更容易被理解，所以采用了后一种。不过采用后一种会遇到下面的麻烦：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按下面的顺序提交议案：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;① &lt;span&gt;议案（&lt;/span&gt;1&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）向&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;发送&lt;/span&gt;&lt;span&gt;Prepare&lt;/span&gt;&lt;span&gt;，获得&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;的承诺。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;② &lt;span&gt;议案（&lt;/span&gt;2，Vb）向A1发送Prepare，获得A1的承诺。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;③ &lt;span&gt;发送议案（&lt;/span&gt;1&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;此时&lt;/span&gt;A1&lt;span&gt;会拒绝议案（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304492/201812/304492-20181223221131182-574899803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;采用后一种解释的话，会发现&lt;/span&gt;A1&lt;span&gt;拒绝议案（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Va&lt;/span&gt;&lt;span&gt;）是违反了&lt;/span&gt;&lt;span&gt;P1&lt;/span&gt;&lt;span&gt;的，而采用前一种解释则不违反&lt;/span&gt;&lt;span&gt;P1&lt;/span&gt;&lt;span&gt;。（这不过是个文字游戏，我已经懒的去思考了，就这样吧）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果我们将半数以上的&lt;/span&gt;Acceptor&lt;span&gt;对同一个议案（&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;）做出承诺的状态称作是“锁定”状态。那么这个“锁定”状态具有以下性质：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;排它性&lt;/strong&gt;&lt;span&gt;：所有比&lt;/span&gt;n&lt;span&gt;小的议案都不允许提交，已经在途的议案，则不允许其形成多数派。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;唯一性&lt;/strong&gt;&lt;span&gt;：任意时刻，全局只有一个议案能获得&lt;/span&gt;“锁定”状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;原子性&lt;/strong&gt;&lt;span&gt;：议案&lt;/span&gt;n&lt;span&gt;从锁定状态变为非锁定状态的过程是原子的，议案&lt;/span&gt;&lt;span&gt;n+1&lt;/span&gt;&lt;span&gt;从非锁定状态变更为锁定状态的过程也是原子的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我相信（有点虚…），正是上面的这三条性质保证了一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，感谢老头子给出的如此精彩的算法。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 15:04:00 +0000</pubDate>
<dc:creator>Super Flanky</dc:creator>
<og:description>前言 Paxos算法是用来解决分布式系统中，如何就某个值达成一致的算法。它晦涩难懂的程度完全可以跟它的重要程度相匹敌。目前关于paxos算法的介绍已经非常多，但却很少有人能对P2c提出自己的见解，大多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SuperFlanky/p/10165945.html</dc:identifier>
</item>
<item>
<title>开发环境之git：团队协作git工作流与常用命令 - 炼心</title>
<link>http://www.cnblogs.com/hezhi/p/10166307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hezhi/p/10166307.html</guid>
<description>&lt;p&gt;此篇文章只是一篇傻瓜式的，记录工作中比较规范且常见的一个git工作流需要用到的命令，让你可以快速的开始工作。而不是一些长篇大论的理论知识，如果你有用过sourcetree或者其它图形化工具，结合你正在使用的工具，敲这些命令，看图形化工具中的变化，对比思考这些命令可能会更容易吸收。&lt;/p&gt;
&lt;h2 id=&quot;基本配置&quot;&gt;1.基本配置&lt;/h2&gt;
&lt;p&gt;刚入职公司开始做项目拉代码，需要经历的第一件事。配置个人的用户名称和电子邮件地址（通常是公司邮件地址）&lt;/p&gt;
&lt;h3 id=&quot;配置用户名和邮箱&quot;&gt;1.1 配置用户名和邮箱&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;git config --global user.name &quot;你的名字&quot;
git config --global user.email &quot;你的邮箱&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置public-key&quot;&gt;1.2 设置public key&lt;/h3&gt;
&lt;p&gt;首先需要在本地生成key&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keygen -t rsa -C &quot;你的邮箱&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一路回车，接下来复制public key&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat ~/.ssh/id_rsa.pub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也可以去系统里找到这个文件自己手动复制，&lt;br/&gt;windows用户，文件一般在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\Users\Administrator\.ssh\id_rsa.pub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mac用户，文件在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;用户名\.ssh\id_rsa.pub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在命令行里输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open ~/.ssh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有可能你的[用户名]目录下只有[公共, 图片, 文稿, 下载, 音乐，影片] 等这类文件夹，你就可以同时按下 shift command . 三个键，就可以看到里面会有一个 .ssh 文件夹了。&lt;br/&gt;还有可能你的文件夹目录甚至都没有[用户名]这一栏，可以按照 访达 --&amp;gt; 偏好设置 --&amp;gt; 边栏 中勾选你的用户名就好了。&lt;/p&gt;
&lt;p&gt;扯远了，回到主题。复制好 .ssh 下的 id_rsa.pub 文件后，打开你的gitlab 或者 其它你们公司用的git仓库管理系统，将它添加到你的账户上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;右上角点击头像 --&amp;gt; 点击settings --&amp;gt; 点击 SSH KEYS --&amp;gt; 点击 ADD SSH KEYS --&amp;gt; 将获取的 id_rsa.pub 文件内容粘贴于此&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开发阶段的实际场景与常用命令&quot;&gt;2.开发阶段的实际场景与常用命令&lt;/h2&gt;
&lt;h3 id=&quot;如果是启动一个新项目组长需要做什么&quot;&gt;2.1 如果是启动一个新项目，组长需要做什么？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 2.1.1：新建gitlab仓库，复制ssh仓库地址
// 2.1.2：克隆项目到本地文件夹
git clone &quot;复制的地址&quot;
// 2.1.3：此时默认是在maser分支上，进到拉取的本地项目目录中去，将本地仓库与远程仓库关联起来。
git remote add origin '复制的地址'
// 2.1.4：推送本地master分支到远程master分支
git push -u origin master
// 2.1.5：新建一个本地dev分支，并切换到本地dev分支
git checkout -b dev
// 2.1.6：在此之前远程是没有dev分支的，需要推送本地dev分支到远程dev分支
git push -u origin dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;master分支将来控制着发布到线上的稳定版本代码，普通成员不可以对master分支进行操作，不然每个组员改点东西，很有可能把线上代码搞崩。组员们只能在dev分支上进行操作。&lt;/p&gt;
&lt;h3 id=&quot;接下来组员们需要做什么&quot;&gt;2.2 接下来组员们需要做什么&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 组员小智：
// 2.2.1 将组长建好的仓库克隆到本地
git clone &quot;复制的地址&quot;
// 2.2.2 默认在master分支上，需要检出远程dev分支到本地dev
git checkout -b dev origin/dev
// 2.2.3 不直接在本地dev分支上写代码，不然就跟svn没什么两样了，基于本地dev分支建一个自己的本地分支，名为xiaozhi
git checkout -b xiaozhi dev
// 2.2.4 此时，就切换到了本地xiaozhi分支上，开始写功能，比如task0001，写完后
git status
// 查看你本地做了哪些修改
git add '修改的文件名（包含目录）'
// 或者
git add *
// 来把你的修改添加到暂存区去，接下来提交代码到本地xiaozhi分支
git commit -m &quot;task0001：基础布局功能&quot;
// 2.2.5 建议每完成一个任务的其中一个小功能就重复一次2.2.4步骤，每天下班前至少要合并推送一次到dev分支。确保你的代码不能影响别人的运行，也不会跟最新的代码相差太远。首先，切换到本地dev分支
git checkout dev
// 2.2.6 拉取最新dev分支代码，可能在你写task0001的时候，别人提交过代码了
git pull
// 2.2.7 合并本地xiaozhi分支代码到本地dev分支
git merge xiaozhi
// 2.2.8 推送你改动的代码到远程dev分支
git push
// 2.2.9 切换到本地xiaozhi分支
git checkout xiaozhi
// 2.2.10 合并本地dev分支到本地xiaozhi分支
git merge dev
// 至此，你将你的改动推送到了远程，你的本地也是最新代码了，继续去做task0003。重复2.2.4-2.2.10步骤

...
...
...
// 当你在2.2.1步骤的时候，可能你的同事小狒也要开始做task0002，他在他的电脑上又是怎么操作的呢？
git clone '复制的地址'
git checkout -b dev origin/dev
git checkout -b xiaofei dev
git status
git commit -a -m &quot;task0002: 基础布局功能&quot;
git checkout dev
git pull
git merge xiaofei
git push
git checkout xiaofei
git merge dev

// 每个组员除了基于dev分支新建的本地分支命名不一样之外，其他基本一样。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;此过程可能会遇到的问题&quot;&gt;2.3 此过程可能会遇到的问题&lt;/h3&gt;
&lt;p&gt;在执行 git pull 或者 git merge 操作的时候&lt;/p&gt;
&lt;h4 id=&quot;如果出现这样的代码&quot;&gt;2.3.1 如果出现这样的代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# Please enter a commit message to explain why this merge is necessary,
# especially if it merges an updated upstream into a topic branch。
# lines starting with &quot;#&quot; will be ignored, and an empty message aborts the commit

// 可以按 ESC 退出键，输入 :wq  然后敲回车就可以恢复正常，然后继续git push 即可&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;发现有冲突怎么办&quot;&gt;2.3.2 发现有冲突怎么办？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 如果提示有冲突，在你的编辑器里看到代码是这样的

&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; HEAD
// 从HEAD到下面的====之间的代码是你拉取的别的组员的代码
function a () {
    console.log('a')
}
======
// 从======到下面的&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;之间的代码是你修改的代码
function a () {
  console.log('aa')
}
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; xiaofei
// 需要小狒和小智商量，保留小智的还是保留小狒的，还是两个人的都要保留一部分。手动改好代码后，执行
git add '冲突的文件名'
git commit -m '解决冲突'
git push&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如何放弃本地修改&quot;&gt;2.3.2 如何放弃本地修改？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 当小智在他的本地xiaozhi分支上加功能时，可能他开始没考虑全面，想把本地修改的内容都删掉重新来过。

// 当小智还没有 git add 缓存代码时
git checkout -- '想放弃修改的文件名（带路径）'
// 或者放弃所有文件的修改
git checkout .


// 当小智已经把想撤销修改的文件执行了 git add 的时候
git reset HEAD '想放弃修改的文件名（带路径）'
git checkout -- '想放弃修改的文件名（带路径）'


// 当小智已经把想撤销修改的文件不仅git add还git commit的时候
git reset --hard HEAD^
// 可以用这条命令来恢复至上一次commit的状态，如果发现已经提交了好几次怎么办，噗，没忍住笑出了声。如果直接回退肯定是可以的，但是这中间的几次commit可能又有你想要的代码，这个说实话，有点惨。说个比较实际的方案吧。把现在的代码文件夹先复制一份。再执行
git log
// 看看你想回退到哪次commit的状态，找到那次commit的版本号（记住关键的前几位就可以了），然后
git reset --hard e235a
// 然后再从复制的那份文件夹中去对比，看看哪些是你想要的，想要的就加进来。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试阶段的实际场景与常用命令&quot;&gt;3. 测试阶段的实际场景与常用命令&lt;/h2&gt;
&lt;p&gt;终于到了开发完成，要测试的时候了。此时，所有人各自对应的本地分支代码(xiaozhi分支，xiaofei分支)都应该和dev保存一致了。&lt;br/&gt;其实就可以把release分支当作dev分支，只不过开始是大家都推送到dev分支上做开发，而现在是都推送到release分支上改bug。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 组长：
git checkout -b release dev
git push -u origin release

// 组员小智：
git checkout -b release origin/release
git checkout xiaozhi
git status
git add *
git commit -m &quot;bug0001：修复首页xxxx的问题&quot;
git checkout release
git pull
git merge xiaozhi
git push
git checkout xiaozhi
git merge release
// 继续解决下一个bug

// 组员小狒
git checkout -b release origin/release
git checkout xiaofei
git status
git add *
git commit -m &quot;bug0002：修复列表页的XXXX的问题&quot;
git checkout release
git pull
git merge xiaofei
git push
git checkout xiaofei
git merge release
// 继续解决下一个bug


// 当所有测试提出的bug都解决完后，大家应该保证dev分支，release分支，各自的本地分支(xiaozhi,xiaofei)都一样
// 组长：
// 合并release分支到dev分支上
git checkout dev
git merge release
git push
// 合并release分支到master分支上并打上标签版本号
git checkout master
git merge release
git push
git tag -a v1.0.0 -m '1.0.0版本'
git push origin --tags

// 组员们继续写功能开始进行下一版本的产品迭代，重复2.2.4-2.2.10步骤&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;上线后客户反馈有bug怎么办&quot;&gt;4. 上线后客户反馈有bug怎么办？&lt;/h2&gt;
&lt;p&gt;有可能当组员们已经在各自的本地分支(xiaozhi, xiaofei)上去做下一版本的开发的时候，客户反馈一些测试小姐姐们当时没有测出来的bug。此时大家肯定不会直接去把dev分支再去合并到master分支了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 组长：
// 4.1.1 基于master分支新建一个hotfix001分支
git checkout -b hotfix001 master
// 4.1.2 与远程hotfix001分支关联起来
git push -u origin hotfix001

// 组长将这个重大而又紧急的任务指派给小智
// 组员小智：
// 4.1.3 检出远程分支hotfix001到本地分支hotfix001
git checkout -b hotfix001 origin/hotfix001
// 4.1.2 小智一顿牛逼操作之后
git commit -a -m &quot;hotfix001: 解决线上xxxx的问题&quot;
git push
// 4.1.3 测试通过后组长去拉取hotfix001的代码并合并回master分支
git checkout hotfix001
git pull
git checkout master
git merge hotfix001
git push
git tag -a v1.0.1 -m '1.0.1版本：修复XXXX等一系列的问题'
git push origin --tags
// 4.1.4 接下来判断这个线上的bug下一版本是否还要处理，可能让人头大的产品脑壳有包，刚上线没几天就要全部推翻重新搞，那就不需要做什么操作了。如果这个功能还要的话，那组长还需要把这个hotfix001分支合并到dev分支中去
git checkout dev
git pull
git merge hotfix001
git push
// 4.1.5 线上bug分支hotfix001完成了它光荣的使命，可以删除了
git branch -d hotfix001
git push origin --delete hotfix001&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;后话&quot;&gt;5.后话：&lt;/h2&gt;
&lt;p&gt;我也在用git图形化工具，比如sourcetree。相信很多人也在用，其实用命令行还是不如sourcetree那么方便而强大的。比如在撤销修改的时候，sourceTree可以只撤销这个文件你所改动的某一部分，而git命令行只能对某一个文件的所有改动撤销修改（当然，可能是我对git命令行操作还不那么深入的缘故，但是我相信就算git命令行能做到，也远没有图形化工具那么方便）。&lt;/p&gt;
&lt;p&gt;不过我觉得我写这篇文章其实还是有意义的，工作了这么久，几乎天天都会用到git，一些常见git命令都不懂也说不过去，对自己要求并不那么高，并不是要强到什么都可以立刻想到用什么git命令去解决，而此篇文章中工作流常用到的命令还是要熟记于心的。&lt;/p&gt;
&lt;p&gt;大家可以用自己的github账号并且找一个小伙伴去建一个仓库模拟体验一下上述多人协作的过程，如果有问题可以一起交流下。&lt;/p&gt;
&lt;p&gt;另外，你可能会感兴趣的一些点：&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 14:50:00 +0000</pubDate>
<dc:creator>炼心</dc:creator>
<og:description>此篇文章只是一篇傻瓜式的，记录工作中比较规范且常见的一个git工作流需要用到的命令，让你可以快速的开始工作。而不是一些长篇大论的理论知识，如果你有用过sourcetree或者其它图形化工具，结合你正在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hezhi/p/10166307.html</dc:identifier>
</item>
<item>
<title>深入剖析GPU Early Z优化 - 风恋残雪</title>
<link>http://www.cnblogs.com/ghl_carmack/p/10166291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ghl_carmack/p/10166291.html</guid>
<description>&lt;p&gt;最近在公司群里同事发了一个UE4关于Mask材质的优化，比如在场景中有大面积的草和树的时候，可以在很大程度上提高效率。这其中的原理就是利用了GPU的特性Early Z，但是它的做法跟我最开始的理解有些出入，因为Early Z是GPU硬件实现的，每个厂商在实现的时候也有所不同。这次在查阅了一些资源和通过实验测试，让我们来揭开Early Z的神秘面纱。首先我们先讲解一下什么是Early Z，然后再讲解一下UE4是如何利用Early Z的特性解决草和 树的Overdraw问题的，然后我们讲解一下Early Z演化，最后我们通过实验数据来验证Early Z是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是Early Z&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们知道传统的渲染管线中，深度测试是发生在Pixel/Fragment Shader之后的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/155497/201812/155497-20181223224744938-2033881808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，如果我们仔细想下，在光栅化的时候我们已经知道了每个片断(fragment)的深度，如果这个时候我们可以提前做测试就可以避免后面复杂的Pixel/Fragment Shader计算过程，硬件厂商当然也想到了这一点，他们也在自己的硬件中各自实现了Early Z功能。在网上找到了一些他们的资料，我们简单看一下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;nVidia&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nVidia的GPU Programming Guide里面有关于Early Z的优化方案，里面提到了一些关于Early Z的一些使用细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Early-z(GPU Programming Guide Version 2.5.0 (GeForce 7 and earlier GPUs)) optimization (sometimes called &quot;z-cull&quot;) improves performance by avoiding the rendering of occluded surfaces. If the occluded surfaces have expensive shaders applied to them, z-cull can save a large amount of&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;computation time. To take advantage of z-cull, follow these guidelines:&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Don't create triangles with holes in them (that is, avoid alpha test or texkill)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Don't modify depth (that is, allow the GPU to use the interpolated depth value)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Violating these rules can invalidate the data the GPU uses for early&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;optimization, and can disable z-cull until the depth buffer is cleared again.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到不要使用alpha test 或者texkll(clip discard)，不要修改深度，只允许使用光栅化插值后的深度，违背这些规则会使GPU Early Z优化失效，直到下一次清除深度缓冲区，然后才能使用Early Z。限于当时的条件，是有这样的限制，那么到了现在GPU还有这些限制吗？我们接下来的实验会说明这一点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;ZCULL and EarlyZ: Coarse and Fine-grained Z and Stencil Culling&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NVIDIA GeForce 6 series and later GPUs can perform a coarse level Z and Stencil culling. Thanks to this optimization large blocks of pixels will not be scheduled for pixel shading if they are determined to be definitely occluded. In addition, GeForce 8 series and later GPUs can also perform fine-grained Z and Stencil culling, which allow the GPU to skip the shading of occluded pixels. These hardware optimizations are automatically enabled when possible, so they are mostly transparent to developers. However, it is good to know when they cannot be enabled or when they can underperform to ensure that you are taking advantage of them.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Coarse Z/Stencil culling (also known as ZCULL) will not be able to cull any pixels in the following cases:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. If you don't use Clears (instead of fullscreen quads that write depth) to clear the depth-stencil buffer.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. If the pixel shader writes depth.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. If you change the direction of the depth test while writing depth. ZCULL will not cull any pixels until the next depth buffer Clear.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. If stencil writes are enabled while doing stencil testing (no stencil culling)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. On GeForce 8 series, if the DepthStencilView has Texture2D[MS]Array dimension&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Also note that ZCULL will perform less efficiently in the following circumstances&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. If the depth buffer was written using a different depth test direction than that used for testing 2. If the depth of the scene contains a lot of high frequency information (i.e.: the depth varies a lot within a few pixels)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. If you allocate too many large depth buffers.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. If using DXGI_FORMAT_D32_FLOAT format Similarly,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fine-grained Z/Stencil culling (also known as EarlyZ) is disabled in the following cases:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. If the pixel shader outputs depth&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. If the pixel shader uses the .z component of an input attribute with the SV_Position semantic (only on GeForce 8 series in D3D10)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. If Depth or Stencil writes are enabled, or Occlusion Queries are enabled, and one of the following is true:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• Alpha-test is enabled&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• Pixel Shader kills pixels (clip(), texkil, discard)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• Alpha To Coverage is enabled&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• SampleMask is not 0xFFFFFFFF (SampleMask is set in D3D10 using OMSetBlendState and in D3D9 setting the D3DRS_MULTISAMPLEMASK renderstate)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是GPU Programming Guide GeForce 8 and 9 Series，可以看到它里面又加入了ZCull（即Hierachical Z）这里也有一些需要注意的地方，但是它没有详细说明如果开启了Alpha Test之后会不地导致后面的所有Early Z失效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;AMD&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Emil Persson的Depth in Depth对Early Z有一个比较深入的讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hierarchical Z, or HiZ for short, allows tiles of pixels to be rejected in a hierarchical fashion. This allows for faster rejection of occluded pixels and offers some bandwidth saving by doing a rough depth test using lower resolution buffers first instead of reading individual depth samples. Tiles that can safely be discarded are eliminated and thus the fragment 1 shader will not be executed for those pixels. Tiles that cannot safely be discarded are passed on to the Early Z stage, which will be discussed later on.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;The Early Z component operates on a pixel level and allows fragments to be rejected before executingthe fragment shader. This means that if a certain fragment is found to be occluded by the current contents of the depth buffer, the fragment shader doesn't have to run for that pixel. Early Z can also reject fragments before shading based on the stencil test. On hardware prior to the Radeon HD 2000series, early Z was a monolithic top-of-the-pipe operation, which means that the entire read-modify- write cycle is executed before the fragment shader. As a result this impacts other functionality that kills fragments such as alpha test and texkill (called &quot;clip&quot; in HLSL and &quot;discard&quot; in GLSL). If Early Z would be left on and the alpha test kills a fragment, the depth- and/or stencil-buffer would have been incorrectly updated for the killed fragments. Therefore, Early Z is disabled for these cases. However, if depth and stencil writes are disabled there are no updates to the depth-stencil buffer anyway, so in this case Early Z will be enabled. On the Radeon HD 2000 series, Early Z works in all cases.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后作者还给了一个参考表，列出了在什么情况下Early Z会失效，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/155497/201812/155497-20181223224745408-1386800389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上面两个比较陈旧的文档，我们可能会对什么时候会导致Early Z的失效比较模糊，而且随着硬件的演进，这些限制条件也会变化，后面我们通过一些实验来做些验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UE4对Mask材质的Early Z优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面简单讲了下什么是Early Z，接下来我们来解决下UE4是如何解决Mask材质带来的Overdraw问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它需要开启一个开关，叫做Mask Material Only in Early-Z pass&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/155497/201812/155497-20181223224745845-390137976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面这个只是一个操作，那么代码是怎么实现的呢？我们这里就不贴代码了，这里只是说一下它做这个的步骤，具体代码可以去参考UE4 Pre Pass的相关代码。&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;首先UE4会把场景中所有的Opaque和Mask的材质做一遍Pre-Pass，只写深度不写颜色，这样可以做到快速写入，先渲染Opaque再渲染Mask的物体，渲染Mask的时候开启Clip。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;做完Pre-pass之后，这个时候把深度测试改为Equal，关闭写深度渲染Opaque物体。然后再渲染Mask物体，同样是关闭深度写，深度测试改为Equal，但是这个时候是不开启clip的，因为pre-pass已经把深度写入，这个时候只需要把Equal的像素写入就可以了。这也是上面Mask Material only in early Z-pass的来历。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这就是UE4提高Mask材质渲染效率的办法，但是这个有个前提就是你场景中的Mask材质比较费才有比较大的提升。等等，它的实现方法跟我们看到的一些文章是矛盾的，而有些文档又没说清楚，既然UE4已经实现了这个功能，并且已经实现了性能提升，那说明先前的文章只针对当时的GPU有效，后面随着硬件的演进更智能了，可以处理的情况更多了。为了验证，我们做一些实验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;揭开Earlyl Z的神秘面纱&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证上面的一系了假设，我这里做了一个简单的实验。这个Demo的基于rastertek的Drect3D 11的教程Texturing，这个Demo就是在屏幕上渲染一个带纹理的三角形。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/155497/201812/155497-20181223224746242-434125676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我修改了它的代码，让它在同一个位置画四个三角形，第一个三角形采用Mask渲染，第二个三角形在PS中修改深度，第三个三角形使用Mask渲染，第四个三角形使用Mask渲染，但是跟UE4一样，把深度写关闭，把深度测试改为Equal，关闭clip。测试显卡为nVidia GTX 570。这样我用GPA(intel graphics performance analyzer)分析PS调用次数以及实现Pixel的个数如下表所示:&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;渲染批次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Depth&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Clip&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;PS Invocations&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Pixels Rendered&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;1 Mask&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Less Write&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;10.4k&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;6548&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;2 Modify depth&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Less Write&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;No&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;10.4k&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;3820&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;3 Mask&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Less Write&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;10.4k&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;4 Mask&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Equal do not Write(写不与深度不影响结果因为是equal，但是为了节省带宽关闭)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;No&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;6548&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;6548&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上图可以看出不论是Modify depth或者Clip都只影响当前Draw call的early z优化,并不会影响后面的early z优化。可以看出，随着硬件的演化，early z(包括Hierachical Z)变得更智能了，可以处理的情况更多了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过对Early Z的简单分析以及实验，我们得出了一个有用的结论:&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Early Z由硬件实现，随着硬件的演进，它的功能也在不断进化，处理的情况也变多。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Alpha Test或者Depth modify都会使用early z失效，但是后面渲染的批次还可以继续使用early z（Hierachical Z）优化。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;渲染API可以通过设置earlydepthstencil(d3d)或者layout(early_fragment_tests) in;（opengl）来强制使用early z。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;随着硬件的演进，原来硬件的很多限制也会被解除，这样就需要我们不断学习新的知识来正确的优化我们的引擎或者游戏。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Sun, 23 Dec 2018 14:48:00 +0000</pubDate>
<dc:creator>风恋残雪</dc:creator>
<og:description>最近在公司群里同事发了一个UE4关于Mask材质的优化，比如在场景中有大面积的草和树的时候，可以在很大程度上提高效率。这其中的原理就是利用了GPU的特性Early Z，但是它的做法跟我最开始的理解有些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ghl_carmack/p/10166291.html</dc:identifier>
</item>
<item>
<title>基于Python Selenium Unittest  PO设计模式详解 - 深圳-逸遥</title>
<link>http://www.cnblogs.com/snailrunning/p/10163159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snailrunning/p/10163159.html</guid>
<description>&lt;h2 id=&quot;本文章会讲述以下几个内容&quot;&gt;本文章会讲述以下几个内容：&lt;/h2&gt;
&lt;p&gt;1、什么是PO设计模式（Page Object Model）&lt;br/&gt;2、为什么要使用PO设计模式&lt;br/&gt;3、使用PO设计模式要点&lt;br/&gt;4、PO设计模式实例&lt;/p&gt;

&lt;h3 id=&quot;什么是po设计模式-page-object-model&quot;&gt;1、什么是PO设计模式 (Page Object Model)&lt;/h3&gt;
&lt;p&gt;一种在测试自动化中变得流行的设计模式，使得自动化测试脚本的减少代码重复、更易读、减少维护成本。&lt;br/&gt;一般PO设计模式有三层&lt;br/&gt;第一层：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对Selenium 进行二次封装，定义一个所有页面都继承的 BasePage ，&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;封装 Selenium 基本方法 例如：元素定位，元素等待，导航页面 ，&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;不需要全部封装，用到多少方法就封装多少方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二层：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;页面元素进行分离，每个元素只定位一次，隔离定位，如果页面改变，只需要改变相应的元素定位；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;业务逻辑分离 或 操作元素动作分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三层：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用单元测试框架对业务逻辑进行测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;为什么要使用po设计模式&quot;&gt;2、为什么要使用PO设计模式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;页面频繁变化，（页面html结构等变化）导致页面UI元素频繁变动，元素定位改变&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;传统线性自动化（面向过程开发），用例中需要反复的定位同一个元素&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;每当页面发生变化的时候，需要在用例中寻找变动的部分，工作量大，容易产生遗漏，不容易维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用po设计模式要点&quot;&gt;3、使用PO设计模式要点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不要在page页面对象外做元素定位&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;不在page页面对象里面写断言，除非是页面是否成功加载断言&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;需要多少个元素就定位多少个，不需要对整个页面的元素进行定位&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;当你的用例设计页面跳转时，例如登陆操作，登陆完成后跳转首页，当页面发生“跳转”&lt;br/&gt;，封装的业务逻辑需要返回（return）对应的页面对象的实例&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;BasePage封装Selenium 基础方法，不需要全部封装，用到多少方法就封装多少方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;po设计模式实例&quot;&gt;4、 PO设计模式实例&lt;/h3&gt;
&lt;p&gt;以TAPD作为项目例子，用PO设计模式实现登陆：&lt;br/&gt;Github地址：&lt;a href=&quot;https://github.com/SEtester/easy_POM&quot; class=&quot;uri&quot;&gt;https://github.com/SEtester/easy_POM&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;用例&quot;&gt;用例：&lt;/h5&gt;
&lt;p&gt;标题：登陆成功&lt;br/&gt;前置条件：打开TAPD登录页 &lt;a href=&quot;https://www.tapd.cn/cloud_logins/login&quot; class=&quot;uri&quot;&gt;https://www.tapd.cn/cloud_logins/login&lt;/a&gt;&lt;br/&gt;操作步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入用户名（手机或邮箱）：XXXXXX&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;输入密码：XXXXXX&lt;/li&gt;
&lt;li&gt;点击登陆按钮&lt;br/&gt;预期结果：&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;页面跳转至“工作台-我的待办”&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;项目目录&quot;&gt;项目目录:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/mw690/6e01037bgy1fydm3lyxe1j20cn04rdfv.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;base_page.py&quot;&gt;base_page.py&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw690/6e01037bgy1fyg1sbtusyj20go0jbjt8.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;login_page.py&quot;&gt;login_page.py&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw690/6e01037bgy1fygvf6thfzj20go0iw0uv.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/mw690/6e01037bgy1fygvh1eq33j20hn06wdgk.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;worktable_to_do_page.py&quot;&gt;worktable_to_do_page.py&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/mw690/6e01037bgy1fyg1vgy0jnj20hr0aomy2.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;test_login.py&quot;&gt;test_login.py&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw690/6e01037bgy1fyg1vze4exj20l90lemzl.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;page-object-model-官方文档&quot;&gt;Page object model 官方文档&lt;/h4&gt;
&lt;p&gt;Github 官方文档地址 : &lt;a href=&quot;https://github.com/SeleniumHQ/selenium/wiki/PageObjects&quot; class=&quot;uri&quot;&gt;https://github.com/SeleniumHQ/selenium/wiki/PageObjects&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;文末感谢乙醇老师指导&quot;&gt;文末，感谢乙醇老师指导&lt;/h3&gt;



</description>
<pubDate>Sun, 23 Dec 2018 14:21:00 +0000</pubDate>
<dc:creator>深圳-逸遥</dc:creator>
<og:description>本文章会讲述以下几个内容： 1、什么是PO设计模式（Page Object Model） 2、为什么要使用PO设计模式 3、使用PO设计模式要点 4、PO设计模式实例 1、什么是PO设计模式 (Pag</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snailrunning/p/10163159.html</dc:identifier>
</item>
<item>
<title>mapbox.gl源码解析——基本架构与数据渲染流程 - 木的树</title>
<link>http://www.cnblogs.com/dojo-lzz/p/10165817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dojo-lzz/p/10165817.html</guid>
<description>&lt;h2&gt;加载地图&lt;/h2&gt;
&lt;p&gt;　Mapbox GL JS是一个JavaScript库,使用WebGL渲染交互式矢量瓦片地图和栅格瓦片地图。WebGL渲染意味着高性能,MapboxGL能够渲染大量的地图要素,拥有流畅的交互以及动画效果、可以显示立体地图并且支持移动端,是一款十分优秀的WEB GIS开发框架。&lt;/p&gt;
&lt;p&gt;在页面引入MapboxGL脚本库和样式库:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script src='https://api.mapbox.com/mapbox-gl-js/v0.40.0/mapbox-gl.js'&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;link href='https://api.mapbox.com/mapbox-gl-js/v0.40.0/mapbox-gl.css' rel='stylesheet'/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    也可以在GitHub找到MapboxGL : https://github.com/mapbox/mapbox-gl-js/releases&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;5176.100033.1.i1.40ef41c2tzKhl8&quot;&gt;    执行上述引入脚本后即创建了mapboxgl对象,通过它可以使用MapboxGL的全部功能。 &lt;br/&gt;在使用之前,需要先设置mapboxgl.accessToken。access tokens(访问令牌)可以使用API提供的示例(如下),也可以注册MapBox账号,在用户信息页查看或者创建令牌。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;5176.100033.1.i1.40ef41c2tzKhl8&quot;&gt;　接下来使用创建地图实例。主要配置项如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const myMap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; mapboxgl.Map({
  container: &lt;/span&gt;'&amp;lt;Id of Container Element&amp;gt;'&lt;span&gt;,
  style: &lt;/span&gt;'&amp;lt;Your Style Here&amp;gt;'&lt;span&gt;,
  center: [&lt;/span&gt;112.508203125, 37.97980872872457&lt;span&gt;],
  zoom: &lt;/span&gt;4&lt;span&gt;,
  pitch: &lt;/span&gt;0&lt;span&gt;,
  bearing: &lt;/span&gt;0&lt;span&gt;,
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-spm-anchor-id=&quot;5176.100033.1.i1.40ef41c2tzKhl8&quot;&gt; &lt;/p&gt;
&lt;h2&gt;基本架构&lt;/h2&gt;
&lt;p&gt;　mapbox的架构有些奇怪，接口层和逻辑层其实没有明确的区分；mapbox中style是一个比较重要的类；统辖整个数据层次；Painter中集成了draw和style两个模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223214446576-533998905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;数据处理流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223214531142-1116093299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;数据加载与渲染流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223214550064-1916598256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;数据的加载与解析在source中；主要有两部分组成，逻辑部分在主线程中比如：&lt;br/&gt;vector_tile_source、geojson_source中&lt;br/&gt;而实际的加载解析则是在对应的worker中，比如：&lt;br/&gt;vector_tile_worker_source、geojson_worker_source中&lt;/p&gt;
&lt;p&gt;以vector_tile_source和vector_tile_worker_source为例介绍，实际的数据解析在vector_tile_worker_source中的loadTile方法，这里接收主线程中传递的参数，以及子线程的回调函数，应该是Actor中的done函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215350391-2081390402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进而进入&lt;br/&gt;loadVectorData函数，getArrayBuffer是调用普通的ajax去请求二进制数据，与室内的数据方式一样。数据请求成功后，将二进制数据实例化成一个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215456004-132993353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215502362-470180659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PBF是一个协议二进制格式，他里面提供了一些方法，方便按照一定的规则来解析二进制数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215548963-1918637986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215555813-710920049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里是VectorTile中的一个VectorTileLayer读取到的二进制字段；这里的解析是把二进制转化成js对象，里面的数据还需要进一步转换成可用的几何数据和属性数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215631758-205202684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为mabox的二进制编码使用的是谷歌的二进制编码方式，所以可以直接使用PBF这个npm包来进行解码&lt;/p&gt;
&lt;p&gt;LoadVectorData加载完后数据进入回调函数中；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215738021-492685721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来进入WorkerTile中的parse方法，开始各种解析数据；这里面要看一下LayerIndex这个对象是StyleLayerIndex的一个实例，里面存放一些跟样式相关的属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215815135-1730477489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后从sourceLayer中获取VectorTileFeature，实际也是从pbf中解析数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215852372-1803234006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来是创建bueket并调用bucket的populate方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215928402-1186978743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223215933872-682631837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;polulate可以理解为首先根据比例进行数据缩放，然后调用addFeature方法，将Feature的几何图形信息添加到bucket的vertexArray中，然后FeatureIndex记录一些信息。&lt;br/&gt;不同的Bucket的polulate方法也不同，addFeature方法更不同。像SymbolBucket添加到vertexArray中的就不是单一的点信息，而是文本盒子的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/412020/201812/412020-20181223220002249-1968785664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 23 Dec 2018 14:02:00 +0000</pubDate>
<dc:creator>木的树</dc:creator>
<og:description>加载地图 Mapbox GL JS是一个JavaScript库,使用WebGL渲染交互式矢量瓦片地图和栅格瓦片地图。WebGL渲染意味着高性能,MapboxGL能够渲染大量的地图要素,拥有流畅的交互以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dojo-lzz/p/10165817.html</dc:identifier>
</item>
<item>
<title>EnjoyingSoft之Mule ESB基础系列第三篇：Mule message structure - Mule message结构 - EnjoyingSoft</title>
<link>http://www.cnblogs.com/enjoyingsoft/p/10165617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoyingsoft/p/10165617.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;Mule ESB是一个使用Java语言编写的开源企业服务总线，企业服务总线英文Enterprise Service Bus，简称ESB。其相关源代码也托管在GitHub上，可以在https://github.com/mulesoft/mule这里找到相关的Source Code。&lt;/p&gt;
&lt;p&gt;MuleESB在众多开源的ESB中处于领先者的地位，已拥有超过数百万的下载量，以及来自世界各地数十万个开发人员。MuleSoft公司也作为开源软件中的独角兽，2017年在纽交所成功上市。我们作为MuleSoft的重要合作伙伴也参与其中，在六年多的时间里，使用Mule ESB社区版实施，或者Mule ESB企业版实施，构建众多Mule ESB开发案例，帮助国内众多的企业成功上线企业集成项目。&lt;/p&gt;
&lt;p&gt;我们使用Mule ESB开发的过程中，体会到它优秀的架构设计和高效的开发速度。同时也深感Mule ESB书籍，Mule ESB中文文档资料非常稀少，所以使用8篇文章来写Mule ESB的基础系列教程，讲解Mule ESB功能和开发。&lt;/p&gt;
&lt;h2 id=&quot;探索mule-message结构&quot;&gt;1. 探索Mule Message结构&lt;/h2&gt;
&lt;p&gt;很多开发者在开始使用Mule开发，很大原因是因为Mule的图形化开发环境非常友好，同时Mule Esb Transport也非常多，但对Mule最重要的Mule message概念并不特别熟悉。本篇重点讲解Mule的Message。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/enjoyingsoft/p/10153082.html&quot;&gt;上一篇教程&lt;/a&gt;中已经说到，Flow的结构和构成元素，在Flow中流动的就是Mule Message。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181223211318348-114247101.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Mule Message是一个数据结构，也有相对应的Java Class。它包括几部分Payload，Property，Attachment。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181223211438996-1556588367.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何理解这幅图，大致可以和HTTP协议类比。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Property&lt;/p&gt;
&lt;p&gt;Mule Message的Property又分成Inbound Properties和Outbound Properties。这一点类似于HTTP协议的请求头和响应头。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Payload&lt;/p&gt;
&lt;p&gt;Mule的Payload是一个对象，类型是不固定的。可能是Stream，也可能是Hashmap，也可能是XML字符串。这一点类似于HTTP协议的请求正文，或者说是请求体。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Attachment&lt;/p&gt;
&lt;p&gt;Mule的Attachment就是消息的附件，这一点类似于HTTP协议中的multipartform-data请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181223211331411-279720118.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mule-message的payload&quot;&gt;2. Mule Message的Payload&lt;/h2&gt;
&lt;p&gt;Payload翻译成中文是负荷，负载的意思。它是Mule Message的主要部分，也是Mule处理的主要对象。我们后续说的数据转换就是对Payload的转换。注意Mule Message的Payload是有可能为空的，比如接收到一个Http Get请求，Http Get请求的请求体是空的，所以这个时候Mule Message的Payload是空的。&lt;/p&gt;
&lt;h2 id=&quot;mule-message的property&quot;&gt;3. Mule Message的Property&lt;/h2&gt;
&lt;p&gt;Mule Message的Property是一个键值对，有name和对应的value。Mule Message有两种类型的Property，Inbound Properties和Outbound Properties。Inbound Properties或者Outbound Properties可以有多个Property，也就是多个键值对。&lt;/p&gt;
&lt;p&gt;Inbound Properties是不可变的，是由Message Source产生的。就类似于Http的请求参数，是由用户的数据请求，经过Java的Servlet，或者Asp.Net等框架封装成Http Request对象。&lt;/p&gt;
&lt;p&gt;Outbound Properties是可变的，我们在Mule的Flow中新增或者改变这些属性。注意，比如转换器，有些Mule Processor会自动增加有些属性。&lt;/p&gt;
&lt;h2 id=&quot;mule-message的attachment&quot;&gt;4. Mule Message的Attachment&lt;/h2&gt;
&lt;p&gt;Attachment，正如字面上意思，可以理解成消息的附件。想象一封邮件，有邮件发送人等头信息，也有邮件正文，同样还有邮件附件。和Property一样，Attachment也有两种类型，Inbound Attachment和Outbound Attachment。我们通常将一些大的对象作为附件传输。&lt;/p&gt;
&lt;h2 id=&quot;mule的variable&quot;&gt;5. Mule的Variable&lt;/h2&gt;
&lt;p&gt;Variable也就是变量，有几种类型的变量，或者说几种不同范围的变量，如下：Flow Variable，Session Variable，Record Variable。Flow Variable在一个Flow是有效的，Session Variable是可以跨Flow的，Record Variable则是处理数据列表时会用到。&lt;/p&gt;
&lt;p&gt;这里不详细讲述。从使用上说，有些类似于Java里面的局部变量，Session变量，但不完全一致。后续实战文章会分析这一点。&lt;/p&gt;
&lt;h2 id=&quot;使用java操作mule-message&quot;&gt;6. 使用Java操作Mule Message&lt;/h2&gt;
&lt;p&gt;对程序员来说，千言万语不如代码，如何使用Java操作Mule Message呢？通过Java代码我们可以清楚的看到Mule Message的结构，成员变量和方法等。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void explorMessage(MuleMessage message) {
    // 获取InboundProperty
    String requestPath = message.getInboundProperty(&quot;http.request.path&quot;);
    // 设定OutboundProperty
    message.setOutboundProperty(&quot;content-type&quot;, &quot;application/json&quot;);
    // 获取Payload
    Object payload = message.getPayload();
    // 获取InboundAttachment
    DataHandler fileAttachment = message.getInboundAttachment(&quot;fileName&quot;);
    // 获取flow变量
    message.getProperty(&quot;flowVarTest&quot;, PropertyScope.INVOCATION);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图是Mule Message的类图，类图中只列表了重要的方法和属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181223211347578-947144180.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文同步发文于&lt;a href=&quot;http://www.enjoyingsoft.com/blogs/2018/12/23/mule-base-03/&quot;&gt;EnjoyingSoft之Mule ESB基础系列第三篇：Mule message structure - Mule message结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;a href=&quot;http://www.enjoyingsoft.com&quot;&gt;EnjoyingSoft&lt;/a&gt; 网站，获取更多&lt;a href=&quot;http://www.enjoyingsoft.com&quot;&gt;Mule ESB 实施，Mule ESB 社区版 实施，Mule ESB实施，Mule ESB社区版实施&lt;/a&gt;帮助。&lt;/p&gt;
&lt;p&gt;欢迎转载，但必须保留原文和此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 13:49:00 +0000</pubDate>
<dc:creator>EnjoyingSoft</dc:creator>
<og:description>Mule ESB是一个使用Java语言编写的开源企业服务总线，企业服务总线英文Enterprise Service Bus，简称ESB。其相关源代码也托管在GitHub上，可以在https://git</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoyingsoft/p/10165617.html</dc:identifier>
</item>
<item>
<title>我的2018 - mskitten</title>
<link>http://www.cnblogs.com/mozi-song/p/10165747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mozi-song/p/10165747.html</guid>
<description>&lt;p&gt;这是2018的年底，我28岁了，没房没车，没有结婚，跟父母断绝了关系，生活在房子均价五万的上海，每天要坐三个小时的地铁上下班。但我非常快乐。&lt;/p&gt;
&lt;p&gt;今年我直到十月底还在B公司上班。B公司真的十分清闲，闲到每天都在看书，还能写一些无病呻吟的博客。我不喜欢这样，觉得很空虚又惊慌。我觉得在实际项目中学到东西要比干看书重要得多。当时的同事都觉得我有毛病。他们上班喝喝茶，下班带带孩子，偶尔翘翘班回家躺着，乐在其中。&lt;/p&gt;
&lt;p&gt;我十一月初入职到现在都还在找自己的节奏。美企容忍度确实高，讲座和training超多，同事也热情约中饭下午茶瑜伽课，四处晃晃一个周就过去了。老板和leader都宽容，说新人适应个大半年是正常的，而我也想多看看，就没太要求自己。第五周的时候开始有点慌了，我开始觉得我的状态跟在IBM的时候没什么两样。第六周更甚，参加了几个Leadership Q&amp;amp;A就过去了，周会的时候花十秒钟就讲完了一周所做的东西，感到面红耳赤。于是第七周也就是上周周一找老板立了flag，承诺把某个稍微复杂的任务做完。为了这个任务加了几个小班，最后不仅做完了，周五下午还提前下班，非常有成就感。&lt;/p&gt;
&lt;p&gt;说到Leadership Q&amp;amp;A，有一次公司里一位高管来做这个活动，此人在十一年中连升四级（普通人大概五六年升一级），他的工作内容复杂到我无法理解。公司常在外籍高管来出差时组织这种活动，目的是给员工答疑解惑，帮助员工梳理职业规划。我是很热衷这种活动的，但是我偶尔会怀疑，参加这种活动除了让我们这种菜鸡明白我们跟高管的差距之远，还能有什么实质的意义？毕竟session不是传道，我们跟人家完全不在一个层次。不在一个层次的结果是连问问题都问不到点子上，更何况靠人家的指点梳理什么职业生涯。&lt;/p&gt;
&lt;p&gt;人和人之间的差距真的可以大到你完全无法揣摩对方的生活和内心，连一点想象都做不到。我很想知道那位高管的人生哲学，但却无从问起，只好一点点等到时间用光，等别人把所有的问题问完。在那个时候我突然意识到，一个人能走到哪里，最终还是要看&lt;strong&gt;他自己&lt;/strong&gt;的内心造诣。当然能力也是有关系的啦。但是最重要的似乎是一种理解，对宇宙洪荒，大千世界，对人类这种生物的本质理解。我觉得如果做到这一点，一个人可以是无所不能的。如果做不到，再多高管在你耳边传道都没用。&lt;/p&gt;
&lt;p&gt;这就是我今年最重要的感悟。我28岁了，也不小了。刚刚摆脱原生家庭的藩篱，现在的生活是我自己的。今后的路要靠自己走，而且也只能靠自己才能走得最好。没有运气问题，不需要别人的帮助，也不会怨怼原生家庭曾经拖我后腿。这是一个清晰无比的感悟，作为一个人的意义，就是用&lt;strong&gt;自己的&lt;/strong&gt;头脑和双手在大地上创造与众不同的、属于自己的生活。&lt;/p&gt;
&lt;p&gt;我在地铁上读了《与神对话》这本书，我觉得非常好看。作者非常透彻慈悲，他以神的角度提出了一个系统的人生观，告诉我们怎样摆脱痛苦，达到美满的人生。我觉得这本鸡汤比一些“畅销书”好喝多了，它对于我来简直醍醐灌顶，让我慢慢摆脱自卑，充满力量。&lt;/p&gt;
&lt;p&gt;读书真的是我能想到的跨越阶级最好的形式（虽然我还没跨越，离跨越还有十万八千里）。我不相信捷径，也早过了急于求成的时期，我觉得俗世成就的多少取决于一个人内心的沉淀，而这种沉淀是要靠时间累积的。当然，看书如吃饭，会受胃口和消化能力所限，我当当上两百块钱买的书可能要一年才看得完，不过那又有什么关系呢？看书又不是为了跟别人比较，只要看完书内心饱满就足够了。&lt;/p&gt;
&lt;p&gt;不管做什么，因为社会浮躁，所以对自己保持诚实还是太重要了。27岁的我希望自己是那个同龄人眼中能力高、前途无量的人，我不停地保持自己的人设，也看着别人保持别人的人设，大家都活在一个个面具下面。28岁的我不再追求这些了，我也说不清是发生了什么，我似乎是顿悟了。有一个英国人的播客十分好听，叫Travel Stories Podcast，是我前两天发现的。他有一种典型欧洲青年的做事思路——探索自己也探索世界，诚心接受自己的不足。他有点话痨，也有点迷糊，整个播客就是听他喋喋不休地自言自语，但是非常好听，因为你会发现他太有想法了。他会叫你一个人去旅行，从遇到的各种人和各种苦难去认识自己。他会讲自己一直想念前女友，于是坐了火车跑去找她摊牌，前女友拒绝了他，他反而觉得很轻松，可以不带包袱地继续生活了。我觉得他的生活很神奇，很有禅意。&lt;/p&gt;
&lt;p&gt;因为原生家庭的关系，我非常习惯自省，不管什么事都会问自己是不是做得不够完美。这本来可能不算优点，但在长大的过程中，这个特点让我善于向各种身边的人学习来完善自己。所以现在的我并不是原生家庭培养长大的我，而是我一手创造的我自己。我的心理医生认为我下定决心跟原生家庭保持距离之后，会获得一次重生，目前看来她说得完全没错。我觉得我变得更加张扬了，工作上对自己狠，生活中对自己好，这应该是做人原本的样子，不是么？&lt;/p&gt;
&lt;p&gt;你看，只要我们想做，还有什么是我们做不到的呢？生命力本身具有摧枯拉朽的力量。不要说我的起点高，我是一个破碎扭曲的家庭长大起来的脆弱自卑的小孩。我的妈妈只上到大专，在过去二十多年中坚持用她的思想干预我的生活；我父亲常年以语言暴力和冷漠的态度对待我。但是我很好，而且会越来越好。你也一样。&lt;/p&gt;

&lt;p&gt;往期推荐&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mozi-song/p/10053202.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;如果IBM再给我一次实习机会&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mozi-song/p/10011186.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;“完美工作”是什么样子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mozi-song/p/9722012.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;一个程序员的辞职信&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;关注微信公众号mskitten，持续推送成长体悟&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1154131/201812/1154131-20181223213021753-1481218589.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 13:33:00 +0000</pubDate>
<dc:creator>mskitten</dc:creator>
<og:description>这是2018的年底，我28岁了，没房没车，没有结婚，跟父母断绝了关系，生活在房子均价五万的上海，每天要坐三个小时的地铁上下班。但我非常快乐。 今年我直到十月底还在B公司上班。B公司真的十分清闲，闲到每</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mozi-song/p/10165747.html</dc:identifier>
</item>
<item>
<title>利用 ImageAI 在 COCO 上学习目标检测 - xinet</title>
<link>http://www.cnblogs.com/q735613050/p/10165709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/q735613050/p/10165709.html</guid>
<description>&lt;p&gt;ImageAI是一个python库，旨在使开发人员能够使用简单的几行代码构建具有包含深度学习和计算机视觉功能的应用程序和系统。 这个 AI Commons 项目https://commons.specpal.science 由 Moses Olafenwa 和 John Olafenwa 开发和维护。为了更好的使用 ImageAI，我将其 Fork 到 &lt;a href=&quot;https://github.com/CodeXZone/ImageAI&quot;&gt;CodeXZone/ImageAI&lt;/a&gt;。同时，ImageAI 也提供了中文手册：&lt;a href=&quot;https://imageai-cn.readthedocs.io/zh_CN/latest/index.html&quot;&gt;imageai&lt;/a&gt;。下面我将借助该教程一步一步的学习目标检测。&lt;/p&gt;
&lt;h2 id=&quot;利用-cocoz-载入-coco-数据集&quot;&gt;利用 cocoz 载入 COCO 数据集&lt;/h2&gt;
&lt;p&gt;首先，利用 &lt;a href=&quot;https://www.cnblogs.com/q735613050/p/10116893.html&quot;&gt;cocoz&lt;/a&gt; 载入 COCOZ：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
# 将 cocoapi 添加进入环境变量
sys.path.append(r'D:\API\cocoapi\PythonAPI')
from pycocotools.cocoz import AnnZ, ImageZ, COCOZ
# ------------------

import numpy as np
from matplotlib import pyplot as plt
from IPython import display


def use_svg_display():
    # 用矢量图显示, 效果更好
    display.set_matplotlib_formats('svg')


def show_imgs(imgs, k=4):
    '''
    展示 多张图片
    '''
    n = len(imgs)
    h, w = k, n // k
    assert n == h * w, &quot;图片数量不匹配&quot;
    use_svg_display()
    _, ax = plt.subplots(h, w, figsize=(5, 5))  # 设置图的尺寸
    K = np.arange(n).reshape((h, w))
    for i in range(h):
        for j in range(w):
            img = imgs[K[i, j]]
            ax[i][j].imshow(img)
            ax[i][j].axes.get_yaxis().set_visible(False)
            ax[i][j].set_xticks([])
    plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataDir = r'E:\Data\coco\images'   # COCO 数据根目录
dataType = 'train2017'
imgZ = ImageZ(dataDir, dataType)

show_imgs(imgZ[300:316])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181223212227124-1528724435.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;物体检测提取和微调&quot;&gt;物体检测，提取和微调&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
sys.path.append('D:/API/ImageAI')

from imageai.Detection import ObjectDetection
import os

execution_path = os.getcwd()

detector = ObjectDetection()  # 创建目标检测实例
detector.setModelTypeAsRetinaNet()
detector.setModelPath(
    os.path.join(execution_path, &quot;resnet50_coco_best_v2.0.1.h5&quot;))
detector.loadModel()  # 载入预训练模型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;detector.detectObjectsFromImage&lt;/code&gt; 比较容易支持解压后的图片，所以我们可以提取出一张图片来做测试：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;input_image = imgZ.Z.extract(imgZ.names[0]) # 输入文件的路径
output_image = os.path.join(execution_path, &quot;image2new.jpg&quot;)  # 输出文件的路径

detections = detector.detectObjectsFromImage(
    input_image=input_image, output_image_path=output_image)

for eachObject in detections:
    print(eachObject[&quot;name&quot;] + &quot; : &quot;, eachObject[&quot;percentage_probability&quot;])
    print(&quot;--------------------------------&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;motorcycle :  99.99607801437378
--------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;detectObjectsFromImage()&lt;/code&gt; 函数返回一个字典列表，每个字典包含图像中检测到的对象信息，字典中的对象信息有 &lt;code&gt;name&lt;/code&gt;（对象类名）和 &lt;code&gt;percentage_probability&lt;/code&gt;（概率）以及 &lt;code&gt;box_points&lt;/code&gt;（图片的左上角与右下角的坐标）。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;detections&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[{'name': 'motorcycle',
  'percentage_probability': 99.99607801437378,
  'box_points': array([ 34,  92, 546, 427])}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们看看其标注框：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;img = plt.imread(output_image)
plt.imshow(img)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181223212253907-1524164920.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了直接使用压缩文件，我们可以修改 &lt;code&gt;detectObjectsFromImage&lt;/code&gt; 的默认参数 &lt;code&gt;input_type='file'&lt;/code&gt; 为 &lt;code&gt;input_type='array'&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;input_image = imgZ[202]  # 输入文件的路径
output_image = os.path.join(execution_path, &quot;image2.jpg&quot;)  # 输出文件的路径

detections = detector.detectObjectsFromImage(
    input_image=input_image, output_image_path=output_image, input_type='array')

for eachObject in detections:
    print(eachObject[&quot;name&quot;] + &quot; : &quot;, eachObject[&quot;percentage_probability&quot;])
    print(&quot;--------------------------------&quot;)

img = plt.imread(output_image)
plt.imshow(img)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;tennis racket :  54.25310730934143
--------------------------------
person :  99.85058307647705
--------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181223212312771-800519742.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;detections, objects_path = detector.detectObjectsFromImage(
    input_image=imgZ[900], input_type = 'array',
    output_image_path=os.path.join(execution_path, &quot;image3new.jpg&quot;),
    extract_detected_objects=True)

for eachObject, eachObjectPath in zip(detections, objects_path):
    print(eachObject[&quot;name&quot;] + &quot; : &quot;, eachObject[&quot;percentage_probability&quot;])
    print(&quot;Object's image saved in &quot;, eachObjectPath)
    print(&quot;--------------------------------&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;person :  56.35678172111511
Object's image saved in  D:\API\CVX\draft\image3new.jpg-objects\person-1.jpg
--------------------------------
person :  75.83483457565308
Object's image saved in  D:\API\CVX\draft\image3new.jpg-objects\person-2.jpg
--------------------------------
person :  60.49004793167114
Object's image saved in  D:\API\CVX\draft\image3new.jpg-objects\person-3.jpg
--------------------------------
person :  85.2730393409729
Object's image saved in  D:\API\CVX\draft\image3new.jpg-objects\person-4.jpg
--------------------------------
person :  83.12703967094421
Object's image saved in  D:\API\CVX\draft\image3new.jpg-objects\person-5.jpg
--------------------------------
bus :  99.7751772403717
Object's image saved in  D:\API\CVX\draft\image3new.jpg-objects\bus-6.jpg
--------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;extract_detected_objects=True&lt;/code&gt; 将会把检测到的对象提取并保存为单独的图像；这将使函数返回 2 个值，第一个是字典数组，每个字典对应一个检测到的对象信息，第二个是所有提取出对象的图像保存路径，并且它们按照对象在第一个数组中的顺序排列。我们先看看原图：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;plt.imshow(imgZ[900])
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181223212330833-1208722883.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示识别出来的对象：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;show_imgs([plt.imread(fname) for fname in objects_path], 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181223212348296-644212457.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一个十分重要的参数 &lt;code&gt;minimum_percentage_probability&lt;/code&gt; 用于设定预测概率的阈值，其默认值为 50（范围在 &lt;span class=&quot;math inline&quot;&gt;\(0-100\)&lt;/span&gt;之间）。如果保持默认值，这意味着只有当百分比概率大于等于 50 时，该函数才会返回检测到的对象。使用默认值可以确保检测结果的完整性，但是在检测过程中可能会跳过许多对象。下面我们看看修改后的效果：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;detections = detector.detectObjectsFromImage(
    input_image=imgZ[900],
    input_type='array',
    output_image_path=os.path.join(execution_path, &quot;image3new.jpg&quot;),
    minimum_percentage_probability=70)

for eachObject in detections:
    print(eachObject[&quot;name&quot;] + &quot; : &quot;, eachObject[&quot;percentage_probability&quot;])
    print(&quot;--------------------------------&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;person :  75.83483457565308
--------------------------------
person :  85.2730393409729
--------------------------------
person :  83.12703967094421
--------------------------------
bus :  99.7751772403717
--------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将 &lt;code&gt;minimum_percentage_probability&lt;/code&gt; 设置为 70，此时仅仅只能检测到 4 个。&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 13:24:00 +0000</pubDate>
<dc:creator>xinet</dc:creator>
<og:description>ImageAI是一个python库，旨在使开发人员能够使用简单的几行代码构建具有包含深度学习和计算机视觉功能的应用程序和系统。 这个 AI Commons 项目https://commons.spec</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/q735613050/p/10165709.html</dc:identifier>
</item>
<item>
<title>图解BERT（NLP中的迁移学习） - d0main</title>
<link>http://www.cnblogs.com/d0main/p/10165671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/d0main/p/10165671.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文翻译自Jay Alammar的博客&lt;a href=&quot;https://jalammar.github.io/illustrated-bert/&quot;&gt;The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　2018年是机器学习模型处理文本(更准确地说，是自然语言处理或简称NLP)的转折点。我们对以何种方式捕捉潜在语义和关系的来表示单词和句子这一问题的理解也在迅速发展。此外，NLP社区中也有人分享了许多了非常强大的模型供你免费下载并在自己的模型和pipeline中使用(它被称为NLP的ImageNet moment，参考了多年前计算机视觉的快速发展)。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210725699-1866158801.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　其中一个最新的里程碑就是BERT的发布，这被人们看作是NLP新时代的开始。BERT是一个打破了许多基于语言的任务中的记录。在论文发布后不久，该模型的团队还开源了模型的代码，并提供了模型的下载版本，这些模型已经在大数据集上进行过了预训练。这是一个重大的进步，因为它使任何想要构建自然语言处理的机器学习模型的人都可以将这个强大的预训练好的模型作为一个随时可用的组件使用——从而节省了从头开始训练模型所需的时间、精力、知识和资源。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210736044-1390036503.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;使用BERT的两个步骤。第一步：下载预训练好的模型；第二步：在特定任务上进行微调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　BERT也是基于最近在NLP社区中涌现的许多聪明的想法，包括 &lt;a href=&quot;https://arxiv.org/abs/1511.01432&quot;&gt;Semi-supervised Sequence Learning&lt;/a&gt; (by &lt;a href=&quot;https://twitter.com/iamandrewdai&quot;&gt;Andrew Dai&lt;/a&gt; 和 &lt;a href=&quot;https://twitter.com/quocleix&quot;&gt;Quoc Le&lt;/a&gt;), &lt;a href=&quot;https://arxiv.org/abs/1802.05365&quot;&gt;ELMo&lt;/a&gt; (by &lt;a href=&quot;https://twitter.com/mattthemathman&quot;&gt;Matthew Peters&lt;/a&gt; 和来自 &lt;a href=&quot;https://allenai.org/&quot;&gt;AI2&lt;/a&gt; and &lt;a href=&quot;https://www.engr.washington.edu/about/bldgs/cse&quot;&gt;UW CSE&lt;/a&gt;的研究人员), &lt;a href=&quot;https://arxiv.org/abs/1801.06146&quot;&gt;ULMFiT&lt;/a&gt; (by fast.ai 创始人 &lt;a href=&quot;https://twitter.com/jeremyphoward&quot;&gt;Jeremy Howard&lt;/a&gt; 和大牛 &lt;a href=&quot;https://twitter.com/seb_ruder&quot;&gt;Sebastian Ruder&lt;/a&gt;), &lt;a href=&quot;https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf&quot;&gt;OpenAI transformer&lt;/a&gt; (by OpenAI 研究员&lt;a href=&quot;https://twitter.com/alecrad&quot;&gt;Radford&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/karthik_r_n&quot;&gt;Narasimhan&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/timsalimans&quot;&gt;Salimans&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/ilyasut&quot;&gt;Sutskever&lt;/a&gt;), 以及Transformer (&lt;a href=&quot;https://arxiv.org/pdf/1706.03762.pdf&quot;&gt;Vaswani et al&lt;/a&gt;)等.&lt;/p&gt;
&lt;p&gt;　　要正确理BERT是什么，我们需要了解许多概念。倒不如先看看BERT有哪些用途。&lt;/p&gt;
&lt;h2 id=&quot;一例子句子分类&quot;&gt;一、例子:句子分类&lt;/h2&gt;
&lt;p&gt;　　最直接的想法就是使用BERT进行单个文本的分类。这个模型看起来是这样的:&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210745557-1442527569.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　要训练这样的模型，您需要重点训练一个分类器，在训练阶段对BERT模型的改动非常小。这种训练过程称为微调（fine-tuning），其根源在于 &lt;a href=&quot;https://arxiv.org/abs/1511.01432&quot;&gt;Semi-supervised Sequence Learning&lt;/a&gt; 和ULMFiT。&lt;/p&gt;
&lt;p&gt;　　对于不熟悉这个概念的人来说，由于我们讨论的是分类器，所以在这个任务中涉及到的是机器学习中的监督学习。这意味着我们需要一个标记好的数据集来训练这样的模型。以垃圾邮件分类为例，标记的数据集将是一个电子邮件消息列表和一个标签（标注“垃圾邮件”或“非垃圾邮件”）。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210755015-1535261829.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;类似的任务场景还有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;情感分析
&lt;ul&gt;&lt;li&gt;输入: 一条影评/商品评价。&lt;/li&gt;
&lt;li&gt;输出: 正面评价还是负面评价?&lt;/li&gt;
&lt;li&gt;数据集如: &lt;a href=&quot;https://nlp.stanford.edu/sentiment/&quot;&gt;SST&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;事实核查
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二模型架构&quot;&gt;二、模型架构&lt;/h2&gt;
&lt;p&gt;　　现在您已经有了一个BERT的用例，接下来让我们进一步了解它是如何工作的。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210806121-909876168.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Google在论文中提到了两个不同模型规模的BERT:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BERT BASE –和OpenAI Transformer模型的规模差不多，方便与其进行性能比较&lt;/li&gt;
&lt;li&gt;BERT LARGE – 一个达到目前多个benchmark的SOTA的巨大的模型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　BERT基本上就是一个训练好的Transformer编码器栈。关于Transformer的内容可以看看 &lt;a href=&quot;https://www.cnblogs.com/d0main/p/10164192.html&quot;&gt;图解Transformer&lt;/a&gt;这篇博文。Transformer是BERT的基础，下面我们也会涉及到这个概念。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210814164-1158823623.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　两种规模的BERT模型都有许多编码器层 (在论文中称为“Transformer块”) – BERT Base有12个这样的结构，BERT Large有24个。编码器中也有前馈网络 (BERT Base中的是768个隐层神经元，BERT Large中的是1024个隐层神经元)， 以及注意力层中使用了比Transformer那篇论文中更多的“头” （BERT Base有12个“头”，BERT Large中有16个）。&lt;/p&gt;
&lt;h3 id=&quot;模型的输入&quot;&gt;模型的输入&lt;/h3&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210829873-1193630360.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　输入序列的第一个token是一个特殊的符号[CLS]，这里的CLS代表class。&lt;/p&gt;
&lt;p&gt;　　就像Transformer的编码器一样，BERT以一串单词作为输入，这些单词不断地想编码器栈上层流动。每一层都要经过自注意力层和前馈网络，然后在将其交给下一个编码器。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210839217-1438175708.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　在体系结构方面，到目前为止，还是与Transformer是相同的（除了一些超参数之外）。接下来在输出端，我们会看到其和Transformer的不同之处。&lt;/p&gt;
&lt;h3 id=&quot;模型的输出&quot;&gt;模型的输出&lt;/h3&gt;
&lt;p&gt;　　每个位置对应地输出一个维度为&lt;em&gt;hidden_size&lt;/em&gt;(BERT Base中为768)的向量。对于之前提到的句子分类的例子，我们只关注第一个位置的输出（也就是被我们用[CLS]符号代替的位置）。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210850418-1049075366.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　输出的这个向量现在可以用作我们选择的分类器的输入。论文利用一个单层神经网络作为分类器，就能取得较好的分类效果。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223210858320-1831484936.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　如果你有更多的标签（例如，如果你是一个电子邮件服务提供商，你需要将电子邮件标记为“垃圾邮件”、“非垃圾邮件”、“社交”和“促销”等等），你只需调整分类器这部分的网络，使其具有更多的输出神经元，然后通过softmax。&lt;/p&gt;
&lt;h2 id=&quot;三与卷积网络并行&quot;&gt;三、与卷积网络并行&lt;/h2&gt;
&lt;p&gt;　　对于有CV背景的人来说，这种向量传递应该让人想起像VGGNet这样的网络的卷积部分和网络结构最后的全连接层之间发生的事情。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211005356-267958720.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;四嵌入表示的新时代&quot;&gt;四、嵌入表示的新时代&lt;/h2&gt;
&lt;p&gt;　　这些新的探索带来了文本编码方式的新转变。到目前为止，在绝大多数的NLP模型中，词嵌入一直是一个主要的文本表示方法。Word2Vec、Glove等方法已广泛应用于此类任务。下面先让我们回顾一下如何使用它们。&lt;/p&gt;
&lt;h3 id=&quot;回顾一下词嵌入&quot;&gt;回顾一下词嵌入&lt;/h3&gt;
&lt;p&gt;　　为了要让机器学习模型能够处理单词，我们需要以数字的形式表示文本，以便模型在计算中使用。通过使用Word2Vec，我们可以用一个向量来代表单词，而这一向量还捕捉了一定的语义信息（如“斯德哥尔摩”和“瑞典”的关系相当于“开罗”与“埃及”的关系)以及语法信息，或基于语法的关系（例如，“had”和“has”的关系与“was”和“is”的关系是一样的）。&lt;/p&gt;
&lt;p&gt;　　人们很快意识到，使用大量文本数据进行预训练学习词嵌入是一个好主意，而不是在小数据集上模型从零开始训练。你可以下载预训练的Word2Vec或GloVe。下面是GloVe训练得到的“stick”对应的向量表示(嵌入向量维度为200）。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211013557-1739777055.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　由于维度很大，在后面的文章中会用下面这种形状代表向量：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211025230-185993939.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;elmo-语境的重要性&quot;&gt;ELMo: 语境的重要性&lt;/h3&gt;
&lt;p&gt;　　如果我们是使用GloVe训练好的向量作为一个词，比如“stick”的表示，那么不管在什么上下文中，这个表示都是一样的。在一些研究中 (&lt;a href=&quot;https://arxiv.org/abs/1705.00108&quot;&gt;Peters et. al., 2017&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1708.00107&quot;&gt;McCann et. al., 2017&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/pdf/1802.05365.pdf&quot;&gt;Peters et. al., 2018 in the ELMo paper&lt;/a&gt; )，研究人员认为像“&lt;em&gt;stick&lt;/em&gt;”这样的词其实有很多意思，具体是什么意思取决于在什么语境中用它。那么为什么不基于其上下文语境来学习一个词的嵌入表示呢？也就是即学习到这个词的上下文的语义，有学习到其他的语境信息。就此，语境化的词嵌入模型应运而生。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://jalammar.github.io/images/elmo-embedding-robin-williams.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;语境化的词嵌入模型能够基于一个单词的上下文的意思给出单词的向量表示[RIP Robin Williams](https://www.youtube.com/watch?v=OwwdgsN9wF8)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ELMo没有为每个单词使用固定的嵌入，而是在为每个单词分配嵌入之前查看整个句子。它使用针对特定任务的双向LSTM来创建这些嵌入。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211058188-52590855.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　ELMo为在语境中进行预训练提供了重要的思路。ELMo LSTM能够在大数据集上进行训练，然后作为其他模型的一个部分处理其他的自然语言任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ELMo的秘诀是什么?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ELMo通过训练预测单词序列中的下一个单词来理解语言——这项任务被称为&lt;strong&gt;语言建模&lt;/strong&gt;。这很方便，因为我们有的是大量的文本数据，这样的模型可以从这些数据中学习，而不需要额外的标签。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211110992-93116852.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;ELMo进行预训练的一个步骤：给定输入“Let’s stick to”， 预测接下来一个词，这就是语言模型的任务。当模型在大语料上进行预训练，他就会学习其中的语言模式。它不太可能准确地直接地猜出这个例子中的下一个单词。更实际一点说，在“hang”这样的单词之后，它将为“out”这样的单词分配更高的概率(组成 “hang out”) 而不是给“camera”分配更高的概率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看到每个LSTM时间步的隐状态从ELMo的“头部”后面探出来。这些向量会在预训练结束后的嵌入过程中会派上用场。&lt;/p&gt;
&lt;p&gt;　　ELMo实际上更进一步，训练了一个双向的LSTM——这样它的语言模型不仅能预测下一个词，还有预测上一个词。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211118781-1736365390.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;[Great slides](https://www.slideshare.net/shuntaroy/a-review-of-deep-contextualized-word-representations-peters-2018) on ELMo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ELMo通过将隐藏状态(和初始嵌入)以某种方式(拼接之后加权求和)组合在一起，提出了语境化的词嵌入。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211128658-535774510.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;五ulm-fit搞懂nlp中的迁移学习&quot;&gt;五、ULM-FiT：搞懂NLP中的迁移学习&lt;/h2&gt;
&lt;p&gt;　　ULM-FiT引入了一些方法来有效地利用模型在预训练中学到的东西——不仅仅是嵌入，还有语境化的嵌入表示。ULM-FiT引入了一个语言模型和一套针对各种任务有效地对语言模型进行微调的流程。&lt;/p&gt;
&lt;p&gt;　　NLP终于找到了一种方法，可以像CV那样进行迁移学习了。&lt;/p&gt;
&lt;h2 id=&quot;六transformer超越lstm&quot;&gt;六、Transformer：超越LSTM&lt;/h2&gt;
&lt;p&gt;　　Transformer的论文和代码的发布，以及它在机器翻译等任务上取得的成果，开始使一些业内人士认为它是LSTM的替代品。Transformer比LSTM更能处理长期依赖。&lt;/p&gt;
&lt;p&gt;　　Transformer的编码器-译码器结构使其成为机器翻译的理想模型。但是你会如何使用它来进行句子分类呢？你将如何针对其他特定任务对语言模型进行微调呢？&lt;/p&gt;
&lt;h2 id=&quot;七openaitransformer为语言建模预训练一个transformer解码器&quot;&gt;七、OpenAI　Transformer：为语言建模预训练一个Transformer解码器&lt;/h2&gt;
&lt;p&gt;　　事实证明，我们可以不用一个完整的Transformer来迁移学习并进行微调。我们可以只用Transformer的解码器就可以了。解码器是一个很好的选择，因为它能屏蔽掉后来的词（当进行逐词生成翻译时，这是一个很有用的特性）。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211140024-643336045.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;The OpenAI Transformer 是由Transformer的解码器栈组成的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个模型堆叠了12个解码器层。由于在这种设计中没有编码器，因此这些解码器层也不会有Transformer原文中的那种编码器-解码器注意力子层。但是，仍然还是有自注意力层。&lt;/p&gt;
&lt;p&gt;　　有了这种结构，我们可以继续在相同的语言建模任务上进行训练模型：使用大量(未标记的)文本来预测下一个单词。只是，把7000本书的文本扔给模型，让它学习！书籍非常适合这类任务，因为它允许模型学习相关联的信息，而当您使用tweet或文章进行训练时，您无法获得这些信息。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211148444-177639109.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;The OpenAI Transformer现在已经准备好被训练成能够预测下一个单词了&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;八在下游任务中使用迁移学习&quot;&gt;八、在下游任务中使用迁移学习&lt;/h2&gt;
&lt;p&gt;　　既然OpenAI　Transformer已经经过了预训练，而且它的各个层也经过了调整，我们就可以开始在下游任务中使用它了。让我们先来看看句子分类（将邮件信息分为“垃圾邮件”或“非垃圾邮件”）:&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211158799-1438659720.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;How to use a pre-trained OpenAI transformer to do sentence clasification&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　OpenAI的论文列出了许多用于处理不同类型任务输入的输入变换。下图显示了模型的结构和执行不同任务时的输入变换。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211210314-861763164.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;九bert从解码器到编码器&quot;&gt;九、BERT：从解码器到编码器&lt;/h2&gt;
&lt;p&gt;　　openAI Transformer为我们提供了一个基于Transformer的可微调的预训练的模型。但是把LSTM换成Transformer还是让有些东西丢失了。ELMo的语言模型是双向的，而openAI Transformer则只训练一个从左到右的语言模型。那么我们能否建立一个既能从左到右预测又能从右到左预测（同时受上、下文的制约)的基于Transformer的模型呢？&lt;/p&gt;
&lt;h3 id=&quot;mlm语言模型&quot;&gt;MLM语言模型&lt;/h3&gt;
&lt;p&gt;　　&lt;em&gt;“我们将使用Transformer编码器”&lt;/em&gt;，BERT说。&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;“这太疯狂了”&lt;/em&gt;，有人说，“&lt;em&gt;每个人都知道双向条件作用会让每个词在多层次的语境中间接地看到自己。&lt;/em&gt;”&lt;/p&gt;
&lt;p&gt;　　“&lt;em&gt;我们将使用掩码&lt;/em&gt;”，BERT自信地说。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211219214-2033398179.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;BERT遮罩住15%输入序列中15%的token，然后让模型预测这些遮罩住的位置是什么单词&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　找到合适的任务来训练Transformer的编码器栈是一个复杂的问题，BERT采用了早期文献(完形填空任务)中的“带掩码的语言模型”概念来解决这个问题。&lt;/p&gt;
&lt;p&gt;　　除了屏蔽15%的输入，BERT还混入一些东西，以改进模型的微调方式。有时它会随机地将一个单词替换成另一个单词，并让模型预测该位置的正确单词。&lt;/p&gt;
&lt;h3 id=&quot;两个句子的任务&quot;&gt;两个句子的任务&lt;/h3&gt;
&lt;p&gt;　　如果你还记得OpenAI Transformer处理不同任务时所做的输入变换，你会注意到一些任务需要模型处理关于两个句子的信息（例如，一个句子是否是另一个句子的复述；再例如假设一个维基百科条目作为输入，一个关于这个条目的问题作为另一个输入，我们能回答这个问题吗？）&lt;/p&gt;
&lt;p&gt;　　为了让BERT更好地处理多个句子之间的关系，预训练的过程还有一个额外的任务：给定两个句子（A和B）， B可能是接在A后面出现的句子吗？&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211229613-602551603.png&quot;/&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;BERT预训练的第二个任务是两个句子的分类任务。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决特定任务的模型&quot;&gt;解决特定任务的模型&lt;/h3&gt;
&lt;p&gt;　　BERT论文展示了BERT在不同任务上的应用。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211239650-626598805.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;用于特征提取的bert&quot;&gt;用于特征提取的BERT&lt;/h3&gt;
&lt;p&gt;　　微调的方法并不是使用BERT的唯一方法。就像ELMo一样，你也可以使用预训练好的BERT来创建语境化的词嵌入。然后，您可以将这些嵌入表示喂给现有的模型——论文中也提到，在NER这类任务中，这种用法的最终效果也没有比用微调的方法的结果差很多。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211317303-1228266810.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　哪种向量作为语境化嵌入的效果最好？我认为这取决于具体任务。论文比较了6中选择（与微调后的96.4分模型相比):&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1135245/201812/1135245-20181223211304478-1913069689.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;十把bert牵出来遛一遛&quot;&gt;十、把BERT牵出来遛一遛&lt;/h2&gt;
&lt;p&gt;　　试用BERT的最好方法是通过在谷歌Colab上托管的&lt;a href=&quot;https://colab.research.google.com/github/tensorflow/tpu/blob/master/tools/colab/bert_finetuning_with_cloud_tpus.ipynb&quot;&gt;BERT FineTuning with Cloud TPUs&lt;/a&gt; notebook。如果你之前从未使用过Cloud TPU，那么这也是尝试它们的一个很好的开始，而且BERT代码也可以在TPU、CPU和GPU上工作。&lt;/p&gt;
&lt;p&gt;　　下一步可以看看 &lt;a href=&quot;https://github.com/google-research/bert&quot;&gt;BERT代码实现&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模型在 &lt;a href=&quot;https://github.com/google-research/bert/blob/master/modeling.py&quot;&gt;modeling.py&lt;/a&gt; (&lt;code&gt;class BertModel&lt;/code&gt;)中定义，而且和原生的Transformer encoder非常相似。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google-research/bert/blob/master/run_classifier.py&quot;&gt;run_classifier.py&lt;/a&gt; 是一个微调过程的例子。其中构造了一个分类层。如果你想构建自己的分类器，可以看看文件中的 &lt;code&gt;create_model()&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;一些预训练模型可供下载。其中包括了BERT Base和 BERT Large，以及在中文、英文等102种语言的维基百科上预训练得到的模型。&lt;/li&gt;
&lt;li&gt;BERT并不是直接处理单词，而是把 WordPieces作为token。 &lt;a href=&quot;https://github.com/google-research/bert/blob/master/tokenization.py&quot;&gt;tokenization.py&lt;/a&gt; 是能够将单词转换成wordPieces的脚本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　你也可以参考 &lt;a href=&quot;https://github.com/huggingface/pytorch-pretrained-BERT&quot;&gt;BERT的PyTorch实现&lt;/a&gt;。&lt;a href=&quot;https://github.com/allenai/allennlp&quot;&gt;AllenNLP&lt;/a&gt; 用这个代码让其他模型也能够用&lt;a href=&quot;https://github.com/allenai/allennlp/pull/2067&quot;&gt;BERT的嵌入表示&lt;/a&gt; 。&lt;/p&gt;
</description>
<pubDate>Sun, 23 Dec 2018 13:14:00 +0000</pubDate>
<dc:creator>d0main</dc:creator>
<og:description>本文翻译自Jay Alammar的博客</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/d0main/p/10165671.html</dc:identifier>
</item>
</channel>
</rss>