<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WPS Office 2019 for Linux来了 - chenxiaopang</title>
<link>http://www.cnblogs.com/pandachen/p/10807089.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pandachen/p/10807089.html</guid>
<description>&lt;p&gt;&lt;span&gt;难得啊，焕然一新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685303/201905/685303-20190503231705271-558403741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685303/201905/685303-20190503231738931-2054450531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;log_main&quot;&gt;
&lt;h2 class=&quot;log_title&quot;&gt;WPS Office 2019 For Linux更新说明&lt;/h2&gt;
&lt;h3 class=&quot;log_h3&quot;&gt;11.1.0.8392 版本主要更新：&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;修复wpsoffice进程存在时不能关机的问题&lt;/li&gt;
&lt;li&gt;修复WPS文字模块web版式下拖动自选图形，WPS崩溃的问题&lt;/li&gt;
&lt;li&gt;修复文档标签tooltip重影的问题&lt;/li&gt;
&lt;li&gt;优化黑色主题下，部分对话框内容显示不清晰的问题&lt;/li&gt;
&lt;li&gt;安装包去除垃圾资源&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;log_h3&quot;&gt;11.1.0.8372 版本主要更新：&lt;/h3&gt;
&lt;h3&gt;WPS公共&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;全新的皮肤风格、图标、控点等，支持高分辨率屏幕、自定义外观&lt;/li&gt;
&lt;li&gt;全新的新建页面，整合最近打开文档、本地模板、公文模板、在线模板等&lt;/li&gt;
&lt;li&gt;设置字体字号时，文档区域支持预览效果&lt;/li&gt;
&lt;li&gt;新增内置浏览器&lt;/li&gt;
&lt;li&gt;支持首页，集合文档搜索、常用位置、云文档等入口&lt;/li&gt;
&lt;li&gt;支持个人中心，展示账号详细资料，可修改账号信息&lt;/li&gt;
&lt;li&gt;支持插入SVG格式图片&lt;/li&gt;
&lt;li&gt;支持插入二维码、条形码&lt;/li&gt;
&lt;li&gt;支持多窗口、多标签自由拆分和组合，以及自由管理标签&lt;/li&gt;
&lt;li&gt;支持为图表中的日期/时间设置区域&lt;/li&gt;
&lt;li&gt;支持维吾尔语排版&lt;/li&gt;
&lt;li&gt;优化皮肤和外观设置，支持自定义外观&lt;/li&gt;
&lt;li&gt;优化功能区布局，调整在窗口比较小时的压缩规则，支持调整快速访问工具栏的宽度&lt;/li&gt;
&lt;li&gt;修复云文档上传失败的问题&lt;/li&gt;
&lt;li&gt;修复文本自动色跟随主题的问题&lt;/li&gt;
&lt;li&gt;修复黑色主题下，WPS表格背景色为黑色的问题&lt;/li&gt;
&lt;li&gt;修改字体匹配规则&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;log_h3&quot;&gt;WPS文字&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;新增导航窗格，支持目录导航、页面导航、书签导航的功能&lt;/li&gt;
&lt;li&gt;新增阅读版式，支持以图书的分栏样式显示文档内容&lt;/li&gt;
&lt;li&gt;新增字体替换功能&lt;/li&gt;
&lt;li&gt;新增中文拼写检查入口&lt;/li&gt;
&lt;li&gt;新增调整表格行高和列宽的入口&lt;/li&gt;
&lt;li&gt;新增对自动编号调整缩进的入口&lt;/li&gt;
&lt;li&gt;新增quote域，引用其他域的计算结果作为参数做二次解析&lt;/li&gt;
&lt;li&gt;支持更新手动目录&lt;/li&gt;
&lt;li&gt;支持页眉页脚的HTML写盘&lt;/li&gt;
&lt;li&gt;支持插入超链接时，可链接到文档中的某个书签&lt;/li&gt;
&lt;li&gt;提供插入方框、打勾方框、打叉方框，自动识别文档中的方框，支持打勾或取消打勾操作&lt;/li&gt;
&lt;li&gt;对于大部分命令支持按F4，重复上一次的操作&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;log_h3&quot;&gt;WPS表格&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;支持粘贴时跳过筛选隐藏的单元格，只粘贴到可见单元格&lt;/li&gt;
&lt;li&gt;支持筛选时检查区域下方数据并扩展筛选区域&lt;/li&gt;
&lt;li&gt;支持智能填充&lt;/li&gt;
&lt;li&gt;支持显示表格筛选标题&lt;/li&gt;
&lt;li&gt;支持多工作表数据合并&lt;/li&gt;
&lt;li&gt;支持列的筛选、筛选条件设置&lt;/li&gt;
&lt;li&gt;支持在右键菜单中设置筛选条件&lt;/li&gt;
&lt;li&gt;支持提取或标记数据中重复值、唯一值&lt;/li&gt;
&lt;li&gt;支持在常用公式中，2019.01.01后所得税的计算&lt;/li&gt;
&lt;li&gt;支持打开HTML文件或粘贴为HTML时，显示进度条&lt;/li&gt;
&lt;li&gt;支持在数字格式对话框中，设置万元、正负号格式&lt;/li&gt;
&lt;li&gt;支持对单元格前后有空字符串进行错误检查&lt;/li&gt;
&lt;li&gt;支持冻结窗格下，区选单元格区域时实现滚动减速&lt;/li&gt;
&lt;li&gt;数字格式中，区域为日本时，新增日历类型“日本年号”&lt;/li&gt;
&lt;li&gt;修复保存工作簿至共享路径时提示共享冲突的问题&lt;/li&gt;
&lt;li&gt;修复Fedora平台下，设置屏幕缩放为200%后，输入字体重叠的问题&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;log_h3&quot;&gt;WPS演示&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;智能图形支持了97种图形的插入和编辑，37种图形仅支持读写&lt;/li&gt;
&lt;li&gt;拆分幻灯片切换和动画选项卡，提升动画易用性&lt;/li&gt;
&lt;li&gt;新增字体缺失提醒功能，可实现幻灯片中缺失字体的检查和替换&lt;/li&gt;
&lt;li&gt;修复输出PDF时，文字加粗的问题&lt;/li&gt;
&lt;li&gt;修复项目符号、制表位排版和占位符跟随的兼容问题&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 03 May 2019 15:32:00 +0000</pubDate>
<dc:creator>chenxiaopang</dc:creator>
<og:description>难得啊，焕然一新。 WPS Office 2019 For Linux更新说明 11.1.0.8392 版本主要更新： 修复wpsoffice进程存在时不能关机的问题 修复WPS文字模块web版式下拖</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pandachen/p/10807089.html</dc:identifier>
</item>
<item>
<title>详解Supervisor进程守护监控 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/supervisor.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/supervisor.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;31.683417085427&quot;&gt;
&lt;blockquote readability=&quot;7.7989949748744&quot;&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://supervisord.org/&quot; target=&quot;_blank&quot;&gt;Supervisor&lt;/a&gt;在百度百科上给的定义是超级用户，监管员。Supervisor是一个进程管理工具，当进程中断的时候Supervisor能自动重新启动它。可以运行在各种类unix的机器上，supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;介绍Supervisor&lt;/h2&gt;
&lt;p&gt;- supervisord&lt;/p&gt;
&lt;p&gt;运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。&lt;/p&gt;
&lt;p&gt;- supervisorctl&lt;/p&gt;
&lt;p&gt;是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。&lt;/p&gt;
&lt;p&gt;supervisor是所有进程的父进程，管理着启动的子进展，supervisor以子进程的PID来管理子进程，当子进程异常退出时supervisor可以收到相应的信号量。&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;安装Supervisor&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;♛ 安装方法1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.0.0 安装python&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum install python-setuptools&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173109582-612972030.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.0.1 安装Supervisor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;easy_install supervisor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173117841-734879689.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;♛ 安装方法2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wget https://pypi.python.org/packages/source/s/supervisor/supervisor-3.1.3&lt;span&gt;.tar.gz
tar zxvf supervisor&lt;/span&gt;-3.1.3&lt;span&gt;.tar.gz
cd supervisor&lt;/span&gt;-3.1.3&lt;span&gt;
python setup.py install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我就是用的安装方法2安装的、&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2 查看安装是否成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;echo_supervisord_conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173125041-1217247343.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;配置Supervisor&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;2.0 创建目录，初始化配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir /usr/&lt;span&gt;supervisor
echo_supervisord_conf &lt;/span&gt;&amp;gt; /usr/supervisor/supervisord.conf
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;strong&gt;echo_supervisord_conf详解：&lt;br/&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5')&quot; readability=&quot;46&quot;&gt;&lt;img id=&quot;code_img_closed_3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;img id=&quot;code_img_opened_3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
[root@centos-011 ~ 07:50:00]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;cat /etc/supervisord.conf.bak&lt;/span&gt;
&lt;span&gt;; Sample supervisor config file.
 
[unix_http_server]
file&lt;/span&gt;=/var/run/supervisor/&lt;span&gt;supervisor.sock   ; socket 路径
 
;chmod&lt;/span&gt;=0700&lt;span&gt;                 ; socket 文件的权限
;chown&lt;/span&gt;=&lt;span&gt;nobody:nogroup       ; socket 所属用户及组
;username&lt;/span&gt;=&lt;span&gt;user              ; 用户名
;password&lt;/span&gt;=123&lt;span&gt;               ; 密码
 
;[inet_http_server]         ; 是否启用服务，默认是关闭的（启用的话可以看到supervisor 管理的服务状态）
;port&lt;/span&gt;=127.0.0.1:9001&lt;span&gt;        ; 监听的IP及端口
;username&lt;/span&gt;=&lt;span&gt;user              ; 用户名
;password&lt;/span&gt;=123&lt;span&gt;               ; 密码
 
[supervisord]               ; supervisord 全局配置
logfile&lt;/span&gt;=/var/log/supervisor/&lt;span&gt;supervisord.log  ; supervisor 日志路径
logfile_maxbytes&lt;/span&gt;=&lt;span&gt;50MB       ; 单个日志文件最大数
logfile_backups&lt;/span&gt;=10&lt;span&gt;          ; 保留多少个日志文件（默认10个）
loglevel&lt;/span&gt;=&lt;span&gt;info               ; (log level;default info; others: debug,warn,trace)
pidfile&lt;/span&gt;=/var/run/&lt;span&gt;supervisord.pid ; pid 文件路径
nodaemon&lt;/span&gt;=&lt;span&gt;false              ; 启动是否丢到前台，设置为false ，表示以daemon 的方式启动
minfds&lt;/span&gt;=1024&lt;span&gt;                 ; 最小文件打开数，对应系统limit.conf 中的nofile ,默认最小为1024，最大为4096
minprocs&lt;/span&gt;=200&lt;span&gt;                ; 最小的进程打开数，对应系统的limit.conf 中的nproc,默认为200
;umask&lt;/span&gt;=022                  ; (process file creation umask;default 022&lt;span&gt;)
;user&lt;/span&gt;=&lt;span&gt;chrism                 ; 启动supervisord 服务的用户，默认为root
;identifier&lt;/span&gt;=supervisor       ; (supervisord identifier, default &lt;span&gt;is&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;supervisor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
;directory&lt;/span&gt;=/&lt;span&gt;tmp              ; 这里的目录指的是服务的工作目录
;nocleanup&lt;/span&gt;=true              ; (don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t clean up tempfiles at start;default false)&lt;/span&gt;
;childlogdir=/tmp            ; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AUTO&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; child log dir, default $TEMP)
;environment&lt;/span&gt;=KEY=&lt;span&gt;value       ; (key value pairs to add to environment)
;strip_ansi&lt;/span&gt;=false            ; (strip ansi escape codes &lt;span&gt;in&lt;/span&gt; logs; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;. false)
 
; the below section must remain &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the config file &lt;span&gt;for&lt;/span&gt;&lt;span&gt; RPC
; (supervisorctl&lt;/span&gt;/&lt;span&gt;web interface) to work, additional interfaces may be
; added by defining them &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory &lt;/span&gt;=&lt;span&gt; supervisor.rpcinterface:make_main_rpcinterface
 
[supervisorctl]
serverurl&lt;/span&gt;=unix:///var/run/supervisor/supervisor.sock ; use a unix:// URL  &lt;span&gt;for&lt;/span&gt;&lt;span&gt; a unix socket
;serverurl&lt;/span&gt;=http://127.0.0.1:9001 ; use an http://&lt;span&gt; url to specify an inet socket
;username&lt;/span&gt;=chris              ; should be same as http_username &lt;span&gt;if&lt;/span&gt;&lt;span&gt; set
;password&lt;/span&gt;=123                ; should be same as http_password &lt;span&gt;if&lt;/span&gt;&lt;span&gt; set
;prompt&lt;/span&gt;=mysupervisor         ; cmd line prompt (default &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supervisor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
;history_file&lt;/span&gt;=~/.sc_history  ; use readline history &lt;span&gt;if&lt;/span&gt;&lt;span&gt; available
 
; The below sample program section shows all possible program subsection values,
; create one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more &lt;span&gt;'&lt;/span&gt;&lt;span&gt;real&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; program: sections to be able to control them under
; supervisor.
 
;[program:theprogramname]      ; 定义一个守护进程 ，比如下面的elasticsearch 
;command&lt;/span&gt;=/bin/&lt;span&gt;cat              ; 启动程序使用的命令，可以是绝对路径或者相对路径
;process_name&lt;/span&gt;=%(program_name)s ; 一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%&lt;span&gt;(program_name)s
;numprocs&lt;/span&gt;=1                    ; Supervisor启动这个程序的多个实例，如果numprocs&amp;gt;1，则process_name的表达式必须包含%&lt;span&gt;(process_num)s，默认是1
;directory&lt;/span&gt;=/&lt;span&gt;tmp                ; supervisord在生成子进程的时候会切换到该目录
;umask&lt;/span&gt;=022                     ; umask &lt;span&gt;for&lt;/span&gt;&lt;span&gt; process (default None)
;priority&lt;/span&gt;=999&lt;span&gt;                  ; 权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999
;autostart&lt;/span&gt;=&lt;span&gt;true                ; 如果设置为true，当supervisord启动的时候，进程会自动启动
;autorestart&lt;/span&gt;=&lt;span&gt;true              ; 设置为随 supervisord 重启而重启，值可以是false、true、unexpected。false：进程不会自动重启
;startsecs&lt;/span&gt;=10&lt;span&gt;                  ; 程序启动后等待多长时间后才认为程序启动成功，默认是10秒
;startretries&lt;/span&gt;=3&lt;span&gt;                ; supervisord尝试启动一个程序时尝试的次数。默认是3
;exitcodes&lt;/span&gt;=0,2                 ; 一个预期的退出返回码，默认是0,2&lt;span&gt;。
;stopsignal&lt;/span&gt;=QUIT               ; 当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, &lt;span&gt;or&lt;/span&gt;&lt;span&gt; USR2
;stopwaitsecs&lt;/span&gt;=10&lt;span&gt;               ; 在操作系统给supervisord发送SIGCHILD信号时等待的时间
;user&lt;/span&gt;=&lt;span&gt;chrism                   ; 如果supervisord以root运行，则会使用这个设置用户启动子程序
;redirect_stderr&lt;/span&gt;=&lt;span&gt;true          ; 如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符
;stdout_logfile&lt;/span&gt;=/a/&lt;span&gt;path        ; 把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置
;stdout_logfile_maxbytes&lt;/span&gt;=&lt;span&gt;1MB   ; 标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小
;stdout_logfile_backups&lt;/span&gt;=10&lt;span&gt;     ; 标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份
;stdout_capture_maxbytes&lt;/span&gt;=&lt;span&gt;1MB   ; 当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB
;stdout_events_enabled&lt;/span&gt;=&lt;span&gt;false   ; 如果设置为true，当进程在写它的stderr
;stderr_logfile&lt;/span&gt;=/a/&lt;span&gt;path        ; 把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true
;stderr_logfile_maxbytes&lt;/span&gt;=&lt;span&gt;1MB   ; 错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小
;stderr_logfile_backups&lt;/span&gt;=10&lt;span&gt;     ; 错误日志轮转备份的数量，默认是10，如果设置为0，则不备份
;stderr_capture_maxbytes&lt;/span&gt;=&lt;span&gt;1MB   ; 当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB
;stderr_events_enabled&lt;/span&gt;=&lt;span&gt;false   ; 如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发
;environment&lt;/span&gt;=A=1,B=2           ; 一个k/&lt;span&gt;v对的list列表
;serverurl&lt;/span&gt;=&lt;span&gt;AUTO                ; 是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url
 
; The below sample eventlistener section shows all possible
; eventlistener subsection values, create one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more &lt;span&gt;'&lt;/span&gt;&lt;span&gt;real&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
; eventlistener: sections to be able to handle event notifications
; sent by supervisor.
 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个地方是自定义一个守护进程&lt;/span&gt;
&lt;span&gt;[program:elasticsearch]                       ; 定义一个守护进程 elasticsearch
environment&lt;/span&gt;=ES_HOME=/usr/local/&lt;span&gt;elasticsearch  ; 设置ES_HOME 环境变量
user&lt;/span&gt;=&lt;span&gt;elk                                      ; 启动elasticsearch 的用户
directory&lt;/span&gt;=/usr/local/&lt;span&gt;elasticsearch            ; 进入到这个目录中
command&lt;/span&gt;=/usr/local/elasticsearch/bin/&lt;span&gt;elasticsearch ; 执行启动命令
numprocs&lt;/span&gt;=1                                    ; Supervisor启动这个程序的多个实例，如果numprocs&amp;gt;1，则process_name的表达式必须包含%&lt;span&gt;(process_num)s，默认是1
autostart&lt;/span&gt;=&lt;span&gt;true                                ; 设置为随 supervisord 启动而启动
autorestart&lt;/span&gt;=&lt;span&gt;true                              ; 设置为随 supervisord 重启而重启
startretries&lt;/span&gt;=3&lt;span&gt;                                ; 设置elasticsearch 重启的重试次数
priority&lt;/span&gt;=1&lt;span&gt;                                    ; 权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999  
 
;[eventlistener:theeventlistenername]
;command&lt;/span&gt;=/bin/&lt;span&gt;eventlistener    ; the program (relative uses PATH, can take args)
;process_name&lt;/span&gt;=%(program_name)s ; process_name expr (default %&lt;span&gt;(program_name)s)
;numprocs&lt;/span&gt;=1                    ; number of processes copies to start (&lt;span&gt;def&lt;/span&gt; 1&lt;span&gt;)
;events&lt;/span&gt;=EVENT                  ; event notif. types to subscribe to (req&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d)&lt;/span&gt;
;buffer_size=10                ; event buffer queue size (default 10&lt;span&gt;)
;directory&lt;/span&gt;=/tmp                ; directory to cwd to before &lt;span&gt;exec&lt;/span&gt; (&lt;span&gt;def&lt;/span&gt;&lt;span&gt; no cwd)
;umask&lt;/span&gt;=022                     ; umask &lt;span&gt;for&lt;/span&gt;&lt;span&gt; process (default None)
;priority&lt;/span&gt;=-1                   ; the relative start priority (default -1&lt;span&gt;)
;autostart&lt;/span&gt;=&lt;span&gt;true                ; start at supervisord start (default: true)
;autorestart&lt;/span&gt;=&lt;span&gt;unexpected        ; restart at unexpected quit (default: unexpected)
;startsecs&lt;/span&gt;=10                  ; number of secs prog must stay running (&lt;span&gt;def&lt;/span&gt;. 1&lt;span&gt;)
;startretries&lt;/span&gt;=3                ; max &lt;span&gt;#&lt;/span&gt;&lt;span&gt; of serial start failures (default 3)&lt;/span&gt;
;exitcodes=0,2                 ; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;expected&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; exit codes &lt;span&gt;for&lt;/span&gt; process (default 0,2&lt;span&gt;)
;stopsignal&lt;/span&gt;=&lt;span&gt;QUIT               ; signal used to kill process (default TERM)
;stopwaitsecs&lt;/span&gt;=10               ; max num secs to wait b4 SIGKILL (default 10&lt;span&gt;)
;user&lt;/span&gt;=&lt;span&gt;chrism                   ; setuid to this UNIX account to run the program
;redirect_stderr&lt;/span&gt;=&lt;span&gt;true          ; redirect proc stderr to stdout (default false)
;stdout_logfile&lt;/span&gt;=/a/path        ; stdout log path, NONE &lt;span&gt;for&lt;/span&gt;&lt;span&gt; none; default AUTO
;stdout_logfile_maxbytes&lt;/span&gt;=1MB   ; max &lt;span&gt;#&lt;/span&gt;&lt;span&gt; logfile bytes b4 rotation (default 50MB)&lt;/span&gt;
;stdout_logfile_backups=10     ; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; of stdout logfile backups (default 10)&lt;/span&gt;
;stdout_events_enabled=&lt;span&gt;false   ; emit events on stdout writes (default false)
;stderr_logfile&lt;/span&gt;=/a/path        ; stderr log path, NONE &lt;span&gt;for&lt;/span&gt;&lt;span&gt; none; default AUTO
;stderr_logfile_maxbytes&lt;/span&gt;=1MB   ; max &lt;span&gt;#&lt;/span&gt;&lt;span&gt; logfile bytes b4 rotation (default 50MB)&lt;/span&gt;
;stderr_logfile_backups        ; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; of stderr logfile backups (default 10)&lt;/span&gt;
;stderr_events_enabled=&lt;span&gt;false   ; emit events on stderr writes (default false)
;environment&lt;/span&gt;=A=1,B=2&lt;span&gt;           ; process environment additions
;serverurl&lt;/span&gt;=&lt;span&gt;AUTO                ; override serverurl computation (childutils)
 
; The below sample group section shows all possible group values,
; create one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more &lt;span&gt;'&lt;/span&gt;&lt;span&gt;real&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; group: sections to create &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;heterogeneous&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
; process groups.
 
;[group:thegroupname]          ; 服务组管理，可以将多个服务名写到这里管理(组名自定义）
;programs&lt;/span&gt;=&lt;span&gt;progname1,progname2  ; 上面配置好的服务名，比如elasticsearch,kibana,logstash
;priority&lt;/span&gt;=999                  ; the relative start priority (default 999&lt;span&gt;)
 
; The [include] section can just contain the &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;files&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; setting.  This
; setting can list multiple files (separated by whitespace &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt;
; newlines).  It can also contain wildcards.  The filenames are
; interpreted as relative to this file.  Included files &lt;/span&gt;*cannot*&lt;span&gt;
; include files themselves.
 
[include]
files &lt;/span&gt;= supervisord.d/*.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2.1 为了不将所有新增配置信息全写在一个配置文件里，这里新建一个文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkdir /usr/supervisor/supervisord.d/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2 修改系统配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim /usr/supervisor/supervisord.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.3 include 2.1中新建的supervisord.d文件夹下所有的conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[include]
files &lt;/span&gt;= /usr/supervisor/supervisord.d/*.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.4 若需要web查看进程，则去掉[inet_http_server]的注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[inet_http_server]
port&lt;/span&gt;=127.0.0.1:9001&lt;span&gt;   ;IP按需配置     
username&lt;/span&gt;=&lt;span&gt;user              
password&lt;/span&gt;=123
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;运行Supervisor&lt;/h2&gt;
&lt;p&gt;3.0 启动supervisord&lt;/p&gt;
&lt;p&gt;&lt;code&gt;supervisord -c /usr/supervisor/supervisord.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.1 查看监听&lt;/p&gt;
&lt;p&gt;lsof -i:9001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173142248-709724422.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这一步，就可以通过 http://ip:9001/ 查看supervisor的web界面了，只不过目前还没有加入任何监控程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173156352-210925464.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2 增加一个配置文件，以便supervisor用来监控程序&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat &amp;gt; /usr/supervisor/supervisord.d/supervisor_test_one.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在新建的supervisor_test_one.conf文件中添加以下配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[program:test_one]
command&lt;/span&gt;=java -jar /data/smallvideo/supervisor/taskApp-&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;.jar TaskTestOne  ; 被监控的进程路径
priority&lt;/span&gt;=1&lt;span&gt;                    ; 数字越高，优先级越高
numprocs&lt;/span&gt;=1&lt;span&gt;                    ; 启动几个进程
autostart&lt;/span&gt;=&lt;span&gt;true                ; 随着supervisord的启动而启动
autorestart&lt;/span&gt;=&lt;span&gt;true              ; 自动重启
startretries&lt;/span&gt;=10&lt;span&gt;               ; 启动失败时的最多重试次数
exitcodes&lt;/span&gt;=&lt;span&gt;0                   ; 正常退出代码
stopsignal&lt;/span&gt;=&lt;span&gt;KILL               ; 用来杀死进程的信号
stopwaitsecs&lt;/span&gt;=10&lt;span&gt;               ; 发送SIGKILL前的等待时间
redirect_stderr&lt;/span&gt;=&lt;span&gt;true          ; 重定向stderr到stdout

[program:test_two]
command&lt;/span&gt;=java -jar /data/smallvideo/supervisor/taskApp-&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;.jar TaskTestTwo   ; 被监控的进程路径
priority&lt;/span&gt;=1&lt;span&gt;                    ; 数字越高，优先级越高
numprocs&lt;/span&gt;=1&lt;span&gt;                    ; 启动几个进程
autostart&lt;/span&gt;=&lt;span&gt;true                ; 随着supervisord的启动而启动
autorestart&lt;/span&gt;=&lt;span&gt;true              ; 自动重启
startretries&lt;/span&gt;=10&lt;span&gt;               ; 启动失败时的最多重试次数
exitcodes&lt;/span&gt;=&lt;span&gt;0                   ; 正常退出代码
stopsignal&lt;/span&gt;=&lt;span&gt;KILL               ; 用来杀死进程的信号
stopwaitsecs&lt;/span&gt;=10&lt;span&gt;               ; 发送SIGKILL前的等待时间
redirect_stderr&lt;/span&gt;=true          ; 重定向stderr到stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3 supervisor配置文件详解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;img id=&quot;code_img_opened_06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
-&lt;span&gt; command：启动程序使用的命令，可以是绝对路径或者相对路径
&lt;/span&gt;- process_name：一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%&lt;span&gt;(program_name)s
&lt;/span&gt;- numprocs：Supervisor启动这个程序的多个实例，如果numprocs&amp;gt;1，则process_name的表达式必须包含%&lt;span&gt;(process_num)s，默认是1
&lt;/span&gt;-&lt;span&gt; numprocs_start：一个int偏移值，当启动实例的时候用来计算numprocs的值
&lt;/span&gt;-&lt;span&gt; priority：权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999
&lt;/span&gt;-&lt;span&gt; autostart：如果设置为true，当supervisord启动的时候，进程会自动重启。
&lt;/span&gt;-&lt;span&gt; autorestart：值可以是false、true、unexpected。false：进程不会自动重启，unexpected：当程序退出时的退出码不是exitcodes中定义的时，进程会重启，true：进程会无条件重启当退出的时候。
&lt;/span&gt;-&lt;span&gt; startsecs：程序启动后等待多长时间后才认为程序启动成功
&lt;/span&gt;-&lt;span&gt; startretries：supervisord尝试启动一个程序时尝试的次数。默认是3
&lt;/span&gt;- exitcodes：一个预期的退出返回码，默认是0,2&lt;span&gt;。
&lt;/span&gt;- stopsignal：当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, &lt;span&gt;or&lt;/span&gt;&lt;span&gt; USR2。
&lt;/span&gt;-&lt;span&gt; stopwaitsecs：在操作系统给supervisord发送SIGCHILD信号时等待的时间
&lt;/span&gt;-&lt;span&gt; stopasgroup：如果设置为true，则会使supervisor发送停止信号到整个进程组
&lt;/span&gt;-&lt;span&gt; killasgroup：如果设置为true，则在给程序发送SIGKILL信号的时候，会发送到整个进程组，它的子进程也会受到影响。
&lt;/span&gt;-&lt;span&gt; user：如果supervisord以root运行，则会使用这个设置用户启动子程序
&lt;/span&gt;-&lt;span&gt; redirect_stderr：如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符。
&lt;/span&gt;-&lt;span&gt; stdout_logfile：把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置。
&lt;/span&gt;-&lt;span&gt; stdout_logfile_maxbytes：标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小
&lt;/span&gt;-&lt;span&gt; stdout_logfile_backups：标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份
&lt;/span&gt;-&lt;span&gt; stdout_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB
&lt;/span&gt;-&lt;span&gt; stdout_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发
&lt;/span&gt;-&lt;span&gt; stderr_logfile：把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true
&lt;/span&gt;-&lt;span&gt; stderr_logfile_maxbytes：错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小
&lt;/span&gt;-&lt;span&gt; stderr_logfile_backups：错误日志轮转备份的数量，默认是10，如果设置为0，则不备份
&lt;/span&gt;-&lt;span&gt; stderr_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB
&lt;/span&gt;-&lt;span&gt; stderr_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发
&lt;/span&gt;- environment：一个k/&lt;span&gt;v对的list列表
&lt;/span&gt;-&lt;span&gt; directory：supervisord在生成子进程的时候会切换到该目录
&lt;/span&gt;-&lt;span&gt; umask：设置进程的umask
&lt;/span&gt;- serverurl：是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;监控demotest程序示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[program:demotest]
command&lt;/span&gt;=python demotest.py 10000&lt;span&gt;  ; 被监控的进程启动命令
directory&lt;/span&gt;=/root/&lt;span&gt;                ; 执行前要不要先cd到目录去，一般不用
priority&lt;/span&gt;=1&lt;span&gt;                    ;数字越高，优先级越高
numprocs&lt;/span&gt;=1&lt;span&gt;                    ; 启动几个进程
autostart&lt;/span&gt;=&lt;span&gt;true                ; 随着supervisord的启动而启动
autorestart&lt;/span&gt;=&lt;span&gt;true              ; 自动重启。。当然要选上了
startretries&lt;/span&gt;=10&lt;span&gt;               ; 启动失败时的最多重试次数
exitcodes&lt;/span&gt;=&lt;span&gt;0                   ; 正常退出代码（是说退出代码是这个时就不再重启了吗？待确定）
stopsignal&lt;/span&gt;=&lt;span&gt;KILL               ; 用来杀死进程的信号
stopwaitsecs&lt;/span&gt;=10&lt;span&gt;               ; 发送SIGKILL前的等待时间
redirect_stderr&lt;/span&gt;=true          ; 重定向stderr到stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.4 重启supervisor&lt;/p&gt;
&lt;p&gt;&lt;code&gt;supervisorctl -c /usr/supervisor/supervisord.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173202998-1323054934.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就可以在http://ip:9001/中访问test_one的程序了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173208594-120360123.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.5 supervisor开机自动启动&lt;/p&gt;
&lt;p&gt;3.5.1 在目录/usr/lib/systemd/system/ 新建文件supervisord.service,并添加配置内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Unit]
Description&lt;/span&gt;=Process Monitoring &lt;span&gt;and&lt;/span&gt;&lt;span&gt; Control Daemon
After&lt;/span&gt;=rc-local.service nss-user-&lt;span&gt;lookup.target

[Service]
Type&lt;/span&gt;=&lt;span&gt;forking
ExecStart&lt;/span&gt;=/usr/bin/supervisord -c /usr/supervisor/&lt;span&gt;supervisord.conf ;开机启动时执行
ExecStop&lt;/span&gt;=/usr/bin/&lt;span&gt;supervisord shutdown
ExecReload&lt;/span&gt;=/usr/bin/&lt;span&gt;supervisord reload
killMode&lt;/span&gt;=&lt;span&gt;process
Restart&lt;/span&gt;=on-&lt;span&gt;failure
RestartSec&lt;/span&gt;=&lt;span&gt;42s

[Install]
WantedBy&lt;/span&gt;=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.5.2 启动服务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl enable supervisord&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.5.3 验证一下是否为开机启动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl is-enabled supervisord&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;Supervisor周边&lt;/h2&gt;
&lt;p&gt;4.1 supervisor常用命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 查看supervisorctl支持的命令&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; supervisorctl help    &lt;/span&gt;
default commands (type help &amp;lt;topic&amp;gt;&lt;span&gt;):
&lt;/span&gt;=====================================&lt;span&gt;
add    exit      open  reload  restart   start   tail   
avail  fg        pid   remove  shutdown  status  update 
clear  maintail  quit  reread  signal    stop    version

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 查看当前运行的进程列表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; supervisorctl status&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;update 更新新的配置到supervisord（不会重启原来已运行的程序）&lt;/p&gt;
&lt;p&gt;reload，载入所有配置文件，并按新的配置启动、管理所有进程（会重启原来已运行的程序）&lt;/p&gt;
&lt;p&gt;start xxx: 启动某个进程&lt;/p&gt;
&lt;p&gt;restart xxx: 重启某个进程&lt;/p&gt;
&lt;p&gt;stop xxx: 停止某一个进程(xxx)，xxx为[program:theprogramname]里配置的值&lt;/p&gt;
&lt;p&gt;stop groupworker: 重启所有属于名为groupworker这个分组的进程(start,restart同理)&lt;/p&gt;
&lt;p&gt;stop all，停止全部进程，注：start、restart、stop都不会载入最新的配置文&lt;/p&gt;
&lt;p&gt;reread，当一个服务由自动启动修改为手动启动时执行一下就ok&lt;/p&gt;
&lt;p&gt;ps:有些版本并不支持supervisorctl ,可以通过&lt;code&gt;supervisorctl -c /usr/supervisor/supervisord.conf&lt;/code&gt;唤起命令，格式如上，实际效果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190422155733101-1728503182.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.2 如果supervisorCPU和内存占用率特别高，导致机器卡死。&lt;/p&gt;
&lt;p&gt;尝试注释掉2.4中的web。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/Supervisor/supervisor/issues/581&quot; target=&quot;_blank&quot;&gt;https://github.com/Supervisor/supervisor/issues/581&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.3 Unlinking stale socket /tmp/supervisor.sock&lt;/p&gt;
&lt;p&gt;解决方案，执行&lt;code&gt;unlink /tmp/supervisor.sock&lt;/code&gt;&lt;/p&gt;

&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 03 May 2019 14:53:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>Supervisor在百度百科上给的定义是超级用户，监管员。Supervisor是一个进程管理工具，当进程中断的时候Supervisor能自动重新启动它。可以运行在各种类unix的机器上，superv</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/supervisor.html</dc:identifier>
</item>
<item>
<title>用例图之间的几种关系 - SSS翱翔万里</title>
<link>http://www.cnblogs.com/SSSzhanglingzhi/p/10806875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SSSzhanglingzhi/p/10806875.html</guid>
<description>&lt;p&gt;&lt;span&gt;用例图之间的几种关系&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;A.解释&lt;/h2&gt;
&lt;p&gt;执行者与执行者之间只有一种关系即继承(也叫泛化)。其意义与面向对象过程中的继承关系类似,但它主要强调子类执行者对父类执行者与用例之间的交互行为的继承。&lt;/p&gt;
&lt;h2&gt;B.表示形式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221355470-1339915234.jpg&quot; alt=&quot;&quot;/&gt;(从子类指向父类)&lt;/p&gt;
&lt;h2&gt;C.核心&lt;/h2&gt;
&lt;p&gt;两个或两个以上执行者之间有共性,共性单独设为一个执行者。&lt;/p&gt;
&lt;h2&gt;D.例子&lt;/h2&gt;
&lt;p&gt;在教务管理系统中,老师、学生、用户之间的关系&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221155715-529854610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解:老师和学生都是用户的子类,所以继承了用户身份验证和注册操作&lt;/p&gt;
&lt;h2&gt;E.有什么用？&lt;/h2&gt;
&lt;p&gt;1.减少代码的冗余量&lt;/p&gt;
&lt;p&gt;2.易于修改&lt;/p&gt;

&lt;h2&gt;A.解释&lt;/h2&gt;
&lt;p&gt;通常来讲,执行者与用例之间的关系都是用无向边表示的(可理解为双向传递信息)&lt;/p&gt;
&lt;h2&gt;B.表现形式&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221409665-596358918.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;C.核心&lt;/h2&gt;
&lt;p&gt;对号入座&lt;/p&gt;
&lt;h2&gt;D.例子&lt;/h2&gt;
&lt;p&gt;管理员与用户身份验证的关系&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221437651-662951712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但也有特殊情况,如下所述&lt;/p&gt;
&lt;p&gt;1．当多个执行者与用例相连时,为了强调某个执行者是主要执行者,就在执行者到用例之间加上一条边。&lt;/p&gt;
&lt;p&gt;2.被动执行者仅从用例获取信息,而不提供信息给用例,那么此时用例到执行者之间就可以连一条有向边。&lt;/p&gt;
&lt;h2&gt;E.有什么用&lt;/h2&gt;
&lt;p&gt;1.使程序整洁了,避免混乱&lt;/p&gt;
&lt;p&gt;2.使软件开发符合要求,难出现缺斤少两的现象。&lt;/p&gt;

&lt;h2&gt;3.1 包含(include)&lt;/h2&gt;
&lt;h3&gt;A.解释&lt;/h3&gt;
&lt;p&gt;A.1一个用例所需要完成的功能是多个互不联系的用例的功能之和,那么它们之间就具备着包含关系。&lt;/p&gt;
&lt;p&gt;A,2多个用例之间具有共性,就需要把共性提取出来作为一个新的用例,此时新用例与原来的多个用例之间就具备了包含关系。&lt;/p&gt;
&lt;h3&gt;B.表现形式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221603760-335141163.jpg&quot; alt=&quot;&quot;/&gt;(指向包含的用例)&lt;/p&gt;
&lt;h3&gt;C.核心&lt;/h3&gt;
&lt;p&gt;对于不同用例而言,提取公共子函数,在登录教务管理系统中,老师和学生都包含着身份信息验证这个用例。&lt;/p&gt;
&lt;p&gt;对于某一个用例而言,可以采用拆分法,不断拆分成小的用例。如管理图书信息这个用例&lt;/p&gt;
&lt;h3&gt;D.例子&lt;/h3&gt;
&lt;p&gt;图书管理系统中,管理图书信息这个用例就包含增加图书信息,删除图书信息,修改图书信息,查询图书信息四个子用例&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221624196-598855885.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;E.有什么用?&lt;/h3&gt;
&lt;p&gt;1.方便软件开发人员开发出软件需的功能&lt;/p&gt;
&lt;p&gt;2.能使客户更好的表达自己的观点(错则改正)。&lt;/p&gt;
&lt;h2&gt;3.2 扩展(extend)&lt;/h2&gt;
&lt;h3&gt;A,解释&lt;/h3&gt;
&lt;p&gt;通俗点来说就是倒霉到家了,碰到了千万分之一概率的异常情况,如火车晚点3小时。&lt;/p&gt;
&lt;h3&gt;B.表现形式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221657106-648103675.jpg&quot; alt=&quot;&quot;/&gt;（指向被扩展的用例）&lt;/p&gt;
&lt;h3&gt;C.核心&lt;/h3&gt;
&lt;p&gt;异常情况&lt;/p&gt;
&lt;h3&gt;D.例子&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;在用户身份验证这一用例中,只要输入账户和密码就可以登录这个网站了。但有一种特殊情况是用户忘记了密码,此时就需找回密码,而找回密码很显然可以作为一个单独的用例。那么它就相当于在用户身份验证这个用例下的一种异常情况，所以用户身份验证与找回密码是扩展关系&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221710380-347525290.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;E.有什么用&lt;/h3&gt;
&lt;p&gt;1.提高程序的安全性&lt;/p&gt;
&lt;p&gt;2.减少程序的维护成本(因为不怕异常)&lt;/p&gt;
&lt;h2&gt;3.3 继承&lt;/h2&gt;
&lt;h3&gt;A.解释&lt;/h3&gt;
&lt;p&gt;同执行者与执行者之间的关系类似,只需把执行者变成用例就可以得到其解释。&lt;/p&gt;
&lt;h3&gt;B.表现形式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221722225-418186682.jpg&quot; alt=&quot;&quot;/&gt;（指向父类）&lt;/p&gt;
&lt;h3&gt;C.核心&lt;/h3&gt;
&lt;p&gt;子类继承了父类的所有非私有属性和方法,但与父类不同的是它在自己的基础上增加了一些新的东西.&lt;/p&gt;
&lt;h3&gt;D.例子&lt;/h3&gt;
&lt;p&gt;蒙牛公司下的产品——特仑苏是继承蒙牛的草场和资金,但他新的地方在于广告效应深远和牛奶的质量好&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221857446-387013836.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;E.有什么用?&lt;/h3&gt;
&lt;p&gt;同执行者与执行者之间的关系(泛化)。&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 14:33:00 +0000</pubDate>
<dc:creator>SSS翱翔万里</dc:creator>
<og:description>用例图之间的几种关系 1. 执行者与执行者之间的唯一关系(继承) A.解释 执行者与执行者之间只有一种关系即继承(也叫泛化)。其意义与面向对象过程中的继承关系类似,但它主要强调子类执行者对父类执行者与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SSSzhanglingzhi/p/10806875.html</dc:identifier>
</item>
<item>
<title>RabbitMQ Node.js 示例 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/rabbitmq_nodejs_example.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/rabbitmq_nodejs_example.html</guid>
<description>&lt;p&gt;RabbitQM 处理和管理消息队列的中间人（broker）。可简单理解为邮局，你在程序中写好消息，指定好收件人，剩下的事件就是 RabbitMQ 的工作了，它会保证收件人正确收到邮件。&lt;/p&gt;
&lt;p&gt;任何发送邮件的程序都是 &lt;code&gt;Producer&lt;/code&gt;，消息队列可理解为邮筒，新件将堆积在此处。所有待处理的消息都以队列形式存储，总体上看来就是一个巨大的消息 buffer，至于存储量与设置的内存及硬件有关。任何应用都可以向队列添加消息，也可以多个消费者都在从队列中获取消息。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;consumer&lt;/code&gt; 即是消息队列中消息的应用，其处于等待接收来自 RabbitMQ 发送来的消息。&lt;/p&gt;
&lt;p&gt;消息生产者，消费者及 RabbitMQ 这个中间人三者不必同时存在于同一机器上，实际运用时也确实大部分不会部署在同一机器上，比如有专门的机器作为 RabbitMQ 实体，而应用程序会部署在其他的集群。应用程序可以是同时负责生产消息的，也同时是消费者。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/45330b63e7453cfb9017628fc29745c89073b097/68747470733a2f2f7777772e7261626269746d712e636f6d2f696d672f7475746f7269616c732f707974686f6e2d6f6e652e706e67&quot;&gt;&lt;img alt=&quot;来自官方文档中关于 RabbitMQ 消息列队的示意图&quot; src=&quot;https://camo.githubusercontent.com/45330b63e7453cfb9017628fc29745c89073b097/68747470733a2f2f7777772e7261626269746d712e636f6d2f696d672f7475746f7269616c732f707974686f6e2d6f6e652e706e67&quot; data-canonical-src=&quot;https://www.rabbitmq.com/img/tutorials/python-one.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;来自官方文档中关于 RabbitMQ 消息列队的示意图&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;通过&lt;a href=&quot;https://www.rabbitmq.com/download.html&quot; rel=&quot;nofollow&quot;&gt;官网提供的地址&lt;/a&gt;下载相应平台的程序进行安装，Mac 可通过 &lt;a href=&quot;https://www.rabbitmq.com/install-homebrew.html&quot; rel=&quot;nofollow&quot;&gt;Homebrew 进行安装&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ brew update &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; brew install rabbitmq
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;启动&lt;/h2&gt;
&lt;p&gt;如果使用 Homebrew 安装，可通过 &lt;code&gt;brew services start rabbitmq&lt;/code&gt; 命令来启动 RabbitMQ 服务。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ brew services start rabbitmq
==&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; Successfully started &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;rabbitmq&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; (label: homebrew.mxcl.rabbitmq)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或直接运行 &lt;code&gt;/usr/local/sbin/rabbitmq-server&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;启动后，会有一个可视化的管理后台，可通过 &lt;a rel=&quot;nofollow&quot; href=&quot;http://localhost:15672/&quot;&gt;http://localhost:15672/&lt;/a&gt; 访问，用户名密码皆为 &lt;code&gt;guest&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;基于 Node.js 的 Hello World 示例&lt;/h2&gt;
&lt;p&gt;通过 &lt;a href=&quot;https://github.com/squaremo/amqp.node&quot;&gt;amqp.node&lt;/a&gt; 展示 RabbitMQ 在 Node.js 中应用的一个示例。&lt;/p&gt;
&lt;p&gt;RabbmitMQ 支持多种协议进行通信，amqp.node 使用的是 AMQP 0-9-1 这一开源协议，后者专门为处理消息而设计。作为客户端消费消息，使用的是 &lt;a href=&quot;http://www.squaremobius.net/amqp.node/&quot; rel=&quot;nofollow&quot;&gt;amqp.node client&lt;/a&gt; 模块，但 RabbitMQ 本身是支持多种&lt;a href=&quot;http://rabbitmq.com/devtools.html&quot; rel=&quot;nofollow&quot;&gt;客户端&lt;/a&gt;的。&lt;/p&gt;
&lt;p&gt;初始化一个 Node,js 项目然后通过以下命令安装 amqp.node 模块：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mkdir rabbitmq-demo &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; yarn init -y
$ yarn add amqplib
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;发送消息&lt;/h3&gt;
&lt;p&gt;创建 &lt;code&gt;send.js&lt;/code&gt; 文件，在其中编写发送消息的逻辑，它将连接到 RabbitMQ 发送消息然后退出。&lt;/p&gt;
&lt;p&gt;首先建立到 RabbitMQ 服务的连接，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;#!/usr/bin/env node&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; amqp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqplib/callback_api&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连接建立成功后，创建一个通道（channel），具体的发送将会在这个通道中进行。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
  }
  &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {});
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送消息前，需要先声明一个队列，然后将消息发送到该队列：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
  }
  &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error1) {
      &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error1;
    }
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; msg &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Hello world&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

    &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assertQueue&lt;/span&gt;(queue, {
      durable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
    });

    &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;sendToQueue&lt;/span&gt;(queue, &lt;span class=&quot;pl-smi&quot;&gt;Buffer&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;from&lt;/span&gt;(msg));
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [x] Sent %s&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, msg);
  });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;队列的创建是一个&lt;a href=&quot;https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation&quot; rel=&quot;nofollow&quot;&gt;幂等操作&lt;/a&gt;，只该队列不存在的情况才会新建。&lt;/p&gt;
&lt;p&gt;最后关闭连接并退出。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;close&lt;/span&gt;();
    &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);
}, &lt;span class=&quot;pl-c1&quot;&gt;500&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;details readability=&quot;6&quot;&gt;完整的 send.js
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;#!/usr/bin/env node&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; amqp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqplib/callback_api&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
        &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
    }
    &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error1) {
            &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error1;
        }

        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;
        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; msg &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Hello World!&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

        &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assertQueue&lt;/span&gt;(queue, {
            durable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
        });
        &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;sendToQueue&lt;/span&gt;(queue, &lt;span class=&quot;pl-smi&quot;&gt;Buffer&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;from&lt;/span&gt;(msg));

        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [x] Sent %s&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, msg);
    });
    &lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
        &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);
    }, &lt;span class=&quot;pl-c1&quot;&gt;500&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;h3&gt;接收消息&lt;/h3&gt;
&lt;p&gt;下面开始编写消费者，消费者做的事情是监听来自 RabbitMQ 的消息并处理。&lt;/p&gt;
&lt;p&gt;创建 &lt;code&gt;receive.js&lt;/code&gt;，引入 amqp.node 模块，流程和发送者一样，也是先创建连接，然后创建通道，在通道中声明需要监听的队列：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;#!/usr/bin/env node&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; amqp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqplib/callback_api&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
  }
  &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error1) {
      &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error1;
    }
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

    &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assertQueue&lt;/span&gt;(queue, {
      durable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
    });
  });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的队列声明不会与发送者那边的冲突，因为上面提到过，队列只在不存在的情况下才会重新生成。这里再次声明可以保证监听前队列已经存在。并且实际场景下，消费者有可能是在发送者之前启动的。&lt;/p&gt;
&lt;p&gt;然后添加监听的逻辑：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
 &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [*] Waiting for messages in %s. To exit press CTRL+C&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, queue);

&lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;consume&lt;/span&gt;(queue, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;msg&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [x] Received %s&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;msg&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;content&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toString&lt;/span&gt;());
}, {
    noAck&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;details readability=&quot;6.5&quot;&gt;完整的 receive.js
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
#&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;pl-sr&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;/&lt;/span&gt;usr&lt;span class=&quot;pl-pds&quot;&gt;/&lt;/span&gt;&lt;/span&gt;bin&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;env node

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; amqp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqplib/callback_api&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
        &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
    }
    &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error1) {
            &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error1;
        }

        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

        &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assertQueue&lt;/span&gt;(queue, {
            durable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
        });

        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [*] Waiting for messages in %s. To exit press CTRL+C&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, queue);

        &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;consume&lt;/span&gt;(queue, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;msg&lt;/span&gt;) {
            &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [x] Received %s&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;msg&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;content&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toString&lt;/span&gt;());
        }, {
            noAck&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
        });
    });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;h3&gt;运行&lt;/h3&gt;
&lt;p&gt;分别在命令行启动上面两个程序，查看打印的信息。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ node send.js
 [x] Sent Hello World&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;

$ node receive.js
 [&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;] Waiting &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;messages&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; hello. To &lt;span class=&quot;pl-c1&quot;&gt;exit&lt;/span&gt; press CTRL+C
 [x] Received Hello World&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，可通过 &lt;code&gt;sudo rabbitmqctl list_queues&lt;/code&gt; 手动查看 RabbitMQ 中的消息。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ /usr/local/sbin/rabbitmqctl list_queues
Timeout: 60.0 seconds ...
Listing queues &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; vhost / ...
name    messages
hello   0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果发现 &lt;code&gt;rabbitmqctl&lt;/code&gt; 命令不可用，需要添加 &lt;code&gt;/usr/local/sbin&lt;/code&gt; 到环境变量中，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; PATH=/usr/local/sbin:&lt;span class=&quot;pl-smi&quot;&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 fish shell 通过添加如下命令到 fish 的配置文件即可：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; -gx PATH /usr/local/sbin &lt;span class=&quot;pl-smi&quot;&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Fri, 03 May 2019 14:33:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>RabbitQM 处理和管理消息队列的中间人（broker）。可简单理解为邮局，你在程序中写好消息，指定好收件人，剩下的事件就是 RabbitMQ 的工作了，它会保证收件人正确收到邮件。 任何发送邮件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/rabbitmq_nodejs_example.html</dc:identifier>
</item>
<item>
<title>订阅发布模式和观察者模式真的不一样 - 一像素</title>
<link>http://www.cnblogs.com/onepixel/p/10806891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onepixel/p/10806891.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;1、观察者模式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。&lt;/p&gt;
&lt;p&gt;观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、订阅-发布模式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;其实24种基本的设计模式中并没有发布订阅模式，上面也说了，他只是观察者模式的一个别称。&lt;/p&gt;
&lt;p&gt;但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。&lt;/p&gt;
&lt;p&gt;在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。&lt;/p&gt;
&lt;p&gt;举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、两种模式的区别&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们先来看下这两个模式的实现结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/849589/201904/849589-20190424122505055-2083728728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，发布订阅模式相比观察者模式多了个事件通道，事件通道作为调度中心，管理事件的订阅和发布工作，彻底隔绝了订阅者和发布者的依赖关系。即订阅者在订阅事件的时候，只关注事件本身，而不关心谁会发布这个事件；发布者在发布事件的时候，只关注事件本身，而不关心谁订阅了这个事件。&lt;/p&gt;
&lt;p&gt;观察者模式有两个重要的角色，即目标和观察者。在目标和观察者之间是没有事件通道的。一方面，观察者要想订阅目标事件，由于没有事件通道，因此必须将自己添加到目标(Subject) 中进行管理；另一方面，目标在触发事件的时候，也无法将通知操作(notify) 委托给事件通道，因此只能亲自去通知所有的观察者。&lt;/p&gt;
&lt;p&gt;我们再来看一下这两个模式的代码实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;订阅-发布模式&lt;/strong&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class PubSub {
    constructor() {
        this.subscribers = [];
    }
    
    subscribe(topic, callback) {
        let callbacks = this.subscribers[topic];
        if (!callbacks) {
            this.subscribers[topic] = [callback];
        } else {
            callbacks.push(callback);
        }
    }
    
    publish(topic, ...args) {
        let callbacks = this.subscribers[topic] || [];
        callbacks.forEach(callback =&amp;gt; callback(...args));
    }
}

// 创建事件调度中心，为订阅者和发布者提供调度服务
let pubSub = new PubSub();
// A订阅了SMS事件（A只关注SMS本身，而不关心谁发布这个事件）
pubSub.subscribe('SMS', console.log);
// B订阅了SMS事件
pubSub.subscribe('SMS', console.log);
// C发布了SMS事件（C只关注SMS本身，不关心谁订阅了这个事件）
pubSub.publish('SMS', 'I published `SMS` event');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Subject {
    constructor() {
        this.observers = [];
    }

    add(observer) {
        this.observers.push(observer);
    }

    notify(...args) {
        this.observers.forEach(observer =&amp;gt; observer.update(...args));
    }
}

class Observer {
    update(...args) {
        console.log(...args);
    }
}

// 创建观察者ob1
let ob1 = new Observer();
// 创建观察者ob2
let ob2 = new Observer();
// 创建目标sub
let sub = new Subject();
// 目标sub添加观察者ob1 （目标和观察者建立了依赖关系）
sub.add(ob1);
// 目标sub添加观察者ob2
sub.add(ob2);
// 目标sub触发SMS事件（目标主动通知观察者）
sub.notify('I fired `SMS` event');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码实现可以看出，发布-订阅模式是面向调度中心编程的，而观察者模式则是面向目标和观察者编程的。前者用于解耦发布者和订阅者，后者用于耦合目标和观察者，不可同日而语也~&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;[1]  &lt;a href=&quot;https://blog.csdn.net/hf872914334/article/details/88899326&quot; target=&quot;_blank&quot;&gt;发布订阅模式与观察者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]  &lt;a href=&quot;https://www.jianshu.com/p/f0f22398d25d&quot; target=&quot;_blank&quot;&gt;重学JS（九）—— 观察者模式和发布/订阅模式真不一样&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 14:28:00 +0000</pubDate>
<dc:creator>一像素</dc:creator>
<og:description>1、观察者模式 观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onepixel/p/10806891.html</dc:identifier>
</item>
<item>
<title>Java设计模式 - - 单例模式 装饰者模式 - StanleyBlogs</title>
<link>http://www.cnblogs.com/StanleyBlogs/p/10806876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StanleyBlogs/p/10806876.html</guid>
<description>&lt;p&gt;作者 ： Stanley 罗昊&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;转载请注明出处和署名，谢谢！&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;静态代理模式：https://www.cnblogs.com/StanleyBlogs/p/10761604.html&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;什么是设计模式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;设计模式其实就是是写了很多代码的人总结出来的经验！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设计模式是关于一些问题的最佳解决方案；&lt;/p&gt;
&lt;p&gt;也就是说，每一个典型的问题，关于一个典型的问题，他都会总结出来一个最佳的解决方案；&lt;/p&gt;
&lt;p&gt;就比方说医生问诊：&lt;/p&gt;
&lt;p&gt;你挂不同的科室，也就是不同的医生，每个医生都有自己擅长并拿手的治疗方案，关于某一个疾病都有自己独特的解决方案；&lt;/p&gt;
&lt;p&gt;设计模式其实也一样，就是通过大量的代码总结出来的一些问题的最佳解决办法；&lt;/p&gt;
&lt;p&gt;Java的设计模式&lt;span&gt;&lt;strong&gt;一共有23种&lt;/strong&gt;&lt;/span&gt;设计模式；&lt;/p&gt;
&lt;p&gt;在这23种设计模式中，你仅掌握3~4种设计模式即可，&lt;span&gt;&lt;strong&gt;并且要求能够手写出来&lt;/strong&gt;&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;23种设计模式并分为三大类：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.创建型模式【五种】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.结构型模式【七种】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.行为型模式【十一种】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;设计模式 -- 六大设计原则&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总原则：开闭原则（Open Close Princciple）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对修改关闭，对扩展开放，所有的设计模式都必须遵循这个原则！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，所有的设计模式，你可以扩展它的功能，但是不可以修改它原始的功能；&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;六大小原则：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.单一职责原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.里氏替换原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里氏替换原则中，子类对父类的方法尽量不要重写和重载，因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.依赖倒转原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个原则的意思四，每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多张个隔离的接口，比使用单个接口（多个几口方法结合到一个的接口）更好；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.迪米特法则（最少知道原则）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是说，一个类对自己的依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部，这样当被依赖的类变化时，才能量最小的影响该类；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.复合重用原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽量首先使用合成/聚合的方式，而不是使用继承的方式；&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;单例设计模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;单例设计模式是最简单的设计模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目的：创建全局唯一的实例对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.饿汉模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在类加载的时候，就创建一个对象，因为就比较饿嘛，上来就创建对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.懒汉模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要的时候才创建，因为比较懒，你不拿鞭子抽它，他就不动；&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;手写单例设计模式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;下面呢，我将创建一个类，这个类，我就把它搞成一个单例设计模式；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单例设计模式有三点，第一点：私有的构造器；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                   第二点：私有的静态属性，并且变量类型与类同名；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                   第三点：共有的创建实例对象的方法（那我这个方法返回的肯定是一个SingleDemo01类型）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;标准的线程安全的单例模式：&lt;/p&gt;
&lt;p&gt;public &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SingleDemo01{&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.私有的构造器&lt;/span&gt;

&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SingleDemo01(){}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.私有的静态属性&lt;/span&gt;

&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SingleDemo01 single;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.公有的创建实例对象的方法&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SingleDemo01getInstance(){

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(single == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2个线程&lt;/span&gt;

&lt;span&gt;synchronized&lt;/span&gt;(SingleDemo01.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(single == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){

single &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingleDemo01();

}

}
return single;
}&lt;br/&gt;}&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;装饰者模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;当你需要对某一个类的某一个功能进行增强的时候，就要用到装饰者模式；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面就举一些例子来完成对装饰者模式的认知：&lt;/p&gt;
&lt;p&gt;我现在想对list集合中的add方法进行增强，在添加元素时打印一句“开始添加元素”，添加完成后再打印一句“元素添加完成”；&lt;/p&gt;
&lt;p&gt;我们看到以上需求，我们本次采用装饰者模式去实现，去实现之前呢需要注意两点：&lt;/p&gt;
&lt;p&gt;1.将要装饰的或包装的类，作为增强类的属性&lt;/p&gt;
&lt;p&gt;2.需要实现增强功能&lt;/p&gt;
&lt;p&gt;具体实现过程：&lt;/p&gt;
&lt;p&gt;首先，我们先定义一个类，叫MyList；&lt;/p&gt;
&lt;p&gt;我现在要加强List的add方法，那么首先我就需要让list作为我的成员属性；&lt;/p&gt;
&lt;p&gt;定义好一个list泛型类型的属性后，我们需要对它进行赋值，所以我们就再给它提供一个构造函数；&lt;/p&gt;
&lt;p&gt;之后呢，我们在类中写一个带参的add方法，那我现在这个add方法是不是就是要对原始的add方法进行增强了；&lt;/p&gt;
&lt;p&gt;编码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList｛

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt;list;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyList(List&amp;lt;String&amp;gt;&lt;span&gt;list){

&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;

}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add (String e){

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加之前输出一句&lt;/span&gt;
&lt;span&gt;
System.out.println(&lt;/span&gt;&quot;start。。。。。。。。。。&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;
&lt;span&gt;
list.add(e);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加之后再输出一句&lt;/span&gt;
&lt;span&gt;
System.out.println(&lt;/span&gt;&quot;end。。。。。。。。。。&quot;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个就是装饰者模式，某类中的某一个方法进行增强&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写一个main方法进行测试&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main (String[] args){

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先建立一个list集合&lt;/span&gt;
&lt;span&gt;
List&lt;/span&gt;&amp;lt;String&amp;gt;list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;list集合建完之后，我是不是就再建一个Mylist直接把值穿进去是不是就可以了&lt;/span&gt;
&lt;span&gt;
MyList my &lt;/span&gt;=&lt;span&gt; newMyList(list);

my.add(&lt;/span&gt;&quot;ss&quot;&lt;span&gt;);

}

｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190503220906385-1073522790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们看到执行结果，是不是已经按照要求增强了；&lt;/p&gt;
&lt;p&gt;这个时候我们还可以继续改进；&lt;/p&gt;
&lt;p&gt;改造成只能添加含有start的元素；&lt;/p&gt;
&lt;p&gt;我们仅需加一个if判断即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList｛

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt;list;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyList(List&amp;lt;String&amp;gt;&lt;span&gt;list){

&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;

}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add (String e){

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加之前输出一句&lt;/span&gt;
&lt;span&gt;
System.out.println(&lt;/span&gt;&quot;start。。。。。。。。。。&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt;(e.contains(&quot;start&quot;)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里我们加了一个判断，表示判断添加进来的元素是否包含start，如果不包含就不进入该方法，也就意味着元素没添加进去&lt;/span&gt;
&lt;span&gt;
list.add(e);

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;
&lt;span&gt;
list.add(e);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加之后再输出一句&lt;/span&gt;
&lt;span&gt;
System.out.println(&lt;/span&gt;&quot;end。。。。。。。。。。&quot;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 03 May 2019 14:21:00 +0000</pubDate>
<dc:creator>StanleyBlogs</dc:creator>
<og:description>Java设计模式 单例模式 装饰者模式 作者 ： Stanley 罗昊 【转载请注明出处和署名，谢谢！】 静态代理模式：https://www.cnblogs.com/StanleyBlogs/p/1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StanleyBlogs/p/10806876.html</dc:identifier>
</item>
<item>
<title>SpringBoot之旅第七篇-Docker - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10806069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10806069.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;记得上大三时，要给微机房电脑安装系统，除了原生的操作系统外，还要另外安装一些必要的开发软件，如果每台电脑都重新去安装的话工作量就很大了，这个时候就使用了windows镜像系统，我们将要安装的软件装好打包成一个镜像，其他电脑只要装这个镜像就可以了，这样工作量就减少了很多。Docker跟这个镜像并不是一回事，但是思想是相同的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们在一台服务器中下载、安装、配置好Mysql，在另外一台服务器中又得重新下载、安装、配置，这样很麻烦也容易出现一些错误。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个时候Docker就派上用场了，我们可以将安装配置好的软件打包成一个镜像，然后其他的服务器中只要安装了Docker，就可以运行镜像，运行成功后的镜像我们称为容器，每个容器之间使用了沙箱隔离机制，这就是Docker的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Docker是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker是一个轻量级容器技术，它不是一个虚拟机技术，却实现了虚拟机技术的资源隔离，而且他的性能要比虚拟机技术高。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像。运行中的这个镜像称为容器，容器启动是非常快速的。类似windows里面的ghost操作系统，安装好后什么都有了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503203737123-1662643528.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 class=&quot;md-end-block&quot;&gt;&lt;span&gt;二、&lt;/span&gt;核心概念&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;先学习几个核心概念&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;客户端(Client)：连接docker主机进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;仓库(Registry)：用来保存各种打包好的软件镜像（包括公共仓库和私有仓库）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;镜像(Images)：软件打包好的镜像，放在docker仓库中。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;容器(Container)：镜像启动后的实例称为一个容器，容器是独立运行的一个或一组应用。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们使用Docker只需要按照以下步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;安装Docker。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;去Docker仓库找到这个软件对应的镜像。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用Docker运行这个镜像，这个镜像就会生成一个Docker容器。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;对容器的启动停止就是对软件的启动停止&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;md-list-item&quot;&gt;&lt;span&gt;三、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;安装Docker&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;接下来我们来在Linux安装Docker,首先我们必须先安装好Linux虚拟机，这个在此不赘述了，我们直接从安装Docker开始，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先我们要检查内核版本，命令为：uname -r，必须是3.10及以上，然后就按照步骤进行安装：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;安装： yum install docker 中间有一个确认操作，按y确定&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;启动：systemctl start docker。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;查看版本：docker -v。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;设置开机启动：systemctl enable docker。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关闭：systemctl stop docker。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;一般正常安装不会有问题，如有问题，百度一下也能解决。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block&quot;&gt;&lt;span&gt;四、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;常用操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;安装完成之后我们来学习下常用的操作&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;4.1 镜像操作&lt;/span&gt;&lt;/h3&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;检索：docker search 关键字，例：docker search mysql&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503190749584-1847931463.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里的搜索其实是去&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;https://hub.docker.com/&lt;/a&gt; 中进行搜索，我们也可以去这里直接进行搜索。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;2&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;拉取：&lt;strong&gt;docker pull&lt;/strong&gt; 镜像名:tag （:tag是可选的，tag表示标签，多为软件的版本，默认是latest） 搜索完成之后，我们可以对我们想要的镜像进行拉取,&lt;span&gt;&lt;span&gt;例：docker pull mysql&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-list-item&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503190841682-2037874998.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/1556860213857.png&quot;&gt;之前没使用国内镜像加速，下载了半个小时还没完成，建议使用镜像加速器，我使用的是阿里云的，直接注册后，按照教程使用即可&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://cr.console.aliyun.com/&quot;&gt;https://cr.console.aliyun.com/&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;3&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;列表：&lt;strong&gt;docker images &lt;/strong&gt;安装完成之后使用命令  查看已下载的镜像&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503190911143-100511386.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;       4.删除：docker rmi image-id 删除不要的镜像，image-id 对应相关镜像ID&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;4.2 容器操作&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;镜像下载成功后，我们可以开始进行容器操作，为了方便演示，我们再下载tomcat的镜像：docker pull tomcat&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503191109351-1248666809.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/1556878231102.png&quot;&gt;下面我们对容器进行操作:&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;-1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;运行: docker run &lt;span&gt;&lt;strong&gt;--name&lt;/strong&gt; &lt;span&gt;container-name &lt;span&gt;&lt;strong&gt;-d&lt;/strong&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;image-name&lt;/strong&gt; &lt;span&gt;其中name 参数是我们自定义容器名 -d 指后台运行，image-name 是镜像名称，例：docker run --name mytomcat -d tomcat:late&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-list-item&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503191639950-1494414119.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        2. 查看运行镜像列表：docker ps ，运行成功后面可以通过命令查看，这个命令只查看正在运行的容器&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503191158479-419830553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;3&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;停止：docker stop 容器的id ，例：docker stop 43e2182aceec&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ol-list&quot; start=&quot;4&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;查看所有镜像列表：docker ps -a&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-list-item&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503191237222-2027148045.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;5&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;启动镜像：docker start 容器的id 例：docker start 43e2182aceec&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ol-list&quot; start=&quot;6&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;删除镜像：docker rm 容器的id 例：docker rm 43e2182aceec&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;3&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;启动一个做了端口映射的tomcat： 启动的整体命令相同，需要加上一个 -p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口,例：docker run --name mytomcat -d -p 8888:8080 tomcat:latest ，这个时候我们将主机的端口号与容器端口映射，这样才能在外部直接访问。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190503191316346-859553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        8. 查看容器日志：docker logs 容器的id 例：docker logs fc5b1c7c31bb&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这是一些基础命令，想要学习更多的命令请访问：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/docker/&quot;&gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 13:55:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 记得上大三时，要给微机房电脑安装系统，除了原生的操作系统外，还要另外安装一些必要的开发软件，如果每台电脑都重新去安装的话工作量就很大了，这个时候就使用了windows镜像系统，我们将要安装的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10806069.html</dc:identifier>
</item>
<item>
<title>2.1：CGPROGRAM - Li_F</title>
<link>http://www.cnblogs.com/Li-F/p/10806798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Li-F/p/10806798.html</guid>
<description>&lt;p&gt;经过前面两个章节的铺垫，我们对渲染以及Unity Shaderlab相关的知识已经有了大概的认识，接下来将要学习的就是Shader最重要的部分，&lt;strong&gt;SL（Shader Language）&lt;/strong&gt;，着色器语言。目前主流的着色器语言有HLSL，GLSL，Cg。三者在语法上也有诸多共通之处，选择一种学习即可。而在Unity中，主流是选择Cg作为着色器语言。在Shader编写的过程中，我们会经常穿梭在各个空间中，这里不对3D数学部分的前置知识作介绍，相关知识可从前面章节推荐的书籍学习。&lt;/p&gt;
&lt;p&gt;在Shaderlab中，有三种着色器的书写方式。一种是Fixed-Function Shader，固定管线着色器。在这个着色器中，我们只能对渲染进行少量的配置，效果也很有限，在Unity 5.x之后的版本，Unity弃用了这种着色器。第二种是Surface Shader，表面着色器，这是Unity为我们提供的一种便于书写的方式，我们可以通过少量的代码，控制光照阴影等繁复的细节由Unity帮我们处理。新建一个Standard Surface Shader，可以看到里面只有50余行代码，但它包含了所有基础实现。最后一种，是Vertex/Fragment Shader，顶点/片元着色器，这是实现各种天马行空想象的最佳场所，当然，它的代码量以及复杂度也是最高的。而前两种shader也会被编译成对应的Vertex/Fragment Shader。这三种书写方式，都是在.shader文件中进行，组织方式上也是极为相似的。&lt;/p&gt;
&lt;p&gt;这个系列的重点是Vertex/Fragment Shader。&lt;/p&gt;

&lt;p&gt;以之前模板的代码作为例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Shader &quot;Blog/Start&quot; {

    Properties {
        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {}
        _Color (&quot;Color&quot;, Color) = (1, 1, 1, 1)
    }

    SubShader {
        CGINCLUDE
        #include &quot;UnityCG.cginc&quot;

        sampler2D _MainTex;
        float4 _MainTex_ST;
        fixed4 _Color;

        struct a2v {
            float4 vertex : POSITION;
            float2 texcoord : TEXCOORD0;
        };

        struct v2f {
            float4 pos : SV_POSITION;
            float2 uv : TEXCOORD0;
        };

        v2f vert(a2v v) {
            v2f o;
            o.pos = UnityObjectToClipPos(v.vertex);
            o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
            return o;
        }

        fixed4 frag(v2f i) : SV_Target {
            fixed4 color;
            color = tex2D(_MainTex, i.uv);
            color *= _Color;
            return color;
        }
        ENDCG

        Pass {

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            ENDCG
        }
    }

    FallBack &quot;Diffuse&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个Shader中，出现了两个不同的代码块。首先第一个是CGINCLUDE代码块，它可以被放置在任何位置，甚至是整个Shader代码块的外部。在这个代码块中，我们可以编写那些需要重用的代码（如顶点着色器或片元着色器）。然后是CGPROGRAM代码块。这个代码块需要放在Pass块内，否则编译器会把这个Shader当成Surface Shader转而去检索&lt;code&gt;surf()&lt;/code&gt;函数进而引起报错。这个代码块也是定义Vertex/Fragment Shader的地方。要保证，每个Pass都有且只有一个Vertex Shader和Fragment Shader。这两个Shader通过&lt;code&gt;#pragma&lt;/code&gt;编译命令指定。接着是两个结构体：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct a2v {
    float4 vertex : POSITION;
    float2 texcoord : TEXCOORD0;
};

struct v2f {
    float4 pos : SV_POSITION;
    float2 uv : TEXCOORD0;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个是顶点着色器的输入结构体，a2v即Application To Vertex（应用阶段到顶点着色），在每一个变量的后面都跟了一个冒号说明，冒号后的是这个变量的&lt;strong&gt;Semantic（语义）&lt;/strong&gt;，语义是和GPU通信的桥梁，告诉GPU在这个变量中填充什么数据。&lt;code&gt;float4 vertex : POSITION;&lt;/code&gt;告诉GPU，把顶点数据的POSITION（模型空间下的顶点坐标）输入到vertex变量中，&lt;code&gt;float2 texcoord : TEXCOORD0;&lt;/code&gt;的意思是，把纹理坐标集0给texcoord变量使用。在着色器之间的数据传递都是艺考语义实现的，使用结构体只是为了代码组织更有条理。&lt;/p&gt;
&lt;p&gt;v2f即Vertex To Fragment，这是顶点着色器的输出结构体，也是片元着色器的输入结构体。&lt;code&gt;float4 pos : SV_POSITION;&lt;/code&gt;：SV指System Value，带有SV前缀的语义在管线中都有特殊的含义，SV_POSITION的含义是裁剪空间下的坐标。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;为什么输出裁剪空间下的顶点坐标？&lt;/p&gt;
&lt;p&gt;因为这个坐标接下来用于片元着色器，片元着色器需要的是光栅化后的坐标，也就是裁剪空间的坐标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后是顶点着色器部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;v2f vert(a2v v) {
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
    return o;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只是做里简单的空间变换以及纹理映射。既然需要的是裁剪空间的坐标，那直接把输入的顶点坐标变换到裁剪空间即可。&lt;code&gt;UnityObjectToClipPos()&lt;/code&gt;是Unity为我们提供的坐标空间转换函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Tranforms position from object to homogenous space
inline float4 UnityObjectToClipPos(in float3 pos)
{
#if defined(STEREO_CUBEMAP_RENDER_ON)
    return UnityObjectToClipPosODS(pos);
#else
    // More efficient than computing M*VP matrix product
    return mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, float4(pos, 1.0)));
#endif
}
inline float4 UnityObjectToClipPos(float4 pos) // overload for float4; avoids &quot;implicit truncation&quot; warning for existing shaders
{
    return UnityObjectToClipPos(pos.xyz);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这个函数处理了一些差别并重载了两个版本，但本质上，都是MVP矩阵右乘顶点坐标的列向量形式。然后是&lt;code&gt;TRANSFORM_TEX&lt;/code&gt;宏。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Transforms 2D UV by scale/bias property
#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这个宏计算了顶点对应的纹理采样位置，计算方式也对应了我们之前说到的_ST(Scale &amp;amp; Tiling，纹理缩放和偏移)相关知识点。然后是片元着色器部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fixed4 frag(v2f i) : SV_Target {
    fixed4 color;
    color = tex2D(_MainTex, i.uv);
    color *= _Color;
    return color;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;片元着色器的最终目的是确定片元的像素颜色，即一个RGBA值。首先注意到的是SV_Target，它的语义是：这个着色器只返回一个值，这个值也就是片元的像素颜色值。此外，片元着色器还可以返回多个颜色，这时我们需要用到&lt;code&gt;SV_TargetN&lt;/code&gt;语义，在这个情境下，SV_Target0是对应片元的像素颜色。例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct frag_output {
    fixed4 color0 : SV_Target0;
    fixed4 color1 : SV_Target1;
    fixed4 color2 : SV_Target2;
}

frag_output frag(v2f i) {
    frag_output output;
    // ...
    return output;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到模板的片元着色器内部，首先是&lt;code&gt;color = tex2D(_MainTex, i.uv);&lt;/code&gt;，&lt;code&gt;tex2D(sampler2D texture, float2 uv);&lt;/code&gt;是Cg为我们提供的一个纹理采样函数，它将按照输入的uv采样输入的纹理texture，最后返回采样颜色。然后是&lt;code&gt;color *= _Color;&lt;/code&gt;这里只是简单的把采样颜色和shader外部给定的颜色做乘法处理（叠加）。在场景中新建一个sphere，把这个shader添加到一个新的material，再把这个material挂到sphere上，不出意外没有报错的话，即可得到一个纯白色的球（由于没有任何光照阴影计算，也没有给纹理赋值）。这是我们第一个生效的shader。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/KaoriZh/KaoriZh.github.io/master/_Images/Unity/Shader/Chapter2/PureWhite.png&quot; alt=&quot;Sphere for First Shader&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 13:55:00 +0000</pubDate>
<dc:creator>Li_F</dc:creator>
<og:description>前言 经过前面两个章节的铺垫，我们对渲染以及Unity Shaderlab相关的知识已经有了大概的认识，接下来将要学习的就是Shader最重要的部分， SL（Shader Language） ，着色器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Li-F/p/10806798.html</dc:identifier>
</item>
<item>
<title>色彩空间的转换 - tuxiaoping</title>
<link>http://www.cnblogs.com/1121518wo/p/10806782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1121518wo/p/10806782.html</guid>
<description>&lt;p&gt;    1、   今天我们来学习一下色彩空间转换，那么什么是色彩空间呢（可以看百度上的解释：https://baike.baidu.com/item/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/4615427?fr=aladdin）&lt;/p&gt;
&lt;p&gt;   我们常见色彩空间有： RGB    HSV    HIS  Ycrcb   YUV&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; color_space(image):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     gray=cv.cvtColor(image,cv.COLOR_BGR2GRAY) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;色彩转为GRAY&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,gray)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     HSV=cv.cvtColor(image,cv.COLOR_BGR2HSV) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 色彩转为HSV&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hsv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,HSV)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     YUV=cv.cvtColor(image,cv.COLOR_BGR2YUV) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;色彩转为YUV&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yuv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,YUV)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; src = cv.imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:/hh.JPG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; cv.namedWindow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ago&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,cv.WINDOW_AUTOSIZE)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ago&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, src)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;color_space(src)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    实现效果如下：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190503205652293-1000967240.jpg&quot; alt=&quot;&quot; width=&quot;1748&quot; height=&quot;858&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     HSV色彩通道说明：&lt;/p&gt;
&lt;p&gt;          H:0--180&lt;/p&gt;
&lt;p&gt;         S: 0--255&lt;/p&gt;
&lt;p&gt;         V: 0---255&lt;/p&gt;
&lt;p&gt;   2、利用inRange()实现过滤掉视频中的颜色，实现只对某一颜色追踪，在之前我们来看一下HSV颜色对应RGB的分量范围;&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190503210738575-996376953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; capture_video():
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     capture = cv.VideoCapture(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:/tt.avi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         ret ,frame=&lt;span&gt;capture.read()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; ret:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         HSV=cv.cvtColor(frame,cv.COLOR_BGR2HSV) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把色彩空间转为HSV&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         lower_hsv=np.array([37,43,461]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置颜色的最低值，这里是根据上面那张HSV颜色以RGB为分量的颜色范围,这里使用numpy 的矩阵运算功能&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         upper_hsv=np.array([77,255,255]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置颜色的最高值，也是根据那张表选择的&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         mask=cv.inRange(HSV,lower_hsv,upper_hsv)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调节图像颜色信息(H) 、饱和度（S）、亮度（V）区间，选择白色区域&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;video&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,frame)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mask&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,mask)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         c = cv.waitKey(50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; c == 27&lt;span&gt; :
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; t1=&lt;span&gt;cv.getTickCount()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;capture_video()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; t2=&lt;span&gt;cv.getTickCount()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the time is : %s ms&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%((t2-t1)/cv.getTickFrequency()*1000&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   实现效果如下（我这里选择的视频不好，没有白色区域，全是黑色的，hh）：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190503212800886-1321991070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   3、通道的分离与合并： &lt;/p&gt;
&lt;p&gt;        首先是通道的分离：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; src=cv.imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:/hh.JPG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; cv.namedWindow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ago&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,0)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ago&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行通道分离，输出三个单通道图片&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; b,g,r=cv.split(src) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用函数split()将色彩图像分割成3个通道&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,b)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,g)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下（我们可以看到通道分离成功，有三个通道，分别是：blue ,green,red）:&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190503214058098-756474328.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        接下来是通道的合并：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; src=cv.imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:/hh.JPG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; cv.namedWindow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ago&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,0)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ago&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行通道分离，输出三个单通道图片&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; b,g,r=cv.split(src) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用函数split()将色彩图像分割成3个通道&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,b)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,g)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行通道的合并&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; src=cv.merge([b,g,r])&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用函数merge()实现通道的合并&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;together&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    效果如下：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190503214601333-88431693.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      最后实现单个通道颜色值得修改：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; src=cv.imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:/hh.JPG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; cv.namedWindow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ago&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,0)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ago&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行通道分离，输出三个单通道图片&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; b,g,r=cv.split(src) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用函数split()将色彩图像分割成3个通道&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,b)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,g)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行通道的合并&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; src=cv.merge([b,g,r])&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用函数merge()实现通道的合并&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;together&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是可以实现修改某个通道的值&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; src[:,:,2]=100 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里是修改了第三个通道的值,也就是red 这通道&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;总结：今天学到的知识点就写到这里了，收货很大，继续加油，坚持下去，看到不一样的自己。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 13:53:00 +0000</pubDate>
<dc:creator>tuxiaoping</dc:creator>
<og:description>1、 今天我们来学习一下色彩空间转换，那么什么是色彩空间呢（可以看百度上的解释：https://baike.baidu.com/item/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1121518wo/p/10806782.html</dc:identifier>
</item>
<item>
<title>用函数式编程，从0开发3D引擎和编辑器（二）：函数式编程准备 - Wonder-YYC</title>
<link>http://www.cnblogs.com/chaogex/p/10806785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaogex/p/10806785.html</guid>
<description>&lt;p&gt;大家好，本文介绍了本系列涉及到的函数式编程的主要知识点，为正式开发做好了准备。&lt;/p&gt;

&lt;p&gt;1.粒度小&lt;/p&gt;
&lt;p&gt;相比面向对象编程以类为单位，函数式编程以函数为单位，粒度更小。&lt;/p&gt;
&lt;p&gt;正所谓：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我只想要一个香蕉，而面向对象却给了我整个森林&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.性能好&lt;/p&gt;
&lt;p&gt;大部分人认为函数式编程差，主要基于下面的理由(参考 &lt;a href=&quot;https://www.zhihu.com/question/54637225&quot;&gt;JavaScript 函数式编程存在性能问题么？&lt;/a&gt;)：&lt;br/&gt;1)柯西化、函数组合等操作增加时间开销&lt;br/&gt;2)map、reduce等操作，会进行多次遍历，增加时间开销&lt;br/&gt;3)Immutable数据每次操作都会被拷贝为新的数据，增加时间和内存开销&lt;/p&gt;
&lt;p&gt;而我说性能好，是指通过“Reason的编译优化+Immutable/Mutable结合使用+递归/迭代结合使用”，可以解决这些问题：&lt;br/&gt;1)由于Bucklescript编译器在编译时的优化，柯西化等操作和Immutable数据被编译成了优化过的js代码，大幅减小了时间开销&lt;br/&gt;2)由于Reason支持Mutable和for,while迭代操作，所以可以在性能热点使用它们，提高性能。&lt;/p&gt;
&lt;p&gt;3.擅长处理数据，适合3D领域编程&lt;/p&gt;
&lt;p&gt;通过高阶函数、柯西化、组合等工具，函数式编程可以像流水线一样对数据进行管道操作，非常方便。&lt;/p&gt;
&lt;p&gt;3D程序有大量的数据要操作，从函数式编程的角度来看：&lt;/p&gt;
&lt;p&gt;3D程序=数据+逻辑&lt;/p&gt;
&lt;p&gt;因此，我们可以：&lt;br/&gt;使用Immutable/Mutable、Data Oriented等思想和数据结构表达数据；&lt;br/&gt;使用函数表达逻辑；&lt;br/&gt;使用组合、柯西化等工具，把数据和逻辑关联起来。&lt;/p&gt;
&lt;h2 id=&quot;更多讨论&quot;&gt;更多讨论&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/kancloud/functional-programm-for-rest/56930&quot;&gt;FP之优点&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/19732025/answer/530161703&quot;&gt;函数式编程（Functional Programming）相比面向对象编程（Object-oriented Programming）有哪些优缺点？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们使用Reason语言，它是从Ocaml而来的，属于非纯函数式编程语言。&lt;/p&gt;
&lt;p&gt;而我们熟知的Haskell，属于纯函数式编程语言。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/what-and-why&quot;&gt;Reason学习文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么不用纯函数式编程语言&quot;&gt;为什么不用纯函数式编程语言&lt;/h2&gt;
&lt;p&gt;1.更高的性能&lt;br/&gt;Reason支持Mutable、迭代操作，提高了性能&lt;/p&gt;
&lt;p&gt;2.更简单易用&lt;br/&gt;1)允许非纯操作，所以不需要使用Haskell中的各种Monad&lt;br/&gt;2)严格求值相对于惰性求值更简单。&lt;/p&gt;
&lt;h2 id=&quot;搭建reason开发环境&quot;&gt;搭建Reason开发环境&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59220417&quot;&gt;Reason的介绍和搭建Reason开发环境&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;数据&quot;&gt;数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;创建不可变数据之后，对其任何的操作，都会返回一个拷贝后的新数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;br/&gt;Reason的变量默认为immutable：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let a = 1;

/* a为immutable */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Reason也有专门的不可变数据结构，如Tuple,List,Record。&lt;/p&gt;
&lt;p&gt;这里以Record为例，它类似于Javascript中的Object：&lt;br/&gt;首先定义Record的类型:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type person = {
  age: int,
  name: string
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义Record的值：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let me = {
  age: 5,
  name: &quot;Big Reason&quot;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这个Record，如修改&quot;age&quot;的值：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let newMe = {
    ...me,
    age: 10
};

Js.log(newMe === me); /* false */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;newMe是从me拷贝而来，任何对newMe的修改，都不会影响me。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在编辑器中的应用&lt;/em&gt;&lt;br/&gt;编辑器的所有数据都是Immutable的，这样的好处是：&lt;br/&gt;1)不用关心数据之间的关联关系，因为每个数据都是独立的&lt;br/&gt;2)不用担心状态被修改，减少了很多bug&lt;br/&gt;3)实现Redo/Undo功能时非常简单，直接把Immutable的数据压入History的栈里即可，不用深拷贝/恢复数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在引擎中的应用&lt;/em&gt;&lt;br/&gt;大部分函数的局部变量都是Immutable的（如使用tuple,record结构)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/let-binding&quot;&gt;Reason-&amp;gt;Let Binding&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/record&quot;&gt;Reason-&amp;gt;Record&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/28016223&quot;&gt;facebook immutable.js 意义何在，使用场景？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://auth0.com/blog/intro-to-immutable-js/&quot;&gt;Introduction to Immutable.js and Functional Programming Concepts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;对可变数据的任何操作，都会直接修改原数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;br/&gt;Reason通过&quot;ref&quot;关键字，标志变量为Mutable。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let foo = ref(5);

let five = foo^; 

foo := 6;   //foo===five===6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Reason也可以通过&quot;mutable&quot;关键字，标志Record的字段为Mutable。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type person = {
  name: string,
  mutable age: int
};
let baby = {name: &quot;Baby Reason&quot;, age: 5};
baby.age = baby.age + 1; /* 修改原数据baby的age为6 */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为操作Mutable数据不会造成拷贝，没有垃圾回收cg的开销，所以在性能热点处，常常使用Mutable数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/mutation&quot;&gt;Reason-&amp;gt;Mutable&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;p&gt;函数是第一公民，函数是数据。&lt;/p&gt;
&lt;p&gt;相关资料：&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/67652709&quot;&gt;如何理解在 JavaScript 中 &quot;函数是第一等公民&quot; 这句话?&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/function&quot;&gt;Reason-&amp;gt;Function&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let a = 1;


/* func2是纯函数 */
let func2 = value =&amp;gt; value;

/* func1是非纯函数，因为使用了外部变量&quot;a&quot; */
let func1 = () =&amp;gt; a;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;脚本的钩子函数(如init,update,dispose等函数)属于纯函数（但不能算严格的纯函数），这样是为了：&lt;br/&gt;1)能够正确序列化&lt;br/&gt;脚本会先序列化为字符串，保存在文件中（如编辑器导出的包中）；&lt;br/&gt;然后在导入该文件时（如编辑器导入包），将脚本字符串反序列化为函数（执行：eval('(' + funcStr + ')')）。如果脚本的钩子函数不是纯函数(如调用了外部变量)，则会报错。&lt;/p&gt;
&lt;p&gt;2)支持多线程&lt;br/&gt;目前脚本是在主线程执行的，但因为它是纯函数，所以未来可以放在单独的脚本线程中执行，提高性能。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;：&lt;br/&gt;虽然纯函数好处很多，但Wonder中大多数的函数都是非纯函数，这是因为：&lt;br/&gt;1)为了性能&lt;br/&gt;2)为了简单易用，所以允许副作用，很少使用容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1&quot;&gt;第 3 章：纯函数的好处&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高阶函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;函数能够作为数据，成为高阶函数的参数或者返回值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let func1 = func =&amp;gt; func(1);

let func2 = value =&amp;gt; value * 2;

func1(func2);   /* func1是高阶函数，因为func2是func1的参数 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个函数中常常有一些共同的逻辑，需要消除重复，可以通过提出一个私有的高阶函数来解决。具体示例如下：&lt;br/&gt;重构前：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let add1 = value =&amp;gt; value + 2;

let add2 = value =&amp;gt; value + 10;

let minus1 = value =&amp;gt; value - 10;

let minus2 = value =&amp;gt; value - 200;

let compute1 = value =&amp;gt; value |&amp;gt; add1 |&amp;gt; minus1;

let compute2 = value =&amp;gt; value |&amp;gt; add2 |&amp;gt; minus2;

/* compute1,compute2有重复逻辑 */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重构后：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;...

let _compute = (value, (addFunc, minusFunc)) =&amp;gt;
  value |&amp;gt; addFunc |&amp;gt; minusFunc;

let compute1 = value =&amp;gt; _compute(value, (add1, minus1));

let compute2 = value =&amp;gt; _compute(value, (add2, minus2));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49579052&quot;&gt;理解 JavaScript 中的高阶函数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。&lt;br/&gt;你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let func1 = (value1, value2) =&amp;gt; value1 + value2;

let func2 = func1(1);

func2(2);   /* 3 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用的地方太多了，此处省略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1&quot;&gt;第 4 章: 柯里化（curry）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/posts/currying/&quot;&gt;Currying&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;类型&quot;&gt;类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/series/understanding-fsharp-types.html&quot;&gt;The &quot;Understanding F# types&quot; series&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基本类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;Reason是强类型语言，包含int、float、string等基本类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type a = string;   /* 定义a为string类型 */

let str:a = &quot;zzz&quot;;   /* 变量str为a类型 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类型在wonder中应用广泛，包括以下的使用场景：&lt;br/&gt;1)类型驱动设计&lt;br/&gt;2)领域建模&lt;br/&gt;3)枚举&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/type&quot;&gt;Reason-&amp;gt;Type&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/posts/type-size-and-design/&quot;&gt;Algebraic type sizes and domain modelling&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Discriminated Union Type&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;类型可以接受参数，还可以组合其它的类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type result('a, 'b) =
  | Ok('a)
  | Error('b);

type myPayload = {data: string};

let payloadResults: list(result(myPayload, string)) = [
  Ok({data: &quot;hi&quot;}),
  Ok({data: &quot;bye&quot;}),
  Error(&quot;Something wrong happened!&quot;)
];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1)作为容器的实现&lt;br/&gt;2)是实现本文后面的Recursive Type的基础&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/more-on-type#type-argument&quot;&gt;Reason-&amp;gt;Type Argument&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/null-undefined-option&quot;&gt;Reason-&amp;gt;Null, Undefined &amp;amp; Option&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/posts/discriminated-unions/&quot;&gt;Discriminated Unions&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;有时候我们想定义一个类型，它不是某一个具体的类型，可以将其定义为抽象类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type value;

type a = value; /* a为value类型 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包括以下的使用案例：&lt;br/&gt;1)在封装WebGL api的FFI中(&lt;a href=&quot;https://reasonml.github.io/docs/en/external#docsNav&quot;&gt;什么是FFI?&lt;/a&gt;)，把WebGL的上下文定义为抽象类型。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/* FFI */


/* 抽象类型 */
type webgl1Context;

[@bs.send]
external getWebgl1Context : ('canvas, [@bs.as &quot;webgl&quot;] _) =&amp;gt; webgl1Context = &quot;getContext&quot;;

[@bs.send.pipe: webgl1Context]
external viewport : (int, int, int, int) =&amp;gt; unit = &quot;&quot;;




/* client code */

/* canvasDom是canvas的dom，此处省略了获取它的代码 */
/* gl是webgl1Context类型 */
/* 编译后的js代码为：var gl = canvasDom.getContext(&quot;webgl&quot;); */
let gl = getWebgl1Context(canvasDom);   

/* 编译后的js代码为：gl.viewport(0,0,100,100); */
gl |&amp;gt; viewport(0,0,100,100);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2)脚本-&amp;gt;属性-&amp;gt;value可以为int或者float类型，因此将value设为抽象类型，并且定义抽象类型和int、float类型之间的转换FFI。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
type scriptAttributeType =
  | Int
  | Float;


/* 抽象类型 */
type scriptAttributeValue;

type scriptAttributeField = {
  type_: scriptAttributeType,
  value: scriptAttributeValue
};

/* 定义scriptAttributeValue和int,float类型相互转换的FFI */

external intToScriptAttributeValue: int =&amp;gt; scriptAttributeValue = &quot;%identity&quot;;

external floatToScriptAttributeValue: float =&amp;gt; scriptAttributeValue =
  &quot;%identity&quot;;

external scriptAttributeValueToInt: scriptAttributeValue =&amp;gt; int = &quot;%identity&quot;;

external scriptAttributeValueToFloat: scriptAttributeValue =&amp;gt; float =
  &quot;%identity&quot;;
  
  
/* client code */

/* 创建scriptAttributeField，设置value的数据(int类型) */

let scriptAttributeField = {
    type_: Int,
    value:intToScriptAttributeValue(10) 
};



/* 修改scriptAttributeField-&amp;gt;value */

let newScriptAttributeField = {
    ...scriptAttributeField,
    value: (scriptAttributeValueToInt(scriptAttributeField.value) + 1) |&amp;gt; intToScriptAttributeValue
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://ocaml.org/learn/tutorials/modules.zh.html#Abstract-Types&quot;&gt;抽象类型(Abstract Types)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Recursive Type&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;从类型定义上看，可以看成是Discriminated Union Type，只是其中至少有一个union type为自身类型，即递归地指向自己。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;br/&gt;还是看代码好理解点，具体示例如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type nodeId = int;

/* tree是Recursive Type，它的文件夹节点包含了子节点，而子节点的类型为自身 */
type tree =
  | LeafNode(nodeId)
  | FolderNode(
      nodeId,
      array(tree),
    );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在编辑器中的应用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Recursive Type常用在树中，如编辑器的资产树的类型就是Recursive Type。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/series/recursive-types-and-folds.html&quot;&gt;The &quot;Recursive types and folds&quot; series&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://keleshev.com/map-as-a-recursion-scheme-in-ocaml&quot;&gt;Map as a Recursion Scheme in OCaml&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;过程&quot;&gt;过程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;多个函数可以组合起来，使得前一个函数的返回值是后一个函数的输入，从而对数据进行管道处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let func1 = value =&amp;gt; value1 + 1;

let func2 = value =&amp;gt; value1 + 2;

10 |&amp;gt; func1 |&amp;gt; func2;   /* 13 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在引擎中的应用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;组合可以应用在多个层面，如函数层面和job层面。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;job = 多个函数的组合&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看下job组合的应用示例：&lt;/p&gt;
&lt;p&gt;从时间序列上来看：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;引擎＝初始化+主循环&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而初始化和每一次循环，都是多个job组合而成的管道操作：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;初始化 = create_canvas |&amp;gt; create_gl |&amp;gt; ...


每一次循环 = tick |&amp;gt; dispose |&amp;gt; reallocate_cpu_memory |&amp;gt; update_transform |&amp;gt; ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html&quot;&gt;第 5 章: 代码组合（compose）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遍历操作可以分成两类：&lt;br/&gt;迭代&lt;br/&gt;递归&lt;/p&gt;
&lt;p&gt;递归就是指函数调用自己，满足终止条件时结束。如深度优先遍历是递归操作，而广度优先遍历是迭代操作。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：&lt;/em&gt;&lt;br/&gt;尽量写成尾递归，这样Reason会将其编译成迭代操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let rec func1 = (value, result) =&amp;gt; {
    value &amp;gt; 3 ? result : func1(value + 1, result + value);
};

func1(1, 0);   /* 0+1+2+3=6; */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几乎所有的遍历都是尾递归，只有在少数使用Mutable和少数性能热点的地方，使用迭代操作（使用for或while命令）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/20761771&quot;&gt;什么是尾递归？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/function#recursive-functions&quot;&gt;Reason-&amp;gt;Recursive Functions&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模式匹配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;使用switch结构代替if else处理程序分支。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let func1 = value =&amp;gt; {
    switch(value){
        | 0 =&amp;gt; 10 
        | _ =&amp;gt; 100
    }
};

func1(0);   /* 10 */
func1(2);   /* 100 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要用在下面三种场景：&lt;/p&gt;
&lt;p&gt;1)取出容器的值&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type a = 
    | A(int)
    | B(string);
    
switch(a){
    | A(value) =&amp;gt; value
    | B(value) =&amp;gt; value
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2)处理&lt;a href=&quot;https://reasonml.github.io/docs/en/null-undefined-option&quot;&gt;Option&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let a = Some(1);

switch(a){
    | None =&amp;gt; ...
    | Some(value) =&amp;gt; ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3)处理枚举类型&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type a = 
    | A
    | B;
    
switch(a){
    | A =&amp;gt; ...
    | B =&amp;gt; ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/pattern-matching&quot;&gt;Reason-&amp;gt;Pattern Matching!&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.kancloud.cn/kancloud/functional-programm-for-rest/56937&quot;&gt;模式匹配&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;异步&quot;&gt;异步&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;函数反应式编程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;处理异步，主要有以下的方法：&lt;br/&gt;1)回调函数&lt;br/&gt;缺点：过多的回调导致嵌套层次太深，容易陷入回调地狱，不易维护。&lt;br/&gt;2)Promise&lt;br/&gt;3)await,aync&lt;br/&gt;4)使用函数反应式编程的流&lt;br/&gt;优点：能够使用组合，像管道处理一样处理各种流，符合函数式编程的思维。&lt;/p&gt;
&lt;p&gt;Wonder使用流来处理异步，其中也用到了Promise，不过都被封装成了流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;br/&gt;使用&lt;a href=&quot;https://github.com/cujojs/most/blob/master/docs/api.md&quot;&gt;most库&lt;/a&gt;实现FRP，因为它的性能比Rxjs更好。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/* 
输出：
next:2
next:4
next:6
complete
*/
let subscription =
  Most.from([|1, 2, 3|])
  |&amp;gt; Most.map(value =&amp;gt; value * 2)
  |&amp;gt; Most.subscribe({
       &quot;next&quot;: value =&amp;gt; Js.log2(&quot;next:&quot;, value),
       &quot;error&quot;: e =&amp;gt; Js.log2(&quot;error:&quot;, e##message),
       &quot;complete&quot;: () =&amp;gt; Js.log(&quot;complete&quot;),
     });

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;凡是异步操作，如事件处理、多线程等，都用流来处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://my.oschina.net/u/2288602?q=%E5%8F%8D%E5%BA%94%E5%9E%8B%E7%BC%96%E7%A8%8B&quot;&gt;你一直都错过的反应型编程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.infoq.cn/article/functional-reactive-programming&quot;&gt;函数式反应型编程 (FRP) —— 实时互动应用开发的新思路&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/26079335&quot;&gt;函数式响应型编程(Functional Reactive Programming)会在什么问题上有优势?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;容器&quot;&gt;容器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了领域建模，或者为了保证纯函数而隔离副作用，需要把值封装到容器中。外界只能操作容器，不直接操作值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1)领域建模示例&lt;/p&gt;
&lt;p&gt;比如我们要开发一个图书管理系统，需要对“书”进行建模。&lt;br/&gt;书有书号、页数这两个数据，有小说书、技术书两种类型。&lt;br/&gt;建模为：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type bookId = int;

type pageNum = int;

type book = 
    | Novel(bookId, pageNum)
    | Technology(bookId, pageNum);
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们创建一本小说，一本技术书，以及它们的集合：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let novel = Novel(0, 100);

let technology = Technology(1, 200);

let bookList = [
    novel,
    technology
];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对“书”这个容器进行操作：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let getPage = (book) =&amp;gt; 
switch(book){
    | Novel(_, page) =&amp;gt; page
    | Technology(_, page) =&amp;gt; page
};


let setPage = (page, book) =&amp;gt; 
switch(book){
    | Novel(bookId, _) =&amp;gt; Novel(bookId, page)
    | Technology(bookId, _) =&amp;gt; Technology(bookId, page)
};

/* client code */

/* 将技术书的页数设置为集合中所有书的总页数 */
let newTechnology =
bookList
|&amp;gt; List.fold_left((totalPage, book) =&amp;gt; totalPage + getPage(book), 0)
|&amp;gt; setPage(_, technology);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包含以下使用场景：&lt;br/&gt;1)领域建模&lt;br/&gt;2)错误处理&lt;br/&gt;3)处理空值&lt;br/&gt;使用&lt;a href=&quot;https://reasonml.github.io/docs/en/null-undefined-option&quot;&gt;Option&lt;/a&gt;包装空值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/rop/&quot;&gt;Railway Oriented Programming&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/series/map-and-bind-and-apply-oh-my.html&quot;&gt;The &quot;Map and Bind and Apply, Oh my!&quot; series&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#%E2%80%9C%E7%BA%AF%E2%80%9D%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86&quot;&gt;强大的容器&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html&quot;&gt;Monad&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#%E5%8D%8F%E8%B0%83%E4%BA%8E%E6%BF%80%E5%8A%B1&quot;&gt;Applicative Functor&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;多态&quot;&gt;多态&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;全称为Generalized algebraic data type，可以用来实现函数参数多态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;br/&gt;重构前，需要对应每种类型，定义一个isXXXEqual函数：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let isIntEqual = (source: int, target: int) =&amp;gt; source == target;

let isStringEqual = (source: string, target: string) =&amp;gt; source == target;
  
  
isIntEqual(1, 1); /*true*/

isStringEqual(&quot;aaa&quot;, &quot;aaa&quot;); /*true*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用GADT重构后，对应多个类型，只有一个isEqual函数：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;type isEqual(_) =
  | Int: isEqual(int)
  | Float: isEqual(float)
  | String: isEqual(string);

let isEqual = (type g, kind: isEqual(g), source: g, target: g) =&amp;gt;
  switch (kind) {
  | _ =&amp;gt; source == target
  };

isEqual(Int, 1, 1); /*true*/

isEqual(String, &quot;aaa&quot;, &quot;aaa&quot;); /*true*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1)契约检查&lt;br/&gt;如需要判断两个变量是否相等，则使用GADT，定义一个assertEqual方法替换assertStringEqual,assertIntEqual等方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.janestreet.com/why-gadts-matter-for-performance/&quot;&gt;Why GADTs matter for performance（需要FQ）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Generalized_algebraic_data_type&quot;&gt;维基百科-&amp;gt;Generalized algebraic data type&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Module Functor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;module可以作为参数，传递给functor，返回一个新的module。&lt;/p&gt;
&lt;p&gt;类似于面向对象的“继承”，可以使用函子functor，在基module上扩展出新的module。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;module type Comparable = {
  type t;

  let equal: (t, t) =&amp;gt; bool;
};

module MakeAdd = (Item: Comparable) =&amp;gt; {
  let add = (x: Item.t, newItem: Item.t, list: list(Item.t)) =&amp;gt;
    Item.equal(x, newItem) ? list : [newItem, ...list];
};

module A = {
  type t = int;
  let equal = (x1, x2) =&amp;gt; x1 == x2;
};

/* module B有add函数，该方法调用了A.equal函数 */
module B = MakeAdd(A);

let list = B.add(1, 2, []);    /* list == [2] */
let list = list |&amp;gt; B.add(1, 1);    /* list == [2] */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在Wonder中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在编辑器中的应用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1)错误处理&lt;br/&gt;错误被包装为容器Result；&lt;br/&gt;由于容器Result中的值的类型不一样，所以将Result分成RelationResult、SameDataResult。&lt;/p&gt;
&lt;p&gt;这两类Result有共同的模式，因此可以提出基module:Result，然后增加MakeRelationResult、MakeSameDataResult这两个module functor。它们将Result作为参数，返回新的module:RelationResult、SameDataResult，从而消除重复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/module#module-functions-functors&quot;&gt;Reason-&amp;gt;Module Functions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details&quot;&gt;JS 函数式编程指南&lt;/a&gt;&lt;br/&gt;这本书作为我学习函数式编程的第一本书，非常容易上手，作者讲得很简单易懂，推荐～&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/stoeffel/awesome-fp-js&quot;&gt;Awesome FP JS&lt;/a&gt;&lt;br/&gt;收集了函数式编程相关的资料。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/site-contents/&quot;&gt;F# for fun and profit&lt;/a&gt;&lt;br/&gt;这个博客讲了很多F#相关的函数式编程的知识，非常推荐！&lt;br/&gt;如果你正在使用Reason或者Ocaml或者F#语言，建议到该博客中学习！&lt;/p&gt;
&lt;p&gt;欢迎浏览上一篇博文：&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/10799388.html&quot;&gt;用函数式编程，从0开发3D引擎和编辑器（一）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 13:53:00 +0000</pubDate>
<dc:creator>Wonder-YYC</dc:creator>
<og:description>大家好，本文介绍了本系列涉及到的函数式编程的主要知识点，为正式开发做好了准备。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaogex/p/10806785.html</dc:identifier>
</item>
</channel>
</rss>