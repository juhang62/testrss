<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>FMDB 使用注意点 - Zxiao..旭</title>
<link>http://www.cnblogs.com/zhangxiaoxu/p/10862054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxiaoxu/p/10862054.html</guid>
<description>&lt;p&gt;关于FMDB最基本的使用我们就不在说了，这个网上大把的文章介绍，我就在这里总结几点我最近在写一个小东西的时候注意到的一点点东西：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一： 怎么看真机上SQLite数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      我们在开发的过程中肯定有使用到真机测试，不知道会不会有小伙伴有好奇心想看看在真机环境中我们创建的数据库可视化的数据是什么样子呢。当然你可以通过SQ语句去查看，当然我们也有办法直接像看表格数据一样查看它。&lt;/p&gt;
&lt;p&gt;      1、XCode  -  Window  -  Devices and Simlators&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739006/201905/739006-20190514144048736-1185668352.png&quot; alt=&quot;&quot; width=&quot;310&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      2、选中你的手机  -  选中你的App  -  下面设置按钮 （如下图所示）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739006/201905/739006-20190514144155095-1405501910.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      3、Download Container...&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/739006/201905/739006-20190514144513741-813574202.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      4、最好保存桌面，方便我们查看&lt;/p&gt;
&lt;p&gt;      然后你桌面就会有一份 .xcappdata 文件了，这时候你再“显示包内容” 就可以看到里面有一份 AppData 和 AppDataInfo.plist 文件，这时候你 AppData - Documents&lt;/p&gt;
&lt;p&gt;就能看到你的 X.sqlite 数据库了。&lt;/p&gt;
&lt;p&gt;      查看这份数据库我使用的是一个叫SQLite的国外软件的破解版，直接可视化看到，大概界面如下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739006/201905/739006-20190514145251459-1379462535.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      当然还有网上很多人说的 火狐浏览器的 SQLite Manager 这个扩展，但由于我的火狐浏览器比较新，就没办法像以前那样可视化的查看了，你现在安装扩展之后是下面这样子的。关于它现在的简单的使用我有标注出来，现在用它查看没没法直接可视化的，但你可以通过下面SQ语句操作该数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739006/201905/739006-20190514145954377-821565208.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;

&lt;p&gt;关于FMDB最基本的使用我们就不在说了，这个网上大把的文章介绍，我就在这里总结几点我最近在写一个小东西的时候注意到的一点点东西：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二：要是你要写入大量的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      1、引入的它叫做“事务”，事务主要是解决数据量多的耗时操作。&lt;/p&gt;
&lt;p&gt;　   在数据库操作中，所谓事务是用户定义的一个数据库操作序列,这些操作要么全做要么全不做,是一个不可分割的工作单位。例如,在关系数据库中,一个事务可以是一条SQL语句、一组SQL语句或整个程序。&lt;br/&gt;　　事务和程序是两个概念。一般地讲,一个程序中包含多个事务。&lt;br/&gt;　　事务的开始与结束可以由用户显式控制。如果用户没有显式地定义事务,则由 DBMS 按缺省规定自动划分&lt;/p&gt;
&lt;p&gt;      在 SQL 语言中,定义事务的语句有三条：&lt;/p&gt;
&lt;p&gt;　　      BEGIN TRANSACTION&lt;br/&gt;　　      COMMIT TRANSACTION&lt;br/&gt;　　      ROLLBACK TRANSACTION&lt;/p&gt;
&lt;p&gt;      2、事务我们这样介绍概念，那它的优点又有那些呢？&lt;/p&gt;
&lt;p&gt;           数据库中的插入操作是比较耗时的，假如我们一次性在主线插入几百几千条数据，由于比较较慢就会造成主线程阻塞。那么这时候可以开启一个事物来进行操作。&lt;br/&gt;　　     数据库以文件的形式存在磁盘中，每次访问时都要打开一次文件，如果对数据库进行大量的操作，就很慢。当用事物的形式提交，开始事务后，进行的大量操作语句都   保存在内存中，当提交时才全部写入数据库，此时，数据库文件也只用打开一次。如果操作错误，还可以回滚事务。&lt;/p&gt;

&lt;p&gt;      3、事务的特性&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;           Atomic（原子性）事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。事务中的所有元素作为一个整体提交或回滚，事务的个元素是不可分的，事务是一个完整操作。&lt;br/&gt;　　     Consistency（一致性）只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。事物完成时，数据必须是一致的，也就是说，和事物开始之前，数据存储中的数据处于一致状态。保证数据的无损。&lt;br/&gt;　　     Lsolation（隔离性）事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。对数据进行修改的多个事务是彼此隔离的。这表明事务必须是独立的，不应该以任何方式以来于或影响其他事务。&lt;br/&gt;　　     Durability（持久性）事务结束后，事务处理的结果必须能够得到固化。事务完成之后，它对于系统的影响是永久的，该修改即使出现系统故障也将一直保留，真实的修改了数据库。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;      &lt;strong&gt;所以事务是线程安全的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt; EG:下面就是一个简单的数据存储关于FMDB事务的例子&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
/**
 debug 
 @param title   统计标题
 @param content 统计内容JSON数据
 */
-(void)DebugSensorsAnalyticsShowWithDoraemonKit:(NSString *)title andParments:(NSString * )content{
    
    // 获得Documents目录路径
    NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
    NSString *dbPath = [documentsPath stringByAppendingPathComponent:@&quot;SensorsAnalytics.sqlite&quot;];
    debugLog(@&quot;!!!  debug  !!! dbPath = %@&quot;,dbPath);
    //创建数据库
    _dataBase = [FMDatabase databaseWithPath:dbPath];
    if (![_dataBase open]) {
        debugLog(@&quot;SensorsAnalytics open fail&quot;);
        return;
    }
    //创建表  currenthour 比较时间 一小时前的删除 不然数据过大
    NSString * sql = @&quot;create table if not exists sensorsAnalytics ('time' TEXT NOT NULL,'title' TEXT NOT NULL, 'content' TEXT NOT NULL,'hour' TEXT NOT NULL)&quot;;
    BOOL result = [_dataBase executeUpdate:sql];
    if (result) {
        debugLog(@&quot;create sensorsAnalytics table success&quot;);
    }
    
    [_dataBase beginTransaction];//开启一个事务
    BOOL isRollBack = NO;
    @try {
        NSString *currentTime = [self getCurrentTimes];
        NSString *currenthour = [self getCurrentHour];
        BOOL insertResult = [_dataBase executeUpdate:@&quot;insert into 'sensorsAnalytics'(time,title,content,hour) values(?,?,?,?)&quot; withArgumentsInArray:@[currentTime,title,content,currenthour]];
        if (insertResult) {
            debugLog(@&quot;insert into 'sensorsAnalytics' success&quot;);
        }
        // 把一个小时前的数据删除
        BOOL deleteResult = [_dataBase executeUpdate:[NSString stringWithFormat:@&quot;delete from sensorsAnalytics where hour &amp;lt; %@&quot;,currenthour]];
        if (deleteResult) {
            debugLog(@&quot;delete from 'sensorsAnalytics' success&quot;);
        }
        
    } @catch (NSException *exception) {
        isRollBack = YES;
        [_dataBase rollback];   // 回滚
    } @finally {
        if (!isRollBack) {
            [_dataBase commit]; // 没有错误一次性提交
        }
    }
    [_dataBase close];
}

-(NSString*)getCurrentTimes{
    
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@&quot;MM-dd HH:mm:ss&quot;];
    NSDate *datenow = [NSDate date];
    NSString *currentTimeString = [formatter stringFromDate:datenow];
    return currentTimeString;
}

-(NSString *)getCurrentHour{
    
    NSDate *now = [NSDate date];
    NSCalendar *calendar = [NSCalendar currentCalendar];
    NSUInteger unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond;
    NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:now];
    NSString * hour =  [NSString stringWithFormat:@&quot;%ld&quot;,(long)[dateComponent hour]];
    return hour;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      参考学习链接： &lt;a href=&quot;https://www.jianshu.com/p/bed74ea65ff3&quot; target=&quot;_blank&quot;&gt;FMDB写入大量数据的处理方法&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 14 May 2019 07:45:00 +0000</pubDate>
<dc:creator>Zxiao..旭</dc:creator>
<og:description>关于FMDB最基本的使用我们就不在说了，这个网上大把的文章介绍，我就在这里总结几点我最近在写一个小东西的时候注意到的一点点东西： 一： 怎么看真机上SQLite数据库 我们在开发的过程中肯定有使用到真</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxiaoxu/p/10862054.html</dc:identifier>
</item>
<item>
<title>CODING 告诉你硅谷项目经理的项目管理之道（2） - CODING研发管理系统</title>
<link>http://www.cnblogs.com/codingdevops/p/10862562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingdevops/p/10862562.html</guid>
<description>&lt;blockquote readability=&quot;10.287769784173&quot;&gt;
&lt;p&gt;优秀的项目管理者是怎么工作的？如何帮助研发团队高效工作？这一直是 CODING 关注的重要话题，我们不断地打磨 CODING 研发管理系统来让开发更简单。&lt;br/&gt;近期我们精心挑选了几篇硅谷科技公司研发管理者的 README 进行翻译。README 主要用来向团队成员展示项目管理者的工作理念和工作方式，以便成员能够快速地融入到团队当中。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://bit.ly/welcometonetflixandme&quot; class=&quot;uri&quot;&gt;https://bit.ly/welcometonetflixandme&lt;/a&gt;&lt;br/&gt;原文作者：Roy，现任 Slack 研发主管，曾就职于 Netflix。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;上一篇我们翻译的 README 来自一位走“民主路线”的管理者（ &lt;a href=&quot;https://zhuanlan.zhihu.com/p/65147030&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/65147030&lt;/a&gt; ），这一次的 README 来自一位“硬核风”的管理者——Roy。Roy 在 Netflix 与 Slack 先后有两个 README，下文是他在 Netflix 时使用的。这也是你可以在网上找到的首批管理者自述文件之一，许多人从 Roy 身上得到了启发。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding-net-production-pp-ci.codehub.cn/a29d56d8-0392-4093-8a55-0d9d6a439a44.jpeg&quot; alt=&quot;图片&quot;/&gt;&lt;br/&gt;&lt;strong&gt;欢迎来到 Netflix，致我的新下属。&lt;/strong&gt;&lt;br/&gt;Roy Rapoport&lt;br/&gt;2016 年 2 月 13&lt;/p&gt;
&lt;h2 id=&quot;文档说明&quot;&gt;&lt;strong&gt;文档说明&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;免责声明：以下内容不适用于 Netflix 或其它组织的在职经理。&lt;/p&gt;
&lt;p&gt;我希望通过这份文档快速地向大家介绍 2016 年我是如何在 Netflix 管理研发团队的。它仅代表了 Netflix 文化与我的管理风格的独特融合，并不能代表我在其它组织或者 Netflix 其他管理者的方式。经历过了种种快乐，我在 2018 年 1 月离开了 Netflix，从那时起这份文档似乎就变得不实用了。但有不少人希望能够继续参考它，因此它依然开放给大家。&lt;/p&gt;
&lt;p&gt;写这么个文档貌似是有点奇怪，没关系，我们还会有很多机会相互了解。这是我目前能想到的高效介绍一些事情的最好方式。它不仅仅是一个 PPT（* 译者注：原文是 PPT 格式，为优化阅读体验译者改为文章格式，但内容不变 *），更是一个信息公告。进入正文前你最好先阅读并熟悉下 Netflix 公司文化（ &lt;a href=&quot;http://jobs.netflix.com/culture&quot; class=&quot;uri&quot;&gt;http://jobs.netflix.com/culture&lt;/a&gt; ）。&lt;/p&gt;
&lt;h2 id=&quot;关于个性冲突&quot;&gt;&lt;strong&gt;关于个性冲突&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我不认为在工作上存在不可调和的个性冲突，我们或多或少都会有一些实质性的观点差异。在调整个性方面，我认为管理者应该适应下属的个性风格，毕竟管理者能在工资中得到“委曲求全”的部分报酬。&lt;/p&gt;
&lt;h2 id=&quot;d.r.i-原则&quot;&gt;&lt;strong&gt;D.R.I 原则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;*译者注：Directly Responsible Individuals 直接责任个人，为每个项目分配一个 DRI，最终要对该项目的成功或失败负责，欲进一步了解推荐阅读：&lt;a href=&quot;https://originalfuzz.com/blogs/magazine/83782148-the-directly-responsible-individual&quot; class=&quot;uri&quot;&gt;https://originalfuzz.com/blogs/magazine/83782148-the-directly-responsible-individual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我理解 D.R.I 原则意味着：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要么你做决定，要么是我，但绝对不是我们两个一起做决定&lt;/li&gt;
&lt;li&gt;我们各自的责任范围不会重叠&lt;/li&gt;
&lt;li&gt;我不能覆盖你的决定&lt;/li&gt;
&lt;li&gt;当我不认同你时，我会尝试去说服你&lt;/li&gt;
&lt;li&gt;如果我不相信你的判断是合理的，我可以解雇你&lt;/li&gt;
&lt;li&gt;不要因为担心判断错误，就不敢提出你的意见&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为一个 DRI 意味着&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不必和其他人达成共识&lt;/li&gt;
&lt;li&gt;不必得到其他人的同意&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为一个 DRI 并不意味着：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你做事可以不经过大脑&lt;/li&gt;
&lt;li&gt;你不必解释你为什么做出某种决定&lt;/li&gt;
&lt;li&gt;没人会事前事后指出你犯了错误&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;我的工作职责&quot;&gt;&lt;strong&gt;我的工作职责&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;吸引和留住世界一流的人才（别左顾右盼了，就是你）&lt;/li&gt;
&lt;li&gt;协调内外部资源，为团队提供良好的平台&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果我做了什么事让你不太想留在公司，或者让你觉得我在对你指手画脚而不是提供平台，恳请你一定要尽快告诉我。&lt;/p&gt;
&lt;h2 id=&quot;关于反馈&quot;&gt;&lt;strong&gt;关于反馈&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我爱死反馈了，反馈是你和我在 Netflix 取得成功的关键。&lt;/strong&gt;人们一般需要三个维度的条件都满足才能持续给出反馈：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高安全感：不会因为给出负面反馈受到惩罚&lt;/li&gt;
&lt;li&gt;低成本：不必因为要给上级反馈、也不必因为收到反馈时和他人争论耗费大量时间&lt;/li&gt;
&lt;li&gt;高收益：给对方反馈之后，有多大可能性会让对方有行动上的改变&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;大家都叫我“钢铁直男”。&lt;/strong&gt;比起言辞上的善意，我会优先关注表达上的效率，但我也会在保证正确传达信息的情况下尽量维持善意。因为确保你完整收到我的反馈是我的重要工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding-net-production-pp-ci.codehub.cn/4f87fceb-39c9-4d21-bed2-f7a0e12bb0ab.jpeg&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;工作时间&quot;&gt;&lt;strong&gt;工作时间&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我尽量不在工作时间（8:00～18:00）外和你谈论工作。&lt;/li&gt;
&lt;li&gt;我有时也偷偷懒，请请假。&lt;/li&gt;
&lt;li&gt;除非我清楚地表明这是紧急情况，否则当我在私人时间发你消息，你第二天上班回复我即可。&lt;/li&gt;
&lt;li&gt;理性来讲，即使在工作时间里，你也无需全天候回复我。&lt;/li&gt;
&lt;li&gt;在工作时间外我并不愿意打电话给你，如果我打了，一定是紧急情况。从目前来看，这种情况很少，低于 1 次/年/人。&lt;/li&gt;
&lt;li&gt;以上这些仅限于我联系你的情况，不包括 on-call 职责和生产环境的紧急呼叫。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;我的日程表&quot;&gt;&lt;strong&gt;我的日程表&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你想跟我聊聊尽管来找我。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然我在这儿干很多杂七杂八的事情，但当你想谈话时，几乎没啥事情比花时间和你沟通来的更重要。所以你可以随时在我的日程表上安排谈话时间。（实际上，在 Netflix 大家都这样，只要发送会议请求就行，不用额外征询他人同意。）&lt;/p&gt;
&lt;p&gt;把事务放在日程表上的万无一失了？那也只是口头承诺。下图是我在 2016 年 2 月随机一周的日程表。日程表目前只有 8 个空格是空闲的，它们不久也会被填满。也不用太执着于我的日程表，可能你在表格上找不着任何空闲时间，但如果你想沟通，我们就沟通。让我知道你的电话号码或者其它联系方式，我会想办法推掉一些事情来找你聊聊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding-net-production-pp-ci.codehub.cn/9db67630-73e2-4e16-bfb6-0612cde39308.png&quot; alt=&quot;图片&quot;/&gt;&lt;br/&gt;&lt;em&gt;（译者注：原图作者已打马赛克）&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于解雇&quot;&gt;&lt;strong&gt;关于解雇&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;是不是开始担心被解雇了？放心吧，&lt;strong&gt;在你工作的头 3 个月里，你会高度怀疑自己随时会被炒鱿鱼。&lt;/strong&gt;问问最近刚加入 Netflix 的工程师们是不是也经历过这种恐惧。很有可能至少有两个人回答“是的”，有这种恐惧的心情再正常不过。如果你在 Netflix 快待满 3 个月，那么恭喜你，很快就不用担心被解雇了。除非我已经明确直接告诉你，你有被解雇的危险。&lt;/p&gt;
&lt;p&gt;关于我的炒人记录。直到 2016 年 2 月 14 日，我已经担任研发管理者三年多了，在这段时间里：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;招聘了九个人&lt;/li&gt;
&lt;li&gt;有两个人被我调岗&lt;/li&gt;
&lt;li&gt;解聘了三个人&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;让我兴致盎然的是：如何让员工在得知自己因业绩问题被我解雇时不会感到惊讶。目前为止我在这方面很成功。主要是因为我的直言不讳，你才不会感到惊讶。&lt;/p&gt;
&lt;h2 id=&quot;绩效判定表&quot;&gt;&lt;strong&gt;绩效判定表&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://coding-net-production-pp-ci.codehub.cn/9b42418c-e55e-4d3f-ab55-ea0ddff20e63.jpeg&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我认为每一个向我汇报的人，在任何特定时间点都处于以下三个特定表现水平之一 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;绿色：你可能有些事情想要改进，有些事情我希望你能改进。但如果你什么都不改变，也行吧。考虑到我们目前的用人要求，你想在这工作多久就工作多久。&lt;/li&gt;
&lt;li&gt;橙色：长远来看，你目前做的事情让你的发展轨迹受阻。如果不改变，那么估计事情的结局不会太好，你需要改变一些事情。&lt;/li&gt;
&lt;li&gt;红色：短期来看，你的发展轨迹是受阻的，而且我们会有一个具体的时间窗来改变它。你和我会明确地讨论问题出现在哪儿了，以及如何去修复它。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有时候我事后会意识到你实际是处于橙色状态而不是绿色，但是红色从来不会是后见之名。如果你问我：“现在我处于红色状态吗？”我会回答：“如果你非要问的话，那答案就算不是吧。”&lt;/p&gt;
&lt;p&gt;变成橙色状态了？赶紧准备下家吧。&lt;br/&gt;开玩笑的啦。&lt;strong&gt;橙色状态完全是可以恢复过来的。&lt;/strong&gt;在过去的三年里，作为研发主管我的绩效已经变橙 2～3 次了，但每次我都恢复过来了。&lt;strong&gt;我从橙色中迅速恢复的能力提高了上属对我完成工作和自我纠正能力的信任。&lt;/strong&gt;这对我手下的人也是一样。如果你陷入橙色状态，你可以努力恢复，一旦你将其恢复过来，将会提高我对你的信任。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coding-net-production-pp-ci.codehub.cn/09b97ddd-8b17-4f6d-8fc7-fdf83f602596.jpeg&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即使进入红色状态也不意味着一定会被解雇。也有一些人曾陷入红色，努力挣扎而出，最终在 Netflix 获得了事业成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你还在这里工作， 那是因为我对你仍然充满信心。如果我失去了信心，我不会再浪费时间管理你，而是给你相当慷慨的离职金——解雇你。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;自我认识&quot;&gt;&lt;strong&gt;自我认识&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;经常给你反馈，无论是正面的还是负面的。（换言之我很坦率）&lt;/li&gt;
&lt;li&gt;确保我的信息能够正确传递。（换言之我很直白）&lt;/li&gt;
&lt;li&gt;当我接受到反馈后，我会采取行动，而不是左耳进右耳出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我已知的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有人指责我对“提供支持而不是指手画脚”有着极端的看法。&lt;/li&gt;
&lt;li&gt;直到你证明了你具备不需要我“指手画脚”的能力时，我才可能在你做事时保持沉默。（若你提出问题或寻求意见时，我依然会倾囊相助。）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;关于-11&quot;&gt;&lt;strong&gt;关于 1:1&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们团队的 1:1 囊括了各种频度和长度的会议（每周 1 小时或者双周 15 分钟）。对于新员工，我们会以一个高频度、高时长的会议开始 1:1，它是专门为你进行的。除非你想要报告事务的状态更新，否则我们在 1:1 上是不会谈什么事务状态的事情。我们中的任何一个人都可以迟到 5 分钟。5 分钟的迟到在我们公司见怪不怪，但我还是会努力不迟到。&lt;/p&gt;
&lt;h2 id=&quot;关于坦率&quot;&gt;&lt;strong&gt;关于坦率&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://coding-net-production-pp-ci.codehub.cn/6a5f6a08-81dc-4005-a830-8f9ebc153d7e.jpeg&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公司也许会要求我在指定日期前向你保密一些事情（例如经理们会比公告时间提前一个星期知道股票期权的变化），这在我管理团队的三年里也只发生过一次。公司不能要求我骗你，这以前没发生过，以后也不会发生（我也从没被要求这么做过）。我们倾向于透明与坦率，你可以问任何问题，大部分时间我会回答，少数情况下我不会回答你。但我承诺我不会对你撒谎。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果你向我汇报（无论是直接还是非直接），你都有编辑这个文档的权限，&lt;strong&gt;这是我特意向你开放的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;译后记&quot;&gt;&lt;strong&gt;译后记&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Roy 是位让人印象深刻的领导人，这也和 Netflix 整体精英化的团队氛围有关。&lt;strong&gt;Roy 鼓励员工进行独立决策、非常强调彼此坦诚相待、高度重视反馈，他在团队中只保留高效的人才，但他也重视下属的进步。&lt;/strong&gt;开发者成长的路径有许多，可以是技术架构、售前解决方案、运维支持等等。关于研发项目管理，CODING 也有几个理念与大家分享：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;加强研发团队间协作，打破壁垒与部门墙。&lt;/strong&gt;结合敏捷开发思想，CODING 提供全面而又灵活性极高的任务协同工具。从用户故事开始，到需求池管理以及任务拆解、缺陷管理、测试管理，覆盖整个敏捷研发管理所需，为项目管理者提供全面详尽的统计报告，助力团队研发效能提升，实现 Scrum 迭代式开发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化的研发流程，减少人力的重复劳动。&lt;/strong&gt;CODING 提供持续集成到自动部署的全过程工具：自动构建、自动化测试、构建物管理、部署交付。支撑项目的快速迭代，保证软件稳定、持续构建和发布。可以无缝对接第三方运维管理工具，支持多种软件交付过程，实现 DevOps 持续交付全流程应用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://coding.net/&quot;&gt;&lt;strong&gt;CODING&lt;/strong&gt;&lt;/a&gt; 助力开发者轻松成为管理者。&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 07:42:00 +0000</pubDate>
<dc:creator>CODING研发管理系统</dc:creator>
<og:description>硅谷顶尖科技公司的研发管理者的工作风格是怎样的？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingdevops/p/10862562.html</dc:identifier>
</item>
<item>
<title>聊聊 CDN 缓存与浏览器缓存 - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/10862511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/10862511.html</guid>
<description>&lt;p&gt;CDN 是互联网上内容分发的重要一环。无论您之前是否了解过 CDN，其实它已经在您的日常生活中发挥作用了。比如您正在淘宝挑选心仪的商品，或者在观看一段令人捧腹的视频，以及您正在阅读的这篇文章，这些资源展示的背后都有 CDN 的默默支撑。&lt;/p&gt;
&lt;p&gt;为什么 CDN 使用如此广泛呢？首先大家需要知道，CDN 旨在解决的最重要的问题是什么，我们称之为网络延迟。举个例子，当您输入一个网址，敲击回车后到网页内容实际出现在屏幕上，中间加载耗费的这个时间，就是网络延迟。通过网络获取资源总是比从本地获取慢，无论服务器是在同一个局域网中还是位于世界的另一个角落，都是如此。这里的速度差异是 IT 行业的一个核心问题，开发者想了很多办法试图去弥补这个差异，CDN 就是应用最为广泛的一个解决方案。&lt;/p&gt;
&lt;p&gt;CDN 为解决网络延迟提供了一整套技术方案，今天我们介绍的缓存就是其中重要的一环。这篇文章主要介绍在使用了 CDN 之后，数据是如何被缓存的，以及缓存是如何提高数据加载速度的。&lt;/p&gt;
&lt;h2&gt;缓存的优点&lt;/h2&gt;
&lt;p&gt;在未接入CDN 之前，用户使用浏览器访问服务的时候，相互交互的过程如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-c90af6a7a94dd0c3277af36e94aaca1d_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c90af6a7a94dd0c3277af36e94aaca1d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c90af6a7a94dd0c3277af36e94aaca1d_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户在第一次访问网站服务器的时候，浏览器会从服务器获取所有的资源，在传输过程中，浏览器会通过一些约定好的响应头，从而确定是否需要将这个资源保存一份到本地作为缓存。当用户第二次访问该网站的时候，浏览器就会优先从缓存中加载资源，不用向服务器请求资源，从而提高了网站的访问速度。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-7912ed2893209ea5dd020c4d397ab160_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;947&quot; data-original=&quot;https://pic1.zhimg.com/v2-7912ed2893209ea5dd020c4d397ab160_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7912ed2893209ea5dd020c4d397ab160_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如我们第一次访问又拍云官网，下面就是浏览器加载资源的快照，可以看到 5.6MB 的数据被传输到本地。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-add6168d36c01aec741a01c377c02046_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;534&quot; data-original=&quot;https://pic3.zhimg.com/v2-add6168d36c01aec741a01c377c02046_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-add6168d36c01aec741a01c377c02046_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在刷新又拍云官网后，我们可以看到传输数据降到了 9.9KB，在使用了缓存之后，浏览器不用再下载全部的文件，减少了下载量也就意味着提高了页面加载的速度。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-3e7704e28b2f60065a9254a809a24746_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;478&quot; data-original=&quot;https://pic3.zhimg.com/v2-3e7704e28b2f60065a9254a809a24746_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3e7704e28b2f60065a9254a809a24746_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的例子，可以直观地观察到浏览器缓存对解决网络延迟起到的作用是非常明显的。&lt;/p&gt;
&lt;p&gt;而对于一些用户访问量巨大的网站而言，如果所有用户都去服务器请求数据，服务器会很快崩溃，并且在不同网络以及不同地区的用户，请求服务器的速度也不一样。为了提高这部分用户的访问速度，CDN 中又提出了新的网络架构，即创建一些最接近用户网络的边缘服务器，然后将文件缓存在这些边缘服务器（节点）上，这就是 CDN 缓存。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-7b1416af0d7acd6f91f2b0ab56927fe7_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;948&quot; data-original=&quot;https://pic4.zhimg.com/v2-7b1416af0d7acd6f91f2b0ab56927fe7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-7b1416af0d7acd6f91f2b0ab56927fe7_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可以看到，服务接入了 CDN 后，数据经历了客户端（浏览器）缓存和 CDN 边缘节点缓存两个阶段，那么下面就分别对这两个阶段的缓存进行介绍。&lt;/p&gt;
&lt;h2&gt;浏览器缓存介绍&lt;/h2&gt;
&lt;p&gt;当我们请求一个网页的时候，服务器会向浏览器返回大量数据，但是这些数据需要全部缓存吗？浏览器又是如何区分哪些数据需要进行缓存，哪些是需要实时跟源站获取的？接下来我们就来看一下浏览器的缓存策略。&lt;/p&gt;
&lt;h3&gt;浏览器缓存策略&lt;/h3&gt;
&lt;p&gt;服务器会在资源返回的响应中，携带上以下四个常用的响应头，浏览器会通过判别这些响应值来决定资源缓存的状态。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ETag&lt;/li&gt;
&lt;li&gt;Cache-Control&lt;/li&gt;
&lt;li&gt;Expires&lt;/li&gt;
&lt;li&gt;Last-Modified&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ETag&lt;/p&gt;
&lt;p&gt;ETag 值是一个字符串，其内容通常是数据的哈希值，每个数据都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。&lt;/p&gt;
&lt;p&gt;服务器可以在响应中返回 ETag，然后浏览器会在后续的请求中携带上这个参数来确定缓存是否需要更新。如果 ETag 值相同，说明资源未更改，服务器会返回 304（Not Modified） 响应码，浏览器就知道本地缓存仍然是可以使用的。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-a21da6bca3bb3d85d4032494cc46284b_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;960&quot; data-original=&quot;https://pic4.zhimg.com/v2-a21da6bca3bb3d85d4032494cc46284b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a21da6bca3bb3d85d4032494cc46284b_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过需要注意的是，ETag 只有在本地缓存已过期（Expires）或者缓存模式设置为 no-cache（Cache-Control）的时候，才会被浏览器携带上与服务器端的值进行判别。&lt;/p&gt;
&lt;p&gt;Cache-Control&lt;/p&gt;
&lt;p&gt;Cache-Control 可以携带多个响应值，这些值可以设置缓存时间、状态以及验证状态。不同值说明如下。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-5c0d24f0296764b4be14cbdab2ca73a1_hd.jpg&quot; alt=&quot;&quot; width=&quot;1220&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1220&quot; data-rawheight=&quot;844&quot; data-original=&quot;https://pic2.zhimg.com/v2-5c0d24f0296764b4be14cbdab2ca73a1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5c0d24f0296764b4be14cbdab2ca73a1_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，访问某张图片，服务器返回的响应如下：Cache-Control: max-age=691200，则说明这张图片可以在客户端存储 8 天。&lt;/p&gt;
&lt;p&gt;Expires&lt;/p&gt;
&lt;p&gt;这个响应头标记了数据的过期时间，超过其中规定的时间后，缓存会被定义为过期。例如：Expires: Sat, 27 Apr 2019 11:43:15 GMT&lt;/p&gt;
&lt;p&gt;说明对应的数据会在 2019 年 4 月 27 号的 11 点 43 分后过期。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果 Cache-Control 中有 max-age 指令，浏览器会忽略此参数。&lt;/p&gt;
&lt;p&gt;Last-Modified&lt;/p&gt;
&lt;p&gt;服务器可以通过配置这个响应头，来向浏览器发送一个数据上次被修改的时间标签，例如：Last-Modified:Wed, 24 Apr 2019 02:54:16 GMT&lt;/p&gt;
&lt;p&gt;这样浏览器就知道了该数据最后被修改的时间，后续请求中，会和服务器进行时间的比较，如果服务器上的时间比本地时间要新，说明数据有更改，浏览器需要重新下载数据。&lt;/p&gt;
&lt;p&gt;HTTP 响应示例&lt;/p&gt;
&lt;p&gt;接下来我们可以看一个响应示例。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-653f10239076c02181aafe847257a4a6_hd.png&quot; alt=&quot;&quot; width=&quot;1218&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1218&quot; data-rawheight=&quot;500&quot; data-original=&quot;https://pic3.zhimg.com/v2-653f10239076c02181aafe847257a4a6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-653f10239076c02181aafe847257a4a6_b.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第 2 行告诉我们 max-age 是 1 小时；&lt;/p&gt;
&lt;p&gt;第 5 行告诉我们这是一张 PNG 图片；&lt;/p&gt;
&lt;p&gt;第 7 行向我们显示了 ETag 值，该值将在 1 小时标记后用于验证，以验证资源是否有更改；&lt;/p&gt;
&lt;p&gt;第 8 行是 Expires 响应，因为设置了 max-age，它将被浏览器忽略；&lt;/p&gt;
&lt;p&gt;第 10 行是 Last-Modified 响应，显示上次修改图像的时间。&lt;/p&gt;
&lt;p&gt;浏览器缓存的不足&lt;/p&gt;
&lt;p&gt;当服务器返回的响应中有 Expires 或者 Cache-Control 设置了 max-age 响应头的时候，浏览器不会向服务器发起校验请求，而是直接复用本地缓存。如果此时服务器进行了资源的更新，用户就无法获取到最新的资源，只能通过强制刷新浏览器缓存来跟服务器请求最新的资源。&lt;/p&gt;
&lt;p&gt;此外，Expires 是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。&lt;/p&gt;
&lt;p&gt;因此在实际使用过程中，需要灵活使用浏览器的缓存策略。&lt;/p&gt;
&lt;h2&gt;CDN 缓存介绍&lt;/h2&gt;
&lt;p&gt;当服务接入了 CDN 之后，浏览器本地缓存的资源过期之后，浏览器不是直接向源服务器请求资源，而是转而向 CDN 边缘节点请求资源。CDN 边缘节点中将用户的数据缓存起来，如果 CDN 中的缓存也过期了，CDN 边缘节点会向源服务器发出回源请求，从而来获取最新资源。以下介绍以又拍云 CDN 为例。&lt;/p&gt;
&lt;h3&gt;CDN 缓存策略&lt;/h3&gt;
&lt;p&gt;CDN 节点缓存策略一般都会遵循 HTTP 标准协议，又拍云在没有匹配到自定义缓存规则且源服务器也没有返回任何有效缓存头的情况下，默认配置策略如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;针对静态资源，所有正常状态码（大于等于 200 小于 400）均缓存 8 天。特别地，301 响应缓存 2 小时，302 响应缓存 20 分钟；&lt;/li&gt;
&lt;li&gt;针对动态资源，程序会自动识别，则不进行缓存；&lt;/li&gt;
&lt;li&gt;对于其他大于等于 400 的不正常响应，则不进行缓存；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缓存节点通知浏览器缓存的具体时间由 HTTP 响应头里面的 Cache-Control 和 Expires 响应头控制。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-4cbd685642580ba1f56a2cd8e2190827_hd.png&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;880&quot; data-original=&quot;https://pic4.zhimg.com/v2-4cbd685642580ba1f56a2cd8e2190827_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4cbd685642580ba1f56a2cd8e2190827_b.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;CDN 缓存的不足&lt;/h3&gt;
&lt;p&gt;CDN 缓存不仅减少了用户的访问延时，相应的也减少了源服务器的负载，但这里需要注意，当源服务器资源更新后，如果 CDN 节点上缓存数据还未过期，用户访问到的依旧是过期的缓存资源，这会导致用户最终访问出现偏差。因此，开发者需要手动刷新相关资源，使 CDN 缓存保持为最新的状态。&lt;/p&gt;
&lt;h3&gt;CDN 缓存刷新&lt;/h3&gt;
&lt;p&gt;又拍云为开发者执行缓存刷新提供了主动更新和被动更新两种方式。&lt;/p&gt;
&lt;p&gt;主动更新主要是指同名资源在源服务器更新之后，开发者手动刷新文件。又拍云提供了可视化的操作台供用户执行缓存刷新操作，同时支持 URL 刷新和规则刷新。此外开发者也可通过 API 接口完成刷新操作。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-38d63ad1e3fb2a1fa2f239734ef14b26_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;732&quot; data-original=&quot;https://pic3.zhimg.com/v2-38d63ad1e3fb2a1fa2f239734ef14b26_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-38d63ad1e3fb2a1fa2f239734ef14b26_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;被动刷新则是等文件在 CDN 节点的缓存过期之后，节点回源拉取源服务器上最新的文件。这个过程由 CDN 自动完成，无需手动操作。&lt;/p&gt;
&lt;p&gt;现如今是一个快节奏的时代，人们总是希望自己能够第一时间获取到最新的资讯，使用的是最快捷的服务。又拍云一直致力于解决互联网网络拥塞问题，提高终端用户访问网站的响应速度和可用性，为广大开发者提供更加简洁方便的 CDN 一站式服务。&lt;/p&gt;
&lt;p&gt;目前又拍云 CDN 可以提供基于文件后缀、目录等多个维度来指定 CDN 缓存和浏览器时间，为开发者提供更精细化的缓存管理服务。针对开发者不同的业务需求，又拍云提供了多项预制模板，方便快捷的来帮助开发者进行数据缓存管理，有效减轻源站负载，通过各网络、各区域的多个节点，来帮助减小终端用户访问服务延时。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/384/%25E8%25BF%2599%25E6%25A0%25B7%25E4%25BB%258B%25E7%25BB%258D%2520CDN%25EF%25BC%258C%25E8%2580%2581%25E5%258F%25B8%25E6%259C%25BA%25E4%25B9%259F%25E8%2583%25BD%25E5%2590%25AC%25E6%2587%2582.html&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;这样介绍 CDN，老司机也能听懂&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;LinkCard LinkCard--hasImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/380/%25E8%2581%258A%25E8%2581%258A%25E5%25B8%25B8%25E8%25A7%2581%25E7%259A%2584%25E7%25BD%2591%25E7%25BB%259C%25E6%2594%25BB%25E5%2587%25BB.html&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-6f1bc531fda73306e2a89f2633ba0896_120x160.jpg&quot; data-image-width=&quot;739&quot; data-image-height=&quot;2885&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;聊聊常见的网络攻击&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 07:35:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<og:description>CDN 是互联网上内容分发的重要一环。无论您之前是否了解过 CDN，其实它已经在您的日常生活中发挥作用了。比如您正在淘宝挑选心仪的商品，或者在观看一段令人捧腹的视频，以及您正在阅读的这篇文章，这些资源</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/10862511.html</dc:identifier>
</item>
<item>
<title>网络应用（3）：CDN与P2P的概念 - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10862235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10862235.html</guid>
<description>&lt;p&gt;我前面说了流量的概念，流量是使用网络时经常要考虑的一个因素--如何才能更快的使用流量，如何才能节省流量使用的成本，对于这样的问题，你可能要了解一下什么是cdn，什么是p2p。&lt;/p&gt;
&lt;h4 id=&quot;cdn是什么&quot;&gt;（1）cdn是什么&lt;/h4&gt;
&lt;p&gt;cdn是一个基于已有的internet网络而进行扩展的网络系统，叫作内容分发网络，content delivery network。&lt;/p&gt;
&lt;p&gt;搭建cdn网络的思路，是在网络边缘，也就是接入网络的设备（用户）的地方，增加服务结点，再通过各种策略，把用户划分到不同的cdn结点，并让用户能在最短的时间获取到数据。&lt;/p&gt;
&lt;p&gt;为什么可以更快拿到数据？我可以更简单地解释：在没有cdn之前，你需要到经过一个很曲折的小路去看电影，而有了cdn后，cdn直接把电影缓存过来了，而且，cdn就在你面前，你直接看电影就好了，这个道理，跟“就近救援”或“就近配送”是一个道理。所以，cdn的根本就是缓存（而它跟源服务间是高速公路，数据很快就传过来），让用户就近取数据，而不是走长长的小路去取数据--极端一点，每个用户都配一台缓存服务器。&lt;/p&gt;
&lt;p&gt;cdn的基本意图，是让用户更快更稳地取得数据。cdn最基本的作用是加速，但随着时代的发展，cdn提供的服务已经远不仅加速的功能，还有预缓存、支持https等诸多功能。&lt;/p&gt;
&lt;p&gt;为了提升服务体验，以及其它考虑，很多公司都接入了cdn，或自建cdn。&lt;/p&gt;
&lt;p&gt;cdn服务商有很少，比如阿里云cdn、百度、腾讯、七牛、网宿等。&lt;/p&gt;
&lt;p&gt;这时，不可避免要考虑一个问题，cdn的使用，是占用带宽的（当然，不使用cdn而使用缓存服务器，也一样占用带宽），而这个带宽的使用，相当使用了运营商修建的道路，是要给钱的。一般来说，按带宽的使用来计费（具体可能按月的带宽峰值，也可能按实际使用来分摊到月，等等。），而在某些场景，比如直播、视频播放等，在客户端从cdn或缓存服务器获取数据时，服务器占用了很大的带宽。&lt;/p&gt;
&lt;p&gt;加一个题外话，怎么从流量换算出带宽？一般来说，很容易统计到文件下载（或被试听）的次数，根据文件的大小与一天的下载的次数，就可以算出一天产生的流量，比如小程的服务器的一个语音文件是250kB，如果一天有100次播放，那一天的流量就是(250*100)=25000kB。再把流量分摊到每一秒，就是带宽（bps）：25000*1024*8/(24*60*60)=204800000/86400=2370bps，也就是一天占用的带宽是2.3k左右。这是一天的带宽，一般来说，一个月内会产生峰值（比如活动日或周末等），这时的带宽可能是正常的几倍，比如3倍，那就是6.9k。然后，根据这个6.9k来计算要给多少钱（先问一下运营商或cdn服务商，1m带宽要多少钱）。&lt;/p&gt;
&lt;p&gt;那么，有没有办法，减少服务器带宽的占用，从而节省费用的开销呢？&lt;/p&gt;
&lt;h4 id=&quot;p2p是什么&quot;&gt;（2）p2p是什么&lt;/h4&gt;
&lt;p&gt;p2p，peer to peer，是点到点的数据交换的网络技术。&lt;/p&gt;
&lt;p&gt;对比cdn跟p2p的网络结构，很容易看出它们的差别。对于cdn，客户端之间的数据交换，需要经过cdn服务器来转发，因此，服务器带宽成本是一个问题（如上所述）。对于p2p，客户端之间可以直接交换数据而不经cdn服务器，所以理论上可以大幅节省带宽成本。注意，客户端间直接交换数据，会使用用户的流量，但一般是在wifi或带宽网络下才使用流量，而带宽网络一般是以带宽或速度来收费的，也就是这时使用多少流量并不需要用户来买单。&lt;/p&gt;
&lt;p&gt;所以，如果为了节省cdn的带宽成本，p2p是一个可以考虑的技术。&lt;/p&gt;
&lt;p&gt;一个简单的p2p应用的结构图是这样的：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/cdn%E4%B8%8Ep2p/%E7%AE%80%E5%8D%95%E7%9A%84p2p%E7%BB%93%E6%9E%84.png&quot; alt=&quot;简单的p2p结构&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E9%80%BB%E8%BE%91%E9%A2%98/%E9%80%BB27.png&quot; alt=&quot;focus&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 07:06:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>我前面说了流量的概念，流量是使用网络时经常要考虑的一个因素 如何才能更快的使用流量，如何才能节省流量使用的成本，对于这样的问题，你可能要了解一下什么是cdn，什么是p2p。 （1）cdn是什么 cdn</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeself/p/10862235.html</dc:identifier>
</item>
<item>
<title>javascript系列--认识并理解构造函数，原型和原型链 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10862197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10862197.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;介绍构造函数，原型，原型链。比如说经常会被问道：symbol是不是构造函数；constructor属性是否只读；prototype、[[Prototype]]和__proto__的区别；什么是原型链？等等问题&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、什么构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构造函数就是通过new关键词生成实例的函数。&lt;/p&gt;
&lt;p&gt;js的构造函数和其他语言不一样，一般规范都是首字母大写。&lt;/p&gt;
&lt;p&gt;首先我们来看一下这个栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/20hR5tptfFdvlh47Qf5WzUoptQ.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是一个典型的构造函数，构造函数本身也是个函数，与普通区别不大，主要区别就是：构造函数使用new生成实例，直接调用就是普通函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、constructor属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回创建实例对象的Object构造函数的引用。此属性的值对函数本身的引用，而不是一个包含函数名称的字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有对象都会从它的原型上继承一个constructor属性&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var o = {};
o.constructor === &lt;span class=&quot;hljs-built_in&quot;&gt;Object; &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么&lt;strong&gt;普通函数&lt;/strong&gt;创建的实例有没有constructor属性呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码说明：&lt;/p&gt;
&lt;p&gt;（1）普通函数在内部有return操作的就有constructor属性，没有return的没有constructor属性；&lt;/p&gt;
&lt;p&gt;（2）有constructor属性的普通函数的constructor属性值不是普通函数本身，是Object。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、symbol是构造函数吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MDN 是这样介绍 `Symbol` 的&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;The `Symbol()` function returns a value of type **symbol**, has static properties that expose several members of built-in objects, has static methods that expose the global symbol registry, and resembles a built-in object class but is incomplete as a constructor because it does not support the syntax &quot;`new Symbol()`&quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Symbol是基本数据类型&lt;/strong&gt;，作为构造函数它不完整，因为不支持语法new Symbol()，如果要生成实例直接使用Symbol()就可以的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;虽然Symbol是基本数据类型，但是Symbol(1234)实例可以获取constructor属性值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;这里的constructor属性来自哪里？其实是Symbol原型上的，默认为Symbol函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、constructor的值是只读的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回答：如果是引用类型的constructor属性值是可以修改的，如果是基本类型的就是只读的。&lt;/p&gt;
&lt;p&gt;引用类型的情况，修改这个很好理解，比如原型链继承的方案中，就是对constructor重新赋值的修正。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/20sL8p2BvuUTnU3Q1FI6-qr7z2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于基本类型来说是只读的，比如：1, &quot;saucxs&quot;, true, Symbol, null, undefined。null和undefined也是没有constructor属性的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;为什么会这样？因为创建他们的是只读的原生构造函数(native constructors)，这个栗子说明依赖一个对象的constructor属性并不安全。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、原型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 &lt;/strong&gt;&lt;strong&gt;prototype属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个对象都拥有一个&lt;strong&gt;原型对象&lt;/strong&gt;，对象以其原型为模板，从原型集成方法和属性，这些属相和方法都在对象的&lt;strong&gt;构造器函数&lt;/strong&gt;的prototype属性上，而不是对象实例本身上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/20tM1iRgpJ70MhO8S7i1oe7ja-.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图发现：&lt;/p&gt;
&lt;p&gt;1、Parent对象有一个原型对象Parent.prototype，原型对象上有两个属性，分别为：constructor和__proto__，其中__proto__已被弃用。&lt;/p&gt;
&lt;p&gt;2、构造函数Parent有一个指向原型的指针constructor；原型Parent.prototype有一个指向构造函数的指针Parent.prototype.constrcutor，其实就是一个循环引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/20pTTHBEzQFmUfZiOJ8lJacpCW.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 __proto__&lt;/strong&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上图中可以看到Parent原型(Parent.prototype)上有一个__proto__属性，这是一个&lt;strong&gt;访问器属性(即getter函数和setter函数)&lt;/strong&gt;。作用：通过__proto__可以访问到对象的内部[[Prototype]](一个对象或者null)&lt;/p&gt;
&lt;p&gt;`__proto__` 发音 dunder proto，最先被 Firefox使用，后来在 ES6 被列为 Javascript 的标准内建属性。&lt;/p&gt;
&lt;p&gt;`[[Prototype]]` 是对象的一个内部属性，外部代码无法直接访问。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/20klZZ-QCXifwhq8k3vXu-J2r6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、p.__proto__获取的是对象的原型，&lt;strong&gt;__proto__是每一个实例上都有的属性&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;prototype是构造函数的属性；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、p.__proto__和Parent.prototype指向同一个对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;所以构造函数Parent,Parent.prototype和p之间的关系，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/20z6l-KhouQIArgugtOoWo-OVC.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意1：`__proto__` 属性在 `ES6` 时才被标准化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以确保 Web 浏览器的兼容性，但是不推荐使用，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 `Object.getPrototypeOf()`。&lt;/p&gt;
&lt;p&gt;如果要读取或修改对象的 `[[Prototype]]` 属性，建议使用如下方案，但是此时设置对象的 `[[Prototype]]` 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。&lt;/p&gt;
&lt;p&gt;如果要创建一个新对象，同时继承另一个对象的 `[[Prototype]]` ，推荐使用 `Object.create()`。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;这里 `child` 是一个新的空对象，有一个指向对象 p 的指针 `__proto__`。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、原型链&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每一个对象拥有一个原型对象，通过__proto__指针指向上一个原型&lt;/strong&gt;，并从中继承方法和属性，&lt;strong&gt;同时原型对象也可能拥有原型，这样一层层的，最终指向null&lt;/strong&gt;。这种关系成为原型链（prototype chain）,作用：&lt;strong&gt;通过原型链一个对象会拥有定义在其他对象中的属性和方法&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;p.constructor指向Parent，那么是不是意味着p实例化存在constructor属性呢？并不存在，打印一下p：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/20RVWcf_ky0Zsiscv6nUMWLOuo.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有图可以知道，实例化对象p本身没有constructor属性，是通过原型链向上查找__proto__，最终找到constructor属性，该属性指向Parent&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;下图展示原型链运行机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/20ePxL8X4JqM4qr9d3PzQJAXwx.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、Symbol是基本数据类型，作为构造函数并不完整，因为不支持语法new Symbol()，但是原型上拥有constructor属性，即Symbol.prototype.constructor。&lt;/p&gt;
&lt;p&gt;2、引用类型constructor属性值是可以修改的，但是对于基本类型的是只读的，当然null和undefined没有constructor属性。&lt;/p&gt;
&lt;p&gt;3、__proto__是每个实例上都有的属性，prototype是构造函数的属性，这两个不一样，但是p.__proto__和Parent.prototype是指向同一个对象。&lt;/p&gt;
&lt;p&gt;4、__proto__属性在ES6时被标准化，但是因为性能问题并不推荐使用，推荐使用Object.getPropertyOf()。&lt;/p&gt;
&lt;p&gt;5、每个对象拥有一个原型对象，通过__ptoto_指针指向上一个原型，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层已成的，最终指向null，这就是原型链。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、参考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes&quot; target=&quot;_blank&quot;&gt;原型对象&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor&quot; target=&quot;_blank&quot;&gt;Objcet.prototype.constructor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto&quot; target=&quot;_blank&quot;&gt;Object.prototype.__proto__&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot; target=&quot;_blank&quot;&gt;Symbol&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://bonsaiden.github.io/JavaScript-Garden/zh/#object.prototype&quot; target=&quot;_blank&quot;&gt;原型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文章首发地址（&lt;a href=&quot;https://www.mwcxs.top/&quot; target=&quot;_blank&quot;&gt;sau交流学习社区&lt;/a&gt;）&lt;/p&gt;

</description>
<pubDate>Tue, 14 May 2019 07:00:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>一、前言 介绍构造函数，原型，原型链。比如说经常会被问道：symbol是不是构造函数；constructor属性是否只读；prototype、[[Prototype]]和__proto__的区别；什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10862197.html</dc:identifier>
</item>
<item>
<title>FPGA+ADV7511实现HDMI显示 - 没落骑士</title>
<link>http://www.cnblogs.com/moluoqishi/p/10860849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moluoqishi/p/10860849.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;目前FPGA成为了视频图像实时处理的主要平台。显示作为图像应用设备的必要功能，对整体系统处理效果非常关键。HDMI是现阶段主流的显示接口，本文基于ADV7511芯片的HDMI显示系统，讲述HDMI显示过程中的一些原理和经验总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、色彩空间转换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之前通过VGA接口显示图像时只清楚RGB图像格式，对YUV了解甚少。YUV是指亮度参量和色度参量分开表示的像素格式，而这样分开的好处就是不但可以避免相互干扰，还可以降低色度的采样率而不会对图像质量影响太大。所以HDMI显示中，经常选择YUV来表示图像信息。要想将图像的YUV信息送入ADV7511，首先需要完成RGB到YUV的格式转换。两种格式分析以及互转公式具体见参考文献1，这里只给出RGB转YUV的标准公式。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;dp-css&quot;&gt;&lt;li&gt;&lt;span&gt;Y = (0.257 * R) + (0.504 * G) + (0.098 * B) + 16&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Cb = U = -( 0.148 * R) - (0.291 * G) + (0.439 * B) + 128&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Cr = V = (0.439 * R) - (0.368 * G) - (0.071 * B) + 128&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　上述三个公式均为乘加操作，调用MAC计算较为方便。在运算过程中首先整体向左移位将所有系数变为整数，再进行乘加操作，最后右移得到最终结果[2]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、HDMI显示原理及ADV7511芯片使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　HDMI接口通过三组TMDS串行差分信号来完成数据传输功能，示意图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190514123705403-395218868.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;527&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;高速传输接口都是一个套路，编码-&amp;gt;并串转换-&amp;gt;串并转换-&amp;gt;解码。HDMI传输流程细节见参考文献3。我们更多只关注ADV7511的核心用户侧接口及使用方式。ADV7511的内部结构如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190514124158627-1478286521.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;501&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;左侧画红框的引脚是我们需要用到的。同步传输首先需要时钟CLK和数据D。然后是行场同步和数据有效指示HSYNC VSYNC DE。该芯片支持多种数据格式和工作模式，利用IIC总线的SDA和SCL读写内部控制寄存器。芯片内寄存器非常多，ADV7511 grogramming guide中的section3 -quick start guide给出了必要的配置向导[4]。其中输入视频格式配置最为重要，本文使用的是YUV 422 ，8bit，DDR with separate sync，left justified模式中的syle 2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190514125158081-722465114.png&quot; alt=&quot;&quot; width=&quot;830&quot; height=&quot;733&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如图，这种模式下只用到了D[35:0]这36bit引脚中的[23:16]。配置寄存器地址为0X15和0X16。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190514125714578-402760464.png&quot; alt=&quot;&quot; width=&quot;752&quot; height=&quot;591&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;我们再来看看ADV7511 hardware user's guide[5]中给出的DDR采样模式接口时序图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190514130109417-1612236662.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;146&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;FPGA端可利用ODDR原语输出双边沿采样数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、显示Demo及效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;自定义HDMI显示IP的用户侧接收VGA格式数据，接口侧连接ADV7511芯片。用户接口包括：RGB HSYNC YSYNC DE。VGA图像数据格式在之前的博文中已有讲述[6]，注意两点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 HSYNC YSYNC是负脉冲&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 DE = HS_DE &amp;amp; YS_DE&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190514140303883-1471727991.jpg&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;405&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;上图是黑白格显示例程。从显示效果来看系统工作正常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 YUV格式分析 - arm-linux - 博客园 http://www.cnblogs.com/armlinux/archive/2012/02/15/2396763.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 &lt;/span&gt;&lt;span&gt;（原创）用verilog实现RGB格式图像到YCbCr或YUV格式的转换及其验证方法 （RGB2YCrCb）（RGB2YUV） - 任怀鲁 - 博客园&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/lunix/archive/2011/07/31/rgb2yuv_design_verification.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;3 &lt;/em&gt;&lt;/span&gt;&lt;span&gt;HDMI介绍与流程 - TaigaComplex求职中 - 博客园 https://www.cnblogs.com/TaigaCon/p/3840653.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;ADV7511 PROGRAMMING GUIDE. Low-Power HDMI 1.4 Compatible Transmitter with Audio Return Channel. - Revision G - PDF https://docplayer.net/30916605-Adv7511-programming-guide-low-power-hdmi-1-4-compatible-transmitter-with-audio-return-channel-revision-g.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5 &lt;em id=&quot;__mceDel&quot;&gt;ADV7511 Design Support Files - Documents - Video - EngineerZone &lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;https://ez.analog.com/video/w/documents/794/adv7511-design-support-files&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;6 &lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;FPGA驱动VGA显示静态图片 - 没落骑士 - 博客园 &lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;https://www.cnblogs.com/moluoqishi/p/9544146.html&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 14 May 2019 06:41:00 +0000</pubDate>
<dc:creator>没落骑士</dc:creator>
<og:description>一、前言 目前FPGA成为了视频图像实时处理的主要平台。显示作为图像应用设备的必要功能，对整体系统处理效果非常关键。HDMI是现阶段主流的显示接口，本文基于ADV7511芯片的HDMI显示系统，讲述H</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moluoqishi/p/10860849.html</dc:identifier>
</item>
<item>
<title>黑科技！仅需 3 行代码，就能将 Gitter 集成到个人网站中，实现一个 IM 即时通讯聊天室功能？ - 犬小哈</title>
<link>http://www.cnblogs.com/quanxiaoha/p/10861849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanxiaoha/p/10861849.html</guid>
<description>&lt;blockquote readability=&quot;6.336&quot;&gt;
&lt;p&gt;欢迎关注个人微信公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 文末&lt;strong&gt;分享阿里 P8 高级架构师吐血总结的 《Java 核心知识整理&amp;amp;面试.pdf》资源链接&lt;/strong&gt;！！&lt;/p&gt;
&lt;p&gt;个人网站: &lt;a href=&quot;https://www.exception.site/essay/how-to-use-gitter-on-your-website-quickly&quot; class=&quot;uri&quot;&gt;https://www.exception.site/essay/how-to-use-gitter-on-your-website-quickly&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155776009900425&quot; title=&quot;黑科技？Gitter 集成 IM 即时通讯聊天室&quot; alt=&quot;黑科技？Gitter 集成 IM 即时通讯聊天室&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;小哈从很早以前就有写博文的习惯，不过那个时候，也没咋认真地写，倒是挺喜欢倒腾，从最初在 CSDN 写博客，写了得有 100 多篇后，那时，CSDN 开始加入了恶心的广告，体验开始变得极差后，就弃了 CSDN。&lt;/p&gt;
&lt;p&gt;当时，就想着自己弄个纯净地个人博客，于是，从 Jekyll 到 Hexo 都玩过，最终都放弃了，原因是不能随心所欲地改成自己想要的样式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775954450259&quot; title=&quot;哦？&quot; alt=&quot;哦？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后基于 Bootstrap4 搭了个前端的架子，大部分个性化 css 都是自己手写的，于是也就有了现在的个人网站：&lt;a href=&quot;https://www.exception.site&quot; class=&quot;uri&quot;&gt;https://www.exception.site&lt;/a&gt;, 网站的目的，旨在写出一些高质量的系列教程，帮助大家在工作中速查、学习啥的。但是，就目前来说，文章的数量还是不够，小哈在后续的日子里，会一点点补全的，有兴趣的不妨收藏一下。&lt;/p&gt;
&lt;p&gt;好了，说了这么多废话，开始进入正题，由于网站没有留言，聊天的功能，导致与很多读者 0 沟通，粘性也就比较差。&lt;/p&gt;
&lt;p&gt;那么，要如何在网站中快速的集成 IM 即时通讯功能呢？&lt;/p&gt;
&lt;h2 id=&quot;二什么是-gitter&quot;&gt;二、什么是 Gitter？&lt;/h2&gt;
&lt;p&gt;什么是 Gitter 呢？听名字貌似和 GitHub 有点关系呢？&lt;/p&gt;
&lt;p&gt;以下来之维基百科的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;strong&gt;Gitter&lt;/strong&gt; 是 &lt;strong&gt;GitHub&lt;/strong&gt; 存储库的开发人员和用户的&lt;strong&gt;即时通讯聊天室系统&lt;/strong&gt;。 Gitter 作为&lt;strong&gt;软件即服务&lt;/strong&gt;提供商，提供包括免费选项和所有基本功能，以及创建单个私人聊天室的能力，和个人和组织的付费订阅选项，允许他们创建任意数量的私人聊天室。&lt;/p&gt;
&lt;p&gt;该服务可以为 GitHub 上的各个 Git 存储库创建个人聊天室。聊天室隐私遵循关联 GitHub 存储库的隐私设置：因此，私有的 GitHub 存储库的聊天室对于访问存储库的人员也是私有的。&lt;/p&gt;
&lt;p&gt;它还可以将连接到聊天室的地址信息放置在 git 存储库的 README 文件中，以引起项目所有用户和开发人员的注意。用户也可以通过 GitHub 登录 Gitter 访问他们访问的存储库的私人聊天室。（注意： &lt;strong&gt;GitHub 密码是不与 Gitter 共享&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;Gitter 类似于 IRC 和 Slack。但与 IRC 不同的是，它像Slack一样，会将所有聊天记录存档至云端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775540471359&quot; title=&quot;Gitter&quot; alt=&quot;Gitter&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三访问-gitter-官网并注册用户&quot;&gt;三、访问 Gitter 官网，并注册用户&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;访问 Gitter 官方网站 &lt;a href=&quot;https://gitter.im/&quot;&gt;https://gitter.im&lt;/a&gt;:&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775572810364&quot; title=&quot;Gitter 官网&quot; alt=&quot;Gitter 官网&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册用户，这里支持 GitLab，GitHub, Twitter 三种方式来授权登录，小哈选的是 GitHub:&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775597896843&quot; title=&quot;Gitter 注册&quot; alt=&quot;Gitter 注册&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四创建自己的-gitter-聊天室&quot;&gt;四、创建自己的 Gitter 聊天室&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775625482361&quot; title=&quot;添加自己的Gitter聊天室&quot; alt=&quot;添加自己的Gitter聊天室&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 &lt;strong&gt;ADD A ROOM&lt;/strong&gt; 按钮:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775674852574&quot; title=&quot;创建属于你的聊天室名称&quot; alt=&quot;创建属于你的聊天室名称&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，添加一些朋友加入到你创建的聊天室吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775703152112&quot; title=&quot;添加一些用户加入到你的聊天室&quot; alt=&quot;添加一些用户加入到你的聊天室&quot;/&gt;&lt;/p&gt;
&lt;p&gt;聊天室创建完成啦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775724957749&quot; title=&quot;创建完成&quot; alt=&quot;创建完成&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，让我看下刚刚创建的聊天室：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775751733566&quot; title=&quot;聊天室都有些啥&quot; alt=&quot;聊天室都有些啥&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;①&lt;/strong&gt;：聊天室名称；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;②&lt;/strong&gt;：聊天室唯一域名（&lt;strong&gt;域名要记住，等下我们集成到个人网站需要&lt;/strong&gt;）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;③&lt;/strong&gt;：聊天室描述；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五借助-sidecar-集成-gitter-到个人网站&quot;&gt;五、借助 Sidecar 集成 gitter 到个人网站&lt;/h2&gt;
&lt;p&gt;好了，聊天室你也创建好了，怎么集成到自己的网站咧？为了开箱即用式的集成到个人网站，我们还需要借助一下 Sidecar, 等等！什么是 Sidecar?&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Sidecar 能够帮助你快速便捷的集成 gitter, 仅仅需要添加几行 javascript 代码即可，开箱即用，你还可以通过一些配置来自定义它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sidecar 官方网站为： &lt;a href=&quot;https://sidecar.gitter.im/&quot;&gt;https://sidecar.gitter.im&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775858110863&quot; title=&quot;Sidecar网站&quot; alt=&quot;Sidecar网站&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将如下 javascript 代码，集成到个人网站中：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
  ((window.gitter = {}).chat = {}).options = {
    room: 'quanxiaoha/community'
  };
&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;https://sidecar.gitter.im/dist/sidecar.v1.js&quot; async defer&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六最终效果&quot;&gt;六、最终效果&lt;/h2&gt;
&lt;p&gt;代码集成完毕后，你看到的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775901386624&quot; title=&quot;最终效果1&quot; alt=&quot;最终效果1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开聊天室效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155775911581639&quot; title=&quot;来和小哈聊天吧&quot; alt=&quot;来和小哈聊天吧&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大工告成，有兴趣的童鞋，自己也可以上手试一试哦！&lt;/p&gt;
&lt;h2 id=&quot;七写在最后&quot;&gt;七、写在最后&lt;/h2&gt;
&lt;p&gt;今天小哈给大家介绍了一个黑科技 Gitter, 以及如何通过 Sidecar 快速便捷地集成到自己的个人网站中。持续关注，小哈后面会再推送一些有意思的干货文章哦！下期见！&lt;/p&gt;
&lt;h2 id=&quot;免费分享-面试学习福利资源&quot;&gt;免费分享 | 面试&amp;amp;学习福利资源&lt;/h2&gt;
&lt;p&gt;最近在网上发现一个不错的 PDF 资源《Java 核心知识&amp;amp;面试.pdf》分享给大家，不光是面试，学习，你都值得拥有！！！&lt;/p&gt;
&lt;p&gt;获取方式: 关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复&lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt;，下面是目录以及部分截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651432676587&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651441280253&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651443805696&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651470347464&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651449186666&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651451040055&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重要的事情说两遍，关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复&lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt; ！！！&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注微信公众号-小哈学java&quot;&gt;欢迎关注微信公众号: 小哈学Java&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155634562788477&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 06:06:00 +0000</pubDate>
<dc:creator>犬小哈</dc:creator>
<og:description>欢迎关注个人微信公众号: 小哈学Java , 文末 分享阿里 P8 高级架构师吐血总结的 《Java 核心知识整理&amp;面试.pdf》资源链接 ！！ 个人网站: 'https://www.exceptio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanxiaoha/p/10861849.html</dc:identifier>
</item>
<item>
<title>UWP 推荐 - 限时免费的RSS阅读器《RSS 追踪》登录 Windows 10 - dotNET匠人</title>
<link>http://www.cnblogs.com/enjoy233/p/uwp_recommendation_free_rss_reader_rssStalker_enter_into_windows10.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/uwp_recommendation_free_rss_reader_rssStalker_enter_into_windows10.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文/云之幻&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前不久，博客作者 Bravo Yeung 写了一篇还算略受欢迎的关于 RSS 的文章 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjMzMzE2MA==&amp;amp;mid=2451732414&amp;amp;idx=2&amp;amp;sn=512248c31cce178973a41c3418cfeee3&amp;amp;chksm=b13c04b9864b8dafc615bc99ce91eb48848810a3b1316a17e28844dd8e52b577baf3ded54b6b&amp;amp;scene=21#wechat_redirect&quot;&gt;.Net开发者必知的技术类RSS订阅指南&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;RSS 现在用的人很少了，而且就算是我，也不过是在一周前才开始正视 RSS 。只因为接触到了一个很好很强大的社区 RSS Hub ，当时看到之后就立刻做出一个决定，我要做一个 RSS 阅读器，把自己想看的信息聚合起来。&lt;/p&gt;
&lt;p&gt;于是 RSS 追踪 就做出来了。目前该软件限时免费，速度要快，先到先得噢，后期会恢复 7元 的原价。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件作者给出的文档:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件使用说明 | 云乡 &lt;a href=&quot;https://blog.richasy.cn/document/rss/use.html&quot; class=&quot;uri&quot;&gt;https://blog.richasy.cn/document/rss/use.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av51859853&quot;&gt;【UWP】RSS Stalker介绍_哔哩哔哩 - bilibili&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/4599976/q7y9ujnfr8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里简单选几个特色功能说一下：&lt;/p&gt;
&lt;h2 id=&quot;时间线支持&quot;&gt;时间线支持&lt;/h2&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;软件提供了对 Windows10 特色功能 &lt;code&gt;Timeline&lt;/code&gt; 的支持。你浏览过的文章都会以自适应卡片的形式出现在 Timeline 中，这样即使你切换了设备，同样可以通过时间线来快速回阅。这也弥补了软件本身没有历史记录的不足。&lt;/p&gt;
&lt;h2 id=&quot;onedrive同步&quot;&gt;OneDrive同步&lt;/h2&gt;
&lt;p&gt;在初次运行软件时，会要求你绑定 OneDrive 。绑定之后，你的订阅、稍后阅读、收藏列表还有推送列表都会在云端备份。每当你进行列表的改动，都会同步到云端，你的其它的设备也会进行实时同步。&lt;/p&gt;
&lt;h2 id=&quot;网-页-翻-译&quot;&gt;网 页 翻 译&lt;/h2&gt;
&lt;p&gt;使用百度翻译 API 进行网页翻译，不保证准确率和翻译程度，用它只是因为注册简单且有很高的免费额度。&lt;/p&gt;
&lt;p&gt;使用该功能需要你自行在百度翻译中心注册，很简单，注册之后可以在个人主页的底部找到自己的 &lt;code&gt;AppId&lt;/code&gt; 和 &lt;code&gt;Key&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;订阅推送&quot;&gt;订阅推送&lt;/h2&gt;
&lt;p&gt;你可以自主选择推送哪些订阅源的消息，方法就是在右键点击对应的订阅源（触屏上是长按），在弹出菜单中选择订阅通知即可。&lt;/p&gt;
&lt;p&gt;软件的后台每隔15分钟检查一次订阅源的更新状态，如果有新的文章会进行推送通知。&lt;/p&gt;
&lt;p&gt;即便你关闭了软件，也不会影响到后台程序的运行，所以不用担心。&lt;/p&gt;

&lt;p&gt;你可以通过链接或关键词的方式添加新的订阅源，搜索渠道来自 Feedly 。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/4599976/m6mbem4ww7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/4599976/a9i3q4zn38.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;更多内容在我的博客：&lt;/p&gt;
&lt;p&gt;云乡 - 云之幻 &lt;a href=&quot;http://blog.richasy.cn&quot; class=&quot;uri&quot;&gt;http://blog.richasy.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;下载地址：&lt;/p&gt;
&lt;p&gt;Get RSS Stalker - Microsoft Store&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/zh-cn/p/rss-stalker/9n85pv1rjd6v&quot; class=&quot;uri&quot;&gt;https://www.microsoft.com/zh-cn/p/rss-stalker/9n85pv1rjd6v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该软件的系统要求：Windows10 v1809 及以上&lt;/p&gt;

&lt;p&gt;在win10中查看系统版本的方法：&lt;/p&gt;
&lt;p&gt;按下图，在开始菜单中输入winver, 然后以管理员权限运行。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/4599976/btmp8ibqpy.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;Windows 10 更新助手:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.microsoft.com/zh-cn/help/3159635/windows-10-update-assistant&quot; class=&quot;uri&quot;&gt;https://support.microsoft.com/zh-cn/help/3159635/windows-10-update-assistant&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;升级成功之后再输入命令winver是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/4599976/c3ybmwt9yv.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;em&gt;原文地址：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65353860&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/65353860&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjMzMzE2MA==&amp;amp;mid=2451732526&amp;amp;idx=1&amp;amp;sn=5d6277a9ca6c0e2e6809f9019f464ba4&amp;amp;chksm=b13c0b29864b823f66e0be8fdd769a1df18ee40fb52fed4cbf6b8d4ae9676bb860dcd32fa8d2&amp;amp;token=427970361&amp;amp;lang=zh_CN#rd&quot;&gt;程会玩 | 无需自行编译也能玩转 Windows Terminal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjMzMzE2MA==&amp;amp;mid=2451732519&amp;amp;idx=1&amp;amp;sn=ddc3dbe4b2cea553682e55487942bae3&amp;amp;chksm=b13c0b20864b82360367e3806fc17c32a8ee9cf7799646e982c6e0a778af26da8ca93b48a192&amp;amp;scene=21#wechat_redirect&quot;&gt;黑科技抢先尝 | Windows全新终端初体验(附代码Build全过程)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjMzMzE2MA==&amp;amp;mid=2451732493&amp;amp;idx=1&amp;amp;sn=501a2b355afc0d8a9092a95f698c8168&amp;amp;chksm=b13c0b0a864b821c1589b39b5b054c20a15e595eb364b82f23b9b5702bad238680e1dc57118d&amp;amp;scene=21#wechat_redirect&quot;&gt;UWP 推荐 | 限时免费的RSS阅读器《RSS 追踪》登录 Windows 10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjMzMzE2MA==&amp;amp;mid=2451732406&amp;amp;idx=1&amp;amp;sn=a597dda49bebdca7706bcaa20d880af4&amp;amp;chksm=b13c04b1864b8da75b8fa0141347005db3d0060c7cf9a4c08a5280abb80f767a280e2190218f&amp;amp;scene=21#wechat_redirect&quot;&gt;开发者见闻 | ASP.NET Core开发者路线图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 05:52:00 +0000</pubDate>
<dc:creator>dotNET匠人</dc:creator>
<og:description>文/云之幻 前不久，博客作者 Bravo Yeung 写了一篇还算略受欢迎的关于 RSS 的文章 '.Net开发者必知的技术类RSS订阅指南' 。 RSS 现在用的人很少了，而且就算是我，也不过是在一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoy233/p/uwp_recommendation_free_rss_reader_rssStalker_enter_into_windows10.html</dc:identifier>
</item>
<item>
<title>使用 ASP.NET Core MVC 创建 Web API——响应数据的内容协商（七） - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/10861728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/10861728.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10614598.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（一）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10649898.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（二）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10697463.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（三）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10727666.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（四）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10824919.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（六）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;     ASP.NET Core MVC 包含对通过固定格式或根据客户端规范来设置响应数据格式的内置支持。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     ASP.NET Web API的内容协商（Content Negotiation）机制的理想情况是这样的：客户端在请求头的Accept字段中指定什么样的MIME类型，Web API服务端就返回对应的MIME类型的内容（响应头的中Content-Type就是Accept中指定的MIME类型）。而现实情况是，Web API服务端能返回什么MIME类型的响应类型取决于有没有对应这个MIME类型的MediaTypeFormatter。ASP.NET Core Web API的默认提供JsonMediaTypeFormatter，如果要支持 XmlMediaTypeFormatter需要进行配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      ASP.NET Core MVC 使用的默认格式是 JSON。 内容协商由 &lt;code&gt;ObjectResult&lt;/code&gt; 实现。 它还内置于从帮助程序方法（全部基于 &lt;code&gt;ObjectResult&lt;/code&gt;）返回的特定于状态代码的操作结果中。 还可以返回一个模型类型（已定义为数据传输类型的类），框架将自动将其打包在 &lt;code&gt;ObjectResult&lt;/code&gt; 中。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;      以下操作方法返回一个对象实例和 &lt;code&gt;NotFound&lt;/code&gt; 帮助程序方法：     &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;lt;Book&amp;gt;&amp;gt; GetBookItem(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bookItem = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _context.Book.FindAsync(id); 

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bookItem == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bookItem;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    将返回 JSON 格式的响应，除非请求了另一个格式且服务器可以返回所请求格式。 可以使用 Rester工具创建包括 Accept 标头的请求并指定另一种格式。 在此情况下，如果服务器有可以生成所请求格式的响应的格式化程序，则结果会以服务器首选的格式返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1) 在Visual Studio 2017中按F5，启动BookApi应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2) 打开Firefox浏览器，并打开 Rester，在Reseter中，将 HTTP 方法设置为 &lt;code&gt;GET&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   3) 然后在URL输入框中输入要获取的对象URI，例如 &lt;code&gt;http://localhost:5000/api/book/25&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   4) 选择“Headers”选项卡，选择“&lt;code&gt;Accept&lt;/code&gt;”选项，并将值设置为 JSON (&lt;code&gt;application/json&lt;/code&gt;)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    5) 使用鼠标点击“Send”按钮。请求将收到具有作书籍数据的“200 正常”响应。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514132903211-1412777851.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     6) 选择“Headers”选项卡，选择“&lt;code&gt;Accept&lt;/code&gt;”选项，并将值设置为 xml (&lt;code&gt;application/xml&lt;/code&gt;)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     7) 使用鼠标点击“Send”按钮。请求将收到具有作书籍数据的“200 正常”响应。如下图。我们虽然指定 &lt;code&gt;Accept为 application/xml&lt;/code&gt;，但是在默认情况下，ASP.NET Core MVC 仅支持 JSON。所以，即使指定另一种格式，返回的结果仍然是 JSON 格式，而不是我们希望的xml。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514132930011-1288302619.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      控制器操作可以返回 POCO（普通旧 CLR 对象），在这种情况下，ASP.NET Core MVC 将自动创建打包对象的 &lt;code&gt;ObjectResult&lt;/code&gt;。 客户端将获取设有格式的序列化对象（默认为 JSON 格式，可以配置 XML 或其他格式）。 如果返回的对象为 &lt;code&gt;null&lt;/code&gt;，那么框架将返回 &lt;code&gt;204 No Content&lt;/code&gt; 响应。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;    1） 在Visual Studio 2017中打开BookController.cs文件，添加以下 &lt;code&gt;GetBook&lt;/code&gt; 方法返回实体对象，代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  Book GetBook(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bookItem =&lt;span&gt;  _context.Book.Find(id);       
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bookItem;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     2）在Visual Studio 2017中按F5启动Web应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3） 打开浏览器，一并打开Rester。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     4) 将 HTTP 方法设置为 &lt;code&gt;GET&lt;/code&gt;。将请求 URL 设置为 &lt;code&gt;http://localhost:5000/api/Book/25&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    5) 使用鼠标点击“Send”按钮。请求将收到具有作书籍数据的“200 正常”响应。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514133029696-262234947.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   6） 请求无效将收到“204 无内容”响应。 如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514133041736-1787096626.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;    配置格式化程序&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       如果应用程序需要支持默认 JSON 格式以外的其他格式，那么可以添加 NuGet 包并配置 MVC 来支持它们。输入和输出的格式化程序不同。输入格式化程序由模型绑定使用；输出格式化程序用来设置响应格式。 还可以配置自定义格式化程序。请求头的Accept中除非指定为application/xml或者application/json，否则指定其它任何MIME，&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;      添加 XML 格式支持&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      在Visual Studio 2017若要添加对 XML 格式的支持，请安装 &lt;code&gt;Microsoft.AspNetCore.Mvc.Formatters.Xml&lt;/code&gt; NuGet 包。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     1. 在Visual Studio 2017的菜单&amp;gt;工具&amp;gt;选项对话框中，选择“NuGet包管理器”中的常规，根据自己需要，设置默认包管理格式，如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514133103687-60557821.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     2. 在解决方案资源管理器中，右键单击“引用”，选择“管理 NuGet 程序包”，如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514133113407-47865157.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     3.将“nuget.org”选择为“包源”，选择“浏览”选项卡并搜索“&lt;code&gt;Microsoft.AspNetCore.Mvc.Formatters.Xml&lt;/code&gt;”，在列表中选择该包，然后选择“安装”，如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514133127773-1722935730.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      4.在Visual Studio 2017中打开Startup.cs文件，将 XmlSerializerFormatters 配置添加到 Startup类的ConfigureServices方法中。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddDbContext&lt;/span&gt;&amp;lt;BookContext&amp;gt;(options =&amp;gt;   options.UseSqlServer(Configuration.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BookContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))); &lt;br/&gt;services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
                .AddXmlSerializerFormatters();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;      或者，可以仅添加输出格式化程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
services.AddMvc(options =&amp;gt;&lt;span&gt;
{
    options.OutputFormatters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlSerializerOutputFormatter());
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;  &lt;/code&gt; 通过上面的代码我们添加了对 XML 格式的支持，控制器方法会基于请求的 &lt;code&gt;Accept&lt;/code&gt; 标头返回相应的格式。接下来我们来测试一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     1) 在Visual Studio 2017中按F5，启动BookApi应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     2) 打开Firefox浏览器，并打开 Rester，在Reseter中，将 HTTP 方法设置为 &lt;code&gt;GET&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     3) 选择“Headers”选项卡，选择“&lt;code&gt;Accept&lt;/code&gt;”选项，并将值设置为 xml (&lt;code&gt;application/xml&lt;/code&gt;)。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     4) 使用鼠标左键，单击“SEND”按钮。 响应返回200，响应窗格显示 &lt;code&gt;Content-Type: application/xml&lt;/code&gt; 标头，且 &lt;code&gt;Book&lt;/code&gt; 对象已序列化为 XML。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514133258678-1454123468.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     5) 选择“Headers”选项卡，选择“&lt;code&gt;Accept&lt;/code&gt;”选项，并将值设置为 JSON (&lt;code&gt;application/json&lt;/code&gt;)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      6) 使用鼠标左键，单击“SEND”按钮。 响应返回200，响应窗格显示 &lt;code&gt;Content-Type: application/json&lt;/code&gt; 标头，且 &lt;code&gt;Book&lt;/code&gt; 对象已序列化为 JSON。如下图。从图片中可以看到请求了设置 &lt;code&gt;Accept: application/json&lt;/code&gt; 的标头，且响应也将它指定为其 &lt;code&gt;Content-Type&lt;/code&gt;。 &lt;code&gt;BOOK&lt;/code&gt; 对象以 JSON 格式显示在响应正文中。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201905/10343-20190514133333875-1832099809.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;     内容协商过程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      内容协商仅在 &lt;code&gt;Accept&lt;/code&gt; 标头出现在请求中时发生。 请求包含 accept 标头时，框架会以最佳顺序枚举 accept 标头中的媒体类型，并且尝试查找可以生成一种由 accept 标头指定格式的响应的格式化程序。 如果未找到可以满足客户端请求的格式化程序，框架将尝试找到第一个可以生成响应的格式化程序（除非开发人员配置 &lt;code&gt;MvcOptions&lt;/code&gt; 上的选项以返回“406 不可接受”）。 如果请求指定 XML，但是未配置 XML 格式化程序，那么将使用 JSON 格式化程序。 一般来说，如果没有配置可以提供所请求格式的格式化程序，那么使用第一个可以设置对象格式的格式化程序。 如果不提供任何标头，则将使用第一个可以处理要返回的对象的格式化程序来序列化响应。 在此情况下，没有任何协商发生 - 服务器确定将使用的格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         如果 Accept 标头包含 &lt;code&gt;*/*&lt;/code&gt;，则将忽略该标头，除非 &lt;code&gt;RespectBrowserAcceptHeader&lt;/code&gt; 在 &lt;code&gt;MvcOptions&lt;/code&gt; 上设置为 true。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 05:35:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<og:description>ASP.NET Core MVC 包含对通过固定格式或根据客户端规范来设置响应数据格式的内置支持。 ASP.NET Web API的内容协商（Content Negotiation）机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chillsrc/p/10861728.html</dc:identifier>
</item>
<item>
<title>中文情感分析——snownlp类库 源码注释及使用 - 勋爵</title>
<link>http://www.cnblogs.com/X-knight/p/10853699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-knight/p/10853699.html</guid>
<description>&lt;p&gt;最近发现了snownlp这个库，这个类库是专门针对中文文本进行文本挖掘的。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;主要功能：&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;中文分词（&lt;a href=&quot;http://aclweb.org/anthology//Y/Y09/Y09-2047.pdf&quot; rel=&quot;nofollow&quot;&gt;Character-Based Generative Model&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;词性标注（&lt;a href=&quot;http://aclweb.org/anthology//A/A00/A00-1031.pdf&quot; rel=&quot;nofollow&quot;&gt;TnT&lt;/a&gt; 3-gram 隐马）&lt;/li&gt;
&lt;li&gt;情感分析（现在训练数据主要是买卖东西时的评价，所以对其他的一些可能效果不是很好，待解决）&lt;/li&gt;
&lt;li&gt;文本分类（Naive Bayes）&lt;/li&gt;
&lt;li&gt;转换成拼音（Trie树实现的最大匹配）&lt;/li&gt;
&lt;li&gt;繁体转简体（Trie树实现的最大匹配）&lt;/li&gt;
&lt;li&gt;提取文本关键词（&lt;a href=&quot;http://acl.ldc.upenn.edu/acl2004/emnlp/pdf/Mihalcea.pdf&quot; rel=&quot;nofollow&quot;&gt;TextRank&lt;/a&gt;算法）&lt;/li&gt;
&lt;li&gt;提取文本摘要（&lt;a href=&quot;http://acl.ldc.upenn.edu/acl2004/emnlp/pdf/Mihalcea.pdf&quot; rel=&quot;nofollow&quot;&gt;TextRank&lt;/a&gt;算法）&lt;/li&gt;
&lt;li&gt;tf，idf&lt;/li&gt;
&lt;li&gt;Tokenization（分割成句子）&lt;/li&gt;
&lt;li&gt;文本相似（&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot; rel=&quot;nofollow&quot;&gt;BM25&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;支持python3（感谢&lt;a href=&quot;https://github.com/erning&quot;&gt;erning&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;官网信息：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;snownlp github:&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/isnowfy/snownlp&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/isnowfy/snownlp&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;使用及源码分析：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;snownlp类库的安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ pip install snownlp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用snownlp进行情感分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; snownlp &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SnowNLP

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建snownlp对象，设置要测试的语句&lt;/span&gt;
s = SnowNLP(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;买来给家婆用来洗儿子的衣服的&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,s.words)   
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将句子分成单词      &lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ['买', '来', '给', '家婆', '用', '来', '洗', '儿子', '的', '衣服', '的']&lt;/span&gt;
&lt;span&gt;
s.tags         
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 例如：[(u'这个', u'r'), (u'东西', u'n'),&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  (u'真心', u'd'), (u'很', u'd'),&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  (u'赞', u'Vg')]&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用sentiments方法获取积极情感概率 positive的概率&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,s.sentiments)

s.pinyin        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将汉字语句转换为Pinyin语句&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 例如：[u'zhe', u'ge', u'dong', u'xi',&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  u'zhen', u'xin', u'hen', u'zan']&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;————————————————————————————————————————————————————————————————————————————————————————————————————————&lt;/span&gt;
s = SnowNLP(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;「繁體字」「繁體中文」的叫法在臺灣亦很常見。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

s.han           &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将繁体字转换为简体字      &lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; u'「繁体字」「繁体中文」的叫法&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在台湾亦很常见。'&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;————————————————————————————————————————————————————————————————————————————————————————————————————————&lt;/span&gt;
text = u&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
自然语言处理是计算机科学领域与人工智能领域中的一个重要方向。
它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法。
自然语言处理是一门融语言学、计算机科学、数学于一体的科学。
因此，这一领域的研究将涉及自然语言，即人们日常使用的语言，
所以它与语言学的研究有着密切的联系，但又有重要的区别。
自然语言处理并不是一般地研究自然语言，
而在于研制能有效地实现自然语言通信的计算机系统，
特别是其中的软件系统。因而它是计算机科学的一部分。
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

s &lt;/span&gt;=&lt;span&gt; SnowNLP(text)

s.keywords(&lt;/span&gt;3)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [u'语言', u'自然', u'计算机']&lt;/span&gt;
&lt;span&gt;
s.summary(&lt;/span&gt;3)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [u'因而它是计算机科学的一部分',&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  u'自然语言处理是一门融语言学、计算机科学、&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     数学于一体的科学',&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  u'自然语言处理是计算机科学领域与人工智能&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     领域中的一个重要方向']&lt;/span&gt;
&lt;span&gt;s.sentences
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分成句子&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;————————————————————————————————————————————————————————————————————————————————————————————————————————&lt;/span&gt;
s = SnowNLP([[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;这篇&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文章&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
             [u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;那篇&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;论文&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
             [u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s.tf)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;TF意思是词频(Term Frequency)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(s.idf)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;IDF意思是逆文本频率指数(Inverse Document Frequency)  &lt;/span&gt;
s.sim([u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文章&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])&lt;span&gt;#&lt;/span&gt;&lt;span&gt; [0.3756070762985226, 0, 0]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;实现过程：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.首先从SnowNLP入手，看一下sentiments方法，在sentiments方法中，调用了sentiment下的分类方法。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; unicode_literals
 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; normal
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; seg
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tag
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sentiment
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .sim &lt;span&gt;import&lt;/span&gt;&lt;span&gt; bm25
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .summary &lt;span&gt;import&lt;/span&gt;&lt;span&gt; textrank
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .summary &lt;span&gt;import&lt;/span&gt;&lt;span&gt; words_merge
 
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SnowNLP(object):
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, doc):
        self.doc &lt;/span&gt;=&lt;span&gt; doc
        self.bm25 &lt;/span&gt;=&lt;span&gt; bm25.BM25(doc)
 
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; words(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; seg.seg(self.doc)
 
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sentences(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; normal.get_sentences(self.doc)
 
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; han(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; normal.zh2hans(self.doc)
 
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pinyin(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; normal.get_pinyin(self.doc)
 
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sentiments(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sentiment.classify(self.doc)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用了sentiment的classify分类方法&lt;/span&gt;
&lt;span&gt; 
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tags(self):
        words &lt;/span&gt;=&lt;span&gt; self.words
        tags &lt;/span&gt;=&lt;span&gt; tag.tag(words)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zip(words, tags)
 
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tf(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.bm25.f
 
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; idf(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.bm25.idf
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sim(self, doc):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.bm25.simall(doc)
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; summary(self, limit=5&lt;span&gt;):
        doc &lt;/span&gt;=&lt;span&gt; []
        sents &lt;/span&gt;=&lt;span&gt; self.sentences
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; sent &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sents:
            words &lt;/span&gt;=&lt;span&gt; seg.seg(sent)
            words &lt;/span&gt;=&lt;span&gt; normal.filter_stop(words)
            doc.append(words)
        rank &lt;/span&gt;=&lt;span&gt; textrank.TextRank(doc)
        rank.solve()
        ret &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt;&lt;span&gt; rank.top_index(limit):
            ret.append(sents[index])
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; keywords(self, limit=5, merge=&lt;span&gt;False):
        doc &lt;/span&gt;=&lt;span&gt; []
        sents &lt;/span&gt;=&lt;span&gt; self.sentences
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; sent &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sents:
            words &lt;/span&gt;=&lt;span&gt; seg.seg(sent)
            words &lt;/span&gt;=&lt;span&gt; normal.filter_stop(words)
            doc.append(words)
        rank &lt;/span&gt;=&lt;span&gt; textrank.KeywordTextRank(doc)
        rank.solve()
        ret &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt;&lt;span&gt; rank.top_index(limit):
            ret.append(w)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; merge:
            wm &lt;/span&gt;=&lt;span&gt; words_merge.SimpleMerge(self.doc, ret)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wm.merge()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ret
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.sentiment文件夹下的__init__文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sentiment中创建了Sentiment对象&lt;/p&gt;
&lt;p&gt;首先调用load方法加载训练好的数据字典，然后调用classify方法，在classify方法中实际调用的是Bayes对象中的classify方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; unicode_literals
 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; codecs
 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .. &lt;span&gt;import&lt;/span&gt;&lt;span&gt; normal
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .. &lt;span&gt;import&lt;/span&gt;&lt;span&gt; seg
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; ..classification.bayes &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Bayes
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据文件路径&lt;/span&gt;
data_path = os.path.join(os.path.dirname(os.path.abspath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;)),
                         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sentiment.marshal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentiment(object):
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建Bayes对象&lt;/span&gt;
        self.classifier =&lt;span&gt; Bayes()
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存训练好的字典数据&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; save(self, fname, iszip=&lt;span&gt;True):
        self.classifier.save(fname, iszip)
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载字典数据&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; load(self, fname=data_path, iszip=&lt;span&gt;True):
        self.classifier.load(fname, iszip)
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对文档分词&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle(self, doc):
        words &lt;/span&gt;=&lt;span&gt; seg.seg(doc)
        words &lt;/span&gt;=&lt;span&gt; normal.filter_stop(words)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; words
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练数据集&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; train(self, neg_docs, pos_docs):
        data &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取消极评论list，同时为每条评论加上neg标签，也放入到一个list中&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; sent &lt;span&gt;in&lt;/span&gt;&lt;span&gt; neg_docs:
            data.append([self.handle(sent), &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;neg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取积极评论list，为每条评论加上pos标签&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; sent &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pos_docs:
            data.append([self.handle(sent), &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用分类器的训练数据集方法，对模型进行训练&lt;/span&gt;
&lt;span&gt;        self.classifier.train(data)
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分类&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; classify(self, sent):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用贝叶斯分类器的分类方法，获取分类标签和概率&lt;/span&gt;
        ret, prob =&lt;span&gt; self.classifier.classify(self.handle(sent))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果分类标签是pos直接返回概率值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ret == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; prob
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果返回的是neg，由于显示的是积极概率值，因此用1减去消极概率值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 1-&lt;span&gt;prob
 
 
classifier &lt;/span&gt;=&lt;span&gt; Sentiment()
classifier.load()
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; train(neg_file, pos_file):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开消极数据文件&lt;/span&gt;
    neg = codecs.open(neg_file, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).readlines()
    pos &lt;/span&gt;= codecs.open(pos_file, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).readlines()
    neg_docs &lt;/span&gt;=&lt;span&gt; []
    pos_docs &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历每一条消极评论，放入到list中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; neg:
        neg_docs.append(line.rstrip(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历每一条积极评论，放入到list中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pos:
        pos_docs.append(line.rstrip(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; classifier
    classifier &lt;/span&gt;=&lt;span&gt; Sentiment()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据，传入积极、消极评论list&lt;/span&gt;
&lt;span&gt;    classifier.train(neg_docs, pos_docs)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存数据字典&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; save(fname, iszip=&lt;span&gt;True):
    classifier.save(fname, iszip)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载数据字典&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; load(fname, iszip=&lt;span&gt;True):
    classifier.load(fname, iszip)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对语句进行分类&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; classify(sent):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; classifier.classify(sent)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sentiment中包含了训练数据集的方法，看一下是如何训练数据集的：&lt;br/&gt;在sentiment文件夹下，包含了以下文件：&lt;/p&gt;
&lt;p&gt;neg.txt和pos.txt是已经分类好的评论数据，neg.txt中都是消极评论，pos中是积极评论&lt;/p&gt;
&lt;p&gt;sentiment.marshal和sentiment.marshal.3中存放的是序列化后的数据字典，这个也稍后再说&lt;/p&gt;
&lt;p&gt;（1）在train()方法中，首先读取消极和积极评论txt文件，然后获取每一条评论，放入到list集合中，格式大致如下&lt;/p&gt;
&lt;p&gt;[ ' 还没有收到书！！！还没有收到书 ' , ' 小熊宝宝我觉得孩子不喜欢，能换别的吗 ' , ......]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; train(neg_file, pos_file):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开消极数据文件&lt;/span&gt;
    neg = codecs.open(neg_file, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).readlines()
    pos &lt;/span&gt;= codecs.open(pos_file, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).readlines()
    neg_docs &lt;/span&gt;=&lt;span&gt; []
    pos_docs &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历每一条消极评论，放入到list中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; neg:
        neg_docs.append(line.rstrip(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历每一条积极评论，放入到list中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pos:
        pos_docs.append(line.rstrip(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; classifier
    classifier &lt;/span&gt;=&lt;span&gt; Sentiment()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据，传入积极、消极评论list&lt;/span&gt;
    classifier.train(neg_docs, pos_docs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后调用了Sentiment对象中的train()方法：&lt;br/&gt;在train方法中，遍历了传入的积极、消极评论list，为每条评论进行分词，并为加上了分类标签，此时的数据格式如下：&lt;/p&gt;
&lt;p&gt;评论分词后的数据格式：['收到','没有'...]&lt;/p&gt;
&lt;p&gt;加上标签后的数据格式(以消极评论为例)：[ [['收到','没有' ...],'neg'] ,  [['小熊','宝宝' ...],‘neg’] ........]]&lt;/p&gt;
&lt;p&gt;可以看到每一条评论都是一个list，其中又包含了评论分词后的list和评论的分类标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练数据集&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; train(self, neg_docs, pos_docs):
        data &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取消极评论list，对每条评论分词，并加上neg标签，也放入到一个list中&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; sent &lt;span&gt;in&lt;/span&gt;&lt;span&gt; neg_docs:
            data.append([self.handle(sent), &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;neg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取积极评论list，为每条评论分词，加上pos标签&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; sent &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pos_docs:
            data.append([self.handle(sent), &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用分类器的训练数据集方法，对模型进行训练&lt;/span&gt;
        self.classifier.train(data)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过了此步骤，已经对数据处理完毕，接下来就可以对数据进行训练&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;3.classification下的bayes.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; unicode_literals
 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gzip
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; marshal
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; math &lt;span&gt;import&lt;/span&gt;&lt;span&gt; log, exp
 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; ..utils.frequency &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AddOneProb
 
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bayes(object):
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;标签数据对象&lt;/span&gt;
        self.d =&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;所有分类的词数之和&lt;/span&gt;
        self.total =&lt;span&gt; 0
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存字典数据&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; save(self, fname, iszip=&lt;span&gt;True):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建对象，用来存储训练结果&lt;/span&gt;
        d =&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加total，也就是积极消极评论分词总词数&lt;/span&gt;
        d[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.total
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;d为分类标签，存储每个标签的数据对象&lt;/span&gt;
        d[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.d.items():
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;k为分类标签，v为标签对应的所有分词数据，是一个AddOneProb对象&lt;/span&gt;
            d[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][k] = v.&lt;span&gt;__dict__&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里判断python版本&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; sys.version_info[0] == 3&lt;span&gt;:
            fname &lt;/span&gt;= fname + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里可有两种方法可以选择进行存储&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; iszip:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#将序列化后的二进制数据直接写入文件&lt;/span&gt;
            marshal.dump(d, open(fname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;首先获取序列化后的二进制数据，然后写入文件&lt;/span&gt;
            f = gzip.open(fname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            f.write(marshal.dumps(d))
            f.close()
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载数据字典&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; load(self, fname, iszip=&lt;span&gt;True):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断版本&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; sys.version_info[0] == 3&lt;span&gt;:
            fname &lt;/span&gt;= fname + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断打开文件方式&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; iszip:
            d &lt;/span&gt;= marshal.load(open(fname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                f &lt;/span&gt;= gzip.open(fname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                d &lt;/span&gt;=&lt;span&gt; marshal.loads(f.read())
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; IOError:
                f &lt;/span&gt;= open(fname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                d &lt;/span&gt;=&lt;span&gt; marshal.loads(f.read())
            f.close()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从文件中读取数据，为total和d对象赋值&lt;/span&gt;
        self.total = d[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        self.d &lt;/span&gt;=&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt; d[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].items():
            self.d[k] &lt;/span&gt;=&lt;span&gt; AddOneProb()
            self.d[k].&lt;/span&gt;&lt;span&gt;__dict__&lt;/span&gt; =&lt;span&gt; v
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据集&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; train(self, data):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历数据集&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;d[1]标签--&amp;gt;分类类别&lt;/span&gt;
            c = d[1&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断数据字典中是否有当前的标签&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; c &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.d:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果没有该标签，加入标签，值是一个AddOneProb对象&lt;/span&gt;
                self.d[c] =&lt;span&gt; AddOneProb()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;d[0]是评论的分词list，遍历分词list&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; d[0]:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用AddOneProb中的add方法，添加单词&lt;/span&gt;
                self.d[c].add(word, 1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算总词数&lt;/span&gt;
        self.total = sum(map(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x: self.d[x].getsum(), self.d.keys()))
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;贝叶斯分类&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; classify(self, x):
        tmp &lt;/span&gt;=&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历每个分类标签&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.d:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取每个分类标签下的总词数和所有标签总词数，求对数差相当于log（某标签下的总词数/所有标签总词数）&lt;/span&gt;
            tmp[k] = log(self.d[k].getsum()) -&lt;span&gt; log(self.total)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; x:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取每个单词出现的频率，log[（某标签下的总词数/所有标签总词数）*单词出现频率]&lt;/span&gt;
                tmp[k] +=&lt;span&gt; log(self.d[k].freq(word))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算概率，由于直接得到的概率值比较小，这里应该使用了一种方法来转换，原理还不是很明白&lt;/span&gt;
        ret, prob =&lt;span&gt; 0, 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.d:
            now &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; otherk &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.d:
                    now &lt;/span&gt;+= exp(tmp[otherk]-&lt;span&gt;tmp[k])
                now &lt;/span&gt;= 1/&lt;span&gt;now
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OverflowError:
                now &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; now &amp;gt;&lt;span&gt; prob:
                ret, prob &lt;/span&gt;=&lt;span&gt; k, now
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (ret, prob)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; good_turing
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseProb(object):
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.d &lt;/span&gt;=&lt;span&gt; {}
        self.total &lt;/span&gt;= 0.0&lt;span&gt;
        self.none &lt;/span&gt;=&lt;span&gt; 0
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exists(self, key):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.d
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; getsum(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.total
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, key):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.exists(key):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False, self.none
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True, self.d[key]
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; freq(self, key):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; float(self.get(key)[1])/&lt;span&gt;self.total
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; samples(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.d.keys()
 
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; NormalProb(BaseProb):
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self, key, value):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.exists(key):
            self.d[key] &lt;/span&gt;=&lt;span&gt; 0
        self.d[key] &lt;/span&gt;+=&lt;span&gt; value
        self.total &lt;/span&gt;+=&lt;span&gt; value
 
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AddOneProb(BaseProb):
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.d &lt;/span&gt;=&lt;span&gt; {}
        self.total &lt;/span&gt;= 0.0&lt;span&gt;
        self.none &lt;/span&gt;= 1
 
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加单词&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self, key, value):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;更新该类别下的单词总数&lt;/span&gt;
        self.total +=&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果单词未出现过&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.exists(key):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将单词加入对应标签的数据字典中，value设为1&lt;/span&gt;
            self.d[key] = 1
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;更新总词数&lt;/span&gt;
            self.total += 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果单词出现过，对该单词的value值加1&lt;/span&gt;
        self.d[key] += value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在bayes对象中，有两个属性d和total,d是一个数据字典，total存储所有分类的总词数，经过train方法训练数据集后，d中存储的是每个分类标签的数据key为分类标签，value是一个AddOneProb对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.d &lt;/span&gt;=&lt;span&gt; {}
        self.total &lt;/span&gt;= 0.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在AddOneProb对象中，同样存在d和total属性，这里的total存储的是每个分类各自的单词总数，d中存储的是所有出现过的单词，单词作为key，单词出现的次数作为value.&lt;br/&gt;为了下次计算概率时，不用重新训练，可以将训练得到的数据序列化到文件中，下次直接加载文件，将文件反序列为对象，从对象中获取数据即可(save和load方法)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.得到训练数据后，使用朴素贝叶斯分类进行分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该方法可自行查阅。&lt;/p&gt;

</description>
<pubDate>Tue, 14 May 2019 04:59:00 +0000</pubDate>
<dc:creator>勋爵</dc:creator>
<og:description>最近发现了snownlp这个库，这个类库是专门针对中文文本进行文本挖掘的。 主要功能： 中文分词（Character-Based Generative Model） 词性标注（TnT 3-g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-knight/p/10853699.html</dc:identifier>
</item>
</channel>
</rss>