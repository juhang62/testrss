<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>经典相位法三维轮廓测量模型 - 3D视觉工坊</title>
<link>http://www.cnblogs.com/YongQiVisionIMAX/p/12765145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YongQiVisionIMAX/p/12765145.html</guid>
<description>&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;2rk9b-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2rk9b-0-0&quot;&gt;作者：书涵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Date：2020-04-24&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;2rk9b-0-0&quot;&gt;&lt;span&gt;来源：&lt;/span&gt;&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://mp.weixin.qq.com/s/o6FGtJGrGdMf8ECnBfbT4A&quot; target=&quot;_blank&quot; data-offset-key=&quot;b2pdh-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;b2pdh-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;经典相位法三维轮廓测量模型&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;92qe4-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;92qe4-0-0&quot;&gt;在结构光三维测量中，之前笔者介绍了关于把投影看做相机的逆的模型，这次笔者要介绍一个经典相位三维轮廓测量模型，有很多相位三维轮廓测量模型都是在经典相位测量模型上的改进。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;de4so-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;de4so-0-0&quot;&gt;如下图所示，在经典三维轮廓测量模型中，需要精准的设置相机，投影与参考平面的位置关系。具体设置如下：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;415qt-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;415qt-0-0&quot;&gt;1.投影平面需要与参考平面平行，且投影坐标系的X轴和Y轴要分别于参考平面的X轴和Y轴平行&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;12vbh-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;12vbh-0-0&quot;&gt;2.相机坐标系Y轴要与参考平面的Y轴平行&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;5bqo4-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5bqo4-0-0&quot;&gt;3.像机光心与投影中心连线要平行于参考平面，像机光轴与投影仪光轴交于参考平面顶点（图中O点）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-15cf9cd42c8e751797cc603b10d7644a_720w.webp&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;426&quot; data-rawheight=&quot;257&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-15cf9cd42c8e751797cc603b10d7644a.webp&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-0d4cd9e67a77d58633f369233a17253e.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;61g4c-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;61g4c-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;根据上述设置，物体的实际高度可以通过相似三角形求得。所求得的高度是物体相对参考平面的高度。推导如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;72gld-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;72gld-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;如上图所示可知，有如下相似关系，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-0432368825ef1351340668037fab45c0_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;729&quot; data-rawheight=&quot;62&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;7gqqm-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7gqqm-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;则由相似三角形原理，可以得到，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-cc5d96479bf80935084fb036d9b17523_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;257&quot; data-rawheight=&quot;144&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-cc5d96479bf80935084fb036d9b17523.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-2f1610a826624a5f0998ed6825b3dab3.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-1f3760e1aa105979dbfd9d57fb58ed08_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;256&quot; data-rawheight=&quot;126&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-1f3760e1aa105979dbfd9d57fb58ed08.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-2a0ab29500b6580abdf78426af61135f.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;dqigg-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dqigg-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;由于&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-ff25bb2c8adcd1b07ba6a4dfeadb9e82_720w.webp&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;310&quot; data-rawheight=&quot;57&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-ff25bb2c8adcd1b07ba6a4dfeadb9e82.webp&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-c9aed6ff86da3148b20c4b58340d00d8.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;eur1i-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;eur1i-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;（投影中心到参考平面距离）则由等比关系式可得：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-35af32ee6e9c0bf78c6a73d8e767391b_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;311&quot; data-rawheight=&quot;89&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-35af32ee6e9c0bf78c6a73d8e767391b.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-e09d252cb2ca86a978eedc6d17dc0e1d.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;3v2is-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3v2is-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;至此，就可以得到物体相对于参考平面的高度PP‘的表达式，想要真正求得物体的实际高度，我们不仅需要提前测量投影中心到参考平面的长度l和投影中心与相机中心的距离d，还需要对参考平面进行标定。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;7hfdu-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;7hfdu-0-0&quot;&gt;&lt;span data-offset-key=&quot;7hfdu-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在对参考平面进行标定时，要做两件事。一是测量一个相位周期（2π）的光栅投影到参考平面上后的光栅的长度 &lt;span class=&quot;Formula isEditable&quot;&gt;&lt;img class=&quot;Formula-image&quot; src=&quot;https://www.zhihu.com/equation?tex=%5Clambda_%7B0%7D&quot; alt=&quot;\lambda_{0}&quot; width=&quot;22&quot; height=&quot;22&quot; data-eeimg=&quot;true&quot;/&gt;&lt;span class=&quot;Formula-placeholder&quot; data-paste-ignore=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;7hfdu-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;7hfdu-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;，又称光栅节距。有了光栅节距值后，如果上图所示的B点绝对相位为 &lt;span class=&quot;Formula isEditable&quot;&gt;&lt;img class=&quot;Formula-image&quot; src=&quot;https://www.zhihu.com/equation?tex=%5Ctheta_%7BB%7D&quot; alt=&quot;\theta_{B}&quot; width=&quot;23&quot; height=&quot;22&quot; data-eeimg=&quot;true&quot;/&gt;&lt;span class=&quot;Formula-placeholder&quot; data-paste-ignore=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;7hfdu-3-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;7hfdu-4-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;（绝对相位=相位主值+相位周期数*2π）。则空间实际距离OB可以表示为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-1ea48bf4017be64ca762ecbd404bafcb_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;196&quot; data-rawheight=&quot;58&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;asbj2-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;asbj2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;。同理可得&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-3fe8e3c679accb19d139ca9fec9d33d5_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;186&quot; data-rawheight=&quot;56&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;cucf1-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cucf1-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;。二是需要获得参考平面在相机中成像的相位值。即知道每个像素点的拍摄的参考平面点的相位值。（注：准确的说应该是点B绝对相位值减去点O绝对相位值的差值，如果点O处相位值为0，则可以直接用B点的绝对相位值）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;e9l1n-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;e9l1n-0-0&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;对参考平面进行标定后，我们就可以通过上述公式对物体的高度进行相位测量，如上图所示,照射在物体表面一点P的投影相位值 &lt;span class=&quot;Formula isEditable&quot;&gt;&lt;img class=&quot;Formula-image&quot; src=&quot;https://www.zhihu.com/equation?tex=%5Ctheta_%7BP%7D%3D%5Ctheta_%7BB%7D&quot; alt=&quot;\theta_{P}=\theta_{B}&quot; width=&quot;74&quot; height=&quot;22&quot; data-eeimg=&quot;true&quot;/&gt;&lt;span class=&quot;Formula-placeholder&quot; data-paste-ignore=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;，而 &lt;span class=&quot;Formula isEditable&quot;&gt;&lt;img class=&quot;Formula-image&quot; src=&quot;https://www.zhihu.com/equation?tex=%5Ctheta_%7BA%7D&quot; alt=&quot;\theta_{A}&quot; width=&quot;23&quot; height=&quot;22&quot; data-eeimg=&quot;true&quot;/&gt;&lt;span class=&quot;Formula-placeholder&quot; data-paste-ignore=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-3-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-4-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;则是点P在相机中成像位置 &lt;span class=&quot;Formula isEditable&quot;&gt;&lt;img class=&quot;Formula-image&quot; src=&quot;https://www.zhihu.com/equation?tex=(u_%7Bp%7D%2Cv_%7Bp%7D)&quot; alt=&quot;(u_{p},v_{p})&quot; width=&quot;66&quot; height=&quot;27&quot; data-eeimg=&quot;true&quot;/&gt;&lt;span class=&quot;Formula-placeholder&quot; data-paste-ignore=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-5-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-6-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;对应的标定时获取的参考平面在 &lt;span class=&quot;Formula isEditable&quot;&gt;&lt;img class=&quot;Formula-image&quot; src=&quot;https://www.zhihu.com/equation?tex=(u_%7Bp%7D%2Cv_%7Bp%7D)&quot; alt=&quot;(u_{p},v_{p})&quot; width=&quot;66&quot; height=&quot;27&quot; data-eeimg=&quot;true&quot;/&gt;&lt;span class=&quot;Formula-placeholder&quot; data-paste-ignore=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-7-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;e9l1n-8-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;处成像的相位值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;7ciuj-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7ciuj-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;所以最终物体高度可以用下式表达：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-5310f75f6378470dfcc4dacd6eb8eb8b_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;374&quot; data-rawheight=&quot;130&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-5310f75f6378470dfcc4dacd6eb8eb8b.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-9b560dc95524a729b2c02e6e595963ce.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2ifnl&quot; data-offset-key=&quot;9cdei-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;9cdei-0-0&quot;&gt;&lt;span data-offset-key=&quot;9cdei-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;至此，经典相位法三维轮廓测量模型推导完毕。根据推导的公式，我们可以回头看看该测量装置在设置时需要如此严格的条件的必要性，对于步骤1的要求，原因如下，如果投影坐标系Y轴与参考平面坐标系的Y轴不平行，则投影到参考平面上的相位值会沿着参考平面Y轴发生变化，即对不同y值，其相位起始点不同，这样在三维中投影结果不能像上图中二维示意图那样OA和OB共用同一个起始点表示。而由于无法知道每个点的y值，就无法获得OB的值。二如果投影坐标系X轴与参考平面坐标系X轴不平行，则投影条纹在参考平面上的光栅节距会随着到起始点O的距离不同而变化。无法把相位用光栅节距换算成实际长度。（其实这里如果知道投影平面X轴和参考平面X轴的夹角，从理论上也可以换算成实际长度，但需要对公式进行改进）。对于步骤2的要求，和步骤1中需要投影Y轴与参考平面Y轴平行类似，如果相机坐标系Y轴与参考平面坐标系Y轴不平行，则参考平面Y轴在相机图片上的成像不是竖直的， 相机上每个像素点的相位值不能用参考平面上的同一个起始点O来计算，则无法知道OA的值。而对于步骤3，则更显而易见，如果投影光心 &lt;span class=&quot;Formula isEditable&quot;&gt;&lt;img class=&quot;Formula-image&quot; src=&quot;https://www.zhihu.com/equation?tex=O_%7Bp%7DO_%7Bc%7D&quot; alt=&quot;O_{p}O_{c}&quot; width=&quot;50&quot; height=&quot;26&quot; data-eeimg=&quot;true&quot;/&gt;&lt;span class=&quot;Formula-placeholder&quot; data-paste-ignore=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;9cdei-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;9cdei-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;不与参考平面平行，则无法知道 &lt;span class=&quot;Formula isEditable&quot;&gt;&lt;img class=&quot;Formula-image&quot; src=&quot;https://www.zhihu.com/equation?tex=OO%5E%7B%E2%80%99%7D_%7Bc%7D&quot; alt=&quot;OO^{’}_{c}&quot; width=&quot;41&quot; height=&quot;27&quot; data-eeimg=&quot;true&quot;/&gt;&lt;span class=&quot;Formula-placeholder&quot; data-paste-ignore=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;9cdei-3-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;9cdei-4-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;的值，如果相机光轴不和投影仪光轴在参考平面上相交，我们就得不到一个三角形，无法用相似性原理得到物体的高度。由以上可以看出，经典的相位法轮廓测量模型对于投影和相机的相对位置的设置有诸多难以达到的要求，而每个要求的标准与否都会影响物体最终的测量误差。而且该模型只能求出物体相对参考平面的高度值，而不能获得物体完整的三维坐标值。此外，该模型中考虑的相机和投影都是一个完美的小孔成像模型，在该模型中，相机拍得的图片不会有成像畸变问题。而投影仪投出的正弦光栅条纹一定是竖直的而不会因为投影畸变使得光栅投出去会有轻微的扭曲。由此可见，在实际三维重建工程中，我们几乎不可能设置这样一个理想的模型。尽管如此，该模型还是提供了一个很不错的思路。且后来有不少学者是基于此模型的基础上对相位法测轮廓模型进行改进，最终得到了易用的三维模型。对于初学者来说，了解这个经典模型对于相位法测轮廓的理解是非常有好处的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 24 Apr 2020 00:38:00 +0000</pubDate>
<dc:creator>3D视觉工坊</dc:creator>
<og:description>作者：书涵 Date：2020-04-24 来源：经典相位法三维轮廓测量模型 在结构光三维测量中，之前笔者介绍了关于把投影看做相机的逆的模型，这次笔者要介绍一个经典相位三维轮廓测量模型，有很多相位三维</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/YongQiVisionIMAX/p/12765145.html</dc:identifier>
</item>
<item>
<title>从一次“并发修改字段业务”引出多版本并发控制与InnoDB锁 - wunsiang</title>
<link>http://www.cnblogs.com/wunsiang/p/12765096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wunsiang/p/12765096.html</guid>
<description>&lt;p&gt;最近在主要在做“工作流引擎”课题的预研工作，在涉及到“会签任务”（工作流业务概念，这与我们今天讨论文问题没有太多关联）的时候，遇到了一个并发修改同一个字段的应用场景。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;238.15049255068&quot;&gt;
&lt;h2 id=&quot;并发字段修改业务&quot;&gt;并发字段修改业务&lt;/h2&gt;
&lt;p&gt;最近在主要在做“工作流引擎”课题的预研工作，在涉及到“会签任务”（工作流业务概念，这与我们今天讨论文问题没有太多关联）的时候，遇到了一个并发修改同一个字段的应用场景。&lt;/p&gt;
&lt;p&gt;大致是由于要等一个活动节点的所有实例任务都完成之后才能继续向下流转，则引擎必须在每次任务提交的时候进行判断。我选择了在数据库表中记录下每个&lt;strong&gt;活动节点&lt;/strong&gt;对应的&lt;strong&gt;任务实例&lt;/strong&gt;数目，活动实例完成提交时做相应的数目修改（active_ti_num - 1）来进行对应活动节点是否完成的判断。数据库表结构如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;活动表字段名&lt;/th&gt;
&lt;th&gt;id（活动主键）&lt;/th&gt;
&lt;th&gt;ai_name（活动名称）&lt;/th&gt;
&lt;th&gt;active_ti_num（当前活动未完成实例个数）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;示例数据&lt;/td&gt;
&lt;td&gt;1213398753365504001&lt;/td&gt;
&lt;td&gt;活动1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;任务表字段名&lt;/th&gt;
&lt;th&gt;id（任务主键）&lt;/th&gt;
&lt;th&gt;ai_id（对应活动id，外键）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;示例数据&lt;/td&gt;
&lt;td&gt;1213400206226272258&lt;/td&gt;
&lt;td&gt;1213398753365504001&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如上所示，当同一个活动具有多个任务实例的时候，而任务实例又并发完成，就可能由于并发update导致数据错误，所以我将任务实例提交处理封成了一个事务，再使用update自减的方式修改active_ti_num字段值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;update id=&quot;decrementActiveNum&quot; parameterType=&quot;int&quot;&amp;gt;
        UPDATE wf_activtity_instance
        SET active_ti_num = active_ti_num + 1
        WHERE id = #{id}
&amp;lt;/update&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在第一个事务修改了active_ti_num后，会锁住活动表中被修改的这一行，其他的事务便只能等待，等持有锁的事务锁释放之后，其他事务可以竞争锁再进行active_ti_num字段修改，从而保证了不出现数据错误。这种处理方法也是一种比较常见的处理方法。&lt;/p&gt;
&lt;p&gt;啰啰嗦嗦说了这么多，业务问题虽然解决了，但不知道大家有没有过疑惑，虽然为了保证数据不发生错误，修改的数据被锁住了，但是MySQL究竟加的是行锁还是表锁？如果我们遇到的是并发insert操作而非update，那是否会出现新的问题？想解决这些疑惑，就需要引出我们今天的话题——“&lt;strong&gt;MVCC原理与在InnoDB中的实现&lt;/strong&gt;”&lt;/p&gt;
&lt;h2 id=&quot;mvcc概念介绍&quot;&gt;MVCC概念介绍&lt;/h2&gt;
&lt;p&gt;在并发操作的控制上，MySQL的大多事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，他们一般都同时实现了MVCC（多版本并发控制）。可以认为MVCC是行级锁的一个变种，在很多场景下避免了加锁操作，因此开销更低。&lt;strong&gt;工作在 RC （读已提交）、RR（可重复度）两种隔离级别下&lt;/strong&gt;。至于这个MVCC究竟是怎么做到既保证效果，又提高并发的，我们先来看看《高性能MySQL》中的介绍。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;MVCC的实现，是通过保存数据在某个时间点的快照来实现的。MVCC是通过每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。当然实际存储的不是时间而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号。&lt;/p&gt;
&lt;p&gt;对于SELECT操作，就查找版本早于当前事务版本的数据行，行的删除版本要么未定义，要么大于当前事务版本。&lt;br/&gt;对于INSERT操作，InnoDB为新插入的每一行保存当前系统版本号作为行版本号。&lt;br/&gt;对于DELETE操作，Innodb为删除的每一行保存当前系统版本号作为行删除标识。&lt;br/&gt;对于UPDATE操作，Innodb为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是MVCC实现的一个大致概括，各存储引擎具体实现上还是略有不同。由于InnoBD是MySQL默认的存储引擎，也是我项目使用的存储引擎，因此我们就来看看在InnoBD中MVCC的实现原理与作用是怎样的（其他存储引擎笔者也不会是吧...）。&lt;/p&gt;
&lt;h2 id=&quot;innodb中mvcc的实现思路&quot;&gt;InnoDB中MVCC的实现思路&lt;/h2&gt;
&lt;p&gt;在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC ，一条记录除了包括各个字段值，还包括了&lt;strong&gt;当前事务id（trx_id）&lt;/strong&gt;和&lt;strong&gt;一个指针（roll_pointer）&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;trx_id：生成这条记录（update/delete）的事务id&lt;/li&gt;
&lt;li&gt;roll_pointer：之前undo_log中原来的那条记录，从而构成版本链&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注：一个事务的事务id在第一次insert/delete/update时生成&lt;/p&gt;
&lt;p&gt;我们接下来通过具体操作的实现思路来进行讲解：&lt;/p&gt;
&lt;h3 id=&quot;update操作&quot;&gt;Update操作&lt;/h3&gt;
&lt;p&gt;插入一条新的记录，把原来的记录放到undo日志中去，再把新纪录的roll_pointer指针指向原来的那条记录（&lt;strong&gt;从而加入版本链&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id=&quot;select操作&quot;&gt;Select操作&lt;/h3&gt;
&lt;p&gt;当执行查询sql时会生成一致性视图read-view，它由执行查询时所有未提交事务id数组(数组里最小的id为min_id)和已创建的最大事务id( max_id)组成，查询的数据结果需要跟read-view做比对从而得到快照结果（即从版本链头部记录开始，顺着链开始比对，找到可见的第一个版本记录）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1891043/202004/1891043-20200424082326676-1649073905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;版本链比对规则&quot;&gt;版本链比对规则&lt;/h4&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果落在绿色部分( trx_id&amp;lt; min_id),表示这个版本是已提交的事务生成的,这个数据是可见的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果落在红色部分( trx_id&amp;gt; max_id),表示这个版本是由将来启动的事务生成的,是肯定不可见的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;如果落在黄色部分( min_id&amp;lt;=trx_id&amp;lt;= max_id),那就包括两种情况&lt;/p&gt;
&lt;p&gt;a.若row的trx_id在数组中,表示这个版本是由还没提交的事务生成的,不可见,当前自己的事务是可见的。&lt;/p&gt;
&lt;p&gt;b.若row的trx_id不在数组中,表示这个版本是已经提交了的事务生成的,可见&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;delete操作&quot;&gt;delete操作&lt;/h3&gt;
&lt;p&gt;对于删除的情况可以认为是 update的特殊情况,会将版本链上最新的数据复制一份,然后将trx_id修改成删除操作的trx_id,同时在该条记录的头信息( record header)里的( deleted flag)标记位写上true,来表示当前记录已经被刪除,在查询时按照上面的规则查到对应的记录如果 delete flag标己位为true,意味看记录已被删除,则不返回数据。&lt;/p&gt;
&lt;p&gt;知道了MVCC的实现机制，那现在我们可以思考下MVCC是如何实现可重复读的和读已提交的呢？&lt;/p&gt;
&lt;h3 id=&quot;mvcc是如何实现可重复读的和读已提交的？&quot;&gt;MVCC是如何实现可重复读的和读已提交的？&lt;/h3&gt;
&lt;p&gt;可重复读隔离级别下，SELECT一致性视图（readview）沿用第一次生成的(这是mvcc实现可重复读的关键，即使其他事务commit，但由于readview还是第一次select时生成的那个，所以当前事务还是看不到)，而读已提交隔离级别下，每次SELECT操作生成最新的一致性视图（readview）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：readview是在当前会话（事务）第一条sql语句执行时生成的，在可重复读的隔离级别下，后面的语句都沿用这个readview（也就是说生成的readview是查哪个表用都有效的）&lt;/p&gt;
&lt;p&gt;由此可见，&lt;strong&gt;可重复读也解决了幻读问题&lt;/strong&gt;，因为新插入的记录的trx_id肯定会出现在select事务readview的未提交事务id数组/大于最大事务id，所以对于该事务肯定不可见，从而解决了幻读问题。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;到这可能有读者会疑惑，之前说的都是对于读数据的并发控制，可是你的业务是更新啊！这还不是一回事啊！&lt;/p&gt;
&lt;p&gt;别急，接下来我们就要说到啦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;快照读与当前读的区别？以及在mvcc中的应用&quot;&gt;快照读与当前读的区别？以及在MVCC中的应用&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;咦？怎么读还有两个？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;读与读的区别&quot;&gt;“读”与“读”的区别&lt;/h4&gt;
&lt;p&gt;我们且看，在RR（可重复读）级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。（比如说并发情况下自增或者先读再增（更新值对原数据值有依赖性））&lt;/p&gt;
&lt;p&gt;对于这种读取历史数据的方式，我们叫它&lt;strong&gt;快照读 (snapshot read)&lt;/strong&gt;，而读取数据库当前版本数据的方式，叫&lt;strong&gt;当前读 (current read)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快照读&lt;/strong&gt;其实就是普通的select操作，如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from table ….;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当前读&lt;/strong&gt;则是特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，&lt;em&gt;&lt;strong&gt;需要加锁&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update ;
delete;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此我们可以想到，事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”，就需要另外的模块来解决了。记下来，我们详细来说说&lt;strong&gt;当前读&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;当前读（写）&quot;&gt;当前读（“写”）&lt;/h4&gt;
&lt;p&gt;事务的隔离级别中虽然只定义了读数据的要求，实际上这也可以说是写数据的要求。上文的“读”，实际是讲的快照读；而这里说的“写”就是当前读了。&lt;/p&gt;
&lt;p&gt;读问题在上文中已经解决了，根据MVCC的定义，并发提交数据时会出现冲突，那么冲突时如何解决呢？我们再来看看InnoDB中RR级别对于写数据的处理。&lt;/p&gt;
&lt;p&gt;InnoDB使用了&lt;strong&gt;Next-Key锁&lt;/strong&gt;解决当前读中的幻读问题。首先我们看下什么是Next-Key锁。&lt;/p&gt;
&lt;p&gt;Next-key Lock：锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。&lt;/p&gt;
&lt;p&gt;Record Lock：对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；&lt;/p&gt;
&lt;p&gt;Gap Lock：对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。&lt;/p&gt;
&lt;p&gt;接下来我们可以看看RR级别和RC级别的对比，来体会Next-key锁的作用。&lt;/p&gt;
&lt;p&gt;RC级别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1891043/202004/1891043-20200424082351767-213070344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RR级别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1891043/202004/1891043-20200424082403764-1486444771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过对比我们可以发现，在RC级别中，事务A修改了所有teacher_id=30的数据，但是当事务Binsert进新数据后，事务A发现莫名其妙多了一行teacher_id=30的数据，而且没有被之前的update语句所修改，这就是“当前读”的幻读。&lt;/p&gt;
&lt;p&gt;RR级别中，事务A在update后加锁，事务B无法插入新数据，这样事务A在update前后读的数据保持一致，避免了幻读。这个锁，就是Gap锁。&lt;/p&gt;
&lt;p&gt;InnoDB是这么实现的：&lt;/p&gt;
&lt;p&gt;在class_teacher这张表中，teacher_id是个索引，那么它就会维护一套B+树的数据关系。&lt;br/&gt;而InnoDB使用的是聚集索引，teacher_id身为二级索引，就要维护一个索引字段和主键id的树状结构，学过数据结构的同学都会知道，在树节点内部关键字保持顺序排列如下图（意会）。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1891043/202004/1891043-20200424082417159-1377645177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图索引结构，Innodb将这段数据分成几个个区间&lt;/p&gt;
&lt;p&gt;(negative infinity, 5],&lt;br/&gt;(5,30],&lt;br/&gt;(30,positive infinity)；&lt;/p&gt;
&lt;p&gt;update class_teacher set class_name=‘初三四班’ where teacher_id=30;不仅用行锁，锁住了相应的数据行；同时也在两边的区间，（5,30]和（30，positive infinity），都加入了gap锁。这样事务B就无法在这个两个区间insert进新数据。&lt;/p&gt;
&lt;p&gt;因此，受限于这种实现方式，Innodb很多时候会锁住不需要锁的区间。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1891043/202004/1891043-20200424082430919-253361187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;update的teacher_id=20是在(5，30]区间，即使没有修改任何数据，Innodb也会在这个区间加gap锁，导致事务B必须等待，而其它区间不会影响，事务C正常插入。&lt;/p&gt;
&lt;p&gt;此外，如果（where条件）使用的是&lt;strong&gt;没有索引的字段&lt;/strong&gt;，比如update class_teacher set teacher_id=7 where class_name=‘初三八班（即使没有匹配到任何数据）’,那么会给全表加入gap锁。同时，它不能像上文中行锁一样经过MySQL Server过滤自动解除不满足条件的锁，因为没有索引，则这些字段也就没有排序，也就没有区间。除非该事务提交，否则其它事务无法插入任何数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;MVCC不可重复读的保证其实是由快照读和当前读两个方面着手，快照读通过mvcc的版本控制来解决，不需要真正加锁。当前读通过行锁和GAP锁（锁的范围为索引B+树中当前索引两边的区间，要是没有索引就锁表）结合形成的的Next-Key锁来解决不可重复度和幻读的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;参考资料&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《高性能MySQL》第三版&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://118.178.126.205:8005/&quot;&gt;美团技术团队&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 24 Apr 2020 00:25:00 +0000</pubDate>
<dc:creator>wunsiang</dc:creator>
<og:description>最近在主要在做“工作流引擎”课题的预研工作，在涉及到“会签任务”（工作流业务概念，这与我们今天讨论文问题没有太多关联）的时候，遇到了一个并发修改同一个字段的应用场景。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wunsiang/p/12765096.html</dc:identifier>
</item>
<item>
<title>Java8新特性(1)：Lambda表达式 - 布禾</title>
<link>http://www.cnblogs.com/seve/p/12765098.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seve/p/12765098.html</guid>
<description>&lt;p&gt;Lambda表达式可以理解为一种匿名函数：没有名称，但有参数列表、函数主体、返回类型。它是行为参数化的一种实现，行为参数化是指将不同的行为作为参数传递给方法，方法的所具备的能力取决于它接收的行为参数。使用Lambda表达式使我们不必为这些行为去编写一堆固定的实现类就能应对不断变化的需求，在1.8之前，可以使用匿名内部类的方式达到相同的效果，只是相对于Lambda表达式来说，匿名内部类的方式会显得啰嗦。&lt;/p&gt;
&lt;h4 id=&quot;函数式接口&quot;&gt;函数式接口&lt;/h4&gt;
&lt;p&gt;Lambda表达式的使用依赖于函数式接口，只有在接受函数式接口的地方才可以使用Lambda表达式。函数式接口是指只声明了一个&lt;strong&gt;抽象方法&lt;/strong&gt;的接口，可以有多个静态方法、默认方法，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface Calculation {
    int calculate(int a, int b);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@FunctionalInterface&lt;/strong&gt;注解表示被标注的接口将被设计成一个函数式接口，不是必须的，它主要是在接口违背函数式接口原则时会出现编译错误。比如修改Calculation接口，再添加一个抽象方法就会出现&lt;span&gt;Multiple non-overriding abstract methods found in interface com.cf.demo.lambda.Calculation&lt;/span&gt;编译错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//编译错误：Multiple non-overriding abstract methods found in interface com.cf.demo.lambda.Calculation
@FunctionalInterface
public interface Calculation {
    int calculate(int a, int b);

    int calculate2(int a, int b);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;注意：Object类的方法是特例，即使接口声明了多个Object类的方法，也不会被算入“只声明了一个抽象方法”的计数中&lt;/span&gt;。如下Calculation接口是正确的函数式接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface Calculation {
    int calculate(int a, int b);

    boolean equals(Object obj);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java8提供了一些常用的函数式接口，位于java.util.function包下，并且为了避免装箱操作，还提供了和基本类型对应的接口，我们在实际使用时，可以优先使用这些内置的函数式接口。当然在某些情况我们也需要使用自定义的函数式接口，&lt;strong&gt;如需要在Lambda表达式中抛异常时，这种情况就需要自定义一个函数式接口，并声明异常&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;lambda表达式语法&quot;&gt;Lambda表达式语法&lt;/h4&gt;
&lt;p&gt;Lambda表达式由&lt;strong&gt;参数列表&lt;/strong&gt;、&lt;strong&gt;箭头(Lambda操作符)&lt;/strong&gt;、&lt;strong&gt;Lambda主体&lt;/strong&gt;三个部分组成。&lt;strong&gt;Lambda表达式的参数列表要和函数式接口的参数列表相对应，Lambda主体的返回值也要和函数式接口的返回类型相对应&lt;/strong&gt;。现在有如下doArithmetic方法，接收两个整型参数以及一个Calculation，doArithmetic方法的行为是由传递的Calculation来决定的，我们可以调用该方法传递不同的Calculation来完成不同的计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static int doArithmetic(int a, int b, Calculation calculation){
        return calculation.calculate(a, b);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在要计算两个数的乘积，用内部类的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     int result = doArithmetic(3, 2, new Calculation() {
            @Override
            public int calculate(int a, int b) {
                return a * b;
            }
        });
        System.out.println(result);//6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用Lambda表达式的方式要更简洁：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     int result = doArithmetic(3, 2, (int a, int b) -&amp;gt; a * b);
        System.out.println(result);//6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(int a, int b)是Lambda表达式的参数列表部分，只有一个参数的时候可以省略小括号，这里有多个参数，所以要保留小括号。参数类型可以省略，因为Java编译器能通过上下文推断出数据类型，无需显示的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     int result = doArithmetic(3, 2, (a, b) -&amp;gt; a * b);
        System.out.println(result);//6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Lambda主体只有一个语句时，可以省略{}和return，(int a, int b) -&amp;gt; a * b)就是省略之后的写法，我们也可以使用完整的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     int result = doArithmetic(3, 2, (a, b) -&amp;gt; {
            return a * b;
        });
        System.out.println(result);//6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当需要在Lambda表达式中使用‘外部局部变量’时，这个‘外部局部变量’默认是final的，‘外部局部变量’这里是指非Lambda表达式内部定义的局部变量。修改doArithmetic方法，添加一个‘外部局部变量’，为乘积赋个初始值，以下代码是编译不通过的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     int initialValue = 1;
        int result = doArithmetic(3, 2, (a, b) -&amp;gt; a * b + initialValue);
        initialValue = 2;//Variable used in lambda expression should be final or effectively final
        System.out.println(result);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法引用&quot;&gt;方法引用&lt;/h4&gt;
&lt;p&gt;方法引用可以对‘某种特殊情况’下的Lambda表达式进行简化，‘某种特殊情况’是指Lambda表达式要做的事情别的方法实现了，那我们就可以直接使用这个方法，然后像Lambda表达式一样传递即可。方法引用的语法为&lt;strong&gt;目标引用放在分隔符::前，方法的名称放在后面&lt;/strong&gt;，目标引用可以是类名也可以是对象名。通过以下三个例子来介绍方法引用的三种使用方法，新增Arithmetic类，Arithmetic类包含一个静态方法和一个实例方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     public class Arithmetic {
                public static int multiply(int a, int b){
                        return a * b;
                }

                public int add(int a, int b){
                        return a + b;
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1.指向静态方法的方法引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     int multiplyResult = doArithmetic(3, 2, Arithmetic::multiply);
        System.out.println(multiplyResult);//6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.指向现有对象的实例方法的方法引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     Arithmetic arithmetic = new Arithmetic();
        int addResult = doArithmetic(3, 2, arithmetic::add);
        System.out.println(addResult);//5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.指向任意类型实例方法的方法引用&lt;/strong&gt;，这种情况有个特点，就是&lt;strong&gt;在引用一个对象的方法，而这个对象本身是Lambda的一个参数&lt;/strong&gt;。比如现在需要实现比较两个数的大小，首先修改calculate方法参数类型为包装类型Integer：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     @FunctionalInterface
        public interface Calculation {
                int calculate(Integer a, Integer b);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比较a和b的大小可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     int result = doArithmetic(3, 2, Integer::compareTo);//Integer::compareTo等于a.compareTo(b) 
        System.out.println(result);//1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构造函数引用&quot;&gt;构造函数引用&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;对于一个现有构造函数，可以使用它的名称和new来创建一个它的引用： ClassName::new&lt;/strong&gt;。再使用构造函数引用时，需要调用的构造器参数列表要和函数式接口的抽象方法的参数要一致。举个例子，现在添加了两个生成String对象的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static String generateString(Supplier&amp;lt;String&amp;gt; supplier) {
        return supplier.get();
    }

    public static String generateString(String value, Function&amp;lt;String, String&amp;gt; function) {
        return function.apply(value);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别使用构造函数引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     String result = generateString(String::new);//调用String()构造方法
        System.out.println(result);

        result = generateString(&quot;hello Lambda&quot;, String::new);//调用String(String original)构造方法
        System.out.println(result);
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 24 Apr 2020 00:23:00 +0000</pubDate>
<dc:creator>布禾</dc:creator>
<og:description>Lambda表达式可以理解为一种匿名函数：没有名称，但有参数列表、函数主体、返回类型。它是行为参数化的一种实现，行为参数化是指将不同的行为作为参数传递给方法，方法的所具备的能力取决于它接收的行为参数。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seve/p/12765098.html</dc:identifier>
</item>
<item>
<title>Blazor WebAssembly 3.2.0 已在塔架就位 将发射新一代前端SPA框架 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/12765062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/12765062.html</guid>
<description>&lt;p&gt;最美人间四月天，春光不负赶路人。在充满无限希望的明媚春天里，一路风雨兼程的.NET团队正奋力实现新的突破。 根据计划，新一代基于WebAssembly 技术研发的前端SPA框架Blazor 将于5月19日在微软Build大会升空。 目前，Blazor 的测试工作和火箭发射前各项准备工作在github 上按计划有序推进。在抗击疫情的特殊时期，力争圆满完成各项任务。&lt;/p&gt;
&lt;p&gt;ASP.NET团队如期4.23在官方博客发布了 Blazor WebAssembly 3.2.0 Preview 5：&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-preview-5-release-now-available/&quot;&gt;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-preview-5-release-now-available/&lt;/a&gt;  ，同时在twitter上发了一条信息带上了下面这张图，这张图很形象的说明了Blazor Webassembly 已经准备就绪，开始上到塔台，准备发射，按照开发计划，将在下周4.30 发布Blazor WebAssembly 3.2.0 RC， 完成功能特性的开发，将在5.19 的微软Build大会正式发射升空，进入使用C#进行前端开发旅程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202004/510-20200424071530626-1984733473.png&quot;&gt;&lt;img width=&quot;491&quot; height=&quot;595&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202004/510-20200424071531241-943823868.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly 3.2.0 Preview 5新增功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;启动期间读取配置： &lt;span&gt;集成了.NET 的配置系统，在应用启动时读取配置文件，这个也算是最后一个功能特性，现在Blazor 把.NET Core的基础框架都已经带到了前端，依赖注入，日志、配置等。&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;&lt;code&gt;HttpClient增强：&lt;span&gt;前后端分离的SPA框架中Ajax的调用是一个关键，HttpClient 为我们的前后端的通信提供了axios 这样的角色，而且特性各种增强，比如证书，token，各种请求选项等。&lt;/span&gt;&lt;/code&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;&lt;code&gt;生成独立的web.config: &lt;span&gt;应用部署到IIS 就需要有一个web.config, Blazor现在在iis上部署更省心了。&lt;/span&gt;&lt;/code&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;code&gt;&lt;span&gt;正好昨天看到InfoQ的一篇文章《&lt;a href=&quot;https://www.infoq.cn/article/po1Eiy9vERsOUtHEyxtg&quot;&gt;Mono 现状与未来： 从 Xamarin 到 WebAssembly、Blazor 及.NET 5&lt;/a&gt;》, 这篇文章对大家理解Blazor 的运行时Mono 有跟深入的理解，推荐大家看看，我这里就节选一段和Blazor Webassembly相关的内容:&lt;/span&gt;&lt;/code&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202004/510-20200424071531703-581335879.png&quot;&gt;&lt;img width=&quot;468&quot; height=&quot;474&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202004/510-20200424071532234-1262302382.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202004/510-20200424071532639-2047312103.png&quot;&gt;&lt;img width=&quot;473&quot; height=&quot;231&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202004/510-20200424071532973-1433573664.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Apr 2020 23:16:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>最美人间四月天，春光不负赶路人。在充满无限希望的明媚春天里，一路风雨兼程的.NET团队正奋力实现新的突破。 根据计划，新一代基于WebAssembly 技术研发的前端SPA框架Blazor 将于5月1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/12765062.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core技术研究-全面认识Web服务器Kestrel - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/12764404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/12764404.html</guid>
<description>&lt;p&gt;因为IIS不支持跨平台的原因，我们在升级到ASP.NET Core后，会接触到一个新的Web服务器&lt;strong&gt;Kestrel&lt;/strong&gt;。相信大家刚接触这个Kestrel时，会有各种各样的疑问。&lt;/p&gt;&lt;p&gt;首先，Kestrel是一个跨平台的Web服务器，支持运行在Windows、macOS、Linux等操作系统中。Kestrel支持一下使用场景：&lt;/p&gt;&lt;p&gt;   1. Kestrel直接作为Web服务器，直接接收并处理各类Http请求：&lt;/p&gt;&lt;p&gt;   2. 与各类反向代理服务器（例如Nginx、Apache、IIS）配合使用，反向代理服务器接收Http请求，将这些请求转发到Kestrel Web服务器&lt;/p&gt;&lt;div readability=&quot;168.58046357616&quot;&gt;
&lt;ul&gt;&lt;li&gt;   对外暴露有限的HTTP服务&lt;/li&gt;
&lt;li&gt;   更加安全，反向代理服务器做了一层过滤、防护和转发&lt;/li&gt;
&lt;li&gt;   通过反向代理服务器实现负载均衡和动态请求分发路由&lt;/li&gt;
&lt;li&gt;   减少域名使用，降低WAF防火墙防护成本&lt;/li&gt;
&lt;li&gt;   安全通信 (HTTPS) 配置，HTTPS转HTTP，仅反向代理服务器需要 X.509 证书，并且该服务器可使用普通 HTTP 协议与内部网络的应用服务器通信。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; 三、Kestrel支持特性之-HTTP/2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Kestrel在以下操作系统和.NET Core版本下支持HTTP/2&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; 操作系统：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Windows Server 2016/Windows 10 或更高版本&lt;/li&gt;
&lt;li&gt;具有 OpenSSL 1.0.2 或更高版本的 Linux（例如，Ubuntu 16.04 或更高版本）&lt;/li&gt;
&lt;li&gt;macOS 的未来版本将支持 HTTP/2&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    macOS 的未来版本将支持 †HTTP/2。 ‡Kestrel 在 Windows Server 2012 R2 和 Windows 8.1 上对 HTTP/2 的支持有限。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;目标框架：&lt;/strong&gt;.NET Core 2.2 或更高版本&lt;/p&gt;
&lt;p&gt;    关于HTTP/2 可以参考一下超链接：&lt;a href=&quot;https://http2.github.io/&quot;&gt;https://http2.github.io/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;    关于HTTP/2和HTTP/1.1的全方位对比，可以参考这个超链接：&lt;a href=&quot;https://cheapsslsecurity.com/p/http2-vs-http1/&quot;&gt;https://cheapsslsecurity.com/p/http2-vs-http1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 四、在ASP.NET Core中使用Kestrel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  在ASP.NET Core的框架&lt;strong&gt;Microsoft.AspNetCore.App&lt;/strong&gt;内置了package：&lt;strong&gt;Microsoft.AspNetCore.Server.Kestrel&lt;/strong&gt; ，即原生对Kestrel的支持：&lt;/p&gt;
&lt;p&gt;  大家可以找到ASP.NET Core 3.1的本地目录：C:\Program Files\dotnet\packs\Microsoft.AspNetCore.App.Ref\3.1.0\ref\netcoreapp3.1 中找到Kestrel相关的dll：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202004/23525-20200423225250325-1754602058.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     当我们新建一个ASP.NET Core Project，在Program.cs类中有以下代码，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class Program
{
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
                });
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     我们通过查看ConfigureWebDefaults的实现源码可以发现，在其内部调用了&lt;strong&gt;UseKestrel&lt;/strong&gt;()方法，&lt;strong&gt;即ASP.NET Core默认使用Kestrel Web服务器！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
internal static void ConfigureWebDefaults(IWebHostBuilder builder)
       {
           builder.ConfigureAppConfiguration((ctx, cb) =&amp;gt;
           {
               if (ctx.HostingEnvironment.IsDevelopment())
               {
                   StaticWebAssetsLoader.UseStaticWebAssets(ctx.HostingEnvironment, ctx.Configuration);
               }
           });
           builder.UseKestrel((builderContext, options) =&amp;gt;
           {
               options.Configure(builderContext.Configuration.GetSection(&quot;Kestrel&quot;));
           })
           .ConfigureServices((hostingContext, services) =&amp;gt;
           {
               // Fallback
               services.PostConfigure&amp;lt;HostFilteringOptions&amp;gt;(options =&amp;gt;
               {
                   if (options.AllowedHosts == null || options.AllowedHosts.Count == 0)
                   {
                       // &quot;AllowedHosts&quot;: &quot;localhost;127.0.0.1;[::1]&quot;
                       var hosts = hostingContext.Configuration[&quot;AllowedHosts&quot;]?.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                       // Fall back to &quot;*&quot; to disable.
                       options.AllowedHosts = (hosts?.Length &amp;gt; 0 ? hosts : new[] { &quot;*&quot; });
                   }
               });
               // Change notification
               services.AddSingleton&amp;lt;IOptionsChangeTokenSource&amp;lt;HostFilteringOptions&amp;gt;&amp;gt;(
                           new ConfigurationChangeTokenSource&amp;lt;HostFilteringOptions&amp;gt;(hostingContext.Configuration));
  
               services.AddTransient&amp;lt;IStartupFilter, HostFilteringStartupFilter&amp;gt;();
  
               if (string.Equals(&quot;true&quot;, hostingContext.Configuration[&quot;ForwardedHeaders_Enabled&quot;], StringComparison.OrdinalIgnoreCase))
               {
                   services.Configure&amp;lt;ForwardedHeadersOptions&amp;gt;(options =&amp;gt;
                   {
                       options.ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;
                       // Only loopback proxies are allowed by default. Clear that restriction because forwarders are
                       // being enabled by explicit configuration.
                       options.KnownNetworks.Clear();
                       options.KnownProxies.Clear();
                   });
  
                   services.AddTransient&amp;lt;IStartupFilter, ForwardedHeadersStartupFilter&amp;gt;();
               }
  
               services.AddRouting();
           })
           .UseIIS()
           .UseIISIntegration();
       }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上详细的代码可以参考，上一篇博文：&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/tianqing/p/12726181.html&quot;&gt;.NET Core技术研究-主机Host&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、Kestrel的配置选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  我们可以使用 webBuilder.ConfigureKestrel设置Kestrel的一些选项：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202004/23525-20200423230409427-2045468944.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   接下来，我们看一下Kestrel Web服务器提供了哪些选项设置：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  1. KeepAliveTimeout：保持活动会话超时时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   默认2分钟，可以用以下代码进行设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.KeepAliveTimeout = TimeSpan.FromMinutes(2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;  2. &lt;span&gt;客户端最大连接数：&lt;/span&gt; MaxConcurrentConnections、 MaxConcurrentUpgradedConnections&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  默认情况下，最大连接数不受限制；&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;可以通过&lt;/span&gt; MaxConcurrentConnections&lt;span&gt;，设置&lt;/span&gt;整个应用设置并发打开的最大 TCP 连接数。&lt;/p&gt;
&lt;p&gt;  对于已从 HTTP 或 HTTPS 升级到另一个协议（例如，Websocket 请求）的连接，有一个单独的限制MaxConcurrentUpgradedConnections。 连接升级后，不会计入 MaxConcurrentConnections 限制。&lt;/p&gt;
&lt;p&gt;  可以用以下代码进行设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.MaxConcurrentConnections = 100;
serverOptions.Limits.MaxConcurrentUpgradedConnections = 100;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;strong&gt;3. 请求正文最大大小： MaxRequestBodySize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  默认的请求正文最大大小为 30,000,000 字节，大约 28.6 MB&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.MaxRequestBodySize = 10 * 1024;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  在 ASP.NET Core MVC 应用中替代限制的推荐方法是在操作方法上使用 &lt;strong&gt;RequestSizeLimitAttribute&lt;/strong&gt; 属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[RequestSizeLimit(100000000)]
public IActionResult MyActionMethod()　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;   4. 请求正文最小数据速率 MinRequestBodyDataRate MinResponseDataRate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   Kestrel 每秒检查一次数据是否以指定的速率（字节/秒）传入。 如果速率低于最小值，则连接超时。&lt;/p&gt;
&lt;p&gt;   宽限期是 Kestrel 提供给客户端用于将其发送速率提升到最小值的时间量；在此期间不会检查速率。 宽限期可以尽可能地避免最初由于 TCP 慢启动而以较慢速率发送数据的连接中断。&lt;/p&gt;
&lt;p&gt;   默认的最小速率为 240 字节/秒，包含 5 秒的宽限期。&lt;/p&gt;
&lt;p&gt;   最小速率也适用于HttpResponse响应。 除了属性和接口名称中具有 RequestBody 或 Response 以外，用于设置请求限制和响应限制的代码相同。   &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.MinRequestBodyDataRate = new MinDataRate(bytesPerSecond: 100, gracePeriod: TimeSpan.FromSeconds(10));
serverOptions.Limits.MinResponseDataRate = new MinDataRate(bytesPerSecond: 100, gracePeriod: TimeSpan.FromSeconds(10));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;  5. 请求Header超时 RequestHeadersTimeout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  获取或设置服务器接收请求标头所花费的最大时间量。 默认值为 30 秒。  &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.RequestHeadersTimeout = TimeSpan.FromMinutes(1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;   6. 每个连接的最大的请求流的数量 MaxStreamsPerConnection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   Http2.MaxStreamsPerConnection 限制每个 HTTP/2 连接的并发请求流的数量。 拒绝过多的流。   &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.Http2.MaxStreamsPerConnection = 100;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　7. 标题表大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   HPACK 解码器解压缩 HTTP/2 连接的 HTTP 标头。 Http2.HeaderTableSize 限制 HPACK 解码器使用的标头压缩表的大小。 该值以八位字节提供，且必须大于零 (0)。　   &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.Http2.HeaderTableSize = 4096;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　8. 最大帧大小 Http2.MaxFrameSize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span data-ttu-id=&quot;51119-214&quot;&gt;&lt;code&gt;Http2.MaxFrameSize&lt;/code&gt; 表示服务器接收或发送的 HTTP/2 连接帧有效负载的最大允许大小。 &lt;span data-ttu-id=&quot;51119-215&quot;&gt;该值以八位字节提供，必须介于 2^14 (16,384) 和 2^24-1 (16,777,215) 之间。&lt;/span&gt;&lt;/span&gt;&lt;span data-ttu-id=&quot;51119-214&quot;&gt;&lt;span data-ttu-id=&quot;51119-215&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.Http2.MaxFrameSize = 16384;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;9. 最大请求头大小 Http2.MaxRequestHeaderFieldSize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;51119-218&quot;&gt;&lt;code&gt;  Http2.MaxRequestHeaderFieldSize&lt;/code&gt; 表示请求标头值的允许的最大大小（用八进制表示）。 &lt;span data-ttu-id=&quot;51119-219&quot;&gt;此限制适用于名称和值的压缩和未压缩表示形式。 &lt;span data-ttu-id=&quot;51119-220&quot;&gt;该值必须大于零 (0)。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-ttu-id=&quot;51119-218&quot;&gt;&lt;span data-ttu-id=&quot;51119-219&quot;&gt;&lt;span data-ttu-id=&quot;51119-220&quot;&gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.Http2.MaxRequestHeaderFieldSize = 8192;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;10. 初始连接窗口大小  &lt;code&gt;Http2.InitialConnectionWindowSize&lt;/code&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span data-ttu-id=&quot;51119-223&quot;&gt;&lt;code&gt;Http2.InitialConnectionWindowSize&lt;/code&gt; 表示服务器一次性缓存的最大请求主体数据大小（每次连接时在所有请求（流）中汇总，以字节为单位）。 &lt;span data-ttu-id=&quot;51119-224&quot;&gt;请求也受 &lt;code&gt;Http2.InitialStreamWindowSize&lt;/code&gt; 限制。 &lt;span data-ttu-id=&quot;51119-225&quot;&gt;该值必须大于或等于 65,535，并小于 2^31 (2,147,483,648)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-ttu-id=&quot;51119-223&quot;&gt;&lt;span data-ttu-id=&quot;51119-224&quot;&gt;&lt;span data-ttu-id=&quot;51119-225&quot;&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;51119-223&quot;&gt;&lt;span data-ttu-id=&quot;51119-224&quot;&gt;&lt;span data-ttu-id=&quot;51119-225&quot;&gt;    默认值为 128 KB (131,072)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.Http2.InitialConnectionWindowSize = 131072;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　11. 初始流窗口大小 Http2.InitialStreamWindowSize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span data-ttu-id=&quot;51119-228&quot;&gt;&lt;code&gt;Http2.InitialStreamWindowSize&lt;/code&gt; 表示服务器针对每个请求（流）的一次性缓存的最大请求主体数据大小（以字节为单位）。 &lt;span data-ttu-id=&quot;51119-229&quot;&gt;请求也受 &lt;code&gt;Http2.InitialConnectionWindowSize&lt;/code&gt; 限制。 &lt;span data-ttu-id=&quot;51119-230&quot;&gt;该值必须大于或等于 65,535，并小于 2^31 (2,147,483,648)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;51119-228&quot;&gt;&lt;span data-ttu-id=&quot;51119-229&quot;&gt;&lt;span data-ttu-id=&quot;51119-230&quot;&gt;    默认值为 96 KB (98,304)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-ttu-id=&quot;51119-228&quot;&gt;&lt;span data-ttu-id=&quot;51119-229&quot;&gt;&lt;span data-ttu-id=&quot;51119-230&quot;&gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.Limits.Http2.InitialStreamWindowSize = 98304;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　12. 同步IO  AllowSynchronousIO &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     AllowSynchronousIO 控制是否允许对请求和响应使用同步 IO。 默认值为 false。这个设置需要注意一下：&lt;/p&gt;
&lt;p&gt;     大量的阻止同步 IO 操作可能会导致线程池资源不足，进而导致应用无响应。 仅在使用不支持异步 IO 的库时，才启用 AllowSynchronousIO。     &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
serverOptions.AllowSynchronousIO = true;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上是ASP.NET Core Web服务器Kestrel的一些研究和梳理，分享给大家。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2020/4/24&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 23 Apr 2020 21:08:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>因为IIS不支持跨平台的原因，我们在升级到ASP.NET Core后，会接触到一个新的Web服务器Kestrel。相信大家刚接触这个Kestrel时，会有各种各样的疑问。 今天我们全面认识一下ASP.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tianqing/p/12764404.html</dc:identifier>
</item>
<item>
<title>负载均衡服务之HAProxy基础配置（一） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12763245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12763245.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;36&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200419164356haproxy.png&quot; class=&quot;desc_img&quot;/&gt; haproxy的配置文件大概可以分两段；第一段配置上global配置段即全局配置段，主要是针对haproxy的进程和安全相关的；第二段是proxies代理配置段，主要是配置haproxy前端监听那个地址那个端口以及后端server的名称、地址、端口，以及server相关属性等配置；而proxies配置段里又分defaults配置段，这个部分主要是定义后续的backend,listen这两个段的默认配置；什么意思呢？也就是在后面的配置中如果我们没有写对应参数，它默认会继承defaults里的配置；如果说后面的配置中和前边的defaults中的配置重复了，那么就已后面的配置生效，也就是说后面的配置段优先级高于defaults里的配置；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;153.21144024515&quot;&gt;
&lt;p&gt;　　前文我们聊了下haproxy的基础安装，以及怎样去代理后端主机的配置；当然没有很详细的去说配置文件中各指令的意思；有关haproxy的安装和代理后端server可以参考本人博客&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12741018.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12741018.html&lt;/a&gt;；今天我们主要来说一下haproxy global配置段常用配置指令的用法和说明；&lt;/p&gt;
&lt;p&gt;　　前边我们大概说了一下haproxy的配置文件大概可以分两段；第一段配置是global配置段即全局配置段，主要是针对haproxy的进程和安全相关的配置；第二段是proxies代理配置段，主要是配置haproxy前端监听那个地址那个端口以及后端server的名称、地址、端口，以及server相关属性等配置；而proxies配置段里又分defaults配置段，这个部分主要是定义后续的backend,listen这两个段的默认配置；什么意思呢？也就是在后面的配置中如果我们没有写对应参数，它默认会继承defaults里的配置；如果说后面的配置中和前边的defaults中的配置重复了，那么就以后面的配置生效，也就是说后面的配置段优先级高于defaults里的配置；了解了haproxy的配置文件结构，接下来我们来看看haproxy的global配置段常用指令；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200423194222045-1394638196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上是haproxy1.5.18yum安装里默认提供的global配置段；其中log是用来指定日志的，这里要说一下haproxy的日志，它和nginx的日志不太一样；nginx的日志是我们用access_log 指令来指定日志文件和调用日志格式的名称，意思就是把日志以增量的方式往指定的日志文件中写；而haproxy的日志不是自己记录日志，而是通过把日志发送给rsyslog服务器上的一个facility上，然后通过rsyslog的配置把指定facility上的日志记录到某个文件中或者数据中；以上配置段意思就是把haproxy的日志发送给本机的rsyslog上的local2 记录所有级别类型的日志；其实我们不用配置rsyslog，默认会把日志记录到/var/log/messages这个文件中，这是因为rsyslog中明确定义了所有facility上的info级别以及info级别以上的日志都记录到/var/log/messages中；有关rsyslog的配置说明可以参考本人博客&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12091118.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12091118.html&lt;/a&gt;；接下来我们来配置下，让haproxy的日志记录到/var/log/haproxy.log这个文件中去；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200423195619964-1254730124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在rsyslog的配置文件中明确要使用local2这个facility上的任何级别的日志都交给/var/log/haproxy.log记录；这样只是把接收日志的方式定义好了；通常如果rsyslog作为日志服务器接收非本机的其他主机日志，我们还要让rsyslog监听在udp或者tcp的514端口上（当然这个端口也可以自己指定，通常不用更改），为其他主机提供服务；所以我们除了要定义把某个facility上的所有级别的日志（当然也可以指定某些级别的日志，这个要看你想要收集那一类的日志）记录到某个文件中外，我们还要把udp或tcp的514端口打开；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200423200258357-505903197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置就是导入imudp模块，然后让rsyslog监听在udp的514端口；这样配置后我们就可以保存rsyslog的配置文件，然后重启rsyslog，我们就可以把haproxy的日志记录到/var/log/haproxy.log中去了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200423201141219-323353162.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们访问haproxy，其中的访问日志就记录到我们定义的/var/log/haproxy.log中去了；&lt;/p&gt;
&lt;p&gt;　　chroot：该指令主要作用同vsftpd里面的chroot类似，禁锢运行目录的；一般这个参数主要是防止haproxy被恶意程序攻击后对操作系统上的其他路径资源的破环；也就是说即便haproxy被恶意程序攻破，最多只能破环我们指定的chroot目录，而非整个系统目录结构；通常情况下haproxy不会出现这种情况，为了安全我们还是配置上这个参数；如果haproxy是我们手动编译安装的，通常我们会把这个参数的值设置成很haproxy的程序编译安装时指定的目录；yum安装的基本上都是/var/lib/haproxy；一般都不会去更改它；&lt;/p&gt;
&lt;p&gt;　　pidfile：该指令是指定pid文件的，通常情况下需要和unit file里指定的pid文件是同一个文件；不是同一个文件的话可能会遇到无法reload的情况；&lt;/p&gt;
&lt;p&gt;　　maxconn：该指令指定haproxy的单个进程最大并发连接数；&lt;/p&gt;
&lt;p&gt;　　user/group：前者用来指定运行haproxy进程的用户（属主），后者是用来指定运行进程的用户属组&lt;/p&gt;
&lt;p&gt;　　uid/gid：前者用来指定运行haproxy工作进程的用户id,后者是指定组id；以上两种方式都是来指定运行haproxy进程的用户身份；默认情况是用的id为99的用户（nobody用户）&lt;/p&gt;
&lt;p&gt;　　deamon：此指令表示haproxy以守护进程运行；&lt;/p&gt;
&lt;p&gt;　　stats socket：指定unix socket文件路径；主要用于本机交互的方式管理haproxy；&lt;/p&gt;
&lt;p&gt;　　以上是haproxy1.5.18配置文件中global段配置选项的说明；在haproxy1.8.0以后的版本中，haproxy支持多进程多线程的方式，而1.5不支持多线程，支持多进程，但是在1.5上启用多进程的方式是串行的，意思就是它不是一个主进程下生成多个子进程，而是一个进程下生成一个进程，然后子进程下在生成子进程的方式；所以如果要使用多进程的方式，建议还是使用1.8以后的版本；&lt;/p&gt;
&lt;p&gt;　　haproxy配置多进程&lt;/p&gt;
&lt;p&gt;　　nbproc：该指令是用于指定haproxy的进程数 ，通常情况下建议同cup核心数一样即可；&lt;/p&gt;
&lt;p&gt;　　cpu-map：该指令用于绑定haproxy对应cup核心；有点类似nginx里的worker_cpu_affinity参数的意义；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424001509738-2047826034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示指定haproxy的进程数为4个，第一个进程绑定到0号核心上，第二个进程绑定到1号核心上，依次类推；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424002547283-293036298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上是haproxy1.8.20上配置使用多进程，启动进程情况，我们可以看到haproxy进程的父进程都是5945；&lt;/p&gt;
&lt;p&gt;　　在1.5.18上使用多进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424002341779-1744671207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以同样的配置在haproxy1.5.18上，启动的多进程就不一样，在1.5.18上多了一个haproxy-systemd这个进程，并且haproxy进程都是它的子进程，而我们用nbproc指定的进程数是指定haproxy-systemd下的haproxy的子进程数；而1.8.20nbproc指定的是haproxy的子进程数量，没有haproxy-systemd，又或者我们可以理解为1.8.20把1.5.18上的haproxy-systemd和haproxy进程合并成一个进程haproxy；通常情况下haproxy单进程也是足够用了，如果是在要开多进程，建议还是使用1.8以上的版本吧；&lt;/p&gt;
&lt;p&gt;　　haproxy使用多线程&lt;/p&gt;
&lt;p&gt;　　haproxy的多线程是在1.7以后的版本才支持的，所以1.5上面不支持多线程的方式，所以我们这里的演示就用haproxy1.8.20来演示&lt;/p&gt;
&lt;p&gt;　　nbthread：指定每个haproxy进程开启的线程数；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424003905895-1973162176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示启动4个进程，每个进程里启动4个线程,默认每个进程一个线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200424004226434-1158936046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　maxsslconn：该指令指定每个haproxy进程ssl最大连接数，通常情况下证书都不放在haproxy上，nginx上放证书更加合适；&lt;/p&gt;
&lt;p&gt;　　maxconnrate：该指令指定每个进程每秒最大连接数；&lt;/p&gt;
&lt;p&gt;　　spread-checks：该指令指定后端server状态check随机提前或延迟百分比时间；通常情况下在后端主机较多的情况下使用；官方建议2-5(20%-50%)之间；如果在后端主机较多的情况下，不使用该指令来延迟对后端主机健康状态检查，那么很有可能降低haproxy的性能，因此该指令在后端主机较多的情况下（比如1000台甚至更多）能够避免同时并发对后端主机check时对haproxy的性能影响；&lt;/p&gt;
&lt;p&gt; 以上是haproxy global配置段比较常用的配置指令说明，更多配置指令请参考&lt;a href=&quot;https://cbonte.github.io/haproxy-dconv&quot; target=&quot;_blank&quot;&gt;https://cbonte.github.io/haproxy-dconv&lt;/a&gt;；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 23 Apr 2020 17:53:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了下haproxy的基础安装，以及怎样去代理后端主机的配置；当然没有很详细的去说配置文件中各指令的意思；有关haproxy的安装和代理后端server可以参考本人博客https://www.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12763245.html</dc:identifier>
</item>
<item>
<title>用了这么多年的泛型，你对它到底有多了解？ - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/12764925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/12764925.html</guid>
<description>&lt;p&gt;现代程序员写代码没有人敢说自己没用过泛型，这个泛型模板T可以被任何你想要的类型替代，确实很魔法很神奇，很多人也习以为常了，但就是这么有趣的泛型T底层到底是怎么帮你实现的，不知道有多少人清楚底层玩法，这篇我就试着来分享一下，不一定全对哈。。。&lt;/p&gt;

&lt;p&gt;现在的netcore 3.1和最新的.netframework8早已经没有当初那个被人诟病的ArrayList了，但很巧这玩意不得不说，因为它决定了C#团队痛改前非，抛弃过往重新上路，上一段ArrayList案例代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;    public class ArrayList
    {
        private object[] items;

        private int index = 0;

        public ArrayList()
        {
            items = new object[10];
        }

        public void Add(object item)
        {
            items[index++] = item;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码，为了保证在Add中可以塞入各种类型 eg: int,double,class， 就想到了一个绝招用祖宗类object接收，这就引入了两大问题，装箱拆箱和类型安全。&lt;/p&gt;
&lt;h2 id=&quot;1-装箱拆箱&quot;&gt;1. 装箱拆箱&lt;/h2&gt;
&lt;p&gt;这个很好理解，因为你使用了祖宗类，所以当你 &lt;code&gt;Add&lt;/code&gt; 的时候塞入的是值类型的话，自然就有装箱操作,比如下面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;            ArrayList arrayList = new ArrayList();
            arrayList.Add(3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1-占用更大的空间&quot;&gt;&amp;lt;1&amp;gt; 占用更大的空间&lt;/h3&gt;
&lt;p&gt;这个问题我准备用windbg看一下，相信大家知道一个int类型占用4个字节，那装箱到堆上是几个字节呢，好奇吧😄。&lt;/p&gt;
&lt;p&gt;原始代码和IL代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;        public static void Main(string[] args)
        {
            var num = 10;
            var obj = (object)num;
            Console.Read();
        }

    IL_0000: nop
        IL_0001: ldc.i4.s 10
        IL_0003: stloc.0
        IL_0004: ldloc.0
        IL_0005: box [mscorlib]System.Int32
        IL_000a: stloc.1
        IL_000b: call int32 [mscorlib]System.Console::Read()
        IL_0010: pop
        IL_0011: ret

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以清楚的看到IL_0005 中有一个box指令，装箱没有问题，然后抓一下dump文件。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;~0s -&amp;gt; !clrstack -l -&amp;gt; !do 0x0000018300002d48&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; ~0s
ntdll!ZwReadFile+0x14:
00007ff9`fc7baa64 c3              ret
0:000&amp;gt; !clrstack -l
OS Thread Id: 0xfc (0)
        Child SP               IP Call Site
0000002c397fedf0 00007ff985c808f3 ConsoleApp2.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp2\Program.cs @ 28]
    LOCALS:
        0x0000002c397fee2c = 0x000000000000000a
        0x0000002c397fee20 = 0x0000018300002d48

0000002c397ff038 00007ff9e51b6c93 [GCFrame: 0000002c397ff038] 
0:000&amp;gt; !do 0x0000018300002d48
Name:        System.Int32
MethodTable: 00007ff9e33285a0
EEClass:     00007ff9e34958a8
Size:        24(0x18) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff9e33285a0  40005a0        8         System.Int32  1 instance               10 m_value

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;倒数第5行 &lt;code&gt;Size: 24(0x18) bytes&lt;/code&gt;, 可以清楚的看到是24字节。 为什么是24个字节，&lt;code&gt;8(同步块指针) + 8(方法表指针) + 4(对象大小)=20&lt;/code&gt;,但因为是x64位，内存是按8对齐，也就是要按8的倍数计算，所以占用是 &lt;code&gt;8+8+8 =24&lt;/code&gt; 字节，原来只有4字节的大小因为装箱已被爆到24字节，如果是10000个值类型的装箱那空间占用是不是挺可怕的？&lt;/p&gt;
&lt;h3 id=&quot;2-栈到堆的装箱搬运到运输到售后到无害化处理都需要付出重大的人力和机器成本&quot;&gt;&amp;lt;2&amp;gt; 栈到堆的装箱搬运到运输到售后到无害化处理都需要付出重大的人力和机器成本&lt;/h3&gt;
&lt;h2 id=&quot;2-类型不安全&quot;&gt;2. 类型不安全&lt;/h2&gt;
&lt;p&gt;很简单，因为是祖宗类型object，所以无法避免程序员使用乱七八糟的类型,当然这可能是无意的，但是编译器确无法规避，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
            ArrayList arrayList = new ArrayList();
            arrayList.Add(3);
            arrayList.Add(new Action&amp;lt;int&amp;gt;((num) =&amp;gt; { }));
            arrayList.Add(new object());

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;面对这两大尴尬的问题，C#团队决定重新设计一个类型，实现一定终身，这就有了泛型。&lt;/p&gt;

&lt;h2 id=&quot;1-救世主&quot;&gt;1. 救世主&lt;/h2&gt;
&lt;p&gt;首先可以明确的说，泛型就是为了解决这两个问题而生的，你可以在底层提供的&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;中使用&lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;,&lt;code&gt;List&amp;lt;double&amp;gt;&lt;/code&gt;。。。等等你看得上的类型，而这种技术的底层实现原理才是本篇关注的重点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            List&amp;lt;double&amp;gt; list1 = new List&amp;lt;double&amp;gt;();
            List&amp;lt;string&amp;gt; list3 = new List&amp;lt;string&amp;gt;();
            ...
        }

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这个问题的探索其实就是 &lt;code&gt;List&amp;lt;T&amp;gt; -&amp;gt; List&amp;lt;int&amp;gt;&lt;/code&gt;在何处实现了 T -&amp;gt; int 的替换，反观java，它的泛型实现其实在底层还是用object来替换的，C#肯定不是这么做的，不然也没这篇文章啦，要知道在哪个阶段被替换了，你起码要知道C#代码编译的几个阶段，为了理解方便，我画一张图吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202004/214741-20200424011121290-648898157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程大家也看到了，要么在MSIL中被替换，要么在JIT编译中被替换。。。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            List&amp;lt;double&amp;gt; list1 = new List&amp;lt;double&amp;gt;();
            List&amp;lt;int&amp;gt; list2 = new List&amp;lt;int&amp;gt;();
            List&amp;lt;string&amp;gt; list3 = new List&amp;lt;string&amp;gt;();
            List&amp;lt;int[]&amp;gt; list4 = new List&amp;lt;int[]&amp;gt;();

            Console.ReadLine();
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;1-在第一阶段探究&quot;&gt;1. 在第一阶段探究&lt;/h2&gt;
&lt;p&gt;因为第一阶段是MSIL代码，所以用ILSpy看一下中间代码即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;         IL_0000: nop
                IL_0001: newobj instance void class [mscorlib]System.Collections.Generic.List`1&amp;lt;float64&amp;gt;::.ctor()
                IL_0006: stloc.0
                IL_0007: newobj instance void class [mscorlib]System.Collections.Generic.List`1&amp;lt;int32&amp;gt;::.ctor()
                IL_000c: stloc.1
                IL_000d: newobj instance void class [mscorlib]System.Collections.Generic.List`1&amp;lt;string&amp;gt;::.ctor()
                IL_0012: stloc.2
                IL_0013: newobj instance void class [mscorlib]System.Collections.Generic.List`1&amp;lt;int32[]&amp;gt;::.ctor()
                IL_0018: stloc.3
                IL_0019: call string [mscorlib]System.Console::ReadLine()
                IL_001e: pop
                IL_001f: ret

.class public auto ansi serializable beforefieldinit System.Collections.Generic.List`1&amp;lt;T&amp;gt;
        extends System.Object
        implements class System.Collections.Generic.IList`1&amp;lt;!T&amp;gt;,
                   class System.Collections.Generic.ICollection`1&amp;lt;!T&amp;gt;,
                   class System.Collections.Generic.IEnumerable`1&amp;lt;!T&amp;gt;,
                   System.Collections.IEnumerable,
                   System.Collections.IList,
                   System.Collections.ICollection,
                   class System.Collections.Generic.IReadOnlyList`1&amp;lt;!T&amp;gt;,
                   class System.Collections.Generic.IReadOnlyCollection`1&amp;lt;!T&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的IL代码中可以看到，最终的类定义还是 &lt;code&gt;System.Collections.Generic.List1\&amp;lt;T&amp;gt;&lt;/code&gt;，说明在中间代码阶段还是没有实现 T -&amp;gt; int 的替换。&lt;/p&gt;
&lt;h2 id=&quot;2-在第二阶段探究&quot;&gt;2. 在第二阶段探究&lt;/h2&gt;
&lt;p&gt;想看到JIT编译后的代码，这个说难也不难，其实每个对象头上都有一个方法表指针，而这个指针指向的就是方法表，方法表中有该类型的所有最终生成方法，如果不好理解，我就画个图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202004/214741-20200424011135790-1283166398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;!dumpheap -stat 寻找托管堆上的四个List对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !dumpheap -stat
Statistics:
              MT    Count    TotalSize Class Name
00007ff9e3314320        1           32 Microsoft.Win32.SafeHandles.SafeViewOfFileHandle
00007ff9e339b4b8        1           40 System.Collections.Generic.List`1[[System.Double, mscorlib]]
00007ff9e333a068        1           40 System.Collections.Generic.List`1[[System.Int32, mscorlib]]
00007ff9e3330d58        1           40 System.Collections.Generic.List`1[[System.String, mscorlib]]
00007ff9e3314a58        1           40 System.IO.Stream+NullStream
00007ff9e3314510        1           40 Microsoft.Win32.Win32Native+InputRecord
00007ff9e3314218        1           40 System.Text.InternalEncoderBestFitFallback
00007ff985b442c0        1           40 System.Collections.Generic.List`1[[System.Int32[], mscorlib]]
00007ff9e338fd28        1           48 System.Text.DBCSCodePageEncoding+DBCSDecoder
00007ff9e3325ef0        1           48 System.SharedStatics

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到从托管堆中找到了4个list对象，现在我就挑一个最简单的 &lt;code&gt;System.Collections.Generic.List1[[System.Int32, mscorlib]]&lt;/code&gt; ，前面的 00007ff9e333a068 就是方法表地址。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;!dumpmt -md 00007ff9e333a068&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !dumpmt -md 00007ff9e333a068
EEClass:         00007ff9e349b008
Module:          00007ff9e3301000
Name:            System.Collections.Generic.List`1[[System.Int32, mscorlib]]
mdToken:         00000000020004af
File:            C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
BaseSize:        0x28
ComponentSize:   0x0
Slots in VTable: 77
Number of IFaces in IFaceMap: 8
--------------------------------------
MethodDesc Table
           Entry       MethodDesc    JIT Name
00007ff9e3882450 00007ff9e3308de8 PreJIT System.Object.ToString()
00007ff9e389cc60 00007ff9e34cb9b0 PreJIT System.Object.Equals(System.Object)
00007ff9e3882090 00007ff9e34cb9d8 PreJIT System.Object.GetHashCode()
00007ff9e387f420 00007ff9e34cb9e0 PreJIT System.Object.Finalize()
00007ff9e38a3650 00007ff9e34dc6e8 PreJIT System.Collections.Generic.List`1[[System.Int32, mscorlib]].Add(Int32)
00007ff9e4202dc0 00007ff9e34dc7f8 PreJIT System.Collections.Generic.List`1[[System.Int32, mscorlib]].Insert(Int32, Int32)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法表中的方法过多，我做了一下删减，可以清楚的看到，此时Add方法已经接受(Int32)类型的数据了，说明在JIT编译之后，终于实现了 T -&amp;gt; int 的替换，然后再把 &lt;code&gt;List&amp;lt;double&amp;gt;&lt;/code&gt; 打出来看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !dumpmt -md 00007ff9e339b4b8
MethodDesc Table
           Entry       MethodDesc    JIT Name
00007ff9e3882450 00007ff9e3308de8 PreJIT System.Object.ToString()
00007ff9e389cc60 00007ff9e34cb9b0 PreJIT System.Object.Equals(System.Object)
00007ff9e3882090 00007ff9e34cb9d8 PreJIT System.Object.GetHashCode()
00007ff9e387f420 00007ff9e34cb9e0 PreJIT System.Object.Finalize()
00007ff9e4428730 00007ff9e34e4170 PreJIT System.Collections.Generic.List`1[[System.Double, mscorlib]].Add(Double)
00007ff9e3867a00 00007ff9e34e4280 PreJIT System.Collections.Generic.List`1[[System.Double, mscorlib]].Insert(Int32, Double)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面看的都是值类型，接下来再看一下如果 T 是引用类型会是怎么样呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !dumpmt -md 00007ff9e3330d58
MethodDesc Table
           Entry       MethodDesc    JIT Name
00007ff9e3890060 00007ff9e34eb058 PreJIT System.Collections.Generic.List`1[[System.__Canon, mscorlib]].Add(System.__Canon)

0:000&amp;gt; !dumpmt -md 00007ff985b442c0
MethodDesc Table
           Entry       MethodDesc    JIT Name
00007ff9e3890060 00007ff9e34eb058 PreJIT System.Collections.Generic.List`1[[System.__Canon, mscorlib]].Add(System.__Canon)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到当是&lt;code&gt;List&amp;lt;int[]&amp;gt;&lt;/code&gt; 和 &lt;code&gt;List&amp;lt;string&amp;gt;&lt;/code&gt; 的时候，JIT使用了 &lt;code&gt;System.__Canon&lt;/code&gt; 这么一个类型作为替代，有可能人家是摄影爱好者吧，为什么用&lt;code&gt;__Canon&lt;/code&gt;替代引用类型，这是因为它想让能共享代码区域的方法都共享来节省空间和内存吧，不信的话可以看看它们的Entry列都是同一个内存地址：00007ff9e3890060, 打印出来就是这么一段汇编。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !u 00007ff9e3890060
preJIT generated code
System.Collections.Generic.List`1[[System.__Canon, mscorlib]].Add(System.__Canon)
Begin 00007ff9e3890060, size 4a
&amp;gt;&amp;gt;&amp;gt; 00007ff9`e3890060 57              push    rdi
00007ff9`e3890061 56              push    rsi
00007ff9`e3890062 4883ec28        sub     rsp,28h
00007ff9`e3890066 488bf1          mov     rsi,rcx
00007ff9`e3890069 488bfa          mov     rdi,rdx
00007ff9`e389006c 8b4e18          mov     ecx,dword ptr [rsi+18h]
00007ff9`e389006f 488b5608        mov     rdx,qword ptr [rsi+8]
00007ff9`e3890073 3b4a08          cmp     ecx,dword ptr [rdx+8]
00007ff9`e3890076 7422            je      mscorlib_ni+0x59009a (00007ff9`e389009a)
00007ff9`e3890078 488b4e08        mov     rcx,qword ptr [rsi+8]
00007ff9`e389007c 8b5618          mov     edx,dword ptr [rsi+18h]
00007ff9`e389007f 448d4201        lea     r8d,[rdx+1]
00007ff9`e3890083 44894618        mov     dword ptr [rsi+18h],r8d
00007ff9`e3890087 4c8bc7          mov     r8,rdi
00007ff9`e389008a ff152088faff    call    qword ptr [mscorlib_ni+0x5388b0 (00007ff9`e38388b0)] (JitHelp: CORINFO_HELP_ARRADDR_ST)
00007ff9`e3890090 ff461c          inc     dword ptr [rsi+1Ch]
00007ff9`e3890093 4883c428        add     rsp,28h
00007ff9`e3890097 5e              pop     rsi
00007ff9`e3890098 5f              pop     rdi
00007ff9`e3890099 c3              ret
00007ff9`e389009a 8b5618          mov     edx,dword ptr [rsi+18h]
00007ff9`e389009d ffc2            inc     edx
00007ff9`e389009f 488bce          mov     rcx,rsi
00007ff9`e38900a2 90              nop
00007ff9`e38900a3 e8c877feff      call    mscorlib_ni+0x577870 (00007ff9`e3877870) (System.Collections.Generic.List`1[[System.__Canon, mscorlib]].EnsureCapacity(Int32), mdToken: 00000000060039e5)
00007ff9`e38900a8 ebce            jmp     mscorlib_ni+0x590078 (00007ff9`e3890078)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再回过头看&lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; 和 &lt;code&gt;List&amp;lt;double&amp;gt;&lt;/code&gt; ,从Entry列中看确实不是一个地址，说明&lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; 和 &lt;code&gt;List&amp;lt;double&amp;gt;&lt;/code&gt; 是两个完全不一样的Add方法，看得懂汇编的可以自己看一下哈。。。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;MethodDesc Table
           Entry       MethodDesc    JIT Name
00007ff9e38a3650 00007ff9e34dc6e8 PreJIT System.Collections.Generic.List`1[[System.Int32, mscorlib]].Add(Int32)
00007ff9e4428730 00007ff9e34e4170 PreJIT System.Collections.Generic.List`1[[System.Double, mscorlib]].Add(Double)

0:000&amp;gt; !u 00007ff9e38a3650
preJIT generated code
System.Collections.Generic.List`1[[System.Int32, mscorlib]].Add(Int32)
Begin 00007ff9e38a3650, size 50
&amp;gt;&amp;gt;&amp;gt; 00007ff9`e38a3650 57              push    rdi
00007ff9`e38a3651 56              push    rsi
00007ff9`e38a3652 4883ec28        sub     rsp,28h
00007ff9`e38a3656 488bf1          mov     rsi,rcx
00007ff9`e38a3659 8bfa            mov     edi,edx
00007ff9`e38a365b 8b5618          mov     edx,dword ptr [rsi+18h]
00007ff9`e38a365e 488b4e08        mov     rcx,qword ptr [rsi+8]
00007ff9`e38a3662 3b5108          cmp     edx,dword ptr [rcx+8]
00007ff9`e38a3665 7423            je      mscorlib_ni+0x5a368a (00007ff9`e38a368a)
00007ff9`e38a3667 488b5608        mov     rdx,qword ptr [rsi+8]
00007ff9`e38a366b 8b4e18          mov     ecx,dword ptr [rsi+18h]
00007ff9`e38a366e 8d4101          lea     eax,[rcx+1]
00007ff9`e38a3671 894618          mov     dword ptr [rsi+18h],eax
00007ff9`e38a3674 3b4a08          cmp     ecx,dword ptr [rdx+8]
00007ff9`e38a3677 7321            jae     mscorlib_ni+0x5a369a (00007ff9`e38a369a)
00007ff9`e38a3679 4863c9          movsxd  rcx,ecx
00007ff9`e38a367c 897c8a10        mov     dword ptr [rdx+rcx*4+10h],edi
00007ff9`e38a3680 ff461c          inc     dword ptr [rsi+1Ch]
00007ff9`e38a3683 4883c428        add     rsp,28h
00007ff9`e38a3687 5e              pop     rsi
00007ff9`e38a3688 5f              pop     rdi
00007ff9`e38a3689 c3              ret
00007ff9`e38a368a 8b5618          mov     edx,dword ptr [rsi+18h]
00007ff9`e38a368d ffc2            inc     edx
00007ff9`e38a368f 488bce          mov     rcx,rsi
00007ff9`e38a3692 90              nop
00007ff9`e38a3693 e8a8e60700      call    mscorlib_ni+0x621d40 (00007ff9`e3921d40) (System.Collections.Generic.List`1[[System.Int32, mscorlib]].EnsureCapacity(Int32), mdToken: 00000000060039e5)
00007ff9`e38a3698 ebcd            jmp     mscorlib_ni+0x5a3667 (00007ff9`e38a3667)
00007ff9`e38a369a e8bf60f9ff      call    mscorlib_ni+0x53975e (00007ff9`e383975e) (mscorlib_ni)
00007ff9`e38a369f cc              int     3


0:000&amp;gt; !u 00007ff9e4428730
preJIT generated code
System.Collections.Generic.List`1[[System.Double, mscorlib]].Add(Double)
Begin 00007ff9e4428730, size 5a
&amp;gt;&amp;gt;&amp;gt; 00007ff9`e4428730 56              push    rsi
00007ff9`e4428731 4883ec20        sub     rsp,20h
00007ff9`e4428735 488bf1          mov     rsi,rcx
00007ff9`e4428738 8b5618          mov     edx,dword ptr [rsi+18h]
00007ff9`e442873b 488b4e08        mov     rcx,qword ptr [rsi+8]
00007ff9`e442873f 3b5108          cmp     edx,dword ptr [rcx+8]
00007ff9`e4428742 7424            je      mscorlib_ni+0x1128768 (00007ff9`e4428768)
00007ff9`e4428744 488b5608        mov     rdx,qword ptr [rsi+8]
00007ff9`e4428748 8b4e18          mov     ecx,dword ptr [rsi+18h]
00007ff9`e442874b 8d4101          lea     eax,[rcx+1]
00007ff9`e442874e 894618          mov     dword ptr [rsi+18h],eax
00007ff9`e4428751 3b4a08          cmp     ecx,dword ptr [rdx+8]
00007ff9`e4428754 732e            jae     mscorlib_ni+0x1128784 (00007ff9`e4428784)
00007ff9`e4428756 4863c9          movsxd  rcx,ecx
00007ff9`e4428759 f20f114cca10    movsd   mmword ptr [rdx+rcx*8+10h],xmm1
00007ff9`e442875f ff461c          inc     dword ptr [rsi+1Ch]
00007ff9`e4428762 4883c420        add     rsp,20h
00007ff9`e4428766 5e              pop     rsi
00007ff9`e4428767 c3              ret
00007ff9`e4428768 f20f114c2438    movsd   mmword ptr [rsp+38h],xmm1
00007ff9`e442876e 8b5618          mov     edx,dword ptr [rsi+18h]
00007ff9`e4428771 ffc2            inc     edx
00007ff9`e4428773 488bce          mov     rcx,rsi
00007ff9`e4428776 90              nop
00007ff9`e4428777 e854fbffff      call    mscorlib_ni+0x11282d0 (00007ff9`e44282d0) (System.Collections.Generic.List`1[[System.Double, mscorlib]].EnsureCapacity(Int32), mdToken: 00000000060039e5)
00007ff9`e442877c f20f104c2438    movsd   xmm1,mmword ptr [rsp+38h]
00007ff9`e4428782 ebc0            jmp     mscorlib_ni+0x1128744 (00007ff9`e4428744)
00007ff9`e4428784 e8d50f41ff      call    mscorlib_ni+0x53975e (00007ff9`e383975e) (mscorlib_ni)
00007ff9`e4428789 cc              int     3

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能你有点蒙，我画一张图吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202004/214741-20200424011152259-965637432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;泛型T真正的被代替是在 JIT编译时才实现的，四个&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 会生成四个具有相应具体类型的类对象，所以就不存在拆箱和装箱的问题，而类型的限定visualstudio编译器工具提前就帮我们约束好啦。&lt;/p&gt;
&lt;p&gt;夜深了，先休息啦！ 希望本篇对你有帮助。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_200414062434170x170.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_200414065053baijiahao.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Apr 2020 17:11:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>现代程序员写代码没有人敢说自己没用过泛型，这个泛型模板T可以被任何你想要的类型替代，确实很魔法很神奇，很多人也习以为常了，但就是这么有趣的泛型T底层到底是怎么帮你实现的，不知道有多少人清楚底层玩法，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/12764925.html</dc:identifier>
</item>
<item>
<title>SpringBoot与单元测试JUnit的结合 - 小鱼吃猫</title>
<link>http://www.cnblogs.com/Lyn4ever/p/12764875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lyn4ever/p/12764875.html</guid>
<description>&lt;p&gt;有些人认为，写单元测试就是在浪费时间 ，写完代码，依然还是能够进行测试的。但是，还是建议写单元测试的，可以让你的条理更加清晰，而且当某个功能出现问题时，可能通过单元测试很容易的定位和解决问题。本文主要总结下在Spring及SpringBoot项目中，使用单元测试时的方法。将JUnit4和JUnit5对比着来写，因为我发现我身边的同事经常搞不明白要怎么用。在SpringBoot中使用单元测试Junit&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;145&quot;&gt;
&lt;p&gt;有些人认为，写单元测试就是在浪费时间 ，写完代码，依然还是能够进行测试的。但是，还是建议写单元测试的，可以让你的条理更加清晰，而且当某个功能出现问题时，可能通过单元测试很容易的定位和解决问题。本文主要总结下在Spring及SpringBoot项目中，使用单元测试时的方法。将JUnit4和JUnit5对比着来写，因为我发现我身边的同事经常搞不明白要怎么用。&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里主要说明下它们在Maven下的依赖包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;junit4&quot;&gt;Junit4&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.13&amp;lt;/version&amp;gt;
  &amp;lt;!--请注意这个scope的用法--&amp;gt;
  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;junit5&quot;&gt;Junit5&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;5.6.2&amp;lt;/version&amp;gt;
  &amp;lt;!--请注意这个scope的用法--&amp;gt;
  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上边的依赖中，两个依赖分别写了scope属性，这里做一个讲解：&lt;/p&gt;
&lt;p&gt;一个标准的maven项目结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200423205406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写Java代码的地方有两个src/main/java和src/test/java。如果我们不在上边依赖中添加scope为test属性，就可以在这两个地方任意地方写@Test测试方法，但是，如果添加了这个属性，就只能在src/test/java下写单元测试代码，这个就是maven所谓的test域。从上图也可以看出，test域可以有自己的配置文件，如果没有的话就会去加载main下的resources的配置文件，如果有，则以自己的为优先。&lt;/p&gt;

&lt;p&gt;不管使用哪一种方法，一个标准的单元测试方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestDemo {
                
    @Test
    void fun1(){
        System.out.println(&quot;欢迎关注我的微信公众号——小鱼与Java&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是对于Junit4而言，所有的测试方法应当是public声明的，而Junit5不用。只不过不同的版本，这个@Test的类是不同的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Junit4: org.junit.Test
Junit5: org.junit.jupiter.api.Test
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比Junit4而言，5添加了新的一些注解，但是常用的注解还是相同的，主要有以下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;注解&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;@Test&lt;/td&gt;
&lt;td&gt;写在一个测试类中的测试方法中的元注解，也就是说，在每一个单元测试方法上都应加上它才会生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@ParameterizedTest&lt;/td&gt;
&lt;td&gt;参数化测试，就是在你的测试方法执行时，自动添加一些参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@RepeatedTest&lt;/td&gt;
&lt;td&gt;重复此测试方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@TestFactory&lt;/td&gt;
&lt;td&gt;动态测试的工厂方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@TestTemplate&lt;/td&gt;
&lt;td&gt;测试模板&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@TestMethodOrder&lt;/td&gt;
&lt;td&gt;测试方法的执行顺序，默认是按照代码的前后顺序执行的&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@DisplayName&lt;/td&gt;
&lt;td&gt;自定义测试方法的名称显示&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@DisplayNameGeneration&lt;/td&gt;
&lt;td&gt;自定义名称生成器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;@BeforeEach&lt;/td&gt;
&lt;td&gt;在Junit4中，这个注解叫@Before。就是会在每一个测试方法执行前都会执行的方法，包括&lt;code&gt;@Test&lt;/code&gt;, &lt;code&gt;@RepeatedTest&lt;/code&gt;, &lt;code&gt;@ParameterizedTest&lt;/code&gt;,或者 &lt;code&gt;@TestFactory&lt;/code&gt;注解的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;@AfterEach&lt;/td&gt;
&lt;td&gt;和上边很相似，在Junit4中，这个注解叫@After。就是会在每一个测试方法执行之后都会执行的方法，包括&lt;code&gt;@Test&lt;/code&gt;, &lt;code&gt;@RepeatedTest&lt;/code&gt;, &lt;code&gt;@ParameterizedTest&lt;/code&gt;, 或者&lt;code&gt;@TestFactory&lt;/code&gt;注解的方法.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@BeforeAll&lt;/td&gt;
&lt;td&gt;在当前测试类中的方法执行前执行，只会执行一次，在Junit4中是@BeforeClass&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;@AfterAll&lt;/td&gt;
&lt;td&gt;在当前测试类中的所有测试方法执行完之后执行，只会执行一次，在Junit4中是@AfterClass&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;@Nested&lt;/td&gt;
&lt;td&gt;表示一个非静态的测试方法，也就是说@BeforeAll和@AfterAll对此方法无效，如果单纯地执行此方法，并不会触发这个类中的@BeforeAll和@AfterAll方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Tag&lt;/td&gt;
&lt;td&gt;自定义tag，就是可以自定义一个属于自己的@Test一样功能的注解&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Disabled&lt;/td&gt;
&lt;td&gt;表明此方法不可用，并不会执行，在JUnit4中的@Ignore&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Timeout&lt;/td&gt;
&lt;td&gt;设定方法执行的超时时间，如果超过，就会抛出异常&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上是在JUnit5中最常用的注解，可以自己挨个试下，一下子就会明白其用法。关注我，后续为您递上具体用法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;引入相关依赖后，然后在对应的位置进行测试就可以了，这里不做演示，可以自行下载代码查看&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里的Spring和SpringBoot项目也是基于Maven构建的，和普通Maven项目的最大区别就是加载Sprign容器而已，一般来说，使用Spring提供的上下文ApplicationContext就可以从配置文件件或者配置类加载Spring容器。如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 使用普通的Spring上下文来加载Spring容器
 * 
 * @auther 微信公众号：小鱼与Java
 * 2020/4/23
 */
public class MyMain {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        Teacher teacher = (Teacher) ctx.getBean(&quot;teacher&quot;);
        System.out.println(teacher.getName());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，我们可以通过引入Spring相关的test依赖来让其自动加载Spring上下文，这样我们就能利用如@Autowired这样的自动注入方式来获取bean了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;5.2.5.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这里对于JUnit4和JUnit5写测试方法时有一点儿不同之处，如下：&lt;/p&gt;
&lt;h2 id=&quot;junit4-2&quot;&gt;Junit4&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:application.xml&quot;})
public class TestDemo {
    @Resource
    private Teacher teacher;

    @Test
    public void fun(){
        System.out.println(teacher.getName());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;junit5-2&quot;&gt;Junit5&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringJUnitConfig
//指定配置文件路径，会先从test域中找
@ContextConfiguration(&quot;classpath:application.xml&quot;)
public class SpringTest {

    @Resource
    private Teacher teacher;

    @Test
    void fun(){
        System.out.println(teacher.getName());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它们都加了额外的注解来加载Spring上下文的&lt;/p&gt;

&lt;p&gt;在SpringBoot中，为我们提供了一个SpringBootTest的注解来加载Spring容器。在SpringBoot2.2.0以前是JUnit4，在SpringBoot之后是JUnit5。但是我建议最应该使用JUnit5。&lt;/p&gt;
&lt;h2 id=&quot;junit4-3&quot;&gt;Junit4&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.6.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.6.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;!--表示只能在maven的测试域中使用--&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootTest
@RunWith(SpringJUnit4ClassRunner.class)
public class TestDemo {

   @Resource
   private Student student;

   @Test
   public void fun1(){
        System.out.println(student.getName());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;junit5-3&quot;&gt;Junit5&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.2.6.RELEASE&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.2.6.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;!--表示只能在maven的测试域中使用--&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;exclusions&amp;gt;
      &amp;lt;!--这个是JUnit5中为了支持使用JUint4所做的一个过度
       也就是说，你只需要在你的JUnit4旧项目中添加这个依赖，
       就能完美过渡，而不用修改之前代码
       这里用不到，自然也就排除了。当然，这里，它无关紧要
                        --&amp;gt;
      &amp;lt;exclusion&amp;gt;
        &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
      &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootTest //它默认会为我们加载Spring容器，
public class TestDemo {

    @Resource
    private Student student;

    @Test
    void fun1(){
        System.out.println(student.getName());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么在SpringBoot中不用指定Spring容器的配置文件？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ 其实他是会自动加载类路径下的那个SpringBoot的启动类的，就算指定配置文件，也是指定那个启动类为配置类。如果你写的包结构不符合它的要求，就需要自己使用@ContextConfiguration注解来指定Spring的配置类了&lt;/p&gt;
&lt;p&gt;关注微信公众号 &quot;小鱼与Java&quot;，回复 2001 获取本文源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lyn4ever.gitee.io/img/wx/gzh2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 23 Apr 2020 16:36:00 +0000</pubDate>
<dc:creator>小鱼吃猫</dc:creator>
<og:description>有些人认为，写单元测试就是在浪费时间 ，写完代码，依然还是能够进行测试的。但是，还是建议写单元测试的，可以让你的条理更加清晰，而且当某个功能出现问题时，可能通过单元测试很容易的定位和解决问题。本文主要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lyn4ever/p/12764875.html</dc:identifier>
</item>
<item>
<title>浅析 CSS 中的边距重叠 - codingOrange</title>
<link>http://www.cnblogs.com/zhangguicheng/p/12764717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangguicheng/p/12764717.html</guid>
<description>&lt;h2 id=&quot;边距重叠是什么&quot;&gt;边距重叠是什么&lt;/h2&gt;
&lt;p&gt;在说边距重叠之前，先以正常的思维来考虑如果你现在是浏览器引擎遇到这种情况应该怎么办？&lt;/p&gt;
&lt;p&gt;现在有两个元素 div1 和 div2 紧挨着，中间没有它元素，它们的外边距就会发生重叠。div1 在左，div2 在右，div1 的 margin-left 为 20px， div2 的 margin-right 为 30px，那两个元素应该距离多少呢？&lt;/p&gt;
&lt;p&gt;50px 吗？应该不是的，如果是 50px，那么 div1 的 margin-left 设置的没起作用，距离右边的元素并不是 20px， div2 元素的 margin-right 也没有起作用。&lt;/p&gt;
&lt;p&gt;如果至少要让一个起作用，那应该要让数值大的 margin 起作用，因为如果让 margin 小的起作用有可能会影响显示。&lt;/p&gt;
&lt;p&gt;所以当两个相邻的外边距重合时，取较大的 margin。&lt;/p&gt;
&lt;p&gt;如果出现magin 为负的情况，则在最大的正maigin中减去绝对值最大的负margin。（这样距离会比较远不会影响相互的显示）&lt;/p&gt;
&lt;p&gt;如果没有正边界，则从零中减去绝对值最大的负边界。&lt;/p&gt;
&lt;p&gt;上面说完了相邻元素的边距重叠，还有一种就是父子元素之间的边距重叠。&lt;/p&gt;
&lt;p&gt;首先说明一下什么情况下父子元素之间会发生边距重叠，现在&lt;strong&gt;考虑父元素中包含一个子元素&lt;/strong&gt;的情况，&lt;strong&gt;当子元素设置了 margin，父元素的 border，padding 为 0 的情况下才会发生边距重叠，如果父元素的 border 或 padding 不为 0，那么子元素外边距和父元素的外边距之间会隔着父元素的 border 或 padding，这样父子元素的 margin 就不会在一起了，也就不会发生边距重叠了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面结合图说明可能出现的几种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况一：&lt;/strong&gt;父元素: margin: 0, 子元素： margin-top： 60px; 我们的本意是子元素距离父元素的顶部 60px，父元素距离其它元素的 margin 为 0。可是我们可以看到父元素距离顶部有一段间距，这就是子元素设置的 margin-top，父子元素的 margin 发生了重叠，这和我们本意并不相符。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;section id = 'sec'&amp;gt;
  &amp;lt;style media=&quot;screen&quot;&amp;gt;
    #sec {
  background: yellowgreen;
}
  .child {
    height: 100px;
    margin-top: 60px;
    background: pink;
  }
&amp;lt;/style&amp;gt;
&amp;lt;article class='child'&amp;gt;
  &amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hhcHB5Q29kaW5nMTAyNC9pbWFnZS1ob3N0aW5nL21hc3Rlci9pbWcvMTU4NzM3MzY5MjU3OC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;1587373692578&quot;/&gt;&lt;/p&gt;
&lt;p&gt;父元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hhcHB5Q29kaW5nMTAyNC9pbWFnZS1ob3N0aW5nL21hc3Rlci9pbWcvMTU4NzM3MzcwNjg3OC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;1587373706878&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况二：&lt;/strong&gt;父元素: margin-top: 100px, 子元素： margin-top： 60px; 通过下面的结果可以看到，父元素距离外部元素的 margin-top 是 100px，验证了边距重叠时，会取较大的 margin 值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;section id = 'sec'&amp;gt;
  &amp;lt;style media=&quot;screen&quot;&amp;gt;
    #sec {
                background: yellowgreen;
                        margin-top: 100px;
    }
    .child {
      height: 100px;
      margin-top: 60px;
      background: pink;
    }
        &amp;lt;/style&amp;gt;
        &amp;lt;article class='child'&amp;gt;
  &amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;父元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hhcHB5Q29kaW5nMTAyNC9pbWFnZS1ob3N0aW5nL21hc3Rlci9pbWcvMTU4NzM3NDA0NDg1MC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;1587374044850&quot;/&gt;&lt;/p&gt;
&lt;p&gt;子元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hhcHB5Q29kaW5nMTAyNC9pbWFnZS1ob3N0aW5nL21hc3Rlci9pbWcvMTU4NzM3NDEyMjk4My5wbmc?x-oss-process=image/format,png&quot; alt=&quot;1587374122983&quot;/&gt;&lt;/p&gt;
&lt;p&gt;平常我们经常见到的&lt;strong&gt;外边距塌陷&lt;/strong&gt;一般指的是下面这种情况。&lt;/p&gt;
&lt;p&gt;父子元素的上方有一个元素，这个时候又会发生边距重叠，并且当这个元素的 margin-bottom 的值要大于等于父子元素边距重叠后最终取得的 margin-top 的值时，父子元素的 margin-top 就不起作用了，这就是&lt;strong&gt;外边距塌陷&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用 MDN 上的外边距塌陷的例子吧。&lt;/p&gt;
&lt;p&gt;.blue 元素的 margin-bottom 是 12px， .red-inner 元素的 margin-top 也为 10px。这个时候 ，如图所示，.blue 元素和 .red-outer 元素之间的 margin 为 12px，.red-inner 元素的 margin-top 并没有起作用，发生了外边距塌陷。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;section id = 'sec'&amp;gt;
    &amp;lt;style&amp;gt;
      .blue {
        height: 50px;
        margin-bottom: 12px;
        background: blue;
      }
  
      .red-outer {
        background: red;
      }

      .red-inner {
        height: 50px;
        margin-top: 10px;
      }
    &amp;lt;/style&amp;gt;
    &amp;lt;div class=&quot;blue&quot;&amp;gt;blue&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;red-outer&quot;&amp;gt;
      &amp;lt;div class=&quot;red-inner&quot;&amp;gt;red inner&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/section&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hhcHB5Q29kaW5nMTAyNC9pbWFnZS1ob3N0aW5nL21hc3Rlci9pbWcvMjAyMDA0MjExNDU3MDAucG5n?x-oss-process=image/format,png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何解决边距重叠&quot;&gt;如何解决边距重叠&lt;/h2&gt;
&lt;p&gt;就上面外边距塌陷的例子而言，本质问题在于子元素没有按照我们的本意距离父元素的顶部 10px，而是与父元素发生了边距重叠。&lt;/p&gt;
&lt;p&gt;在最开始的时候我们分析过导致父子元素边距重叠的根本原因就是父元素的 border， padding 为 0，导致父子元素的外边距挨在一起，因此发生了边距重叠。&lt;/p&gt;
&lt;p&gt;那么&lt;strong&gt;给父元素的 border或者 padding 一个值即可父子元素边距重叠&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;p&gt;但是无缘无故给父元素一个 border 或 padding 值似乎不太合适，因此一般我们不采用这种方法，而是&lt;strong&gt;触发父元素的 BFC&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接下来就详细地讲一下 BFC 到底是什么，BFC 究竟是个什么神奇的东西呢，为什么父元素触发了 BFC 就可以解决边距重叠了，为什么父元素触发了 BFC 就可以清除浮动了呢？&lt;/p&gt;
&lt;p&gt;关于 BFC 我们在下一篇文章 &lt;a href=&quot;https://www.cnblogs.com/zhangguicheng/p/12747081.html&quot;&gt;CSS 中你应该了解的 BFC&lt;/a&gt; 中一探究竟。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Apr 2020 15:43:00 +0000</pubDate>
<dc:creator>codingOrange</dc:creator>
<og:description>浅析 CSS 中的边距重叠 边距重叠是什么 在说边距重叠之前，先以正常的思维来考虑如果你现在是浏览器引擎遇到这种情况应该怎么办？ 现在有两个元素 div1 和 div2 紧挨着，中间没有它元素，它们的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangguicheng/p/12764717.html</dc:identifier>
</item>
<item>
<title>Servlet 和 Servlet容器 - rickiyang</title>
<link>http://www.cnblogs.com/rickiyang/p/12764615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rickiyang/p/12764615.html</guid>
<description>&lt;h4 id=&quot;servlet&quot;&gt;Servlet&lt;/h4&gt;
&lt;p&gt;很多同学可能跟我一样始终没有搞清楚到底什么是 Servlet，什么是 Servlet 容器。网上看了很多帖子，或许人家说的很清楚，但是自己的那个弯弯就是拐不过来。&lt;/p&gt;
&lt;p&gt;想了很久说一下自己的理解。&lt;/p&gt;
&lt;p&gt;Java web 开发中为啥要有 Servlet 呢？是否可以不要。&lt;/p&gt;
&lt;p&gt;web开发的本质就一句话：客户端和服务器交换数据。于是你使用 Java 的 Socket 套接字进行编程，去处理客户端来的 tcp 请求，经过编解码处理读取请求体，获取请求行，然后找到请求行对应的处理逻辑步入服务器的处理中，处理完毕把对应的结果返回给当前的 Socket 链接，响应完毕，关闭 Socket。&lt;/p&gt;
&lt;p&gt;以上过程，你有没有发现其实是两个部分：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;建立连接，传输数据，关闭连接，你肯定知道这些步骤不是你所开发的web服务去处理的，而是tomcat容器帮你做了这些事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;拿到请求行之后去找对应的 url 路由，这一部分是谁做的呢？在如今 SpringBoot 横行的时代，去配置化已经成为趋势，编程越来越简单导致的后果就是越来越难以理解事物最开始的样子。还记得 SpringMVC工程中的 web.xml文件吗？是否还记得在web.xml中有这么一段配置呢：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet
        &amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
                &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
                &amp;lt;param-value&amp;gt;classpath*:/spring/SpringMVC-servlet.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;

&amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring 的核心就是一个 Servlet,它拦截了所有的请求,将请求交给 DispatcherServlet 去处理。&lt;br/&gt;我们再来问一遍，Servlet 到底是什么，它就是一段处理 web 请求的逻辑，并不是很高深的东西。&lt;/p&gt;
&lt;p&gt;再来看 Java 中的 Servlet，它只是一个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
package javax.servlet;

import java.io.IOException;


public interface Servlet {

   
    public void init(ServletConfig config) throws ServletException;

    public ServletConfig getServletConfig();

    public void service(ServletRequest req, ServletResponse res)
            throws ServletException, IOException;

    public String getServletInfo();

    public void destroy();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 接口规定请求从容器到达 web 服务端的规范，最重要的三个步骤是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;init()：初始化请求的时候要做什么；&lt;/li&gt;
&lt;li&gt;service()：拿到请求的时候要做什么；&lt;/li&gt;
&lt;li&gt;destory()：处理完请求销毁的时候要做什么。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所有实现 Servlet 的实现方都是在这个规范的基础上进行开发。那么 Servlet 中的数据是从哪里来的呢？答案就是 Servlet 容器。容器才是真正与客户端打交道的那一方。Servlet容器只有一个，而 Servlet 可以有多个。常见的Servlet容器Tomcat,它监听了客户端的请求端口,根据请求行信息确定将请求交给哪个Servlet 处理，找到处理的Servlet之后，调用该Servlet的 service() 方法，处理完毕将对应的处理结果包装成ServletResponse 对象返回给客户端。&lt;/p&gt;
&lt;h4 id=&quot;servlet-容器&quot;&gt;Servlet 容器&lt;/h4&gt;
&lt;p&gt;上面说过，Servlet 只是一个处理请求的应用程序，光有Servlet是无法运行起来的，需要有一个 main 方法去调用你的这段 Servlet 程序才行。所以这里出现了Servlet 容器的概念。Servlet容器的主要作用是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建立连接；&lt;/li&gt;
&lt;li&gt;调用Servlet处理请求；&lt;/li&gt;
&lt;li&gt;响应请求给客户端；&lt;/li&gt;
&lt;li&gt;释放连接；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这上面的四步，如果是你来设计的话是否可以用一个模板方法搞定，1，3，4都是固定的步骤，不会因为请求不同而有很大的变化。2却会因为对应的请求不同需要业务逻辑自己去实现不同的处理。所以这里抽象出来了 Servlet，Servlet想怎么玩就怎么玩，这是你自己的事情。容器帮你做的是你不想做的脏活累活。&lt;/p&gt;
&lt;p&gt;另外，既然叫做容器肯定是能装多个Servlet，并且可以管理Servlet的声明周期。这些功能应该是容器必备的。&lt;/p&gt;
&lt;p&gt;上面提到了 web.xml 中的 DispatcherServlet，它是 Spring 中定义的一个 Servlet，实现了 Servlet 接口，本质也是一个 Servlet。只是它是 HttpServlet 的继承者，主要处理 http 请求。所以 Spring 程序本质是就是一个 Servlet。SpringMVC 帮你做了本该你去实现的逻辑，你看不到并不代表它不是。&lt;/p&gt;
&lt;p&gt;好啦，以上通俗的语言解释了什么是 Servlet，什么是 Servlet 容器，以及 Servlet 和 Servlet 容器之间的关系。&lt;/p&gt;
&lt;h4 id=&quot;tomcat&quot;&gt;Tomcat&lt;/h4&gt;
&lt;p&gt;Tomcat是啥呢？本质上是一个 Servlet 容器，实现了对 Java Servlet 规范的支持。同时 Tomcat 也提供了处理HTTP请求的能力，所以也可以作为一个Web服务器。了解到Tomcat有 Web服务器和 Servlet容器的功能，那么 Tomcat总体是如何设计的呢？我们来看一张简图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1607781/202004/1607781-20200423231951106-1254411029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java web 应用如果部署到 Tomcat 中，一个Tomcat就表示一个服务。一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina，而一个 Service 服务可以包含多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等，一个 Service 服务还会包括一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 ServletRequest 和 ServletResponse 对象进行交流。&lt;/p&gt;
&lt;p&gt;Tomcat容器的设计提现在一个核心文件中：server.xml。这个文件充分展示了Tomcat的高度抽象设计：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&amp;gt;
    &amp;lt;Service name=&quot;Catalina&quot;&amp;gt;
        &amp;lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
                   connectionTimeout=&quot;20000&quot;
                   redirectPort=&quot;8443&quot;/&amp;gt;
        &amp;lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;/&amp;gt;
                                &amp;lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&amp;gt;
                &amp;lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot;
                        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
          
          
            &amp;lt;/Host&amp;gt;
        &amp;lt;/Engine&amp;gt;
    &amp;lt;/Service&amp;gt;
&amp;lt;/Server&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ol readability=&quot;16.164003759398&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Server 组件是管理 tomcat 实例的组件，可以监听一个端口，从此端口上可以远程向该实例发送 shutdown 关闭命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12.287521079258&quot;&gt;
&lt;p&gt;Service 组件是一个逻辑组件，用于绑定 connector 和 container，有了 service 表示可以向外提供服务，就像是一般的 daemon 类服务的 service。可以认为一个 service 就启动一个JVM，更严格地说，一个 engine 组件才对应一个 JVM （定义负载均衡时，jvmRoute 就定义在 Engine 组件上用来标识这个 JVM ），只不过 connector 也工作在 JVM 中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小故事&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;是否关注到 Service name = Catalina，实际上 Tomcat 的前身就是 Catalina，这是一个岛的名字，而&lt;/p&gt;
&lt;p&gt;Catalina 只是一个 Servlet 容器，为&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_servlet&quot;&gt;Servlet&lt;/a&gt;和 JavaServer Pages（JSP）实现了&lt;a href=&quot;https://en.wikipedia.org/wiki/Sun_Microsystems&quot;&gt;Sun Microsystems&lt;/a&gt;的规范。&lt;/p&gt;
&lt;p&gt;Tomcat 的作者 &lt;a href=&quot;https://en.wikipedia.org/wiki/James_Duncan_Davidson&quot;&gt;詹姆斯·邓肯·戴维森&lt;/a&gt;，Sun Microsystems 的软件架构师在后来 Sun Microsystems 向 Apache Software Foundation 捐赠该项目中发挥了重要作用。当时他认为许多开源项目都有与 &lt;a href=&quot;https://en.wikipedia.org/wiki/O'Reilly_Media&quot;&gt;O'Reilly&lt;/a&gt; 相关的书籍，封面上有动物，所以他想以动物命名。后来这位老哥想到了猫🐈。他认为这只动物代表着某种可以自己生存的东西，当2003年 O'Reilly 发行带有&lt;a href=&quot;https://en.wikipedia.org/wiki/Snow_leopard&quot;&gt;雪豹&lt;/a&gt;的 Tomcat 书籍时，他希望看到动物封面的愿望终于实现了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;Connector 组件是监听组件，它有四个作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开启监听套接字，监听外界请求，并和客户端建立 TCP 连接；&lt;/li&gt;
&lt;li&gt;使用 protocolHandler 解析请求中的协议和端口等信息，如 http 协议、AJP 协议；&lt;/li&gt;
&lt;li&gt;根据解析到的信息，使用 processer 将分析后的请求转发给绑定的 Engine；&lt;/li&gt;
&lt;li&gt;接收响应数据并返回给客户端。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的 server.xml 配置我们能看到有两个 Connector。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 Connector 表示通过 8080 端口使用 HTTP/1.1版本的协议来访问 Tomcat。&lt;/p&gt;
&lt;p&gt;我们知道 80 端口是为 HTTP(HyperText Transport Protocol) 即 超文本传输协议 开放的，主要用于万维网传输信息的协议。而我们一般在 Tomcat 中监听的是一个非 80 端口。那为啥不直接在 Tomcat 中写上 80 端口，即所有 HTTP 请求都可以收到。这是因为在生产环境中，一般不会直接暴露原始服务给外网，一方面是安全性，另一方面是 负载均衡处理 和 静态资源处理。所以会在原始服务上加一层代理，代理来监听 80 端口，再将服务暴露端口的请求转发给对应服务。&lt;/p&gt;
&lt;p&gt;第二个 Connector：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 Connector 监听 8009 端口的 AJP 协议连接。AJP 协议负责和其他的 HTTP 服务器(如 Apache )建立连接；在把 Tomcat 与其他 HTTP 服务器集成时，就需要用到这个连接器。之所以使用 Tomcat 和其他服务器集成，是因为 Tomcat 可以用作 Servlet/JSP 容器，但是对静态资源的处理速度较慢，不如 Apache 和 IIS 等 HTTP 服务器。因此常常将 Tomcat 与 Apache 等集成，前者作 Servlet 容器，后者处理静态资源，而 AJP 协议便负责 Tomcat 和 Apache 的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Container 表示一类组件，在配置文件(server.xml)中没有体现出来。它包含4个容器类组件：Engine容器、Host容器、Context容器 和 wrapper容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Engine&lt;/strong&gt; 容器用于从 Connector 组件处接收已建立的 TCP 连接，还用于接收客户端发送的 HTTP 请求并分析请求，然后按照分析的结果将相关参数传递给匹配出的虚拟主机。Engine 还用于指定默认的虚拟主机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt; 容器定义虚拟主机，对应了服务器中一个网络名实体（如”www.baidu.com”，或IP地址”23.0.32.1”）。为了使用户可以通过域名连接 Tomcat 服务器，这个域名应该在域名服务器已经注册过。&lt;/p&gt;
&lt;p&gt;比如上例中的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot;
                        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;name=localhost 表示当前对应的请求是本机，这是因为已经配置了Nginx代理的原因，如果没有配置代理，那么这里就必须是真实的IP 或者域名。注意后面的 appBase，appBase表示当前 web资源所在的目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Context&lt;/strong&gt; 容器主要是根据 path 和 docBase 获取一些信息，将结果交给其内的 wrapper 组件进行处理（它提供wrapper运行的环境，所以它叫上下文context）。一般来说，都采用默认的标准 wrapper 类，因此在 Context 容器中几乎不会出现 wrapper 组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wrapper&lt;/strong&gt; 容器对应 Servlet 的处理过程。它开启 Servlet 的生命周期，根据 Context 给出的信息以及解析 web.xml 中的映射关系，负责装载相关的类，初始化 servlet 对象 &lt;code&gt;init()&lt;/code&gt;、执行 servlet 代码 &lt;code&gt;service()&lt;/code&gt; 以及服务结束时 servlet 对象的销毁 &lt;code&gt;destory()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;根据上面描述的 tomcat 组件体系结构，处理请求的大致过程其实很容易推导出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Client(request)--&amp;gt;Connector--&amp;gt;Engine--&amp;gt;Host--&amp;gt;Context--&amp;gt;Wrapper(response data)--&amp;gt;Connector(response header)--&amp;gt;Client
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到宏观上 Tomcat 设计的真是非常精妙，层叠式的容器设计呈现出一种美感。Connector 和 Container 两大组件涵盖主要功能，这种复合组件化的设计思想我们是否可以应用在业务系统中呢。右面有空继续分析 Tomcat 中各个模块的设计。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Apr 2020 15:21:00 +0000</pubDate>
<dc:creator>rickiyang</dc:creator>
<og:description>Servlet 和 Servlet容器的概念</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rickiyang/p/12764615.html</dc:identifier>
</item>
</channel>
</rss>