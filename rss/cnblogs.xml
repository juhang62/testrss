<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SLAM+语音机器人DIY系列：（二）ROS入门——8.理解roslaunch在大型项目中的作用 - 小虎哥哥爱学习</title>
<link>http://www.cnblogs.com/hiram-zhang/p/10393328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiram-zhang/p/10393328.html</guid>
<description>&lt;p&gt;&lt;span&gt;ROS&lt;span&gt;机器人操作系统&lt;/span&gt;在机器人应用领域很流行，依托代码开源和模块间协作等特性，给机器人开发者带来了很大的方便。我们的机器人“&lt;span&gt;miiboo&lt;/span&gt;”中的大部分程序也采用ROS进行开发，所以本文就重点对ROS基础知识进行详细的讲解，给不熟悉ROS的朋友起到一个抛砖引玉的作用。本章节主要内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.ROS是什么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.ROS系统整体架构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.在ubuntu16.04中安装ROS kinetic&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.如何编写ROS的第一个程序hello_world&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.编写简单的消息发布器和订阅器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.编写简单的service和client&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.理解tf的原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.理解roslaunch在大型项目中的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.熟练使用rviz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.在实际机器人上运行ROS高级功能预览&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;roslaunch&lt;/span&gt;&lt;span&gt;的作用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一个大型的机器人项目中，经常涉及到多个&lt;/span&gt;node&lt;span&gt;协同工作，并且每个&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;都有很多可设置的&lt;/span&gt;&lt;span&gt;parameter&lt;/span&gt;&lt;span&gt;。比如我们的机器人&lt;/span&gt;miiboo_nav&lt;span&gt;导航项目，涉及到地图服务节点、定位算法节点、运动控制节点、底盘控制节点、激光雷达数据获取节点等众多节点，和几百个影响着这些&lt;/span&gt;node&lt;span&gt;行为模式的&lt;/span&gt;&lt;span&gt;parameter&lt;/span&gt;&lt;span&gt;。如果全部手动&lt;/span&gt;&lt;span&gt;rosrun&lt;/span&gt;&lt;span&gt;逐个启动&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;并传入&lt;/span&gt;&lt;span&gt;parameter&lt;/span&gt;&lt;span&gt;，工程的复杂程度将难以想象。所以这个时候就需要用&lt;/span&gt;&lt;span&gt;roslaunch&lt;/span&gt;&lt;span&gt;来解决问题，将需要启动的节点和需要设置的&lt;/span&gt;&lt;span&gt;parameter&lt;/span&gt;&lt;span&gt;全部写入一个&lt;/span&gt;&lt;span&gt;*.launch&lt;/span&gt;&lt;span&gt;文件，然后用&lt;/span&gt;&lt;span&gt;roslaunch&lt;/span&gt;&lt;span&gt;一次性的启动&lt;/span&gt;&lt;span&gt;*.launch&lt;/span&gt;&lt;span&gt;文件，这样所有的节点就轻而易举的启动了。&lt;/span&gt;miiboo_nav&lt;span&gt;导航项目的&lt;/span&gt;miiboo_nav.launch&lt;span&gt;文件内容如图&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190217225807210-473734253.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;28&lt;span&gt;）&lt;/span&gt;miiboo_nav&lt;span&gt;导航项目的&lt;/span&gt;miiboo_nav.launch&lt;span&gt;文件内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;标签介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;launch&lt;span&gt;文件采用&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;文本标记语言进行编写，对比较常用的标签进行介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&amp;lt;launch&amp;gt;&lt;span&gt;标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;这个是顶层标签，所有的描述标签都要写在&lt;/span&gt;&amp;lt;launch&amp;gt;&amp;lt;/launch&amp;gt;&lt;span&gt;之间。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
...
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&amp;lt;node&amp;gt;&lt;span&gt;标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;这个是最常见的标签，每个&lt;/span&gt;node&lt;span&gt;标签里包含了&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;图中节点的名称属性&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;、该节点所在的包名&lt;/span&gt;&lt;span&gt;pkg&lt;/span&gt;&lt;span&gt;、节点的类型&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;为可执行文件名称，如果节点用&lt;/span&gt;&lt;span&gt;c++&lt;/span&gt;&lt;span&gt;编写；&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;*.py&lt;/span&gt;&lt;span&gt;，如果节点用&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;编写）、调试属性&lt;/span&gt;&lt;span&gt;output&lt;/span&gt;&lt;span&gt;（如果&lt;/span&gt;&lt;span&gt;output=&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;screen&lt;/span&gt;&lt;span&gt;”，终端输出信息将被打印到当前控制台，而不是存入&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;日志文件）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;node &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=”xx” &lt;/span&gt;&lt;span&gt;pkg&lt;/span&gt;&lt;span&gt;=”xx” &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=”xx” &lt;/span&gt;&lt;span&gt;output&lt;/span&gt;&lt;span&gt;=”xx”&amp;gt;
&lt;/span&gt;&lt;span&gt;...
&amp;lt;/node&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&amp;lt;include&amp;gt;&lt;span&gt;标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;这个标签是用于导入另一个&lt;/span&gt;*.launch&lt;span&gt;文件到当前文件。也就是说高层级的&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;文件可以通过&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;的方法调用其它&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;文件，这样可以使&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;文件的组织方式更加模块化，便于移植与复用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;=”$(find &lt;/span&gt;&lt;span&gt;pkg_name)/launch/xx.launch”&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;remap&amp;gt;&lt;span&gt;标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个标签是用于将&lt;/span&gt;topic&lt;span&gt;的名称进行重映射，&lt;/span&gt; from&lt;span&gt;中填入原来的&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;名称，&lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;中填入新的&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;名称。&lt;/span&gt;&lt;span&gt;&amp;lt;remap&amp;gt;&lt;/span&gt;&lt;span&gt;标签根据放置在&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;文件的层级不同，在相应的层级起作用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;remap &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;=”orig_topic_name” &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=”new_topic_name”/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;param&amp;gt;&lt;span&gt;标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个标签用于在参数服务器中创建或设置一个指定名称的参数值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=”param_name” &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=”xx” &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=”xx”/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;rosparam&amp;gt;&lt;span&gt;标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个标签用于从&lt;/span&gt;yaml&lt;span&gt;文件中一次性导入大量参数到参数服务器中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rosparam &lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;span&gt;=”load” &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;=”$(find &lt;/span&gt;&lt;span&gt;pkg_name)/path_to_file.yaml”&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;arg&amp;gt;&lt;span&gt;标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个标签用于在&lt;/span&gt;launch&lt;span&gt;文件中定义用于存储的临时变量，该标签定义的变量只在当前&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;文件中使用。推荐使用第一种方式赋值，这样可以方便从命令行中传入参数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=”xx” &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=”xx”/&amp;gt;
&lt;/span&gt;&lt;span&gt;或者
&amp;lt;arg name&lt;/span&gt;&lt;span&gt;=”xx” &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=”xx”/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;lt;&lt;strong&gt;group&amp;gt;&lt;span&gt;标签：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个标签用于将&lt;/span&gt;node&lt;span&gt;批量划分到某个命名空间。便于大项目中节点的批量管理。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;group &lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;=”group_one”&amp;gt;
&lt;/span&gt;&lt;span&gt;&amp;lt; node ... &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; node &lt;/span&gt;&lt;span&gt;... &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;group &lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;=”group_two”&amp;gt;
&lt;/span&gt;&lt;span&gt;&amp;lt; node ... &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; node &lt;/span&gt;&lt;span&gt;... &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;的使用方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先在相应功能包目录下新建一个&lt;/span&gt;launch&lt;span&gt;文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在&lt;/span&gt;launch&lt;span&gt;文件夹中新建&lt;/span&gt;&lt;span&gt;*.launch&lt;/span&gt;&lt;span&gt;文件，并按照上面的&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;标签规则编写好&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;文件的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后在终端中用&lt;/span&gt;roslaunch&lt;span&gt;命令启动&lt;/span&gt;&lt;span&gt;launch&lt;/span&gt;&lt;span&gt;文件，命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd ~/catkin_ws/&lt;span&gt;
source devel&lt;/span&gt;/&lt;span&gt;setup.bash
roslaunch &lt;/span&gt;&amp;lt;pkg_name&amp;gt; &amp;lt;file_name.launch&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;特别说明，&lt;span&gt;由于&lt;/span&gt;&lt;/span&gt;&lt;span&gt;roslaunch&lt;span&gt;命令会自动去启动&lt;/span&gt;&lt;span&gt;roscore&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，所以不需要像之前使用&lt;/span&gt;&lt;span&gt;rosrun&lt;/span&gt;&lt;span&gt;那样特意先去手动启动&lt;/span&gt;&lt;span&gt;roscore&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Feb 2019 15:54:00 +0000</pubDate>
<dc:creator>小虎哥哥爱学习</dc:creator>
<og:description>摘要 ROS机器人操作系统在机器人应用领域很流行，依托代码开源和模块间协作等特性，给机器人开发者带来了很大的方便。我们的机器人“miiboo”中的大部分程序也采用ROS进行开发，所以本文就重点对ROS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hiram-zhang/p/10393328.html</dc:identifier>
</item>
<item>
<title>Vue2.5开发去哪儿网App 第三章笔记  上 - 最美的烟火</title>
<link>http://www.cnblogs.com/donghaoblogs/p/10393285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donghaoblogs/p/10393285.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.  vue 生命周期函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;生命周期图示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://doc.vue-js.com/images/lifecycle.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;979&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_0fda732b-fd0e-42f5-8ae9-4dbdf57f1316&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0fda732b-fd0e-42f5-8ae9-4dbdf57f1316&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0fda732b-fd0e-42f5-8ae9-4dbdf57f1316&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue实例生命周期函数&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../../vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{
            test:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;template option&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;{{test}}&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        beforeCreate:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。&lt;/span&gt;
&lt;span&gt;
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beforCreate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        created:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。&lt;/span&gt;
&lt;span&gt;
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;created&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        beforeMount:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在挂载开始之前被调用：相关的 render 函数首次被调用&lt;/span&gt;
&lt;span&gt;
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beforeMount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);
        },
        mounted:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。&lt;/span&gt;
&lt;span&gt;
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mounted&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data.test &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我改变了test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; beforeUpdate   updated方法&lt;/span&gt;
&lt;span&gt;

        },
        beforeDestroy:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例销毁之前调用。在这一步，实例仍然完全可用。&lt;/span&gt;
&lt;span&gt;            
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beforeDestrory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        destroyed:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。&lt;/span&gt;
&lt;span&gt;            
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;destroyed&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        beforeUpdate:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。&lt;/span&gt;
&lt;span&gt;
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;boforeUpdate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        updated:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。&lt;/span&gt;
&lt;span&gt;

            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;updated&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$destroy();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发 beforeDestroy 和 destroyed 的钩子。&lt;/span&gt;
&lt;span&gt;        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 模板语法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。&lt;/p&gt;
&lt;p&gt;在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_db35a481-6a9a-4627-8b4f-7035807a4c03&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_db35a481-6a9a-4627-8b4f-7035807a4c03&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_db35a481-6a9a-4627-8b4f-7035807a4c03&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;模板语法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../../vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{name}}
    &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;#插值表达式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;文本&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-html&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; :title&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;被插入的内容都会被当做 HTML —— 数据绑定会被忽略&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;age + '岁'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;#过滤器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{ msg | capitalize }}

    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;v-bind:href&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;百度一下&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;


    v-bind 缩写
    &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 完整语法 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;v-bind:href&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;:href&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;


    v-on 缩写
    &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 完整语法 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doSomething&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;doSomething&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{
            name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;h1&amp;gt;Dell&amp;lt;/h1&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            title:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is a title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            age:&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
            msg:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is a message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        filters: {
            capitalize: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;value) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; value.toString()
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.charAt(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;).toUpperCase() &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; value.slice(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            }
        }
    })
    console.log(app.$data)
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 计算属性，方法，侦听器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_4763e17f-5743-40fa-973f-988d5bb6b4d6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4763e17f-5743-40fa-973f-988d5bb6b4d6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4763e17f-5743-40fa-973f-988d5bb6b4d6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;计算属性，方法，侦听器&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../../vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;获取fullName&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第一种方式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;{{ fullName }}&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第二种方式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;{{getFullName()}}&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第三种方式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{fullName}}

    {{ age }}

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{
            firstName:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dell&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            lastName:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            age:&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
            fullName:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dell Lee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #计算属性  缓存机制，如果依赖的值没有发生改变，不会重新执行&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; computed:{&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     fullName:function () {&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         console.log('fullName 计算了一次')&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         return this.firstName+&quot;   &quot;+this.lastName&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; },&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; methods:{&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     // 即使依赖的值没有发生改变，也会重新执行&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     getFullName:function () {&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         console.log('getFullName 计算了一次')&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         return this.firstName+&quot;   &quot;+this.lastName&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; },&lt;/span&gt;
&lt;span&gt;        watch:{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #类似computed&lt;/span&gt;
&lt;span&gt;            firstName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我执行了firstName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fullName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.firstName&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName
            },
            lastName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fullName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.firstName&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我执行了lastName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            },
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 计算属性的 setter,getter&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_ba45600c-0abe-47b2-ae33-2df2e565d69b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ba45600c-0abe-47b2-ae33-2df2e565d69b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ba45600c-0abe-47b2-ae33-2df2e565d69b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;计算属性setter和getter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../../vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{fullName}}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data:{
            firstName:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dell&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            lastName:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        },
        computed: {
            fullName: {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #依赖的值发生改变时，执行&lt;/span&gt;
&lt;span&gt;                get:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.firstName &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName
                },
                set:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; value.split(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    console.log(name);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.firstName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                }
            }
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 17 Feb 2019 15:31:00 +0000</pubDate>
<dc:creator>最美的烟火</dc:creator>
<og:description>1. vue 生命周期函数 每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/donghaoblogs/p/10393285.html</dc:identifier>
</item>
<item>
<title>快速排序算法分析解析 - friendwrite</title>
<link>http://www.cnblogs.com/friendwrite/p/10393255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/friendwrite/p/10393255.html</guid>
<description>&lt;p&gt;快速排序算法的时间复杂度和各次标准数据元素的值关系很大。如果每次选取的标准元素都能均分两个子数组的长度,这样的快速排序过程是一个完全二叉树结构。(即每个结点都把当前数组分成两个大小相等的数组结点,n个元素数组的根结点的分解次数就构成一棵完全二叉树)。这时分解次数等于完全二叉树的深度log2n;每次快速排序过程无论把数组怎样划分、全部的比较次数都接近于n-1次，所以最好情况下快速排序算法的时间复杂度为O(nlog2n):快速排序算法的最坏情况是数据元素已全部有序，此时数据元素数组的根结点的分需次数构成一棵二叉退化树(即单分支二叉树),一棵二叉退化树的深度是n,所以最坏情况下快速排序算法的时间复杂度为O(n2)。般情况下 ,标准元素值的分布是随机的，数组的分邮大数构成模二又树，这样的二叉树的深度接近于log2n, 所以快速排序算法的平均(或称期望）时间复杂度为O(nlog2n)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; findKey(&amp;amp;&lt;span&gt;$arr&lt;/span&gt;, &lt;span&gt;$low&lt;/span&gt;, &lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;$target&lt;/span&gt; = &lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$low&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;$low&lt;/span&gt; &amp;lt; &lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;$low&lt;/span&gt; &amp;lt; &lt;span&gt;$hight&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;$target&lt;/span&gt; &amp;lt; &lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;]) {
            &lt;/span&gt;&lt;span&gt;$hight&lt;/span&gt;--&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$low&lt;/span&gt;] = &lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;$low&lt;/span&gt; &amp;lt; &lt;span&gt;$hight&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;$target&lt;/span&gt; &amp;gt; &lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$low&lt;/span&gt;&lt;span&gt;]) {
            &lt;/span&gt;&lt;span&gt;$low&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$hight&lt;/span&gt;] = &lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$low&lt;/span&gt;&lt;span&gt;];
    }
    &lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$hight&lt;/span&gt;]=&lt;span&gt;$target&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; quickSort(&amp;amp;&lt;span&gt;$arr&lt;/span&gt;,&lt;span&gt;$low&lt;/span&gt;,&lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;$posKey&lt;/span&gt;=findKey(&lt;span&gt;$arr&lt;/span&gt;,&lt;span&gt;$low&lt;/span&gt;,&lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$low&lt;/span&gt;&amp;lt;&lt;span&gt;$posKey&lt;/span&gt;&lt;span&gt;){
        quickSort(&lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt;,&lt;span&gt;$low&lt;/span&gt;,&lt;span&gt;$posKey&lt;/span&gt;-1&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$posKey&lt;/span&gt;&amp;lt;&lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;){
        quickSort(&lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt;,&lt;span&gt;$posKey&lt;/span&gt;+1,&lt;span&gt;$hight&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt; = [12, 56, 98, 32, 16, 34, 2, 9, 1&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;$len&lt;/span&gt; = &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;&lt;span&gt;);
quickSort(&lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt;, 0, &lt;span&gt;$len&lt;/span&gt; - 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;);&lt;span&gt;die&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 17 Feb 2019 15:20:00 +0000</pubDate>
<dc:creator>friendwrite</dc:creator>
<og:description>快速排序算法的时间复杂度和各次标准数据元素的值关系很大。如果每次选取的标准元素都能均分两个子数组的长度,这样的快速排序过程是一个完全二叉树结构。(即每个结点都把当前数组分成两个大小相等的数组结点,n个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/friendwrite/p/10393255.html</dc:identifier>
</item>
<item>
<title>我们为什么要搞长沙.NET技术社区？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10393240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10393240.html</guid>
<description>&lt;p&gt;　　感谢大家的关注，请允许我冒昧的向大家汇报长沙.NET技术社区第一次交流会的会议进展情况。&lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;活动过程汇报&lt;/h2&gt;
&lt;p&gt;　　2019年2月17日，继深圳，广州，西安，成都，苏州相继成立了.net社区之后，酝酿已久的长沙.net社区也终于组织了第一次线下交流会。&lt;/p&gt;
&lt;p&gt;　　作为第一次交流活动，之前只在小范围进行了宣传，但依然有幸邀请到.net社区爱好者十余位，大家一起分享自己过去的工作经历，以及对于社区的美好愿景，思想的火花在此碰撞，取得了非常不错的效应。&lt;/p&gt;
&lt;p&gt;　　活动分成了三个环节，一个是自我介绍环节，其次是成立社区的目标和实现形式，一个是社区成立所面临的问题。大家针对相关内容进行了讨论，氛围热烈，效果显著，为后期社区的进一步发展种下了一颗扎实的种子。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201902/191302-20190217231608956-1037718960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 align=&quot;center&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;　　长沙，固然是一座优秀的历史文化名城，但IT产业的发展水平，相对于北上广深来说，则远远不如。在近日发布的中国互联网产业排行榜100强中，没有一家长沙本土的IT企业，而在湖南规模产业一百强中，上榜的IT企业也只有不过两家。&lt;/p&gt;
&lt;p&gt;　　虽然必须承认，是经济基础决定的上层建筑，资本市场对于一线城市的热捧才造就了今日北京，上海，广州，深圳，杭州地区IT产业的辉煌。一家又一家优秀的IT企业的诞生，为地方带来了巨大的经济效应，同时也促进了IT技术社群的繁荣。而反过来，极其繁荣的IT产业背后，紧随企业发展步伐的IT技术社区也同样是一个充满黄金的宝库。IT企业和IT社区，就像是水乳交融的关系，互相紧密衔接，密不可分。 &lt;/p&gt;
&lt;p&gt;　　每一个回到长沙的优秀开发者们都会说的一句话是：长沙IT社区非常的闭塞。确实如此，长沙技术社区之闭塞，是中国内地城市的缩影。当你回到长沙时，也许也曾想知道哪家企业拥有非常不错的技术讨论氛围，或者在哪里可以找到为你提供技术思路的组织，这一点之前大概无法实现。虽然说，互联网的发达，可以让你通过网络找到任何你想要的，但是，或许有那么一段时间，你也会渴望通过线下的交流，获得更多的交流机会。&lt;/p&gt;
&lt;p&gt;　　当然，曾经一度，长沙的IT社区更加闭塞，后来有了致力于互联网社区环境的长沙互联网活动基地（其前身是唐胡子俱乐部），唐胡子俱乐部此前在长沙每年举办了数十次大大小小的技术活动，为不少开发者提供了一些开天窗看世界的机会。&lt;/p&gt;
&lt;p&gt;　　不过这些活动更多的是更高格局的技术交流、或职业规划、企业发展规划等，其层次太高无法为不同层次的开发者带来便利。尤其是.NET开发者社区，或者整个后端开发、容器、大数据等开发者社区，也更是如此，技术活动或少之又少，没办法为更多在工作过程中、感觉到一脸懵逼的新手们或者技术吃不饱的高手们提供太多帮助。 &lt;/p&gt;
&lt;p&gt;　　今天的第一次技术交流活动，汇集的代表有的从北上广深杭回来，有的则是在本土土生土长。大家都来自不同的行业，但都有一致的标签，那就是技术出生的资深开发者，对于技术社区充满了期待，而其他城市.NET社区的成立，更是为长沙社区的成立树立了榜样。&lt;/p&gt;
&lt;p&gt;　　我们也期待，通过建立社区、通过大家的努力，能在长沙开发者技术圈形成破冰效应，让我们的开发者闭塞的技术氛围有所改观。 &lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;目的&lt;/h2&gt;
&lt;p&gt;　　我们为什么一定要搞社区呢？&lt;/p&gt;
&lt;p&gt;　　我们认为在每个人的职场过程中，或许我们曾经做过不同的项目或者产品，也接触过不同的人，但脱掉业务的标签，其实大家都是一类人，都是为了实现自己梦想的奋斗者，代码是我们改变世界的方式和手段。而IT行业与其他行业的显著特点，正是在于他的飞速发展特性。尤其是市场的飞速变化，更是带来了技术的飞速变化。而开发语言尤其如此，每一门优秀的开发语言，如果不适应市场的变化，就容易被淘汰。&lt;/p&gt;
&lt;p&gt;　　而开发者同样如此，从来没有一成不变的稳定，只有一如既往的持续学习。在学习过程中，有许多方式，例如看书、看论坛灌水、培训听讲座等形式，究竟哪种形式更好，每个人有自己不同的观点。但是，无论哪种方式，我们都会面临一个类似的需求，那就是要跟人交流。定期的总结自己的学习到的知识，定期的分享知识。&lt;/p&gt;
&lt;p&gt;　　而我们成立社区，就是为了知识的分享。每一位优秀的开发者共同参与其中，交流学习心得，将优秀的技术、理念、思想、优秀的管理方法播撒给更多人，让大家感受到知识的价值。&lt;/p&gt;
&lt;p&gt;　　总体上，组建社区的目的大概可以分成以下三个方面。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1、      组建社区，是为了栽树，着眼于未来，从今天开始做。还是那句话，尽绵薄之力改变社区环境。毕竟长沙这么大，没有人能妄图改变所有开发者，总有叫不醒的人，先从改变周边开始。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2、      沉淀互联网技术氛围，形成互联网社区文化。让北上广深回来的优秀开发者们将成熟的社区模式带回来，再与长沙本土的互联网社区融合，逐渐形成长沙本土氛围的互联网文化。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3、      抱团学习，互相赋能。有了优秀的领头羊，才能知道学习的方向，而大家共同努力，可以形成协同效应，实现学习效果的倍增。 &lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;我们打算怎么搞？ &lt;/h2&gt;
&lt;p&gt;总结了以下几点： &lt;/p&gt;
&lt;p&gt;1、    打造属于开发者自己的技术社区。其核心思想依然是，开放、分享、合作，互利、共赢的互联网精神。 &lt;/p&gt;
&lt;p&gt;2、    不是为了成立吹水群线下交流组织，而是通过优秀开发者的榜样力量、和热心社区事业的开发者共同努力，尽绵薄之力改善长沙互联网环境。&lt;/p&gt;
&lt;p&gt;3、    社区活动。通过社区活动的形式，带来技能的分享。带动长沙本土开发者的互联网意识，让大家明确学习的目标，形成积极乐观的学习态度，为社群的进一步完善提供助力。 &lt;/p&gt;
&lt;p&gt;4、    博客矩阵，鼓励社区参与者分享笔记和博客，实现自己技能的沉淀。&lt;/p&gt;
&lt;p&gt;5、    文档编译。通过带领开发者参与翻译文档、编纂技术资料的形式，为技术圈技能的沉淀提供助力。&lt;/p&gt;
&lt;p&gt;6、    开源贡献。通过带领开发者参与一些开源项目，为开源技术社区提供贡献。 &lt;/p&gt;
&lt;p&gt;7、    不限语言。.NET开发或互联网开发只是一个开头，但是语言并非仅仅局限于.NET本身。 &lt;/p&gt;
&lt;p&gt;8、    小目标：2019年4月底，5月初组织第一次线下技术分享，争取年内组织较大规模的活动3-4次。&lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;组织形式 &lt;/h2&gt;
&lt;p&gt;1、    参考其他城市的先进典型，成立长沙.NET技术社区。&lt;/p&gt;
&lt;p&gt;2、    总体上分为两个部分，一部分主要负责开源项目和各类基础文档的编纂和翻译工作；一部分则负责组织活动和宣传工作。   &lt;/p&gt;
&lt;p&gt;3、    推选李文强担任社区会长（执行主席），推选长沙地区互联网活动发起人唐胡子担任名誉主席，长沙社区发起人邹溪源担任秘书长。 &lt;/p&gt;
&lt;p&gt;4、    以上领导干部同志都是无偿劳动、带头贡献，社区拳头最大的依然是开发者，随时可以罢免领导干部。 &lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;谁能参与？ &lt;/h2&gt;
&lt;p&gt;　　人人皆可参与其中，开放是我们的基本原则，不管你是不是长沙IT社区的开发者、不管你什么语言、什么工作岗位，不管你想参与其中、或者你只是想看看热闹，你都可以参与其中。&lt;/p&gt;
&lt;h2 align=&quot;center&quot;&gt;如何参与？&lt;/h2&gt;
&lt;p&gt;　　您可以随时加入以下微信群，跟大家一起愉快的交流。我们非常诚挚的欢迎大家过来提意见，不管是正面的，还是反对的。都是我们进步的阶梯。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201902/191302-20190217231626316-958363366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 17 Feb 2019 15:18:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>我们为什么要搞长沙.NET技术社区？ 感谢大家的关注，请允许我冒昧的向大家汇报长沙.NET技术社区第一次交流会的会议进展情况。 活动过程汇报 2019年2月17日，继深圳，广州，西安，成都，苏州相继成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10393240.html</dc:identifier>
</item>
<item>
<title>搭建一个具有缓存功能的反向代理服务 - guoew</title>
<link>http://www.cnblogs.com/guoew/p/10393231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoew/p/10393231.html</guid>
<description>&lt;p&gt;前提：需要搭建和部署nginx服务以及后端服务，以便测试反向代理使用，这部分工作省略。&lt;/p&gt;
&lt;h3 id=&quot;一.-设置缓存空间&quot;&gt;一. 设置缓存空间&lt;/h3&gt;
&lt;p&gt;在nginx的http模块中开辟一块名为my_cache的缓存空间，缓存路径为/tmp/nginxcache,大小为10m。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 设置缓存路径及其他缓存参数。
# levels定义高速缓存的级别，每个级别接收值1或2，
# keys_zone设置共享缓存名称和大小，所有活动的key和信息被存储再缓存中。
# max_size设置最大缓存大小
proxy_cache_path  /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=1g;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二.-设置缓存&quot;&gt;二. 设置缓存&lt;/h3&gt;
&lt;p&gt;在nginx server模块设置反向代理缓存&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;    proxy_pass  http://127.0.0.1:3000;   #代理的后端服务
    proxy_cache my_cache ;    #定义用于缓存的共享缓存区域，默认为proxy_cache off
    proxy_cache_key $host$uri$is_args$args;    #设置缓存key
    proxy_cache_valid 200 304 302 5m;    #设置不同响应码的缓存时间
    proxy_cache_valid 404 10s;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三.-重启nginx测试&quot;&gt;三. 重启nginx，测试&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;nginx -s reload
siege http://onlinetest.guoew.cc/ -c 500 -t 5

Lifting the server siege...      done.                                                                                      Transactions:              129470 hits
Availability:              100.00 %            #成功率
Elapsed time:              299.03 secs        #执行时间
Data transferred:         6918.02 MB        #数据传输大小
Response time:                0.65 secs        #平均响应时间
Transaction rate:          432.97 trans/sec    #每秒处理请求数
Throughput:               23.13 MB/sec        #平均每秒传输数据量
Concurrency:              282.00            #实际最高并发
Successful transactions:      129470    #成功处理次数
Failed transactions:               0        #失败处理次数
Longest transaction:           17.72    #传输所花最长时间
Shortest transaction:            0.00    #传输所花最短时间&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四.-不使用缓存再进行测试&quot;&gt;四. 不使用缓存，再进行测试&lt;/h3&gt;
&lt;p&gt;不敢直视，siege 500并发几乎全部报错，降低到并发100才能勉强进行测试。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ransactions:                8389 hits
Availability:              100.00 %
Elapsed time:              299.32 secs
Data transferred:          356.36 MB
Response time:                3.05 secs
Transaction rate:           28.03 trans/sec
Throughput:                1.19 MB/sec
Concurrency:               85.60
Successful transactions:        6721
Failed transactions:               0
Longest transaction:           18.60
Shortest transaction:            0.00&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五.-总结&quot;&gt;五. 总结&lt;/h3&gt;
</description>
<pubDate>Sun, 17 Feb 2019 15:15:00 +0000</pubDate>
<dc:creator>guoew</dc:creator>
<og:description>前提：需要搭建和部署nginx服务以及后端服务，以便测试反向代理使用，这部分工作省略。 一. 设置缓存空间 在nginx的http模块中开辟一块名为my_cache的缓存空间，缓存路径为/tmp/ng</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoew/p/10393231.html</dc:identifier>
</item>
<item>
<title>WebGL或OpenGL关于模型视图投影变换的设置技巧 - charlee44</title>
<link>http://www.cnblogs.com/charlee44/p/10393227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlee44/p/10393227.html</guid>
<description>&lt;p&gt;看了不少的关于WebGL/OpenGL的资料，笔者发现这些资料在讲解图形变换的时候都讲了很多的原理，然后举出一个特别简单的实例(坐标是1.0，0.5的那种)来讲解。确实一看就懂，但用到实际的场景之中就一脸懵逼了（比如地形的三维坐标都是很大的数字）。所以笔者这里结合一个具体的实例，总结下WebGL/OpenGL中，关于模型变换、视图变换、投影变换的设置技巧。&lt;/p&gt;
&lt;p&gt;绘制任何复杂的场景之前，都可以先绘制出其包围盒，能应用于包围盒的图形变换，基本上就能用于该场景了，因此，笔者这里绘制一幅地形的包围盒。它的最大最小范围为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//包围盒范围
var minX = 399589.072;
var maxX = 400469.072;
var minY = 3995118.062;
var maxY = 3997558.062;
var minZ = 732;
var maxZ = 1268;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;WebGL是OpenGL的子集，因此我这里直接用WebGL的例子，但是各种接口函数跟OpenGL是非常类似的，尤其是图形变换的函数。&lt;/p&gt;
&lt;h2 id=&quot;cube.html&quot;&gt;1) Cube.html&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;Hello cube&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body onload=&quot;main()&quot;&amp;gt;
    &amp;lt;canvas id=&quot;webgl&quot; width=&quot;600&quot; height=&quot;600&quot;&amp;gt;
    Please use a browser that supports &quot;canvas&quot;
    &amp;lt;/canvas&amp;gt;

    &amp;lt;script src=&quot;lib/webgl-utils.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;lib/webgl-debug.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;lib/cuon-utils.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;lib/cuon-matrix.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;Cube.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cube.js&quot;&gt;2) Cube.js&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;// Vertex shader program
var VSHADER_SOURCE =
    'attribute vec4 a_Position;\n' +
    'attribute vec4 a_Color;\n' +
    'uniform mat4 u_MvpMatrix;\n' +
    'varying vec4 v_Color;\n' +
    'void main() {\n' +
    '  gl_Position = u_MvpMatrix * a_Position;\n' +
    '  v_Color = a_Color;\n' +
    '}\n';

// Fragment shader program
var FSHADER_SOURCE =
    '#ifdef GL_ES\n' +
    'precision mediump float;\n' +
    '#endif\n' +
    'varying vec4 v_Color;\n' +
    'void main() {\n' +
    '  gl_FragColor = v_Color;\n' +
    '}\n';

//包围盒范围
var minX = 399589.072;
var maxX = 400469.072;
var minY = 3995118.062;
var maxY = 3997558.062;
var minZ = 732;
var maxZ = 1268;

//包围盒中心
var cx = (minX + maxX) / 2.0;
var cy = (minY + maxY) / 2.0;
var cz = (minZ + maxZ) / 2.0;

//当前lookAt()函数初始视点的高度
var eyeHight = 2000.0;

//根据视点高度算出setPerspective()函数的合理角度
var fovy = (maxY - minY) / 2.0 / eyeHight;
fovy = 180.0 / Math.PI * Math.atan(fovy) * 2;

//setPerspective()远截面
var far = 3000;

//
function main() {
    // Retrieve &amp;lt;canvas&amp;gt; element
    var canvas = document.getElementById('webgl');

    // Get the rendering context for WebGL
    var gl = getWebGLContext(canvas);
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    // Initialize shaders
    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
        console.log('Failed to intialize shaders.');
        return;
    }

    // Set the vertex coordinates and color
    var n = initVertexBuffers(gl);
    if (n &amp;lt; 0) {
        console.log('Failed to set the vertex information');
        return;
    }

    // Get the storage location of u_MvpMatrix
    var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');
    if (!u_MvpMatrix) {
        console.log('Failed to get the storage location of u_MvpMatrix');
        return;
    }

    // Register the event handler
    var currentAngle = [0.0, 0.0]; // Current rotation angle ([x-axis, y-axis] degrees)
    initEventHandlers(canvas, currentAngle);

    // Set clear color and enable hidden surface removal
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);

    // Start drawing
    var tick = function () {

        //setPerspective()宽高比
        var aspect = canvas.width / canvas.height;

        //
        draw(gl, n, aspect, u_MvpMatrix, currentAngle);
        requestAnimationFrame(tick, canvas);
    };
    tick();
}

function initEventHandlers(canvas, currentAngle) {
    var dragging = false;         // Dragging or not
    var lastX = -1, lastY = -1;   // Last position of the mouse

    // Mouse is pressed
    canvas.onmousedown = function (ev) {
        var x = ev.clientX;
        var y = ev.clientY;
        // Start dragging if a moue is in &amp;lt;canvas&amp;gt;
        var rect = ev.target.getBoundingClientRect();
        if (rect.left &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; rect.right &amp;amp;&amp;amp; rect.top &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; rect.bottom) {
            lastX = x;
            lastY = y;
            dragging = true;
        }
    };

    //鼠标离开时
    canvas.onmouseleave = function (ev) {
        dragging = false;
    };

    // Mouse is released
    canvas.onmouseup = function (ev) {
        dragging = false;
    };

    // Mouse is moved
    canvas.onmousemove = function (ev) {
        var x = ev.clientX;
        var y = ev.clientY;
        if (dragging) {
            var factor = 100 / canvas.height; // The rotation ratio
            var dx = factor * (x - lastX);
            var dy = factor * (y - lastY);
            // Limit x-axis rotation angle to -90 to 90 degrees
            //currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 90.0), -90.0);
            currentAngle[0] = currentAngle[0] + dy;
            currentAngle[1] = currentAngle[1] + dx;
        }
        lastX = x, lastY = y;
    };

    //鼠标缩放
    canvas.onmousewheel = function (event) {
        var lastHeight = eyeHight;
        if (event.wheelDelta &amp;gt; 0) {
            eyeHight = Math.max(1, eyeHight - 80);
        } else {
            eyeHight = eyeHight + 80;
        }

        far = far + eyeHight - lastHeight;
    };
}

function draw(gl, n, aspect, u_MvpMatrix, currentAngle) {
    //模型矩阵
    var modelMatrix = new Matrix4();
    modelMatrix.rotate(currentAngle[0], 1.0, 0.0, 0.0); // Rotation around x-axis 
    modelMatrix.rotate(currentAngle[1], 0.0, 1.0, 0.0); // Rotation around y-axis    
    modelMatrix.translate(-cx, -cy, -cz);

    //视图矩阵
    var viewMatrix = new Matrix4();
    viewMatrix.lookAt(0, 0, eyeHight, 0, 0, 0, 0, 1, 0);

    //投影矩阵
    var projMatrix = new Matrix4();
    projMatrix.setPerspective(fovy, aspect, 10, far);

    //模型视图投影矩阵
    var mvpMatrix = new Matrix4();
    mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);

    // Pass the model view projection matrix to u_MvpMatrix
    gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);

    // Clear color and depth buffer
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Draw the cube
    gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
}

function initVertexBuffers(gl) {
    // Create a cube
    //    v6----- v5
    //   /|      /|
    //  v1------v0|
    //  | |     | |
    //  | |v7---|-|v4
    //  |/      |/
    //  v2------v3

    var verticesColors = new Float32Array([
        // Vertex coordinates and color
        maxX, maxY, maxZ, 1.0, 1.0, 1.0,  // v0 White
        minX, maxY, maxZ, 1.0, 0.0, 1.0,  // v1 Magenta
        minX, minY, maxZ, 1.0, 0.0, 0.0,  // v2 Red
        maxX, minY, maxZ, 1.0, 1.0, 0.0,  // v3 Yellow
        maxX, minY, minZ, 0.0, 1.0, 0.0,  // v4 Green
        maxX, maxY, minZ, 0.0, 1.0, 1.0,  // v5 Cyan
        minX, maxY, minZ, 0.0, 0.0, 1.0,  // v6 Blue
        minX, minY, minZ, 1.0, 0.0, 1.0   // v7 Black
    ]);

    // Indices of the vertices
    var indices = new Uint8Array([
        0, 1, 2, 0, 2, 3,    // front
        0, 3, 4, 0, 4, 5,    // right
        0, 5, 6, 0, 6, 1,    // up
        1, 6, 7, 1, 7, 2,    // left
        7, 4, 3, 7, 3, 2,    // down
        4, 7, 6, 4, 6, 5     // back
    ]);

    // Create a buffer object
    var vertexColorBuffer = gl.createBuffer();
    var indexBuffer = gl.createBuffer();
    if (!vertexColorBuffer || !indexBuffer) {
        return -1;
    }

    // Write the vertex coordinates and color to the buffer object
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);

    var FSIZE = verticesColors.BYTES_PER_ELEMENT;
    // Assign the buffer object to a_Position and enable the assignment
    var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
    if (a_Position &amp;lt; 0) {
        console.log('Failed to get the storage location of a_Position');
        return -1;
    }
    gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0);
    gl.enableVertexAttribArray(a_Position);
    // Assign the buffer object to a_Color and enable the assignment
    var a_Color = gl.getAttribLocation(gl.program, 'a_Color');
    if (a_Color &amp;lt; 0) {
        console.log('Failed to get the storage location of a_Color');
        return -1;
    }
    gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 6, FSIZE * 3);
    gl.enableVertexAttribArray(a_Color);

    // Write the indices to the buffer object
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    return indices.length;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行结果&quot;&gt;3) 运行结果&lt;/h2&gt;
&lt;p&gt;这份代码改进《WebGL编程指南》一书里面绘制一个简单立方体的例子，引用的几个JS-lib也是该书提供。本例全部源代码地址链接为：&lt;a href=&quot;https://share.weiyun.com/52XmsFv&quot; class=&quot;uri&quot;&gt;https://share.weiyun.com/52XmsFv&lt;/a&gt; ，密码：h1lbay。&lt;br/&gt;用chrome打开Cube.html，会出现一个长方体的包围盒，还可以用鼠标左键旋转，鼠标滚轮缩放：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190217231046380-1339025221.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本例的思路是通过JS的requestAnimationFrame()函数不停的调用绘制函数draw(),同时将一些变量关联到鼠标操作事件和draw()，达到页面图形变换的效果。这里笔者就不讲原理，重点讲一讲设置三个图形变换的具体过程，网上已经有非常多的原理介绍了。&lt;/p&gt;
&lt;h2 id=&quot;模型变换&quot;&gt;1) 模型变换&lt;/h2&gt;
&lt;p&gt;在draw()函数中设置模型矩阵：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//模型矩阵
var modelMatrix = new Matrix4();
modelMatrix.rotate(currentAngle[0], 1.0, 0.0, 0.0); // Rotation around x-axis 
modelMatrix.rotate(currentAngle[1], 0.0, 1.0, 0.0); // Rotation around y-axis    
modelMatrix.translate(-cx, -cy, -cz);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于这个包围盒（长方体）的坐标值都非常大，所以第一步需要对其做平移变换translate(-cx, -cy, -cz)，cx，cy，cz就是包围盒的中心：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//包围盒中心
var cx = (minX + maxX) / 2.0;
var cy = (minY + maxY) / 2.0;
var cz = (minZ + maxZ) / 2.0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是旋转变换，数组currentAngle记录了绕X轴和Y轴旋转的角度，初始值为0。配合onmousedown，onmouseup，onmousemove三个鼠标事件，将页面鼠标X、Y方向的移动，转换成绕X轴，Y轴的角度值，累计到currentAngle中，从而实现了三维模型随鼠标旋转。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Mouse is moved
canvas.onmousemove = function (ev) {
    var x = ev.clientX;
    var y = ev.clientY;
    if (dragging) {
        var factor = 100 / canvas.height; // The rotation ratio
        var dx = factor * (x - lastX);
        var dy = factor * (y - lastY);
        // Limit x-axis rotation angle to -90 to 90 degrees
        //currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 90.0), -90.0);
        currentAngle[0] = currentAngle[0] + dy;
        currentAngle[1] = currentAngle[1] + dx;
    }
    lastX = x, lastY = y;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意模型矩阵的平移变换要放后面，需要把坐标轴换到包围盒中心，才能绕三维模型自转。&lt;/p&gt;
&lt;h2 id=&quot;视图变换&quot;&gt;2) 视图变换&lt;/h2&gt;
&lt;p&gt;通过lookAt()函数设置视图矩阵：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//当前lookAt()函数初始视点的高度
var eyeHight = 2000.0;

// …

//视图矩阵
var viewMatrix = new Matrix4();
viewMatrix.lookAt(0, 0, eyeHight, 0, 0, 0, 0, 1, 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;视图变换调整的是观察者的状态，lookAt()函数分别设置了视点、目标观察点以及上方向。虽然可以在任何位置去观察三维场景的点，从而得到渲染结果。但在实际的应用当中，这个函数设置的结果很难以想象，所以笔者设置成，观察者站在包围盒中心上方的位置，对准坐标系原点（注意这个时候经过模型变换，包围盒的中心点已经是坐标系原点了），常见的Y轴作为上方向。这样，视图内无论如何都是可见的。&lt;br/&gt;这里将视点的高度设置成变量eyeHight，初始值为2000，是一个大于0的经验值。同时通过鼠标的滚轮事件onmousewheel()调整该值，从而实现三维模型的缩放的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //鼠标缩放
 canvas.onmousewheel = function (event) {
     var lastHeight = eyeHight;
     if (event.wheelDelta &amp;gt; 0) {
         eyeHight = Math.max(1, eyeHight - 80);
     } else {
         eyeHight = eyeHight + 80;
     } 
 };&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;投影变换&quot;&gt;3) 投影变换&lt;/h2&gt;
&lt;p&gt;通过setPerspective()来设置投影变换：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//根据视点高度算出setPerspective()函数的合理角度
var fovy = (maxY - minY) / 2.0 / eyeHight;
fovy = 180.0 / Math.PI * Math.atan(fovy) * 2;

//setPerspective()远截面
var far = 3000;

//setPerspective()宽高比
var aspect = canvas.width / canvas.height;

//...

//投影矩阵
var projMatrix = new Matrix4();
projMatrix.setPerspective(fovy, aspect, 10, far);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面的视图变换已经论述了，这个模型是在中心点上方去观察中心点，相当于视线垂直到前界面near的表面，那么setPerspective()就可以确定其角度fovy了，示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190217231117876-1480964252.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显的看出，当光线射到包围盒的中心，包围盒Y方向长度的一半，除以视点高，就是fovy一般的正切值。&lt;/p&gt;
&lt;p&gt;宽高比aspect即是页面canvas元素的宽高比。&lt;/p&gt;
&lt;p&gt;近界面near一般设置成较近的值，但是不能太近（比如小于1），否则会影响深度判断的精度造成页面闪烁。&lt;a href=&quot;https://blog.csdn.net/u011450490/article/details/50601458&quot;&gt;《OpenGL绘制纹理，缩放相机导致纹理闪烁的解决方法gluPerspective ()》&lt;/a&gt;论述了这个问题。&lt;/p&gt;
&lt;p&gt;而远界面far也是需要跟着鼠标滚轮一起变换的，否则当eyeHight变大，三维物体会逐渐离开透视变换的视锥体：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//鼠标缩放
canvas.onmousewheel = function (event) {
    var lastHeight = eyeHight;
    if (event.wheelDelta &amp;gt; 0) {
        eyeHight = Math.max(1, eyeHight - 80);
    } else {
        eyeHight = eyeHight + 80;
    }

    far = far + eyeHight - lastHeight;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模型视图投影矩阵&quot;&gt;4) 模型视图投影矩阵&lt;/h2&gt;
&lt;p&gt;将三个矩阵都应用起来，就得到最终的模型视图投影矩阵。注意计算式是：投影矩阵 * 视图矩阵 * 模型矩阵：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//模型视图投影矩阵
var mvpMatrix = new Matrix4();
mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本例中的三维物体随着鼠标旋转，是把鼠标X、Y方向的移动距离转换成绕X轴，Y轴方向的角度来实现的。但是如何用鼠标实现绕Z轴（第三轴）旋转呢？例如像OSG这样的渲染引擎，是可以用鼠标绕第三个轴旋转的(当然操作有点费力)。这里希望大家能批评指正下。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Feb 2019 15:14:00 +0000</pubDate>
<dc:creator>charlee44</dc:creator>
<og:description>通过一个地形包围盒的具体实例，讲解了WebGL/OpenGL中设置模型变换、视图变换、投影变换的技巧。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlee44/p/10393227.html</dc:identifier>
</item>
<item>
<title>[Flutter] 写第一个 Flutter app，part1 要点 - 黑眼诗人</title>
<link>http://www.cnblogs.com/farwish/p/10393029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/farwish/p/10393029.html</guid>
<description>&lt;p&gt;模拟器中调试元素的布局：&lt;/p&gt;
&lt;p&gt;　　Android Studio 右侧边栏 Flutter Inspector，选择 Toggle Debug Paint 打开。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;格式化代码：&lt;/p&gt;
&lt;p&gt;　　编辑器中右键 Reformat Code with dartfmt。&lt;/p&gt;

&lt;p&gt;使用外部功能包（https://pub.dartlang.org/flutter）：&lt;/p&gt;
&lt;p&gt;　　把外部包名加到 pubspec.yaml 的 dependencies 依赖中，运行 flutter packages get 安装，代码中 import 进来使用。&lt;/p&gt;

&lt;p&gt;例子内容解读（https://flutter.io/docs/get-started/codelab）：&lt;/p&gt;
&lt;p&gt;　　StatelessWidget 子 Widget 实现 build 方法，Stateless widget 是不变的，意思是它们的属性不能变 - 所有的值都是 final。&lt;/p&gt;
&lt;p&gt;　　StatefulWidget   子 Widget 实现 createState 方法；Stateful widget 维护着 widget 生命周期内可能改变的状态。&lt;/p&gt;
&lt;p&gt;　　　　实现一个 stateful widget 需要至少两个 class：&lt;/p&gt;
&lt;p&gt;　　　　1）一个创建了 State 类实例的 StatefulWidget 类。&lt;/p&gt;
&lt;p&gt;　　　　2）一个 State 类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们使用了一个 RandomWords 的 State 类，RandomWordsState 依赖 RandomWords 类。&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; RandomWordsState &lt;span&gt;extends&lt;/span&gt; State&amp;lt;RandomWords&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 实现 build() 方法，返回 Scaffold&lt;/span&gt;
&lt;span&gt;    @override
    Widget build(BuildContext context) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Scaffold(
            appBar: AppBar(
                title: Text(&lt;/span&gt;'Startup Name Generator'&lt;span&gt;),
            ),
            body: _buildSuggestions(),
        );
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现 Scaffold 里使用的私有 widget 功能，比如构建 ListView，ListView 构造方法允许我们构建一个按需加载的 list
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ListView 提供一个 builder 属性和 itemBuilder 方法，itemBuilder 是一个匿名函数形式的回调方法，传入 BuildContext 和 行索引号。&lt;/span&gt;&lt;span&gt;
    Widget _buildSuggestions() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ListView.builder(
         padding: &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; EdgeInsets.all(16.0&lt;span&gt;),
         itemBuilder: &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; (context, i) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i.isOdd) &lt;span&gt;return&lt;/span&gt; Divider(); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

            &lt;span&gt;final&lt;/span&gt; index = i ~/ 2; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (index &amp;gt;=&lt;span&gt; _suggestions.length) {
                _suggestions.addAll(generateWordPairs().take(&lt;/span&gt;10)); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _buildRow(_suggestions[index]);
         });
      }&lt;br/&gt;　　　/*1*/ itemBuilder回调在生成每个单词时调用一次，并替换 ListTile 行。偶数行为单词添加 ListTile，奇数行添加 Divider widget 垂直分隔实体。&lt;br/&gt;　　　/*2*/ 在 ListView 每行之前添加一个一像素高的 divider&lt;br/&gt;　　　/*3*/ 表达式 i ~/ 2，i 整除 2，返回整数的结果。如 1,2,3,4,5 变成 0,1,1,2,2。这计算 ListView 中真实的单词数，减去 divider widget 数。&lt;br/&gt;　　　/*4*/ 如果到达了可用单词的结尾，接着生成 10个到建议列表中。调用 _buildRow 展示每行的 title。&lt;br/&gt;Widget _buildRow(WordPair pair) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ListTile(
            title: Text(
                pair.asPascalCase,
                style: _biggerFont,
             ),
        );
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有状态的类除了创建 State 类的实例，什么都不做。&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; RandomWords &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; StatefulWidget {
    @override
    RandomWordsState createState() &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RandomWordsState();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Flutter Api Doc（https://docs.flutter.io/flutter/index.html）：&lt;/p&gt;
&lt;p&gt;　　ListTile 一个单独的固定高度的行，一般包含有文本和前后图标（https://docs.flutter.io/flutter/material/ListTile-class.html）。&lt;/p&gt;
&lt;p&gt;　　　　第一行的 text 不是可选的，由 title 指定。&lt;/p&gt;
&lt;p&gt;　　　　subtitle 是可选的，会分配附加一行文本的空间，或者当 isThreeLine 为 true 是两行。&lt;/p&gt;
&lt;p&gt;　　　　dense 为 true 时，title 总高 和 DefaultTextStyles 包裹的 title、subtitle 尺寸会缩小。&lt;/p&gt;
&lt;p&gt;　　　　ListTile 总是固定的高度（取决于 isThreeLine、dense、subtitle 是如何配置的）；根据它们的内容无法增加高度。&lt;/p&gt;
&lt;p&gt;　　　　如果你在寻找可以在一行内任意布局的 widget，考虑使用 Row.&lt;/p&gt;
&lt;p&gt;　　　　ListTile 一般在 ListViews 中使用，或者 Drawer 和 Card 的 Column 中。&lt;/p&gt;
&lt;p&gt;　　　　需要它的一个祖先是 Material widget。&lt;/p&gt;
&lt;p&gt;　　　　ListTileTheme，给 ListTiles 定义了视觉属性。&lt;/p&gt;
&lt;p&gt;　　　　ListView，可以在一个滚动列表中展示任意数量的 ListTile。&lt;/p&gt;
&lt;p&gt;　　　　CircleAvatar，代表一个人的 icon，通常作为 ListTile 的 leading 元素来使用。&lt;/p&gt;
&lt;p&gt;　　　　Card，展示少量的带有 Column 的 ListTiles。&lt;/p&gt;
&lt;p&gt;　　　　Divider，&lt;/p&gt;
&lt;p&gt;　　　　ListTile.divideTitles，&lt;/p&gt;
&lt;p&gt;　　　　CheckboxListTile，RadioListTile，SwitchListTile&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　Divider 两边带有 padding的一个设备像素厚水平线（https://docs.flutter.io/flutter/material/Divider-class.html）。&lt;/p&gt;
&lt;p&gt;　　　　Divider 可以用在 list、Drawer 和其它需要水平/垂直分隔内容的地方。&lt;/p&gt;
&lt;p&gt;　　　　在一个列表的 item 中使用一像素 divider，考虑使用 ListTile.divideTiles，是针对这种情况优化的例子。&lt;/p&gt;
&lt;p&gt;　　　　盒子高度由 Divider.height 控制，合适的 padding 会在宽高中自动计算。&lt;/p&gt;
&lt;p&gt;　　　　PopupMenuDivider，等同 Divider，但是针对弹出菜单。&lt;/p&gt;
&lt;p&gt;　　　　ListTile.divideTiles，另一种 list 中的 divide widget 的途径。&lt;/p&gt;

&lt;p&gt;part1：&lt;a href=&quot;https://flutter.io/docs/get-started/codelab&quot; target=&quot;_blank&quot;&gt;https://flutter.io/docs/get-started/codelab&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Link：&lt;a href=&quot;https://www.cnblogs.com/farwish/p/10393029.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/farwish/p/10393029.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Feb 2019 15:12:00 +0000</pubDate>
<dc:creator>黑眼诗人</dc:creator>
<og:description>模拟器中调试元素的布局： Android Studio 右侧边栏 Flutter Inspector，选择 Toggle Debug Paint 打开。 格式化代码： 编辑器中右键 Reformat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/farwish/p/10393029.html</dc:identifier>
</item>
<item>
<title>简单介绍Java的静态分派和动态分派 - kingsleylam</title>
<link>http://www.cnblogs.com/kingsleylam/p/10390323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingsleylam/p/10390323.html</guid>
<description>&lt;p&gt;最近复习JVM的知识，对于静态分派和动态分派的理解有点混乱，于是自己尝试写写代码，在分析中巩固知识。&lt;/p&gt;
&lt;p&gt;有如下一段代码，请问每一段分别输出什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.khlin.my.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.println(&quot;Base.foo() invoked&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bar(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;Base.bar(int) invoked&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bar(Character c) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;Base.bar(Character) invoked&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; baz(Object o) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;Base.baz(Object) invoked&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; baz(Integer i) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot;Base.baz(Integer) invoked&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Child &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Base {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         System.out.println(&quot;Child.foo() invoked&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bar(Character c) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         System.out.println(&quot;Child.bar(Character) invoked&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bar(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         System.out.println(&quot;Child.bar(char) invoked&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         Base child = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Child();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         System.out.println(&quot;第1段输出：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        child.foo();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         child.bar(&lt;span&gt;new&lt;/span&gt; Character('C'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         System.out.println(&quot;第2段输出：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         Object integer = &lt;span&gt;new&lt;/span&gt; Integer(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        child.baz(integer);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         System.out.println(&quot;第3段输出：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         child.bar('C'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我简单地介绍一下从代码编译到方法调用的整个过程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;· &lt;strong&gt;编译&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先看看第1段输出，child.foo()是调用父类还是子类的静态方法呢？&lt;/p&gt;
&lt;p&gt;在编译阶段，发生了&lt;span&gt;&lt;strong&gt;静态分派&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Base child = &lt;span&gt;new&lt;/span&gt; Child();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我们创建一个对象时，如上图，Base称为变量的的静态类型(Static Type), 或者叫做外观类型(Apparent Type)，后面的Child则称为变量的实际类型(Actual Type)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所有依赖静态类型来定位方法执行版本的分派动作，称为静态分派。&lt;/strong&gt;&lt;/span&gt;静态分派的典型应用是方法重载，其发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。&lt;/p&gt;
&lt;p&gt;方法的接收者(Reciever) 和方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。&lt;/p&gt;
&lt;p&gt;在静态分派的时候，选择目标方法的依据有两点，&lt;span&gt;&lt;strong&gt;一是静态类型是Base还是Child，二是方法的参数类型。因此，静态分派是多分派。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们来看看“第1段输出”代码生成的指令。通过javap -v App.class指令得出如下结果，可以看到第18和第31行两条指令的符号引用，和上述分析一致：child的静态类型是Base，所以选择Base类的方法；通过无参数和Character类型，分别确定是具体哪个方法版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201902/452847-20190217222001270-620129333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但最终两者的行为不一样，child.foo() 调用的是静态类型Base的foo()，而child.bar(new Character('C')) 则是调用实际类型Child的方法。&lt;/p&gt;
&lt;p&gt;原因就是出在两条指令不一样：invokestatic和invokevirtual&lt;/p&gt;
&lt;p&gt;在Java虚拟机里面提供了5条方法调用字节码指令：&lt;/p&gt;
&lt;p&gt;invokestatic:调用静态方法&lt;/p&gt;
&lt;p&gt;invokespecial:调用实例构造器&amp;lt;init&amp;gt;方法、私有方法和父类方法&lt;/p&gt;
&lt;p&gt;invokevirtual: 调用所有的虚方法&lt;/p&gt;
&lt;p&gt;invokeinterface:调用接口方法，会在运行时再确定 一个实现此接口的对象&lt;/p&gt;
&lt;p&gt;invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic是由用户所设定的引导方法决定的。&lt;/p&gt;
&lt;p&gt;具体原因是不同的指令在下一阶段（类加载的解析）的行为不一样，暂时先放到一边，我们再看看第2段输出的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201902/452847-20190217224514028-1594349870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，&lt;strong&gt;&lt;span&gt;在静态分派时，是根据传入方法的参数的静态类型来决定调用的方法版本，&lt;/span&gt;&lt;/strong&gt;虽然有baz(Integer)的方法，但是传入的参数integer的静态类型是Object，所以调用了baz(Object)。&lt;/p&gt;
&lt;p&gt;再来看看第3段输出的指令，我们知道符号引用肯定还是Base类里的方法(尽管Child类里有参数一样的bar(char c) 方法)，但Base里没有一模一样参数(char类型) 的方法，不会报错吗？会调用哪个方法呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201902/452847-20190217225110057-1718363360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适”的版本。&lt;/p&gt;
&lt;p&gt;具体可参考：&lt;a title=&quot;JVM 方法调用之静态分派&quot; href=&quot;https://www.cnblogs.com/kingsleylam/p/6789119.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/kingsleylam/p/6789119.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;· 类加载之解析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。&lt;/p&gt;
&lt;p&gt;只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法，私有方法，实例构造器，父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，其他方法称为非虚方法（除了final方法）。&lt;/p&gt;
&lt;p&gt;final修饰的方法，虽然是使用invokevirtual指令来调用，但由于它无法被覆盖，没有其他版本，因此也是非虚方法。具体参考：&lt;a title=&quot;JVM 方法调用之解析&quot; href=&quot;https://www.cnblogs.com/kingsleylam/p/6765426.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/kingsleylam/p/6765426.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回到第1段输出，child.foo()是invokestatic指令，那么在解析阶段，就会替换成直接引用，具体的类也就确定下来了，因此调用的是静态类型Base.foo()。&lt;/p&gt;
&lt;p&gt;而child.bar(new Character('C')) 是invokevirtual, 在这个阶段可以确定调用的方法签名，但还不能确定方法的接收者的实际类型。它将由动态分派来完成确定。&lt;span&gt;&lt;strong&gt;&lt;span&gt;由于只有一个宗量影响，因此动态分派是单分派。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法接收者的实际类型在下一阶段确定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· 运行期的方法调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。&lt;/p&gt;
&lt;p&gt;具体可以参考：&lt;a title=&quot;JVM 方法调用之动态分派&quot; href=&quot;https://www.cnblogs.com/kingsleylam/p/6789989.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/kingsleylam/p/6789989.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最终输出结果是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201902/452847-20190217230931661-1725515536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考资料：《深入理解Java虚拟机》第2版 周志明著&lt;/p&gt;
</description>
<pubDate>Sun, 17 Feb 2019 14:53:00 +0000</pubDate>
<dc:creator>kingsleylam</dc:creator>
<og:description>最近复习JVM的知识，对于静态分派和动态分派的理解有点混乱，于是自己尝试写写代码，在分析中巩固知识。 有如下一段代码，请问每一段分别输出什么？ 下面我简单地介绍一下从代码编译到方法调用的整个过程。 &amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingsleylam/p/10390323.html</dc:identifier>
</item>
<item>
<title>how networks work fifth note - lingyefengzi</title>
<link>http://www.cnblogs.com/lingyefengzi/p/10393105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lingyefengzi/p/10393105.html</guid>
<description>&lt;h2 id=&quot;思维导图&quot;&gt;思维导图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557340/201902/1557340-20190217224142920-247067411.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;当使用浏览器访问Web服务器时，浏览器的通信对象不仅限于Web服务器
防火墙并不是必需的，但是没有防火墙会增加风险
也有防火墙无法抵御的攻击(防火墙不会检查通信数据的具体内容，因此无法地狱隐藏在&amp;gt;通信数据内容中的攻击)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;看点&quot;&gt;看点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Web服务器的部署地&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;防火墙的结构原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过将请求平均分配给多台服务器来平衡负载&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用缓存服务器分担负载&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内容分发服务&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;内容分发服务是从缓存服务器发展而来，它在互联网中部署很多缓存服务器，
并将用户的访问引导到最近的缓存服务器上。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;web服务器的部署地点&quot;&gt;Web服务器的部署地点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在公司里部署Web服务器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;1. 服务器直接部署在公司网络上，并且可以从互联网直接访问。
淘汰原因：
(1)IP地址不足。
(2)安全问题。
2.部署防火墙&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;将Web服务部署在数据中心&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;数据中心是与运营商核心部分NOC直接连接的，或者是与运营商之间的枢纽IX直接连接的。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;防火墙的结构和原理&quot;&gt;防火墙的结构和原理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;主流的包过滤方式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何设置包过滤规则&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;通过网络包的头部控制信息来设置过滤规则(IP地址)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通过端口号限定应用程序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过控制位判断连接方向&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;阻止以Web服务器为起点，SYN为1，而ACK为0的包
使用UDP协议无法进行阻止&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;从公司内网访问公开区域的规则&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从外部无法访问公司内网&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;防火墙内置的路由功能可以由用户自行设置，因此可以在路由表中配置私有地址相关的路由，使得公司内网到公开区域的访问可以从私有地址的形式来进行，这意味着公司内网和公开区域之间传输的包不需要地址转化

当使用地址转化时，默认状态下是无法从互联网访问公司内网的，因此我们不需要在设置一条包过滤规则来阻止从互联网访问
公司内网&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通过防火墙&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;防火墙无法抵御的攻击&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Web服务器在收到含有特定数据的包时会引起宕机

解决方式;
one way:修复Web服务器程序中的Bug
another way:在防火墙之外部署用来检查包的内容并阻止有害包的设备或软件&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通过将请求平均分配给多台服务器来平衡负载&quot;&gt;通过将请求平均分配给多台服务器来平衡负载&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;性能不足时需要负载均衡&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;服务器的分布式架构&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用负载均衡器分配访问&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;用负载均衡器的IP地址代替Web服务器的实际地址注册到DNS服务器上
然后由负载均衡器来判断将请求转发给哪台Web服务器上&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用缓存服务器分担负载&quot;&gt;使用缓存服务器分担负载&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;缓存服务器通过更新时间管理内容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;需要代替Web服务器被注册到DNS服务器上。
缓存服务器接受请求消息
检查请求消息的内容，看看请求的数据是否已经保存在缓存中

若不存在，在HTTP头部字段中添加一个Via字段
确定转发到哪台服务器上是根据请求消息的URI中的目录名来判断的
缓存服务器会以客户端的身份向目标Web服务器发送请求消息
缓存服务器会在响应消息中加上Via头部字段
缓存服务器会以Web服务器的身份向客户端发送响应消息，并把缓存服务器响应消息保存到缓存中，并记录保存时间

若存在，缓存服务器会添加一个If-Modified-Since头部字段并将请求转发给Web服务器，询问Web服务器用户请求的数据
是否已经发生变化
若没有变化，则会返回一个没有变化的响应消息

若Web服务器上的数据有变化，后面的过程和没有命中缓存的情况是一样的。Web服务器会返回最新版本的数据&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最原始的代理-正向代理(客户端一侧的缓存服务器)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;目的:缓存  实现防火墙

工作方式：先接收来自客户端的请求消息，然后再转发到互联网中
由于代理在转发过程中可以查看请求的内容，所以可以根据内容判断是否允许访问

一般需要在浏览器中设置窗口中的&quot;代理服务器&quot;一栏中填写正向代理的IP地址&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;透明代理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;透明代理:通过查看请求消息的包头部(IP地址)
在接入网的入口处放置透明代理&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内容分发服务&quot;&gt;内容分发服务&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;利用内容分发服务分担负载&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;缓存服务器放在服务器端时，可以减轻Web服务器的负载，但无法减少互联网中的流量。
客户端缓存服务器服务器运营者无法控制它。
Web缓冲服务器放在客户端的运营商处

内容分发服务，提供这种厂商称为CDSP(Content Delivery Service Provider)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;如何找到最近的缓存服务器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;服务器端的DNS服务器收集缓存服务器部署地点的路由器收集路由信息
查出路由器到客户端DNS服务器的路由距离&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通过重定向服务器分配访问目标&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;将重定向服务器注册到Web服务器端的DNS服务器上
客户端会将HTTP请求消息发送到重定向服务器上
将缓存服务器的地址放到Location字段中返回响应

缺点：增加了HTTP消息的交互次数
优点：重定向的方法是根据客户端发送来的HTTP消息的发送方IP地址来估算距离的，因此精度较高

重定向服务器可以返回一个通过网络包往返时间估算到缓存服务器的距离的脚本，通过在客户端运行脚本
来找到最优的缓存服务器。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;缓存的更新方法会影响性能&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;当Web服务器在原始数据发生更新时，立即通知缓存服务器(内容分发服务)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 17 Feb 2019 14:44:00 +0000</pubDate>
<dc:creator>lingyefengzi</dc:creator>
<og:description>服务器端的局域网中有什么玄机 思维导图 问题 看点 Web服务器的部署地 防火墙的结构原理 通过将请求平均分配给多台服务器来平衡负载 利用缓存服务器分担负载 内容分发服务 Web服务器的部署地点 在公</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lingyefengzi/p/10393105.html</dc:identifier>
</item>
<item>
<title>Java 中的按值传递 - 水目沾</title>
<link>http://www.cnblogs.com/zhuwbox/p/10392970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuwbox/p/10392970.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Java 中只有按值传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &quot;Java 中只有按值传递&quot;，初看到这几个字有点不敢相信，无数次通过函数改变过对象，无数次跟同事说 Java 在传对象的时候是按引用传递。后来细细想想，之所以以为 Java 传对象是按引用传递是因为其中有很多概念都没理清楚，与 C++ 中的搞混了。从 C++ 转 Java 的时候将 C++ 中的知识点映射到 Java 没错，这有利于 C++ 转 Java 的人更快的学习 Java。但一旦映射错误就很容易形成固定思维。&lt;/p&gt;
&lt;p&gt;    在 C++ 和 Java 中都有引用的概念，但他们完全不是同一个东西。Java 中的引用更类似 C++ 的指针，C++ 的引用在 Java 中并无对应概念。在 C++ 中有按值传递、按指针传递和按引用传递三种，而在 Java 中没有 C++ 引用和指针的概念，所以只有按值传递一说。&lt;/p&gt;
&lt;p&gt;    为了更好的说明 Java 中只有按值传递，先来看看 Java 的数据类型，Java 的数据类型分为基本数据类型和引用类型，其中：&lt;/p&gt;
&lt;p&gt;    1、基本类型包括 byte/short/int/long/float/double/char/boolean 八种，基本类型在内存中地址中保存的即本身的值，其一般都在栈上分配。&lt;/p&gt;
&lt;p&gt;    2、引用类型指向一个对象，它与 C++ 的指针非常相似。但 C++ 的指针可以指向基本类型和类对象，而 Java 的引用只能指向类（枚举、接口等）对象。Java 中对象本身在堆上分配，而引用类型在栈上分配，其内存地址中保存的是对象在堆中的地址。两种类型在内存中的布局如下：&lt;/p&gt;

&lt;p&gt;    上图可以一目了然的看出基本类型与引用类型的区别，基本类型数据即本身，引用类型仅仅是引用。来看下基本类型和引用类型在参数传递中所表现的不同的地方：&lt;/p&gt;

&lt;p&gt;    运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EbGrZVyOwibB2bicolPWgJ8uuEpxaxzr4NkqEXhnjRIpUbfhzcTLWRnq5YXAicqtFiajqvyqTcy5PRlv6pNibRIEibsQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EbGrZVyOwibB2bicolPWgJ8uuEpxaxzr4NkqEXhnjRIpUbfhzcTLWRnq5YXAicqtFiajqvyqTcy5PRlv6pNibRIEibsQ/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/EbGrZVyOwibB2bicolPWgJ8uuEpxaxzr4NkqEXhnjRIpUbfhzcTLWRnq5YXAicqtFiajqvyqTcy5PRlv6pNibRIEibsQ/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    可以看出基本类型 int 的变量 basicTypeA 在 changeBasic 调用后值并没有发生改变，而引用类型 MyInteger 的变量 referenceTypeA 在调用 changeReference 后发生了改变。&lt;strong&gt;这里就比较容易误导读者以为：Java 基本类型是按值传递而引用类型是按引用传递（暂且这么定义）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    其实不然，按值传递的意思想必大家都知道：传递的是值的的拷贝，比如上面代码中的调用 changeBasic(basicTypeA) 时，arg 是 basicTypeA 的一个拷贝，所以无论对 arg 做任何操作都不影响 basicTypeA 变量本身。而调用 changeReference(referenceTypeA) ，arg 也是 referenceTypeA 的一个拷贝，但是由于 arg 和 referenceTypeA 都是引用类型且他们指向同一对象，所以通过 arg 修改对象，referenceTypeA 也能看到。两种类型变量在内存中调用过程如下：&lt;/p&gt;

&lt;p&gt;    所以可以看出无论是基本类型还是引用类型，都是按值传递。只是由于它们在内存中所表示的内容不同，最后表现出来的结果也有所不同。同理，在 C++ 中的按值传递、按指针传递和按引用传递理论上都可以归为按值传递（其实这个归类在学 C++ 的时候就归纳出来了，只是后来反而忘了）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对&quot;引用&quot;进行传递的坑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Java 的引用类似于 C++ 的指针，但是 C++ 的对象传递提供了对象本身直接传递和指针传递两种方式（引用方式不谈），而 Java 对象只有对引用进行传递这一种，不存在直接将对象本身进行传递。&lt;/p&gt;
&lt;p&gt;    1、对象本身进行传递的好处是传递的都是对象的拷贝，在函数中对拷贝的对象做任何修改都不会改变原对象。但是如果对象非常大，而且调用很频繁会影响性能。&lt;/p&gt;
&lt;p&gt;    2、对象的引用（或者指针）传递的好处是只需要拷贝一个引用（或者指针）大小的数据即可，且可以在调用的函数中改变原对象内容。&lt;/p&gt;
&lt;p&gt;    在 C++ 中以上（1）和（2）程序员自己还可以选择，Java 里面直接只有第 2 种方式，凡事有利有弊，有时候我们并不想在函数中改变原对象的内容，这里我就踩过一个坑，有个对象通过管道传递的流程如下：&lt;/p&gt;

&lt;p&gt;    funcA 与 funcB 是两个不同的人负责的，一次升级后 funcB 的负责人发现在函数中获取的对象 X 内容不对，一开始还以为是传递对象 X 的接口出现了错误便是一顿排查，知道最后才发现对象 X 是在升级后在 funcA 中被修改了，浪费了不少时间。当然这个架构的流程设计的不合理是主要原因（只需要在分发的时候讲对象 X 做手动拷贝即可避免上述问题），但是不不影响我们抛出 Java 只能对引用进行传递的弊端。&lt;/p&gt;
&lt;p&gt;    在调用链较长、各种 for/while 循环中很容易就犯了上述错误，解决方案当然就是手动拷贝对象，Java 中拷贝对象有以下两种方式：&lt;/p&gt;
&lt;p&gt;    1、实现Cloneable接口并重写Object类中的clone()方法。&lt;/p&gt;
&lt;p&gt;    2、实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。&lt;/p&gt;
&lt;p&gt;    其中 2 能避免深浅拷贝的问题，但调用比较耗时。1 也能避免深浅拷贝但是需要自己手动去写相应的代码，如果嵌套较深，代码将非常复杂。至于深浅拷贝的问题可以自行百度，其本质还是因为只是将对象的引用进行了传递而导致的一些问题。&lt;/p&gt;


</description>
<pubDate>Sun, 17 Feb 2019 14:14:00 +0000</pubDate>
<dc:creator>水目沾</dc:creator>
<og:description>Java 中只有按值传递 &quot;Java 中只有按值传递&quot;，初看到这几个字有点不敢相信，无数次通过函数改变过对象，无数次跟同事说 Java 在传对象的时候是按引用传递。后来细细想想，之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuwbox/p/10392970.html</dc:identifier>
</item>
</channel>
</rss>