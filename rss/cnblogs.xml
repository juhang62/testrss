<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在vscode中配置LeetCode插件，从此愉快地刷题 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12590795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12590795.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，今早在B站看到up主的vscode里藏了leetcode插件，这才知道原来还有这款神器。但是没想到在用的时候遇到了一些麻烦，花了一点时间才解决。所以写这篇文章除了给大家安利这个好用的插件之外，也是为了帮助更多的同学避免踩坑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;简介vscode&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vscode在工业界鼎鼎大名，被誉为&lt;strong&gt;微软少有的拿得出手的精品&lt;/strong&gt;（逃）。原本是不想过多赘述的，但是鉴于许多粉丝还是正在上学的萌新，所以花点笔墨简单介绍一下。&lt;/p&gt;
&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/6692c9e4-fe71-421b-8175-4ea5c9542dd3.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vscode是微软开发的&lt;strong&gt;编辑器&lt;/strong&gt;，严格说起来它并不是一个IDE，只是一个编辑器。但是由于它支持嵌入各大语言的编译器，并且对于terminal的支持也非常出色，所以已经近乎于一个支持众多语言，拥有许多特性的IDE了。根据2019年stackflow最新的调研，vscode已经成为&lt;strong&gt;最受开发者欢迎的开发环境了&lt;/strong&gt;。在当下的互联网公司当中，可以说是无论前后端或者是其他的开发岗位都有大量的工程师使用它。它免费轻量级、跨平台、并且有着大量好用的插件作为支持。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以不论你用的是Windows，linux还是Mac，都可以非常方便地使用它。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;强调一下，vscode支持各大语言，基本上我们能想到的，我们听说过的没有听说过的，它都支持。我刚才特意去看了一下，连&lt;strong&gt;上古语言Pascal&lt;/strong&gt;都支持，所以装就完事了。对学生党多说一句，不要听什么老师或者是某本教材的忽悠，去装什么visual studio或者是dev C++了，已经过时了。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;vscode的插件&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vscode之所以强大很大的原因是因为&lt;strong&gt;拥抱开源&lt;/strong&gt;，我们每个人都可以为它开发插件。也正是因为这点，vscode当中有着非常非常多的插件，无论我们想得到的还是想不到的，可以说是应有尽有。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们点击左侧边栏的extensions打开插件市场，我们可以当中进行搜索。&lt;/p&gt;
&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/854e2d3f-9564-4949-aa48-122e827d636b.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你想要写Python，那么我们就输入Python，排名第一的就是Python的解释器：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xkwrdksj30sg0lcn1i.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且右侧还会有&lt;strong&gt;详细的说明和介绍文档&lt;/strong&gt;，介绍这款插件的使用方法或者是配置方法，以及我们可以自己根据需要设置的配置。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换成C++也是一样：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xlht6lvj30sg0lcn17.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些说明其实&lt;strong&gt;对应github仓库当中的一个repo&lt;/strong&gt;，所以当我们点击其中的一些链接会跳转到github当中。另外，如果我们自己开发了相应的插件，同样也可以注册到vscode当中来，给其他人使用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是&lt;strong&gt;开源精神&lt;/strong&gt;所在，即使微软家大业大，仅仅靠它一家公司的努力，是不可能同时支持和维护这么多功能和插件的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，需要注意的是大部分插件是安装好了可以直接使用的，但是也&lt;strong&gt;有些插件是需要配置&lt;/strong&gt;的，这需要我们在安装和使用之前详细阅读文档。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;leetcode插件&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉了vscode的插件之后，我们开始进入本文的正题。和预料的一样，我们在插件市场当中搜索leetcode，然后安装下载量最高的那个即可。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xmcsdx5j30sg0lcq5x.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们安装之后，按住&lt;strong&gt;shift + ctrl(command) + p&lt;/strong&gt;，打开插件搜索栏。输入leetcode，选择第一个sign in，然后输入账号和密码即可。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xmudjohj30sg0lcacy.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是你会发现&lt;strong&gt;登陆失败了&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么回事，为什么失败了，难道是记错密码了吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是你打开leetcode的网站又尝试了一下，发现密码没有记错，网页可以登陆。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们打开官网，会发现官方已经知道登陆失败的问题了，这是由于leetcode官网升级了登陆机制导致的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xnqldo9j31he0fc0xt.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是leetcode只升级了国际版，对于国内的版本还没有升级，所以如果你使用的是国内的leetcode账号，那么我们只需要更换leetcode版本即可。更换的方式也很简单，点击上方地球形状的按钮进行选择即可：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xojaghlj30sg0lcdi2.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，我个人&lt;strong&gt;更推荐使用国际版&lt;/strong&gt;，因为英文的题目描述会更加清楚，并且题目的更新也会更加及时。况且以后说不准中文版的leetcode也会升级登陆机制，到时候还是会面临无法登陆的问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很遗憾的是，对于无法登陆这个问题，官方很坦率地承认了对于这个问题&lt;strong&gt;没有特别好的解决方法，只能使用cookie来绕开&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;cookie登陆&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cookie在网站当中经常使用，我们可以简单地将它认为是一个&lt;strong&gt;标识身份的令牌或者说证书&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，现在的网站往往有自动登录机制。因为我们每打开一次都要用户输入一次账号密码实在是太反人类了，并且有时候我们打开多个相同网站中的不同站点，也会想要保持登录的状态，而不是再输入账号密码。cookie正是基于整个目的诞生的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cookie的原理也很简单，我们在登录网站成功之后，网站的服务器&lt;strong&gt;会根据我们的账号id或者是其他信息使用加密算法生成一串密文&lt;/strong&gt;。并且将这串密文发送给浏览器，浏览器会将这串密文存储起来，这样下次浏览器在访问网站的时候，只需要携带上这串密文，网站拿到密文进行解密之后就能识别出这是哪一个用户，自动设置成已经登录的状态，并且返回对应的数据。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此cookie数据非常重要，它&lt;strong&gt;关乎我们许多账号的安全&lt;/strong&gt;。如果我们的cookie被黑客获取，我们的账号都会面临被盗的风险。由于对称加密算法几乎不可攻破，所以目前许多针对浏览器账户的攻击手段都和cookie有关。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我猜测登录问题出现的原因应该是leetcode官方人为限制了第三方插件通过账号密码代理登录，所以解决方法很简单，就是我们&lt;strong&gt;使用cookie来进行模拟登录&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前期准备&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于leetcode插件底层是使用的&lt;strong&gt;leetcode-cli&lt;/strong&gt;命令行工具，所以我们需要现在本地保证我们的命令行工具的版本正确。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们需要安装Node.js 8以上的版本，关于Node.js的安装方法网上随便就能搜到，安装也很简单，这里就不赘述了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，我们通过npm工具安装最新版本的leetcode-cli：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;npm uninstall -g leetcode-cli&lt;br/&gt;npm install -g leetcode-tools/leetcode-cli&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;操作流程&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们需要通过浏览器获取我们账号的cookie。下面以Google Chrome浏览器举例。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先打开leetcode用我们自己的账号和密码登录，然后右击选择inspect：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xr4zkbhj312s0rqdje.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着选择Network下的XHR：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xrdj2g0j31ce0pstba.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们点击网站导航栏中的problems：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xrnhkapj319o0o0djz.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候右边会显示出前端网页跳转的请求信息，我们找到其中一个名叫all的请求，选择Headers，往下拉就能找到cookie：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xrxq32cj315z0u011p.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把这一串字符串复制下来。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新打开vscode，打开leetcode插件，选择sign in，这一次在&lt;strong&gt;选择登录方式的时候我们选择使用cookie登录&lt;/strong&gt;：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xsevf8kj30sg0lc0v0.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后输入账号，粘贴进我们刚才复制下来的cookie即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺利的话，看到下图红框当中的边栏出现，就说明我们已经&lt;strong&gt;成功登录&lt;/strong&gt;了。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xsxfljqj30sg0lc76q.jpg&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;leetcode插件使用&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;leetcode的使用很简单，和网页版差距不大，我们&lt;strong&gt;点开all可以看到所有的问题&lt;/strong&gt;，我们点击问题的标题会自动为我们加载题目的详细信息，已经通过的问题会打上绿色的勾。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xtf7tzzj30sg0lcn1t.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要做题的话就右击选择&lt;strong&gt;Show Problem&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xtpsr9zj30gy07amxv.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后会弹出语言让我们选择，我们就选择我们最常用的语言就好。比如我最近用Python做题，就选择Python3：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xtz95cpj30sg0lcwhf.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后选择&lt;strong&gt;Just Open The problem file&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xubhp12j30oy05qt9a.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vscode会自动为我们打开一个分屏。我们就可&lt;strong&gt;以一边看问题一边写代码&lt;/strong&gt;了，不得不说实在是非常方便。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xunln8hj313s0lc78l.jpg&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;leetcode配置&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后简单讲一下leetcode插件的一些配置。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;leetcode这个插件当中的配置还蛮多的，但是我个人觉得最主要的是其中的两个。一个是配置我们每个问题代码存放的文件路径，方便以后我们找到这些写好的代码。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个配置名字叫做&lt;strong&gt;leetcode.workspaceFolder&lt;/strong&gt;，默认的路径是$HOME/.leetcode。这里的HOME是你系统的环境变量，不同的系统这个变量指定的位置不一样。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以打开终端输入&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$HOME&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看一下我们当前的$HOME目录指向哪里，当然我们&lt;strong&gt;也可以自己修改这个配置&lt;/strong&gt;。我们打开vscode的配置文件，搜索leetcode.workspaceFolder，就可以找到vscode当中的配置，我们修改我们想要的path即可。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xwihlltj30pr09sgm5.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个配置是&lt;strong&gt;编辑器的快捷方式&lt;/strong&gt;，我们仔细观察会发现我们打开的leetcode py文件下面会有两个按钮。我这张图里是三个，因为我设置过。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xwvteduj30gl08eglu.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些按钮是可以点击的，它们&lt;strong&gt;都有具体的功能&lt;/strong&gt;。比如Submit是提交当前的code到leetcode网站，帮我们提交代码。Test是执行样例，看看样例是否能够通过。除了这两个之外还有两个，一个叫做Solution，可以查看当前最高赞的代码。另一个是Description，是显示问题描述。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在&lt;strong&gt;leetcode.editor.shortcuts&lt;/strong&gt;配置当中进行修改：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd9xxe7o7yj30j4087glt.jpg&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个插件之后，我们就可以摆脱使用网页端来进行刷题了。不得不说实在是&lt;strong&gt;非常方便&lt;/strong&gt;，另外对于我们程序员来说，我觉得leetcode当中的许多问题，我们是一定会遇到的。&lt;strong&gt;问题仅仅是你遇到它的时候是在刷题还是面试&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是周末，祝愿大家刷题愉快，&lt;strong&gt;点个关注&lt;/strong&gt;再走吧。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Mar 2020 00:38:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>大家好，今早在B站看到up主的vscode里藏了leetcode插件，这才知道原来还有这款神器。但是没想到在用的时候遇到了一些麻烦，花了一点时间才解决。所以写这篇文章除了给大家安利这个好用的插件之外，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12590795.html</dc:identifier>
</item>
<item>
<title>常见的线性结构 - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/12586248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/12586248.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;  本篇博客主要是记录手写这些这数据结构的底层实现，加深对线性结构的理解，实现自己的一个小型数据结构库，也会进行简单的时间复杂度分析，对不同的实现进行比较和优化，即侧重于代码实现。由于数据结构是实践性比较强的一个科目，希望大家在看这篇博客时，自己也去写一下代码，看一下运行结果是不是自己想要的，我也会贴出我的运行结果来进行分析。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;h3 id=&quot;数组介绍&quot;&gt;数组介绍&lt;/h3&gt;
&lt;p&gt;  数组是在内存中存储相同数据类型的连续的空间，最大的优点：查询快速。&lt;br/&gt;  数组最好应用于“索引有语意”的情况，例如索引代表学生学号，我们可以根据学号获取这个学生对象的信息。但并非所有有语意的索引都适用于数组，例如身份证号，我们不可能拿身份证号作为索引，因为身份证长度是18位数，而且身份证号也不是连续的，这样会浪费很大的内存空间。&lt;br/&gt;  数组也可以处理“索引没有语意”的情况，若索引没有语意时，如何表示没有元素？我们应该如何去添加元素、如何去删除元素呢？为了解决这些问题，我们可以基于Java的数组，二次封装属于我们自己的数组。&lt;/p&gt;
&lt;h3 id=&quot;自定义数组&quot;&gt;自定义数组&lt;/h3&gt;
&lt;p&gt;  我们通过创建一个自定义数组，来实现对数组的增删改查，以及数组进行扩容，现在我们先通过定义一个整型数组来实现，后面再通过泛型来达到通用的效果。&lt;br/&gt;1.先创建一个实体类：Array&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Array {

    private int[] data;
    private int size;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.为我们的数组添加一些基本的方法，比如构造器、获取数组容量大小、获取数组中元素个数、判断数组是否为空、判断是否包含某个元素的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //有参构造--- 根据用户分配的初始容量进行创建数组
    public Array(int capacity){
        data = new int[capacity];
        size = 0;
    }    

    //创建无参构造 --- 当用户未指定初始容量时，我们可以设置一个初始容量大小
    public Array(){
        this(10);
    }    

    //创建一个获取容量大小的方法
    public int getCapacity(){
        return data.length;
    }

    //创建一个获取数组中元素个数的方法
    public int getSize(){
        return size;
    }

    //判断数组是否为空
    public boolean isEmpty(){
        return size == 0;
    }

    //是否包含某个元素
    public boolean contains(int e) {
        for(int i = 0; i &amp;lt; this.size; ++i) {
            if (this.data[i] == e) {
                return true;
            }
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现数组的增删改查方法&quot;&gt;实现数组的增删改查方法&lt;/h3&gt;
&lt;p&gt;1.向数组中添加元素&lt;br/&gt;在指定索引位置添加一个新元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 在指定索引的位置插入一个新元素e
    public void add(int index, int e){
        //判断索引是否合法
        if(index &amp;lt; 0 || index &amp;gt; size){
            throw new IllegalArgumentException(&quot;Add failed. Require index &amp;gt;= 0 and index &amp;lt;= size.&quot;);
        }
        //判断数组是否已满
        if(size == data.length){
            throw new IllegalArgumentException(&quot;Add failed. Array is full.&quot;);
        }
        //把索引为index以及index之后的元素，都向右移动一个位置
        for(int i = size - 1; i &amp;gt;= index ; i --){
            data[i + 1] = data[i];
        }
        //在指定index的位置添加新元素e
        data[index] = e;
        //维护size的值
        size ++;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在所有元素前添加一个新元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 在所有元素前添加一个新元素
    public void addFirst(int e){
        add(0, e);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在所有元素后添加一个新元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 在所有元素前添加一个新元素
    public void addLast(int e){
        add(size, e);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.修改数组中的元素&lt;br/&gt;通过索引修改数组中的元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void set(int index, int e){
        if(index &amp;lt; 0 || index &amp;gt;= size)
            throw new IllegalArgumentException(&quot;Set failed. Index is illegal.&quot;);
        //由于数组支持随机访问，根据索引即可找到所需要修改的元素
        data[index] = e;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.查找元素&lt;br/&gt;通过index索引，获取元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public int get(int index){
        //判断用户输入的索引值是否合法
        if(index &amp;lt; 0 || index &amp;gt;= size)
            throw new IllegalArgumentException(&quot;Get failed. Index is illegal.&quot;);
        return data[index];
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找某个元素的索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public int find(int e) {
        for(int i = 0; i &amp;lt; this.size; ++i) {
            if (this.data[i] == e) {
                return i;
            }
        }
        //未找到该元素，则返回-1
        return -1;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.删除元素&lt;br/&gt;删除指定位置的元素,并返回删除的元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 从数组中删除index位置的元素, 返回删除的元素
    public int remove(int index){
        //索引合法性判断
        if(index &amp;lt; 0 || index &amp;gt;= size)
            throw new IllegalArgumentException(&quot;Remove failed. Index is illegal.&quot;);
        //保存待删除的元素
        int ret = data[index];
        //把index位置之后的所有元素，都向左移动一个位置
        for(int i = index + 1 ; i &amp;lt; size ; i ++)
            data[i - 1] = data[i];
        //维护size的值
        size --;
        return ret;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除第一个元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    // 从数组中删除第一个元素, 返回删除的元素
    public int removeFirst(){
        return remove(0);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除最后一个元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public int removeLast(){
        return remove(size - 1);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除数组中的指定元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 从数组中删除元素e
    public void removeElement(int e){
        int index = find(e);
        if(index != -1)
            remove(index);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.重写toString()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    public String toString(){
        //通过StringBuilderl来拼接字符串
        StringBuilder res = new StringBuilder();
        //自定义输出格式
        res.append(String.format(&quot;Array: size = %d , capacity = %d\n&quot;, size, data.length));
        res.append('[');
        for(int i = 0 ; i &amp;lt; size ; i ++){
            res.append(data[i]);
            if(i != size - 1)
                res.append(&quot;, &quot;);
        }
        res.append(']');
        return res.toString();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对我们数组的增删改查方法进行测试,我们可以在主函数中进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        Array arr = new Array(20);
        for(int i = 0 ; i &amp;lt; 10 ; i ++){
            //执行添加元素操作 --- 新增到元素末尾
            arr.addLast(i);
        }
        System.out.println(arr);// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

        //将新元素插入到指定位置
        arr.add(1, 100);
        System.out.println(arr);// [0, 100, 1, 2, 3, 4, 5, 6, 7, 8, 9]

        //将新元素添加到第一个位置
        arr.addFirst(-1);
        System.out.println(arr);// [-1, 0, 100, 1, 2, 3, 4, 5, 6, 7, 8, 9]

        //删除指定位置的元素
        arr.remove(2);
        System.out.println(arr);// [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

        //删除指定元素
        arr.removeElement(4);
        System.out.println(arr);// [-1, 0, 1, 2, 3, 5, 6, 7, 8, 9]

        //删除第一个位置的元素
        arr.removeFirst();
        System.out.println(arr);// [0, 1, 2, 3, 5, 6, 7, 8, 9]
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  经测试，我们自定义数组的增删改查等基本操作已经实现了，不过我们现在写的自定义数组，只能存储整型数据，为了适用性更好，我们可以把我们的自定义数组改为泛型，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Array&amp;lt;E&amp;gt; {

    private E[] data;
    private int size;

    public Array(int capacity){
        //无法定义为new E[capacity] ,使因为jdk1.5之后才支持泛型的，由于历史版本遗留问题
        // 这里只能进行强转
        this.data = (E[]) new Object[capacity];
        this.size = 0;
    }

    //创建无参构造 --- 当用户未指定初始容量时，我们可以设置一个初始容量大小
    public Array(){
        this(10);
    }

    //创建一个获取容量大小的方法
    public int getCapacity(){
        return this.data.length;
    }

    //创建一个获取数组中元素个数的方法
    public int getSize() {
        return this.size;
    }

    //判断数组是否为空
    public boolean isEmpty() {
        return this.size == 0;
    }

    // 向所有元素后添加一个新元素
    public void addLast(E e){
//        //判断数组中是否还有空位置
//        if (size == data.length) {
//            throw new IllegalArgumentException(&quot;AddLast failed. Array is full.&quot;);
//        }
//        //因为size始终表示数组中元素为空的第一个索引
//        data[size] = e;
//        //添加元素后，需要改变size的值
//        size++;
        add(size,e);
    }

    //在所有元素前添加一个新元素 --- 将新元素添加到索引为0的位置
    public void addFirst(E e){
//        //判断数组中是否还有空位置
//        if (size == data.length) {
//            throw new IllegalArgumentException(&quot;AddLast failed. Array is full.&quot;);
//        }
//        //需要将所有元素向后移一个位置，然后把新元素加入到索引为0的位置
//        for(int i = size - 1; i &amp;gt;= 0 ; i --){
//            //向后赋值
//            data[i + 1] = data[i];
//        }
//        data[0] = e;
//        size ++;
        add(0,e);
    }

    // 在指定索引的位置插入一个新元素e
    public void add(int index, E e){

        if(size == data.length){
            throw new IllegalArgumentException(&quot;Add failed. Array is full.&quot;);
        }

        if(index &amp;lt; 0 || index &amp;gt; size){
            throw new IllegalArgumentException(&quot;Add failed. Require index &amp;gt;= 0 and index &amp;lt;= size.&quot;);
        }

        for(int i = size - 1; i &amp;gt;= index ; i --){
            data[i + 1] = data[i];
        }
        data[index] = e;
        size ++;
    }

    // 获取index索引位置的元素
    public E get(int index){
        //判断用户输入的索引值是否合法
        if(index &amp;lt; 0 || index &amp;gt;= size)
            throw new IllegalArgumentException(&quot;Get failed. Index is illegal.&quot;);
        return data[index];
    }

    //查找某个元素的索引
    public int find(E e) {
        for(int i = 0; i &amp;lt; this.size; ++i) {
            if (this.data[i] == e) {
                return i;
            }
        }
        return -1;
    }

    // 修改index索引位置的元素为e
    public void set(int index, E e){
        if(index &amp;lt; 0 || index &amp;gt;= size)
            throw new IllegalArgumentException(&quot;Set failed. Index is illegal.&quot;);
        data[index] = e;
    }

    //是否包含某个元素
    public boolean contains(E e) {
        for(int i = 0; i &amp;lt; this.size; ++i) {
            if (this.data[i] == e) {
                return true;
            }
        }
        return false;
    }

    //删除指定位置的元素
    public void remove(int index) {
        //索引合法性判断
        if (index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; this.size) {
            for(int i = index + 1; i &amp;lt; this.size; ++i) {
                //向前赋值
                this.data[i - 1] = this.data[i];
            }
            //删除元素后，修改size的值
            --this.size;
        } else {
            throw new IllegalArgumentException(&quot;Remove failed. Index is illegal.&quot;);
        }
    }

    //删除第一个元素
    public void removeFirst() {
        this.remove(0);
    }

    //删除最后一个元素
    public void removeLast() {
        this.remove(this.size - 1);
    }

    //删除数组中的指定元素
    public void removeElement(E e) {
        //先查找指定元素所在的索引位置
        int index = this.find(e);
        //删除指定索引位置的元素
        this.remove(index);
    }


    @Override
    public String toString(){

        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;Array: size = %d , capacity = %d\n&quot;, size, data.length));
        res.append('[');
        for(int i = 0 ; i &amp;lt; size ; i ++){
            res.append(data[i]);
            if(i != size - 1)
                res.append(&quot;, &quot;);
        }
        res.append(']');
        return res.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改为泛型之后，我们可以通过自定义一个学生类，来使用我们的自定义数组进行增删查改操作，测试是否有问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Student {
    private String name;
    private int score;

    public Student(String studentName, int studentScore) {
        this.name = studentName;
        this.score = studentScore;
    }

    public String toString() {
        return String.format(&quot;Student(name: %s, score: %d)&quot;, this.name, this.score);
    }

    public static void main(String[] args) {
        Array arr = new Array();
        //执行添加元素操作 --- 新增到元素末尾
        arr.addLast(new Student(&quot;Lucy&quot;, 100));
        arr.addLast(new Student(&quot;Bob&quot;, 66));
        arr.addLast(new Student(&quot;Tina&quot;, 88));
        System.out.println(arr);

        //删除指定位置的元素
        arr.remove(2);
        System.out.println(arr);

        //将新元素插入到指定位置
        arr.add(1,new Student(&quot;LiHua&quot;, 75));
        System.out.println(arr);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;动态数组&quot;&gt;动态数组&lt;/h3&gt;
&lt;p&gt;  当数组中的元素存满时，再执行添加操作，这个时候会抛出数组元素已满的异常信息，我们希望我们的自定义数组可以进行动态扩容，我们可以通过写一个重置数组容量的方法，这个方法只允许在数组类内部调用，不允许用户直接调用，所以需要设置成私有的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //将数组空间的容量变成newCapacity大小
    private void resize(int newCapacity){
        E[] newData = (E[]) new Object[newCapacity];
        for (int i=0;i&amp;lt;size;i++){
            newData[i] = data[i];
        }
        data = newData;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写好了resize()后，现在让我们来重写之前的添加和删除方法：&lt;br/&gt;添加操作：为了防止在添加的时候，抛出数组已满的异常，我们可以在向数组中添加元素的时候，判断数组受否已满，若满了，则进行扩容操作，这里我们扩容为原来的2倍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void add(int index, E e){

        if(index &amp;lt; 0 || index &amp;gt; size){
            throw new IllegalArgumentException(&quot;Add failed. Require index &amp;gt;= 0 and index &amp;lt;= size.&quot;);
        }

        if(size == data.length){
            //throw new IllegalArgumentException(&quot;Add failed. Array is full.&quot;);
            //若数组满了，则进行扩容操作
            this.resize(data.length * 2);
        }

        for(int i = size - 1; i &amp;gt;= index ; i --){
            data[i + 1] = data[i];
        }
        data[index] = e;
        size ++;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除操作：为了不浪费内存，在删除元素时，我们可以判断数组中元素的个数是否是数组容量的一半，若是的话，这个时候就对数组进行缩容操作，以达到节省内存的目的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 从数组中删除index位置的元素, 返回删除的元素
    public E remove(int index){
        if(index &amp;lt; 0 || index &amp;gt;= size)
            throw new IllegalArgumentException(&quot;Remove failed. Index is illegal.&quot;);

        E ret = data[index];
        for(int i = index + 1 ; i &amp;lt; size ; i ++)
            data[i - 1] = data[i];
        size --;
        data[size] = null; // 方便GC机制回收
        //当数组的元素个数为数组长度的一半时，进行缩容操作
        if(size == data.length / 2)
            resize(data.length / 2);
        return ret;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们来测试我们的扩容和缩容方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {

        Array&amp;lt;Integer&amp;gt; arr = new Array&amp;lt;&amp;gt;();
        for(int i = 0 ; i &amp;lt; 10 ; i ++)
            arr.addLast(i);
        System.out.println(arr);

        arr.add(1, 100);
        System.out.println(arr);

        arr.addFirst(-1);
        System.out.println(arr);

        arr.remove(2);
        System.out.println(arr);

        arr.removeElement(4);
        System.out.println(arr);

        arr.removeFirst();
        System.out.println(arr);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果分析：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328104511112-1990284731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;时间复杂度分析&quot;&gt;时间复杂度分析&lt;/h3&gt;
&lt;p&gt;常见的算法复杂度：O(1),O(n),O(lgn),O(nlgn),O(n^2)&lt;br/&gt;大O描述的是算法的运行时间和输入数据之间的关系&lt;br/&gt;例如下面这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static int sum(int[] nums){
        int sum = 0;
        for (int num : nums) {
            sum = sum + num;
        }
        return sum;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的算法复杂度为O（n）。n是nums中的元素个数，这个算法的运行时间是和nums中元素的个数呈线性关系的。好了，上面是关于算法复杂度的简单描述，我们来看下我们自定义数组中添加操作的算法复杂度吧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加操作：由于算法复杂度是按照最坏的情况来计算的，所以这里添加的算法复杂度为O（n）&lt;br/&gt;  addLast(e) -------- O(1)&lt;br/&gt;  addFirst(e) --------- O(n),因为向数组中第一个元素位置添加元素，需要将这些元素都向右移动一个位置，这和元素的个数呈线性关系，若数组中元素的个数越多，组需要花费的时间越长&lt;br/&gt;  add(index,e) ----- O(n/2) =O(n)&lt;/li&gt;
&lt;li&gt;删除操作同添加操作，算法复杂度为O（n）&lt;/li&gt;
&lt;li&gt;修改操作的算法复杂度为O（1），这个是数组的最大优势，也就是支持随机访问，只要我们知道所查元素的索引。&lt;/li&gt;
&lt;li&gt;查找操作：get(index) --- O(1) ,contains(e)和find(e)的时间复杂度都为O（n）,因为需要遍历这个数据中的所有元素。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;栈&quot;&gt;栈&lt;/h2&gt;
&lt;h3 id=&quot;栈介绍&quot;&gt;栈介绍&lt;/h3&gt;
&lt;p&gt;  栈也是一种线性结构，相比数组，栈对应的操作是数组的子集。栈只能从一端添加元素，也只能从这端取出元素，这一端成为栈顶,栈是一种“先进后出”的数据结构，即 LIFO(Last In First Out)&lt;/p&gt;
&lt;p&gt;一些常见的栈应用：比如：撤销操作，程序调用的系统栈，括号匹配等问题。&lt;/p&gt;
&lt;p&gt;栈中常用的方法：&lt;br/&gt;   void push(Object obj); //进栈&lt;br/&gt;   Object pop(); //出栈&lt;br/&gt;   Object peek(); //查看栈顶的元素&lt;br/&gt;   int getSize(); //查看栈中元素的个数&lt;br/&gt;   boolean isEmpty();  //判断栈是否为空&lt;/p&gt;
&lt;h3 id=&quot;定义栈接口&quot;&gt;定义栈接口&lt;/h3&gt;
&lt;p&gt;  由于用户在调用栈进行操作时，完全不用关心栈的底层是如何实现的，因此我们可以定义一个 接口来供用户调用，下面就让我们基于之前实现的自定义动态数组，来实现栈的这些基本操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Stack&amp;lt;E&amp;gt; {

    /**
     * 获取栈中元素的个数
     * @return
     */
    int getSize();

    /**
     * 判断栈是否为空
     * @return
     */
    boolean isEmpty();

    /**
     * 入栈
     * @param e
     */
    void push(E e);

    /**
     * 出栈
     * @return
     */
    E pop();

    /**
     * 查看栈顶元素
     * @return
     */
    E peek();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于数组实现栈的基本操作&quot;&gt;基于数组实现栈的基本操作&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class ArrayStack&amp;lt;E&amp;gt; implements Stack&amp;lt;E&amp;gt; {

    //这里的Array是我们的自定义动态数组
    private Array&amp;lt;E&amp;gt; array;

    //有参构造器，为栈分配指定空间
    public ArrayStack(int capacity) {
        this.array = new Array(capacity);
    }

    //无参构造器，调用动态数组的无参构造进行赋值
    public ArrayStack(){
        this.array = new Array&amp;lt;&amp;gt;();
    }

    //获取栈的容量
    public int getCapacity() {
        return this.array.getCapacity();
    }

    @Override
    public int getSize() {
        //直接调用动态数组的getSize()
        return this.array.getSize();
    }

    @Override
    public boolean isEmpty() {
        return this.array.isEmpty();
    }

    @Override
    public void push(E e) {
        //向栈中添加元素，调用动态数组的向最后一个元素位置的添加方法
        this.array.addLast(e);
    }

    @Override
    public E pop() {
        //获取栈顶的元素，即动态数组的最后一个元素
        E e = this.array.get(array.getSize() - 1);
        //删除动态数组中最后一个元素
        this.array.removeLast();
        return e;
    }

    @Override
    public E peek() {
        return this.array.get(array.getSize() - 1);
    }

    //重写toString()
    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(&quot;Stack: &quot;);
        res.append('[');
        for (int i=0; i&amp;lt;this.getSize(); i++){
            res.append(this.array.get(i));
            if (i != this.getSize()-1 ){
                res.append(',');
            }
        }
        res.append(&quot;] top&quot;);
        return res.toString();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在来测试我们基于动态数组实现的栈：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    public static void main(String[] args) {
        Stack&amp;lt;Integer&amp;gt; stack = new ArrayStack();

        for(int i = 0; i &amp;lt; 5; ++i) {
            //入栈
            stack.push(i);
            System.out.println(stack);
        }
        //出栈
        stack.pop();
        System.out.println(stack);
        //打印出栈顶的元素
        System.out.println(stack.peek());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码的运行结果分析：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328111725336-1563327566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用栈实现括号匹配问题&quot;&gt;使用栈实现“括号匹配”问题&lt;/h3&gt;
&lt;p&gt;该问题是leetcode官网上的一个问题，题目描述如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328111843678-1934819953.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;关于括号匹配问题，具体实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean isValid(String s) {

        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();

        for (int i=0; i&amp;lt;s.length(); i++){
            if (s.charAt(i) != '(' &amp;amp;&amp;amp; s.charAt(i) != '[' &amp;amp;&amp;amp; s.charAt(i) != '{'){
                if (stack.isEmpty()) return false;
                char topChar = stack.pop();
                if (topChar == '(' &amp;amp;&amp;amp; s.charAt(i) != ')') return false;
                if (topChar == '[' &amp;amp;&amp;amp; s.charAt(i) != ']') return false;
                if (topChar == '{' &amp;amp;&amp;amp; s.charAt(i) != '}') return false;
            }else {
                stack.push(s.charAt(i));
            }
        }
        return stack.isEmpty();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;队列&quot;&gt;队列&lt;/h2&gt;
&lt;h3 id=&quot;队列介绍&quot;&gt;队列介绍&lt;/h3&gt;
&lt;p&gt;  队列也是一种线性结构，相比数组，队列对应的操作是数组的子集，队列只能从一端（队尾）添加元素，只能从另一端（队首）取出元素。队列是一种先进先出的数据结构（先到先得），即FIFO(First In First Out).&lt;br/&gt; &lt;br/&gt;队列中常用的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;void enqueue(Object obj); //入队&lt;/li&gt;
&lt;li&gt;Object dequeue(); //出队&lt;/li&gt;
&lt;li&gt;Object getFront(); //获取队首的元素&lt;/li&gt;
&lt;li&gt;int getSize(); //获取队列中元素的个数&lt;/li&gt;
&lt;li&gt;boolean isEmpty(); //判断队列是否为空&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;定义队列接口&quot;&gt;定义队列接口&lt;/h3&gt;
&lt;p&gt;和栈操作一样，我们不需要让用户知道队列底层是如何实现的，只知道如何调用就行了，所以我们创建一个接口，包含这些队列的基本方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Queue&amp;lt;E&amp;gt; {

    /**
     * 入队
     * @param e 入队的元素
     */
    void enqueue(E  e);

    /**
     * 出队
     * @return 出队的元素
     */
    E dequeue();

    /**
     * 获取队首的元素
     * @return 队首的元素
     */
    E getFront();

    /**
     * 判断队列是否为空
     * @return
     */
    boolean isEmpty();

    /**
     * 获取队列中的元素
     * @return
     */
    int getSize();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组队列&quot;&gt;数组队列&lt;/h3&gt;
&lt;p&gt;有了队列接口后，我们现在来通过自定义的动态数组实现队列的基本操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ArrayQueue&amp;lt;E&amp;gt; implements Queue&amp;lt;E&amp;gt;{

    private Array&amp;lt;E&amp;gt; array;


    //有参构造 --- 用户可以自定义队列的大小
    public ArrayQueue(int capacity) {
        this.array = new Array&amp;lt;E&amp;gt;(capacity);
    }

    //无参构造
    public ArrayQueue(){
        array = new Array&amp;lt;E&amp;gt;();
    }

    //入队操作 -- 相当于向动态数组末尾添加元素
    @Override
    public void enqueue(E e) {
        array.addLast(e);
    }

    //出队操作 --- 相当于删除动态数组的第一个元素
    @Override
    public E dequeue() {
        return array.removeFirst();
    }

    //获取队首的元素
    @Override
    public E getFront() {
        return array.getFirst();
    }

    //判断队列是否未空
    @Override
    public boolean isEmpty() {
        return array.isEmpty();
    }

    //返回队列中元素的个数
    @Override
    public int getSize() {
        return array.getSize();
    }

    //获取队列的容量大小
    public int getCapacity(){
        return array.getCapacity();
    }

    //重写toString() --- 自定义输出格式
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(&quot;Queue: &quot;); //队列
        builder.append(&quot;front[&quot;); //队首
        for (int i=0; i&amp;lt;array.getSize(); i++){
            builder.append(array.get(i));
            //如果不是最后一个元素，则在元素后面追加','
            if (i != array.getSize()-1 ){
                builder.append(&quot;,&quot;);
            }
        }
        builder.append(&quot;]trail&quot;); //队尾
        return builder.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组队列测试，我们可以住方法中写我们的测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {

        ArrayQueue&amp;lt;Integer&amp;gt; queue = new ArrayQueue&amp;lt;&amp;gt;();
        for(int i = 0 ; i &amp;lt; 10 ; i ++){
            queue.enqueue(i);
            System.out.println(queue);
            //当余数为2时，就从队列中删除一个元素
            if(i % 3 == 2){
                queue.dequeue();
                System.out.println(queue);
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码的运行结果分析如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328113033972-1353286509.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;数组队列的时间复杂度分析：&lt;br/&gt;入队：由于是向数组中最后一个元素末尾添加元素，不需要关心数组中元素的个数，所以时间复杂度为O(1);&lt;br/&gt;出队：由于出队操作，我们始终是删除的数组第一个元素，实际上是将待删除的元素之后的所有元素都想前移动一个位置，所以出队操作执行的时间与数组的中元素的个数呈线性关系，时间复杂度为O(n).&lt;/p&gt;
&lt;h3 id=&quot;循环队列&quot;&gt;循环队列&lt;/h3&gt;
&lt;p&gt;  由于数组队列的出队操作的时间复杂度为O(n),效率是比较低的，为了提升程序性能，降低时间复杂度，让出队操作的时间复杂度也是O(1)，我们引入了循环队列。&lt;br/&gt;循环队列的实现思路：&lt;br/&gt;  我们可以使用Java给我们提供的数组来表示队列，并且定义两个变量，一个变量（front）用来表示队首元素所在的索引，另一个变量（tail）表示队尾待添加元素的索引，这样在入队时，直接将元素天添加到队尾位置就可以了，即索引为trail的位置；在进行出队操作时，我们也可以通过front索引来获取队首元素，并进行删除，这样就可以实现队列的入队和出队操作的时间复杂度都为O(1)了。同时为了节约空间内存，删除元素后，释放的空间，我们在添加新的元素时，是可以放在这些位置上的，就像一个环一样，不过要留出一个空位置，用来表示这个队列为空，即当front == tai时表示为空。&lt;br/&gt; &lt;br/&gt;代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LoopQueue&amp;lt;E&amp;gt; implements Queue&amp;lt;E&amp;gt; {

    //注意这里的data类型为E[]，并不是Array
    private E[] data;
    //队首元素的索引
    private int front;
    //队尾待添加元素的索引
    private int tail;
    //队列中元素的个数
    private int size;

    //有参构造
    public LoopQueue(int capacity){
        //这里要比用户分配的空间多1，是为了处理循环队列为空和已满的问题
        this.data = (E[])new Object[capacity+1];
        this.front = 0;
        this.tail = 0;
        this.size = 0;
    }

    //无参构造
    public LoopQueue(){
        this(10);
    }

    //判断队列是否未空
    @Override
    public boolean isEmpty() {
        return this.front == this.tail;
    }

    //获取队列中元素的个数
    @Override
    public int getSize() {
        return this.size;
    }

    //获取队列的容量
    public int getCapacity() {
        //这这里需要减去1，因为这一个空间是辅助我们去实现循环队列入队出队操作的
        return this.data.length - 1;
    }

    //获取队首的元素
    @Override
    public E getFront() {
        //判断队列是否为空
        if (this.isEmpty()){
            throw new IllegalArgumentException(&quot;Queue is empty.&quot;);
        }
        return this.data[this.front];
    }

    //入队操作
    @Override
    public void enqueue(E e) {
        //判断队列是否已满
        if ((this.tail+1) % this.data.length == this.front){
            //若满了，则对该队列进行扩容
            this.resize(getCapacity() * 2);
        }
        //将该元素加入队尾
        this.data[this.tail] = e;
        //修改tail的值 -- 需要考虑到tail的值是(data.length-1)时
        this.tail = (this.tail+1) % data.length;
        //修改size的值
        this.size ++ ;
    }

    //出队操作
    @Override
    public E dequeue() {
        //判断队列是否为空
        if (this.isEmpty()){
            throw new IllegalArgumentException(&quot;Cannot dequeue from an empty queue.&quot;);
        }else {
            //获取队首的元素
            E e = this.data[this.front];
            //修改front的值
            this.front = (this.front + 1) % this.data.length;
            //修改size的值
            --this.size;
            //为了节约空间，当队列中的元素为当前队列的1/4时，进行缩容
            //要保证空间缩容为原来的1/2时，容量不为0
            if (this.size == this.getCapacity() / 4 &amp;amp;&amp;amp; this.getCapacity() / 2 != 0){
                this.resize(this.getCapacity()/2);
            }
            return e;
        }
    }

    //修改队列的空间大小
    private void resize(int capacity){
        //创建一个新数组
        E[] newData = (E[])(new Object[capacity+1]);
        //把原队列中的值放入新数组中
        for (int i=0; i&amp;lt;this.size; i++){
            //注意：要保持队列的数据结构特性,即需要保持数据的先进先出的数据格式
            //注意超出数组长度的情况 -- 通过对数组长度取余数来避免
            newData[i] = this.data[(i + this.front) % this.data.length ];
        }

        this.data = newData;
        this.front = 0;
        this.tail = this.size;
    }

    //重写toString() --- 自定义我们的输出格式
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        //获取当前 队列的元素个数和容量大小
        builder.append(String.format(&quot;Queue：size=%d, capacity=%d\n &quot;,this.getSize(),this.getCapacity()));
        //队首
        builder.append(&quot;front [&quot;);
        //取余数是为了防止下标越界
        for (int i = this.front;i != this.tail;i = (i+1)%this.data.length){
            builder.append(this.data[i]);
            if ((i+1) % this.data.length != tail){
                builder.append(&quot;,&quot;);
            }
        }
        builder.append(&quot;] tail&quot;);
        return builder.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在主方法中写我们的测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        Queue&amp;lt;Integer&amp;gt; queue = new LoopQueue();

        for(int i = 0; i &amp;lt; 10; ++i) {
            queue.enqueue(i);
            System.out.println(queue);
            if (i % 3 == 2) {
                queue.dequeue();
                System.out.println(queue);
            }
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码的运行结果分析：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328113919405-915966346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数组队列和循环队列的性能比较&quot;&gt;数组队列和循环队列的性能比较&lt;/h3&gt;
&lt;p&gt;  现在循环队列就已经实现了，前面说到循环队列的入队和出队操作的时间复杂度都为O(1)，而数组队列的出队操作的时间复杂度为O(n)，现在让我们来简单设计一个程序， 来比较数组队列和循环队列进行入队操作和出队操作所需要的时间吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class QueueCompare {

    //测试队列进行入队和出队操作所花费的时间
    public static Long testQueue(Queue&amp;lt;Integer&amp;gt; queue,int num){
        //获取系统的当前时间 --- 毫秒
        long startTime = System.currentTimeMillis();
        Random random = new Random();
        int i;
        for (i=0; i&amp;lt;num; i++){
            //在队列中添加一个整数范围内的随机数
            queue.enqueue(random.nextInt(Integer.MAX_VALUE));
        }
        for (i=0; i&amp;lt;num; i++){
            //出队操作
            queue.dequeue();
        }
        //获取进行入队和出队操作后的当前时间 --- 毫秒
        long endTime = System.currentTimeMillis();
        return endTime-startTime;
    }

    public static void main(String[] args) {
        //比较10万个整数的入队和出队操作所花费的时间
        int num = 100000;
        //数组队列耗时
        Queue&amp;lt;Integer&amp;gt; arrayQueue = new ArrayQueue&amp;lt;&amp;gt;();
        Long time1 = testQueue(arrayQueue, num);
        System.out.println(&quot;ArrayQueue, time: &quot; + time1 + &quot; ms&quot;);
        //循环队列耗时
        Queue&amp;lt;Integer&amp;gt; loopQueue = new LoopQueue&amp;lt;&amp;gt;();
        Long time2 = testQueue(loopQueue, num);
        System.out.println(&quot;loopQueue, time: &quot; + time2 + &quot; ms&quot;);

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我这台电脑上的运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328114251802-478829930.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们可以从结果中看到，运行结果差距还是很大的，所以这也体现了算法的重要性，以及O（n）和O（1）的区别。&lt;/p&gt;
&lt;h2 id=&quot;链表：最基础的动态数据结构&quot;&gt;链表：最基础的动态数据结构&lt;/h2&gt;
&lt;h3 id=&quot;链表介绍&quot;&gt;链表介绍&lt;/h3&gt;
&lt;p&gt;  链表也是一种线性结构，但与数组、栈和队列不同的是，链表是一种动态数据结构。虽然 我们创建的动态的数组也能进行扩容操作，但底层是依赖于静态数组的，其实质还是静态数据结构。&lt;br/&gt; &lt;br/&gt;为什么链表很重要？&lt;br/&gt; 1.链表是真正的动态数据结构，也是最简单的动态数据结构&lt;br/&gt; 2.链表可以帮助我们更深入的理解引用（即C语言种的指针）&lt;br/&gt; 3.帮助我们更深入的理解递归&lt;br/&gt; 4.辅助组成其他的数据结构&lt;br/&gt; &lt;br/&gt;  链表数据存储在“节点”中（Node）中，其优点是真正的动态，不需要处理固定容量的问题，但缺点正是数组的优点，就是丧失了随机访问能力。数组最好用于索引有语意的情况，它最大的优点是支持快速查询，即支持随机访问；而链表不适合用于索引有语意的情况，它最大的有点是动态的。&lt;br/&gt;  链表的最基本元素是节点，现在让我们自己手动来写一个最简单的链表类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LinkedList&amp;lt;E&amp;gt; {
    
    //链表的头结点
    private Node head;
    //链表的长度
    private int size;

    //以为链表是动态的数据结构，所以不需要分配容量
    public LinkedList(){
        this.head = null;
        this.size = 0;
    }

    // 获取链表中元素的个数
    public int getSize(){
        return this.size;
    }

    // 返回链表是否为空
    public boolean isEmpty(){
        return size == 0;
    }

    //设置成为内部类，是为了对用户屏蔽链表的内部实现
    private class Node{
        //存储这个节点的数据
        public E e;
        //指向下一个节点的引用
        public Node next;

        public Node(E e, Node next) {
            this.e = e;
            this.next = next;
        }

        public Node(E e){
            this(e, null);
        }

        public Node(){
            this(null, null);
        }

        //我们只需要输出这个节点的数据信息
        @Override
        public String toString() {
            return e.toString();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现链表的增删改查操作&quot;&gt;实现链表的增删改查操作&lt;/h3&gt;
&lt;p&gt;在自己手写链表底层实现的时候，有不用懂得最好用笔和纸，把这些节点的指向关系画出来，因为图形化的才是最直观的，也能帮助我们更好的理解。&lt;br/&gt;1.向链表中添加元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 在链表头添加新元素
    public void addFirst(E e){
//        Node node = new Node(e);
//        node.next = head;
//        head = node;
        //上面三行代码可以合并成一行代码
        head = new Node(e, head);
        size ++;
    }

    // 在链表的index(0-based)位置添加新元素e
    // 在链表中index并不是一个常用的操作，因为链表不支持随机访问
    public void add(int index,E  e){
        //判断index是否合法
        //注意：与数组不同的是，链表这里的index是可以等于size的，此时表示在链表末尾添加元素
        if (index &amp;lt;0 || index &amp;gt; size){
            throw new IllegalArgumentException(&quot;Add failed. Illegal index.&quot;);
        }
        //判断是否是向头节点中添加元素
        if (index == 0){
            this.addFirst(e);
        }else {
            Node prev = head;
            for (int i = 0;i&amp;lt; index-1 ;i++){
                prev = prev.next;
            }
//            Node node = new Node(e);
//            node.next = prev.next;
//            prev.next = node;
            //上面三行代码可以合并成一行代码
            prev.next = new Node(e,prev.next);
            size ++ ;
        }
    }

    //在链表末尾添加元素
    public void addLast(E e){
        this.add(size,e);
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们也可以通过为链表添加一个虚拟的头结点，来实现链表的添加方法，就不用对头结点进行单独处理，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //设置虚拟头结点
    private Node dummyHead;
    private int size;

    public LinkedList() {
        //虚拟头结点不存数据，始终为空
        this.dummyHead = new Node();
        this.size = 0;
    }

    // 获取链表中的元素个数
    public int getSize(){
        return size;
    }

    // 返回链表是否为空
    public boolean isEmpty(){
        return size == 0;
    }

    // 在链表的index(0-based)位置添加新的元素e
// 在链表中不是一个常用的操作，练习用：）
    public void add(int index,E e){
        //判断索引是否合法
        if (index&amp;lt;0 || index &amp;gt; size){
            throw new IllegalArgumentException(&quot;Add failed. Illegal index.&quot;);
        }
        Node prev = dummyHead;
        for (int i=0; i&amp;lt;index; i++){
            prev = prev.next;
        }
        prev.next = new Node(e,prev.next);
        size ++ ;
    }

    // 在链表头添加新的元素e
    public void addFirst(E e){
        this.add(0,e);
    }

    // 在链表末尾添加新的元素e
    public void addLast(E e){
        this.add(size,e);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.修改元素：下面我们使用为为链表添加一个虚拟头结点的方式，来进行修改链表中的元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 获得链表的第index(0-based)个位置的元素
    public E get(int index){
        //这里把index=size也排除是因为最后一个节点所指向的节点为空
        if (index &amp;lt; 0 || index &amp;gt;= size){
            throw new IllegalArgumentException(&quot;Get failed. Illegal index.&quot;);
        }
        Node curr = dummyHead.next;
        for (int i=0; i&amp;lt;index; i++){
            curr = curr.next;
        }
        return curr.e;
    }

    // 获得链表的第一个元素
    public E getFirst(){
        return get(0);
    }

    // 获得链表的最后一个元素
    public E getLast(){
        return get(size - 1);
    }

    // 查找链表中是否有元素e
    public boolean contains(E e){
        Node curr = dummyHead.next;
        while (curr != null){
            if (curr.e.equals(e)) return true;
            curr = curr.next;
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改链表中的指定位置的元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 修改链表的第index(0-based)个位置的元素为e
    public void set(int index,E e){
        if (index &amp;lt; 0 || index &amp;gt;= size){
            throw new IllegalArgumentException(&quot;Get failed. Illegal index.&quot;);
        }
        Node curr = dummyHead.next;
        for (int i=0; i&amp;lt;index; i++){
            curr = curr.next;
        }
        curr.e = e;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.删除元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   // 从链表中删除index(0-based)位置的元素, 返回删除的元素
    public E remove(int index){
        if (index &amp;lt; 0 || index &amp;gt;= size){
            throw new IllegalArgumentException(&quot;remove failed. Illegal index.&quot;);
        }

        Node prev = dummyHead;
        for (int i=0; i&amp;lt;index; i++){
            prev = prev.next;
        }

        //待删除的元素
        Node delNode = prev.next;
        prev.next = delNode.next;
        //方便GC机制回收
        delNode.next = null;
        size -- ;
        return delNode.e;
    }

    // 从链表中删除第一个元素, 返回删除的元素
    public E removeFirst(){
        return this.remove(0);
    }

    // 从链表中删除最后一个元素, 返回删除的元素
    public E removeLast(){
        return this.remove(size-1);
    }

    // 从链表中删除元素e
    public void removeElement(E e){
        Node prev = dummyHead;
        while ( prev.next != null ){
            //如果找到被删除的元素，就跳出循环
            if (prev.next.e.equals(e)) break;
            prev = prev.next;
        }

        if (prev.next != null){
           Node delNode = prev.next;
           prev.next = delNode.next;
           delNode.next = null;
           size -- ;
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写我们自定义链表的toString()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    public String toString(){
        StringBuilder res = new StringBuilder();

        Node cur = dummyHead.next;
        while(cur != null){
            res.append(cur + &quot;-&amp;gt;&quot;);
            cur = cur.next;
        }
        res.append(&quot;NULL&quot;);

        return res.toString();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对自定义链表的增删改查方法进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        LinkedList&amp;lt;Integer&amp;gt; linkedList = new LinkedList&amp;lt;&amp;gt;();
        for(int i = 0 ; i &amp;lt; 5 ; i ++){
            linkedList.addFirst(i);
            System.out.println(linkedList);
        }

        linkedList.add(2, 666);
        System.out.println(linkedList);

        linkedList.remove(2);
        System.out.println(linkedList);

        linkedList.removeFirst();
        System.out.println(linkedList);

        linkedList.removeLast();
        System.out.println(linkedList);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码的运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328123347152-748221700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过自定义链表实现栈&quot;&gt;通过自定义链表实现栈&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class LinkedStack&amp;lt;E&amp;gt; implements Stack&amp;lt;E&amp;gt; {
    //基于自定义链表实现栈结构
    private LinkedList&amp;lt;E&amp;gt; linkedList = new LinkedList&amp;lt;&amp;gt;();

    @Override
    public int getSize() {
        return this.linkedList.getSize();
    }

    @Override
    public boolean isEmpty() {
        return this.linkedList.isEmpty();
    }

    @Override
    public void push(E e) {
        this.linkedList.addFirst(e);
    }

    @Override
    public E pop() {
        return this.linkedList.removeFirst();
    }

    @Override
    public E peek() {
        return this.linkedList.getFirst();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(&quot;Stack: top &quot;);
        res.append(this.linkedList);
        return res.toString();
    }
    
    //测试自定义栈
    public static void main(String[] args) {
        LinkedListStack&amp;lt;Integer&amp;gt; stack = new LinkedListStack();

        for(int i = 0; i &amp;lt; 5; ++i) {
            stack.push(i);
            System.out.println(stack);
        }

        stack.pop();
        System.out.println(stack);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过自定义链表实现队列&quot;&gt;通过自定义链表实现队列&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class LinkedListQueue&amp;lt;E&amp;gt; implements Queue&amp;lt;E&amp;gt; {

    //head指向头结点,tail指向下次添加元素的位置
    private Node head, tail;
    private int size;

    //不写也可以，和系统自动生成的无参构造器作用效果相同
    public LinkedListQueue(){
        head = null;
        tail = null;
        size = 0;
    }

    //入队 -- 只能从队尾添加元素
    @Override
    public void enqueue(E e) {
        if (tail == null){
            tail = new Node(e);
            head = tail;
        }else {
            tail.next = new Node(e);
            tail = tail.next;
        }
        size ++ ;
    }

    //出队操作 -- 只能从队首删除元素
    @Override
    public E dequeue() {
        if (isEmpty()) {
            throw new IllegalArgumentException(&quot;Cannot dequeue from an empty queue.&quot;);
        }
            
        Node delNode = head;
        head = head.next;
        delNode.next = null;
        if (head == null) tail=null;
        size -- ;
        return delNode.e;
    }

    //获取队首的元素
    @Override
    public E getFront() {
        if(isEmpty())
            throw new IllegalArgumentException(&quot;Queue is empty.&quot;);
        return head.e;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(&quot;Queue: front &quot;);
        Node curr = head;
        while (curr != null){
            res.append(curr.e+&quot;-&amp;gt;&quot;);
            curr = curr.next;
        }
        res.append(&quot;NULL tail&quot;);
        return res.toString();
    }

    private class Node{
        public E e;
        public Node next;

        public Node(E e, Node next){
            this.e = e;
            this.next = next;
        }

        public Node(E e){
            this(e, null);
        }

        public Node(){
            this(null, null);
        }

        @Override
        public String toString(){
            return e.toString();
        }
    }


    public static void main(String[] args){

        LinkedListQueue&amp;lt;Integer&amp;gt; queue = new LinkedListQueue&amp;lt;&amp;gt;();
        for(int i = 0 ; i &amp;lt; 10 ; i ++){
            queue.enqueue(i);
            System.out.println(queue);

            if(i % 3 == 2){
                queue.dequeue();
                System.out.println(queue);
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328150341356-1309716765.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;现在让我们来看一个leetcode上关于链表的简单例题，就是力扣上的203号题，题目描述如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202003/1975191-20200328150902121-1872723449.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //leetcode上的题：删除给定链表中和指定元素相等的所有元素
    public ListNode removeElements(ListNode head, int val) {
        //当给定的链表为空时，直接返回
        if (head == null) {
            return head;
        }else {
            ListNode prev;
            //当头节点的值和val相等时 --- 相当于删除头结点
            while (head != null &amp;amp;&amp;amp; head.val == val){
                prev = head;
                head = head.next;
                prev.next = null;
            }
            prev = head;

            while (prev.next != null){
                if (prev.next.val == val){
                    ListNode delNode = prev.next;
                    prev.next = delNode.next;
                    delNode.next = null;
                }else {
                    prev = prev.next;
                }
            }
        }
        return head;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;递归&quot;&gt;递归&lt;/h3&gt;
&lt;p&gt;我们在使用递归时，要注意递归函数的“宏观语意”，递归函数就是一个函数，完成一个功能。可以理解为把待解决的复杂问题转化为求解最基本的问题。&lt;br/&gt;例1：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //计算arr[i...n)这个区间内所有数字的和 -- 使用递归
    private static int sum(int[] arr,int i){
        //把复杂为题化为求解最基本的问题
        if (i == arr.length) return 0;
        //将sum(arr,I+1) 递归方法理解为为可以解决求arr[(i+1)...n)这个区间内所有数字的和
        return arr[i] + sum(arr,i+1);
    }

    public static int sum(int[] arr){
        return sum(arr, 0);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例2：使用递归解决删除链表中元素的问题&lt;br/&gt;思路：由于链表具有天然递归性，Node可以表示一个节点，也可以表示一个链表，所以我们可以把给定的链表分为头结点和head.next,调用递归方法判断head.next中师傅含有待删除元素，然后返回已经删除该元素的链表，在判断头结点中元素是否和待删除元素相等，若相等则返回head.next,否则返回head,实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public ListNode removeElements(ListNode head, int val) {
        if (head == null) return head;
        ListNode res = removeElements(head.next, val);
        if (head.val == val) {
            return res;
        }else {
            head.next = res;
            return head;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码也可以使用三目运算符来简化我们的代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public ListNode removeElements(ListNode head, int val) {
        if (head == null) return head;
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;递归在动态数据结构中是很常用的，因为很多问题使用递归比非递归更容易解决，在后面学习树的过程中，我们也将频繁使用递归，数据结构的线性结构学习笔记就记录到这里了。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Mar 2020 00:34:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>[TOC] 前言 本篇博客主要是记录手写这些这数据结构的底层实现，加深对线性结构的理解，实现自己的一个小型数据结构库，也会进行简单的时间复杂度分析，对不同的实现进行比较和优化，即侧重于代码实现。由于数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/12586248.html</dc:identifier>
</item>
<item>
<title>多线程之旅（Thread） - 晨曦001</title>
<link>http://www.cnblogs.com/chenxi001/p/12590724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxi001/p/12590724.html</guid>
<description>&lt;p&gt;      在上篇文章中我们已经知道了多线程是什么了，那么它到底可以干嘛呢？这里特别声明一个前面的委托没看的同学可以到上上上篇博文查看，因为多线程要经常使用到&lt;a href=&quot;https://www.cnblogs.com/chenxi001/p/12483709.html#4521375&quot; target=&quot;_blank&quot;&gt;委托&lt;/a&gt;。&lt;a href=&quot;https://gitee.com/D_C_L/multithreading.git&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、异步、同步&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      1.同步（在计算的理解总是要你措不及防，同步当线程做完一件事情之后，才会执行后续动作），同步方法慢，只有一个线程执行，异步方法快，因为多个线程一起干活，但是两者并不是线性增长，当我们的异步线程占有的资源越来越多了，会导致资源可能不够，其次线程过多CPU也是需要管理成本的，所以不是越多越好。&lt;/p&gt;
&lt;p&gt;      2.异步（可以同时执行多个任务，在同样的时间，执行不同的任务），同步方法卡界面（UI）,因为我们的主线程（UI）忙于计算造成了堵塞了。异步方法不卡界面，计算任务交给了子线程完成。winform中体现的玲玲精致。（你品，你细品），web 可以异步的处理一起其他的任务,比如给用户发邮箱（我们的BS结构的，每次访问都是一个子线程，当我们的代码写的比较糟糕，是不是加载比较慢呢哈哈）。异步多线程无序，执行的先后无序，执行的时间不确定，结束也不确定，所以我们很难通过执行时间和先后顺序控制，异步的执行顺序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、初识Thread&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;memberListTable&quot;&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr&gt;&lt;th&gt;属性名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CurrentContext&lt;/td&gt;
&lt;td&gt;获取线程正在其中执行的当前上下文。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CurrentThread&lt;/td&gt;
&lt;td&gt;获取当前正在运行的线程。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;3&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;ExecutionContext&lt;/td&gt;
&lt;td&gt;获取一个 ExecutionContext 对象，该对象包含有关当前线程的各种上下文的信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsAlive&lt;/td&gt;
&lt;td&gt;获取一个值，该值指示当前线程的执行状态。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsBackground&lt;/td&gt;
&lt;td&gt;获取或设置一个值，该值指示某个线程是否为后台线程。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsThreadPoolThread&lt;/td&gt;
&lt;td&gt;获取一个值，该值指示线程是否属于托管线程池。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ManagedThreadId&lt;/td&gt;
&lt;td&gt;获取当前托管线程的唯一标识符。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Name&lt;/td&gt;
&lt;td&gt;获取或设置线程的名称。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Priority&lt;/td&gt;
&lt;td&gt;获取或设置一个值，该值指示线程的调度优先级。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ThreadState&lt;/td&gt;
&lt;td&gt;获取一个值，该值包含当前线程的状态。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Thread 中包括了多个方法来控制线程的创建、挂起、停止、销毁，后面的例子中会经常使用。&lt;/p&gt;
&lt;table class=&quot;memberListTable&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;30%&quot;/&gt;&lt;col width=&quot;70%&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Abort()　　　　&lt;/td&gt;
&lt;td&gt;终止本线程。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GetDomain()&lt;/td&gt;
&lt;td&gt;返回当前线程正在其中运行的当前域。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GetDomainId()&lt;/td&gt;
&lt;td&gt;返回当前线程正在其中运行的当前域Id。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Interrupt()&lt;/td&gt;
&lt;td&gt;中断处于 WaitSleepJoin 线程状态的线程。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Join()&lt;/td&gt;
&lt;td&gt;已重载。 阻塞调用线程，直到某个线程终止时为止。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Resume()&lt;/td&gt;
&lt;td&gt;继续运行已挂起的线程。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Start()　　&lt;/td&gt;
&lt;td&gt;执行本线程。&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Suspend()&lt;/td&gt;
&lt;td&gt;挂起当前线程，如果当前线程已属于挂起状态则此不起作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Sleep()　　&lt;/td&gt;
&lt;td&gt;把正在运行的线程挂起一段时间。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;      1.Thread是我们.NET 1.0 给我们提供的多线程类，可以创建，和控制多线程，Thread类构造函数为接受ThreadStart和ParameterizedThreadStart类型的委托参数，下面有请代码神君。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cf68def2-3ee3-45b9-8d37-6221fd2fe243')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_cf68def2-3ee3-45b9-8d37-6221fd2fe243&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cf68def2-3ee3-45b9-8d37-6221fd2fe243&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cf68def2-3ee3-45b9-8d37-6221fd2fe243',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cf68def2-3ee3-45b9-8d37-6221fd2fe243&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用Thread 创建多线程
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化创建线程 无参无返回值&lt;/span&gt;
            Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是多线程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
            thread.Start();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建5个线程1&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个之所以创建一个k，后面线程不安全会说到&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; k =&lt;span&gt; i;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是一个有参数无返回值多线程&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt; Thread(x =&amp;gt;&lt;span&gt; Running(Convert.ToInt32(x))).Start(k);
            }
            Console.Read();
        }

 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 一个执行需要长时间的任务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Running(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;**********************************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行开始啦&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; s);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取当前执行的线程ID：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Thread.CurrentThread.ManagedThreadId.ToString());
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000000&lt;/span&gt;; i++&lt;span&gt;)
            {
                j&lt;/span&gt;++&lt;span&gt;;
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行结束啦&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; s);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202003/1808958-20200329065156033-978731602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、渐入佳境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1.运行上面的代码，可以看到线程的无序性，虽然我们的0最先开始执行的，但是不是第一个结束的，这个是因为我们每个线程执行的时间的不确定性。这里也要特别说明为什么Thread构造函数传递的是ThreadStart和ParameterizedThreadStart类型的委托参数，为什么不是Action ，Func，答案就是.NET 1.0的时候还没有Action 、Func。ThreadStart委托是一个无参无返回值上代码中我们创建了，ParameterizedThreadStart委托是一个有参数无返回值，但是我们可以看到我们的参数是一个object类型，是一个不安全的参数（当时泛型也没有出来）当然为了防止这问题，我们也是想到了方法，那就是我们可以通过一个泛型类，帮我们限制参数类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b973ceda-e31c-4e23-b909-a74dafe1dc40')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_b973ceda-e31c-4e23-b909-a74dafe1dc40&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b973ceda-e31c-4e23-b909-a74dafe1dc40&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b973ceda-e31c-4e23-b909-a74dafe1dc40',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b973ceda-e31c-4e23-b909-a74dafe1dc40&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 防止参数不安全
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show5()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们创建一个泛型类，限制我们的类型&lt;/span&gt;
            MyThread&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; mythread = &lt;span&gt;new&lt;/span&gt; MyThread&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Thread_child&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将我们的方法传递,进去&lt;/span&gt;
            Thread th3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(mythread.ThreadChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;            th3.Start();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建一个泛型类
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;class&lt;/span&gt; MyThread&amp;lt;T&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T data;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyThread(T data)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
            }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadChild()
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child Thread Start! Result:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, data);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　2.我们在上面还提供了其他的方法，但是这些方法已经不建议使用了，现在已经弃用了，因为我们无法精确地控制线程的开启与暂停，当我们将线程挂起的时候，同时也会挂起线程使用的资源，会导致死锁，不建议使用。将线程销毁也不建议    不一定及时/有些动作发出收不回来。（这里我使用的是.net Core 3.1 执行直接报错了哈哈）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('304d7eef-bd8a-41f7-a2ad-344bf3e01c2b')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_304d7eef-bd8a-41f7-a2ad-344bf3e01c2b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_304d7eef-bd8a-41f7-a2ad-344bf3e01c2b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('304d7eef-bd8a-41f7-a2ad-344bf3e01c2b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_304d7eef-bd8a-41f7-a2ad-344bf3e01c2b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用Thread 线程挂起、唤醒线程、销毁，方式是抛异常、取消Abort异常
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show1()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Thread 线程&lt;/span&gt;
            Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt;
            {
                Running();
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启线程&lt;/span&gt;
&lt;span&gt;            thread.Start();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是线程挂起
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;thread.Suspend();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒线程
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;thread.Resume();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上面的两个方法，现在已经弃用了，因为我们无法精确地控制线程的开启与暂停
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当我们将线程挂起的时候，同时也会挂起线程使用的资源，会导致死锁，不建议使用&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将线程销毁
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也不建议    不一定及时/有些动作发出收不回来&lt;/span&gt;
&lt;span&gt;                thread.Abort();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态方法将线程异常取消继续工作&lt;/span&gt;
&lt;span&gt;                Thread.ResetAbort();
            }
            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202003/1808958-20200329063947692-1669242074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　3.线程优先级，当然我们的线程是一个无序的，也有控制线程执行的权重,但是这个优先级不是绝对的，因为线程的执行顺序还是看我们的CPU爸爸的，但是我们可以利用Priority属性做线程的权重执行，使用也很简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4ce37a1b-9f7f-4347-945f-cf2cb3d32901')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_4ce37a1b-9f7f-4347-945f-cf2cb3d32901&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4ce37a1b-9f7f-4347-945f-cf2cb3d32901&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4ce37a1b-9f7f-4347-945f-cf2cb3d32901',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4ce37a1b-9f7f-4347-945f-cf2cb3d32901&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用Thread 线程的优先级（但是执行还是看CPU，可以做优先级，但是不是绝对优先）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show3()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Thread 线程&lt;/span&gt;
            Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt;
            {
                Running();
            });
            thread.Start();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;thread.Priority属性可以设置线程的优先级关系&lt;/span&gt;
            thread.Priority =&lt;span&gt; ThreadPriority.Highest;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行完啦啦啦啦啦啦啦啦啦啦啦拉拉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　4.前台线程、后台线程（这个字面意思，还是和我们的理解是不一样的）我们设置IsBackground控制线程是否（前/后）台线程。默认是前台线程，启动之后一定要完成任务的，阻止进程退出。指定后台线程：随着进程退出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202003/1808958-20200329064945814-1905348198.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;384&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 三、多线程起飞&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1、异步回调&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.我们的Thread没有给我提供异步回调的功能，没办法需要自己造轮子了，我们可以先想一下回调的需求是什么，需求分析：当我们的线程任务执行完之后需要之后某些方法。我们细品一下，我们要执行完之后，在执行一个人任务，那就是同步执行异步方法了吧。我们在子线程中怎么同步执行呢？下面的代码就实现了回调功能不管我们执行多少次回调总会在任务后面执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bc663f09-cc1a-4390-8393-28c7ae35c49e')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_bc663f09-cc1a-4390-8393-28c7ae35c49e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bc663f09-cc1a-4390-8393-28c7ae35c49e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bc663f09-cc1a-4390-8393-28c7ae35c49e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bc663f09-cc1a-4390-8393-28c7ae35c49e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步回调执行
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show6() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个任务委托&lt;/span&gt;
            ThreadStart threadStart = () =&amp;gt;&lt;span&gt; {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是任务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个回调执行的委托&lt;/span&gt;
            Action action = () =&amp;gt;&lt;span&gt; {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;哈哈，我就是你们的回调方法哈，记得双击么么哒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*********************************************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            };
            ThreadWithCallback(threadStart, action);
            Console.ReadLine();
        }

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 回调封装 无返回值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;start&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;callback&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;回调&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadWithCallback(ThreadStart start, Action callback)
        {
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt;
            {
                start.Invoke();
                callback.Invoke();
            });
            thread.Start();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202003/1808958-20200329070715671-1414312189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;2、返回参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.当然我们使用线程需要返回参数，但是我们的Thread没有给我们提供返回值的委托和方法，这个要莫子搞罗？当然我们先分析需求，我们要获取返回值是不是要等线程执行之后呢？好的线程执行我们可以使用Join堵塞线程等它执行完毕，但是我们要怎么获取返回值呢？对了我们可以创建一个变量，我们的线程给变量赋值吗？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6e275a80-1290-40d6-9908-14d0574c3aa5')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_6e275a80-1290-40d6-9908-14d0574c3aa5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6e275a80-1290-40d6-9908-14d0574c3aa5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6e275a80-1290-40d6-9908-14d0574c3aa5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6e275a80-1290-40d6-9908-14d0574c3aa5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步返回值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show7()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个委托&lt;/span&gt;
            Func&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; func = () =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是返回值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取执行结果&lt;/span&gt;
&lt;span&gt;            Console.WriteLine(ThreadWithReturn(func).Invoke());
            Console.ReadLine();
        }

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 有返回值封装（请根据本案例自行封装回调）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;返回值类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;func&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要子线程执行的方法&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Func&amp;lt;T&amp;gt; ThreadWithReturn&amp;lt;T&amp;gt;(Func&amp;lt;T&amp;gt;&lt;span&gt; func)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个泛型，限制我们的类型&lt;/span&gt;
            T t = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
            ThreadStart newStart &lt;/span&gt;= () =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程给变量赋值&lt;/span&gt;
                t =&lt;span&gt; func.Invoke();
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线程&lt;/span&gt;
            Thread thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(newStart);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行线程&lt;/span&gt;
&lt;span&gt;            thread.Start();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个委托 无参有返回值，执行委托会发生执行线程等待堵塞
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当线程执行完之后，也就是说线程已经给变量t赋值了，我们就返回t&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Func&amp;lt;T&amp;gt;(() =&amp;gt;&lt;span&gt;
            {
                thread.Join();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202003/1808958-20200329071922748-355851100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 四、Thread总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1.大家是不是觉得多线程很酷呢？哈哈我刚刚学的时候也是激动的心颤抖的手。当然文章中我们介绍了很多API的使用，大家可以动手试试，API的使用是小事，最重要的是我们的思路，到我们看到回调封装和返回值封装，我们都是利用了多线程的一些特性，来完成的这些功能拓展的。我们宏观的看多线程感觉很恐怖，但是在我们做回调函数的时候是不是感觉有一种微观看法，线程执行的内部也是同步的执行哪些方法的。好了今天就写到这里昨天晚上9点多就睡了，早起撸个文章美滋滋。当然多线程还有讲完的，才说道了.NET 1.0哈哈，后续的文章也会写出来。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Mar 2020 23:34:00 +0000</pubDate>
<dc:creator>晨曦001</dc:creator>
<og:description>在上篇文章中我们已经知道了多线程是什么了，那么它到底可以干嘛呢？这里特别声明一个前面的委托没看的同学可以到上上上篇博文查看，因为多线程要经常使用到委托。源码 一、异步、同步 1.同步（在计算的理解总是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenxi001/p/12590724.html</dc:identifier>
</item>
<item>
<title>Golang 实现 Redis(3): 实现内存数据库 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/12590718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/12590718.html</guid>
<description>&lt;p&gt;本文是 golang 实现 redis 系列的第三篇, 主要介绍如何实现内存KV数据库。本文完整源代码在作者Github: &lt;a href=&quot;https://github.com/HDT3213/godis/blob/master/src/db&quot;&gt;HDT3213/godis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HDT3213/godis/blob/master/src/db/db.go&quot;&gt;db.go&lt;/a&gt; 是内存数据库的主要源文件，db.Exec 方法会从协议解析器中获得命令参数并调用相应的处理函数进行处理。&lt;/p&gt;
&lt;p&gt;目录:&lt;/p&gt;

&lt;p&gt;KV 内存数据库的核心是并发安全的哈希表，常见的设计有几种：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;sync.map: golang 官方提供的并发哈希表, 性能优秀但结构复杂不便于扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;juc.ConcurrentHashMap: java 的并发哈希表采用分段锁实现。在进行扩容时访问哈希表线程都将协助进行 rehash 操作，在 rehash 结束前所有的读写操作都会阻塞。因为缓存数据库中键值对数量巨大且对读写操作响应时间要求较高，使用juc的策略是不合适的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;memcached hashtable: 在后台线程进行 rehash 操作时，主线程会判断要访问的哈希槽是否已被 rehash 从而决定操作 old_hashtable 还是操作 primary_hashtable。&lt;br/&gt;这种策略使主线程和rehash线程之间的竞争限制在哈希槽内，最小化rehash操作对读写操作的影响，这是最理想的实现方式。但由于作者才疏学浅无法使用 golang 实现该策略故忍痛放弃（主要原因在于 golang 没有 volatile 关键字, 保证线程可见性的操作非常复杂），欢迎各位读者讨论。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文采用在 sync.map 发布前 golang 社区广泛使用的分段锁策略。我们将key分散到固定数量的 shard 中避免 rehash 操作。shard 是有锁保护的 map, 当 shard 进行 rehash 时会阻塞shard内的读写，但不会对其他 shard 造成影响。&lt;/p&gt;
&lt;p&gt;这种策略简单可靠易于实现，但由于需要两次 hash 性能略差。这个 dict 完整源码在&lt;a href=&quot;https://github.com/HDT3213/godis/blob/master/src/datastruct/dict/concurrent.go&quot;&gt;Github&lt;/a&gt; 可以独立使用（虽然也没有什么用。。。）。&lt;/p&gt;
&lt;p&gt;定义数据结构:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;type ConcurrentDict struct {
    table []*Shard
    count int32
}

type Shard struct {
    m     map[string]interface{}
    mutex sync.RWMutex
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构造时初始化 shard，这个操作相对比较耗时:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func computeCapacity(param int) (size int) {
        if param &amp;lt;= 16 {
                return 16
        }
        n := param - 1
        n |= n &amp;gt;&amp;gt; 1
        n |= n &amp;gt;&amp;gt; 2
        n |= n &amp;gt;&amp;gt; 4
        n |= n &amp;gt;&amp;gt; 8
        n |= n &amp;gt;&amp;gt; 16
        if n &amp;lt; 0 {
                return math.MaxInt32
        } else {
                return int(n + 1)
        }
}

func MakeConcurrent(shardCount int) *ConcurrentDict {
    shardCount = computeCapacity(shardCount)
    table := make([]*Shard, shardCount)
    for i := 0; i &amp;lt; shardCount; i++ {
        table[i] = &amp;amp;Shard{
            m: make(map[string]interface{}),
        }
    }
    d := &amp;amp;ConcurrentDict{
        count: 0,
        table: table,
    }
    return d
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈希算法选择FNV算法:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;const prime32 = uint32(16777619)

func fnv32(key string) uint32 {
    hash := uint32(2166136261)
    for i := 0; i &amp;lt; len(key); i++ {
        hash *= prime32
        hash ^= uint32(key[i])
    }
    return hash
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定位shard, 当n为2的整数幂时 h % n == (n - 1) &amp;amp; h&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (dict *ConcurrentDict) spread(hashCode uint32) uint32 {
        if dict == nil {
                panic(&quot;dict is nil&quot;)
        }
        tableSize := uint32(len(dict.table))
        return (tableSize - 1) &amp;amp; uint32(hashCode)
}

func (dict *ConcurrentDict) getShard(index uint32) *Shard {
        if dict == nil {
                panic(&quot;dict is nil&quot;)
        }
        return dict.table[index]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Get 和 Put 方法实现:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (dict *ConcurrentDict) Get(key string) (val interface{}, exists bool) {
        if dict == nil {
                panic(&quot;dict is nil&quot;)
        }
        hashCode := fnv32(key)
        index := dict.spread(hashCode)
        shard := dict.getShard(index)
        shard.mutex.RLock()
        defer shard.mutex.RUnlock()
        val, exists = shard.m[key]
        return
}

func (dict *ConcurrentDict) Len() int {
        if dict == nil {
                panic(&quot;dict is nil&quot;)
        }
        return int(atomic.LoadInt32(&amp;amp;dict.count))
}

// return the number of new inserted key-value
func (dict *ConcurrentDict) Put(key string, val interface{}) (result int) {
        if dict == nil {
                panic(&quot;dict is nil&quot;)
        }
        hashCode := fnv32(key)
        index := dict.spread(hashCode)
        shard := dict.getShard(index)
        shard.mutex.Lock()
        defer shard.mutex.Unlock()

        if _, ok := shard.m[key]; ok {
                shard.m[key] = val
                return 0
        } else {
                shard.m[key] = val
                dict.addCount()
                return 1
        }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上一节实现的ConcurrentMap 可以保证对单个 key 操作的并发安全性，但是仍然无法满足需求:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;MSETNX 命令当且仅当所有给定键都不存在时所有给定键设置值, 因此我们需要锁定所有给定的键直到完成所有键的检查和设置&lt;/li&gt;
&lt;li&gt;LPOP 命令移除列表中最后一个元素后需要移除该键值对，因此我们锁定该键直到移除元素并移除空列表&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此我们需要实现 db.Locker 用于锁定一个或一组 key 并在我们需要的时候释放锁。&lt;/p&gt;
&lt;p&gt;实现 db.Locker 最直接的想法是使用一个 &lt;code&gt;map[string]*sync.RWMutex&lt;/code&gt;, 加锁过程分为两步: 初始化对应的锁 -&amp;gt; 加锁， 解锁过程也分为两步: 解锁 -&amp;gt; 释放对应的锁。那么存在一个无法解决的并发问题:&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;时间&lt;/th&gt;
&lt;th&gt;协程A&lt;/th&gt;
&lt;th&gt;协程B&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;locker[&quot;a&quot;].Unlock()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;locker[&quot;a&quot;] = &amp;amp;sync.RWMutex{}&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;delete(locker[&quot;a&quot;])&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;locker[&quot;a&quot;].Lock()&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于 t3 时协程B释放了锁，t4 时协程A试图加锁会失败。&lt;/p&gt;
&lt;p&gt;若我们在解锁时不释放锁就可以避免该异常的发生，但是每个曾经使用过的锁都无法释放从而造成严重的内存泄露。&lt;/p&gt;
&lt;p&gt;我们注意到哈希表的长度远少于可能的键的数量，反过来说多个键可以共用一个哈希槽。若我们不为单个键加锁而是为它所在的哈希槽加锁，因为哈希槽的数量非常少即使不释放锁也不会占用太多内存。&lt;/p&gt;
&lt;p&gt;作者根据这种思想实现了 &lt;a href=&quot;https://github.com/HDT3213/godis/blob/master/src/datastruct/lock/lock_map.go&quot;&gt;LockerMap&lt;/a&gt; 来解决并发控制问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;type Locks struct {
    table []*sync.RWMutex
}

func Make(tableSize int) *Locks {
    table := make([]*sync.RWMutex, tableSize)
    for i := 0; i &amp;lt; tableSize; i++ {
        table[i] = &amp;amp;sync.RWMutex{}
    }
    return &amp;amp;Locks{
        table: table,
    }
}

func (locks *Locks)Lock(key string) {
    index := locks.spread(fnv32(key))
    mu := locks.table[index]
    mu.Lock()
}

func (locks *Locks)UnLock(key string) {
    index := locks.spread(fnv32(key))
    mu := locks.table[index]
    mu.Unlock()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈希算法已经在Dict一节介绍过不再赘述。&lt;/p&gt;
&lt;p&gt;在锁定多个key时需要注意，若协程A持有键a的锁试图获得键b的锁，此时协程B持有键b的锁试图获得键a的锁则会形成死锁。&lt;/p&gt;
&lt;p&gt;解决方法是所有协程都按照相同顺序加锁，若两个协程都想获得键a和键b的锁，那么必须先获取键a的锁后获取键b的锁，这样就可以避免循环等待。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (locks *Locks)Locks(keys ...string) {
    keySlice := make(sort.StringSlice, len(keys))
    copy(keySlice, keys)
    sort.Sort(keySlice)
    for _, key := range keySlice {
        locks.Lock(key)
    }
}

func (locks *Locks)RLocks(keys ...string) {
    keySlice := make(sort.StringSlice, len(keys))
    copy(keySlice, keys)
    sort.Sort(keySlice)
    for _, key := range keySlice {
        locks.RLock(key)
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Time To Live (TTL) 的实现方式非常简单，其核心是 string -&amp;gt; time 哈希表。&lt;/p&gt;
&lt;p&gt;当访问某个 key 时会检查是否过期，并删除过期key:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (db *DB) Get(key string) (*DataEntity, bool) {
        db.stopWorld.RLock()
        defer db.stopWorld.RUnlock()

        raw, ok := db.Data.Get(key)
        if !ok {
                return nil, false
        }
        if db.IsExpired(key) {
                return nil, false
        }
        entity, _ := raw.(*DataEntity)
        return entity, true
}

func (db *DB) IsExpired(key string) bool {
        rawExpireTime, ok := db.TTLMap.Get(key)
        if !ok {
                return false
        }
        expireTime, _ := rawExpireTime.(time.Time)
        expired := time.Now().After(expireTime)
        if expired {
                db.Remove(key)
        }
        return expired
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时会定时的检查过期key并删除:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (db *DB) CleanExpired() {
        now := time.Now()
        toRemove := &amp;amp;List.LinkedList{}
        db.TTLMap.ForEach(func(key string, val interface{}) bool {
                expireTime, _ := val.(time.Time)
                if now.After(expireTime) {
                        // expired
                        db.Data.Remove(key)
                        toRemove.Add(key)
                }
                return true
        })
        toRemove.ForEach(func(i int, val interface{}) bool {
                key, _ := val.(string)
                db.TTLMap.Remove(key)
                return true
        })
}

func (db *DB) TimerTask() {
        ticker := time.NewTicker(db.interval)
        go func() {
                for range ticker.C {
                        db.CleanExpired()
                }
        }()
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 28 Mar 2020 22:46:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>Golang 实现 Redis 之三： 内存KV数据库实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Finley/p/12590718.html</dc:identifier>
</item>
<item>
<title>ML-Agents（三）3DBall例子 - 煦阳</title>
<link>http://www.cnblogs.com/gentlesunshine/p/12590516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gentlesunshine/p/12590516.html</guid>
<description>&lt;p&gt;前一周忙着公司的考试，都没有怎么学新的，今天补上~&lt;br/&gt;之后的记录，我准备先只研究官方的示例，主要是把研究过程中的疑惑和想法记下来。首先我先补充一下如何利用GPU进行训练，结合（一）中的安装方法，需要CUDA v10.0，cuDNN v7.6.5 for CUDA v10.0，对应Tensorflow的版本是2.0.1。&lt;/p&gt;
&lt;h2 id=&quot;一、利用gpu进行训练&quot;&gt;一、利用GPU进行训练&lt;/h2&gt;
&lt;p&gt;前置工作在文章（一）中都有，原先的环境可以保留。现在可以拉一个新的ml-agents源码，然后修改&lt;code&gt;ml-agents&lt;/code&gt;文件下的&lt;code&gt;setup.py&lt;/code&gt;中如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004305918-2041525782.png&quot; alt=&quot;image-20200319233335183&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来是&lt;code&gt;&quot;tensorflow&amp;gt;=1.7,&amp;lt;2.1&quot;&lt;/code&gt;，现在修改为&lt;code&gt;&quot;tensorflow-gpu&amp;gt;=1.7,&amp;lt;2.1&quot;&lt;/code&gt;，然后再在Anaconda中新建一个环境，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004305192-2003581869.png&quot; alt=&quot;image-20200319234037666&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建好后在命令行中重新安装环境（别忘记cd到新的ml-agents源码），分别输入：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install -e ml-agents-envs -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install -e ml-agents -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就是分别安装两个环境，可以发现他会自动下载&lt;code&gt;tensorflow_gpu-2.0.1&lt;/code&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004304425-1500806339.jpg&quot; alt=&quot;GPU&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好后，在Unity对应的Agent脚本上，也需要将&lt;code&gt;Inference Device&lt;/code&gt;勾选为&lt;code&gt;GPU&lt;/code&gt;，然后按以前的方法开始训练，就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004303332-428982462.png&quot; alt=&quot;image-20200319233940196&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、3dball&quot;&gt;二、3DBall&lt;/h2&gt;
&lt;p&gt;官方示例中，3Dball是一个比较简单的例子，主要运用了reinforcement learning（强化学习）。就是小球在平台上，萌版平台要控制自己绕x、z轴旋转，从而保持小球在自己头上不掉下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004302776-1038401911.gif&quot; alt=&quot;3dBall&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现根据官方文档翻译一下：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置：一个平衡球任务，agent需要保持小球在其脑袋上的平衡&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;目标：Agent必须尽可能长时间地保持球在头顶的平衡&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Agent设置：环境中包含12个想同类型的agent，全部使用同样的行为参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Agent奖励设置：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行为参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;矢量观察空间：8个变量，包括agent方块的旋转角度（两个值，x、z轴方向），球和方块之间的相对位置关系（Vector3），球上刚体的速度（Vector3）&lt;/li&gt;
&lt;li&gt;矢量动作空间：类型为&lt;code&gt;Continuous&lt;/code&gt;，&lt;code&gt;Size&lt;/code&gt;为2，分别控制绕x轴旋转、绕z轴旋转&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Float属性：三个&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;scale（比例）：小球的比例，默认为1，推荐最小值为0.2，最大值为5&lt;/li&gt;
&lt;li&gt;gravity（重力）：重力加速度，默认为9.81，推荐最小值4，最大值为105&lt;/li&gt;
&lt;li&gt;mass（质量）：小球的质量，默认为1，推荐最小值为0.1，最大值为20&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基准平均奖励：100&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OK，上面是借鉴官方文档，随意翻译了一下，大概可以了解3DBall主要用途和一些主要参数，里面的Float属性我这里不是很明白，在代码中是用在&lt;code&gt;Agent.InitializeAgent()&lt;/code&gt;中的&lt;code&gt;SetResetParameters()&lt;/code&gt;，这个方法顾名思义应该是对Agent进行初始化的操作。也许在这里，我们可以任意修改小球的比例、质量、重力加速度来改变小球在不同的情况下，训练的效果如何吧。&lt;/p&gt;
&lt;h2 id=&quot;3dball代码分析&quot;&gt;3DBall代码分析&lt;/h2&gt;
&lt;p&gt;看到目前为止，ml-agents其中的精华就在agent的脚本如何设置了，我们下面来分析一下&lt;code&gt;Ball3DAgent&lt;/code&gt;代码。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class Ball3DAgent : Agent
{
    [Header(&quot;Specific to Ball3D&quot;)]
    public GameObject ball;
    Rigidbody m_BallRb;
    IFloatProperties m_ResetParams;

    public override void InitializeAgent()
    {
        m_BallRb = ball.GetComponent&amp;lt;Rigidbody&amp;gt;();
        m_ResetParams = Academy.Instance.FloatProperties;
        SetResetParameters();
    }

    public void SetBall()
    {
        //从Academy中获取小球的属性（质量、比例）
        m_BallRb.mass = m_ResetParams.GetPropertyWithDefault(&quot;mass&quot;, 1.0f);
        var scale = m_ResetParams.GetPropertyWithDefault(&quot;scale&quot;, 1.0f);
        ball.transform.localScale = new Vector3(scale, scale, scale);
    }

    public void SetResetParameters()
    {
        SetBall();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里初始化应用了&lt;code&gt;InitializeAgent()&lt;/code&gt;方法，这里获取了小球的刚体，并且利用&lt;code&gt;SetBall()&lt;/code&gt;来设置了小球的质量和比例，这里的的&lt;em&gt;&lt;strong&gt;m_ResetParams&lt;/strong&gt;&lt;/em&gt;变量是Academy的FloatProperties变量，这里的变量好像是会作为环境参数传递给Python，具体的用途我也还没研究清楚，姑且先看做是初始化小球的属性。&lt;/p&gt;
&lt;h3 id=&quot;环境观察值&quot;&gt;环境观察值&lt;/h3&gt;
&lt;p&gt;直接上源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override void CollectObservations(VectorSensor sensor)
{
    //平台绕Z轴旋转值
    sensor.AddObservation(gameObject.transform.rotation.z);
    //平台绕X轴旋转值
    sensor.AddObservation(gameObject.transform.rotation.x);
    //小球与平台的相对位置
    sensor.AddObservation(ball.transform.position -gameObject.transform.position);
    //小球刚体的速度
    sensor.AddObservation(m_BallRb.velocity);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上一共运用了8个观察值，注意Vector3类型的变量算是3个观察值（x,y,z）。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;Ball3DHardAgent&lt;/strong&gt;项目里，与&lt;strong&gt;Ball3DAgent&lt;/strong&gt;的区别就在于这里少了小球刚体速度的收集，从而导致前者在其他设置都相同的情况下，训练效果不佳，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004300760-514021057.gif&quot; alt=&quot;3dHardBall&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到平台的抖动很大，就是因为没有考虑到小球的速度影响而导致训练结果天差地别，因此在用ML-Agents的时候，&lt;strong&gt;需要严谨的考虑环境的观测项&lt;/strong&gt;，可能由于一个观测项的增加或删除，就导致最终学习结果的好坏，这里我也是慢慢才学习，这就是我为什么要先研究官方的示例，到时候最坏也可以照猫画虎。&lt;/p&gt;
&lt;h3 id=&quot;agent动作反馈&quot;&gt;Agent动作反馈&lt;/h3&gt;
&lt;p&gt;这里是Agent的核心实现，观测值通过Agent收集到Brain处，Brain再通过外部Python训练环境反馈动作，再沿相同的路线返回到Agent的&lt;code&gt;AgentAction(float[] vectorAction)&lt;/code&gt;上（这里不知道我的想法对不对），具体的代码如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override void AgentAction(float[] vectorAction)
{
    //控制平台绕Z轴、X轴旋转的值
    //用Mathf.Clamp()将响应的动作值限制到-2到2
    var actionZ = 2f * Mathf.Clamp(vectorAction[0], -1f, 1f);
    var actionX = 2f * Mathf.Clamp(vectorAction[1], -1f, 1f);

    //平台绕Z轴旋转响应
    if ((gameObject.transform.rotation.z &amp;lt; 0.25f &amp;amp;&amp;amp; actionZ &amp;gt; 0f) ||
            (gameObject.transform.rotation.z &amp;gt; -0.25f &amp;amp;&amp;amp; actionZ &amp;lt; 0f))
    {
        gameObject.transform.Rotate(new Vector3(0, 0, 1), actionZ);
    }
        //平台绕X轴旋转响应
        if ((gameObject.transform.rotation.x &amp;lt; 0.25f &amp;amp;&amp;amp; actionX &amp;gt; 0f) ||
            (gameObject.transform.rotation.x &amp;gt; -0.25f &amp;amp;&amp;amp; actionX &amp;lt; 0f))
    {
        gameObject.transform.Rotate(new Vector3(1, 0, 0), actionX);
    }
    //gameObject.transform.Rotate(new Vector3(0, 0, 1), actionZ);
    //gameObject.transform.Rotate(new Vector3(1, 0, 0), actionX);
    
    //当小球在平台上，掉落或飞出平台，分别进行奖励或惩罚
    if ((ball.transform.position.y - gameObject.transform.position.y) &amp;lt; -2f ||
        Mathf.Abs(ball.transform.position.x - gameObject.transform.position.x) &amp;gt; 3f ||
        Mathf.Abs(ball.transform.position.z - gameObject.transform.position.z) &amp;gt; 3f)
    {
        SetReward(-1f);//惩罚1
        Done();//此次训练结束并重新开始，会调用AgentReset()
    }
    else
    {
        SetReward(0.1f);//在平台上的时候，每次动作都奖励0.1
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先是平台对于旋转的响应，我又将两个if的条件去掉训练了一下，发现平台训练过程中比较不稳，抖动较大，因为只要一来值就让平台旋转，可能这里会造成平台一直在调整姿态的过程中，而源代码中，以绕Z轴为例，只有在平台Z轴旋转值&amp;lt;0.25f且actionZ&amp;gt;0、或平台Z轴旋转值&amp;gt;0.25f且actionZ&amp;lt;0时才对平台的姿态进行动作，这样就相当于设置了一个缓冲区间，不会让平台不停调整姿态，而是根据小球情况来适当调整姿态。&lt;/p&gt;
&lt;p&gt;这里附上两次训练的tensorboard。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004257635-1172426529.png&quot; alt=&quot;image-20200329000940392&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红色的是不加if条件的，蓝色的是官方加if的。其实从数据来看，大的趋势都差不多，不过我从训练现象来看，确实官方加if之后训练过程比较稳定。&lt;/p&gt;
&lt;p&gt;后面的奖励代码中，有三个条件判断小球应该受到惩罚。&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;(ball.transform.position.y - gameObject.transform.position.y) &amp;lt; -2f&lt;/p&gt;
&lt;p&gt;小球与平台y方向上的差值小于2，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004256994-1336985776.png&quot; alt=&quot;image-20200329001534471&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以看出是小球掉落到平台下边，其实大多数情况是其他两种情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;Mathf.Abs(ball.transform.position.x - gameObject.transform.position.x) &amp;gt; 3f&lt;/p&gt;
&lt;p&gt;和Mathf.Abs(ball.transform.position.z - gameObject.transform.position.z) &amp;gt; 3f&lt;/p&gt;
&lt;p&gt;这两种放一起将，先来看看小球的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004255953-1055367914.png&quot; alt=&quot;image-20200329001749169&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时小球的x，z值都是3，可以看出小球刚好在x轴方向或者z方向滚出了平台边缘。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，上面三种情况只要发生一种就对小球Agent做出-1惩罚，同时调用&lt;code&gt;Done()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;agent复位&quot;&gt;Agent复位&lt;/h3&gt;
&lt;p&gt;复位就比较简单了，来看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override void AgentReset()
{
        //复位平台旋转角度
    gameObject.transform.rotation = new Quaternion(0f, 0f, 0f, 0f);
    //令平台随机绕x轴旋转-10~10度
    gameObject.transform.Rotate(new Vector3(1, 0, 0), Random.Range(-10f, 10f));
    //令平台随机绕z轴旋转-10~10度
    gameObject.transform.Rotate(new Vector3(0, 0, 1), Random.Range(-10f, 10f));
    //小球刚体速度变为0
    m_BallRb.velocity = new Vector3(0f, 0f, 0f);
    //小球在y（相对平台高度）为4的地方，同时随机x、z值出现
    ball.transform.position = new Vector3(Random.Range(-1.5f, 1.5f), 4f, Random.Range(-1.5f, 1.5f))
        + gameObject.transform.position;
    //Agent重置时，同时重置参数，这里是指小球的质量和比例，其实我觉得这里没必要，估计之后别的项目有用
    SetResetParameters();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的代码比较简单，注释能看明白即可。&lt;/p&gt;
&lt;h3 id=&quot;agent手动设置&quot;&gt;Agent手动设置&lt;/h3&gt;
&lt;p&gt;这里主要是当训练模式为&lt;code&gt;Heuristic Only&lt;/code&gt;时调用，具体设置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1659542/202003/1659542-20200329004255434-872654300.png&quot; alt=&quot;image-20200329002653210&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override float[] Heuristic()
{
    var action = new float[2];

    action[0] = -Input.GetAxis(&quot;Horizontal&quot;);
    action[1] = Input.GetAxis(&quot;Vertical&quot;);
    return action;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的代码相当于我们输入来控制动作向量空间的值，其实就是action[]数组，我们令action[0]控制平台绕x轴的旋转，action[1]控制平台绕z轴的旋转。&lt;/p&gt;
&lt;p&gt;可以试一下，其实要保持小球在平台上还有点难度。&lt;/p&gt;
&lt;p&gt;至此第一个例子就研究到这，有什么问题欢迎大家一起探讨。&lt;/p&gt;
&lt;p&gt;写文不易~因此做以下申明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.博客中标注原创的文章，版权归原作者 煦阳（本博博主） 所有；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.未经原作者允许不得转载本文内容，否则将视为侵权；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.转载或者引用本文内容请注明来源及原作者；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.对于不遵守此声明或者其他违法使用本文内容者，本人依法保留追究权等。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Mar 2020 16:51:00 +0000</pubDate>
<dc:creator>煦阳</dc:creator>
<og:description>﻿ ML Agents（三）3DBall例子 前一周忙着公司的考试，都没有怎么学新的，今天补上~ 之后的记录，我准备先只研究官方的示例，主要是把研究过程中的疑惑和想法记下来。首先我先补充一下如何利用G</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gentlesunshine/p/12590516.html</dc:identifier>
</item>
<item>
<title>拿 C# 搞函数式编程 - 3 - hez2010</title>
<link>http://www.cnblogs.com/hez2010/p/12590389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hez2010/p/12590389.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天和某个人聊天聊到了 C# 的 LINQ，发现我认识的 LINQ 似乎和大多数人认识的 LINQ 不太一样，怎么个不一样法呢？其实 LINQ 也可以用来搞函数式编程。&lt;/p&gt;
&lt;p&gt;当然，并不是说写几个 &lt;code&gt;lambda&lt;/code&gt; 和用用像 Java 那样的 &lt;code&gt;stream&lt;/code&gt; 之类的就算叫做 LINQ 了，LINQ 其实是一个另外的一些东西。&lt;/p&gt;
&lt;h2 id=&quot;linq&quot;&gt;LINQ&lt;/h2&gt;
&lt;p&gt;在 C# 中，相信大家都见过如下的 LINQ 写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;IEnumerable&amp;lt;int&amp;gt; EvenNumberFilter(IEnumerable&amp;lt;int&amp;gt; list)
{
    return from c in list where c &amp;amp; 1 == 0 select c;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码借助 LINQ 的语法实现了对一个列表中的偶数的筛选。&lt;/p&gt;
&lt;p&gt;LINQ 只是一个用于方便对集合进行操作的工具而已，如果我们如果想让我们自己的类型支持 LINQ 语法，那么我们需要让我们的类型实现 &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;，然后就可以这么用了。。。&lt;/p&gt;
&lt;p&gt;哦，原来是这样的吗？那我全都懂了。。。。。。&lt;/p&gt;
&lt;p&gt;？？？哦，我的老天，当然不是！&lt;/p&gt;
&lt;p&gt;其实 LINQ 和 &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; 完全没有关系！LINQ 只是一组扩展方法而已，它主要由以下方法组成：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;方法说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;Where&lt;/td&gt;
&lt;td&gt;数据筛选&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Select/SelectMany&lt;/td&gt;
&lt;td&gt;数据投影&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Join/GroupJoin&lt;/td&gt;
&lt;td&gt;数据联接&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;OrderBy/ThenBy/OrderByDescending/ThenByDescending&lt;/td&gt;
&lt;td&gt;数据排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GroupBy&lt;/td&gt;
&lt;td&gt;数据分组&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;......&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以上方法对应 LINQ 关键字：&lt;code&gt;where&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt;, &lt;code&gt;orderby&lt;/code&gt;, &lt;code&gt;group&lt;/code&gt;...&lt;/p&gt;
&lt;p&gt;在编译器编译 C# 代码时，会将 LINQ 语法转换为扩展方法调用的语法，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;from c in list where c &amp;gt; 5 select c;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会被编译成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;list.Where(c =&amp;gt; c &amp;gt; 5).Select(c =&amp;gt; c);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;from x1 in list1 join x2 in list2 on x1.k equals x2.k into g select g.u;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会被编译成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;list1.GroupJoin(list2, x1 =&amp;gt; x1.k, x2 =&amp;gt; x2.k, (x1, g) =&amp;gt; g.u);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;from x in list orderby x.k1, x.k2, x.k3;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会被编译成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;list.OrderBy(x =&amp;gt; x.k1).ThenBy(x =&amp;gt; x.k2).ThenBy(x =&amp;gt; x.k3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再有：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;from c in list1
from d in list2
select c + d;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会被编译成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;list1.SelectMany(c =&amp;gt; list2, (c, d) =&amp;gt; c + d);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;停停停！&lt;/p&gt;
&lt;p&gt;此外，编译器在编译的时候总是会先将 LINQ 语法翻译为方法调用后再编译，那么，只要有对应名字的方法，不就意味着可以用 LINQ 语法了（逃&lt;/p&gt;
&lt;p&gt;那么你看这个 &lt;code&gt;SelectMany&lt;/code&gt; 是不是。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1590449/202003/1590449-20200329000822036-790619986.jpg&quot; alt=&quot;jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;selectmany-is-monad&quot;&gt;&lt;code&gt;SelectMany&lt;/code&gt; is &lt;code&gt;Monad&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;哦我的上帝，你瞧瞧这个可怜的 &lt;code&gt;SelectMany&lt;/code&gt;，这难道不是 &lt;code&gt;Monad&lt;/code&gt; 需要的 &lt;code&gt;bind&lt;/code&gt; 函数？&lt;/p&gt;
&lt;p&gt;事情逐渐变得有趣了起来。&lt;/p&gt;
&lt;p&gt;我们继承上一篇的精神，再写一次 &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;maybet&quot;&gt;&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;首先，我们写一个抽象类 &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;首先我们给它加一个 &lt;code&gt;Select&lt;/code&gt; 方法用于选择 &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt; 中的数据，如果是 &lt;code&gt;T&lt;/code&gt;，那么返回一个 &lt;code&gt;Just&amp;lt;T&amp;gt;&lt;/code&gt;，如果是 &lt;code&gt;Nothing&amp;lt;T&amp;gt;&lt;/code&gt;，那么返回一个 &lt;code&gt;Nothing&amp;lt;T&amp;gt;&lt;/code&gt;。相当于我们的 &lt;code&gt;returns&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public abstract class Maybe&amp;lt;T&amp;gt;
{
    public abstract Maybe&amp;lt;U&amp;gt; Select&amp;lt;U&amp;gt;(Func&amp;lt;T, Maybe&amp;lt;U&amp;gt;&amp;gt; f);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们实现我们的 &lt;code&gt;Just&lt;/code&gt; 和 &lt;code&gt;Nothing&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Just&amp;lt;T&amp;gt; : Maybe&amp;lt;T&amp;gt;
{
    private readonly T value;
    public Just(T value) { this.value = value; }

    public override Maybe&amp;lt;U&amp;gt; Select&amp;lt;U&amp;gt;(Func&amp;lt;T, Maybe&amp;lt;U&amp;gt;&amp;gt; f) =&amp;gt; f(value);
    public override string ToString() =&amp;gt; $&quot;Just {value}&quot;;
}

public class Nothing&amp;lt;T&amp;gt; : Maybe&amp;lt;T&amp;gt;
{
    public override Maybe&amp;lt;U&amp;gt; Select&amp;lt;U&amp;gt;(Func&amp;lt;T, Maybe&amp;lt;U&amp;gt;&amp;gt; _) =&amp;gt; new Nothing&amp;lt;U&amp;gt;();
    public override string ToString() =&amp;gt; &quot;Nothing&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们给 &lt;code&gt;Maybe&lt;/code&gt; 实现 &lt;code&gt;bind&lt;/code&gt; —— 即给 &lt;code&gt;Maybe&lt;/code&gt; 加上一个叫做 &lt;code&gt;SelectMany&lt;/code&gt; 的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public abstract class Maybe&amp;lt;T&amp;gt;
{
    public abstract Maybe&amp;lt;U&amp;gt; Select&amp;lt;U&amp;gt;(Func&amp;lt;T, Maybe&amp;lt;U&amp;gt;&amp;gt; f);

    public Maybe&amp;lt;V&amp;gt; SelectMany&amp;lt;U, V&amp;gt;(Func&amp;lt;T, Maybe&amp;lt;U&amp;gt;&amp;gt; k, Func&amp;lt;T, U, V&amp;gt; s)
        =&amp;gt; Select(x =&amp;gt; k(x).Select(y =&amp;gt; new Just&amp;lt;V&amp;gt;(s(x, y))));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt; 实现完了！什么，就这？？那么怎么用呢？激动人心的时刻来了！&lt;/p&gt;
&lt;p&gt;首先，我们创建几个 &lt;code&gt;Maybe&amp;lt;int&amp;gt;&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var x = new Just&amp;lt;int&amp;gt;(3);
var y = new Just&amp;lt;int&amp;gt;(7);
var z = new Nothing&amp;lt;int&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们分别利用 LINQ 计算 &lt;code&gt;x + y&lt;/code&gt;, &lt;code&gt;x + z&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var u = from x0 in x from y0 in y select x0 + y0;
var v = from x0 in x from z0 in z select x0 + z0;

Console.WriteLine(u);
Console.WriteLine(v);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Just 10
Nothing
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完美！上面的 LINQ 被编译成了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var u = x.SelectMany(_ =&amp;gt; y, (x0, y0) =&amp;gt; x0 + y0);
var v = x.SelectMany(_ =&amp;gt; z, (x0, z0) =&amp;gt; x0 + z0);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，函数 &lt;code&gt;k&lt;/code&gt; 为 &lt;code&gt;int -&amp;gt; Maybe&amp;lt;int&amp;gt;&lt;/code&gt;，而函数 &lt;code&gt;s&lt;/code&gt; 为&lt;code&gt;(int, int) -&amp;gt; int&lt;/code&gt;，是一个加法函数。&lt;/p&gt;
&lt;p&gt;函数 &lt;code&gt;k&lt;/code&gt; 的参数我们并不关心，它用作一个 &lt;code&gt;selector&lt;/code&gt;，我们只需要让它产生一个 &lt;code&gt;Maybe&amp;lt;int&amp;gt;&lt;/code&gt;，然后利用函数 &lt;code&gt;s&lt;/code&gt; 将两个 &lt;code&gt;int&lt;/code&gt; 的值做加法运算，并把结果包装到一个 &lt;code&gt;Just&amp;lt;int&amp;gt;&lt;/code&gt; 里面即可。&lt;/p&gt;
&lt;p&gt;这个过程中，如果有任何一方产生了 &lt;code&gt;Nothing&lt;/code&gt;，则后续运算结果永远都是 &lt;code&gt;Nothing&lt;/code&gt;，因为 &lt;code&gt;Nothing.Select(...)&lt;/code&gt; 还是 &lt;code&gt;Nothing&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一点扩展&quot;&gt;一点扩展&lt;/h2&gt;
&lt;p&gt;我们再给这个 &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt; 加一个 &lt;code&gt;Where&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public abstract class Maybe&amp;lt;T&amp;gt;
{
    public abstract Maybe&amp;lt;U&amp;gt; Select&amp;lt;U&amp;gt;(Func&amp;lt;T, Maybe&amp;lt;U&amp;gt;&amp;gt; f);

    public Maybe&amp;lt;V&amp;gt; SelectMany&amp;lt;U, V&amp;gt;(Func&amp;lt;T, Maybe&amp;lt;U&amp;gt;&amp;gt; k, Func&amp;lt;T, U, V&amp;gt; s)
        =&amp;gt; Select(x =&amp;gt; k(x).Select(y =&amp;gt; new Just&amp;lt;V&amp;gt;(s(x, y))));

    public Maybe&amp;lt;U&amp;gt; Where(Func&amp;lt;Maybe&amp;lt;T&amp;gt;, bool&amp;gt; f) =&amp;gt; f(this) ? this : new Nothing&amp;lt;T&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们就可以玩：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var just = from c in x where true select c;
var nothing = from c in x where false select c;

Console.WriteLine(just);
Console.WriteLine(nothing);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当满足条件的时候返回 &lt;code&gt;Just&lt;/code&gt;，否则返回 &lt;code&gt;Nothing&lt;/code&gt;。上述代码将输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Just 3
Nothing
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有内味了（逃&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;该系列的后续文章将按揭编写，如果 C# 争气一点，把 Discriminated Unions、Higher Kinded Generics 和 Type Classes 特性加上了，我们再继续。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Mar 2020 16:10:00 +0000</pubDate>
<dc:creator>hez2010</dc:creator>
<og:description>LINQ + SelectMany = Monad!</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hez2010/p/12590389.html</dc:identifier>
</item>
<item>
<title>【NLP面试QA】预训练模型 - 西多士NLP</title>
<link>http://www.cnblogs.com/sandwichnlp/p/12590380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sandwichnlp/p/12590380.html</guid>
<description>&lt;h4 id=&quot;自回归语言模型与自编码语言&quot;&gt;自回归语言模型与自编码语言&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;自回归语言模型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过给定文本的上文，对下一个字进行预测&lt;/li&gt;
&lt;li&gt;优点：对文本序列联合概率的密度估计进行建模，使得该模型更适用于一些生成类的NLP任务，因为这些任务在生成内容的时候就是从左到右的，这和自回归的模式天然匹配。&lt;/li&gt;
&lt;li&gt;缺点：联合概率是按照文本序列从左至右进行计算的，因此无法提取下文信息；&lt;/li&gt;
&lt;li&gt;代表模型：ELMo/GPT1.0/GPT2.0/XLNet(XLNet 做了些改进使得能够提取到下文特征)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自编码语言模型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其通过随机 mask 掉一些单词，在训练过程中根据上下文对这些单词进行预测，使预测概率最大化。其本质为去噪自编码模型，加入的 [MASK] 即为噪声，模型对 [MASK] 进行预测即为去噪。&lt;/li&gt;
&lt;li&gt;优点：能够利用上下文信息得到双向特征表示&lt;/li&gt;
&lt;li&gt;缺点：其引入了独立性假设，即每个 [MASK] 之间是相互独立的。这实际上是语言模型的有偏估计，另外，由于预训练中 [MASK] 的存在，使得模型预训练阶段的数据与微调阶段的不匹配，使其难以直接用于生成任务。&lt;/li&gt;
&lt;li&gt;代表模型：Bert/Roberta/ERNIE&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;bert&quot;&gt;Bert&lt;/h4&gt;
&lt;h5 id=&quot;bert-中的预训练任务&quot;&gt;Bert 中的预训练任务&lt;/h5&gt;
&lt;h6 id=&quot;masked-language-model&quot;&gt;Masked Language Model&lt;/h6&gt;
&lt;p&gt;在预训练任务中，15%的 Word Piece 会被 mask，这15%的 Word Piece 中，80%的时候会直接替换为 [Mask] ，10%的时候将其替换为其它任意单词，10%的时候会保留原始Token&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有 100% mask 的原因
&lt;ul&gt;&lt;li&gt;如果句子中的某个Token100%都会被mask掉，那么在fine-tuning的时候模型就会有一些没有见过的单词&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;加入 10% 随机 token 的原因
&lt;ul&gt;&lt;li&gt;Transformer 要保持对每个输入token的分布式表征，否则模型就会记住这个 [mask] 是token ’hairy‘&lt;/li&gt;
&lt;li&gt;另外编码器不知道哪些词需要预测的，哪些词是错误的，因此被迫需要学习每一个 token 的表示向量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;另外，每个 batchsize 只有 15% 的单词被 mask 的原因，是因为性能开销的问题，双向编码器比单项编码器训练要更慢&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;next-sentence-prediction&quot;&gt;Next Sentence Prediction&lt;/h6&gt;
&lt;p&gt;仅仅一个MLM任务是不足以让 BERT 解决阅读理解等句子关系判断任务的，因此添加了额外的一个预训练任务，即 Next Sequence Prediction。&lt;/p&gt;
&lt;p&gt;具体任务即为一个句子关系判断任务，即判断句子B是否是句子A的下文，如果是的话输出’IsNext‘，否则输出’NotNext‘。&lt;/p&gt;
&lt;p&gt;训练数据的生成方式是从平行语料中随机抽取的连续两句话，其中50%保留抽取的两句话，它们符合IsNext关系，另外50%的第二句话是随机从预料中提取的，它们的关系是NotNext的。这个关系保存在图4中的[CLS]符号中&lt;/p&gt;
&lt;p&gt;但实际上这个任务是过于简单了的，对于模型的预训练并没有太大的帮助，在 Roberta 的模型中将其去掉了&lt;/p&gt;
&lt;h5 id=&quot;bert-的-embedding&quot;&gt;Bert 的 Embedding&lt;/h5&gt;
&lt;p&gt;BERT的输入表征由三种Embedding求和而成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Token Embeddings：即传统的词向量层，每个输入样本的首字符需要设置为 [CLS]，可以用于之后的分类任务，若有两个不同的句子，需要用 [SEP] 分隔，且最后一个字符需要用 [SEP] 表示终止&lt;/li&gt;
&lt;li&gt;Segment Embeddings：为 &lt;span class=&quot;math inline&quot;&gt;\([0, 1]\)&lt;/span&gt; 序列，用来在 NSP 任务中区别两个句子，便于做句子关系判断任务&lt;/li&gt;
&lt;li&gt;Position Embeddings：与 Transformer 中的位置向量不同，BERT 中的位置向量是直接训练出来的&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;bert-wwm&quot;&gt;BERT-wwm&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Whole Word Masking 即全词 Mask，打破了传统 Bert 的独立性假设，即每个 [MASK] 之间是相互独立的。这使得同一个词中不同字符的预测的上下文语境是相同的，加强同一个词不同字符之间的相关性。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;roberta-与-bert-的区别&quot;&gt;Roberta 与 Bert 的区别&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;训练参数经过了仔细的挑参，训练数据更大，训练 Batch Size 更大&lt;/li&gt;
&lt;li&gt;认为 Next Sentence Prediction 任务没有太大帮助，将 NSP loss 去掉，输入改为从一个文档中连续抽取句子，当到达文档末尾时，加一个分隔符再抽样下一个文档的句子。&lt;/li&gt;
&lt;li&gt;Bert 的语料在预处理的时候就会被 Mask，在训练阶段保持不变；而 Roberta 中改为动态的 Mask，使得每次读取到的数据都不一样（具体是将数据复制10遍，统一随机 Mask）&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;ernie-与-bert-的区别&quot;&gt;ERNIE 与 Bert 的区别&lt;/h5&gt;
&lt;p&gt;由于 Bert 仅对单个的字符进行 Mask 很容易使得模型提取到字搭配的低层次的语义特征，而对于短语和实体层次的语义信息抽取能力较弱。因此将外部知识引入到预训练任务中，主要有三个层次的预训练任务&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Basic-Level Masking： 跟bert一样对单字进行mask，很难学习到高层次的语义信息；&lt;/li&gt;
&lt;li&gt;Phrase-Level Masking： 输入仍然是单字级别的，mask连续短语；&lt;/li&gt;
&lt;li&gt;Entity-Level Masking： 首先进行实体识别，然后将识别出的实体进行mask。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200329000207475-1329279944.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;xlnet&quot;&gt;XLNet&lt;/h4&gt;
&lt;p&gt;XLNet 针对自回归语言模型单向编码以及 BERT 类自编码语言模型的有偏估计的缺点，提出了一种广义自回归语言预训练方法。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200329000239175-37250506.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;排列语言模型permutation-language-model，plm&quot;&gt;排列语言模型(Permutation Language Model，PLM)&lt;/h5&gt;
&lt;p&gt;通过引入一个排列语言模型，希望语言模型用自回归的方法从左往右预测下一个字符的时候，不仅要包含上文信息，同时也要能够提取到对应字符的下文信息，且不需要引入Mask符号。&lt;/p&gt;
&lt;p&gt;首先将句子进行重排列，重排列后的末尾几个字就能够看见其之后的一些词，根据能够看到的对象进行相应的 Mask 即可。在实现上是通过对 Attention 矩阵增加掩码来选择哪些词能够被看见哪些词不能够被看见的。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200329000334250-1092039643.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;双流注意力机制（two-stream-self-attention）&quot;&gt;双流注意力机制（Two-Stream Self-Attention）&lt;/h5&gt;
&lt;p&gt;由于我们有多层的 Transformer，需要在最后一层预测最末尾的几个字，比如最大长度为 512，最后一层只需要预测最后 10 个词，我们需要所有字的信息都能传输到最后一层，但又希望最后在预测某个字的时候看不到这个字的信息，因此引入了双流注意力机制&lt;/p&gt;
&lt;p&gt;Query Stream 的掩码矩阵中仅传输位置信息，用于表明预测顺序是什么样的；Content Stream 与传统的 Transformer 一致，包括内容信息和位置信息，确保所有的字信息都能传输到最后一层。个 Attention Stream 的区别仅在于掩码是否能看见自己，以及输入一个是仅有位置信息，另一个是包括位置和内容信息。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200329000416156-1422696578.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;部分预测（partial-prediction）&quot;&gt;部分预测（Partial Prediction）&lt;/h5&gt;
&lt;p&gt;如果重排列之后对所有字都进行预测的话模型难以收敛（可能是前几个字看到的字的个数太少），计算量也大。因此仅对最后 15% 的字进行预测&lt;/p&gt;
&lt;h5 id=&quot;transformer-xl&quot;&gt;Transformer-XL&lt;/h5&gt;
&lt;p&gt;传统的 Transformer 的输入长度限制在 512，更长的文本信息模型是学不到的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;片段递归机制（segment-level recurrence mechanism）：指的是当前时刻的隐藏信息在计算过程中，将通过循环递归的方式利用上一时刻较浅层的隐藏状态（上一时刻的隐藏状态均存储到一个临时存储空间中），这使得每次的计算将利用更大长度的上下文信息，大大增加了捕获长距离信息的能力。&lt;/li&gt;
&lt;li&gt;相对位置编码（Relative Positional Encodings）：采用了片段递归机制之后，不同片段的位置信息是一样的然后叠加在了一起，这是不合适的，因此提出了相对位置编码的方式来替代绝对位置编码&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200329000453260-175972095.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;albert&quot;&gt;ALBERT&lt;/h4&gt;
&lt;p&gt;ALBERT 贡献在于，其提出了两种模型参数缩减的技术，使得在减小模型重量的同时，模型性能不会受到太大的影响。&lt;/p&gt;
&lt;h5 id=&quot;对embedding因式分解&quot;&gt;对Embedding因式分解&lt;/h5&gt;
&lt;p&gt;采用了一个因式分解的方式对 Embedding 层的矩阵进行压缩。简单来说，就是先将 one-hot 映射到一个低维空间 &lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;，然后再将其从低维空间映射到高维空间 &lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;，即参数量的变化为 &lt;span class=&quot;math inline&quot;&gt;\(O(V \times H) =&amp;gt; O(V \times E + E \times H)\)&lt;/span&gt;，且论文也用实验证明，Embedding的参数缩减对整个模型的性能并没有太大的影响&lt;/p&gt;
&lt;h5 id=&quot;跨层参数共享&quot;&gt;跨层参数共享&lt;/h5&gt;
&lt;p&gt;多层 Transformer 共享参数，提高参数利用率，使得参数量得到有效的减少。（参数共享的对象为 Transformer 中的 feed-forward layer 参数和 self-attention 的参数）&lt;/p&gt;
&lt;h5 id=&quot;句间连贯性损失&quot;&gt;句间连贯性损失&lt;/h5&gt;
&lt;p&gt;ALBERT 针对预训练任务中的 NSP 任务进行改进，即句间连贯性判断。NSP 任务仅需判断两个文段是否是一个主题即可，该任务太简单了。句间连贯性判断任务需要判断两个文段的顺序是否颠倒，强迫模型去学习文段的语意，这相比于 NSP 任务更加巧妙。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该系列文章是个人为面试做的知识储备，如有出错，请大家指正，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 28 Mar 2020 16:07:00 +0000</pubDate>
<dc:creator>西多士NLP</dc:creator>
<og:description>[TOC] 自回归语言模型与自编码语言 自回归语言模型 通过给定文本的上文，对下一个字进行预测 优点：对文本序列联合概率的密度估计进行建模，使得该模型更适用于一些生成类的NLP任务，因为这些任务在生成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sandwichnlp/p/12590380.html</dc:identifier>
</item>
<item>
<title>【2020-03-28】Dubbo源码杂谈 - 淡墨痕</title>
<link>http://www.cnblogs.com/zzq6032010/p/12588538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzq6032010/p/12588538.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    本周空闲时间利用了百分之六七十的样子。主要将Dubbo官网文档和本地代码debug结合起来学习，基本看完了服务导出、服务引入以及服务调用的过程，暂未涉及路由、字典等功能。下面对这一周的收获进行一下总结梳理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、基于事件驱动的服务导出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   提起服务导出，不要被它的名字误导了，通俗点说就是服务的暴露和注册。服务的暴露是指将服务端的端口开放，等待消费端来连接。服务的注册即将服务信息注册到注册中心。针对服务暴露和注册的具体流程，可参见博主之前的一篇文章  &lt;a href=&quot;https://www.cnblogs.com/zzq6032010/p/11275478.html&quot;&gt;https://www.cnblogs.com/zzq6032010/p/11275478.html&lt;/a&gt; ，讲述的比较详细，暂不赘述。&lt;/p&gt;
&lt;p&gt;   注重提一下的是Dubbo启动服务暴露和注册的时机，是采用的&lt;strong&gt;事件驱动&lt;/strong&gt;来触发的，跟SpringBoot有点神似。这种通过事件驱动来触发特定逻辑的方式，在实际开发工作中也可以灵活使用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、服务引入及SPI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    对于Dubbo的SPI自适应扩展，可参见博主之前的一篇文章 &lt;a href=&quot;https://www.cnblogs.com/zzq6032010/p/11219611.html&quot;&gt;https://www.cnblogs.com/zzq6032010/p/11219611.html&lt;/a&gt;，但此篇文章当时写的比较浅显，还未悟得全部。&lt;/p&gt;
&lt;p&gt;下面以Protocol类为例，看一下在ServiceConfig类中的成员变量  Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension() 是什么样子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.apache.dubbo.rpc;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.dubbo.common.extension.ExtensionLoader;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Protocol$Adaptive &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; org.apache.dubbo.rpc.Protocol {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy()  {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPort()  {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; org.apache.dubbo.rpc.RpcException {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (arg0 == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (arg0.getUrl() == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         org.apache.dubbo.common.URL url =&lt;span&gt; arg0.getUrl();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         String extName = ( url.getProtocol() == &lt;span&gt;null&lt;/span&gt; ? &quot;dubbo&quot;&lt;span&gt; : url.getProtocol() );
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(extName == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot; + url.toString() + &quot;) use keys([protocol])&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).getExtension(extName);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; extension.export(arg0);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; org.apache.dubbo.rpc.RpcException {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (arg1 == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;url == null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         org.apache.dubbo.common.URL url =&lt;span&gt; arg1;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         String extName = ( url.getProtocol() == &lt;span&gt;null&lt;/span&gt; ? &quot;dubbo&quot;&lt;span&gt; : url.getProtocol() );
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(extName == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot; + url.toString() + &quot;) use keys([protocol])&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).getExtension(extName);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; extension.refer(arg0, arg1);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.util.List getServers()  {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(&quot;The method public default java.util.List org.apache.dubbo.rpc.Protocol.getServers() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是getAdaptiveExtension()之后得到的代理类，可见在初始化ServiceConfig时先获取的protocol只是一个代理Protocol类，程序运行时再通过传入的Url来判断具体使用哪个Protocol实现类。这才是SPI自适应扩展的精髓所在。&lt;/p&gt;
&lt;p&gt;除此之外，在通过getExtension方法获取最终实现类时，还要经过wrapper类的包装。详见ExtensionLoader类中的如下方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T createExtension(String name) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Class&amp;lt;?&amp;gt; clazz =&lt;span&gt; getExtensionClasses().get(name);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; findException(name);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             T instance =&lt;span&gt; (T) EXTENSION_INSTANCES.get(clazz);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 instance =&lt;span&gt; (T) EXTENSION_INSTANCES.get(clazz);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            injectExtension(instance);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; wrapperClasses =&lt;span&gt; cachedWrapperClasses;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isNotEmpty(wrapperClasses)) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; wrapperClass : wrapperClasses) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     instance =&lt;span&gt; injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            initExtension(instance);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Extension instance (name: &quot; + name + &quot;, class: &quot; +
&lt;span&gt;23&lt;/span&gt;                     type + &quot;) couldn't be instantiated: &quot; +&lt;span&gt; t.getMessage(), t);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果接口存在包装类，则在第16行进行wrapper类的处理，将当前instance封装进包装类中，再返回包装类的实例，即通过这一行代码实现了扩展类的&lt;strong&gt;装饰器模式&lt;/strong&gt;改造。&lt;/p&gt;
&lt;p&gt;此处同样以Protocol类为例，Url中的协议是registry，那么我最终执行到RegistryProtocol的export方法时栈调用路径是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1558028/202003/1558028-20200328231932793-204206717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 即中间经过了三层Wrapper的封装，每层都有自己特定的功能，且各层之间互不影响。Dubbo在很多自适应扩展接口处加了类似这样的装饰扩展，程序的可扩展设计还可以这样玩，Interesting!&lt;/p&gt;
&lt;p&gt;服务引入的流程大体是这样的：消费端从注册中心获取服务端信息，封装成Invoker，再封装成代理类注入消费端Spring容器。流程比较简单，可自行根据上一节的内容debug调试。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、服务调用的疑问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    之前未看Dubbo源码时一直有一个疑问：dubbo的消费端代理类调用服务端接口进行消费时，是通过netty将消息发送过去的，服务端在接收到消息后，是如何调用的服务端目标类中的方法？反射吗？反射可以调用到方法，但是没法解决依赖的问题，而且正常情况服务端调用应该也是Spring容器中已经实例化好的的服务对象，那是如何通过netty的消息找到Spring中的对象的？&lt;/p&gt;
&lt;p&gt;    实际dubbo处理的很简单，只要在服务暴露的时候将暴露的服务自己存起来就好了，等消费端传过来消息的时候，直接去map里面取，取到的就是Spring中封装的那个服务对象，very easy。&lt;/p&gt;
&lt;p&gt;    服务调用的流程大体是这样的：调用之后通过client远程连接到server，在server端维护了暴露服务的一个map，服务端接收到请求后去map获取Exporter，exporter中有服务端封装好的Invoker，持有Spring中的服务bean，最终完成调用。中间还涉及很多细节，比如netty的封装与调用，序列化反序列化，负载均衡和容错处理等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    Dubbo作为一个优秀的rpc服务框架，其优势不止在于它的rpc过程，还在于更多细节模块的实现以及可扩展的设计，比如序列化处理、负载均衡、容错、netty的线程调度、路由、字典...   内容挺多的，后面打算针对dubbo的四大负载均衡算法做一下研究，浅尝辄止，不求甚解！&lt;/p&gt;

</description>
<pubDate>Sat, 28 Mar 2020 16:02:00 +0000</pubDate>
<dc:creator>淡墨痕</dc:creator>
<og:description>前言 本周空闲时间利用了百分之六七十的样子。主要将Dubbo官网文档和本地代码debug结合起来学习，基本看完了服务导出、服务引入以及服务调用的过程，暂未涉及路由、字典等功能。下面对这一周的收获进行一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzq6032010/p/12588538.html</dc:identifier>
</item>
<item>
<title>Redis缓存设计与性能优化 - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/12587429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/12587429.html</guid>
<description>&lt;p&gt;Redis我们一般是用作缓存，扛并发；或者用于某些特定的业务场景，比如前面说到redis各种数据类型的使用场景以及redis的哨兵和集群模式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里主要整理了下&lt;/span&gt;redis用作缓存，存在的一些问题，以及改善方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202003/1216484-20200328143249634-2038640061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;简单的流程就像这个样子，一般请先到缓存区获取，如果缓存没有再到后端的数据库去查询。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;span&gt;缓存穿透&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存穿透是指，是指查询一个根本不存在数据，这样缓存层里面没有，就会去访问后面的存储层了。如果有大量的这种恶意请求过来，都打向后面的存储层。显然我们的存储层是扛不住这样的压力。这样缓存就失去了保护后面存储的意义了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.缓存空对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于缓存穿透，可以采用缓存空对象，第一次进来缓存和&lt;/span&gt;DB都没有，就存个空对象到缓存里面。但是如果大批量的恶意请求过来，这样做就会导致缓存的key暴增，显然不是一个很好的方案。&lt;/p&gt;
&lt;p&gt;　　2.&lt;span&gt;布隆过滤器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说某个值存在时，这个值可能不存在；&lt;/span&gt;&lt;span&gt;但是&lt;/span&gt;&lt;span&gt;它说不存在时，那就肯定不存在。布隆过滤器是一个大型的位数组和几个不一样的无偏&lt;/span&gt; hash 函数。所谓无偏就是能够把元素的hash值算得比较均匀&lt;span&gt;。向布隆过滤器中添加&lt;/span&gt; key 时，会使用多个hash 函数对key进行hash分别算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个hash函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就 完成了 add 操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向布隆过滤器询问&lt;/span&gt; key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为1，只要有一个位为0，那么说明布隆过滤器中这个key&lt;span&gt;肯定&lt;/span&gt;&lt;span&gt;不存在。&lt;/span&gt;&lt;span&gt;但是&lt;/span&gt;&lt;span&gt;都是&lt;/span&gt; 1，这并不能说明这个key就一定存在，只是极有可能存在，因为这些位被置为1可能是因为其它的key存在所致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202003/1216484-20200328143431927-2002707437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; guvua包&lt;span&gt;布隆过滤器的使用，导包&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.google.guava&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;guava&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bloomFilterTest() {
        BloomFilter&lt;/span&gt;&amp;lt;CharSequence&amp;gt; bloomFilter =&lt;span&gt; BloomFilter.create(
                Funnels.stringFunnel(Charset.forName(&lt;/span&gt;&quot;UTF-8&quot;&lt;span&gt;)),
                &lt;/span&gt;1000, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;期望存入的数据个数&lt;/span&gt;
                0.001);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;误差率
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加到布隆过滤器&lt;/span&gt;
        String[] keys = &lt;span&gt;new&lt;/span&gt; String[1000&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String key: keys) {
            bloomFilter.put(key);
        }

        String key &lt;/span&gt;= &quot;key&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; exist =&lt;span&gt; bloomFilter.mightContain(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;exist) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo 存在才去缓存获取&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到这个类里面有很多的hash算法：com.google.common.hash.Hashing&lt;/p&gt;
&lt;p&gt;redisson也有布隆过滤器的实现。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.缓存失效&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于大批量的&lt;/span&gt;key同时失效，导致，大量的请求同时打向数据库，造成数据库压力过大，甚至直接挂掉。我们在批量写入缓存的时候，设置超时时间，可以是一个固定时间+随机时间方式来生成，这样就可以错开失效时间。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;缓存雪崩是指缓存层挂掉之后，所有请求都打向数据库，数据库扛不住，也可能挂掉，就导致对应的服务也挂掉，也会影响上游的调用服务。这样的级联问题。就像雪崩最开始一小片，然后越来越大，导致整个服务崩溃。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.保证缓存层的高可用性，比如&lt;/span&gt;redis哨兵或者redis集群。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.各依赖服务之间做限流，熔断，降级等，比如&lt;/span&gt;Hystri，阿里的sentinel&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.缓存一致性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　引入缓存之后，随之而来的问题就是当DB数据更新时，缓存中的数据就会与db数据不一致。所以数据修改时是先更新缓存还是先更新DB？&lt;/p&gt;
&lt;p&gt;　　如果先更新缓存，然后更新DB失败，那么下一个请求过来读取的缓存数据不是最新的。而我们实际上最终数据肯定都是以DB为准的。&lt;/p&gt;
&lt;p&gt;　　先更新db 在更新缓存，这是在更新DB的时候来的请求读取的数据也是不是最新的&lt;/p&gt;
&lt;p&gt;　　淘汰缓存——更新DB——重新刷进缓存，在更新db是来的请求在缓存没有数据，就会去请求DB，如果并发 可能操作多各请求去写DB，那么就需要加锁了&lt;/p&gt;
&lt;p&gt;　　加锁——淘汰缓存——更新DB——重新刷进缓存，这样相对而言就比较保险了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.bigkey问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bigkey是什么？在redis中，一个字符串最大512MB；hash，list，set，zset可以存储2^31 - 1 个元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说字符串超过&lt;/span&gt;10kb，其他的几种元素个数不要超过5000个。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以使用&lt;/span&gt;src/redis-cli --bigkeys 来查看bigkey，我这里设置了一个30多K的字符串，看下扫描结果，扫除了一个字符串类型的bigkey，4084字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202003/1216484-20200328144805533-298737371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Bigkey有哪些危害。一是删除时阻塞其他请求，比如一个bigkey，平时都没什么，但是设置了过期时间，到期了删除时，可能就会阻塞其他请求，4.0之后可以开启lazyfree-lazy- expire yes来异步删除；二是造成网络拥堵，比如一个key数据量达到1MB，假设并发量1000，这个时候获取它就会产生1000MB的流量，千兆网卡，峰值的速率也才128MB/S,并不是扛不住并发，而是会占用大量网络带宽。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于很大&lt;/span&gt;list，set这些，我们可以将数据拆分，生成一个系列的的key去存放数据。如果是redis集群这些key自然就可以分到不同的小主从上面去，如果是单机，那么可以自己实现一个路由算法，来如何获取这一系列key中的某一个。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. &lt;span&gt;客户端使用&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.避免多个服务使用一个&lt;/span&gt;redis实例，如果实在有，可以看下将业务拆分，把这些公共数据服务化。&lt;/p&gt;
&lt;p&gt;　　2.使用连接池，控制有效连接，同时也提高效率。连接池重要参数设置：&lt;/p&gt;
&lt;p&gt;　　　　1 maxActive &lt;span&gt;资源池中最大连接数&lt;/span&gt; &lt;span&gt;默认值&lt;/span&gt;8 &lt;/p&gt;
&lt;p&gt;　　　　2 maxIdle 资源池允许最大空闲 的连接数 &lt;span&gt;默认值&lt;/span&gt;8 &lt;/p&gt;
&lt;p&gt;　　　　3 minIdle 资源池确保最少空闲 的连接数 &lt;span&gt;默认值&lt;/span&gt;0 &lt;/p&gt;
&lt;p&gt;　　　　4 blockWhenExhausted 当资源池用尽后，调用者是否要等待。只有当为true时，下面的maxWaitMillis才会生效&lt;span&gt;，默认值&lt;/span&gt;true 建议使用默认值&lt;/p&gt;
&lt;p&gt;　　　　5 maxWaitMillis 当资源池连接用尽后，调用者的最大等待时间(单位为毫秒) -1：表示永不超时 不建议使用默认值&lt;/p&gt;
&lt;p&gt;　　　　6 testOnBorrow 向资源池借用连接时是否做连接有效性检测(ping)，无效连接会被移除 &lt;span&gt;默认值&lt;/span&gt;false 业务量很大时候建议 设置为false(多一次 ping的开销)。&lt;/p&gt;
&lt;p&gt;　　　　7 testOnReturn 向资源池归还连接时是否做连接有效性检测(ping)，无效连接会被移除 &lt;span&gt;默认值&lt;/span&gt;false 业务量很大时候建议 设置为false(多一次 ping的开销)。&lt;/p&gt;
&lt;p&gt;　　　　8 jmxEnabled 是否开启jmx监控，可用于监控 &lt;span&gt;默认值&lt;/span&gt;true 建议开启，但应用本身也要开启&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前面三个参数相对而言更重要，单独拎出来再说下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　最大连接数&lt;/span&gt;maxActive&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　可以从业务希望的并发量，客户端执行时间，&lt;/span&gt;redis资源设置（应用个数（集群部署多少个实例） * maxActive &amp;lt;= maxclients(redis最大连接数，redis配置中设置的)），等因素考虑。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　比如一次客户端执行时间&lt;/span&gt;2ms，那么一个连接的QPS就是500，业务期望的QPS是3000，那么理论上连接池大小3000/500=60个，实际上考虑其他影响，一般设置比理论值稍微大点。但这个值不是越大越好，一方面连接太多占用客户端和服务端资源，另一方面对　　　　于Redis这种高 QPS的服务器，一个大命令的阻塞即使设置再大资源池仍然会无济于事。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　最大空闲连接数&lt;/span&gt;maxIdle:&lt;/p&gt;
&lt;p&gt;　　　　　　maxIdle实际上才是业务需要的最大连接数，空闲的连接造好放在那儿，进来一个请求就可以直接拿来用了。maxActive&lt;span&gt;是为了给出总量，所以&lt;/span&gt;maxIdle不要设置过小，否则会有当空闲连接不够，就会创建新的连接，又会有新的开销，最佳就是maxActive = 　　　　　　maxIdle。这样就避免连接池伸缩带来的性能干扰。但是如果并发量不大或者maxActive&lt;span&gt;设置过高，会导致不必要的连接资源浪费。一般推荐&lt;/span&gt;maxIdle可以设置为按上面的业务期望QPS计算出来的理论连接数，maxActive&lt;span&gt;可以再放大一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　最小空闲连接数&lt;/span&gt;minIdle：&lt;/p&gt;
&lt;p&gt;　　　　　　至少保持多少空闲连接，在使用连接的过程中，如果连接数超过了minIdle，那么继续建立连接，如果超过了 maxIdle，当超过的连接执行完业务后会慢慢被移出连接池释放掉。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.&lt;/span&gt;&lt;span&gt;缓存预热&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　比如说上线一个抢购活动，肯定到点开始就会有很多人来请求了，这个时候就可以提前做数据的预热，既可以把连接池初始化好，也可以把数据放好。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Mar 2020 15:58:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<og:description>Redis我们一般是用作缓存，扛并发；或者用于某些特定的业务场景，比如前面说到redis各种数据类型的使用场景以及redis的哨兵和集群模式。 这里主要整理了下redis用作缓存，存在的一些问题，以及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/12587429.html</dc:identifier>
</item>
<item>
<title>解析“60k”大佬的19道C#面试题（上） - .NET骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/20200325-19-csharp-interview-question-from-60k-boss-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/20200325-19-csharp-interview-question-from-60k-boss-1.html</guid>
<description>&lt;h2 id=&quot;先略看题目：&quot;&gt;先略看题目：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;请简述&lt;code&gt;async&lt;/code&gt;函数的编译方式&lt;/li&gt;
&lt;li&gt;请简述&lt;code&gt;Task&lt;/code&gt;状态机的实现和工作机制&lt;/li&gt;
&lt;li&gt;请简述&lt;code&gt;await&lt;/code&gt;的作用和原理，并说明和&lt;code&gt;GetResult()&lt;/code&gt;有什么区别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Task&lt;/code&gt;和&lt;code&gt;Thread&lt;/code&gt;有区别吗？如果有请简述区别&lt;/li&gt;
&lt;li&gt;简述&lt;code&gt;yield&lt;/code&gt;的作用&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;实现斐波那契数列生成&lt;/li&gt;
&lt;li&gt;简述&lt;code&gt;stackless coroutine&lt;/code&gt;和&lt;code&gt;stackful coroutine&lt;/code&gt;的区别，并指出&lt;code&gt;C#&lt;/code&gt;的&lt;code&gt;coroutine&lt;/code&gt;是哪一种&lt;/li&gt;
&lt;li&gt;请简述&lt;code&gt;SelectMany&lt;/code&gt;的作用&lt;/li&gt;
&lt;li&gt;请实现一个函数&lt;code&gt;Compose&lt;/code&gt;用于将多个函数复合&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;monad&lt;/code&gt;，并利用&lt;code&gt;LINQ&lt;/code&gt;实现对&lt;code&gt;Nothing&lt;/code&gt;（空值）和&lt;code&gt;Just&lt;/code&gt;（有值）的求和&lt;/li&gt;
&lt;li&gt;简述&lt;code&gt;LINQ&lt;/code&gt;的&lt;code&gt;lazy computation&lt;/code&gt;机制&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;SelectMany&lt;/code&gt;实现两个数组中元素的两两相加&lt;/li&gt;
&lt;li&gt;请为三元函数实现柯里化&lt;/li&gt;
&lt;li&gt;请简述&lt;code&gt;ref struct&lt;/code&gt;的作用&lt;/li&gt;
&lt;li&gt;请简述&lt;code&gt;ref return&lt;/code&gt;的使用方法&lt;/li&gt;
&lt;li&gt;请利用&lt;code&gt;foreach&lt;/code&gt;和&lt;code&gt;ref&lt;/code&gt;为一个数组中的每个元素加&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请简述&lt;code&gt;ref&lt;/code&gt;、&lt;code&gt;out&lt;/code&gt;和&lt;code&gt;in&lt;/code&gt;在用作函数参数修饰符时的区别&lt;/li&gt;
&lt;li&gt;请简述非&lt;code&gt;sealed&lt;/code&gt;类的&lt;code&gt;IDisposable&lt;/code&gt;实现方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delegate&lt;/code&gt;和&lt;code&gt;event&lt;/code&gt;本质是什么？请简述他们的实现机制&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;没错，这是一位来自【广州.NET技术俱乐部】微信群的偏&lt;code&gt;Programming Languages&lt;/code&gt;（&lt;code&gt;编程语言开发科学&lt;/code&gt;）的大佬，本文我将&lt;strong&gt;斗胆&lt;/strong&gt;回答一下这些题目😂。&lt;/p&gt;
&lt;p&gt;由于这些题目（对我来说）比较&lt;strong&gt;难&lt;/strong&gt;，因此我这次只&lt;strong&gt;斗胆&lt;/strong&gt;回答前&lt;code&gt;10&lt;/code&gt;道题，发作上篇，另外一半的题目再等我慢慢查阅资料，另行回答😂。&lt;/p&gt;

&lt;h2 id=&quot;1-请简述async函数的编译方式&quot;&gt;1. 请简述&lt;code&gt;async&lt;/code&gt;函数的编译方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;是&lt;code&gt;C# 5.0&lt;/code&gt;推出的异步代码编程模型，其本质是编译为状态机。&lt;strong&gt;只要&lt;/strong&gt;函数前带上&lt;code&gt;async&lt;/code&gt;，&lt;strong&gt;就会&lt;/strong&gt;将函数转换为状态机。&lt;/p&gt;
&lt;h2 id=&quot;2-请简述task状态机的实现和工作机制&quot;&gt;2. 请简述&lt;code&gt;Task&lt;/code&gt;状态机的实现和工作机制&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CPS&lt;/code&gt;全称是&lt;code&gt;Continuation Passing Style&lt;/code&gt;，在&lt;code&gt;.NET&lt;/code&gt;中，它会自动编译为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将所有引用的局部变量做成闭包，放到一个隐藏的&lt;code&gt;状态机&lt;/code&gt;的类中；&lt;/li&gt;
&lt;li&gt;将所有的&lt;code&gt;await&lt;/code&gt;展开成一个状态号，有几个&lt;code&gt;await&lt;/code&gt;就有几个状态号；&lt;/li&gt;
&lt;li&gt;每次执行完一个状态，都重复回调&lt;code&gt;状态机&lt;/code&gt;的&lt;code&gt;MoveNext&lt;/code&gt;方法，同时指定下一个状态号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MoveNext&lt;/code&gt;方法还需处理线程和异常等问题。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;3-请简述await的作用和原理，并说明和getresult有什么区别&quot;&gt;3. 请简述&lt;code&gt;await&lt;/code&gt;的作用和原理，并说明和&lt;code&gt;GetResult()&lt;/code&gt;有什么区别&lt;/h2&gt;
&lt;p&gt;从状态机的角度出发，&lt;code&gt;await&lt;/code&gt;的本质是调用&lt;code&gt;Task.GetAwaiter()&lt;/code&gt;的&lt;code&gt;UnsafeOnCompleted(Action)&lt;/code&gt;回调，并指定下一个状态号。&lt;/p&gt;
&lt;p&gt;从多线程的角度出发，如果&lt;code&gt;await&lt;/code&gt;的&lt;code&gt;Task&lt;/code&gt;需要在新的线程上执行，该状态机的&lt;code&gt;MoveNext()&lt;/code&gt;方法会&lt;strong&gt;立即返回&lt;/strong&gt;，此时，&lt;strong&gt;主线程被释放出来了&lt;/strong&gt;，然后在&lt;code&gt;UnsafeOnCompleted&lt;/code&gt;回调的&lt;code&gt;action&lt;/code&gt;指定的线程上下文中继续&lt;code&gt;MoveNext()&lt;/code&gt;和下一个状态的代码。&lt;/p&gt;
&lt;p&gt;而相比之下，&lt;code&gt;GetResult()&lt;/code&gt;就是在当前线程上立即等待&lt;code&gt;Task&lt;/code&gt;的完成，在&lt;code&gt;Task&lt;/code&gt;完成前，当前线程&lt;strong&gt;不会释放&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;code&gt;Task&lt;/code&gt;也可能不一定在新的线程上执行，此时用&lt;code&gt;GetResult()&lt;/code&gt;或者&lt;code&gt;await&lt;/code&gt;就只有会不会创建状态机的区别了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;4-task和thread有区别吗？如果有请简述区别&quot;&gt;4. &lt;code&gt;Task&lt;/code&gt;和&lt;code&gt;Thread&lt;/code&gt;有区别吗？如果有请简述区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Task&lt;/code&gt;和&lt;code&gt;Thread&lt;/code&gt;都能创建用多线程的方式执行代码，但它们有较大的区别。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Task&lt;/code&gt;较新，发布于&lt;code&gt;.NET 4.5&lt;/code&gt;，能结合新的&lt;code&gt;async/await&lt;/code&gt;代码模型写代码，它不止能创建新线程，还能使用线程池（默认）、单线程等方式编程，在&lt;code&gt;UI&lt;/code&gt;编程领域，&lt;code&gt;Task&lt;/code&gt;还能自动返回&lt;code&gt;UI&lt;/code&gt;线程上下文，还提供了许多便利&lt;code&gt;API&lt;/code&gt;以管理多个&lt;code&gt;Task&lt;/code&gt;，用表格总结如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;区别&lt;/th&gt;
&lt;th&gt;Task&lt;/th&gt;
&lt;th&gt;Thread&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;.NET&lt;/code&gt;版本&lt;/td&gt;
&lt;td&gt;&lt;code&gt;4.5&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1.1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;async/await&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;创建新线程&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;线程池/单线程&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;返回主线程&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;管理API&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;TL;DR&lt;/code&gt;就是，用&lt;code&gt;Task&lt;/code&gt;就对了。&lt;/p&gt;
&lt;h2 id=&quot;5-简述yield的作用&quot;&gt;5. 简述&lt;code&gt;yield&lt;/code&gt;的作用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;yield&lt;/code&gt;需配合&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;一起使用，能在一个函数中支持多次（不是多个）返回，其本质和&lt;code&gt;async/await&lt;/code&gt;一样，也是状态机。&lt;/p&gt;
&lt;p&gt;如果不使用&lt;code&gt;yield&lt;/code&gt;，需实现&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;，它只暴露了&lt;code&gt;GetEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;，这样确保&lt;code&gt;yield&lt;/code&gt;是可重入的，比较符合人的习惯。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意，其它的语言，如&lt;code&gt;C++&lt;/code&gt;/&lt;code&gt;Java&lt;/code&gt;/&lt;code&gt;ES6&lt;/code&gt;实现的&lt;code&gt;yield&lt;/code&gt;，都叫&lt;code&gt;generator&lt;/code&gt;（生成器），这相当于&lt;code&gt;.NET&lt;/code&gt;中的&lt;code&gt;IEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;（而不是&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;）。这种设计导致&lt;code&gt;yield&lt;/code&gt;不可重入，&lt;strong&gt;只要其迭代过一次，就无法重新迭代了&lt;/strong&gt;，需要注意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;6-利用ienumerablet实现斐波那契数列生成&quot;&gt;6. 利用&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;实现斐波那契数列生成&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;IEnumerable&amp;lt;int&amp;gt; GenerateFibonacci(int n)
{
    if (n &amp;gt;= 1) yield return 1;
    
    int a = 1, b = 0;
    for (int i = 2; i &amp;lt;= n; ++i)
    {
        int t = b;
        b = a;
        a += t;
        
        yield return a;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7-简述stackless-coroutine和stackful-coroutine的区别，并指出c的coroutine是哪一种&quot;&gt;7. 简述&lt;code&gt;stackless coroutine&lt;/code&gt;和&lt;code&gt;stackful coroutine&lt;/code&gt;的区别，并指出&lt;code&gt;C#&lt;/code&gt;的&lt;code&gt;coroutine&lt;/code&gt;是哪一种&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stackless&lt;/code&gt;和&lt;code&gt;stackful&lt;/code&gt;对应的是协程中栈的内存，&lt;code&gt;stackless&lt;/code&gt;表示栈内存位置不固定，而&lt;code&gt;stackful&lt;/code&gt;则需要分配一个固定的栈内存。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;继续执行&lt;/code&gt;（&lt;code&gt;Continuation&lt;/code&gt;/&lt;code&gt;MoveNext()&lt;/code&gt;）时，&lt;code&gt;stackless&lt;/code&gt;需要编译器生成代码，如闭包，来自定义&lt;code&gt;继续执行&lt;/code&gt;逻辑；而&lt;code&gt;stackful&lt;/code&gt;则直接从原栈的位置&lt;code&gt;继续执行&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;性能方面，&lt;code&gt;stackful&lt;/code&gt;的中断返回需要依赖控制&lt;code&gt;CPU&lt;/code&gt;的跳转位置来实现，属于骚操作，会略微影响&lt;code&gt;CPU&lt;/code&gt;的分支预测，从而影响性能（但影响不算大），这方面&lt;code&gt;stackless&lt;/code&gt;无影响。&lt;/p&gt;
&lt;p&gt;内存方面，&lt;code&gt;stackful&lt;/code&gt;需要分配一个固定大小的栈内存（如&lt;code&gt;4kb&lt;/code&gt;），而&lt;code&gt;stackless&lt;/code&gt;只需创建带一个状态号变量的状态机，&lt;code&gt;stackful&lt;/code&gt;占用的内存更大。&lt;/p&gt;
&lt;p&gt;骚操作方面，&lt;code&gt;stackful&lt;/code&gt;可以轻松实现完全一致的递归/异常处理等，没有任何影响，但&lt;code&gt;stackless&lt;/code&gt;需要编译器作者高超的技艺才能实现（如&lt;code&gt;C#&lt;/code&gt;的作者），注意最初的&lt;code&gt;C# 5.0&lt;/code&gt;在&lt;code&gt;try-catch&lt;/code&gt;块中是不能写&lt;code&gt;await&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;和已有组件结合/框架依赖方面，&lt;code&gt;stackless&lt;/code&gt;需要定义一个状态机类型，如&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;/&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;/&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;等，而&lt;code&gt;stackful&lt;/code&gt;不需要，因此这方面&lt;code&gt;stackless&lt;/code&gt;较麻烦。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;属于&lt;code&gt;stackful&lt;/code&gt;，因此每个&lt;code&gt;goroutine&lt;/code&gt;需要分配一个固定大小的内存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C#&lt;/code&gt;属于&lt;code&gt;stackless&lt;/code&gt;，它会创建一个闭包和状态机，需要编译器生成代码来指定&lt;code&gt;继续执行&lt;/code&gt;逻辑。&lt;/p&gt;
&lt;p&gt;总结如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;&lt;code&gt;stackless&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;stackful&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;内存位置&lt;/td&gt;
&lt;td&gt;不固定&lt;/td&gt;
&lt;td&gt;固定&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;继续执行&lt;/td&gt;
&lt;td&gt;编译器定义&lt;/td&gt;
&lt;td&gt;CPU跳转&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;性能/速度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;快&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;快，但影响分支预测&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;内存占用&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;低&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需要固定大小的栈内存&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;编译器难度&lt;/td&gt;
&lt;td&gt;难&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;适中&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;组件依赖&lt;/td&gt;
&lt;td&gt;不方便&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;方便&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;嵌套&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;举例&lt;/td&gt;
&lt;td&gt;&lt;code&gt;C#&lt;/code&gt;/&lt;code&gt;js&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Go&lt;/code&gt;/&lt;code&gt;C++ Boost&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;8-请简述selectmany的作用&quot;&gt;8. 请简述&lt;code&gt;SelectMany&lt;/code&gt;的作用&lt;/h2&gt;
&lt;p&gt;相当于&lt;code&gt;js&lt;/code&gt;中数组的&lt;code&gt;flatMap&lt;/code&gt;，意思是将序列中的&lt;strong&gt;每一条数据&lt;/strong&gt;，转换为&lt;strong&gt;0到多条&lt;/strong&gt;数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SelectMany&lt;/code&gt;可以实现过滤/&lt;code&gt;.Where&lt;/code&gt;，方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IEnumerable&amp;lt;T&amp;gt; MyWhere&amp;lt;T&amp;gt;(this IEnumerable&amp;lt;T&amp;gt; seq, Func&amp;lt;T, bool&amp;gt; predicate)
{
    return seq.SelectMany(x =&amp;gt; predicate(x) ? 
        new[] { x } : 
        Enumerable.Empty&amp;lt;T&amp;gt;());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SelectMany&lt;/code&gt;是&lt;code&gt;LINQ&lt;/code&gt;中&lt;code&gt;from&lt;/code&gt;关键字的组成部分，这一点将在第&lt;code&gt;10&lt;/code&gt;题作演示。&lt;/p&gt;
&lt;h2 id=&quot;9-请实现一个函数compose用于将多个函数复合&quot;&gt;9. 请实现一个函数&lt;code&gt;Compose&lt;/code&gt;用于将多个函数复合&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static Func&amp;lt;T1, T3&amp;gt; Compose&amp;lt;T1, T2, T3&amp;gt;(this Func&amp;lt;T1, T2&amp;gt; f1, Func&amp;lt;T2, T3&amp;gt; f2)
{
    return x =&amp;gt; f2(f1(x));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Func&amp;lt;int, double&amp;gt; log2 = x =&amp;gt; Math.Log2(x);
Func&amp;lt;double, string&amp;gt; toString = x =&amp;gt; x.ToString();

var log2ToString = log2.Compose(toString);

Console.WriteLine(log2ToString(16)); // 4
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;10-实现maybet-monad，并利用linq实现对nothing（空值）和just（有值）的求和&quot;&gt;10. 实现&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;monad&lt;/code&gt;，并利用&lt;code&gt;LINQ&lt;/code&gt;实现对&lt;code&gt;Nothing&lt;/code&gt;（空值）和&lt;code&gt;Just&lt;/code&gt;（有值）的求和&lt;/h2&gt;
&lt;p&gt;本题比较难懂，经过和大佬确认，本质是要实现如下效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void Main()
{
        Maybe&amp;lt;int&amp;gt; a = Maybe.Just(5);
        Maybe&amp;lt;int&amp;gt; b = Maybe.Nothing&amp;lt;int&amp;gt;();
        Maybe&amp;lt;int&amp;gt; c = Maybe.Just(10);

        (from a0 in a from b0 in b select a0 + b0).Dump(); // Nothing
        (from a0 in a from c0 in c select a0 + c0).Dump(); // Just 15
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照我猴子进化来的大脑的理解，应该很自然地能写出如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Maybe&amp;lt;T&amp;gt; : IEnumerable&amp;lt;T&amp;gt;
{
        public bool HasValue { get; set; }
        public T Value { get; set;}
        
        IEnumerable&amp;lt;T&amp;gt; ToValue()
        {
                if (HasValue) yield return Value;
        }

        public IEnumerator&amp;lt;T&amp;gt; GetEnumerator()
        {
                return ToValue().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
                return ToValue().GetEnumerator();
        }
}

public class Maybe
{
        public static Maybe&amp;lt;T&amp;gt; Just&amp;lt;T&amp;gt;(T value)
        {
                return new Maybe&amp;lt;T&amp;gt; { Value = value, HasValue = true};
        }
        
        public static Maybe&amp;lt;T&amp;gt; Nothing&amp;lt;T&amp;gt;()
        {
                return new Maybe&amp;lt;T&amp;gt;();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种很自然，通过继承&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;来实现&lt;code&gt;LINQ to Objects&lt;/code&gt;的基本功能，但却是错误答案。&lt;/p&gt;
&lt;p&gt;正确答案：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public struct Maybe&amp;lt;T&amp;gt;
{
        public readonly bool HasValue;
        public readonly T Value;

        public Maybe(bool hasValue, T value)
        {
                HasValue = hasValue;
                Value = value;
        }

        public Maybe&amp;lt;B&amp;gt; SelectMany&amp;lt;TCollection, B&amp;gt;(Func&amp;lt;T, Maybe&amp;lt;TCollection&amp;gt;&amp;gt; collectionSelector, Func&amp;lt;T, TCollection, B&amp;gt; f)
        {
                if (!HasValue) return Maybe.Nothing&amp;lt;B&amp;gt;();

                Maybe&amp;lt;TCollection&amp;gt; collection = collectionSelector(Value);
                if (!collection.HasValue) return Maybe.Nothing&amp;lt;B&amp;gt;();

                return Maybe.Just(f(Value, collection.Value));
        }

        public override string ToString() =&amp;gt; HasValue ? $&quot;Just {Value}&quot; : &quot;Nothing&quot;;
}

public class Maybe
{
        public static Maybe&amp;lt;T&amp;gt; Just&amp;lt;T&amp;gt;(T value)
        {
                return new Maybe&amp;lt;T&amp;gt;(true, value);
        }

        public static Maybe&amp;lt;T&amp;gt; Nothing&amp;lt;T&amp;gt;()
        {
                return new Maybe&amp;lt;T&amp;gt;();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;br/&gt;首先这是一个函数式编程的应用场景，它应该使用&lt;code&gt;struct&lt;/code&gt;——值类型。&lt;/p&gt;
&lt;p&gt;其次，不是所有的&lt;code&gt;LINQ&lt;/code&gt;都要走&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;，可以用手撸的&lt;code&gt;LINQ&lt;/code&gt;表达式——&lt;code&gt;SelectMany&lt;/code&gt;来表示。（关于这一点，其实特别重要，我稍后有空会深入聊聊这一点。）&lt;/p&gt;

&lt;p&gt;这些技术平时可能比较冷门，全部能回答正确也并不意味着会有多有用，可能很难有机会用上。&lt;/p&gt;
&lt;p&gt;但如果是在开发像&lt;code&gt;ASP.NET Core&lt;/code&gt;那样的超高性能网络服务器、中间件，或者&lt;code&gt;Unity 3D&lt;/code&gt;那样的高性能游戏引擎、或者做一些高性能实时&lt;code&gt;ETL&lt;/code&gt;之类的，就能依靠这些知识，做出比肩甚至超过&lt;code&gt;C&lt;/code&gt;/&lt;code&gt;C++&lt;/code&gt;的性能，同时还能享受&lt;code&gt;C#&lt;/code&gt;/&lt;code&gt;.NET&lt;/code&gt;便利性的产品。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;群里有人戏称面试时出这些题的公司，要么是心太大，要么至少得开&lt;code&gt;60k&lt;/code&gt;，因此本文取名为&lt;code&gt;60k大佬&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;敬请期待我的下篇😂。&lt;/p&gt;
&lt;p&gt;喜欢的朋友请关注我的微信公众号：【DotNet骚操作】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201908/233608-20190825165420518-990227633.jpg&quot; alt=&quot;DotNet骚操作&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Mar 2020 15:54:00 +0000</pubDate>
<dc:creator>.NET骚操作</dc:creator>
<og:description>解析“60k”大佬的19道C 面试题（上） 先略看题目： 1. 请简述 函数的编译方式 2. 请简述 状态机的实现和工作机制 3. 请简述 的作用和原理，并说明和 有什么区别 4. 和`Thread`</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/20200325-19-csharp-interview-question-from-60k-boss-1.html</dc:identifier>
</item>
</channel>
</rss>