<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>开发环境--Pipenv的使用 - 暮良文王</title>
<link>http://www.cnblogs.com/liangmingshen/p/10174289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangmingshen/p/10174289.html</guid>
<description>&lt;h2&gt;1.Pipenv 介绍&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Pipenv是基于pip的Python包管理工具，它和pip的用法非常相似，可以看做pip的加强版。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pipenv解决了旧的pip+virtualenv+requirements.txt 的工作方式的弊端（因为&lt;span&gt;requirements.txt 需要手动维护，使用上不够灵活&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体来说，它是pip、Pipfile、Virtualenv的结合体，它让安装包、包依赖管理和虚拟环境管理更加方便。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.pipenv使用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（1）安装：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;pip install pipenv&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;检查是否创建成功：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;pipenv --version&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（2）创建虚拟环境：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;pipenv install
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　这会为当前项目创建一个文件夹，其中包含隔离的Python解释其环境，并且安装pip、wheel、setuptools等基本的包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）激活虚拟环境&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;pipenv shell 
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当执行pipenv shell 命令时， Pipenv 会自动从项目目录下的.env文件中加载环境变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在你会发现，命令行提示符前面添加了虚拟环境名，这说明我们已经成功激活了虚拟环境，现在你所有的命令都会在虚拟环境中执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）退出虚拟环境&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;3. 管理依赖包&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一个程序通常会使用很多的Python包，即依赖（dependency）。而程序不仅仅会在一台电脑上运行，程序部署上线时，需要安装到远程服务器上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你打算开源的话，就可能会有更多的人需要在他们的电脑上运行。为此，他们不得不记录下所有的依赖包，然后使用pip或Pipenv安装，这些重复无用的工作当然应该避免。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且requirements.txt 需要手动维护，使用上不够灵活。&lt;span&gt;Pipfile&lt;/span&gt;的出现就是为了替代难于管理的requirements.txt。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在创建虚拟环境时，如果项目根目录下没有Pipfile文件，pipenv还会在项目的根文件夹目录下创建Pipfile和Pipfile.lock文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前者用来记录项目依赖包列表，后者记录了固定版本的详细依赖包列表。&lt;span&gt;当我们使用Pipenv 安装/删除/更新 依赖包时，二者会自动更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1337485/201812/1337485-20181225152519583-796429834.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看当前环境下的依赖情况：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;pipenv graph
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在虚拟环境中查看依赖列表：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当需要在一个新的环境运行程序时&lt;/span&gt;， 只需要执行 &lt;span&gt;pipenv install&lt;span&gt;  命令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pipenv 就会创建一个新的虚拟环境，然后自动从Pipfile中读取依赖并安装到新创建的虚拟环境中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 07:37:00 +0000</pubDate>
<dc:creator>暮良文王</dc:creator>
<og:description>1.Pipenv 介绍 Pipenv是基于pip的Python包管理工具，它和pip的用法非常相似，可以看做pip的加强版。 pipenv解决了旧的pip+virtualenv+requirement</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangmingshen/p/10174289.html</dc:identifier>
</item>
<item>
<title>[UWP]使用Picker构建应用内图片公共裁剪组件 - HHChaos</title>
<link>http://www.cnblogs.com/hhchaos/p/10174116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhchaos/p/10174116.html</guid>
<description>&lt;p&gt;在上一篇博文《&lt;a href=&quot;https://www.cnblogs.com/hhchaos/p/10021952.html&quot;&gt;[UWP]如何实现UWP平台最佳图片裁剪控件&lt;/a&gt;》中我讲解了编写ImageCropper控件的过程及知识分享。在那篇文章里，我大言不惭的称其为UWP平台最佳图片裁剪控件（主要是没有别的类似控件来充当对手🤣）。其实写博客时的那个版本连交互动画都还没有，远远称不上“最佳”。&lt;/p&gt;
&lt;p&gt;不过，这一个月来ImageCropper经过数次迭代，它已经具有非常棒的体验了！另外还有一件令人兴奋的事，它即将加入&lt;a href=&quot;https://github.com/windows-toolkit/WindowsCommunityToolkit&quot;&gt;WindowsCommunityToolkit&lt;/a&gt;中（PR已经接近尾声）！这将让更多UWP开发者可以体验它。&lt;/p&gt;
&lt;p&gt;今天这篇博文我来讲下ImageCropper的一个特殊应用实例。&lt;/p&gt;
&lt;p&gt;先来思考一下这个问题：&lt;/p&gt;
&lt;p&gt;如果我们的应用只有一个界面需要调用图片剪裁，那很好，直接在这个页面嵌入ImageCropper控件就可以轻松完成了。但是，如果这个应用有多处需要裁剪图片的地方（譬如说上传图片、修剪照片、裁剪头像...），我们是否可以为这些需要裁剪图片的地方构建一个公共的可调用组件呢？&lt;/p&gt;
&lt;p&gt;事实上，我们可以借助HHChaosToolkit中的Picker组件来完成这一想法。&lt;/p&gt;
&lt;p&gt;之前我写过一系列关于Picker的文章，不了解Picker的话建议可以抽时间阅读：&lt;/p&gt;
&lt;p&gt;那么，我们今天使用Picker和ImageCropper来为应用构建一个公共裁剪组件。&lt;/p&gt;
&lt;p&gt;先看下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1239018/201812/1239018-20181225150910950-1013828668.gif&quot; alt=&quot;ImageCropper&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何实现的呢？&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;创建一个空白UWP应用项目，并引入了HHChaosToolkit.UWP以及ImageCropper.UWP这两个Nuget包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1239018/201812/1239018-20181225144958581-513678201.jpg&quot; alt=&quot;Nuget&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在&lt;a href=&quot;https://github.com/HHChaos/HHChaosToolkit&quot;&gt;HHChaosToolkit&lt;/a&gt;项目首页写过：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;HHChaosToolkit是一套适用于MVVM框架下使用的弹窗层组件库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HHChaosToolkit其中包含了Picker弹窗组件、SubWindows子窗口组件以及轻量级MVVM框架。我们在这个例子中使用到的是它的Picker以及MVVM部分。&lt;/p&gt;
&lt;p&gt;ImageCropper则是这个例子中主要依赖的功能组件。&lt;/p&gt;
&lt;p&gt;项目结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1239018/201812/1239018-20181225145026907-926765620.jpg&quot; alt=&quot;Solution&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中包含了两个页面，&lt;code&gt;ImageCropperPickerPage&lt;/code&gt;即是这个例子中我们要构建的图片公共裁剪组件，&lt;code&gt;MainPage&lt;/code&gt;中包含了调用使用公共裁剪组件的示例，逻辑代码均在其对应的ViewModel中。&lt;/p&gt;
&lt;h2 id=&quot;图片裁剪picker&quot;&gt;图片裁剪Picker&lt;/h2&gt;
&lt;p&gt;ImageCropperPicker就是我们想要的图片公共裁剪组件的Picker实现，它可以在任意地方调用（无论是在View还是ViewModel的代码中），且不会中断当前的操作，其调用原理可以查看我之前的博文《&lt;a href=&quot;https://www.cnblogs.com/hhchaos/p/9961249.html&quot;&gt;[UWP]使用Popup构建UWP Picker&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;这个页面中包含了ImageCropper控件，用于实现图片裁剪功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1239018/201812/1239018-20181225145059138-988304971.jpg&quot; alt=&quot;ImageCropper&quot;/&gt;&lt;/p&gt;
&lt;p&gt;界面布局如下：&lt;/p&gt;
&lt;pre class=&quot;xaml&quot;&gt;
&lt;code&gt;&amp;lt;Page
    x:Class=&quot;ImageCropperPicker.Views.ImageCropperPickerPage&quot;
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    xmlns:cropper=&quot;using:ImageCropper.UWP&quot;
    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
    xmlns:local=&quot;using:ImageCropperPicker.Views&quot;
    xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
    DataContext=&quot;{Binding ImageCropperPickerViewModel, Source={StaticResource Locator}}&quot;
    RequestedTheme=&quot;Dark&quot;
    mc:Ignorable=&quot;d&quot;&amp;gt;
    &amp;lt;Grid&amp;gt;
        &amp;lt;Grid.ColumnDefinitions&amp;gt;
            &amp;lt;ColumnDefinition /&amp;gt;
            &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt;
        &amp;lt;/Grid.ColumnDefinitions&amp;gt;
        &amp;lt;cropper:ImageCropper
            x:Name=&quot;ImageCropper&quot;
            Padding=&quot;80&quot;
            AspectRatio=&quot;{Binding AspectRatio}&quot;
            Background=&quot;Transparent&quot;
            CircularCrop=&quot;{Binding CircularCrop}&quot;
            Mask=&quot;#af000000&quot;
            SourceImage=&quot;{Binding SourceImage}&quot; /&amp;gt;
        &amp;lt;Grid Grid.Column=&quot;1&quot; Background=&quot;#af000000&quot;&amp;gt;
            &amp;lt;StackPanel Padding=&quot;55&quot; VerticalAlignment=&quot;Center&quot;&amp;gt;
                &amp;lt;AppBarButton
                    Margin=&quot;0,15&quot;
                    Click=&quot;Button_Click&quot;
                    Icon=&quot;Accept&quot;
                    Label=&quot;OK&quot; /&amp;gt;
                &amp;lt;AppBarButton
                    Command=&quot;{Binding ExitCommand}&quot;
                    Foreground=&quot;White&quot;
                    Icon=&quot;Cancel&quot;
                    Label=&quot;Cancel&quot; /&amp;gt;
            &amp;lt;/StackPanel&amp;gt;
        &amp;lt;/Grid&amp;gt;
    &amp;lt;/Grid&amp;gt;
&amp;lt;/Page&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;逻辑层代码中，我使用&lt;code&gt;ImageCropperConfig&lt;/code&gt;类来接受调用方传来的参数，并在打开Picker时读取参数，初始化Picker。&lt;/p&gt;
&lt;p&gt;ImageCropperConfig定义如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public class ImageCropperConfig
    {
        public StorageFile ImageFile { get; set; }
        public double AspectRatio { get; set; } = -1;
        public bool CircularCrop { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ImageCropperPicker的ViewModel代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using HHChaosToolkit.UWP.Mvvm;
using ImageCropperPicker.Models;
using System;
using Windows.UI.Xaml.Media.Imaging;
using Windows.UI.Xaml.Navigation;

namespace ImageCropperPicker.ViewModels
{
    public class ImageCropperPickerViewModel : ObjectPickerBase&amp;lt;WriteableBitmap&amp;gt;
    {
        private WriteableBitmap _sourceImage;
        public WriteableBitmap SourceImage
        {
            get =&amp;gt; _sourceImage;
            set =&amp;gt; Set(ref _sourceImage, value);
        }
        private double _aspectRatio;
        public double AspectRatio
        {
            get =&amp;gt; _aspectRatio;
            set =&amp;gt; Set(ref _aspectRatio, value);
        }
        private bool _circularCrop;
        public bool CircularCrop
        {
            get =&amp;gt; _circularCrop;
            set =&amp;gt; Set(ref _circularCrop, value);
        }
        public async override void OnNavigatedTo(NavigationEventArgs e)
        {
            if (e.Parameter is ImageCropperConfig config)
            {
                var writeableBitmap = new WriteableBitmap(1, 1);
                using (var stream = await config.ImageFile.OpenReadAsync())
                {
                    await writeableBitmap.SetSourceAsync(stream);
                }

                SourceImage = writeableBitmap;
                AspectRatio = config.AspectRatio;
                CircularCrop = config.CircularCrop;
            }
            base.OnNavigatedTo(e);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，完成裁剪图片的操作我放在了界面上OK按键的后台代码中（实际上还是调用的Picker中的方法）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            var img = await ImageCropper.GetCroppedBitmapAsync();
            ViewModel?.SetResult(img);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;应用内调用&quot;&gt;应用内调用&lt;/h2&gt;
&lt;p&gt;调用方法非常的简单，直接使用HHChaosToolkit中的&lt;code&gt;ObjectPickerService&lt;/code&gt;来启动Picker，并且等待Picker返回结果即可。&lt;/p&gt;
&lt;p&gt;比较特别的是，在这里我通过使用&lt;code&gt;PickerOpenOption&lt;/code&gt;让裁剪图片Picker可以覆盖到整个应用界面，UI表现看起来更佳。&lt;/p&gt;
&lt;p&gt;调用代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        private async Task&amp;lt;ImageSource&amp;gt; CropImage(ImageCropperConfig config)
        {
            var startOption = new PickerOpenOption
            {
                VerticalAlignment = VerticalAlignment.Stretch,
                HorizontalAlignment = HorizontalAlignment.Stretch,
            };
            var ret = await ViewModelLocator.Current.ObjectPickerService.PickSingleObjectAsync&amp;lt;WriteableBitmap&amp;gt;(
                typeof(ImageCropperPickerViewModel).FullName, config, startOption);
            if (!ret.Canceled)
            {
                return ret.Result;
            }
            return null;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是看起来很简单？是的，优雅的调用方式就应该这么简单！&lt;/p&gt;
&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;
&lt;p&gt;正如我之前所说，Picker组件在很多地方都可以派上用处，我们几乎可以用它来实现一切UWP自定义弹出框，非常欢迎有类似需求的开发者们试用！&lt;/p&gt;
&lt;p&gt;这个示例项目开源在&lt;a href=&quot;https://github.com/HHChaos/ImageCropperPicker&quot;&gt;Github&lt;/a&gt;中，感兴趣的可以自行Clone编译，同时项目中的代码请随意享用，喜欢的话请不要忘记Star！&lt;/p&gt;
&lt;p&gt;本篇博客到此结束！谢谢大家阅读！&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 07:17:00 +0000</pubDate>
<dc:creator>HHChaos</dc:creator>
<og:description>在上一篇博文《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhchaos/p/10174116.html</dc:identifier>
</item>
<item>
<title>实例直观解释sessionid的作用 - 思琼同学</title>
<link>http://www.cnblogs.com/lisqiong/p/10172780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lisqiong/p/10172780.html</guid>
<description>&lt;p&gt;有两个php页面，demo1.php与demo2.php。如果想要在demo1.php创建一个session需要在的demo2.php或者说其它页面都可以获取到设置的session的值，达到会话的功能，有几种实现方式？&lt;/p&gt;
&lt;h4 id=&quot;一未屏蔽浏览器cookie&quot;&gt;一、未屏蔽浏览器cookie&lt;/h4&gt;
&lt;p&gt;demo1.php代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
session_start();
$sid = session_id();
echo &quot;sessionid：&quot;.$sid.&quot;&amp;lt;br/&amp;gt;&quot;;
$_SESSION['user'] = '巴八灵';
$a = $_SESSION['user'];
echo &quot;session的值：&quot;.$a.PHP_EOL.&quot;&amp;lt;br/&amp;gt;&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595183/201812/595183-20181225113428295-830022297.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;demo2.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
session_start();
$sid = session_id();
echo &quot;sessionid：&quot;.$sid.&quot;&amp;lt;br/&amp;gt;&quot;;
echo &quot;session的值：&quot;.$_SESSION['user'];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595183/201812/595183-20181225113441462-1152797309.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;查看php.ini配置我们这里设置session存储是在服务器tmp目录下&quot;&gt;查看php.ini配置我们这里设置session存储是在服务器/tmp目录下&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595183/201812/595183-20181225112827577-359592874.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;通过查看发现session的存储都是以sessionid加上一串字符构成的文件，我们设置的session的值就存储在这样的文件当中。我们发现设置的session之所以能够在两个页面中共享获取，是因为都共同拥有一个sessionid，并且这个sessionid以cookie形式存储在浏览器，然后通过http请求中的header头的cookie项传递给服务器。那如果将浏览器cookie禁用后将会发生什么效果呢？下面的部分就将阐述浏览器禁用cookie后的影响和解决方法的实现。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二屏蔽浏览器cookie后&quot;&gt;二、屏蔽浏览器cookie后&lt;/h4&gt;
&lt;p&gt;我这边使用的是google浏览器，进入google浏览器设置选项-内容设置-cookie-屏蔽cookie选项，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595183/201812/595183-20181225144519286-1031805905.png&quot;/&gt;&lt;br/&gt;发现程序报错，sessionid每次刷新都会不一样，但是session的设置不会受影响，值还是还是可以存储到服务器中，但是与其它页面session不共享。&lt;/p&gt;
&lt;h5 id=&quot;方法一通过url显现传递sessionid实现session共享&quot;&gt;方法一：通过url显现传递sessionid实现session共享&lt;/h5&gt;
&lt;p&gt;demo1.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
session_start();
$sid = session_id();
echo &quot;sessionid：&quot;.$sid.&quot;&amp;lt;br/&amp;gt;&quot;;
$_SESSION['user'] = '巴八灵';
$a = $_SESSION['user'];
echo &quot;session的值：&quot;.$a.&quot;&amp;lt;br/&amp;gt;&quot;; 
echo &quot;&amp;lt;a href='./demo2.php?sid=&quot;.$sid.&quot;' target='_blank' &amp;gt;demo2.php&amp;lt;/a&amp;gt;&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595183/201812/595183-20181225141149224-866444344.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;demo2.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;?php
$sid = $_GET['sid'];
session_id($sid);
session_start();
$sid = session_id();
echo &quot;sessionid：&quot;.$sid.&quot;&amp;lt;br/&amp;gt;&quot;;
echo &quot;session的值：&quot;.$_SESSION['user'];
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;方法二修改php.ini配置隐式通过get参数sessionid&quot;&gt;方法二：修改php.ini配置隐式通过get参数sessionid&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;session.use_trans_sid = 1
session.use_cookies = 1
session.use_only_cookies = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改参数数重启php-fpm&lt;/p&gt;
&lt;p&gt;demo1.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;?php
session_start();
$sid = session_id();
echo &quot;sessionid：&quot;.$sid.&quot;&amp;lt;br/&amp;gt;&quot;;
$_SESSION['user'] = '巴八灵';
$a = $_SESSION['user'];
echo &quot;session的值：&quot;.$a.&quot;&amp;lt;br/&amp;gt;&quot;; 
echo &quot;&amp;lt;a href='./demo2.php‘ target='_blank' &amp;gt;demo2.php&amp;lt;/a&amp;gt;&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595183/201812/595183-20181225141000354-1487298619.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;demo2.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
session_start();
$sid = session_id();
echo &quot;sessionid：&quot;.$sid.&quot;&amp;lt;br/&amp;gt;&quot;;
echo &quot;session的值：&quot;.$_SESSION['user'];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/595183/201812/595183-20181225141018061-1414774495.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;仔细可以发现屏蔽浏览器cookie后，浏览器中header头没有传递cookie项，这个时候sessionid不能够都过header头的方式传递，服务器肯定不知道sessionid的是什么，于是可以通过url中传递sessionid来让服务器知道这个是什么，从而去取session的设置信息。换言之就是sessionid是获取session配置信息的一个桥梁，cookie在其中起到的是传递sessionid的作用，我们屏蔽cookie后，让session可以共享的解决方法也是将sessionid告诉给服务器来解决问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;由此我们可以得出实现sessionid会话的三种方式为&quot;&gt;由此我们可以得出实现sessionid会话的三种方式为：&lt;/h3&gt;

&lt;h4 id=&quot;屏蔽浏览器cookie后php设置session时产生的sessionid可以通过get方式将这个参数传递给需要访问的其它页面在新的页面中接收sessionid的值并通过session_id_getsid这个方法讲sesionid给出去从而获取设置的session值&quot;&gt;2.屏蔽浏览器cookie后，php设置session时产生的sessionid可以通过get方式将这个参数传递给需要访问的其它页面，在新的页面中接收sessionid的值，并通过session_id($_GET['sid'])这个方法讲sesionid给出去从而获取设置的session值&lt;/h4&gt;
&lt;h4 id=&quot;通过配置php.ini中session.use_trans_sid-1来实现隐式传递sessionid设置session的页面跳转也不需要带上参数系统会默认带上跳转后的页面也不需要接收参数都是在内部解决的从而也可以获取到设置的session的值&quot;&gt;3.通过配置php.ini中session.use_trans_sid = 1来实现隐式传递sessionid，设置session的页面跳转也不需要带上参数，系统会默认带上，跳转后的页面也不需要接收参数，都是在内部解决的，从而也可以获取到设置的session的值&lt;/h4&gt;
</description>
<pubDate>Tue, 25 Dec 2018 07:04:00 +0000</pubDate>
<dc:creator>思琼同学</dc:creator>
<og:description>有两个php页面，demo1.php与demo2.php。如果想要在demo1.php创建一个session需要在的demo2.php或者说其它页面都可以获取到设置的session的值，达到会话的功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lisqiong/p/10172780.html</dc:identifier>
</item>
<item>
<title>asp.net core mcroservices 架构之 分布式日志（二）之自定义日志开发 - 一夜寒江</title>
<link>http://www.cnblogs.com/ck0074451665/p/10171668.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ck0074451665/p/10171668.html</guid>
<description>&lt;p&gt;          netcore的日志是作为一个扩展库存在的，每个组件都有它的入口，那么作为研究这个组件的入口是最好的，首先看两种方式：&lt;/p&gt;
&lt;p&gt;这个是源码例子提供的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fcf19f7b-919e-416c-a293-c6994da095ae')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_fcf19f7b-919e-416c-a293-c6994da095ae&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fcf19f7b-919e-416c-a293-c6994da095ae&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fcf19f7b-919e-416c-a293-c6994da095ae',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fcf19f7b-919e-416c-a293-c6994da095ae&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; loggingConfiguration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                .SetBasePath(Directory.GetCurrentDirectory())
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 .AddJsonFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;false&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                .Build();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; A Web App based program would configure logging via the WebHostBuilder.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a logger factory with filters that can be applied across all logger providers.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; serviceCollection = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 .AddLogging(builder =&amp;gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    builder
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         .AddConfiguration(loggingConfiguration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                         .AddFilter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, LogLevel.Debug)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         .AddFilter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, LogLevel.Debug)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                         .AddFilter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SampleApp.Program&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, LogLevel.Debug)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                        .AddConsole();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; NET461
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    builder.AddEventLog();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; NETCOREAPP2_2
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#error&lt;/span&gt; Target framework needs to be updated
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; providers may be added to a LoggerFactory before any loggers are created&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; serviceProvider =&lt;span&gt; serviceCollection.BuildServiceProvider();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; getting the logger using the class's name is conventional&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             _logger = serviceProvider.GetRequiredService&amp;lt;ILogger&amp;lt;Program&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这个是咱们使用hostbuild中的扩展&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('693ae608-859f-4c42-8e22-e8d8e6f72e2c')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_693ae608-859f-4c42-8e22-e8d8e6f72e2c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_693ae608-859f-4c42-8e22-e8d8e6f72e2c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('693ae608-859f-4c42-8e22-e8d8e6f72e2c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_693ae608-859f-4c42-8e22-e8d8e6f72e2c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt; WebHostBuilder().ConfigureAppConfiguration((webHostBuild,configBuild) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; env =&lt;span&gt; webHostBuild.HostingEnvironment;
                
                configBuild.AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .AddJsonFile($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.{env.EnvironmentName}.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                ,optional:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,reloadOnChange:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                .SetBasePath(Directory.GetCurrentDirectory());
            }).ConfigureLogging((hostingContext, logging) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                logging.AddConfiguration(hostingContext.Configuration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                .AddCustomizationLogger();
            }).UseKestrel((hostcon,opt)&lt;/span&gt;=&amp;gt;&lt;span&gt; {
                opt.ListenAnyIP(&lt;/span&gt;&lt;span&gt;5555&lt;/span&gt;&lt;span&gt;);
            })
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ihost=&lt;span&gt; host.Build(); 
            ihost.Run();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;从以上两种可以看出，其实第二种WebHostBuilder是封装第一种的。所以咱们选择从第一个入口着手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181224233126169-1525423445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; netcore日志设计思想是：LoggingBuider 构建，LoggerFactory和Logger类负责日志操作和Log提供程序的管理，Configuration是配置功能。&lt;/p&gt;
&lt;p&gt;那么咱们基于以上的代码，看LoggingBuilder类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging
{
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggingBuilder : ILoggingBuilder
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoggingBuilder(IServiceCollection services)
        {
            Services &lt;/span&gt;=&lt;span&gt; services;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceCollection Services { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看为Service做的扩展&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection.Extensions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Extension methods for setting up logging services in an &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggingServiceCollectionExtensions
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Adds logging services to the specified &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt; to add services to.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; so that additional calls can be chained.&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddLogging(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; AddLogging(services, builder =&amp;gt;&lt;span&gt; { });
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Adds logging services to the specified &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt; to add services to.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;configure&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggingBuilder&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; configuration delegate.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; so that additional calls can be chained.&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddLogging(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;ILoggingBuilder&amp;gt;&lt;span&gt; configure)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (services == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(services));
            }

            services.AddOptions();

            services.TryAdd(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;ILoggerFactory, LoggerFactory&amp;gt;&lt;span&gt;());&lt;span&gt;//生成log的工厂&lt;/span&gt;
            services.TryAdd(ServiceDescriptor.Singleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(ILogger&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(Logger&amp;lt;&amp;gt;&lt;span&gt;))); &lt;span&gt;//Log泛型类&lt;/span&gt;

            services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;LoggerFilterOptions&amp;gt;&amp;gt;&lt;span&gt;(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultLoggerLevelConfigureOptions(LogLevel.Information)));&lt;span&gt;//Filter配置类&lt;/span&gt;

            configure(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggingBuilder(services)); &lt;span&gt;//提供一个回掉方法，将logbuilder作为上下文传入
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是Log日志部分完成相当于注册功能的代码。&lt;/p&gt;
&lt;p&gt;在入口中咱们看到了，回掉函数中放着加载配置和指定Logging提供程序。首先看加载配置：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;builder.AddConfiguration(loggingConfiguration.GetSection(&quot;Logging&quot;)) &lt;/p&gt;
&lt;p&gt;AddConfiguration是在 Logging.Configuration中的LoggingBuilderExtensions.cs&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Copyright (c) .NET Foundation. All rights reserved.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.&lt;/span&gt;

&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Extension methods for setting up logging services in an &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggingBuilder&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggingBuilderExtensions
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Configures &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;LoggerFilterOptions&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt; from an instance of &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IConfiguration&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;builder&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggingBuilder&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; to use.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;configuration&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IConfiguration&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt; to add.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;The builder.&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILoggingBuilder AddConfiguration(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; ILoggingBuilder builder, IConfiguration configuration)
        {
            builder.AddConfiguration();  &lt;span&gt;//这个是下面紧挨着代码块的实现，主要是根据类名或者别名，找出对应的configuration并加载&lt;/span&gt;
            builder.Services.AddSingleton&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;LoggerFilterOptions&amp;gt;&amp;gt;&lt;br/&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerFilterConfigureOptions(configuration)); //&lt;span&gt;添加filter结点的配置&lt;/span&gt;
            builder.Services.AddSingleton&lt;/span&gt;&amp;lt;IOptionsChangeTokenSource&amp;lt;LoggerFilterOptions&amp;gt;&amp;gt;&lt;br/&gt;(&lt;span&gt;new&lt;/span&gt; ConfigurationChangeTokenSource&amp;lt;LoggerFilterOptions&amp;gt;&lt;span&gt;(configuration));//&lt;span&gt;更改后需要通知检控类刷新操作&lt;/span&gt;

            builder.Services.AddSingleton(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggingConfiguration(configuration));//&lt;span&gt;将这个配直节放入service

            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
        }
    }
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Copyright (c) .NET Foundation. All rights reserved.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.&lt;/span&gt;

&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection.Extensions;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging.Configuration
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Extension methods for setting up logging services in an &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggingBuilder&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggingBuilderConfigurationExtensions
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;&lt;span&gt; 这个类就是添加根据类型或者是别名去找到配置节的功能 &lt;/span&gt;Adds services required to consume &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggerProviderConfigurationFactory&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; or &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggerProviderConfiguration{T}&quot;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddConfiguration(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; ILoggingBuilder builder)
        {
            builder.Services.TryAddSingleton&lt;/span&gt;&amp;lt;ILoggerProviderConfigurationFactory&lt;br/&gt;, LoggerProviderConfigurationFactory&amp;gt;&lt;span&gt;();
            builder.Services.TryAddSingleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(ILoggerProviderConfiguration&amp;lt;&amp;gt;)&lt;br/&gt;, &lt;span&gt;typeof&lt;/span&gt;(LoggerProviderConfiguration&amp;lt;&amp;gt;&lt;span&gt;));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家其实看到了，全部是往ServiceColl中扔东西，但是细想一下，这不就是根据部件组合出功能的思想吗？不同的部件会组合出新的功能。那日志是如何组合出来的？在咱们的入口类中有这一句：&lt;/p&gt;
&lt;p&gt;_logger = serviceProvider.GetRequiredService&amp;lt;ILogger&amp;lt;Program&amp;gt;&amp;gt;();在上面为Service做扩展的那一段代码中已经为ILogger&amp;lt;&amp;gt;注册了服务，还有LoggerFactory也是。那么就从这个类入手，看序列图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225113743206-1821660555.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道netcore把DI集成了，基础组件和业务类都可以作为服务来看待，然后进行控制服务以及服务的相互组合，比如在服务中&lt;/p&gt;
&lt;p&gt; LoggerFactory类需要初始化，那么看看它的构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; LoggerFactory() : &lt;span&gt;this&lt;/span&gt;(Enumerable.Empty&amp;lt;ILoggerProvider&amp;gt;&lt;span&gt;())
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LoggerFactory(IEnumerable&amp;lt;ILoggerProvider&amp;gt; providers) : &lt;span&gt;this&lt;/span&gt;(providers, &lt;span&gt;new&lt;/span&gt; StaticFilterOptionsMonitor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerFilterOptions()))
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LoggerFactory(IEnumerable&amp;lt;ILoggerProvider&amp;gt; providers, LoggerFilterOptions filterOptions) : &lt;span&gt;this&lt;/span&gt;(providers, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StaticFilterOptionsMonitor(filterOptions))
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LoggerFactory(IEnumerable&amp;lt;ILoggerProvider&amp;gt; providers, IOptionsMonitor&amp;lt;LoggerFilterOptions&amp;gt;&lt;span&gt; filterOption)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; providers)
            {
                AddProviderRegistration(provider, dispose: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }

            _changeTokenRegistration &lt;/span&gt;=&lt;span&gt; filterOption.OnChange(RefreshFilters);
            RefreshFilters(filterOption.CurrentValue);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会不会奇怪为什么构造函数中 ILoggerProvider是以列表的形式出现？&lt;/p&gt;
&lt;p&gt;再看看console提供程序的服务注册代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsoleLoggerExtensions
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Adds a console logger named 'Console' to the factory.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;builder&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggingBuilder&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; to use.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILoggingBuilder AddConsole(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; ILoggingBuilder builder)
        {
            builder.AddConfiguration();

            builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;ILoggerProvider, ConsoleLoggerProvider&amp;gt;&lt;span&gt;());
            builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;ConsoleLoggerOptions&amp;gt;, ConsoleLoggerOptionsSetup&amp;gt;&lt;span&gt;());
            builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IOptionsChangeTokenSource&amp;lt;ConsoleLoggerOptions&amp;gt;, LoggerProviderOptionsChangeTokenSource&amp;lt;ConsoleLoggerOptions, ConsoleLoggerProvider&amp;gt;&amp;gt;&lt;span&gt;());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它是以 TryAddEnumerable 的形式添加的，也就是说 ILoggerProvider 在服务中有一个列表。那么这个就清楚了，你可以添加&lt;/p&gt;
&lt;p&gt;AddDebug AddConsole许多的提供程序，然后全部被注入进LoggerFacotry，LoggerFacotry会生成Logger然后传递给主Logger统一管理。&lt;/p&gt;
&lt;p&gt;LoggerFactory有段代码 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetLoggerInformation(&lt;span&gt;ref&lt;/span&gt; LoggerInformation loggerInformation, ILoggerProvider provider,  &lt;span&gt;string&lt;/span&gt;&lt;span&gt; categoryName)
        {
            loggerInformation.Logger &lt;/span&gt;=&lt;span&gt; provider.CreateLogger(categoryName);
            loggerInformation.ProviderType &lt;/span&gt;=&lt;span&gt; provider.GetType();
            loggerInformation.ExternalScope &lt;/span&gt;= provider &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ISupportExternalScope;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LoggerInformation[] CreateLoggers(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; categoryName)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loggers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerInformation[_providerRegistrations.Count];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; _providerRegistrations.Count; i++&lt;span&gt;)
            {
                SetLoggerInformation(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; loggers[i], _providerRegistrations[i].Provider, categoryName);
            }

            ApplyRules(loggers, categoryName, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, loggers.Length);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loggers;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; ILogger CreateLogger(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; categoryName)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CheckDisposed())
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectDisposedException(nameof(LoggerFactory));
            }

            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_sync)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_loggers.TryGetValue(categoryName, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; logger))
                {
                    logger &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Logger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                    {
                        Loggers &lt;/span&gt;=&lt;span&gt; CreateLoggers(categoryName)  //&lt;span&gt;上面的代码块生成&lt;/span&gt;
                    };
                    _loggers[categoryName] &lt;/span&gt;=&lt;span&gt; logger;
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;        说了那么多，咱们开始动手自己做一个。咱们并不是新建一个服务，而是为Logging服务做一个扩展，&lt;/p&gt;
&lt;p&gt;所以不用新建builder部分，而是为LoggerBuilder新建一个扩展，先看代码结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225115256619-1562008446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后看看为LoggerBuilder做的扩展方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Copyright (c) .NET Foundation. All rights reserved.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.&lt;/span&gt;

&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection.Extensions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging.Console;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Walt.Freamwork.Log
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomizationLoggerLoggerExtensions
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Adds a console logger named 'Console' to the factory.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;builder&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggingBuilder&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; to use.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILoggingBuilder AddCustomizationLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; ILoggingBuilder builder)
        {
            builder.AddConfiguration();

            builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;ILoggerProvider, CustomizationLoggerProvider&amp;gt;&lt;span&gt;());
            builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;CustomizationLoggerOptions&amp;gt;, CustomizationLoggerOptionsSetup&amp;gt;&lt;span&gt;());
            builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IOptionsChangeTokenSource&amp;lt;ConsoleLoggerOptions&amp;gt;, LoggerProviderOptionsChangeTokenSource&amp;lt;ConsoleLoggerOptions, ConsoleLoggerProvider&amp;gt;&amp;gt;&lt;span&gt;());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Adds a console logger named 'Console' to the factory.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;builder&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;ILoggingBuilder&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; to use.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;configure&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILoggingBuilder AddCustomizationLogger(&lt;span&gt;this&lt;/span&gt; ILoggingBuilder builder, Action&amp;lt;CustomizationLoggerOptions&amp;gt;&lt;span&gt; configure)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (configure == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(configure));
            }

            builder.AddCustomizationLogger();
            builder.Services.Configure(configure);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
        }

       
 
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就像第一部分的原理，将你自己的CustomizationLoggerProvider服务添加进服务中，就完成了一半。配置文件和配置Token，&lt;/p&gt;
&lt;p&gt;有了这个token，就可以监控到配置文件更改，从而引发change方法，让开发去做一些事情。那么看配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KafkaLog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Prix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是我的自定义日志提供程序&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看看配置类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225144407913-1156534234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就两个参数，咱们配置了一个。再来看看配置安装程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225144502469-902223650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仅此而已，然后就是上面的扩展方法，给注册就ok了。&lt;/p&gt;
&lt;p&gt;如何用这些配置尼？看provider类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Copyright (c) .NET Foundation. All rights reserved.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.&lt;/span&gt;

&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Concurrent;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging.Console.Internal;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Walt.Freamwork.Log
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IConsoleLoggerSettings is obsolete&lt;/span&gt;
&lt;span&gt;#pragma&lt;/span&gt; warning disable CS0618 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Type or member is obsolete&lt;/span&gt;&lt;span&gt;

    [ProviderAlias(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KafkaLog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)] &lt;span&gt;//还记得上面讲原理是注入了providerconfiguration等类，就是根据这个别名去找配直节的。
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomizationLoggerProvider : ILoggerProvider, ISupportExternalScope
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, CustomizationLogger&amp;gt; _loggers =
         &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, CustomizationLogger&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Func&amp;lt;&lt;span&gt;string&lt;/span&gt;, LogLevel, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; _filter; 
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; CustomizationLoggerProcessor _messageQueue = 
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomizationLoggerProcessor();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Func&amp;lt;&lt;span&gt;string&lt;/span&gt;, LogLevel, &lt;span&gt;bool&lt;/span&gt;&amp;gt; trueFilter = (cat, level) =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Func&amp;lt;&lt;span&gt;string&lt;/span&gt;, LogLevel, &lt;span&gt;bool&lt;/span&gt;&amp;gt; falseFilter = (cat, level) =&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IDisposable _optionsReloadToken;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; _includeScopes; 

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _prix;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IExternalScopeProvider _scopeProvider;

 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CustomizationLoggerProvider(IOptionsMonitor&amp;lt;CustomizationLoggerOptions&amp;gt;&lt;span&gt; options)  &lt;br/&gt;&lt;span&gt;//这里自动和configuration中的值绑定后，被注入到这里来了。&lt;/span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Filter would be applied on LoggerFactory level&lt;/span&gt;
            _filter =&lt;span&gt; trueFilter;
          
            _optionsReloadToken &lt;/span&gt;=&lt;span&gt; options.OnChange(ReloadLoggerOptions); &lt;span&gt;//这个就是我说的需要注册token服务，然后配置更改就会激发这个方法&lt;/span&gt;
            ReloadLoggerOptions(options.CurrentValue);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReloadLoggerOptions(CustomizationLoggerOptions options)
        {
            _includeScopes &lt;/span&gt;=&lt;span&gt; options.IncludeScopes; 
              _prix&lt;/span&gt;=&lt;span&gt;options.Prix;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scopeProvider =&lt;span&gt; GetScopeProvider();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; logger &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _loggers.Values)
            {
                logger.ScopeProvider &lt;/span&gt;=&lt;span&gt; scopeProvider; 
            }
        }

  
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetKeyPrefixes(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(name))
            {
                &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastIndexOfDot = name.LastIndexOf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastIndexOfDot == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                name &lt;/span&gt;= name.Substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, lastIndexOfDot);
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IExternalScopeProvider GetScopeProvider()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_includeScopes &amp;amp;&amp;amp; _scopeProvider == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                _scopeProvider &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerExternalScopeProvider();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _includeScopes ? _scopeProvider : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            _optionsReloadToken&lt;/span&gt;?&lt;span&gt;.Dispose();
            _messageQueue.Dispose();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetScopeProvider(IExternalScopeProvider scopeProvider)
        {
            _scopeProvider &lt;/span&gt;=&lt;span&gt; scopeProvider;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ILogger CreateLogger(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _loggers.GetOrAdd(name, CreateLoggerImplementation);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; CustomizationLogger CreateLoggerImplementation(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; includeScopes =&lt;span&gt;  _includeScopes; 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;  CustomizationLogger(name,&lt;span&gt;null&lt;br/&gt;&lt;/span&gt;,includeScopes? _scopeProvider: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,_messageQueue,_prix); &lt;span&gt;//这里就是你的终端类了，里面实现为kafka发消息或者写到redis都行。&lt;/span&gt;
       
            
        }
    }
&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning restore CS0618&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt; 下面打包然后上传到nuget服务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225144916557-1513420221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 调用方查看包&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225145018742-596761369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果没有这个包 dotnet add添加，如果有，直接把project项目文件中的包版本改以下，restore就ok了。&lt;/p&gt;
&lt;p&gt;下面进行调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225145453048-2013940811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行：还记得配置文件中的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225145533734-1437371148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就是用来做测试的，目前输出还是用console：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225145745353-773319886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225145812320-563509091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;customizationLogger的程序是从console那个提供程序中挖过来的，console中有很多的上一个版本的代码，而我肯定是需要新的，所以把Obsolete的代码全部删除。&lt;/p&gt;
&lt;p&gt;这是console的程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181225115838548-1621995012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;日志第三部分讲集成kafka，希望大家关注和讨论。&lt;/p&gt;

</description>
<pubDate>Tue, 25 Dec 2018 07:01:00 +0000</pubDate>
<dc:creator>一夜寒江</dc:creator>
<og:description>一 netcore日志原理 netcore的日志是作为一个扩展库存在的，每个组件都有它的入口，那么作为研究这个组件的入口是最好的，首先看两种方式： 这个是源码例子提供的。 1 var loggingC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ck0074451665/p/10171668.html</dc:identifier>
</item>
<item>
<title>Socket 编程之 TCP 实现 - 余同学的开发之路</title>
<link>http://www.cnblogs.com/YJK923/p/10173918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/10173918.html</guid>
<description>&lt;p&gt;前几天介绍了计算机网络的一些概念，并介绍了几个协议。下面就说说 Java 中的 Socket 编程，服务器和客户端是如何通信的呢？&lt;/p&gt;

&lt;p&gt;首先要介绍一下 Socket ，我们知道在 TCP/IP 协议簇中，TCP、UDP 协议都是在传输层，应用层基于传输层进行通信。而 Socket 可以看成是对 TCP 、UDP 协议的实现。具体到编程的时候，要看业务选择是使用 TCP 还是 UDP 协议。今天主要讲的就是基于 TCP 通信的 Socket 实现。若你对 TCP 还不熟悉。&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MzY4Nzg0OQ==&amp;amp;mid=2247484047&amp;amp;idx=1&amp;amp;sn=8fb05f571aa66559b4d09787fbb68e72&amp;amp;chksm=eb1e36c9dc69bfdf971ad94830830c27fe0c91b575fdf78503dc2b621e82f85fddbb74b1787b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;可以看这篇文章。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Java 中为 TCP 协议提供了两个类：Socket 类和 ServerSocket 类。一个 Socket 实例代表了 TCP 连接的一个客户端，而一个 ServerSocket 实例代表了 TCP 连接的一个服务器端，一般在 TCP Socket 编程中，客户端有多个，而服务器端只有一个，客户端 TCP 向服务器端 TCP 发送连接请求，服务器端的 ServerSocket 实例则监听来自客户端的 TCP 连接请求，并为每个请求创建新的 Socket 实例，由于服务端在调用 accept（）等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码，因此要为每个 Socket 连接开启一个线程（这里就是多线程的应用啊）。服务器端要同时处理 ServerSocket 实例和 Socket 实例，而客户端只需要使用 Socket 实例。&lt;/p&gt;

&lt;p&gt;另外，每个 Socket 实例会关联一个 InputStream 和 OutputStream 对象，我们通过将字节写入 Socket 的 OutputStream 来发送数据，并通过从 InputStream 来接收数据。&lt;/p&gt;

&lt;p&gt;好吧，上面的描述可能有点懵，下面就来看一个 demo。使用 Socket 实现一个简单的交互，在服务器端使用多线程来处理请求。&lt;/p&gt;

&lt;p&gt;客户端实现如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Client {
    public static void main(String[] args) throws IOException {
        Socket socket = null;
        PrintWriter pw = null;
        BufferedReader br = null;
        try {
            // 创建Socket对象，指明需要连接的服务器地址和端口
            socket = new Socket(&quot;localhost&quot;, 6688);

            // 连接建立后，通过 Socket 输出流向服务器端发送请求信息 
            pw = new PrintWriter(socket.getOutputStream());
            pw.write(&quot;Hello , server . I'm Client !&quot;);
            pw.flush();
            socket.shutdownOutput();

            // 通过输入流获取服务器端返回的响应信息；
            br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String info = null;
                while((info = br.readLine()) != null){
                    System.out.println(&quot;服务器返回信息： &quot;+ info);
            }
            socket.shutdownInput();

        ----后面的错误处理和关闭资源省略-----
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务器端实现如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Server {
    public static void main(String[] args) throws IOException {
        Socket socket = null;
        try {
            // 创建ServerSocket对象，绑定监听端口
            ServerSocket serverSocket = new ServerSocket(6688);
            while(true){
                // 通过accept()方法监听客户端请求
                socket =serverSocket.accept();
                ServerThread serverThread = new ServerThread(socket);
                serverThread.start();
            }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;线程具体实现如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ServerThread extends Thread {
    Socket socket = null;
    BufferedReader br = null;
    PrintWriter pw = null;

    public ServerThread(Socket socket){
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            // 连接建立后，通过输入流读取客户端发送的请求信息 msg
            br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            StringBuffer msg = new StringBuffer();
            String info = null;
            while((info = br.readLine()) != null){
                msg.append(info);
            }
            System.out.println(&quot;服务器收到 [ &quot;+ socket.getInetAddress()+&quot; ] 的消息 [ &quot; + msg+&quot; ]&quot;);
            socket.shutdownInput();

            // 通过输出流向客户端发送相应信息
            pw = new PrintWriter(socket.getOutputStream());
            pw.write(&quot; success !&quot;);
            pw.flush();
            socket.shutdownOutput();
        } 
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结一下 Socket TCP 中实战的步骤。&lt;/p&gt;

&lt;p&gt;服务器端：&lt;/p&gt;
&lt;p&gt;(1) 创建ServerSocket对象，绑定监听端口；&lt;br/&gt;(2) 通过accept()方法监听客户端请求；&lt;br/&gt;(3) 连接建立后，通过输入流读取客户端发送的请求信息；&lt;br/&gt;(4) 通过输出流向客户端发送相应信息；&lt;/p&gt;
&lt;p&gt;(5) 关闭响应资源。&lt;/p&gt;

&lt;p&gt;客户端：&lt;/p&gt;
&lt;p&gt;(1) 创建Socket对象，指明需要连接的服务器地址和端口；&lt;br/&gt;(2) 连接建立后，通过输出流向服务器端发送请求信息；&lt;br/&gt;(3) 通过输入流获取服务器端返回的响应信息；&lt;/p&gt;
&lt;p&gt;(4) 关闭响应资源。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1 首先执行服务器端代码。&lt;/p&gt;
&lt;p&gt;2 服务器端执行之后默认就一直在等待客户端的连接请求。&lt;/p&gt;
&lt;p&gt;3 以上只是一个非常基础的案例，这只是 Socket 编程的冰山一角。&lt;/p&gt;
&lt;p&gt;4 可以优化的地方还有很多，服务器端参数的优化，如，接受数据的缓冲区大小、等待客户端连接的最长时间、使用线程池处理请求等。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 06:54:00 +0000</pubDate>
<dc:creator>余同学的开发之路</dc:creator>
<og:description>前几天介绍了计算机网络的一些概念，并介绍了几个协议。下面就说说 Java 中的 Socket 编程，服务器和客户端是如何通信的呢？ 首先要介绍一下 Socket ，我们知道在 TCP/IP 协议簇中，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/10173918.html</dc:identifier>
</item>
<item>
<title>0/1分数规划？我不会啊！ - Judge_Cheung</title>
<link>http://www.cnblogs.com/Judge/p/10173795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Judge/p/10173795.html</guid>
<description>&lt;p&gt;最近入门了 0/1 分数规划，于是写篇博客纪念&lt;/p&gt;
&lt;p&gt;分数规划是一项不常用到的（但还蛮实用的）算法，一般来讲就是求一个最优比率。&lt;/p&gt;
&lt;h2 id=&quot;分数规划的简单介绍&quot;&gt;分数规划的简单介绍&lt;/h2&gt;
&lt;p&gt;分数规划顾名思义就是求一个分数表达式的最大（小）值。&lt;/p&gt;
&lt;p&gt;比如说有 n 个物品，每个物品有两个权值 a 和 b ，然后让你选出&lt;strong&gt;任意件数&lt;/strong&gt;（但可能会有限制）的物品，使得两个&lt;strong&gt;权值和&lt;/strong&gt;间的比值最大，即求 &lt;span class=&quot;math inline&quot;&gt;\(\dfrac{\sum_{i=1}^{k} a[i]}{\sum_{j=1}^{k} b[j]}\)&lt;/span&gt; （在这里 &lt;span class=&quot;math inline&quot;&gt;\(1-k\)&lt;/span&gt; 为挑出的 k 件物品）的最大值，然后对选择物品方面给出&lt;strong&gt;一定的限制条件&lt;/strong&gt;，那么一道 0/1 分数规划的题目就完成了&lt;/p&gt;
&lt;h2 id=&quot;分数规划的求解方法&quot;&gt;分数规划的求解方法&lt;/h2&gt;
&lt;p&gt;分数规划有两种求解方法，一种是 &lt;strong&gt;二分法&lt;/strong&gt;，而另一种则是 &lt;strong&gt;Dinkelbach 算法&lt;/strong&gt;，一般来讲我们选用第一种方法进行分数规划求解&lt;/p&gt;
&lt;h3 id=&quot;二分法&quot;&gt;1.二分法&lt;/h3&gt;
&lt;p&gt;问题同上，求 &lt;span class=&quot;math inline&quot;&gt;\(\dfrac{\sum_{i=1}^{k} a[i]}{\sum_{j=1}^{k} b[j]}\)&lt;/span&gt; 的最大值，然后加上一个限制：&lt;span class=&quot;math inline&quot;&gt;\(k&amp;gt;=W\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们令 &lt;span class=&quot;math inline&quot;&gt;\(sum=\sum_{i=1}^{k} a[i] ,\ tot=\sum_{j=1}^{k} b[j]\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(k&amp;gt;=W\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后假设问题中的最优解为 &lt;span class=&quot;math inline&quot;&gt;\(ans\)&lt;/span&gt; ，那么必然有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\dfrac{sum}{tot}&amp;lt;=ans\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;移项得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[sum&amp;lt;=ans\times tot\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;继续移就得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[sum-ans\times tot&amp;lt;=0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样转化有什么用呢？那我们尝试将 &lt;span class=&quot;math inline&quot;&gt;\(sum\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(tot\)&lt;/span&gt; 带回去，就可以得到这么一个式子：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{i=1}^{k} (a[i]-b[i]\times ans) &amp;lt;=0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个式子不难理解，就是把整体的贡献转化为了单件物品的贡献。&lt;/p&gt;
&lt;p&gt;那么我们只需要二分这个 ans， 计算出每件物品的 &lt;span class=&quot;math inline&quot;&gt;\(a-b\times ans\)&lt;/span&gt;，然后排个序，贪心取前 &lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt; 个加起来，看看最后的值是否 &lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;=0\)&lt;/span&gt; ，然后就可以根据结果移动左右边界了。&lt;/p&gt;
&lt;h3 id=&quot;dinkelbach-算法&quot;&gt;2.Dinkelbach 算法&lt;/h3&gt;
&lt;p&gt;这个算法其实就是以二分函数图像的单调性为原理，利用了check中计算得出的结果，通过&lt;strong&gt;改变二分枚举的中间点在图像上的位置&lt;/strong&gt;来优化二分。&lt;/p&gt;
&lt;p&gt;然后先给一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20170206231632579?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHpvaV96dHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里我们看到每次枚举的中间点都在一条直线上（但单一的直线并不是二分的函数图像），那么对于枚举出的中间点其实可以不着急扔，先计算出当前点所在的直线，然后找到这条直线在 x 轴上的截距，用这个截距作为下一次二分的中间点，这样可能会更快逼近正确答案&lt;/p&gt;
&lt;p&gt;然鹅这个算法的效果却不见的有多么优秀，因为二分的函数图像有可能是&lt;strong&gt;坑坑洼洼的&lt;/strong&gt;，所以有时这个算法跑数据的时间反而比二分大，但是如果图像是&lt;strong&gt;较为光滑的弧线&lt;/strong&gt;，或许&lt;span class=&quot;math inline&quot;&gt;\(Dinkelbach\)&lt;/span&gt; 算法就能充分展现它的优势了&lt;/p&gt;
&lt;p&gt;至于其他的地方（包括证明），和二分其实差不多，就不啰嗦了&lt;/p&gt;
&lt;h2 id=&quot;分数规划的有机结合&quot;&gt;分数规划的有机结合&lt;/h2&gt;
&lt;p&gt;分数规划一般来讲不会单独成题，一般来讲有以下几种形式：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;0.不与任何算法结合，即分数规划裸题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1.与&lt;span class=&quot;math inline&quot;&gt;\(0/1\)&lt;/span&gt;背包结合，即最优比率背包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2.与生成树结合，即最优比率生成树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3.与负环判定结合，即最优比率环&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4.与网络流结合，即最大密度子图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;5.与费用流结合，即最优比率流（这个是我乱叫的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;6.与其他的各种带选择的算法乱套，即最优比率啥啥的...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于上面的后三个结合图论算法，其实类似是把供选择的物品变为了图中的边，然后限制条件求解最优比率。&lt;/p&gt;
&lt;h3 id=&quot;分数规划裸题&quot;&gt;0.分数规划裸题&lt;/h3&gt;
&lt;p&gt;这个在介绍二分算法的时候讲过了&lt;/p&gt;
&lt;h4 id=&quot;题目&quot;&gt;题目&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2976&quot;&gt;Dropping tests&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//by Judge
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define eps 1e-4
using namespace std;
const int M=1005;
#ifndef Judge
#define getchar() (p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,1&amp;lt;&amp;lt;21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1&amp;lt;&amp;lt;21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,k; double a[M],b[M],c[M],l,r=1e6,mid,sum;
inline bool check(){
    for(int i=1;i&amp;lt;=n;++i)
        c[i]=a[i]-b[i]*mid;
    sort(c+1,c+1+n),sum=0;
    for(int i=k;i&amp;lt;=n;++i)
        sum+=c[i];
    return sum&amp;gt;=0;
}
int main(){
    while(1){
        n=read(),k=read();
        if(!n&amp;amp;&amp;amp;!k) return 0;
        l=0,r=1e6,++k;
        for(int i=1;i&amp;lt;=n;++i)
            a[i]=read();
        for(int i=1;i&amp;lt;=n;++i)
            b[i]=read();
        while(r-l&amp;gt;eps){
            mid=(l+r)/2;
            check()?l=mid:r=mid;
        }
        printf(&quot;%.0lf\n&quot;,100.0*l);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最优比率背包&quot;&gt;1.最优比率背包&lt;/h3&gt;
&lt;p&gt;题目大意和裸题的差不多，也是求 n 个物品中，&lt;span class=&quot;math inline&quot;&gt;\(\dfrac{\sum_{i=1}^{k} a[i]}{\sum_{j=1}^{k} b[j]}\)&lt;/span&gt; 的最大值，但是条件有变化，这次我们要对权值 b 进行限制，首先我们还是令 &lt;span class=&quot;math inline&quot;&gt;\(sum=\sum_{i=1}^{k} a[i] ,\ tot=\sum_{j=1}^{k} b[j]\)&lt;/span&gt; ，那么限制条件就是 &lt;span class=&quot;math inline&quot;&gt;\(tot&amp;gt;=W\)&lt;/span&gt;（&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;已给出）&lt;/p&gt;
&lt;p&gt;那么这个时候我们设完 &lt;span class=&quot;math inline&quot;&gt;\(ans\)&lt;/span&gt; 之后得到的式子同样是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{i=1}^{k} (a[i]-b[i]\times ans) &amp;lt;=0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;于是 &lt;span class=&quot;math inline&quot;&gt;\(ans\)&lt;/span&gt; 照常二分，对于条件成立的判断方式变一变就好了。&lt;/p&gt;
&lt;p&gt;其实你应该也猜到了判断方式，原先我们不是贪心取前面的 k 个数么，那这次我们把贪心改成背包就好了啊&lt;/p&gt;
&lt;p&gt;那样的话，对于每个物品来说，体积就是 b ，而价值就是上面的 &lt;span class=&quot;math inline&quot;&gt;\(a[i]-b[i]\times ans\)&lt;/span&gt;，然后我们跑 0/1 背包，判断满背包价值的正负性。&lt;/p&gt;
&lt;h4 id=&quot;题目-1&quot;&gt;题目&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4377&quot;&gt;Talent Show&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码-1&quot;&gt;代码&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//by Judge
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define ll long long
using namespace std;
#ifndef Judge
#define getchar() (p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,1&amp;lt;&amp;lt;21,stdin),p1==p2)?EOF:*p1++)
#endif
inline void cmax(ll&amp;amp; a,ll b){if(a&amp;lt;b)a=b;}
inline int Min(int a,int b){return a&amp;lt;b?a:b;}
char buf[1&amp;lt;&amp;lt;21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,l,r=1e6,mid,V,t[305]; ll w[305],f[10005];
inline bool check(int tim){
    memset(f,-0x3f,sizeof(f)),f[0]=0;
    ll tmp=f[V];
    for(int i=1,j,k;i&amp;lt;=n;++i)
        for(j=V;~j;--j) if(f[j]!=tmp){
            cmax(f[Min(j+w[i],V)],f[j]+t[i]-w[i]*tim);
        }
    return f[V]&amp;gt;=0;
}
inline int calc(){
    while(l&amp;lt;=r){
        mid=l+r&amp;gt;&amp;gt;1;
        check(mid)?l=mid+1:r=mid-1;
    }
    return r;
}
int main(){
    n=read(),V=read();
    for(int i=1;i&amp;lt;=n;++i){
        w[i]=read(),
        t[i]=read()*1000;
    }
    return !printf(&quot;%d\n&quot;,calc());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最优比率生成树&quot;&gt;2.最优比率生成树&lt;/h3&gt;
&lt;p&gt;对于构造最优比率生成树的分数规划，其实差不多类似是将 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 物品转换为 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 条边，然后求解，只不过限制改了，选出的 &lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt; 条边要构成一棵树&lt;/p&gt;
&lt;p&gt;具体点说，题目一般会给你一张图（有时候是完全图），然后给你 n 个点 m 条边，求出原图包含 n 个点的一棵树，使得&lt;strong&gt;所选的边的两个权值和比值&lt;/strong&gt;最大&lt;/p&gt;
&lt;p&gt;那么求法呢，其实也很类似：&lt;/p&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们考虑构造最小生成树的时候，边是从小到大加的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么对于每一条边，我们让他的边权为 &lt;span class=&quot;math inline&quot;&gt;\(a[i]-b[i]\times ans\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;然后和克鲁斯卡尔一样排个序一条一条尝试加就好了（然鹅有时候你得尝试普里姆算法）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果加成功了就累计入 &lt;span class=&quot;math inline&quot;&gt;\(sum\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后根据 &lt;span class=&quot;math inline&quot;&gt;\(sum\)&lt;/span&gt; 的正负性来判断 &lt;span class=&quot;math inline&quot;&gt;\(check\)&lt;/span&gt; 的返回值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实和前面两个没高明到哪里去，基本想法一样的&lt;/p&gt;
&lt;h4 id=&quot;题目-2&quot;&gt;题目&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2728&quot;&gt;Desert King&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码-2&quot;&gt;代码&lt;/h4&gt;
&lt;p&gt;（慢着，kruskal会炸？还是我打开方式不对？只好开 &lt;span class=&quot;math inline&quot;&gt;\(Prim\)&lt;/span&gt; ）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//by Judge
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define eps 1e-5
using namespace std;
const int M=1005;
#ifndef Judge
#define getchar() (p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,1&amp;lt;&amp;lt;21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1&amp;lt;&amp;lt;21],*p1=buf,*p2=buf;
inline bool cmin(double&amp;amp; a,double b){return a&amp;gt;b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,pat,x[M],y[M],z[M],vis[M];
double f[M][M],g[M][M],minv[M];
double l,r,mid,sum,tmp;
inline bool check(){
    memset(vis,0,sizeof(vis));
    sum=0,vis[1]=1;
    for(int i=1;i&amp;lt;=n;++i)
        minv[i]=g[1][i]-f[1][i]*mid;
    for(int i=2,j,k;i&amp;lt;=n;++i){
        for(tmp=1e16,k=-1,j=2;j&amp;lt;=n;++j)
            if(!vis[j]&amp;amp;&amp;amp;cmin(tmp,minv[j])) k=j;
        if(k==-1) break;
        for(vis[k]=1,sum+=tmp,j=2;j&amp;lt;=n;++j) if(!vis[j])
            cmin(minv[j],g[k][j]-f[k][j]*mid);
    }
    return sum&amp;gt;=0;
}
inline double dis(int i,int j){
    static double dx,dy;
    dx=x[i]-x[j],dy=y[i]-y[j];
    return sqrt(dx*dx+dy*dy);
}
int main(){
    while(1){
        n=read();
        if(!n) return 0;
        for(int i=1;i&amp;lt;=n;++i){
            x[i]=read(),
            y[i]=read(),
            z[i]=read();
        }
        for(int i=1;i&amp;lt;=n;++i)
            for(int j=i+1;j&amp;lt;=n;++j)
                f[j][i]=f[i][j]=dis(i,j),
                g[j][i]=g[i][j]=abs(z[i]-z[j]);
        l=0,r=100;
        while(r-l&amp;gt;eps){
            mid=(l+r)/2,
            (check()?l:r)=mid;
        }
        printf(&quot;%.3lf\n&quot;,l);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最优比率环&quot;&gt;3.最优比率环&lt;/h3&gt;
&lt;p&gt;简而言之，最优比率环就是给你一个图，图上每条边有两个权值（当然，第二个权值可能恒为 1 ），然后让你在图中找到一个环，令&lt;strong&gt;环上边的个两个权值和的比值&lt;/strong&gt;最大（或是最小）&lt;/p&gt;
&lt;p&gt;然后就是要用上面生成树类似的思路，得到每条边边权为： &lt;span class=&quot;math inline&quot;&gt;\(a[i]-b[i]\times ans\)&lt;/span&gt; ，然后在图上找负环（有时是正环，但是正负环可以人工转化的嘛），找到就 &lt;span class=&quot;math inline&quot;&gt;\(check\)&lt;/span&gt; 成功&lt;/p&gt;
&lt;h4 id=&quot;题目-3&quot;&gt;题目&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3199&quot;&gt;[HNOI2009]最小圈&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码-3&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//by Judge
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define eps 1e-10
using namespace std;
const int M=1e5+7;
inline bool cmin(double&amp;amp; a,double b){return a&amp;gt;b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,m,tim,pat,head[M],vis[M]; double l,r,mid,d[M];
struct Edge{ int to,next; double val; Edge(){}
    Edge(int a,double b,int c){ to=a,val=b,next=c; }
}e[M&amp;lt;&amp;lt;1];
inline void add(int u,int v,double z){
    e[++pat]=Edge(v,z,head[u]),head[u]=pat;
}
bool dfs(int u){ vis[u]=1;
    for(int i=head[u];i;i=e[i].next)
        if(cmin(d[e[i].to],d[u]+e[i].val-mid))
            if(vis[e[i].to]||dfs(e[i].to))
                return vis[u]=0,1;
    return vis[u]=0;
}
inline bool check(){
    memset(d,0,sizeof(d));
    for(int i=1;i&amp;lt;=n;++i)
        if(dfs(i)) return 1;
    return 0;
}
int main(){ n=read(),m=read(); double z;
    for(int i=1,x,y;i&amp;lt;=m;++i){
        x=read(),y=read();
        scanf(&quot;%lf&quot;,&amp;amp;z);
        add(x,y,z);
        if(z&amp;lt;0) l+=z; else r+=z;
    }
    while(r-l&amp;gt;eps){
        mid=(l+r)/2,
        (check()?r:l)=mid;
    }
    return !printf(&quot;%.8lf\n&quot;,l);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最大密度子图&quot;&gt;4.最大密度子图&lt;/h3&gt;
&lt;p&gt;题目一般就是给出 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个点然后让你导出一个子图，让这个子图中&lt;strong&gt;边数与点数的比值&lt;/strong&gt;最大&lt;/p&gt;
&lt;p&gt;不过有时候题目中的边（甚至是点）可能会带上权值，那么具体问题具体分析就好了&lt;/p&gt;
&lt;h4 id=&quot;题目-4&quot;&gt;题目&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/UVA1389&quot;&gt;Hard Life&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（话说这道题翻译照搬的&lt;span class=&quot;math inline&quot;&gt;\(bzoj\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(UVA\)&lt;/span&gt; 是要输出方案的啊...）&lt;/p&gt;
&lt;h4 id=&quot;代码-4&quot;&gt;代码&lt;/h4&gt;
&lt;p&gt;（好像就这个代码最长了，题目讲得简单然鹅码量巨大）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//by Judge
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define db double
using namespace std;
const db eps=1e-8;const int N=1005;
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,m,S,T,pat,ans,h[N],q[N],head[N],cur[N];
int u[N],v[N],du[N],vis[N]; db U,l,r,mid;
struct Edge { int to,nxt; db flow; } e[N&amp;lt;&amp;lt;5];
void insert(int u,int v,db w) {
    e[++pat]=(Edge){v,head[u],w},head[u]=pat;
    e[++pat]=(Edge){u,head[v],0},head[v]=pat;
}
#define v e[i].to
inline bool bfs() { int hd=0,tl=1,u;
    memset(h,0,sizeof(h)),h[q[1]=S]=1;
    while(hd&amp;lt;tl) { u=q[++hd];
        for(int i=head[u]; i; i=e[i].nxt)
            if(e[i].flow&amp;gt;eps&amp;amp;&amp;amp;!h[v])
                h[v]=h[u]+1,q[++tl]=v;
    } return h[T];
}
db dfs(int x,db F) {
    if(x==T) return F; db w,used=0;
    for(int &amp;amp;i=cur[x]; i; i=e[i].nxt)
        if(h[x]+1==h[v]) {
            w=dfs(v,min(e[i].flow,F-used));
            e[i].flow-=w,e[i^1].flow+=w;
            used+=w; if(used==F) return F;
        }
    if(!used) h[x]=0;
    return used;
}
db dinic() { db res=0;
    for(;bfs();res+=dfs(S,1e16))
        memcpy(cur,head,sizeof(cur));
    return res;
}
void DFS(int x) { ++ans,vis[x]=1;
    for(int i=head[x]; i; i=e[i].nxt)
        if(e[i].flow&amp;gt;eps&amp;amp;&amp;amp;!vis[v]) DFS(v);
}
#undef v
inline bool check() {
    pat=1,S=0,T=n+1;
    memset(head,0,sizeof(head));
    for(int i=1; i&amp;lt;=n; ++i){
        insert(S,i,U),
        insert(i,T,U+mid+mid-du[i]);
    }
    for(int i=1; i&amp;lt;=m; ++i){
        insert(u[i],v[i],1),
        insert(v[i],u[i],1);
    }
    return U*n-dinic()&amp;gt;eps;
}
int main() {
    while(scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m)!=EOF) {
        for(int i=0; i&amp;lt;=n; ++i) du[i]=0;
        memset(vis,0,sizeof(vis)),ans=-1,U=m;
        if(!m) {puts(&quot;1\n1\n\n&quot;);continue;}
        for(int i=1; i&amp;lt;=m; ++i)
            u[i]=read(),v[i]=read(),
            ++du[u[i]],++du[v[i]];
        for(l=0,r=m;r-l&amp;gt;1.0/n/n;){
            mid=(l+r)/2,
            (check()?l:r)=mid;
        }
        mid=l,check(),DFS(S);
        printf(&quot;%d\n&quot;,ans);
        for(int i=1; i&amp;lt;=n; ++i)
            if(vis[i]) printf(&quot;%d\n&quot;,i);
    } return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最优比率流&quot;&gt;5.最优比率流&lt;/h3&gt;
&lt;p&gt;还是那句老话，和之前一样的，就是根据二分出来的答案赋边权，然后一般是每次建一边图跑费用流根据最小费用的正负性判断 &lt;span class=&quot;math inline&quot;&gt;\(ans\)&lt;/span&gt; 合法性（用 &lt;span class=&quot;math inline&quot;&gt;\(zkw\)&lt;/span&gt; 跑费用流有时候会挂，比如这个例题，当然可能是我天生大常数那就 &lt;span class=&quot;math inline&quot;&gt;\(GG\)&lt;/span&gt; ）&lt;/p&gt;
&lt;h4 id=&quot;题目-5&quot;&gt;题目&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3705&quot;&gt;[SDOI2017]新生舞会&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（这里是一道二分图最大费用最大流，但是代码实现中可以边权取反然后跑最小费用）&lt;/p&gt;
&lt;h4 id=&quot;代码-5&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//by Judge
#include&amp;lt;queue&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define eps 1e-8
#define ll long long
using namespace std;
const double inf=1e18+7;
const int M=205;
#ifndef Judge
#define getchar() (p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,1&amp;lt;&amp;lt;21,stdin),p1==p2)?EOF:*p1++)
#endif
inline int Min(int a,int b){return a&amp;lt;b?a:b;}
inline bool cmax(double&amp;amp; a,double b){return a&amp;lt;b?a=b,1:0;}
char buf[1&amp;lt;&amp;lt;21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,S,T,pat=1,tot,head[M],cur[M]; ll a[M][M],b[M][M];
int inq[M],vis[M]; double l,r=1e4,mid,ans,dis[M]; queue&amp;lt;int&amp;gt; q;
struct Edge{ int to,flow,next; double val;
    Edge(int a,double b,int c,int d){
        to=a,val=b,flow=c,next=d;
    } Edge(){}
}e[M*M*M];
inline void add(int u,int v,double c,int w){
    e[++pat]=Edge(v,c,w,head[u]),head[u]=pat;
    e[++pat]=Edge(u,-c,0,head[v]),head[v]=pat;
}
#define v e[i].to
inline bool spfa(){
    for(int i=S;i&amp;lt;=T;++i)
        dis[i]=-inf,vis[i]=0;
    dis[S]=0,q.push(S);
    while(!q.empty()){
        int u=q.front();
        q.pop(),vis[u]=0;
        for(int i=head[u];i;i=e[i].next)
            if(e[i].flow&amp;amp;&amp;amp;cmax(dis[v],dis[u]+e[i].val))
                if(!vis[v]) vis[v]=1,q.push(v);
    } return dis[T]!=-inf;
}
int dfs(int u,int flow){
    if(u==T) return ans+=dis[T]*flow,flow;
    int res=0; vis[u]=1;
    for(int &amp;amp;i=cur[u],k;i;i=e[i].next)
        if(dis[v]==dis[u]+e[i].val)
            if(!vis[v]&amp;amp;&amp;amp;e[i].flow){
                k=dfs(v,Min(e[i].flow,flow-res));
                if(k){
                    res+=k;
                    e[i].flow-=k;
                    e[i^1].flow+=k;
                    if(res==flow)
                        break;
                }
            }
    return res;
}
inline bool check(){
    pat=1,ans=0,
    memset(head,0,sizeof(head));
    for(int i=1;i&amp;lt;=n;++i){
        add(S,i,0,1),
        add(n+i,T,0,1);
    }
    for(int i=1;i&amp;lt;=n;++i) 
        for(int j=1;j&amp;lt;=n;++j)
            add(i,n+j,a[i][j]-b[i][j]*mid,1);
    for(;spfa();dfs(S,1e9))
        memcpy(cur,head,sizeof(cur));
    return ans&amp;lt;=0;
}
int main(){
    n=read(),T=n+1&amp;lt;&amp;lt;1;
    for(int i=1;i&amp;lt;=n;++i)
        for(int j=1;j&amp;lt;=n;++j)
            a[i][j]=read();
    for(int i=1;i&amp;lt;=n;++i)
        for(int j=1;j&amp;lt;=n;++j)
            b[i][j]=read();
    for(tot=pat;r-l&amp;gt;eps;){
        mid=(l+r)/2,
        (check()?r:l)=mid;
    }
    return !printf(&quot;%.6lf\n&quot;,l);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;各种其他结合&quot;&gt;6.各种其他结合&lt;/h3&gt;
&lt;p&gt;暂无更新&lt;/p&gt;
&lt;h2 id=&quot;分数规划的一点感想&quot;&gt;分数规划的一点感想&lt;/h2&gt;
&lt;p&gt;讲道理，其实分数规划这个东西哪儿都能套，然鹅现在关于分数规划的题目却并不是很多，至少没有到泛滥的地步，不过相信在不（知道多）久的将来，分数规划会成为人尽皆知的一种算法&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[tHe\ EnD\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哦，对了，参考文献？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hzoi_ztx/article/details/54898323&quot;&gt;01分数规划问题相关算法与题目讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.xuebuyuan.com/3225634.html&quot;&gt;poj 3155 (最大密度子图)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外的另外，&lt;strong&gt;有时间的话&lt;/strong&gt;会把自己出的分数规划的题目放到&lt;strong&gt;6&lt;/strong&gt;这块内容上来&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 06:34:00 +0000</pubDate>
<dc:creator>Judge_Cheung</dc:creator>
<og:description>最近入门了 0/1 分数规划，于是写篇博客纪念 分数规划是一项不常用到的（但还蛮实用的）算法，一般来讲就是求一个最优比率。 分数规划的简单介绍 分数规划顾名思义就是求一个分数表达式的最大（小）值。 比</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Judge/p/10173795.html</dc:identifier>
</item>
<item>
<title>redis 系列26 Cluster高可用 (1) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10169394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10169394.html</guid>
<description>&lt;h3&gt;一.概述&lt;/h3&gt;
&lt;p&gt;　　Redis集群提供了分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。在大数据量方面的高可用方案，cluster集群比Sentinel有优势。但Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据，而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误。学习集群同样先了解一些原理方面包括：节点、槽指派、命令执行、重新分片，转向、故障转移、消息。后面再操作集群演示。关于集群搭建后面会列出实现步骤，也可参考Redis官网的实现步骤：&lt;a href=&quot;http://www.redis.cn/topics/cluster-tutorial.html&quot; target=&quot;_blank&quot;&gt;http://www.redis.cn/topics/cluster-tutorial.html&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;　　1.1 节点&lt;/h4&gt;
&lt;p&gt;　　　　一个Redis集群通常由多个节点(node)组成，开始每个节点都是相互独立的，需要将独立的节点连接起来，构成一个包含多节点的集群。连接各节点的工作使用cluster meet命令来完成，格式如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
        cluster meet ip  port    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　向一个节点发送该命令，可以让发送的节点与指定的节点进行握手，握手成功时，指定的节点就会添加到发送节点当前所在的集群中。例如：有三个独立的节点，端口分别为:7000, 7001,7002。首先使用客户端连接上节点7000, 通过发送cluster nodes命令可以看到，集群目前只包含7000自己一个节点，通过cluster nodes查看信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    /usr/local/redis/&lt;span&gt;bin
    [root@hsr bin]# .&lt;/span&gt;/redis-cli -c -p &lt;span&gt;7000&lt;/span&gt; -a &lt;span&gt;123456&lt;/span&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt;&lt;span&gt; cluster nodes
&lt;span&gt;  &lt;strong&gt;  142116fa16006f39865ebe604d1580c119fa0fea :&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;7000@17000     myself,master - 0 0 0 connected&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　通过向节点7000发送以下命令，可以将节点7001 添加到7000所在的集群中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt; cluster meet &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
    OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　继续向节点7000发送以下命令，可以将节点7002也添加到7000和7001所在的集群中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt; cluster meet &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;7002&lt;/span&gt;&lt;span&gt;
    OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　三个节点握手成功，使三个节点都处于同一个集群中，再次查看集群节点情况，三个节点都connected连接成功：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt;&lt;span&gt; cluster nodes
　　0eed9cc9122d2724365550b70965c2a8e281043d &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7002&lt;/span&gt;@&lt;span&gt;17002&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545632759414&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; connected&lt;/strong&gt;&lt;/span&gt;
　　aeaaeacb8b4d4c4a3bca3c6f52fc4b363e68f083 &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;@&lt;span&gt;17001&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545632758405&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; connected&lt;/strong&gt;&lt;/span&gt;
　　142116fa16006f39865ebe604d1580c119fa0fea &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;@&lt;span&gt;17000&lt;/span&gt; myself,master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545632756000&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;strong&gt;&lt;span&gt;connected&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　　cluster nodes由以下字段组成，表格如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;
&lt;p&gt;&lt;strong&gt;字段名&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;
&lt;p&gt;&lt;strong&gt;节点7002&lt;/strong&gt;&lt;strong&gt;的字段值&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;
&lt;p&gt;id&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;节点 ID，一个40个字符的随机字符串&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;0eed9cc9122d2724365550b70965c2a8e281043d&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;ip:port&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;客户端应该联系节点以运行查询的节点地址&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;127.0.0.1:7002&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;flags&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;逗号列表分隔的标志，myself，master，slave，fail等&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;master&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;master&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;如果节点是从属节点，并且主节点已知，则节点ID为主节点，否则为“ - ”字符&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;ping-sent&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;毫秒为单位的当前激活的ping发送的unix时间&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;1545632759414&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;config-epoch&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;当前节点的配置时期，每次发生故障切换时，都会创建一个新的，唯一的&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;2&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;link-state&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;用于节点到节点集群总线的链路状态。我们使用此链接与节点进行通信&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;connected&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;102&quot;&gt;slot&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;在connected后面还会显示槽号范围&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;202&quot;&gt;分配槽后显示&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5&gt;　　　　(1)  启动节点&lt;/h5&gt;
&lt;p&gt;　　　　　　一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled 配置选项是否为yes来决定是否开启服务器的集群模式。每个节点还是与普通redis服务一样，具备所有功能比如：支持RDB、AOF持久化、发布与订阅、保存键值对、复制 等等。对于集群模式才会用到的数据，内部保存在cluster.h/clusterState结构中。&lt;/p&gt;
&lt;h5&gt;　　　　(2) 集群数据结构&lt;/h5&gt;
&lt;p&gt;　　　　　　内部clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP、Port等等。每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其它节点(包括主从)都会创建一个相应的clusterNode结构, 以此来记录其它节点的状态。该结构中的属性不再介绍，详细请查看&quot;redis设计与实现&quot;书。&lt;/p&gt;
&lt;h5&gt;　　　　(3) cluster meet 命令的实现&lt;/h5&gt;
&lt;p&gt;　　　　上面讲到通过cluster meet 命令，可以使节点与指定的节点进行握手形成集群。假设有节点A和B 握手的步骤包括：&lt;/p&gt;
&lt;p&gt;　　　　　　(1) 在客户端向节点A发送一条 cluster meet  B命令时，节点A会为节点B创建一个ClusterNode结构，并将该结构添加到自己的ClusterState.nodes字典中。&lt;/p&gt;
&lt;p&gt;　　　　　　(2) 向节点B发送meet后，如果顺利节点B将接收到节点A消息，节点B会为节点A创建一个ClusterNode结构, 并将该结构添加到自己的ClusterState.nodes字典中。&lt;/p&gt;
&lt;p&gt;　　　　　　(3) 节点B 将向节点A返回一条PONG消息。&lt;/p&gt;
&lt;p&gt;　　　　　　(4) 节点A接收B返回的消息，能过这条PONG消息节点A知道节点B已经成功接收到了自己发送的MEET消息。&lt;/p&gt;
&lt;p&gt;　　　　　　(5) 节点A将向B返回一条PING消息。&lt;/p&gt;
&lt;p&gt;　　　　　　(6) 节点B将接收A的消息，通过这条PING消息节点B知道节点A已经成功接收到了自己返回的PONG消息，握手成功。&lt;/p&gt;
&lt;p&gt;　　　　之后节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终节点B会被集群中所有节点认识。&lt;/p&gt;

&lt;h4&gt;　　1.2  槽指派　&lt;/h4&gt;
&lt;p&gt; 　　　　Redis集群通过分片的方式来保存数据库中的键值对：集群的整个 数据库被分为16384个槽(slot), 数据库中的每个键都属于这16384 个slot其中一个，集群中的每个节点可以处理0个或最多16384个slot。当数据库中的16384个slot都有在节点中分配时，此时集群处于上线状态(OK)，相反如果任何一个slot没有得到分配，那么集群处于下线状态(fail)。&lt;/p&gt;
&lt;p&gt;　　　　在节点7000的客户端通过cluster info可以查看，因为集群中的三个节点都没有在处理任何slot，所以处于下线状态。能过cluster info来查看集群为fail状态，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt;&lt;span&gt; cluster info
    cluster_state:fail
    cluster_slots_assigned:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    cluster_slots_ok:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    cluster_slots_pfail:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    cluster_slots_fail:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    cluster_known_nodes:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　通向节点发送cluster addslots命令，可以将一个或多个slot指派给某节点负责。例如将slot 0 到5000指派给节点7000负责，手动添加槽时，一定要退出redis客户端，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     [root@hsr bin]# ./redis-cli -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -p &lt;span&gt;7000&lt;/span&gt; -a &lt;span&gt;123456&lt;/span&gt; cluster addslots {&lt;span&gt;0&lt;/span&gt;..&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;}
     OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　在登到redis客户端，查看集群节点的槽分配情况，可以看到7000节点已分配了0-5000的槽范围：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    [root@hsr bin]# ./redis-cli -c -p &lt;span&gt;7000&lt;/span&gt; -a &lt;span&gt;123456&lt;/span&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt;&lt;span&gt; cluster nodes
　　0eed9cc9122d2724365550b70965c2a8e281043d &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7002&lt;/span&gt;@&lt;span&gt;17002&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545635637429&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt; connected
　　aeaaeacb8b4d4c4a3bca3c6f52fc4b363e68f083 &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;@&lt;span&gt;17001&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545635638436&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; connected
　　142116fa16006f39865ebe604d1580c119fa0fea &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;@&lt;span&gt;17000&lt;/span&gt; myself,master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545635635000&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; connected &lt;span&gt;&lt;strong&gt;0-5000&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　为了让7000、7001、7002三个节点所在的集群进入上线状态，继续将slot  5001~10000指派给节点7001。 将slot 10001~16383指派给7002。当三个cluster addslots 命令都执行后，数据库中的16383个slot都已经指派给了相应的节点，集群进入上线状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    [root@hsr bin]# ./redis-cli -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -p &lt;span&gt;7001&lt;/span&gt; -a &lt;span&gt;123456&lt;/span&gt; cluster addslots {&lt;span&gt;5001&lt;/span&gt;..&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;}
    OK
    [root@hsr bin]# .&lt;/span&gt;/redis-cli -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -p &lt;span&gt;7002&lt;/span&gt; -a &lt;span&gt;123456&lt;/span&gt; cluster addslots {&lt;span&gt;10001&lt;/span&gt;..&lt;span&gt;16383&lt;/span&gt;&lt;span&gt;}
    OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　此时已经进入集群进入上线状态：如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt;&lt;span&gt; cluster info
&lt;span&gt;&lt;strong&gt;    cluster_state:ok&lt;/strong&gt;&lt;/span&gt;
    cluster_slots_assigned:&lt;/span&gt;&lt;span&gt;16384&lt;/span&gt;&lt;span&gt;
    cluster_slots_ok:&lt;/span&gt;&lt;span&gt;16384&lt;/span&gt;&lt;span&gt;
    cluster_slots_pfail:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    cluster_slots_fail:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    cluster_known_nodes:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    cluster_size:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt;&lt;span&gt; cluster nodes
　　a9e82a7870ac31c221a4d13b28ba9897bb12257c &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;@&lt;span&gt;17000&lt;/span&gt; myself,master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545704528000&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; connected &lt;span&gt;&lt;strong&gt;0-5000&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
　　3b10786d21bbeb66e3517e8d3daa3ee2ce16705e &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;@&lt;span&gt;17001&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545704529806&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; connected &lt;span&gt;&lt;strong&gt;5001-10000&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
　　7bd0cbd26392d1e98ffe9d46ae153c944d8f398d &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7002&lt;/span&gt;@&lt;span&gt;17002&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545704529000&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; connected &lt;span&gt;&lt;strong&gt;10001-16383&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　一个节点除了会将自己负责处理的slot外，还会将自己的slot数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前处理哪些slot。例如：当节点A  通过消息从节点B那里接收到节点B的slot数组时，节点A会在自己的ClusterState.nodes字典中查找节点B对应的ClusterState结构，并对结构中的slots数组进行保存或更新。这样下来集群中的每个节点都会知道数据库中的16384个slot分别被指派给了集群中的哪些节点。&lt;/p&gt;
&lt;p&gt;　　　　下图是集群中各节点的ClusterState.nodes字典，里面记录了slot与各节点的分配关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201812/151560-20181224170500304-382111695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;　　1.3  在集群中执行命令　　&lt;/h4&gt;
&lt;p&gt; 　　　　在对数据库中的16384个slot都进行了指派之后，集群进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。当客户端向节点发送键有关的命令时，接收的节点会计算出命令要处理的键属于哪个slot，并检查这个slot是否派给了节点自己：&lt;/p&gt;
&lt;p&gt;　　　　(1)如果键所在的slot正好就指派给了当前节点，那么节点直接执行这个命令。&lt;/p&gt;
&lt;p&gt;　　　　(2)如果键所在的slot并没有指派给当前节点,那么节点会向客户端返回一个moved错误，指引客户端转向到正确的节点，并再次发送之前想要的执行命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201812/151560-20181224171122627-137024557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　自动分配节点和槽号，示例如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
     --&lt;span&gt; 在节点7000写入一个键值对,发现自动分配到7001的14041槽号中。
     &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt; &lt;span&gt;set&lt;/span&gt; cluster &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello 7000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
     -&amp;gt; Redirected to slot [&lt;span&gt;14041&lt;/span&gt;] located at &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
    OK

     &lt;/span&gt;--&lt;span&gt;节点7000，读取该键，自动重定向到7001节点中出读取
     &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt; cluster
     &lt;/span&gt;-&amp;gt; Redirected to slot [&lt;span&gt;14041&lt;/span&gt;] located at &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;
     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello 7000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

      --&lt;span&gt;节点7000, 修改该键，自动重定向到7001节点中出修改
    &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt; &lt;span&gt;set&lt;/span&gt; cluster &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello 7001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    -&amp;gt; Redirected to slot [&lt;span&gt;14041&lt;/span&gt;] located at &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
     OK
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;　　　　(1) 计算键属于哪个slot槽&lt;/h5&gt;
&lt;p&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;redis 集群共有&lt;span lang=&quot;EN-US&quot;&gt;16384个哈希槽&lt;span lang=&quot;EN-US&quot;&gt;, 每个&lt;span lang=&quot;EN-US&quot;&gt;key通过&lt;span lang=&quot;EN-US&quot;&gt;CRC16校验后对&lt;span lang=&quot;EN-US&quot;&gt;16384个槽取模来决定放置到哪个节点的槽号。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;使用cluster keyslot  key命令可以查看一个指定的键属于哪个slot，例如下面读取cluster键，对应槽号为14041。如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt;&lt;span&gt; cluster keyslot cluster
    (integer) &lt;/span&gt;&lt;span&gt;14041&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;　　　　(2) moved错误(Redirected重定向 )&lt;/h5&gt;
&lt;p&gt;　　　　当节点发现键所在的槽并非由自己负责处理的时候，节点就会向客户端返回一个moved错误，指引客户端转向到正在负责槽的节点。moved错误格式为:moved slot ip :port。 其中slot为键所在的槽，而ip和port则是负责处理槽slot的节点的ip地址和端口号。&lt;/p&gt;
&lt;p&gt;　　　　在集群模式下客户端接收到moved错误时，并不会打印出moved错误，而是根据moved错误自动进行节点转向，并打印出转向日志Redirected to slot 信息。只有在单机模式下，才会打印moved信息，因为单机模式下的redis-cli客户端不清楚moved错误的作用，所以会直接将moved信息打印出来，则不是进行节点转向。&lt;/p&gt;
&lt;h5&gt;　　　　(3) 节点数据库的实现&lt;/h5&gt;
&lt;p&gt;　　　　集群节点保存键值对以及键值对 过期的方式与单机redis服务方式完全相同，节点与单机服务器在数据库方面的一个区别是：节点只能使用0号数据库，而单机redis服务则没有这一限制。&lt;/p&gt;

&lt;h4&gt;　　1.4 重新分片&lt;/h4&gt;
&lt;p&gt;　　　　Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点被移动到目标节点。重新分片操作可以在线online进行,重新分片过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。&lt;/p&gt;
&lt;p&gt;　　　　例如：在原有节点7000,7001,7002三个节点的集群上，新添加一个节点，端口为7003，然后通过重新分片操作，将原本指派给节点7002的10001~16383的槽，将其中的14042-16383重新分给节点7003。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    --&lt;span&gt; 配置好7003的redis.conf, 启动7003的redis服务    
    [root@hsr cluster&lt;/span&gt;-&lt;span&gt;test]# pwd
    &lt;/span&gt;/usr/local/redis/cluster-&lt;span&gt;test
    [root@hsr cluster&lt;/span&gt;-test]# ./redis-server  ./&lt;span&gt;7003&lt;/span&gt;/&lt;span&gt;redis.conf

    &lt;/span&gt;--&lt;span&gt; 将7003加入集群中
    &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt; cluster meet &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;7003&lt;/span&gt;&lt;span&gt;
    OK

    &lt;/span&gt;-- 查看集群信息时，有两个槽(&lt;span&gt;4808&lt;/span&gt;,&lt;span&gt;14041&lt;/span&gt;&lt;span&gt;)已经自动分配到了7003节点
　　&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;&amp;gt;&lt;span&gt; cluster nodes
　　399051ed127fbd1df8a0455858da9c103bf4864a &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7003&lt;/span&gt;@&lt;span&gt;17003&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545705387000&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; connected &lt;span&gt;&lt;strong&gt;4808 14041&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
　　a9e82a7870ac31c221a4d13b28ba9897bb12257c &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;@&lt;span&gt;17000&lt;/span&gt; myself,master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545705386000&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; connected &lt;span&gt;0&lt;/span&gt;-&lt;span&gt;4807&lt;/span&gt; &lt;span&gt;4809&lt;/span&gt;-&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
　　3b10786d21bbeb66e3517e8d3daa3ee2ce16705e &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;@&lt;span&gt;17001&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545705387741&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; connected &lt;span&gt;5001&lt;/span&gt;-&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
　　7bd0cbd26392d1e98ffe9d46ae153c944d8f398d &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7002&lt;/span&gt;@&lt;span&gt;17002&lt;/span&gt; master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545705387000&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; connected &lt;span&gt;10001&lt;/span&gt;-&lt;span&gt;14040&lt;/span&gt; &lt;span&gt;14042&lt;/span&gt;-&lt;span&gt;16383&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 通过setslot来简单演示下重新分配槽：&lt;/p&gt;
&lt;p&gt;　　　　在迁移(目的节点)执行&lt;code&gt;cluster setslot &amp;lt;slot&amp;gt; IMPORTING &amp;lt;node ID&amp;gt;&lt;/code&gt;命令，指明需要迁移的slot和迁移源节点。&lt;/p&gt;
&lt;p&gt;　　　　下面登录到7003目的节点，使用cluster setslot将参数14042槽号以及所在的源节点ID，导入到当前7003节点中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7003&lt;/span&gt;&amp;gt; cluster setslot &lt;span&gt;14042&lt;/span&gt;&lt;span&gt; importing 7bd0cbd26392d1e98ffe9d46ae153c944d8f398d
    OK

    &lt;/span&gt;--&lt;span&gt; 查看cluster nodes ，7003节点信息如下：
    399051ed127fbd1df8a0455858da9c103bf4864a &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;7003&lt;/span&gt;@&lt;span&gt;17003&lt;/span&gt; myself,master - &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1545707846000&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; connected &lt;span&gt;4808&lt;/span&gt; &lt;span&gt;14041&lt;/span&gt; &lt;br/&gt;[&lt;span&gt;&lt;strong&gt;14042-&amp;lt;-7bd0cbd26392d1e98ffe9d46ae153c944d8f398d&lt;/strong&gt;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　取消迁移操作，可在迁移源节点和迁移目的节点上执行&lt;code&gt;cluster setslot &amp;lt;slot&amp;gt; STABLE&lt;/code&gt;&lt;code&gt;。&lt;/code&gt;下篇介绍使用redis-trib.rb来进行重新分片，redis-trib.rb自动实现了&lt;code&gt;setslot&lt;/code&gt;&lt;code&gt;的&lt;/code&gt;完整的迁移流程。&lt;/p&gt;

</description>
<pubDate>Tue, 25 Dec 2018 06:32:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.概述 Redis集群提供了分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。在大数据量方面的高可用方案，cluster集群比Sentinel有优势。但Redis集群并不支持处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10169394.html</dc:identifier>
</item>
<item>
<title>策略模式 Strategy 政策Policy 行为型 设计模式（二十五） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10173694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10173694.html</guid>
<description>&lt;p&gt;策略模式 Strategy&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181225141939827-1793823315.png&quot;&gt;&lt;img title=&quot;image_5c21cbb4_55b2&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181225141940838-716734557.png&quot; alt=&quot;image_5c21cbb4_55b2&quot; width=&quot;689&quot; height=&quot;457&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181225141941367-1979840183.png&quot;&gt;&lt;img title=&quot;image_5c21cbb4_3b5&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181225141941587-509551365.png&quot; alt=&quot;image_5c21cbb4_3b5&quot; width=&quot;877&quot; height=&quot;140&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;与策略相关的常见词汇有：营销策略、折扣策略、教学策略、记忆策略、学习策略....&lt;/p&gt;
&lt;p&gt;“策略”意味着分情况讨论，而不是一概而论&lt;/p&gt;
&lt;p&gt;面对不同年龄段的人，面对不同的商品，必然将会有不同的话术；&lt;/p&gt;
&lt;p&gt;面对购物总价的范围，很可能会有不同的折扣方案；&lt;/p&gt;
&lt;p&gt;面对理解能力不同的学生，必然有不同的教学策略；&lt;/p&gt;

&lt;p&gt;而在我们程序的世界里，“策略”就是分情况讨论。也就是&lt;span&gt;&lt;strong&gt;类似状态模式中的条件分支或者选择分支&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;只不过&lt;span&gt;&lt;strong&gt;状态模式中是事物的不同状态，而策略模式中关注的是处理方法&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(totalPrice &amp;gt; 1000&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9折&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(totalPrice &amp;gt; 2000&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8折&lt;/span&gt;
}&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(totalPrice &amp;gt; 3000&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7折&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这就是一种打折策略，对应于购物总金额的不同，采用不同的处理方法。&lt;/p&gt;
&lt;p&gt;显然，使用条件分支或者选择语句，类似状态模式中的分析，也存在类似的问题&lt;/p&gt;
&lt;p&gt;如果条件过多，会导致&lt;span&gt;&lt;strong&gt;处理逻辑复杂&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而且，策略的逻辑与业务逻辑&lt;span&gt;&lt;strong&gt;耦合&lt;/strong&gt;&lt;/span&gt;在一起，如果处理方法变化还需要修改业务逻辑方法，&lt;span&gt;&lt;strong&gt;扩展性差&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而且，也&lt;span&gt;&lt;strong&gt;不适合增加新的策略方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;意图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义一系列的算法，把他们一个个的封装起来，并使他们可以互相转换，本模式使得算法可以独立于使用它的客户端而变化。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;别名：政策Policy&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;策略模式与状态模式本质一样，只不过一个是状态，一个是行为算法。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;结构&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181225141941820-1712816165.png&quot;&gt;&lt;img title=&quot;image_5c21cbb4_22ad&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181225141942106-1816607220.png&quot; alt=&quot;image_5c21cbb4_22ad&quot; width=&quot;618&quot; height=&quot;304&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象策略角色Strategy&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;定义了抽象的策略，比如打折，排序等&lt;/p&gt;
&lt;p&gt;定义了策略的一致性访问接口，比如定义了一个排序接口 sort（）&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;具体策略角色ConcreteStrategy&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实现抽象策略的定义的接口，实现自己的行为算法，比如ConcreteStrategyA冒泡 ConcreteStrategyB快排&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;环境类Context&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;维护Strategy，持有一个Strategy的引用，用来管理Strategy，可以切换策略&lt;/p&gt;
&lt;p&gt;是Strategy的使用者&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;排序接口,定义了一个sort方法&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; strategy;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SortStrategy {
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sort();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; strategy;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bubble &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; SortStrategy {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sort() {
        System.out.println(&lt;/span&gt;&quot;冒泡排序,输出结果...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; strategy;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QuickSort &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; SortStrategy {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sort() {
        System.out.println(&lt;/span&gt;&quot;快速排序,输出结果...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;环境类&lt;/p&gt;
&lt;p&gt;内部持有一个SortStrategy，简单起见初始化为Bubble&lt;/p&gt;
&lt;p&gt;使用一个简单的方法进行切换&lt;/p&gt;
&lt;p&gt;并且提供sort方法，代理strategy的sort方法&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; strategy;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Context {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SortStrategy strategy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bubble();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setStrategy(String strategy) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(strategy.equals(&quot;bubble&quot;&lt;span&gt;)){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.strategy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bubble();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(strategy.equals(&quot;quick&quot;&lt;span&gt;)){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.strategy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QuickSort();
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sort() {
        strategy.sort();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;div readability=&quot;52.34834324554&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; strategy;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    Context context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Context();
    context.sort();
    context.setStrategy(&lt;/span&gt;&quot;quick&quot;&lt;span&gt;);
    context.sort();
    context.setStrategy(&lt;/span&gt;&quot;bubble&quot;&lt;span&gt;);
    context.sort();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181225141942297-1013591716.png&quot;&gt;&lt;img title=&quot;image_5c21cbb4_406f&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181225141942582-1969861121.png&quot; alt=&quot;image_5c21cbb4_406f&quot; width=&quot;516&quot; height=&quot;120&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;上面的代码可以看得出来，具体的算法行为，被封装在了具体的策略类中，比如Bubble和QuickSort&lt;/p&gt;
&lt;p&gt;通过环境类Context对算法进行管理切换。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;策略模式与状态模式是类似的，借助于多态的特性，以达到不同状态不同行为&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不同的场景使用不同的算法，这本就是一种“不同状态，不同行为”的含义延伸&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;都是借助于多态特性，进而也就是依赖倒置原则---面向抽象编程，其根本也是为了“低耦合&lt;/strong&gt;&lt;/span&gt;”。&lt;/p&gt;

&lt;p&gt;策略模式中使用独立的类来封装不同的算法行为，每一个类封装具体的行为&lt;/p&gt;
&lt;p&gt;策略模式主要是将&lt;span&gt;&lt;strong&gt;算法的定义与使用进行分开&lt;/strong&gt;&lt;/span&gt;，算法被封装在不同的策略类中&lt;/p&gt;
&lt;p&gt;借助于算法的环境类Context，针对抽象策略进行编程，符合依赖倒置原则 &lt;/p&gt;
&lt;p&gt;而且，新增加具体的算法，只需要增加一个新的具体的策略类即可。&lt;/p&gt;

&lt;p&gt;策略模式将算法的定义与使用分开，具体的策略完全可以通过配置文件等方式注入到Context中，客户端完全不需要关注具体的策略&lt;/p&gt;
&lt;p&gt;而且，&lt;span&gt;&lt;strong&gt;运行时可以随时的更换策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;策略模式的Context，我们的示例中一个Context一个当前策略，那么Context到底内部维护几个策略？到底谁负责切换，是客户端还是Context&lt;/p&gt;
&lt;p&gt;个人认为都是灵活的，策略模式的核心就在于算法的定义与使用的解耦，在接下来的其他事情，自己看情况随便来（随便的前提是合理有效）&lt;/p&gt;

&lt;p&gt;只要是涉及到&lt;span&gt;&lt;strong&gt;多种算法行为&lt;/strong&gt;&lt;/span&gt;的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;切换&lt;/strong&gt;&lt;/span&gt;：策略可以运行时切换&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复用&lt;/strong&gt;&lt;/span&gt;：算法与使用解耦，算法可以单独扩展&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;封装&lt;/strong&gt;&lt;/span&gt;：屏蔽使用者对算法内部数据结构等逻辑的了解，否则如果算法的实现耦合在客户端，客户端不是一清二楚么&lt;/p&gt;
&lt;p&gt;都&lt;span&gt;&lt;strong&gt;可以考虑策略模式&lt;/strong&gt;&lt;/span&gt;，策略模式能够灵活的切换算法，以及算法独立发展，符合开闭原则 &lt;/p&gt;

&lt;p&gt;但是类似状态模式，策略模式也会产生很多小的具体的策略类，增加类的个数和运行时对象的个数。&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 25 Dec 2018 06:28:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>策略模式 Strategy是一种相对比较简单的行为型设计模式，与状态模式有一定的类似，策略模式将算法概念进行抽象，抽象为同一接口，面向接口编程，状态模式也是类似，本质仍旧是面向抽象编程，本文对策略模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10173694.html</dc:identifier>
</item>
<item>
<title>聊聊我的 Java 自学之路 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10173584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10173584.html</guid>
<description>&lt;p&gt;最近经常在知乎收到类似『没基础，java 如何自学』、『怎么才能掌握编程』等等问题，再加上发现高中同学也在自学。有感而发，讲讲我的自学之路。&lt;/p&gt;
&lt;h2 id=&quot;大学&quot;&gt;1.1. &lt;strong&gt;大学&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;高考没正常发挥，考入一所二流的学校，当时分数也只高出录取分数线一两分，只能选择机械专业，当时分数如果高个两三分，或许可以上计算机专业，或许现在基础知识水平可能不一样，可是谁说的准那？&lt;/p&gt;
&lt;p&gt;说回正题，大学前两年，跟大多数同学一样，基本在混，该打游戏打游戏，该逃课的逃课。但是期末的时候会去临时努力一把，最后也能取个好成绩。这里说一点，后来才发现有些同学原来期末的时候也不去准备一把，没办法这样也就只能挂科了。所以这里想说个观点，其实你只要稍微努力一点，其实就已经超过了很多人。&lt;/p&gt;
&lt;p&gt;说说我们专业，跟计算机有关联可能就是『机』了吧。所幸，大一的时候还有一门 C 语言必修课。那时候其实对于编程存在懵懂的兴趣，曾想过学完 C 语言，然后成为一个黑客。可是学的时候才发现，才发现这门课是如此枯燥，而且你根本不知道学完你能干什么。书本只有练习题，老师也只是照本宣科。于是那时候也失去对这门课的兴趣。&lt;/p&gt;
&lt;h2 id=&quot;大三&quot;&gt;1.2. &lt;strong&gt;大三&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;大三那年对于我人生是有意义的一年。&lt;/p&gt;
&lt;p&gt;那个学期，穷的没办法，出去兼职，赚到人生第一笔工资。并且用这部分钱，报考驾校。也是这笔钱，让我意识到原来赚钱是如此不容易。&lt;/p&gt;
&lt;p&gt;大三那年，因为面临毕业的压力，不得不去思考将来从事什么。静下心来思考分析未来到底应该干什么。我想过从事本专业的工作，但是本专业无非就去工厂工作或者在研究院从事制图工作，我根本没兴趣。真的，我那时候真的十分厌恶 CAD 制图。&lt;/p&gt;
&lt;p&gt;这里真的感谢我女朋友，是她给我提了个思路，让我去尝试学习下 Java。哈哈，感谢某度，搜索 Java 的时候弹出满屏广告，一点进去就看了 XXX 在某培训班毕业，成功进入大公司，拿到很高工资。的确，这个真的很有吸引力。于是踏上自学之路。还记得是大三寒假的时候，在家敲下第一行代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        System.out.println(&quot;Hello world&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说说那时候怎么自学的。我在某自学网站上找到 Java 基础的视频课程，真的很老的课程，录制于 2012 年。给你们看看当时的课程目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/23/167db1ead292439b?w=916&amp;amp;h=608&amp;amp;f=png&amp;amp;s=105705&quot; alt=&quot;课程目录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/23/167db1f4d440dfe9?w=904&amp;amp;h=610&amp;amp;f=png&amp;amp;s=102873&quot; alt=&quot;课程目录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下去每天的生活基本上就很枯燥，除了上课，就是学习，偶尔还出去兼职一下。那时候基本就在学校图书馆学习，没事就往我们学校四楼去借 Java 相关的书籍。那时候也不知道那些 Java 书籍比较经典，所以就根据标题挑书，于是就挑了『Java 入门到精通』，『21天带你学会 Java』这类书。当时看到这类书就觉得标题十分吸引人，那时候就觉得看完这些书就能速成 Java。但是现在回想，这些书真的十分坑爹，基本上就是网上资源抄抄改改，误人子弟。各位读者如果想买书的话，千万别买这类书籍。&lt;/p&gt;
&lt;p&gt;时间来到大三那个暑假，基本上学完了 Java 基础，最后还跟着视频教程完成一个贪吃蛇的小游戏，那时候真的感觉很有成就感。&lt;/p&gt;
&lt;p&gt;学完 Java 基础，接下去就面临着学那个方向的问题。那时候其实也没多考虑，就直接选择 Web 后台开发这个方向。在淘宝上买了一套某培训班的培训课程后，就跟着其进度学习。这个阶段，已经感觉到不像 Java 基础那时候简单了。学的东西不仅难，而且多，基本上各个方面都需要学会。还记得这个课程，刚开始先教 Html、CSS、JavaScript,后来就开始教 SQL 语法，最后开始 Java 的 Servlet 等。那时候基本上每天白天仔细看课程视频，然后晚上一行行去输入练习，尽量保证当天把课程都练习一遍，不拖到明天。但是有时候就是学完这个，又忘了上面或者说就是想不到这种解决办法。这时候我就会再看下之前课程，看下到底哪个点卡住，然后思考下为什么没想到。&lt;/p&gt;
&lt;h2 id=&quot;实习&quot;&gt;1.3. 实习&lt;/h2&gt;
&lt;p&gt;大概在 11 月的时候，基本把课程学完了。学校里又没有什么课程了，呆着学校又没什么事，也就想着出看看能不能知道实习。&lt;/p&gt;
&lt;p&gt;那时候由于刚自学完，对于自己的技能根本没有信心，也不知道企业开发到底需要掌握什么技能。这就导致了那时候我心想只要找到实习工作就好，能开给我一些工资，然后能让进入学习就好了。&lt;/p&gt;
&lt;p&gt;兜兜转转，不断在 58 赶集上找工作，找了一圈最终找到了一家公司招聘 Java 开发。面试官问了几个简单 Java 的基础问题后，然后就发 offer 了。&lt;/p&gt;
&lt;p&gt;进入公司之后，我才发现这个跟自己想象的完全不一样。全公司后台开发就我一个人，而面试我的面试官，不在这个公司，在另一个市的另一家公司，在这公司挂牌一个开发经理职位。&lt;/p&gt;
&lt;p&gt;那时候也不知道需求，就扔给我一套表结构设计以及一套他们以前开发好的后台代码，就让我模仿这个改改就好了。还记得那套框架由 easyui，struts2，mybatis，mysql 构成。每天的工作就是照着这块改，不会的就找搜索引擎。旁边的同事，基本上都是其他岗位，没有一个可以请教问题的。那时候也没有什么需求文档，基本都是某某经理拍拍脑袋想出来。在那个公司呆了两三个月，基本上没有什么收获，就像公司辞了职。&lt;/p&gt;
&lt;p&gt;那个时候已经到了三月份，还有三个月就毕业了。那时候也很慌张，自己学校招聘会也去逛了下，但是根本没有看到 Java 相关的工作。偶然间在网上看到恒生，网易的春招的机会，抱着试试的想法，就选择报名。报名之后，了解到其笔试内容，发现很多内容自己很多根本没学过，比如操作系统，linux 知识。可是没办法啊，只能疯狂在牛客网刷题，疯狂补充这些知识。最后，两家公司笔试还是都挂了。。。。&lt;/p&gt;
&lt;p&gt;等网易笔试完，已经到了四月。本地工作岗位，也已经基本找了遍，不是不要实习生，就是基本工资太低，低到什么程度那，有家公司实习每月就给 800 工资。&lt;/p&gt;
&lt;p&gt;后来曾有个大公司来学校宣讲，听到最后意外得知他们还招聘 Java 开发，马上报名参加。接下来的笔试与面试都是跑到那个公司所在城市，最后拿到了这家公司的 offer。不过最后没有选择去，一是因为其毕业之后开的工资真的太低，才 3500，二是因为他们公司所在地方实在太偏僻了。&lt;/p&gt;
&lt;p&gt;本地没办法找到工作之后，不得不去杭州找找机会。在拉勾了搜了一圈工作机会，终于找到几家公司还在招收实习生，广投简历，收到几家公司的面试机会。那一天去面试的时候，正好也是网易春招面试，看到一个个坐着网易大巴去面试，真的十分羡慕。那一天，面了两家公司，最后一家公司发了实习 offer。说说那时候实习工资吧，一天 160，那时候真觉得好高，真觉得应该早点来杭州。&lt;/p&gt;
&lt;p&gt;进入公司之后，分配了个师兄带我。这个师兄虽然话很少，但是在他身上学习到了很多，第一次感觉到那种技术开发的范围。在公司实习大概一个多月，基本上用到也是之前学习到东西，可以说复习巩固以前学的知识。5 月份就回学校报到，然后毕业答辩，顺利就毕业。后来在这家公司也顺利入职，真正进入开发这一行。&lt;/p&gt;
&lt;h2 id=&quot;总结与想法&quot;&gt;1.4. 总结与想法&lt;/h2&gt;
&lt;p&gt;看到这里想必你们也看完我的自学之路，下面也谈谈我这一路的想法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;看到很多朋友问，我现在学编程来的及吗？我想说的是，你什么时候学编程都来的及，但是你自己需要评估你自己到底能不能&lt;strong&gt;静下心来花下时间来学习&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;学习编程需要什么基础？学习编程最好是理工科，但是你如果不是，也没关系，只要你能&lt;strong&gt;坚持&lt;/strong&gt;下来，也能学好。我认识好几位同事，也是文科专业转行过来，有一些大牛，甚至高中没毕业。但是你如果对这个没兴趣，最好尽早放弃。兴趣是很好的导师。&lt;/li&gt;
&lt;li&gt;学习编程，需不需要去去培训班？如果你自己没有自制力，或者想快点出师，可以选择培训班。因为在培训班，你会感受到这种学习的范围，培训班最后也会叫你一些面试技巧什么的。但是建议你报班之前，之前尝试先把 Java 基础学完。如果 Java 基础都学不下去，那你最后报班学习效果也不好。但是不要片面看了培训班的广告，或者被一些销售以毕业后高薪洗脑后，就糊里糊涂就报班了。&lt;strong&gt;自己千万要考虑好没，再去选择报班&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;现在我应该学习 Java 后台，安卓，Python ？其实到底该学习那个真的不好给建议。但是我可以教你们一个方法，从事情的价值出发，列一分优缺清单。把安卓,Java后台开发，Python 这几个优缺点列一个表格，然后 -10 到 10 打一个分数，最后把每一列相加，得出一个最终分，选择那个分数最高的。&lt;/li&gt;
&lt;li&gt;学完结束之后，找工作一定要去一线城市，北上广深杭。为什么这些城市那？因为这些大城市，机会多，薪资也较高。虽然相对而言，生活压力也大一点。但是相信我，在一线城市你生活工作几年，你的&lt;strong&gt;视野格局&lt;/strong&gt;会提高很多。但是如果你前几天在一些二线城市，然后由于薪资水平，再想去一线城市，这样就难很多。&lt;/li&gt;
&lt;li&gt;对那些还在校正在自学同学们讲讲，你们在校如果时间很好多，一定不要只学 Java 相关知识，算法数据结构等也不能丢，这个真的很重要。&lt;/li&gt;
&lt;li&gt;如果你现在已经自学好，正在要找工作。&lt;strong&gt;请充满信心，不要妄自菲薄&lt;/strong&gt;。一次两次失败并不代表什么，总结前几次的失败，这也能更好认识自己。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;天下每天白吃的午餐，同理也没有速成的大法。希望在学的各位同学，静下心来，好好练习代码~&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 06:05:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>最近经常在知乎收到类似『没基础，java 如何自学』、『怎么才能掌握编程』等等问题，再加上发现高中同学也在自学。有感而发，讲讲我的自学之路。 1.1. 大学 高考没正常发挥，考入一所二流的学校，当时分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodAndyxublog/p/10173584.html</dc:identifier>
</item>
<item>
<title>DDD Code First 迁移数据实现EF CORE的软删除，值对象迁移配置 - 往事随灬锋</title>
<link>http://www.cnblogs.com/lifeng618/p/10172967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifeng618/p/10172967.html</guid>
<description>&lt;p&gt;EntityFramework Core 2.0全局过滤 （HasQueryFilter） &lt;a href=&quot;https://www.cnblogs.com/CreateMyself/p/8491058.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/CreateMyself/p/8491058.html&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3&gt;什么是值对象&lt;/h3&gt;
&lt;br/&gt;没有唯一的标识，固定不变的，表示一个具体的概念，用来描述一个东西的特征，代表是什么，使用时直接添加或替换，值对象在迁移时，会以字段的形式迁移到数据库中
&lt;h3&gt;软删除&lt;/h3&gt;
&lt;p&gt;定义删除的接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
         public interface ISoftDelete
         {
            bool IsDeleted { get; set; }
         }
     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建模型实现ISoftDelete接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
       public class UserInfo : IAggregationRoot, ISoftDelete
        {       
          public Guid Id { get; set; }
          public string UserName { get; private set; }
          public string UserPassword { get; private set; }
          public string UserPhone { get; private set; }
          public Address Address { get; private set; }
          public bool IsDeleted { get; set; }
        }
        [Owned]
        public class Address:IValueObject
        { 
          public string Province { get;private set; }
          public string City { get; private set; }
          public string County { get; private set; }
          public string AddressDetails { get; private set; }    
        }
     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lamda的扩展以及Code First 迁移配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    protected override void OnModelCreating(ModelBuilder modelBuilder)
        {          
            //设置软删除
            foreach (var entityType in modelBuilder.Model.GetEntityTypes())
            {               
                var parameter = Expression.Parameter(entityType.ClrType);
                //查询类上面是否有Owned（值对象）的特性
                var ownedModelType = parameter.Type;
                var ownedAttribute = Attribute.GetCustomAttribute(ownedModelType, typeof(OwnedAttribute));
                if (ownedAttribute == null)
                {
                    var propertyMethodInfo = typeof(EF).GetMethod(&quot;Property&quot;).MakeGenericMethod(typeof(bool));
                    var isDeletedProperty =
                        Expression.Call(propertyMethodInfo, parameter, Expression.Constant(&quot;IsDeleted&quot;));
                    BinaryExpression compareExpression = Expression.MakeBinary(ExpressionType.Equal, isDeletedProperty,
                        Expression.Constant(false));
                    var lambda = Expression.Lambda(compareExpression, parameter);
                    modelBuilder.Entity(entityType.ClrType).HasQueryFilter(lambda);
                }      
            }
        }
     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里需要过滤掉值对象的类，在值对象的类上面声明一个特性，通过该特性过滤掉该值对象， 如果该类是值对象就直接跳过，不过滤值对象EF CORE会给值对象附加一个IsDeleted的字段，EF CORE执行中会报错，提示找不到该字段&lt;br/&gt;Owned是EF CORE 配置值对象的特性，可以去自定义特性，在每一个值对象上面声明，在OnModelCreating 过滤掉包含这个特性的类&lt;br/&gt;最终实现的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
         public async Task&amp;gt;&amp;gt; GetUserList(SearchUserDto input)
         {
            Expression&amp;gt; where = e =&amp;gt; e.IsDisable == false;
            if (!string.IsNullOrEmpty(input.SearchName))
            {
                where = where.And(e =&amp;gt; e.UserName.Contains(input.SearchName));
            }

            if (!string.IsNullOrEmpty(input.SearchPwd))
            {
                where = where.And(e =&amp;gt; e.UserPhone.Contains(input.SearchPwd));
            }
         
            var userList = await _userRepository.LoadEntityListAsync(where, e =&amp;gt; e.UserName, &quot;asc&quot;, input.PageIndex, input.Pagesize);
            var total = await _userRepository.GetEntitiesCountAsync(where);
            var userDtoList = userList.MapToList();

            HeaderResult&amp;gt; result = new HeaderResult&amp;gt;
            {
                IsSucceed = true,
                Result = userDtoList,
                Total = total
            };
            return result;
        }
     
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 25 Dec 2018 06:00:00 +0000</pubDate>
<dc:creator>往事随灬锋</dc:creator>
<og:description>感谢Jeffcky大佬的博客： EntityFramework Core 2.0全局过滤 （HasQueryFilter） https://www.cnblogs.com/CreateMyself/p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifeng618/p/10172967.html</dc:identifier>
</item>
</channel>
</rss>