<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白的springboot之路（十六）、mybatis-plus 的使用 - 大叔杨</title>
<link>http://www.cnblogs.com/yanghj/p/12446686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanghj/p/12446686.html</guid>
<description>&lt;h2&gt;0-前言&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;mybatis plus&lt;/strong&gt;是对mybatis的增强，集成mybatis plus后，简单的CRUD和分页就不用写了，非常方便，五星推荐；&lt;/p&gt;
&lt;h2&gt;1-集成&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1-1、添加依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &amp;lt;!-- &lt;span&gt;9&lt;/span&gt;、集成mybatis-plus  --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1-2、配置文件增加配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#mybatis-&lt;span&gt;plus
mybatis&lt;/span&gt;-plus.mapper-locations=classpath:mapper&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Mapper.xml
mybatis-plus.type-aliases-package=com.anson.model
mybatis-plus.configuration.map-underscore-to-camel-case=true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1-3、配置类中增加分页bean&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PaginationInterceptor paginationInterceptor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaginationInterceptor();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1-4、model（工具生成即可）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.anson.model;
import java.io.Serializable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User implements  Serializable
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;----------------------------&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String realname;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username = username == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : username.trim();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password = password == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : password.trim();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRealname() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; realname;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRealname(String realname) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.realname = realname == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : realname.trim();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1-5、mapper(XML)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-//mybatis.org//DTD Mapper 3.0//EN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://mybatis.org/dtd/mybatis-3-mapper.dtd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;mapper &lt;span&gt;namespace&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.anson.dao.UserMapper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;resultMap id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BaseResultMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.anson.model.User&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;id column=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; jdbcType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INTEGER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; property=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;result column=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; jdbcType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; property=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;result column=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passWord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; jdbcType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; property=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;result column=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;realName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; jdbcType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; property=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;realname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/resultMap&amp;gt;
  &amp;lt;sql id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Base_Column_List&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    id, userName, passWord, realName
  &lt;/span&gt;&amp;lt;/sql&amp;gt;

&amp;lt;/mapper&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1-6、dao(mapper类)，继承 BaseMapper&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.anson.dao;

import com.anson.model.User;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import javafx.scene.control.Pagination;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import java.util.List;

@Repository
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserMapper extends BaseMapper&amp;lt;User&amp;gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1-7、service 继承 ServiceImpl&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.anson.service;

import com.anson.dao.UserMapper;
import com.anson.model.User;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserService extends ServiceImpl&amp;lt;UserMapper, User&amp;gt;&lt;span&gt;
{
    @Autowired
    UserMapper usermapper;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;1-8、controller&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　看见没，以上基本没有一行代码，但是在controller我们已经可以直接使用增删查改和分页了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-----------mybatis plus--------------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、增&lt;/span&gt;
&lt;span&gt;
        User user&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setId(&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
        user.setUsername(&lt;/span&gt;&lt;span&gt;&quot;anson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        user.setPassword(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1236216&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        user.setRealname(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王琪琪&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt;        userservice.save(user);
&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、删&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        userservice.removeById(id);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、查&lt;/span&gt;

        User b =&lt;span&gt;userservice.getById(id);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、改&lt;/span&gt;
&lt;span&gt;
        User update &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        update.setId(&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
        update.setUsername(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex2266&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt;        userservice.updateById(update);
&lt;/span&gt;&lt;span&gt;}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、分页&lt;/span&gt;
&lt;span&gt;
        IPage&lt;/span&gt;&amp;lt;User&amp;gt; page=&lt;span&gt;new&lt;/span&gt; Page(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        page &lt;/span&gt;=&lt;span&gt; userservice.page(page);&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;怎么样，是不是很爽，项目中，只有少部分特殊的操作需要单独写SQL和方法，大部分CRUD都不需要写了&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2、注意的地方&lt;/h2&gt;
&lt;p&gt;　　mybatis中，对于下划线“_”，默认是转换成大写字母处理的，比如我们数据库表字段“update_time”,mybatis会转换成“updateTime”;&lt;/p&gt;
&lt;p&gt;所以，&lt;span&gt;&lt;strong&gt;为了避坑，直接给出强制建议（或者说结论）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1、数据库表设计，不要采用大小写，一律小写，多个单词组合采用下划线连接，如字段“update_time”、“edit_by”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2、model中，所有采用下划线的字段，转换成驼峰大小写，如：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　“update_time” 在实体类中为：“updateTime”，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　“edit_by” 在实体类中为： “editBy”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3、mybatis plus强大的条件构造器queryWrapper、updateWrapper&lt;/h2&gt;
&lt;p&gt;　　muybatis plus 可以通过条件构造器增加各种查询和更新条件，有以下四种条件构造器（&lt;strong&gt;主要用后两种&lt;/strong&gt;，Lambda则看个人喜好）：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;LambdaQueryWrapper&lt;/strong&gt; ：看名称也能明白就是用于Lambda语法使用的查询Wrapper&lt;br/&gt;　　　　&lt;strong&gt;LambdaUpdateWrapper&lt;/strong&gt; ： Lambda 更新封装Wrapper&lt;br/&gt;　　　　&lt;strong&gt;QueryWrapper&lt;/strong&gt; ： Entity 对象封装操作类，不是用lambda语法&lt;br/&gt;　　　　&lt;strong&gt;UpdateWrapper&lt;/strong&gt; ： Update 条件封装，用于Entity对象更新操作&lt;/p&gt;
&lt;p&gt;先贴张常用条件构造器函数图（图片来源于网络）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/118906/202003/118906-20200309081134964-1433251131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 例子：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、根据条件删除&lt;/span&gt;
        QueryWrapper&amp;lt;User&amp;gt; queryWrapper = &lt;span&gt;new&lt;/span&gt; QueryWrapper&amp;lt;&amp;gt;&lt;span&gt;();
        queryWrapper
                .isNull(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .ge(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
                .isNotNull(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;realname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        boolean delete &lt;/span&gt;=&lt;span&gt; userservice.remove(queryWrapper);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、根据条件查询&lt;/span&gt;
        QueryWrapper&amp;lt;User&amp;gt; queryWrapper2 = &lt;span&gt;new&lt;/span&gt; QueryWrapper&amp;lt;&amp;gt;&lt;span&gt;();
        queryWrapper2.eq(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        User user &lt;/span&gt;=&lt;span&gt; userservice.getOne(queryWrapper2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、根据条件查询并分页&lt;/span&gt;
        Page&amp;lt;User&amp;gt; page2 = &lt;span&gt;new&lt;/span&gt; Page&amp;lt;&amp;gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
        QueryWrapper&lt;/span&gt;&amp;lt;User&amp;gt; queryWrapper3 = &lt;span&gt;new&lt;/span&gt; QueryWrapper&amp;lt;&amp;gt;&lt;span&gt;();
        queryWrapper3.like(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        IPage&lt;/span&gt;&amp;lt;User&amp;gt; userIPage =&lt;span&gt; userservice.page(page2, queryWrapper3);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、根据条件更新&lt;/span&gt;
&lt;span&gt;
        User user2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user2.setRealname(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        UpdateWrapper&lt;/span&gt;&amp;lt;User&amp;gt; userUpdateWrapper = &lt;span&gt;new&lt;/span&gt; UpdateWrapper&amp;lt;&amp;gt;&lt;span&gt;();
        userUpdateWrapper.eq(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        boolean update &lt;/span&gt;= userservice.update(user, userUpdateWrapper);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 09 Mar 2020 00:34:00 +0000</pubDate>
<dc:creator>大叔杨</dc:creator>
<og:description>0-前言 mybatis plus是对mybatis的增强，集成mybatis plus后，简单的CRUD和分页就不用写了，非常方便，五星推荐； 1-集成 1-1、添加依赖 &amp;lt;!-- 9、集成m</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanghj/p/12446686.html</dc:identifier>
</item>
<item>
<title>程序员过关斩将--从每秒6000写请求谈起 - 架构师修行之路</title>
<link>http://www.cnblogs.com/zhanlang/p/12446675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanlang/p/12446675.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/553/5534532/202003/wACNKZQZ_KhvW.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;每一个片子的幕后，都保留了你的观看记录，详细的记着你观看了几次，跳过了那些时长 ，据说根据这些数据可以分析出你喜欢哪个日本明星，以此来做定向推送......&lt;/p&gt;
&lt;p&gt;虽然看起来很简单的一个功能，其实涉及到的数据量非常大，极限情况下为你的用户数*视频数的乘积。&lt;/p&gt;
&lt;p&gt;那么在只有两个网站服务器，一台sqlserver的情况下，该如何面对这样不算大数据量的写请求呢？为什么说是写请求呢？因为用户观看视频的每一秒你都需要记录下来，例如：视频的第十秒用户观看了。要想把这个功能搞定，首先需要定义几个事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;记录用户观看视频情况的数据定义&lt;/li&gt;
&lt;li&gt;和客户端交互的数据协议&lt;/li&gt;
&lt;li&gt;数据库中记录的数据格式&lt;/li&gt;
&lt;li&gt;如何解决服务器写的压力（毕竟单台服务器请求数还是比较大）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;h5 id=&quot;用户观看视频进度定义&quot;&gt;用户观看视频进度定义&lt;/h5&gt;
&lt;p&gt;对于一个视频来说，假如有1个小时的时长，这3600秒对应着3600个是否已经观看的状态，对于观看状态来说，只有观看和未观看两种状态，所以一个bit足以，一个字节（byte）有8个bit，所以一个byte可以表示8秒的观看状态，以此为基础，进制越高，同样数量的字符表示的状态就越多。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;客户端每次上传新的数据，需要和服务端已经存在的数据做位运算，例如： 01000 表示第二秒观看了 ，客户端新上传：00011 表示第4,5秒都观看了，对于用户而言这个视频第2,4,5 秒都看过，虽然只是一个简单的运算，但是量大的时候，对cpu的消耗不容小觑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;第一字节    第二字节
  0 1 2 3 4 5 6 7  0 1 2 3 4 5 6 7 
bit：  1 0 0 0 1 0 0 0  0 1 0 0 0 0 0 0
二进制：  0x88    0x40
字符串：  8840&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;和客户端交互协议&quot;&gt;和客户端交互协议&lt;/h5&gt;
&lt;p&gt;用户观看视频的进度实时信息，只有客户端知道，客户端需要上传用户的观看进度数据，和服务端交互的进制可以选择通用性比较强的16进制，当然你选择100进制也无所谓，只要双方能同时支持，并且能正常解析即可&lt;/p&gt;
&lt;h5 id=&quot;数据库数据格式&quot;&gt;数据库数据格式&lt;/h5&gt;
&lt;p&gt;每种数据库支持的数据类型有差异，所以这里不在过多叙述，当然无论什么格式，占用空间越少越好，但也要根据业务的计算量来综合考虑。&lt;/p&gt;
&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;h5 id=&quot;cpu性能问题&quot;&gt;cpu性能问题&lt;/h5&gt;
&lt;p&gt;毕竟要把用户每次最新的观看数据和老数据做合并工作，在用户量大的情况下不容小觑。在综合了各种条件之后，最终采用10进制来做合并工作，客户端上传上来16进制数据，然后转化为十进制，然后和观看记录（10进制）做合并运算，这部分cpu省略不了，具体转化程序为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //需要新加的数据
        ConcurrentQueue&amp;lt;UserVideoInfo&amp;gt; AddQueue = new ConcurrentQueue&amp;lt;UserVideoInfo&amp;gt;();

//把16进制的字符串按照两位 分割成十进制数组
        protected List&amp;lt;int&amp;gt; ConvertToProgressArray(string progressString)
        {
            if (string.IsNullOrWhiteSpace(progressString))
            {
                return null;
            }
            //验证是否为2的倍数长度
            if (progressString.Length % 2 != 0)
            {
                return null;
            }
            var proStrSpan = progressString.AsSpan();
            List&amp;lt;int&amp;gt; ret = new List&amp;lt;int&amp;gt;();
          
            int i = 0;
            while (i &amp;lt; proStrSpan.Length)
            {
                ret.Add(int.Parse(proStrSpan.Slice(i, 2).ToString(), System.Globalization.NumberStyles.HexNumber)); ;
                i = i + 2;
            }
            return ret;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;客户端请求数量问题&quot;&gt;客户端请求数量问题&lt;/h5&gt;
&lt;p&gt;如果同时一万用户在同时观看视频，上传数据时间间隔为2秒，意味着每秒有5000请求。由于这个业务只是一个用户log型业务，何为log型，就是说可以容忍一部分数据丢失，针对这个数据形态，客户端可以先在本地做缓冲记录，没有必要一秒上传一次记录，例如现在约定的客户端30秒上传一次记录，如果用户关掉客户端，下次启动的时候会重新上传未成功的记录。&lt;/p&gt;
&lt;h5 id=&quot;数据库压力&quot;&gt;数据库压力&lt;/h5&gt;
&lt;p&gt;如果每次请求都单独更新数据库，按照第二条的计算每秒高达5000次update请求。用户观看每次视频都加载内存中缓存，仔细分析这种业务，由于是log型数据，所以每次你请求没有必要都去更新数据库，而是先更新了缓存，然后定时去更新数据库。&lt;/p&gt;
&lt;p&gt;由于数据量的问题，所有的更新操作都会发送到一个任务队列，队列的执行者会根据配置批量更新数据库，这样比单条更新数据库性能要高很多，其实这种方案在很多log型的业务中都有使用，批量更新对数据库的压力要小很多,代码类似以下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public async Task&amp;lt;int&amp;gt; AddUserVideoData(UserVideoInfo data, DBProcessEnum processType = DBProcessEnum.Update)
        {
            if(processType== DBProcessEnum.Add)
            {
                AddQueue.Enqueue(data);
            }
           
            return 1;
        }

 void MulProcessData()
        {
            //每次更新的条数
            int maxNumber = 50;
            List&amp;lt;UserVideoInfo&amp;gt; data = new List&amp;lt;UserVideoInfo&amp;gt;();
            while (true)
            {
                if (data == null)
                {
                    data = new List&amp;lt;UserVideoInfo&amp;gt;();
                }
                try
                {                   
                    if (!AddQueue.Any() &amp;amp;&amp;amp; !UpdateQueue.Any())
                    {
                        System.Threading.Thread.Sleep(500);
                    }                   
                    else
                    {
                        //先处理 需要更新的
                        data.Clear();
                        while (data.Count &amp;lt;= maxNumber &amp;amp;&amp;amp; AddQueue.Any())
                        {
                            if (!AddQueue.TryDequeue(out UserVideoInfo value))
                            {                                
                                continue;
                            }
                            //判断是否有重复对象
                            if (data.Any(s =&amp;gt; s.UserId == value.UserId &amp;amp;&amp;amp; s.VideoId == value.VideoId))
                            {
                                var exsitItem = data.First(s =&amp;gt; s.UserId == value.UserId &amp;amp;&amp;amp; s.VideoId == value.VideoId);
                                exsitItem = value;
                            }
                            else
                            {
                                data.Add(value);
                            }

                        }
                        if (data != null &amp;amp;&amp;amp; data.Any())
                        {
                            var ret = UserVideoProgressProxy.Add(data);
                        }
                        
                    }
                }
                catch (Exception err)
                {
                    
                }


            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;p&gt;其实这种高IO的操作用sqlserver这种关系型数据库反而不好，Nosql在这种简单高IO的情境下要很多，改天可以改为redis试一试，估计会比sqlserver要好很多。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 00:28:00 +0000</pubDate>
<dc:creator>架构师修行之路</dc:creator>
<og:description>背景 每一个片子的幕后，都保留了你的观看记录，详细的记着你观看了几次，跳过了那些时长 ，据说根据这些数据可以分析出你喜欢哪个日本明星，以此来做定向推送...... 虽然看起来很简单的一个功能，其实涉及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanlang/p/12446675.html</dc:identifier>
</item>
<item>
<title> GitHub 热点速览 vol.10：疫情下的 GitHub  - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12445600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12445600.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308222958578-1932475217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：如果说上周的 GitHub 是股市附体 star 低迷不振，那么本周的 GitHub 像极了受到疫情影响而未开学的高校们，新生 GitHub 项少，能上 GitHub Trending 的数量更少，基本上一只手数得过来的惨淡，而它们的 star 成绩单同样像是少了老师监管的中小学生交作业——质量不佳、迟迟不交 🌚 好在每年开学新生中总有让人眼前一亮的选手，比如，本周刚开源，开源当日并斩获 2k+ star 的东京疫情项目…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自上周 HelloGitHub 微博的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间超过 30 天的项目一律称之为成熟稳重老项目，由于文章篇幅问题还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;可怕 GitHub 新生&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 苹果开源参数解析器：Swift Argument Parser&lt;/li&gt;
&lt;li&gt;1.2 fastai 草稿：fastbook&lt;/li&gt;
&lt;li&gt;1.3 数据集：CLUEDatasetSearch&lt;/li&gt;
&lt;li&gt;1.4 电商系统+1：ElysiumMall&lt;/li&gt;
&lt;li&gt;1.5 谷歌开源：FuzzBench&lt;/li&gt;
&lt;li&gt;1.6 CAA 检测：lecaa&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;尚能星否 GitHub 老项目&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 500+ CSS 图标：css.gg&lt;/li&gt;
&lt;li&gt;2.2 学 C++ 吗？：CPlusPlusThings&lt;/li&gt;
&lt;li&gt;2.3 Python 代码段：pysheeet&lt;/li&gt;
&lt;li&gt;2.4 云相册：lsky-pro&lt;/li&gt;
&lt;li&gt;2.5 CSS 实践：Simpsons in CSS&lt;/li&gt;
&lt;li&gt;2.6 Go 版 Dubbo：dubbo-go&lt;/li&gt;
&lt;li&gt;2.7 数据科学：Data-Science--Cheat-Sheet&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周 GitHub Trending #疫情下的 GitHub #主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 口罩项目：FaceMaskDetection&lt;/li&gt;
&lt;li&gt;3.2 东京疫情数据：东京都新型コロナウイルス感染症対策サイト&lt;/li&gt;
&lt;li&gt;3.3 可视化疫情数据：COVID-19&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可怕-github-新生&quot;&gt;1. 可怕 GitHub 新生&lt;/h2&gt;
&lt;h3 id=&quot;苹果开源参数解析器swift-argument-parser&quot;&gt;1.1 苹果开源参数解析器：Swift Argument Parser&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swift Argument Parser 是苹果官方开源的参数解析器，具有直观、安全的特点。此外苹果也推荐了 2 个 ArgumentParser 在 Swift 项目工具中采用的示例：&lt;br/&gt;🎨 indexstore-db 是一个包含两个命令的简单实例；&lt;br/&gt;🎈 swift-format 则用了一些高级功能，例如自定义选项值和隐藏标志。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2698412698413&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/apple/swift-argument-parsers&quot; class=&quot;uri&quot;&gt;https://github.com/apple/swift-argument-parsers&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223033684-731547972.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;fastai-草稿fastbook&quot;&gt;1.2 fastai 草稿：fastbook&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：3500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AI 有多火呢？这个介绍深度学习，fastai 和 PyTorch 的项目一开源直逼 2k star，当然 star 增长量过 1,600+，如果你想学习 fastai 这个深度学习开源库，不妨试试这个项目，该项目暂时只是一个初稿，将在今年 7 月左右以 MOOC 的形式面世。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/fastai/fastbook&quot; class=&quot;uri&quot;&gt;https://github.com/fastai/fastbook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223041787-156494018.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据集cluedatasetsearch&quot;&gt;1.3 数据集：CLUEDatasetSearch&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：450+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CLUEDatasetSearch 是一个中英文 NLP 数据集，它支持你在线搜索某个数据集，目前收录了【情感分析】、【文本分类】、【文本匹配】、【知识图谱】、【语料库】、【机器翻译】等方面内容。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.2121212121212&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/CLUEbenchmark/CLUEDatasetSearch&quot; class=&quot;uri&quot;&gt;https://github.com/CLUEbenchmark/CLUEDatasetSearch&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223049913-1923350210.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;电商系统1elysiummall&quot;&gt;1.4 电商系统+1：ElysiumMall&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ElysiumMall 是刚开源的电商系统，采用流行技术实现，它由前台商城和后台管理系统两部分组成，基于 SpringBoot + MyBatis 实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。&lt;/li&gt;
&lt;li&gt;后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1.4035087719298&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/JackZhu426/ElysiumMall&quot; class=&quot;uri&quot;&gt;https://github.com/JackZhu426/ElysiumMall&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223059041-887892324.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;谷歌开源fuzzbench&quot;&gt;1.5 谷歌开源：FuzzBench&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FuzzBench 是谷歌开源的基准测试服务，可用于模糊测试，它提供了&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集成模糊测试的 API&lt;/li&gt;
&lt;li&gt;基于真实数据的基准，FuzzBench 可以使用任何 OSS-Fuzz 项目作为基准&lt;/li&gt;
&lt;li&gt;它也是一个带有图形和统计测试的报告库，可以帮你快速理解测试结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，你还可以将你的 fuzzer 同其他 fuzzer 进行比较，以方便你提升系统。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/google/fuzzbench&quot; class=&quot;uri&quot;&gt;https://github.com/google/fuzzbench&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223109038-653454748.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;caa-检测lecaa&quot;&gt;1.6 CAA 检测：lecaa&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3 月 4 日 Let's Encrypt 在其证书授权 (CAA) 代码中发现了一个 bug，如果客户不强制更新证书，就必须撤销数百万个证书。而 lecaa 就是当日开源的可用于检测 Let's Encrypt CAA 问题的脚本，如果你有这块的需求不妨试试。&lt;/p&gt;
&lt;blockquote readability=&quot;1.7021276595745&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/hannob/lecaa&quot; class=&quot;uri&quot;&gt;https://github.com/hannob/lecaa&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;尚能星否-github-老项目&quot;&gt;2. 尚能星否 GitHub 老项目&lt;/h2&gt;
&lt;h3 id=&quot;css-图标css.gg&quot;&gt;2.1 500+ CSS 图标：css.gg&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;css.gg 是代码设计而成的轻巧图标，可自定义，通过 API 和 NPM 可用于 Retina，你可以通过 CSS、JSON、XML 等形式来使用这些图标。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/astrit/css.gg&quot; class=&quot;uri&quot;&gt;https://github.com/astrit/css.gg&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223118380-1889197476.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;学-c-吗cplusplusthings&quot;&gt;2.2 学 C++ 吗？：CPlusPlusThings&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：250+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;lCPlusPlusThings，又名 C++ 那些事，收录了学习 C++ 内容，包括理论、源码、实践、课程代码、项目等。项目分为【基础学习】、【进阶学习】、【设计模式】、【多线程与多进程】、【第三方学习资料】、【工具篇】等篇章。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3114754098361&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/Light-City/CPlusPlusThings&quot; class=&quot;uri&quot;&gt;https://github.com/Light-City/CPlusPlusThings&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223126970-62316523.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;python-代码段pysheeet&quot;&gt;2.3 Python 代码段：pysheeet&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pysheeet 是一个收录 Python 代码片段的项目，你可以快速找到对应的 Python 代码，此外项目也介绍了 Python 3 中的一些重要特性。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.4545454545455&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/crazyguitar/pysheeet&quot; class=&quot;uri&quot;&gt;https://github.com/crazyguitar/pysheeet&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223135919-1181394475.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;云相册lsky-pro&quot;&gt;2.4 云相册：lsky-pro&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;lsky-pro 是用 PHP 写成的云相册，主要特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持第三方云储存，支持本地、阿里云 OSS、腾讯云 COS、七牛云、又拍云、FTP。&lt;/li&gt;
&lt;li&gt;支持多图上传、拖拽上传、粘贴上传、上传预览、全屏预览、页面响应式布局。&lt;/li&gt;
&lt;li&gt;简洁的图片管理功能，支持鼠标右键、单选多选、重命名等操作。&lt;/li&gt;
&lt;li&gt;强大的图片预览功能，支持响应式。&lt;/li&gt;
&lt;li&gt;支持全局配置用户初始剩余储存空间、支持单个设置用户剩余储存空间。&lt;/li&gt;
&lt;li&gt;支持一键复制图片外链、二维码扫描链接。&lt;/li&gt;
&lt;li&gt;支持设置上传文件、文件夹路径命名规则。&lt;/li&gt;
&lt;li&gt;支持图片鉴黄功能。&lt;/li&gt;
&lt;li&gt;支持文件夹分类功能。&lt;/li&gt;
&lt;li&gt;对外开放的上传接口。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/wisp-x/lsky-pro&quot; class=&quot;uri&quot;&gt;https://github.com/wisp-x/lsky-pro&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223146430-1662092410.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;css-实践simpsons-in-css&quot;&gt;2.5 CSS 实践：Simpsons in CSS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然是一个 5 年前的老项目，当不妨碍它上周在 GitHub Trending 榜呆了半周，Simpsons in CSS 实现了用 CSS 制作辛普森一家头像，每个头像有自己的动画表情，如果你想学习 CSS 不妨 Pick 下这个项目，可查看每个对应动画是如何用 CSS 实现的。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4035087719298&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/pattle/simpsons-in-css&quot; class=&quot;uri&quot;&gt;https://github.com/pattle/simpsons-in-css&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223156677-802422542.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;go-版-dubbodubbo-go&quot;&gt;2.6 Go 版 Dubbo：dubbo-go&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dubbo-go 使用 go 实现的 Dubbo，它实现了基于 Dubbo 的 extension 模块和分层的代码设计(包括 protocol layer, registry layer, cluster layer, config 等等)。&lt;/p&gt;
&lt;p&gt;你可以对这些分层接口进行新的实现，并通过调用 extension 模块的“ extension.SetXXX ”方法来覆盖 dubbo-go [同 go-for-apache-dubbo ]的默认实现，以完成自己的特殊需求而无需修改源代码。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/apache/dubbo-go&quot; class=&quot;uri&quot;&gt;https://github.com/apache/dubbo-go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223205060-999827538.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据科学data-science--cheat-sheet&quot;&gt;2.7 数据科学：Data-Science--Cheat-Sheet&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Data-Science--Cheat-Sheet 是一个数据科学领域的速查表，包括【人工智能】、【大数据】、【数据挖掘】、【数据可视化】、【数据仓库】、【机器学习】等等理论应用方面内容，也包括了 Python 、R 语言、Docker 等编程语言与工具，共计 30+ 个分类内容，是一个全面的数据科学学习仓。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1594202898551&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/abhat222/Data-Science--Cheat-Sheet&quot; class=&quot;uri&quot;&gt;https://github.com/abhat222/Data-Science--Cheat-Sheet&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223213389-712250141.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本周-github-trending-疫情下的-github-主题的主力军&quot;&gt;3. 本周 GitHub Trending #疫情下的 GitHub #主题的主力军&lt;/h2&gt;
&lt;p&gt;HelloGitHub 在某一期的 GitHub 主题给大家分享过中国 nCoV 相关 GitHub 项目（详见：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/107627597&quot;&gt;《共抗疫情的开源项目，让我们贡献自己的一份力量》&lt;/a&gt;，随着国外 nCoV 进入爆发式增长，GitHub 上关于 nCoV 的项目也跟着“水涨船高”，在这里小鱼干给你分享 3 个本周 GitHub Trending 上的项目，不妨来学习下数据可视化展示等方面内容~&lt;/p&gt;
&lt;h3 id=&quot;口罩项目facemaskdetection&quot;&gt;3.1 口罩项目：FaceMaskDetection&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FaceMaskDetection 是开源人脸口罩检测模型和数据，提供了 PyTorch、TensorFlow（包括 ftlite、pb 模型）、Keras、MXNet、Caffe 这五大主流框架的推理代码，它可以检测人脸是否佩戴口罩，并附有 8,000 张人脸口罩标注数据。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2903225806452&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/AIZOOTech/FaceMaskDetection&quot; class=&quot;uri&quot;&gt;https://github.com/AIZOOTech/FaceMaskDetection&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223222839-1852635810.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;东京疫情数据东京都新型コロナウイルス感染症対策サイト&quot;&gt;3.2 东京疫情数据：东京都新型コロナウイルス感染症対策サイト&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：3200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;东京都新型コロナウイルス感染症対策サイト 是昨日 GitHub Trending 榜的明星项目，当然获得 2.1k+ star，它收集了东京的新冠病例数据，并以图表显示展示出来，可查看到当然新增及累计病例数。除了病例数据之外，它也提供了一些病状方便自查是否患有新冠，简言之，你可以理解为 东京都新型コロナウイルス感染症対策サイト 是一个 Web 版的丁香医生疫情系统。在线访问：&lt;a href=&quot;https://stopcovid19.metro.tokyo.lg.jp/flow/&quot; class=&quot;uri&quot;&gt;https://stopcovid19.metro.tokyo.lg.jp/flow/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.2307692307692&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/tokyo-metropolitan-gov/covid19&quot; class=&quot;uri&quot;&gt;https://github.com/tokyo-metropolitan-gov/covid19&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223231486-1082503451.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;可视化疫情数据covid-19&quot;&gt;3.3 可视化疫情数据：COVID-19&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Johns Hopkins 大学系统科学与工程中心出品的 COVID-19 疫情全球实时扩散图，提供了可视化的源代码，&lt;a href=&quot;https://www.arcgis.com/apps/opsdashboard/index.html#/bda7594740fd40299423467b48e9ecf6&quot;&gt;点击线访问&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.3793103448276&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/CSSEGISandData/COVID-19&quot; class=&quot;uri&quot;&gt;https://github.com/CSSEGISandData/COVID-19&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200308223247622-791635297.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 10 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友可同前端、Java、Go…各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200217165012919-1203910757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 00:21:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 摘要：如果说上周的 GitHub 是股市附体 star 低迷不振，那么本周的 GitHub 像极了受到疫情影响而未开学的高校们，新生 GitHub 项少，能上 G</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12445600.html</dc:identifier>
</item>
<item>
<title>200行代码，7个对象——让你了解ASP.NET Core框架的本质[3.x版] - Artech</title>
<link>http://www.cnblogs.com/artech/p/mini-asp-net-core-3x.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/mini-asp-net-core-3x.html</guid>
<description>&lt;p&gt;2019年1月19日，微软技术（苏州）俱乐部成立，我受邀在成立大会上作了一个名为《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-framework.html&quot;&gt;ASP.NET Core框架揭秘&lt;/a&gt;》的分享。在此次分享中，我按照ASP.NET Core自身的运行原理和设计思想创建了一个 “迷你版” 的ASP.NET Core框架，并且利用这个 “极简” 的模拟框架阐述了ASP.NET Core框架最核心、最本质的东西。整个框架涉及到的核心代码不会超过200行，涉及到7个核心的对象。由于ASP.NET Core 3.X采用了不同的应用承载方式，所以我们将这个模拟框架升级到3.x版本。[本篇内容节选自即将出版的《ASP.NET Core 3框架解密》，感兴趣的朋友可以通过&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-aspnet-core-3.html&quot;&gt;《“ASP.NET Core 3框架揭秘”读者群，欢迎加入》&lt;/a&gt;加入本书读者群，以便及时了解本书的动态。源代码从&lt;a href=&quot;https://files.cnblogs.com/files/artech/mini-asp-net-core-framework.7z&quot;&gt;这里&lt;/a&gt;下载。]&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、中间件委托链&lt;br/&gt;     HttpContext&lt;br/&gt;     中间件&lt;br/&gt;     中间件管道的构建&lt;br/&gt;二、服务器&lt;br/&gt;     IServer&lt;br/&gt;     针对服务器的适配&lt;br/&gt;     HttpListenerServer&lt;br/&gt;三、承载服务&lt;br/&gt;     WebHostedService&lt;br/&gt;     WebHostBuilder&lt;br/&gt;     应用构建&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过本篇文章，我将管道最核心的部分提取出来构建一个“迷你版”的ASP.NET Core框架。较之真正的ASP.NET Core框架，虽然重建的模拟框架要简单很多，但是它们采用完全一致的设计。为了能够在真实框架中找到对应物，在定义接口或者类型时会采用真实的名称，但是在API的定义上会做最大限度的简化。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;HttpContext&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;一个HttpContext对象表示针对当前请求的上下文。要理解HttpContext上下文的本质，需要从请求处理管道的层面来讲。对于由一个服务器和多个中间件构成的管道来说，面向传输层的服务器负责请求的监听、接收和最终的响应，当它接收到客户端发送的请求后，需要将请求分发给后续中间件进行处理。对于某个中间件来说，完成自身的请求处理任务之后，在大部分情况下需要将请求分发给后续的中间件。请求在服务器与中间件之间，以及在中间件之间的分发是通过共享上下文的方式实现的。&lt;/p&gt;
&lt;p&gt;如下图所示，当服务器接收到请求之后，会创建一个通过HttpContext表示的上下文对象，所有中间件都在这个上下文中完成针对请求的处理工作。那么一个HttpContext对象究竟会携带什么样的上下文信息？一个HTTP事务（Transaction）具有非常清晰的界定，如果从服务器的角度来说就是始于请求的接收，而终于响应的回复，所以请求和响应是两个基本的要素，也是HttpContext承载的最核心的上下文信息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202658936-850957054.png&quot;&gt;&lt;img width=&quot;488&quot; height=&quot;118&quot; title=&quot;12-1&quot; alt=&quot;12-1&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202659307-628275088.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以将请求和响应理解为一个Web应用的输入与输出，既然HttpContext上下文是针对请求和响应的封装，那么应用程序就可以利用这个上下文对象得到当前请求所有的输入信息，也可以利用它完成我们所需的所有输出工作。所以，我们为ASP.NET Core模拟框架定义了如下这个极简版本的HttpContext类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpListenerFeature : IHttpRequestFeature, IHttpResponseFeature
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; HttpListenerContext _context;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpListenerFeature(HttpListenerContext context)=&amp;gt; _context =&lt;span&gt; context;

    Uri IHttpRequestFeature.Url&lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Request.Url;
    NameValueCollection IHttpRequestFeature.Headers&lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Request.Headers;
    NameValueCollection IHttpResponseFeature.Headers&lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Response.Headers;
    Stream IHttpRequestFeature.Body&lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Request.InputStream;
    Stream IHttpResponseFeature.Body&lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Response.OutputStream;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; IHttpResponseFeature.StatusCode
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _context.Response.StatusCode;
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; _context.Response.StatusCode =&lt;span&gt; value;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，我们可以利用HttpRequest对象得到当前请求的地址、请求消息的报头集合和主体内容。利用HttpResponse对象，我们不仅可以设置响应的状态码，还可以添加任意的响应报头和写入任意的主体内容。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;中间件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;HttpContext对象承载了所有与当前请求相关的上下文信息，应用程序针对请求的响应也利用它来完成，所以可以利用一个&lt;span&gt;Action&amp;lt;HttpContext&amp;gt;&lt;/span&gt;类型的委托对象来表示针对请求的处理，我们姑且将它称为请求处理器（Handler）。但Action&amp;lt;HttpContext&amp;gt;仅仅是请求处理器针对“同步”编程模式的表现形式，对于面向Task的异步编程模式，这个处理器应该表示成类型为&lt;span&gt;Func&amp;lt;HttpContext,Task&amp;gt;&lt;/span&gt;的委托对象。&lt;/p&gt;
&lt;p&gt;由于这个表示请求处理器的委托对象具有非常广泛的应用，所以我们为它专门定义了如下这个RequestDelegate委托类型，可以看出它就是对Func&amp;lt;HttpContext,Task&amp;gt;委托的表达。一个RequestDelegate对象表示的是请求处理器，那么中间件在模型中应如何表达？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; Task RequestDelegate(HttpContext context);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为请求处理管道核心组成部分的中间件可以表示成类型为Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;的委托对象。换句话说，中间件的输入与输出都是一个RequestDelegate对象。我们可以这样来理解：对于管道中的某个中间件（下图所示的第一个中间件）来说，后续中间件组成的管道体现为一个RequestDelegate对象，由于当前中间件在完成了自身的请求处理任务之后，往往需要将请求分发给后续中间件进行处理，所以它需要将后续中间件构成的RequestDelegate对象作为输入。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202659524-1992410873.png&quot;&gt;&lt;img width=&quot;494&quot; height=&quot;136&quot; title=&quot;12-2&quot; alt=&quot;12-2&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202659773-1718471185.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当代表当前中间件的委托对象执行之后，如果将它自己“纳入”这个管道，那么代表新管道的RequestDelegate对象就成为该委托对象执行后的输出结果，所以中间件自然就表示成输入和输出类型均为RequestDelegate的Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;对象。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;中间件管道的构建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;从事软件行业10多年来，笔者对架构设计越来越具有这样的认识：好的设计一定是“简单”的设计。所以在设计某个开发框架时笔者的目标是再简单点。上面介绍的请求处理管道的设计就具有“简单”的特质：&lt;span&gt;Pipeline = Server + Middlewares&lt;/span&gt;。但是“再简单点”其实是可以的，我们可以将多个中间件组成一个单一的请求处理器。请求处理器可以通过RequestDelegate对象来表示，所以整个请求处理管道将具有更加简单的表达：&lt;span&gt;Pipeline = Server + RequestDelegate&lt;/span&gt;（见下图12）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202659989-1446581360.png&quot;&gt;&lt;img width=&quot;399&quot; height=&quot;158&quot; title=&quot;12-3&quot; alt=&quot;12-3&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202700229-1384903565.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表示中间件的Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;对象向表示请求处理器的RequestDelegate对象之间的转换是通过&lt;span&gt;IApplicationBuilder&lt;/span&gt;对象来完成的。从接口命名可以看出，IApplicationBuilder对象是用来构建“应用程序”（Application）的，实际上，由所有注册中间件构建的RequestDelegate对象就是对应用程序的表达，因为应用程序的意图完全是由注册的中间件达成的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IApplicationBuilder
{
    RequestDelegate Build();
    IApplicationBuilder Use(Func&lt;/span&gt;&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&lt;span&gt; middleware);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上所示的代码片段是模拟框架对IApplicationBuilder接口的简化定义。它的Use方法用来注册中间件，而Build方法则将所有的中间件按照注册的顺序组装成一个RequestDelegate对象。如下所示的代码片段中ApplicationBuilder类型是对该接口的默认实现。我们给出的代码片段还体现了这样一个细节：当我们将注册的中间件转换成一个表示请求处理器的RequestDelegate对象时，会在管道的尾端添加一个处理器用来响应一个状态码为404的响应。这个细节意味着如果没有注册任何的中间件或者所有注册的中间件都将请求分发给后续管道，那么应用程序会回复一个状态码为404的响应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApplicationBuilder : IApplicationBuilder
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IList&amp;lt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&amp;gt; _middlewares = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RequestDelegate Build()
    {
        RequestDelegate next &lt;/span&gt;= context =&amp;gt;&lt;span&gt;
        {
            context.Response.StatusCode &lt;/span&gt;= &lt;span&gt;404&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        };                    
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; middleware &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _middlewares.Reverse())
        {
            next &lt;/span&gt;=&lt;span&gt; middleware.Invoke(next);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IApplicationBuilder Use(Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&lt;span&gt; middleware)
    {
        _middlewares.Add(middleware);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务器在管道中的职责非常明确：负责HTTP请求的监听、接收和最终的响应。具体来说，启动后的服务器会绑定到指定的端口进行请求监听。一旦有请求抵达，服务器会根据该请求创建代表请求上下文的HttpContext对象，并将该上下文分发给注册的中间件进行处理。当中间件管道完成了针对请求的处理之后，服务器会将最终生成的响应回复给客户端。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;IServer&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在模拟的ASP.NET Core框架中，我们将服务器定义成一个极度简化的IServer接口。在如下所示的代码片段中，IServer接口具有唯一的StartAsync方法来启动自身代表的服务器。服务器最终需要将接收的请求分发给注册的中间件，而注册的中间件最终会被IApplicationBuilder对象构建成一个代表请求处理器的RequestDelegate对象，StartAsync方法的参数handler代表的就是这样一个对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IServer
{
    Task StartAsync(RequestDelegate handler);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;针对服务器的适配&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;面向应用层的HttpContext对象是对请求和响应的抽象与封装，但是请求最初是由面向传输层的服务器接收的，最终的响应也会由服务器回复给客户端。所有ASP.NET Core应用使用的都是同一个HttpContext类型，但是它们可以注册不同类型的服务器，应如何解决两者之间的适配问题？计算机领域有这样一句话：“任何问题都可以通过添加一个抽象层的方式来解决，如果解决不了，那就再加一层。”同一个HttpContext类型与不同服务器类型之间的适配问题自然也可以通过添加一个抽象层来解决。我们将定义在该抽象层的对象称为&lt;span&gt;特性（Feature&lt;/span&gt;），特性可以视为对HttpContext某个方面的抽象化描述。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202700759-273762690.png&quot;&gt;&lt;img width=&quot;439&quot; height=&quot;291&quot; title=&quot;12-4&quot; alt=&quot;12-4&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202701050-1792137598.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，我们可以定义一系列特性接口来为HttpContext提供某个方面的上下文信息，具体的服务器只需要实现这些Feature接口即可。对于所有用来定义特性的接口，最重要的是提供请求信息的&lt;span&gt;IRequestFeature&lt;/span&gt;接口和完成响应的&lt;span&gt;IResponseFeature&lt;/span&gt;接口。&lt;/p&gt;
&lt;p&gt;下面阐述用来适配不同服务器类型的特性在代码层面的定义。如下面的代码片段所示，我们定义了一个IFeatureCollection接口来表示存放特性的集合。可以看出，这是一个以Type和Object作为Key和Value的字典，Key代表注册Feature所采用的类型，而Value代表Feature对象本身，也就是说，我们提供的特性最终是以对应类型（一般为接口类型）进行注册的。为了便于编程，我们定义了Set&amp;lt;T&amp;gt;方法和Get&amp;lt;T&amp;gt;方法来设置与获取特性对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFeatureCollection : IDictionary&amp;lt;Type, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FeatureCollection : Dictionary&amp;lt;Type, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;, IFeatureCollection { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Extensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; IFeatureCollection features)  =&amp;gt; features.TryGetValue(&lt;span&gt;typeof&lt;/span&gt;(T), &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; value) ? (T)value : &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IFeatureCollection Set&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IFeatureCollection features, T feature)
    {
        features[&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(T)] =&lt;span&gt; feature;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; features;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最核心的两种特性类型就是分别用来表示请求和响应的特性，我们可以采用如下两个接口来表示。可以看出，IHttpRequestFeature接口和IHttpResponseFeature接口具有与抽象类型HttpRequest和HttpResponse完全一致的成员定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHttpRequestFeature
{
    Uri Url { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    NameValueCollection Headers { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    Stream Body { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHttpResponseFeature
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; StatusCode { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    NameValueCollection Headers { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    Stream Body { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在前面给出了用于描述请求上下文的HttpContext类型的成员定义，下面介绍其具体实现。如下面的代码片段所示，表示请求和响应的HttpRequest与HttpResponse分别是由对应的特性（IHttpRequestFeature对象和IHttpResponseFeature对象）创建的。HttpContext对象本身则是通过一个表示特性集合的IFeatureCollection 对象来创建的，它会在初始化过程中从这个集合中提取出对应的特性来创建HttpRequest对象和HttpResponse对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpRequest Request { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpResponse Response { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpContext(IFeatureCollection features)
    {
        Request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequest(features);
        Response &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpResponse(features);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpRequest
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHttpRequestFeature _feature;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Uri Url=&amp;gt;&lt;span&gt; _feature.Url;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; NameValueCollection Headers=&amp;gt;&lt;span&gt; _feature.Headers;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Stream Body=&amp;gt;&lt;span&gt; _feature.Body;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpRequest(IFeatureCollection features)=&amp;gt; _feature = features.Get&amp;lt;IHttpRequestFeature&amp;gt;&lt;span&gt;();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpResponse
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHttpResponseFeature _feature;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; NameValueCollection Headers=&amp;gt;&lt;span&gt; _feature.Headers;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Stream Body=&amp;gt;&lt;span&gt; _feature.Body;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; StatusCode
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _feature.StatusCode;
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; _feature.StatusCode =&lt;span&gt; value;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpResponse(IFeatureCollection features)=&amp;gt; _feature = features.Get&amp;lt;IHttpResponseFeature&amp;gt;&lt;span&gt;();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;换句话说，我们利用HttpContext对象的Request属性提取的请求信息最初来源于IHttpRequestFeature对象，利用它的Response属性针对响应所做的任意操作最终都会作用到IHttpResponseFeature对象上。这两个对象最初是由注册的服务器提供的，这正是同一个ASP.NET Core应用可以&lt;span&gt;自由地选择不同服务器类型&lt;/span&gt;的根源所在。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;HttpListenerServer&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在对服务器的职责和它与HttpContext的适配原理有了清晰的认识之后，我们可以尝试定义一个服务器。我们将接下来定义的服务器类型命名为HttpListenerServer，因为它对请求的监听、接收和响应是由一个HttpListener对象来实现的。由于服务器接收到请求之后需要借助“特性”的适配来构建统一的请求上下文（即HttpContext对象），这也是中间件的执行上下文，所以提供针对性的特性实现是自定义服务类型的关键所在。&lt;/p&gt;
&lt;p&gt;对HttpListener有所了解的读者都知道，当它在接收到请求之后同样会创建一个HttpListenerContext对象表示请求上下文。如果使用HttpListener对象作为ASP.NET Core应用的监听器，就意味着不仅所有的请求信息会来源于这个HttpListenerContext对象，我们针对请求的响应最终也需要利用这个上下文对象来完成。HttpListenerServer对应特性所起的作用实际上就是在HttpListenerContext和HttpContext这两种上下文之间搭建起一座如下图所示的桥梁。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202701279-990544999.png&quot;&gt;&lt;img width=&quot;419&quot; height=&quot;210&quot; title=&quot;12-5&quot; alt=&quot;12-5&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202701505-1895959417.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上图中用来在HttpListenerContext和HttpContext这两个上下文类型之间完成适配的特性类型被命名为&lt;span&gt;HttpListenerFeature&lt;/span&gt;。如下面的代码片段所示，HttpListenerFeature类型同时实现了针对请求和响应的特性接口IHttpRequestFeature与IHttpResponseFeature。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpListenerFeature : IHttpRequestFeature, IHttpResponseFeature
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; HttpListenerContext _context;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpListenerFeature(HttpListenerContext context) =&amp;gt; _context =&lt;span&gt; context;
    Uri IHttpRequestFeature.Url &lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Request.Url;
    NameValueCollection IHttpRequestFeature.Headers &lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Request.Headers;
    NameValueCollection IHttpResponseFeature.Headers &lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Response.Headers;
    Stream IHttpRequestFeature.Body &lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Request.InputStream;
    Stream IHttpResponseFeature.Body &lt;/span&gt;=&amp;gt;&lt;span&gt; _context.Response.OutputStream;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; IHttpResponseFeature.StatusCode
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _context.Response.StatusCode;
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; _context.Response.StatusCode =&lt;span&gt; value;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建HttpListenerFeature对象时需要提供一个HttpListenerContext对象，IHttpRequestFeature接口的实现成员所提供的请求信息全部来源于这个HttpListenerContext上下文，IHttpResponseFeature接口的实现成员针对响应的操作最终也转移到这个HttpListenerContext上下文上。如下所示的代码片段是针对HttpListener的服务器类型HttpListenerServer的完整定义。我们在创建HttpListenerServer对象的时候可以显式提供一组监听地址，如果没有提供，监听地址会默认设置“localhost:5000”。在实现的StartAsync方法中，我们启动了在构造函数中创建的HttpListenerServer对象，并且在一个无限循环中通过调用其GetContextAsync方法实现了针对请求的监听和接收。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpListenerServer : IServer
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; HttpListener _httpListener;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] _urls;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpListenerServer(&lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] urls)
    {
        _httpListener &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpListener();
        _urls &lt;/span&gt;= urls.Any() ? urls : &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(RequestDelegate handler)
    {
        Array.ForEach(_urls, url &lt;/span&gt;=&amp;gt;&lt;span&gt; _httpListener.Prefixes.Add(url));
        _httpListener.Start();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listenerContext = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _httpListener.GetContextAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; feature = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpListenerFeature(listenerContext);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; features = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FeatureCollection()
                .Set&lt;/span&gt;&amp;lt;IHttpRequestFeature&amp;gt;&lt;span&gt;(feature)
                .Set&lt;/span&gt;&amp;lt;IHttpResponseFeature&amp;gt;&lt;span&gt;(feature);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpContext(features);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; handler(httpContext);
            listenerContext.Response.Close();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当HttpListener监听到抵达的请求后，我们会得到一个HttpListenerContext对象，此时只需要利用它创建一个HttpListenerFeature对象并且分别以IHttpRequestFeature接口和IHttpResponseFeature接口的形式注册到创建的FeatureCollection集合上。我们最终利用这个FeatureCollection集合创建出代表请求上下文的HttpContext对象，当将它作为参数调用由所有注册中间件共同构建的RequestDelegate对象时，中间件管道将接管并处理该请求。&lt;/p&gt;

&lt;p&gt;到目前为止，我们已经了解构成ASP.NET Core请求处理管道的两个核心要素（服务器和中间件），现在我们的目标是利用.NET Core承载服务系统来承载这一管道。毫无疑问，还需要通过实现IHostedService接口来定义对应的承载服务，为此我们定义了一个名为WebHostedService的承载服务。(关于.NET Core承载服务系统，请参阅我的系列文章《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-01.html&quot;&gt;服务承载系统&lt;/a&gt;》)&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;WebHostedService&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;由于服务器是整个请求处理管道的“龙头”，所以从某种意义上来说，启&lt;span&gt;动一个ASP.NET Core应用就是为启动服务器&lt;/span&gt;，所以可以将服务的启动在WebHostedService承载服务中实现。如下面的代码片段所示，创建一个WebHostedService对象时，需要提供服务器对象和由所有注册中间件构建的RequestDelegate对象。在实现的StartAsync方法中，我们只需要调用服务器对象的StartAsync方法启动它即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostedService : IHostedService
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServer _server;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _handler;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebHostedService(IServer server, RequestDelegate handler)
    {
        _server &lt;/span&gt;=&lt;span&gt; server;
        _handler &lt;/span&gt;=&lt;span&gt; handler;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task StartAsync(CancellationToken cancellationToken) =&amp;gt;&lt;span&gt; _server.StartAsync(_handler);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task StopAsync(CancellationToken cancellationToken) =&amp;gt;&lt;span&gt; Task.CompletedTask;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到目前为止，我们基本上已经完成了所有核心的工作，如果能够将一个WebHostedService实例注册到.NET Core的承载系统中，它就能够帮助我们启动一个ASP.NET Core应用。为了使这个过程在编程上变得更加便利和“优雅”，我们定义了一个辅助的WebHostBuilder类型。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;WebHostBuilder&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;要创建一个WebHostedService对象，必需显式地提供一个表示服务器的&lt;a&gt;IServe&lt;/a&gt;r对象，以及由所有注册中间件构建而成的RequestDelegate对象，WebHostBuilder提供了更加便利和“优雅”的服务器与中间件注册方式。如下面的代码片段所示，WebHostBuilder是对额外两个Builder对象的封装：一个是用来构建服务宿主的IHostBuilder对象，另一个是用来注册中间件并最终帮助我们创建RequestDelegate对象的IApplicationBuilder对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostBuilder
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHostBuilder HostBuilder { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IApplicationBuilder ApplicationBuilder { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebHostBuilder(IHostBuilder hostBuilder, IApplicationBuilder applicationBuilder)
    {
        HostBuilder &lt;/span&gt;=&lt;span&gt; hostBuilder;
        ApplicationBuilder &lt;/span&gt;=&lt;span&gt; applicationBuilder;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们为WebHostBuilder定义了如下两个扩展方法：&lt;span&gt;UseHttpListenerServer&lt;/span&gt;方法完成了针对自定义的服务器类型HttpListenerServer的注册；&lt;span&gt;Configure&lt;/span&gt;方法提供了一个Action&amp;lt;IApplication&lt;br/&gt;Builder&amp;gt;类型的参数，利用该参数来注册任意中间件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Extensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; WebHostBuilder UseHttpListenerServer(&lt;span&gt;this&lt;/span&gt; WebHostBuilder builder, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] urls)
    {
        builder.HostBuilder.ConfigureServices(svcs &lt;/span&gt;=&amp;gt; svcs.AddSingleton&amp;lt;IServer&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpListenerServer(urls)));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; WebHostBuilder Configure(&lt;span&gt;this&lt;/span&gt; WebHostBuilder builder, Action&amp;lt;IApplicationBuilder&amp;gt;&lt;span&gt; configure)
    {
        configure&lt;/span&gt;?&lt;span&gt;.Invoke(builder.ApplicationBuilder);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代表ASP.NET Core应用的请求处理管道最终是利用承载服务WebHostedService注册到.NET Core的承载系统中的，针对WebHostedService服务的创建和注册体现在为IHostBuilder接口定义的&lt;span&gt;ConfigureWebHost&lt;/span&gt;扩展方法上。如下面的代码片段所示，ConfigureWebHost方法定义了一个Action&amp;lt;WebHostBuilder&amp;gt;类型的参数，利用该参数可以注册服务器、中间件及其他相关服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Extensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder ConfigureWebHost(&lt;span&gt;this&lt;/span&gt; IHostBuilder builder, Action&amp;lt;WebHostBuilder&amp;gt;&lt;span&gt; configure)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webHostBuilder = &lt;span&gt;new&lt;/span&gt; WebHostBuilder(builder, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationBuilder());
        configure&lt;/span&gt;?&lt;span&gt;.Invoke(webHostBuilder);
        builder.ConfigureServices(svcs &lt;/span&gt;=&amp;gt; svcs.AddSingleton&amp;lt;IHostedService&amp;gt;(provider =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = provider.GetRequiredService&amp;lt;IServer&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handler =&lt;span&gt; webHostBuilder.ApplicationBuilder.Build();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHostedService(server, handler);
        }));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ConfigureWebHost方法中，我们创建了一个ApplicationBuilder对象，并利用它和当前的IHostBuilder对象创建了一个WebHostBuilder对象，然后将这个WebHostBuilder对象作为参数调用了指定的Action&amp;lt;WebHostBuilder&amp;gt;委托对象。在此之后，我们调用IHostBuilder接口的ConfigureServices方法在依赖注入框架中注册了一个用于创建WebHostedService服务的工厂。对于由该工厂创建的WebHostedService对象来说，服务器来源于注册的服务，而作为请求处理器的RequestDelegate对象则由ApplicationBuilder对象根据注册的中间件构建而成。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;应用构建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;到目前为止，这个用来模拟ASP.NET Core请求处理管道的“迷你版”框架已经构建完成，下面尝试在它上面开发一个简单的应用。如下面的代码片段所示，我们调用静态类型Host的CreateDefaultBuilder方法创建了一个IHostBuilder对象，然后调用ConfigureWebHost方法并利用提供的Action&amp;lt;WebHostBuilder&amp;gt;对象注册了HttpListenerServer服务器和3个中间件。在调用Build方法构建出作为服务宿主的IHost对象之后，我们调用其Run方法启动所有承载的IHostedSerivce服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder()
            .ConfigureWebHost(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
                .UseHttpListenerServer()
                .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app
                    .Use(FooMiddleware)
                    .Use(BarMiddleware)
                    .Use(BazMiddleware)))
            .Build()
            .Run();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RequestDelegate FooMiddleware(RequestDelegate next)
        &lt;/span&gt;=&amp;gt; &lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo=&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
        };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RequestDelegate BarMiddleware(RequestDelegate next)
        &lt;/span&gt;=&amp;gt; &lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar=&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
        };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RequestDelegate BazMiddleware(RequestDelegate next)
        &lt;/span&gt;=&amp;gt; context =&amp;gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于中间件最终体现为一个类型为Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;的委托对象，所以可以利用与之匹配的方法来定义中间件。演示实例中定义的3个中间件（FooMiddleware、BarMiddleware和BazMiddleware）对应的正是3个静态方法，它们调用WriteAsync扩展方法在响应中写了一段文字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Extensions
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task WriteAsync(&lt;span&gt;this&lt;/span&gt; HttpResponse response, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; contents)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; buffer =&lt;span&gt; Encoding.UTF8.GetBytes(contents);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; response.Body.WriteAsync(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应用启动之后，如果利用浏览器向应用程序采用的默认监听地址（“http://localhost:5000”）发送一个请求，得到的输出结果如下图所示。浏览器上呈现的文字正是注册的3个中间件写入的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202701828-1506221380.png&quot;&gt;&lt;img width=&quot;402&quot; height=&quot;168&quot; title=&quot;12-6&quot; alt=&quot;12-6&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202003/19327-20200308202702102-1896686672.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 00:16:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>2019年1月19日，微软技术（苏州）俱乐部成立，我受邀在成立大会上作了一个名为《ASP.NET Core框架揭秘》的分享。在此次分享中，我按照ASP.NET Core自身的运行原理和设计思想创建了一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/mini-asp-net-core-3x.html</dc:identifier>
</item>
<item>
<title>JavaScript实现树结构（一） - AhuntSun</title>
<link>http://www.cnblogs.com/AhuntSun-blog/p/12446656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AhuntSun-blog/p/12446656.html</guid>
<description>&lt;h2 id=&quot;javascript实现树结构一&quot;&gt;JavaScript实现树结构（一）&lt;/h2&gt;
&lt;h3 id=&quot;一树结构简介&quot;&gt;一、树结构简介&lt;/h3&gt;
&lt;h4 id=&quot;简单了解树结构&quot;&gt;1.1.简单了解树结构&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;什么是树？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;真实的树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png&quot; alt=&quot;image-20200229205530929&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;树一般都有一个&lt;strong&gt;根&lt;/strong&gt;，连接着根的是&lt;strong&gt;树干&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;树干会发生分叉，形成许多&lt;strong&gt;树枝&lt;/strong&gt;，树枝会继续分化成更小的&lt;strong&gt;树枝&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;树枝的最后是&lt;strong&gt;叶子&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转&lt;code&gt;180°&lt;/code&gt;的树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png&quot; alt=&quot;image-20200229205630945&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树结构对比于数组/链表/哈希表有哪些优势呢：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：可以通过&lt;strong&gt;下标值访问&lt;/strong&gt;，效率高；&lt;/li&gt;
&lt;li&gt;缺点：查找数据时需要先对数据进行&lt;strong&gt;排序&lt;/strong&gt;，生成&lt;strong&gt;有序数组&lt;/strong&gt;，才能提高查找效率；并且在插入和删除元素时，需要大量的&lt;strong&gt;位移操作&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;链表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：数据的插入和删除操作效率都很高；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;查找&lt;/strong&gt;效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;哈希表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：哈希表的插入/查询/删除效率都非常高；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;空间利用率不高&lt;/strong&gt;，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是&lt;strong&gt;无序&lt;/strong&gt;的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中&lt;strong&gt;最大值或最小值&lt;/strong&gt;这些特殊值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;树结构：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。&lt;/p&gt;
&lt;p&gt;总的来说：&lt;strong&gt;每种数据结构都有自己特定的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;树（Tree）&lt;/strong&gt;:由 n（n ≥ 0）个节点构成的&lt;strong&gt;有限集合&lt;/strong&gt;。当 n = 0 时，称为&lt;strong&gt;空树&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于任一棵非空树（n &amp;gt; 0），它具备以下性质：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数中有一个称为&lt;strong&gt;根（Root）&lt;/strong&gt;的特殊节点，用 &lt;strong&gt;r&lt;/strong&gt; 表示；&lt;/li&gt;
&lt;li&gt;其余节点可分为 m（m &amp;gt; 0）个互不相交的有限集合 T~1~，T~2~，...，T~m~，其中每个集合本身又是一棵树，称为原来树的&lt;strong&gt;子树（SubTree）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;树的常用术语：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png&quot; alt=&quot;image-20200229221126468&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;节点的度（Degree）&lt;/strong&gt;：节点的&lt;strong&gt;子树个数&lt;/strong&gt;，比如节点B的度为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的度&lt;/strong&gt;：树的所有节点中&lt;strong&gt;最大的度数&lt;/strong&gt;，如上图树的度为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶节点（Leaf）&lt;/strong&gt;：&lt;strong&gt;度为0的节点&lt;/strong&gt;（也称为叶子节点），如上图的H，I等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父节点（Parent）&lt;/strong&gt;：度不为0的节点称为父节点，如上图节点B是节点D和E的父节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子节点（Child）&lt;/strong&gt;：若B是D的父节点，那么D就是B的子节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟节点（Sibling）&lt;/strong&gt;：具有同一父节点的各节点彼此是兄弟节点，比如上图的B和C，D和E互为兄弟节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径和路径长度&lt;/strong&gt;：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如A-&amp;gt;H的路径长度为3；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点的层次（Level）&lt;/strong&gt;：规定&lt;strong&gt;根节点在1层&lt;/strong&gt;，其他任一节点的层数是其父节点的&lt;strong&gt;层数加1&lt;/strong&gt;。如B和C节点的层次为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的深度（Depth）&lt;/strong&gt;：树种所有节点中的&lt;strong&gt;最大层次&lt;/strong&gt;是这棵树的深度，如上图树的深度为4；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;树结构的表示方式&quot;&gt;1.2.树结构的表示方式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最普通的表示方法&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png&quot; alt=&quot;image-20200229230417613&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点A需要3个引用，分别指向子节点B，C，D；B节点需要2个引用，分别指向子节点E和F；K节点由于没有子节点，所以不需要引用。&lt;/p&gt;
&lt;p&gt;这种方法缺点在于我们无法确定某一结点的引用数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;儿子-兄弟表示法&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png&quot; alt=&quot;image-20200229232805477&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种表示方法可以完整地记录每个节点的数据，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//节点A
Node{
  //存储数据
  this.data = data
  //统一只记录左边的子节点
  this.leftChild = B
  //统一只记录右边的第一个兄弟节点
  this.rightSibling = null
}

//节点B
Node{
  this.data = data
  this.leftChild = E
  this.rightSibling = C
}

//节点F
Node{
  this.data = data
  this.leftChild = null
  this.rightSibling = null
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种表示法的优点在于每一个节点中引用的数量都是确定的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;儿子-兄弟表示法旋转&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下为儿子-兄弟表示法组成的树结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/6.png&quot; alt=&quot;image-20200229234549049&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将其顺时针旋转45°之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png&quot; alt=&quot;image-20200229235549522&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就成为了一棵&lt;strong&gt;二叉树&lt;/strong&gt;，由此我们可以得出结论：&lt;strong&gt;任何树都可以通过二叉树进行模拟&lt;/strong&gt;。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。&lt;/p&gt;
&lt;h3 id=&quot;二二叉树&quot;&gt;二、二叉树&lt;/h3&gt;
&lt;h4 id=&quot;二叉树简介&quot;&gt;2.1.二叉树简介&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;二叉树的概念&lt;/strong&gt;：如果树中的每一个节点最多只能由&lt;strong&gt;两个子节点&lt;/strong&gt;，这样的树就称为&lt;strong&gt;二叉树&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树的组成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;二叉树可以为空，也就是没有节点；&lt;/li&gt;
&lt;li&gt;若二叉树不为空，则它由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;二叉树的五种形态&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png&quot; alt=&quot;image-20200301001718079&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树TL的二叉树、只有右子树TR的二叉树和有左右两个子树的二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树的特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个二叉树的第 i 层的最大节点树为：2^(i-1)^，i &amp;gt;= 1；&lt;/li&gt;
&lt;li&gt;深度为k的二叉树的最大节点总数为：2^k^ - 1 ，k &amp;gt;= 1；&lt;/li&gt;
&lt;li&gt;对任何非空二叉树，若 n~0~ 表示叶子节点的个数，n~2~表示度为2的非叶子节点个数，那么两者满足关系：n~0~ = n~2~ + 1；如下图所示：H，E，I，J，G为叶子节点，总数为5；A，B，C，F为度为2的非叶子节点，总数为4；满足n~0~ = n~2~ + 1的规律。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png&quot; alt=&quot;image-20200301092140211&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;特殊的二叉树&quot;&gt;2.2.特殊的二叉树&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;完美二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，这就构成了完美二叉树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png&quot; alt=&quot;image-20200301093237681&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;完全二叉树（Complete Binary Tree）:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;除了二叉树最后一层外，其他各层的节点数都达到了最大值；&lt;/li&gt;
&lt;li&gt;并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；&lt;/li&gt;
&lt;li&gt;完美二叉树是特殊的完全二叉树；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png&quot; alt=&quot;image-20200301093659373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，由于H缺失了右子节点，所以它不是完全二叉树。&lt;/p&gt;
&lt;h4 id=&quot;二叉树的数据存储&quot;&gt;2.3.二叉树的数据存储&lt;/h4&gt;
&lt;p&gt;常见的二叉树存储方式为&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;链表&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;：按从上到下，从左到右的方式存储数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png&quot; alt=&quot;image-20200301094919588&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 * 2，右子节点的序号等于父节点序号 * 2 + 1 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;非完全二叉树&lt;/strong&gt;：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png&quot; alt=&quot;image-20200301100043636&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;11&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;13&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;使用链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二叉树最常见的存储方式为&lt;strong&gt;链表&lt;/strong&gt;：每一个节点封装成一个Node，Node中包含存储的数据、左节点的引用和右节点的引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png&quot; alt=&quot;image-20200301100616105&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三二叉搜索树&quot;&gt;三、二叉搜索树&lt;/h3&gt;
&lt;h4 id=&quot;认识二叉搜索树&quot;&gt;3.1.认识二叉搜索树&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;（&lt;strong&gt;BST&lt;/strong&gt;，Binary Search Tree），也称为&lt;strong&gt;二叉排序树&lt;/strong&gt;和&lt;strong&gt;二叉查找树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;二叉搜索树是一棵二叉树，可以为空；&lt;/p&gt;
&lt;p&gt;如果不为空，则满足以下&lt;strong&gt;性质&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;条件1：非空左子树的&lt;strong&gt;所有&lt;/strong&gt;键值&lt;strong&gt;小于&lt;/strong&gt;其根节点的键值。比如三中节点6的所有非空左子树的键值都小于6；&lt;/li&gt;
&lt;li&gt;条件2：非空右子树的&lt;strong&gt;所有&lt;/strong&gt;键值&lt;strong&gt;大于&lt;/strong&gt;其根节点的键值；比如三中节点6的所有非空右子树的键值都大于6；&lt;/li&gt;
&lt;li&gt;条件3：左、右子树本身也都是二叉搜索树；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png&quot; alt=&quot;image-20200301103139916&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，树二和树三符合3个条件属于二叉树，树一不满足条件3所以不是二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;二叉搜索树的特点主要是&lt;strong&gt;较小的值&lt;/strong&gt;总是保存在&lt;strong&gt;左节点&lt;/strong&gt;上，相对&lt;strong&gt;较大的值&lt;/strong&gt;总是保存在&lt;strong&gt;右节点&lt;/strong&gt;上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中&quot;搜索&quot;的来源。&lt;/p&gt;
&lt;h4 id=&quot;二叉搜索树应用举例&quot;&gt;3.2.二叉搜索树应用举例&lt;/h4&gt;
&lt;p&gt;下面是一个二叉搜索树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png&quot; alt=&quot;image-20200301111718686&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若想在其中查找数据10，只需要查找4次，查找效率非常高。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第1次：将10与根节点9进行比较，由于10 &amp;gt; 9，所以10下一步与根节点9的右子节点13比较；&lt;/li&gt;
&lt;li&gt;第2次：由于10 &amp;lt; 13，所以10下一步与父节点13的左子节点11比较；&lt;/li&gt;
&lt;li&gt;第3次：由于10 &amp;lt; 11，所以10下一步与父节点11的左子节点10比较；&lt;/li&gt;
&lt;li&gt;第4次：由于10 = 10，最终查找到数据10 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png&quot; alt=&quot;image-20200301111751041&quot;/&gt;同样是15个数据，在排序好的数组中查询数据10，需要查询10次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png&quot; alt=&quot;image-20200301115348138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实：如果是排序好的数组，可以通过二分查找：第一次找9，第二次找13，第三次找15...。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是&lt;strong&gt;二叉搜索树&lt;/strong&gt;。这就是数组二分法查找效率之所以高的原因。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6304347826087&quot;&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&quot;&gt;JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 09 Mar 2020 00:15:00 +0000</pubDate>
<dc:creator>AhuntSun</dc:creator>
<og:description>JavaScript实现树结构（一） 一、树结构简介 1.1.简单了解树结构 什么是树？ 真实的树： 树的特点： 树一般都有一个 根 ，连接着根的是 树干 ； 树干会发生分叉，形成许多 树枝 ，树枝会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AhuntSun-blog/p/12446656.html</dc:identifier>
</item>
<item>
<title>编程老司机带你玩转 CompletableFuture 异步编程 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12446644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12446644.html</guid>
<description>&lt;p&gt;hello，各位小伙伴们早上好，今天给大家分享一篇关于使用 CompletableFuture 进行异步编程的文章。 CompletableFuture 这个类功能非常强大，支持回调方式处理任务结果，并且支持编排异步任务，完成一些需要需要相互依赖组合任务。 但是事物都有两面性，CompletableFuture 非常复杂，其拥有 50 多个方法，使用难度稍大。 本文从这点出发，归纳分类这些方法，并且增加大量的代码示例，帮打大家看完这篇文章就理解 CompletableFuture 使用方法。 嘿嘿，赶紧点进来瞅瞅，顺便点个赞呗~&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;278.23955735661&quot;&gt;
&lt;p&gt;本文从实例出发，介绍 &lt;code&gt;CompletableFuture&lt;/code&gt; 基本用法。不过讲的再多，不如亲自上手练习一下。所以建议各位小伙伴看完，上机练习一把，快速掌握 &lt;code&gt;CompletableFuture&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;个人博文地址：https://sourl.cn/s5MbCm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;全文摘要：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Future&lt;/code&gt; VS &lt;code&gt;CompletableFuture&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 基本用法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;x00.-前言&quot;&gt;0x00. 前言&lt;/h2&gt;
&lt;p&gt;一些业务场景我们需要使用多线程异步执行任务，加快任务执行速度。 Java 提供 &lt;code&gt;Runnable&lt;/code&gt; &lt;code&gt;Future&amp;lt;V&amp;gt;&lt;/code&gt; 两个接口用来实现异步任务逻辑。&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;Future&amp;lt;V&amp;gt;&lt;/code&gt; 可以获取任务执行结果，但是获取方式十方不变。我们不得不使用&lt;code&gt;Future#get&lt;/code&gt; 阻塞调用线程，或者使用轮询方式判断 &lt;code&gt;Future#isDone&lt;/code&gt; 任务是否结束，再获取结果。&lt;/p&gt;
&lt;p&gt;这两种处理方式都不是很优雅，JDK8 之前并发类库没有提供相关的异步回调实现方式。没办法，我们只好借助第三方类库，如 &lt;code&gt;Guava&lt;/code&gt;，扩展 &lt;code&gt;Future&lt;/code&gt;，增加支持回调功能。相关代码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080830077-1051350991.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然这种方式增强了 Java 异步编程能力，但是还是无法解决多个异步任务需要相互依赖的场景。&lt;/p&gt;
&lt;p&gt;举一个生活上的例子，假如我们需要出去旅游，需要完成三个任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务一：订购航班&lt;/li&gt;
&lt;li&gt;任务二：订购酒店&lt;/li&gt;
&lt;li&gt;任务三：订购租车服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很显然任务一和任务二没有相关性，可以单独执行。但是任务三必须等待任务一与任务二结束之后，才能订购租车服务。&lt;/p&gt;
&lt;p&gt;为了使任务三时执行时能获取到任务一与任务二执行结果，我们还需要借助 &lt;code&gt;CountDownLatch&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080830337-1137184891.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x01.-completablefuture&quot;&gt;0x01. CompletableFuture&lt;/h2&gt;
&lt;p&gt;JDK8 之后，Java 新增一个功能十分强大的类：&lt;code&gt;CompletableFuture&lt;/code&gt;。单独使用这个类就可以轻松的完成上面的需求:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080830551-292151003.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大家可以先不用管 &lt;code&gt;CompletableFuture&lt;/code&gt; 相关 &lt;code&gt;API&lt;/code&gt;，下面将会具体讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对比 &lt;code&gt;Future&amp;lt;V&amp;gt;&lt;/code&gt;，&lt;code&gt;CompletableFuture&lt;/code&gt; 优点在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不需要手工分配线程，JDK 自动分配&lt;/li&gt;
&lt;li&gt;代码语义清晰，异步任务链式调用&lt;/li&gt;
&lt;li&gt;支持编排异步任务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;怎么样，是不是功能很强大？接下来抓稳了，小黑哥要发车了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080830724-1604495668.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法一览&quot;&gt;1.1 方法一览&lt;/h3&gt;
&lt;p&gt;首先来通过 IDE 查看下这个类提供的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080831082-1756910796.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍微数一下，这个类总共有 50 多个方法，我的天。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080831448-721706481.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过也不要怕，小黑哥帮你们归纳好了，跟着小黑哥的节奏，带你们掌握 &lt;code&gt;CompletableFuture&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若图片不清晰，可以关注『程序通事』，回复：『233』，获取该思维导图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080831612-327784688.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建-completablefuture-实例&quot;&gt;1.2 创建 CompletableFuture 实例&lt;/h3&gt;
&lt;p&gt;创建 &lt;code&gt;CompletableFuture&lt;/code&gt; 对象实例我们可以使用如下几个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080831833-1895207835.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个方法创建一个具有默认结果的 &lt;code&gt;CompletableFuture&lt;/code&gt;，这个没啥好讲。我们重点讲述下下面四个异步方法。&lt;/p&gt;
&lt;p&gt;前两个方法 &lt;code&gt;runAsync&lt;/code&gt; 不支持返回值，而 &lt;code&gt;supplyAsync&lt;/code&gt;可以支持返回结果。&lt;/p&gt;
&lt;p&gt;这个两个方法默认将会使用公共的 &lt;code&gt;ForkJoinPool&lt;/code&gt; 线程池执行，这个线程池默认线程数是 &lt;strong&gt;CPU&lt;/strong&gt; 的核数。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以设置 JVM option:-Djava.util.concurrent.ForkJoinPool.common.parallelism 来设置 ForkJoinPool 线程池的线程数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用共享线程池将会有个弊端，一旦有任务被阻塞，将会造成其他任务没机会执行。所以&lt;strong&gt;强烈&lt;/strong&gt;建议使用后两个方法，根据任务类型不同，主动创建线程池，进行资源隔离，避免互相干扰。&lt;/p&gt;
&lt;h3 id=&quot;设置任务结果&quot;&gt;1.3 设置任务结果&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 提供以下方法，可以主动设置任务结果。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; boolean complete(T value)
 boolean completeExceptionally(Throwable ex)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个方法，主动设置 &lt;code&gt;CompletableFuture&lt;/code&gt; 任务执行结果，若返回 &lt;code&gt;true&lt;/code&gt;，表示设置成功。如果返回 &lt;code&gt;false&lt;/code&gt;，设置失败，这是因为任务已经执行结束，已经有了执行结果。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 执行异步任务
CompletableFuture cf = CompletableFuture.supplyAsync(() -&amp;gt; {
  System.out.println(&quot;cf 任务执行开始&quot;);
  sleep(10, TimeUnit.SECONDS);
  System.out.println(&quot;cf 任务执行结束&quot;);
  return &quot;楼下小黑哥&quot;;
});
//
Executors.newSingleThreadScheduledExecutor().execute(() -&amp;gt; {
  sleep(5, TimeUnit.SECONDS);
  System.out.println(&quot;主动设置 cf 任务结果&quot;);
  // 设置任务结果，由于 cf 任务未执行结束，结果返回 true
  cf.complete(&quot;程序通事&quot;);
});
// 由于 cf 未执行结束，将会被阻塞。5 秒后，另外一个线程主动设置任务结果
System.out.println(&quot;get:&quot; + cf.get());
// 等待 cf 任务执行结束
sleep(10, TimeUnit.SECONDS);
// 由于已经设置任务结果，cf 执行结束任务结果将会被抛弃
System.out.println(&quot;get:&quot; + cf.get());
/***
   * cf 任务执行开始
   * 主动设置 cf 任务结果
   * get:程序通事
   * cf 任务执行结束
   * get:程序通事
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意一点，一旦 &lt;code&gt;complete&lt;/code&gt; 设置成功，&lt;code&gt;CompletableFuture&lt;/code&gt; 返回结果就不会被更改，即使后续 &lt;code&gt;CompletableFuture&lt;/code&gt; 任务执行结束。&lt;/p&gt;
&lt;p&gt;第二个方法，给 &lt;code&gt;CompletableFuture&lt;/code&gt; 设置异常对象。若设置成功，如果调用 &lt;code&gt;get&lt;/code&gt; 等方法获取结果，将会抛错。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 执行异步任务
CompletableFuture cf = CompletableFuture.supplyAsync(() -&amp;gt; {
    System.out.println(&quot;cf 任务执行开始&quot;);
    sleep(10, TimeUnit.SECONDS);
    System.out.println(&quot;cf 任务执行结束&quot;);
    return &quot;楼下小黑哥&quot;;
});
//
Executors.newSingleThreadScheduledExecutor().execute(() -&amp;gt; {
    sleep(5, TimeUnit.SECONDS);
    System.out.println(&quot;主动设置 cf 异常&quot;);
    // 设置任务结果，由于 cf 任务未执行结束，结果返回 true
    cf.completeExceptionally(new RuntimeException(&quot;啊，挂了&quot;));
});
// 由于 cf 未执行结束，前 5 秒将会被阻塞。后续程序抛出异常，结束
System.out.println(&quot;get:&quot; + cf.get());
/***
 * cf 任务执行开始
 * 主动设置 cf 异常
 * java.util.concurrent.ExecutionException: java.lang.RuntimeException: 啊，挂了
 * ......
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;completionstage&quot;&gt;1.4 CompletionStage&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 分别实现两个接口 &lt;code&gt;Future&lt;/code&gt;与 &lt;code&gt;CompletionStage&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080831993-1537839515.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 接口大家都比较熟悉，这里主要讲讲 &lt;code&gt;CompletionStage&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 大部分方法来自&lt;code&gt;CompletionStage&lt;/code&gt; 接口，正是因为这个接口，&lt;code&gt;CompletableFuture&lt;/code&gt;才有如从强大功能。&lt;/p&gt;
&lt;p&gt;想要理解 &lt;code&gt;CompletionStage&lt;/code&gt; 接口，我们需要先了解任务的时序关系的。我们可以将任务时序关系分为以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;串行执行关系&lt;/li&gt;
&lt;li&gt;并行执行关系&lt;/li&gt;
&lt;li&gt;AND 汇聚关系&lt;/li&gt;
&lt;li&gt;OR 汇聚关系&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;串行执行关系&quot;&gt;1.5 串行执行关系&lt;/h3&gt;
&lt;p&gt;任务串行执行，下一个任务必须等待上一个任务完成才可以继续执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080832143-1617974285.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CompletionStage&lt;/code&gt; 有四组接口可以描述串行这种关系，分别为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080832377-303208333.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thenApply&lt;/code&gt; 方法需要传入核心参数为 &lt;code&gt;Function&amp;lt;T,R&amp;gt;&lt;/code&gt;类型。这个类核心方法为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; R apply(T t)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这个接口将会把上一个任务返回结果当做入参，执行结束将会返回结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thenAccept&lt;/code&gt; 方法需要传入参数对象为 &lt;code&gt;Consumer&amp;lt;T&amp;gt;&lt;/code&gt;类型，这个类核心方法为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void accept(T t)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回值 &lt;code&gt;void&lt;/code&gt; 可以看出，这个方法不支持返回结果，但是需要将上一个任务执行结果当做参数传入。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thenRun&lt;/code&gt; 方法需要传入参数对象为 &lt;code&gt;Runnable&lt;/code&gt; 类型，这个类大家应该都比较熟悉，核心方法既不支持传入参数，也不会返回执行结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thenCompose&lt;/code&gt; 方法作用与 &lt;code&gt;thenApply&lt;/code&gt; 一样，只不过 &lt;code&gt;thenCompose&lt;/code&gt; 需要返回新的 &lt;code&gt;CompletionStage&lt;/code&gt;。这么理解比较抽象，可以集合代码一起理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080832532-1535986211.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法中带有 &lt;strong&gt;Async&lt;/strong&gt; ，代表可以异步执行，这个系列还有重载方法，可以传入自定义的线程池，上图未展示，读者只可以自行查看 API。&lt;/p&gt;
&lt;p&gt;最后我们通过代码展示 &lt;code&gt;thenApply&lt;/code&gt; 使用方式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CompletableFuture&amp;lt;String&amp;gt; cf
        = CompletableFuture.supplyAsync(() -&amp;gt; &quot;hello,楼下小黑哥&quot;)// 1
        .thenApply(s -&amp;gt; s + &quot;@程序通事&quot;) // 2
        .thenApply(String::toUpperCase); // 3
System.out.println(cf.join());
// 输出结果 HELLO,楼下小黑哥@程序通事&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码比较简单，首先我们开启一个异步任务，接着串行执行后续两个任务。任务 2 需要等待任务1 执行完成，任务 3 需要等待任务 2。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面方法，大家需要记住了 &lt;code&gt;Function&amp;lt;T，R&amp;gt;&lt;/code&gt;，&lt;code&gt;Consumer&amp;lt;T&amp;gt;&lt;/code&gt;，&lt;code&gt;Runnable&lt;/code&gt; 三者区别，根据场景选择使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;and-汇聚关系&quot;&gt;1.6 AND 汇聚关系&lt;/h3&gt;
&lt;p&gt;AND 汇聚关系代表所有任务完成之后，才能进行下一个任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080832681-1554875019.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上所示，只有任务 A 与任务 B 都完成之后，任务 C 才会开始执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CompletionStage&lt;/code&gt; 有以下接口描述这种关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080832840-2047568284.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thenCombine&lt;/code&gt; 方法核心参数 &lt;code&gt;BiFunction&lt;/code&gt; ，作用与 &lt;code&gt;Function&lt;/code&gt;一样，只不过 &lt;code&gt;BiFunction&lt;/code&gt; 可以接受两个参数，而 &lt;code&gt;Function&lt;/code&gt; 只能接受一个参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thenAcceptBoth&lt;/code&gt; 方法核心参数&lt;code&gt;BiConsumer&lt;/code&gt; 作用也与 &lt;code&gt;Consumer&lt;/code&gt;一样，不过其需要接受两个参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;runAfterBoth&lt;/code&gt; 方法核心参数最简单，上面已经介绍过，不再介绍。&lt;/p&gt;
&lt;p&gt;这三组方法只能完成两个任务 AND 汇聚关系，如果需要完成多个任务汇聚关系，需要使用 &lt;code&gt;CompletableFuture#allOf&lt;/code&gt;，不过这里需要注意，这个方法是不支持返回任务结果。&lt;/p&gt;
&lt;p&gt;AND 汇聚关系相关示例代码，开头已经使用过了，这里再粘贴一下，方便大家理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080830551-292151003.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;or-汇聚关系&quot;&gt;1.7 OR 汇聚关系&lt;/h3&gt;
&lt;p&gt;有 AND 汇聚关系，当然也存在 OR 汇聚关系。OR 汇聚关系代表只要多个任务中任一任务完成，就可以接着接着执行下一任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080833275-1582656936.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CompletionStage&lt;/code&gt; 有以下接口描述这种关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080833438-320401663.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面三组接口方法传参与 AND 汇聚关系一致，这里也不再详细解释了。&lt;/p&gt;
&lt;p&gt;当然 OR 汇聚关系可以使用 &lt;code&gt;CompletableFuture#anyOf&lt;/code&gt; 执行多个任务。&lt;/p&gt;
&lt;p&gt;下面示例代码展示如何使用 &lt;code&gt;applyToEither&lt;/code&gt; 完成 OR 关系。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CompletableFuture&amp;lt;String&amp;gt; cf
        = CompletableFuture.supplyAsync(() -&amp;gt; {
    sleep(5, TimeUnit.SECONDS);
    return &quot;hello,楼下小黑哥&quot;;
});// 1

CompletableFuture&amp;lt;String&amp;gt; cf2 = cf.supplyAsync(() -&amp;gt; {
    sleep(3, TimeUnit.SECONDS);
    return &quot;hello，程序通事&quot;;
});
// 执行 OR 关系
CompletableFuture&amp;lt;String&amp;gt; cf3 = cf2.applyToEither(cf, s -&amp;gt; s);

// 输出结果，由于 cf2 只休眠 3 秒，优先执行完毕
System.out.println(cf2.join());
// 结果：hello，程序通事&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常处理&quot;&gt;1.8 异常处理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 方法执行过程若产生异常，当调用 &lt;code&gt;get&lt;/code&gt;，&lt;code&gt;join&lt;/code&gt;获取任务结果才会抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080833701-1718647955.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码我们显示使用 &lt;code&gt;try..catch&lt;/code&gt; 处理上面的异常。不过这种方式不太优雅，&lt;code&gt;CompletionStage&lt;/code&gt; 提供几个方法，可以优雅处理异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080833846-944666818.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exceptionally&lt;/code&gt; 使用方式类似于 &lt;code&gt;try..catch&lt;/code&gt; 中 &lt;code&gt;catch&lt;/code&gt;代码块中异常处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;whenComplete&lt;/code&gt; 与 &lt;code&gt;handle&lt;/code&gt; 方法就类似于 &lt;code&gt;try..catch..finanlly&lt;/code&gt; 中 &lt;code&gt;finally&lt;/code&gt; 代码块。无论是否发生异常，都将会执行的。这两个方法区别在于 &lt;code&gt;handle&lt;/code&gt; 支持返回结果。&lt;/p&gt;
&lt;p&gt;下面示例代码展示 &lt;code&gt;handle&lt;/code&gt; 用法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CompletableFuture&amp;lt;Integer&amp;gt;
        f0 = CompletableFuture.supplyAsync(() -&amp;gt; (7 / 0))
        .thenApply(r -&amp;gt; r * 10)
        .handle((integer, throwable) -&amp;gt; {
            // 如果异常存在,打印异常，并且返回默认值
            if (throwable != null) {
                throwable.printStackTrace();
                return 0;
            } else {
                // 如果
                return integer;
            }
        });


System.out.println(f0.join());
/**
 *java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero
 * .....
 * 
 * 0
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;x02.-总结&quot;&gt;0x02. 总结&lt;/h2&gt;
&lt;p&gt;JDK8 提供 &lt;code&gt;CompletableFuture&lt;/code&gt; 功能非常强大，可以编排异步任务，完成串行执行，并行执行，AND 汇聚关系，OR 汇聚关系。&lt;/p&gt;
&lt;p&gt;不过这个类方法实在太多，且方法还需要传入各种函数式接口，新手刚开始使用会直接会被弄懵逼。这里帮大家在总结一下三类核心参数的作用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Function&lt;/code&gt; 这类函数接口既支持接收参数，也支持返回值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Consumer&lt;/code&gt; 这类接口函数只支持接受参数，不支持返回值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Runnable&lt;/code&gt; 这类接口不支持接受参数，也不支持返回值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;搞清楚函数参数作用以后，然后根据串行，AND 汇聚关系，OR 汇聚关系归纳一下相关方法，这样就比较好理解了&lt;/p&gt;
&lt;p&gt;最后再贴一下，文章开头的思维导图，希望对你有帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200309080834023-515296793.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x03.-帮助文档&quot;&gt;0x03. 帮助文档&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;极客时间-并发编程专栏&lt;/li&gt;
&lt;li&gt;https://colobu.com/2016/02/29/Java-CompletableFuture&lt;/li&gt;
&lt;li&gt;https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最后说一句求关注&quot;&gt;最后说一句（求关注）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 很早之前就有关注，本以为跟 &lt;code&gt;Future&lt;/code&gt;一样，使用挺简单，谁知道学的时候才发现好难。各种 API 方法看的头有点大。&lt;/p&gt;
&lt;p&gt;后来看到极客时间-『并发编程』专栏使用归纳方式分类 &lt;code&gt;CompletableFuture&lt;/code&gt; 各种方法，一下子就看懂了。所这篇文章也参考这种归纳方式。&lt;/p&gt;
&lt;p&gt;这篇文章找资料，整理一个星期，幸好今天顺利产出。&lt;/p&gt;
&lt;p&gt;看在小黑哥写的这么辛苦的份上，点个关注吧，赏个赞呗。别下次一定啊，大哥！写文章很辛苦的，需要来点正反馈。&lt;/p&gt;
&lt;p&gt;才疏学浅，难免会有纰漏，如果你发现了错误的地方，还请你留言给我指出来，我对其加以修改。&lt;/p&gt;
&lt;p&gt;感谢您的阅读，&lt;strong&gt;我坚持原创&lt;/strong&gt;，十分欢迎并感谢您的关注~&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 09 Mar 2020 00:09:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>hello，各位小伙伴们早上好，今天给大家分享一篇关于使用 CompletableFuture 进行异步编程的文章。  CompletableFuture 这个类功能非常强大，支持回调方式处理任务结果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12446644.html</dc:identifier>
</item>
<item>
<title>【原创】为什么我的 Kafka 总是连接失败呢？ - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/why_cnnect_to_kafka_always_failure.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/why_cnnect_to_kafka_always_failure.html</guid>
<description>&lt;h2 id=&quot;提出问题&quot;&gt;提出问题&lt;/h2&gt;
&lt;p&gt;近日助友 &lt;span&gt;Docker 部署 Kafka 服务，服务日志启动正常，但客户端却无法连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;往日曾踩过此坑，然方法均源于博客，其语焉不详，不知为何不行，亦不知为何行，印象不甚深刻，耗费大量时间&lt;/p&gt;
&lt;p&gt;为避此坑，特地学习官方文档相关章节，让我寻到珠丝马迹，请听我娓娓道来~&lt;/p&gt;
&lt;p&gt;如嫌篇幅较长，可跳过验证，直奔结论&lt;/p&gt;
&lt;p&gt;本文主要记录为何会出现无法连接到 Broker 的原因，想必看完本文你会知道该怎么做的 :)&lt;/p&gt;
&lt;p&gt;谨以此文献给那些因为无知而浪费的时光！&lt;/p&gt;
&lt;h2 id=&quot;大胆猜测&quot;&gt;大胆猜测&lt;/h2&gt;
&lt;p&gt;Kafka的服务端称为 &lt;code&gt;Broker&lt;/code&gt;，每个 Broker 启动时会将自己的 Broker 配置信息上报给 &lt;code&gt;Zookeeper&lt;/code&gt; ，如，监听地址与端口号等，Kafka的客户端（生产者与消费者统称）要连接 Broker 需要经过一层认证，不通过认证就无法连接！&lt;/p&gt;
&lt;h2 id=&quot;小心求证&quot;&gt;小心求证&lt;/h2&gt;
&lt;h3 id=&quot;测试环境&quot;&gt;测试环境：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;GNU/Linux Debian 10 4.19.0内核&lt;/li&gt;
&lt;li&gt;Docker：&lt;code&gt;19.03.6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Docker-compose：&lt;code&gt;1.17.1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;镜像：&lt;code&gt;zookeeper:3.5.5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;镜像：&lt;code&gt;wurstmeister/kafka:2.12-2.2.1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;设计实验&quot;&gt;设计实验：&lt;/h3&gt;
&lt;p&gt;使用 docker 镜像部署一套单节点的 &lt;code&gt;Zookeeper&lt;/code&gt; + &lt;code&gt;Kafka&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要求Broker监听自定义域名（主机名）与端口，服务启动后展示 &lt;code&gt;Zookeeper&lt;/code&gt; 中 &lt;code&gt;Broker&lt;/code&gt; 的注册信息&lt;/p&gt;
&lt;p&gt;使用客户端连接 &lt;code&gt;Broker&lt;/code&gt; ，使用不同的 &lt;code&gt;--bootstrap-server&lt;/code&gt; 组合方式，进行验证&lt;/p&gt;
&lt;h3 id=&quot;开始实验&quot;&gt;开始实验&lt;/h3&gt;
&lt;p&gt;为了提高部署效率，这里提供一个简单可启动的 &lt;code&gt;docker-compose-test.yml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: &quot;3.3&quot;
services:
    zookeeper:
        image: zookeeper:3.5.5
        restart: always
        container_name: zookeeper
        ports:
            - &quot;2181:2181&quot;
        expose:
            - &quot;2181&quot;
        environment:
            - ZOO_MY_ID=1
    kafka:
        image: wurstmeister/kafka:2.12-2.2.1
        restart: always
        container_name: kafka
        environment:
            - KAFKA_BROKER_ID=1
            - KAFKA_LISTENERS=PLAINTEXT://kafka:9090
            - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
            - KAFKA_MESSAGE_MAX_BYTES=2000000
        ports:
            - &quot;9090:9090&quot;
        depends_on:
            - zookeeper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 &lt;code&gt;docker-compose-test.yml&lt;/code&gt; 放入你的目录，运行部署脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309012513269-1982982116.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看两者的日志，检查是否正常启动&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker logs -f zookeeper &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309012925576-846797736.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker logs -f kafka&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309013408560-662367560.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 Kafka 已经注册成功&lt;/p&gt;
&lt;p&gt;让我们查看一下，Zookeeper 中注册的 Broker 信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker exec -it zookeeper bash bin/zkCli.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309014107520-1584005744.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;quit&lt;/code&gt; 退出&lt;/p&gt;
&lt;p&gt;想到我们已经将Kafka监听的端口号已经映射到宿主机了，使用宿主机 IP 访问不就得了？&lt;/p&gt;
&lt;p&gt;先创建个Topic&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -it --rm --network host wurstmeister/kafka:2.12-2.2.1 \
             bash /opt/kafka/bin/kafka-topics.sh \
             --bootstrap-server 192.168.1.19:9090 \
             --create --topic logsTopic --partitions 1 --replication-factor 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309015353135-668033151.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;噢！又是这该死的错误！&lt;/p&gt;
&lt;p&gt;想到刚才在 &lt;code&gt;zookeeper&lt;/code&gt; 中看到的信息，要不我把 IP 换成 &lt;code&gt;kafka&lt;/code&gt; 不就结了？&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -it --rm --network host wurstmeister/kafka:2.12-2.2.1 \
             bash /opt/kafka/bin/kafka-topics.sh \
             --bootstrap-server kafka:9090 \
             --create --topic logsTopic --partitions 1 --replication-factor 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309015042025-1764613927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不对，宿主机本身没有对 &lt;code&gt;kafka&lt;/code&gt; 作映射，问题一定出在这里！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309015854775-1057766554.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次执行刚才的命令，没有输出，说明创建 Topic 成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309020104350-1349176194.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生产一条消息测试下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -it --rm --network host wurstmeister/kafka:2.12-2.2.1 \
        bash /opt/kafka/bin/kafka-console-producer.sh \
        --broker-list kafka:9090 --topic logsTopic&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309020612665-412307096.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入回车，发送消息； ctrl + c 断开连接&lt;/p&gt;
&lt;p&gt;创建消费者，消费消息测试&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -it --rm --network host wurstmeister/kafka:2.12-2.2.1 \
        bash /opt/kafka/bin/kafka-console-consumer.sh \
        --bootstrap-server kafka:9090  --topic logsTopic  --from-beginning&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1149398/202003/1149398-20200309021018678-1101588121.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，消费也成功了&lt;/p&gt;
&lt;h2 id=&quot;归纳总结&quot;&gt;归纳总结&lt;/h2&gt;
&lt;p&gt;这个实验说明了什么呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明 Kafka 客户端在连接 Broker 的时候，Broker 将客户端发来的请求带的信息与 Broker 启动时上报给 Zookeeper 的信息 进行了比对，比对相同则认证通过，反之建立连接失败！&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;官方文档&quot;&gt;官方文档&lt;/h2&gt;
&lt;p&gt;通过耐心地查看 &lt;code&gt;Kafka&lt;/code&gt; 的官方文档，终于在角落里看到她的影子！（好久不见妹子，看文档都眉清目秀的~）&lt;/p&gt;
&lt;p&gt;比如下面这段：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;From Kafka version 2.0.0 onwards, host name verification of servers is enabled by default for client connections as well as inter-broker connections to prevent man-in-the-middle attacks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大意是讲通过这种&lt;code&gt;认证hostname&lt;/code&gt;的机制，来避免中间人攻击&lt;/p&gt;
&lt;p&gt;还有这段：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;advertised.host.name&lt;/strong&gt;: DEPRECATED: only used when &lt;code&gt;advertised.listeners&lt;/code&gt; or &lt;code&gt;listeners&lt;/code&gt; are not set. Use &lt;code&gt;advertised.listeners&lt;/code&gt; instead. Hostname to publish to ZooKeeper for clients to use. In IaaS environments, this may need to be different from the interface to which the broker binds. &lt;span&gt;If this is not set, it will use the value for &lt;code&gt;host.name&lt;/code&gt; if configured. Otherwise it will use the value returned from java.net.InetAddress.getCanonicalHostName().&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然这个参数已经标记为废弃了，但是她提供了个信息：如果设置主机名可能会被上报&lt;/p&gt;
&lt;p&gt;最后看看这段&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;advertised.listeners&lt;/strong&gt;: &lt;span&gt;Listeners to publish to ZooKeeper for clients to use, if different than the &lt;code&gt;listeners&lt;/code&gt; config property. In IaaS environments, this may need to be different from the interface to which the broker binds. If this is not set, the value for &lt;code&gt;listeners&lt;/code&gt; will be used.&lt;/span&gt; Unlike &lt;code&gt;listeners&lt;/code&gt; it is not valid to advertise the 0.0.0.0 meta-address.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，无论设置 &lt;code&gt;listeners&lt;/code&gt; 还是 &lt;code&gt;advertised.listeners&lt;/code&gt; 它们其一的信息会被上报，供客户端使用；只有在需要绑定不同接口时，才需要设置 &lt;code&gt;advertised.listeners&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Kafka 客户端在连接 Broker 的时候，Broker 将客户端发来的请求附加信息与 Broker 启动时上报给 Zookeeper 的 listeners参数信息、host（来自listeners的中间域名或主机名部分）、port (来自listeners的端口部分) 进行了验证，认证通过建立连接执行请求，反之建立连接失败&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;写这篇文章费了好大的功夫，猜是一回事，弄明白又是一回事，如果本文对你有所帮助，欢迎点推荐与关注&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引用：&lt;br/&gt;&lt;a href=&quot;https://kafka.apache.org/documentation.html&quot; class=&quot;uri&quot;&gt;https://kafka.apache.org/documentation.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文采用 CC BY 4.0 协议进行授权，转载请标注作者署名及来源。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/hellxz/p/why_cnnect_to_kafka_always_failure.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/hellxz/p/why_cnnect_to_kafka_always_failure.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 00:02:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>提出问题 近日助友 Docker 部署 Kafka 服务，服务日志启动正常，但客户端却无法连接 往日曾踩过此坑，然方法均源于博客，其语焉不详，不知为何不行，亦不知为何行，印象不甚深刻，耗费大量时间 为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hellxz/p/why_cnnect_to_kafka_always_failure.html</dc:identifier>
</item>
<item>
<title>（数据科学学习手札79）基于geopandas的空间数据分析——深入浅出分层设色 - 费弗里</title>
<link>http://www.cnblogs.com/feffery/p/12381322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feffery/p/12381322.html</guid>
<description>&lt;blockquote readability=&quot;3.196261682243&quot;&gt;
&lt;p&gt;本文对应代码和数据已上传至我的&lt;code&gt;Github&lt;/code&gt;仓库&lt;a href=&quot;https://github.com/CNFeffery/DataScienceStudyNotes&quot; class=&quot;uri&quot;&gt;https://github.com/CNFeffery/DataScienceStudyNotes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　通过前面的文章，我们已经对&lt;code&gt;geopandas&lt;/code&gt;中的&lt;strong&gt;数据结构&lt;/strong&gt;、&lt;strong&gt;坐标参考系&lt;/strong&gt;、&lt;strong&gt;文件IO&lt;/strong&gt;以及&lt;strong&gt;基础可视化&lt;/strong&gt;有了较为深入的学习，其中在&lt;strong&gt;基础可视化&lt;/strong&gt;那篇文章中我们提到了分层设色地图，可以对与多边形关联的数值属性进行分层，并分别映射不同的填充颜色，但只是开了个头举了个简单的例子，实际数据可视化过程中的分层设色有一套策略方法。&lt;/p&gt;
&lt;p&gt;　　作为&lt;em&gt;基于geopandas的空间数据分析&lt;/em&gt;系列文章的第五篇，通过本文你将会学习到基于&lt;code&gt;geopandas&lt;/code&gt;和机器学习的&lt;strong&gt;分层设色&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;地区分布图&lt;/strong&gt;（&lt;em&gt;Choropleth maps&lt;/em&gt;，又叫面量图）作为可能是最常见的一种地理可视化方法，其核心是对某个与矢量面关联的数值序列进行有意义的分层，并为这些分层选择合适美观的色彩，最后完成对地图的着色，优点是美观且直观，即使对地理信息一窍不通的人，也能通过颜色区分出不同面之间的同质性与异质性：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309014947606-680390211.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　但同样地，如果对数据分层采取的方法有失严谨没有很好的遵循数据特点，会很容易让看到图的人产生出不正确的判断，下面我们按照先分层，后设色的顺序进行介绍。&lt;/p&gt;
&lt;h2 id=&quot;基于mapclassify的数据分层&quot;&gt;2.1 基于mapclassify的数据分层&lt;/h2&gt;
&lt;p&gt;　　上一篇文章中我们提到过,，在&lt;code&gt;geopandas.GeoDataFrame.plot()&lt;/code&gt;中，参数&lt;code&gt;scheme&lt;/code&gt;对应的数据分层是基于第三方库&lt;code&gt;mapclassify&lt;/code&gt;实现的，因此要想对&lt;code&gt;geopandas&lt;/code&gt;中的数据分层有深入的了解，我们就得先来了解一下&lt;code&gt;mapclassify&lt;/code&gt;中的各种数据分层算法，用到的数据是系列文章前几期使用地滚瓜烂熟的新冠肺炎疫情数据，数据处理过程同上一篇文章，这里不再解释：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309080733759-934443377.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/center&gt;
&lt;h3 id=&quot;boxplot&quot;&gt;2.1.1 BoxPlot&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;BoxPlot&lt;/code&gt;即箱线图，是统计学中使用到的一种方法：对个数为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;观测数据从小到大进行排序，分别得到位置处于&lt;span class=&quot;math inline&quot;&gt;\(0.25n\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(0.5n\)&lt;/span&gt;以及&lt;span class=&quot;math inline&quot;&gt;\(0.75n\)&lt;/span&gt;的观测值，称为&lt;span class=&quot;math inline&quot;&gt;\(Q_{1}\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(Median\)&lt;/span&gt;以及&lt;span class=&quot;math inline&quot;&gt;\(Q_{3}\)&lt;/span&gt;（即第一四位数、中位数和第三四分位数），并定义&lt;span class=&quot;math inline&quot;&gt;\(Q_{3}-Q_{1}\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(IQR\)&lt;/span&gt;，以&lt;span class=&quot;math inline&quot;&gt;\(Q_{1}-1.5IQR\)&lt;/span&gt;为下限，以&lt;span class=&quot;math inline&quot;&gt;\(Q3+1.5IQR\)&lt;/span&gt;为上限，将小于下限或大于上限的观测值作为离群异常值，最后用图像的形式表达上述计算结果，如图2的上图，而图2的下图对应着概率估计，可以看出，箱线图法实际上是基于概率估计的一种异常值剔除方法，因为离群值只有&lt;span class=&quot;math inline&quot;&gt;\(0.0035*2=0.007\)&lt;/span&gt;的概率会出现，即如果你想要找出数据中的异常高低值，&lt;code&gt;BoxPlot&lt;/code&gt;是不错的选择：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309014954143-1492026827.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　在&lt;code&gt;mapclassify&lt;/code&gt;中我们使用&lt;code&gt;BoxPlot()&lt;/code&gt;来为数据实现箱线图分层：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import mapclassify as mc

# 对各省2020-03-08对应的累计确诊数量进行分层
bp = mc.BoxPlot(temp['province_confirmedCount'])
# 查看数据分层结果
bp&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309014956508-651043056.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　可以看出通过箱线图法将数据分成了五类，其中&lt;strong&gt;异常值&lt;/strong&gt;只有1个即为湖北省，下面我们配合&lt;code&gt;geopandas&lt;/code&gt;来对上述结果进行可视化，和上一篇文章一样，按照省级单位名称连接我们的疫情数据与矢量数据：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309014958615-381354321.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　接着对其进行可视化，在上一篇文章图28的基础上，将&lt;code&gt;scheme&lt;/code&gt;参数改为&lt;code&gt;BoxPlot&lt;/code&gt;，又因为箱线图可以看作无监督问题，故分层数量&lt;code&gt;k&lt;/code&gt;在这里无效，删去：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;fig, ax = plt.subplots(figsize=(10, 10))

ax = data_with_geometry.to_crs(albers_proj).plot(ax=ax,
                                                 column='province_confirmedCount',
                                                 cmap='Reds',
                                                 missing_kwds={
                                                     &quot;color&quot;: &quot;lightgrey&quot;,
                                                     &quot;edgecolor&quot;: &quot;black&quot;,
                                                     &quot;hatch&quot;: &quot;////&quot;,
                                                     &quot;label&quot;: &quot;缺失值&quot;
                                                 },
                                                 legend=True,
                                                 scheme='BoxPlot',
                                                 legend_kwds={
                                                     'loc': 'lower left',
                                                     'title': '确诊数量分级',
                                                     'shadow': True
                                                 })

ax = nine_lines.geometry.to_crs(albers_proj).plot(ax=ax,
                                                  edgecolor='grey',
                                                  linewidth=3,
                                                  alpha=0.4)

ax.axis('off')
plt.suptitle('新型冠状肺炎累计确诊数量地区分布', fontsize=24) # 添加最高级别标题
plt.tight_layout(pad=4.5) # 调整不同标题之间间距
ax.text(-2800000, 1300000, '* 原始数据来源：丁香园，\n其中台湾及香港数据缺失') # 添加数据说明

fig.savefig('图6.png', dpi=300)&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015002778-576035073.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　咋看起来没问题，但是如果你仔细观察左下角的图例会发现前两行范围颜色是重复的，且数值范围是错乱的，这是&lt;code&gt;geopandas.GeoDataFrame.plot()&lt;/code&gt;中涉及箱线图法的一个小&lt;code&gt;bug&lt;/code&gt;，遇到这种问题不用慌，如果你在上一篇文章中去我的&lt;code&gt;Github&lt;/code&gt;仓库查看过创作图29对应的代码，一定会想到既然&lt;code&gt;geopandas&lt;/code&gt;自身有&lt;strong&gt;bug&lt;/strong&gt;，那我们用&lt;code&gt;matplotlib&lt;/code&gt;中的&lt;code&gt;mpatches&lt;/code&gt;和&lt;code&gt;legend&lt;/code&gt;自定义图例就可以啦，而为了自定义的图例色彩与&lt;code&gt;geopandas&lt;/code&gt;映射出的保持一致，我们需要额外使用到&lt;code&gt;matplotlib&lt;/code&gt;中的&lt;code&gt;get_cmap(cmap)&lt;/code&gt;来制作可独立导出颜色的&lt;strong&gt;cmap&lt;/strong&gt;方案实例，譬如我们这里是&lt;code&gt;Reds&lt;/code&gt;，就需要按照前面&lt;code&gt;bp&lt;/code&gt;的有记录数量的分层结果，从&lt;code&gt;Reds&lt;/code&gt;中产生同样5个档次的颜色，具体操作过程如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import matplotlib.patches as mpatches

fig, ax = plt.subplots(figsize=(10, 10))

ax = data_with_geometry.to_crs(albers_proj).plot(ax=ax,
                                                 column='province_confirmedCount',
                                                 cmap='Reds',
                                                 missing_kwds={
                                                     &quot;color&quot;: &quot;lightgrey&quot;,
                                                     &quot;edgecolor&quot;: &quot;black&quot;,
                                                     &quot;hatch&quot;: &quot;////&quot;,
                                                     &quot;label&quot;: &quot;缺失值&quot;
                                                 },
                                                 scheme='BoxPlot')

handles, labels = ax.get_legend_handles_labels() #get existing legend item handles and labels

ax = nine_lines.geometry.to_crs(albers_proj).plot(ax=ax,
                                                  edgecolor='grey',
                                                  linewidth=3,
                                                  alpha=0.4)

# 实例化cmap方案
cmap = plt.get_cmap('Reds')

# 得到mapclassify中BoxPlot的数据分层点
bp = mc.BoxPlot(temp['province_confirmedCount'])
bins = bp.bins

# 制作图例映射对象列表
LegendElement = [mpatches.Patch(facecolor=cmap(_*0.25), label=f'{int(max(bins[_], 0))} - {int(bins[_+1])}') 
                 for _ in range(5)] + \
                [mpatches.Patch(facecolor='lightgrey', edgecolor='black', hatch='////', label='缺失值')]

# 将制作好的图例映射对象列表导入legend()中，并配置相关参数
ax.legend(handles = LegendElement, loc='lower left', fontsize=10, title='确诊数量分级', shadow=True, borderpad=0.6)

ax.axis('off')
plt.suptitle('新型冠状肺炎累计确诊数量地区分布(截至2020年03月04日)', fontsize=24) # 添加最高级别标题
plt.title('数据分层方法：BoxPlot', fontsize=18)
plt.tight_layout(pad=4.5) # 调整不同标题之间间距
ax.text(-2900000, 1250000, '* 原始数据来源：丁香园，\n其中台湾及香港数据缺失') # 添加数据说明

fig.savefig('图7.png', dpi=300)&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015007208-792688777.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　可以看到，通过自定义图例的方式，虽然麻烦了一点，但是我们不仅修复了图例的&lt;strong&gt;bug&lt;/strong&gt;，还为其添加了更加完善的细节，如图形修改为矩形，范围修改为整数。&lt;/p&gt;
&lt;h3 id=&quot;equalinterval&quot;&gt;2.1.2 EqualInterval&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;EqualInterval&lt;/code&gt;即等间距，是最简单的一种分层方法，它在原数据最小值与最大值间以等间距的方式划分出&lt;code&gt;k&lt;/code&gt;个层次，&lt;code&gt;mapclassify&lt;/code&gt;中对应等间距法的类为&lt;code&gt;EqualInterval()&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;bp = mc.EqualInterval(temp['province_confirmedCount'])
# 查看数据分层结果
bp&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015008780-891772349.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　可以看到对于分布非常不均匀的新冠肺炎确诊数量数据来说，这种方法表现得十分糟糕，中间三个类都没有记录落入，如果使用这种方法强行绘图，效果就会类似上一篇文章中地区分布图部分，最开始那个糟糕的效果那样只有湖北一个地方是最深的暗红色，而其他地方皆为最淡的色阶，这里就不重复演示。&lt;/p&gt;
&lt;h3 id=&quot;fisherjenks&quot;&gt;2.1.3 FisherJenks&lt;/h3&gt;
&lt;p&gt;　　在了解&lt;code&gt;mapclassify&lt;/code&gt;中的&lt;code&gt;FisherJenks&lt;/code&gt;之前，我们先来了解一下什么是&lt;em&gt;Jenks Natural Breaks&lt;/em&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Jenks Natural Breaks&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;em&gt;Jenks Natural Breaks&lt;/em&gt;旨在为1维数据计算合适的划分点，使得不同组之间的差距尽可能大的同时组内差距尽可能小，其思路非常简单，举一个简单的例子进行说明：&lt;/p&gt;
&lt;p&gt;　　对于一组待分割的序列&lt;span class=&quot;math inline&quot;&gt;\(X=[4, 5, 9, 10]\)&lt;/span&gt;，现在需要为其找到将原始数据分为&lt;span class=&quot;math inline&quot;&gt;\(k=2\)&lt;/span&gt;部分的方法，那么实际上就有&lt;span class=&quot;math inline&quot;&gt;\([4], [5, 9, 10]\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\([4, 5], [9, 10]\)&lt;/span&gt;以及&lt;span class=&quot;math inline&quot;&gt;\([4, 5, 9],[10]\)&lt;/span&gt;这三种切分方法，现定义&lt;em&gt;sum of squared deviations for array mean&lt;/em&gt;（简称&lt;em&gt;SDAM&lt;/em&gt;）：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SDAM=\sum_{i=1}^{n}(X_{i}-\bar{X})^{2} \]&lt;/span&gt;&lt;br/&gt;　　以及针对每一种数据分层方法，在其分出的每一组&lt;span class=&quot;math inline&quot;&gt;\(G_{i}\)&lt;/span&gt;上计算组内离差平方和并累加所有组的结果，定义为&lt;em&gt;sum of squared deviations for class means&lt;/em&gt;（简称&lt;em&gt;SDCM_ALL&lt;/em&gt;）：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SDCM\_ALL=\sum_{i=1}^{k}\sum_{j=1}^{|G_{i}|}(G_{ij}-\bar{G_{i}})^2 \]&lt;/span&gt;&lt;br/&gt;　　有了&lt;span class=&quot;math inline&quot;&gt;\(SDAM\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(SDAM\_ALL\)&lt;/span&gt;，现在对分组优劣定义一个评判指标&lt;em&gt;goodness of variance fit&lt;/em&gt;（简称&lt;em&gt;GVF&lt;/em&gt;），取值范围为&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;，越高越好：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ GVF=(SDAM-SCDM)/SDAM \]&lt;/span&gt;&lt;br/&gt;　　这样我们就可以对每一种分组方案进行评价，譬如对我们上面简单的例子：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SDAM=(4-7)^2+(5-7)^2+(9-7)^2+(10-7)^2=26 \\ SDCM_{1}=[(4-4)^2]+[(5-8)^2+(9-8)^2+(10-8)^2]=14 \\ SDCM_{2}=[(4-4.5)^2+(5-4.5)^2]+[(9-9.5)^2+(10-9.5)^2]=1 \\ SDCM_{3}=[(4-6)^2+(5-6)^2+(9-6)^2]+[(10-10)^2]=14 \]&lt;/span&gt;&lt;br/&gt;　　则对应各种方案的&lt;em&gt;GVF&lt;/em&gt;计算如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ GVF_{1}=GVF_{3}=(26-14)/26=0.46 \\ GVF_{2}=(26-1)/26=0.96 \]&lt;/span&gt;&lt;br/&gt;　　可以看出第三种方案&lt;span class=&quot;math inline&quot;&gt;\([4, 5], [9, 10]\)&lt;/span&gt;的分层方法效果最好，也与我们对数据的直观感觉相贴合，这就是&lt;em&gt;Jenks Natural Breaks&lt;/em&gt;的基本思路，但这种暴力遍历所有分组方案的做法对数据数量及选择分组的个数很敏感，尤其是对分组数量，一旦分组数量过于多，待筛选计算的方案数量就变成了天文数字，下面我来告诉大家为什么：&lt;/p&gt;
&lt;p&gt;　　定义长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的序列&lt;span class=&quot;math inline&quot;&gt;\(X=[x_{1},x_{2},...,x_{n}]\)&lt;/span&gt;。且满足&lt;span class=&quot;math inline&quot;&gt;\(i\leq{j}\)&lt;/span&gt;时&lt;span class=&quot;math inline&quot;&gt;\(x_{i}\leq{x_{j}}\)&lt;/span&gt;，即整个序列从小到大单调递增，那么将其分成&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;组的过程，可以分解为先选择第一组，且为了保证右边剩余&lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;个组每组至少有1个数据分配，则第一组有&lt;span class=&quot;math inline&quot;&gt;\(n-k+1\)&lt;/span&gt;种分配方式，而第一组包含的数字数量&lt;span class=&quot;math inline&quot;&gt;\(n_{1}\)&lt;/span&gt;确定之后，剩余&lt;span class=&quot;math inline&quot;&gt;\(n-n_{1}\)&lt;/span&gt;个数据的继续分组又可以视为独立的递归分组过程，因此最终需要考虑的方案个数用公式表达起来有些复杂，但是换成计算机中的&lt;em&gt;递归&lt;/em&gt;过程就变得一目了然，我经过思考和纸上的推演，写出了下面所示的递归函数&lt;code&gt;f(n, k)&lt;/code&gt;来实现方案总数的计算：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def f(n, k):

    # 若k退化为2，则显然需要n - 1种方案，譬如4个数字分2组有3种方案
    if k == 2:
        return n - 1

    else:
        # 若k未退化为2，则继续递归过程
        return sum([f(n-_, k-1) for _ in range(1, n - k + 2)])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　有了这个递归函数，我们就可以来直观的看一看为什么不能选择太多分组，首先我们对长度为100的序列分为5组试试：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f(100, 3)
Out[11]: 4851&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　可以看到待选择的方案才4851个，还是很少的，那么我们接下来将组数提高到5：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f(100, 5)
Out[12]: 3764376&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　发生了什么？随着递归深度的增大，待选择方案数量一下子就提高到三百多万个！再切换成7试一下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f(100, 7)
Out[13]: 1120529256&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　在跑上述代码时，明显能感受到计算花费时间的激增，最终结果也达到惊人的11亿多！看到这，我们就明白了，原始的&lt;em&gt;Jenks Natural Breaks&lt;/em&gt;算法虽然很有效，但如果以暴力遍历的方式计算，其复杂度是难以应付日常需求的，为了对其进行优化，以在少量的计算时间内计算出尽可能靠谱的分组结果，一系列改良加速方法被提出，而&lt;code&gt;mapclassify&lt;/code&gt;中的&lt;code&gt;FisherJenks&lt;/code&gt;，即为&lt;em&gt;jenks&lt;/em&gt;教授在论文&lt;em&gt;Fisher, W. D., 1958, On grouping for maximum homogeneity.&lt;/em&gt;的基础上提出的改良算法，但这是一个很神秘的算法，根据https://macwright.org/2013/02/18/literate-jenks.html 中的介绍，&lt;em&gt;jenks&lt;/em&gt;教授的原始论文没有留下数字化资料，一直为堪萨斯大学地理学系所私有，而随着1996年&lt;em&gt;jenks&lt;/em&gt;教授的离世，原论文需要到2072年版权才能到期公开，所以我们现在在各种&lt;code&gt;GIS&lt;/code&gt;类软件以及各种开源软件包中使用到的&lt;code&gt;fisher jenks&lt;/code&gt;算法，均是对最初的一段&lt;code&gt;Fortran&lt;/code&gt;代码的移植和改造，这也成了一段未解之谜，感兴趣的读者可以去https://stat.ethz.ch/pipermail/r-sig-geo/2006-March/000811.html 了解更多。&lt;/p&gt;
&lt;p&gt;　　回到我们的主题，搞清楚了&lt;code&gt;FisherJenks&lt;/code&gt;的计算目标之后，我们同样利用&lt;code&gt;mapclassify&lt;/code&gt;计算分层结果，其默认分层为5：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015011263-1779893842.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　可以看到，在这种方式下，数据的分组较为合理，同样将&lt;code&gt;geopandas.GeoDataFrame.plot()&lt;/code&gt;中的参数设置为&lt;code&gt;FisherJenks&lt;/code&gt;绘制出图10：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015020468-715021201.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　与&lt;code&gt;BoxPlot&lt;/code&gt;相比差距还是比较明显，处于第二级严重程度的省份只有河南、广东及浙江，更贴近数据的自然层次结构。&lt;/p&gt;
&lt;h3 id=&quot;naturalbreaks&quot;&gt;2.1.4 NaturalBreaks&lt;/h3&gt;
&lt;p&gt;　　等下！上一小结中的&lt;code&gt;FisherJenks&lt;/code&gt;不就是我们俗称的自然断点法吗，怎么又来了个&lt;code&gt;NaturalBreaks&lt;/code&gt;？其实我在翻看&lt;code&gt;mapclassify&lt;/code&gt;的官方文档看到这里时，也很疑惑，于是我仔细研究了&lt;code&gt;NaturalBreaks&lt;/code&gt;对应的源代码，追根溯源，WHAT?，竟然是&lt;code&gt;k-mean&lt;/code&gt;算法，而且直接调用的&lt;code&gt;scikit-learn&lt;/code&gt;的&lt;code&gt;KMEANS&lt;/code&gt;。。。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015038239-531320710.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　不过也可以理解，毕竟&lt;code&gt;k-means&lt;/code&gt;就是在找数据中组内相似度尽可能高且组间差异尽量大的簇，关于&lt;code&gt;k-means&lt;/code&gt;我想我就不需要赘述了，毕竟是最基础的数据挖掘算法之一，而&lt;code&gt;scikit-learn&lt;/code&gt;里默认的&lt;code&gt;KMEANS&lt;/code&gt;使用的&lt;code&gt;k-means++&lt;/code&gt;初始方式，只是在原始&lt;code&gt;k-means&lt;/code&gt;基础上，修改了后续初始点的概率密度，使得&lt;code&gt;k-means&lt;/code&gt;算法更加鲁棒稳定，下面直接来看&lt;code&gt;NaturalBreaks&lt;/code&gt;的数据分层结果：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015023169-2083136038.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图12&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　和&lt;code&gt;FisherJenks&lt;/code&gt;的结果竟然一样，但如果你多运行几次会发现这个结果不是完全固定的，由于&lt;code&gt;k-means&lt;/code&gt;随机初始迭代起点，因此不同次运行的结果可能会有轻微差别（图13），在数据量很大时，基于快速聚类法的&lt;code&gt;NaturalBreaks&lt;/code&gt;是较为理想的数据分层选择：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015041660-609558970.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图13&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　配合&lt;code&gt;geopandas&lt;/code&gt;绘图只需要把&lt;code&gt;scheme&lt;/code&gt;参数修改为&lt;code&gt;NaturalBreaks&lt;/code&gt;即可，因为跟&lt;code&gt;FisherJenks&lt;/code&gt;类似，这里就不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;jenkscaspall&quot;&gt;2.1.5 JenksCaspall&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;mapclassify&lt;/code&gt;中的&lt;code&gt;JenksCaspall&lt;/code&gt;本质上为&lt;code&gt;k-medians&lt;/code&gt;聚类，其首先根据分层层数&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;在数据中找到&lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;个分位数点，将原始数据等分为数量尽可能相同的&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;份并以这&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;份数据的中位数作为各自的初始点，接着基于&lt;code&gt;k-medians&lt;/code&gt;的思想，迭代计算为每个样本点找到与其距离更近的中位数点，并以此重新划分分层以及重新计算各分层中位数点，直至每个数据对应的分层标签不再变化，再将每个分层中数据的最大值作为间断点，下面我们从&lt;code&gt;mapclassify&lt;/code&gt;源代码中抽出该部分代码，对其迭代过程可视化，具体的代码较多，请在文章开头的&lt;code&gt;Github&lt;/code&gt;仓库中对应本文路径下查看：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015046198-1538994121.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图14&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　其中颜色区分对应迭代轮次的数据分层归属，虚线代表对应迭代轮次的间断点，仔细可以看出在迭代过程中数据分层的变化情况。&lt;/p&gt;
&lt;p&gt;　　用&lt;code&gt;JenksCaspall&lt;/code&gt;数据分层出来的结果，无论数据分布如何，每个分层内部的数据个数都较为均匀，下面我们用&lt;code&gt;JenksCaspall&lt;/code&gt;来划分省份疫情严重情况：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015052038-2044406604.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图15&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　可以看到被分到最严重级别的不再只有湖北省，当你希望数据分层个数较为均匀时，&lt;code&gt;JenksCaspall&lt;/code&gt;是个不错的选择。&lt;/p&gt;
&lt;h3 id=&quot;headtailbreaks&quot;&gt;2.1.6 HeadTailBreaks&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;HeadTailBreaks&lt;/code&gt;是一种较为崭新的数据分层方法，出自&lt;em&gt;Head/Tail Breaks: A New Classification Scheme for Data with a Heavy-Tailed Distribution&lt;/em&gt;（&lt;a href=&quot;https://www.tandfonline.com/doi/abs/10.1080/00330124.2012.700499&quot; class=&quot;uri&quot;&gt;https://www.tandfonline.com/doi/abs/10.1080/00330124.2012.700499&lt;/a&gt;），专门用于对具有重尾特点的数据进行分层，所谓重尾即在整个数据中，较小的值数量往往较多，而最大的位于头部的值数量很少，其数据分布呈现出“尾重头轻”的特点：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015100358-958508288.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图16&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　这种典型如人口密度分布数据，数值较低的点往往数量众多，聚集在尾部，形成重尾，&lt;code&gt;HeadTailBreaks&lt;/code&gt;的优点是可以尽量在地区分布图中真实反映原始数据的分布特点，如图17（&lt;a href=&quot;https://sites.google.com/site/thepowerofcartography/head-tail-breaks&quot; class=&quot;uri&quot;&gt;https://sites.google.com/site/thepowerofcartography/head-tail-breaks&lt;/a&gt;），左边是&lt;code&gt;FisherJenks&lt;/code&gt;，右边是&lt;code&gt;HeadTailBreaks&lt;/code&gt;，可以看出，右图相对于左图更好地体现了原始数据的重尾特点，最浅色的图斑数量明显多于次浅色的图斑：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015106363-1687908950.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图17&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　在&lt;code&gt;geopandas&lt;/code&gt;中使用时传入&lt;code&gt;scheme='HeadTailBreaks'&lt;/code&gt;即可（由于新冠肺炎各省份确诊数量数据尾部和头部最大值之间没有较为连续的中间值过渡，不太适合用此方法故不作演示）。&lt;/p&gt;
&lt;h3 id=&quot;quantiles&quot;&gt;2.1.7 Quantiles&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;Quantiles&lt;/code&gt;即分位数，原理很简单，根据分位数点对原数据进行等分：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015110189-1285467204.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图18&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　利用&lt;code&gt;Quantiles&lt;/code&gt;对确诊数量分组可视化：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015116923-507690064.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图19&lt;/span&gt;&lt;/center&gt;
&lt;h3 id=&quot;percentiles&quot;&gt;2.1.8 Percentiles&lt;/h3&gt;
&lt;p&gt;　　同样是使用分位数对数据进行分层，&lt;code&gt;Percentiles&lt;/code&gt;提供了参数&lt;code&gt;pct&lt;/code&gt;以允许用户以百分位数的形式传入自定义分隔点，譬如我们将&lt;code&gt;[1, 50, 99, 100]&lt;/code&gt;作为&lt;code&gt;pct&lt;/code&gt;的传入值，则分组结果如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015123530-1687884006.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图20&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　每个传入的百分位点其左边到上一个分隔点为止，包括其本身，将被分到同一组，对应的图像如图21，在&lt;code&gt;geopandas&lt;/code&gt;中使用时除了设置&lt;code&gt;scheme='Percentiles'&lt;/code&gt;之外，还要在另一个字典型参数&lt;code&gt;classification_kwds&lt;/code&gt;中传入&lt;code&gt;{'pct': 百分位数列表}&lt;/code&gt;：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015128288-672011178.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图21&lt;/span&gt;&lt;/center&gt;
&lt;h3 id=&quot;stdmean&quot;&gt;2.1.9 StdMean&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;StdMean&lt;/code&gt;的思想类似前面的箱线图，不同的是箱线图属于非参数方法，而&lt;code&gt;StdMean&lt;/code&gt;建立在正态分布为基础的经验法则之上，即对于正态分布而言，&lt;strong&gt;68%的数据将分布在距离均值1个标准差之内，95%的数据在2个标准差之内，99.7%的数据在3个标准差之内&lt;/strong&gt;，即对原始数据标准化之后，根据距离样本均值的不同标准差范围来划分数据，&lt;code&gt;mapclassify&lt;/code&gt;中的&lt;code&gt;StdMean&lt;/code&gt;默认按照&lt;code&gt;[-2, -1, 1, 2]&lt;/code&gt;来划分：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015132513-736624182.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图22&lt;/span&gt;&lt;/center&gt;
&lt;h3 id=&quot;userdefined&quot;&gt;2.1.10 UserDefined&lt;/h3&gt;
&lt;p&gt;　　关于数据分层最后要介绍的是自定义分层，即按照用户输入的分隔点来自由划分数据集，譬如我们按照新浪新闻疫情地图的划分方式：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015136754-277644150.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图23&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　结合&lt;code&gt;geopandas&lt;/code&gt;使用时除了设置&lt;code&gt;scheme='UserDefined'&lt;/code&gt;以外，还要设置&lt;code&gt;classification_kwds&lt;/code&gt;中的&lt;code&gt;bins=分隔点列表&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;fig, ax = plt.subplots(figsize=(10, 10))

ax = data_with_geometry.to_crs(albers_proj).plot(ax=ax,
                                                 column='province_confirmedCount',
                                                 cmap='Reds',
                                                 missing_kwds={
                                                     &quot;color&quot;: &quot;lightgrey&quot;,
                                                     &quot;edgecolor&quot;: &quot;black&quot;,
                                                     &quot;hatch&quot;: &quot;////&quot;,
                                                     &quot;label&quot;: &quot;缺失值&quot;
                                                 },
                                                 legend=True,
                                                 scheme='UserDefined',
                                                 classification_kwds={
                                                     'bins': [9, 99, 499, 999, 9999]
                                                 },
                                                 legend_kwds={
                                                     'loc': 'lower left',
                                                     'title': '确诊数量分级',
                                                     'shadow': True
                                                 })

ax = nine_lines.geometry.to_crs(albers_proj).plot(ax=ax,
                                                  edgecolor='grey',
                                                  linewidth=3,
                                                  alpha=0.4)

ax.axis('off')
plt.suptitle('新型冠状肺炎累计确诊数量地区分布', fontsize=24) # 添加最高级别标题
plt.tight_layout(pad=4.5) # 调整不同标题之间间距
ax.text(-2800000, 1300000, '* 原始数据来源：丁香园，\n其中台湾及香港数据缺失') # 添加数据说明

fig.savefig('图24.png', dpi=300)&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015142043-704330219.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图24&lt;/span&gt;&lt;/center&gt;
&lt;h2 id=&quot;色彩方案的选择&quot;&gt;2.2 色彩方案的选择&lt;/h2&gt;
&lt;p&gt;　　前面已经详细介绍了数据分层常用的各种方法及使用场景，“分层”的部分做完之后，就到了设色的部分，其实色彩搭配是比较主观的事情，但想要自己创造出美观合理的配色方案并不是容易的事情，下面我们来介绍两种选择配色方案的方法。&lt;/p&gt;
&lt;h3 id=&quot;基于palettable的配色&quot;&gt;2.2.1 基于palettable的配色&lt;/h3&gt;
&lt;p&gt;　　下面我要给大家介绍的&lt;code&gt;Python&lt;/code&gt;第三方库&lt;code&gt;palettable&lt;/code&gt;在我之前关于词云图的一篇文章中介绍&lt;code&gt;stylecloud&lt;/code&gt;时介绍过，是专门帮助我们为可视化作品配色的。&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;palettable&lt;/code&gt;不依赖其他三方库，纯&lt;code&gt;Python&lt;/code&gt;实现，其强大之处在于内置了数量惊人的经典配色方案，囊括了&lt;em&gt;CartoColors&lt;/em&gt;、&lt;em&gt;cmocean&lt;/em&gt;、&lt;em&gt;Colorbrewer2&lt;/em&gt;、&lt;em&gt;Cubehelix&lt;/em&gt;、&lt;em&gt;Light &amp;amp; Bartlein&lt;/em&gt;、&lt;em&gt;matplotlib&lt;/em&gt;、&lt;em&gt;MyCarta&lt;/em&gt;、&lt;em&gt;Scientific&lt;/em&gt;、&lt;em&gt;Tableau&lt;/em&gt;以及&lt;em&gt;The Wes Anderson Palettes blog&lt;/em&gt;中的大量经典配色方案：&lt;/p&gt;
&lt;p&gt;　　使用起来非常简单，譬如如果我们想要使用&lt;code&gt;palettable.cmocean.sequential&lt;/code&gt;中的色彩，其中&lt;code&gt;cmocean&lt;/code&gt;表示色彩来源，&lt;code&gt;sequential&lt;/code&gt;表示连续型色彩，就可以先在对应的&lt;a href=&quot;https://jiffyclub.github.io/palettable/cmocean/sequential/&quot;&gt;示例网页&lt;/a&gt;下查看所有方案：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015146588-1147561697.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图25&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　比如我对其中的&lt;code&gt;Dense&lt;/code&gt;方案很中意：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015149732-1822314769.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图26&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　就可以按照如下方式，先从&lt;code&gt;palettable&lt;/code&gt;中导入对应颜色，譬如我们导入&lt;code&gt;Dense_20&lt;/code&gt;，20表示其自带的离散色彩数量，并查看其自带的离散色彩RGB值、离散色盘以及连续色盘示例：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from palettable.cmocean.sequential import Dense_20
from pprint import pprint

print('对应离散颜色：')
pprint(Dense_20.colors)
print('离散：')
Dense_20.show_discrete_image()
print('连续:')
Dense_20.show_continuous_image()&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015153958-1998393516.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图27&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　使用&lt;code&gt;.mpl_colormap&lt;/code&gt;将其转换为&lt;code&gt;matplotlib&lt;/code&gt;可接受的cmap数据结构，作为&lt;code&gt;cmap&lt;/code&gt;参数值传入绘图部分即可：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015159678-162974612.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图28&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　如果想要翻转映射方向，换成&lt;code&gt;Dense_20_r&lt;/code&gt;再重复上述操作即可：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015204618-228405999.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图29&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　更多&lt;code&gt;palettable&lt;/code&gt;自带色彩方案，可以在https://jiffyclub.github.io/palettable/ 下查看探索。&lt;/p&gt;
&lt;h3 id=&quot;基于图片主色的配色&quot;&gt;2.2.2 基于图片主色的配色&lt;/h3&gt;
&lt;p&gt;　　我们在生活中偶然会看到配色方案让人眼前一亮的海报或画作，这时如果你想将这些作品中的主要颜色也应用到自己的可视化作品上，可以参考我下面的做法，这里以我很喜欢的贾樟柯导演的《一直游到海水变蓝》中文版海报为例：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015210238-2059611246.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图30&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　思路是抽取所有像素点的RGB三通道值，分别作为三个特征，输入&lt;code&gt;k-means&lt;/code&gt;中进行聚类，将聚类数量设置为你想要提取出的主色数量：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.cluster import KMeans

# 构建特征
rgb = pd.DataFrame([sea[x][y] for x in range(sea.shape[0]) for y in range(sea.shape[1])],
             columns=['r', 'g', 'b'])

# k-means聚类，其中n_clusters表示聚类数量，n_jobs=-1表示开启所有核心并行运算
model = KMeans(n_clusters=5, n_jobs=-1)
model.fit(rgb) # 训练模型

# 提取聚类簇重心，即我们需要的主色，绘制调色板
plt.bar([i for i in range(model.cluster_centers_.__len__())], 
        height=[1 for i in range(model.cluster_centers_.__len__())],
        color=[tuple(c) for c in (model.cluster_centers_ / 255.)],
        width=1)
plt.axis('off')&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015214538-174285938.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图31&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　再来个例子，提取《一直游到海水变蓝》海外版海报主色：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015219098-66164482.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图32&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　对应提取到的5种主色如图33：&lt;br/&gt;　　&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202003/1344061-20200309015222710-1762089105.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图33&lt;/span&gt;&lt;/center&gt;
&lt;br/&gt;　　类似的，你可以试着提取你喜爱的平面作品的主色。
&lt;p&gt;　　以上就是本文的全部内容，如有笔误望指出。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Mar 2020 00:01:00 +0000</pubDate>
<dc:creator>费弗里</dc:creator>
<og:description>本文对应代码和数据已上传至我的 仓库 &amp;quot;https://github.com/CNFeffery/DataScienceStudyNotes&amp;quot; 1 简介 通过前面的文章，我们已经对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feffery/p/12381322.html</dc:identifier>
</item>
<item>
<title>聊聊.netcore采坑那一些事之系统时间and文件路径 - 程序员修炼之旅</title>
<link>http://www.cnblogs.com/xiaoXuZhi/p/netcoredatetime.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoXuZhi/p/netcoredatetime.html</guid>
<description>&lt;p&gt;.netcore实际开发过程中，先总结两个坑，这两个坑都是关于Linux（CentOS）和windows下的兼容性问题。Linux（CentOS）环境下，获取系统时间，实际时间少了8个小时；文件路径​被识别为了文件名。下面就简单分享一下解决方式，其实只要你一看，发现很简单的，之所以分享出来，当你才开始用户.netcore时，可以有一个提示作用，嘿嘿！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;112&quot;&gt;

&lt;h2&gt;&lt;span&gt;Hi,小伙伴大家好，最近工作比较忙，很久没有和大家分享点东西了。这个周末都加了两天班。公司的新项目都是采用.netcore来开发，在开发过程中，也踩到了一些坑，在此先总结两个坑，这两个坑都是关于Linux（CentOS）和windows下的兼容性问题。我们最开始的开发环境接口调用一直是部署在windows环境运行一切正常，但是部署到Linux（CentOS）环境下，就出现了这两个问题，其实问题也简单：获取系统时间，实际时间少了8个小时；文件路径​被识别为了文件名。下面就简单分享一下解决方式，其实只要你一看，发现很简单的，之所以分享出来，当你才开始用户.netcore时，可以有一个提示作用，嘿嘿！&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;一、&lt;strong&gt;DateTime.Now获取系统时间少了8个小时&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;.net core项目，部署到Linux&lt;span&gt;（&lt;/span&gt;CentOS）上的时候，发现DateTime.Now获取的时间与Windows不一致，获取到系统时间比系统的时间实际少了8个小时，发现这一个问题，大家第一时间想到的是时区差异。网上搜了一下，发现还有不少的小伙伴遇到了同样的问题，有给出了对应的解决方式，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体原因就是：&lt;/span&gt;Linux和Windows两者所采用的时区不同，两者的时区分别为：Linux：IANA&lt;span&gt;，&lt;/span&gt;Windows:Windows time zone IDs。这就是最终元凶啦！&lt;/p&gt;
&lt;p&gt;找到原因后，那么该如何解决呢？方式很简单，就是两者采用同一个时区不就完事了嘛，最终统一采用IANA，在实现上可以借助第三方库：NodaTime。具体实现代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 /// &amp;lt;summary&amp;gt;

        /// 获取系统当前时间

        /// &amp;lt;/summary&amp;gt;

        /// &amp;lt;returns&amp;gt;系统当前时间&amp;lt;/returns&amp;gt;

        public static DateTime GetSysDateTimeNow()

        {

            Instant now = SystemClock.Instance.GetCurrentInstant();

            var shanghaiZone = DateTimeZoneProviders.Tzdb[&quot;Asia/Shanghai&quot;];

            return now.InZone(shanghaiZone).ToDateTimeUnspecified();

      }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;是不是&lt;/span&gt;so easy？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实我们使用时间的时候，会有很多种方式，也会对时间做很多格式转换，比如：&lt;/span&gt;yyyy-MM-dd HH:mm:ss格式化时间，时间和时间戳的相互转换等等。为了统一规范操作，在实际项目中，我们对时间的操作根据实际需要做了一个统一封装，当然了在很多人看来是没有多大技术含量的，也是哦，其目的是为了实现统一控制，方便管理，提高代码的复用性。现在我也把代码贴出，如果有需要的，你可以参考一下，同时我也生成了一个包，放到Nuget上，包名为（XYH.Tools.DateTimeTools），如果有需要的，可以挡下来使用。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;我已经将源码上传到&lt;/span&gt;GitHub上，有兴趣的可以档下来&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;源码地址：&lt;/span&gt;https://github.com/xuyuanhong0902/XYH.Tools.git&lt;/p&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/* ==============================================================================
 * 功能描述：所有时间的相关操作集合  
 * 创 建 者：程序修炼之旅 交流微信号：15908150902
 * 创建日期： 2020-03-08
 * CLR Version :1.0
 * ==============================================================================*/

using NodaTime;
using System;

/// &amp;lt;summary&amp;gt;
/// 公用帮助类
/// &amp;lt;/summary&amp;gt;
namespace XYH.Tools.DateTimeTools
{
    /// &amp;lt;summary&amp;gt;
    /// 时间相关的操作类
    /// &amp;lt;/summary&amp;gt;
    public static class DateTimeTools
    {
        #region 获取系统当前时间的几个方法（返回时间+格式化后的时间字符串）

        /// &amp;lt;summary&amp;gt;
        /// 获取系统当前时间
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;系统当前时间&amp;lt;/returns&amp;gt;
        public static DateTime GetSysDateTimeNow()
        {
            Instant now = SystemClock.Instance.GetCurrentInstant();
            var shanghaiZone = DateTimeZoneProviders.Tzdb[&quot;Asia/Shanghai&quot;];
            return now.InZone(shanghaiZone).ToDateTimeUnspecified();
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取系统当前时间格式化字符串 24小时制 被格式化为 (yyyy-MM-dd HH:mm:ss.fff)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;系统当前格式化的时间字符串(yyyy-MM-dd HH:mm:ss.fff)&amp;lt;/returns&amp;gt;
        public static string GetSysDateTimeNowStringYMD24HMSF()
        {
            return GetSysDateTimeNow().ToStringYMD24HMSF();
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取系统当前时间格式化字符串 12小时制 被格式化为 (yyyy-MM-dd hh:mm:ss.fff)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;系统当前格式化的时间字符串(yyyy-MM-dd hh:mm:ss.fff)&amp;lt;/returns&amp;gt;
        public static string GetSysDateTimeNowStringYMD12HMSF(this DateTime time)
        {
            return GetSysDateTimeNow().ToStringYMD12HMSF();
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取系统当前时间格式化字符串 24小时制 被格式化为 (yyyy-MM-dd HH:mm:ss)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;系统当前格式化的时间字符串(yyyy-MM-dd HH:mm:ss)&amp;lt;/returns&amp;gt;
        public static string GetSysDateTimeNowStringYMD24HMS(this DateTime time)
        {
            return GetSysDateTimeNow().ToStringYMD24HMS();
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取系统当前时间格式化字符串 12小时制 被格式化为 (yyyy-MM-dd hh:mm:ss)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;系统当前格式化的时间字符串(yyyy-MM-dd hh:mm:ss)&amp;lt;/returns&amp;gt;
        public static string GetSysDateTimeNowStringYMD12HMS(this DateTime time)
        {
            return GetSysDateTimeNow().ToStringYMD12HMS();
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取系统当前时间格式化字符串  被格式化为 (yyyy-MM-dd)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;系统当前格式化的时间字符串(yyyy-MM-dd)&amp;lt;/returns&amp;gt;
        public static string GetSysDateTimeNowStringYMD(this DateTime time)
        {
            return GetSysDateTimeNow().ToStringYMD();
        }

        #endregion

        #region DateTime 扩展几个 格式方法

        /// &amp;lt;summary&amp;gt;
        /// 时间 格式化 24小时制 被格式化为  (yyyy-MM-dd HH:mm:ss.fff)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;time&quot;&amp;gt;被格式的时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;格式化后的时间字符串(yyyy-MM-dd HH:mm:ss.fff)&amp;lt;/returns&amp;gt;
        public static string ToStringYMD24HMSF(this DateTime time)
        {
            return time.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;);
        }

        /// &amp;lt;summary&amp;gt;
        /// 时间 格式化 12小时制 被格式化为  (yyyy-MM-dd hh:mm:ss.fff)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;time&quot;&amp;gt;被格式化时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;格式化后的时间字符串(yyyy-MM-dd hh:mm:ss.fff)&amp;lt;/returns&amp;gt;
        public static string ToStringYMD12HMSF(this DateTime time)
        {
            return time.ToString(&quot;yyyy-MM-dd hh:mm:ss.fff&quot;);
        }

        /// &amp;lt;summary&amp;gt;
        /// 时间 格式化 24小时制 被格式化为  (yyyy-MM-dd HH:mm:ss)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;time&quot;&amp;gt;被格式化时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;格式化后的时间字符串(yyyy-MM-dd HH:mm:ss)&amp;lt;/returns&amp;gt;
        public static string ToStringYMD24HMS(this DateTime time)
        {
            return time.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        }

        /// &amp;lt;summary&amp;gt;
        /// 时间 格式化 12小时制 被格式化为  (yyyy-MM-dd hh:mm:ss)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;time&quot;&amp;gt;被格式化时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;格式化后的时间字符串(yyyy-MM-dd hh:mm:ss)&amp;lt;/returns&amp;gt;
        public static string ToStringYMD12HMS(this DateTime time)
        {
            return time.ToString(&quot;yyyy-MM-dd hh:mm:ss&quot;);
        }

        /// &amp;lt;summary&amp;gt;
        /// 时间 格式化  被格式化为  (yyyy-MM-dd)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;time&quot;&amp;gt;被格式化时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;格式化后的时间字符串(yyyy-MM-dd)&amp;lt;/returns&amp;gt;
        public static string ToStringYMD(this DateTime time)
        {
            return time.ToString(&quot;yyyy-MM-dd&quot;);
        }

        #endregion

        #region 获取时间戳

        /// &amp;lt;summary&amp;gt;
        /// 获取时间戳(秒)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;秒时间戳&amp;lt;/returns&amp;gt;
        public static long GetSecondTimestamp()
        {
            // 以1970-1-1 为时间开始 同系统当前时间的秒差值即为秒时间戳
            TimeSpan ts = GetSysDateTimeNow() - new DateTime(1970, 1, 1, 0, 0, 0, 0);
            return Convert.ToInt64(ts.TotalSeconds);
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取时间戳（毫秒）
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;毫秒时间戳&amp;lt;/returns&amp;gt;
        public static long GetMilliSecondTimestamp()
        {
            // 以1970-1-1 为时间开始 同系统当前时间的毫秒差值即为毫秒时间戳
            TimeSpan ts = GetSysDateTimeNow() - new DateTime(1970, 1, 1, 0, 0, 0, 0);
            return Convert.ToInt64(ts.TotalMilliseconds);
        }

        #endregion

        #region 将一个时间戳转换为一个时间

        /// &amp;lt;summary&amp;gt;
        /// 将一个秒时间戳转换为时间格式(秒)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;secondTimestamp&quot;&amp;gt;秒时间戳&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;转换后的时间&amp;lt;/returns&amp;gt;
        public static DateTime? SecondStampToDateTime(long secondTimestamp)
        {
            //  做一个简单的判断
            if (secondTimestamp &amp;lt;= 0)
            {
                return null;
            }

            // 以1970-1-1 为时间开始，通过计算与之的时间差，来计算其对应的时间
            DateTime dateTime = new System.DateTime(1970, 1, 1, 0, 0, 0, 0);
            dateTime = dateTime.AddSeconds(secondTimestamp).ToLocalTime();
            return dateTime;
        }

        /// &amp;lt;summary&amp;gt;
        /// 将一个字符串秒时间戳转换为时间格式(秒)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;secondTimestampStr&quot;&amp;gt;字符串秒时间戳&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;转换后的时间&amp;lt;/returns&amp;gt;
        public static DateTime? SecondStampToDateTime(string secondTimestampStr)
        {
            // 如果为空，那么直接返回null
            if (string.IsNullOrEmpty(secondTimestampStr))
            {
                return null;
            }

            // 首先将字符串时间戳转换为数字
            long secondTimestamp = 0;
            long.TryParse(secondTimestampStr, out secondTimestamp);

            // 调用
            return SecondStampToDateTime(secondTimestamp);
        }

        /// &amp;lt;summary&amp;gt;
        /// 将一个字符串毫秒时间戳转换为时间格式(毫秒)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;secondTimestampStr&quot;&amp;gt;字符串毫秒时间戳&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;转换后的时间&amp;lt;/returns&amp;gt;
        public static DateTime? MilliSecondStampToDateTime(long secondTimestamp)
        {
            //  做一个简单的判断
            if (secondTimestamp &amp;lt;= 0)
            {
                return null;
            }

            // 以1970-1-1 为时间开始，通过计算与之的时间差，来计算其对应的时间
            DateTime dateTime = new System.DateTime(1970, 1, 1, 0, 0, 0, 0);
            dateTime = dateTime.AddMilliseconds(secondTimestamp).ToLocalTime();

            return dateTime;
        }

        /// &amp;lt;summary&amp;gt;
        /// 将一个毫秒时间戳转换为时间格式(毫秒)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;milliSecondStampStr&quot;&amp;gt;毫秒时间戳&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;转换后的时间&amp;lt;/returns&amp;gt;
        public static DateTime? MilliSecondStampToDateTime(string milliSecondStampStr)
        {
            // 如果为空，那么直接返回null
            if (string.IsNullOrEmpty(milliSecondStampStr))
            {
                return null;
            }

            // 首先将字符串时间戳转换为数字
            long milliSecondStamp = 0;
            long.TryParse(milliSecondStampStr, out milliSecondStamp);

            // 调用
            return MilliSecondStampToDateTime(milliSecondStamp);
        }

        #endregion
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;二、&lt;strong&gt;文件路径被识别为了文件名&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;哈哈，最近还遇到一个有趣的事情，就是在&lt;/span&gt;Windows上，文件路径的创建，都是正确的，但是部署到CentOS,所创建的文件，所有路径都变成了文件名称，所有文件都在根目录下了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网上找了一下原因，就是文件路径左斜杠和右斜杠的问题。在&lt;/span&gt;Windows上无论是左斜杠还是右斜杠都没有问题，但是在linux中只支持右斜杠，将代码中所用到的路径操作，都统一修改为右斜杠，问题就解决了。文件路径1/文件路径2/文件名&lt;/p&gt;
&lt;h2&gt;三、&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;回头来看这两个问题，都是系统的兼容性问题，在仔细想一下，也是一个习惯性问题，尤其是文件路径这问题，我们要习惯的用右斜杠。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们以后在写&lt;/span&gt;.net程序的时候，无论是否会采用.netcore实现linux系统部署，我们都也该想到不同系统的兼容性问题，在实现上都采用一个通用的方式来实现，那么以后在做项目升级，系统迁移的时候，就会少一些麻烦。嘿嘿，今天就先到这，后续我在分享一下其它.netcore实战所踩的坑。谢谢您的阅读。&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;Hi,小伙伴大家好，最近工作比较忙，很久没有和大家分享点东西了。这个周末都加了两天班。公司的新项目都是采用.netcore来开发，在开发过程中，也踩到了一些坑，在此先总结两个坑，这两个坑都是关于Linux（CentOS）和windows下的兼容性问题。我们最开始的开发环境接口调用一直是部署在windows环境运行一切正常，但是部署到Linux（CentOS）环境下，就出现了这两个问题，其实问题也简单：获取系统时间，实际时间少了8个小时；文件路径​被识别为了文件名。下面就简单分享一下解决方式，其实只要你一看，发现很简单的，之所以分享出来，当你才开始用户.netcore时，可以有一个提示作用，嘿嘿！&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 08 Mar 2020 23:26:00 +0000</pubDate>
<dc:creator>程序员修炼之旅</dc:creator>
<og:description>.netcore实际开发过程中，先总结两个坑，这两个坑都是关于Linux（CentOS）和windows下的兼容性问题。Linux（CentOS）环境下，获取系统时间，实际时间少了8个小时；文件路径​</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoXuZhi/p/netcoredatetime.html</dc:identifier>
</item>
<item>
<title>SSM动态切换数据源 - Howlet</title>
<link>http://www.cnblogs.com/Howlet/p/12446603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Howlet/p/12446603.html</guid>
<description>&lt;hr/&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有需求就要想办法解决，最近参与的项目其涉及的三个数据表分别在三台不同的服务器上，这就有点突兀了，第一次遇到这种情况，可这难不倒笔者，资料一查，代码一打，回头看看源码，万事大吉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;预备知识&quot;&gt;1. 预备知识&lt;/h2&gt;
&lt;p&gt;这里默认大家都会SSM框架了，使用时我们要往sqlSessionFactory里注入数据源。那么猜测：1、可以往sqlSessionFactory里注入多数据源来实现切换；2、将多个数据源封装成一个&lt;code&gt;总源&lt;/code&gt;，再把这个&lt;code&gt;总源&lt;/code&gt;注入到sqlSessionFactory里实现切换。答案是使用后者，即封装成&lt;code&gt;总源&lt;/code&gt;的形式。Spring提供了动态切换数据源的功能，那么我们来看看其实现原理&lt;/p&gt;

&lt;h2 id=&quot;实现原理&quot;&gt;2. 实现原理&lt;/h2&gt;
&lt;p&gt;笔者是根据源码讲解的，这些步骤讲完会贴出源码内容&lt;/p&gt;

&lt;h3 id=&quot;一&quot;&gt;一、&lt;/h3&gt;
&lt;p&gt;Spring提供了AbstractRoutingDataSource抽象类，其继承了AbstractDataSource。而AbstractDataSource又实现了DataSource。因此我们可以将AbstractRoutingDataSource的实现类注入到sqlSessionFactory中来实现切换数据源&lt;/p&gt;

&lt;h3 id=&quot;二&quot;&gt;二、&lt;/h3&gt;
&lt;p&gt;刚才我们将多个数据源封装成&lt;code&gt;总源&lt;/code&gt;的想法在AbstractRoutingDataSource中有体现，其内部用一个Map集合封装多个数据源，即 &lt;code&gt;private Map&amp;lt;Object, DataSource&amp;gt; resolvedDataSources;&lt;/code&gt; ，那么要使用时从该Map集合中获取即可&lt;/p&gt;

&lt;h3 id=&quot;三&quot;&gt;三、&lt;/h3&gt;
&lt;p&gt;AbstractRoutingDataSource中有个determineTargetDataSource()方法，其作用是决定使用哪个数据源。我们通过determineTargetDataSource()方法从Map集合中获取数据源，那么必须有个key值指定才行。所以determineTargetDataSource()方法内部通过调用determineCurrentLookupKey()方法来获取key值，Spring将determineCurrentLookupKey()方法抽象出来给用户实现，从而让用户决定使用哪个数据源&lt;/p&gt;

&lt;h3 id=&quot;四&quot;&gt;四、&lt;/h3&gt;
&lt;p&gt;既然知道我们需要重写determineCurrentLookupKey()方法，那么就开始把。实现时发现该方法没有参数，我们无法传参来决定返回的key值，又不能改动方法（因为是重写），所以方法内部调用我们自定义类的静态方法即可解决问题&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DynamicDataSourceHolder.getDataSourceKey();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;五&quot;&gt;五、&lt;/h3&gt;
&lt;p&gt;自定义类，作用是让我们传入key值来决定使用哪个key&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DynamicDataSourceHolder {

    // ThreadLocal没什么好说的，绑定当前线程
    private static final ThreadLocal&amp;lt;String&amp;gt; dataSourceKey = new ThreadLocal&amp;lt;String&amp;gt;();

    public static String getDataSourceKey(){
        return dataSourceKey.get();
    }

    public static void setDataSourceKey(String key){
        dataSourceKey.set(key);
    }

    public static void clearDataSourceKey(){
        dataSourceKey.remove();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;六&quot;&gt;六、&lt;/h3&gt;
&lt;p&gt;AbstractRoutingDataSource抽象类源码（&lt;strong&gt;不喜可跳&lt;/strong&gt;）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean {
    @Nullable
    private Map&amp;lt;Object, Object&amp;gt; targetDataSources;
    @Nullable
    private Object defaultTargetDataSource;
    private boolean lenientFallback = true;
    private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();
    @Nullable
    private Map&amp;lt;Object, DataSource&amp;gt; resolvedDataSources;
    @Nullable
    private DataSource resolvedDefaultDataSource;

    public AbstractRoutingDataSource() {
    }

    public void setTargetDataSources(Map&amp;lt;Object, Object&amp;gt; targetDataSources) {
        this.targetDataSources = targetDataSources;
    }

    public void setDefaultTargetDataSource(Object defaultTargetDataSource) {
        this.defaultTargetDataSource = defaultTargetDataSource;
    }

    public void setLenientFallback(boolean lenientFallback) {
        this.lenientFallback = lenientFallback;
    }

    public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup) {
        this.dataSourceLookup = (DataSourceLookup)(dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup());
    }

    public void afterPropertiesSet() {
        if (this.targetDataSources == null) {
            throw new IllegalArgumentException(&quot;Property 'targetDataSources' is required&quot;);
        } else {
            this.resolvedDataSources = new HashMap(this.targetDataSources.size());
            this.targetDataSources.forEach((key, value) -&amp;gt; {
                Object lookupKey = this.resolveSpecifiedLookupKey(key);
                DataSource dataSource = this.resolveSpecifiedDataSource(value);
                this.resolvedDataSources.put(lookupKey, dataSource);
            });
            if (this.defaultTargetDataSource != null) {
                this.resolvedDefaultDataSource = this.resolveSpecifiedDataSource(this.defaultTargetDataSource);
            }

        }
    }

    protected Object resolveSpecifiedLookupKey(Object lookupKey) {
        return lookupKey;
    }

    protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {
        if (dataSource instanceof DataSource) {
            return (DataSource)dataSource;
        } else if (dataSource instanceof String) {
            return this.dataSourceLookup.getDataSource((String)dataSource);
        } else {
            throw new IllegalArgumentException(&quot;Illegal data source value - only [javax.sql.DataSource] and String supported: &quot; + dataSource);
        }
    }

    public Connection getConnection() throws SQLException {
        return this.determineTargetDataSource().getConnection();
    }

    public Connection getConnection(String username, String password) throws SQLException {
        return this.determineTargetDataSource().getConnection(username, password);
    }

    public &amp;lt;T&amp;gt; T unwrap(Class&amp;lt;T&amp;gt; iface) throws SQLException {
        return iface.isInstance(this) ? this : this.determineTargetDataSource().unwrap(iface);
    }

    public boolean isWrapperFor(Class&amp;lt;?&amp;gt; iface) throws SQLException {
        return iface.isInstance(this) || this.determineTargetDataSource().isWrapperFor(iface);
    }

    protected DataSource determineTargetDataSource() {
        Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;);
        Object lookupKey = this.determineCurrentLookupKey();
        DataSource dataSource = (DataSource)this.resolvedDataSources.get(lookupKey);
        if (dataSource == null &amp;amp;&amp;amp; (this.lenientFallback || lookupKey == null)) {
            dataSource = this.resolvedDefaultDataSource;
        }

        if (dataSource == null) {
            throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;);
        } else {
            return dataSource;
        }
    }

    @Nullable
    protected abstract Object determineCurrentLookupKey();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;配置&quot;&gt;3. 配置&lt;/h2&gt;

&lt;h3 id=&quot;配置db.properties&quot;&gt;3.1 配置db.properties&lt;/h3&gt;
&lt;p&gt;这里配置两个数据库，一个评论库，一个用户库&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 问题库
howl.comments.driverClassName = com.mysql.jdbc.Driver
howl.comments.url = jdbc:mysql://127.0.0.1:3306/comment
howl.comments.username = root
howl.comments.password =

# 用户库
howl.users.driverClassName = com.mysql.jdbc.Driver
howl.users.url = jdbc:mysql://127.0.0.1:3306/user
howl.users.username = root
howl.users.password =&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;配置applicationcontext.xml&quot;&gt;3.2 配置applicationContext.xml&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--  加载properties文件  --&amp;gt;
&amp;lt;context:property-placeholder location=&quot;classpath:db.properties&quot;&amp;gt;&amp;lt;/context:property-placeholder&amp;gt;


&amp;lt;!--  问题的数据源  --&amp;gt;
&amp;lt;bean id=&quot;commentsDataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
    &amp;lt;property name=&quot;driverClassName&quot; value=&quot;${howl.comments.driverClassName}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;${howl.comments.url}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;${howl.comments.username}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;${howl.comments.password}&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;


&amp;lt;!--  用户的数据源  --&amp;gt;
&amp;lt;bean id=&quot;usersDataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
    &amp;lt;property name=&quot;driverClassName&quot; value=&quot;${howl.users.driverClassName}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;${howl.users.url}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;${howl.users.username}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;${howl.users.password}&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;


&amp;lt;!--  通过setter方法，往DynamicDataSource的Map集合中注入数据  --&amp;gt;
&amp;lt;!--  具体参数，看名字可以明白  --&amp;gt;
&amp;lt;bean id=&quot;dynamicDataSource&quot; class=&quot;com.howl.util.DynamicDataSource&quot;&amp;gt;
    &amp;lt;property name=&quot;targetDataSources&quot;&amp;gt;
        &amp;lt;map key-type=&quot;java.lang.String&quot;&amp;gt;
            &amp;lt;entry key=&quot;cds&quot; value-ref=&quot;commentsDataSource&quot;/&amp;gt;
            &amp;lt;entry key=&quot;uds&quot; value-ref=&quot;usersDataSource&quot;/&amp;gt;
        &amp;lt;/map&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;defaultTargetDataSource&quot; ref=&quot;commentsDataSource&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;


&amp;lt;!--  将`总源`注入SqlSessionFactory工厂  --&amp;gt;
&amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dynamicDataSource&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为dynamicDataSource是继承AbstractRoutingDataSource，所以setter注入方法得去父类里面去找，开始笔者也是懵了一下&lt;/p&gt;

&lt;h3 id=&quot;切换数据源&quot;&gt;3.3 切换数据源&lt;/h3&gt;
&lt;p&gt;数据源是在Service层切换的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UserService&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class UserService {

    @Autowired
    private UserDao userDao;

    public User selectUserById(int id) {

        // 表明使用usersDataSource库
        DynamicDataSourceHolder.setDataSourceKey(&quot;uds&quot;);
        return userDao.selectUserById(id);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;CommentService&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class CommentService {

    @Autowired
    CommentDao commentDao;

    public List&amp;lt;Comment&amp;gt; selectCommentById(int blogId) {

        // 表明使用评论库
        DynamicDataSourceHolder.setDataSourceKey(&quot;cds&quot;);
        return commentDao.selectCommentById(blogId, -1);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;自动切换&quot;&gt;3.4 自动切换&lt;/h3&gt;
&lt;p&gt;手动切换容易忘记，我们学了AOP可以使用AOP来切换，这里使用注解实现&lt;/p&gt;

&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 开启AOP注解支持 --&amp;gt;
&amp;lt;aop:aspectj-autoproxy&amp;gt;&amp;lt;/aop:aspectj-autoproxy&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;切面类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Aspect
public class DataSourceAspect {

    @Pointcut(&quot;execution(* com.howl.service.impl.*(..))&quot;)
    private void pt1() {
    }

    @Around(&quot;pt1()&quot;)
    public Object around(ProceedingJoinPoint pjp) {

        Object rtValue = null;
        try {
            String name = pjp.getTarget().getClass().getName();
            if (name.equals(&quot;com.howl.service.UserService&quot;)) {
                DynamicDataSourceHolder.setDataSourceKey(&quot;uds&quot;);
            }
            if (name.equals(&quot;com.howl.service.CommentService&quot;)){
                DynamicDataSourceHolder.setDataSourceKey(&quot;cds&quot;);
            }
            // 调用业务层方法
            rtValue = pjp.proceed();

            System.out.println(&quot;后置通知&quot;);
        } catch (Throwable t) {
            System.out.println(&quot;异常通知&quot;);
            t.printStackTrace();
        } finally {
            System.out.println(&quot;最终通知&quot;);
        }
        return rtValue;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用环绕通知实现切入com.howl.service.impl里的所有方法，在遇到UserService、CommentService时，前置通知动态切换对应的数据源&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;以前笔者认为Service层多了impl包和接口是多余的，现在要用到AOP的时候后悔莫及，所以默认结构如此肯定有道理的&lt;/li&gt;
&lt;li&gt;出bug的时候，才知道分步测试哪里出问题了，如果TDD推动那么能快速定位报错地方，日志也很重要&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d97cd60e404f&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/d97cd60e404f&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 08 Mar 2020 23:13:00 +0000</pubDate>
<dc:creator>Howlet</dc:creator>
<og:description>有需求就要想办法解决，最近参与的项目其涉及的三个数据表分别在三台不同的服务器上，这就有点突兀了，第一次遇到这种情况，可这难不倒笔者，资料一查，代码一打，回头看看源码，万事大吉 1. 预备知识 这里默认</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Howlet/p/12446603.html</dc:identifier>
</item>
</channel>
</rss>