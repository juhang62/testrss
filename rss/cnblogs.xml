<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>线程最最基础的知识 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/11546683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/11546683.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/69152be5467f4bd6b6bb3739f82304f3_dxc_0005_00.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Java 多线程系列文章第 5 篇。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是线程&quot;&gt;什么是线程&lt;/h2&gt;
&lt;p&gt;试想一下没有线程的程序是怎么样的？百度网盘在上传文件时就无法下载文件了，得等文件上传完成后才能下载文件。这个我们现在看起来很反人性，因为我们习惯了一个程序同时可以进行运行多个功能，而这些都是线程的功劳。&lt;/p&gt;
&lt;p&gt;之前的文章 &lt;a href=&quot;http://www.baidu.com&quot;&gt;进程知多少&lt;/a&gt; 中讲到，为了实现多个程序并行执行，引入了进程概念。现在引入线程是为了让一个程序能够并发执行。&lt;/p&gt;
&lt;h2 id=&quot;线程的组成&quot;&gt;线程的组成&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线程ID&lt;/strong&gt;：线程标识符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前指令指针（PC）&lt;/strong&gt;：指向要执行的指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寄存器集合&lt;/strong&gt;：存储单元寄存器的集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆栈&lt;/strong&gt;：暂时存放数据和地址，一般用来保护断点和现场。&lt;/p&gt;
&lt;h2 id=&quot;线程与进程区别&quot;&gt;线程与进程区别&lt;/h2&gt;
&lt;p&gt;线程和进程之间的区别，我觉得可以用这个例子来看出两者的不同，进程就是一栋房子，房子住着 3 个人，线程就是住在房子里的人。进程是一个独立的个体，有自己的资源，线程是在进程里的，多个线程共享着进程的资源。&lt;/p&gt;
&lt;h2 id=&quot;线程状态&quot;&gt;线程状态&lt;/h2&gt;
&lt;p&gt;我们看到 Java 源代码里面，线程状态的枚举有如下 6 个。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum State {

 //新建状态
 NEW,

 //运行状态
 RUNNABLE,

 //阻塞状态
 BLOCKED,

 //等待状态
 WAITING,

 //等待状态（区别在于这个有等待的时间）
 TIMED_WAITING,

 //终止状态
 TERMINATED;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面给这 6 个状态一一做下解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NEW&lt;/strong&gt;：新建状态。在创建完 Thread ，还没执行 start() 之前，线程的状态一直是 NEW。可以说这个时候还没有真正的一个线程映射着，只是一个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RUNNABLE&lt;/strong&gt;：运行状态。线程对象调用 start() 之后，就进入 RUNNABLE 状态，该状态说明在 JVM 中有一个真实的线程存在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BLOCKED&lt;/strong&gt;：阻塞状态。线程在等待锁的释放，也就是等待获取 monitor 锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WAITING&lt;/strong&gt;：等待状态。线程在这个状态的时候，不会被分配 CPU，而且需要被显示地唤醒，否则会一直等待下去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIMED_WAITING&lt;/strong&gt;：超时等待状态。这个状态的线程也一样不会被分配 CPU，但是它不会无限等待下去，有时间限制，时间一到就停止等待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TERMINATED&lt;/strong&gt;：终止状态。线程执行完成结束，但不代表这个对象已经没有了，对象可能还是存在的，只是线程不存在了。&lt;/p&gt;
&lt;p&gt;线程既然有这么多个状态，那肯定就有状态机，也就是在什么情况下 A 状态会变成 B 状态。下面就来简单描述一下。&lt;/p&gt;
&lt;p&gt;结合下图，我们 new 出线程类的时候，就是 &lt;code&gt;NEW&lt;/code&gt; 状态，调用 &lt;strong&gt;start()&lt;/strong&gt; 方法，就进入了 &lt;code&gt;RUNNABLE&lt;/code&gt; 状态，这时如果触发等待，则进入了 &lt;code&gt;WAITING&lt;/code&gt; 状态，如果触发超时等待，则进入 &lt;code&gt;TIMED_WAITING&lt;/code&gt; 状态，当访问需要同步的资源时，则只有一个线程能访问，其他线程就进入 &lt;code&gt;BLOCKED&lt;/code&gt; 状态，当线程执行完后，进入 &lt;code&gt;TERMINATED&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/887bee2bae0b40a5b1fc3e4ff751ef39_dxc_0005_03.jpg&quot; alt=&quot;图片来源于网路，侵删&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实在 JVM 中，线程是有 9 个状态，如下所示，有兴趣的同学可以深入了解一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;javaClasses.hpp
enum ThreadStatus {
    NEW = 0,
    RUNNABLE = JVMTI_THREAD_STATE_ALIVE + // runnable / running
                               JVMTI_THREAD_STATE_RUNNABLE,
    SLEEPING = JVMTI_THREAD_STATE_ALIVE + // Thread.sleep()
                               JVMTI_THREAD_STATE_WAITING +
                               JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                               JVMTI_THREAD_STATE_SLEEPING,
    IN_OBJECT_WAIT = JVMTI_THREAD_STATE_ALIVE + // Object.wait()
                               JVMTI_THREAD_STATE_WAITING +
                               JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
                               JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
    IN_OBJECT_WAIT_TIMED = JVMTI_THREAD_STATE_ALIVE + // Object.wait(long)
                               JVMTI_THREAD_STATE_WAITING +
                               JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                               JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
    PARKED = JVMTI_THREAD_STATE_ALIVE + // LockSupport.park()
                               JVMTI_THREAD_STATE_WAITING +
                               JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
                               JVMTI_THREAD_STATE_PARKED,
    PARKED_TIMED = JVMTI_THREAD_STATE_ALIVE + // LockSupport.park(long)
                               JVMTI_THREAD_STATE_WAITING +
                               JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
                               JVMTI_THREAD_STATE_PARKED,
    BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE + // (re-)entering a synchronization block
                               JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
    TERMINATED = JVMTI_THREAD_STATE_TERMINATED
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;java-线程实现&quot;&gt;Java 线程实现&lt;/h2&gt;
&lt;p&gt;下面讲一讲在 Java 中如何创建一个线程。众所周知，实现 Java 线程有 2 种方式：继承 Thread 类和实现 Runnable 接口。&lt;/p&gt;
&lt;h3 id=&quot;继承-thread-类&quot;&gt;继承 Thread 类&lt;/h3&gt;
&lt;p&gt;继承 Thread 类，重写 &lt;code&gt;run()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;MyThread&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现-runnable-接口&quot;&gt;实现 Runnable 接口&lt;/h3&gt;
&lt;p&gt;实现 Runnable 接口，实现 &lt;code&gt;run()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyRunnable implements Runnable {

    public void run() {
        System.out.println(&quot;MyRunnable&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这 2 种线程的启动方式也不一样。&lt;code&gt;MyThread&lt;/code&gt; 是一个线程类，所以可以直接 &lt;code&gt;new&lt;/code&gt; 出一个对象出来，接着调用 &lt;code&gt;start()&lt;/code&gt; 方法来启动线程；而 &lt;code&gt;MyRunnable&lt;/code&gt; 只是一个普通的类，需要 &lt;code&gt;new&lt;/code&gt; 出线程基类 &lt;code&gt;Thread&lt;/code&gt; 对象，将 &lt;code&gt;MyRunnable&lt;/code&gt; 对象传进去。&lt;/p&gt;
&lt;p&gt;下面是启动线程的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadImpl {

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        Thread myRunnable = new Thread(new MyRunnable());
        System.out.println(&quot;main Thread begin&quot;);
        myThread.start();
        myRunnable.start();
        System.out.println(&quot;main Thread end&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main Thread begin
main Thread end
MyThread
MyRunnable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看这结果，不像咱们之前的串行执行依次打印，主线程不会等待子线程执行完。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敲重点&lt;/strong&gt;：不能直接调用 &lt;code&gt;run()&lt;/code&gt;，直接调用 &lt;code&gt;run()&lt;/code&gt; 不会创建线程，而是主线程直接执行 &lt;code&gt;run()&lt;/code&gt; 的内容，相当于执行普通函数。这时就是串行执行的。看下面代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadImpl {

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        Thread myRunnable = new Thread(new MyRunnable());
        System.out.println(&quot;main Thread begin&quot;);
        myThread.run();
        myRunnable.run();
        System.out.println(&quot;main Thread end&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main Thread begin
MyThread
MyRunnable
main Thread end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果看出只是串行的，但看不出没有线程，我们看下面例子来验证直接调用 &lt;code&gt;run()&lt;/code&gt; 方法没有创建新的线程，使用 &lt;strong&gt;VisualVM&lt;/strong&gt; 工具来观察线程情况。&lt;/p&gt;
&lt;p&gt;我们对代码做一下修改，加上 &lt;code&gt;Thread.sleep(1000000)&lt;/code&gt; 让它睡眠一段时间，这样方便用工具查看线程情况。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;run()&lt;/code&gt; 的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadImpl {

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName(&quot;MyThread&quot;);
        Thread myRunnable = new Thread(new MyRunnable());
        myRunnable.setName(&quot;MyRunnable&quot;);
        System.out.println(&quot;main Thread begin&quot;);
        myThread.run();
        myRunnable.run();
        System.out.println(&quot;main Thread end&quot;);
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}

class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;MyThread&quot;);
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}

class MyRunnable implements Runnable {

    public void run() {
        System.out.println(&quot;MyRunnable&quot;);
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main Thread begin
MyThread&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/68ae1f24617f4cde8bf1f3382db17e42_dxc_0005_01.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只打印出 2 句日志，观察线程时也只看到 &lt;code&gt;main&lt;/code&gt; 线程，没有看到 &lt;code&gt;MyThread&lt;/code&gt; 和 &lt;code&gt;MyRunnable&lt;/code&gt; 线程，印证了上面咱们说的：&lt;strong&gt;直接调用 &lt;code&gt;run()&lt;/code&gt; 方法，没有创建线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面我们来看看有&lt;br/&gt;调用 &lt;code&gt;start()&lt;/code&gt; 的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadImpl {

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName(&quot;MyThread&quot;);
        Thread myRunnable = new Thread(new MyRunnable());
        myRunnable.setName(&quot;MyRunnable&quot;);
        System.out.println(&quot;main Thread begin&quot;);
        myThread.start();
        myRunnable.start();
        System.out.println(&quot;main Thread end&quot;);
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main Thread begin
main Thread end
MyThread
MyRunnable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/90963a7629a946fa8a262aa9e9d94b35_dxc_0005_02.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有日志都打印出来了，并且通过 &lt;strong&gt;VisualVM&lt;/strong&gt; 工具可以看到 &lt;code&gt;MyThread&lt;/code&gt; 和 &lt;code&gt;MyRunnable&lt;/code&gt; 线程。看到了这个结果，切记创建线程要调用 &lt;code&gt;start()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;今天就先讲到这，继续关注后面的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;推荐阅读&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/NSlEeXMK22-clfDv44h60w&quot;&gt;线程最最基础的知识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/cIj_uzT6gZjROO44rNFHFQ&quot;&gt;老板叫你别阻塞了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Euc2NKvK_TsqvcT-DWpD5A&quot;&gt;吃个快餐都能学到串行、并行、并发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yWqFw_S7suYpqszuJFDsGg&quot;&gt;泡一杯茶，学一学同异步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HJIVxnzyDesYPGGyJsaFyQ&quot;&gt;进程知多少？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WiPwb7AyVlxyr1_kYXt96w&quot;&gt;设计模式看了又忘，忘了又看？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后台回复『设计模式』可以获取《一故事一设计模式》电子书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;觉得文章有用帮忙转发&amp;amp;点赞，多谢朋友们！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/c50a23a8826d45a7b66b3be24c89205e_.jpg&quot; alt=&quot;LieBrother&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Sep 2019 00:30:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>Java 多线程系列文章第 5 篇。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liebrother/p/11546683.html</dc:identifier>
</item>
<item>
<title>重学Java(一)：与《Java编程思想》的不解之缘 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11546500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11546500.html</guid>
<description>
&lt;p&gt;说起来非常惭愧，我在 2008 年的时候就接触了 Java，但一直到现在（2018 年 10 月 10 日），基础知识依然非常薄弱。用一句话自嘲就是：&lt;strong&gt;十年 IT 老兵，Java 菜鸡一枚&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;于是，我想，不如静下心来，重新读一遍那些经典的 Java 技术书，并且没读完一章就输出一篇原创技术文章。从哪一本开始呢？想了一想，还是从《Java 编程思想》开始吧！毕竟这本书赢得了全球程序员的广泛赞誉，从 Java 的基础语法到最高级特性，都能指导我们 Java 程序员轻松掌握。&lt;/p&gt;
&lt;p&gt;记得刚上大学那会，就买了一本影印版的《Java 编程思想》，但由于初学 Java，对编程极度缺乏信心，导致看这本书有一种看天书的感觉。后来，去苏州参加工作的时候把它作为最宝贵的纪念品带了过去。&lt;/p&gt;
&lt;p&gt;2014 年回洛阳的时候它送给了一位关系不错的同事，权当是分别的礼物吧。2016 年的时候，我又重新买了一本，希望自己能够夯实一下基础。但事与愿违，它被我束之高阁了——又两年过去了，我重新捧起它，总觉得有一种负罪感。&lt;/p&gt;
&lt;p&gt;读一本书，最好能从它的前言开始。那么我们就来看看 Bruce Eckel 在前言里都说了些什么吧。&lt;/p&gt;
&lt;h3 id=&quot;h01java&quot;&gt;01、Java 的核心目的是“为程序员减少复杂性”。&lt;/h3&gt;
&lt;p&gt;James Gosling 创建 Java 语言的初衷是：“减少开发健壮代码所需的时间和困难”。尽管这个目标导致 Java 的运行效率偏慢，但与用 C++ 开发相同的程序相比，Java 只需要一半甚至更少的时间。&lt;/p&gt;
&lt;p&gt;作为程序员，这是我们希望看到的。少敲代码省下来的那一部分时间，可以约个妹子去看场电影，放松一下，对吧？况且，Java 一直在更新，性能也不断地被优化。&lt;/p&gt;
&lt;p&gt;记得上大学那会，我们专业只有两个班，一个班学 Java，一个班级学 C++。结果大学毕业后，C++ 的同学几乎都转了行，有些同学反馈说因为 C++ 的指针太飘忽不定了，难学难懂难掌握（C++ 表示不服，怎么能这样莫名其妙地泼脏水呢）。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;02、并发编程确实很难。&lt;/h3&gt;
&lt;p&gt;Bruce Eckel 吐露心声说自己也曾深陷“并发”泥潭，但经过“数月的努力，还是走了出来”。所以，各位，千万不要丧失驾驭并发编程的信心啊，尽管并发编程是真的难。&lt;/p&gt;
&lt;p&gt;并发是什么呢？通常情况下，并发是指“系统能够同时并行处理很多请求”。我们来看一下并发常用的一些指标。&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;响应时间&lt;/strong&gt;（Response Time）：系统从接收请求到做出回应所花费的时间。&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;吞吐量&lt;/strong&gt;（Throughput）：单位时间内处理的请求数量。最明显的例子就是高速通道上的 ETC 和普通车道，显然 ETC 的吞吐量更大，因为不需要在进站的时候从窗口取卡，在出站的时候还卡缴费。&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;并发用户数&lt;/strong&gt;：同时承载正常使用系统功能的用户数量。&lt;/p&gt;
&lt;p&gt;如何提升系统的并发能力呢？&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;提升单机硬件配置&lt;/strong&gt;。比如说增加 CPU 核数（从 2 个到 4 个，从 4 个到 8 个），升级网卡到万兆，升级硬盘为 SSD（固态硬盘，比普通硬盘读写更快、质量更轻、能耗更低、体积更小），扩充系统内存（从 64G 到 128G）。&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;改善单机架构配置&lt;/strong&gt;。比如使用内存读写而不是每次都读写数据库。&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;增加服务器数量&lt;/strong&gt;。单机性能总是有极限的，但服务器集群数量可以很庞大。&lt;/p&gt;
&lt;p&gt;好了，本篇文章到此就要结束了。我从《Java 编程思想》的前言里读到了以上这些内容，你呢？&lt;/p&gt;
&lt;p&gt;PS：这篇文章写于 2018 年 10 月 10 日，现在读起来感觉当时写得太烂了，但很适合作为《重学Java》系列文章的第一篇（毕竟开局嘛）。&lt;/p&gt;

</description>
<pubDate>Wed, 18 Sep 2019 16:43:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>说起来非常惭愧，我在 2008 年的时候就接触了 Java，但一直到现在（2018 年 10 月 10 日），基础知识依然非常薄弱。用一句话自嘲就是：十年 IT 老兵，Java 菜鸡一枚。 于是，我想</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11546500.html</dc:identifier>
</item>
<item>
<title>Dagger2 探索记1——四大基本组件(一) - 缘溪行</title>
<link>http://www.cnblogs.com/yuanxixing/p/11525027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanxixing/p/11525027.html</guid>
<description>&lt;p&gt;       和很多自主学习的人，我接触Dagger 2 框架的原因是刚进公司的时候导师给安排的学习任务，学习方式是组内培训。&lt;/p&gt;
&lt;p&gt;       听到这个消息的我，以为是部门的人轮流给我讲课。&lt;/p&gt;
&lt;p&gt;       后来导师跟我说，组内培训的意思是，我先自己好好学这个框架，然后给组内的所有人搞个培训。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1302182/201909/1302182-20190915224130059-248225640.png&quot; alt=&quot;&quot; width=&quot;133&quot; height=&quot;133&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1302182/201909/1302182-20190915230644029-1637450558.png&quot; alt=&quot;&quot; width=&quot;161&quot; height=&quot;148&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       没办法，在网上看了很多相关博客，浪费了不少时间，终于还是学有所得，也记录一下我最近的学习进展。&lt;/p&gt;
&lt;p&gt;       就不多讲什么历史了，你能看到我这篇博客，想来历史什么的科普你都已经被塞到吐了，还是撸代码学得快。&lt;/p&gt;

&lt;p&gt;       在module的build.gradle中添加代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dependencies {
    ......
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dagger2&lt;/span&gt;
    implementation 'com.google.dagger:dagger:2.7'&lt;span&gt;
    annotationProcessor &lt;/span&gt;'com.google.dagger:dagger-compiler:2.7'
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;butterknife&lt;/span&gt;
    implementation 'com.jakewharton:butterknife:10.0.0'&lt;span&gt;
    annotationProcessor &lt;/span&gt;'com.jakewharton:butterknife-compiler:10.0.0'&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      为了后面书写代码简便，将ButterKnife一起配置了。&lt;/p&gt;
&lt;p&gt;      在Project build.gradle中添加如下代码(这段代码是配置ButterKnife使用的，不配置可能就会报TimeOut的错误)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;allprojects {
    repositories {
        google()
        maven { url &lt;/span&gt;&quot;https://oss.sonatype.org/content/repositories/snapshots&quot;&lt;span&gt; }
        jcenter()
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      到这里配置就完成了，ButterKnife可以为我们省下很多代码，因为ButterKnife和D&lt;span&gt;agger的厂家&lt;/span&gt;是一样的，很多地方也是共通的，就不多解释原理，拿来就用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;  &lt;span&gt;我们先创建一个简单的Tools类:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tools {
    @Inject
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Tools(){}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       不需要任何属性，只用@Inject标记一个空的构造方法，然后我们使用Ctrl+F9进行编译。&lt;/p&gt;
&lt;p&gt;       Dagger2 是通过标记来公式化编写代码，减轻我们重复编写代码的劳动。&lt;/p&gt;
&lt;p&gt;       这里提到个词“公式化”，其实很好理解。&lt;/p&gt;
&lt;p&gt;       比如，你要给你给你喜欢的女孩子表白，先跟你寝室兄弟们排练一百遍表白流程。到了女寝楼下，你清一清嗓子，就有人给你打好了灯光，你叫完女孩的名字，身后就有人放飞了粉红的爱心气球，你刚说完那羞羞的三个字，周围就全是大声呼喊“答应他、答应他......”&lt;/p&gt;
&lt;p&gt;       女孩十分感动，然后拒绝了你......&lt;/p&gt;
&lt;p&gt;       咳咳，讲偏了！&lt;/p&gt;
&lt;p&gt;       总之，公式化的东西就是这样，固定好的流程，你只需要打个特殊的手势，别人就知道该怎么做。为什么？因为流程都是公式化的，固定的，已经跑过千百次了，大家闭着眼睛都能敲出来。在程序里也是这样，不要重复造轮子。你只需要打个标记，就像上面提到的@Inject，剩下的繁琐的任务交给喜欢重复劳动的计算机。&lt;/p&gt;
&lt;p&gt;       那么，看到@Inject这个标记，计算机又做了什么呢？&lt;/p&gt;
&lt;p&gt;       编译过后会发现build中多了一个文件(你要问我路径在哪？后面我带你找，听我的，慢慢来！)，叫做Tools_Factory类，内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Tools_Factory &lt;span&gt;implements&lt;/span&gt; Factory&amp;lt;Tools&amp;gt;&lt;span&gt; {
  INSTANCE;

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Tools get() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tools();
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Factory&amp;lt;Tools&amp;gt;&lt;span&gt; create() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INSTANCE;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        这就是AS自动生成的代码。一个工厂类，类如其名，就是个工厂。通过create()方法进行创建，通过get()方法获得new Tools对象。&lt;/p&gt;
&lt;p&gt;        下面我就贴四大基本组件的代码了，先把框架搭起来：&lt;/p&gt;
&lt;p&gt;        首先是MainActicity：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ButterKnife.bind(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ButterKnife绑定Activity&lt;/span&gt;
&lt;span&gt;
    }

    @OnClick({R.id.turn_firstactivity})
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onViewClicked(View view) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (view.getId()){
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.turn_firstactivity:
                startActivity(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Intent(&lt;span&gt;this&lt;/span&gt;, FirstActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        就简简单单一个跳转，跳转到我们接下来要使用的FirstActivity中。&lt;/p&gt;
&lt;p&gt;        贴一下activity_main这个layout，平时我看博客最讨厌别人不把代码贴完，我当然不会犯这个错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&lt;span&gt;
    android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
    android:layout_height&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
    android:orientation&lt;/span&gt;=&quot;vertical&quot;&amp;gt;
    &amp;lt;&lt;span&gt;Button
        android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
        android:id&lt;/span&gt;=&quot;@+id/turn_firstactivity&quot;&lt;span&gt;
        android:text&lt;/span&gt;=&quot;四大基本组件&quot;/&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        接下来是FirstActivity，也就是我们第一个例子的主要Activity&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FirstActivity &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AppCompatActivity &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;    @BindView(R.id.fist_text_1)    TextView text1;
    @BindView(R.id.fist_text_2)    TextView text2;

    @Inject    Tools tool1;
    @Inject    Tools tool2;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.first);
        ButterKnife.bind(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);//绑定View和Activity&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        代码很好理解，用ButterKnife来直接绑定View和Activity，节省了很多代码，而节省的代码也是前面提到“公式化”的体现。&lt;/p&gt;
&lt;p&gt;        以及对应的layout的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&lt;span&gt;
    android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
    android:layout_height&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
    android:orientation&lt;/span&gt;=&quot;vertical&quot;&amp;gt;

    &amp;lt;&lt;span&gt;TextView
        android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
        android:id&lt;/span&gt;=&quot;@+id/fist_text_1&quot;
        /&amp;gt;

    &amp;lt;&lt;span&gt;TextView
        android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
        android:id&lt;/span&gt;=&quot;@+id/fist_text_2&quot;
        /&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         我们再新建接口FirstComponent：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FirstComponent {

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; inject(FirstActivity activity);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       这个方法名inject可以随意改写，但是为了方便后来人阅读，建议你还是按照约定俗成的规矩来写，让后来接手你代码的人少骂你两句。&lt;/p&gt;
&lt;p&gt;       到这一步，我们需要先Ctrl+F9编译一下了。因为有个文件需要Dagger2自动生成后，我们才能使用。&lt;/p&gt;
&lt;p&gt;       接下来在FirstActivity中添上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.first);
        ButterKnife.bind(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        DaggerFirstComponent.builder()
                .build()
                .inject(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        text1.setText(tool1.toString());
        text2.setText(tool2.toString());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        这个多的文件就是DaggerFirstComponent.java，可以Ctrl+鼠标左键点击DaggerFirstComponent跳转到这个文件查看。&lt;/p&gt;
&lt;p&gt;        前面找不到自动生成文件在哪的，可以再点击一下&lt;img src=&quot;https://img2018.cnblogs.com/blog/1302182/201909/1302182-20190915213349434-574504576.png&quot; alt=&quot;&quot;/&gt;这个像准星一样的图标，自动定位到对应的文件夹。&lt;/p&gt;
&lt;p&gt;        这个文件就是Dagger+Component的名字组合出来的，实际上也是继承了Component接口对其中的方法进行重写。&lt;/p&gt;
&lt;p&gt;        DaggerFirstComponent代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
public &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DaggerFirstComponent &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; FirstComponent {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; MembersInjector&amp;lt;FirstActivity&amp;gt;&lt;span&gt; firstActivityMembersInjector;

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DaggerFirstComponent(Builder builder) {
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; builder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    initialize(builder);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Builder builder() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Builder();
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; FirstComponent create() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder().build();
  }

  @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initialize(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Builder builder) {

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.firstActivityMembersInjector =&lt;span&gt;
        FirstActivity_MembersInjector.create(Tools_Factory.create());
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inject(FirstActivity activity) {
    firstActivityMembersInjector.injectMembers(activity);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Builder {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Builder() {}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FirstComponent build() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DaggerFirstComponent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         很明显的Builder建造者模式。&lt;/p&gt;
&lt;p&gt;         再反观一下Activity中对DaggerFirstComponent的调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        DaggerFirstComponent.builder()&lt;/span&gt;
&lt;span&gt;                .build()
                .inject(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         首先在里面先初始化一个Builder类，然后调用Builder类中的build()方法对DaggerFirstComponent进行构造。&lt;/p&gt;
&lt;p&gt;         DaggerFirstComponent构造函数中，有个initialize的初始化函数，给DaggerFirstComponent持有的一个内部成员firstActivityMembersInjector赋值。&lt;/p&gt;
&lt;p&gt;         注意这行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;this&lt;/span&gt;.firstActivityMembersInjector = &lt;span&gt;FirstActivity_MembersInjector.create(Tools_Factory.create());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         这又涉及到一个关键的文件，记住后缀MembersInjector就行了。&lt;/p&gt;
&lt;p&gt;         可能有的小伙伴就要问，为啥我不一次性把所有的自动生成文件都列出来？&lt;/p&gt;
&lt;p&gt;         按照逻辑一步步来，这样比较好理解。&lt;/p&gt;
&lt;p&gt;         这也是最后一个了：一个工厂类Factory、一个接口实现类DaggerComponent、加上组装类MemberInjector（如果你看见第四个，可能是ButterKnife生成的，有兴趣可以看看）&lt;/p&gt;
&lt;p&gt;         为啥要把MemberInject叫做组装类，听我慢慢讲来。&lt;/p&gt;
&lt;p&gt;         MemberInject.java源代码太长了，先只看create()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Provider&amp;lt;Tools&amp;gt;&lt;span&gt; tool1AndTool2Provider;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FirstActivity_MembersInjector(Provider&amp;lt;Tools&amp;gt;&lt;span&gt; tool1AndTool2Provider) {
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; tool1AndTool2Provider != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tool1AndTool2Provider =&lt;span&gt; tool1AndTool2Provider;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MembersInjector&amp;lt;FirstActivity&amp;gt; create(Provider&amp;lt;Tools&amp;gt;&lt;span&gt; tool1AndTool2Provider) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FirstActivity_MembersInjector(tool1AndTool2Provider);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        大概意思就是先传进来一个工厂类Factory.create()，前面讲过，工厂类就俩方法：create()和get()。然后把create好的工厂类赋给MemberInject类里的成员变量，大概就是把工厂类构建好，保存起来备用。&lt;/p&gt;
&lt;p&gt;       到这里我们就已经build()跑完了。捋一捋现在都干了啥，DaggerFirstComponent这个类调用了Factory.create()，然后把它给了MemberInject，自己保存了一个MemberInject的实例。到了这步，其实返回的还是个Component，然后继续执行Component里已有的方法而已。&lt;/p&gt;
&lt;p&gt;       注意这点，到这里返回的是个Component！划重点，后面要考的。&lt;/p&gt;
&lt;p&gt;       如果你看代码足够认真可能会注意到，DaggerFirstComponent中有个create()方法，对应的就是builder().build()。意味着依赖注入的代码可以简写成下面这种形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        DaggerFirstComponent.create()&lt;/span&gt;&lt;span&gt;.inject(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        没错，确实可以这样，但强烈不建议这样写。划重点，强烈不建议！&lt;/p&gt;
&lt;p&gt;        因为不符合开闭原则，原因后面会讲到。&lt;/p&gt;
&lt;p&gt;        DaggerFirstComponent类继承了FirstComponent接口，重写了inject方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inject(FirstActivity activity) {
    firstActivityMembersInjector.injectMembers(activity);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       可以看到Inject方法只是给MemberInject的实例传了个Activity。&lt;/p&gt;
&lt;p&gt;       MemberInject都被喂了哪些东西？&lt;/p&gt;
&lt;p&gt;       工厂类create好了送进去，Activity也给它了。&lt;/p&gt;
&lt;p&gt;       为啥叫它组装类！看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    instance.tool1 = tool1Provider.get();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       instance是Activity的实例，通过Activity找到之前声明的依赖注入实例tools，然后在工厂类实例tool1Provider中get()一个新的对象赋值给它。&lt;/p&gt;
&lt;p&gt;       东西都是DaggerFirstComponent给它准备好的，他只负责组装。&lt;/p&gt;
&lt;p&gt;       到这里，整个依赖注入全部完成。&lt;/p&gt;
&lt;p&gt;       运行结果如下：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1302182/201909/1302182-20190915223259266-1981287633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      注入两个不同的Tools。&lt;/p&gt;
&lt;p&gt;      回顾一下，其实逻辑很简单。&lt;/p&gt;
&lt;p&gt;       1、在需要注入依赖的Activity中，用@Inject标记所注入的依赖类的实例tools&lt;/p&gt;
&lt;p&gt;       2、在所需呀注入的类Tools的构造函数Tools()上标记@Inject，编译会根据此生成Factory工厂类&lt;/p&gt;
&lt;p&gt;       3、在接口FirstComponent上标记@Component，并写入Inject方法&lt;/p&gt;
&lt;p&gt;       4、编译生成DaggerFirstComponent.java&lt;/p&gt;
&lt;p&gt;       5、调用DaggerFirstComponent方法将工厂类的实例和Activity的实例都交给MemberInjecter&lt;/p&gt;
&lt;p&gt;       6、MemberInjecter组装完成，依赖成功注入。&lt;/p&gt;

&lt;p&gt;       等等，四大基本组件怎么只讲了两个？&lt;/p&gt;
&lt;p&gt;       因为两个就已经能基本完成一个简单的依赖注入了，下一章接着讲工厂类的另一种构成方法。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 16:33:00 +0000</pubDate>
<dc:creator>缘溪行</dc:creator>
<og:description>和很多自主学习的人，我接触Dagger 2 框架的原因是刚进公司的时候导师给安排的学习任务，学习方式是组内培训。 听到这个消息的我，以为是部门的人轮流给我讲课。 后来导师跟我说，组内培训的意思是，我先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanxixing/p/11525027.html</dc:identifier>
</item>
<item>
<title>BMP 图像信息隐藏及检测 - Qftm</title>
<link>http://www.cnblogs.com/qftm/p/11546479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qftm/p/11546479.html</guid>
<description>&lt;p&gt;针对文件结构的信息隐藏方法需详细掌握文件的格式，利用文件结构块之间的关系或根据块数据和块大小之间的关系来隐藏信息。&lt;/p&gt;
&lt;p&gt;BMP（Bitmap-File）图形文件是 Windows 采用的常见图形文件格式，要利用 BMP 位图进行信息隐藏首先需要详细了解 BMP 文件的格式，BMP 图像文件结构比较单一而且固定，BMP  图像由文件头、信息头、调色板区和数据区四个部分组成，而 24 位真彩色图像中没有调色板信息。24 位真彩色 BMP 位图文件包括 3 部分。 第一部分是 BMP 文件头（14个字节）。前 2 个字节是“BM”，是用于识别 BMP文件的标志；第 3、4、5、6 字节存放的是位图文件的大小，以字节为单位；第7、8、9、10 字节是保留的，必须为 0；第 11、12、13、14 字节给出位图阵列相对于文件头的偏移，在 24 位真彩色图像中，这个值固定为 54；第二部分是位图信息头（40个字节）。第19，20，21，22字节表示的是图像文件的宽度，以像素为单位；第23，24，25，26 字节表示的是图像文件的高度，以像素为单位。从第 29个字节开始，第 29、30 字节描述的是像素的位数， 24 位真彩色位图。该位的值为 0x18； 第三部分是数据区。从第 55 个字节开始，每 3 个字节表示一个像素，这 3 个字节依次表示该像素的红、绿、蓝亮度分量值。&lt;/p&gt;
&lt;p&gt;在不影响图像正常显示情况下，可使用以下四种方法在 24 位真彩色 BMP 图像中隐藏信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在图像文件尾部添加任意长度的数据，秘密信息存放在文件尾部可以减少修改文件头的数据量，仅需修改文件头中文件长度的值即可。&lt;/li&gt;
&lt;li&gt;在调色板或者位图信息头和实际的图像数据之间隐藏数据，如果将秘密数据放在文件头与图像数据之间，则至少需要修改文件头中文件长度、数据起始偏移地址这两个域的值。&lt;/li&gt;
&lt;li&gt;修改文件头和信息头中的保留字段隐藏信息。&lt;/li&gt;
&lt;li&gt;在图像像素区利用图像宽度字节必须是 4 的倍数的特点，在补足位处隐藏数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Windows 10 操作系统&lt;/p&gt;
&lt;p&gt;MATLAB 2019a 版本软件&lt;/p&gt;
&lt;p&gt;BMP 格式图片文件&lt;/p&gt;
&lt;p&gt;010 编辑工具&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;一、在实际的图像数据后隐藏信息&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;待隐藏的秘密信息文件名称为  hidden.txt，  Baboon.bmp  为载体图像，将载体和秘密信息放置在同一个目录下，在 Windows 的 MS-DOS 方式下执行命令 Copy baboon.bmp /b + hidden.txt /a baboon1.bmp  ，其中参数/b 指定以二进制格式复制、合并文件，参数/a 以 ASCII 格式复制、合并文件。执行该命令后，生成一个新的 baboon1.bmp 文件，使用图像浏览工具浏览该文件发现与原始载体图像几乎完全相同，信息隐藏在 baboon.bmp 文件的尾部。从 BMP 图像的结构中可知，图像的 3、4、5、6 四个字节存放整个 BMP 图像的长度。使用该方法隐藏信息时，未修改图像文件的文件长度字节，通过比较文件的实际长度和&lt;/p&gt;
&lt;p&gt;文件中保存的文件长度，就可发现该图像是否隐藏秘密信息。&lt;/p&gt;
&lt;p&gt;（1）制作隐藏信息的图片QftmModify1.bmp&lt;/p&gt;
&lt;p&gt;创建Hidden.txt文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201909/1594459-20190919001638226-2044563141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;制作QftmModify1.bmp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
copy  Qftm.bmp/b + hidden.txt/a QftmModify1.bmp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201909/1594459-20190919001755012-1389510036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）Matlab脚本检测文件是否存在隐藏信息&lt;/p&gt;
&lt;p&gt;检测图片QftmModify1.bmp文件长度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clc;
clear;
fid&lt;/span&gt;=fopen('QftmModify1.bmp','r'); %&lt;span&gt;读入载体图像文件
[a,length]&lt;/span&gt;=fread(fid,inf,'uint8');%&lt;span&gt;length 是文件的实际长度
fclose(fid);
fid&lt;/span&gt;=fopen('QftmModify1.bmp','r'&lt;span&gt;);
status&lt;/span&gt;=fseek(fid,2,'bof'&lt;span&gt;);
fileb&lt;/span&gt;=fread(fid,4,'uint8'&lt;span&gt;);
filelength&lt;/span&gt;=fileb(1)*1+fileb(2)*256+fileb(3)*256^2+fileb(4)*256^3 %&lt;span&gt;文件图像中保存的文件长度
diff&lt;/span&gt;=length-&lt;span&gt;filelength;
&lt;/span&gt;%&lt;span&gt;diff 表示隐藏的信息长度如果相同，表示图像没有隐藏任何信息。
fclose(fid);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行脚本查看diff结果&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201909/1594459-20190919001845882-391682552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 从结果可以看出来当没有对bmp的文件头文件长度进行修改时，隐藏的图片diff差值不等于0，得到图片存在信息隐藏。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二、文件头与图像数据之间隐藏信息&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在数据区开始之前隐藏信息，隐藏的秘密信息从 hidden.txt 文件中读取（隐藏整个文件），此种方法修改图像数据的偏移量和图像数据的文件长度。&lt;/p&gt;
&lt;p&gt;（1）Matlab脚本进行隐藏信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clc;
clear;
wm&lt;/span&gt;=randsrc(1,300, [0 1]); %&lt;span&gt;  产生随机水印
fid&lt;/span&gt;=fopen('Qftm.bmp','r'); %&lt;span&gt;读入载体图像文件
[a,length]&lt;/span&gt;=fread(fid,inf,'uint8'&lt;span&gt;);
fclose(fid);
msgfid&lt;/span&gt;=fopen('hidden.txt','r');%&lt;span&gt;打开秘密文件
[msg,count]&lt;/span&gt;=&lt;span&gt;fread(msgfid);
fclose(msgfid);
wa&lt;/span&gt;=&lt;span&gt;a;
j&lt;/span&gt;=1&lt;span&gt;;
wa(&lt;/span&gt;11)=54+&lt;span&gt;count;
wa(&lt;/span&gt;3)=wa(3)+&lt;span&gt;count;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i=55:54+&lt;span&gt;count
    wa(i)&lt;/span&gt;=uint8(msg(j,1));%&lt;span&gt;隐藏密码信息
    j&lt;/span&gt;=j+1&lt;span&gt;;
end
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i=55&lt;span&gt;:length
    wa(i&lt;/span&gt;+count)=&lt;span&gt;a(i);
end
figure;
wa&lt;/span&gt;=&lt;span&gt;uint8(wa);
fid&lt;/span&gt;=fopen('watermarked.bmp', 'wb'&lt;span&gt;);
fwrite(fid,wa);
fclose(fid);
I&lt;/span&gt;=imread('Qftm.bmp'&lt;span&gt;);
J&lt;/span&gt;=imread('watermarked.bmp'&lt;span&gt;);
subplot(&lt;/span&gt;1,2,1&lt;span&gt;)
imshow(I)
title(&lt;/span&gt;'未修改图像'&lt;span&gt;);
subplot(&lt;/span&gt;1,2,2&lt;span&gt;)
imshow(J)
title(&lt;/span&gt;'修改后图像')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201909/1594459-20190919002234251-88891813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  分析《watermarked.bmp》16进制清晰查看隐藏效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201909/1594459-20190919002247052-491293492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三、&lt;/strong&gt;&lt;strong&gt;BMP &lt;/strong&gt;&lt;strong&gt;图像文件隐藏信息的检测&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在BMP图像中隐藏信息的时候一般都是通过修改文件的偏移量和图像文件中图像的长度来隐藏信息，但在BMP图像文件中，file_length=biwidth*biBytecount*biHeight+bfoffBits，其中  biwidth,biheight表示&lt;/p&gt;
&lt;p&gt;图像文件的宽度和高度，bfoffBits表示文件头到实际位图图像数据之间的偏移量。&lt;/p&gt;
&lt;p&gt;（1）Matlab脚本对Bmp进行信息隐藏多层Check&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clc;
clear;
wm&lt;/span&gt;=randsrc(1,300, [0 1]); %&lt;span&gt;  产生随机水印信息
fid&lt;/span&gt;=fopen('watermarked.bmp','r'); %&lt;span&gt;读入载体图像文件
[a,length]&lt;/span&gt;=fread(fid,inf,'uint8'&lt;span&gt;);
status&lt;/span&gt;=fseek(fid,2,'bof'&lt;span&gt;);
fileb&lt;/span&gt;=fread(fid,4,'uint8'&lt;span&gt;);
filelength&lt;/span&gt;=fileb(1)*1+fileb(2)*256+fileb(3)*256^2+fileb(4)*256^3 %&lt;span&gt;文件图像的理论长度
status&lt;/span&gt;=fseek(fid,10,'bof'&lt;span&gt;);
b&lt;/span&gt;=fread(fid,4,'uint8'&lt;span&gt;);
bfoffbitsmodify&lt;/span&gt;=b(1)*1+b(2)*256+b(3)*256^2+b(4)*256^3 %&lt;span&gt;读取偏移量
status&lt;/span&gt;=fseek(fid,18,'bof'&lt;span&gt;);
b&lt;/span&gt;=fread(fid,4,'uint8'&lt;span&gt;);
biwidth&lt;/span&gt;=b(1)*1+b(2)*256+b(3)*256^2+b(4)*256^3&lt;span&gt;
status&lt;/span&gt;=fseek(fid,22,'bof'&lt;span&gt;);
b&lt;/span&gt;=fread(fid,4,'uint8'&lt;span&gt;);
biHeight&lt;/span&gt;=b(1)*1+b(2)*256+b(3)*256^2+b(4)*256^3&lt;span&gt;;
bfoffbits&lt;/span&gt;=54;%&lt;span&gt;偏移量
biBytecount&lt;/span&gt;=3;%24 位真彩色图像为 3&lt;span&gt;
filetruelength&lt;/span&gt;=biwidth*biBytecount*biHeight+bfoffbits %&lt;span&gt;图片实际真实长度（固定偏移54）
filelengthbfoffbits&lt;/span&gt;=biwidth*biBytecount*biHeight+bfoffbitsmodify %&lt;span&gt;读取偏移计算文件长度
fclose(fid);
diff1&lt;/span&gt;=length-filelength;        %&lt;span&gt;未修改图片长度时Check1
diff2&lt;/span&gt;=filelength-filetruelength %&lt;span&gt;修改了图片长度时Check2
diff3&lt;/span&gt;=filelengthbfoffbits-filetruelength %&lt;span&gt;修改了图片偏移时Check3
diff&lt;/span&gt;=diff1+diff2+diff3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对watermarked.bmp（文件长度和文件偏移都被修改了）进行测试，根据diff的值进行判定该图片是否存在信息隐藏，运行结果查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201909/1594459-20190919002344210-699576299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结果diff != 0可以看出来该图片存在信息隐藏。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;四、在图像文件头和信息头的保留字段中隐藏信息&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;BMP 图像文件中有很多从不使用的保留字节，如 7、8、9、10 字节是保留的，必须为 0，可在第 7、8、9、10 字节隐藏秘密信息。&lt;/p&gt;
&lt;p&gt;（1）Matlab脚本对Bmp的保留字段隐藏信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clc;
clear;
fid&lt;/span&gt;=fopen('Qftm.bmp','r'); %&lt;span&gt;读入载体图像文件
[a,length]&lt;/span&gt;=fread(fid,inf,'uint8'&lt;span&gt;);
fclose(fid);
wa&lt;/span&gt;=&lt;span&gt;a;
&lt;/span&gt;% 在BMP的7、8、9、10保留字中隐藏秘密信息Qftm,ASCII值为0x51 0x66 0x74 0x6d&lt;span&gt;
wa(&lt;/span&gt;7)=81&lt;span&gt;;
wa(&lt;/span&gt;8)=102&lt;span&gt;;
wa(&lt;/span&gt;9)=116&lt;span&gt;;
wa(&lt;/span&gt;10)=109&lt;span&gt;;
figure;
wa&lt;/span&gt;=&lt;span&gt;uint8(wa);
fid&lt;/span&gt;=fopen('watermarkedReserve.bmp', 'wb'&lt;span&gt;);
fwrite(fid,wa);
fclose(fid);
I&lt;/span&gt;=imread('Qftm.bmp'&lt;span&gt;);
J&lt;/span&gt;=imread('watermarkedReserve.bmp'&lt;span&gt;);
subplot(&lt;/span&gt;1,2,1&lt;span&gt;)
imshow(I)
title(&lt;/span&gt;'未修改图像'&lt;span&gt;);
subplot(&lt;/span&gt;1,2,2&lt;span&gt;)
imshow(J)
title(&lt;/span&gt;'修改后图像')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201909/1594459-20190919002430279-601024819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  分析《watermarkedReserve.bmp》16进制清晰查看隐藏效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201909/1594459-20190919002449555-1396830744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Wed, 18 Sep 2019 16:26:00 +0000</pubDate>
<dc:creator>Qftm</dc:creator>
<og:description>原理简介 针对文件结构的信息隐藏方法需详细掌握文件的格式，利用文件结构块之间的关系或根据块数据和块大小之间的关系来隐藏信息。 BMP（Bitmap-File）图形文件是 Windows 采用的常见图形</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qftm/p/11546479.html</dc:identifier>
</item>
<item>
<title>实时计算数据架构的演变 - nicekk</title>
<link>http://www.cnblogs.com/nicekk/p/11546384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nicekk/p/11546384.html</guid>
<description>&lt;p&gt;传统数据基础架构&lt;br/&gt;传统单体数据架构最大的特点便是集中式数据存储，大多数分为计算层和存储层。&lt;/p&gt;
&lt;p&gt;存储层，主要是负责存储企业各种系统产生的数据，如 Web 业务系统、订单系统、CRM 系统，ERP 系统、监控系统，数据比如系统的订单交易量，网站的活跃用户数，每个用户的交易额。&lt;br/&gt;所有的操作均需要借助于同一套数据库实现。&lt;br/&gt;单体架构初期效率很高，但是随着时间的推移，业务越来越多，上线迭代很快。&lt;br/&gt;但随着后期业务越来越多，系统逐渐变的臃肿。数据库变成了唯一准确的数据源，每个应用都需要访问数据库来获取对应的数据，如果数据库发生改变或者出现问题，整个业务系统都会受到影响。&lt;br/&gt;&lt;img src=&quot;https://mypic-1253424599.cos.ap-shanghai.myqcloud.com/201909182244.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微服务架构&lt;br/&gt;微服务将系统拆分成不同的独立服务模块，每个模块有自己独立的数据库，不同的业务之间互相不干扰，微服务架构解决了业务系统拓展性的问题，但是随之也带来了新的问题。&lt;br/&gt;就是业务数据过于分散在不同的系统中，很难将数据集中化管理。对于企业内部数据仓库，数据挖掘之类的应用，需要把各个业务系统数据库数据抽取到数据仓库之中，在数据仓库中进行数据的抽取、转换、加载（ETL），从而构建不同的数据集市应用，提供给业务系统用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mypic-1253424599.cos.ap-shanghai.myqcloud.com/201909182245.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大数据数据架构&lt;br/&gt;起初，数据是构建在关系型数据库之上，但随着企业数据量的暴增，关系型数据库已经无法支撑起大规模数据集的存储和分析，于是基于HADOOP构建企业级大数据平台便成为了共识。&lt;br/&gt;后来，离线的高延迟渐渐的无法满足企业需求，例如一些时间要求比较高的应用，实时报表统计，需要非常低的延时展示结果。为此业界提出一套lambda架构方案来处理不同类型的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mypic-1253424599.cos.ap-shanghai.myqcloud.com/201909182246.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;包含了批量计算的 Batch Layer和实时计算的 Speed Layer，通过在一套平台中，将批计算和流计算结合在一起。&lt;br/&gt;lambda 架构是构建大数据应用程序的一种很有效的解决方案，但还不是最完美的方案&lt;/p&gt;
&lt;p&gt;有状态流式架构&lt;br/&gt;数据产生的本质，其实是一条条真实存在的事件，而前面讲的不同的架构所用到的技术，如hadoop，spark，多少都在一定程度上违背了这种本质，需要在一定延时的情况下对业务数据进行处理。&lt;br/&gt;而有状态的流计算架构，基于实时的流式数据，维护所有计算过程的状态，所谓状态就是计算过程中产生的所有中间计算结果，每次计算新的数据进入到流式系统中都是基于中间状态结果的基础上进行计算，最终产生正确的统计结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mypic-1253424599.cos.ap-shanghai.myqcloud.com/201909182247.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种架构好处是，不需要从原始数据重新从外部存储中拿出来，从而进行全量计算；另外用户也无需协调各种批量计算工具，从数据仓库中获取统计结果，然后再落地存储，这些操作全部都可以基于流式操作来完成&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 15:46:00 +0000</pubDate>
<dc:creator>nicekk</dc:creator>
<og:description>flink架构演变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nicekk/p/11546384.html</dc:identifier>
</item>
<item>
<title>线程操作之锁的使用 - tomjoy</title>
<link>http://www.cnblogs.com/guapitomjoy/p/11546305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guapitomjoy/p/11546305.html</guid>
<description>&lt;h3 id=&quot;一线程锁&quot;&gt;一、线程锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.多个线程抢占资源的情况：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁通常被用来实现对共享资源的同步访问。为每一个共享资源创建一个Lock对象，当你需要访问该资源时，调用acquire方法来获取锁对象（如果其它线程已经获得了该锁，则当前线程需等待其被释放），待资源访问完后，再调用release方法释放锁：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;案例一：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from threading import  Thread,Lock
import time
K = Lock()
def func():
    global n
    K.acquire()       # 加锁
    team = n
    time.sleep(0.1)   # 分析：第一个线程刚拿到team = n = 100,就遇到阻塞，马上切换到下一个线程，下一个线程还是跟上一个线程一样的情况，
                      #       由于线程切换速度很快，一直拿到的team都是99，除非你的线程数量足够大。
                      # 解决方法： 给处理数据部分进行加锁处理。
    n = team-1
    K.release()      # 释放锁
if __name__ == '__main__':
    n = 100
    l = []
    for i in range(100):
        t = Thread(target=func)
        l.append(t)
        t.start()
    for t in l:
        t.join()
    print(n)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;案例二：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from threading import Thread,Lock
x = 0
K = Lock()
def func():
    global x
    K.acquire()
    for i in range(60000):

        x = x+1
        # t1 的x刚拿到0 保存状态 就被切换了
        # t2 的x拿到0 进行+1操作  x = 1
        # t1 又获得了运行 ,返回被切之前的保存状态，x=0+1  x= 1
        # 其实运算出来的数字应该是+2,实际上只+1
        # 这就产生了数据安全问题
    K.release()
if __name__ == '__main__':
    t1 = Thread(target=func)
    t2 = Thread(target=func)
    t3 = Thread(target=func)

    t1.start()
    t2.start()
    t3.start()

    t1.join()
    t2.join()
    t3.join()
    print(x)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二死锁问题&quot;&gt;二、死锁问题&lt;/h3&gt;
&lt;p&gt;死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from threading import Lock as Lock
import time
mutexA=Lock()
mutexA.acquire()
mutexA.acquire()
print(123)
mutexA.release()
mutexA.release()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。&lt;/p&gt;
&lt;p&gt;这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from threading import Thread,RLock,currentThread
import time
k1 = k2 = RLock()   #  一个线程拿到锁，counter加1,该线程内又碰到加锁的情况，则counter继续加1，这期间所有其他线程都只能等待，等待该线程释放所有锁，即counter递减到0为止
class Myt(Thread):
    def run(self):
        self.task1()
        self.task2()

    def task1(self):
        k1.acquire()
        print(f'{self.name} 抢到了 锁1')
        k2.acquire()
        print(f'{self.name} 抢到了 锁2')
        k2.release()
        print(f'{self.name} 释放了 锁2')
        k1.release()
        print(f'{self.name} 释放了 锁1')


    def task2(self):
        k2.acquire()
        print(f'{self.name} 抢到了 锁2')
        time.sleep(1)     # 当线程1 执行到这一步的时候，遇到阻塞，马上切换到线程2，此时，线程1已经拿到了锁2，但是线程2也要拿，所以形成了死锁。
        k1.acquire()      # 解决方法： 加入递归锁RLock
        print(f'{self.name} 抢到了 锁1')
        k1.release()
        print(f'{self.name} 释放了 锁1')
        k2.release()
        print(f'{self.name} 释放了 锁2')

for i in range(3):
    t = Myt()
    t.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三-信号量semaphore&quot;&gt;三、 信号量Semaphore&lt;/h3&gt;
&lt;p&gt;同进程的一样&lt;/p&gt;
&lt;p&gt;Semaphore管理一个内置的计数器，&lt;br/&gt;每当调用acquire()时内置计数器-1；&lt;br/&gt;调用release() 时内置计数器+1；&lt;br/&gt;计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()。&lt;/p&gt;
&lt;p&gt;实例：(同时只有5个线程可以获得semaphore,即可以限制最大连接数为5)：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from threading import Thread,currentThread,Semaphore

import time
def func():
    sm.acquire()
    print(f'{currentThread().name} 正在执行')
    time.sleep(3)
    sm.release()
sm = Semaphore(5)
for i in range(15):
    t= Thread(target=func)
    t.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四gil锁&quot;&gt;四、GIL锁：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GIL 与Lock是两把锁，本质上也是一把互斥锁，保护的数据不一样，前者是解释器级别的（当然保护的就是解释器级别的数据，比如垃圾回收的数据），后者是保护用户自己开发的应用程序的数据，很明显GIL不负责这件事，只能用户自定义加锁处理，即Lock&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程分析：所有线程抢的是GIL锁，或者说所有线程抢的是执行权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;线程1抢到GIL锁，拿到执行权限，开始执行，然后加了一把Lock，还没有执行完毕，即线程1还未释放Lock，有可能线程2抢到GIL锁，开始执行，执行过程中发现Lock还没有被线程1释放，于是线程2进入阻塞，被夺走执行权限，有可能线程1拿到GIL，然后正常执行到释放Lock。。。这就导致了串行运行的效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;既然是串行，那我们执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;t1.start()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;t1.join&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;t2.start()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;t2.join()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;这也是串行执行啊，为何还要加Lock呢，需知join是等待t1所有的代码执行完，相当于锁住了t1的所有代码，而Lock只是锁住一部分操作共享数据的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;五计算密集型&quot;&gt;五、计算密集型&lt;/h3&gt;
&lt;p&gt;在 处理像科学计算 这类需要持续使用cpu的类型。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process
from threading import Thread
import os,time

res = 0
def func():
    global res
    for i in range(10000000):
        res += i


if __name__ == '__main__':

    print(os.cpu_count())   # CPU核心数
    start = time.time()
    l = []
    for i in range(4):
        # t = Process(target=func)
        t =Thread(target=func)
        l.append(t)
        t.start()
    for t in l :
        t.join()
    end = time.time()
    print(end-start)   # 多进程耗时：3.4384214878082275   多线程耗时：4.417709827423096&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上看出：在处理持续计算长时间使用CPU的代码，多进程处理的速度比多线程快。推荐使用多进程进行运算。&lt;/p&gt;
&lt;h3 id=&quot;六io密集型&quot;&gt;六、IO密集型&lt;/h3&gt;
&lt;p&gt;指在处理像IO操作等可能引起阻塞的类型&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process
from threading import Thread
import time

def func():
    time.sleep(5)

if __name__ == '__main__':
    l = []
    start = time.time()
    for i in range(4):
        # t = Process(target=func)  # 多进程
        t = Thread(target=func)  # 多线程
        l.append(t)
        t.start()
    for t in l:
        t.join()
    end = time.time()
    print(end-start)   # 多进程：5.8953258991241455  多线程：5.002920150756836&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上可以看出：在执行IO操作引起阻塞这种任务的时候，多线程的速度明显比多进程要快。&lt;/p&gt;
&lt;p&gt;由上面两个案例，得出结论：&lt;/p&gt;
&lt;p&gt;​ python对于计算密集型的任务开多线程的效率并不能带来多大性能上的提升，甚至不如串行(没有大量切换)，但是，对于IO密集型的任务效率还是有显著提升的。&lt;br/&gt;​&lt;br/&gt;​ 多线程用于IO密集型，如socket，爬虫，web&lt;br/&gt;​ 多进程用于计算密集型，如金融分析&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 15:24:00 +0000</pubDate>
<dc:creator>tomjoy</dc:creator>
<og:description>一、线程锁 1.多个线程抢占资源的情况： 锁通常被用来实现对共享资源的同步访问。为每一个共享资源创建一个Lock对象，当你需要访问该资源时，调用acquire方法来获取锁对象（如果其它线程已经获得了该</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guapitomjoy/p/11546305.html</dc:identifier>
</item>
<item>
<title>Java中各种引用(Reference)解析 - 堕落门徒</title>
<link>http://www.cnblogs.com/cord/p/11546303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cord/p/11546303.html</guid>
<description>&lt;h2 id=&quot;引用类型&quot;&gt;1,引用类型&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.lang.ref&lt;/code&gt;整体包结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/cord/Desktop/jdk-src/jpg/1.引用/java.lang.ref.png&quot; alt=&quot;java.lang.ref&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/564309/201909/564309-20190918232236858-1324586838.png&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;强引用&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;强引用的对象绝对不会被gc回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;软引用&lt;/td&gt;
&lt;td&gt;SoftReference&lt;/td&gt;
&lt;td&gt;如果物理内存充足则不会被gc回收,如果物理内存不充足则会被gc回收。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;弱引用&lt;/td&gt;
&lt;td&gt;WeakReference&lt;/td&gt;
&lt;td&gt;一旦被gc扫描到则会被回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;虚引用&lt;/td&gt;
&lt;td&gt;PhantomReference&lt;/td&gt;
&lt;td&gt;不会影响对象的生命周期，形同于无，任何时候都可能被gc回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;FinalReference&lt;/td&gt;
&lt;td&gt;用于收尾机制(finalization)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;finalreference&quot;&gt;2, FinalReference&lt;/h2&gt;
&lt;p&gt;​ &lt;code&gt;FinalReference&lt;/code&gt;访问权限为package，并且只有一个子类&lt;code&gt;Finalizer&lt;/code&gt;，同时&lt;code&gt;Finalizer&lt;/code&gt; 是final修饰的类，所以无法继承扩展。&lt;/p&gt;
&lt;p&gt;​ 与&lt;code&gt;Finalizer&lt;/code&gt;相关联的则是Object中的&lt;code&gt;finalize()&lt;/code&gt;方法，在类加载的过程中，如果当前类有覆写&lt;code&gt;finalize()&lt;/code&gt;方法，则其对象会被标记为finalizer类，这种类型的对象被回收前会先调用其&lt;code&gt;finalize()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;​ 具体的实现机制是，在gc进行可达性分析的时候，如果当前对象是finalizer类型的对象，并且本身不可达（与GC Roots无相连接的引用），则会被加入到一个&lt;code&gt;ReferenceQueue&lt;/code&gt;类型的队列(F-Queue)中。而系统在初始化的过程中，会启动一个&lt;code&gt;FinalizerThread&lt;/code&gt;实例的&lt;strong&gt;守护线程&lt;/strong&gt;(线程名Finalizer)，该线程会不断消费F-Queue中的对象，并执行其&lt;code&gt;finalize()&lt;/code&gt;方法(runFinalizer)，并且runFinalizer方法会捕获Throwable级别的异常，也就是说&lt;code&gt;finalize()&lt;/code&gt;方法的异常不会导致&lt;code&gt;FinalizerThread&lt;/code&gt;运行中断退出。对象在执行&lt;code&gt;finalize()&lt;/code&gt;方法后，只是断开了与&lt;code&gt;Finalizer&lt;/code&gt;的关联，并不意味着会立即被回收，还是要等待下一次GC，&lt;strong&gt;而每个对象的&lt;code&gt;finalize()&lt;/code&gt;方法都只会执行一次，不会重复执行。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;​ &lt;code&gt;finalize()&lt;/code&gt;方法是对象逃脱死亡命运的最后一次机会，如果在该方法中将对象本身(this关键字) 赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出&quot;即将回收的集合&quot;。&lt;/p&gt;
&lt;p&gt;——《深入理解java虚拟机》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;finalize()使用不当会导致内存泄漏和内存溢出，比如&lt;code&gt;SocksSocketImpl&lt;/code&gt;之类的服务会在&lt;code&gt;finalize()&lt;/code&gt;中加入&lt;code&gt;close()&lt;/code&gt;操作用于释放资源，但是如果&lt;code&gt;FinalizerThread&lt;/code&gt;一直没有执行的话就会导致资源一直无法释放，从而出现内存泄漏。还有如果某对象的&lt;code&gt;finalize()&lt;/code&gt;方法执行时间太长或者陷入死循环，将导致&lt;code&gt;F-Queue&lt;/code&gt;一直堆积，从而造成内存溢出(oom)。&lt;/p&gt;
&lt;h3 id=&quot;finalizer&quot;&gt;2.1, Finalizer&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;FinalizerThread&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //消费ReferenceQueue并执行对应元素对象的finalize()方法
    private static class FinalizerThread extends Thread {
        ......
        public void run() {
            ......
            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
            running = true;
            for (;;) {
                try {
                    Finalizer f = (Finalizer)queue.remove();
                    f.runFinalizer(jla);
                } catch (InterruptedException x) {
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //初始化的时候启动FinalizerThread(守护线程)
    static {
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        for (ThreadGroup tgn = tg;
             tgn != null;
             tg = tgn, tgn = tg.getParent());
        Thread finalizer = new FinalizerThread(tg);
        finalizer.setPriority(Thread.MAX_PRIORITY - 2);
        finalizer.setDaemon(true);
        finalizer.start();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在jvm启动的时候就会启动一个守护线程去消费引用队列，并调用引用队列指向对象的finalize()方法。&lt;br/&gt;jvm在注册finalize()方法被覆写的对象的时候会创建一个&lt;code&gt;Finalizer&lt;/code&gt;对象，并且将该对象加入一个双向链表中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static void register(Object finalizee) {
        new Finalizer(finalizee);
    }
    private Finalizer(Object finalizee) {
        super(finalizee, queue);
        add();
    }
    private void add() { 
        synchronized (lock) { //头插法构建Finalizer对象的链表
            if (unfinalized != null) {
                this.next = unfinalized;
                unfinalized.prev = this;
            }
            unfinalized = this;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外还有两个附加线程用于消费Finalizer链表以及队列:&lt;br/&gt;&lt;code&gt;Runtime.runFinalization()&lt;/code&gt;会调用&lt;code&gt;runFinalization()&lt;/code&gt;用于消费Finalizer队列，而&lt;code&gt;java.lang.Shutdown&lt;/code&gt;则会在jvm退出的时候(jvm关闭钩子)调用&lt;code&gt;runAllFinalizers()&lt;/code&gt;用于消费Finalizer链表。&lt;/p&gt;
&lt;h2 id=&quot;softreference&quot;&gt;3, SoftReference&lt;/h2&gt;
&lt;p&gt;系统将要发生内存溢出(oom)之前，会回收软引用的对象，如果回收后还没有足够的内存，抛出内存溢出异常；&lt;/p&gt;
&lt;p&gt;使用SoftReference类，将要软引用的对象最为参数传入；&lt;/p&gt;
&lt;p&gt;构造方法传入ReferenceQueue队列的时候，如果引用的对象被回收，则将其加入该队列。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public SoftReference(T referent)    根据传入的引用创建软引用                    
public SoftReference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt; q)根据传入的引用和注册队列创建软引用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        ReferenceQueue&amp;lt;String&amp;gt; referenceQueue = new ReferenceQueue&amp;lt;&amp;gt;();
        SoftReference&amp;lt;String&amp;gt; softReference = new SoftReference&amp;lt;&amp;gt;(&quot;abc&quot;, referenceQueue);
        System.gc();
        System.out.println(softReference.get());
        Reference&amp;lt;? extends String&amp;gt; reference = referenceQueue.poll();
        System.out.println(reference);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abc
null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;软引用可用来实现内存敏感的高速缓存&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;weakreference&quot;&gt;4, WeakReference&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;WeakReference&lt;/code&gt;与&lt;code&gt;SoftReference&lt;/code&gt;类似，区别在于&lt;code&gt;WeakReference&lt;/code&gt;的生命周期更短，一旦发生GC就会被回收，不过由于gc的线程优先级比较低，所以&lt;code&gt;WeakReference&lt;/code&gt;不会很快被GC发现并回收。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;WeakReference&lt;/code&gt;类，将要弱引用的对象最为参数传入；&lt;/p&gt;
&lt;p&gt;构造方法传入ReferenceQueue队列的时候，如果引用的对象被回收，则将其加入该队列。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WeakReference(T referent)           根据传入的引用创建弱引用
WeakReference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt; q) 根据传入的引用和注册队列创建弱引用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用示例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WeakReferenceTest {
    public static void main(String[] args) {
        ReferenceQueue&amp;lt;String&amp;gt; rq = new ReferenceQueue&amp;lt;&amp;gt;();
        //这里必须用new String构建字符串，而不能直接传入字面常量字符串
        Reference&amp;lt;String&amp;gt; r = new WeakReference&amp;lt;&amp;gt;(new String(&quot;java&quot;), rq);
        Reference rf;
        //一次System.gc()并不一定会回收A，所以要多试几次
        while((rf=rq.poll()) == null) {
            System.gc();
        }
        System.out.println(rf);
        if (rf != null) {
            //引用指向的对象已经被回收，存入引入队列的是弱引用本身,所以这里最终返回null
            System.out.println(rf.get());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.ref.WeakReference@5a07e868
null&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;phantomreference&quot;&gt;5, PhantomReference&lt;/h2&gt;
&lt;p&gt;​ 虚引用是引用中最弱的引用类型，有些形同虚设的意味。不同于软引用和弱引用，虚引用不会影响对象的生命周期，如果一个对象仅持有虚引用，那么它就相当于无引用指向，不可达，被gc扫描到就会被回收，&lt;u&gt;虚引用无法通过get()方法来获取目标对象的强引用从而使用目标对象，虚引用中get()方法永远返回null。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;​ 虚引用必须和引用队列(ReferenceQueue)联合使用，当gc回收一个被虚引用指向的对象时，会将虚引用加入相关联的引用队列中。&lt;u&gt;虚引用主要用于追踪对象gc回收的活动&lt;/u&gt;，通过查看引用队列中是否包含对象所对应的虚引用来判断它是否即将被回收。&lt;/p&gt;
&lt;p&gt;​ 虚引用的一个应用场景是用来追踪gc回收对应对象的活动。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public PhantomReference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt; q)  创建弱引用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PhantomReferenceTest {

    public static void main(String[] args) {
        ReferenceQueue&amp;lt;String&amp;gt; rq = new ReferenceQueue&amp;lt;&amp;gt;();
        PhantomReference&amp;lt;String&amp;gt; reference = new PhantomReference&amp;lt;&amp;gt;(new String(&quot;cord&quot;), rq);
        System.out.println(reference.get());
        System.gc();
        System.runFinalization();
        System.out.println(rq.poll() == reference);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;null
true&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;referencequeue&quot;&gt;6, ReferenceQueue&lt;/h2&gt;
&lt;p&gt;ReferenceQueue内部数据结构是一个链表，链表里的元素是加入进去的Reference实例，然后通过&lt;code&gt;wait&lt;/code&gt;和&lt;code&gt;notifyAll&lt;/code&gt;与对象锁实现生产者和消费者，通过这种方式模拟一个队列。&lt;/p&gt;
&lt;p&gt;ReferenceQueue是使用wati()和notifyAll()实现生产者和消费者模式的一个具体场景。&lt;/p&gt;
&lt;p&gt;ReferenceQueue重点源码解析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;NULL和ENQUEUED&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static ReferenceQueue&amp;lt;Object&amp;gt; NULL = new Null&amp;lt;&amp;gt;();
    static ReferenceQueue&amp;lt;Object&amp;gt; ENQUEUED = new Null&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个静态属性主要用于标识加入引用队列的引用的状态，&lt;code&gt;NULL&lt;/code&gt;标识该引用已被当前队列移除过，&lt;code&gt;ENQUEUED&lt;/code&gt;标识该引用已加入当前队列。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;enqueue(Reference&amp;lt;? extends T&amp;gt; r)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    boolean enqueue(Reference&amp;lt;? extends T&amp;gt; r) { /* Called only by Reference class */
        synchronized (lock) {
            //检查该引用是否曾从当前队列移除过或者已经加入当前队列了，如果有则直接返回
            ReferenceQueue&amp;lt;?&amp;gt; queue = r.queue;
            if ((queue == NULL) || (queue == ENQUEUED)) {
                return false;
            }
            assert queue == this;
            r.queue = ENQUEUED;//将引用关联的队列统一标识为ENQUEUED
            r.next = (head == null) ? r : head;//当前引用指向head
            head = r; //将head指向当前引用(链表新增节点采用头插法)
            queueLength++; //更新链表长度
            if (r instanceof FinalReference) {
                sun.misc.VM.addFinalRefCount(1); //
            }
            lock.notifyAll(); //通知消费端
            return true;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;remove(long timeout)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;remove尝试移除队列中的头部元素，如果队列为空则一直等待直至达到指定的超时时间。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public Reference&amp;lt;? extends T&amp;gt; remove(long timeout)
        throws IllegalArgumentException, InterruptedException
    {
        if (timeout &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;Negative timeout value&quot;);
        }
        synchronized (lock) {
            Reference&amp;lt;? extends T&amp;gt; r = reallyPoll();
            if (r != null) return r; //如果成功移除则直接返回
            long start = (timeout == 0) ? 0 : System.nanoTime();
            for (;;) {
                lock.wait(timeout); //释放当前线程锁，等待notify通知唤醒
                r = reallyPoll();
                if (r != null) return r;
                if (timeout != 0) {   //如果超时时间不为0则校验超时
                    long end = System.nanoTime();
                    timeout -= (end - start) / 1000_000;
                    if (timeout &amp;lt;= 0) return null;  //如果剩余时间小于0则返回
                    start = end;
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cleaner&quot;&gt;7，Cleaner&lt;/h2&gt;
&lt;p&gt;​ Cleaner是&lt;code&gt;PhantomReference&lt;/code&gt;的一个子类实现，提供了比&lt;code&gt;finalization(收尾机制)&lt;/code&gt;更轻量级和健壮的实现，因为Cleaner中的清理逻辑是由&lt;code&gt;Reference.ReferenceHandler&lt;/code&gt; 直接调用的，而且由于是虚引用的子类，它完全不会影响指向的对象的生命周期。&lt;/p&gt;
&lt;p&gt;​ 一个Cleaner实例记录了一个对象的引用，以及一个包含了清理逻辑的Runnable实例。当Cleaner指向的引用被gc回收后，&lt;code&gt;Reference.ReferenceHandler&lt;/code&gt;会不断消费引用队列中的元素，当元素为Cleaner类型的时候就会调用其clean()方法。&lt;/p&gt;
&lt;p&gt;​ &lt;u&gt;Cleaner不是用来替代finalization的，只有在清理逻辑足够轻量和直接的时候才适合使用Cleaner，繁琐耗时的清理逻辑将有可能导致ReferenceHandler线程阻塞从而耽误其它的清理任务。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;重点源码解析：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Cleaner extends PhantomReference&amp;lt;Object&amp;gt;
{
    //一个统一的空队列，用于虚引用构造方法，Cleaner的trunk会被直接调用不需要通过队列
    private static final ReferenceQueue&amp;lt;Object&amp;gt; dummyQueue = new ReferenceQueue&amp;lt;&amp;gt;();

    //Cleaner内部为双向链表,防止虚引用本身比它们引用的对象先被gc回收,此为头节点
    static private Cleaner first = null;

    //添加节点
    private static synchronized Cleaner add(Cleaner cl) {
        if (first != null) {    //头插法加入节点
            cl.next = first;
            first.prev = cl;
        }
        first = cl;
        return cl;
    }
    //移除节点
    private static synchronized boolean remove(Cleaner cl) {

        //指向自己说明已经被移除
        if (cl.next == cl)
            return false;

        //移除头部节点
        if (first == cl) {
            if (cl.next != null)
                first = cl.next;
            else
                first = cl.prev;
        }
        if (cl.next != null)//下一个节点指向前一个节点
            cl.next.prev = cl.prev;
        if (cl.prev != null)//前一个节点指向下一个节点
            cl.prev.next = cl.next;

        //自己指向自己标识已被移除
        cl.next = cl;
        cl.prev = cl;
        return true;

    }

    //清理逻辑runnable实现
    private final Runnable thunk;

    ...

    //调用清理逻辑
    public void clean() {
        if (!remove(this))
            return;
        try {
            thunk.run();
        } catch (final Throwable x) {
            ...
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;u&gt;Cleaner可以用来实现对堆外内存进行管理&lt;/u&gt;，&lt;code&gt;DirectByteBuffer&lt;/code&gt;就是通过Cleaner实现堆外内存回收的:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    DirectByteBuffer(int cap) { //构造方法中创建引用对象相关联的Cleaner对象                 
        ...
        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
        att = null;
    }
    
    private static class Deallocator implements Runnable {
        ...
        public void run() { //内存回收的逻辑(具体实现参看源码此处不展开)
        ...
        }

    }     &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reference&quot;&gt;8, Reference&lt;/h2&gt;
&lt;p&gt;Reference是上面列举的几种引用包括Cleaner的共同父类，一些引用的通用处理逻辑均在这里面实现。&lt;/p&gt;
&lt;h3 id=&quot;引用实例的几个状态&quot;&gt;引用实例的几个状态&lt;/h3&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Active&lt;/p&gt;
&lt;p&gt;当处于Active状态，gc会特殊处理引用实例，一旦gc检测到其可达性发生变化，gc就会更改其状态。此时分两种情况，如果该引用实例创建时有注册引用队列，则会进入pending状态，否则会进入inactive状态。新创建的引用实例为Active。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Pending&lt;/p&gt;
&lt;p&gt;当前为pending-Reference列表中的一个元素，等待被ReferenceHandler线程消费并加入其注册的引用队列。如果该引用实例未注册引用队列，则永远不会处理这个状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Enqueued&lt;/p&gt;
&lt;p&gt;该引用实例创建时有注册引用队列并且当前处于入队列状态，属于该引用队列中的一个元素。当该引用实例从其注册引用队列中移除后其状态变为Inactive。如果该引用实例未注册引用队列，则永远不会处理这个状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Inactive&lt;/p&gt;
&lt;p&gt;当处于Inactive状态，无需任何处理，一旦变成Inactive状态则其状态永远不会再发生改变。&lt;/p&gt;
&lt;p&gt;整体迁移流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/cord/Desktop/jdk-src/jpg/1.引用/引用实例状态.png&quot; alt=&quot;引用实例状态&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/564309/201909/564309-20190918232307324-2059752462.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;重点源码解析&quot;&gt;重点源码解析&lt;/h3&gt;
&lt;p&gt;1，Reference中的几个关键属性&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //关联的对象的引用,根据引用类型不同gc针对性处理
    private T referent;       
    //引用注册的队列,如果有注册队列则回收引用会加入该队列
    volatile ReferenceQueue&amp;lt;? super T&amp;gt; queue;

    //上面引用队列referenceQueue中保存引用的链表
    /*    active:     NULL //未加入队列前next指向null
     *    pending:    this
     *    Enqueued:   next reference in queue (or this if last)
     *    Inactive:   this
     */
    Reference next;


    /* When active:   由gc管理的引用发现链表的下一个引用
     *     pending:   pending链表中的下一个元素
     *   otherwise:   NULL
     */
    transient private Reference&amp;lt;T&amp;gt; discovered;  /* used by VM */

    /* 
     *等待入队列的引用链表，gc往该链表加引用对象，Reference-handler线程消费该链表。
     * 它通过discovered连接它的元素 
     */     
    private static Reference&amp;lt;Object&amp;gt; pending = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2，ReferenceHandler&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private static class ReferenceHandler extends Thread {
        ...
        public void run() {
            while (true) {
                tryHandlePending(true); //无限循环调用tryHandlePending
            }
        }
    }
    static {
        ... jvm启动时以守护线程运行ReferenceHandler
        Thread handler = new ReferenceHandler(tg, &quot;Reference Handler&quot;);
        handler.setPriority(Thread.MAX_PRIORITY);
        handler.setDaemon(true);
        handler.start();
        //注册JavaLangRefAccess匿名实现,堆外内存管理会用到(Bits.reserveMemory)
        SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
            @Override
            public boolean tryHandlePendingReference() {
                return tryHandlePending(false);
            }
        });
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //消费pending队列
    static boolean tryHandlePending(boolean waitForNotify) {
        Reference&amp;lt;Object&amp;gt; r;
        Cleaner c;
        try {
            synchronized (lock) {
                if (pending != null) {
                    r = pending;
                    // 'instanceof' might throw OutOfMemoryError sometimes
                    // so do this before un-linking 'r' from the 'pending' chain...
                    //判断是否为Cleaner实例
                    c = r instanceof Cleaner ? (Cleaner) r : null;
                   //将r从pending链表移除
                    pending = r.discovered;
                    r.discovered = null;
                } else {
                    // The waiting on the lock may cause an OutOfMemoryError
                    // because it may try to allocate exception objects.
                    //如果pending没有元素可消费则等待通知
                    if (waitForNotify) {
                        lock.wait();
                    }
                    // retry if waited
                    return waitForNotify;
                }
            }
        } catch (OutOfMemoryError x) {
            //释放cpu资源
            Thread.yield();
            // retry
            return true;
        } catch (InterruptedException x) {
            // retry
            return true;
        }

        //调用Cleaner清理逻辑(可参考前面的7，Cleaner段落)
        if (c != null) {
            c.clean();
            return true;
        }
        //如果当前引用实例有注册引用队列则将其加入引用队列
        ReferenceQueue&amp;lt;? super Object&amp;gt; q = r.queue;
        if (q != ReferenceQueue.NULL) q.enqueue(r);
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;​ jvm中引用有好几种类型的实现，gc针对这几种不同类型的引用有着不同的回收机制，同时它们也有着各自的应用场景, 比如SoftReference可以用来做高速缓存, WeakReference也可以用来做一些普通缓存(WeakHashMap), 而PhantomReference则用在一些特殊场景，比如Cleaner就是一个很好的应用场景，它可以用来回收堆外内存。与此同时，SoftReference, WeakReference, PhantomReference这几种弱类型引用还可以与引用队列结合使用，使得可以在关联引用回收之后可以做一些额外处理，甚至于Finalizer(收尾机制)都可以在对象回收过程中改变对象的生命周期。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;https://www.ibm.com/developerworks/cn/java/j-fv/index.html&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/article/jvm-source-code-analysis-finalreference&quot; class=&quot;uri&quot;&gt;https://www.infoq.cn/article/jvm-source-code-analysis-finalreference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-langref/index.html&quot; class=&quot;uri&quot;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-langref/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/duanxz/p/10275778.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/duanxz/p/10275778.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;u&gt;《深入理解java虚拟机》&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/mazhimazh/article/details/19752475&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tuicool.com/articles/AZ7Fvqb&quot; class=&quot;uri&quot;&gt;https://www.tuicool.com/articles/AZ7Fvqb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/aitangyong/article/details/39455229&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/duanxz/p/6089485.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/duanxz/p/6089485.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.throwable.club/2019/02/16/java-reference/#Reference%E7%9A%84%E7%8A%B6%E6%80%81%E9%9B%86%E5%90%88&quot; class=&quot;uri&quot;&gt;https://www.throwable.club/2019/02/16/java-reference/#Reference的状态集合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://imushan.com/2018/08/19/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Reference/&quot;&gt;http://imushan.com/2018/08/19/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Reference/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 15:23:00 +0000</pubDate>
<dc:creator>堕落门徒</dc:creator>
<og:description>[TOC] 1,引用类型 整体包结构 | 类型 | 对应类 | 特征 | | : : | : : | : : | | 强引用 | | 强引用的对象绝对不会被gc回收 | | 软引用 | SoftRef</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cord/p/11546303.html</dc:identifier>
</item>
<item>
<title>Null is your firend, not a mistake - 秉心说</title>
<link>http://www.cnblogs.com/bingxinshuo/p/11546151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingxinshuo/p/11546151.html</guid>
<description>&lt;blockquote readability=&quot;4.16&quot;&gt;
&lt;p&gt;原文作者： &lt;a href=&quot;https://medium.com/@elizarov&quot;&gt;Roman Elizarov&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址： &lt;a href=&quot;https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5&quot;&gt;Null is your firend, not a mistake&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：秉心说&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201909/800205-20190918225025325-2075648902.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Kotlin_Island_west_side.jpg&quot;&gt;Kotlin Island from Wikimedia by Pavlikhin, CC BY-SA 4.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我使用 Java 语言编程已经很久很久了，掌握了通过 Java 编写和维护大型软件（百万行代码）应该注意些什么，并亲眼目睹了全行业都在竭力避免空指针异常 &lt;code&gt;NullPointerException（NPE）&lt;/code&gt;，它困扰着大大小小的 Java 类库。在 2009 年其发明者 &lt;code&gt;Tony Hoare&lt;/code&gt; 承认空引用是他造成的一个 &lt;a href=&quot;https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/&quot;&gt;“十亿美元的错误”&lt;/a&gt;之前，人人已经意识到它的危险性。&lt;/p&gt;
&lt;p&gt;在 1996 年 Java 1.0 发布时，这个问题还不是如此明显。让我们看一个典型的 Java API 的例子：&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/File.html#list--&quot;&gt;&lt;code&gt;File.list()&lt;/code&gt;&lt;/a&gt; 方法。它被用来列举文件夹中的内容，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;for(String name : new File(&quot;directory&quot;).list()) {
    System.out.println(name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅当文件夹存在时上面的代码才会正常运行，否则将抛出 &lt;code&gt;NPE&lt;/code&gt;，因为 &lt;code&gt;list()&lt;/code&gt; 返回了 &lt;code&gt;null&lt;/code&gt;。但是谁会写这样的代码呢？不仅仅 &lt;code&gt;list()&lt;/code&gt; 方法的文档中清楚的说明了文件夹不存在时将返回 &lt;code&gt;null&lt;/code&gt;，而且现代的 IDE 也会对特定的代码给你提出警告。&lt;/p&gt;
&lt;p&gt;但是，当使用 Java 编程时，开发者经常犯这类错误。到目前为止，有大量研究表明它们是如何发生的。结果表明，大多数情况下，我们的 API 函数不应该返回 null，其他开发者也并不希望返回 null。在一些特殊情况下，比如缺省值，Java 中的惯例是返回一些 “空对象”（空集合，未填充的对象等等），或者抛出异常，比返回 null 更糟糕。这就是为什么要设计 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-&quot;&gt;&lt;code&gt;Files.newDirectoryStream&lt;/code&gt;&lt;/a&gt;, 高级版本的 &lt;code&gt;File.list&lt;/code&gt;，任何情况都不会出现 null。&lt;/p&gt;
&lt;p&gt;所以当 null 在一些特殊情况下作为函数返回值时，如性能优化，未初始化的引用字段等等，它常常会让你措手不及，没有做好准备去处理它。不仅仅是必须处理空值的情况很少，而且在 Java 中用来处理空值的代码是很啰嗦的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String[] list = new File(&quot;directory&quot;).list();
if (list != null) {
    for (String name : list) {
        System.out.println(name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;毫无疑问，除非真的需要（你的客户在生产环境发现了 NPE），不然你真的不想写这样的代码。&lt;/p&gt;
&lt;p&gt;对 null 的恐惧导致了一些极端情况。有一些 Java 编码风格完全禁止 null，将可恶的工作交给开发者。不知道你有没有见过这样的 Java 类库，所有的域对象都要实现一个特殊的 &lt;code&gt;Null&lt;/code&gt; 接口，并且提供手动编码生成的 “空对象” 实例。如果没有见过说明你还是幸运的。但是我敢打赌你已经看到了只为了避免空值而污染 Java 代码的 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional &amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; 包装器（译者注：Java 8 新特性）。&lt;/p&gt;
&lt;p&gt;有些集合框架的 API 出于谨慎禁止 null 元素，并且一些 Java 核心团队成员认为 Java 集合框架对 null 的支持是一个错误。这让人非常难过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事实上，null 这个概念不是一个错误，但是 Java 的类型系统认为 null 是任何类型的成员。&lt;/strong&gt; 让我们看看，在 Java 中 &lt;code&gt;“abc”&lt;/code&gt; 是一个合法的 &lt;code&gt;String&lt;/code&gt;，&lt;code&gt;null&lt;/code&gt; 也是一个合法的 &lt;code&gt;String&lt;/code&gt;。你可以在前者上使用 string 的所有方法，例如 &lt;code&gt;substring&lt;/code&gt;。但是在后者上使用则会发生运行时错误。它是类型安全的吗？并不完全是。一个类型的特定值在进行某些操作时发生运行时异常（例如除 0）是正常的，但是当对一个值进行该类型的所有操作都发生了异常，这首先表明的是这个值并不属于这个类型。所有的那些 NPE 都表明了 Java 的类型系统存在明显的缺陷。&lt;/p&gt;
&lt;p&gt;更多的类型安全的编程语言，例如 Kotlin，通过合理的将 null 的概念合并到类型系统中来修复这个缺陷。添加检查和警告也有一定作用，但这并不够。显然，一个健全的类型系统必须允许 &lt;code&gt;String&lt;/code&gt; 类型的所有变量都支持它的操作。所以在 Kotlin 中，将 &lt;code&gt;null&lt;/code&gt; 赋给 &lt;code&gt;String&lt;/code&gt; 类型的变量就不仅仅只是一个警告了，而是类型错误，就像把数值 &lt;code&gt;42&lt;/code&gt; 赋给 &lt;code&gt;String&lt;/code&gt; 类型变量一样。&lt;/p&gt;
&lt;p&gt;类型系统中合理的 null 支持是 API 设计的一个转折点，没有任何理由再去害怕 null 了。一些函数返回可空类型 &lt;code&gt;String?&lt;/code&gt;，另一些函数返回不可空类型 &lt;code&gt;String&lt;/code&gt;，就和一些函数返回 &lt;code&gt;String&lt;/code&gt;，另一些返回 &lt;code&gt;Int&lt;/code&gt; 一样。它们都是不同的类型，有着不同但是安全的操作集。&lt;/p&gt;
&lt;p&gt;用类型安全的 null 来表示 “缺失的值” 是更好，更高效，更简洁的。看一下 Kotlin 标准库中的 &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int-or-null.html&quot;&gt;&lt;code&gt;String.toIntOrNull()&lt;/code&gt;&lt;/a&gt; 函数，用于将 string 转为数字，不能转换的话返回 null。使用起来很愉快，编写一个命令行程序，接受 integer 参数并处理参数的缺失就很简单：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;) {
    val id = args.getOrNull(0)?.toIntOrNull() 
        ?: error(&quot;id expected&quot;)
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 API 设计中使用 null 吧，它是你和 Kotlin 的好朋友。没有理由去害怕它，也没有理由使用 &lt;code&gt;null object&lt;/code&gt; 模式或者包装器来处理它，更不用说异常了。在你的 API 中合理使用 null 会给你带来更可读，更安全的代码，并且远离样板代码。&lt;/p&gt;
&lt;h2 id=&quot;深入阅读&quot;&gt;深入阅读&lt;/h2&gt;
&lt;p&gt;如果你喜欢这个主题，并且想了解更多关于语言设计的细节，那么可以考虑阅读这篇文章—— &lt;a href=&quot;https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903&quot;&gt;Dealing with absence of value&lt;/a&gt; 。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;文章首发微信公众号： &lt;strong&gt;&lt;code&gt;秉心说&lt;/code&gt;&lt;/strong&gt; ， 专注 Java 、 Android 原创知识分享，LeetCode 题解。&lt;/p&gt;
&lt;p&gt;更多最新原创文章，扫码关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201909/800205-20190918225026641-586535010.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 14:50:00 +0000</pubDate>
<dc:creator>秉心说</dc:creator>
<og:description>原文作者： 'Roman Elizarov' 原文地址： 'Null is your firend, not a mistake' 译者：秉心说 'Kotlin Island from Wikimed</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingxinshuo/p/11546151.html</dc:identifier>
</item>
<item>
<title>对象的构造与析构（二） - 原野追逐</title>
<link>http://www.cnblogs.com/songhe364826110/p/11546138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songhe364826110/p/11546138.html</guid>
<description>&lt;ul&gt;&lt;li&gt;C++的类中可以定义一个特殊的清理函数，叫做析构函数，语法规则为&lt;code&gt;~ClassName()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;析构函数没有参数，也没有返回值类型声明&lt;/li&gt;
&lt;li&gt;析构函数在对象销毁时自动被调用&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当类中自定义了构造函数，并且构造函数中使用了系统资源（如：堆空间、文件打开，等），则需要自定义析构函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;多个对象之间&quot;&gt;多个对象之间&lt;/h2&gt;
&lt;p&gt;多个对象构造时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;栈对象的构造顺序依赖于程序的执行流&lt;/li&gt;
&lt;li&gt;堆对象的构造顺序依赖于new的使用顺序&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全局对象的构造顺序是不确定的，&lt;/span&gt;不同的编译器可能使用不同的规则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多个对象析构时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;栈对象和全局对象的析构顺序与构造顺序相反&lt;/li&gt;
&lt;li&gt;堆对象的析构发生取决于delete的使用顺序&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;单个对象内部&quot;&gt;单个对象内部&lt;/h2&gt;
&lt;p&gt;单个对象创建时，对象内部构造函数的调用顺序为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;先调用父类的构造函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;再调用成员变量的构造函数，&lt;/span&gt;调用顺序与声明顺序相同&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最后调用类自身的构造函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单个对象内部的析构顺序与构造顺序相反。&lt;/p&gt;

&lt;h2 id=&quot;const对象&quot;&gt;const对象&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;由const关键字修饰的对象为只读对象&lt;/li&gt;
&lt;li&gt;只读对象的成员变量不允许被改变&lt;/li&gt;
&lt;li&gt;只读属性只在编译阶段有效，运行时无效&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;const成员函数&quot;&gt;const成员函数&lt;/h2&gt;
&lt;p&gt;const成员函数的定义如下所示，需要注意的是，&lt;span&gt;函数声明和函数定义都必须带const关键字。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Type ClassName :: func(Type para) const&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于const成员函数的使用，有下面几条规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;const对象只能调用const成员函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;const成员函数只能调用const成员函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;const成员函数不能直接修改成员变量的值&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

class Test
{
    int mi;
public:
    Test(int i);
    void setMi(int i) const;
    int getMi() const;
    void printMi();
};

Test::Test(int i)
{
    mi = i;
}

void Test::setMi(int i) const
{
    mi = i;  //Error，const成员函数中不能直接修改成员变量的值
}

int Test::getMi() const
{
    return mi;
}

void Test::printMi()
{
    printf(&quot;printMi(): mi = %d\n&quot;, mi);
}

int main()
{
    const Test t1(1);

    t1.getMi();    //OK，const对象调用const成员函数
    t1.printMi();  //Error，const对象调用普通成员函数

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;从&lt;span&gt;面向对象&lt;/span&gt;的角度，对象由&lt;span&gt;属性（成员变量）&lt;/span&gt;和&lt;span&gt;方法（成员函数）&lt;/span&gt;构成；&lt;br/&gt;从&lt;span&gt;程序运行&lt;/span&gt;的角度，对象由&lt;span&gt;数据&lt;/span&gt;和&lt;span&gt;函数&lt;/span&gt;构成，数据位于栈、堆或全局数据区，函数位于代码段。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;每一个对象都拥有自己独立的属性（成员变量）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有的对象共享类的方法（成员函数）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;方法能够直接访问对象的属性&lt;/li&gt;
&lt;li&gt;方法中的隐藏参数this指针用于值代当前对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

class Test
{
    int mi;
public:
    int mj;
    Test(int i);
    Test(const Test &amp;amp;t);
    int getMi();
    void print();
};

Test::Test(int i)
{
    mi = i;
}

Test::Test(const Test &amp;amp;t)
{
    mi = t.mi;  //成员函数可以直接访问对应类对象的成员变量
}

int Test::getMi()
{
    return mi;
}

void Test::print()
{
    printf(&quot;this = %p\n&quot;, this);  //每个成员函数中隐藏了一个this指针，用于指向当前对象
}

int main()
{
    Test t1(1);
    Test t2(2);
    Test t3(3);

    printf(&quot;t1.getMi() = %d\n&quot;, t1.getMi());
    printf(&quot;&amp;amp;t1 = %p\n&quot;, &amp;amp;t1);
    t1.print();

    printf(&quot;t2.getMi() = %d\n&quot;, t2.getMi());
    printf(&quot;&amp;amp;t2 = %p\n&quot;, &amp;amp;t2);
    t2.print();

    printf(&quot;t3.getMi() = %d\n&quot;, t3.getMi());
    printf(&quot;&amp;amp;t3 = %p\n&quot;, &amp;amp;t3);
    t3.print();

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201909/1053346-20190918224250808-1260321304.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;intarray.h&quot;&gt;IntArray.h&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#ifndef _INTARRAY_H_
#define _INTARRAY_H_

class IntArray
{
private:
    int m_length;
    int *m_pointer;
public:
    IntArray(int len);
    IntArray(const IntArray &amp;amp;obj);
    int length();
    bool get(int index, int &amp;amp;value);
    bool set(int index ,int value);
    ~IntArray();
};

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;intarray.cpp&quot;&gt;IntArray.cpp&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;IntArray.h&quot;

IntArray::IntArray(int len)
{
    m_pointer = new int[len];

    for(int i=0; i&amp;lt;len; i++)
    {
        m_pointer[i] = 0;
    }

    m_length = len;
}

IntArray::IntArray(const IntArray &amp;amp;obj)
{
    m_length = obj.m_length;

    m_pointer = new int[obj.m_length];

    for(int i = 0; i &amp;lt; obj.m_length; i++)
    {
        m_pointer[i] = obj.m_pointer[i];
    }
}

int IntArray::length()
{
    return m_length;
}

bool IntArray::get(int index, int &amp;amp;value)
{
    bool ret = (0 &amp;lt;= index) &amp;amp;&amp;amp; (index &amp;lt; length());

    if( ret )
    {
        value = m_pointer[index];
    }

    return ret;
}

bool IntArray::set(int index, int value)
{
    bool ret = (0 &amp;lt;= index) &amp;amp;&amp;amp; (index &amp;lt; length());

    if( ret )
    {
        m_pointer[index] = value;
    }

    return ret;
}

IntArray::~IntArray()
{
    delete[] m_pointer;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;intarray测试&quot;&gt;IntArray测试&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;IntArray.h&quot;
#include &amp;lt;stdio.h&amp;gt;

int main()
{
    IntArray a(5);

    for(int i = 0; i &amp;lt; a.length(); i++)
    {
        a.set(i, i + 1);
    }

    for(int i = 0; i &amp;lt; a.length(); i++)
    {
        int value = 0;

        if( a.get(i, value) )
        {
            printf(&quot;a[%d] = %d\n&quot;, i, value);
        }
    }

    IntArray b = a;

    for(int i = 0; i &amp;lt; b.length(); i++)
    {
        int value = 0;

        if( b.get(i, value) )
        {
            printf(&quot;b[%d] = %d\n&quot;, i, value);
        }
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201909/1053346-20190918224443375-1135899504.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 14:46:00 +0000</pubDate>
<dc:creator>原野追逐</dc:creator>
<og:description>[TOC] 1. 析构函数 C++的类中可以定义一个特殊的清理函数，叫做析构函数，语法规则为 析构函数没有参数，也没有返回值类型声明 析构函数在对象销毁时自动被调用 当类中自定义了构造函数，并且构造函</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songhe364826110/p/11546138.html</dc:identifier>
</item>
<item>
<title>LVM（逻辑卷管理） - cloudos</title>
<link>http://www.cnblogs.com/cloudos/p/9348315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudos/p/9348315.html</guid>
<description>&lt;p&gt;LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。&lt;br/&gt;LVM的工作原理其实很简单，它就是通过将底层的物理硬盘抽象的封装起来，然后以逻辑卷的方式呈现给上层应用。在传统的磁盘管理机制中，我们的上层应用是直接访问文件系统，从而对底层的物理硬盘进行读取，而在LVM中，其通过对底层的硬盘进行封装，当我们对底层的物理硬盘进行操作时，其不再是针对于分区进行操作，而是通过一个叫做逻辑卷的东西来对其进行底层的磁盘管理操作。比如说我增加一个物理硬盘，这个时候上层的服务是感觉不到的，因为呈现给上层服务的是以逻辑卷的方式。&lt;br/&gt;LVM最大的特点就是可以对磁盘进行动态管理。因为逻辑卷的大小是可以动态调整的，而且不会丢失现有的数据。如果我们新增加了硬盘，其也不会改变现有上层的逻辑卷。作为一个动态磁盘管理机制，逻辑卷技术大大提高了磁盘管理的灵活性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PV&lt;/strong&gt;（Physical Volume）- 物理卷&lt;br/&gt;物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘。&lt;br/&gt;&lt;strong&gt;VG&lt;/strong&gt;（Volumne Group）-卷组&lt;span&gt;&lt;br/&gt;&lt;/span&gt;卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。&lt;br/&gt;&lt;strong&gt;LV&lt;/strong&gt;（Logical Volume）- 逻辑卷&lt;br/&gt;逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PE&lt;/strong&gt;（Physical Extent）：每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;LE&lt;/strong&gt;（Logical Extent）：逻辑卷也被划分为被称为LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span id=&quot;Label3&quot;&gt;如下图所示PV、VG、LV三者关系：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1121174/201807/1121174-20180721222325528-1055457585.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;    &lt;span&gt;    pvcreate、pvs 、pvdisplay 、pvremove、pvmove、pvscan&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;VG：Volume Group(卷组)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;  vgcreate、vgs、vgdisplay、vgremove、vgrename、vgreduce、vgextent、vgscan&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;LV：logical Volume(逻辑卷&lt;/span&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         lvcreate、lvs、lvdisplay、lvremove、lvextend、lvresize、lvscan、lvrename&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、虚拟机新增两块磁盘&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;ESXI线添加虚拟磁盘，fdisk -l没发现，一般情况下重启服务器就可以。但是不能影响业务，为什么新增磁盘或磁盘扩容后，Linux系统识别不到呢？因为连接存储设备的SCSI总线需要重新扫描，才能识别到这些新的存储设备&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# &lt;span&gt;ls&lt;/span&gt; /sys/class/scsi_host/          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定主机总线SCSI总线号    &lt;/span&gt;
&lt;span&gt;host0  host1  host2
[root@Node1 &lt;/span&gt;~]#  &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;- - -&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /sys/class/scsi_host/host0/scan   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新扫描 SCSI总线添加磁盘&lt;/span&gt;
[root@Node1 ~]#  &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;- - -&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /sys/class/scsi_host/host1/&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;
[root@Node1 &lt;/span&gt;~]#  &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;- - -&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /sys/class/scsi_host/host2/&lt;span&gt;scan
[root@Node1 &lt;/span&gt;~]# fdisk -l | &lt;span&gt;grep&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^Disk /dev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查硬盘是否在线&lt;/span&gt;
Disk /dev/sda: &lt;span&gt;53.7&lt;/span&gt; GB, &lt;span&gt;53687091200&lt;/span&gt; bytes, &lt;span&gt;104857600&lt;/span&gt;&lt;span&gt; sectors
Disk &lt;/span&gt;/dev/sdb: &lt;span&gt;21.5&lt;/span&gt; GB, &lt;span&gt;21474836480&lt;/span&gt; bytes, &lt;span&gt;41943040&lt;/span&gt;&lt;span&gt; sectors
Disk &lt;/span&gt;/dev/sdc: &lt;span&gt;32.2&lt;/span&gt; GB, &lt;span&gt;32212254720&lt;/span&gt; bytes, &lt;span&gt;62914560&lt;/span&gt;&lt;span&gt; sectors
[root@Node1 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2、用fidsk分别对/dev/sdb与/dev/sdc进行分区&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# fdisk  /dev/&lt;span&gt;sdb   &lt;span&gt;//对/dev/sdb进行分区&lt;/span&gt;
Welcome to fdisk (util&lt;/span&gt;-linux &lt;span&gt;2.23&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)

Changes will remain &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; memory only, until you decide to write them.
Be careful before &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; the write command.

Device does not contain a recognized partition table
Building a &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DOS disklabel with disk identifier &lt;span&gt;0xafcc8a41&lt;/span&gt;&lt;span&gt;.

Command (m &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): n
Partition type:
   p   primary (&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; primary, &lt;span&gt;0&lt;/span&gt; extended, &lt;span&gt;4&lt;/span&gt;&lt;span&gt; free)
   e   extended
Select (&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; p): p&lt;span&gt; //主分区&lt;/span&gt;
Partition number (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;): &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
First sector (&lt;/span&gt;&lt;span&gt;2048&lt;/span&gt;-&lt;span&gt;41943039&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;2048&lt;/span&gt;&lt;span&gt;): 
Using &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; value &lt;span&gt;2048&lt;/span&gt;&lt;span&gt;
Last sector, &lt;/span&gt;+sectors or +size{K,M,G} (&lt;span&gt;2048&lt;/span&gt;-&lt;span&gt;41943039&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;41943039&lt;/span&gt;): +&lt;span&gt;10G  
Partition &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; of type Linux and of size &lt;span&gt;10&lt;/span&gt; GiB &lt;span&gt;is&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;

Command (m &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): t   
Selected partition &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Hex code (type L to list all codes): 8e    
Changed type of partition &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linux LVM&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

Command (m &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): n
Partition type:
   p   primary (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; primary, &lt;span&gt;0&lt;/span&gt; extended, &lt;span&gt;3&lt;/span&gt;&lt;span&gt; free)
   e   extended
Select (&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; p): p
Partition number (&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;): &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
First sector (&lt;/span&gt;&lt;span&gt;20973568&lt;/span&gt;-&lt;span&gt;41943039&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;20973568&lt;/span&gt;&lt;span&gt;): 
Using &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; value &lt;span&gt;20973568&lt;/span&gt;&lt;span&gt;
Last sector, &lt;/span&gt;+sectors or +size{K,M,G} (&lt;span&gt;20973568&lt;/span&gt;-&lt;span&gt;41943039&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;41943039&lt;/span&gt;&lt;span&gt;): 
Using &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; value &lt;span&gt;41943039&lt;/span&gt;&lt;span&gt;
Partition &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; of type Linux and of size &lt;span&gt;10&lt;/span&gt; GiB &lt;span&gt;is&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;

Command (m &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): t
Partition number (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;): &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Hex code (type L to list all codes): 8e
Changed type of partition &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linux LVM&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

Command (m &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): w
The partition table has been altered&lt;/span&gt;!&lt;span&gt;

Calling ioctl() to re&lt;/span&gt;-&lt;span&gt;read partition table.
Syncing disks.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、partprobe让内核重新识别分区表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]#&lt;span&gt;partprobe /dev/sd{b,c}
&lt;/span&gt;&lt;span&gt;[root@Node1 ~]# partx -a /dev/sdc&lt;br/&gt;&lt;span&gt;[root@Node1 ~]# partx -s /dev/sdc&lt;/span&gt;
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;cat&lt;/span&gt; /proc/&lt;span&gt;partitions   &lt;span&gt;//查看分区信息表&lt;/span&gt;
major minor  #blocks  name

   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;   &lt;span&gt;52428800&lt;/span&gt;&lt;span&gt; sda
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;1&lt;/span&gt;     &lt;span&gt;204800&lt;/span&gt;&lt;span&gt; sda1
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;2&lt;/span&gt;   &lt;span&gt;20971520&lt;/span&gt;&lt;span&gt; sda2
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;3&lt;/span&gt;   &lt;span&gt;20971520&lt;/span&gt;&lt;span&gt; sda3
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;4&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;&lt;span&gt; sda4
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;5&lt;/span&gt;    &lt;span&gt;5242880&lt;/span&gt;&lt;span&gt; sda5
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;6&lt;/span&gt;    &lt;span&gt;2097152&lt;/span&gt;&lt;span&gt; sda6
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;7&lt;/span&gt;    &lt;span&gt;2936832&lt;/span&gt;&lt;span&gt; sda7
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;       &lt;span&gt;16&lt;/span&gt;   &lt;span&gt;20971520&lt;/span&gt;&lt;span&gt; sdb
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;       &lt;span&gt;17&lt;/span&gt;   &lt;span&gt;10485760&lt;/span&gt;&lt;span&gt; sdb1
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;       &lt;span&gt;18&lt;/span&gt;   &lt;span&gt;10484736&lt;/span&gt;&lt;span&gt; sdb2
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;       &lt;span&gt;32&lt;/span&gt;   &lt;span&gt;31457280&lt;/span&gt;&lt;span&gt; sdc
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;       &lt;span&gt;33&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt;&lt;span&gt; sdc1
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;       &lt;span&gt;37&lt;/span&gt;   &lt;span&gt;20971520&lt;/span&gt;&lt;span&gt; sdc5
   &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;       &lt;span&gt;38&lt;/span&gt;   &lt;span&gt;10482688&lt;/span&gt;&lt;span&gt; sdc6
  &lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;    &lt;span&gt;4415488&lt;/span&gt;&lt;span&gt; sr0
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;ls&lt;/span&gt; /dev/sdb*    &lt;span&gt; //查看/dev/sdb分区情况&lt;/span&gt;
/dev/sdb  /dev/sdb1  /dev/&lt;span&gt;sdb2
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;ls&lt;/span&gt; /dev/sdc*     &lt;span&gt;//查看/dev/sdc分区情况&lt;/span&gt;
/dev/sdc  /dev/sdc1  /dev/sdc5  /dev/sdc6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、验证磁盘分区结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# fdisk -l | &lt;span&gt;grep&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LVM$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
/dev/sdb1            &lt;span&gt;2048&lt;/span&gt;    &lt;span&gt;20973567&lt;/span&gt;    &lt;span&gt;10485760&lt;/span&gt;&lt;span&gt;   8e  Linux LVM
&lt;/span&gt;/dev/sdb2        &lt;span&gt;20973568&lt;/span&gt;    &lt;span&gt;41943039&lt;/span&gt;    &lt;span&gt;10484736&lt;/span&gt;&lt;span&gt;   8e  Linux LVM
&lt;/span&gt;/dev/sdc5            &lt;span&gt;4096&lt;/span&gt;    &lt;span&gt;41947135&lt;/span&gt;    &lt;span&gt;20971520&lt;/span&gt;&lt;span&gt;   8e  Linux LVM
&lt;/span&gt;/dev/sdc6        &lt;span&gt;41949184&lt;/span&gt;    &lt;span&gt;62914559&lt;/span&gt;    &lt;span&gt;10482688&lt;/span&gt;   8e  Linux LVM 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、安装LVM&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# &lt;span&gt;cat&lt;/span&gt; /etc/system-release     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看系统版本&lt;/span&gt;
CentOS Linux release &lt;span&gt;7.6&lt;/span&gt;.&lt;span&gt;1810&lt;/span&gt;&lt;span&gt; (Core)
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; lvm2         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;安装LVM包&lt;/span&gt;
[root@Node1 ~]# rpm -qa | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; lvm
llvm&lt;/span&gt;-private-&lt;span&gt;6.0&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64
lvm2&lt;/span&gt;-&lt;span&gt;2.02&lt;/span&gt;.&lt;span&gt;180&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;.el7_6.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.x86_64
lvm2&lt;/span&gt;-libs-&lt;span&gt;2.02&lt;/span&gt;.&lt;span&gt;180&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;.el7_6.&lt;span&gt;8&lt;/span&gt;.x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、PV物理卷常用操作&lt;span id=&quot;Label3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;span&gt;       &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;pvcreate /dev/DEVICE: 创建PV&lt;br/&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;pvs：简要PV信息显示&lt;br/&gt;        pvdisplay：显示PV的详细信息&lt;br/&gt;        pvremove  /dev/DEVICE: 移除PV&lt;br/&gt;        pvscan: 扫描系统中连接的所有硬盘，列出找到的物理卷列表&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# pvcreate /dev/sdb{&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;}       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建2个物理卷pv&lt;/span&gt;
  Physical volume &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/sdb1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully created.
  Physical volume &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/sdb2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully created.
[root@Node1 &lt;/span&gt;~]# pvs                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看物理卷摘要信息&lt;/span&gt;
&lt;span&gt;  PV         VG Fmt  Attr PSize   PFree  
  &lt;/span&gt;/dev/sdb1     lvm2 ---   &lt;span&gt;10&lt;/span&gt;.00g  &lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
  &lt;/span&gt;/dev/sdb2     lvm2 ---  &amp;lt;&lt;span&gt;10&lt;/span&gt;.00g &amp;lt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# pvscan                     &lt;span&gt;//搜索已存在的物理卷&lt;/span&gt;
  PV &lt;/span&gt;/dev/sdb2                      lvm2 [&amp;lt;&lt;span&gt;10.00&lt;/span&gt;&lt;span&gt; GiB]
  PV &lt;/span&gt;/dev/sdb1                      lvm2 [&lt;span&gt;10.00&lt;/span&gt;&lt;span&gt; GiB]
  Total: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; [&amp;lt;&lt;span&gt;20.00&lt;/span&gt; GiB] / &lt;span&gt;in&lt;/span&gt; use: &lt;span&gt;0&lt;/span&gt; [&lt;span&gt;0&lt;/span&gt;   ] / &lt;span&gt;in&lt;/span&gt; no VG: &lt;span&gt;2&lt;/span&gt; [&amp;lt;&lt;span&gt;20.00&lt;/span&gt;&lt;span&gt; GiB]
[root@Node1 &lt;/span&gt;~]# pvremove  /dev/sdb2         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除/dev/sdb2&lt;/span&gt;
  Labels on physical volume &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/sdb2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully wiped.
[root@Node1 &lt;/span&gt;~]# pvdisplay  /dev/sdb1       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示详细的物理卷信息&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/sdb1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; is a new physical volume of &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10.00 GiB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  --- NEW Physical volume ---&lt;span&gt;
  PV Name               &lt;/span&gt;/dev/&lt;span&gt;sdb1
  VG Name               
  PV Size               &lt;/span&gt;&lt;span&gt;10.00&lt;/span&gt;&lt;span&gt; GiB
  Allocatable           NO
  PE Size               &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;   
  Total PE              &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Free PE               &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Allocated PE          &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  PV UUID               k6YMJN&lt;/span&gt;-BfTI-DL8G-qjEr-onjT-CmDK-IzC9vB&lt;br/&gt;[root@Node1 ~]# pvcreate /dev/sdb2        // 将/dev/sdb2加入物理卷&lt;br/&gt;Physical volume &quot;/dev/sdb2&quot; successfully created.  &lt;br/&gt;[root@Node1 ~]# pvs -o +pv_uuid&lt;br/&gt;PV         VG     Fmt  Attr PSize   PFree   PV UUID                               &lt;br/&gt;/dev/sdb1  datavg lvm2 a--  &amp;lt;10.00g &amp;lt;10.00g GX3Clm-pGDv-4xtw-VIr3-x00m-vIlD-zPOooJ&lt;br/&gt;/dev/sdb2  datavg lvm2 a--  &amp;lt;10.00g &amp;lt;10.00g zuMtAt-6S6z-3vDa-xnj2-WADw-hk0s-H9V1Wi&lt;br/&gt;/dev/sdc5  datavg lvm2 a--  &amp;lt;10.00g &amp;lt;10.00g orxgvl-GKbn-LMN0-YOUY-mIGA-TqJp-g1V8iv  &lt;br/&gt;[root@Node1 ~]# pvs -v
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、VG常用操作&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span id=&quot;Label3&quot;&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;vgcreate&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span id=&quot;Label3&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;/dev/DEVICE: 创建VG卷组&lt;br/&gt;        vgs: &lt;span&gt;简要VG信息显示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;Label3&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;     &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span id=&quot;Label3&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   vgextend：动态扩展LVM卷组，它通过向卷组中添加物理卷来增加卷组的容量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span id=&quot;Label3&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        vgreduce：通过删除LVM卷组中的物理卷来减少卷组容量，不能删除LVM卷组中剩余的最后一个物理卷&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;Label3&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;        vgdisplay：显示VG的详细信息&lt;br/&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; vgscan：查找系统中存在的LVM卷组，并显示找到的卷组列表&lt;br/&gt;        vgremove：删除卷组，其上的逻辑卷必须处于离线状态&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# vgcreate datavg /dev/sdb{&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;}    &lt;span&gt; //创建datavg卷组  &lt;/span&gt;
  Volume group &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datavg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully created
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgdisplay datavg          &lt;span&gt;&lt;span&gt; //显示datavg详细信息，也可以使用vgdisplay -vv或vgdisplay -vvv命令&lt;/span&gt;&lt;/span&gt;       &lt;/span&gt;--- Volume group ---&lt;span&gt;
  VG Name               datavg
  System ID             
  Format                lvm2
  Metadata Areas        &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  Metadata Sequence No  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  VG Access             read&lt;/span&gt;/&lt;span&gt;write&lt;/span&gt;&lt;span&gt;
  VG Status             resizable
  MAX LV                &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Cur LV                &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Open LV               &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Max PV                &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Cur PV                &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  Act PV                &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  VG Size               &lt;/span&gt;&lt;span&gt;19.99&lt;/span&gt;&lt;span&gt; GiB
  PE Size               &lt;/span&gt;&lt;span&gt;4.00&lt;/span&gt;&lt;span&gt; MiB
  Total PE              &lt;/span&gt;&lt;span&gt;5118&lt;/span&gt;&lt;span&gt;
  Alloc PE &lt;/span&gt;/ Size       &lt;span&gt;0&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;&lt;span&gt;   
  Free  PE &lt;/span&gt;/ Size       &lt;span&gt;5118&lt;/span&gt; / &lt;span&gt;19.99&lt;/span&gt;&lt;span&gt; GiB
  VG UUID               thDWMH&lt;/span&gt;-ZXq6-zJP5-LtTn-xmQh-OpG5-&lt;span&gt;b3qrUu
   
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgs       &lt;span&gt;//显示VG的简要信息&lt;/span&gt;
  VG     #PV #LV #SN Attr   VSize  VFree 
  datavg   &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; wz--n- &lt;span&gt;19&lt;/span&gt;.99g &lt;span&gt;19&lt;/span&gt;&lt;span&gt;.99g
[root@Node1 &lt;/span&gt;~]# vgextend datavg  /dev/&lt;span&gt;sdc5    &lt;span&gt;//向datavg卷组中添加物理卷&lt;/span&gt;
  Physical volume &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/sdc5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully created.
  Volume group &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datavg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully extended
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# pvs
  PV         VG     Fmt  Attr PSize   PFree  
  &lt;/span&gt;/dev/sdb1  datavg lvm2 a--  &amp;lt;&lt;span&gt;10&lt;/span&gt;.00g &amp;lt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
  &lt;/span&gt;/dev/sdb2  datavg lvm2 a--  &amp;lt;&lt;span&gt;10&lt;/span&gt;.00g &amp;lt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
  &lt;/span&gt;/dev/sdc5  datavg lvm2 a--  &amp;lt;1&lt;span&gt;0&lt;/span&gt;.00g &amp;lt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgs
  VG     #PV #LV #SN Attr   VSize   VFree  
  datavg   &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; wz--n- &amp;lt;&lt;span&gt;29&lt;/span&gt;.99g &amp;lt;&lt;span&gt;29&lt;/span&gt;&lt;span&gt;.99g
[root@Node1 &lt;/span&gt;~]# vgreduce datavg /dev/&lt;span&gt;sdc5  &lt;span&gt;&lt;span&gt;//从datavg卷组中移除物理卷&lt;/span&gt;&lt;/span&gt;
  Removed &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/sdc5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; from volume group &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datavg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgs
  VG     #PV #LV #SN Attr   VSize  VFree 
  datavg   &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; wz--n- &lt;span&gt;19&lt;/span&gt;.99g &lt;span&gt;19&lt;/span&gt;&lt;span&gt;.99g
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# pvs
  PV         VG     Fmt  Attr PSize   PFree  
  &lt;/span&gt;/dev/sdb1  datavg lvm2 a--  &amp;lt;&lt;span&gt;10&lt;/span&gt;.00g &amp;lt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
  &lt;/span&gt;/dev/sdb2  datavg lvm2 a--  &amp;lt;&lt;span&gt;10&lt;/span&gt;.00g &amp;lt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
  &lt;/span&gt;/dev/sdc5         lvm2 ---   &lt;span&gt;20&lt;/span&gt;.00g  &lt;span&gt;20&lt;/span&gt;&lt;span&gt;.00g
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgremove datavg       &lt;span&gt;//移除datavg&lt;/span&gt;
  Volume group &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datavg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully removed&lt;/span&gt;&lt;span&gt;.
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgs
[root@Node1 &lt;/span&gt;~]# vgcreate datavg /dev/sdb{&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;}
  Volume group &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datavg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully created
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgdisplay datavg 
  &lt;/span&gt;--- Volume group ---&lt;span&gt;
  VG Name               datavg
  System ID             
  Format                lvm2
  Metadata Areas        &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  Metadata Sequence No  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  VG Access             read&lt;/span&gt;/&lt;span&gt;write&lt;/span&gt;&lt;span&gt;
  VG Status             resizable
  MAX LV                &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Cur LV                &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Open LV               &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Max PV                &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  Cur PV                &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  Act PV                &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  VG Size               &lt;/span&gt;&lt;span&gt;19.99&lt;/span&gt;&lt;span&gt; GiB
  PE Size               &lt;/span&gt;&lt;span&gt;4.00&lt;/span&gt;&lt;span&gt; MiB
  Total PE              &lt;/span&gt;&lt;span&gt;5118&lt;/span&gt;&lt;span&gt;
  Alloc PE &lt;/span&gt;/ Size       &lt;span&gt;0&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;&lt;span&gt;   
  Free  PE &lt;/span&gt;/ Size       &lt;span&gt;5118&lt;/span&gt; / &lt;span&gt;19.99&lt;/span&gt;&lt;span&gt; GiB
  VG UUID               T8c1W9&lt;/span&gt;-xpJF-vvnS-bm5y-gqmY-5RBK-&lt;span&gt;wRkD9Y
   
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgs
  VG     #PV #LV #SN Attr   VSize  VFree 
  datavg   &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; wz--n- &lt;span&gt;19&lt;/span&gt;.99g &lt;span&gt;19&lt;/span&gt;&lt;span&gt;.99g
[root@Node1 &lt;/span&gt;~]# vgextend datavg  /dev/&lt;span&gt;sdc5
  Volume group &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datavg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully extended
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgs
  VG     #PV #LV #SN Attr   VSize   VFree  
  datavg   &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; wz--n- &amp;lt;&lt;span&gt;29&lt;/span&gt;.99g &amp;lt;&lt;span&gt;29&lt;/span&gt;&lt;span&gt;.99g
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# pvs
  PV         VG     Fmt  Attr PSize   PFree  
  &lt;/span&gt;/dev/sdb1  datavg lvm2 a--  &amp;lt;&lt;span&gt;10&lt;/span&gt;.00g &amp;lt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
  &lt;/span&gt;/dev/sdb2  datavg lvm2 a--  &amp;lt;&lt;span&gt;10&lt;/span&gt;.00g &amp;lt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.00g
  &lt;/span&gt;/dev/sdc5  datavg lvm2 a--  &amp;lt;1&lt;span&gt;0&lt;/span&gt;.00g &amp;lt;1&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00g&lt;br/&gt;[root@Node1 ~]# pvscan &lt;span&gt;  //扫描系统中连接的所有硬盘，列出找到的物理卷列表&lt;/span&gt;&lt;br/&gt;PV /dev/sdb1   VG datavg          lvm2 [&amp;lt;10.00 GiB / &amp;lt;10.00 GiB free]&lt;br/&gt;PV /dev/sdb2   VG datavg          lvm2 [&amp;lt;10.00 GiB / &amp;lt;10.00 GiB free]&lt;br/&gt;PV /dev/sdc5   VG datavg          lvm2 [&amp;lt;10.00 GiB / &amp;lt;10.00 GiB free]&lt;br/&gt;Total: 3 [&amp;lt;29.99 GiB] / in use: 3 [&amp;lt;29.99 GiB] / in no VG: 0 [0   ]&lt;br/&gt;[root@Node1 ~]# vgscan   &lt;span&gt;  //显示系统中所有卷组&lt;/span&gt;&lt;br/&gt;Reading volume groups from cache.&lt;br/&gt;Found volume group &quot;datavg&quot; using metadata type lvm2&lt;br/&gt;[root@Node1 ~]# vgs -o +pv_name&lt;br/&gt;VG     #PV #LV #SN Attr   VSize   VFree   PV        &lt;br/&gt;datavg   3   0   0 wz--n- &amp;lt;29.99g &amp;lt;29.99g /dev/sdb1 &lt;br/&gt;datavg   3   0   0 wz--n- &amp;lt;29.99g &amp;lt;29.99g /dev/sdb2 &lt;br/&gt;datavg   3   0   0 wz--n- &amp;lt;29.99g &amp;lt;29.99g /dev/sdc5 &lt;br/&gt;[root@Node1 ~]# vgs -v&lt;br/&gt;VG     Attr   Ext   #PV #LV #SN VSize   VFree   VG UUID                                VProfile&lt;br/&gt;datavg wz--n- 4.00m   3   0   0 &amp;lt;29.99g &amp;lt;29.99g 2b9qgs-mCb0-Isc2-Af74-5uWo-Yf8Q-4KOmns  &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、LV常用操作&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span id=&quot;Label3&quot;&gt;&lt;span&gt;         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;lvcreate : 用来创建LVM的逻辑卷&lt;br/&gt;               lvcreate -L #[mMgGtT] -n NAME VolumeGroup&lt;br/&gt;              用法：lvcreate [选项] [参数]&lt;br/&gt;  　　选项：&lt;br/&gt;   　　  -L：指定大小&lt;br/&gt;  　　   -l：指定大小（LE数）&lt;br/&gt;  　　   -n：指定名称&lt;br/&gt;   　　  -s：创建快照&lt;br/&gt;    　　 -p r：设置为只读（该选项一般用于创建快照中&lt;br/&gt;        lvs : 显示逻辑卷信息&lt;br/&gt;        lvscan：扫描当前系统中的所有逻辑卷，及其对应的设备文件&lt;br/&gt;        lvdisplay：显示逻辑卷属性&lt;br/&gt;        lvextend：可在线扩展逻辑卷空间&lt;br/&gt;        lvreduce：缩减逻辑卷空间，一般离线使用&lt;br/&gt;        lvremove：删除逻辑卷，需要处于离线（卸载）状态&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# lvcreate -L 5G -&lt;span&gt;n datalv datavg    &lt;span&gt;//创建datalv逻辑卷&lt;/span&gt;
  Logical volume &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datalv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; created.
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;ls&lt;/span&gt; /dev/mapper/&lt;span&gt;
control  datavg&lt;/span&gt;-&lt;span&gt;datalv
[root@Node1 &lt;/span&gt;~]# mkfs.xfs -L Backup /dev/datavg/&lt;span&gt;datalv  &lt;span&gt; //格式化逻辑卷&lt;/span&gt;
meta&lt;/span&gt;-data=/dev/datavg/datalv     isize=&lt;span&gt;512&lt;/span&gt;    agcount=&lt;span&gt;4&lt;/span&gt;, agsize=&lt;span&gt;327680&lt;/span&gt;&lt;span&gt; blks
         &lt;/span&gt;=                       sectsz=&lt;span&gt;512&lt;/span&gt;   attr=&lt;span&gt;2&lt;/span&gt;, projid32bit=&lt;span&gt;1&lt;/span&gt;
         =                       crc=&lt;span&gt;1&lt;/span&gt;        finobt=&lt;span&gt;0&lt;/span&gt;, sparse=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
data     &lt;/span&gt;=                       bsize=&lt;span&gt;4096&lt;/span&gt;   blocks=&lt;span&gt;1310720&lt;/span&gt;, imaxpct=&lt;span&gt;25&lt;/span&gt;
         =                       sunit=&lt;span&gt;0&lt;/span&gt;      swidth=&lt;span&gt;0&lt;/span&gt;&lt;span&gt; blks
naming   &lt;/span&gt;=version &lt;span&gt;2&lt;/span&gt;              bsize=&lt;span&gt;4096&lt;/span&gt;   ascii-ci=&lt;span&gt;0&lt;/span&gt; ftype=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
log      &lt;/span&gt;=internal log           bsize=&lt;span&gt;4096&lt;/span&gt;   blocks=&lt;span&gt;2560&lt;/span&gt;, version=&lt;span&gt;2&lt;/span&gt;
         =                       sectsz=&lt;span&gt;512&lt;/span&gt;   sunit=&lt;span&gt;0&lt;/span&gt; blks, lazy-count=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
realtime &lt;/span&gt;=none                   extsz=&lt;span&gt;4096&lt;/span&gt;   blocks=&lt;span&gt;0&lt;/span&gt;, rtextents=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[root@Node1 &lt;/span&gt;~]#  &lt;span&gt;mkdir&lt;/span&gt; /&lt;span&gt;dbbackup
[root@Node1 &lt;/span&gt;~]#  &lt;span&gt;mount&lt;/span&gt; /dev/mapper/datavg-datalv /dbbackup/  &lt;span&gt; //挂载至/dbbackup目录&lt;/span&gt;&lt;span&gt;
[root@Node1 &lt;/span&gt;~]#  &lt;span&gt;df&lt;/span&gt; -hT | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; datalv  &lt;span&gt;//查询datalv的挂载情况
&lt;/span&gt;&lt;/span&gt;/dev/mapper/datavg-datalv xfs       5G   33M  5G   &lt;span&gt;1&lt;/span&gt;% /&lt;span&gt;dbbackup
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# lvs  &lt;span&gt;//显示逻辑卷信息&lt;/span&gt;
  LV     VG     Attr       LSize  Pool Origin Data&lt;/span&gt;%  Meta%  Move Log Cpy%&lt;span&gt;Sync Convert
  datalv datavg &lt;/span&gt;-wi-ao---- &lt;span&gt;5&lt;/span&gt;&lt;span&gt;.00g                                                    
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# lvscan  &lt;span&gt;//扫描系统中的逻辑卷&lt;/span&gt;
  ACTIVE            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/dev/datavg/datalv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; [&lt;span&gt;5.00&lt;/span&gt;&lt;span&gt; GiB] inherit
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# lvdisplay &lt;span&gt; //显示逻辑卷详细信息
  &lt;/span&gt;&lt;/span&gt;--- Logical volume ---&lt;span&gt;
  LV Path                &lt;/span&gt;/dev/datavg/&lt;span&gt;datalv
  LV Name                datalv
  VG Name                datavg
  LV UUID                Y1P5zJ&lt;/span&gt;-Wy1Q-kERv-VUtC-4vAm-NsMb-&lt;span&gt;3aCy1y
  LV Write Access        read&lt;/span&gt;/&lt;span&gt;write&lt;/span&gt;&lt;span&gt;
  LV Creation host, &lt;/span&gt;&lt;span&gt;time&lt;/span&gt; Node1.contoso.com, &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;18&lt;/span&gt; &lt;span&gt;06&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;&lt;span&gt;
  LV Status              available
  # open                 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  LV Size                &lt;/span&gt;&lt;span&gt;5.00&lt;/span&gt;&lt;span&gt; GiB
  Current LE             &lt;/span&gt;&lt;span&gt;3840&lt;/span&gt;&lt;span&gt;
  Segments               &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  Allocation             inherit
  Read ahead sectors     auto
  &lt;/span&gt;- currently set to     &lt;span&gt;8192&lt;/span&gt;&lt;span&gt;
  Block device           &lt;/span&gt;&lt;span&gt;253&lt;/span&gt;:&lt;span&gt;0&lt;br/&gt;&lt;span&gt;[root@Node1 ~]# lvcreate -L 3G -n weblv datavg&lt;/span&gt;   &lt;span&gt;&lt;span&gt;//创建weblv逻辑卷&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;[root@Node1 ~]# mkfs.ext4 -L webapp /dev/datavg/weblv&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[root@Node1 ~]# mkdir /webapp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[root@Node1 ~]# mount /dev/mapper/datavg-weblv /webapp/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[root@Node1 ~]# df -hT | grep mapper&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/dev/mapper/datavg-datalv xfs        5G   33M   5G   1% /dbbackup&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/dev/mapper/datavg-weblv  ext4      2.9G  9.0M  2.8G   1% /webapp&lt;br/&gt;[root@Node1 ~]# lvs&lt;br/&gt;LV     VG     Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert&lt;br/&gt;datalv datavg -wi-ao----  5.00g                                                    &lt;br/&gt;weblv  datavg -wi-ao----  3.00g                                                    &lt;br/&gt;[root@Node1 ~]# lvscan&lt;br/&gt;ACTIVE            '/dev/datavg/datalv' [5.00 GiB] inherit&lt;br/&gt;ACTIVE            '/dev/datavg/weblv' [3.00 GiB] inherit&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、LVM逻辑卷的扩充与缩小&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;      lvextend：扩展逻辑卷空间&lt;br/&gt;             lvextend -L [+]#[mMgGtT] /dev/VG_NAME/LV_NAME&lt;br/&gt;       lvreduce：缩减逻辑卷空间&lt;br/&gt;          &lt;span&gt;&lt;strong&gt;缩减逻辑卷：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;            1、先确定缩减后的目标大小；并确保对应的目标逻辑卷大小中有足够的空间可容纳原有所有数据；&lt;br/&gt;            2、先卸载文件系统，并要执行强制检测  e2fsck -f&lt;br/&gt;            3、缩减逻辑边界 resize2fs DEVICE&lt;br/&gt;            4、缩减物理边界 lvreduce&lt;br/&gt;            5、新挂载 mount&lt;br/&gt;        &lt;span&gt;PS：缩减很危险，要离线操作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt; lvresize：扩展或缩小逻辑卷空间&lt;br/&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;strong&gt;&lt;span&gt;resize2fs&lt;/span&gt;&lt;/strong&gt;： 针对的是ext2、ext3、ext4文件系统&lt;br/&gt;                      &lt;span&gt;&lt;span&gt;调整ext2\ext3\ext4文件系统的大小，它可以放大或者缩小没有挂载的文件系统的大小。如果文件系统已经挂载，它可以扩大文件系统的大小，前提是内核支持在线调整大小。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;  &lt;/span&gt; &lt;strong&gt;&lt;span&gt;xfs_growfs&lt;/span&gt;&lt;/strong&gt;: 针对的是xfs文件系统&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;1）ext2/ext3/ext4文件系统的调整命令是resize2fs&lt;span&gt;（增大和减小都支持）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# lvextend -L 5G /dev/mapper/datavg-&lt;span&gt;weblv    &lt;span&gt;&lt;code class=&quot;bash plain&quot;&gt;//&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;增大至5G&lt;/code&gt;&lt;/span&gt;
[root@Node1 &lt;/span&gt;~]# lvextend -L +2G /dev/mapper/datavg-&lt;span&gt;weblv   &lt;span&gt;&lt;code class=&quot;bash plain&quot;&gt;//&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;增加2G&lt;/code&gt;&lt;/span&gt;
[root@Node1 &lt;/span&gt;~]# resize2fs /dev/mapper/datavg-&lt;span&gt;weblv      &lt;span&gt;//调整逻辑大小&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;df&lt;/span&gt; -hT | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; weblv                     &lt;span&gt;//由3G增大至5，又增加2G，目前7G
&lt;/span&gt;&lt;/span&gt;/dev/mapper/datavg-weblv  ext4      &lt;span&gt;6&lt;/span&gt;.9G   14M  &lt;span&gt;6&lt;/span&gt;.5G   &lt;span&gt;1&lt;/span&gt;% /&lt;span&gt;webapp     
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; /etc/&lt;span&gt;fstab . &lt;span&gt; //复制fstab命令至当前目录&lt;/span&gt;
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
fstab  lost&lt;/span&gt;+&lt;span&gt;found
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;umount&lt;/span&gt; -f /dev/mapper/datavg-&lt;span&gt;weblv  &lt;span&gt;//卸载/dev/mapper/datavg-weblv逻辑卷&lt;/span&gt;
[root@Node1 &lt;/span&gt;~]# e2fsck -f /dev/datavg/&lt;span&gt;weblv  &lt;span&gt; //检查ext2、ext3、ext4文件系统，如果系统已经挂载了，那么不建议去检查，因为这样是不安全的&lt;/span&gt;
e2fsck &lt;/span&gt;&lt;span&gt;1.42&lt;/span&gt;.&lt;span&gt;9&lt;/span&gt; (&lt;span&gt;28&lt;/span&gt;-Dec-&lt;span&gt;2013&lt;/span&gt;&lt;span&gt;)
Pass &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;: Checking inodes, blocks, and sizes
Pass &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: Checking directory structure
Pass &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: Checking directory connectivity
Pass &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;: Checking reference counts
Pass &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;: Checking group summary information
webapp: &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;/&lt;span&gt;458752&lt;/span&gt; files (&lt;span&gt;0.0&lt;/span&gt;% non-contiguous), &lt;span&gt;48640&lt;/span&gt;/&lt;span&gt;1835008&lt;/span&gt;&lt;span&gt; blocks
[root@Node1 &lt;/span&gt;~]# resize2fs /dev/datavg/&lt;span&gt;weblv 5G  &lt;span&gt;//调整至5G空间大小的逻辑卷&lt;/span&gt;
resize2fs &lt;/span&gt;&lt;span&gt;1.42&lt;/span&gt;.&lt;span&gt;9&lt;/span&gt; (&lt;span&gt;28&lt;/span&gt;-Dec-&lt;span&gt;2013&lt;/span&gt;&lt;span&gt;)
Resizing the filesystem on &lt;/span&gt;/dev/datavg/weblv to &lt;span&gt;1310720&lt;/span&gt;&lt;span&gt; (4k) blocks.
The filesystem on &lt;/span&gt;/dev/datavg/weblv is now &lt;span&gt;1310720&lt;/span&gt; blocks &lt;span&gt;long&lt;/span&gt;&lt;span&gt;.

[root@Node1 &lt;/span&gt;~]# lvreduce -L 5G /dev/datavg/&lt;span&gt;weblv  &lt;span&gt;&lt;span&gt;//缩减至5G空间大小的逻辑卷&lt;/span&gt;&lt;/span&gt;
  WARNING: Reducing active logical volume to &lt;/span&gt;&lt;span&gt;5.00&lt;/span&gt;&lt;span&gt; GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce datavg&lt;/span&gt;/weblv? [y/&lt;span&gt;n]: y
  Size of logical volume datavg&lt;/span&gt;/weblv changed from &lt;span&gt;7.00&lt;/span&gt; GiB (&lt;span&gt;1792&lt;/span&gt; extents) to &lt;span&gt;5.00&lt;/span&gt; GiB (&lt;span&gt;1280&lt;/span&gt;&lt;span&gt; extents).
  Logical volume datavg&lt;/span&gt;/&lt;span&gt;weblv successfully resized.
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;mount&lt;/span&gt; /dev/mapper/datavg-weblv /webapp/  &lt;span&gt;//重新挂载&lt;/span&gt;&lt;span&gt;
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;df&lt;/span&gt; -&lt;span&gt;hT | grep weblv&lt;/span&gt;/dev/mapper/datavg-weblv  ext4      &lt;span&gt;4&lt;/span&gt;.9G   12M  &lt;span&gt;4&lt;/span&gt;.7G   &lt;span&gt;1&lt;/span&gt;% /&lt;span&gt;webapp
[root@Node1 &lt;/span&gt;~]# &lt;span&gt;ls&lt;/span&gt; /webapp/     &lt;span&gt; //查看fstab文件还在
fstab  lost+found&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2）xfs文件系统的调整命令是xfs_growfs&lt;span&gt;（只支持增大）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# lvextend -L 8G /dev/mapper/datavg-&lt;span&gt;datalv  &lt;span&gt; //增大至8G&lt;/span&gt;
[root@Node1 &lt;/span&gt;~]# lvextend -L +2G /dev/mapper/datavg-&lt;span&gt;datalv  &lt;span&gt;//增加2G&lt;/span&gt;
[root@Node1 &lt;/span&gt;~]# xfs_growfs /dev/mapper/datavg-&lt;span&gt;datalv     &lt;span&gt;//扩容xfs逻辑卷&lt;/span&gt;
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgs
  VG     #PV #LV #SN Attr   VSize   VFree 
  datavg   &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;2&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; wz--n- &amp;lt;&lt;span&gt;29&lt;/span&gt;.99g &amp;lt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;.99g
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# lvs
  LV     VG     Attr       LSize  Pool Origin Data&lt;/span&gt;%  Meta%  Move Log Cpy%&lt;span&gt;Sync Convert
  datalv datavg &lt;/span&gt;-wi-ao---- &lt;span&gt;15&lt;/span&gt;&lt;span&gt;.00g                                                    
  weblv  datavg &lt;/span&gt;-wi-ao----  &lt;span&gt;5&lt;/span&gt;&lt;span&gt;.00g                                                    
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# lvscan
  ACTIVE            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/dev/datavg/datalv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; [&lt;span&gt;15.00&lt;/span&gt;&lt;span&gt; GiB] inherit
  ACTIVE            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/dev/datavg/weblv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; [&lt;span&gt;5.00&lt;/span&gt;&lt;span&gt; GiB] inherit

PS:&lt;span&gt;xfs文件系统只支持增大分区空间的情况，不支持减小的情况，硬要减小的话，只能在减小后将逻辑分区重新通过mkfs.xfs命令重新格式化才能挂载上，这样的话这个逻辑分区上原来的数据就丢失了&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 6、逻辑卷快照&lt;br/&gt;&lt;span&gt; snapshot是像照相一样将当前的系统信息保存下来。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当创建一个snapshot的时候，仅拷贝原始卷里数据的元数据(meta-data)。创建的时候，并不会有数据的物理拷贝，因此snapshot的创建几乎是实时的，当原始卷上有写操作执行时，snapshot跟踪原始卷块的改变，这个时候原始卷上将要改变的数据在改变之前被拷贝到snapshot预留的空间里，因此这个原理的实现叫做写时复制(copy-on-write)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在写操作写入块之前，原始数据被移动到 snapshot空间里，这样就保证了所有的数据在snapshot创建时保持一致。而对于snapshot的读操作，如果是没有修改过的块，那么会将读操作直接重定向到原始卷上，如果是已经修改过的块，那么就读取拷贝到snapshot中的块。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     注：创建快照前需将针对的逻辑卷临时改为只读，创建完毕后再改为读写，例如&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     - 创建快照前：mount -o remount,ro /dev/datavg/weblv /webapp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     - 创建快照后：mount -o remount,rw /dev/datavg/weblv &lt;span&gt;&lt;span&gt;&lt;span&gt;/webapp&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@Node1 webapp]# &lt;span&gt;df&lt;/span&gt; -h | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; datavg
&lt;/span&gt;/dev/mapper/datavg-weblv   &lt;span&gt;4&lt;/span&gt;.9G   13M  &lt;span&gt;4&lt;/span&gt;.7G   &lt;span&gt;1&lt;/span&gt;% /&lt;span&gt;webapp
&lt;/span&gt;/dev/mapper/datavg-datalv   15G   33M   15G   &lt;span&gt;1&lt;/span&gt;% /&lt;span&gt;dbbackup
[root@Node1 &lt;/span&gt;~]# cd /webapp/&lt;span&gt;
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; /etc/&lt;span&gt;passwd&lt;/span&gt; /etc/fstab /etc/redhat-&lt;span&gt;release .    &lt;span&gt;//复制一些文件到当前目录&lt;/span&gt;
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
fstab  lost&lt;/span&gt;+found  &lt;span&gt;passwd&lt;/span&gt;  redhat-&lt;span&gt;release
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;mount&lt;/span&gt; -o remount,ro /dev/datavg/weblv /&lt;span&gt;webap &lt;span&gt; //先改成只读挂载&lt;/span&gt;
[root@Node1 webapp]# lvcreate &lt;/span&gt;-s -L 2G -n weblvsnap -p r /dev/datavg/&lt;span&gt;weblv  &lt;span&gt;//对weblv做快照为weblvsnap 大小为2G,设为只读&lt;/span&gt;
  Logical volume &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weblvsnap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; created.
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;mount&lt;/span&gt; -o remount,rw /dev/datavg/weblv /&lt;span&gt;webapp  &lt;span&gt;//快照完，改为读写挂载&lt;/span&gt;
[root@Node1 webapp]# mdir &lt;/span&gt;/mnt/&lt;span&gt;web
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;mount&lt;/span&gt; /dev/datavg/weblvsnap /mnt/web/    &lt;span&gt;//挂载快照&lt;/span&gt;
&lt;span&gt;mount&lt;/span&gt;: /dev/mapper/datavg-weblvsnap is &lt;span&gt;write&lt;/span&gt;-protected, mounting read-&lt;span&gt;only
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;df&lt;/span&gt; -hT | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; weblv
&lt;/span&gt;/dev/mapper/datavg-weblv     ext4      &lt;span&gt;4&lt;/span&gt;.9G   13M  &lt;span&gt;4&lt;/span&gt;.7G   &lt;span&gt;1&lt;/span&gt;% /&lt;span&gt;webapp
&lt;/span&gt;/dev/mapper/datavg-weblvsnap ext4      &lt;span&gt;4&lt;/span&gt;.9G   13M  &lt;span&gt;4&lt;/span&gt;.7G   &lt;span&gt;1&lt;/span&gt;% /mnt/&lt;span&gt;web
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
fstab  lost&lt;/span&gt;+found  &lt;span&gt;passwd&lt;/span&gt;  redhat-&lt;span&gt;release
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;rm&lt;/span&gt; -rf fstab &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; data &amp;gt;&lt;span&gt; data.txt
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
data.txt  lost&lt;/span&gt;+found  &lt;span&gt;passwd&lt;/span&gt;  redhat-&lt;span&gt;release
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt; /mnt/web/&lt;span&gt;
fstab  lost&lt;/span&gt;+found  &lt;span&gt;passwd&lt;/span&gt;  redhat-&lt;span&gt;release
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
data.txt  lost&lt;/span&gt;+found  &lt;span&gt;passwd&lt;/span&gt;  redhat-&lt;span&gt;release
[root@Node1 webapp]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt; /mnt/web/&lt;span&gt;
fstab  lost&lt;/span&gt;+found  &lt;span&gt;passwd&lt;/span&gt;  redhat-&lt;span&gt;release&lt;/span&gt;&lt;span&gt;
[root@Node1 webapp]# cd &lt;/span&gt;/mnt/web/&lt;span&gt;
[root@Node1 web]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
fstab  lost&lt;/span&gt;+found  &lt;span&gt;passwd&lt;/span&gt;  redhat-&lt;span&gt;release
[root@Node1 web]# &lt;/span&gt;&lt;span&gt;rm&lt;/span&gt; -&lt;span&gt;rf fstab   &lt;span&gt;//挂载为只读模式，无法删除该目录下的文件
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;rm&lt;/span&gt;: cannot remove ‘fstab’: Read-&lt;span&gt;only 
[root@Node1 web]# lvs
  LV        VG     Attr       LSize  Pool Origin Data&lt;/span&gt;%  Meta%  Move Log Cpy%&lt;span&gt;Sync Convert
  datalv    datavg &lt;/span&gt;-wi-ao---- &lt;span&gt;15&lt;/span&gt;&lt;span&gt;.00g                                                    
  weblv     datavg owi&lt;/span&gt;-aos---  &lt;span&gt;5&lt;/span&gt;&lt;span&gt;.00g                                                    
  weblvsnap datavg sri&lt;/span&gt;-aos---  &lt;span&gt;2&lt;/span&gt;.00g      weblv  &lt;span&gt;0.01&lt;/span&gt;&lt;span&gt;                                   
[root@Node1 web]# lvscan
  ACTIVE            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/dev/datavg/datalv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; [&lt;span&gt;15.00&lt;/span&gt;&lt;span&gt; GiB] inherit
  ACTIVE   Original &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/dev/datavg/weblv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; [&lt;span&gt;5.00&lt;/span&gt;&lt;span&gt; GiB] inherit
  ACTIVE   &lt;span&gt;Snapshot&lt;/span&gt; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/dev/datavg/weblvsnap&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; [&lt;span&gt;2.00&lt;/span&gt; GiB] inherit&lt;br/&gt;[root@Node1 web]# lvdisplay /dev/datavg/weblvsnap &lt;br/&gt;--- Logical volume ---&lt;br/&gt;LV Path                /dev/datavg/weblvsnap&lt;br/&gt;LV Name                weblvsnap&lt;br/&gt;VG Name                datavg&lt;br/&gt;LV UUID                pf2jl8-21kq-kCKf-PymV-Vqvn-a5nm-q2tp0s&lt;br/&gt;LV Write Access        &lt;span&gt;read only&lt;/span&gt;&lt;br/&gt;LV Creation host, time Node1.contoso.com, 2019-09-19 05:31:23 +0800&lt;br/&gt;LV snapshot status     active destination for weblv&lt;br/&gt;LV Status              available&lt;br/&gt;# open                 1&lt;br/&gt;LV Size                5.00 GiB&lt;br/&gt;Current LE             1280&lt;br/&gt;COW-table size         2.00 GiB&lt;br/&gt;COW-table LE           512&lt;br/&gt;Allocated to snapshot  0.01%&lt;br/&gt;Snapshot chunk size    4.00 KiB&lt;br/&gt;Segments               1&lt;br/&gt;Allocation             inherit&lt;br/&gt;Read ahead sectors     auto&lt;br/&gt;- currently set to     8192&lt;br/&gt;Block device           253:4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;7、删除LVM流程&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;       卸载=&amp;gt;lvremove=&amp;gt;vgremove=&amp;gt;pvremove&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Node1 ~]# &lt;span&gt;umount&lt;/span&gt; /dev/mapper/datavg-&lt;span&gt;weblvsnap&lt;br/&gt;&lt;/span&gt;&lt;span&gt;[root@Node1 ~]# &lt;span&gt;umount&lt;/span&gt; /dev/mapper/datavg-&lt;span&gt;weblv&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;[root@Node1 ~]# &lt;span&gt;umount&lt;/span&gt; /dev/mapper/datavg-data&lt;span&gt;lv&lt;/span&gt;&lt;/span&gt;
[root@Node1 &lt;/span&gt;~]# lvremove /dev/mapper/datavg-&lt;span&gt;weblvsnap   &lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;删除逻辑卷，需要处于离线（卸载）状态&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
Do you really want to remove active logical volume datavg&lt;/span&gt;/weblvsnap? [y/&lt;span&gt;n]: y
  Logical volume &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weblvsnap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully removed
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# lvs
  LV     VG     Attr       LSize  Pool Origin Data&lt;/span&gt;%  Meta%  Move Log Cpy%&lt;span&gt;Sync Convert
  datalv datavg &lt;/span&gt;-wi-ao---- &lt;span&gt;15&lt;/span&gt;&lt;span&gt;.00g                                                    
  weblv  datavg &lt;/span&gt;-wi-ao----  &lt;span&gt;5&lt;/span&gt;&lt;span&gt;.00g  
[root@Node1 &lt;/span&gt;~&lt;span&gt;]# vgremove datavg   &lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;删除卷组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
Do you really want to remove volume group &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datavg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; containing &lt;span&gt;1&lt;/span&gt; logical volumes? [y/&lt;span&gt;n]: y
Do you really want to remove active logical volume datavg&lt;/span&gt;/weblv? [y/&lt;span&gt;n]: y
  Logical volume &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weblv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully removed
  Volume group &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datavg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; successfully removed
[root@Node1 &lt;/span&gt;~]# pvremove /dev/&lt;span&gt;sdc5 &lt;span&gt; //移除物理卷&lt;/span&gt;
  Labels on physical volume &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/sdc5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; successfully wiped.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;五、&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;LVM的优缺点   &lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     &lt;strong&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;     1. 文件系统可以跨多个磁盘，因此文件系统大小不会受物理磁盘的限制。&lt;br/&gt;     2. 可以在系统运行的状态下动态的扩展文件系统的大小    &lt;br/&gt;     3. 可以增加新的磁盘到LVM的存储池中。   &lt;br/&gt;     4. 可以以镜像的方式冗余重要的数据到多个物理磁盘。    &lt;br/&gt;     5. 可以方便的导出整个卷组到另外一台机器。&lt;br/&gt;    &lt;br/&gt;     &lt;strong&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/strong&gt;   &lt;br/&gt;     1. 在从卷组中移除一个磁盘的时候必须使用reducevg命令（这个命令要求root权限，并且不允许在快照卷组中使用）。   &lt;br/&gt;     2. 当卷组中的一个磁盘损坏时，整个卷组都会受到影响。    &lt;br/&gt;     3. 因为加入了额外的操作，存储性能受到影响&lt;br/&gt;     4. 不能减小文件系统大小（受文件系统类型限制）&lt;br/&gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;span&gt;  使用 LVM 将获得更好的可扩展性和可操作性，但却损失了可靠性和存储性能，总的说来就是在这两者间选择。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 14:41:00 +0000</pubDate>
<dc:creator>cloudos</dc:creator>
<og:description>一、LVM概念 LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cloudos/p/9348315.html</dc:identifier>
</item>
</channel>
</rss>