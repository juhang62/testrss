<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Git分布式版本控制器安装注意点及其常用命令 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/git.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/git.html</guid>
<description>&lt;p&gt;&lt;span&gt;将git按照默认选项下载安装后，打开git bach版面进行git命令行操作(记住在安装的过程中文件夹中不能存在中文)：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;注：Windows下，路径名不要包含中文，因为Git对中文支持不给力，可能会存在报错。&lt;/span&gt;&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Git下载地址&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;git安装成功后，查看git版本：
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;git version
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;显示当前的Git配置：
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; git config --&lt;span&gt;list
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;编辑Git配置文件：
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;  git config -e [--&lt;span&gt;global&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;打开对应于文件地址(和window cmd一样的操作)：
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;cd d:
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;创建文件夹：
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;mkdir 文件夹名称
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; 查看文件所在路径（/&lt;span&gt;e）：
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;pwd
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;通过 git init命令把这个目录变成Git可以管理的仓库
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;(创建自己的第一个git仓库，创建git仓库后我们可以看到有一个master分支标志出现，说明创建成功了)
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;git init
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; Initialized empty Git repository &lt;span&gt;in&lt;/span&gt; E:/.git/
&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;删除本地git仓库：
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; rm .git -&lt;span&gt;rf
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;创建一个.txt文件夹：
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;touch myfrist.txt
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;编辑.txt 文件：
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;vim 加上文本名称
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;添加指定文件或者文件夹到git中去：
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;git add 文件名称
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;添加当前目录的所有文件到暂存区
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;git add .
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;删除工作区文件，并且将这次删除放入暂存区
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;git rm [file1] [file2] ...
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;停止追踪指定文件，但该文件会保留在工作区
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; git rm --&lt;span&gt;cached [file]
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;改名文件，并且将这个改名放入暂存区
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; git mv [file-original] [file-&lt;span&gt;renamed]
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;在提交之前首先要设置对应的用户信息：
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; git config --&lt;span&gt;global&lt;/span&gt; user.email &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;you@example.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; git config --&lt;span&gt;global&lt;/span&gt; user.name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;使用 git commit 将所有暂存区文件提交到仓库：
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; git commit -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;带的是文件注释说明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; 注：git commit命令，-&lt;span&gt;m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;提交暂存区的指定文件到仓库区
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; git commit [file1] [file2] ... -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;带的是文件注释说明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;提交工作区自上次commit之后的变化，直接到仓库区
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; git commit -&lt;span&gt;a
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;commit可以一次提交多个文件：
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt; git add file1.txt
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt; git add file2.txt
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt; git add file3.txt
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;  git commit -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add 3 files.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;修改文件：
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;进入编辑模式
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;vim 加上文件名称
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt; esc+&lt;span&gt;：wq保存
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;：q退出
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;：q！强制退出不保存修改
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;修改以后我们可以查看对应的状态：
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;git status  (这个在git的命令使用中使用的是最为频繁的一个命令了)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;如果有对应的文件又被修改过得话：
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;提示：modified 文件名   ：提示某个文件比修改过了
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt; 删除文件夹：rm -&lt;span&gt;r 文件夹名称
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;删除文件：rm 文件名
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt; 显示有变更的文件
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt; git status
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt; 显示当前分支的版本历史
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt; git log
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt; 显示commit历史，以及每次commit发生变更的文件
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;  git log --&lt;span&gt;stat
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt; 搜索提交历史，根据关键词
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;  git log -&lt;span&gt;S [keyword]
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt; &lt;span&gt; 显示某个commit之后的所有变动，每个commit占据一行
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;  git log [tag] HEAD --pretty=format:%&lt;span&gt;s
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;  显示某个commit之后的所有变动，其&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交说明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须符合搜索条件
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;  git log [tag] HEAD --&lt;span&gt;grep feature
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; &lt;span&gt; 显示某个文件的版本历史，包括文件改名
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;  git log --&lt;span&gt;follow [file]
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt; git whatchanged [file]
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; &lt;span&gt; 显示指定文件相关的每一次diff
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;  git log -&lt;span&gt;p [file]
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt; &lt;span&gt; 显示过去5次提交
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;  git log -&lt;span&gt;5&lt;/span&gt; --pretty --&lt;span&gt;oneline
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; &lt;span&gt; 显示所有提交过的用户，按提交次数排序
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;  git shortlog -&lt;span&gt;sn
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt; &lt;span&gt; 显示指定文件是什么人在什么时间修改过
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt; git blame [file]
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt; &lt;span&gt; 显示暂存区和工作区的代码差异
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt; git diff
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; &lt;span&gt; 显示暂存区和上一个commit的差异
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;  git diff --&lt;span&gt;cached [file]
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt; &lt;span&gt; 显示工作区与当前分支最新commit之间的差异
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt; git diff HEAD
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; &lt;span&gt; 显示两次提交之间的差异
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;  git diff [first-branch]...[second-&lt;span&gt;branch]
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt; &lt;span&gt; 显示今天你写了多少行代码
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;  git diff --shortstat &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@{0 day ago}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt; 
&lt;span&gt;138&lt;/span&gt; &lt;span&gt; 显示某次提交的元数据和内容变化
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt; git show [commit]
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt; &lt;span&gt; 显示某次提交发生变化的文件
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;  git show --name-&lt;span&gt;only [commit]
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt; &lt;span&gt; 显示某次提交时，某个文件的内容
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt; git show [commit]:[filename]
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt; &lt;span&gt; 显示当前分支的最近几次提交
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt; git reflog
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt; &lt;span&gt; 从本地master拉取代码更新当前分支：branch 一般为master
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt; git rebase [branch]
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; 
&lt;span&gt;153&lt;/span&gt; &lt;span&gt; 显示有变更的文件
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt; git status
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; 
&lt;span&gt;156&lt;/span&gt; &lt;span&gt; 显示当前分支的版本历史
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt; git log
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt; &lt;span&gt; 显示commit历史，以及每次commit发生变更的文件
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;  git log --&lt;span&gt;stat
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt; &lt;span&gt; 搜索提交历史，根据关键词
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;  git log -&lt;span&gt;S [keyword]
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt; &lt;span&gt; 显示某个commit之后的所有变动，每个commit占据一行
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;  git log [tag] HEAD --pretty=format:%&lt;span&gt;s
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; 
&lt;span&gt;168&lt;/span&gt;  显示某个commit之后的所有变动，其&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交说明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须符合搜索条件
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;  git log [tag] HEAD --&lt;span&gt;grep feature
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt; &lt;span&gt; 显示某个文件的版本历史，包括文件改名
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;  git log --&lt;span&gt;follow [file]
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt; git whatchanged [file]
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt; &lt;span&gt; 显示指定文件相关的每一次diff
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;  git log -&lt;span&gt;p [file]
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; 
&lt;span&gt;178&lt;/span&gt; &lt;span&gt; 显示过去5次提交
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;  git log -&lt;span&gt;5&lt;/span&gt; --pretty --&lt;span&gt;oneline
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt; &lt;span&gt; 显示所有提交过的用户，按提交次数排序
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;  git shortlog -&lt;span&gt;sn
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt; &lt;span&gt; 显示指定文件是什么人在什么时间修改过
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt; git blame [file]
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt; &lt;span&gt; 显示暂存区和工作区的代码差异
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt; git diff
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt; &lt;span&gt; 显示暂存区和上一个commit的差异
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;  git diff --&lt;span&gt;cached [file]
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; 
&lt;span&gt;193&lt;/span&gt; &lt;span&gt; 显示工作区与当前分支最新commit之间的差异
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt; git diff HEAD
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; 
&lt;span&gt;196&lt;/span&gt; &lt;span&gt; 显示两次提交之间的差异
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;  git diff [first-branch]...[second-&lt;span&gt;branch]
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt; &lt;span&gt; 显示今天你写了多少行代码
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;  git diff --shortstat &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@{0 day ago}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt; 
&lt;span&gt;202&lt;/span&gt; &lt;span&gt; 显示某次提交的元数据和内容变化
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt; git show [commit]
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; 
&lt;span&gt;205&lt;/span&gt; &lt;span&gt; 显示某次提交发生变化的文件
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;  git show --name-&lt;span&gt;only [commit]
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt; &lt;span&gt; 显示某次提交时，某个文件的内容
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt; git show [commit]:[filename]
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; 
&lt;span&gt;211&lt;/span&gt; &lt;span&gt; 显示当前分支的最近几次提交
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt; git reflog
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; 
&lt;span&gt;214&lt;/span&gt; &lt;span&gt; 从本地master拉取代码更新当前分支：branch 一般为master
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;  git rebase [branch]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 这是我这段时间来学习git所用到的一些比较普遍的命令，今天记录一下加深一下自己的印象，Git的使用命令还有很多，需要我们慢慢的学习和积累。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Dec 2018 15:47:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>将git按照默认选项下载安装后，打开git bach版面进行git命令行操作(记住在安装的过程中文件夹中不能存在中文)：注：Windows下，路径名不要包含中文，因为Git对中文支持不给力，可能会存在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Can-daydayup/p/git.html</dc:identifier>
</item>
<item>
<title>Kali安装Nessus - starnight_cyber</title>
<link>http://www.cnblogs.com/Hi-blog/p/Installation-and-Use-Nessus-On-Kali.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Hi-blog/p/Installation-and-Use-Nessus-On-Kali.html</guid>
<description>&lt;p&gt;　　本文将简要介绍在虚拟机Kali2.0上安装和使用漏洞扫描器Nessus。&lt;/p&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;p&gt;　　链接地址：&lt;a href=&quot;https://www.tenable.com/downloads/nessus&quot; target=&quot;_blank&quot;&gt;https://www.tenable.com/downloads/nessus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217221909504-1370470654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在如图标记1的位置找到合适的版本，下载的同时我们可以获取标记2激活码。注册，如下图的Nessus Home版。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217222057072-1255158602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注册之后，会邮件给您发送类似“9019-C3D9-C33F-5407-8F5C”这样的注册码。注册码是单次有效的，用过一次需要再次获取。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;　　有了工具安装包和激活码，就可以安装了。&lt;/p&gt;
&lt;p&gt;　　使用命令dpkg -i进行安装，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217222735231-747484104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装过程比较快，输入命令启动Nessus服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;root@kali:~/temp# /etc/init.d/nessusd start&lt;br/&gt;Starting Nessus : .&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　打开浏览器访问：https://kali:8834/，第一次访问会出现如下提示，点击Advanced =&amp;gt; Add Exception =&amp;gt; Confirm Security Exception即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217223440646-1043368156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　自动跳转到创建账号 =&amp;gt; 输入账号/密码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217223552823-1563493906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Continue =&amp;gt;　输入激活码　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217223654755-873144558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Continue =&amp;gt; 之后就是比较漫长的等待了...（下载插件）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217223806512-2034233669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　下载结束之后，便可以登录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217231158868-600236599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;使用Nessus扫描&lt;/h2&gt;
&lt;p&gt;　　点击创建新的扫描任务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217231340207-576067393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　其中标记为UPGRADE的，为Nessus Professional才能使用的功能。如创建基本网络扫描任务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217231434789-2060390811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　 设置一些扫描的基本信息，最重要的就是这个目标地址设定了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217232456812-1505242427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　保存之后，点击如图小三角，启动扫描任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/624934/201812/624934-20181217232545146-1112917741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　等待扫描结果即可。&lt;/p&gt;
&lt;p&gt;　　高级用法，请参考：&lt;a href=&quot;https://www.cnblogs.com/Hi-blog/p/9494535.html&quot; target=&quot;_blank&quot;&gt;Nessus扫描策略&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Dec 2018 15:36:00 +0000</pubDate>
<dc:creator>starnight_cyber</dc:creator>
<og:description>本文将简要介绍在虚拟机Kali2.0上安装和使用漏洞扫描器Nessus。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Hi-blog/p/Installation-and-Use-Nessus-On-Kali.html</dc:identifier>
</item>
<item>
<title>linux（Redhat7）安装Apache - 白钰锋</title>
<link>http://www.cnblogs.com/byf-soft/p/10134696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/byf-soft/p/10134696.html</guid>
<description>&lt;pre&gt;
1.下载apache安装包以及安装依赖的包（apr、apr-util、pcre）&lt;br/&gt;wget https://mirrors.cnnic.cn/apache/httpd/httpd-2.4.37.tar.gz&lt;br/&gt;wget http://archive.apache.org/dist/apr/apr-1.5.2.tar.gz&lt;br/&gt;wget http://archive.apache.org/dist/apr/apr-util-1.3.12.tar.gz&lt;br/&gt;wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.10/pcre-8.10.zip&lt;br/&gt;2.解压安装&lt;br/&gt;tar -zxvf http-2.4.34.tar.gz&lt;br/&gt;tar -zxvf apr-1.5.2.tar.gz&lt;br/&gt;tar -zxvf apr-util-1.3.12.tar.gz&lt;br/&gt;unzip pcre-8.10.zip&lt;br/&gt;3.进入响应的目录&lt;br/&gt;cd apr-1.5.2&lt;br/&gt;./configure --prefix=/usr/local/apr/&lt;br/&gt;make&lt;br/&gt;make install&lt;br/&gt;cd ../
&lt;/pre&gt;
&lt;pre readability=&quot;4.8965517241379&quot;&gt;
cd apr-util-1.3.12&lt;br/&gt;./configure --prefix=/usr/local/apr-util/ --with-apr=/usr/local/apr/&lt;br/&gt;make&lt;br/&gt;make install&lt;br/&gt;cd ../&lt;p&gt;cd pcre-8.10&lt;br/&gt;./configure --prefix=/usr/local/pcre/&lt;br/&gt;make&lt;br/&gt;make install&lt;br/&gt;cd ../&lt;br/&gt;注：g++编译错误可以参考 &lt;a href=&quot;https://www.cnblogs.com/byf-soft/p/10134756.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/byf-soft/p/10134756.html&lt;/a&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;8&quot;&gt;
cd httpd-2.4.37&lt;br/&gt;./configure --prefix=/usr/local/apache/ --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --with-pcre=/usr/local/pcre/&lt;br/&gt;make&lt;br/&gt;make install&lt;br/&gt;cd /usr/local/apache/conf&lt;br/&gt;vi httpd.conf&lt;br/&gt;打开ServerName 地址改为本机地址 我的地址是192.168.48.133:80&lt;br/&gt;cd ../bin&lt;br/&gt;./apachectl start&lt;p&gt;打开浏览器访问http://192.168.48.133:80&lt;/p&gt;&lt;p&gt;如果不能访问 在本机curl http://192.168.48.133:80 &lt;br/&gt;若是可以显示页面信息，则有可能是防火墙的原因 &lt;br/&gt;关闭防火墙 &lt;br/&gt;systemctl stop firewalld（暂时关闭）
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
重新打开浏览器访问http://192.168.48.133:80&lt;/pre&gt;
&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 17 Dec 2018 15:29:00 +0000</pubDate>
<dc:creator>白钰锋</dc:creator>
<og:description>小白Apache安装记录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/byf-soft/p/10134696.html</dc:identifier>
</item>
<item>
<title>css3打包后自动追加前缀插件：autoprefixer - 双眸</title>
<link>http://www.cnblogs.com/both-eyes/p/10134677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/both-eyes/p/10134677.html</guid>
<description>&lt;h3 id=&quot;用vue-cli构建的项目脚手架已经帮你把autoprefixer的配置做好了自己不需要做什么改动就会自动加前缀&quot;&gt;用vue-cli构建的项目脚手架已经帮你把autoprefixer的配置做好了，自己不需要做什么改动就会自动加前缀：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217231040319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;下面一起看看涉及到autoprefixer这个插件的一些配置&quot;&gt;下面一起看看涉及到autoprefixer这个插件的一些配置：&lt;/h4&gt;
&lt;p&gt;1，postcss配置写在.postcssrc.js，&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217231114671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，浏览器规则则写在package.json上,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217231142676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;3，开发环境（build/webpack.dev.conf.js）样式相关的loader&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217231357987.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4，生产环境（build/webpack.prod.conf.js）样式相关的loader&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018121723133215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上述的配置设置不需要自己配置，cli脚手架环境搭建的时候已经配置好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vue-cli的开发环境和生产环境都是使用了postcss的，并且配置是一样的&lt;/p&gt;
&lt;h3 id=&quot;这里有一个问题网上有博主说项目打包前和打包后的css前缀不一致&quot;&gt;这里有一个问题，网上有博主说项目打包前和打包后的css前缀不一致：&lt;/h3&gt;
&lt;p&gt;--给app.vue下的img添加样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;img{
 display: flex;
 transform: translateX(200px)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;--打包前（即开发环境）img的样式&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217231633748.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;--打包后（即生产环境）img的样式&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217231641731.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;根据上面可看出打包前和打包后元素所带的css前缀不一致了。&lt;/p&gt;
&lt;h4 id=&quot;然后给出的解决方案&quot;&gt;然后给出的解决方案：&lt;/h4&gt;
&lt;p&gt;从上面可以看出，vue-cli的开发环境和生产环境都是使用了postcss的，并且配置是一样的，那么为什么打包前和打包后元素所带的css前缀不一致呢，&lt;/p&gt;
&lt;h4 id=&quot;锁定问题&quot;&gt;锁定问题&lt;/h4&gt;
&lt;p&gt;我们可以分析对比下build/webpack.dev.conf.js和build/webpack.prod.conf.js这两个文件，影响css的无非就module里处理样式的loader和处理css的插件plugin，从上面可以看出影响前缀的postcss的loader在两个环节中是一致的，那么就可以知道问题出在处理css的插件上了。&lt;/p&gt;
&lt;p&gt;经过排查发现，webpack.prod.conf.js配置里是多了两个css处理插件的，如下&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217231800505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ExtractTextPlugin这是提取分离css文件，不会影响css前缀，排除，那么问题就锁定到OptimizeCSSPlugin插件身上。再进一步，当我们把OptimizeCSSPlugin插件注释掉，然后打包测试，居然发现这时开发环境和生产环境的css前缀一致了，就是它了！！！&lt;/p&gt;
&lt;p&gt;我们打开到npm官网搜一下这家伙&lt;br/&gt;&lt;a href=&quot;https://www.npmjs.com/package/optimize-css-assets-webpack-plugin&quot; class=&quot;uri&quot;&gt;https://www.npmjs.com/package/optimize-css-assets-webpack-plugin&lt;/a&gt;&lt;br/&gt;这是一个优化压缩css代码的插件，但很失望，文档说明很少&lt;br/&gt;但我们注意到有一句话很关键：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018121723184733.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这货里面依赖了cssnano,这插件也是用来优化处理css格式、前缀什么的。同时也有个autoprefixer配置参数，直接到它官网 &lt;a href=&quot;https://cssnano.co/&quot; class=&quot;uri&quot;&gt;https://cssnano.co/&lt;/a&gt; 找到autoprefixer：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018121723192228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里的翻译是：根据browsers选项删除不必要的前缀。请注意，默认情况下，它不会向CSS文件添加新前缀，这就可以解析清除我们的问题了，原来这插件的autoprefixer（默认应该是为true）把它认为不必要的前缀删掉了，而postcss的autoprefixer是将我们设定的浏览器范围的前缀加上，因此完美冲突了&lt;/p&gt;
&lt;h4 id=&quot;解决问题&quot;&gt;解决问题&lt;/h4&gt;
&lt;p&gt;在build/webpack.prod.conf.js文件中OptimizeCSSPlugin插件的属性cssProcessorOptions加上autoprefixer：false来禁用它，避免冲突&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217232025564.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new OptimizeCSSPlugin({
  cssProcessorOptions: config.build.productionSourceMap
   ? { safe: true, map: false,autoprefixer:false }
   : { safe: true, autoprefixer: false}
 }),&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;最后，看看我们dev和build出来的css前缀，应该就一致的了：&lt;br/&gt;问题原因就是：OptimizeCSSPlugin里面依赖了cssnano,而cssnano里面也有一个autoprefixer配置参数，它的作用是删除不必要的前缀（会误删在某些浏览器必要的前缀），这与postcss的autoprefixer效果冲突了，因此禁用它。现在打包出来的与我们设定的浏览器范围对应的前缀一致&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;按照网上的博主的配置确实可以把开发环境和测试环境的前缀一模一样，但是看了下没有必要，问题的前提不是前缀不一致，那个配置只是把和当前浏览器不匹配的前缀不显示出来而已，样式还都是生效的，个人觉得如果不是特别大的问题不用改配置。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Dec 2018 15:23:00 +0000</pubDate>
<dc:creator>双眸</dc:creator>
<og:description>用vue cli构建的项目脚手架已经帮你把autoprefixer的配置做好了，自己不需要做什么改动就会自动加前缀： 下面一起看看涉及到autoprefixer这个插件的一些配置： 1，postcss</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/both-eyes/p/10134677.html</dc:identifier>
</item>
<item>
<title>js实现所有异步请求全部加载完毕后，loading效果消失 - 渴望成为大牛的男人</title>
<link>http://www.cnblogs.com/bai1218/p/10134678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bai1218/p/10134678.html</guid>
<description>&lt;blockquote readability=&quot;12.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span&gt;在实际开发中，一定有情况是这样的，一个页面我们有多个地方请求了ajax，在这种情况下，我们要实现数据没来之前出现我们炫酷的loading效果，而且要等到&lt;span&gt;所有&lt;/span&gt;的ajax都请求完毕后，才让我们的loading效果消失，那么问题来了，每个ajax请求数据的时间都是不确定的，我们这个loading效果结束的逻辑又应该放到哪里呢？就好比这样（伪代码模拟）：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log('loading效果图旋转中'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timer1 =  setTimeout(() =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'第一个加载完成了'&lt;span&gt;);
    }, &lt;/span&gt;'随机的时间'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timer2 =  setTimeout(() =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'第二个加载完成了'&lt;span&gt;);
    }, &lt;/span&gt;'随机的时间'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timer3 =  setTimeout(() =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'第三个加载完成了'&lt;span&gt;);
    }, &lt;/span&gt;'随机的时间'&lt;span&gt;);

    console.log(&lt;/span&gt;'loading效果图消失,我好慌，我应该放到哪里')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;是不是很难受，你说每个请求的结束时间都不确定，我哪知道我应该放到哪里结束，别怕，给大家提供&lt;span&gt;两种&lt;/span&gt;解决方案，为了逻辑清晰，我就用一个延时器来给大家进行模拟了，莫要嫌弃:)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;9&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; loadingNums = 3&lt;span&gt;;
    console.log(&lt;/span&gt;'loading效果图旋转中'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timer1 =  setTimeout(() =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'第一个加载完成了'&lt;span&gt;);
        loadingNums&lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(loadingNums==0&lt;span&gt;){
            console.log(&lt;/span&gt;'loading效果图消失'&lt;span&gt;)
        }
    }, &lt;/span&gt;1000&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timer2 =  setTimeout(() =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'第三个加载完成了'&lt;span&gt;);
        loadingNums&lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(loadingNums==0&lt;span&gt;){
            console.log(&lt;/span&gt;'loading效果图消失'&lt;span&gt;)
        }
    }, &lt;/span&gt;2000&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timer3 =  setTimeout(() =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'第二个加载完成了'&lt;span&gt;);
        loadingNums&lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(loadingNums==0&lt;span&gt;){
            console.log(&lt;/span&gt;'loading效果图消失'&lt;span&gt;)
        }
    }, &lt;/span&gt;3000);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 页面控制台打印效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459233/201812/1459233-20181217230732230-1471450407.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;blockquote readability=&quot;11.5&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log('loading效果图旋转中'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
        setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'第一个加载完成了'&lt;span&gt;);
            resolve();
        }, &lt;/span&gt;1000&lt;span&gt;);
    })
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p2 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
        setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'第三个加载完成了'&lt;span&gt;);
            resolve();
        }, &lt;/span&gt;2000&lt;span&gt;);
    })
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p3 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
        setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'第二个加载完成了'&lt;span&gt;);
            resolve();
        }, &lt;/span&gt;3000&lt;span&gt;);
    })
    
    Promise.all([p1,p2,p3]).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;'loading效果图消失'&lt;span&gt;);
    })&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;页面控制台打印效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459233/201812/1459233-20181217230732230-1471450407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;


&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;好了已经很晚了，各位晚安早点睡觉，保护好自己的头发~~~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 17 Dec 2018 15:23:00 +0000</pubDate>
<dc:creator>渴望成为大牛的男人</dc:creator>
<og:description>在实际开发中，一定有情况是这样的，一个页面我们有多个地方请求了ajax，在这种情况下，我们要实现数据没来之前出现我们炫酷的loading效果，而且要等到所有的ajax都请求完毕后，才让我们的loadi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bai1218/p/10134678.html</dc:identifier>
</item>
<item>
<title>Tomcat与Spring中的事件机制详解 - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/10134541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/10134541.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近在看tomcat源码，源码中出现了大量事件消息，可以说整个tomcat的启动流程都可以通过事件派发机制串起来，研究透了tomcat的各种事件消息，基本上对tomcat的启动流程也就有了一个整体的认识。在这一基础上，联想到之前在看spring源码过程中也存在不少事件相关知识，于是想对这两个框架中的事件派发机制做一个简单的总结，加深理解。&lt;/p&gt;
&lt;p&gt;事件机制原理其实比较简单，抽象来看的话，设计模式中的观察者模式可以说是最经典的事件驱动机制的体现了，观察者和被观察者就体现了事件监听和事件派发的角色。还有各种MQ，其实也是事件机制的一种体现。&lt;/p&gt;
&lt;p&gt;理解tomcat和spring中的事件机制之前，让我们先从最基本的jdk中提供的事件机制开始说起。&lt;/p&gt;
&lt;h2 id=&quot;jdk中的事件机制&quot;&gt;JDK中的事件机制&lt;/h2&gt;
&lt;p&gt;JDK中对事件机制的各个角色提供了完善的抽象，主要包括3个角色：&lt;/p&gt;
&lt;p&gt;EventObject（事件关注内容）：事件发布时需要关注的内容。jdk中提供了EventObject接口。&lt;/p&gt;
&lt;p&gt;EventListener（事件监听者）：事件监听对象，也就是对EventObject感兴趣的对象。jdk中提供了EventListener接口。&lt;/p&gt;
&lt;p&gt;EventSource（事件源）：发布事件的对象，可以在该对象中组册EventListener，然后在特定的条件下发布EventObject给已经注册的EventListener。&lt;/p&gt;
&lt;p&gt;事件的注册与发布，需要这三个对象协同工作，可以通过下面的例子来说明各个对象的作用：&lt;/p&gt;
&lt;p&gt;首先是事件关注内容对象MyEventObject，实现了EventObject接口。eventName参数为具体的事件关注内容&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyEventObject extends EventObject {

    private String eventName ;
    
    public MyEventObject (Object source, String eventName) {
        
        super(source);
        this.setEventName(eventName);
    }

    public String getEventName() {
        return eventName;
    }

    public void setEventName(String eventName) {
        this.eventName = eventName;
    }

    private static final long serialVersionUID = 8374250957018011175L;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次是事件监听接口MyEventListener，继承了EventListener，定义了一个myEvent接口用来发布事件，任何感兴趣的监听对象都可以实现该接口来监听。&lt;/p&gt;
&lt;p&gt;对MyEventObject感兴趣的监听者MyEventListenerImpl，实现了MyEventListener接口，当事件发布时会触发myEvent事件并收到MyEventObject对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface MyEventListener extends EventListener {

    public void myEvent(MyEventObject eventObject);
}

public class MyEventListenerImpl implements MyEventListener {

    @Override
    public void myEvent(MyEventObject eventObject) {

        System.out.println(&quot;MyEventListenerImpl --- &quot; + eventObject.getEventName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是事件发布源对象MyEventSource，它可以注册多个事件监听对象，任何实现了MyEventListener接口的监听对象都可以注册，内部通过一个Set来存储感兴趣的监听对象，并在合适的时机会发布消息并通知所有监听对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyEventSource {

    private Set&amp;lt;MyEventListener&amp;gt; myEventListeners = new HashSet&amp;lt;&amp;gt;();
    
    public void addListener(MyEventListener listener){
        
        this.myEventListeners.add(listener);
    }
    
    public void removeListener(MyEventListener listener){
        
        this.myEventListeners.remove(listener);
    }
    
    public void pushEvent(){
        //dosomething
        //发布push event消息
        notifyListener(new MyEventObject(this, &quot;push event&quot;));
    }
    
    private void notifyListener(MyEventObject eventObject){
        
        for (MyEventListener myEventListener : myEventListeners) {
            myEventListener.myEvent(eventObject);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后可以通过一个启动类来注册并触发事件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    
    MyEventSource myEventSource = new MyEventSource();
    
    MyEventListenerImpl myEventListenerImpl = new MyEventListenerImpl();
    
    myEventSource.addListener(myEventListenerImpl);
    
    myEventSource.pushEvent();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyEventObject定义了感兴趣的内容，MyEventListenerImpl是对MyEventObject感兴趣的监听者，MyEventSource会发布MyEventObject给所有组册的监听者，最后通过一个main来启动整个流程。&lt;/p&gt;
&lt;p&gt;明白了jdk中对事件机制的定义，再来看看tomcat和spring中的事件机制。&lt;/p&gt;
&lt;h2 id=&quot;tomcat的事件机制&quot;&gt;Tomcat的事件机制&lt;/h2&gt;
&lt;p&gt;tomcat的事件机制也离不开EventObject、EventListener以及EventSource三个对象，只不过在此基础上提供了更加抽象和便捷的操作。这里我挑选tomcat的生命周期接口对象Lifecycle来讲解整个事件发布流程：&lt;/p&gt;
&lt;p&gt;首先还是EventObject对象LifecycleEvent，这里只列出了核心代码。它的主要参数是Lifecycle，Lifecycle中定义了tomcat各个阶段的名称：before_init、after_init、start等等，是事件监听者感兴趣的对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class LifecycleEvent extends EventObject {

    //......

    public LifecycleEvent(Lifecycle lifecycle, String type, Object data) {

        super(lifecycle);
        this.type = type;
        this.data = data;
    }

    //......
}

public interface Lifecycle {
    /**
     * The LifecycleEvent type for the &quot;component after init&quot; event.
     */
    public static final String BEFORE_INIT_EVENT = &quot;before_init&quot;;

    /**
     * The LifecycleEvent type for the &quot;component after init&quot; event.
     */
    public static final String AFTER_INIT_EVENT = &quot;after_init&quot;;

    /**
     * The LifecycleEvent type for the &quot;component start&quot; event.
     */
    public static final String START_EVENT = &quot;start&quot;;

    //......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事件监听接口LifecycleListener，定义了lifecycleEvent方法用来传递监听者感兴趣的LifecycleEvent对象，监听者使用LifecycleEvent参数用来在tomcat的各个阶段处理进行相应处理。这些感兴趣的对象包括下面这些类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/368583/201812/368583-20181217213232254-541900938.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里使用ContextConfig类为例，可以看到它实现了LifecycleListener接口。这个类在解析server.xml的时候用来监听StandardContext的各个阶段的事件，并做出相应处理：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface LifecycleListener {

    public void lifecycleEvent(LifecycleEvent event);
}

public class ContextConfig implements LifecycleListener {
    
    //......
    @Override
    public void lifecycleEvent(LifecycleEvent event) {

        // Identify the context we are associated with
        try {
            context = (Context) event.getLifecycle();
        } catch (ClassCastException e) {
            log.error(sm.getString(&quot;contextConfig.cce&quot;, event.getLifecycle()), e);
            return;
        }

        // Process the event that has occurred
        if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
            configureStart();
        } else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) {
            beforeStart();
        } else if (event.getType().equals(Lifecycle.AFTER_START_EVENT)) {
            // Restore docBase for management tools
            if (originalDocBase != null) {
                context.setDocBase(originalDocBase);
            }
        } else if (event.getType().equals(Lifecycle.CONFIGURE_STOP_EVENT)) {
            configureStop();
        } else if (event.getType().equals(Lifecycle.AFTER_INIT_EVENT)) {
            init();
        } else if (event.getType().equals(Lifecycle.AFTER_DESTROY_EVENT)) {
            destroy();
        }
    }

    //......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LifecycleSupport是我们需要了解的主要对象，它是监听对象的一个管理类，原理其实和上面的例子差不多，对应了MyEventSource类的部分功能，方便EventSource类来管理监听对象。它把对监听对象的添加移除以及发布事件几个操作进行了统一管理，避免EventSource类中出现太多管理监听对象的逻辑。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class LifecycleSupport {

    //......

    //监听对象集合
    private LifecycleListener listeners[] = new LifecycleListener[0];
    
    private final Object listenersLock = new Object(); // Lock object for changes to listeners

    //添加监听对象
    public void addLifecycleListener(LifecycleListener listener) {

      synchronized (listenersLock) {
          LifecycleListener results[] =
            new LifecycleListener[listeners.length + 1];
          for (int i = 0; i &amp;lt; listeners.length; i++)
              results[i] = listeners[i];
          results[listeners.length] = listener;
          listeners = results;
      }

    }

    //发布监听对象
    public void fireLifecycleEvent(String type, Object data) {

        LifecycleEvent event = new LifecycleEvent(lifecycle, type, data);
        LifecycleListener interested[] = listeners;
        for (int i = 0; i &amp;lt; interested.length; i++)
            interested[i].lifecycleEvent(event);

    }

    //移除监听对象
    public void removeLifecycleListener(LifecycleListener listener) {

        synchronized (listenersLock) {
            int n = -1;
            for (int i = 0; i &amp;lt; listeners.length; i++) {
                if (listeners[i] == listener) {
                    n = i;
                    break;
                }
            }
            if (n &amp;lt; 0)
                return;
            LifecycleListener results[] =
              new LifecycleListener[listeners.length - 1];
            int j = 0;
            for (int i = 0; i &amp;lt; listeners.length; i++) {
                if (i != n)
                    results[j++] = listeners[i];
            }
            listeners = results;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用了LifecycleSupport之后，操作LifecycleListener就简单多了，只需要调用LifecycleSupport的各个方法就可以了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class LifecycleBase implements Lifecycle{

    //......
    private LifecycleSupport lifecycle = new LifecycleSupport(this);

    @Override
    public void addLifecycleListener(LifecycleListener listener) {
        lifecycle.addLifecycleListener(listener);
    }

    @Override
    public void removeLifecycleListener(LifecycleListener listener) {
        lifecycle.removeLifecycleListener(listener);
    }

    protected void fireLifecycleEvent(String type, Object data) {
        lifecycle.fireLifecycleEvent(type, data);
    }
    //......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在需要发布事件时调用fireLifecycleEvent方法就可以发布事件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;fireLifecycleEvent(Lifecycle.CONFIGURE_STOP_EVENT, null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tomcat事件机制就是在之前的例子上抽出了一个LifecycleSupport类来方便管理监听对象的各种操作，这是一个可以借鉴的地方，其他差别并不大。再来看看spring中对事件机制的处理。&lt;/p&gt;
&lt;h2 id=&quot;spring的事件机制&quot;&gt;Spring的事件机制&lt;/h2&gt;
&lt;p&gt;spring中的事件机制原理也是一样的，只是相对来说实现上稍微复杂一点。还是通过相同的角度来看这个问题。&lt;/p&gt;
&lt;p&gt;首先是EventObject，spring里面的主要实现是ApplicationEvent：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/368583/201812/368583-20181217215139215-1739883536.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里通过ContextStartedEvent类来查看EventObject，它关注的对象是ApplicationContext，是spring容器在启动时触发的事件对象：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class ApplicationEvent extends EventObject {

    //......
    public ApplicationEvent(Object source) {
        super(source);
        this.timestamp = System.currentTimeMillis();
    }
    //......
}

public abstract class ApplicationContextEvent extends ApplicationEvent {
    public ApplicationContextEvent(ApplicationContext source) {
        super(source);
    }

    public final ApplicationContext getApplicationContext() {
        return (ApplicationContext)this.getSource();
    }
}

public class ContextStartedEvent extends ApplicationContextEvent {
    public ContextStartedEvent(ApplicationContext source) {
        super(source);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事件监听接口ApplicationListener，定义了onApplicationEvent方法用来传递监听者感兴趣的ApplicationEvent对象，监听者使用ApplicationEvent参数用来在Context的各个阶段处理进行相应处理。&lt;/p&gt;
&lt;p&gt;如果我们需要在容器启动后进行相应处理，那么我们可以在业务类中实现ApplicationListener接口，在事件发生时就会发起通知：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ApplicationListener&amp;lt;E extends ApplicationEvent&amp;gt; extends EventListener {

    void onApplicationEvent(E event);
}

public class MyApplicationListener implements ApplicationListener&amp;lt;ApplicationEvent&amp;gt; {

    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {

        if (applicationEvent instanceof ContextRefreshedEvent){

            System.out.println(&quot;context refresh!&quot;);   
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么在spring框架中是怎么发布这些事件的呢？是不是也有一个类似tomcat中LifecycleSupport一样的类呢？通过查看源码可以发现发现，ApplicationContext容器在初始化阶段会调用refresh()方法，这其中又调用了&lt;br/&gt;finishRefresh()方法，这其中调用了publishEvent(new ContextRefreshedEvent(this))方法，发布了ContextRefreshedEvent这一对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void finishRefresh() {
    
    //......
    // Publish the final event.
    publishEvent(new ContextRefreshedEvent(this));
}

protected void publishEvent(Object event, @Nullable ResolvableType eventType) {

    //......
    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
    //......
}

publishEvent方法通过调用一个默认的多播器SimpleApplicationEventMulticaster的multicastEvent方法来发布各种事件：

SimpleApplicationEventMulticaster
public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));

    //通过getApplicationListeners获取了所有监听器，然后通过invokeListener方法循环发布事件
    for (final ApplicationListener&amp;lt;?&amp;gt; listener : getApplicationListeners(event, type)) {
        Executor executor = getTaskExecutor();
        if (executor != null) {
            executor.execute(() -&amp;gt; invokeListener(listener, event));
        }
        else {
            invokeListener(listener, event);
        }
    }
}

protected void invokeListener(ApplicationListener&amp;lt;?&amp;gt; listener, ApplicationEvent event) {
    //......
    doInvokeListener(listener, event);
}

private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
    //......
    listener.onApplicationEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说在spring容器中发布ApplicationListener所关注的对象是通过SimpleApplicationEventMulticaster这个类来管理的，和tomcat中LifecycleSupport的功能类似，只是在实现上有略微差别。&lt;/p&gt;
&lt;p&gt;最后提一句，在spring中你也可以自己发布各种事件，调用ApplicationContext的publishEvent方法即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;applicationContext.publishEvent(new ApplicationEvent(new String(&quot;事件发布&quot;)) { });&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章对Java的事件机制在tomcat以及spring框架中的实现做了一个简单总结和对比，你需要知道以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JDK中定义了EventObject和EventListener两个接口，奠定了事件机制的基础。&lt;/li&gt;
&lt;li&gt;Tomcat额外提供了一个support类来对监听器的添加删除以及发布进行管理。&lt;/li&gt;
&lt;li&gt;Spring容器内部通过SimpleApplicationEventMulticaster来发布各个事件，用户可以通过实现ApplicationListener接口来监听自己感兴趣的容器事件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;希望你通过这篇文章的学习可以对Java的事件机制有一个更深刻的认识，在实现自己的事件机制时有可以借鉴以及改进的地方。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Dec 2018 15:06:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<og:description>引言 最近在看tomcat源码，源码中出现了大量事件消息，可以说整个tomcat的启动流程都可以通过事件派发机制串起来，研究透了tomcat的各种事件消息，基本上对tomcat的启动流程也就有了一个整</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/10134541.html</dc:identifier>
</item>
<item>
<title>Java进阶篇 设计模式之十四 ----- 总结篇 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/10134494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/10134494.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇是讲述之前学习设计模式的一个总结篇，其目的是为了对这些设计模式的进行一个提炼总结，能够通过查看看此篇就可以理解一些设计模式的核心思想。&lt;/p&gt;
&lt;h2 id=&quot;设计模式简介&quot;&gt;设计模式简介&lt;/h2&gt;
&lt;h3 id=&quot;什么是设计模式&quot;&gt;什么是设计模式&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么使用设计模式&quot;&gt;为什么使用设计模式&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;设计模式类型&quot;&gt;设计模式类型&lt;/h3&gt;
&lt;p&gt;设计模式有23种类型。按照主要分类可以分为三大类:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、创建型模式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;工厂模式&lt;/li&gt;
&lt;li&gt;抽象工厂模式&lt;/li&gt;
&lt;li&gt;建造者模式&lt;/li&gt;
&lt;li&gt;原型模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;二、结构型模式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;适配器模式&lt;/li&gt;
&lt;li&gt;桥接模式&lt;/li&gt;
&lt;li&gt;过滤器模式&lt;/li&gt;
&lt;li&gt;组合模式&lt;/li&gt;
&lt;li&gt;装饰器模式&lt;/li&gt;
&lt;li&gt;外观模式&lt;/li&gt;
&lt;li&gt;享元模式&lt;/li&gt;
&lt;li&gt;代理模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三、行为型模式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这些设计模式特别关注对象之间的通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;责任链模式&lt;/li&gt;
&lt;li&gt;命令模式&lt;/li&gt;
&lt;li&gt;解释器模式&lt;/li&gt;
&lt;li&gt;迭代器模式&lt;/li&gt;
&lt;li&gt;中介者模式&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;备忘录模式&lt;/li&gt;
&lt;li&gt;观察者模式&lt;/li&gt;
&lt;li&gt;状态模式&lt;/li&gt;
&lt;li&gt;空对象模式&lt;/li&gt;
&lt;li&gt;策略模式&lt;/li&gt;
&lt;li&gt;模板模式&lt;/li&gt;
&lt;li&gt;访问者模式&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;设计模式的原则&quot;&gt;设计模式的原则&lt;/h3&gt;
&lt;p&gt;设计模式的六大原则&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开闭原则：对扩展开放，对修改关闭。&lt;/li&gt;
&lt;li&gt;里氏代换原则：对开闭原则的补充。任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。&lt;/li&gt;
&lt;li&gt;依赖倒转原则：针对接口编程，依赖于抽象而不依赖于具体。&lt;/li&gt;
&lt;li&gt;接口隔离原则：尽量使用多个隔离的接口，为了降低类之间的耦合度。&lt;/li&gt;
&lt;li&gt;迪米特法则：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。&lt;/li&gt;
&lt;li&gt;合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;设计模式之间的关系图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217163803866.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设计模式总概况:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217163820234.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式相关文章:&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建型模式&quot;&gt;创建型模式&lt;/h2&gt;
&lt;h3 id=&quot;单例模式&quot;&gt;单例模式&lt;/h3&gt;
&lt;h4 id=&quot;单例模式介绍&quot;&gt;单例模式介绍&lt;/h4&gt;
&lt;p&gt;核心就是保证一个系统中的某个类只有一个实例而且该实例易于外界访问。&lt;/p&gt;
&lt;h4 id=&quot;单例模式的使用场景&quot;&gt;单例模式的使用场景&lt;/h4&gt;
&lt;p&gt;在程序中比较常用的是&lt;strong&gt;数据库连接池&lt;/strong&gt;、&lt;strong&gt;线程池&lt;/strong&gt;、&lt;strong&gt;日志对象&lt;/strong&gt;等等。&lt;/p&gt;
&lt;h4 id=&quot;单例模式使用&quot;&gt;单例模式使用&lt;/h4&gt;
&lt;p&gt;单例模式的写法主要有5种，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;饿汉式&lt;/strong&gt;: 简单安全, 效率低;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;饱汉式&lt;/strong&gt;: 简单不安全, 效率高 ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态内部类&lt;/strong&gt;: 安全, 效率高;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双重锁检查&lt;/strong&gt;: 复杂安全, 效率高;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;枚举单例&lt;/strong&gt;：简单安全, 效率高；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;单例模式示例图&quot;&gt;单例模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217202935684.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;单例模式总结&quot;&gt;单例模式总结&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;构造方法私有化（private）;&lt;/li&gt;
&lt;li&gt;定义一个私有(private)静态(static)实例化对象;&lt;/li&gt;
&lt;li&gt;对外提供一个公共(public)静态(static)的方法得到该实例;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;工厂模式&quot;&gt;工厂模式&lt;/h3&gt;
&lt;p&gt;工厂模式主要有三种，简单工厂模式、工厂方法模式和抽象工厂模式。但是一般的情况下我们主要用到的是工厂方法模式和抽象工厂模式。&lt;/p&gt;
&lt;h4 id=&quot;工厂方法模式介绍&quot;&gt;工厂方法模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其核心是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;工厂方法模式使用场景&quot;&gt;工厂方法模式使用场景&lt;/h4&gt;
&lt;p&gt;比如生活中的汽车制造，大名鼎鼎的&lt;strong&gt;hibernate&lt;/strong&gt;框架在选择数据库方言这块。&lt;/p&gt;
&lt;h4 id=&quot;工厂方法模式示例图&quot;&gt;工厂方法模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217203523292.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;抽象工厂模式介绍&quot;&gt;抽象工厂模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;主要核心是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;抽象工厂模式使用场景&quot;&gt;抽象工厂模式使用场景&lt;/h4&gt;
&lt;p&gt;比如生活中的服装制造厂，可以单独制造衣服、裤子、袜子等等，也可以生产一套服装。&lt;/p&gt;
&lt;h4 id=&quot;抽象工厂模式示例图&quot;&gt;抽象工厂模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217203439887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;建造者模式&quot;&gt;建造者模式&lt;/h3&gt;
&lt;h4 id=&quot;建造者模式介绍&quot;&gt;建造者模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br/&gt;简单的来说就是将一个复杂的东西抽离出来，对外提供一个简单的调用，可以在同样的构建过程创建不同的表示。和工厂模式很相似，不过相比而言更加注重组件的装配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;建造者模式使用场景&quot;&gt;建造者模式使用场景&lt;/h4&gt;
&lt;p&gt;适用一些基本组件不便，但是组合经常变化的时候。比如超市促销的大礼包。&lt;/p&gt;
&lt;h4 id=&quot;建造者模式角色&quot;&gt;建造者模式角色&lt;/h4&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Builder：指定一个抽象的接口，规定该产品所需实现部件的创建，并不涉及具体的对象部件的创建。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ConcreteBuilder：需实现Builder接口，并且针对不同的逻辑，进行不同方法的创建，最终提供该产品的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Director：用来创建复杂对象的部分，对该部分进行完整的创建或者按照一定的规则进行创建。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Product：示被构造的复杂对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;建造者模式优缺点&quot;&gt;建造者模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建造者独立，易扩展。&lt;/li&gt;
&lt;li&gt;便于控制细节风险。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内部结构复杂，不易于理解。&lt;/li&gt;
&lt;li&gt;产品直接需要有共同点，范围有控制。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;建造者模式示例图&quot;&gt;建造者模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217213007743.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;原型模式&lt;/h3&gt;
&lt;h4 id=&quot;原型模式介绍&quot;&gt;原型模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。核心是克隆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;原型模式使用场景&quot;&gt;原型模式使用场景&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;类初始化的时候需要消耗大量资源的时候；&lt;/li&gt;
&lt;li&gt;获取数据库连接繁琐的时候；&lt;/li&gt;
&lt;li&gt;一个对象，有很多个修改者的时候；&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;原型模式优缺点&quot;&gt;原型模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;br/&gt;1.可以提升性能；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;br/&gt;1.因为必须实现Cloneable 接口，所以用起来可能不太方便。&lt;/p&gt;
&lt;h4 id=&quot;原型模式示例图&quot;&gt;原型模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217213235420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结构型模式&quot;&gt;结构型模式&lt;/h2&gt;
&lt;h3 id=&quot;适配器模式&quot;&gt;适配器模式&lt;/h3&gt;
&lt;h4 id=&quot;适配器模式介绍&quot;&gt;适配器模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。简单的来说就是通过某个接口将不兼容的两个类进行兼容，俗称转换器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;适配器模式使用&quot;&gt;适配器模式使用&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;适配器模式主要有两种类型，一种是类适配器模式，主要通过继承来实现适配器功能；一种是对象适配器模式，通过组合来实现适配器功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;适配器模式使用场景&quot;&gt;适配器模式使用场景&lt;/h4&gt;
&lt;p&gt;电器的电压，经典的jdbc使用。&lt;/p&gt;
&lt;h4 id=&quot;适配器模式优缺点&quot;&gt;适配器模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;提升了类的复用和灵活度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用过多，系统会比较杂乱，难以把握。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;适配器模式示例图&quot;&gt;适配器模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217213605109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;桥接模式&quot;&gt;桥接模式&lt;/h3&gt;
&lt;h4 id=&quot;桥接模式介绍&quot;&gt;桥接模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;桥接是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。通过一个中间的桥梁对两边的东西进行关联起来，但是关联的两者之间又不相互影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;桥接模式场景&quot;&gt;桥接模式场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;桥接模式优缺点&quot;&gt;桥接模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、抽象和实现的分离，实现了解耦；&lt;br/&gt;2、提升的扩展能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;会使系统看起复杂，对新手不友好，没有一定的抽象进行设计能力难以理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;桥接模式示例图&quot;&gt;桥接模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217213743508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;外观模式&quot;&gt;外观模式&lt;/h3&gt;
&lt;h4 id=&quot;外观模式介绍&quot;&gt;外观模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;外观模式隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。它向现有的系统添加一个接口，来隐藏系统的复杂性。对外提供一个简单接口，隐藏实现的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;外观模式使用场景&quot;&gt;外观模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;系统中有多个复杂的模块或者子系统的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;外观模式优缺点&quot;&gt;外观模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;降低了耦合，从某种方面来说也提升了安全性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不符合开闭原则，不易更改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;外观模式示例图&quot;&gt;外观模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217213927721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;装饰器模式&quot;&gt;装饰器模式&lt;/h3&gt;
&lt;h4 id=&quot;装饰器模式介绍&quot;&gt;装饰器模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。&lt;br/&gt;把某个东西进行装饰起来，让它可以提供一些额外的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;装饰器模式使用场景&quot;&gt;装饰器模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原型不变，动态增加一些功能的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;装饰器模式优缺点&quot;&gt;装饰器模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;装饰类和被装饰类可以独立发展，耦合度低，易于扩展，灵活方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;过多的对某个类进行装饰，会增加复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;装饰器模式示例图&quot;&gt;装饰器模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217214208674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;组合模式&quot;&gt;组合模式&lt;/h3&gt;
&lt;h4 id=&quot;组合模式介绍&quot;&gt;组合模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;组合模式是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;组合模式使用场景&quot;&gt;组合模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以表示为 ‘&lt;strong&gt;部分-整体&lt;/strong&gt;’的层级结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;组合模式优缺点&quot;&gt;组合模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;高层模块调用较为简单，增加某个节点方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因为其子节点的声明都是实现类，而不是接口，违反了依赖倒置原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;组合模式示例图&quot;&gt;组合模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217214413922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;过滤器模式&quot;&gt;过滤器模式&lt;/h3&gt;
&lt;h4 id=&quot;过滤器模式介绍&quot;&gt;过滤器模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;过滤器模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;过滤器模式使用场景&quot;&gt;过滤器模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要进行筛选的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;过滤器模式优缺点&quot;&gt;过滤器模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;简单，解耦，使用方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;过多使用需要注意性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;过滤器模式注意事项&quot;&gt;过滤器模式注意事项&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在jdk1.8以后可以使用steam的方法进行过滤分组，可以根据指定的条件进行过滤分组筛选。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;享元模式&quot;&gt;享元模式&lt;/h3&gt;
&lt;h4 id=&quot;享元模式介绍&quot;&gt;享元模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;享元模式角色&quot;&gt;享元模式角色&lt;/h4&gt;
&lt;p&gt;享元模式的角色主要分为三大类，抽象享元类、具体享元类以及享元工厂类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象享元类：所有具体享元类的超类或者接口，通过这个接口，可以接受并作用于外部专题。&lt;/li&gt;
&lt;li&gt;具体享元类：实现抽象享元类接口的功能并增加存储空间。&lt;/li&gt;
&lt;li&gt;享元工厂类：用来创建并管理抽象享元类对象，它主要用来确保合理地共享。每当接受到一个请求是，便会提供一个已经创建的抽象享元类对象或者新建一个。 享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在 ，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;享元模式使用场景&quot;&gt;享元模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;系统有大量相似对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;享元模式优缺点&quot;&gt;享元模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;极大的减少对象的创建，从而降低了系统的内存，提升了效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提高了系统的复杂度，因为需要将状态进行分离成内部和外部，并且也使外部状态固有化，使得随着内部状态的变化而变化，会造成系统的混乱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;享元模式注意事项&quot;&gt;享元模式注意事项&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要注意划分外部状态和内部状态，否则可能会引起线程安全问题。 这些类必须有一个工厂对象加以控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;与单例模式比较&quot;&gt;与单例模式比较&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;虽然它们在某些方面很像，但是实际上却是不同的东西，单例模式的目的是限制创建多个对象，避免冲突，比如使用数据库连接池。而享元模式享元模式的目的是共享，避免多次创建耗费资源，比如使用String类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;享元模式示例图&quot;&gt;享元模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217215202385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代理模式&quot;&gt;代理模式&lt;/h3&gt;
&lt;h4 id=&quot;代理模式介绍&quot;&gt;代理模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;主要是通过一个类代表另一个类的功能。通常，我们创建具有现有对象的对象，以便向外界提供功能接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;代理模式角色&quot;&gt;代理模式角色&lt;/h4&gt;
&lt;p&gt;代理模式主要由这三个角色组成，抽象角色、代理角色和真实角色。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象角色：通过接口或抽象类声明真实角色实现的业务方法。&lt;/li&gt;
&lt;li&gt;代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。&lt;/li&gt;
&lt;li&gt;真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;代理模式使用&quot;&gt;代理模式使用&lt;/h4&gt;
&lt;p&gt;代理模式又分为静态代理、动态代理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。&lt;/li&gt;
&lt;li&gt;动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。可以使用JDK中&lt;code&gt;java.lang.reflect&lt;/code&gt;来进行开发。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;代理模式使用场景&quot;&gt;代理模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、远程代理。&lt;br/&gt;2、虚拟代理。&lt;br/&gt;3、Copy-on-Write 代理。&lt;br/&gt;4、保护（Protect or Access）代理。&lt;br/&gt;5、Cache代理。&lt;br/&gt;6、防火墙（Firewall）代理。&lt;br/&gt;7、同步化（Synchronization）代理。&lt;br/&gt;8、智能引用（SmartReference）代理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;代理模式优缺点&quot;&gt;代理模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、职责清晰。&lt;br/&gt;2、高扩展性。&lt;br/&gt;3、智能化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。&lt;br/&gt;2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;代理模式注意事项&quot;&gt;代理模式注意事项&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。&lt;br/&gt;和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;代理模式示例图&quot;&gt;代理模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217215608661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;行为型模式&quot;&gt;行为型模式&lt;/h2&gt;
&lt;h3 id=&quot;责任链模式&quot;&gt;责任链模式&lt;/h3&gt;
&lt;h4 id=&quot;责任链模式介绍&quot;&gt;责任链模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;责任链模式顾名思义，就是为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。&lt;br/&gt;简单的理解的话就是进行层级处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;责任链模式角色&quot;&gt;责任链模式角色&lt;/h4&gt;
&lt;p&gt;责任链模式主要由这三个角色组成，请求接收者接口(Handler)、请求实现者类(ConcreteHandler)和请求发送者(Client)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求接收者接口：定义可以处理客户端请求事项的接口，包含“可链接下一个同样能处理请求”的对象引用。&lt;/li&gt;
&lt;li&gt;请求实现者类：实现请求处理接口，并判断对象本身是否能够处理本次请求，如果不能完成请求，则交由后继者来处理。&lt;/li&gt;
&lt;li&gt;请求发送者：将请求发送给第一个接收者对象，并等待请求的回复。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;责任链模式使用场景&quot;&gt;责任链模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要动态指定处理某一组请求时，在不确定接受者的的情况下，向多个对象发送请求时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;责任链模式优缺点&quot;&gt;责任链模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;耦合度低，请求者和执行者并没有必然的联系；&lt;br/&gt;灵活度高，可以通过内部成员来进行更改它们执行的次序；&lt;br/&gt;扩展性好，Handler的子类扩展非常方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;会在某程度上降低程序的性能，设置不当的话可能会出现循环调用。&lt;br/&gt;在链过长时，会降低代码的阅读性以及增加代码的复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;责任链模式注意事项&quot;&gt;责任链模式注意事项&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;虽然责任链模式很灵活，但是牺牲的是一定的性能，因为责任链模式是层级处理，在处理数据的有一定的延迟，所所以需要低延迟的情况下，不推荐使用责任链模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;责任链模式示例图&quot;&gt;责任链模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217215816696.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;命令模式&quot;&gt;命令模式&lt;/h3&gt;
&lt;h4 id=&quot;命令模式介绍&quot;&gt;命令模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令模式顾名思义，是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。&lt;br/&gt;也就是将一个请求封装成一个对象，从而可以用不同的请求对客户进行参数化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;命令模式角色&quot;&gt;命令模式角色&lt;/h4&gt;
&lt;p&gt;命令模式主要由这三个角色组成，命令对象(command)、命令执行对象(received)和命令请求对象(invoker)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令对象：通过接口或抽象类声明实现的方法。&lt;/li&gt;
&lt;li&gt;命令执行对象：实现命令对象的方法，并将一个接收者和动作进行绑定，调用接收者相应的操作。&lt;/li&gt;
&lt;li&gt;命令请求对象：用于执行这个请求，可以动态的对命令进行控制。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;命令模式使用场景&quot;&gt;命令模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果在有类似&lt;code&gt;命令&lt;/code&gt;需要指定的，就可以用命令模式，比如记录日志、撤销操作命令等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;命令模式优缺点&quot;&gt;命令模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;耦合度低，请求者和执行者并没有必然的联系；&lt;br/&gt;扩展性好，Command的子类可以非常容易地扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果命令过多的话，会增加系统的复杂度 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;命令模式示例图&quot;&gt;命令模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217215953885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解释器模式&quot;&gt;解释器模式&lt;/h3&gt;
&lt;h4 id=&quot;解释器模式介绍&quot;&gt;解释器模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;解释器模式顾名思义，就是对某事物进行解释。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。&lt;br/&gt;解释器模式其实就是对某事物进行解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解释器模式角色&quot;&gt;解释器模式角色&lt;/h4&gt;
&lt;p&gt;解释器模式主要由这四个角色组成，抽象表达式(Expression)角色、终结符表达式(Terminal Expression)角色、非终结符表达式(Nonterminal Expression)角色和环境(Context)角色。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。&lt;/li&gt;
&lt;li&gt;终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。&lt;/li&gt;
&lt;li&gt;非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。&lt;/li&gt;
&lt;li&gt;环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;解释器模式使用场景&quot;&gt;解释器模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个简单的语法规则需要解释的场景，比如sql。&lt;br/&gt;有重复的问题的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解释器模式优缺点&quot;&gt;解释器模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;扩展性好，子类扩展非常方便。&lt;br/&gt;实现简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可使用的场景比较少；&lt;br/&gt;类过多的话，会使代码臃肿，难以维护；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解释器模式示例图&quot;&gt;解释器模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018121722020782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/h3&gt;
&lt;h4 id=&quot;迭代器模式介绍&quot;&gt;迭代器模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示，属于行为型模式。 它提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;迭代器模式角色&quot;&gt;迭代器模式角色&lt;/h4&gt;
&lt;p&gt;迭代器模式主要由这四个角色组成，迭代器角色（Iterator）、具体迭代器角色（Concrete Iterator）、容器角色（Container）和具体容器角色（Concrete Container）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;迭代器角色（Iterator）：通过接口或抽象类声明实现的方法。&lt;/li&gt;
&lt;li&gt;具体迭代器角色（Concrete Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。&lt;/li&gt;
&lt;li&gt;容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。&lt;/li&gt;
&lt;li&gt;具体容器角色（Concrete Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;迭代器模式使用场景&quot;&gt;迭代器模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要为聚合对象提供遍历的功能的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;迭代器模式优缺点&quot;&gt;迭代器模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;灵活度高，可以通过不同的方式遍历对象；&lt;br/&gt;扩展性好，可以很方便的增加新的聚合类和迭代器类而不用修改之前的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;迭代器模式示例图&quot;&gt;迭代器模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018121722045025.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;访问者模式&quot;&gt;访问者模式&lt;/h3&gt;
&lt;h4 id=&quot;访问者模式介绍&quot;&gt;访问者模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;访问者模式（VisitorPattern），顾名思义使用了这个模式后就可以在不修改已有程序结构的前提下，通过添加额外的&lt;strong&gt;访问者&lt;/strong&gt;来完成对已有代码功能的提升，它属于行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。&lt;br/&gt;其主要目的是将数据结构与数据操作分离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;访问者模式角色&quot;&gt;访问者模式角色&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;访问者模式&lt;/strong&gt;主要由这五个角色组成，抽象访问者(Visitor)、具体访问者(ConcreteVisitor)、抽象节点(Node)、具体节点(ConcreteNode)和结构对象(ObjectStructure)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象访问者(Visitor)角色：声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。&lt;/li&gt;
&lt;li&gt;具体访问者(ConcreteVisitor)角色：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。&lt;/li&gt;
&lt;li&gt;抽象节点(Node)角色：声明一个接受操作，接受一个访问者对象作为一个参数。&lt;/li&gt;
&lt;li&gt;具体节点(ConcreteNode)角色：实现了抽象节点所规定的接受操作。&lt;/li&gt;
&lt;li&gt;结构对象(ObjectStructure)角色：有如下的责任，可以遍历结构中的所有元素。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;访问者模式使用场景&quot;&gt;访问者模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作；&lt;br/&gt;需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，也不希望在增加新操作时修改这些类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;访问者模式优缺点&quot;&gt;访问者模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;访问者模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能；&lt;br/&gt;符合单一职责原则，通过访问者将无关的行为分离，使职责单一；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;访问者模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;违反了迪米特原则，因为具体元素对访问者公布细节；&lt;br/&gt;违反了依赖倒置原则，依赖了具体类，没有依赖抽象；&lt;br/&gt;对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;访问者模式示例图&quot;&gt;访问者模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181105203837733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;中介者模式&quot;&gt;中介者模式&lt;/h3&gt;
&lt;h4 id=&quot;中介者模式介绍&quot;&gt;中介者模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;中介者模式（Mediator Pattern），定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为，属于行为型模式。&lt;br/&gt;其主要的目的是用来降低多个对象和类之间的通信复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;中介者模式角色&quot;&gt;中介者模式角色&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;主要由这四个角色组成， 抽象中介者(Mediator)、具体中介者(ConcreteMediator)、 抽象同事类(Colleague)和具体同事类(ConcreteColleague) 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象中介者(Mediator): 定义了同事对象到中介者对象之间的接口。&lt;/li&gt;
&lt;li&gt;具体中介者(ConcreteMediator): 实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。&lt;/li&gt;
&lt;li&gt;抽象同事类(Colleague): 定义了中介者对象的接口，它只知道中介者而不知道其他的同事对象。&lt;/li&gt;
&lt;li&gt;具体同事类(ConcreteColleague) : 每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;中介者模式使用场景&quot;&gt;中介者模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;中介者模式优缺点&quot;&gt;中介者模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;灵活性高，因为将同事类进行了解耦，使其不必有关联性；&lt;br/&gt;降低了类的复杂度，将一对多转化成了一对一；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;中介者使用过多，会使系统变得复杂难以维护；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;中介者模式注意事项&quot;&gt;中介者模式注意事项&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若不明确各个类的职责，那么就不要进行使用！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;和外观模式、代理模式比较&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;中介者模式和外观模式、代理模式比较类似，但是又有不同。&lt;br/&gt;和外观模式比较，中介者模式中，同事类必须依赖与中介者，中介者也知道同事类；但是外观模式中，子系统是不需要知道外观类的存在，并且子系统是可以脱离外观模式的。&lt;br/&gt;和代理模式，代理模式的核心就是代理作用，主要还是对原先的类进行扩展或增加控制，比如进行权限控制；而中介者模式主要目的是为了减少对象之前的耦合，也就是同事类直接相互独立，互不影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;中介者模式示例图&quot;&gt;中介者模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181105211356878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;策略模式&quot;&gt;策略模式&lt;/h3&gt;
&lt;h4 id=&quot;策略模式介绍&quot;&gt;策略模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;策略模式（Strategy Pattern）属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。&lt;br/&gt;其主要目的是通过定义相似的算法，替换if else 语句写法，并且可以随时相互替换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;策略模式角色&quot;&gt;策略模式角色&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;策略模式&lt;/strong&gt;主要由这三个角色组成，环境角色(Context)、抽象策略角色(Strategy)和具体策略角色(ConcreteStrategy)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;环境角色(Context)：持有一个策略类的引用，提供给客户端使用。&lt;/li&gt;
&lt;li&gt;抽象策略角色(Strategy)：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。&lt;/li&gt;
&lt;li&gt;具体策略角色(ConcreteStrategy)：包装了相关的算法或行为。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;策略模式使用场景&quot;&gt;策略模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为；&lt;br/&gt;一个系统需要动态地在几种算法中选择一种;&lt;br/&gt;如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;策略模式优缺点&quot;&gt;策略模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;扩展性好，可以在不修改对象结构的情况下，为新的算法进行添加新的类进行实现；&lt;br/&gt;灵活性好，可以对算法进行自由切换；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用策略类变多，会增加系统的复杂度。；&lt;br/&gt;客户端必须知道所有的策略类才能进行调用；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;策略模式示例图&quot;&gt;策略模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181111152930787.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;模板模式&quot;&gt;模板模式&lt;/h3&gt;
&lt;h4 id=&quot;模板模式介绍&quot;&gt;模板模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 这种类型的设计模式属于行为型模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。&lt;br/&gt;模板模式，其主要的的思想就是做一个模板，提供给客户端进行调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;模板模式角色&quot;&gt;模板模式角色&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;模板模式&lt;/strong&gt;主要由抽象模板(Abstract Template)角色和具体模板(Concrete Template)角色组成。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;抽象模板(Abstract Template): 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤;定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;具体模板(Concrete Template): 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤;每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;模板模式使用场景&quot;&gt;模板模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有多个子类共有逻辑相同的方法；&lt;br/&gt;重要的、复杂的方法，可以考虑作为模板方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;模板模式优缺点&quot;&gt;模板模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;扩展性好，对不变的代码进行封装，对可变的进行扩展；&lt;br/&gt;可维护性好，因为将公共代码进行了提取，使用的时候直接调用即可；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为每一个不同的实现都需要一个子类来实现，导致类的个数增加，会使系统变得复杂；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;模板模式注意事项&quot;&gt;模板模式注意事项&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为防止恶意操作，一般模板方法都加上 final 关键词！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;模板模式示例图&quot;&gt;模板模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181113194037589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;https://www.dofactory.com/images/diagrams/net/template.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;备忘录模式&quot;&gt;备忘录模式&lt;/h3&gt;
&lt;h4 id=&quot;备忘录模式介绍&quot;&gt;备忘录模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;备忘录模式(Memento Pattern)用于保存一个对象的某个状态，以便在适当的时候恢复对象，该模式属于行为型模式。&lt;br/&gt;其主要目的是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。&lt;br/&gt;其主要的的思想就是备份。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;备忘录模式角色&quot;&gt;备忘录模式角色&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;备忘录模式&lt;/strong&gt;主要由这三个角色组成，备忘录角色(Memento)、发起人角色(Originator)和负责人(Caretaker)角色。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;备忘录(Memento)：主要的功能是包含要被恢复的对象的状态。&lt;/li&gt;
&lt;li&gt;发起人(Originator)：在创建的时候，会在备忘录对象中存储状态。&lt;/li&gt;
&lt;li&gt;负责人(Caretaker)：主要是负责从备忘录对象中恢复对象的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;备忘录模式使用场景&quot;&gt;备忘录模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要保存/恢复数据的相关状态场景；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;备忘录模式优缺点&quot;&gt;备忘录模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态；&lt;br/&gt;实现了信息的封装，使得用户不需要关心状态的保存细节；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;非常的消耗资源；&lt;br/&gt;客户端必须知道所有的策略类才能进行调用；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;备忘录模示例图&quot;&gt;备忘录模示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181122192355292.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;状态模式&quot;&gt;状态模式&lt;/h3&gt;
&lt;h4 id=&quot;状态模式介绍&quot;&gt;状态模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;状态模式（State Pattern）属于行为型模式，其状态的对象和一个行为随着状态对象改变而改变。&lt;br/&gt;其主要目的解决的是当控制一个对象状态转换的条件表达式过于复杂是的情况。把状态的判断逻辑转移到表示不同状态一系列类中，可以把复杂的判断简单化。&lt;br/&gt;主要的的思想就是提供一种状态，提供给客户端进行调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;状态模式角色&quot;&gt;状态模式角色&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;状态模式&lt;/strong&gt;主要由环境角色（Context）、 抽象状态（State）和具体状态（Concrete State）组成。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;环境角色（Context）: 它定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的具体状态对象来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;抽象状态角色(State): 定义一个接口以封装使用上下文环境的的一个特定状态相关的行为。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;具体状态角色（Concrete State）:实现抽象状态定义的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;状态模式使用场景&quot;&gt;状态模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;行为随状态改变而改变的场景；&lt;br/&gt;条件、分支语句的代替者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;状态模式优缺点&quot;&gt;状态模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;扩展性好，将和状态有关的行为放到一起，增加新的的状态，只需要改变对象状态即可改变对象的行为即可；&lt;br/&gt;复用性好，让多个环境对象共享一个状态对象，从而减少系统中对象的个数；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用状态模式会增加系统类和对象的个数，并且该模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱；&lt;br/&gt;状态模式对&quot;开闭原则&quot;的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;状态模式注意事项&quot;&gt;状态模式注意事项&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在行为受状态约束的时候使用状态模式，而且状态不超过5个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;和策略模式比较&lt;/strong&gt;&lt;br/&gt;在学习状态模式的时候，很容易和策略模式搞混，因为它们实在是太像了，很难区分，在查阅一番资料之后，整理了如下的相同点和区别点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相同点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它们很容易添加新的状态或策略，而且不需要修改使用它们的Context对象。&lt;/li&gt;
&lt;li&gt;它们都符合OCP原则，在状态模式和策略模式中，Context对象对修改是关闭的，添加新的状态或策略，都不需要修改Context。&lt;/li&gt;
&lt;li&gt;它们都会初始化。&lt;/li&gt;
&lt;li&gt;它们都依赖子类去实现相关行为。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;区别点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;状态模式的行为是平行性的，不可相互替换的；&lt;/li&gt;
&lt;li&gt;而策略模式的行为是平等性的，是可以相互替换的。&lt;/li&gt;
&lt;li&gt;最重要的一个不同之处是，策略模式的改变由客户端完成；&lt;/li&gt;
&lt;li&gt;而状态模式的改变，由环境角色或状态自己.&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;状态模式示例图&quot;&gt;状态模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181122192503391.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h3&gt;
&lt;h4 id=&quot;观察者模式介绍&quot;&gt;观察者模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;观察者模式又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。。&lt;br/&gt;其主要目的是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;观察者模式角色&quot;&gt;观察者模式角色&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;主要由这四个角色组成，抽象主题角色（Subject）、具体主题角色（ConcreteSubject）、抽象观察者角色（Observer）和具体观察者角色（ConcreteObserver）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象主题角色（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。&lt;/li&gt;
&lt;li&gt;具体主题角色（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。&lt;/li&gt;
&lt;li&gt;抽象观察者角色（Observer）：主要是负责从备忘录对象中恢复对象的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;观察者模式使用场景&quot;&gt;观察者模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要关联行为的场景；&lt;br/&gt;事件需要创建一个触发链的场景，比如监控；&lt;br/&gt;跨系统的消息交换场景，比如消息队列、事件总线的处理机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;观察者模式优缺点&quot;&gt;观察者模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；&lt;br/&gt;如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；&lt;br/&gt;观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;观察者模式注意事项&quot;&gt;观察者模式注意事项&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果顺序执行，某一观察者错误会导致系统卡壳，建议采用异步方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;观察者模式示例图&quot;&gt;观察者模式示例图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181128203250148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;空对象模式&quot;&gt;空对象模式&lt;/h3&gt;
&lt;h4 id=&quot;空对象模式介绍&quot;&gt;空对象模式介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;空对象模式（NullObject Pattern）主要是通过一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。 这样的Null 对象也可以在数据不可用的时候提供默认的行为。&lt;br/&gt;其主要目的是在进行调用是不返回Null，而是返回一个空对象，防止空指针异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;空对象模式使用场景&quot;&gt;空对象模式使用场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要大量对空值进行判断的时候；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;空对象模式优缺点&quot;&gt;空对象模式优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以加强系统的稳固性，能有效防止空指针报错对整个系统的影响；&lt;br/&gt;不依赖客户端便可以保证系统的稳定性；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要编写较多的代码来实现空值的判断，从某种方面来说不划算；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;在学习设计模式的时候，主要参考书籍是《大话设计模式》以及&lt;a href=&quot;http://www.runoob.com/design-pattern/design-pattern-tutorial.html&quot;&gt;菜鸟教程&lt;/a&gt;的设计模式介绍。&lt;br/&gt;其实在我们学习了这么多的设计模式中，大部分可能只是听说了解过，真正经常使用的设计模式也无外乎就那几种，单例模式(数据库、线程池场景)、工厂模式(简单的crud操作中实例化的model)、策略模式(商城会员、优惠打折场景)、观察者模式(消息推送场景)、代理模式（主要是动态代理这块)、外观模式(一键调用)、装饰器模式(锦上添花场景)，但是也不全这样，使用设计模式最好根据实际的场景来使用，否则可能在不合适的场景使用了不适合的设计模式而导致代码混乱。&lt;/p&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;往期音乐推荐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们目送 那渐渐消失的行迹云 在晃眼间消逝 总是如此短暂 如像昨天起 不变的事 始终不会改变 不该存在的东西 带着遗憾消失在指间&lt;br/&gt;那鸟儿还未能展翅高飞 但它总有一天会破风驰行 遥不可及的地方仍在远处 所以只能凝视深藏的愿望 孩子们走在盛夏的铁路上 流风轻抚着他们的赤脚 远离了童年&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;二、&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这世上大部分失落，都是因为我们自己没成为更好的自己，却奢求别人成为更好的别人。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;三、&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;平静孤寂的调子起头，两个人分开之后的沉寂 颓废，慢慢的音阶起伏，我意识到不能这样下去，我开始改变现状，变得积极。到高潮部分 我不在颓废，我走了新的目标 我迎着太阳前进。我想这就是You的含义，你是我的一段过去&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;四、&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;扶桑画师浅溪，居泰安，喜绘鲤。院前一方荷塘，锦鲤游曳，溪常与嬉戏。 其时正武德之乱，藩镇割据，战事频仍，魑魅魍魉，肆逆于道。兵戈逼泰安，街邻皆逃亡，独溪不舍锦鲤，未去。 是夜，院室倏火。有人入火护溪，言其本鲤中妖，欲取溪命，却生情愫，遂不忍为之。翌日天明，火势渐歇，人已不见。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;五、&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;稚儿擎瓜柳棚下，细犬逐蝶窄巷中，人间繁华多笑语，惟我空余两鬓风。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;六、&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;散落的花，火的碎片 诱人的夏夜终结&lt;br/&gt;渐渐 天空闪耀，带着谁许的愿&lt;br/&gt;突然绽放的烟花&lt;br/&gt;美丽如梦幻，迟来脆弱的夏天&lt;br/&gt;夜空中，火花舞动在今夜&lt;br/&gt;枝头落下的仲夏夜之梦&lt;br/&gt;愉快的凉风，热带的夜&lt;br/&gt;天空飘着细雨，在喧闹的蝉鸣时节&lt;br/&gt;夏末，秋天指向路边。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;七、&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;论如何一个人在家嗨成狗。取下耳机无限的孤独感。带上耳机卧槽我是全世界。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;八、&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我渴望能见你一面，但请你记得，我不会开口要求见你。这不是因为骄傲，你知道我在你面前毫无骄傲可言，而是因为，唯有你也想见我的时候，我们见面才有意义。 ———《越洋情书》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;九、&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;就算是Believe，中间也藏了一个lie；&lt;br/&gt;就算是Friend，还是免不了end；&lt;br/&gt;就算是Lover，还可能会over；&lt;br/&gt;就算是Wife，心里也夹杂着if；&lt;br/&gt;欣慰的是：即便是Forget，也曾经get，&lt;br/&gt;就算impossible，但还藏着possible。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;十、&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;人有三样东西是无法隐瞒的，咳嗽、穷困和爱；你想隐瞒越欲盖弥彰。人有三样东西是不该挥霍的，身体、金钱和爱；你想挥霍却得不偿失。人有三样东西是无法挽留的，时间、生命和爱；你想挽留却渐行渐远。人有三样东西是不该回忆的，灾难、死亡和爱；你想回忆却苦不堪言。 ——《洛丽塔》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;十一、&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单，重复，毫无华丽旋律，也无厚重悲凉的伴奏。但心偏偏就被紧紧的抓住了。一种茫然却被迫紧凑的感觉。一种不知何所处的心虚。what for？&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;十二、&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;轻吟一句情话，执笔一副情画。 绽放一地情花，覆盖一片青瓦。 共饮一杯清茶，同研一碗青砂。&lt;br/&gt;挽起一面轻纱，看清天边月牙。爱像水墨青花，何惧刹那芳华。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;十三、&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所有人和事，自己问心无愧就好，不是你的也别强求，反正离去的，都是风景，留下的，才是人生。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上评论来自网易云！&lt;/p&gt;
&lt;h3 id=&quot;项目的代码&quot;&gt;项目的代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;是本人在学习Java过程中记录的一些代码，也包括之前博文中使用的代码。如果感觉不错，希望顺手给个start，当然如果有不足，也希望提出。&lt;br/&gt;github地址: &lt;a href=&quot;https://github.com/xuwujing/java-study&quot; class=&quot;uri&quot;&gt;https://github.com/xuwujing/java-study&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot; class=&quot;uri&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Dec 2018 14:44:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本篇是讲述之前学习设计模式的一个总结篇，其目的是为了对这些设计模式的进行一个提炼总结，能够通过查看看此篇就可以理解一些设计模式的核心思想。 设计模式简介 什么是设计模式 设计模式是一套被反复使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/10134494.html</dc:identifier>
</item>
<item>
<title>EnjoyingSoft之Mule ESB基础系列第一篇：初识Mule ESB - EnjoyingSoft</title>
<link>http://www.cnblogs.com/enjoyingsoft/p/10132360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoyingsoft/p/10132360.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;我们在做企业集成项目的时候，经常会用到很多开源中间件，比如企业服务总线，消息中间件，服务框架等。在使用这些开源中间件的时候，我们也趟过了很多的坑，EnjoyingSoft，就是享受这些软件，其中积累的经验分享给大家，希望为开源事业做一份贡献。这篇系列主要说的是企业服务总线Mule ESB。&lt;/p&gt;
&lt;p&gt;Mule ESB在众多开源的ESB中处于领先者的地位，MuleSoft公司也作为独角兽，2017年在纽交所上市。我们作为MuleSoft的合作伙伴也有幸参与其中，在六年多的时间里，我们使用Mule ESB企业版实施，或者在社区版基础上扩展，使用Mule ESB社区版实施，帮助国内众多的企业成功上线SOA项目。&lt;/p&gt;
&lt;p&gt;使用Mule ESB的过程中，体会到其快速的开发效率，以及优秀的架构设计。同时也深感国内这块资料非常稀少，所以计划使用8篇文章来写Mule ESB的基础系列。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/enjoyingsoft/p/10132360.html&quot;&gt;EnjoyingSoft之Mule ESB基础系列第一篇：初识Mule ESB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;EnjoyingSoft之Mule ESB基础系列第二篇：Mule ESB基本概念&lt;/li&gt;
&lt;li&gt;EnjoyingSoft之Mule ESB基础系列第三篇：Mule message structure - Mule message结构&lt;/li&gt;
&lt;li&gt;EnjoyingSoft之Mule ESB基础系列第四篇：Mule Expression Language - MEL表达式&lt;/li&gt;
&lt;li&gt;EnjoyingSoft之Mule ESB基础系列第五篇：控制消息的流向-数据路由&lt;/li&gt;
&lt;li&gt;EnjoyingSoft之Mule ESB基础系列第六篇：Data Transform - 数据转换&lt;/li&gt;
&lt;li&gt;EnjoyingSoft之Mule ESB基础系列第七篇：SOAP Web Service的消费和创建&lt;/li&gt;
&lt;li&gt;EnjoyingSoft之Mule ESB基础系列第八篇：使用API构建Rest Service&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mule-esb基本介绍&quot;&gt;1. Mule ESB基本介绍&lt;/h2&gt;
&lt;p&gt;Mule ESB是世界上使用最广泛的开源企业服务总线（ESB）产品，已拥有超过数百万的下载量，以及来自世界各地数十万个开发人员，很多世界五百强企业选择Mule ESB作为企业集成平台。通过Mule，企业可以在短时间内轻松地创建并集成应用服务，Mule ESB消除了系统集成的复杂度，使开发人员能够在异构系统和服务之间，轻松地构建出高性能的集成应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217164521482-951567851.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和传统的ESB不一样，Mule ESB是一个轻量级的ESB，内核基于SEDA模型和Spring框架构建。基于Spring，意味有着非常灵活的扩展性。同时Mule ESB不仅仅是一个ESB，它也是流行的微服务体系中的一部分。这个系列我们着重介绍它的ESB功能，后续我们再着重介绍它的API管理等功能。&lt;/p&gt;
&lt;h2 id=&quot;mule-esb社区版和企业版&quot;&gt;2. Mule ESB社区版和企业版&lt;/h2&gt;
&lt;p&gt;和很多开源软件一样，Mule ESB分成两个版本，社区版和企业版。其中社区版是免费使用的。而企业版则需要付费订阅使用，功能更强大。如果企业预算充足，则可以选择企业版。或者使用Mule ESB社区版，在社区版基础上做扩展，在有技术支持的情况下，同样可以收到良好的效果。&lt;/p&gt;
&lt;p&gt;关于社区版和企业版的主要区别，可以参照下表。如何选择可以参考具体的业务场景和企业情况。Anyway，由于Mule ESB是开源的，我们在社区版上可以有很多的灵活扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217164557950-1776201263.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mule-esb常用场景&quot;&gt;3. Mule ESB常用场景&lt;/h2&gt;
&lt;p&gt;我们来说一下Mule ESB的常见应用场景，可以更好的理解Mule ESB到底可以帮助我们解决什么问题。&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;旧系统改造，开放系统的服务能力。举个例子，我们有一个电商系统，需要调用SAP ERP的订单接口来创建订单。这个时候就需要将SAP的订单服务暴露成我们流行的Rest Service接口，以方便电商系统调用。当然电商系统可以直接使用SAP的JCO包来调用SAP的BAPI Function，但显然暴露一个通用的Rest Service更易于调用。使用Mule ESB实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217164612140-1188691040.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;系统集成。举个例子，很多系统之间数据交互可能还是用FTP目录。尤其是企业跟企业之间的数据交互，比如，A企业丢一个EDI 文件到B企业的FTP目录，然后B企业会从FTP目录下载解析并放置到数据库。这个场景用Mule ESB实现就很方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217164626816-373060981.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ETL。市面上有很多开源的ETL软件，其实Mule ESB也有ETL的功能，通过Flow设定ETL的数据转换和数据流向。下图就演示了Mule的ETL和数据分发功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165035323-651476547.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;mule-esb软件安装&quot;&gt;4. Mule ESB软件安装&lt;/h2&gt;
&lt;p&gt;用一个相对宽泛的标准来划分，Mule ESB软件可以分成两部分。&lt;/p&gt;
&lt;p&gt;一部分是客户端，也就是基于Eclipse的Anypoint Studio，客户端就是用来开发集成应用的，通常面向的用户就是我们的开发人员。由于是基于Eclipse环境，所以Java开发人员会很熟悉，同时Anypoint Studio也可以集成Git，SVN，Maven，Junit，Jenkins等一系列生态工具。&lt;/p&gt;
&lt;p&gt;当然作为其他语言的开发人员也不用担心，Anypoint Studio是一个可视化的拖拽的开发环境，大部分的工作只需要使用鼠标拖拽组件，配置属性即可。&lt;/p&gt;
&lt;p&gt;还要一部分是服务端，也就是Mule Runtime，也可以称作Container，容器，注意不要跟Docker的概念混淆。这里的Container指的是Java Container，你可以大概想象成Tomcat类似的东西。客户端开发的应用就部署运行在Mule Runtime中。&lt;/p&gt;
&lt;p&gt;需要注意的是，Mule Runtime是一个独立的Container，只依赖JDK，并不依赖其他第三方的容器。服务器中只需要安装JDK和Mule Runtime，即可运行Mule应用。还有一种不太常见的做法，就是把Mule App跑在第三方的容器里(比如Tomcat等)，通过对容器的扩展来支持Mule App。不过我们不推荐这种做法，还是推荐使用独立的Mule Runtime，也就是官方说的Standalone版本。&lt;/p&gt;
&lt;h3 id=&quot;客户端安装&quot;&gt;客户端安装&lt;/h3&gt;
&lt;p&gt;Anypoint Studio是基于Eclipse构建的，你可以在这里下载到(&lt;a href=&quot;https://mule-studio.s3.amazonaws.com/6.4.4-U4/AnypointStudio-for-win-64bit-6.4.4-201803231844.zip&quot;&gt;Windows 64Bit&lt;/a&gt;，&lt;a href=&quot;https://mule-studio.s3.amazonaws.com/6.4.4-U4/AnypointStudio-for-macosx-64bit-6.4.4-201803231844.zip&quot;&gt;Mac 64Bit&lt;/a&gt;)。请根据你的客户端的操作系统选择对应的版本。我们只要在Windows或者Mac电脑上安装好JDK8之后，解压缩Zip包，双击即可打开。打开的界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165048930-1123016715.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于Anypoint Studio默认只内嵌了Mule ESB企业版运行时，如果你想使用社区版的话，我们还需要安装Mule ESB社区版运行时。为什么客户端也需要Runtime？这很容易理解，我们开发调试都需要使用Runtime，难道你编写代码后，不运行和调试吗-:)&lt;/p&gt;
&lt;p&gt;安装社区版运行时，可以使用下列步骤。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击Help/Install New Software...菜单&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Work with下拉框中选择Mule Runtimes for Anypoint Studio&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165106556-1256722786.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;选中Mule ESB Server Runtime 3.9.0 CE，CE就是Community Edition，社区版的意思。然后点击Next一直到完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;服务端安装&quot;&gt;服务端安装&lt;/h3&gt;
&lt;p&gt;服务端不区分操作系统，你可以从&lt;a href=&quot;https://repository-master.mulesoft.org/nexus/service/local/repositories/releases/content/org/mule/distributions/mule-standalone/3.9.0/mule-standalone-3.9.0.tar.gz&quot;&gt;这里&lt;/a&gt;下载到3.9.0版本的社区版Runtime。Mule ESB Runtime可以运行在Windows,Linux,Mac等操作系统上，我们推荐在生产环境使用Linux部署Mule ESB Runtime。服务端的安装也很简单，只要在服务器上安装好JDK8之后，解压缩Runtime即可。&lt;/p&gt;
&lt;h2 id=&quot;第一个mule-esb应用--hello-world&quot;&gt;5. 第一个Mule ESB应用- Hello world&lt;/h2&gt;
&lt;p&gt;我们学习新的语言和框架都会使用经典的Hello world程序，这里也不例外。我们要做的就是，使用Mule ESB建立一个HTTP服务，当用户访问HTTP端口后，返回Hello world。开发步骤很简单：&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;点击File/New/Mule Project，新建Mule工程，这里选择使用CE版，也就是社区版，然后一步步Next直到完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165119794-170793078.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;拖入HTTP组件到空白的画布中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165158643-615727007.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;选择画布上的Http组件，在属性页面新增Connector Configuration，在弹出窗口设定侦听的端口，注意不要和你本机的端口冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165218048-988387325.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;拖入Set Payload组件，在属性页面，设定Value值，Hello word。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165712140-1315127283.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在工程项目上右击弹出菜单，Run As/Mule Application。稍等片刻，Console窗口会出现&quot;Mule is up and kicking&quot;，表示Mule已经开始工作了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165728340-1260443715.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用Postman访问HTTP端口，返回Hello world，Mule。恭喜你，你是一个Mule开发者了 -:)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165744486-1053663714.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用Mule ESB上手非常简单，我们后续会介绍更多的组件，比如你需要从数据库获取数据，那么就使用Database，还有更多组件等待挖掘。&lt;/p&gt;
&lt;h2 id=&quot;部署mule-esb应用&quot;&gt;6. 部署Mule ESB应用&lt;/h2&gt;
&lt;p&gt;我们已经在客户端开发完成了Hello world，也顺利跑起来了。但是如何部署到服务端呢。和常见的Java开发一样，我们也需要打包应用。这里我们用的是普通工程，我们通过一个Export操作，即可导出Mule App（当然Mule App也支持Maven工程，可以通过Maven打包）。在工程项目上右击弹出菜单，Export...，然后在对话框中选择Anypoint Studio Project to Mule Deployable Archive。注意这里不要选中Attach project sources。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201812/1490365-20181217165759385-1281313899.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将导出的Zip包放入到Mule Runtime的apps目录下，然后启动Mule Runtime。如果是Linux或者mac，那么在Mule Runtime的bin目录下执行&lt;code&gt;./mule&lt;/code&gt;启动命令。如果是Windows，双击执行bin目录mule.bat即可启动。&lt;/p&gt;
&lt;p&gt;然后使用Postman访问服务器，你会得到和Studio一样的效果。&lt;/p&gt;
&lt;p&gt;本文同步发文于&lt;a href=&quot;http://www.enjoyingsoft.com/blogs/2018/12/17/mule-base-01/&quot;&gt;EnjoyingSoft之Mule ESB基础系列第一篇：初识Mule ESB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;a href=&quot;http://www.enjoyingsoft.com/&quot;&gt;EnjoyingSoft&lt;/a&gt; 网站，获取更多&lt;a href=&quot;http://www.enjoyingsoft.com/&quot;&gt;Mule ESB社区版实施&lt;/a&gt;帮助。&lt;/p&gt;
&lt;p&gt;欢迎转载，但必须保留原文和此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Dec 2018 13:57:00 +0000</pubDate>
<dc:creator>EnjoyingSoft</dc:creator>
<og:description>我们在做企业集成项目的时候，经常会用到很多开源中间件，比如企业服务总线，消息中间件，服务框架等。在使用这些开源中间件的时候，我们也趟过了很多的坑，EnjoyingSoft，就是享受这些软件，其中积累的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoyingsoft/p/10132360.html</dc:identifier>
</item>
<item>
<title>【Netty】(6) ---源码ServerBootstrap - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10134069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10134069.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;之前写了两篇与Bootstrap相关的文章，一篇是ServerBootstrap的父类，一篇是客户端Bootstrap类，博客地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10092919.html&quot;&gt;【Netty】源码AbstractBootstrap&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10105887.html&quot;&gt;【Netty】源码 Bootstrap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以接下来 有关ServerBootstrap 源码的分析，如果上面已经分析过了，就不再陈述。&lt;/p&gt;
&lt;h2 id=&quot;一概念&quot;&gt;&lt;span&gt;一、概念&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;ServerBootstrap可以理解为服务器启动的工厂类，我们可以通过它来完成服务器端的 Netty 初始化。&lt;br/&gt;作用职责:&lt;code&gt;EventLoop初始化&lt;/code&gt;,&lt;code&gt;channel的注册过程&lt;/code&gt; ,&lt;code&gt;关于pipeline的初始化&lt;/code&gt;,&lt;code&gt;handler的添加过程&lt;/code&gt;,服务端连接分析。&lt;br/&gt;下面也先看下源码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;​      // 定义一对线程组
​         // 主线程组, 用于接受客户端的连接，但是不做任何处理，跟老板一样，不做事
​         EventLoopGroup bossGroup = new NioEventLoopGroup();
​         // 从线程组, 老板线程组会把任务丢给他，让手下线程组去做任务
​         EventLoopGroup workerGroup = new NioEventLoopGroup();

     try {
         // netty服务器的创建, 辅助工具类，用于服务器通道的一系列配置
         ServerBootstrap serverBootstrap = new ServerBootstrap();
         serverBootstrap.group(bossGroup, workerGroup)           //绑定两个线程组
                        .channel(NioServerSocketChannel.class)   //指定NIO的模式
                        .handler(new LoggingHandler(LogLevel.INFO))
                        .childHandler(new HelloServerInitializer()); // 子处理器，用于处理workerGroup

         // 启动server，并且设置8088为启动的端口号，同时启动方式为同步
         ChannelFuture channelFuture = serverBootstrap.bind(8088).sync();

         // 监听关闭的channel，设置位同步方式
         channelFuture.channel().closeFuture().sync();
     } finally {
         //退出线程组
         bossGroup.shutdownGracefully();
         workerGroup.shutdownGracefully();
     }
 }&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;二源码解析&quot;&gt;&lt;span&gt;二、源码解析&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;groupbossgroup-workergroup&quot;&gt;&lt;span&gt;1、group(bossGroup, workerGroup)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里跟客户端明显的一个区别就是，客户端只传入了一个NioEventLoopGroup,而服务端传入了两个。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; /**
  * 这里调用的是 ServerBootstrap 类本身的 group 方法 发现传入的两个EventLoopGroup
  * 一个赋值给父类（AbstractBootstrap）,另一个赋值给 该对象本身属性
  */
 public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {

     //调用父类的group方法
     super.group(parentGroup);
     if (childGroup == null) {
         throw new NullPointerException(&quot;childGroup&quot;);
     }
     if (this.childGroup != null) {
         throw new IllegalStateException(&quot;childGroup set already&quot;);
     }
     this.childGroup = childGroup;
     return this;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在服务器端的初始化时, 我们设置一个是 bossGroup, 另一个是 workerGroup. 那么这两个 EventLoopGroup 到底是怎么分工的？&lt;br/&gt;&lt;code&gt;bossGroup 是用于服务端 的 accept 的, 即用于处理客户端的连接请求.workerGroup 它们负责客户端连接通道的 IO 操作&lt;/code&gt;。&lt;br/&gt;关于 bossGroup 与 workerGroup 的关系, 我们可以用如下图来展示（盗图）:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181217213710304-1631763761.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先, 服务器端 bossGroup 不断地监听是否有客户端的连接, 当发现有一个新的客户端连接到来时, bossGroup 就会为此连接初始化各项资源,然后从 workerGroup 中选出一个 EventLoop 绑定到此客户端连接中. 那么接下来的服务器与客户端的交互过程就全部在此分配的 EventLoop 中了。至于 bossGroup 和 workerGroup 和 channel 如何联系到一起的，等下面再讲bind(host)方法的时候在用源码展示，因为是通过&lt;code&gt;bind(host)&lt;/code&gt;开始将他们联系到一起的。&lt;/p&gt;

&lt;h3 id=&quot;channelnioserversocketchannel.class方法&quot;&gt;&lt;span&gt;2、channel(NioServerSocketChannel.class)方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里和上一篇说的channl是差不多的，具体源码可以看上一篇就可以了，只是这里传入的类是NioServerSocketChannel,而客户端是NioSocketChannel,但他们都是通过类的反射&lt;br/&gt;机制获得类的对象的。同样真正用到该对象的时候，也是在bind(host)方法里。&lt;/p&gt;
&lt;p&gt;有关NioServerSocketChannel对象和之前的NioSocketChannel对象本身是没有讲过的。&lt;/p&gt;

&lt;h3 id=&quot;handler和childhandler&quot;&gt;&lt;span&gt;3、handler()和childHandler()&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们跟客户端比较发现还是有明显区别的, 和 EventLoopGroup 一样, 服务器端的 handler 也有两个, 一个是通过 handler() 方法设置 handler 字段, 另一个是通过&lt;br/&gt;childHandler() 设置 childHandler 字段。&lt;code&gt;不过handler()方法并不是必须的，而childHandler()方法是必须调用的&lt;/code&gt;。&lt;br/&gt;看代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**handler(new LoggingHandler(LogLevel.INFO))
     * 
     * 我们发现channel方法调用的是父类(AbstractBootstrap)的方法
     * 所以这个 handler  字段与 accept 过程有关, 即这个 handler 负责处理客户端的连接请求
     */
    public B handler(ChannelHandler handler) {
        if (handler == null) {
            throw new NullPointerException(&quot;handler&quot;);
        }
        this.handler = handler;
        return self();
    }


    /** 再看childHandler(class)
     * 
     *很明显 这个childHandler 方法是属于ServerBootstrap 本身的方法
     * 所以推测: 这个childHandler 就是负责和客户端的连接的 IO 交互
     */
    public ServerBootstrap childHandler(ChannelHandler childHandler) {
        if (childHandler == null) {
            throw new NullPointerException(&quot;childHandler&quot;);
        }
        this.childHandler = childHandler;
        return this;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有关handler和childHandler在哪个地方会被运用，等下将bind()方法的时候，我们在看他的源码。&lt;/p&gt;
&lt;h3 id=&quot;bindhost方法&quot;&gt;&lt;span&gt;4、bind(host)方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;bind(host)才是整个流程的关键，前面做得只是初始化了一些netty客户端运行的对象(可以理解成只是创建了对象，并没有使用它），但真正用到这些这些对象，&lt;br/&gt;还是在&lt;code&gt;bind(host)&lt;/code&gt;方法里。我们一步一步跟着源码走，里面会省略一些不重要的代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        /**
         * 1、调用父类(AbstractBootstrap)的方法
         * &amp;lt;p&amp;gt;
         * 作用: 根据端口号 创建一个InetSocketAddress对象,用于连接连接服务器
         */
        public ChannelFuture bind(int inetPort) {
            return bind(new InetSocketAddress(inetPort));
        }

        /**
         * 2、继续调用父类(AbstractBootstrap)的方法
         * &amp;lt;p&amp;gt;
         * 作用: 做一些校验工作
         */
        public ChannelFuture bind(SocketAddress localAddress) {
            validate();
            if (localAddress == null) {
                throw new NullPointerException(&quot;localAddress&quot;);
            }
            return doBind(localAddress);
        }


        /**
         * 3、继续调用父类(AbstractBootstrap)的方法
         * &amp;lt;p&amp;gt;
         * 作用: 这个方法做了很多事情
         */
        private ChannelFuture doBind(final SocketAddress localAddress) {
            //3、1 具体看下面3、1的代码部分
            final ChannelFuture regFuture = initAndRegister();
            final Channel channel = regFuture.channel();

            ChannelPromise promise = channel.newPromise();
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        }
    }

    /**
     * 3、1  这步做了很多重要的事情
     */
    final ChannelFuture initAndRegister() {
        Channel channel = null;

        //这里终于调用newChannel方法了，这里就是之前BootStrap讲的ReflectiveChannelFactory对象的方法，这里的
        //channel 对象是NioServerSocketChannel。
        channel = channelFactory.newChannel();
        //这个方法也太重要了 和handle有关 下面3.1.1 讲它
        init(channel);

        //这里的group()获取的就是bootstrap ,这里面会调用next方法 来循环获取下一个channel 具体的我就不点进去分析了
        //这里group().register(channel) 将 bossGroup 和 NioServerSocketChannel 关联起来了.
        ChannelFuture regFuture = config().group().register(channel);

        return regFuture;
    }

    /**
     * 3.1.1 首先可以看到into的方法在父类(AbstractBootstrap)已经提供，只是子类写具体实现代码
     */
    abstract void init(Channel channel) throws Exception;

    /**
     * 我们再来看ServerBootstrap实现了init方法，这里面做了很多事
     * 比如workerGroup相关，还有handel相关
     */
    @Override
    void init(Channel channel) throws Exception {

        //通过channel获得ChannelPipeline，说明每一个channel都会对应一个ChannelPipeline
        ChannelPipeline p = channel.pipeline();

        //这里终于获得workerGroup 对象
        final EventLoopGroup currentChildGroup = childGroup;
        //这里获得childHandler对象
        final ChannelHandler currentChildHandler = childHandler;
        final Entry&amp;lt;ChannelOption&amp;lt;?&amp;gt;, Object&amp;gt;[] currentChildOptions;
        final Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt;[] currentChildAttrs;

        p.addLast(new ChannelInitializer&amp;lt;Channel&amp;gt;() {
            @Override
            public void initChannel(final Channel ch) throws Exception {
                final ChannelPipeline pipeline = ch.pipeline();
                //获得handel方法传入的对象
                ChannelHandler handler = config.handler();

                //这一步说明 .handler(new LoggingHandler(LogLevel.INFO))方法不是必须要的
                //如果你没有调handler方法也没有关系 ，因为它会在这路做一层判断
                if (handler != null) {
                    pipeline.addLast(handler);
                }

                //到这里线程就开始启动运行了 发现已经讲Channel,ChannelPipeline,workerGroup,childHandler等全部联系到了一起。
                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.addLast(new ServerBootstrapAcceptor(
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;源码博客推荐&quot;&gt;&lt;span&gt;源码博客推荐&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;有些源码自己也没有去分析 比如:NioServerSocketChannel对象本身,ChannelPipeline对象。&lt;br/&gt;下面推荐源码专题博客&lt;br/&gt;1、&lt;a href=&quot;https://segmentfault.com/a/1190000007282628&quot;&gt;Netty源码分析教程&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;https://blog.csdn.net/zxhoo/article/category/1800249&quot;&gt;Netty学习笔记&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;如果一个人充满快乐，正面的思想，那么好的人事物就会和他共鸣，而且被他吸引过来。同样，一个人老带悲伤，倒霉的事情也会跟过来。

                                                  ——在自己心情低落的时候，告诫自己不要把负能量带给别人。（大校14）
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 17 Dec 2018 13:46:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>【Netty】6 源码ServerBootstrap 之前写了两篇与Bootstrap相关的文章，一篇是ServerBootstrap的父类，一篇是客户端Bootstrap类，博客地址:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10134069.html</dc:identifier>
</item>
<item>
<title>GoogLeNetv4 论文研读笔记 - 范中豪</title>
<link>http://www.cnblogs.com/zhhfan/p/10134117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhfan/p/10134117.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1602.07261v1.pdf&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向传统体系结构中引入残差连接使网络的性能变得更好，这提出了一个问题，即将Inception架构与残差连接结合起来是否能带来一些好处。在此，研究者通过实验表明使用残差连接显著地加速了Inception网络的训练。也有一些证据表明，相比没有残差连接的消耗相似的Inception网络，残差Inception网络在性能上具有微弱的优势。针对是否包含残差连接的Inception网络，本文同时提出了一些新的简化网络，同时进一步展示了适当的激活缩放如何使得很宽的残差Inception网络的训练更加稳定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本研究中，研究者研究了当时最新的两个想法：残差连接和最新版的Inception架构。他们研究了使用残差连接来代替Inception架构中的过滤连接阶段，这将使Inception架构保持它的计算效率的同时获得残差连接方法的好处。除了将两者直接集成，也研究了Inception本身能否通过加宽和加深来变得更高效。为此，他们设计了Inception v4，相比v3，它有更加统一简化的网络结构和更多的inception模块&lt;/p&gt;
&lt;p&gt;在本文中，他们将两个纯Inception变体(Inception-v3和v4)与消耗相似的 Inception-ResNet混合版本进行比较。挑选的模型满足和非残差模型具有相似的参数和计算复杂度的约束条件。实验对组合模型的性能进行了评估，结果显示Inception-v4和Inception-ResNetv2的性能都很好，同时发现单个框架性能的提升不会引起组合性能大幅的提高&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;残差连接的作者认为残差连接在训练深度卷积模型是很有必要的，但是至少在图像识别上，本研究并不支持这一点，该实验表明使用残差连接来训练深度网络也不是很难做到。不过，残差连接所带来的潜在优势可能需要在更深网络结构中来展现。但是，使用残差连接确实能够极大地提高训练速度，这一点很值得肯定。&lt;/p&gt;
&lt;p&gt;残差连接&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213049860-1202199858.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为减少计算而优化的ResNet连接&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213102998-1597252613.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;纯Inception模块&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以前的Inception模块为了能够在内存中对整个模型进行拟合，采用分布式训练的方法，该方法将每个副本划分成一个含多个子网络的模型。然而，Inception结构是高度可调的，这就意味着各层滤波器的数量可以有多种变化，而整个训练网络的质量不会受到影响。为了优化训练速度，他们对层的尺寸进行调整以平衡多模型子网络的计算。因为TensorFlow的引入和为了优化，本研究对Inception块的每个网格尺寸进行了统一。以下所有架构图中，卷积层没有标记&quot;V&quot;的表示使用相同的填充原则，即它们的输出网格尺寸与它们的输入相匹配。标记了&quot;V&quot;的卷积层使用valid填充，即每个单元输入块全部包含在前几层中，同时输出激活图（output activation map）的网格尺寸也相应地减少&lt;/p&gt;
&lt;p&gt;Inception-v4网络整体架构&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213130074-754508728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Inception-v4和Inception-ResNet-v2网络结构，这是输入部分(&lt;strong&gt;Fig3&lt;/strong&gt;)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213147441-560748937.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Inception-v4网络的35 * 35 网格模块，对应Inception-v4的Inception-A&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213200966-2006637933.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Inception-v4网络的17 * 17 网格模块，对应Inception-v4的Inception-B&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213206812-1034801698.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Inception-v4网络的8 * 8 网格模块，对应Inception-v4的Inception-C&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213212054-2047815142.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;35 * 35 -&amp;gt; 17 * 17 的降维模块(&lt;strong&gt;Fig7&lt;/strong&gt;)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213219367-1882185025.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数设置&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213226708-112282521.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;17 * 17 -&amp;gt; 8 * 8 的网格缩减模块&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213236108-1821928396.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;残差Inception块&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;残差版本的Inception网络使用了比源Inception更廉价的Inception块。每个Inception块后紧连接着滤波膨胀层（没有激活函数的1×1卷积）以在相加之前放大滤波器组的维度，以实现输入的匹配。这样补偿了在Inception块中的降维。&lt;/p&gt;
&lt;p&gt;Inception-ResNet-v1与Inception-v3的计算代价相近，Inception-ResNet-v2与Inception-v4的计算代价相近。另一个研究使用的残差和非残差变体技术上的不同是：在Inception-ResNet上仅在传统层的顶部而非所有层的顶部中使用batch-normalization。这是因为研究者想要保持每个模型副本在单个GPU上就可以训练，在部分层的顶部忽略 batch-normalization能够增加Inception块的数量&lt;/p&gt;
&lt;p&gt;Inception-ResNet-v1和Inception-ResNet-v2网络完整架构&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213250263-375781893.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Inception-ResNet-v1&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络使用35*35网格模块(Inception-ResNet-A)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213259599-1079322662.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络的17*17网格模块(Inception-ResNet-B)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213306064-1913159996.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Fig7作为Reduction-A&lt;/p&gt;
&lt;p&gt;网络的17*17 -&amp;gt; 8*8网格缩减模块(Reduction-B)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213314200-262594541.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络的8*8网格模块(Inception-ResNet-C)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213319542-562369835.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络的主干(stem)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213326703-1836297099.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Inception-ResNet-v2&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fig3用于网络stem&lt;/p&gt;
&lt;p&gt;网络35*35的网格模块(Inception-ResNet-A)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213337862-1607800147.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络17*17网格模块(Inception-ResNet-B)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213344804-927012404.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Fig7用于Reduction-A&lt;/p&gt;
&lt;p&gt;网络17*17 -&amp;gt; 8*8网格缩减模块(Reduction-B)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213349620-868426774.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络8*8网格模块(Inception-ResNet-C)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213354480-2051015946.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对残差模块的缩放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;研究者发现如果滤波器数量超过1000，残差网络开始出现不稳定，同时网络会在训练过程早期便会出现“死亡”，意即经过成千上万次迭代，在平均池化（average pooling） 之前的层开始只生成0。通过降低学习率，或增加额外的batch-normalizatioin都无法避免这种状况。同时，发现在将残差模块添加到activation激活层之前，对其进行放缩能够稳定训练，通常来说将残差放缩因子定在0.1-0.3，即使缩放并不是完全必须的，它似乎并不会影响最终准确率，但是放缩能有益于训练的稳定性&lt;/p&gt;
&lt;p&gt;实验结果表明Inception-ResNet-v1,Inception-v4,Inception-ResNet-v2的错误率逐个降低并都比Inception-v3和BN-Inception表现的好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文详细呈现了三种新的网络结构&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Inception-ResNet-v1：混合Inception版本，它的计算效率与Inception-v3相近&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Inception-ResNet-v2：更加昂贵的混合Inception版本，明显改善了识别性能&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Inception-v4：没有残差连接的纯Inception变种，性能与Inception-ResNet-v2相近&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;研究者们研究了引入残差连接如何显著地提高Inception网络地训练速度。并且他们最新地模型仅仅凭借增加模型尺寸就能表现地优于他们现有的网络&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文研究了将Inception和残差连接相结合的效果，实验表明结合ResNet可以加速训练，同时提高性能，在构建 Inception-ResNet 网络同时，还设计了一个更深更优化的 Inception v4 模型，能达到相媲美的性能&lt;/p&gt;
&lt;p&gt;比较了一下文章中提到的三个网络的架构，然后发现，Inception-ResNet-v1与Inception-ResNet-v2，Inception-v4相比，最明显的差别是stem部分不同，特别是与Inception-ResNet-v2相比，其它部分几乎就只是卷积层数的变化，而在stem部分，其它两个使用相同的结构，使用的参数量的比较 4112 : 5344，同时v1这部分输出为35*35*256，其它两个输出为35*35*384，显然这里明显让v1吃亏了，其性能差的原因我觉得这个部分有很大的原因。之后Inception-ResNet-v2与Inception-v4相比，架构的总体结构可以看出是很相似的，最大的区别在于数据是否是直接传到下一层的，如下&lt;/p&gt;
&lt;p&gt;Inception-v4(Inception-A)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213411648-2115765491.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Inception-ResNet-v2（Inception-A）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213422060-378530456.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Inception-v4(Reduction-B)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213428579-1975715734.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Inception-ResNet-v2（Reduction-B）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181217213434167-1374256802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人感觉差别不是很大，很直观地可以看出因为Inception-ResNet-v2使用的变换较少，计算量较小，因而可以获得更好的性能吧，其它的更多是各种参数的问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/10121938.html&quot;&gt;GoogLeNetv1 论文研读笔记&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/10121965.html&quot;&gt;GoogLeNetv2 论文研读笔记&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/10122019.html&quot;&gt;GoogLeNetv3 论文研读笔记&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/10124903.html&quot;&gt;ResNet 论文研读笔记&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Dec 2018 13:39:00 +0000</pubDate>
<dc:creator>范中豪</dc:creator>
<og:description>GoogLeNet v4 即 Inception-v4介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhfan/p/10134117.html</dc:identifier>
</item>
</channel>
</rss>