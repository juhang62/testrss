<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>写作的意义 - KiwenLau</title>
<link>http://www.cnblogs.com/kiwenlau/p/the-value-of-writing.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kiwenlau/p/the-value-of-writing.html</guid>
<description>&lt;p&gt;我的个人公众号&lt;strong&gt;寒雁Talk&lt;/strong&gt;开通有一段时间了，一直在思考应该写点什么，毕竟是第1篇嘛。&lt;/p&gt;
&lt;p&gt;这半年时间，我没有发布博客，不过积累了不少话题，也有一些未完成的文章，但是，我意识到，&lt;strong&gt;写什么内容其实并不重要，重要的是写作本身。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的个人博客（&lt;strong&gt;&lt;a href=&quot;https://kiwenlau.com&quot;&gt;https://kiwenlau.com&lt;/a&gt;&lt;/strong&gt;）已经写了接近5年了，一共185篇，接近20万字，除去翻译和产品博客，大概也有&lt;strong&gt;10万字&lt;/strong&gt;。写得不算太多，也不算少。所以，对于写作这件事，我还是有一些感悟的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;写作是一件具有长期价值的事情，这一点类似于健身与读书。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;最重要的职业技能&quot;&gt;最重要的职业技能&lt;/h3&gt;
&lt;p&gt;当我和导师讨论要不要读博的时候，他没有去强调学术研究以及博士学位本身的价值，而提到了一点：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;读博可以训练写作能力，这一点对于职业生涯是非常关键的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;导师对于写作确实要求非常严谨，他会逐字逐句地批阅我的论文，认真检查各种细节，比如标点、错别字、引用资料、行文逻辑等。这的确帮助我提高了写作能力，养成了更加严谨的写作习惯。我在写博客的时候，也会和写论文一样认真阅读引用资料，并把引用资料列在文章后面。&lt;/p&gt;
&lt;p&gt;工作几年之后，我才真正理解导师说的话。写作确实是&lt;strong&gt;最重要的职业技能&lt;/strong&gt;之一。&lt;/p&gt;
&lt;p&gt;作为程序员，我们最重要的事情大概是写代码，写足够Clean的代码。当然，写Clean Code这一点大部分人是做不到的，这是另外一个话题。如果代码写得好的话，已经很不错了，不过，想要进一步突破的话，还需要足够强的写作能力。&lt;/p&gt;
&lt;p&gt;程序员并不是整天都在写代码，仔细想想，其实写文字的事情也并不少，我们要写comment，写commit，写readme，写开发方案，写技术文档，写内部技术博客，写日报，写周报，写会议记录，写述职报告等等。很多人并不会把与技术强相关的内容（比如comment、commit、readme、技术方案、技术文档）当做写作，所以就放飞自我了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;comment和commit随便写，没人看得懂，自己都看不懂。&lt;/li&gt;
&lt;li&gt;readme一般不写，大部分都是脚手架生成的内容，谁也不知道这个项目最基本的信息，干什么的？有PRD、设计稿、API文档链接么？有啥要点？有重要的参考资料吗？&lt;/li&gt;
&lt;li&gt;开发方案不存在的，需求看起来挺简单的，上来就是撸代码，遇到问题再说，大不了推倒重来。&lt;/li&gt;
&lt;li&gt;技术文档不写，想用的话自己看代码啊，很简单的，或者勉强写一点文档，改天自己也得看代码才知道是咋回事。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从短期来看，这些东西不写或者随便写貌似不影响写代码，甚至还可以“提高效率”，这也是大部分人的借口。但是，从长远来看，对自己、对同事、对职业生涯都是一种严重的伤害。当我们正在做一个项目时候，有些简单的信息确实很容易查到的，但是用不了多久，就需要花很多时间去查询，所以很多时候都是在坑自己，当然有时也会坑别人尤其是新人。坑的人多了，会给大家一种不靠谱的感觉，职业发展也是非常有限的。&lt;/p&gt;
&lt;p&gt;写作能力强的人，理解写下来的重要性，也知道要写什么，还懂得怎么写，对文字型的工作会更加认真，做事会靠谱很多，大家都喜欢和他共事，潜力当然大。&lt;/p&gt;
&lt;p&gt;有个朋友曾经和我调侃：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;善于写作的程序员前途无量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话有点夸张，不过也算是从一个很有意思的角度总结了互联网行业，虽然程序员被莫名其妙地黑得很惨，但是国内外的互联网大佬大部分都是程序员，他们的写作能力都还不错，如果读过一些互联网大佬比如雷军、张一鸣等人的文章的话，应该可以体会到这一点。&lt;/p&gt;
&lt;h3 id=&quot;最有效的学习方式&quot;&gt;最有效的学习方式&lt;/h3&gt;
&lt;p&gt;写作大概是&lt;strong&gt;最有效的学习方式&lt;/strong&gt;之一了。哪怕写一个再小的话题，也可以发现自己一些不知道的或者忘掉的知识点。如果写长篇博客的话，较真起来大概要认真阅读数十篇博客，有时还需要翻书或者看Paper，因为很可能会触及最底层的知识点，这个时候我们才能真正认识到自己的“无知”。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当我在写&lt;a href=&quot;https://kiwenlau.com/2019/08/08/how-does-chrome-succeed/&quot;&gt;《Chrome是如何成功的？》&lt;/a&gt;的时候，我了解了Sundar Pichai是如何成为谷歌CEO的，理解了Chrome的产品哲学，即Speed, Security, Stability以及Simplicity（绝大多数产品都做不到）；&lt;/li&gt;
&lt;li&gt;当我在写&lt;a href=&quot;https://kiwenlau.com/2019/07/16/how-does-v8-work/&quot;&gt;《V8引擎是如何工作的？》&lt;/a&gt;的时候，我理解了JS是如何执行的，也明白了处于编程语言鄙视链底端的JS为什么可以在质疑声中迅速崛起（V8引擎功不可没）；&lt;/li&gt;
&lt;li&gt;当我在写&lt;a href=&quot;https://kiwenlau.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/&quot;&gt;《JavaScript黑客是这样窃取比特币的》&lt;/a&gt;的时候，我学到一些混淆代码的技巧，也发现了所谓Vue被攻击是不存在的（不要轻信标题党，他们没有去看代码）；&lt;/li&gt;
&lt;li&gt;当我在写&lt;a href=&quot;https://kiwenlau.com/2017/12/20/rethinking-unit-test/&quot;&gt;《重新思考单元测试》&lt;/a&gt;的时候，我重新梳理了单元测试的重要意义，理解了了应该如何把握单元测试的粒度；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是所谓的&lt;strong&gt;费曼学习法&lt;/strong&gt;，通过输出倒逼输入。这里所说的输入，有3层含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;梳理知识体系&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;写作可以帮助我们把零散的知识系统性地整理出来，一方面可以加深印象，另一方面可以作为备忘，随时查阅。我偶尔会翻阅自己写的博客，很多知识点细节是很容易忘掉的。如果可以将一个话题写一个系列的博客，则这样的收获会更加明显，碎片化的知识经过梳理之后，会成为具有完整逻辑的知识体系。做得更好一点，是可以写书的，我想这是很多写作者最美好的追求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;发现知识盲点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这大概是写作过程中最头疼也最有收获的一点了吧，每一个专业术语背后都可能有一个平时忽略的知识点。如果不搞清楚的话，我们会不知如何下笔。用一些写作技巧一笔带过，或者摘录他人的文字当然可以，但是这样是对自己的不负责任，也是对读者不负责任。对于不知道的东西，要么不写，要写的话就静下心来弄清楚，收获很多。如果每次写文章的时候，我们都可以多花点时间去研究那些不知道的东西，积累的知识也是相当可观的。听乔布斯的话，对未知的世界保持好奇心：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Stay foolish, Stay hungury. -- Steve Jobs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;锻炼思考能力&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于一个知识点，了解What是不够的，还应该理解Why，而写作的过程就是不断给自己提问的过程，当我们自己可以轻松回答这些问题的时候，写起来会顺畅很多，如果不懂装懂，最后写出来的文章也没有太大的价值。其实，很多问题并没有标准答案，因为场景不同，需要我自己独立去思考，形成自己的答案，用以指导自己的行为。正如我写这篇文章，更多地是给自己回答问题，为什么要坚持写作？写作的意义是什么？如果我没有很好的答案的话，我可能很难坚持下去。每一个独立的问题想清楚之后，还需要再将离散的片段按照一定的逻辑清晰地组织清楚，这很考验结构化的思考能力。&lt;/p&gt;
&lt;h3 id=&quot;最佳的个人品牌&quot;&gt;最佳的个人品牌&lt;/h3&gt;
&lt;p&gt;博客写得好，有读者，有粉丝，有流量，也算是“网红”吧。网红这个词有些负面，感觉像是靠一些肤浅甚至不堪的东西牟利，比如标题党、追热点、洗稿、盗图等，所以我倾向于用“个人品牌”这个词。&lt;/p&gt;
&lt;p&gt;不过，网红和个人品牌，在有一点上是殊途同归的，它们都意味着流量，而流量是可以直接或者间接变现的。互联网从PC时代，到移动时代，再到物联网时代，有一个公式是恒久不变的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;流量 = 钱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概创业过的人，对这一点会有更加深刻的理解。&lt;/p&gt;
&lt;p&gt;但是，网红和个人品牌还是有本质区别的，前者是为了快速变现，而后者看重的是长期价值。就写作这件事情而言，如果真的要打造个人品牌的话，应该更加珍惜自己的文字，不要为了流量去写作，要为了个人品牌去写作，写一些有价值、有诚意的东西。真正有价值的流量是靠优质的内容带来的，粗制滥造的内容是在贬低自己的品牌。&lt;/p&gt;
&lt;p&gt;创作优质内容的门槛并没有那么高，在前端领域，几乎所有人都看过阮一峰的博客，而他的博客都是非常浅显易懂的，很多博客篇幅也挺短的。不过，他的博客确实很有用，可以帮助我们解决开发过程中的一些实际问题。&lt;/p&gt;
&lt;p&gt;强调写作质量，并不意味着必须写深刻的内容或者长篇大论，写简单的内容也可以，如果可以写得足够清楚，而简单的内容其实受众更广。&lt;/p&gt;
&lt;p&gt;也正是因为阮一峰的博客比较简单了，有一些人会吐槽，似乎自己也能写，这就有点不自量力了。阮一峰的博客已经写了17年了，现在每月的PV是&lt;strong&gt;210万&lt;/strong&gt;。我估算了一下，阮一峰博客每年的广告收入大概是&lt;strong&gt;20万&lt;/strong&gt;，那些吐槽的人能做得到吗？至少我还做不到。&lt;/p&gt;
&lt;p&gt;如果可以靠写作直接变现，当然不错，不过这其实很难做到，需要很长时间积累。知名技术博客&lt;strong&gt;酷壳&lt;/strong&gt;的博主在某个知识付费平台做了一个课程，估计卖了好几百万，羡慕吧？其实他的博客也写了16年了，而且内容相对要复杂很多。&lt;/p&gt;
&lt;p&gt;对于我们这种还没写几年的业余写作者而言，不要对直接变现抱有太多期待，不现实，也没有这个必要，写作只是业余爱好，副业都远远谈不上。&lt;/p&gt;
&lt;p&gt;个人品牌虽然很难直接快速地变现，但是间接的好处还是挺多的，当然前提是创作优质的内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找工作：博客写得不错的人找工作更简单，博客可以看出一个人解决问题的思路，以及知识的深度与广度，对面试是加分的；&lt;/li&gt;
&lt;li&gt;工作邀请：博客写得非常优秀的人，其实不用找工作，会有人找你的，我招人的时候也是通过博客去找人；我自己也经常收到读者的工作邀请，这好像是在自夸了：）&lt;/li&gt;
&lt;li&gt;招聘：文章里放一些团队招聘信息还是有效果的，因为读者大多都是同行；&lt;/li&gt;
&lt;li&gt;影响力：通过树立个人品牌，打造行业内的影响力，认识更多优秀的同行；&lt;/li&gt;
&lt;li&gt;创业：如果你的博客流量还可以，是可以为产品导流的，我创业的时候就是这么干的，效果挺明显的；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;结尾&quot;&gt;结尾&lt;/h3&gt;
&lt;p&gt;如果真的有人因为我的博客，开始认真写作了，那就太好了。当然，这一点基本上是做不到的。所以，这篇文章是写给自己以及所有业余作者，我想大家会有一些共鸣，要相信写作这件事，继续坚持，不要在意短期的收益，做一个长期主义者。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Most people overestimate what they can do in one year and underestimate what they can do in ten years. -- Bill Gates.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，欢迎大家关注我的微信公众号&lt;strong&gt;寒雁Talk&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;招聘&quot;&gt;招聘&lt;/h3&gt;
&lt;p&gt;阿里巴巴业务平台事业部招聘P6及以上前端大佬，参与最前沿的阿里前端生态系统，一起探索数据中台技术，拥抱未来，内推地址：hanyan.lk@alibaba-inc.com&lt;/p&gt;
</description>
<pubDate>Fri, 03 Apr 2020 00:33:00 +0000</pubDate>
<dc:creator>KiwenLau</dc:creator>
<og:description>我的个人公众号 寒雁Talk 开通有一段时间了，一直在思考应该写点什么，毕竟是第1篇嘛。 这半年时间，我没有发布博客，不过积累了不少话题，也有一些未完成的文章，但是，我意识到， 写什么内容其实并不重要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kiwenlau/p/the-value-of-writing.html</dc:identifier>
</item>
<item>
<title>性能计数器在.NET Core中的新玩法 - Artech</title>
<link>http://www.cnblogs.com/artech/p/performance-counter-in-net-core.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/performance-counter-in-net-core.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/artech/158198/o_.netcore.png&quot; class=&quot;desc_img&quot;/&gt;传统的.NET Framework提供的System.Diagnostics.PerformanceCounter类型可以帮助我们收集Windows操作系统下物理机或者进程的性能指标，基于PerformanceCounter类型的性能计数API在.NET Core下被彻底放弃。在.NET Core中的性能计数器具有新的玩法。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;84.842786683107&quot;&gt;
&lt;p&gt;传统的.NET Framework提供的System.Diagnostics.PerformanceCounter类型可以帮助我们收集Windows操作系统下物理机或者进程的性能指标，基于PerformanceCounter类型的性能计数API在.NET Core下被彻底放弃。但是.NET Core程序的很多核心性能指标都会采用事件的方式发出来，具体使用的就是如下所示的这个名为RuntimeEventSource的内部类型。源代码可以从&lt;a href=&quot;https://github.com/jiangjinnan/InsideAspNetCore3/tree/master/01/08/S812&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[EventSource(Guid=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;49592C0F-5A05-516D-AA4B-A64E02026C89&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Runtime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RuntimeEventSource : EventSource
{
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以利用EventListener对象监听由RuntimeEventSource发送的事件，进而得到当前的性能指标。如下所示的代码片段就是用来获取性能计数的PerformanceCounterListener类型的定义。在重写的OnEventSourceCreated方法中，可以根据名称订阅针对RuntimeEventSource的事件。在具体调用EnableEvents方法时，我们提供了一个字典作为参数，参数利用一个名为EventCounterIntervalSec的元素将取样的时间间隔设置为5秒。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PerformanceCounterListener: EventListener
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HashSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; _keys = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;  { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Min&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Max&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Increment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DateTimeOffset?&lt;span&gt; _lastSampleTime;

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnEventSourceCreated(EventSource eventSource)
    {
        &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnEventSourceCreated(eventSource);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (eventSource.Name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Runtime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            EnableEvents(eventSource, EventLevel.Critical, (EventKeywords)(&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;),  &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; { [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EventCounterIntervalSec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
        }
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnEventWritten(EventWrittenEventArgs eventData)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_lastSampleTime != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; DateTimeOffset.UtcNow - _lastSampleTime.Value &amp;gt; TimeSpan.FromSeconds(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
        {
            Console.WriteLine();
        }
        _lastSampleTime &lt;/span&gt;=&lt;span&gt; DateTimeOffset.UtcNow;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metrics = (IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;)eventData.Payload[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = metrics [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; values =&lt;span&gt; metrics
            .Where(it&lt;/span&gt;=&amp;gt;&lt;span&gt;_keys.Contains(it.Key))
            .Select(it &lt;/span&gt;=&amp;gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{it.Key} = {it.Value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timestamp = DateTimeOffset.UtcNow.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd hh:mm::ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{timestamp}]{name, -32}: {string.Join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, values.ToArray())}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        _ &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PerformanceCounterListener();
        Console.Read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在重写的OnEventWritten方法中，可以得到性能计数时间的内容载荷（体现为一个字典对象），并从中提取出性能指标的名称（Name）和相关的采样值（Max、Min、Count、Mean和Increment）。提取出的性能指标数据连同当前时间戳经过格式化后直接输出到控制台上。在作为入口的Main方法中，我们直接创建了PerformanceCounterListener对象，它会以5秒的间隔收集当前的性能指标，并以下图所示的形式输出到控制台上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202004/19327-20200403082948377-1061298684.png&quot;&gt;&lt;img width=&quot;447&quot; height=&quot;276&quot; title=&quot;8-21&quot; alt=&quot;8-21&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202004/19327-20200403082948861-1084376508.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，利用PerformanceCounterListener对象几乎可以收集到.NET Core程序所在进程以及物理机的绝大部分核心指标，其中包括CPU、内存、GC、线程池相关的指标。如果需要开发APM（Application Performance Management）框架，或者直接集成第三方APM（如我个人比较钟爱的Elastic APM），就可以直接利用这种方式采集所需的性能指标。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 03 Apr 2020 00:30:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>传统的.NET Framework提供的System.Diagnostics.PerformanceCounter类型可以帮助我们收集Windows操作系统下物理机或者进程的性能指标，基于Perfor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/performance-counter-in-net-core.html</dc:identifier>
</item>
<item>
<title>基于 Spring Cloud 的微服务架构实践指南（上） - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/12624324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/12624324.html</guid>
<description>&lt;blockquote readability=&quot;6.2911392405063&quot;&gt;
&lt;p&gt;show me the code and talk to me,做的出来更要说的明白&lt;br/&gt;GitHub 项目&lt;a href=&quot;https://github.com/buerbl/learnSpringCloud&quot;&gt;learnSpringCloud&lt;/a&gt;同步收录&lt;br/&gt;我是布尔bl，你的支持是我分享的动力！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、-引入&quot;&gt;一、 引入&lt;/h2&gt;
&lt;p&gt;上回 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3ODA5NDc0Mw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=eabbbabb1a25193afd702213ab160b76&amp;amp;chksm=fd7bd234ca0c5b22fefecafabb293b200428d00737876665c8d251c7cf7979aae71e00f720d7&amp;amp;token=405320755&amp;amp;lang=zh_CN#rd&quot;&gt;Spring Cloud 理论篇&lt;/a&gt; 介绍了 Spring Cloud 的常见组件，让读者对 &lt;code&gt;Spring Cloud&lt;/code&gt; 有了一个宏观认识，这是从理论层面出发的。接下来我们就进入 &lt;code&gt;Spring Cloud&lt;/code&gt; 的实战教程，撸起袖子，真枪实弹干一场。在实战演练中感受一下 &lt;code&gt;Spring Cloud&lt;/code&gt; 的魅力所在。在教程中，我会将 &lt;code&gt;Spring Cloud&lt;/code&gt; 常见组件进行整合。整个过程就像搭积木一样，一点一点地完成一个微服务工程的搭建。实战演练是比较繁琐的，但是只要我们真正地去做了，就会收获很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20200401154409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、eureka-组件注册中心&quot;&gt;二、&lt;code&gt;Eureka&lt;/code&gt; 组件(注册中心)&lt;/h2&gt;
&lt;p&gt;作为 &lt;code&gt;Spring Cloud&lt;/code&gt; 的注册中心，我们第一步需要把 &lt;code&gt;Eureka&lt;/code&gt; 组件搭起来。因为接下来的消费者以及生产者都是以 &lt;code&gt;Eureka&lt;/code&gt; 组件为基础展开的。&lt;/p&gt;
&lt;h3 id=&quot;21-pom-文件&quot;&gt;2.1 &lt;code&gt;pom&lt;/code&gt; 文件&lt;/h3&gt;
&lt;p&gt;我们引入 &lt;code&gt;Eureka&lt;/code&gt; 的依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3ODA5NDc0Mw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=eabbbabb1a25193afd702213ab160b76&amp;amp;chksm=fd7bd234ca0c5b22fefecafabb293b200428d00737876665c8d251c7cf7979aae71e00f720d7&amp;amp;token=405320755&amp;amp;lang=zh_CN#rd&quot;&gt;Spring Cloud 理论篇&lt;/a&gt; 提到 &lt;code&gt;Spring Cloud&lt;/code&gt; 是基于 &lt;code&gt;SpringBoot&lt;/code&gt; 开发的。那么读者是否有疑惑为什么不需要&lt;br/&gt;&lt;code&gt;web&lt;/code&gt;模块呢？当然是需要的，只不过是 &lt;code&gt;Eureka&lt;/code&gt; 的依赖的依赖中已经包含了必要的模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20200401163459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-yml-文件&quot;&gt;2.2 &lt;code&gt;yml&lt;/code&gt; 文件&lt;/h3&gt;
&lt;p&gt;引入必要模块后，我们就要去配置 &lt;code&gt;yml&lt;/code&gt; 文件了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;server:
  port: 7001

eureka:
  instance:
    hostname: localhost # eureka 服务端的实例名称
  client:
    register-with-eureka: false # 表示不需要向注册中心注册自己
    fetch-registry: false # false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka # 设置与 Eureka Server 交互的地址查询服务和注册服务
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于配置相关的文件意义，注释已经说的很清楚了。详情请看注释。&lt;/p&gt;
&lt;h3 id=&quot;23-启动类&quot;&gt;2.3 启动类&lt;/h3&gt;
&lt;p&gt;最后写好启动类，就算完成的&lt;code&gt;Eureka&lt;/code&gt; 组件的搭建了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableEurekaServer
public class AppApplication7001 {
    public static void main( String[] args ) {
        SpringApplication.run(AppApplication7001.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们的启动类的注解除了万年不变的&lt;code&gt;@SpringBootApplication&lt;/code&gt;，还增加了 &lt;code&gt;@EnableEurekaServer&lt;/code&gt;，该注解的作用是表明该工程作为 &lt;code&gt;Eureka&lt;/code&gt; 组件存在的。就好像我们怎么证明自己的身份呢，拿出自己的身份证即可。&lt;/p&gt;
&lt;h3 id=&quot;24-启动效果&quot;&gt;2.4 启动效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20200401164854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Eureka&lt;/code&gt; 组件启动如图所示。&lt;/p&gt;
&lt;h2 id=&quot;三、生产者（服务提供者）&quot;&gt;三、生产者（服务提供者）&lt;/h2&gt;
&lt;h3 id=&quot;31-pom-文件&quot;&gt;3.1 &lt;code&gt;pom&lt;/code&gt; 文件&lt;/h3&gt;
&lt;p&gt;我们再新建一个工程，该工程其实本质也是一个 &lt;code&gt;Eureka&lt;/code&gt; 组件，不过我们可以通过配置文件使其变成生产者。可能读者有点迷糊，我打个比方。社会上有警察、医生、码畜等等，有很多的身份类型，但本质我们都是人。我们都是有感情的生物。回到代码层面，首先我们需要引入相关依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-yml-文件&quot;&gt;3.2 &lt;code&gt;yml&lt;/code&gt; 文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;server:
  port: 8002  # 服务的端口
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-启动类&quot;&gt;3.3 启动类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableEurekaClient
public class AppApllcation8002{
    public static void main( String[] args ) {
         SpringApplication.run(AppApllcation8002.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以看到注册中心的启动类和服务提供者的注解是不一样的。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;注册中心&lt;/th&gt;
&lt;th&gt;服务提供者&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@EnableEurekaServer&lt;/td&gt;
&lt;td&gt;@EnableEurekaClient&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;34-启动效果&quot;&gt;3.4 启动效果&lt;/h3&gt;
&lt;p&gt;目前我们有了两个工程，启动的时候是有顺序的。首先启动注册中心然后再启动服务提供者。这就好比我们先要有房子了，才可以入住一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20200402170316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比上图我们可以发现网页多出来一个服务提供者。说明服务提供者项目搭建完成。&lt;/p&gt;
&lt;h2 id=&quot;四、消费者（服务消费者）&quot;&gt;四、消费者（服务消费者）&lt;/h2&gt;
&lt;h3 id=&quot;41-pom-文件&quot;&gt;4.1 &lt;code&gt;pom&lt;/code&gt; 文件&lt;/h3&gt;
&lt;p&gt;有个服务提供者，那么是不是应该有服务消费者呢？此时我们需要新建另外一个工程作为服务消费者。那么问题来了，作为服务消费者，我们怎样去调用服务提供者呢？此时，肯定是不能像以前直接在 &lt;code&gt;controller&lt;/code&gt; 层调用 &lt;code&gt;service&lt;/code&gt; 层一样了，因为服务消费者和服务提供者是两个工程了，并且分别运行在两个 &lt;code&gt;tomcat&lt;/code&gt; 里面。这里我们就需要进行网络调用了。在 &lt;code&gt;Spring Cloud&lt;/code&gt; 里面我们可以使用 &lt;code&gt;Feign&lt;/code&gt; 进行不同服务的调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-feign&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-yml-文件&quot;&gt;4.2 &lt;code&gt;yml&lt;/code&gt; 文件&lt;/h3&gt;
&lt;p&gt;接下来我们需要配置&lt;code&gt;yml&lt;/code&gt; 文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;server:
  port: 80

eureka:
  client:
    register-with-eureka: false  # 不向注册中心注册了
    service-url:
      defaultZone: http://localhost:7001/eureka
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为工程是作为服务消费者存在的。所以我们不需要往注册中心注册服务。这样注册中心就只管理好服务提供者即可。&lt;/p&gt;
&lt;h3 id=&quot;43-启动类以及feign类接口&quot;&gt;4.3 启动类以及&lt;code&gt;feign类&lt;/code&gt;接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FeignClient(value = &quot;microservicloud-dept&quot;) // 服务提供者的名字
public interface IFeignService {
    @GetMapping(&quot;/provide&quot;)
    String feign();
}

@SpringBootApplication
@RestController
@EnableEurekaClient
@EnableFeignClients(basePackages = {&quot;com.example&quot;})
public class AppApplication80 {
    public static void main( String[] args ) {
        SpringApplication.run(AppApplication80.class, args);
    }

    @Autowired
    private IFeignService feignService;
    @GetMapping(&quot;/controller/feign&quot;)
    public String feign(){
        return feignService.feign();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;至此我们就完成了一个简单的 &lt;code&gt;Spring Cloud&lt;/code&gt; 的微服务架构多模块项目。根据项目搭建，我们可以简单画出架构图。具体源码已经在开头引用给出，可以直接克隆运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20200402223139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关注微信公众号，随时移动端阅读&quot;&gt;关注微信公众号，随时移动端阅读&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/19/170f21764d87ef98?w=654&amp;amp;h=193&amp;amp;f=png&amp;amp;s=41932&quot; alt=&quot;公众号.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Apr 2020 00:26:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>show me the code and talk to me,做的出来更要说的明白 GitHub 项目 &amp;quot;learnSpringCloud&amp;quot; 同步收录 我是布尔bl，你的支持是我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhuantou/p/12624324.html</dc:identifier>
</item>
<item>
<title>JavaScript DOM 事件模型 - pgjett</title>
<link>http://www.cnblogs.com/pgjett/p/12624320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pgjett/p/12624320.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;34&quot;&gt;&lt;img data-src=&quot;https://blog-static.cnblogs.com/files/pgjett/40.ico&quot; class=&quot;desc_img&quot;/&gt; JavaScript 是基于面向对象和事件驱动的一门语言，事件模型是 DOM 中至关重要的内容，理解事件驱动机制、事件反馈、事件冒泡、事件捕获以及事件委托能帮助我们更好的处理事件，写出更优的代码&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;58&quot;&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;JavaScript 是基于面向对象和事件驱动的一门语言，事件模型是 DOM 中至关重要的内容，理解事件驱动机制、事件反馈、事件冒泡、事件捕获以及事件委托能帮助我们更好的处理事件，写出更优的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;事件驱动机制&quot;&gt;事件驱动机制&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;当事件发生时，我们收到事件的反馈，在 JavaScript 中，事件反馈是我们自行定义的事件处理函数&lt;/li&gt;
&lt;li&gt;事件，如点击事件、鼠标移入事件等，是每一个元素与生俱来的能力&lt;/li&gt;
&lt;li&gt;通常说的绑定事件，实际上是绑定事件的反馈，即事件处理函数&lt;/li&gt;
&lt;li&gt;例如点击一个按钮，按钮元素对象是事件发送器或事件源，事件是鼠标点击事件，事件处理函数是侦听器&lt;/li&gt;
&lt;li&gt;元素对象发出事件，事件处理函数做出反应，这就是 JS 的事件驱动机制&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在观察者模式中，事件发送器就是主题，事件处理函数即侦听器就是观察者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;绑定事件反馈&quot;&gt;绑定事件反馈&lt;/h2&gt;
&lt;ol readability=&quot;26&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;内联属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;button onclick=&quot;test()&quot;&amp;gt;按钮&amp;lt;/button&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;介于结构和逻辑要相分离，不建议使用内联方式绑定&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;事件句柄&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var oBtn = document.getElementsByTagName('button')[0];
oBtn.onclick = function() {
    // this -&amp;gt; oBtn
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;兼容性好，但是重复绑定会覆盖&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;25&quot;&gt;
&lt;p&gt;事件监听器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var oBtn = document.getElementsByTagName('button')[0];
oBtn.addEventListener(&quot;click&quot;, funtion(){
    // this -&amp;gt; oBtn
 }, false);
oBtn.addEventListener(&quot;click&quot;, test, false);
funtion test(){ 
    // 事件处理函数
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重复添加，不会覆盖之前添加的监听器，但是如果事件类型、事件处理函数和最后一个布尔参数都相同，则不会重复执行&lt;/p&gt;
&lt;p&gt;IE8 及以下不支持 addEventListener，可用 attachEvent 代替&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var oBtn = document.getElementsByTagName('button')[0];
oBtn.attachEvent(&quot;onclick&quot;, funtion(){
        // this -&amp;gt; window
    }); 
// 区别于 addEventListener，第一个参数使用 'onclick'，而不是 'click'
// 并且内部 this 指向 window
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;兼容性封装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function addEvent(elem, type, fn) {
    if (elem.addEventListener) {
        elem.addEventListener(type, fn, false);
    } else if (elem.attachEvent) {
        elem.attachEvent('on' + type, function(ev) {
                fn.call(elem, ev); // call 兼容性比 bind 好
            });
    } else {
        elem['on' + type] = fn;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;解除绑定&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;oBtn.onclik = null;
oBtn.removeEventListener(&quot;click&quot;, test, false); // 解除 addEventListener
oBtn.detachEvent('onclick', test); // 解除 attachEvent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：点击一次后清除事件反馈&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;oBtn.onclik = function() {
        // ...
    this.onclick = null;
}
// 非严格模式
oBtn.addEventListener(&quot;click&quot;, funtion() {
        // ...
    this.removEventListener('cilck', arguments.callee, false);
        }, false);
// 严格模式
oBtn.addEventListener(&quot;click&quot;, funtion temp() {
        // ...
    this.removeEventListener('click', temp, false);
        }, false);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;事件冒泡和捕获&quot;&gt;事件冒泡和捕获&lt;/h2&gt;
&lt;ol readability=&quot;24&quot;&gt;&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;事件冒泡：当一个元素发生事件时，该事件会向父级元素传递，按由子到父的顺序触发一连串的事件反馈，称之为事件冒泡&lt;/p&gt;
&lt;p&gt;DOM 上的嵌套关系会产生事件冒泡，例如两个 div 嵌套，点击内部的 div，触发内部 div 的点击事件，内部 div 的点击事件处理函数进行响应，这个事件向其父级即外部 div 传递，外部 div 也有点击事件，外部 div 所绑定的点击事件反馈也会响应&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;outer&quot;&amp;gt;
    &amp;lt;div class=&quot;inner&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var outer = document.getElementsByClassName('outer')[0],
    inner = outer.getElementsByClassName('inner')[0];
outer.addEventListener('click', function () {
    console.log('bubble outer');
}, false);
inner.addEventListener('click', function () {
    console.log('bubble inner');
}, false);
// addEventListener 最后一个参数默认值为 false，表示事件冒泡
// 点击 inner，打印出
// bubble inner 
// bubble outer
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;事件捕获：当一个元素发生事件时，该事件会向父级元素传递，按由父到子的顺序触发一连串的事件反馈，称之为事件捕获&lt;/p&gt;
&lt;p&gt;事件捕获与事件冒泡的触发顺序相反，同样需要 DOM 上的嵌套关系&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;outer.addEventListener('click', function () {
    console.log('outer');
}, true);
inner.addEventListener('click', function () {
    console.log('inner');
}, true);
// addEventListener 最后一个参数使用 true，表示事件捕获
// 点击 inner，打印出
// outer
// in
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;捕获和冒泡的执行顺序&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;outer.addEventListener('click', function () {
    console.log('bubble outer');
}, false); // 冒泡
inner.addEventListener('click', function () {
    console.log('bubble inner');
}, false); // 冒泡
outer.addEventListener('click', function () {
    console.log('outer');
}, true); // 捕获
inner.addEventListener('click', function () {
    console.log('inner');
}, true); // 捕获
// 点击 inner，打印出
// outer
// bubble inner
// inner
// bubble outer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击一个元素，元素即事件源，若事件源绑定了事件处理函数，且设定了事件捕获，则先执行捕获，捕获执行完毕后，按照绑定顺序执行该事件源绑定的事件，如果设定了事件冒泡，再执行冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;focus blur change submit reset select 事件没有冒泡和捕获，IE 浏览器没有事件捕获&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;阻止事件冒泡&quot;&gt;阻止事件冒泡&lt;/h2&gt;
&lt;ol readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;阻止冒泡的方法&lt;/p&gt;
&lt;p&gt;Event 的原型上有 stopPropagation 方法，可以阻止冒泡，是 w3c 的规范&lt;/p&gt;
&lt;p&gt;Event 的原型上有 cancleBubble 属性，赋值为 true，可以阻止冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;addEventListener 绑定事件处理函数，拿到事件对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var outer = document.getElementsByClassName('outer')[0],
    inner = outer.getElementsByClassName('inner')[0];
inner.addEventListener('click', function (ev) {
        console.log(ev); // 事件对象 ev
        ev.stopPropagation(); // 阻止事件冒泡
    }, false);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;IE 浏览器没有 stopPropagation 方法，可以使用 cancelBubble 属性&lt;/p&gt;
&lt;p&gt;注意：IE 浏览器中事件对象存放在 window.event 中。IE8 不支持 addEventListener 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 封装阻止冒泡的方法
function cancelBubble(ev) {
    if (ev.stopPropagation) {
        ev.stopPropagation();
    } else ev.cancelBubble = true; // 兼容 IE8 及以下
}
// 使用上文中封装好的 addEvent 方法
function addEvent(elem, type, fn) {
    if (elem.addEventListener) {
        elem.addEventListener(type, fn);
    } else if (elem.attachEvent) {
        elem.attachEvent('on' + type, function (ev) {
            fn.call(elem, ev);
        });
    } else {
        elem['on' + type] = fn;
    }
}
// 绑定事件处理函数
var outer = document.getElementsByClassName('outer')[0],
    inner = outer.getElementsByClassName('inner')[0];
addEvent(inner, 'click', function (ev) {
        var ev = ev || window.event; // IE 兼容性写法
        cancelBubble(ev); // 阻止冒泡
    });
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;阻止默认事件&quot;&gt;阻止默认事件&lt;/h2&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li&gt;
&lt;p&gt;三种方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件对象 preventDefault() 方法，兼容 IE9 及以上&lt;/li&gt;
&lt;li&gt;事件对象 returnValue = false，兼容 IE8 及以下&lt;/li&gt;
&lt;li&gt;事件处理函数 return false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;兼容性写法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function preventDefaultEvent(ev) {
    if (ev.preventDefault) {
        ev.preventDefault();
    } else ev.returnValue = false; // 兼容 IE8 及以下
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;右键菜单事件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;document.oncontextmenu = function (ev) {
    var ev = ev || window.event;
    // 1. ev.preventDefault();  // IE9 及以上
    // 2. ev.returnValue = false; // IE8 及以下
    // 3. return false;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;14.5&quot;&gt;
&lt;p&gt;a 标签跳转事件&lt;/p&gt;
&lt;p&gt;href 使用伪协议&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&quot;javascript:void(0);&quot;&amp;gt;a 标签&amp;lt;/a&amp;gt; 
&amp;lt;a href=&quot;javascript:;&quot;&amp;gt;a 标签&amp;lt;/a&amp;gt; 
&amp;lt;a href=&quot;#&quot;&amp;gt;a 标签&amp;lt;/a&amp;gt; &amp;lt;!--跳转到当前页面顶部--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;onclick 事件 return false&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&quot;http://www.baidu.com&quot; onclick=&quot;return false&quot;&amp;gt;a 标签&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;http://www.baidu.com&quot; onclick=&quot;return test(),false&quot;&amp;gt;a 标签&amp;lt;/a&amp;gt;
&amp;lt;!--第二个是利用了 “,” 分隔符会返回最后一个的特点，与 test 方法无关--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;绑定事件处理函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--内联绑定--&amp;gt;
&amp;lt;a id='taga' href=&quot;http://www.baidu.com&quot; onclick=&quot;return test()&quot;&amp;gt;a 标签&amp;lt;/a&amp;gt;
&amp;lt;!--句柄绑定--&amp;gt;
&amp;lt;script&amp;gt;
    document.getElementById('taga').onclick = test;
    function test(ev) {
       var ev = ev || window.event;
        // 1. ev.preventDefault();  // IE9 及以上
        // 2. ev.returnValue = false; // IE8 及以下
        // 3. return false;
    }
    // 前两种方式在使用内联属性绑定时，不需要在属性上加 return，第三种则需要
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;表单的 action 属性支持 &lt;code&gt;javascript:&lt;/code&gt; 伪协议，onsubmit 或者提交按钮点击事件都可以绑定处理函数，阻止提交的方法和阻止 a 标签跳转的方法类似&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;冒泡捕获流&quot;&gt;冒泡捕获流&lt;/h2&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件流：描述从页面中接收事件的顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件冒泡流：微软 IE 提出，Event Bubbling&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件捕获流：网景 Netscape 提出，Event Capturing&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;事件流三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段&lt;/p&gt;
&lt;p&gt;元素触发事件时，首先事件捕获阶段，由父到子的执行事件处理函数，然后处于目标阶段，该元素的事件处理函数按绑定顺序执行，最后事件冒泡阶段，由子到父的执行事件处理函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;事件和事件源&quot;&gt;事件和事件源&lt;/h2&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;事件即事件对象，可以由事件处理函数的参数拿到&lt;/p&gt;
&lt;p&gt;IE8 及以下中事件对象存放在 window.event 中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// btn 按钮元素
btn.onclick = function(ev) {
    var ev = ev || window.event; // IE8 兼容性写法
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;事件源即事件源对象，是发生事件的元素，即事件发送器，可以从事件对象中获取&lt;/p&gt;
&lt;p&gt;IE8 及以下只有 srcElement，firefox 低版本只有 target，chrome 两者都有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// btn 按钮元素
btn.onclick = function(ev) {
    var ev = ev || window.event; // IE8 兼容性写法
    var tar = ev.target || ev.srcElement; // 获取事件源的兼容性写法
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;事件委托&quot;&gt;事件委托&lt;/h2&gt;
&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;事件委托也叫事件代理，指对父级元素绑定事件处理函数，通过获取事件源来处理子元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;示例：点击按钮使列表 ul 增加 li 元素，点击每个 li 元素打印出其中的内容（innerHTML）&lt;/p&gt;
&lt;p&gt;如果不使用事件委托，需要循环对每个 li 进行绑定，点击按钮添加新的 li 元素后也要进行绑定，效率低下&lt;/p&gt;
&lt;p&gt;使用事件委托，直接对 ul 绑定点击事件处理函数，获取事件对象、事件源对象，再对源对象进行处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;body&amp;gt;
&amp;lt;button&amp;gt;btn&amp;lt;/button&amp;gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
    var oBtn = document.getElementsByTagName('button')[0],
        oList = document.getElementsByTagName('ul')[0],
        oLi = oList.getElementsByTagName('li');
    oBtn.onclick = function () {
        var li = document.createElement('li');
        li.innerText = oLi.length + 1;
        oList.appendChild(li);
    }
    oList.onclick = function (ev) {
        var ev = ev || window.event,
            tar = ev.target || ev.srcElement;
        // tar 即为被点击的 li 元素
        console.log(tar.innerHTML); 
        // 返回在所有兄弟元素中的索引，借用数组 indexOf 方法
        console.log(Array.prototype.indexOf.call(oLi, tar));
    }
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Fri, 03 Apr 2020 00:25:00 +0000</pubDate>
<dc:creator>pgjett</dc:creator>
<og:description>JavaScript DOM 事件模型 JavaScript 是基于面向对象和事件驱动的一门语言，事件模型是 DOM 中至关重要的内容，理解事件驱动机制、事件反馈、事件冒泡、事件捕获以及事件委托能帮助</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pgjett/p/12624320.html</dc:identifier>
</item>
<item>
<title>坚持写作快两年了，有些私藏工具跟你们分享 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12624282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12624282.html</guid>
<description>&lt;h2 id=&quot;小黑碎碎念&quot;&gt;小黑碎碎念&lt;/h2&gt;
&lt;p&gt;翻看掘金专栏的第一篇文章，&lt;strong&gt;2018 年 6 月 5 日&lt;/strong&gt;发布，没想到自己坚持写作已经将近一年半多了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080637300-204008028.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚开始写作完全不知道写什么，所以刚开始文章也比较水，主要分享一些常用开源工具类的用法。&lt;/p&gt;
&lt;p&gt;后来偶然的机会，看到同事一段比较有意思的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080637503-2100865404.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚看到时完全不解，请教同事之后，明白其中的原因。仔细一想，这是一个很容易的踩坑的地方，于是写了一篇文章分享这个知识点。&lt;/p&gt;
&lt;p&gt;我还记得这篇文章发表之后，上了推荐位，陆续收到读者们点赞、评论。看到自己的文章被别人认可，真切感受到写作带来的快感。&lt;/p&gt;
&lt;p&gt;从这篇之后，开始有了一些 &lt;strong&gt;idea&lt;/strong&gt;，不断分享工作学到的知识点，踩到一些坑。&lt;/p&gt;
&lt;p&gt;不过后续写作也不是顺顺利利的，这过程也因为&lt;strong&gt;懒&lt;/strong&gt;，因为没什么人关注，陆续断更了三四个月。所幸最后坚持下来，哼哧哼哧不断输出。从当初的月更，转变到了现在的周更。&lt;/p&gt;
&lt;p&gt;这个过程收获了很多，因为&lt;strong&gt;写作不断倒逼输入&lt;/strong&gt;，学到的知识不断延伸，慢慢的越学越多。也因为写作链接到了其他一样坚持的小伙伴们。&lt;/p&gt;
&lt;p&gt;好了，上面是一些个人的一些碎碎念，一些关于写作的经历，回到今天文章主题。&lt;/p&gt;
&lt;p&gt;小黑哥是一个爱折腾的人，这一年写作过程碰到一些&lt;strong&gt;手工繁琐&lt;/strong&gt;的事，都会去找一些工具软件代替。这一年不断打磨下来，形成自己的一套写作工具链，今天整理分享给大家，希望帮助大家的提高写作效率。&lt;/p&gt;
&lt;p&gt;写作可以分为三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写作前&lt;/li&gt;
&lt;li&gt;写作中&lt;/li&gt;
&lt;li&gt;写作后&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照这三步介绍这个过程中我用到一些工具。&lt;/p&gt;
&lt;h2 id=&quot;写作前&quot;&gt;写作前&lt;/h2&gt;
&lt;h3 id=&quot;trello&quot;&gt;trello&lt;/h3&gt;
&lt;p&gt;官网地址:&lt;a href=&quot;https://trello.com/&quot;&gt;https://trello.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一款任务管理工具，类似于敏捷开发中看板，我们可以快速管理任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080637678-850065086.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;日常工作我只要想到一个 &lt;strong&gt;idea&lt;/strong&gt;，就会第一时间先记录到 &lt;strong&gt;idea&lt;/strong&gt; 列表中。这里千万不要高估自己的记忆力，如果想到了，感觉记录下来。以前上午灵光一现想到一个 &lt;strong&gt;idea&lt;/strong&gt;，准备晚上写一下，然后晚上就想不起来。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080637826-836232793.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前期准备时，可以将收集到的资料，素材，全部放到具体卡片中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080637970-706620287.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们开始写作后，拖动到下一个列表，完成之后，再拖到下一个列表，这样写作任务非常清晰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trello&lt;/strong&gt; 十分强大，这里只是用了小功能，感兴趣的同学可以深入研究一下。&lt;/p&gt;
&lt;h2 id=&quot;写作中&quot;&gt;写作中&lt;/h2&gt;
&lt;h3 id=&quot;typoraipic坚果云&quot;&gt;typora+iPic+坚果云&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;markdown 编辑器&lt;/strong&gt;：typora，下载地址：&lt;a href=&quot;https://typora.io/%E3%80%82&quot;&gt;https://typora.io/。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图床工具：iPic，下载地址：&lt;a href=&quot;https://toolinbox.net/iPic/&quot;&gt;https://toolinbox.net/iPic/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;云盘：坚果云，下载地址:&lt;a href=&quot;https://www.jianguoyun.com/&quot;&gt;https://www.jianguoyun.com/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;iPic 只支持 macos&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 typora 中使用 &lt;strong&gt;markdown&lt;/strong&gt; 写作，可以&lt;strong&gt;实时预览&lt;/strong&gt;，所见即所得，这点非常方便。&lt;/p&gt;
&lt;p&gt;除了这点，我最喜欢的就是配合 &lt;strong&gt;iPic&lt;/strong&gt; 自动生成图床的链接。我们只需要将图片拖入 typora，或者直接复制到编辑器中，就可以自动生成图床链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080638233-1917629198.gif&quot; alt=&quot;来源于网上&quot;/&gt;&lt;/p&gt;
&lt;p&gt;免费版 &lt;strong&gt;iPic&lt;/strong&gt; 只支持微博图床，不需要任何配置就可以使用，个人使用过程觉得够了。如果需要使用其他图床，需要订阅该软件，具体价格如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080638454-49569333.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过好消息，最新版本的 &lt;strong&gt;typora&lt;/strong&gt;,还支持其他几款图床客户端：&lt;/p&gt;
&lt;p&gt;吐槽一点，旧版本的 &lt;strong&gt;typora&lt;/strong&gt; 使用过程，经常碰到卡顿，完全无响应的情况。强制重启软件可能会丢失之前写作记录，之前碰到好几次，都有点想放弃使用这个软件。&lt;/p&gt;
&lt;p&gt;所幸最新版已经改善这种情况，赞一个。不过还是有一点，如果文章中有&lt;strong&gt;过大/过多&lt;/strong&gt;的图片，将会有点卡顿。可能是软件实时渲染引起的，切换到源代码模式，就不会卡了。&lt;/p&gt;
&lt;p&gt;最后通过搭配坚果云，实现云端同步，多端文章共享。&lt;/p&gt;
&lt;h3 id=&quot;ipic-mover&quot;&gt;iPic Mover&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;iPic&lt;/strong&gt; 家同系列的产品，可以一键将已有 &lt;strong&gt;Markdown&lt;/strong&gt; 文件中所有图片迁移至新图床。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080638684-904939584.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;画图工具&quot;&gt;画图工具&lt;/h3&gt;
&lt;p&gt;官网地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.processon.com/&quot;&gt;https://www.processon.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://draw.io/&quot;&gt;http://draw.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上两个我目前比较常用画图网站，支持流程图，UML，原型图等。其中 &lt;strong&gt;processon&lt;/strong&gt; 免费版只支持存储 9 张图，可以通过关注公众号，邀请好友，增加存储上限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;draw.io&lt;/strong&gt; 是一个免费网站，可以搭配 &lt;strong&gt;Google 云端硬盘&lt;/strong&gt;，实现无限存储。不过由于 404 问题，国内访问可能较慢。&lt;/p&gt;
&lt;p&gt;之前经常碰到一些读者咨询，这类类似手绘的图片是怎么画的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080638911-1238081649.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实上面图片就是通过 &lt;strong&gt;draw.io&lt;/strong&gt; 画的，大家在使用过程选择如下图形即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080639089-1810103558.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;箭头属性选择 comic（手绘）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080639302-858155588.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以及最后字体选择&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080639462-485845037.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码图片生成器&quot;&gt;代码图片生成器&lt;/h3&gt;
&lt;p&gt;官网地址:&lt;a href=&quot;https://carbon.now.sh/&quot;&gt;https://carbon.now.sh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;生成比较精美的代码图片，不用担心一些网站不支持代码格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080639617-2113865405.jpg&quot; alt=&quot;image-20200328143839226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外 &lt;strong&gt;carbon&lt;/strong&gt; 还有 IDEA，vscode 等插件，安装之后，可以快速使用。&lt;/p&gt;
&lt;h3 id=&quot;小技巧&quot;&gt;小技巧&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;自动空格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写作时我们需要注意在中英文/中文数字之间加上&lt;strong&gt;空格&lt;/strong&gt;，这样比较易读性，视觉上看起来比较优雅。&lt;/p&gt;
&lt;p&gt;不过对于那些还没有习惯手动加空格的人来说，很容易遗忘。不好好在我们可以借助输入法完成自动加空格功能。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以下为 &lt;strong&gt;macos&lt;/strong&gt; 搜狗输入法相关截图，其他输入法也有类似设置。&lt;/p&gt;
&lt;p&gt;不过，&lt;strong&gt;windows&lt;/strong&gt; 没有找到类似配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080639790-367154799.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外在推荐一款空格之神的浏览器插件，将会自动在网页中英文之间加入空格。当我们习惯之后，手动加入空格也会变成一种肌肉记忆。&lt;/p&gt;
&lt;p&gt;github 地址:&lt;a href=&quot;https://github.com/vinta/pangu.js&quot;&gt;https://github.com/vinta/pangu.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080639954-1186312912.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直角引号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人喜欢使用直角引号(&lt;strong&gt;「」&lt;/strong&gt; &lt;strong&gt;『』&lt;/strong&gt;)代替弯引号(&lt;strong&gt;'' &quot;&quot;&lt;/strong&gt;),使用键盘打出直角引号比较麻烦，我们可以直接使用输入法标点替换功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080640174-480254250.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080640327-2135984646.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写作后&quot;&gt;写作后&lt;/h2&gt;
&lt;p&gt;写作完成之后，我们需要将文章发布到微信公众号以及其他博客平台。&lt;/p&gt;
&lt;h3 id=&quot;微信公众号&quot;&gt;微信公众号&lt;/h3&gt;
&lt;p&gt;由于之前文章采用 &lt;strong&gt;markdown&lt;/strong&gt; 写作，而微信公众号编辑器不支持渲染 &lt;strong&gt;markdown&lt;/strong&gt;，这就导致我们需要自己排版。虽然排版我们可以使用 &lt;strong&gt;135 编辑器&lt;/strong&gt;，&lt;strong&gt;壹伴插件&lt;/strong&gt;等完成，不过还是很麻烦。&lt;/p&gt;
&lt;p&gt;追求方便的同学可以使用自动排版 &lt;strong&gt;markdown&lt;/strong&gt; 的网站，里面支持样式也是比较简洁好看。&lt;/p&gt;
&lt;p&gt;官网地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://md.aclickall.com/&quot;&gt;http://md.aclickall.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mdnice.com/&quot;&gt;https://mdnice.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080640489-1946118352.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080640732-64891255.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上两个排版网站功能大同小异，只不过排版样式不一样。其中 &lt;strong&gt;mdnice&lt;/strong&gt; 可以支持将样式复制到知乎中。&lt;/p&gt;
&lt;h3 id=&quot;其他博客平台&quot;&gt;其他博客平台&lt;/h3&gt;
&lt;p&gt;目前个人还会把文章分发到掘金，博客园，&lt;strong&gt;segmentfault&lt;/strong&gt; 等，这些平台都支持 &lt;strong&gt;markdown&lt;/strong&gt;,可以直接将 &lt;strong&gt;markdown&lt;/strong&gt; 直接复制过去。不过分发平台较多，一个个发还是比较麻烦。&lt;/p&gt;
&lt;p&gt;下面推荐两个工具，自动分发文章到各个博客网站。&lt;/p&gt;
&lt;p&gt;官网地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://openwrite.cn/&quot;&gt;https://openwrite.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ystcode/BlogHelper&quot;&gt;https://github.com/ystcode/BlogHelper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前个人正在使用 &lt;strong&gt;openwrite&lt;/strong&gt;，不过该平台目前采用会员机制，年付会员 &lt;strong&gt;99&lt;/strong&gt; 元。免费版可以使用 &lt;strong&gt;BlogHelper&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;最后说一句（求关注）&quot;&gt;最后说一句（求关注）&lt;/h2&gt;
&lt;p&gt;写作是一个&lt;strong&gt;逆人性&lt;/strong&gt;的过程，不断坚持输出，其实真的很难。希望上面的工具和技巧，可以帮助到同样坚持写作的小伙伴。&lt;/p&gt;
&lt;p&gt;最后，写作也是一个孤独的过程，欢迎各位小伙伴关注我，加我微信，一起交流讨论，互相成长，奥利给！&lt;/p&gt;
&lt;p&gt;最后再次感谢您的阅读，我是&lt;strong&gt;楼下小黑哥&lt;/strong&gt;，一位还未秃头的工具猿，下篇文章我们再见~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200403080640888-1660046539.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 03 Apr 2020 00:07:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>小黑碎碎念 翻看掘金专栏的第一篇文章， 2018 年 6 月 5 日 发布，没想到自己坚持写作已经将近一年半多了。 刚开始写作完全不知道写什么，所以刚开始文章也比较水，主要分享一些常用开源工具类的用法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12624282.html</dc:identifier>
</item>
<item>
<title>给 EF Core 查询增加 With NoLock - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/12623934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/12623934.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;EF Core 在 3.x 版本中增加了 &lt;code&gt;Interceptor&lt;/code&gt;，使得我们可以在发生低级别数据库操作时作为 EF Core 正常运行的一部分自动调用它们。 例如，打开连接、提交事务或执行命令时。&lt;/p&gt;
&lt;p&gt;所以我们可以自定义一个 &lt;code&gt;Interceptor&lt;/code&gt; 来记录执行的 sql 语句，也可以通过 &lt;code&gt;Interceptor&lt;/code&gt; 来实现 sql 语句的执行。&lt;/p&gt;
&lt;p&gt;这里我们可以借助 &lt;code&gt;Interceptor&lt;/code&gt; 实现对于查询语句的修改，自动给查询语句加 &lt;code&gt;(WITH NOLOCK)&lt;/code&gt;，&lt;code&gt;WITH NOLOCK&lt;/code&gt; 等效于 &lt;code&gt;READ UNCOMMITED&lt;/code&gt;（读未提交）的事务级别，这样会造成一定的脏读，但是从效率上而言，是比较高效的，不会因为别的事务长时间未提交导致查询阻塞，所以对于大数据场景下，查询 SQL 加 &lt;code&gt;NOLOCK&lt;/code&gt; 还是比较有意义的&lt;/p&gt;
&lt;h2 id=&quot;nolockinterceptor&quot;&gt;NoLockInterceptor&lt;/h2&gt;
&lt;p&gt;继承 &lt;code&gt;DbCommandInterceptor&lt;/code&gt;，重写查询 sql 执行之前的操作，在执行 sql 之前增加 &lt;code&gt;WITH(NOLOCK)&lt;/code&gt;，实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class QueryWithNoLockDbCommandInterceptor : DbCommandInterceptor
{
    private static readonly Regex TableAliasRegex =
        new Regex(@&quot;(?&amp;lt;tableAlias&amp;gt;AS \[[a-zA-Z]\w*\](?! WITH \(NOLOCK\)))&quot;,
            RegexOptions.Multiline | RegexOptions.Compiled | RegexOptions.IgnoreCase);

    public override InterceptionResult&amp;lt;object&amp;gt; ScalarExecuting(DbCommand command, CommandEventData eventData, InterceptionResult&amp;lt;object&amp;gt; result)
    {
        command.CommandText = TableAliasRegex.Replace(
            command.CommandText,
            &quot;${tableAlias} WITH (NOLOCK)&quot;
            );
        return base.ScalarExecuting(command, eventData, result);
    }

    public override Task&amp;lt;InterceptionResult&amp;lt;object&amp;gt;&amp;gt; ScalarExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult&amp;lt;object&amp;gt; result,
        CancellationToken cancellationToken = new CancellationToken())
    {
        command.CommandText = TableAliasRegex.Replace(
            command.CommandText,
            &quot;${tableAlias} WITH (NOLOCK)&quot;
            );
        return base.ScalarExecutingAsync(command, eventData, result, cancellationToken);
    }

    public override InterceptionResult&amp;lt;DbDataReader&amp;gt; ReaderExecuting(DbCommand command, CommandEventData eventData, InterceptionResult&amp;lt;DbDataReader&amp;gt; result)
    {
        command.CommandText = TableAliasRegex.Replace(
            command.CommandText,
            &quot;${tableAlias} WITH (NOLOCK)&quot;
            );
        return result;
    }

    public override Task&amp;lt;InterceptionResult&amp;lt;DbDataReader&amp;gt;&amp;gt; ReaderExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult&amp;lt;DbDataReader&amp;gt; result,
        CancellationToken cancellationToken = new CancellationToken())
    {
        command.CommandText = TableAliasRegex.Replace(
            command.CommandText,
            &quot;${tableAlias} WITH (NOLOCK)&quot;
            );
        return base.ReaderExecutingAsync(command, eventData, result, cancellationToken);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;interceptor-的使用&quot;&gt;Interceptor 的使用&lt;/h2&gt;
&lt;p&gt;在注册 &lt;code&gt;DbContext&lt;/code&gt; 服务的时候，可以配置 &lt;code&gt;Interceptor&lt;/code&gt;，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var services = new ServiceCollection();
services.AddDbContext&amp;lt;TestDbContext&amp;gt;(options =&amp;gt;
{
    options
        .UseLoggerFactory(loggerFactory)
        .UseSqlServer(DbConnectionString)
        .AddInterceptors(new QueryWithNoLockDbCommandInterceptor())
        ;
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用效果&quot;&gt;使用效果&lt;/h2&gt;
&lt;p&gt;通过 loggerFactory 记录的日志查看查询执行的 sql 语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202004/489462-20200402234957480-1640323527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到查询语句自动加上了 &lt;code&gt;WITH (NOLOCK)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Thu, 02 Apr 2020 15:51:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>给 EF Core 查询增加 With NoLock Intro EF Core 在 3.x 版本中增加了 ，使得我们可以在发生低级别数据库操作时作为 EF Core 正常运行的一部分自动调用它们。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/12623934.html</dc:identifier>
</item>
<item>
<title>数据挖掘入门系列教程（七点五）之神经网络介绍 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12623925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12623925.html</guid>
<description>&lt;h2 id=&quot;数据挖掘入门系列教程（七点五）之神经网络介绍&quot;&gt;数据挖掘入门系列教程（七点五）之神经网络介绍&lt;/h2&gt;
&lt;p&gt;这篇博客是是为了下一篇博客“使用神经网络破解验证码”做准备。主要是对神经网络的原理做介绍。同时这篇博客主要是参考了西瓜书，如果身边有西瓜书的同学，强烈建议直接去看西瓜书，至于我这篇博客，你就当个乐子好了（因为你会发现内容与西瓜书很相似）。&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;什么是神经网络（Neural Network，NN）【亦可称之为人工神经网络（Artificial Neural Network，ANN）】，首先它是一门重要的机器学习技术，也是深度学习的基础，是一种模拟生物神经网络结构和功能的数学模型或者计算机模型。&lt;/p&gt;
&lt;p&gt;在神经网络中，最基本的成分是神经元（neuron）模型。在生物模型中，每一个神经元与其他神经元相连，当他“兴奋”时，他会向其他的神经元发送化学物质，从而改变其他神经元的电位，如果其他神经元的电位超过了某些&quot;阈值&quot;&quot;（threshold），那么其他神经元也会“激活“兴奋，继续向其所连接的神经元发送化学物质。&lt;/p&gt;
&lt;p&gt;下面是生物中神经元的模型（感觉又回到了高中时代）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234635645-309765517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;沃伦·麦卡洛克（生物学）和沃尔特·皮茨（逻辑学）在1943年基于数学和一种称为阈值逻辑的算法创造了一种神经网络的计算模型（也就是神经元MP模型）。这种模型使得神经网络的研究分裂为两种不同研究思路。一种主要关注大脑中的生物学过程，另一种主要关注神经网络在人工智能里的应用。&lt;/p&gt;
&lt;p&gt;依照生物的模型，两位科学家对其工作原理和机构进行简化和抽象构建了M-P模型，下面来介绍一下M-P模型。&lt;/p&gt;
&lt;h3 id=&quot;m-p-模型&quot;&gt;M-P 模型&lt;/h3&gt;
&lt;p&gt;M-P，emm，就是上面两位科学家的命名（McCulloch-Pitts）。M-P模型如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234636146-1845560137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的模型能够很容易的理解：在这个模型中，神经元接收到来自&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个其他神经元传递过来的输入信号&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;，这些输入信号通过带权重（&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;）的连接( connection)进行传递，神经元接收到的总输入值将与神经元的阀值进行比较，然后通过&quot;激活函数&quot; (activation function) 处理以产生神经元的输出。前面的都能够很简单的理解，那么，问题来了，”激活函数“是什么？&lt;/p&gt;
&lt;p&gt;一种是如下图的阶跃函数，它将输入值映射为输出值”0“，”1“。0对应神经元抑制，1对应神经元兴奋，这个和生物中很相似，但是它具有不连续，不光滑等性质。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234636462-1285342357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，实际上常用Sigmoid函数作为激活函数，Sigmoid函数如下图所示：它把输入值压缩在（0，1）的输出范围内。因此也被称之为“挤压函数”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234636839-1121988211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们将这样的神经元按照一定的层次结构连接起来，就得到了神经网络。&lt;/p&gt;
&lt;h3 id=&quot;感知机（两层神经网络）&quot;&gt;感知机（两层神经网络）&lt;/h3&gt;
&lt;p&gt;感知机模型如下所示，输入层接受外部输入信号然后传递给输出层，输出层则就是M-P模型。其中&lt;span class=&quot;math inline&quot;&gt;\(y_k=f\left(\sum_{i} w_{(k,i)} x_{i}-\theta_i\right)\)&lt;/span&gt;。感知机能够很容易的实现“与，或，非”运算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234637225-1759340733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说给定一定的数据集(&lt;span class=&quot;math inline&quot;&gt;\(x_i,y_k\)&lt;/span&gt;)，如果我们知道权重&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;和阈值&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;，那么我们就可以得到&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;之间的关系（比如说在分类中，对于物体的属性&lt;span class=&quot;math inline&quot;&gt;\(x_1,x_2…x_i\)&lt;/span&gt;，我们可以的到物体的类别&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;）。对于阈值来说，我们可以把它看成由一个“哑节点（值为-1.0）”乘以权重&lt;span class=&quot;math inline&quot;&gt;\(w_{n+1}\)&lt;/span&gt;得到。因此，权重和阈值的学习可以统一为权重的学习。那么，怎样进行学习呢（也就是得到合适的权重值）？&lt;/p&gt;
&lt;h4 id=&quot;权重学习&quot;&gt;权重学习&lt;/h4&gt;
&lt;p&gt;假设我们给定样例为&lt;span class=&quot;math inline&quot;&gt;\((x,y)\)&lt;/span&gt;，当前感知机的输出为&lt;span class=&quot;math inline&quot;&gt;\(\hat{y}\)&lt;/span&gt;，则权重的调整如下：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} &amp;amp;w_{i} \leftarrow w_{i}+\Delta w_{i}\\ &amp;amp;\Delta w_{i}=\eta(y-\hat{y}) x_{i} \end{aligned} \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\eta \in(0,1)\)&lt;/span&gt;称之为学习率。若&lt;span class=&quot;math inline&quot;&gt;\(\hat{y}=y\)&lt;/span&gt;则感知机不发生变化。&lt;/p&gt;
&lt;p&gt;通过上面的部分我们知道，感知机只有输出层的神经元进行激活函数处理，即只有一层功能神经元，其学习能力很有限。当我们通过学习得到合适的权重时候，假如不考虑激活函数，则&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;的表达式可以写成下面的表达式：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} y_k = \sum_{i}^{n+1}(w_ix_i) \\ n+1是因为其中里面有一个阈值\theta \end{aligned} \]&lt;/p&gt;
&lt;p&gt;也就是说对于感知机，它只能够处理线性可分问题。可以证明若两类模式是线性可分的，即存在一个线性超平面能将它们分开，如下图所示，则感知机在学习过程一定会收敛 (converge) 而求得适当的权向量&lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{w}=\left(w_{1} ; w_{2} ; \ldots ; w_{n+1}\right)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234637579-74578014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;否则感知机学习过程将会发生震荡 (fluctuation) ，&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;难以稳定下来，不能求得合适解。例如对于下图中的异或问题就没办法求解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234637943-393691912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;多层神经网络（多层感知机）&quot;&gt;多层神经网络（多层感知机）&lt;/h3&gt;
&lt;p&gt;要解决非线性可分问题，就需要使用多层神经网络。如下图所示，我们在中间添加了一层神经元，称之为隐层或者隐含层（hidden layer），该网络可称之为”单隐层网络“。隐含层与输出层的功能相似（都是功能神经元），都拥有激活函数。输入层接受数据的输入，隐层和输出层对数据进行函数处理。因此也可称之为”两层神经网络“，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234638260-1368950405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，上面的异或问题便可以得到解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234638631-1494334188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般来说，神经网络是如下的结构，每一层神经元与下一层神经元全互联，同层之间不存在连接，也不存在跨层连接。称之为”多层前馈神经网络“（这里的前馈代表的是指网络拓扑结构中不存在环或者回路，不代表信号不能向后传播）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234639119-1623910380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在M-P模型中我们说过，对于神经网络的学习，我们可以看成是连接权（connection weight）（也就是神经元之间连接的权重）和阈值的学习。那么在多层神经网络中，又怎样得到合适的阈值和连接权呢？&lt;/p&gt;
&lt;h4 id=&quot;连接权学习bp算法&quot;&gt;连接权学习——BP算法&lt;/h4&gt;
&lt;p&gt;对于多层神经网络的连接权的学习，前面B-P模型的学习算法肯定是不行的。因此需要新的算法，而误差逆传播（error BackPropagation，简称BP）算法便是一个很有效（迄今为止最成功）的算法。&lt;/p&gt;
&lt;p&gt;假设我们的多层前馈神经网络如下所示，其中隐层第&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;个神经元的阈值使用&lt;span class=&quot;math inline&quot;&gt;\(\gamma_h\)&lt;/span&gt;表示，输出层第&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;个神经元的阈值使用&lt;span class=&quot;math inline&quot;&gt;\(\theta_j\)&lt;/span&gt;表示，&lt;span class=&quot;math inline&quot;&gt;\(b_h\)&lt;/span&gt;表示隐层第&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;个神经元的输出。其中激活函数都使用&lt;span class=&quot;math inline&quot;&gt;\(Sigmoid\)&lt;/span&gt;函数。&lt;/p&gt;
&lt;p&gt;在下图中，我们可以很容易的得出一共有&lt;span class=&quot;math inline&quot;&gt;\(q\times d + q + q \times l + l = q\times(d + l + 1) +l\)&lt;/span&gt;个参数需要确定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234639937-715142490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给定训练例子&lt;span class=&quot;math inline&quot;&gt;\(\left(\boldsymbol{x}_{k}, \boldsymbol{y}_{k}\right)\)&lt;/span&gt;，假设神经网络的输出为&lt;span class=&quot;math inline&quot;&gt;\(\hat{\boldsymbol{y}}_{k}=\left(\hat{y}_{1}^{k}, \hat{y}_{2}^{k}, \ldots, \hat{y}_{l}^{k}\right)\)&lt;/span&gt;，即&lt;/p&gt;
&lt;p&gt;\[\hat{y}_{j}^{k}=f\left(\beta_{j}-\theta_{j}\right) \]&lt;/p&gt;
&lt;p&gt;则网络在&lt;span class=&quot;math inline&quot;&gt;\(\hat{\boldsymbol{y}}_{k}=\left(\hat{y}_{1}^{k}, \hat{y}_{2}^{k}, \ldots, \hat{y}_{l}^{k}\right)\)&lt;/span&gt;的均方误差（也就是损失函数loss function）是：&lt;/p&gt;
&lt;p&gt;\[E_{k}=\frac{1}{2} \sum_{j=1}^{l}\left(\hat{y}_{j}^{k}-y_{j}^{k}\right)^{2} \]&lt;/p&gt;
&lt;p&gt;设任意参数&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;的更新估计式如下：&lt;/p&gt;
&lt;p&gt;\[v \leftarrow v+\Delta v \]&lt;/p&gt;
&lt;p&gt;BP算法基于梯度下降策略，以目标的负梯度方向对参数进行调整。对于均方误差，给定学习率&lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\Delta w_{h j}=-\eta \frac{\partial E_{k}}{\partial w_{h j}}\end{equation} \]&lt;/p&gt;
&lt;p&gt;对于&lt;span class=&quot;math inline&quot;&gt;\(w_{hj}\)&lt;/span&gt;，它先影响第&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;个输出层神经元的输入&lt;span class=&quot;math inline&quot;&gt;\(\beta_{j}\)&lt;/span&gt;，然后再影响输出值&lt;span class=&quot;math inline&quot;&gt;\(\hat{y}_{j}^{k}\)&lt;/span&gt;，最后影响&lt;span class=&quot;math inline&quot;&gt;\(E_k\)&lt;/span&gt;，根据导数的规律，有：&lt;/p&gt;
&lt;p&gt;\[\begin{equation} \frac{\partial E_{k}}{\partial w_{h j}}=\frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial w_{h j}} \\ \end{equation} \]&lt;/p&gt;
&lt;p&gt;然后对于&lt;span class=&quot;math inline&quot;&gt;\(\beta_{j}\)&lt;/span&gt;有：&lt;/p&gt;
&lt;p&gt;\[\frac{\partial \beta_{j}}{\partial w_{h j}}=b_{h} \]&lt;/p&gt;
&lt;p&gt;对于对于&lt;span class=&quot;math inline&quot;&gt;\(Sigmoid\)&lt;/span&gt;函数有：&lt;/p&gt;
&lt;p&gt;\[f^{\prime}(x)=f(x)(1-f(x)) \]&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{aligned} &amp;amp;\because \hat{y}_{j}^{k}=f\left(\beta_{j}-\theta_{j}\right)\\ &amp;amp;\because E_{k}=\frac{1}{2} \sum_{j=1}^{l}\left(\hat{y}_{j}^{k}-y_{j}^{k}\right)^{2} \\ \therefore g_{j} &amp;amp;=-\frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \\ &amp;amp;=-\left(\hat{y}_{j}^{k}-y_{j}^{k}\right) f^{\prime}\left(\beta_{j}-\theta_{j}\right) \\ &amp;amp;=(y_{j}^{k}-\hat{y}_{j}^{k})\hat{y}_{j}^{k}(1-\hat{y}_{j}^{k}) \end{aligned}\end{equation} \]&lt;/p&gt;
&lt;p&gt;所以对于&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{h j}\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\Delta w_{h j}=\eta g_{j} b_{h}\end{equation} \]&lt;/p&gt;
&lt;p&gt;同理对于&lt;span class=&quot;math inline&quot;&gt;\(\Delta \theta_{j}\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\Delta \theta_{j}=-\eta \frac{\partial E_{k}}{\partial \theta_{j}}\end{equation} \]&lt;/p&gt;
&lt;p&gt;又:&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{aligned} \frac{\partial E_{k}}{\partial \theta_{j}} &amp;amp;=\frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \theta_{j}} \\ &amp;amp;=\frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial\left[f\left(\beta_{j}-\theta_{j}\right)\right]}{\partial \theta_{j}} \\ &amp;amp;=\frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot f^{\prime}\left(\beta_{j}-\theta_{j}\right) \times(-1) \\ &amp;amp;=\frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot f\left(\beta_{j}-\theta_{j}\right) \times\left[1-f\left(\beta_{j}-\theta_{j}\right)\right] \times(-1) \\ &amp;amp;=\frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \hat{y}_{j}^{k}\left(1-\hat{y}_{j}^{k}\right) \times(-1) \\ &amp;amp;=\frac{\partial\left[\frac{1}{2} \sum_{j=1}^{l}\left(\hat{y}_{j}^{k}-y_{j}^{k}\right)^{2}\right]}{\partial \hat{y}_{j}^{k}} \cdot \hat{y}_{j}^{k}\left(1-\hat{y}_{j}^{k}\right) \times(-1) \\ &amp;amp;=\frac{1}{2} \times 2\left(\hat{y}_{j}^{k}-y_{j}^{k}\right) \times 1 \cdot \hat{y}_{j}^{k}\left(1-\hat{y}_{j}^{k}\right) \times(-1) \\ &amp;amp;=\left(y_{j}^{k}-\hat{y}_{j}^{k}\right) \hat{y}_{j}^{k}\left(1-\hat{y}_{j}^{k}\right) \\ &amp;amp;=g_{j} \end{aligned}\end{equation} \]&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\Delta \theta_{j}=-\eta \frac{\partial E_{k}}{\partial \theta_{j}}=-\eta g_{j}\end{equation} \]&lt;/p&gt;
&lt;p&gt;对于&lt;span class=&quot;math inline&quot;&gt;\(\Delta v_{i h}\)&lt;/span&gt;，因为：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\Delta v_{i h}=-\eta \frac{\partial E_{k}}{\partial v_{i h}}\end{equation} \]&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{aligned} \frac{\partial E_{k}}{\partial v_{i h}} &amp;amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot \frac{\partial b_{h}}{\partial \alpha_{h}} \cdot \frac{\partial \alpha_{h}}{\partial v_{i h}} \\ &amp;amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot \frac{\partial b_{h}}{\partial \alpha_{h}} \cdot x_{i} \\ &amp;amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot x_{i} \\ &amp;amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot w_{h j} \cdot f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot x_{i} \\ &amp;amp;=\sum_{j=1}^{l}\left(-g_{j}\right) \cdot w_{h j} \cdot f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot x_{i} \\ &amp;amp;=-f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot \sum_{j=1}^{l} g_{j} \cdot w_{h j} \cdot x_{i} \\ &amp;amp;=-b_{h}\left(1-b_{h}\right) \cdot \sum_{j=1}^{l} g_{j} \cdot w_{h j} \cdot x_{i} \\ &amp;amp;=-e_{h} \cdot x_{i} \end{aligned}\end{equation} \]&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\Delta v_{i h}=-\eta \frac{\partial E_{k}}{\partial v_{i h}}=\eta e_{h} x_{i}\end{equation} \]&lt;/p&gt;
&lt;p&gt;对于&lt;span class=&quot;math inline&quot;&gt;\(\begin{equation}\Delta \gamma_{h}\end{equation} = -\eta \frac{\partial E_{k}}{\partial \gamma_{h}}\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{aligned} \frac{\partial E_{k}}{\partial \gamma_{h}} &amp;amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot \frac{\partial b_{h}}{\partial \gamma_{h}} \\ &amp;amp;=\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot \frac{\partial \beta_{j}}{\partial b_{h}} \cdot f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \cdot(-1) \\ &amp;amp;=-\sum_{j=1}^{l} \sum_{\partial j}^{\partial E_{k}} \frac{\partial \hat{y}_{j}^{k}}{\mathbb{G}_{j}} \cdot w_{h j} \cdot f^{\prime}\left(\alpha_{h}-\gamma_{h}\right) \\ &amp;amp;=-\sum_{j=1}^{l} \frac{\partial E_{k}}{\partial \hat{y}_{j}^{k}} \cdot \frac{\partial \hat{y}_{j}^{k}}{\partial \beta_{j}} \cdot w_{h j} \cdot b_{h}\left(1-b_{h}\right) \\ &amp;amp;=\sum_{j=1}^{l} g_{j} \cdot w_{h j} \cdot b_{h}\left(1-b_{h}\right) \\ &amp;amp;=e_{h} \end{aligned}\end{equation} \]&lt;/p&gt;
&lt;p&gt;因此：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\Delta \gamma_{h}=-\eta \frac{\partial E_{k}}{\partial \gamma_{h}}=-\eta e_{h}\end{equation} \]&lt;/p&gt;
&lt;p&gt;综上可得：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{array}{l} \Delta w_{h j}=\eta g_{j} b_{h} \\ \Delta \theta_{j}=-\eta g_{j} \\ \Delta v_{i h}=\eta e_{h} x_{i} \\ \Delta \gamma_{h}=-\eta e_{h} \\ 学习率\eta不一定相等 \end{array}\end{equation} \]&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{aligned} &amp;amp;g_{j}=\left(y_{j}^{k}-\hat{y}_{j}^{k}\right) \hat{y}_{j}^{k}\left(1-\hat{y}_{j}^{k}\right)\\ &amp;amp;e_{h}=\sum_{j=1}^{l} g_{j} \cdot w_{h j} \cdot b_{h}\left(1-b_{h}\right)\\ \end{aligned}\end{equation} \]&lt;/p&gt;
&lt;p&gt;算法的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234643034-1394265849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需注意的是，BP算法的目标是要最小化训练集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;上的累计误差（也就是误差目标函数，&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;代表样本的数量）：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}E=\frac{1}{m} \sum_{k=1}^{m} E_{k} \end{equation} \]&lt;/p&gt;
&lt;p&gt;但是在上面的算法中，我们知道，”标准BP算法“只是针对某一个训练样例更新了连接权和阈值，只针对单个&lt;span class=&quot;math inline&quot;&gt;\(E_k\)&lt;/span&gt;，也许它能够计算出合适的&lt;span class=&quot;math inline&quot;&gt;\(w,v,\theta,\gamma\)&lt;/span&gt;让某一个测试样例&lt;span class=&quot;math inline&quot;&gt;\((x_k,y_k)\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(E_k\)&lt;/span&gt;达到最小值，但是对于所有的样例，可能计算出来的&lt;span class=&quot;math inline&quot;&gt;\(w,v,\theta,\gamma\)&lt;/span&gt;并不能让&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;达到最小值。因此我们需要进行多次迭代频繁的更新参数才能够达到&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;的极小点。累积 BP算法直接针对累积误差最小化，它在读取整个训练集 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;一遍后才对参数进行更新，其参数更新的频率低得多。但在很多任务中，累积误差下降到一定程度之后，进 一步下降会非常缓慢，这时标准BP往往会更快获得较好的解，尤其是在训练集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;非常大时更明显。（西瓜书中的原话）。&lt;/p&gt;
&lt;p&gt;可以证明，只需一个包含&lt;strong&gt;足够多神经元&lt;/strong&gt;的隐层，多层前馈网络就能以任意精度逼近任意复杂度的连续函数（可以看一下参考4.）。但是如何设置何理的神经元数量，则就是靠炼丹了（”试错法“trial-by-error）。&lt;/p&gt;
&lt;h4 id=&quot;防止过拟合&quot;&gt;防止过拟合&lt;/h4&gt;
&lt;p&gt;通过前面我们知道，多层反馈网络能够以任意精度逼近任意复杂度的连续函数，因此它很容易造成”过拟合“问题。训练集的误差可能降低，但是测试集合的误差就可能刚好相反。有2中策略解决该问题：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;早停（early stopping）&lt;/p&gt;
&lt;p&gt;将数据集分成训练机和测试集，训练集用来更新连接权和阈值，测试集用来验证累计误差。若训练集误差降低但是测试集误差升高，则停止训练。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7.5&quot;&gt;
&lt;p&gt;正则化（regularization）&lt;/p&gt;
&lt;p&gt;正则化的思想就是在误差目标函数中增加一个用于描述网络复杂度的部分。这里添加连接权和阈值的平方和。此时误差目标函数就变成了：&lt;/p&gt;
&lt;p&gt;\[\begin{equation} E=\lambda \frac{1}{m} \sum_{k=1}^{m} E_{k}+(1-\lambda) \sum_{i} w_{i}^{2} \\ \lambda \in(0,1) \end{equation} \]&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;增加连接权与闵值平方和这一项后，训练过程将会偏好比较小的连接权和阈值，使网络输出更加&quot;光滑&quot;，从而对过拟合有所缓解.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;局部最小和全局最小&quot;&gt;局部最小和全局最小&lt;/h3&gt;
&lt;p&gt;通过前面的学习我们知道，训练的过程实际上就是寻找最优参数（连接权和阈值）使得&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;最小。 最优面临着两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;局部最优&lt;/li&gt;
&lt;li&gt;全局最优&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果从数学角度来说，局部最优就是&lt;strong&gt;极小值点&lt;/strong&gt;，而全局最优则就是&lt;strong&gt;最小值点&lt;/strong&gt;。（最小值一定是极小值，但是极小值不一定是最小值）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234643454-1990521588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234644728-274538202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在神经网络中，我们肯定是希望找到一个最小值（而非一个极小值）。但是当我们使用梯度下降算法的时候，我们很容易陷入到极小值中间（此时梯度为0，也就是说导数为0，参数停止更新）。那么我们如何来避免这种情况呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;以多组不同参数值初始化多个神经网络，按标准方法训练后，取其中误差最小的解作为最终参数。这相当于从多个不同的初始点开始搜索,这样就可能陷入不同的局部极小，从中进行选择有可能获得更接近全局最小的结果。简单点来说就是从多个较小值中取出一个最小值。&lt;/li&gt;
&lt;li&gt;使用“模拟退火”(simulated annealing)技术。模拟退火在每一步都以一定的概率接受比当前解更差的结果，从而有助于“跳出”局部极小。在每步迭代过程中，接受“次优解”的概率要随着时间的推移而逐渐降低，从而保证算法稳定。&lt;/li&gt;
&lt;li&gt;使用随机梯度下降.与标准梯度下降法精确计算梯度不同，随机梯度下降法在计算梯度时加入了随机因素。于是，即便陷入局部极小点，它计算出的梯度仍可能不为零,这样就有机会跳出局部极小继续搜索。&lt;/li&gt;
&lt;li&gt;遗传算法&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这里来说一下模拟退火算法，为什么说着算法呢？因为这个算法简单，并且挺有意思的。算法的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200402234646305-1474977053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;算法的流程很简单，假设我们需要求&lt;span class=&quot;math inline&quot;&gt;\(\int(\omega)\)&lt;/span&gt;的最小值，首先我们先随机产生一个较大的解&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;（称之为初始温度），然后再产生另外一个解&lt;span class=&quot;math inline&quot;&gt;\(\omega’\)&lt;/span&gt;（&lt;span class=&quot;math inline&quot;&gt;\(\omega’ = d\omega,0&amp;lt;d&amp;lt;1,d称之为退温系数\)&lt;/span&gt;），如果&lt;span class=&quot;math inline&quot;&gt;\(\Delta \int=\int\left(\omega^{\prime}\right)-\int(\omega) \leq 0\)&lt;/span&gt;，那毋庸置疑，肯定接受这个解。如果&lt;span class=&quot;math inline&quot;&gt;\(\Delta \int=\int\left(\omega^{\prime}\right)-\int(\omega) &amp;gt; 0\)&lt;/span&gt;，则按照一定的概率&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;接受这个解（从(0,1)中随机选择一个数&lt;span class=&quot;math inline&quot;&gt;\(rand\)&lt;/span&gt;，若&lt;span class=&quot;math inline&quot;&gt;\(P&amp;gt;rand\)&lt;/span&gt;则接受这个解），当&lt;span class=&quot;math inline&quot;&gt;\(\omega &amp;lt; \omega_k\)&lt;/span&gt;时退出算法（&lt;span class=&quot;math inline&quot;&gt;\(\omega_k\)&lt;/span&gt;称之为终止温度）。那么&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;是多少呢？&lt;/p&gt;
&lt;p&gt;\[\begin{equation}p=e^{-\frac{\Delta \int}{k \omega}}\end{equation},k为一个常数 \]&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;OK，神经网络就暂时介绍到这里，至于深度学习这些内容，以后再做介绍，毕竟代码不是一天写成的。这一篇博客主要是为下一篇博客的使用神经网络识别验证码做铺垫。因为在《Python数据挖掘入门与实践》中并没有对神经网络做介绍。&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;p&gt;上面博客中的一些图片和一些公式来自下面的参考，并在某些图上进行了修改。为了排版就没有一个一个进行说明了，在这里统一说明下。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《西瓜书》——周志华&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&quot;&gt;人工神经网络&lt;/a&gt;——维基百科&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://datawhalechina.github.io/pumpkin-book/#/chapter5/chapter5&quot;&gt;南瓜书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/9ed784e7557b&quot;&gt;为什么神经网络能以任意精度拟合任意复杂度的函数？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95&quot;&gt;模拟退火算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/subconscious/p/5058741.html&quot;&gt;神经网络浅讲：从神经元到深度学习&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 02 Apr 2020 15:48:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>[TOC] 数据挖掘入门系列教程（七点五）之神经网络介绍 这篇博客是是为了下一篇博客“使用神经网络破解验证码”做准备。主要是对神经网络的原理做介绍。同时这篇博客主要是参考了西瓜书，如果身边有西瓜书的同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12623925.html</dc:identifier>
</item>
<item>
<title>多线程-2（线程同步） - 梦一回</title>
<link>http://www.cnblogs.com/ccaa/p/12616966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccaa/p/12616966.html</guid>
<description>
&lt;p&gt;带着问题去思考！大家好。&lt;br/&gt;今天我们来了解下什么是线程同步？&lt;/p&gt;
&lt;p&gt;首先我们先知道这些概念和一些类；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行基本的原子性&lt;/li&gt;
&lt;li&gt;Mutex类&lt;/li&gt;
&lt;li&gt;SemaphoreSlim类&lt;/li&gt;
&lt;li&gt;AutoResetEvent类&lt;/li&gt;
&lt;li&gt;ManualRestEventSlim类&lt;/li&gt;
&lt;li&gt;CountDownEvent类&lt;/li&gt;
&lt;li&gt;Barrier类&lt;/li&gt;
&lt;li&gt;ReaderWriterLockSilm类&lt;/li&gt;
&lt;li&gt;SpinWait类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们都知道确保当一个线程使用某些资源的时候，同时其他线程无法使用该资源。这引入一个概念是共享资源。&lt;/p&gt;
&lt;p&gt;多个线程同时使用共享对象会造成很多问题。同步线程使得对共享对象的操作能够以正确的顺序执行是非常重要的。&lt;/p&gt;
&lt;p&gt;首先通过一个加减例子了解下lock处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('36c18485-5709-441f-99e3-9acfc4d0f6d3')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_36c18485-5709-441f-99e3-9acfc4d0f6d3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_36c18485-5709-441f-99e3-9acfc4d0f6d3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('36c18485-5709-441f-99e3-9acfc4d0f6d3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_36c18485-5709-441f-99e3-9acfc4d0f6d3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CounterBase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Increment();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Decrement();
    }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Counter:CounterBase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Count { &lt;span&gt;get&lt;/span&gt;;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Decrement()
        {
            Count&lt;/span&gt;++&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Increment()
        {
            Count&lt;/span&gt;--&lt;span&gt;;
        }
    }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CounterLock : CounterBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _synclock = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Count { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Decrement()
        {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(_synclock)
            {
                Count&lt;/span&gt;++&lt;span&gt;;
            }
           
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Increment()
        {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_synclock)
            {
                Count&lt;/span&gt;--&lt;span&gt;;
            }
        }
       
    }

 &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 多线程锁&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Incorrect counter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Counter();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t1 = &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt; TestCount(c));
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t2= &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt; TestCount(c));
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t3 = &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt; TestCount(c));
            t1.Start();
            t2.Start();
            t3.Start();
            t1.Join();
            t2.Join();
            t3.Join();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Total count:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,c.Count);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Correct counter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CounterLock();

             t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt; TestCount(c1));
             t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt; TestCount(c1));
             t3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt; TestCount(c1));
            t1.Start();
            t2.Start();
            t3.Start();
            t1.Join();
            t2.Join();
            t3.Join();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Total count:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, c1.Count);
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
        }
 &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestCount(CounterBase c)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
            {
                c.Increment();
                c.Decrement();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202004/1006793-20200401233149548-1926744517.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202004/1006793-20200401233210413-1594483092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;我们知道，最终结果应该是0；&lt;/p&gt;
&lt;p&gt;因为第一个线程得到count为10增加为11，第二个线程得到的值是11并增加为12.第一个线程得到count为12，但是递减操作发生前，第二个线程得到的值也是12,。然后第一个线程将12递减11并保存count中，同时第二个线程进行了同样的操作，结果我们进行了两次递增操作但是只有一次递减操作。这是竞争条件(race condition)&lt;/p&gt;
&lt;p&gt;1：请尽量避免使用共享对象&lt;/p&gt;
&lt;p&gt;2：必须是共享的状态时候，使用原子操作。一个操作只占一个量子的时间，一次完成。这说明只有当前操作完成后，其他线程才能执行其他操作，避免死锁，和使用锁&lt;/p&gt;
&lt;p&gt;3：使用不同方式来协调线程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将等待的线程置于阻塞状态。当线程阻塞状态，只会占用少量CPU时间，意味将引入至少一次所谓的&lt;strong&gt;上下文切换&lt;/strong&gt;（context switch上下文切换是操作系统的线程调度器）.该调度器会保存等待的线程等待，并切换到另一个线程，依次恢复等待的线程的状态。这需要消耗很多资源，但是如果线程要被挂起很长时间的话，这是值得的--&lt;strong&gt;-内核模式(kernel-mode)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;线程只需要等待一小段时间，不用将线程切换到阻塞状态。虽然线程等待时会浪费CPU时间，但节省了上下文切换耗费的CPU时间----&lt;strong&gt;用户模式(user-mode)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;先尝试使用用户模式等待，如果线程等待足够长时间。则会切换到阻塞状态节省CPU资源--&lt;strong&gt;-混合模式(hybrid)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;执行基本的原子操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不用阻塞线程就可避免竞争条件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CounterLock : CounterBase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Count { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _count;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Decrement()
        {
            
            Interlocked.Decrement(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; _count);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Increment()
        {
            Interlocked.Increment(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; _count);
        }
       
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们修改CounterLock,再来看看结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202004/1006793-20200401233741978-1047367829.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202004/1006793-20200401233751018-1293227689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们可能会得到0，但是最终会得到一些不确定的非0.第一个例子是线程不安全的。第二个例子中，我们借助Interlocked类，无需锁定任何对象即可获取正确结果。Interlocked提供了Increment.Decrement和Add基于数学操作的原子方法，编写Counter类时无需使用锁、&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; Mutex类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MutexName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CSharpThreadingCookbook&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; m=&lt;span&gt;new&lt;/span&gt; Mutex(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,MutexName))
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!m.WaitOne(TimeSpan.FromSeconds(&lt;span&gt;5&lt;/span&gt;),&lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Second instance is running!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Running!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    Console.ReadLine();
                    m.ReleaseMutex();
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202004/1006793-20200402233957058-1869070193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;程序启动，定义一个指定名称的互斥量，设置initialOwner标志为false，这意味着如果互斥量已经被创建，则允许程序获取该互斥量。如果没有获得互斥量，程序则简单显示Running&lt;/p&gt;
&lt;p&gt;在运行同样一个程序，则会在5秒种内尝试获得互斥量，如果此时在第一个程序中按下任意键，第二个程序则会开始执行。然而如果保持等待5秒，第二个程序无法获得该互斥量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006793/202004/1006793-20200402234318570-991771824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 02 Apr 2020 15:44:00 +0000</pubDate>
<dc:creator>梦一回</dc:creator>
<og:description>带着问题去思考！大家好。今天我们来了解下什么是线程同步？ 首先我们先知道这些概念和一些类； 执行基本的原子性 Mutex类 SemaphoreSlim类 AutoResetEvent类 ManualR</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ccaa/p/12616966.html</dc:identifier>
</item>
<item>
<title>数据结构---栈及四则运算实现 - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/12623863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/12623863.html</guid>
<description>&lt;p&gt;&lt;span&gt;假设我们要求输入类似这样一个表达式：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;9+(3-1)*3+10/2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，输出结果。我们知道先括号，再乘除，最后加减，中学时候使用的科学计算器，是允许输入这样的表达式计算结果的，那么计算机怎么知道这个串里面先算括号再算乘除呢？我们先来介绍下栈这种数据结构，再来解决这个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面已经说过数组的连表，现在来说另外一种线性表的数据结构&lt;/span&gt;---&lt;span&gt;栈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个比较形象的例子，洗盘子的时候，是不是一个一个往上面堆着放，拿的时候也从上面一个一个的拿，最先放的在最下面，最后放的在最上面，拿的时候第一个拿到。这就是典型的栈结构。先进后出&lt;/span&gt;&lt;strong&gt;&lt;span&gt;First In Last Out(FILO).&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;怎么来实现一个栈结构呢，栈也是一种线性表，前面也有提到两种很基础的线性表结构的数据结构数组和链表。栈其实就是第一个特殊的链表或者数组。可以基于数组或者链表来实现，成为数组栈或者链栈，与之具有数组和链表相关特点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;栈的特殊点在于先进去的元素放在栈低，后进的在栈顶。向栈中插入一个元素叫入栈、进栈、压栈都行，插入的数据会被放在栈顶。从栈中取出一个元素叫出栈、退栈都行，取出之后，原本栈顶的这个元素就会被删掉，让它下面的那个元素成为新的栈顶元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组栈一般栈低是索引开始的元素，压栈就往索引增长方向走；链栈一般栈低是头结点，栈顶是尾结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然都是用数组或链表来实现，为什么还单独拎出来一个数据结构呢。数组和链表暴露了太多了的操作。就会更容易出错。针对性的封装出来的栈这种结构，在某些场景会更加适合。想象一下我们浏览器的的前进后退，是不是就很像两个栈的数据在互相交换操作，一个前进栈，一个后退栈。点后退，把后退栈的栈顶弹出，放进前进栈的栈顶；再点前进，是不是就是压进前进栈顶的后退栈的栈顶元素。就这样互相交替着。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想象一个程序的调用流程是不是也是一个栈结构。最后调用的方法最先执行。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Java&lt;span&gt;里面的&lt;/span&gt;&lt;span&gt;Stack&lt;/span&gt;&lt;span&gt;也是基于数组实现的，它继承了&lt;/span&gt;&lt;span&gt;Vector&lt;/span&gt;&lt;span&gt;。我们用数组实现一个简单栈的基本操作：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.nijunyang.algorithm.stack;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Description:
 * Created by nijunyang on 2020/4/1 23:48
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyStack&amp;lt;E&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_SIZE = 10&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] elements;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyStack() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(DEFAULT_SIZE);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStack(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[capacity];
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 入栈
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; push(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹性伸缩，扩容/收缩释放内存空间&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (size &amp;gt;=&lt;span&gt; elements.length) {
            resize(size &lt;/span&gt;* 2&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (size &amp;gt; 0 &amp;amp;&amp;amp; size &amp;lt; elements.length / 2&lt;span&gt;) {
            resize(elements.length &lt;/span&gt;/ 2&lt;span&gt;);
        }
        elements[size&lt;/span&gt;++] =&lt;span&gt; e;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 出栈
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pop() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        E e &lt;/span&gt;= (E) elements[--size];   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;size是5，那么最后一个元素就是4也就是--size&lt;/span&gt;
        elements[size] = &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在size已经是4了，弹出就是4这个元素的位置置为空&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; size == 0&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扩容/收缩
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; resize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newCapacity) {
        Object[] temp &lt;/span&gt;=  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[newCapacity];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; size; i ++&lt;span&gt;){
            temp[i] &lt;/span&gt;=&lt;span&gt; elements[i];
        }
        elements &lt;/span&gt;=&lt;span&gt; temp;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        MyStack&lt;/span&gt;&amp;lt;Integer&amp;gt; myStack = &lt;span&gt;new&lt;/span&gt; MyStack(5&lt;span&gt;);
        myStack.push(&lt;/span&gt;1&lt;span&gt;);
        myStack.push(&lt;/span&gt;2&lt;span&gt;);
        myStack.push(&lt;/span&gt;3&lt;span&gt;);
        myStack.push(&lt;/span&gt;4&lt;span&gt;);
        myStack.push(&lt;/span&gt;5&lt;span&gt;);
        myStack.push(&lt;/span&gt;6&lt;span&gt;);
        System.out.println(myStack.size);
        Integer e &lt;/span&gt;=&lt;span&gt; myStack.pop();
        System.out.println(e);
        e &lt;/span&gt;=&lt;span&gt; myStack.pop();
        System.out.println(e);
        e &lt;/span&gt;=&lt;span&gt; myStack.pop();
        System.out.println(e);
        e &lt;/span&gt;=&lt;span&gt; myStack.pop();
        System.out.println(e);
        e &lt;/span&gt;=&lt;span&gt; myStack.pop();
        System.out.println(e);
        e &lt;/span&gt;=&lt;span&gt; myStack.pop();
        System.out.println(e);
        e &lt;/span&gt;=&lt;span&gt; myStack.pop();
        System.out.println(e);
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;现在用我们看看怎么用栈来解决&lt;/span&gt;&lt;strong&gt;&lt;span&gt;9+(3-1)*3+10/2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这个计算问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们要怎么来处理括号和运算符号的优先级呢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里先说一下中缀表达式和后缀表达式，像这个表达式&lt;/span&gt;9+(3-1)*3+10/2&lt;span&gt;就是中缀表达式，如果我们转换成&lt;/span&gt;&lt;span&gt;9 3 1 - 3 * + 10 2 / +&lt;/span&gt; &lt;span&gt;这个就是后缀表达式，后缀表达式也叫&lt;a href=&quot;https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/9841727?fr=aladdin&quot; target=&quot;_blank&quot;&gt;逆波兰&lt;/a&gt;，可以可以自行百度或者google,后缀表达式就是操作符号在两个操作数的后面，而中缀表达式就是操作符号在两个操作数的中间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看下后缀表达式是怎么操作的，就是遇到操作符号就把前面两个数进行符号运算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;9 3 1 - 3 * + 10 2 / + 这个表达式的操作如下：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;9 3 1 - &lt;span&gt;这个时候就把&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;相减得到&lt;/span&gt;&lt;span&gt;2 =&amp;gt; 9 2 3 *&lt;/span&gt; &lt;span&gt;这个时候就把&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;相乘 得到&lt;/span&gt;&lt;span&gt;6 =&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;9 6 + =&amp;gt; 15 10 2 / =&amp;gt;15 5 + =&amp;gt; 20&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大致就是这么个流程，这个过程是不是很像栈的操作，遇到数字就入栈，遇到符号就把数字前面两个数字出栈进行计算，然后将结果入栈，直到表达式结束。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在我们只要把中缀表达式转换成后缀表达式就可以进行计算了。看下百度的转换流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202004/1216484-20200402232851699-427872421.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;简单来说就是用一个栈来存放符号，然后从左到右遍历中缀表达式的数字和字符，若是数字就输出，若是符号则判断和栈顶符号的优先级，如果是括号或优先级低于栈顶元素，则依次出栈并输出，将当前符号进栈，直到最后结束。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;9+(3-1)*3+10/2&lt;/p&gt;

&lt;p&gt;&lt;span&gt;先初始化一个栈&lt;/span&gt;stack&lt;span&gt;，然后依次遍历我们的中缀表达式，操作逻辑如下：&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;strong&gt;9 &lt;span&gt;输出&lt;/span&gt; &lt;span&gt;=&amp;gt; 9&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+ &lt;span&gt;栈空的直接进栈：&lt;/span&gt;&lt;span&gt;stack&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;( &lt;span&gt;未配对的 直接进栈：&lt;/span&gt;&lt;span&gt;stack&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;+ (&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3 &lt;span&gt;数字直接输出：&lt;/span&gt;&lt;span&gt;9 3&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;- &lt;span&gt;前面是&lt;/span&gt;&lt;span&gt;(&lt;/span&gt; &lt;span&gt;直接进栈：&lt;/span&gt;&lt;span&gt;stack + ( -&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1 &lt;span&gt;直接输出：&lt;/span&gt; &lt;span&gt;9 3 1&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;)  &lt;span&gt;将前面的符号弹出输出，直到匹配到第一个&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;为止：&lt;/span&gt;&lt;span&gt;9 3 1 -  stack: +&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;* &lt;span&gt;优先级高于&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;进栈：&lt;/span&gt; &lt;span&gt;stack&lt;/span&gt;&lt;span&gt;：&lt;/span&gt; &lt;span&gt;+ *&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3 &lt;span&gt;输出&lt;/span&gt; &lt;span&gt;9 3 1 - 3&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+ &lt;span&gt;优先级低于栈顶的&lt;/span&gt;&lt;span&gt;*&lt;/span&gt; &lt;span&gt;将栈顶弹出输出 继续判断之后栈顶是否比&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;优先级低&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;同级也弹出，直到有限比栈顶高，或者空栈为止&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，这里就会连续弹出&lt;/span&gt; &lt;span&gt;* +&lt;/span&gt; &lt;span&gt;然后将当前的&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;入栈：&lt;/span&gt;&lt;span&gt;9 3 1 - 3 * +     stack: +&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;10 &lt;span&gt;输出：&lt;/span&gt;&lt;span&gt;9 3 1 - 3 * + 10&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/ &lt;span&gt;优先级高于栈顶&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;直接入栈：&lt;/span&gt;&lt;span&gt;stack&lt;/span&gt;&lt;span&gt;：&lt;/span&gt; &lt;span&gt;+ /&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2 &lt;span&gt;直接输出：&lt;/span&gt; &lt;span&gt;9 3 1 - 3 * + 10 2&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;最后符号依次出输出：&lt;/span&gt;9 3 1 - 3 * + 10 2 / +&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上述逻辑中可以看到，不管是最后的计算，还是中缀表达式转后缀表达式中都用到栈这种数据结构。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 02 Apr 2020 15:33:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<og:description>假设我们要求输入类似这样一个表达式：9+(3-1)*3+10/2，输出结果。我们知道先括号，再乘除，最后加减，中学时候使用的科学计算器，是允许输入这样的表达式计算结果的，那么计算机怎么知道这个串里面先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/12623863.html</dc:identifier>
</item>
<item>
<title>Java&amp;Spring过时的经典语录 - 编程一生</title>
<link>http://www.cnblogs.com/xiexj/p/12623835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/12623835.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;字符串拼接：请用StringBuffer代替String直接相加提高性能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过去的理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有没有人告诉过你开发中不要&lt;/p&gt;
&lt;p&gt;String newString = &quot;牛郎&quot;+&quot;织女&quot;;&lt;/p&gt;
&lt;p&gt;而是要根据是否线程安全采用&lt;/p&gt;
&lt;p&gt;String newString = new StringBuffer(&quot;牛郎&quot;).append(&quot;织女&quot;).toString();&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;String newString = new StringBuilder(&quot;牛郎&quot;).append(&quot;织女&quot;).toString();&lt;/p&gt;

&lt;p&gt;因为使用过程中会创建多个字符串对象，而String内部是一个固定长度的字符串数组，所以采用这种方法会浪费内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更新的理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在jdk8之前，+拼接底层使用的是concat做字符串拼接就是说：&lt;/p&gt;
&lt;p&gt;String newString = &quot;牛郎&quot;+&quot;织女&quot;;&lt;/p&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;p&gt;String newString = &quot;牛郎&quot;.concat(&quot;织女&quot;);&lt;/p&gt;

&lt;p&gt;String#concat底层将要拼接的字符串以数组的形式复制到一个新数组中，空间开销确实大。但是jdk8对+的拼接底层做了优化：&lt;/p&gt;
&lt;p&gt;编译期会把所有的可以final的字符串合成一个字符串。原理就和一般人会用&lt;/p&gt;
&lt;p&gt;final long dayInMillisecond = 24*3600*1000;&lt;/p&gt;
&lt;p&gt;来代替直接将后面的值计算出来，因为这样更直观，执行期效率是一样的。&lt;/p&gt;

&lt;p&gt;而对于需要动态拼接的，会内部转成StringBuilder处理。所以对于动态字符串一般来说效果是一样的，对于静态效率反而高些。&lt;/p&gt;

&lt;p&gt;但是凡事都有特例，也有jdk处理不够智能的地方。但是根据java的走势来说，符合：简单即正义。长远来说，越简单的写法越是jdk优化的重点，效率还会有提升的空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其他的用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了一般的字符串拼接，有时候还需要将列表等一些集合用符号（比如,）连接起来，java8以上提供了StringJoiner来完成这件事。比如list拼接：&lt;/p&gt;
&lt;p&gt;Lists.newArrayList(&quot;迢迢牵牛星&quot;,&lt;/p&gt;
&lt;p&gt;&quot;皎皎河汉女&quot;)&lt;/p&gt;
&lt;p&gt;.stream().collect(Collectors.joining(&quot;,&quot;));&lt;/p&gt;
&lt;p&gt;底层用的就是StringJoiner。&lt;/p&gt;

&lt;p&gt;如果使用google的guava的话，这种情况还有更简单的写法：&lt;/p&gt;
&lt;p&gt;Joiner.on(&quot;,&quot;).join(Lists.newArrayList(&quot;迢迢牵牛星&quot;,&quot;皎皎河汉女&quot;));&lt;/p&gt;
&lt;p&gt;它底层用的是StringBuilder和StringJoiner底层是一样的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;面试简述SpringMVC的工作原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过去的理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记得2015年前面试必备的一道题，面试者需要像小时候背《咏鹅》一样倒背如流：SpringMVC的工作原理。经典回答是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202004/1112728-20200402232653507-724321908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;SpringMVC 框架是以请求为驱动，围绕 Servlet 设计，将请求发给控制器，然后通过模型对象，分派器来展示请求结果视图。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更新的理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;早在Spring3里就封装好了RESTful风格开发方式，开发者只需要将请求的Controller替换成RestController或者方法上加上@ResponseBody即可。&lt;/p&gt;

&lt;p&gt;目前在前后端分离的场景下，经典的SpringMVC中请求流程基本不全用上。&lt;/p&gt;

&lt;p&gt;Spring提供了两种方法将资源的Java表述形式转换为发送给客户端的表述形式：内容协商和消息转换器。&lt;/p&gt;

&lt;p&gt;内容协商就是经典的方法，当控制器的处理方法完成时，返回一个逻辑视图。内容协商是一个特殊的视图解释器。&lt;/p&gt;

&lt;p&gt;消息转换提供了一种更为直接的方式，DispatcherServlet不再需要那么麻烦地将模型数据传送到视图中。只是控制器产生数据给消息转换器后就直接返回给客户端了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用HttpClient还是OkHttp来做http请求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过去的理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有没有人告诉过你使用OkHttp来代替HttpClient更简洁高效。OkHttp使用build模式创建对象，而且在发送异步请求的时候不需要引入其他的依赖。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更新的理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在基于Spring的JAVA服务端开发中一般会使用各种框架帮我们去完成各种单调重复的工作，比如不管是HttpClient还是OkHttp都需要将返回的reponse自己用编解码工作转成对象再处理。但是如果使用feign则可以省去。&lt;/p&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;com.netflix.feign&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;feign-core&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;8.18.0&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;com.netflix.feign&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;feign-jackson&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;8.18.0&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;com.netflix.feign&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;!--这里也可以换成feign-httpclient--&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;feign-okhttp&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;8.18.0&amp;lt;/version&amp;gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;我们需要创建一个bean来指定url和处理超时重试、&lt;/p&gt;
&lt;p&gt;日志打印等高可用方面的问题。&lt;/p&gt;
&lt;pre&gt;
@Bean&lt;br/&gt;public TestHttpService testHttpService() {&lt;br/&gt;TestHttpService service = Feign.builder()&lt;br/&gt;.encoder(new JacksonEncoder())&lt;br/&gt;.decoder(new JacksonDecoder())&lt;br/&gt;.options(new Request.Options(1000, 3500))&lt;br/&gt;.retryer(new Retryer.Default(5000, 5000, 3))&lt;br/&gt;.logger(logger)&lt;br/&gt;.logLevel(Logger.Level.FULL)&lt;br/&gt;.target(TestHttpService.class, testUrl);&lt;br/&gt;return service;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Spring的简化开发主要是使用了声明式代替命令式，&lt;/p&gt;
&lt;p&gt;在http请求这里当然也可以这么用：&lt;/p&gt;
&lt;p&gt;public interface TestHttpService {&lt;/p&gt;
&lt;pre&gt;
    @RequestLine(&quot;GET /xxxx?appkey={appkey}&amp;amp;ips={ip}&amp;amp;username={username}&amp;amp;operator={operator}&quot;)&lt;br/&gt;Response getTest(@Param(value = &quot;appkey&quot;) String appkey,&lt;br/&gt;@Param(value = &quot;ip&quot;) String ip,&lt;br/&gt;@Param(value = &quot;username&quot;) String username,&lt;br/&gt;@Param(value = &quot;operator&quot;) String operator);
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;运行一下，发现执行过程这么清晰：&lt;/p&gt;
&lt;p&gt;[TestHttpService] ---&amp;gt; GET http://xxx/x?appkey=x&amp;amp;ips=x&amp;amp;username=x&amp;amp;operator=x HTTP/1.1&lt;/p&gt;
&lt;p&gt;[TestHttpService] ---&amp;gt; END HTTP (0-byte body)&lt;/p&gt;
&lt;p&gt;[TestHttpService] &amp;lt;--- HTTP/1.1 200 OK (154ms)&lt;/p&gt;
&lt;p&gt;[TestHttpService] connection: keep-alive&lt;/p&gt;
&lt;p&gt;[TestHttpService] content-length: 28&lt;/p&gt;
&lt;p&gt;[TestHttpService] content-type: application/json;charset=utf-8&lt;/p&gt;
&lt;p&gt;[TestHttpService] date: Sun, 29 Mar 2020 02:19:43 GMT&lt;/p&gt;
&lt;p&gt;[TestHttpService] m-traceid: -264385071732215405&lt;/p&gt;
&lt;p&gt;[TestHttpService] server: openresty&lt;/p&gt;
&lt;p&gt;[TestHttpService] version: oceanus&lt;/p&gt;
&lt;p&gt;[TestHttpService] &lt;/p&gt;
&lt;p&gt;[TestHttpService] {&quot;data&quot;:[],&quot;isSuccess&quot;:true}&lt;/p&gt;
&lt;p&gt;[TestHttpService] &amp;lt;--- END HTTP (28-byte body)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其他的用法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;早在Spring3里就已经使用了模板方法来简化http请求的开发，使用JdbcTemplate不仅可以使用java8的lambda表达式，还可使用消息转换器直接将返回值转成对象的形式，更友好的实现了面向对象编程。当然feign更简洁，并且提供了高可用的支持。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Apr 2020 15:27:00 +0000</pubDate>
<dc:creator>编程一生</dc:creator>
<og:description>字符串拼接：请用StringBuffer代替String直接相加提高性能 过去的理论 有没有人告诉过你开发中不要 String newString = &amp;quot;牛郎&amp;quot;+&amp;quot;织女&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiexj/p/12623835.html</dc:identifier>
</item>
</channel>
</rss>