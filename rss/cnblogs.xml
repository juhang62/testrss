<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java面试题 BAT 大公司面试题整理总结！ - 鬼辩书生讲Java</title>
<link>http://www.cnblogs.com/zhanshuo/p/10756716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanshuo/p/10756716.html</guid>
<description>&lt;p&gt;本文只列出了问题，答案还是需要需要自己的总结，很多时候自己总结出来的语言在面试时比硬背的效果好很多。&lt;/p&gt;
&lt;p&gt;这些题目是网友去百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐等一线互联网公司面试被问到的题目。熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。&lt;/p&gt;
&lt;p&gt;熟练掌握java是很关键的，大公司不仅仅要求你会使用几个api，更多的是要你熟悉源码实现原理，甚至要你知道有哪些不足，怎么改进，还有一些java有关的一些算法，设计模式等等。&lt;/p&gt;
&lt;p&gt;（一） java基础面试知识点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java中==和equals和hashCode的区别&lt;/li&gt;
&lt;li&gt;int、char、long各占多少字节数&lt;/li&gt;
&lt;li&gt;int与integer的区别&lt;/li&gt;
&lt;li&gt;探探对java多态的理解&lt;/li&gt;
&lt;li&gt;String、StringBuffer、StringBuilder区别&lt;/li&gt;
&lt;li&gt;什么是内部类？内部类的作用&lt;/li&gt;
&lt;li&gt;抽象类和接口区别&lt;/li&gt;
&lt;li&gt;抽象类的意义&lt;/li&gt;
&lt;li&gt;抽象类与接口的应用场景&lt;/li&gt;
&lt;li&gt;抽象类是否可以没有方法和属性？&lt;/li&gt;
&lt;li&gt;接口的意义&lt;/li&gt;
&lt;li&gt;泛型中extends和super的区别&lt;/li&gt;
&lt;li&gt;父类的静态方法能否被子类重写&lt;/li&gt;
&lt;li&gt;进程和线程的区别&lt;/li&gt;
&lt;li&gt;final，finally，finalize的区别&lt;/li&gt;
&lt;li&gt;序列化的方式&lt;/li&gt;
&lt;li&gt;Serializable 和Parcelable 的区别&lt;/li&gt;
&lt;li&gt;静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？&lt;/li&gt;
&lt;li&gt;静态内部类的设计意图&lt;/li&gt;
&lt;li&gt;成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用&lt;/li&gt;
&lt;li&gt;谈谈对kotlin的理解&lt;/li&gt;
&lt;li&gt;闭包和局部内部类的区别&lt;/li&gt;
&lt;li&gt;string 转换成 integer的方式及原理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（二） java深入源码级的面试题（有难度）&lt;/p&gt;
&lt;ul readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;哪些情况下的对象会被垃圾回收机制处理掉？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;讲一下常见编码方式？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;utf-8编码中的中文占几个字节；int型几个字节？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;静态代理和动态代理的区别，什么场景使用？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java的异常体系&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;谈谈你对解析与分派的认识。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java中实现多态的机制是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何将一个Java对象序列化到文件里？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;说说你对Java反射的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;说说你对Java注解的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;说说你对依赖注入的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;说一下泛型原理，并举例说明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java中String的了解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;String为什么要设计成不可变的？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Object类的equal和hashCode方法重写，为什么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（三） 数据结构&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;常用数据结构简介&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;并发集合了解哪些？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;列举java的集合以及集合之间的继承关系&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;集合类以及集合框架&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul readability=&quot;14.5&quot;&gt;&lt;li&gt;
&lt;p&gt;List,Set,Map的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;List和Map的实现方式以及存储方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HashMap的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HashMap数据结构？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HashMap源码理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HashMap如何put数据（从HashMap源码角度讲解）？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HashMap怎么手写实现？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ConcurrentHashMap的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ArrayMap和HashMap的对比&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HashTable实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TreeMap具体实现&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HashMap和HashTable的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HashMap与HashSet的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HashSet与HashMap怎么判断集合元素重复？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;集合Set实现Hash怎么防止碰撞&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ArrayList和LinkedList的区别，以及应用场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组和链表的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;二叉树的深度优先遍历和广度优先遍历的具体实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆的结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆和树的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;什么是深拷贝和浅拷贝&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手写链表逆序代码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;讲一下对树，B+树的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;讲一下对图的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;判断单链表成环与否？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;链表翻转（即：翻转一个单项链表）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;合并多个单有序链表（假设都是递增的）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List item&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（四） 线程、多线程和线程池&lt;/p&gt;
&lt;ul readability=&quot;30&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;开启线程的三种方式？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程和进程的区别？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为什么要有线程，而不是仅仅用进程？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;run()和start()方法区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何控制某个方法允许并发访问线程的个数？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Java中wait和seelp方法的不同；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;谈谈wait/notify关键字的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;什么导致线程阻塞？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程如何关闭？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;讲一下java中的同步的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据一致性如何保证？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何保证线程安全？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何实现线程同步？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;两个进程同时要求写或者读，能不能实现？如何防止进程的同步？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程间操作List&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java中对象的生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Synchronized用法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronize的原理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;static synchronized 方法的多线程访问和作用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;同一个类里面两个synchronized方法，两个线程同时访问的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile的原理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;谈谈volatile关键字的用法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;谈谈volatile关键字的作用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谈谈NIO的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;synchronized 和volatile 关键字的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;synchronized与Lock的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ReentrantLock 、synchronized和volatile比较&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ReentrantLock的内部实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lock原理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;死锁的四个必要条件？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么避免死锁？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象锁和类锁是否会互相影响？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;什么是线程池，如何使用?&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java的并发、多线程、线程模型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;谈谈对多线程的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;多线程有什么要注意的问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;谈谈你对并发编程的理解并举例说明&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;谈谈你对多线程同步机制的理解？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何保证多线程读写文件的安全？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;多线程断点续传原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;断点续传的实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 23 Apr 2019 07:31:00 +0000</pubDate>
<dc:creator>鬼辩书生讲Java</dc:creator>
<og:description>本文只列出了问题，答案还是需要需要自己的总结，很多时候自己总结出来的语言在面试时比硬背的效果好很多。 这些题目是网友去百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐等一线互联网公司面试被问到的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanshuo/p/10756716.html</dc:identifier>
</item>
<item>
<title>将你的前端应用打包成docker镜像并部署到服务器？仅需一个脚本搞定 - detectiveHLH</title>
<link>http://www.cnblogs.com/detectiveHLH/p/10756702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/detectiveHLH/p/10756702.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;前段时间，自己搞了个阿里云的服务器。想自己在上面折腾，但是不想因为自己瞎折腾而污染了现有的环境。毕竟，现在的阿里云已经没有免费的快照服务了。要想还原的话，最简单的办法就是重新装系统。而一旦重装，之前的搭建的所有环境就都白搭了。&lt;/p&gt;
&lt;p&gt;再加上之前本身就想引入docker，所以就打算利用docker容器来部署这次的前端应用。&lt;/p&gt;
&lt;h2 id=&quot;构建前端应用&quot;&gt;2.构建前端应用&lt;/h2&gt;
&lt;p&gt;在打包之前，首先需要一个可正常运行的前端应用。这个可以使用&lt;a href=&quot;https://umijs.org/&quot;&gt;umi&lt;/a&gt;或者&lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;create-react-app&lt;/a&gt;来构建。&lt;/p&gt;
&lt;h2 id=&quot;nginx的默认配置文件&quot;&gt;3.nginx的默认配置文件&lt;/h2&gt;
&lt;p&gt;然后需要在项目中加上默认nginx配置文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 80;
    server_name localhost;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        try_files $uri $uri/ /index.html;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写本地构建脚本&quot;&gt;4.编写本地构建脚本&lt;/h2&gt;
&lt;h3 id=&quot;移除上次的目录和dockerfile&quot;&gt;4.1. 移除上次的目录和Dockerfile&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#!/bin/bash

if [ -d &quot;./dist&quot; ]; then
    rm -rf ./dist
fi

if [ -f &quot;./Dockerfile&quot; ]; then
    rm -f ./Dockerfile
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为每次更改后dist中的内容肯定与之前不同，其实这一步显得不是那么必要。运行npm的打包命令也会自动清楚该目录。&lt;/p&gt;
&lt;p&gt;而清除Dockerfile则是为了防止更新了Dockerfile，而这次却不能得到最新的配置。&lt;/p&gt;
&lt;h3 id=&quot;打包前端应用&quot;&gt;4.2. 打包前端应用&lt;/h3&gt;
&lt;p&gt;执行前端的打包命令，生成静态文件目录。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yarn build&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成dockerfile&quot;&gt;4.3. 生成Dockerfile&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;echo &quot;FROM nginx:latest&quot; &amp;gt;&amp;gt; ./Dockerfile
echo &quot;COPY ./dist /usr/share/nginx/html/&quot; &amp;gt;&amp;gt; ./Dockerfile
echo &quot;COPY ./default.conf /etc/nginx/conf.d/&quot; &amp;gt;&amp;gt; ./Dockerfile
echo &quot;EXPOSE 80&quot; &amp;gt;&amp;gt; ./Dockerfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;FROM&lt;/code&gt;制定了该定制容器的基础镜像为&lt;code&gt;nginx:latest&lt;/code&gt;;&lt;code&gt;COPY&lt;/code&gt;命里将打包好的静态文件目录复制到容器内的&lt;code&gt;/usr/share/nginx/html/&lt;/code&gt;目录下，然后将nginx的配置写入容器中对应的位置; &lt;code&gt;EXPOSE&lt;/code&gt;则是设置对外暴露容器的80端口。&lt;/p&gt;
&lt;h3 id=&quot;生成并推送定制image&quot;&gt;4.4. 生成并推送定制image&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker build -t detectivehlh/mine .
docker login -u detectivehlh -p ********
docker push detectivehlh/mine&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是在开发本地，使用docker命令来打包，所以该脚本对docker有强依赖。&lt;code&gt;build&lt;/code&gt;命令表示打包docker应用的，&lt;code&gt;-t&lt;/code&gt;选项则制定了docker镜像的名字和tag，tag会默认为latest。&lt;/p&gt;
&lt;p&gt;然后登录dockerHub，将定制好的镜像推送到dockerHub中。&lt;code&gt;detectivehlh&lt;/code&gt;就是dockerHub的用户名，&lt;code&gt;mine&lt;/code&gt;是image的名字。&lt;/p&gt;
&lt;h3 id=&quot;删除tag为none的无用image&quot;&gt;4.5. 删除tag为none的无用image&lt;/h3&gt;
&lt;p&gt;第一次构建不会生成tag为&lt;code&gt;none&lt;/code&gt;的image，但是后面每次再次执行该命令就会出现这样的情况。所以每次构建了一个新的image后，需要清除调不需要的image。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker images | grep none | awk '{print $3}' | xargs docker rmi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;grep&lt;/code&gt;命令匹配到tag为&lt;code&gt;none&lt;/code&gt;的image，&lt;code&gt;awk&lt;/code&gt;是一个强大的文本分析工具，&lt;code&gt;{print $3}&lt;/code&gt;表示打印出匹配到的每一行的第三个字段，也就是docker的&lt;code&gt;image id&lt;/code&gt;。如果是&lt;code&gt;$0&lt;/code&gt;的话表示当前整行的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt;是一个给其他命令（也就是后面的docker rmi）传递参数的一个过滤器，将标准输入转换成命令行参数。&lt;/p&gt;
&lt;p&gt;总结来说，上述命令就是找到tag为&lt;code&gt;none&lt;/code&gt;的image的ID，然后使用docker rmi命令移除该image。&lt;/p&gt;
&lt;h3 id=&quot;执行部署&quot;&gt;4.6. 执行部署&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cmd=&quot;cd ~ &amp;amp;&amp;amp; sh deploy.sh mine&quot;
ssh -t USER_NAME@IP_ADDRESS &quot;bash -c \&quot;${cmd}\&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过ssh命令，登录远程服务器，并且执行参数中的脚本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deploy.sh&lt;/code&gt;是放在服务端的构建脚本。放在默认的登录用户下。我们发现，后面还跟了个mine，这是在服务器上运行的docker镜像的名字。这里暂时没有对container的名字加上hash，因为自己的小项目，暂时没有必要。&lt;/p&gt;
&lt;p&gt;在项目中的完整构建脚本如下。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#!/bin/bash

if [ -d &quot;./dist&quot; ]; then
    rm -rf ./dist
fi
if [ -f &quot;./Dockerfile&quot; ]; then
    rm -f ./Dockerfile
fi

yarn build

echo &quot;FROM nginx:latest&quot; &amp;gt;&amp;gt; ./Dockerfile
echo &quot;COPY ./dist /usr/share/nginx/html/&quot; &amp;gt;&amp;gt; ./Dockerfile
echo &quot;COPY ./default.conf /etc/nginx/conf.d/&quot; &amp;gt;&amp;gt; ./Dockerfile
echo &quot;EXPOSE 80&quot; &amp;gt;&amp;gt; ./Dockerfile

docker build -t detectivehlh/mine .
docker login -u detectivehlh -p ********
docker push detectivehlh/mine

docker images | grep none | awk '{print $3}' | xargs docker rmi

cmd=&quot;cd ~ &amp;amp;&amp;amp; sh deploy.sh mine&quot;
ssh -t USER_NAME@IP_ADDRESS &quot;bash -c \&quot;${cmd}\&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写服务器部署脚本&quot;&gt;5. 编写服务器部署脚本&lt;/h2&gt;
&lt;p&gt;从上面步骤来看，我们还需要一个服务器端的部署脚本。大家可能会说，标题不是说一个脚本搞定吗？em。。。服务器一个，本地一个...简称只需一个脚本。&lt;/p&gt;
&lt;h3 id=&quot;接收参数&quot;&gt;5.1 接收参数&lt;/h3&gt;
&lt;p&gt;在本地的构建脚本中，我们传入了docker运行的container的名字。在服务器构建脚本中需要来接收它。然后更新刚刚推送的docker image。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#!/bin/bash
name=$1
docker pull detectivehlh/$name&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动container&quot;&gt;5.2. 启动container&lt;/h3&gt;
&lt;p&gt;在启动container时我们会面对两种情况，名字为传入参数的container已经在运行了。而在此时如果再次运行&lt;code&gt;docker run&lt;/code&gt;命令就会报错而导致我们无法使用最新的container，也无法达到更新应用的目的。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;if docker ps | grep $name | awk {'print $(NF)'} | grep -Fx $name; then
    echo &quot;Container mine is already start&quot;
    docker stop $name
    docker rm $name
    docker run -d --name $name -p 3000:80 detectivehlh/$name
else
    echo &quot;Container mine is not start!, starting&quot;
    docker run -d --name $name -p 3000:80 detectivehlh/$name
    echo &quot;Finish starting&quot;
fi
docker images | grep none | awk '{print $3}' | xargs docker rmi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以在这里做一个判断，第一个if判断如果存在名字为传入参数的container正在运行，就停止当前容器再重新启动。如果不存在则直接启动容器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt;命令就不过多解释了。&lt;code&gt;-d&lt;/code&gt;表示后台运行容器并返回容器ID，&lt;code&gt;--name&lt;/code&gt;表示设置容器的名字，&lt;code&gt;-p&lt;/code&gt;表示设置端口，将阿里云服务器的3000端口映射到容器的80端口，最后一句表示要启动哪个image（好像还是解释了一遍）。&lt;/p&gt;
&lt;p&gt;最后一句就是移除多次更新后出现的tag为&lt;code&gt;none&lt;/code&gt;的无用镜像。完整的脚本如下。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#!/bin/bash
name=$1
docker pull detectivehlh/$name
if docker ps | grep $name | awk {'print $(NF)'} | grep -Fx $name; then
    echo &quot;Container mine is already start&quot;
    docker stop $name
    docker rm $name
    docker run -d --name $name -p 3000:80 detectivehlh/$name
else
    echo &quot;Container mine is not start!, starting&quot;
    docker run -d --name $name -p 3000:80 detectivehlh/$name
    echo &quot;Finish starting&quot;
fi
docker images | grep none | awk '{print $3}' | xargs docker rmi&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如果你只是想打个包&quot;&gt;6. 如果你只是想打个包&lt;/h2&gt;
&lt;p&gt;看到标题进来的兄dei，如果只是想打包一个docker镜像，那么你只需要&lt;code&gt;Dockerfile&lt;/code&gt;文件和&lt;code&gt;docker build&lt;/code&gt;命令就OK了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;7. 总结&lt;/h2&gt;
&lt;p&gt;最初写这个脚本，主要目的是为了方便。所以脚本中为了达到这个目的做了一些调整。最终我达成了满足我需求的一个方便的部署脚本。&lt;/p&gt;
&lt;p&gt;它的方便体现在，当我完成了项目代码的更新，只需要跑一下这个脚本，然后等待一会儿，项目就会自动打包成docker image，并且自动的在我的服务器上运行该container。&lt;/p&gt;
&lt;p&gt;但是这种方式会给实际的生产环境带来一些不可控的问题。比如，脚本必须不能上传，因为涉及一些服务器的敏感信息。但是如果你不小心上传了，那你的服务器就相当于裸奔了；再比如，你对你的代码必须要十分自信，没有经过测试的代码就直接部署，会带来一些风险。&lt;/p&gt;
&lt;p&gt;如果是自己用的，那完全不用担心，想怎么搞怎么搞。但是如果是开放给所有人用的并且有一定的访问量，比如博客，那么对于其他用户来说，这种方式就不怎么友好。&lt;/p&gt;
&lt;p&gt;所以我的观点是，分情况来。目前来说我的项目只有少数几个人在用，也还在处于迭代阶段。并且代码仓库是私有的，所以我完全不用担心隐私的问题。服务未经测试就直接上线对于我来说，其实问题也不大。首先我会在本地测试，确认无误后才会执行部署操作。所以在不同的阶段，找到最适合自己的方案就OK。&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 07:30:00 +0000</pubDate>
<dc:creator>detectiveHLH</dc:creator>
<og:description>1.前言 前段时间，自己搞了个阿里云的服务器。想自己在上面折腾，但是不想因为自己瞎折腾而污染了现有的环境。毕竟，现在的阿里云已经没有免费的快照服务了。要想还原的话，最简单的办法就是重新装系统。而一旦重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/detectiveHLH/p/10756702.html</dc:identifier>
</item>
<item>
<title>Spring Boot系列(一) Spring Boot准备知识 - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/10756699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/10756699.html</guid>
<description>&lt;p&gt;本文是学习 Spring Boot 的一些准备知识.&lt;/p&gt;
&lt;h2 id=&quot;spring-web-mvc&quot;&gt;Spring Web MVC&lt;/h2&gt;
&lt;h3 id=&quot;spring-web-mvc-的两个context&quot;&gt;Spring Web MVC 的两个Context&lt;/h3&gt;
&lt;p&gt;如下图所示, 基于 Servlet 的 Spring Web MVC 启动时会创建两个上下文, 即 &lt;code&gt;Servlet WebApplicationContext&lt;/code&gt; 和 &lt;code&gt;Root WebApplicationContext&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;前者是 &lt;code&gt;DispatcherServlet&lt;/code&gt;引导创建的, 后者由 &lt;code&gt;ServletContextListener&lt;/code&gt; 创建, 包含服务,数据库操作等非 Web 相关的组件.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794700/201904/794700-20190423153020694-1025287144.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dispatcherservlet&quot;&gt;DispatcherServlet&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 是前端控制器, Spring MVC 遵循前端控制器模式(具体参看一书). 前端控制器是 MVC 模式中 C 的一部分, 除此之外, C 还包括我们定义的 &lt;code&gt;Controller&lt;/code&gt; 等应用控制器类.&lt;/p&gt;
&lt;h3 id=&quot;handlermapping&quot;&gt;HandlerMapping&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;传统 Servlet 的请求 url 模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet规范中描述了 Servlet 和 Filter 的 URL 匹配模式. 如下;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;精确匹配, 如 &lt;code&gt;/index&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;扩展名匹配, 如 &lt;code&gt;*.jsp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;路径匹配, 如 &lt;code&gt;/hive/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;优先级按精确匹配 &amp;gt; 最长路径匹配 &amp;gt; 扩展名匹配.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring MVC 中的 &lt;code&gt;HandlerMapping&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring boot 中使用自动装配来实例化和启动 &lt;code&gt;DispatcherServlet&lt;/code&gt;. 类名为 &lt;code&gt;DispatcherServletAutoConfiguration&lt;/code&gt;, 路径默认为 &quot;&quot; 或 &quot;/&quot; . 可以修改配置, 对应的配置类为 &lt;code&gt;WebMvcProperties&lt;/code&gt; , 对应的配置为 &lt;code&gt;spring.mvc.servlet.path=/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从中可以看到 Spring 配置的一般规律, 其他的配置项也可以从配置类中找到依据.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(DispatcherServlet.class)
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration {
    ...
    @Configuration
    @Conditional(DefaultDispatcherServletCondition.class)
    @ConditionalOnClass(ServletRegistration.class)
    @EnableConfigurationProperties({ HttpProperties.class, WebMvcProperties.class })
    protected static class DispatcherServletConfiguration {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)
public class WebMvcProperties {
    ...
    private final Servlet servlet = new Servlet();
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class Servlet {

        /**
         * Path of the dispatcher servlet.
         */
        private String path = &quot;/&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;HandlerMapping&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用来找到 URL 匹配的 Handler 方法, 这些方法正是我们定义的 Controller 中的方法. 这些方法被 &lt;code&gt;@RequestMapping&lt;/code&gt; 标记. 这个注解还有一些变体(CRUD): &lt;code&gt;GetMapping&lt;/code&gt; , &lt;code&gt;PostMapping&lt;/code&gt;, &lt;code&gt;PutMapping&lt;/code&gt;, &lt;code&gt;DeleteMapping&lt;/code&gt;等.&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;可以使用实现接口 &lt;code&gt;HandlerInterceptor&lt;/code&gt; 拦截器来验证 handler 的本质. 其中一个方法的签名是 &lt;code&gt;boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/code&gt;. 注意 &lt;code&gt;handler&lt;/code&gt; 定义的类型是 &lt;code&gt;Object&lt;/code&gt;, 说明handler的类型可能不止是 &lt;code&gt;HandlerMethod&lt;/code&gt; .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;异常处理&quot;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;参看&lt;a href=&quot;https://www.cnblogs.com/walkinhalo/p/9744656.html&quot;&gt;Spring系列(七) Spring MVC 异常处理&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;servlet-规范&quot;&gt;Servlet 规范&lt;/h3&gt;
&lt;p&gt;规范中定义了异常处理相关的返回信息应该包含什么内容. 如: &lt;code&gt;javax.servlet.error.stauts_code&lt;/code&gt; 定义了错误码; &lt;code&gt;javax.servlet.error.message&lt;/code&gt; 定义了错误信息; &lt;code&gt;javax.servlet.error.exception&lt;/code&gt; 定义了异常.&lt;/p&gt;
&lt;h3 id=&quot;servlet-实现&quot;&gt;Servlet 实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;web.xml&lt;/code&gt; 的配置如下:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;PageNotFoundServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.xlx.servlet.PageNotFoundServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;

&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;PageNotFoundServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/404.html&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;

&amp;lt;error-page&amp;gt;
    &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;
    &amp;lt;location&amp;gt;/404.html&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PageNotFoundServlet&lt;/code&gt; 实现:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PageNotFoundServlet extends HttpServlet{

    public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,Exception{

        // 此处验证request中设置的错误码.
        request.getAttribute(&quot;javax.servlet.error.stauts_code&quot;);

        response.setCharacterEncoding(&quot;UTF-8&quot;);
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter writer = response.getWriter();
        writer.println(&quot;page not found...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mvc-实现&quot;&gt;MVC 实现&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;RestControllerAdvicer&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestConstrollerAdvice
public class RestControllerAdvicer{

    @ExceptionHandler(NohandlerFoundException.class)
    public Object pageNotFound(HttpStatus status,HttpServletRequest request,Throwable throwable){
        Map&amp;lt;String,Object&amp;gt; errors = new HashMap&amp;lt;&amp;gt;();
        errors.put(&quot;stauts_code&quot;,request.getAttribute(&quot;javax.servlet.error.stauts_code&quot;));
         errors.put(&quot;stauts_uri&quot;,request.getAttribute(&quot;javax.servlet.error.request_uri&quot;));

         return error;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spring-boot-实现&quot;&gt;Spring Boot 实现&lt;/h3&gt;
&lt;p&gt;通过实现 &lt;code&gt;ErrorPageRegistrar&lt;/code&gt; 注册错误页面.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Application implements ErrorPageRegistrar{

    @Override
    public void registerErrorPages(ErrorPageRegistry registry){
        registry.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND,&quot;404.html&quot;));
    }
}

....

@GetMapping(&quot;/404.html&quot;)
public Object handle404(){
    // 实现错误处理
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多参看相关的那篇文章.&lt;/p&gt;
&lt;h2 id=&quot;视图&quot;&gt;视图&lt;/h2&gt;
&lt;h3 id=&quot;view&quot;&gt;View&lt;/h3&gt;
&lt;p&gt;接口 &lt;code&gt;View&lt;/code&gt; 定义了一个 &lt;code&gt;void render(@Nullable Map&amp;lt;String, ?&amp;gt; var1, HttpServletRequest var2, HttpServletResponse var3) throws Exception;&lt;/code&gt; 方法, 用来渲染视图.&lt;/p&gt;
&lt;h3 id=&quot;viewreslover&quot;&gt;ViewReslover&lt;/h3&gt;
&lt;p&gt;接口 &lt;code&gt;ViewReslover&lt;/code&gt; 定义解析视图名称的方法 &lt;code&gt;@Nullable View resolveViewName(String var1, Locale var2) throws Exception;&lt;/code&gt; 用来寻找对应的view对象名称.&lt;/p&gt;
&lt;p&gt;view 名称: prefix + viewname + suffix&lt;/p&gt;
&lt;p&gt;前缀 prefix 和 后缀 suffix 同样可以配置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spring.mvc.view.suffix=.jsp&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;thymeleaf&quot;&gt;Thymeleaf&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ThymeleafAutoConfiguration&lt;/code&gt; 同样可以找到对应的配置类 &lt;code&gt;ThymeleafProperties&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ContentNegotiationViewResolver&lt;/code&gt; 内容协调处理器, 处理多个 viewResolver 的情况.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;国际化i18n&quot;&gt;国际化(i18n)&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;理解 &lt;code&gt;MessageSource&lt;/code&gt; 抽象.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 23 Apr 2019 07:29:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>本文是学习 Spring Boot 的一些准备知识. Spring Web MVC Spring Web MVC 的两个Context 如下图所示, 基于 Servlet 的 Spring Web M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/10756699.html</dc:identifier>
</item>
<item>
<title>MATLAB程序：用FCM分割脑图像 - 凯鲁嘎吉</title>
<link>http://www.cnblogs.com/kailugaji/p/10756673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kailugaji/p/10756673.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者：凯鲁嘎吉 - 博客园&lt;a href=&quot;https://www.cnblogs.com/kailugaji/p/%20http://www.cnblogs.com/kailugaji/&quot; target=&quot;_blank&quot;&gt; http://www.cnblogs.com/kailugaji/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;脑图像基础知识请看：&lt;a href=&quot;https://www.cnblogs.com/kailugaji/tag/%E8%84%91%E5%9B%BE%E5%83%8F/&quot; target=&quot;_blank&quot;&gt;脑图像&lt;/a&gt;；FCM算法介绍请看：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kailugaji/p/9648430.html&quot;&gt;聚类——FCM&lt;/a&gt;；数据来源：&lt;a href=&quot;http://brainweb.bic.mni.mcgill.ca/brainweb/&quot; target=&quot;_blank&quot;&gt;BrainWeb: Simulated Brain Database&lt;/a&gt;，只选取脑图像中的0、1、2、3类，其余类别设为0。本文用到的数据：&lt;a href=&quot;https://files-cdn.cnblogs.com/files/kailugaji/Simulated_Brain_Database.rar&quot; target=&quot;_blank&quot;&gt;Simulated Brain Database&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1. MATLAB程序&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;FCM_image_main.m&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function [accuracy,iter_FCM,run_time]=FCM_image_main(filename, num, K)
%num：第几层，K：聚类数
%[accuracy,iter_FCM,run_time]=FCM_image_main('t1_icbm_normal_1mm_pn0_rf0.rawb', 100, 4)
[data_load, label_load]=main(filename, num);  %原图像
[m,n]=size(data_load);
X=reshape(data_load,m*n,1);   %(m*n)*1
real_label=reshape(label_load,m*n,1)+ones(m*n,1);
Ground_truth(num, K);  %标准分割结果，进行渲染
t0=cputime;
[label_1,~,iter_FCM]=My_FCM(X,K);
[label_new,accuracy]=succeed(real_label,K,label_1);
run_time=cputime-t0;
label_2=reshape(label_new,m, n); 
rendering_image(label_2, K);  %聚类结果
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;main.m&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function [read_new, mark]=main(filename, num)
%将真实脑图像中的0、1、2、3拿出来，其余像素为0.
%函数main(filename, num)中的第一个参数filename是欲读取的rawb文件的文件名，第二个参数num就是第多少张。
%例如：main('t1_icbm_normal_1mm_pn0_rf0.rawb',100)
mark=Mark('phantom_1.0mm_normal_crisp.rawb',num);
read=readrawb(filename, num);
[row, col]=size(read);
read_new=zeros(row, col);
for i=1:row   %行
    for j=1:col    %列
        if mark(i,j)==0
            read_new(i,j)=0;
        else
            read_new(i,j)=read(i,j);   %将第0、1、2、3类拿出来，其余类为0
        end
    end
end
%旋转90°并显示出来
figure(1);  
init_image=imrotate(read_new, 90); 
imshow(uint8(init_image)); 
title('原图像');
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;Mark.m&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function mark=Mark(filename,num)
%将标签为1、2、3类分出来，其余为0，mark取值：0、1、2、3
%[mark_new,mark]=Mark('phantom_1.0mm_normal_crisp.rawb',90);
fp=fopen(filename);
temp=fread(fp, 181 * 217 * 181);
image=reshape(temp, 181 * 217, 181);   
images=image(:, num);
images=reshape(images, 181, 217);
mark_data=images;
fclose(fp);
mark=zeros(181,217);
%将第0、1、2、3类标签所在的坐标点拿出来，其余置0
for i=1:181
    for j=1:217
        if (mark_data(i,j)==1)||(mark_data(i,j)==2)||(mark_data(i,j)==3)
            mark(i,j)=mark_data(i,j);
        else
            mark(i,j)=0;
        end
    end
end
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;readrawb.m&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function g = readrawb(filename, num)
% 函数readrawb(filename, num)中的第一个参数filename是欲读取的rawb文件的文件名，第二个参数num就是第多少张。
fid = fopen(filename);
% 连续读取181*217*181个数据，这时候temp是一个长度为181*217*181的向量。
% 先将rawb中的所有数据传递给temp数组，然后将tempreshape成图片集。
temp = fread(fid, 181 * 217 * 181);
% 所以把它变成了一个181*217行，181列的数组，按照它的代码，这就是181张图片的数据，每一列对应一张图。
% 生成图片集数组。图片集images数组中每一列表示一张图片。
images = reshape(temp, 181 * 217, 181);   
% 读取数组中的第num行，得到数组再reshape成图片原来的行数和列数：181*217。
image = images(:, num);
image = reshape(image, 181, 217);
g = image;
fclose(fid);
end
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;Ground_truth.m&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function Ground_truth(num, K)
%标准分割结果
%Ground_truth(100, 4)
mark=Mark('phantom_1.0mm_normal_crisp.rawb',num);  %0、1、2、3
m=181;
n=217;
read_new=zeros(m,n);
mark=mark+ones(m, n);  %标签：1、2、3、4
for i=1:m   %行
    for j=1:n    %列
        for k=1:K
            if mark(i,j)==k
                read_new(i,j)=floor(255/K)*(k-1);               
            end
        end
    end
end
% 旋转90°并显示出来
figure(2)
truth_image=imrotate(read_new, 90); 
imshow(uint8(truth_image)); 
title('标准分割结果');
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;My_FCM.m&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;67&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function [label_1,para_miu_new,iter]=My_FCM(data,K)
%输入K：聚类数
%输出：label_1:聚的类, para_miu_new:模糊聚类中心μ，responsivity:模糊隶属度
format long
eps=1e-8;  %定义迭代终止条件的eps
alpha=2;  %模糊加权指数，[1,+无穷)
T=100;  %最大迭代次数
fitness=zeros(T,1);
[data_num,~]=size(data);
count=zeros(data_num,1);  %统计distant中每一行为0的个数
responsivity=zeros(data_num,K);
R_up=zeros(data_num,K);
%----------------------------------------------------------------------------------------------------
%对data做最大-最小归一化处理
X=(data-ones(data_num,1)*min(data))./(ones(data_num,1)*(max(data)-min(data)));
[X_num,X_dim]=size(X);
%----------------------------------------------------------------------------------------------------
%随机初始化K个聚类中心
rand_array=randperm(X_num);  %产生1~X_num之间整数的随机排列
para_miu=X(rand_array(1:K),:);  %随机排列取前K个数，在X矩阵中取这K行作为初始聚类中心
% ----------------------------------------------------------------------------------------------------
% FCM算法
for t=1:T
    %欧氏距离，计算（X-para_miu）^2=X^2+para_miu^2-2*para_miu*X'，矩阵大小为X_num*K
    distant=(sum(X.*X,2))*ones(1,K)+ones(X_num,1)*(sum(para_miu.*para_miu,2))'-2*X*para_miu';
    %更新隶属度矩阵X_num*K
    for i=1:X_num
        count(i)=sum(distant(i,:)==0);
        if count(i)&amp;gt;0
            for k=1:K
                if distant(i,k)==0
                    responsivity(i,k)=1./count(i);
                else
                    responsivity(i,k)=0;
                end
            end
        else
            R_up(i,:)=distant(i,:).^(-1/(alpha-1));  %隶属度矩阵的分子部分
            responsivity(i,:)= R_up(i,:)./sum( R_up(i,:),2);
        end
    end
    %目标函数值
    fitness(t)=sum(sum(distant.*(responsivity.^(alpha))));
     %更新聚类中心K*X_dim
    miu_up=(responsivity'.^(alpha))*X;  %μ的分子部分
    para_miu=miu_up./((sum(responsivity.^(alpha)))'*ones(1,X_dim));
    if t&amp;gt;1  
        if abs(fitness(t)-fitness(t-1))&amp;lt;eps
            break;
        end
    end
end
para_miu_new=para_miu;
iter=t;  %实际迭代次数
[~,label_1]=max(responsivity,[],2);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;succeed.m&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function [label_new,accuracy]=succeed(real_label,K,id)
%输入K：聚的类，id：训练后的聚类结果，N*1的矩阵
N=size(id,1);   %样本个数
p=perms(1:K);   %全排列矩阵
p_col=size(p,1);   %全排列的行数
new_label=zeros(N,p_col);   %聚类结果的所有可能取值，N*p_col
num=zeros(1,p_col);  %与真实聚类结果一样的个数
%将训练结果全排列为N*p_col的矩阵，每一列为一种可能性
for i=1:N
    for j=1:p_col
        for k=1:K
            if id(i)==k
                new_label(i,j)=p(j,k);  %iris数据库，1 2 3
            end
        end
    end
end
%与真实结果比对，计算精确度
for j=1:p_col
    for i=1:N
        if new_label(i,j)==real_label(i)
                num(j)=num(j)+1;
        end
    end
end
[M,I]=max(num);
accuracy=M/N;
label_new=new_label(:,I);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;rendering_image.m&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function rendering_image(label,K)
%对分割结果进行渲染,4类,label:1、2、3、4
[m, n]=size(label);
read_new=zeros(m,n);
for i=1:m   %行
    for j=1:n    %列
        for k=1:K
            if label(i,j)==k
                read_new(i,j)=floor(255/K)*(k-1);               
            end
        end
    end
end
% 旋转90°并显示出来 
figure(3); 
cluster_image=imrotate(read_new, 90); 
imshow(uint8(cluster_image)); 
title('分割后');
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;2. 实验及结果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对T1模态、icmb协议下，切片厚度为1mm，噪声水平为7%，灰度不均匀水平为40%的第90层脑图像进行分割。因为FCM随机初始化，所以聚类结果会有偏差，结果受初始化影响比较大。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
&amp;gt;&amp;gt; [accuracy,iter_FCM,run_time]=FCM_image_main('t1_icbm_normal_1mm_pn7_rf40.rawb', 90, 4)

accuracy =

   0.943783893881916


iter_FCM =

    25


run_time =

   1.937500000000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;              &lt;img src=&quot;https://img2018.cnblogs.com/blog/1027447/201904/1027447-20190423151459055-1065067530.png&quot; alt=&quot;&quot;/&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1027447/201904/1027447-20190423151529502-704465901.png&quot; alt=&quot;&quot;/&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1027447/201904/1027447-20190423151550078-1975715324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 23 Apr 2019 07:26:00 +0000</pubDate>
<dc:creator>凯鲁嘎吉</dc:creator>
<og:description>MATLAB程序：用FCM分割脑图像 作者：凯鲁嘎吉 - 博客园 http://www.cnblogs.com/kailugaji/ 脑图像基础知识请看：脑图像；FCM算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kailugaji/p/10756673.html</dc:identifier>
</item>
<item>
<title>互联网公司的架构设计要怎么落地？ - arch-system</title>
<link>http://www.cnblogs.com/dotnet-arch-system/p/10756631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnet-arch-system/p/10756631.html</guid>
<description>&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;　　你做架构设计了吗？你认为要不要做架构设计？你的公司有没有做架构设计？互联网公司的架构设计又要怎么做？我不知道你是怎么想的，在我得到的答复中，大部分人认为要做架构设计，但自己却很少做，自己经历的公司也少有做架构设计。这里是矛盾的，难道大部分人和公司都犯错了吗？应该不是这样。专职的架构师越来越少，架构部门也大都解散，为什么会是这样，我们该怎么办？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、初识架构设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;软件工程一般可分为需求、设计、编码、测试、部署、维护。既然架构设计是一个过程，那么就有输入和输出。架构设计输入的是PRD产品说明书，输出的是架构设计文档，中间是处理过程和工具，具体如下：&lt;/p&gt;
&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;输入：功能需求和非功能需求，从PRD中提取；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;过程和工具：&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-indent-1 ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;设计的目标和思路&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-indent-1 ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;功能设计：用例视图、用例活动图&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-indent-1 ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;应用：边界、逻辑架构、接口、领域图&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-indent-1 ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;数据存储&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-indent-1 ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;物理架构、安装部署&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-indent-1 ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;非功能设计&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;jCfS&quot;&gt;输出：设计说明书，表述工具有Word、Visio、UML等&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;需求是我要什么即What，而架构设计是我要怎么做即How。架构设计为施工阶段提供了指导，有利于接下来的编码、测试、部署和维护，包括项目排期、人员分工、配合、单元测试、物理部署、系统修改和升级。设计是施工的计划，没有计划就没有管理，计划可节约施工的成本和时间。如果没有架构设计就开始写代码，会导致很多的问题，干着干着就干不下去了，或干到一半必须得改等等现象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、应用架构设计案例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;以下是一个真实的应用架构设计案例，《国内航班查询引擎项目》的架构设计过程如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 功能清单&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;产品经理提供的PRD文档做得怎么样，第一眼就看它有没有功能清单。下图的功能清单表格主要有两个核心功能，一个是查询航班数据模块，另一个是清理缓存模块。&lt;/p&gt;
&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;你做架构设计了吗？你认为要不要做架构设计？你的公司有没有做架构设计？互联网公司的架构设计又要怎么做？我不知道你是怎么想的，在我得到的答复中，大部分人认为要做架构设计，但自己却很少做，自己经历的公司也少有做架构设计。这里是矛盾的，难道大部分人和公司都犯错了吗？应该不是这样。专职的架构师越来越少，架构部门也大都解散，为什么会是这样，我们该怎么办？&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;一、初识架构设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;软件工程一般可分为需求、设计、编码、测试、部署、维护。既然架构设计是一个过程，那么就有输入和输出。架构设计输入的是PRD产品说明书，输出的是架构设计文档，中间是处理过程和工具，具体如下：&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;输入：功能需求和非功能需求，从&amp;quot;],[20,&amp;quot;PRD中提取；&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;过程和工具：&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;设计的目标和思路&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;功能设计：用例视图、用例活动图&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;应用：边界、逻辑架构、接口、领域图&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;数据存储&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;物理架构、安装部署&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;非功能设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;输出：设计说明书，表述工具有Word、Visio、UML等&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;需求是我要什么即What，而架构设计是我要怎么做即How。架构设计为施工阶段提供了指导，有利于接下来的编码、测试、部署和维护，包括项目排期、人员分工、配合、单元测试、物理部署、系统修改和升级。设计是施工的计划，没有计划就没有管理，计划可节约施工的成本和时间。如果没有架构设计就开始写代码，会导致很多的问题，干着干着就干不下去了，或干到一半必须得改等等现象。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;二、应用架构设计案例&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;以下是一个真实的应用架构设计案例，《国内航班查询引擎项目》的架构设计过程如下：\n2.1 功能清单&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;产品经理提供的PRD文档做得怎么样，第一眼就看它有没有功能清单。下图的功能清单表格主要有两个核心功能，一个是查询航班数据模块，另一个是清理缓存模块。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery-block&amp;quot;:&amp;quot;https://images-cdn.shimo.im/gQjPx8ucdiUtNkY9/image.image/png!thumbnail&amp;quot;},&amp;quot;29:1|30:0|3:\&amp;quot;415px\&amp;quot;|4:\&amp;quot;218.984px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;218.984px\&amp;quot;|ori-width:\&amp;quot;415px\&amp;quot;&amp;quot;],[20,&amp;quot;2.2 用例图与用例活动图&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/oASxorsTjXgKDObk/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;415px\&amp;quot;|4:\&amp;quot;256.688px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;256.688px\&amp;quot;|ori-width:\&amp;quot;415px\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/WV99sMsrXDwgkvRR/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;345px\&amp;quot;|4:\&amp;quot;486.828px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;486.828px\&amp;quot;|ori-width:\&amp;quot;345px\&amp;quot;&amp;quot;],[20,&amp;quot;\n上图是用例图和用例活动图，用例图有查询航班数据和清理缓存，这与功能清单有对应关系。每一个用例都可以展开为用例活动图，产品经理的活动图关注的是业务的逻辑，我们的用例活动图关注是程序的业务逻辑，有更多的技术视角。如图所示，前台网站或Mobile发起查询请求后，经过参数验证，然后分别获取政策、获取贴点、获取价格、获取航班数据，再合并计算数据，最后构建返回数据。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.3 领域图&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/1Rd20g82erEg4uUH/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;415px\&amp;quot;|4:\&amp;quot;250.797px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;250.797px\&amp;quot;|ori-width:\&amp;quot;415px\&amp;quot;&amp;quot;],[20,&amp;quot;\n上图是领域图，它从用例活动图演化而来，图中的行为与活动图有对应关系。如图所示，平台或Mobile触发查询引擎后，然后多线程获取政策数据、贴点数据、价格数据和航班数据，然后进行合并计算。领域图是应用程序的业务逻辑模型，它的每一个框有可能是一个类，也可能是一个类库，或是一个应用、一个子系统，它是可大可小、可伸缩、可扩展的。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.4 接口设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/vjSbSuD2wfUzPQN1/%E6%9F%A5%E8%AF%A2%E8%88%AA%E7%8F%AD%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3.png!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23494949\&amp;quot;|29:0|30:0|3:\&amp;quot;611px\&amp;quot;|4:\&amp;quot;833.438px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;833.438px\&amp;quot;|ori-width:\&amp;quot;611px\&amp;quot;&amp;quot;],[20,&amp;quot;&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n什么是接口？接口是契约、连接和交互，它是应用与外部世界的联系者。有一位资深架构师说过，“我只需要设计好一套接口，让整个业务流转起来，我的工作就做完了，至于怎么实现我可以不知道”，这话有一定道理。以上契约遵循统一的Request/Response实现模式设计规范。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.5 分层设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/kqyTuyVbYeIfCa25/统一分层架构.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;611px\&amp;quot;|4:\&amp;quot;389.719px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;389.719px\&amp;quot;|ori-width:\&amp;quot;611px\&amp;quot;&amp;quot;],[20,&amp;quot;\n2.6 代码实现&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/UpI2cvVzv7QuSHsc/代码实现.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;611px\&amp;quot;|4:\&amp;quot;435.938px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;435.938px\&amp;quot;|ori-width:\&amp;quot;611px\&amp;quot;&amp;quot;],[20,&amp;quot;\n左上图是第一个版本的代码实现，例如SearchVerify实现验证查询参数、CaculateBusiness实现合并计算、PolicyBusiness实现政策相关逻辑、PriceBusiness实现价格相关逻辑、DiscountBusiness实现贴点相关逻辑、CacheBusiness实现缓存逻辑、UserBusiness实现用户逻辑。右上图是第二个版本，相对第一个版本的实现要复杂些：ValidateBusiness对应验证查询参数、CaculateBusiness对应合并计算、PolicyBusiness对应政策、PriceBusiness对应价格、TiedianBusiness对应贴点、FilterPolicy对应政策过滤。可能你已经发现，不管代码怎么升级改造，只要领域模型没有发生变化，业务模块也就不会发生大的变化。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;架构设计会改变编码方式&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;，在架构设计阶段如果做好了领域模型，你就可以在编码施工阶段，先写业务逻辑层再写数据访问层。先定义好业务服务和数据接口定义，再根据数据定义来实现数据访问。这与表驱动的传统方式有所不同。&amp;quot;],[20,&amp;quot;先写数据层再写业务逻辑层，是&amp;quot;,&amp;quot;history:\&amp;quot;deletion\&amp;quot;&amp;quot;],[20,&amp;quot;先写好数据表的增删改查，然后业务逻辑层只是简单地调用一下数据层，便提供给界面层使用。它只是一个简单代理，完全没有发挥业务逻辑层应有的价值。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.7 其它设计项&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;除了以上设计项，还有数据库设计、物理架构设计、非功能性设计。数据库设计有E-R图和表设计，物理架构设计有应用集群、应用部署图、域名等，非功能性设计有性能、可用性、伸缩性、扩展性、安全性等。最后是总结和表述，输出一份架构设计文档，详见下图和附档链接。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/VJyoTHGWvcIyDTM7/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;198px\&amp;quot;|4:\&amp;quot;410.938px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;410.938px\&amp;quot;|ori-width:\&amp;quot;198px\&amp;quot;&amp;quot;],[20,&amp;quot;\n2.8 演化&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/fkNIabnIpZw3BNj5/%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E5%88%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;587px\&amp;quot;|4:\&amp;quot;349.609px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;349.609px\&amp;quot;|ori-width:\&amp;quot;587px\&amp;quot;&amp;quot;],[20,&amp;quot;\n以上是架构设计的关键过程，&amp;quot;],[20,&amp;quot;上&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;一环是功能需求，下一环是代码实施，从功能需求到用例图，到用例活动图，到领域图、架构分层和核心代码，&amp;quot;,&amp;quot;0:\&amp;quot;%232b2b2b\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;以领域模型为中心去构建业务逻辑代码，然后再实现数据库的访问。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;它们之间环环相扣，做不好领域图可能源自没有做好用例活动图，因为用例活动图是领域图的上一环。&amp;quot;,&amp;quot;0:\&amp;quot;%232b2b2b\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;从功能到图纸到代码，从代码到图纸到功能，&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;这是一个可&amp;quot;,&amp;quot;0:\&amp;quot;%232b2b2b\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;演化可追溯的过程。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;架构设计如同施工图纸，能直接指导工程代码的实施，以及&amp;quot;,&amp;quot;0:\&amp;quot;%232b2b2b\&amp;quot;&amp;quot;],[20,&amp;quot;编码施工次序的改变。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.9 案例参考&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;AppArchDemo案例参考地址&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：&amp;quot;],[20,&amp;quot;https://github.com/das2017/AppArchDemo&amp;quot;,&amp;quot;16:\&amp;quot;https%3A%2F%2Fgithub.com%2Fdas2017%2FAppArchDemo\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;fZ4A\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;三、更多知&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;识探讨&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;什么是探讨，什么是培训？培训是我有知识和经验，然后教给大家，我是正确的，大家照着干就可以了。而探讨是我有一个很好的问题，来问大家，来请教大家，以启发你我的思维。接下来，与你一起探讨以下架构知识：&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.1 设计表述&amp;quot;],[20,&amp;quot;探讨&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;|27:\&amp;quot;14\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;一定要有架构设计文档吗？按教科书是需要的，但真实的情况可能并不是这样，没有设计文档的情况并不少见。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;架构设计文档要不要保存？项目做完后，它要保存多久呢？你待过的公司有保存吗？我们要沉下心来问问自己，追求真实比书本更为重要。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;设计文档到底在为谁服务？为自己还是为别人？为半年后的自己，还是为公司或同事？&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;设计可以省掉吗？在没有设计文档的前提下，是否可以编写高质量的代码？如果文档可以省掉，那么架构设计过程呢？&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;架构设计文档的编写并不简单，可能要花一周或一个月的时间，成本较高。设计表述方式有多种，具体如下：\n架构设计文档：&amp;quot;],[20,&amp;quot;它相当于造房子用的施工图纸，是相对&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;比较正式的方式；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Us1z\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;需求分析设计或项目排期会议：PRD出来后，研发成员一起开需求分析设计会，分析讨论的过程也是设计的过程。或者通过项目排期，在估算项目难易程度和排期时，也有设计分析的成分；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Us1z\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;设计邮件：一份简单的设计邮件，内容大约有：问题描述、原因分析、技术方案、架构建议等；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Us1z\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;非正式讨论：几个人站在白板前，讨论和画画，会议结束后再把它拍下发给参与人员。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Us1z\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;3.2 关于UML&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;UML是Unified Modeling Language缩写，又称统一建模语言，是始于1997年一个OMG标准。它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。它不仅统一了Booch、Rumbaugh和Jacobson的表示方法，而且对其作了进一步的发展，并最终统一为标准建模语言。UML图型主要有用例图、时序图、活动图、类图、状态图、组件图和部署图。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;UML是设计表述和建模工具，虽然它的愿景是全生命周期，甚至用UML直接生成可执行软件。实际上这是很难的，不到真正写代码，不可能明确所有细节。当然，UML在设计过程中还是有一定作用的，例如时序图、类图、状态图，这些如果不用UML图来表示而用文字来描述的话，大家很难达成一致理解。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;UML是理想建模工具吗？那什么是理想的建模工具呢？船泊业3D建模，在未生产前就在电脑里把整个船构建起来。塑胶建模工具ProE、商品房售楼部的沙盘，在未见实物前就可通过模型知道很多信息。理想建模工具应该是3D的、动态的、简单而形象的。UML只是一种表述你头脑中思想的工具，相对而言你头脑中的思想才重要，所选用的表述工具要根据双方的实际情况，简单清晰、利于沟通才是目的，并不一定就是UML。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.3 关于设计模式&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;设计模式是一套被反复使用的、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式是为了重用代码，让代码更容易被他人理解。 设计模式于己于他于系统都是多赢的，设计模式使代码编制进一步工程化。每种模式都描述了一个不断重复发生的问题，以及该问题的核心解决方案，项目中合理地运用设计模式可以很好地解决很多问题。GoF的设计模式共有23种，理解意图是运用设计模式的关键，一图胜万言，下面是图解23种设计模式。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/nDMwg5kswpgIrcIO/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;558px\&amp;quot;|4:\&amp;quot;359.797px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;359.797px\&amp;quot;|ori-width:\&amp;quot;558px\&amp;quot;&amp;quot;],[20,&amp;quot;\n设计模式是代码的形状，是代码结构设计的招式，是练功的套路，如同书是人类进步的阶梯。但练功是练功，打架是打架，真正的功夫要在大规模实战中所得。从设计模式到代码，再从代码重构到设计模式。设计模式不仅是设计出来的，也是重构「长」出来的。虽然重构并非一定会得到与设计模式完全相同的抽象结果，但重构是设计模式的迭代补充。设计模式如果使用得过早过多或不恰当，会给代码增加不必要的结构复杂度。重构和模式设计的良好结合，使代码更趋于品质和实用。GoF设计模式是始于1995年的经典，主要解决当时软件的重用性、扩展性和可维护性问题。而在20多年后互联网时代的今天，版本迭代快、可随时在线更新，使用环境、语言和框架都已发生变化，许多模式是否还合时宜？设计模式在面试的时候用得多，还是在实际开发中用得多？可能每个人答案都不一样，但每个工具都有其适用场景、收益和成本，思考这些有利于我们更好地使用它。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.4 关于设计原则&amp;quot;],[20,&amp;quot;SOLID&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;设计原则是设计模式的关键所在，原则和方法是决策的思想指南，设计原则SOLID具体如下：&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;单一职责原则SRP：一个类只做一种类型的责任，一次只做一件事；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;开闭原则OCP：对扩展开放，对修改关闭。开闭原则具有理想主义的色彩，它是面向对象设计的终极目标；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;里氏代换原则LSP：任何基类可以出现的地方，子类一定可以出现，它是一个建议或约定；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;接口隔离原则ISP：不能强迫用户去依赖那些他们不使用的接口；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;依赖倒置原则DIP：高层模块不应该依赖低层模块，但它们都应该依赖抽象，客户第一。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;3.5 关于DDD&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;DDD是Domain Driven Design的缩写，翻译为领域驱动设计，它的核心是领域模型。什么是模型？装修人员从来没看过你的房子，但看过以下模型后，就能知道你要装修成什么样。它的价值在于导航、精炼、统一表述。它能够帮助施工方和客户，全方面和多角度地去看待问题，而不是盲人摸象。它是利于沟通、实现、维护和扩展。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/K9hX6icpAoU6PIx7/11.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;565px\&amp;quot;|4:\&amp;quot;317.953px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;317.953px\&amp;quot;|ori-width:\&amp;quot;565px\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,&amp;quot;什么是领域？&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;领是领地的意思，域是边界的意思。领域是一个专业科目，是人为的划分，一个领域一个边界一个框，领域会随着规模、角度和时代的变更而发生变化。例如，公司规模很小的时候，没有财务部，一个人既当会计又当出纳。当公司规模变大一些时，可以一位做会计，一位做出纳，可划分两个领域。当公司规模变得更大的时候，领域又变了，成立财务部，财务部里有N位，每人干的事情都不一样。业务在变，认知在变，领域的划分也要变。领域是主观的，它是对客观世界的阶段性认知。\n&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/XSvnHBcUen4mJkue/image.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;559px\&amp;quot;|4:\&amp;quot;299px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;299px\&amp;quot;|ori-width:\&amp;quot;559px\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,&amp;quot;领域模型处于业务问题与技术解决之间，先将业务对象抽象成领域模型，然后根据领域模型来实现技术对象。从对象到类再到对象，从具体到抽象再到具体，我们对抽象和具体再做进一步引申。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;请问，是先有鸡还是先有蛋？这个问题不好回答，给你一只具体的鸡和一个具体的蛋，你便能知道它们是父子关系、子父关系或没有关系，但是如果给你一只抽象的鸡和一个抽象的蛋，你是不知道它们是什么关系的。再请问，是先有类还是先有对象？这个问题也不好回答。在设计阶段，是先有对象再有类，在编码阶段，是先有类然后再有对象。整个过程是：架构师在设计阶段根据业务对象抽象出类，然后程序员在编码阶段，先编写类然后再New出一个对象。从对象到类再到对象，从业务问题到领域模型再到技术解决方案，从问题域到领域模型再到代码实施，这是领域驱动的核心所在。&amp;quot;],[20,&amp;quot;领域驱动设计=从问题域驱动领域模型构建+从领域模型驱动代码实施。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/SqIWMBIxWp8Frr4j/DDD分层法.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;433px\&amp;quot;|4:\&amp;quot;577.328px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;577.328px\&amp;quot;|ori-width:\&amp;quot;433px\&amp;quot;&amp;quot;],[20,&amp;quot;\n以上是DDD的分层架构，包括仓储层Repository Layer、领域层Domain Layer、应用层Application Layer、表现层Presentation Layer、基础设施层Infrastructure Layer。从仓库中取出原材料，然后流水线将人、材料、工具组织起来，最后输出给表现层。上图中，领域层不依赖于仓储层，而是仓储层依赖于领域层。这相当于传统三层中业务逻辑层不依赖于数据层，而是数据层依赖于业务逻辑层。为什么要这样呢？这是因为上层需要什么下层就提供什么，而不是下层有什么就提供什么，客户第一、按需生产都是这个道理。在技术的具体实现上即依赖倒置DIP，把接口放在上层，然后下层实现，最后使用IoC工具绑定即可。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.6 设计不足与过度设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;什么是设计不足，什么是过度设计？不能解决当前问题的就是设计不足；只能解决当前问题的是恰当设计；能解决当前问题，且又能解决未来一段时间问题的是良好设计；能解决当前问题，但面向未来设计过多，且成本较大，预测错误又不能解决未来问题的是过度设计。我们要追求恰当设计或良好设计，特别是互联网项目，变化大、迭代快，很难预测未来发生的事项。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;那什么是好的设计呢？好的设计是实用的、易于理解的，是谨慎克制的、简单的，是能够落地的、考虑施工成本的。好的设计要解决业务的问题，你的设计再牛逼，但不能解决业务的问题，那么这个设计就是不好的设计。好的设计是谨慎克制的，不能为Show技术或个人意愿而过多使用复杂的技术。好的设计是能够落地的，如果你的设计在落地上出现很多问题，那么就是有问题的设计。没有人在设计时失败，只有实施时失败。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.7 架构设计是艺术&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;以上架构知识非常重要，但并不是知道了这些，就能做好架构设计了。这如同很多人都会画圆和直线，但并不会画画；很多人会使用钉板和菜刀，但并不能做一桌美味的佳肴。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;我们探讨一个具体的问题，“能异步的尽量异步”，互联网公司程序员经常说的这句话，是否正确？首先，程序员喜欢同步还是异步？用户喜欢同步还是异步？程序员为了并发量，会选择异步。用户不要等待，要求系统立即返回，会选择同步。那么在什么情况下使用同步，什么情况下使用异步呢？有几个考虑因子，第一个是复杂度，同步=异步+轮询/通知，同步相对简单，异步则相对复杂。第二个是可靠度，如果是2/5/8秒概率较大，那么最好选用同步。第三个是用户体验，当使用异步后，用户体验也需要改进，可立即返回给用户一个单号和进度条。第四个是业务成熟度，业务成熟度分萌芽期、发展期、成熟期、衰退期这四个阶段。对于新业务，能同步就同步，当业务变得越来越成熟，访问量越来越大的时候，容易出现高并发量导致用户排队，这时异步是挺好的选择。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;在实际问题面前，选择同步还是异步？要看情况，需经过分析、思考，你需要知道每一种选择的利弊。&amp;quot;],[20,&amp;quot;分析的过程往往比决策更为重要，当你知道了每一种选择的利弊，这时你喜欢就好，因为你只有喜欢了才能把事情办得更好。你的架构设计=你+架构设计，架构设计是科学，你是主观意识，最后的决策一定包含了你的个性和情感。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;科学到最后是艺术，架构设计是艺术。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;四、互联网公司的架构设计要怎么落地&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;互联网公司的架构设计是怎么做的呢？专职的架构师越来越少，架构部门也大都解散，为什么会是这样，我们该怎么办？&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;4.1 要不要做架构设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;哪些项目需要做架构设计呢？越大的项目越需要做架构设计，开发时间越长的项目越需要做架构设计，参与人员越多、内部越复杂、外部依赖越多、影响面越大、维护成本越高的项目越需要做架构设计。那&amp;quot;],[20,&amp;quot;互联网的项目呢？它有以下特征：&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;时间：开发的周期整体很长，可能维护10年、20年，但单个应用的开发周期短，多半以天和周为单位；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;OPYx\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;规模：互联网项目整体很大，但单个应用规模小，会被拆分为多个小应用；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;OPYx\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;业务知识：为自己做系统，行业知识不缺，长期为一个系统服务，有些自己也是客户；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;OPYx\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;复杂度：研发人员多，内部关系复杂，外部依赖多，变化大迭代快，在不断地演化，24小时不间断运行。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;OPYx\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;4.2 MVP与架构设计 &amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/f2MzklaXjg0v9QxL/MVP.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;612px\&amp;quot;|4:\&amp;quot;396.297px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;396.297px\&amp;quot;|ori-width:\&amp;quot;612px\&amp;quot;&amp;quot;],[20,&amp;quot; &amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot; MVP的英文全称是Minimum Viable Product，是最小可行性产品的意思。如上图所示，用户需要一个交通工具，有两种实现方式，第一种做法是分多个阶段设计与制造，第一步是造一个轮子，第二步是造两个轮子，第三步是造一个盖子，第四步是一辆可用的轿车。第二种做法是每一阶段都要满足用户从A地到B地的需求，第一步先造个滑板，第二步是造个自行车，第三步是造辆摩托车，第四步是造辆轿车。第一个版本到第三个版本输出的产品都可以满足用户的基本需求，虽不完善但可以解决用户的问题，并且越来越好，到了第四个版本的产品才是客户预期。\nMVP对架构设计提出更高的要求。如果单纯从研发内部的角度，第一种是施工成本较低的方案，但我们需要以客户为中心，需要不断地满足客户的需求，所以在做设计时，不仅要考虑施工的成本，还有客户需求、扩展性、继承性等，如上图第三种设计方案。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;4.3 互联网公司是怎么做的&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;互联网公司的架构设计是怎么做的，当前主流做法有：\n分工：将技术研发和业务研发相分离，下层是云平台部或基础架构部，提供IaaS、PaaS中间件等云服务，上层是各业务线的产品研发部，专注于业务场景的应用研发；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;敏捷：业务研发敏捷化，产品与研发、测试实时沟通，以减少行业知识的缺乏；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;整体：技术委员会，负责技术总体规划和技术成长；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;未来：研究院，解决未来的技术问题，如阿里达摩院、百度研究院；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;应用架构：主要负责技术与业务的结合，由应用架构师、技术经理或高级程序员担当。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;4.4 应用架构要怎么落地&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;应用的架构设计要怎么落地，常见如下：\n总体架构规划：手握地图，才能明确自己所处的位置，以便于配合。总体架构规划可以让每个研发人员了解整体，它如同房子的地基框架图纸，可长期保存和更新维护。具体参考TOGAF开放组体系结构。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;单个项目架构设计：重点项目一定要做架构设计，参与架构评审，非重点项目&amp;quot;],[20,&amp;quot;可简化设计表述。&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;应用架构评审：以流程的方式来保证应用架构设计的质量，例如重构项目、跨部门项目、业务核心项目需要经过应用架构评审之后，才能申请服务器、数据库、域名等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;其它工作：如果有应用架构师专职人员，除以上工作外，还包括统一公司应用分层、制定代码规范、组织技术培训、中间件推广、应用性能调优等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;五、你给技术打个分&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;以上，首先是一个启发性的问题，然后是初识架构设计，接着是一个真实的应用架构设计案例，并探讨了更多架构设计知识，包括设计表述、UML、设计模式、设计原则SOLID以及DDD，最后是互联网公司要怎么落地。这些知识点都是工具，这些工具到底怎么样呢？如果它是一个新知识，我们不好妄加评价，但这些工具已经出来很多年了，我们也工作了这么多年。它好不好用，实不实用，我们都应该知道些。现在，大家也当回老板，请你给技术打个分，以下二维码是链接，欢迎绩效考评 :-)&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/qieXBXHU6L8LzM3F/image.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;256px\&amp;quot;|4:\&amp;quot;280.078px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;280.078px\&amp;quot;|ori-width:\&amp;quot;256px\&amp;quot;&amp;quot;],[20,&amp;quot;\n六、案例参考&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;AppArchDemo案例参考地址&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：&amp;quot;],[20,&amp;quot;https://github.com/das2017/AppArchDemo&amp;quot;,&amp;quot;16:\&amp;quot;https%3A%2F%2Fgithub.com%2Fdas2017%2FAppArchDemo\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;fZ4A\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,&amp;quot;作者简介：&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n张辉清，10多年IT老兵，系统分析师、项目管理师。曾中青易游CTO、同程交通创新技术负责人、古大集团首席架构师、携程架构师，领导过30～200人的技术团队，将研发能力提高1～2个档次。现关注架构设计与工程效率、技术变现、中小研发团队能力提升。\n\n---------------------------------------------------\n&amp;quot;],[20,&amp;quot;留言送书活动：&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,&amp;quot;参与方式：&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;即日起至2019年2月xx日 24:00\n在文末右下角“写留言”处说说你对架构设计的想法，支持数-前两位的精彩留言将会获得作者签名图书《小团队构建大网站：中小研发团队架构实践》\n\n本期赠书由本文的作者赞助。\n&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;你做架构设计了吗？你认为要不要做架构设计？你的公司有没有做架构设计？互联网公司的架构设计又要怎么做？我不知道你是怎么想的，在我得到的答复中，大部分人认为要做架构设计，但自己却很少做，自己经历的公司也少有做架构设计。这里是矛盾的，难道大部分人和公司都犯错了吗？应该不是这样。专职的架构师越来越少，架构部门也大都解散，为什么会是这样，我们该怎么办？&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;一、初识架构设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;软件工程一般可分为需求、设计、编码、测试、部署、维护。既然架构设计是一个过程，那么就有输入和输出。架构设计输入的是PRD产品说明书，输出的是架构设计文档，中间是处理过程和工具，具体如下：&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;输入：功能需求和非功能需求，从&amp;quot;],[20,&amp;quot;PRD中提取；&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;过程和工具：&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;设计的目标和思路&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;功能设计：用例视图、用例活动图&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;应用：边界、逻辑架构、接口、领域图&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;数据存储&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;物理架构、安装部署&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;非功能设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;33:1|bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;输出：设计说明书，表述工具有Word、Visio、UML等&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;jCfS\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;需求是我要什么即What，而架构设计是我要怎么做即How。架构设计为施工阶段提供了指导，有利于接下来的编码、测试、部署和维护，包括项目排期、人员分工、配合、单元测试、物理部署、系统修改和升级。设计是施工的计划，没有计划就没有管理，计划可节约施工的成本和时间。如果没有架构设计就开始写代码，会导致很多的问题，干着干着就干不下去了，或干到一半必须得改等等现象。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;二、应用架构设计案例&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;以下是一个真实的应用架构设计案例，《国内航班查询引擎项目》的架构设计过程如下：\n2.1 功能清单&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;产品经理提供的PRD文档做得怎么样，第一眼就看它有没有功能清单。下图的功能清单表格主要有两个核心功能，一个是查询航班数据模块，另一个是清理缓存模块。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery-block&amp;quot;:&amp;quot;https://images-cdn.shimo.im/gQjPx8ucdiUtNkY9/image.image/png!thumbnail&amp;quot;},&amp;quot;29:1|30:0|3:\&amp;quot;415px\&amp;quot;|4:\&amp;quot;218.984px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;218.984px\&amp;quot;|ori-width:\&amp;quot;415px\&amp;quot;&amp;quot;],[20,&amp;quot;2.2 用例图与用例活动图&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/oASxorsTjXgKDObk/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;415px\&amp;quot;|4:\&amp;quot;256.688px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;256.688px\&amp;quot;|ori-width:\&amp;quot;415px\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/WV99sMsrXDwgkvRR/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;345px\&amp;quot;|4:\&amp;quot;486.828px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;486.828px\&amp;quot;|ori-width:\&amp;quot;345px\&amp;quot;&amp;quot;],[20,&amp;quot;\n上图是用例图和用例活动图，用例图有查询航班数据和清理缓存，这与功能清单有对应关系。每一个用例都可以展开为用例活动图，产品经理的活动图关注的是业务的逻辑，我们的用例活动图关注是程序的业务逻辑，有更多的技术视角。如图所示，前台网站或Mobile发起查询请求后，经过参数验证，然后分别获取政策、获取贴点、获取价格、获取航班数据，再合并计算数据，最后构建返回数据。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.3 领域图&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/1Rd20g82erEg4uUH/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;415px\&amp;quot;|4:\&amp;quot;250.797px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;250.797px\&amp;quot;|ori-width:\&amp;quot;415px\&amp;quot;&amp;quot;],[20,&amp;quot;\n上图是领域图，它从用例活动图演化而来，图中的行为与活动图有对应关系。如图所示，平台或Mobile触发查询引擎后，然后多线程获取政策数据、贴点数据、价格数据和航班数据，然后进行合并计算。领域图是应用程序的业务逻辑模型，它的每一个框有可能是一个类，也可能是一个类库，或是一个应用、一个子系统，它是可大可小、可伸缩、可扩展的。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.4 接口设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/vjSbSuD2wfUzPQN1/%E6%9F%A5%E8%AF%A2%E8%88%AA%E7%8F%AD%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3.png!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23494949\&amp;quot;|29:0|30:0|3:\&amp;quot;611px\&amp;quot;|4:\&amp;quot;833.438px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;833.438px\&amp;quot;|ori-width:\&amp;quot;611px\&amp;quot;&amp;quot;],[20,&amp;quot;&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n什么是接口？接口是契约、连接和交互，它是应用与外部世界的联系者。有一位资深架构师说过，“我只需要设计好一套接口，让整个业务流转起来，我的工作就做完了，至于怎么实现我可以不知道”，这话有一定道理。以上契约遵循统一的Request/Response实现模式设计规范。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.5 分层设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/kqyTuyVbYeIfCa25/统一分层架构.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;611px\&amp;quot;|4:\&amp;quot;389.719px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;389.719px\&amp;quot;|ori-width:\&amp;quot;611px\&amp;quot;&amp;quot;],[20,&amp;quot;\n2.6 代码实现&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/UpI2cvVzv7QuSHsc/代码实现.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;611px\&amp;quot;|4:\&amp;quot;435.938px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;435.938px\&amp;quot;|ori-width:\&amp;quot;611px\&amp;quot;&amp;quot;],[20,&amp;quot;\n左上图是第一个版本的代码实现，例如SearchVerify实现验证查询参数、CaculateBusiness实现合并计算、PolicyBusiness实现政策相关逻辑、PriceBusiness实现价格相关逻辑、DiscountBusiness实现贴点相关逻辑、CacheBusiness实现缓存逻辑、UserBusiness实现用户逻辑。右上图是第二个版本，相对第一个版本的实现要复杂些：ValidateBusiness对应验证查询参数、CaculateBusiness对应合并计算、PolicyBusiness对应政策、PriceBusiness对应价格、TiedianBusiness对应贴点、FilterPolicy对应政策过滤。可能你已经发现，不管代码怎么升级改造，只要领域模型没有发生变化，业务模块也就不会发生大的变化。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;架构设计会改变编码方式&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;，在架构设计阶段如果做好了领域模型，你就可以在编码施工阶段，先写业务逻辑层再写数据访问层。先定义好业务服务和数据接口定义，再根据数据定义来实现数据访问。这与表驱动的传统方式有所不同。&amp;quot;],[20,&amp;quot;先写数据层再写业务逻辑层，是&amp;quot;,&amp;quot;history:\&amp;quot;deletion\&amp;quot;&amp;quot;],[20,&amp;quot;先写好数据表的增删改查，然后业务逻辑层只是简单地调用一下数据层，便提供给界面层使用。它只是一个简单代理，完全没有发挥业务逻辑层应有的价值。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.7 其它设计项&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;除了以上设计项，还有数据库设计、物理架构设计、非功能性设计。数据库设计有E-R图和表设计，物理架构设计有应用集群、应用部署图、域名等，非功能性设计有性能、可用性、伸缩性、扩展性、安全性等。最后是总结和表述，输出一份架构设计文档，详见下图和附档链接。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/VJyoTHGWvcIyDTM7/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;198px\&amp;quot;|4:\&amp;quot;410.938px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;410.938px\&amp;quot;|ori-width:\&amp;quot;198px\&amp;quot;&amp;quot;],[20,&amp;quot;\n2.8 演化&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/fkNIabnIpZw3BNj5/%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E5%88%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;587px\&amp;quot;|4:\&amp;quot;349.609px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;349.609px\&amp;quot;|ori-width:\&amp;quot;587px\&amp;quot;&amp;quot;],[20,&amp;quot;\n以上是架构设计的关键过程，&amp;quot;],[20,&amp;quot;上&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;一环是功能需求，下一环是代码实施，从功能需求到用例图，到用例活动图，到领域图、架构分层和核心代码，&amp;quot;,&amp;quot;0:\&amp;quot;%232b2b2b\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;以领域模型为中心去构建业务逻辑代码，然后再实现数据库的访问。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;它们之间环环相扣，做不好领域图可能源自没有做好用例活动图，因为用例活动图是领域图的上一环。&amp;quot;,&amp;quot;0:\&amp;quot;%232b2b2b\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;从功能到图纸到代码，从代码到图纸到功能，&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;这是一个可&amp;quot;,&amp;quot;0:\&amp;quot;%232b2b2b\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;演化可追溯的过程。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;架构设计如同施工图纸，能直接指导工程代码的实施，以及&amp;quot;,&amp;quot;0:\&amp;quot;%232b2b2b\&amp;quot;&amp;quot;],[20,&amp;quot;编码施工次序的改变。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;2.9 案例参考&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;AppArchDemo案例参考地址&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：&amp;quot;],[20,&amp;quot;https://github.com/das2017/AppArchDemo&amp;quot;,&amp;quot;16:\&amp;quot;https%3A%2F%2Fgithub.com%2Fdas2017%2FAppArchDemo\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;fZ4A\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;三、更多知&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;识探讨&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;什么是探讨，什么是培训？培训是我有知识和经验，然后教给大家，我是正确的，大家照着干就可以了。而探讨是我有一个很好的问题，来问大家，来请教大家，以启发你我的思维。接下来，与你一起探讨以下架构知识：&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.1 设计表述&amp;quot;],[20,&amp;quot;探讨&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;|27:\&amp;quot;14\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;一定要有架构设计文档吗？按教科书是需要的，但真实的情况可能并不是这样，没有设计文档的情况并不少见。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;架构设计文档要不要保存？项目做完后，它要保存多久呢？你待过的公司有保存吗？我们要沉下心来问问自己，追求真实比书本更为重要。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;设计文档到底在为谁服务？为自己还是为别人？为半年后的自己，还是为公司或同事？&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;设计可以省掉吗？在没有设计文档的前提下，是否可以编写高质量的代码？如果文档可以省掉，那么架构设计过程呢？&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;架构设计文档的编写并不简单，可能要花一周或一个月的时间，成本较高。设计表述方式有多种，具体如下：\n架构设计文档：&amp;quot;],[20,&amp;quot;它相当于造房子用的施工图纸，是相对&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;比较正式的方式；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Us1z\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;需求分析设计或项目排期会议：PRD出来后，研发成员一起开需求分析设计会，分析讨论的过程也是设计的过程。或者通过项目排期，在估算项目难易程度和排期时，也有设计分析的成分；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Us1z\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;设计邮件：一份简单的设计邮件，内容大约有：问题描述、原因分析、技术方案、架构建议等；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Us1z\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;非正式讨论：几个人站在白板前，讨论和画画，会议结束后再把它拍下发给参与人员。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Us1z\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;3.2 关于UML&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;UML是Unified Modeling Language缩写，又称统一建模语言，是始于1997年一个OMG标准。它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。它不仅统一了Booch、Rumbaugh和Jacobson的表示方法，而且对其作了进一步的发展，并最终统一为标准建模语言。UML图型主要有用例图、时序图、活动图、类图、状态图、组件图和部署图。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;UML是设计表述和建模工具，虽然它的愿景是全生命周期，甚至用UML直接生成可执行软件。实际上这是很难的，不到真正写代码，不可能明确所有细节。当然，UML在设计过程中还是有一定作用的，例如时序图、类图、状态图，这些如果不用UML图来表示而用文字来描述的话，大家很难达成一致理解。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;UML是理想建模工具吗？那什么是理想的建模工具呢？船泊业3D建模，在未生产前就在电脑里把整个船构建起来。塑胶建模工具ProE、商品房售楼部的沙盘，在未见实物前就可通过模型知道很多信息。理想建模工具应该是3D的、动态的、简单而形象的。UML只是一种表述你头脑中思想的工具，相对而言你头脑中的思想才重要，所选用的表述工具要根据双方的实际情况，简单清晰、利于沟通才是目的，并不一定就是UML。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.3 关于设计模式&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;设计模式是一套被反复使用的、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式是为了重用代码，让代码更容易被他人理解。 设计模式于己于他于系统都是多赢的，设计模式使代码编制进一步工程化。每种模式都描述了一个不断重复发生的问题，以及该问题的核心解决方案，项目中合理地运用设计模式可以很好地解决很多问题。GoF的设计模式共有23种，理解意图是运用设计模式的关键，一图胜万言，下面是图解23种设计模式。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/nDMwg5kswpgIrcIO/image.image/png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;558px\&amp;quot;|4:\&amp;quot;359.797px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;359.797px\&amp;quot;|ori-width:\&amp;quot;558px\&amp;quot;&amp;quot;],[20,&amp;quot;\n设计模式是代码的形状，是代码结构设计的招式，是练功的套路，如同书是人类进步的阶梯。但练功是练功，打架是打架，真正的功夫要在大规模实战中所得。从设计模式到代码，再从代码重构到设计模式。设计模式不仅是设计出来的，也是重构「长」出来的。虽然重构并非一定会得到与设计模式完全相同的抽象结果，但重构是设计模式的迭代补充。设计模式如果使用得过早过多或不恰当，会给代码增加不必要的结构复杂度。重构和模式设计的良好结合，使代码更趋于品质和实用。GoF设计模式是始于1995年的经典，主要解决当时软件的重用性、扩展性和可维护性问题。而在20多年后互联网时代的今天，版本迭代快、可随时在线更新，使用环境、语言和框架都已发生变化，许多模式是否还合时宜？设计模式在面试的时候用得多，还是在实际开发中用得多？可能每个人答案都不一样，但每个工具都有其适用场景、收益和成本，思考这些有利于我们更好地使用它。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.4 关于设计原则&amp;quot;],[20,&amp;quot;SOLID&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;设计原则是设计模式的关键所在，原则和方法是决策的思想指南，设计原则SOLID具体如下：&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;单一职责原则SRP：一个类只做一种类型的责任，一次只做一件事；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;开闭原则OCP：对扩展开放，对修改关闭。开闭原则具有理想主义的色彩，它是面向对象设计的终极目标；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;里氏代换原则LSP：任何基类可以出现的地方，子类一定可以出现，它是一个建议或约定；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;接口隔离原则ISP：不能强迫用户去依赖那些他们不使用的接口；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;依赖倒置原则DIP：高层模块不应该依赖低层模块，但它们都应该依赖抽象，客户第一。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;Rtis\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;3.5 关于DDD&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;DDD是Domain Driven Design的缩写，翻译为领域驱动设计，它的核心是领域模型。什么是模型？装修人员从来没看过你的房子，但看过以下模型后，就能知道你要装修成什么样。它的价值在于导航、精炼、统一表述。它能够帮助施工方和客户，全方面和多角度地去看待问题，而不是盲人摸象。它是利于沟通、实现、维护和扩展。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/K9hX6icpAoU6PIx7/11.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;565px\&amp;quot;|4:\&amp;quot;317.953px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;317.953px\&amp;quot;|ori-width:\&amp;quot;565px\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,&amp;quot;什么是领域？&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;领是领地的意思，域是边界的意思。领域是一个专业科目，是人为的划分，一个领域一个边界一个框，领域会随着规模、角度和时代的变更而发生变化。例如，公司规模很小的时候，没有财务部，一个人既当会计又当出纳。当公司规模变大一些时，可以一位做会计，一位做出纳，可划分两个领域。当公司规模变得更大的时候，领域又变了，成立财务部，财务部里有N位，每人干的事情都不一样。业务在变，认知在变，领域的划分也要变。领域是主观的，它是对客观世界的阶段性认知。\n&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/XSvnHBcUen4mJkue/image.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;559px\&amp;quot;|4:\&amp;quot;299px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;299px\&amp;quot;|ori-width:\&amp;quot;559px\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,&amp;quot;领域模型处于业务问题与技术解决之间，先将业务对象抽象成领域模型，然后根据领域模型来实现技术对象。从对象到类再到对象，从具体到抽象再到具体，我们对抽象和具体再做进一步引申。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;请问，是先有鸡还是先有蛋？这个问题不好回答，给你一只具体的鸡和一个具体的蛋，你便能知道它们是父子关系、子父关系或没有关系，但是如果给你一只抽象的鸡和一个抽象的蛋，你是不知道它们是什么关系的。再请问，是先有类还是先有对象？这个问题也不好回答。在设计阶段，是先有对象再有类，在编码阶段，是先有类然后再有对象。整个过程是：架构师在设计阶段根据业务对象抽象出类，然后程序员在编码阶段，先编写类然后再New出一个对象。从对象到类再到对象，从业务问题到领域模型再到技术解决方案，从问题域到领域模型再到代码实施，这是领域驱动的核心所在。&amp;quot;],[20,&amp;quot;领域驱动设计=从问题域驱动领域模型构建+从领域模型驱动代码实施。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/SqIWMBIxWp8Frr4j/DDD分层法.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;433px\&amp;quot;|4:\&amp;quot;577.328px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;577.328px\&amp;quot;|ori-width:\&amp;quot;433px\&amp;quot;&amp;quot;],[20,&amp;quot;\n以上是DDD的分层架构，包括仓储层Repository Layer、领域层Domain Layer、应用层Application Layer、表现层Presentation Layer、基础设施层Infrastructure Layer。从仓库中取出原材料，然后流水线将人、材料、工具组织起来，最后输出给表现层。上图中，领域层不依赖于仓储层，而是仓储层依赖于领域层。这相当于传统三层中业务逻辑层不依赖于数据层，而是数据层依赖于业务逻辑层。为什么要这样呢？这是因为上层需要什么下层就提供什么，而不是下层有什么就提供什么，客户第一、按需生产都是这个道理。在技术的具体实现上即依赖倒置DIP，把接口放在上层，然后下层实现，最后使用IoC工具绑定即可。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.6 设计不足与过度设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;什么是设计不足，什么是过度设计？不能解决当前问题的就是设计不足；只能解决当前问题的是恰当设计；能解决当前问题，且又能解决未来一段时间问题的是良好设计；能解决当前问题，但面向未来设计过多，且成本较大，预测错误又不能解决未来问题的是过度设计。我们要追求恰当设计或良好设计，特别是互联网项目，变化大、迭代快，很难预测未来发生的事项。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;那什么是好的设计呢？好的设计是实用的、易于理解的，是谨慎克制的、简单的，是能够落地的、考虑施工成本的。好的设计要解决业务的问题，你的设计再牛逼，但不能解决业务的问题，那么这个设计就是不好的设计。好的设计是谨慎克制的，不能为Show技术或个人意愿而过多使用复杂的技术。好的设计是能够落地的，如果你的设计在落地上出现很多问题，那么就是有问题的设计。没有人在设计时失败，只有实施时失败。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3.7 架构设计是艺术&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;以上架构知识非常重要，但并不是知道了这些，就能做好架构设计了。这如同很多人都会画圆和直线，但并不会画画；很多人会使用钉板和菜刀，但并不能做一桌美味的佳肴。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;我们探讨一个具体的问题，“能异步的尽量异步”，互联网公司程序员经常说的这句话，是否正确？首先，程序员喜欢同步还是异步？用户喜欢同步还是异步？程序员为了并发量，会选择异步。用户不要等待，要求系统立即返回，会选择同步。那么在什么情况下使用同步，什么情况下使用异步呢？有几个考虑因子，第一个是复杂度，同步=异步+轮询/通知，同步相对简单，异步则相对复杂。第二个是可靠度，如果是2/5/8秒概率较大，那么最好选用同步。第三个是用户体验，当使用异步后，用户体验也需要改进，可立即返回给用户一个单号和进度条。第四个是业务成熟度，业务成熟度分萌芽期、发展期、成熟期、衰退期这四个阶段。对于新业务，能同步就同步，当业务变得越来越成熟，访问量越来越大的时候，容易出现高并发量导致用户排队，这时异步是挺好的选择。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;在实际问题面前，选择同步还是异步？要看情况，需经过分析、思考，你需要知道每一种选择的利弊。&amp;quot;],[20,&amp;quot;分析的过程往往比决策更为重要，当你知道了每一种选择的利弊，这时你喜欢就好，因为你只有喜欢了才能把事情办得更好。你的架构设计=你+架构设计，架构设计是科学，你是主观意识，最后的决策一定包含了你的个性和情感。&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;科学到最后是艺术，架构设计是艺术。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;四、互联网公司的架构设计要怎么落地&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;互联网公司的架构设计是怎么做的呢？专职的架构师越来越少，架构部门也大都解散，为什么会是这样，我们该怎么办？&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;4.1 要不要做架构设计&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;哪些项目需要做架构设计呢？越大的项目越需要做架构设计，开发时间越长的项目越需要做架构设计，参与人员越多、内部越复杂、外部依赖越多、影响面越大、维护成本越高的项目越需要做架构设计。那&amp;quot;],[20,&amp;quot;互联网的项目呢？它有以下特征：&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;时间：开发的周期整体很长，可能维护10年、20年，但单个应用的开发周期短，多半以天和周为单位；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;OPYx\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;规模：互联网项目整体很大，但单个应用规模小，会被拆分为多个小应用；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;OPYx\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;业务知识：为自己做系统，行业知识不缺，长期为一个系统服务，有些自己也是客户；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;OPYx\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;复杂度：研发人员多，内部关系复杂，外部依赖多，变化大迭代快，在不断地演化，24小时不间断运行。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;OPYx\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;4.2 MVP与架构设计 &amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/f2MzklaXjg0v9QxL/MVP.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;612px\&amp;quot;|4:\&amp;quot;396.297px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;396.297px\&amp;quot;|ori-width:\&amp;quot;612px\&amp;quot;&amp;quot;],[20,&amp;quot; &amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot; MVP的英文全称是Minimum Viable Product，是最小可行性产品的意思。如上图所示，用户需要一个交通工具，有两种实现方式，第一种做法是分多个阶段设计与制造，第一步是造一个轮子，第二步是造两个轮子，第三步是造一个盖子，第四步是一辆可用的轿车。第二种做法是每一阶段都要满足用户从A地到B地的需求，第一步先造个滑板，第二步是造个自行车，第三步是造辆摩托车，第四步是造辆轿车。第一个版本到第三个版本输出的产品都可以满足用户的基本需求，虽不完善但可以解决用户的问题，并且越来越好，到了第四个版本的产品才是客户预期。\nMVP对架构设计提出更高的要求。如果单纯从研发内部的角度，第一种是施工成本较低的方案，但我们需要以客户为中心，需要不断地满足客户的需求，所以在做设计时，不仅要考虑施工的成本，还有客户需求、扩展性、继承性等，如上图第三种设计方案。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;4.3 互联网公司是怎么做的&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;互联网公司的架构设计是怎么做的，当前主流做法有：\n分工：将技术研发和业务研发相分离，下层是云平台部或基础架构部，提供IaaS、PaaS中间件等云服务，上层是各业务线的产品研发部，专注于业务场景的应用研发；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;敏捷：业务研发敏捷化，产品与研发、测试实时沟通，以减少行业知识的缺乏；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;整体：技术委员会，负责技术总体规划和技术成长；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;未来：研究院，解决未来的技术问题，如阿里达摩院、百度研究院；&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;应用架构：主要负责技术与业务的结合，由应用架构师、技术经理或高级程序员担当。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;0JrC\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;4.4 应用架构要怎么落地&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:3&amp;quot;],[20,&amp;quot;应用的架构设计要怎么落地，常见如下：\n总体架构规划：手握地图，才能明确自己所处的位置，以便于配合。总体架构规划可以让每个研发人员了解整体，它如同房子的地基框架图纸，可长期保存和更新维护。具体参考TOGAF开放组体系结构。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;单个项目架构设计：重点项目一定要做架构设计，参与架构评审，非重点项目&amp;quot;],[20,&amp;quot;可简化设计表述。&amp;quot;,&amp;quot;0:\&amp;quot;%23494949\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;应用架构评审：以流程的方式来保证应用架构设计的质量，例如重构项目、跨部门项目、业务核心项目需要经过应用架构评审之后，才能申请服务器、数据库、域名等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;其它工作：如果有应用架构师专职人员，除以上工作外，还包括统一公司应用分层、制定代码规范、组织技术培训、中间件推广、应用性能调优等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;五、你给技术打个分&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;以上，首先是一个启发性的问题，然后是初识架构设计，接着是一个真实的应用架构设计案例，并探讨了更多架构设计知识，包括设计表述、UML、设计模式、设计原则SOLID以及DDD，最后是互联网公司要怎么落地。这些知识点都是工具，这些工具到底怎么样呢？如果它是一个新知识，我们不好妄加评价，但这些工具已经出来很多年了，我们也工作了这么多年。它好不好用，实不实用，我们都应该知道些。现在，大家也当回老板，请你给技术打个分，以下二维码是链接，欢迎绩效考评 :-)&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://images-cdn.shimo.im/qieXBXHU6L8LzM3F/image.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;256px\&amp;quot;|4:\&amp;quot;280.078px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;280.078px\&amp;quot;|ori-width:\&amp;quot;256px\&amp;quot;&amp;quot;],[20,&amp;quot;\n六、案例参考&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;AppArchDemo案例参考地址&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：&amp;quot;],[20,&amp;quot;https://github.com/das2017/AppArchDemo&amp;quot;,&amp;quot;16:\&amp;quot;https%3A%2F%2Fgithub.com%2Fdas2017%2FAppArchDemo\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;bullet-id:\&amp;quot;fZ4A\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,&amp;quot;作者简介：&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n张辉清，10多年IT老兵，系统分析师、项目管理师。曾中青易游CTO、同程交通创新技术负责人、古大集团首席架构师、携程架构师，领导过30～200人的技术团队，将研发能力提高1～2个档次。现关注架构设计与工程效率、技术变现、中小研发团队能力提升。\n\n---------------------------------------------------\n&amp;quot;],[20,&amp;quot;留言送书活动：&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;],[20,&amp;quot;参与方式：&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;即日起至2019年2月xx日 24:00\n在文末右下角“写留言”处说说你对架构设计的想法，支持数-前两位的精彩留言将会获得作者签名图书《小团队构建大网站：中小研发团队架构实践》\n\n本期赠书由本文的作者赞助。\n&amp;quot;]]&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/gQjPx8ucdiUtNkY9/image.image/png!thumbnail&quot; alt=&quot;&quot; width=&quot;415px&quot; height=&quot;218.984px&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 用例图与用例活动图&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/oASxorsTjXgKDObk/image.image/png!thumbnail&quot; alt=&quot;&quot; width=&quot;415px&quot; height=&quot;256.688px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/WV99sMsrXDwgkvRR/image.image/png!thumbnail&quot; alt=&quot;&quot; width=&quot;345px&quot; height=&quot;486.828px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;上图是用例图和用例活动图，用例图有查询航班数据和清理缓存，这与功能清单有对应关系。每一个用例都可以展开为用例活动图，产品经理的活动图关注的是业务的逻辑，我们的用例活动图关注是程序的业务逻辑，有更多的技术视角。如图所示，前台网站或Mobile发起查询请求后，经过参数验证，然后分别获取政策、获取贴点、获取价格、获取航班数据，再合并计算数据，最后构建返回数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 领域图&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/1Rd20g82erEg4uUH/image.image/png!thumbnail&quot; alt=&quot;&quot; width=&quot;415px&quot; height=&quot;250.797px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;上图是领域图，它从用例活动图演化而来，图中的行为与活动图有对应关系。如图所示，平台或Mobile触发查询引擎后，然后多线程获取政策数据、贴点数据、价格数据和航班数据，然后进行合并计算。领域图是应用程序的业务逻辑模型，它的每一个框有可能是一个类，也可能是一个类库，或是一个应用、一个子系统，它是可大可小、可伸缩、可扩展的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4 接口设计&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/vjSbSuD2wfUzPQN1/%E6%9F%A5%E8%AF%A2%E8%88%AA%E7%8F%AD%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3.png!thumbnail&quot; alt=&quot;&quot; width=&quot;611px&quot; height=&quot;833.438px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;什么是接口？接口是契约、连接和交互，它是应用与外部世界的联系者。有一位资深架构师说过，“我只需要设计好一套接口，让整个业务流转起来，我的工作就做完了，至于怎么实现我可以不知道”，这话有一定道理。以上契约遵循统一的Request/Response实现模式设计规范。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.5 分层设计&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/kqyTuyVbYeIfCa25/%E7%BB%9F%E4%B8%80%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png!thumbnail&quot; alt=&quot;&quot; width=&quot;611px&quot; height=&quot;389.719px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.6 代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/UpI2cvVzv7QuSHsc/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png!thumbnail&quot; alt=&quot;&quot; width=&quot;611px&quot; height=&quot;435.938px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;左上图是第一个版本的代码实现，例如SearchVerify实现验证查询参数、CaculateBusiness实现合并计算、PolicyBusiness实现政策相关逻辑、PriceBusiness实现价格相关逻辑、DiscountBusiness实现贴点相关逻辑、CacheBusiness实现缓存逻辑、UserBusiness实现用户逻辑。右上图是第二个版本，相对第一个版本的实现要复杂些：ValidateBusiness对应验证查询参数、CaculateBusiness对应合并计算、PolicyBusiness对应政策、PriceBusiness对应价格、TiedianBusiness对应贴点、FilterPolicy对应政策过滤。可能你已经发现，不管代码怎么升级改造，只要领域模型没有发生变化，业务模块也就不会发生大的变化。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;&lt;strong&gt;架构设计会改变编码方式&lt;/strong&gt;，在架构设计阶段如果做好了领域模型，你就可以在编码施工阶段，先写业务逻辑层再写数据访问层。先定义好业务服务和数据接口定义，再根据数据定义来实现数据访问。这与表驱动的传统方式有所不同。先写数据层再写业务逻辑层，是先写好数据表的增删改查，然后业务逻辑层只是简单地调用一下数据层，便提供给界面层使用。它只是一个简单代理，完全没有发挥业务逻辑层应有的价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.7 其它设计项&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;除了以上设计项，还有数据库设计、物理架构设计、非功能性设计。数据库设计有E-R图和表设计，物理架构设计有应用集群、应用部署图、域名等，非功能性设计有性能、可用性、伸缩性、扩展性、安全性等。最后是总结和表述，输出一份架构设计文档，详见下图和附档链接。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/VJyoTHGWvcIyDTM7/image.image/png!thumbnail&quot; alt=&quot;&quot; width=&quot;198px&quot; height=&quot;410.938px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.8 演化&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/fkNIabnIpZw3BNj5/%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E5%88%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png!thumbnail&quot; alt=&quot;&quot; width=&quot;587px&quot; height=&quot;349.609px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;以上是架构设计的关键过程，&lt;strong&gt;上&lt;/strong&gt;&lt;strong&gt;一环是功能需求，下一环是代码实施，从功能需求到用例图，到用例活动图，到领域图、架构分层和核心代码，&lt;/strong&gt;&lt;strong&gt;以领域模型为中心去构建业务逻辑代码，然后再实现数据库的访问。&lt;/strong&gt;&lt;strong&gt;它们之间环环相扣，做不好领域图可能源自没有做好用例活动图，因为用例活动图是领域图的上一环。&lt;/strong&gt;&lt;strong&gt;从功能到图纸到代码，从代码到图纸到功能，&lt;/strong&gt;&lt;strong&gt;这是一个可&lt;/strong&gt;&lt;strong&gt;演化可追溯的过程。&lt;/strong&gt;架构设计如同施工图纸，能直接指导工程代码的实施，以及编码施工次序的改变。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、更多知识探讨&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;什么是探讨，什么是培训？培训是我有知识和经验，然后教给大家，我是正确的，大家照着干就可以了。而探讨是我有一个很好的问题，来问大家，来请教大家，以启发你我的思维。接下来，与你一起探讨以下架构知识：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 设计表述探讨&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;liGt&quot; data-list-number=&quot;1&quot; data-list-content=&quot;1.&quot;&gt;一定要有架构设计文档吗？按教科书是需要的，但真实的情况可能并不是这样，没有设计文档的情况并不少见。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;liGt&quot; data-list-number=&quot;2&quot; data-list-content=&quot;2.&quot;&gt;架构设计文档要不要保存？项目做完后，它要保存多久呢？你待过的公司有保存吗？我们要沉下心来问问自己，追求真实比书本更为重要。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;liGt&quot; data-list-number=&quot;3&quot; data-list-content=&quot;3.&quot;&gt;设计文档到底在为谁服务？为自己还是为别人？为半年后的自己，还是为公司或同事？&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;liGt&quot; data-list-number=&quot;4&quot; data-list-content=&quot;4.&quot;&gt;设计可以省掉吗？在没有设计文档的前提下，是否可以编写高质量的代码？如果文档可以省掉，那么架构设计过程呢？&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;ql-long-3423802&quot;&gt;架构设计文档的编写并不简单，可能要花一周或一个月的时间，成本较高。设计表述方式有多种，具体如下：&lt;/p&gt;
&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Us1z&quot;&gt;架构设计文档：它相当于造房子用的施工图纸，是相对比较正式的方式；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Us1z&quot;&gt;需求分析设计或项目排期会议：PRD出来后，研发成员一起开需求分析设计会，分析讨论的过程也是设计的过程。或者通过项目排期，在估算项目难易程度和排期时，也有设计分析的成分；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Us1z&quot;&gt;设计邮件：一份简单的设计邮件，内容大约有：问题描述、原因分析、技术方案、架构建议等；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Us1z&quot;&gt;非正式讨论：几个人站在白板前，讨论和画画，会议结束后再把它拍下发给参与人员。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.2 关于UML&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;UML是Unified Modeling Language缩写，又称统一建模语言，是始于1997年一个OMG标准。它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。它不仅统一了Booch、Rumbaugh和Jacobson的表示方法，而且对其作了进一步的发展，并最终统一为标准建模语言。UML图型主要有用例图、时序图、活动图、类图、状态图、组件图和部署图。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;UML是设计表述和建模工具，虽然它的愿景是全生命周期，甚至用UML直接生成可执行软件。实际上这是很难的，不到真正写代码，不可能明确所有细节。当然，UML在设计过程中还是有一定作用的，例如时序图、类图、状态图，这些如果不用UML图来表示而用文字来描述的话，大家很难达成一致理解。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;UML是理想建模工具吗？那什么是理想的建模工具呢？船泊业3D建模，在未生产前就在电脑里把整个船构建起来。塑胶建模工具ProE、商品房售楼部的沙盘，在未见实物前就可通过模型知道很多信息。理想建模工具应该是3D的、动态的、简单而形象的。UML只是一种表述你头脑中思想的工具，相对而言你头脑中的思想才重要，所选用的表述工具要根据双方的实际情况，简单清晰、利于沟通才是目的，并不一定就是UML。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3 关于设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式是为了重用代码，让代码更容易被他人理解。 设计模式于己于他于系统都是多赢的，设计模式使代码编制进一步工程化。每种模式都描述了一个不断重复发生的问题，以及该问题的核心解决方案，项目中合理地运用设计模式可以很好地解决很多问题。GoF的设计模式共有23种，理解意图是运用设计模式的关键，一图胜万言，下面是图解23种设计模式。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/nDMwg5kswpgIrcIO/image.image/png!thumbnail&quot; alt=&quot;&quot; width=&quot;558px&quot; height=&quot;359.797px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;设计模式是代码的形状，是代码结构设计的招式，是练功的套路，如同书是人类进步的阶梯。但练功是练功，打架是打架，真正的功夫要在大规模实战中所得。从设计模式到代码，再从代码重构到设计模式。设计模式不仅是设计出来的，也是重构「长」出来的。虽然重构并非一定会得到与设计模式完全相同的抽象结果，但重构是设计模式的迭代补充。设计模式如果使用得过早过多或不恰当，会给代码增加不必要的结构复杂度。重构和模式设计的良好结合，使代码更趋于品质和实用。GoF设计模式是始于1995年的经典，主要解决当时软件的重用性、扩展性和可维护性问题。而在20多年后互联网时代的今天，版本迭代快、可随时在线更新，使用环境、语言和框架都已发生变化，许多模式是否还合时宜？设计模式在面试的时候用得多，还是在实际开发中用得多？可能每个人答案都不一样，但每个工具都有其适用场景、收益和成本，思考这些有利于我们更好地使用它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.4 关于设计原则SOLID&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;设计原则是设计模式的关键所在，原则和方法是决策的思想指南，设计原则SOLID具体如下：&lt;/p&gt;
&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Rtis&quot;&gt;单一职责原则SRP：一个类只做一种类型的责任，一次只做一件事；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Rtis&quot;&gt;开闭原则OCP：对扩展开放，对修改关闭。开闭原则具有理想主义的色彩，它是面向对象设计的终极目标；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Rtis&quot;&gt;里氏代换原则LSP：任何基类可以出现的地方，子类一定可以出现，它是一个建议或约定；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Rtis&quot;&gt;接口隔离原则ISP：不能强迫用户去依赖那些他们不使用的接口；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;Rtis&quot;&gt;依赖倒置原则DIP：高层模块不应该依赖低层模块，但它们都应该依赖抽象，客户第一。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.5 关于DDD&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;DDD是Domain Driven Design的缩写，翻译为领域驱动设计，它的核心是领域模型。什么是模型？装修人员从来没看过你的房子，但看过以下模型后，就能知道你要装修成什么样。它的价值在于导航、精炼、统一表述。它能够帮助施工方和客户，全方面和多角度地去看待问题，而不是盲人摸象。它是利于沟通、实现、维护和扩展。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/K9hX6icpAoU6PIx7/11.png!thumbnail&quot; alt=&quot;&quot; width=&quot;565px&quot; height=&quot;317.953px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;strong&gt;什么是领域？&lt;/strong&gt;领是领地的意思，域是边界的意思。领域是一个专业科目，是人为的划分，一个领域一个边界一个框，领域会随着规模、角度和时代的变更而发生变化。例如，公司规模很小的时候，没有财务部，一个人既当会计又当出纳。当公司规模变大一些时，可以一位做会计，一位做出纳，可划分两个领域。当公司规模变得更大的时候，领域又变了，成立财务部，财务部里有N位，每人干的事情都不一样。业务在变，认知在变，领域的划分也要变。领域是主观的，它是对客观世界的阶段性认知。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/XSvnHBcUen4mJkue/image.png!thumbnail&quot; alt=&quot;&quot; width=&quot;559px&quot; height=&quot;299px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;&lt;strong&gt;领域模型处于业务问题与技术解决之间，先将业务对象抽象成领域模型，然后根据领域模型来实现技术对象。从对象到类再到对象，从具体到抽象再到具体，我们对抽象和具体再做进一步引申。&lt;/strong&gt;请问，是先有鸡还是先有蛋？这个问题不好回答，给你一只具体的鸡和一个具体的蛋，你便能知道它们是父子关系、子父关系或没有关系，但是如果给你一只抽象的鸡和一个抽象的蛋，你是不知道它们是什么关系的。再请问，是先有类还是先有对象？这个问题也不好回答。在设计阶段，是先有对象再有类，在编码阶段，是先有类然后再有对象。整个过程是：架构师在设计阶段根据业务对象抽象出类，然后程序员在编码阶段，先编写类然后再New出一个对象。从对象到类再到对象，从业务问题到领域模型再到技术解决方案，从问题域到领域模型再到代码实施，这是领域驱动的核心所在。&lt;strong&gt;领域驱动设计=从问题域驱动领域模型构建+从领域模型驱动代码实施。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/SqIWMBIxWp8Frr4j/DDD%E5%88%86%E5%B1%82%E6%B3%95.png!thumbnail&quot; alt=&quot;&quot; width=&quot;433px&quot; height=&quot;577.328px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;以上是DDD的分层架构，包括仓储层Repository Layer、领域层Domain Layer、应用层Application Layer、表现层Presentation Layer、基础设施层Infrastructure Layer。从仓库中取出原材料，然后流水线将人、材料、工具组织起来，最后输出给表现层。上图中，领域层不依赖于仓储层，而是仓储层依赖于领域层。这相当于传统三层中业务逻辑层不依赖于数据层，而是数据层依赖于业务逻辑层。为什么要这样呢？这是因为上层需要什么下层就提供什么，而不是下层有什么就提供什么，客户第一、按需生产都是这个道理。在技术的具体实现上即依赖倒置DIP，把接口放在上层，然后下层实现，最后使用IoC工具绑定即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.6 设计不足与过度设计&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;什么是设计不足，什么是过度设计？不能解决当前问题的就是设计不足；只能解决当前问题的是恰当设计；能解决当前问题，且又能解决未来一段时间问题的是良好设计；能解决当前问题，但面向未来设计过多，且成本较大，预测错误又不能解决未来问题的是过度设计。我们要追求恰当设计或良好设计，特别是互联网项目，变化大、迭代快，很难预测未来发生的事项。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;那什么是好的设计呢？好的设计是实用的、易于理解的，是谨慎克制的、简单的，是能够落地的、考虑施工成本的。好的设计要解决业务的问题，你的设计再牛逼，但不能解决业务的问题，那么这个设计就是不好的设计。好的设计是谨慎克制的，不能为Show技术或个人意愿而过多使用复杂的技术。好的设计是能够落地的，如果你的设计在落地上出现很多问题，那么就是有问题的设计。没有人在设计时失败，只有实施时失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.7 架构设计是艺术&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;以上架构知识非常重要，但并不是知道了这些，就能做好架构设计了。这如同很多人都会画圆和直线，但并不会画画；很多人会使用钉板和菜刀，但并不能做一桌美味的佳肴。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;我们探讨一个具体的问题，“能异步的尽量异步”，互联网公司程序员经常说的这句话，是否正确？首先，程序员喜欢同步还是异步？用户喜欢同步还是异步？程序员为了并发量，会选择异步。用户不要等待，要求系统立即返回，会选择同步。那么在什么情况下使用同步，什么情况下使用异步呢？有几个考虑因子，第一个是复杂度，同步=异步+轮询/通知，同步相对简单，异步则相对复杂。第二个是可靠度，如果是2/5/8秒概率较大，那么最好选用同步。第三个是用户体验，当使用异步后，用户体验也需要改进，可立即返回给用户一个单号和进度条。第四个是业务成熟度，业务成熟度分萌芽期、发展期、成熟期、衰退期这四个阶段。对于新业务，能同步就同步，当业务变得越来越成熟，访问量越来越大的时候，容易出现高并发量导致用户排队，这时异步是挺好的选择。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;在实际问题面前，选择同步还是异步？要看情况，需经过分析、思考，你需要知道每一种选择的利弊。&lt;strong&gt;分析的过程往往比决策更为重要，当你知道了每一种选择的利弊，这时你喜欢就好，因为你只有喜欢了才能把事情办得更好。你的架构设计=你+架构设计，架构设计是科学，你是主观意识，最后的决策一定包含了你的个性和情感。&lt;/strong&gt;科学到最后是艺术，架构设计是艺术。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、互联网公司的架构设计要怎么落地&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;互联网公司的架构设计是怎么做的呢？专职的架构师越来越少，架构部门也大都解散，为什么会是这样，我们该怎么办？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 要不要做架构设计&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;哪些项目需要做架构设计呢？越大的项目越需要做架构设计，开发时间越长的项目越需要做架构设计，参与人员越多、内部越复杂、外部依赖越多、影响面越大、维护成本越高的项目越需要做架构设计。那互联网的项目呢？它有以下特征：&lt;/p&gt;
&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;OPYx&quot;&gt;时间：开发的周期整体很长，可能维护10年、20年，但单个应用的开发周期短，多半以天和周为单位；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;OPYx&quot;&gt;规模：互联网项目整体很大，但单个应用规模小，会被拆分为多个小应用；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;OPYx&quot;&gt;业务知识：为自己做系统，行业知识不缺，长期为一个系统服务，有些自己也是客户；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;OPYx&quot;&gt;复杂度：研发人员多，内部关系复杂，外部依赖多，变化大迭代快，在不断地演化，24小时不间断运行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.2 MVP与架构设计&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;ql-long-3423802&quot; data-header=&quot;3&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/f2MzklaXjg0v9QxL/MVP.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;396.297px&quot;/&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;MVP的英文全称是Minimum Viable Product，是最小可行性产品的意思。如上图所示，用户需要一个交通工具，有两种实现方式，第一种做法是分多个阶段设计与制造，第一步是造一个轮子，第二步是造两个轮子，第三步是造一个盖子，第四步是一辆可用的轿车。第二种做法是每一阶段都要满足用户从A地到B地的需求，第一步先造个滑板，第二步是造个自行车，第三步是造辆摩托车，第四步是造辆轿车。第一个版本到第三个版本输出的产品都可以满足用户的基本需求，虽不完善但可以解决用户的问题，并且越来越好，到了第四个版本的产品才是客户预期。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;MVP对架构设计提出更高的要求。如果单纯从研发内部的角度，第一种是施工成本较低的方案，但我们需要以客户为中心，需要不断地满足客户的需求，所以在做设计时，不仅要考虑施工的成本，还有客户需求、扩展性、继承性等，如上图第三种设计方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.3 互联网公司是怎么做的&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;互联网公司的架构设计是怎么做的，当前主流做法有：&lt;/p&gt;
&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;0JrC&quot;&gt;分工：将技术研发和业务研发相分离，下层是云平台部或基础架构部，提供IaaS、PaaS中间件等云服务，上层是各业务线的产品研发部，专注于业务场景的应用研发；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;0JrC&quot;&gt;敏捷：业务研发敏捷化，产品与研发、测试实时沟通，以减少行业知识的缺乏；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;0JrC&quot;&gt;整体：技术委员会，负责技术总体规划和技术成长；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;0JrC&quot;&gt;未来：研究院，解决未来的技术问题，如阿里达摩院、百度研究院；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;0JrC&quot;&gt;应用架构：主要负责技术与业务的结合，由应用架构师、技术经理或高级程序员担当。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.4 应用架构要怎么落地&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;应用的架构设计要怎么落地，常见如下：&lt;/p&gt;
&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;W9qg&quot; data-list-number=&quot;1&quot; data-list-content=&quot;1.&quot;&gt;总体架构规划：手握地图，才能明确自己所处的位置，以便于配合。总体架构规划可以让每个研发人员了解整体，它如同房子的地基框架图纸，可长期保存和更新维护。具体参考TOGAF开放组体系结构。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;W9qg&quot; data-list-number=&quot;2&quot; data-list-content=&quot;2.&quot;&gt;单个项目架构设计：重点项目一定要做架构设计，参与架构评审，非重点项目可简化设计表述。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;W9qg&quot; data-list-number=&quot;3&quot; data-list-content=&quot;3.&quot;&gt;应用架构评审：以流程的方式来保证应用架构设计的质量，例如重构项目、跨部门项目、业务核心项目需要经过应用架构评审之后，才能申请服务器、数据库、域名等。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;W9qg&quot; data-list-number=&quot;4&quot; data-list-content=&quot;4.&quot;&gt;其它工作：如果有应用架构师专职人员，除以上工作外，还包括统一公司应用分层、制定代码规范、组织技术培训、中间件推广、应用性能调优等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、你给技术打个分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;以上，首先是一个启发性的问题，然后是初识架构设计，接着是一个真实的应用架构设计案例，并探讨了更多架构设计知识，包括设计表述、UML、设计模式、设计原则SOLID以及DDD，最后是互联网公司要怎么落地。这些知识点都是工具，这些工具到底怎么样呢？如果它是一个新知识，我们不好妄加评价，但这些工具已经出来很多年了，我们也工作了这么多年。它好不好用，实不实用，我们都应该知道些。现在，大家也当回老板，请你给技术打个分，以下二维码是链接，欢迎绩效考评 :-)&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/qieXBXHU6L8LzM3F/image.png!thumbnail&quot; alt=&quot;&quot; width=&quot;256px&quot; height=&quot;280.078px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、案例参考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;--------------------------------------------------------------------&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;strong&gt;这些工具到底怎么样？欢迎&lt;/strong&gt;在评论处说说你的真实想法。&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 07:21:00 +0000</pubDate>
<dc:creator>arch-system</dc:creator>
<og:description>你做架构设计了吗？你认为要不要做架构设计？你的公司有没有做架构设计？互联网公司的架构设计又要怎么做？我不知道你是怎么想的，在我得到的答复中，大部分人认为要做架构设计，但自己却很少做，自己经历的公司也少</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnet-arch-system/p/10756631.html</dc:identifier>
</item>
<item>
<title>【最短路径Floyd算法详解推导过程】看完这篇，你还能不懂Floyd算法？还不会？ - Halburt</title>
<link>http://www.cnblogs.com/Halburt/p/10756572.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Halburt/p/10756572.html</guid>
<description>&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; Floyd-Warshall算法（Floyd-Warshall algorithm），是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。
 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的说就是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。&lt;/p&gt;
&lt;h4 id=&quot;解决最短路径问题有几个出名的算法&quot;&gt;解决最短路径问题有几个出名的算法:&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1.dijkstra算法,最经典的单源最短路径算法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.bellman-ford算法,允许负权边的单源最短路径算法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;3.spfa,其实是bellman-ford+队列优化,其实和bfs的关系更密一点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;4.floyd算法,经典的多源最短路径算法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;今天先说说Floyd&lt;/p&gt;
&lt;h3 id=&quot;floyd算法详解&quot;&gt;Floyd算法详解&lt;/h3&gt;
&lt;h4 id=&quot;描述&quot;&gt;描述&lt;/h4&gt;
&lt;p&gt;a）如图：存在【0,1,2,3】 4个点，两点之间的距离就是边上的数字，如果两点之间，没有边相连，则无法到达，为无穷大。 &lt;br/&gt;b）要让任意两点（例如从顶点a点到顶点b）之间的路程变短，只能引入第三个点（顶点k），并通过这个顶点k中转即a-&amp;gt;k-&amp;gt;b，才可能缩短原来从顶点a点到顶点b的路程。那么这个中转的顶点k是0~n中的哪个点呢？&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-0778c48de86ff16b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法过程&quot;&gt;算法过程&lt;/h3&gt;
&lt;h4 id=&quot;准备&quot;&gt;准备&lt;/h4&gt;
&lt;p&gt;1）如图 0-&amp;gt;1距离为5，0-&amp;gt;2不可达，距离为∞，0-&amp;gt;3距离为7……依次可将图转化为邻接矩阵（主对角线，也就是自身到自身，我们规定距离为0，不可达为无穷大），如图矩阵 用于存放任意一对顶点之间的最短路径权值。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-951011b86335cb23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;2）再创建一个二维数组Path路径数组，用于存放任意一对顶点之间的最短路径。每个单元格的内容表示从i点到j点途经的顶点。（初始还未开始查找，默认-1）&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-72040c559d36cb33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-1fd46ed3526262a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;开始查找&quot;&gt;开始查找&lt;/h4&gt;
&lt;h4 id=&quot;列举所有的路径自己到自己不算&quot;&gt;1）列举所有的路径（自己到自己不算）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-8d56f28ddad196dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即为：&lt;br/&gt;0 -&amp;gt; 1 , 0 -&amp;gt; 2 , 0 -&amp;gt; 3 ,&lt;br/&gt;1 -&amp;gt; 0 , 1 -&amp;gt; 2 , 1 -&amp;gt; 3 ,&lt;br/&gt;2 -&amp;gt; 0 , 1 -&amp;gt; 1 , 1 -&amp;gt; 3&lt;br/&gt;转化成二元数组即为：&lt;br/&gt;{0，1}，{0，2}，{0，3}，{1，0}，{1，2}，{1，3}，{2，0}，{2，1}，{2，3}，{3，0}，{3，1}，{3，2}&lt;/p&gt;
&lt;h5 id=&quot;选择编号为0的点为中间点&quot;&gt;2）选择编号为0的点为中间点&lt;/h5&gt;
&lt;p&gt;{0，1}，{0，2}，{0，3}，{1，0}，{1，2}，{1，3}，{2，0}，{2，1}，{2，3}，{3，0}，{3，1}，{3，2}&lt;br/&gt;从上面中二元组集合的第一个元素开始，循环执行以下过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 用i，j两个变量分别指向二元组里的两个元素，比如{0，1}这个二元组，i指向0；j指向1
2. 判断 (A[ i ][ 0 ]+A[ 0 ][ j ] ) &amp;lt; A[ i ][ j ] （即判断 i -&amp;gt; j，i点到j点的距离是否小于从0点中转的距离），如果false，则判断下一组二元数组。
3. 如果表达式为真，更新A[ i ] [ j ]的值为A[ i ] [ 0 ] + A[ 0 ] [ j ]，Path[ i ] [ j ]的值为点0（即设置i到j要经过0点中转）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;{0，1}按照此过程执行之后，&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-7bac6f1aabe2e687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;0-&amp;gt;0 + 0-&amp;gt;1的距离不小于0-&amp;gt;1 ，&lt;strong&gt;下一组{0，2}，{0，3}， {1，0}，{2，0}，{3，0}也同理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;{1，2}按照此过程执行，A[1,0] 无穷大， A[0,2]也是无穷大，而A[1,4] = 4，&lt;strong&gt;则1点到2点肯定不会从0点中转。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A[1][0]无穷大同理&lt;strong&gt;下一组{1，2}， {1，3}也同理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;{2，1}按照此过程执行，A[2][0] = 3 ,A[0][1]=5 ，A[2][1] = 3那么 A[2][0]+ ,A[0][1] &amp;gt; A[2][1]&lt;br/&gt;…………&lt;br/&gt;依次类推，遍历二元组集合，没有0点适合做中转的&lt;/p&gt;
&lt;h4 id=&quot;选择编号为1的点为中间点&quot;&gt;3）选择编号为1的点为中间点&lt;/h4&gt;
&lt;h4 id=&quot;选择编号为2的点为中间点&quot;&gt;4）选择编号为2的点为中间点&lt;/h4&gt;
&lt;p&gt;依次类推，遍历二元组集合{0，1}，{0，2}，{0，3}，{1，0}，{1，2}，{1，3}，{2，0}，{2，1}，{2，3}，{3，0}，{3，1}，{3，2}&lt;br/&gt;，当遍历{3，0}时，A[3][2] = 1 ,A[2][0]=3 ，A[3][0] = 不可达，那么 2点适合做从3点到0点之间的中转点。&lt;br/&gt;设置距离矩阵A[3][0] = 1+3 =4 ，Path矩阵Path[3][0] = 2点，表示从3到0在2点中转，距离最近。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-dfc7c44ef8970a2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;如图表示（红色单元格），从3到0，最近距离为4，在2点中转 。&lt;/p&gt;
&lt;p&gt;依次类推，遍历完二元组集合&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-b9bd22514253c830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;选择编号为3的点为中间点最终结果&quot;&gt;5）选择编号为3的点为中间点，最终结果&lt;/h4&gt;
&lt;p&gt;依次类推，遍历二元组集合，直到所有的顶点都做过一次中间点为止。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-c946b9258b13e089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;根据最终结果就可以知道任意2点的最短距离和路径&quot;&gt;6）根据最终结果，就可以知道任意2点的最短距离和路径&lt;/h4&gt;
&lt;p&gt;比如1点到2点怎么走？根据路径Path矩阵,Path[1][2] = 3，表示从点3中转，即 1-&amp;gt; 3 -&amp;gt;2&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-0778c48de86ff16b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;如果中转点不止1个呢&quot;&gt;6）如果中转点不止1个呢？&lt;/h4&gt;
&lt;p&gt;有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即a-&amp;gt;k1-&amp;gt;k2b-&amp;gt;或者a-&amp;gt;k1-&amp;gt;k2…-&amp;gt;k-&amp;gt;i…-&amp;gt;b。&lt;br/&gt;比如顶点1到顶点0，我们看数组Path&lt;br/&gt;Path[1][0] = 3，说明顶点3是中转点，那么再从3到0&lt;br/&gt;Path[3][0] = 2，说明从3到0，顶点2是中转点，然后在从2到0&lt;br/&gt;Path[2][0] = -1，说明顶点2到顶点0没有途径顶点，也就是说，可以由顶点2直接到顶点0，即它们有边连接。&lt;/p&gt;
&lt;p&gt;最终，最短路径为1-&amp;gt;3-&amp;gt;2-&amp;gt;0，距离为 A[1][0] = 6 。&lt;br/&gt;显然，这是一个逐层递进，递归的过程。&lt;/p&gt;
&lt;h3 id=&quot;算法实现&quot;&gt;算法实现&lt;/h3&gt;
&lt;h4 id=&quot;基本定义&quot;&gt;基本定义&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    //    表示无穷大 即不可达
    public static int MAX = Integer.MAX_VALUE;
    //    距离矩阵
    public int[][] dist;
    //    路径Path矩阵
    public int[][] path;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;核心算法&quot;&gt;核心算法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//        核心算法
       for(int k = 0 ; k &amp;lt; size ; k++){
           for(int i = 0;i &amp;lt; size;i++){
               for(int j = 0 ;j &amp;lt; size;j++){
//                判断如果 ik距离可达且 kj距离可达 且 i和j的距离是否大于 i-&amp;gt; k 与 k-&amp;gt;j的距离和
                    if( dist[i][k] != MAX &amp;amp;&amp;amp;  dist[k][j] != MAX  &amp;amp;&amp;amp;  dist[i][j] &amp;gt; (dist[i][k] + dist[k][j]) ){
                        path[i][j]= k;
                        dist[i][j]= dist[i][k] + dist[k][j];
                    }
               }
           }
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;运行结果&quot;&gt;运行结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-24cab8ab1e94cdd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;源码下载&quot;&gt;源码下载&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://download.csdn.net/download/qq_16896037/11138984&quot;&gt;Floyd算法java实现-源码下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Halburt/p/10756495.html&quot;&gt;Floyd算法java实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完这篇文章如果你还不会Floyd，请留言评论。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-1e8fc47ea50bf6a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 07:13:00 +0000</pubDate>
<dc:creator>Halburt</dc:creator>
<og:description>简介 Floyd Warshall算法（Floyd Warshall algorithm），是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法名称以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Halburt/p/10756572.html</dc:identifier>
</item>
<item>
<title>什么是Servlet(原理，从访问到方法) - 不会敲代码的老王</title>
<link>http://www.cnblogs.com/rolandlee/p/10756573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rolandlee/p/10756573.html</guid>
<description>&lt;p&gt;Servlet是SUN公司提供的一门用于开发动态WEB资源的技术。SUN公司在其API中提供了一个Servlet接口，用户若想开发一个动态WEB资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编写一个Java类，实现Servlet接口；&lt;/li&gt;
&lt;li&gt;把开发好的Java类部署到WEB服务器中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们不仅要问，写好的Servlet会在WEB应用中的什么位置上呢？位置如下如所示。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417151743.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示：按照一种约定俗成的称呼习惯，通常我们也把实现了Servlet接口的Java程序，称之为Servlet。&lt;/p&gt;

&lt;p&gt;阅读Servlet API文档，文档地址是&lt;a href=&quot;https://tomcat.apache.org/tomcat-8.5-doc/servletapi/index.html&quot; class=&quot;uri&quot;&gt;https://tomcat.apache.org/tomcat-8.5-doc/servletapi/index.html&lt;/a&gt;。文档里面有对Servlet接口的详细描述，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417151950.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;借助有道翻译为：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;定义了所有Servlet必须实现的方法。&lt;br/&gt;Servlet是运行在一个Web服务器里的一个小型Java程序。Servlets通常通过HTTP(超文本传输协议)接收并响&amp;gt; 应来自Web客户端的请求。&lt;br/&gt;要实现这个接口，您可以编写一个继承了javax.servlet.GenericServlet的一般的Servlet，或者继承了javax.servlet.http.HttpServlet的HTTP Servlet。&lt;br/&gt;这个接口定义了方法来初始化一个Servlet，服务请求，并从服务器删除Servlet。这些被称为生命周期方法&amp;gt; 并且按以下顺序依次调用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet被构造，然后用init方法初始化；&lt;/li&gt;
&lt;li&gt;任何来自客户机的请求在service方法中处理；&lt;/li&gt;
&lt;li&gt;Servlet从服务中移除，调用destroy方法销毁，然后垃圾收集和完成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了生命周期方法，该接口提供了getServletConfig方法(Servlet可以使用它来得到任何启动信息)和getServletInfo方法(它允许Servlet返回自身的基本信息，比如作者、版本和版权)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里面有一个专业术语——&lt;strong&gt;life-cycle methods&lt;/strong&gt;，解释过来就是与生命周期相关的方法，即生命周期中的某个特定时刻必定会执行的方法。那么什么是对象的生命周期？什么又是与生命周期相关的方法呢？&lt;strong&gt;对象从创建到销毁经历的过程，称之为对象的生命周期。在对象生命周期过程中，在特定时刻肯定会执行一些特定的方法，这些方法称之为与生命周期相关的方法&lt;/strong&gt;。例如，人从出生到死亡经历的过程，为人的一个生命周期，在人生命周期过程中，必定有一些与生命周期息息相关的方法，例如吃饭、上学、结婚等，这些方法在人生命周期过程中某个特定时刻必定会执行，所以这些方法是人生命周期相关的方法。但不是说对象中的所有方法都与生命周期相关，例如人自杀，这个方法不是在生命周期中必定会执行的。&lt;br/&gt;阅读完Servlet API，我们需要解决两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输出Hello Servlet的Java代码应该写在Servlet的哪个方法内？&lt;/li&gt;
&lt;li&gt;如何向浏览器输出数据？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;答案很明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输出Hello Servlet的Java代码应该写在Servlet的service方法中；&lt;/li&gt;
&lt;li&gt;通过ServletResponse接口的实例中的getOutputStream方法获得输出流，向http响应对象中写入数据，服务器将http响应对象回送给浏览器，浏览器解析数据并显示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们正式编写一个入门级的Servlet。首先在Tomcat服务器webapps目录下新建一个Web应用，比如myWeb(Web应用所在目录)，在myWeb目录中新建一个WEB-INF目录，接着在WEB-INF目录下新建一个classes目录，在classes目录中新建一个Java应用程序——FirstServlet.java，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.liayun;

import java.io.*;
import javax.servlet.*;

public class FirstServlet extends GenericServlet {
    
    public void service(ServletRequest req, ServletResponse res) throws ServletException, java.io.IOException {
        OutputStream out = res.getOutputStream();
        out.write(&quot;Hello Servlet!!!&quot;.getBytes());
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;着编译Java应用程序，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417152808.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们需要将Servlet所用Jar包加载到classpath路径下，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417152833.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再在WEB-INF目录中新建一个web.xml文件，配置Servlet的访问对外路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
  version=&quot;3.1&quot;&amp;gt;
  
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;FirstServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;cn.liayun.FirstServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;/servlet&amp;gt;
    
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;FirstServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/FirstServlet&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后启动Tomcat，通过Chrome浏览器进行访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417152912.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Servlet程序是由Web服务器调用的，Web服务器收到客户端的Servlet访问请求后：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步；&lt;/li&gt;
&lt;li&gt;②装载并创建该Servlet的一个实例对象；&lt;/li&gt;
&lt;li&gt;③调用Servlet实例对象的init()方法；&lt;/li&gt;
&lt;li&gt;④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去；&lt;/li&gt;
&lt;li&gt;⑤Web应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用动图来描述以上调用过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190324155210143.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是用UML时序图来描述以上调用过程，则如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417153309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：上图并没画出destory()方法。destory()方法会在Web容器移除Servlet时执行，客户机第一次访问服务器时，服务器会创建Servlet实例对象，它就永远驻留在内存里面了，等待客户机第二次访问，这时有一个用户访问完Servlet之后，此Servlet对象并不会被摧毁，destory()方法也就不会被执行。&lt;/p&gt;

&lt;p&gt;Servlet对象是用户第一次访问时创建，对象创建之后就驻留在内存里面了，响应后续的请求。Servlet对象一旦被创建，init()方法就会被执行，客户端的每次请求导致service()方法被执行，Servlet对象被摧毁时(Web服务器停止后或者Web应用从服务器里删除时)，destory()方法就会被执行。&lt;/p&gt;
&lt;h2 id=&quot;在eclipse中开发servlet&quot;&gt;在Eclipse中开发Servlet&lt;/h2&gt;
&lt;p&gt;在Eclipse中新建一个Dynamic Web Project工程，Eclipse会自动创建下图所示目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417153410.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;servlet接口实现类&quot;&gt;Servlet接口实现类&lt;/h3&gt;
&lt;p&gt;对于Servlet接口，SUN公司定义了两个默认实现类，分别为GenericServlet和HttpServlet。HttpServlet指能够处理HTTP请求的Servlet，它在原有Servlet接口上添加了一些与HTTP协议相关的处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法(温馨提示：可阅读HttpServlet API文档)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417153443.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;借助有道翻译为：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;提供了一个抽象类派生子类来创建一个适合于一个网站的HTTP Servlet。HttpServlet的子类必须覆盖至少一个方法，通常是其中一个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;doGet，如果Servlet支持HTTP GET请求&lt;/li&gt;
&lt;li&gt;doPost，HTTP POST请求&lt;/li&gt;
&lt;li&gt;doPut，HTTP PUT请求&lt;/li&gt;
&lt;li&gt;doDelete，HTTP DELETE请求&lt;/li&gt;
&lt;li&gt;初始化和销毁，管理Sevlet生命中被掌握的资源&lt;/li&gt;
&lt;li&gt;getServletInfo，Servlet用来提供关于其自身信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;几乎没有理由覆盖service()方法。service()方法会处理标准HTTP请求，通过派遣他们每个HTTP请求类型的处理程序方法(上述doMethod方法)。&lt;br/&gt;同样，几乎没有理由覆盖doOptions和doTrace方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;通过eclipse创建和编写servlet&quot;&gt;通过Eclipse创建和编写Servlet&lt;/h2&gt;
&lt;p&gt;选中cn.liayun包，右键→New→Servlet，在Eclipse中创建和编写Servlet可参考下面一系列步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417153623.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417153627.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417153629.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417153635.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们就通过Eclipse帮我们创建好一个名字为ServletSample的Servlet，创建好的ServletSample里面会有如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.liayun;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ServletSample
 */
@WebServlet(&quot;/ServletSample&quot;)
public class ServletSample extends HttpServlet {
    private static final long serialVersionUID = 1L;

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // TODO Auto-generated method stub
        response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());
    }

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // TODO Auto-generated method stub
        doGet(request, response);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些代码都是Eclipse自动生成的，而web.xml文件中也多了&lt;code&gt;&amp;lt;servlet&amp;gt;&amp;lt;/servlet&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;两对标签，这两对标签是配置ServletSample的，应如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletSample&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;cn.liayun.ServletSample&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletSample&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/ServletSample&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：照理说，web.xml文件中会多&lt;code&gt;&amp;lt;servlet&amp;gt;&amp;lt;/servlet&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;这两对标签，但是我的就没有，而且使用的是注解@WebServlet(&quot;/ServletSample&quot;)，好像因为我使用的是Servlet3.1规范的缘故。&lt;br/&gt;最后我们就可以通过浏览器访问ServletSample这个Servlet了，访问的URL地址是http://localhost:8080/day05/ServletSample。&lt;/p&gt;

&lt;p&gt;如果你的Eclipse中有一个动态web项目TomcatTest，当你使用Eclipse导入一个外部项目，恰好这个项目名就是TomcatTest，这时你为了避免重名，需要修改导入的项目名，比如修改为t_ TomcatTest，然后你将其部署到Tomcat服务器中的webapps目录中，该项目映射的虚拟目录名称仍然是TomcatTest，所以你需要修改其虚拟目录。步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417154011.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417154014.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于客户端是通过URL地址访问Web服务器中的资源，所以Servlet程序若想被外界访问，必须把Servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用&lt;code&gt;&amp;lt;servlet&amp;gt;&lt;/code&gt;元素和&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;元素完成。&lt;code&gt;&amp;lt;servlet&amp;gt;&lt;/code&gt;元素用于注册Servlet，它包含有两个主要的子元素：&lt;code&gt;&amp;lt;servlet-name&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;servlet-class&amp;gt;&lt;/code&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。一个&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&lt;code&gt;&amp;lt;servlet-name&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;url-pattern&amp;gt;&lt;/code&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo1&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;cn.itcast.ServletDemo1&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo1&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/ServletDemo1&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同一个Servlet可以被映射到多个URL上，即多个&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;元素的&lt;code&gt;&amp;lt;servlet-name&amp;gt;&lt;/code&gt;子元素的设置值可以是同一个Servlet的注册名。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo1&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;cn.itcast.ServletDemo1&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo1&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/ServletDemo1&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo1&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/aa&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo1&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/1.html&amp;lt;/url-pattern&amp;gt; &amp;lt;!-- 伪静态，明显是一个动态Web资源，但将其映射成静态Web资源的名称 --&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;温馨提示：一个Web应用的web.xml文件内容一经修改，不需要重新发布，服务器会自动监测web.xml的改动，只要web.xml文件的内容修改，服务器就会自动加载。原因是在Tomcat服务器的conf/context.xml文件中，有如下关键代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417154219.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据Tomcat服务器文档可知，在conf/context.xml文件中，Context元素信息被所有的Web应用加载。即Context元素的配置信息会被所有Web应用程序所共享。所以所有的Web应用会监测web.xml的改动，只要web.xml文件的内容一旦修改，服务器就会自动重新加载。&lt;br/&gt;通过上面的配置，当我们想访问名称是ServletDemo1的Servlet时，可以使用如下的几个地址去访问：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;http://localhost:8080/day05/ServletDemo1；&lt;/li&gt;
&lt;li&gt;http://localhost:8080/day05/aa；&lt;/li&gt;
&lt;li&gt;http://localhost:8080/day05/1.html。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ServletDemo1被映射到了多个URL上。&lt;/p&gt;

&lt;p&gt;在Servlet映射到的URL中也可以使用&lt;code&gt;*&lt;/code&gt;通配符，但是只能有两种固定的格式：一种格式是“&lt;code&gt;*&lt;/code&gt;.扩展名”，另一种格式是以正斜杠（/）开头并以“&lt;code&gt;*&lt;/code&gt;”结尾。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;AnyName&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;

&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;AnyName&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/action/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于如下的一些映射关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet1映射到&lt;code&gt;/abc/*&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Servlet2映射到&lt;code&gt;/*&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Servlet3映射到&lt;code&gt;/abc&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Servlet4映射到&lt;code&gt;*.do&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有如下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当请求URL为“&lt;code&gt;/abc/a.html&lt;/code&gt;”，“&lt;code&gt;/abc/*&lt;/code&gt;”和“&lt;code&gt;/*&lt;/code&gt;”都匹配，哪个Servlet响应？——Servlet引擎将调用Servlet1；&lt;/li&gt;
&lt;li&gt;当请求URL为“&lt;code&gt;/abc&lt;/code&gt;”时，“&lt;code&gt;/abc/*&lt;/code&gt;”、“&lt;code&gt;/*&lt;/code&gt;”和“&lt;code&gt;/abc&lt;/code&gt;”都匹配，哪个Servlet响应？——Servlet引擎将调用Servlet3；&lt;/li&gt;
&lt;li&gt;当请求URL为“&lt;code&gt;/abc/a.do&lt;/code&gt;”时，“&lt;code&gt;/abc/*&lt;/code&gt;”、“&lt;code&gt;/*&lt;/code&gt;”和“&lt;code&gt;*.do&lt;/code&gt;”都匹配，哪个Servlet响应？——Servlet引擎将调用Servlet1；&lt;/li&gt;
&lt;li&gt;当请求URL为“&lt;code&gt;/a.do&lt;/code&gt;”时，“&lt;code&gt;/*&lt;/code&gt;”和“&lt;code&gt;*.do&lt;/code&gt;”都匹配，哪个Servlet响应？——Servlet引擎将调用Servlet2；&lt;/li&gt;
&lt;li&gt;当请求URL为“&lt;code&gt;/xxx/yyy/a.do&lt;/code&gt;”时，“&lt;code&gt;/*&lt;/code&gt;”和“&lt;code&gt;*.do&lt;/code&gt;”都匹配，哪个Servlet响应？——Servlet引擎将调用Servlet2。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;**结论：匹配的原则就是&quot;谁长得更像就找谁&quot;，“&lt;code&gt;*.do&lt;/code&gt;”——这种*在前面的时候优先级最低。**&lt;/p&gt;

&lt;p&gt;Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至Web容器退出，Servlet实例对象才会销毁。验证如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新建一个Servlet——ServletDemo3，并覆盖init()和destroy()方法；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package cn.liayun;

import java.io.IOException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ServletDemo3 extends HttpServlet {
    private static final long serialVersionUID = 1L;

    @Override
    public void init(ServletConfig config) throws ServletException {
        super.init(config);
        System.out.println(&quot;init&quot;);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.getOutputStream().write(&quot;haha&quot;.getBytes());
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }
    
    @Override
    public void destroy() {
        System.out.println(&quot;destroy&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将项目部署到服务器中，启动服务器，发现没有输出init，说明启动服务器时，Servlet实例对象并没有被创建。此时，通过浏览器进行访问，会发现控制台输出init，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417154730.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时再打开一个浏览器进行访问，仍然只会输出一个init，说明针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当Web服务器停止后或者Web应用从服务器里删除时，destroy()方法就会被执行；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417154734.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Web服务器停止前，Servlet实例对象就会被摧毁。&lt;/p&gt;
&lt;p readability=&quot;45&quot;&gt;在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次Servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。&lt;br/&gt;如果在&lt;servlet readability=&quot;90&quot;&gt;元素中配置了一个元素，那Web应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。例如：
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo3&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;cn.itcast.ServletDemo3&amp;lt;/servlet-class&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时在启动服务器的过程中，会在控制台看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417154739.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;温馨提示：&lt;code&gt;&amp;lt;load-on-startup&amp;gt;&lt;/code&gt;元素配置的数必须为正整数，数字越小，Servlet越优先创建。它的用途：可为Web应用写一个InitServlet，这个Servlet配置为启动时装载，为整个Web应用创建必要的数据库表和数据。&lt;/p&gt;

&lt;p&gt;如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。凡是在web.xml文件中找不到匹配的&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理所有其他Servlet都不处理的访问请求。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo3&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;cn.itcast.ServletDemo3&amp;lt;/servlet-class&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;!-- 将ServletDemo3配置成缺省Servlet --&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;ServletDemo3&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当访问不存在的Servlet时，就使用配置的默认Servlet进行处理，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417154743.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;&amp;lt;Tomcat的安装目录&amp;gt;\conf\web.xml&lt;/code&gt;文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;default&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.apache.catalina.servlets.DefaultServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;debug&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;0&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;listings&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;

&amp;lt;!-- The mapping for the default servlet --&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;default&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet(服务器中的html文件数据的读取由缺省Servlet完成)。&lt;/p&gt;

&lt;p&gt;当多个客户端并发访问同一个Servlet时，Web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。下面我会举例来说明。&lt;/p&gt;

&lt;p&gt;下面是不存在线程安全问题的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.liayun;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(&quot;/ServletSample&quot;)
public class ServletSample extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        int i = 0;
        i++;
        response.getOutputStream().write((i + &quot;&quot;).getBytes());
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当多线程并发访问这个方法里面的代码时，会存在线程安全问题吗？显然不会，i变量被多个线程并发访问，但是没有线程安全问题，因为i是doGet方法里面的局部变量，当有多个线程并发访问doGet方法时，每一个线程里面都有自己的i变量，各个线程操作的都是自己的i变量，所以不存在线程安全问题。多线程并发访问某一个方法的时候，如果在方法内部定义了一些资源(变量，集合等)，那么每一个线程都有这些东西，所以就不存在线程安全问题。&lt;/p&gt;

&lt;p&gt;下面是存在线程安全问题的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.liayun;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(&quot;/ServletSample&quot;)
public class ServletSample extends HttpServlet {
    
    private int i = 0;

    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        i++;

        try {
            Thread.sleep(1000 * 10);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        
        response.getOutputStream().write((i + &quot;&quot;).getBytes());
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把i定义成全局变量，当多个线程并发访问变量i时，就会存在线程安全问题了。线程安全问题只存在多个线程并发操作同一个资源的情况下，所以在编写Servlet的时候，如果并发访问某一个资源(变量，集合等)，就会存在线程安全问题，那么该如何解决这个问题呢？可使用同步代码块。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.liayun;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(&quot;/ServletSample&quot;)
public class ServletSample extends HttpServlet {
    
    private int i = 0;//共享资源

    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        i++;

        synchronized (this) {
            try {
                Thread.sleep(1000 * 10);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        
        response.getOutputStream().write((i + &quot;&quot;).getBytes());
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加了synchronized后，并发访问i时就不存在线程安全问题了，为什么加了synchronized后就没有线程安全问题了呢？原因：假如现在有一个线程访问Servlet对象，那么它就先拿到了Servlet对象的那把锁，等到它执行完之后才会把锁还给Servlet对象，由于是它先拿到了Servlet对象的那把锁，所以当有别的线程来访问这个Servlet对象时，由于锁已经被之前的线程拿走了，后面的线程只能排队等候了。&lt;br/&gt;以上这种做法是给Servlet对象加了一把锁，保证任何时候都只有一个线程在访问该Servlet对象里面的资源，这样就不存在线程安全问题了。这种做法虽然解决了线程安全问题，但是编写Servlet却万万不能用这种方式处理线程安全问题，假如有9999个人同时访问这个Servlet，那么这9999个人必须按先后顺序排队轮流访问。&lt;br/&gt;针对Servlet的线程安全问题，SUN公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是&quot;Serializable&quot;，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了&quot;Serializable&quot;接口的类的对象就可以被序列化，还有一个&quot;Cloneable&quot;接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了&quot;Cloneable&quot;接口，那么对象就可以被克隆了。SingleThreadModel接口中没有定义任何方法，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。&lt;br/&gt;对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190417154750.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上代码还要注意异常的处理，代码&lt;code&gt;Thread.sleep(1000*4)&lt;/code&gt;;只能try不能抛，因为子类在覆盖父类的方法时，不能抛出比父类更多的异常；并且catch之后，后台记录异常的同时并给用户一个友好提示，因为用户访问的是一个网页。&lt;/p&gt;
&lt;/servlet&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 07:13:00 +0000</pubDate>
<dc:creator>不会敲代码的老王</dc:creator>
<og:description>Servlet简介 Servlet是SUN公司提供的一门用于开发动态WEB资源的技术。SUN公司在其API中提供了一个Servlet接口，用户若想开发一个动态WEB资源(即开发一个Java程序向浏览器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rolandlee/p/10756573.html</dc:identifier>
</item>
<item>
<title>asp.net core系列 59 Ocelot 构建基础项目示例 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10755112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10755112.html</guid>
<description>&lt;h3&gt;一.入门概述&lt;/h3&gt;
&lt;p&gt;　　从这篇开始探讨Ocelot，Ocelot是一个.NET API网关，仅适用于.NET Core，用于.NET面向微服务/服务的架构中。当客户端(web站点、ios、 app 等)访问web api时，需要先统一入口点进入Ocelot网关(Ocelot可以做很多事情例如路由，身份验证，服务发现，日志记录等，下面列出了功能基本)，再由Ocelot分发到web api。Ocelot官方希望IS4一起使用，实现令牌轻松集成。&lt;/p&gt;
&lt;p&gt;　　Ocelot是一组按特定顺序排列的中间件,查看源码会发现Ocelot是一堆的middleware组成的一个管道。&lt;/p&gt;
&lt;p&gt;　　Ocelot操控HttpRequest对象到其配置指定的状态，在中间件中Ocelot创建一个HttpRequestMessage对象，该对象用于向下游服务(wep api)发出请求。发出请求的中间件是Ocelot管道中的最后一件事。它不会调用下一个中间件。&lt;/p&gt;
&lt;p&gt;　　当下游服务&lt;span lang=&quot;EN-US&quot;&gt;response返回&lt;span lang=&quot;EN-US&quot;&gt;Ocelot管道时，将检索下游服务的响应。有一个中间件将&lt;span lang=&quot;EN-US&quot;&gt;HttpResponseMessage映射到&lt;span lang=&quot;EN-US&quot;&gt;HttpResponse对象并返回给客户端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　通过官方部署架构图介绍，可以了解到：Ocelot有5种部署方式包括：&lt;/p&gt;
&lt;p&gt;       　　(1) Ocelot基本实现&lt;/p&gt;
&lt;p&gt;     　　  (2) Ocelot结合IS4、&lt;/p&gt;
&lt;p&gt;    　　   (3) Ocelot多个实现(高可用，负载)&lt;/p&gt;
&lt;p&gt;     　　  (4) Ocelot结合Consul(健康检查，服务注册)、&lt;/p&gt;
&lt;p&gt;    　　   (5) Ocelot结合Service Fabric。&lt;/p&gt;
&lt;p&gt;　　查看&lt;a href=&quot;https://ocelot.readthedocs.io/en/latest/introduction/bigpicture.html&quot; target=&quot;_blank&quot;&gt;部署架构图&lt;/a&gt;，在架构图中，Ocelot网关暴露在广域网的一个访问入口，供客户端调用。而web api是在局域网中,由Ocelot来转发。&lt;/p&gt;

&lt;p&gt;　　Ocelot的功能基本包括：&lt;/p&gt;
&lt;p&gt;                   路由&lt;/p&gt;
&lt;p&gt;                   请求聚合&lt;/p&gt;
&lt;p&gt;                   Consul和Eureka的服务发现&lt;/p&gt;
&lt;p&gt;                   Service Fabric&lt;/p&gt;
&lt;p&gt;                   WebSockets&lt;/p&gt;
&lt;p&gt;                   Authentication认证&lt;/p&gt;
&lt;p&gt;                   Authorisation授权&lt;/p&gt;
&lt;p&gt;                   限速&lt;/p&gt;
&lt;p&gt;                   高速缓存&lt;/p&gt;
&lt;p&gt;                   重试策略/ QoS&lt;/p&gt;
&lt;p&gt;                   负载均衡&lt;/p&gt;
&lt;p&gt;                   日志/跟踪/关联&lt;/p&gt;
&lt;p&gt;                   标头/查询字符串/声明转换&lt;/p&gt;
&lt;p&gt;                   自定义中间件/委托处理程序&lt;/p&gt;
&lt;p&gt;                   配置/管理REST API&lt;/p&gt;
&lt;p&gt;                   Platform / Cloud Agnostic&lt;/p&gt;

&lt;p&gt;         安装Nuget包&lt;/p&gt;
&lt;p&gt;                  Install-Package Ocelot&lt;/p&gt;

&lt;h3&gt;二.Ocelot 基础项目演示&lt;/h3&gt;
&lt;p&gt;　　下面通过贡献者的开源项目来学习Ocelot，掌握一个基础项目应用,学习起来也更直观。示例有三个项目：一个是网关APIGateway项目，有二个是web api服务。 项目实现的功能是：客户端统一通过网关作为入口点访问，实现路由的功能。&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://github.com/catcherwong-archive/APIGatewayDemo/tree/master/APIGatewayBasicDemo&quot; target=&quot;_blank&quot;&gt;github开源地址&lt;/a&gt;   架构&lt;/span&gt;如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190423110106196-1867094680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2.1 CustomersAPIServices项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;该项目是一个&lt;span lang=&quot;EN-US&quot;&gt;web api项目，用来处理客户事务的&lt;span lang=&quot;EN-US&quot;&gt;API服务。该地址为&lt;span lang=&quot;EN-US&quot;&gt;http://localhost:9001, &lt;span lang=&quot;EN-US&quot;&gt;可以在“项目选项”中指定&lt;span lang=&quot;EN-US&quot;&gt;url，也可以在&lt;span lang=&quot;EN-US&quot;&gt;Host启动时配置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　(1) Program类添加UseUrls&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                   .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;().UseUrls(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://*:9001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;(2) &lt;span lang=&quot;EN-US&quot;&gt;在&lt;span lang=&quot;EN-US&quot;&gt;CustimersAPIServices项目中创建一个&lt;span lang=&quot;EN-US&quot;&gt;CustomersController&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
   [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomersController : Controller
    {        
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Catcher Wong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;James Li&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }

        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Catcher Wong - {id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }            
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;2.2 ProductsAPIServices项目 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　该项目是一个&lt;span lang=&quot;EN-US&quot;&gt;web api项目，处理产品某事的&lt;span lang=&quot;EN-US&quot;&gt;API服务。该地址为&lt;span lang=&quot;EN-US&quot;&gt;http://localhost:9002， 可以在“项目选项”中指定&lt;span lang=&quot;EN-US&quot;&gt;url，也可以在&lt;span lang=&quot;EN-US&quot;&gt;Host启动时配置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　(1) Program类添加UseUrls&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                   .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;().UseUrls(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://*:9002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;(2) 在&lt;span lang=&quot;EN-US&quot;&gt;ProductsAPIServices项目中创建&lt;span lang=&quot;EN-US&quot;&gt;ProductsController&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductsController : Controller
    {
        
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Surface Book 2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mac Book Pro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;strong&gt;　2.3 APIGateway项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;该项目是Ocelot网关项目，先安装Ocelot包。在项目中添加一个Ocelot的json配置文件，这里创建的是configuration.json文件。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;(1) configuration.json(配置&lt;span lang=&quot;EN-US&quot;&gt;Ocelot)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReRoutes:处理上游请求的对象(客户端)，每个数组{} 就是配置:上游地址和对应下游地址&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReRoutes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以Downstream开头的，是要转发到下游服务器的地址(CustomersAPIServices)，与nginx转发类似
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面所有Downstream开头的，组成一个转发url,转发地址是http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9001/api/customers&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/customers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;DownstreamHost&quot;: &quot;localhost&quot;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;DownstreamPort&quot;: 9001,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转发到下游服务器的主机和端口。&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9001&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Upstream开头是指上游服务器（客户端）访问地址，通过http get方式访问。
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也就是说客户端访问http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9000/customers 实际是转发到了http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9001/api/customers的服务&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/customers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHttpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
    },
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/customers/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;DownstreamHost&quot;: &quot;localhost&quot;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;DownstreamPort&quot;: 9001,&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9001&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/customers/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHttpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
    },
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;DownstreamPort&quot;: 9002,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;DownstreamHost&quot;: &quot;localhost&quot;,&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9002&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHttpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
    }
  ],
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局配置,允许覆盖ReRoutes特定设置&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GlobalConfiguration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RequestIdKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OcRequestId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AdministrationPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/administration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(2) Startup类，使用Ocelot&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.UseStartup&amp;lt;Startup&amp;gt;()
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置网关url&lt;/span&gt;
                   .UseUrls(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://*:9000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                   .ConfigureAppConfiguration((hostingContext, config) &lt;/span&gt;=&amp;gt;&lt;span&gt;
               {
                   config
                       .SetBasePath(hostingContext.HostingEnvironment.ContentRootPath)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加Ocelot配置文件&lt;/span&gt;
                       .AddJsonFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configuration.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                       .AddEnvironmentVariables();
               })
               .ConfigureServices(s &lt;/span&gt;=&amp;gt;&lt;span&gt;
               {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加服务&lt;/span&gt;
&lt;span&gt;                   s.AddOcelot();
                   s.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
               })
                .Configure(a &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {        
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加中间件            &lt;/span&gt;
&lt;span&gt;                    a.UseOcelot().Wait();
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　最后开始测试：&lt;/p&gt;
&lt;p&gt;　　　　(1) 启动CustomersAPIServices web api服务程序 http://localhost:9001&lt;/p&gt;
&lt;p&gt;　　　　(2) 启动ProductsAPIServices web api服务程序  http://localhost:9002&lt;/p&gt;
&lt;p&gt;　　　　(3) 启动 APIGateway 网关服务程序  http://localhost:9000&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190423114229500-756999367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;三. 关于&lt;a href=&quot;https://ocelot.readthedocs.io/en/latest/features/routing.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;ReRoutes&lt;/strong&gt;&lt;/a&gt;路由介绍&lt;/h3&gt;
&lt;p&gt;　　在上面示例中，使用了基本的路由配置，在ocelot路由配置中,还有许多特性，比如：　　　&lt;/p&gt;
&lt;p&gt;　　(1) 给DownstreamPathTemplate和UpstreamPathTemplate设置占位符,来捕捉所有类型的ReRoute，是使用直接代理。&lt;/p&gt;
&lt;p&gt;　　(2) 设置上游(客户端)的主机头来匹配 &quot;UpstreamHost&quot;: &quot;somedomain.com&quot;。&lt;/p&gt;
&lt;p&gt;　　(3) 设置路由的优先级，Priority的数字越高代表级别越高。&lt;/p&gt;
&lt;p&gt;　　(4) 设置动态路由，不必提供ReRoute配置。&lt;/p&gt;
&lt;p&gt;　　(5) 设置查询字符串,根据url的参数unitId={unitId}来匹配转发。&lt;/p&gt;


&lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.c-sharpcorner.com/article/building-api-gateway-using-ocelot-in-asp-net-core/&quot; target=&quot;_blank&quot;&gt;构建基础Ocelot项目介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;a href=&quot;https://ocelot.readthedocs.io/en/latest/introduction/bigpicture.html&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;



</description>
<pubDate>Tue, 23 Apr 2019 06:55:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.入门概述 从这篇开始探讨Ocelot，Ocelot是一个.NET API网关，仅适用于.NET Core，用于.NET面向微服务/服务的架构中。当客户端(web站点、ios、 app 等)访问we</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10755112.html</dc:identifier>
</item>
<item>
<title>一起来学spring Cloud | 第一章：spring Cloud 与Spring Boot - young码农</title>
<link>http://www.cnblogs.com/haly/p/10737574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haly/p/10737574.html</guid>
<description>&lt;p class=&quot;p&quot;&gt;&lt;span&gt;目前大家都在说微服务，其实微服务不是一个名字，是一个架构的概念，大家现在使用的基于&lt;/span&gt;RPC框架（dubbo、thrift等）架构其实也能算作一种微服务架构。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;目前越来越多的公司开始使用微服务架构，所以在目前招聘&lt;/span&gt;java岗位时，有springcloud经验还是会占一点优势，今天young就和大家一起来学习Spring Cloud微服务框架。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;本章，我们先解决新人都头疼的一个问题，&lt;/span&gt;spring Cloud 与spring Boot到底是什么关系？？？？&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一&lt;/span&gt; &lt;span&gt;、什么是&lt;/span&gt;spring Boot&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;在讲解什么是&lt;/span&gt;spring Boot之前，我们先可以思考一下，目前使用spring时，有没有感觉以下的两个问题经常被频繁的吐槽&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;1. 在过去的 Spring 发中，需要引入大量的 xml 文件。Spring 2.5 引入了包扫描，消除了显式的配置 Bean。 Spring 3.0 又引入了基于 JavaBean 的配置，这种方式可以取代 xml 文件。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;   尽管如此，在实际的开发中还是需要配置 xml 文件，例如配 SpringMVC 事务管理器、过滤器、切面等等。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2. 在项目的开发过程中，会引入大量的第三方依赖，选择依赖是一件不容易的事，解决依赖与依赖之间的冲突也很耗费精力。所以，在以前的Spring开发中，依赖管理也是一件棘手的事情。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;结合上面&lt;/span&gt;Spring的两点瑕疵，我们在来总结一下，什么是SpringBoot：&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;1. Spring Boot并不是一个全新的框架，它不是spring解决方案的一个替代品，而是spring的一个封装。所以，你以前可以用spring做的事情，现在用spring Boot都可以做。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2. Spring Boot是一种全新的编程规范，是一个服务于框架的框架，服务范围是简化配置文件和起步依赖，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二&lt;/span&gt; &lt;span&gt;、什么是&lt;/span&gt;spring Cloud&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;1. Spring Cloud是一个微服务框架，相比Dubbo等RPC框架, Spring Cloud提供的全套的分布式系统解决方案，它依赖于 Spring Boot ，有快速开发、持续交付和容易部署等特点。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2. Spring Cloud不像其他Spring子项目那样相对独立，它是一个拥有诸多子项目的大型综合项目。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三&lt;/span&gt; &lt;span&gt;、&lt;/span&gt;Spring Cloud与Spring Boot的对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;1. Spring Boot 是 Spring的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务；Spring Cloud是一个基于Spring Boot实现的云应用开发工具；&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2. Spring Boot专注于快速、方便集成的单个个体；Spring Cloud是关注全局的服务治理框架；&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;3. Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置；Spring Cloud很大的一部分是基于Spring Boot来实现。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;4. Spring Boot可以离开Spring Cloud独立使用开发项目，但是SpringCloud离不开Spring Boot，属于依赖的关系。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;四、&lt;/span&gt;Spring Cloud的常用组件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;Spring Cloud 提供了开发分布式微服务系统的一些常用组件，例如服务注册和发现、配置中心、熔断器、 智能路由 、微代理、控制总线、全局锁、分布式会话等。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;spring Cloud的子项目很多，但是目前在实际工作中，我们一般业务项目使用到的组件就是常规的几个，其它的一般开发用不到，做为新手，我们先熟悉常用且重要的几个。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;接下来的这8个常用组件的描述来自（方志朋的《深入理解Spring Cloud 与微服务构建一书》）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;（1）服务注册和发现组件&lt;/span&gt; Eureka&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;          &lt;span&gt;利用&lt;/span&gt; Eureka 组件可以很轻松地实现服务的注册和发现功能。 Eureka 组件提供了服务的健&lt;span&gt;康监测，以及界面友好的&lt;/span&gt; UI 。通过 Eureka 组件提供的 UI, Eureka 组件可以让开发人员随时了&lt;span&gt;解服务单元的运行情况。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;           另外&lt;/span&gt; Spring Cloud 也支持 Consul 和Zookeepe ，用于注册和发现服务。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;（2）&lt;span&gt;熔断组件&lt;/span&gt; Hystrix &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;          Hystrix是一个 熔断组件，它除了有一些基本的熔断器功能外，还能够实现服务降级、服&lt;span&gt;务限流的功能。另外&lt;/span&gt; Hystrix 提供了熔断器的健康监测，以及熔断器健康数据的 API 口。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;          Hystrix Dashboard 组件提供了单个服务熔断器的健康状态数据的界面展示功能，Hystrix Turbine 组件提供了多个服务的熔断器的健康状态数据的界面展示功能。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;（3）&lt;span&gt;负载均衡组件&lt;/span&gt; Ribbon&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　  Ribbon 是一个负载均衡组件，它通常和 Eureka 、Zuul、 RestTemplate、Feign 配合使用。Ribbon 和Zuul 配合，很容易做到负载均衡，将请求根据负载均衡策略分配到不同的服务实例中。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;        Ribbon和RestTemplate、Feign配合，在消费服务时能够做到负载均衡。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;（4）&lt;span&gt;路由网关&lt;/span&gt; Zuul&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　  &lt;span&gt;路由网关&lt;/span&gt; Zuul 有智能路由和过滤的功能。内部服务的 API 接口通过 Zuul 网关统一对外暴露，&lt;span&gt;内部服务的&lt;/span&gt; API 接口不直接暴露，防止了内部服务敏感信息对外暴露。在默认的情况下，Zuul和Ribbon相结合，能够做到负载均衡、智能路由。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;         Zuul过滤功能是通过拦截请求来实现的，可以对一&lt;span&gt;些用户的角色和权限进行判断，起到安全验证的作用，&lt;/span&gt;&lt;span&gt;同时也可以用于输出实时的请求曰志。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;         上述的4个&lt;/span&gt;&lt;span&gt;组件都来自于&lt;/span&gt; Netflix 的公司，称为 Spring Cloud Netflix。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;（5）Spring Cloud Config &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;  　　Spring Cloud Config 组件提供了配置文件统一管理的功能。Spring Cloud Config包括Server&lt;span&gt;端和&lt;/span&gt;Client端，Server 端读取本地仓库或者远程仓库的配置文件，所有的Client 向Server读取&lt;span&gt;配置信息，从而达到配置文件统一&lt;/span&gt;&lt;span&gt;管理的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;          通常情况下，&lt;/span&gt; Spring Cloud Config 和 Spring Cloud Bus 相互配合刷新指定 Client 或所有Client的配置文件。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;  (6)  Spring Cloud Security&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　 Spring Cloud Security 是对 Spring Security 组件的封装，Spring Cloud Security 向服务单元&lt;span&gt;提供了用户验证和权限认证。一般来说，单独在微服务系统中使用&lt;/span&gt; Spring Cloud Security 是很&lt;span&gt;少见的，一&lt;/span&gt;&lt;span&gt;般它会配合&lt;/span&gt; Spring Security 0Auth2 组件一起使用， 通过搭建授权服务，验证 Token&lt;span&gt;或者&lt;/span&gt; JWT 这种形式对整个微服务系统进行安全验证。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;（7）Spring Cloud Sleuth &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　 Spring Cloud Sleuth 是一个分布式链路追踪组件，它封装了 Dapper Zipkin 和 Kibana 等组&lt;span&gt;件，通过它可以知道服务之间的相互依赖关系，并实时观察链路的调用情况。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;（8）&lt;/span&gt;Spring Cloud Stream &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;        Spring Cloud Stream Spring Cloud 框架的数据流操作包，可以封装 RabbitMq 、ActiveMq 、Kafka 、Redis 等消息组件，利用 Spring Cloud Stream 可以实现消息的接收和发送。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;五、微服务相比单体服务的优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;关于微服务的优缺点，我不想用官网模板或者书上说的一大堆，young我经历了从单体服务到微服务项目的过渡，我就从个人工作体会接地气的讲解一下微服务的优缺点。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;      1. 新人上手快：新人在参与新项目时，只需要下载需求相关模块的代码，了解这部分代码就行了，不需要关注整个项目的代码逻辑，可以减少上手时间。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;      2. 本地调试快：以前修改一个功能，整个项目启动，花费时间很长。现在只启动修改的单个模块，启动很快。（不知道有没有和我一样，以前本地启动一个复杂项目花费30s-60s，调试启动一次就能喝杯茶了）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;      3. 开发进度加快：以前一个项目，多个人开发，你改的代码，影响我，我改的代码影响你，某个人改了错误代码提交，整个项目都启动不了。微服务不同功能模块，互不影响，你自己的锅自己背。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;      4. 跨语言合作： 同一个项目不同的功能模块可以使用不同语言开发，java，js，php，随心所欲。不同语言只需要提供 http 客户端，便可以实现跨语言调用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;      5.  简单的分库： 同一个项目，不同模块连接不同的数据库，主要是配置简单。（我们项目就连接3个不同的mysql业务数据库，1个redis集群，1个mongo集群）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;      6. 服务集群扩展容易 ：现在springcloud做服务集群，节省资源，并且搭建速度快。比如项目中，资源服务功能模块压力大，运维只要快速copy一份配置，部署一台资源服务模块的服务就行了，其它功能服务模块不用管。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;缺点： &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;     1. 运维人员压力大： 单体应用以前运维同事只要监控个一个应用正常运行，而现在却需要保证几十甚至上百个应用运转正常，这是一个艰巨的任务。 &lt;/span&gt;     &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;     2. 事务、异步、测试面临挑战：&lt;span&gt;跨进程之间的事务、大量的异步处理、多个微服务之间的整体测试都需要有一整套的解决方案，而现在看起来，这些技术并没有成熟。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;     3. 服务分割难度大：对于一个项目，如何进行功能划分，哪些功能归属同一个服务模块，对架构师和设计人员的要求较高。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;     后面，我会以实际工作中的案例，逐步讲解springcloud重要组件的使用，逐渐搭建出一个微服务项目，敬请期待~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;    如果不正确的地方，欢迎大家留言指出，共同进步~&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 06:30:00 +0000</pubDate>
<dc:creator>young码农</dc:creator>
<og:description>目前大家都在说微服务，其实微服务不是一个名字，是一个架构的概念，大家现在使用的基于RPC框架（dubbo、thrift等）架构其实也能算作一种微服务架构。 目前越来越多的公司开始使用微服务架构，所以在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haly/p/10737574.html</dc:identifier>
</item>
<item>
<title>性能篇（七）内存管理概述 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10756139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10756139.html</guid>
<description>&lt;p&gt;       Android运行时ART和Dalvik虚拟机使用分页和内存映射（mmapping）管理内存。这意味着所有被修改过的内存——无论是通过分配新的对象还是触摸被映射的页——仍然驻留在RAM中并且不能移除分页。唯一从应用中释放内存的方法是释放应用持有的对象引用，让内存能够被垃圾收集器使用。但有一个例外：如果系统想在其它地方使用内存，那么所有被映射但没有被修改的文件，比如代码，可能会被从RAM的分页中移除。&lt;/p&gt;
&lt;p&gt;       本文将阐述Android如何管理应用进程和内存分配。更多关于如何更有效管理应用内存的信息，请查阅【&lt;a href=&quot;https://www.cnblogs.com/andy-songwei/p/10737682.html&quot; target=&quot;_blank&quot;&gt;管理应用的内存&lt;/a&gt;】。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;垃圾收集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       一个被管理的内存环境， 像ART或Dalvik虚拟机，保持追踪每一块内存分配。一旦虚拟机确定某块内存不再被程序使用，它会释放该内存回到堆中，而不需要程序员的任何干预。这个在被管理的内存环境中回收不再被使用的内存的机制被称为垃圾收集。垃圾收集有两个目标：找到程序中在未来不会再被访问的数据对象；以及回收被那些对象使用的资源。&lt;/p&gt;
&lt;p&gt;       Android的内存堆是一个分代的内存堆，这意味着，基于被分配的对象的预期寿命和大小，它追踪着不同的分配群组。例如，最近被分配的对象属于年轻代。当一个对象保持活跃了足够长的时间，它可能会被提升到老年代，后面还有一个永久代。&lt;/p&gt;
&lt;p&gt;       每一个堆分代都有它自己的对象可以占据的特定的内存数量上限。任何时候某代开始填充时，系统会执行一个垃圾回收事件来尝试释放内存。这个垃圾收集的持续时长取决于它所收集的对象在哪个代，以及在每个代中有多少活跃对象。&lt;/p&gt;
&lt;p&gt;       虽然垃圾收集可能非常快，但它仍然会影响您应用的性能。通常您无法掌控代码中垃圾收集事件何时会发生。系统有一套正在运行的标准来决定何时执行垃圾收集。当满足标准时，系统会停止执行进程并开始垃圾收集。如果垃圾收集发生在一个密集的正在处理的循环（如动画或音乐回放期间）中间时，这可能会增加处理时间。这个增加可能潜在地推动应用中代码执行时间超过为有效和平滑帧渲染而建议的16ms阈值。&lt;/p&gt;
&lt;p&gt;       除此之外，您的代码流可能执行某些类型的工作：这类工作强迫垃圾收集事件更频繁地发生或者使它们延续得比平常时间更长。例如，如果在透明度混合动画的每一帧期间，您在一个for循环最里面部分分配多个对象，可能导致大量对象污染内存堆。在那种环境下，垃圾收集器会执行多个垃圾收集事件并会降低应用的性能。&lt;/p&gt;
&lt;p&gt;       更多关于垃圾收集的分代信息，请查阅【&lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot; target=&quot;_blank&quot;&gt;垃圾收集&lt;/a&gt;】。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共享内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       为了适合在RAM中所需要的一切，Android尝试跨进程分享RAM分页。Android可以通过如下方式实现这个目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个应用进程都是从一个已经存在的叫做Zygote的进程fork（译者注：派生）出来的。当系统启动并且加载公共框架代码和资源（比如activity主题）时，Zygote进程开始启动。为了启动新的应用进程，系统会fork Zygote进程，然后在新的应用进程中加载和运行应用代码。这个方法允许大部分的为框架代码和资源而分配的RAM分页在所有进程之间共享。&lt;/li&gt;
&lt;li&gt;大部分静态数据被映射都一个进程中。这项技术允许数据在进程之间共享，并且允许在需要时将其调出。典型的静态数据包括：Dalvik代码（通过把它放入到一个为直接映射而预先链接的.odex文件），应用资源（通过将资源表设计为一个可以被映射的结构并通过对齐APK的zip入口），以及传统的项目元素如.so文件中的本地代码。&lt;/li&gt;
&lt;li&gt;在许多地方，通过使用被显式分配的共享内存区域（使用ashmem或者gralloc），Android跨进程共享相同的动态RAM。例如，窗口表面使用应用和屏幕合成器之间的共享内存，以及游标缓存使用内容提供者和客户端之间的共享内存。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       因为共享内存的大量使用，确定您的应用正在使用多少内存需要关注。关于正确确定应用的内存使用，在【&lt;a href=&quot;https://developer.android.google.cn/studio/profile/investigate-ram.html&quot; target=&quot;_blank&quot;&gt;RAM使用研究&lt;/a&gt;】中进行探讨。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分配和回收应用内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       对于每个应用进程，Dalvik堆被限制为单个虚拟内存范围。这定义了逻辑堆的大小，这个大小可以根据需要增长，但只能增长到系统为每个应用定义的极限值。&lt;/p&gt;
&lt;p&gt;       堆的逻辑大小和堆使用的物理内存数量并不相同。当检查应用的堆时，Android会计算一个被称为Proportional Set Size（PSS），它会计算和其它进程共享的赃页和干净页——但是其数量只能与共享RAM的应用数成比例。PSS总数被系统看成是物理内存的足迹。更多关于PSS的信息，请查阅【&lt;a href=&quot;https://developer.android.google.cn/studio/profile/investigate-ram.html&quot; target=&quot;_blank&quot;&gt;RAM使用研究&lt;/a&gt;】指导。&lt;/p&gt;
&lt;p&gt;       Dalvik堆并不会压缩堆的逻辑大小，这意味着Android不会整理堆碎片来压缩空间。Android仅仅会在堆的结尾有未被使用的空间时压缩逻辑堆大小。但是，系统仍然会减少被堆使用的物理内存。垃圾收集发生以后，Dalvik会遍历堆并且找到未被使用的页，然后使用madvise把那些页返回到内核。所以，成对的分配和大块的重新分配可能导致回收所有（或者几乎所有）被使用的物理内存。可是，从小的分配中回收内存可能非常低效，因为用于小分配的页面可能仍然和还没有被释放的事物共享。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;限制应用内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       为了维护功能的多任务环境，Android对每个应用的对大小设置了一个硬性限制。依据总体上所拥有的可用RAM数量多少，确切的堆大小限制在设备之间是不同的。如果您的应用已经到达了堆的容量并且尝试分配更多的内存，可能会收到OutOfMemoryError。&lt;/p&gt;
&lt;p&gt;       在某些情况下，您可能想查询系统来确切地知道您当前的设备有多少可用的堆空间——例如，为了确定保留多少数据在缓存中是安全的。您可以通过调用getMemoryClass()查询系统来获取这个数据。这个方法会返回一个整数来指示应用堆可用的兆字节数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;切换应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       当用户在应用之间切换时，Android将不在前台的应用——也就是，对用户是不可见的或者运行一个前台service如音乐播放——保存在最近最少使用（LRU）缓存中。例如，当用户首先启动应用，就会为它创建一个进程；但是当用户离开这个应用，那个进程并不会退出。系统会缓存这个进程。如果用户稍后返回到该应用，系统会重新使用这个进程，从而让应用切换得更快。&lt;/p&gt;
&lt;p&gt;       如果应用拥有一个缓存的进程，并且保留当前不需要的内存，那么您的应用——即使当用户不是正在使用它——会影响系统的整体性能。当系统运行时内存不足，系统会从最近最少使用的进程开始杀死LRU缓存中的应用。系统也会考虑那些持有最多内存的进程，并且可能终止它们来释放RAM。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;★ 注意：当系统开始杀死LRU缓存中的进程时，主要是从下往上进行的。系统也会考虑哪些进程消耗了更多的内存，并且这样的话，如果被杀死可以提供给系统更多的内存收获。在LRU列表中消耗的内存越少，您保留在列表并且能够快速恢复的机会就越大。&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       &lt;span&gt;更多关于当不在前台运行时进程如何缓存以及Android如何决定哪些进程可以被杀死的信息，请查阅【&lt;a href=&quot;https://developer.android.google.cn/guide/components/processes-and-threads.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;进程和线程&lt;/span&gt;&lt;/a&gt;】指导。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Apr 2019 06:20:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>由于在Android设备中内存是比较稀有的，如果内存使用不当会严重影响用户体验。垃圾收集，共享内存，分配和回收应用内存，切换应用等都等情形下内存的行为，都是需要开发者们需要关注的。本文会从整体上阐述对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/10756139.html</dc:identifier>
</item>
</channel>
</rss>