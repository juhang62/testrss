<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Go中http超时问题的排查 - 蘑菇先生</title>
<link>http://www.cnblogs.com/mushroom/p/11756631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mushroom/p/11756631.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;最新有同事反馈，服务间有调用超时的现象，在业务高峰期发生的概率和次数比较高。从日志中调用关系来看，有2个调用链经常发生超时问题。&lt;/p&gt;
&lt;p&gt;问题1： A服务使用 http1.1 发送请求到 B 服务超时。&lt;/p&gt;
&lt;p&gt;问题2: A服务使用一个轻量级http-sdk(内部http2.0) 发送请求到 C 服务超时。&lt;/p&gt;
&lt;p&gt;Golang给出的报错信息时：&lt;/p&gt;
&lt;pre class=&quot;none&quot;&gt;
&lt;code&gt;Post http://host/v1/xxxx: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通知日志追踪ID来排查，发现有的请求还没到服务方就已经超时。&lt;/p&gt;
&lt;p&gt;有些已经到服务方了，但也超时。&lt;/p&gt;
&lt;p&gt;这里先排查的是问题2，下面是过程。&lt;/p&gt;
&lt;h2 id=&quot;排查&quot;&gt;排查&lt;/h2&gt;
&lt;h3 id=&quot;推测&quot;&gt;推测&lt;/h3&gt;
&lt;p&gt;调用方设置的http请求超时时间是1s。&lt;/p&gt;
&lt;p&gt;请求已经到服务端了还超时的原因，可能是：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务方响应慢。 通过日志排查确实有部分存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;客户端调用花了990ms，到服务端只剩10ms，这个肯定会超时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;请求没到服务端超时的原因，可能是：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;golang CPU调度不过来。通过cpu监控排除这个可能性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;golang 网络库原因。重点排查&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;排查方法：&lt;/p&gt;
&lt;p&gt;本地写个测试程序，1000并发调用测试环境的C服务:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;n := 1000
var waitGroutp = sync.WaitGroup{}
waitGroutp.Add(n)
for i := 0; i &amp;lt; n; i++ {
       go func(x int) {
         httpSDK.Request()
     }
}
waitGroutp.Wait()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;too many open files    // 这个错误是笔者本机ulimit太小的原因，可忽略
net/http: request canceled (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并发数量调整到500继续测试，还是报同样的错误。&lt;/p&gt;
&lt;h3 id=&quot;连接超时&quot;&gt;连接超时&lt;/h3&gt;
&lt;p&gt;本地如果能重现的问题，一般来说比较好查些。&lt;/p&gt;
&lt;p&gt;开始跟golang的源码，下面是创建httpClient的代码，这个httpClient是全局复用的。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func createHttpClient(host string, tlsArg *TLSConfig) (*http.Client, error) {
    httpClient := &amp;amp;http.Client{
        Timeout: time.Second,
    }
    tlsConfig := &amp;amp;tls.Config{InsecureSkipVerify: true}
    transport := &amp;amp;http.Transport{
        TLSClientConfig:     tlsConfig,
        MaxIdleConnsPerHost: 20,
    }
    http2.ConfigureTransport(transport)
    return httpClient, nil
}
// 使用httpClient
httpClient.Do(req)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跳到net/http/client.go 的do方法&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (c *Client) do(req *Request) (retres *Response, reterr error) {
    if resp, didTimeout, err = c.send(req, deadline); err != nil {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续进 send 方法，实际发送请求是通过 RoundTrip 函数。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error) {
     rt.RoundTrip(req) 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;send 函数接收的 rt 参数是个 inteface，所以要从 http.Transport 进到 RoundTrip 函数。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;log.Println(&quot;getConn time&quot;, time.Now().Sub(start), x)&lt;/code&gt; 是笔者添加的日志，为了验证创建连接耗时。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var n int
// roundTrip implements a RoundTripper over HTTP.
func (t *Transport) roundTrip(req *Request) (*Response, error) {
    // 检查是否有注册http2，有的话直接使用http2的RoundTrip
    if t.useRegisteredProtocol(req) {
        altProto, _ := t.altProto.Load().(map[string]RoundTripper)
        if altRT := altProto[scheme]; altRT != nil {
            resp, err := altRT.RoundTrip(req)
            if err != ErrSkipAltProtocol {
                return resp, err
            }
        }
    }
    for {
        //n++
        // start := time.Now()
        pconn, err := t.getConn(treq, cm)
         // log.Println(&quot;getConn time&quot;, time.Now().Sub(start), x)
        if err != nil {
            t.setReqCanceler(req, nil)
            req.closeBody()
            return nil, err
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：加了日志跑下来，确实有大量的&lt;code&gt;getConn time&lt;/code&gt;超时。&lt;/p&gt;
&lt;h3 id=&quot;疑问&quot;&gt;疑问&lt;/h3&gt;
&lt;p&gt;这里有2个疑问：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为什么Http2没复用连接，反而会创建大量连接？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建连接为什么会越来越慢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;继续跟 getConn 源码, getConn第一步会先获取空闲连接，因为这里用的是http2，可以不用管它。&lt;/p&gt;
&lt;p&gt;追加耗时日志，确认是dialConn耗时的。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (*persistConn, error) {
   if pc, idleSince := t.getIdleConn(cm); pc != nil {
   }
    //n++
    go func(x int) {
        // start := time.Now()
        // defer func(x int) {
        //  log.Println(&quot;getConn dialConn time&quot;, time.Now().Sub(start), x)
        // }(n)
        pc, err := t.dialConn(ctx, cm)
        dialc &amp;lt;- dialRes{pc, err}
    }(n)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续跟dialConn函数，里面有2个比较耗时的地方：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;连接建立，三次握手。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;tls握手的耗时，见下面http2章节的dialConn源码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分别在dialConn函数中 t.dial 和 addTLS 的位置追加日志。&lt;/p&gt;
&lt;p&gt;可以看到，三次握手的连接还是比较稳定的，后面连接的在tls握手耗时上面，耗费将近1s。&lt;/p&gt;
&lt;pre class=&quot;none&quot;&gt;
&lt;code&gt;2019/10/23 14:51:41 DialTime 39.511194ms https.Handshake 1.059698795s
2019/10/23 14:51:41 DialTime 23.270069ms https.Handshake 1.064738698s
2019/10/23 14:51:41 DialTime 24.854861ms https.Handshake 1.0405369s
2019/10/23 14:51:41 DialTime 31.345886ms https.Handshake 1.076014428s
2019/10/23 14:51:41 DialTime 26.767644ms https.Handshake 1.084155891s
2019/10/23 14:51:41 DialTime 22.176858ms https.Handshake 1.064704515s
2019/10/23 14:51:41 DialTime 26.871087ms https.Handshake 1.084666172s
2019/10/23 14:51:41 DialTime 33.718771ms https.Handshake 1.084348815s
2019/10/23 14:51:41 DialTime 20.648895ms https.Handshake 1.094335678s
2019/10/23 14:51:41 DialTime 24.388066ms https.Handshake 1.084797011s
2019/10/23 14:51:41 DialTime 34.142535ms https.Handshake 1.092597021s
2019/10/23 14:51:41 DialTime 24.737611ms https.Handshake 1.187676462s
2019/10/23 14:51:41 DialTime 24.753335ms https.Handshake 1.161623397s
2019/10/23 14:51:41 DialTime 26.290747ms https.Handshake 1.173780655s
2019/10/23 14:51:41 DialTime 28.865961ms https.Handshake 1.178235202s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：第二个疑问的答案就是tls握手耗时&lt;/p&gt;
&lt;h3 id=&quot;http2&quot;&gt;http2&lt;/h3&gt;
&lt;p&gt;为什么Http2没复用连接，反而会创建大量连接？&lt;/p&gt;
&lt;p&gt;前面创建http.Client 时，是通过http2.ConfigureTransport(transport) 方法，其内部调用了configureTransport：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func configureTransport(t1 *http.Transport) (*Transport, error) {
    // 声明一个连接池
   // noDialClientConnPool 这里很关键，指明连接不需要dial出来的，而是由http1连接升级而来的 
    connPool := new(clientConnPool)
    t2 := &amp;amp;Transport{
        ConnPool: noDialClientConnPool{connPool},
        t1:       t1,
    }
    connPool.t = t2
// 把http2的RoundTripp的方法注册到，http1上transport的altProto变量上。
// 当请求使用http1的roundTrip方法时，检查altProto是否有注册的http2，有的话，则使用
// 前面代码的useRegisteredProtocol就是检测方法
    if err := registerHTTPSProtocol(t1, noDialH2RoundTripper{t2}); err != nil           {
        return nil, err
    }
   // http1.1 升级到http2的后的回调函数，会把连接通过 addConnIfNeeded 函数把连接添加到http2的连接池中
    upgradeFn := func(authority string, c *tls.Conn) http.RoundTripper {
        addr := authorityAddr(&quot;https&quot;, authority)
        if used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {
            go c.Close()
            return erringRoundTripper{err}
        } else if !used {
            go c.Close()
        }
        return t2
    }
    if m := t1.TLSNextProto; len(m) == 0 {
        t1.TLSNextProto = map[string]func(string, *tls.Conn) http.RoundTripper{
            &quot;h2&quot;: upgradeFn,
        }
    } else {
        m[&quot;h2&quot;] = upgradeFn
    }
    return t2, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TLSNextProto 在 http.Transport-&amp;gt; dialConn 中使用。调用upgradeFn函数，返回http2的RoundTripper，赋值给alt。&lt;/p&gt;
&lt;p&gt;alt会在http.Transport 中 RoundTripper 内部检查调用。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error) {
    pconn := &amp;amp;persistConn{
        t:             t,
    }
    if cm.scheme() == &quot;https&quot; &amp;amp;&amp;amp; t.DialTLS != nil {
     // 没有自定义DialTLS方法，不会走到这一步
    } else {
        conn, err := t.dial(ctx, &quot;tcp&quot;, cm.addr())
        if err != nil {
            return nil, wrapErr(err)
        }
        pconn.conn = conn
        if cm.scheme() == &quot;https&quot; {
         // addTLS 里进行 tls 握手，也是建立新连接最耗时的地方。
            if err = pconn.addTLS(firstTLSHost, trace); err != nil {
                return nil, wrapErr(err)
            }
        }
    }
    if s := pconn.tlsState; s != nil &amp;amp;&amp;amp; s.NegotiatedProtocolIsMutual &amp;amp;&amp;amp; s.NegotiatedProtocol != &quot;&quot; {
        if next, ok := t.TLSNextProto[s.NegotiatedProtocol]; ok {
            // next 调用注册的升级函数
            return &amp;amp;persistConn{t: t, cacheKey: pconn.cacheKey, alt: next(cm.targetAddr, pconn.conn.(*tls.Conn))}, nil
        }
    }
    return pconn, nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;当没有连接时，如果此时来一大波请求，会创建n多http1.1的连接，进行升级和握手，而tls握手随着连接增加而变的非常慢。&lt;/p&gt;
&lt;h3 id=&quot;解决超时&quot;&gt;解决超时&lt;/h3&gt;
&lt;p&gt;上面的结论并不能完整解释，复用连接的问题。因为服务正常运行的时候，一直都有请求的，连接是不会断开的，所以除了第一次连接或网络原因断开，正常情况下都应该复用http2连接。&lt;/p&gt;
&lt;p&gt;通过下面测试，可以复现有http2的连接时，还是会创建N多新连接：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;sdk.Request()  // 先请求一次，建立好连接，测试是否一直复用连接。
time.Sleep(time.Second)
n := 1000
var waitGroutp = sync.WaitGroup{}
waitGroutp.Add(n)
for i := 0; i &amp;lt; n; i++ {
       go func(x int) {
         sdk.Request()
     }
}
waitGroutp.Wait()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以还是怀疑http1.1升级导致，这次直接改成使用 http2.Transport&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;httpClient.Transport = &amp;amp;http2.Transport{
            TLSClientConfig: tlsConfig,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改了后，测试发现没有报错了。&lt;/p&gt;
&lt;p&gt;为了验证升级模式和直接http2模式的区别。 这里先回到升级模式中的 addConnIfNeeded 函数中，其会调用addConnCall 的 run 函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (c *addConnCall) run(t *Transport, key string, tc *tls.Conn) {
    cc, err := t.NewClientConn(tc)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run参数中传入的是http2的transport。&lt;/p&gt;
&lt;p&gt;整个解释是http1.1创建连接后，会把传输层连接，通过addConnIfNeeded-&amp;gt;run-&amp;gt;Transport.NewClientConn构成一个http2连接。 因为http2和http1.1本质都是应用层协议，传输层的连接都是一样的。&lt;/p&gt;
&lt;p&gt;然后在newClientConn连接中加日志。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (t *Transport) newClientConn(c net.Conn, singleUse bool) (*ClientConn, error) {
    //  log.Println(&quot;http2.newClientConn&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;升级模式下，会打印很多http2.newClientConn，根据前面的排查这是讲的通的。而单纯http2模式下，也会创建新连接，虽然很少。&lt;/p&gt;
&lt;h3 id=&quot;并发连接数&quot;&gt;并发连接数&lt;/h3&gt;
&lt;p&gt;那http2模式下什么情况下会创建新连接呢？&lt;/p&gt;
&lt;p&gt;这里看什么情况下http2会调用 newClientConn。回到clientConnPool中，dialOnMiss在http2模式下为true，getStartDialLocked 里会调用dial-&amp;gt;dialClientConn-&amp;gt;newClientConn。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (p *clientConnPool) getClientConn(req *http.Request, addr string, dialOnMiss bool) (*ClientConn, error) {
    p.mu.Lock()
    for _, cc := range p.conns[addr] {
        if st := cc.idleState(); st.canTakeNewRequest {
            if p.shouldTraceGetConn(st) {
                traceGetConn(req, addr)
            }
            p.mu.Unlock()
            return cc, nil
        }
    }
    if !dialOnMiss {
        p.mu.Unlock()
        return nil, ErrNoCachedConn
    }
    traceGetConn(req, addr)
    call := p.getStartDialLocked(addr)
    p.mu.Unlock()
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有连接的情况下，canTakeNewRequest 为false，也会创建新连接。看看这个变量是这么得来的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (cc *ClientConn) idleStateLocked() (st clientConnIdleState) {
    if cc.singleUse &amp;amp;&amp;amp; cc.nextStreamID &amp;gt; 1 {
        return
    }
    var maxConcurrentOkay bool
    if cc.t.StrictMaxConcurrentStreams {
        maxConcurrentOkay = true
    } else {
        maxConcurrentOkay = int64(len(cc.streams)+1) &amp;lt; int64(cc.maxConcurrentStreams)
    }
    st.canTakeNewRequest = cc.goAway == nil &amp;amp;&amp;amp; !cc.closed &amp;amp;&amp;amp; !cc.closing &amp;amp;&amp;amp; maxConcurrentOkay &amp;amp;&amp;amp;
        int64(cc.nextStreamID)+2*int64(cc.pendingRequests) &amp;lt; math.MaxInt32
    // if st.canTakeNewRequest == false {
    //  log.Println(&quot;clientConnPool&quot;, cc.maxConcurrentStreams, cc.goAway == nil, !cc.closed, !cc.closing, maxConcurrentOkay, int64(cc.nextStreamID)+2*int64(cc.pendingRequests) &amp;lt; math.MaxInt32)
    // }
    st.freshConn = cc.nextStreamID == 1 &amp;amp;&amp;amp; st.canTakeNewRequest
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了查问题，这里加了详细日志。测试下来，发现是maxConcurrentStreams 超了，canTakeNewRequest才为false。&lt;/p&gt;
&lt;p&gt;在http2中newClientConn的初始化配置中, maxConcurrentStreams 默认为1000：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;   maxConcurrentStreams:  1000,     // &quot;infinite&quot;, per spec. 1000 seems good enough.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但实际测下来，发现500并发也会创建新连接。继续追查有设置这个变量的地方：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (rl *clientConnReadLoop) processSettings(f *SettingsFrame) error {
    case SettingMaxConcurrentStreams:
            cc.maxConcurrentStreams = s.Val
           //log.Println(&quot;maxConcurrentStreams&quot;, s.Val)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行测试，发现是服务传过来的配置，值是250。&lt;/p&gt;
&lt;p&gt;结论： 服务端限制了单连接并发连接数，超了后就会创建新连接。&lt;/p&gt;
&lt;h3 id=&quot;服务端限制&quot;&gt;服务端限制&lt;/h3&gt;
&lt;p&gt;在服务端框架中，找到ListenAndServeTLS函数，跟下去-&amp;gt;ServeTLS-&amp;gt;Serve-&amp;gt;setupHTTP2_Serve-&amp;gt;onceSetNextProtoDefaults_Serve-&amp;gt;onceSetNextProtoDefaults-&amp;gt;http2ConfigureServer。&lt;/p&gt;
&lt;p&gt;查到new(http2Server)的声明，因为web框架即支持http1.1 也支持http2，所以没有指定任何http2的相关配置，都使用的是默认的。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Server is an HTTP/2 server.
type http2Server struct {
    // MaxConcurrentStreams optionally specifies the number of
    // concurrent streams that each client may have open at a
    // time. This is unrelated to the number of http.Handler goroutines
    // which may be active globally, which is MaxHandlers.
    // If zero, MaxConcurrentStreams defaults to at least 100, per
    // the HTTP/2 spec's recommendations.
    MaxConcurrentStreams uint32
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从该字段的注释中看出，http2标准推荐至少为100，golang中使用默认变量 http2defaultMaxStreams， 它的值为250。&lt;/p&gt;
&lt;h2 id=&quot;真相&quot;&gt;真相&lt;/h2&gt;
&lt;p&gt;上面的步骤，更多的是为了记录排查过程和源码中的关键点，方便以后类似问题有个参考。&lt;/p&gt;
&lt;p&gt;简化来说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用方和服务方使用http1.1升级到http2的模式进行通讯&lt;/li&gt;
&lt;li&gt;服务方http2Server限制单连接并发数是250&lt;/li&gt;
&lt;li&gt;当并发超过250，比如1000时，调用方就会并发创建750个连接。这些连接的tls握手时间会越来越长。而调用超时只有1s，所以导致大量超时。&lt;/li&gt;
&lt;li&gt;这些连接有些没到服务方就超时，有些到了但服务方还没来得及处理，调用方就取消连接了，也是超时。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;并发量高的情况下，如果有网络断开，也会导致这种情况发送。&lt;/p&gt;
&lt;h3 id=&quot;重试&quot;&gt;重试&lt;/h3&gt;
&lt;p&gt;A服务使用的轻量级http-sdk有一个重试机制，当检测到是一个临时错误时，会重试2次。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;Temporary() bool // Is the error temporary?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而这个超时错误，就属于临时错误，从而放大了这种情况发生。&lt;/p&gt;
&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;
&lt;p&gt;不是升级模式的http2即可。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;httpClient.Transport = &amp;amp;http2.Transport{
            TLSClientConfig: tlsConfig,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么http2不会大量创建连接呢？&lt;/p&gt;
&lt;p&gt;这是因为http2创建新连接时会加锁，后面的请求解锁后，发现有连接没超过并发数时，直接复用连接即可。所以没有这种情况，这个锁在 clientConnPool.getStartDialLocked 源码中。&lt;/p&gt;
&lt;h3 id=&quot;问题1&quot;&gt;问题1&lt;/h3&gt;
&lt;p&gt;问题1： A服务使用 http1.1 发送请求到 B 服务超时。&lt;/p&gt;
&lt;p&gt;问题1和问题2的原因一样，就是高并发来的情况下，会创建大量连接，连接的创建会越来越慢，从而超时。&lt;/p&gt;
&lt;p&gt;这种情况没有很好的办法解决，推荐使用http2。&lt;/p&gt;
&lt;p&gt;如果不能使用http2，调大MaxIdleConnsPerHost参数，可以缓解这种情况。默认http1.1给每个host只保留2个空闲连接，来个1000并发，就要创建998新连接。&lt;/p&gt;
&lt;p&gt;该调整多少，可以视系统情况调整，比如50，100。&lt;/p&gt;
</description>
<pubDate>Tue, 29 Oct 2019 00:19:00 +0000</pubDate>
<dc:creator>蘑菇先生</dc:creator>
<og:description>'背景' '排查' '推测' '连接超时' '疑问' 'http2' '解决超时' '并发连接数' '服务端限制' '真相' '重试' '解决办法' '问题1' 背景 最新有同事反馈，服务间有调用超时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mushroom/p/11756631.html</dc:identifier>
</item>
<item>
<title>Vue系列---理解Vue.nextTick使用及源码分析(五) - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/11756584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/11756584.html</guid>
<description>&lt;p&gt;一. 什么是Vue.nextTick()?&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;官方文档解释为：在下次DOM更新循环结束之后执行的延迟回调。在修改数据之后立即使用该方法，获取更新后的DOM。&lt;/p&gt;
&lt;p&gt;我们也可以简单的理解为：当页面中的数据发生改变了，就会把该任务放到一个异步队列中，只有在当前任务空闲时才会进行DOM渲染，当DOM渲染完成以后，该函数就会自动执行。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;2.1 更改数据后，进行节点DOM操作。&lt;/p&gt;
&lt;p&gt;比如修改数据、修改节点样式、等操作。比如说我修改data中的一个属性数据后，如果我这个时候直接获取该html内容的话，它还是老数据的，那么此时此刻，我们可以使用 Vue.nextTick()， 在该函数内部获取该数据即可: 如下代码:&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;vue.nextTick()方法的使用&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;https://cn.vuejs.org/js/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
      el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      data: {
        name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kongzhi111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      },
      mounted() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateData();
      },
      methods: {
        updateData() {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kongzhi222&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
          console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.list.textContent); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印 kongzhi111&lt;/span&gt;
          &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$nextTick(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.list.textContent); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印 kongzhi222&lt;/span&gt;
&lt;span&gt;          });
        }
      }
    })
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，页面初始化时候，页面显示的是 &quot;kongzhi111&quot;; 当页面中的所有的DOM更新完成后，我在mounted()生命周期中调用 updateData()方法，然后在该方法内部修改 this.name 这个数据，再打印 this.$refs.list.textContent, 可以看到打印的数据 还是 'kongzhi111'; 为什么会是这样呢？那是因为修改name数据后，我们的DOM还没有被渲染完成，所以我们这个时候获取的值还是之前的值，但是我们放在nextTick函数里面的时候，代码会在DOM更新完成后 会自动执行 nextTick()函数，因此这个时候我们再去使用 this.$refs.list.textContent 获取该值的时候，就可以获取到最新值了。&lt;br/&gt;&lt;strong&gt;理解DOM更新：&lt;/strong&gt;在VUE中，当我们修改了data中的某一个值后，并不会立刻去渲染html页面，而是将vue更改的数据放到watcher的一个异步队列中，只有在当前任务空闲时才会执行watcher中的队列任务，因此这就会有一个延迟时间，因此我们把代码放到nextTick函数后就可以获取到该 html 页面的最新值了。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;2.2 在created生命周期中进行DOM操作。&lt;/p&gt;
&lt;div readability=&quot;26&quot;&gt;
&lt;p&gt;在Vue生命周期中，只有在mounted生命周期中我们的HTML才渲染完成，因此在该生命周期中，我们就可以获取到页面中的html DOM节点，但是如果我们在 created生命周期中是访问不到DOM节点的。&lt;br/&gt;在该生命周期中我们想要获取DOM节点的话,我们需要使用 this.$nextTick() 函数。&lt;/p&gt;
&lt;p&gt;比如如下代码进行演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;vue.nextTick()方法的使用&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;https://cn.vuejs.org/js/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
      el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      data: {
        name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kongzhi111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      },
      created() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印undefined&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$nextTick(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
          console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印出 &quot;&amp;lt;div&amp;gt;kongzhi111&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;
&lt;span&gt;        });
      },
      methods: {
        
      }
    })
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，在created生命周期内，我们打印 this.$refs.list 值为undefined，那是因为在created生命周期内页面的html没有被渲染完成，因此打印出为undefined; 但是我们把它放入 this.$nextTick函数内即可 打印出值出来，这也印证了 nextTick 是在下次DOM更新循环结束之后执行的延迟回调。因此只有DOM渲染完成后才会自动执行的延迟回调函数。&lt;/p&gt;
&lt;p&gt;Vue的特点之一就是能实现响应式，但数据更新时，DOM不会立即更新，而是放入一个异步队列中，因此如果在我们的业务场景中，需要在DOM更新之后执行一段代码时，这个时候我们可以使用 this.$nextTick() 函数来实现。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;三. Vue.nextTick的调用方式如下：&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;strong&gt;Vue.nextTick([callback, context]) 和 vm.$nextTick([callback]);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vue.nextTick([callback, context]);&lt;/strong&gt; 该方法是全局方法，该方法可接收2个参数，分别为回调函数 和 执行回调函数的上下文环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vm.$nextTick([callback]):&lt;/strong&gt; 该方法是实列方法，执行时自动绑定this到当前的实列上。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;四：vm.$nextTick 与 setTimeout 的区别是什么？&lt;/p&gt;
&lt;p&gt;在区别他们俩之前，我们先来看一个简单的demo如下：&lt;/p&gt;
&lt;div readability=&quot;144.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;vue.nextTick()方法的使用&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;https://cn.vuejs.org/js/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
      el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      data: {
        name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kongzhi111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      },
      created() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印undefined&lt;/span&gt;
&lt;span&gt;        setTimeout(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
          console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印出 &quot;&amp;lt;div&amp;gt;kongzhi111&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;
&lt;span&gt;        }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
      }
    })
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们不使用 nextTick， 我们使用setTimeout延迟也一样可以获取页面中的HTML元素的，那么他们俩之间到底有什么区别呢？&lt;/p&gt;
&lt;p&gt;通过看vue源码我们知道，nextTick 源码在 src/core/util/next-tick.js 里面。在vue中使用了三种情况来延迟调用该函数，首先我们会判断我们的设备是否支持Promise对象，如果支持的话，会使用 Promise.then 来做延迟调用函数。如果设备不支持Promise对象，再判断是否支持 MutationObserver 对象，如果支持该对象，就使用MutationObserver来做延迟，最后如果上面两种都不支持的话，我们会使用 setTimeout(() =&amp;gt; {}, 0); setTimeout 来做延迟操作。&lt;/p&gt;
&lt;p&gt;在比较 nextTick 与 setTimeout 的区别，其实我们可以比较 promise 或 MutationObserver 对象 与 setTimeout的区别的了，因为nextTick会先判断设备是否支持promise及MutationObserver 对象的，只要我们弄懂 promise 和 setTimeout的区别，也就弄明白 nextTick 与 setTimeout的区别了。&lt;/p&gt;
&lt;p&gt;在比较promise与setTimeout之前，我们先来看如下demo。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    console.log(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      console.log(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Promise(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve) {
      console.log(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
        i &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;99&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; resolve();
      }
      console.log(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      console.log(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    });
    console.log(&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码输出的结果是：1, 3, 4, 6, 5, 2; 首先打印1，这个我们能理解的，其实为什么打印3，在promise内部也属于同步的，只有在then内是异步的，因此打印 1, 3, 4 ， 然后执行then函数是异步的，因此打印6. 那么结果为什么是 1, 3, 4, 6, 5, 2 呢？ 为什么不是 1, 3, 4, 6, 2, 5呢？&lt;/p&gt;
&lt;p&gt;我们都知道 Promise.then 和 setTimeout 都是异步的，那么在事件队列中Promise.then的事件应该是在setTimeout的后面的，那么为什么Promise.then比setTimeout函数先执行呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解Event Loop 的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们都明白，javascript是单线程的，所有的任务都会在主线程中执行的，当主线程中的任务都执行完成之后，系统会 &quot;依次&quot; 读取任务队列里面的事件，因此对应的异步任务进入主线程，开始执行。&lt;/p&gt;
&lt;p&gt;但是异步任务队列又分为: macrotasks(宏任务) 和 microtasks(微任务)。 他们两者分别有如下API:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;macrotasks(宏任务):&lt;/strong&gt; setTimeout、setInterval、setImmediate、I/O、UI rendering 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;microtasks(微任务):&lt;/strong&gt; Promise、process.nextTick、MutationObserver 等。&lt;/p&gt;
&lt;p&gt;如上我们的promise的then方法的函数会被推入到 microtasks(微任务) 队列中，而setTimeout函数会被推入到 macrotasks(宏任务) 任务队列中，在每一次事件循环中 macrotasks(宏任务) 只会提取一个执行，而 microtasks(微任务) 会一直提取，直到 microtasks(微任务)队列为空为止。&lt;/p&gt;
&lt;p&gt;也就是说，如果某个 microtasks(微任务) 被推入到执行中，那么当主线程任务执行完成后，会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为止。而事件循环每次只会入栈一个 macrotasks(宏任务), 主线程执行完成该任务后又会循环检查 microtasks(微任务) 队列是否还有未执行的，直到所有的执行完成后，再执行 macrotasks(宏任务)。 依次循环，直到所有的异步任务完成为止。&lt;/p&gt;
&lt;p&gt;有了上面 macrotasks(宏任务) 和 microtasks(微任务) 概念后，我们再来理解上面的代码，上面所有的代码都写在script标签中，那么读取script标签中的所有代码，它就是第一个宏任务，因此我们就开始执行第一个宏任务。因此首先打印 1， 然后代码往下读取，我们遇到setTimeout, 它就是第二个宏任务，会将它推入到 macrotasks(宏任务) 事件队列里面排队。&lt;br/&gt;下面我们继续往下读取，&lt;br/&gt;遇到Promise对象，在Promise内部执行它是同步的，因此会打印3, 4。 然后继续遇到 Promise.then 回调函数，他是一个 microtasks(微任务)的，因此将他 推入到 microtasks(微任务) 事件队列中，最后代码执行 console.log(6); 因此打印6. 第一个macrotasks(宏任务)执行完成后，然后我们会依次循环执行 microtasks(微任务), 直到最后一个为止，因此我们就执行 promise.then() 异步回调中的代码，因此打印5，那么此时此刻第一个 macrotasks(宏任务) 执行完毕，会执行下一个 macrotasks(宏任务)任务。因此就执行到 setTimeout函数了，最后就打印2。到此，所有的任务都执行完毕。因此我们最后的结果为：1, 3, 4, 6, 5, 2;&lt;/p&gt;
&lt;p&gt;我们可以继续多添加几个setTimeout函数和多加几个Promise对象来验证下，如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
  console.log(&lt;/span&gt;1&lt;span&gt;);
  setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;2&lt;span&gt;);
  }, &lt;/span&gt;10&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve) {
    console.log(&lt;/span&gt;3&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
      i &lt;/span&gt;=== 9999 &amp;amp;&amp;amp;&lt;span&gt; resolve();
    }
    console.log(&lt;/span&gt;4&lt;span&gt;);
  }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;5&lt;span&gt;);
  });
  setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;7&lt;span&gt;);
  },&lt;/span&gt;1&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve) {
    console.log(&lt;/span&gt;8&lt;span&gt;);
    resolve();
  }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;9&lt;span&gt;);
  });
  console.log(&lt;/span&gt;6&lt;span&gt;);
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上打印的结果为: 1, 3, 4, 8, 6, 5, 9, 7, 2;&lt;/p&gt;
&lt;p&gt;首先打印1，这是没有任何争议的哦，promise内部也是同步代码，因此打印 3, 4, 然后就是第二个promise内部代码，因此打印8，再打印外面的代码，就是6。因此主线程执行完成后，打印的结果分别为：&lt;/p&gt;
&lt;p&gt;1, 3, 4, 8, 6。 然后再执行 promise.then() 回调的 microtasks(微任务)。因此打印 5, 9。因此microtasks(微任务)执行完成后，就执行第二个宏任务setTimeout，由于第一个setTimeout是10毫秒后执行，第二个setTimeout是1毫秒后执行，因此1毫秒的优先级大于10毫秒的优先级，因此最后分别打印 7, 2 了。因此打印的结果是: 1, 3, 4, 8, 6, 5, 9, 7, 2;&lt;br/&gt;&lt;strong&gt;总结:&lt;/strong&gt; 如上我们也看到 microtasks(微任务) 包括 Promise 和 MutationObserver, 因此 我们可以知道在Vue中的nextTick 的执行速度上是快于setTimeout的。&lt;/p&gt;
&lt;p&gt;我们从如下demo也可以得到验证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;vue.nextTick()方法的使用&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;https://cn.vuejs.org/js/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
      el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      data: {
        name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kongzhi111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      },
      created() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印undefined&lt;/span&gt;
&lt;span&gt;        setTimeout(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
          console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印出 &quot;&amp;lt;div&amp;gt;kongzhi111&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;
&lt;span&gt;        }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$nextTick(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nextTick比setTimeout先执行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        });
      }
    })
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，先打印的是 undefiend, 其次是打印 &quot;nextTick比setTimeout先执行&quot; 信息, 最后打印出 &quot;&amp;lt;div&amp;gt;kongzhi111&amp;lt;/div&amp;gt;&quot; 信息。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;五：理解 MutationObserver&lt;/p&gt;
&lt;div readability=&quot;81.5&quot;&gt;
&lt;p&gt;在Vue中的nextTick的源码中，使用了3种情况来做延迟操作，首先会判断我们的设备是否支持Promsie对象，如果支持Promise对象，就使用Promise.then()异步函数来延迟，如果不支持，我们会继续判断我们的设备是否支持 MutationObserver, 如果支持，我们就使用 MutationObserver 来监听。最后如果上面两种都不支持的话，我们会使用 setTimeout 来处理，那么我们现在要理解的是 MutationObserver 是什么？&lt;br/&gt;&lt;strong&gt;5.1 MutationObserver是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MutationObserver 中文含义可以理解为 &quot;变动观察器&quot;。它是监听DOM变动的接口，DOM发生任何变动，MutationObserver会得到通知。在Vue中是通过该属性来监听DOM更新完毕的。&lt;/p&gt;
&lt;p&gt;它和事件类似，但有所不同，事件是同步的，当DOM发生变动时，事件会立刻处理，但是 MutationObserver 则是异步的，它不会立即处理，而是等页面上所有的DOM完成后，会执行一次，如果页面上要操作100次DOM的话，如果是事件的话会监听100次DOM，但是我们的 MutationObserver 只会执行一次，它是等待所有的DOM操作完成后，再执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它的特点是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 等待所有脚本任务完成后，才会执行，即采用异步方式。&lt;br/&gt;2. DOM的变动记录会封装成一个数组进行处理。&lt;br/&gt;3. 还可以观测发生在DOM的所有类型变动，也可以观测某一类变动。&lt;/p&gt;
&lt;p&gt;当然 MutationObserver 也是有浏览器兼容的，我们可以使用如下代码来检测浏览器是否支持该属性，如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; MutationObserver = window.MutationObserver || window.WebkitMutationObserver ||&lt;span&gt; window.MozMutationObserver;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监测浏览器是否支持&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; observeMutationSupport = !!MutationObserver;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;MutationObserver 构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们要使用 MutationObserver 构造函数的话，我们先要实列化 MutationObserver 构造函数，同时我们要指定该实列的回调函数，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt; MutationObserver(callback);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;观察器callback回调函数会在每次DOM发生变动后调用，它接收2个参数，第一个是变动的数组，第二个是观察器的实列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MutationObserver 实列的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;observe() 该方法是要观察DOM节点的变动的。该方法接收2个参数，第一个参数是要观察的DOM元素，第二个是要观察的变动类型。&lt;/p&gt;
&lt;p&gt;调用方式为：&lt;strong&gt;observer.observe(dom, options);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;options 类型有如下：&lt;/p&gt;
&lt;p&gt;childList: 子节点的变动。&lt;br/&gt;attributes: 属性的变动。&lt;br/&gt;characterData: 节点内容或节点文本的变动。&lt;br/&gt;subtree: 所有后代节点的变动。&lt;/p&gt;
&lt;p&gt;需要观察哪一种变动类型，需要在options对象中指定为true即可; 但是如果设置subtree的变动，必须同时指定childList, attributes, 和 characterData 中的一种或多种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 监听childList的变动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;MutationObserver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;kongzhi111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; MutationObserver &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; window.MutationObserver &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; window.WebkitMutationObserver &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; window.MozMutationObserver;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; Observer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(mutations, instance) {
      console.log(mutations);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印mutations 如下图对应的&lt;/span&gt;
&lt;span&gt;      console.log(instance);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印instance 如下图对于的&lt;/span&gt;
&lt;span&gt;      mutations.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(mutation){
        console.log(mutation); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印mutation&lt;/span&gt;
&lt;span&gt;      });
    });
    Observer.observe(list, {
      childList: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子节点的变动&lt;/span&gt;
&lt;span&gt;      subtree: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有后代节点的变动&lt;/span&gt;
&lt;span&gt;    });
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; li &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.createElement(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; textNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.createTextNode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kongzhi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    li.appendChild(textNode);
    list.appendChild(li);
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们使用了 observe() 方法来观察list节点的变化，只要list节点的子节点或后代的节点有任何变化都会触发 MutationObserver 构造函数的回调函数。因此就会打印该构造函数里面的数据。&lt;br/&gt;打印如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201910/561794-20191029064941726-1214465244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 监听characterData的变动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下测试代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;MutationObserver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;kongzhi111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; MutationObserver &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; window.MutationObserver &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; window.WebkitMutationObserver &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; window.MozMutationObserver;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; Observer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(mutations, instance) {
          mutations.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(mutation){
            console.log(mutation);
          });
        });
        Observer.observe(list, {
          childList: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子节点的变动&lt;/span&gt;
&lt;span&gt;          characterData: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点内容或节点文本变动&lt;/span&gt;
&lt;span&gt;          subtree: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有后代节点的变动&lt;/span&gt;
&lt;span&gt;        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变节点中的子节点中的数据&lt;/span&gt;
&lt;span&gt;        list.childNodes[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].data &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kongzhi222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印如下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201910/561794-20191029065024354-161170771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 监听属性的变动&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;MutationObserver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;kongzhi111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; MutationObserver &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; window.MutationObserver &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; window.WebkitMutationObserver &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; window.MozMutationObserver;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; Observer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(mutations, instance) {
      mutations.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(mutation){
        console.log(mutation);
      });
    });
    Observer.observe(list, {
      attributes: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    });
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点的属性，会触发回调函数&lt;/span&gt;
&lt;span&gt;    list.setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tugenhua111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新设置属性，会触发回调函数&lt;/span&gt;
&lt;span&gt;    list.setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tugenhua222&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除属性，也会触发回调函数&lt;/span&gt;
&lt;span&gt;    list.removeAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上就是MutationObserver的基本使用，它能监听 子节点的变动、属性的变动、节点内容或节点文本的变动 及 所有后代节点的变动。 下面我们来看下我们的 nextTick.js 中的源码是如何实现的。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;六：nextTick源码分析&lt;/p&gt;
&lt;p&gt;vue源码在 vue/src/core/util/next-tick.js 中。源码如下：&lt;/p&gt;
&lt;div readability=&quot;190&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
import { noop } from 'shared/util'&lt;span&gt;
import { handleError } from &lt;/span&gt;'./error'&lt;span&gt;
import { isIE, isIOS, isNative } from &lt;/span&gt;'./env'&lt;span&gt;
export let isUsingMicroTask &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
const callbacks &lt;/span&gt;=&lt;span&gt; []
let pending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; flushCallbacks () {
  pending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  const copies &lt;/span&gt;= callbacks.slice(0&lt;span&gt;)
  callbacks.length &lt;/span&gt;= 0
  &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; copies.length; i++&lt;span&gt;) {
    copies[i]()
  }
}
let timerFunc;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; isNative(Promise)) {
  const p &lt;/span&gt;=&lt;span&gt; Promise.resolve()
  timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    p.then(flushCallbacks)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isIOS) setTimeout(noop)
  }
  isUsingMicroTask &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!isIE &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; MutationObserver !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; (
  isNative(MutationObserver) &lt;/span&gt;||
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PhantomJS and iOS 7.x&lt;/span&gt;
  MutationObserver.toString() === '[object MutationObserverConstructor]'&lt;span&gt;
)) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use MutationObserver where native Promise is not available,&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g. PhantomJS, iOS7, Android 4.4&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (#6466 MutationObserver is unreliable in IE11)&lt;/span&gt;
  let counter = 1&lt;span&gt;
  const observer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(flushCallbacks)
  const textNode &lt;/span&gt;=&lt;span&gt; document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  })
  timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    counter &lt;/span&gt;= (counter + 1) % 2&lt;span&gt;
    textNode.data &lt;/span&gt;=&lt;span&gt; String(counter)
  }
  isUsingMicroTask &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; setImmediate !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; isNative(setImmediate)) {
  timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    setImmediate(flushCallbacks)
  }
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fallback to setTimeout.&lt;/span&gt;
  timerFunc = () =&amp;gt;&lt;span&gt; {
    setTimeout(flushCallbacks, &lt;/span&gt;0&lt;span&gt;)
  }
}
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; nextTick (cb?: Function, ctx?&lt;span&gt;: Object) {
  let _resolve
  callbacks.push(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cb) {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        cb.call(ctx)
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
        handleError(e, ctx, &lt;/span&gt;'nextTick'&lt;span&gt;)
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_resolve) {
      _resolve(ctx)
    }
  })
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pending) {
    pending &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    timerFunc()
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $flow-disable-line&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!cb &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
      _resolve &lt;/span&gt;=&lt;span&gt; resolve
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们从上往下看，首先定义变量 callbacks = []; 该变量的作用是: 用来存储所有需要执行的回调函数。let pending = false; 该变量的作用是表示状态，判断是否有正在执行的回调函数。&lt;br/&gt;也可以理解为，如果代码中 timerFunc 函数被推送到任务队列中去则不需要重复推送。&lt;/p&gt;
&lt;p&gt;flushCallbacks() 函数，该函数的作用是用来执行callbacks里面存储的所有回调函数。如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; flushCallbacks () {
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   设置 pending 为 false, 说明该 函数已经被推入到任务队列或主线程中。需要等待当前
   栈执行完毕后再执行。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  pending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝一个callbacks函数数组的副本&lt;/span&gt;
  const copies = callbacks.slice(0&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把函数数组清空&lt;/span&gt;
  callbacks.length = 0
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环该函数数组，依次执行。&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; copies.length; i++&lt;span&gt;) {
    copies[i]()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;timerFunc: 保存需要被执行的函数。&lt;/p&gt;
&lt;p&gt;继续看接下来的代码，我们上面讲解过，在Vue中使用了几种情况来延迟调用该函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. promise.then 延迟调用,&lt;/strong&gt; 基本代码如下: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; isNative(Promise)) {
  const p &lt;/span&gt;=&lt;span&gt; Promise.resolve()
  timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    p.then(flushCallbacks)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isIOS) setTimeout(noop)
  }
  isUsingMicroTask &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码的含义是: 如果我们的设备(或叫浏览器)支持Promise, 那么我们就使用 Promise.then的方式来延迟函数的调用。Promise.then会将函数延迟到调用栈的最末端，从而会做到延迟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. MutationObserver 监听,&lt;/strong&gt; 基本代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!isIE &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; MutationObserver !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; (
  isNative(MutationObserver) &lt;/span&gt;||
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PhantomJS and iOS 7.x&lt;/span&gt;
  MutationObserver.toString() === '[object MutationObserverConstructor]'&lt;span&gt;
)) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use MutationObserver where native Promise is not available,&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g. PhantomJS, iOS7, Android 4.4&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (#6466 MutationObserver is unreliable in IE11)&lt;/span&gt;
  let counter = 1&lt;span&gt;
  const observer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(flushCallbacks)
  const textNode &lt;/span&gt;=&lt;span&gt; document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  })
  timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    counter &lt;/span&gt;= (counter + 1) % 2&lt;span&gt;
    textNode.data &lt;/span&gt;=&lt;span&gt; String(counter)
  }
  isUsingMicroTask &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，首先也是判断我们的设备是否支持 MutationObserver 对象, 如果支持的话，我们就会创建一个MutationObserver构造函数, 并且把flushCallbacks函数当做callback的回调, 然后我们会创建一个文本节点, 之后会使用MutationObserver对象的observe来监听该文本节点, 如果文本节点的内容有任何变动的话，它就会触发 flushCallbacks 回调函数。那么要怎么样触发呢? 在该代码内有一个 timerFunc 函数, 如果我们触发该函数, 会导致文本节点的数据发生改变，进而触发MutationObserver构造函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. setImmediate 监听,&lt;/strong&gt; 基本代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; setImmediate !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; isNative(setImmediate)) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fallback to setImmediate.&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Techinically it leverages the (macro) task queue,&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; but it is still a better choice than setTimeout.&lt;/span&gt;
  timerFunc = () =&amp;gt;&lt;span&gt; {
    setImmediate(flushCallbacks)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果上面的 Promise 和 MutationObserver 都不支持的话, 我们继续会判断设备是否支持 setImmediate, 我们上面分析过, 他属于 macrotasks(宏任务)的。该任务会在一个宏任务里执行回调队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 使用setTimeout 做降级处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们上面三种情况, 设备都不支持的话, 我们会使用 setTimeout 来做降级处理, 实现延迟效果。如下基本代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fallback to setTimeout.&lt;/span&gt;
  timerFunc = () =&amp;gt;&lt;span&gt; {
    setTimeout(flushCallbacks, &lt;/span&gt;0&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们的源码继续往下看, 会看到我们的nextTick函数被export了，如下基本代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt; nextTick (cb?: Function, ctx?&lt;span&gt;: Object) {
  let _resolve
  callbacks.push(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cb) {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        cb.call(ctx)
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
        handleError(e, ctx, &lt;/span&gt;'nextTick'&lt;span&gt;)
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_resolve) {
      _resolve(ctx)
    }
  })
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pending) {
    pending &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    timerFunc()
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $flow-disable-line&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!cb &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
      _resolve &lt;/span&gt;=&lt;span&gt; resolve
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码, nextTick 函数接收2个参数，cb 是一个回调函数, ctx 是一个上下文。 首先会把它存入callbacks函数数组里面去, 在函数内部会判断cb是否是一个函数，如果是一个函数，就调用执行该函数，当然它会在callbacks函数数组遍历的时候才会被执行。其次 如果cb不是一个函数的话, 那么会判断是否有_resolve值, 有该值就使用Promise.then() 这样的方式来调用。比如: this.$nextTick().then(cb) 这样的使用方式。因此在下面的if语句内会判断赋值给_resolve：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (!cb &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined'&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
    _resolve &lt;/span&gt;=&lt;span&gt; resolve
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Promise返回了一个 fulfilled 的Promise。赋值给 _resolve; 然后在callbacks.push 中会执行如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
_resolve(ctx);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;全局方法Vue.nextTick在 /src/core/global-api/index.js 中声明，是对函数nextTick的引用，所以使用时可以显式指定执行上下文。代码初始化如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Vue.nextTick = nextTick;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以使用如下的一个简单的demo来简化上面的代码。如下demo:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  &lt;span&gt;var&lt;/span&gt; callbacks =&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pending = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timerFunc() {
    const copies &lt;/span&gt;= callbacks.slice(0&lt;span&gt;)
    callbacks.length &lt;/span&gt;= 0
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; copies.length; i++&lt;span&gt;) {
      copies[i]()
    }
  }
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; nextTick(cb, ctx) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _resolve;
    callbacks.push(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cb) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          cb.call(ctx)
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
          handleError(e, ctx, &lt;/span&gt;'nextTick'&lt;span&gt;)
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_resolve) {
        _resolve(ctx)
      }
    });
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pending) {
      pending &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      timerFunc()
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $flow-disable-line&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!cb &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
        _resolve &lt;/span&gt;=&lt;span&gt; resolve
      })
    }
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用方式如下:&lt;/span&gt;
  nextTick(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'打印出来了'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 会被执行打印&lt;/span&gt;
&lt;span&gt;  });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上我们已经知道了 nextTick 是Vue中的一个全局函数, 在Vue里面会有一个Watcher, 它用于观察数据的变化, 然后更新DOM, 但是在Vue中并不是每次数据改变都会触发更新DOM的, 而是将这些操作都缓存到一个队列中, 在一个事件循环结束后, 会刷新队列, 会统一执行DOM的更新操作。&lt;/p&gt;
&lt;p&gt;在Vue中使用的是Object.defineProperty来监听每个对象属性数据变化的, 当监听到数据发生变化的时候, 我们需要把该消息通知到所有的订阅者, 也就是Dep, 那么Dep则会调用它管理的所有的Watch对象，因此会调用Watch对象中的update方法, 我们可以看下源码中的update的实现。源码在 vue/src/core/observer/watcher.js 中如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update () {
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore else &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lazy) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dirty = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sync) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步执行渲染视图&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.run()
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步推送到观察者队列中&lt;/span&gt;
    queueWatcher(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码我们可以看到, 在Vue中它默认是使用异步执行DOM更新的。当异步执行update的时候，它默认会调用 queueWatcher 函数。&lt;/p&gt;
&lt;p&gt;我们下面再来看下该 queueWatcher 函数代码如下: (源码在: vue/src/core/observer/scheduler.js) 中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; queueWatcher (watcher: Watcher) {
  const id &lt;/span&gt;=&lt;span&gt; watcher.id
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (has[id] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    has[id] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flushing) {
      queue.push(watcher)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if already flushing, splice the watcher based on its id&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if already past its id, it will be run next immediately.&lt;/span&gt;
      let i = queue.length - 1
      &lt;span&gt;while&lt;/span&gt; (i &amp;gt; index &amp;amp;&amp;amp; queue[i].id &amp;gt;&lt;span&gt; watcher.id) {
        i&lt;/span&gt;--&lt;span&gt;
      }
      queue.splice(i &lt;/span&gt;+ 1, 0&lt;span&gt;, watcher)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; queue the flush&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;waiting) {
      waiting &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;

      &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production' &amp;amp;&amp;amp; !&lt;span&gt;config.async) {
        flushSchedulerQueue()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      }
      nextTick(flushSchedulerQueue)
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上源码, 我们从第一句代码执行过来, 首先获取该 id = watcher.id; 然后判断该id是否存在 if (has[id] == null) {} , 如果已经存在则直接跳过,不存在则执行if&lt;br/&gt;语句内部代码, 并且标记哈希表has[id] = true; 用于下次检验。如果 flushing 为false的话, 则把该watcher对象push到队列中, 考虑到一些情况, 比如正在更新队列中&lt;br/&gt;的watcher时, 又有事件塞入进来怎么处理? 因此这边加了一个flushing来表示队列的更新状态。&lt;/p&gt;
&lt;p&gt;如果加入队列到更新状态时，又分为两种情况:&lt;/p&gt;
&lt;p&gt;1. 这个watcher还没有处理, 就找到这个watcher在队列中的位置, 并且把新的放在后面, 比如如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flushing) {
  queue.push(watcher)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 如果watcher已经更新过了, 就把这个watcher再放到当前执行的下一位, 当前的watcher处理完成后, 立即会处理这个最新的。如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if already flushing, splice the watcher based on its id&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if already past its id, it will be run next immediately.&lt;/span&gt;
  let i = queue.length - 1
  &lt;span&gt;while&lt;/span&gt; (i &amp;gt; index &amp;amp;&amp;amp; queue[i].id &amp;gt;&lt;span&gt; watcher.id) {
    i&lt;/span&gt;--&lt;span&gt;
  }
  queue.splice(i &lt;/span&gt;+ 1, 0&lt;span&gt;, watcher)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;waiting) {
  waiting &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;

  &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production' &amp;amp;&amp;amp; !&lt;span&gt;config.async) {
    flushSchedulerQueue()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
  }
  nextTick(flushSchedulerQueue)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;waiting 为false, 等待下一个tick时, 会执行刷新队列。 如果不是正式环境的话, 会直接 调用该函数 flushSchedulerQueue; (源码在: vue/src/core/observer/scheduler.js) 中。否则的话,  把该函数放入 nextTick 函数延迟处理。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 28 Oct 2019 22:57:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>Vue系列---理解Vue.nextTick使用及源码分析(五)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/11756584.html</dc:identifier>
</item>
<item>
<title>Django框架篇-13用户认证组件 - 郭少</title>
<link>http://www.cnblogs.com/897463196-a/p/11756558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/897463196-a/p/11756558.html</guid>
<description>[unable to retrieve full-text content]用户认证 auth模块 django.contrib.auth中提供了许多方法，这里主要介绍其中的三个： 1.1 、authenticate() 提供了用户认证，即验证用户名以及密码是否正确,一般需要username password两个关键字参数 如果认证信息有效，会返回一个 User 对象。au</description>
<pubDate>Mon, 28 Oct 2019 19:47:00 +0000</pubDate>
<dc:creator>郭少</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https://www.cnblogs.com/897463196-a/p/11756558.html</dc:identifier>
</item>
<item>
<title>Java 中的 final、finally、finalize 有什么不同？ - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/11756472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/11756472.html</guid>
<description>&lt;p&gt;Java 中 final、finally、finalize 有什么不同？这是在 Java 面试中经常问到的问题，他们究竟有什么不同呢？&lt;/p&gt;
&lt;p&gt;这三个看起来很相似，其实他们的关系就像卡巴斯基和巴基斯坦一样有基巴关系。&lt;/p&gt;
&lt;p&gt;那么如果被问到这个问题该怎么回答呢？首先可以从语法和使用角度出发简单介绍三者的不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。&lt;/li&gt;
&lt;li&gt;finally 是 Java 保证重点代码一定要被执行的一种机制。可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。&lt;/li&gt;
&lt;li&gt;finalize 是基础类 java.lang.Object 的一个方法，设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果只回答到这里，就会没有亮点，我们可以再深入地去介绍三者的不同，比如从性能、并发、对象生命周期或垃圾收集基本过程等方面去谈谈自己的理解。&lt;/p&gt;

&lt;p&gt;使用 final 关键字可以明确表示代码的语义、逻辑意图，比如：&lt;/p&gt;
&lt;p&gt;可以将方法或者类声明为 final，这样就可以明确告知别人，这些行为是不许修改的。&lt;br/&gt;Java 核心类库的定义或源码，比如 java.lang 包下面的很多类，相当一部分都被声明成为 final class，比如我们常见的 String 类，在第三方类库的一些基础类中同样如此，这可以有效避免 API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。&lt;/p&gt;
&lt;p&gt;使用 final 修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成 final。&lt;/p&gt;
&lt;p&gt;final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。&lt;/p&gt;
&lt;p&gt;关于 final 也许会有性能的好处，很多文章或者书籍中都介绍了可在特定场景提高性能，比如，利用 final 可能有助于 JVM 将方法进行内联，可以改善编译器进行条件编译的能力等等。我在之前一篇文章进行了介绍，想了解的可以点击查阅。&lt;/p&gt;
&lt;p&gt;扩展阅读：&lt;a href=&quot;https://blog.csdn.net/qq_27276045/article/details/102774119&quot;&gt;深入理解 Java 中的 final 关键字&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;final-与-immutable&quot;&gt;final 与 immutable&lt;/h2&gt;
&lt;p&gt;在前面介绍了 final 在实践中的益处，需要注意的是，final 并不等同于 immutable，比如下面这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final List&amp;lt;String&amp;gt; strList = new ArrayList&amp;lt;&amp;gt;();
strList.add(&quot;wupx&quot;);
strList.add(&quot;huxy&quot;);  
List&amp;lt;String&amp;gt; loveList = List.of(&quot;wupx&quot;, &quot;huxy&quot;);
loveList.add(&quot;love&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;final 只能约束 strList 这个引用不可以被赋值，但是 strList 对象行为不被 final 影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面这个例子中，List.of 方法创建的本身就是不可变 List，最后那句 add 是会在运行时抛出异常的。&lt;/p&gt;
&lt;p&gt;Immutable 在很多场景是非常棒的选择，某种意义上说，Java 语言目前并没有原生的不可变支持，如果要实现 immutable 的类，我们需要做到：&lt;/p&gt;
&lt;p&gt;将 class 自身声明为 final，这样别人就不能扩展来绕过限制了。&lt;/p&gt;
&lt;p&gt;将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。&lt;/p&gt;
&lt;p&gt;通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。&lt;/p&gt;
&lt;p&gt;如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，使用 copy-on-write 原则，创建私有的 copy。&lt;/p&gt;
&lt;p&gt;关于 setter/getter 方法，很多人喜欢直接用 IDE 或者 Lombok 一次全部生成，建议最好确定有需要时再实现。&lt;/p&gt;

&lt;p&gt;对于 finally，知道怎么使用就足够了。需要关闭的连接等资源，更推荐使用 Java 7 中添加的 try-with-resources 语句，因为通常 Java 平台能够更好地处理异常情况，还可以减少代码量。&lt;/p&gt;
&lt;p&gt;另外，有一些常被考到的 finally 问题。比如，下面代码会输出什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try {
  // do something
  System.exit(1);
} finally{
  System.out.println(&quot;Hello，I am finally。&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面 finally 里面的代码是不会被执行的，因为 try-catch 异常退出了。&lt;/p&gt;
&lt;p&gt;像其他 finally 中的代码不会执行的情况还有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 死循环
try{
    while(ture){
        System.out.println(&quot;always run&quot;);
    }
}finally{
    System.out.println(&quot;ummm&quot;);
}

// 线程被杀死
当执行 try-finally 的线程被杀死时，finally 中的代码也无法执行。&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;对于 finalize，是不推荐使用的，在 Java 9 中，已经将 Object.finalize() 标记为 deprecated。&lt;/p&gt;
&lt;p&gt;为什么呢？因为无法保证 finalize 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。&lt;/p&gt;
&lt;p&gt;通常来说，利用上面的提到的 try-with-resources 或者 try-finally 机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑 Java 提供的 Cleaner 机制或者其他替代方法。&lt;/p&gt;
&lt;h2 id=&quot;为什么不推荐使用-finalize&quot;&gt;为什么不推荐使用 finalize？&lt;/h2&gt;
&lt;p&gt;前面简单介绍了 finalize 是不推荐使用的，究竟为什么不推荐使用呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;finalize 的执行是和垃圾收集关联在一起的，一旦实现了非空的 finalize 方法，就会导致相应对象回收呈现数量级上的变慢。&lt;/li&gt;
&lt;li&gt;finalize 被设计成在对象被垃圾收集前调用，JVM 要对它进行额外处理。finalize 本质上成为了快速回收的阻碍者，可能导致对象经过多个垃圾收集周期才能被回收。&lt;/li&gt;
&lt;li&gt;finalize 拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致 OOM 的原因。&lt;/li&gt;
&lt;li&gt;要确保回收资源就是因为资源都是有限的，垃圾收集时间的不可预测，可能会极大加剧资源占用。&lt;/li&gt;
&lt;li&gt;finalize 会掩盖资源回收时的出错信息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此对于消耗非常高频的资源，千万不要指望 finalize 去承担资源释放的主要职责。建议资源用完即显式释放，或者利用资源池来尽量重用。&lt;/p&gt;
&lt;p&gt;下面给出 finalize 掩盖资源回收时的出错信息的例子，让我们来看 java.lang.ref.Finalizer 的源代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void runFinalizer(JavaLangAccess jla) {
    //  ... 省略部分代码
    try {
        Object finalizee = this.get(); 
        if (finalizee != null &amp;amp;&amp;amp; !(finalizee instanceof java.lang.Enum)) {
           jla.invokeFinalize(finalizee);
           // Clear stack slot containing this variable, to decrease
           // the chances of false retention with a conservative GC
           finalizee = null;
        }
    } catch (Throwable x) { }
        super.clear(); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看过之前讲解异常文章的朋友，应该可以很快看出 Throwable 是被吞掉的，也就意味着一旦出现异常或者出错，得不到任何有效信息。&lt;/p&gt;
&lt;p&gt;扩展阅读：&lt;a href=&quot;https://blog.csdn.net/qq_27276045/article/details/102762241&quot;&gt;Java 异常处理的 20 个最佳实践，你知道几个？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;有更好的方法替代-finalize-吗&quot;&gt;有更好的方法替代 finalize 吗？&lt;/h2&gt;
&lt;p&gt;Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻象引用（PhantomReference），这是一种常见的所谓 post-mortem 清理机制。利用幻象引用和引用队列，可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的资源），它比 finalize 更加轻量、更加可靠。&lt;/p&gt;
&lt;p&gt;每个 Cleaner 的操作都是独立的，有自己的运行线程，所以可以避免意外死锁等问题。&lt;/p&gt;
&lt;p&gt;我们可以为自己的模块构建一个 Cleaner，然后实现相应的清理逻辑，具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Cleaner 是一个用于关闭资源的类，功能类似 finalize 方法
 * Cleaner 有自己的线程，在所有清理操作完成后，自己会被 GC
 * 清理中抛出的异常会被忽略
 * 
 * 清理方法（一个 Runnable）只会运行一次。会在两种情况下运行：
 * 1. 注册的 Object 处于幻象引用状态
 * 2. 显式调用 clean 方法
 * 
 * 通过幻象引用和引用队列实现
 * 可以注册多个对象，通常被定义为静态（减少线程数量）
 * 注册对象后返回的Cleanable对象用于显式调用 clean 方法
 * 实现清理行为的对象（下面的 state），不能拥有被清理对象的引用
 * 如果将下面的 State 类改为非静态，第二个 CleaningExample 将不会被 clean，
 * 因为非静态内部类持有外部对象的引用，外部对象无法进入幻象引用状态
 */
public class CleaningExample implements AutoCloseable {

    public static void main(String[] args) {
        try {
            // 使用JDK7的try with Resources显式调用clean方法
            try (CleaningExample ignored = new CleaningExample()) {
                throw new RuntimeException();
            }
        } catch (RuntimeException ignored) {
        }

        // 通过GC调用clean方法
        new CleaningExample();
        System.gc();
    }

    private static final Cleaner CLEANER = Cleaner.create();

    // 如果是非静态内部类，则会出错
    static class State implements Runnable {
        State() {
        }

        @Override
        public void run() {
            System.out.println(&quot;Cleaning called&quot;);
        }
    }

    private final State state;
    private final Cleaner.Cleanable cleanable;

    public CleaningExample() {
        this.state = new State();
        this.cleanable = CLEANER.register(this, state);
    }

    @Override
    public void close() {
        cleanable.clean();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。&lt;/p&gt;
&lt;p&gt;从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致幻象引用堆积，同样会出现问题。所以，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收。&lt;/p&gt;

&lt;p&gt;这篇文章首先从从语法角度分析了 final、finally、finalize，并从安全、性能、垃圾收集等方面逐步深入，详细地讲解了 final、finally、finalize 三者的区别。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201910/1356806-20191029001911060-30735410.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Oct 2019 16:19:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>Java 中 final、finally、finalize 有什么不同？这是在 Java 面试中经常问到的问题，他们究竟有什么不同呢？ 这三个看起来很相似，其实他们的关系就像卡巴斯基和巴基斯坦一样有基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/11756472.html</dc:identifier>
</item>
<item>
<title>MyBatis之启动分析（一） - ytao-杨滔</title>
<link>http://www.cnblogs.com/ytao-blog/p/11756456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ytao-blog/p/11756456.html</guid>
<description>[unable to retrieve full-text content]MyBatis 的初始化工作就是解析主配置文件，映射配置文件以及注解信息。</description>
<pubDate>Mon, 28 Oct 2019 16:09:00 +0000</pubDate>
<dc:creator>ytao-杨滔</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https://www.cnblogs.com/ytao-blog/p/11756456.html</dc:identifier>
</item>
<item>
<title>动手造轮子：实现一个简单的依赖注入(一) - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/implement-dependency-injection-01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/implement-dependency-injection-01.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;在上一篇文章中主要介绍了一下要做的依赖注入的整体设计和大概编程体验，这篇文章要开始写代码了，开始实现自己的依赖注入框架。&lt;/p&gt;
&lt;h2 id=&quot;类图&quot;&gt;类图&lt;/h2&gt;
&lt;p&gt;首先来温习一下上次提到的类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201910/489462-20191027161747492-358829271.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务生命周期&quot;&gt;服务生命周期&lt;/h2&gt;
&lt;p&gt;服务生命周期定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public enum ServiceLifetime : sbyte
{
    /// &amp;lt;summary&amp;gt;
    /// Specifies that a single instance of the service will be created.
    /// &amp;lt;/summary&amp;gt;
    Singleton = 0,

    /// &amp;lt;summary&amp;gt;
    /// Specifies that a new instance of the service will be created for each scope.
    /// &amp;lt;/summary&amp;gt;
    Scoped = 1,

    /// &amp;lt;summary&amp;gt;
    /// Specifies that a new instance of the service will be created every time it is requested.
    /// &amp;lt;/summary&amp;gt;
    Transient = 2,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;服务定义&quot;&gt;服务定义&lt;/h2&gt;
&lt;p&gt;服务注册定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceDefinition
{
    // 服务生命周期
    public ServiceLifetime ServiceLifetime { get; }
    // 实现类型
    public Type ImplementType { get; }
    // 服务类型
    public Type ServiceType { get; }
    // 实现实例
    public object ImplementationInstance { get; }
    // 实现工厂
    public Func&amp;lt;IServiceProvider, object&amp;gt; ImplementationFactory { get; }

    // 获取真实的实现类型
    public Type GetImplementType()
    {
        if (ImplementationInstance != null)
            return ImplementationInstance.GetType();

        if (ImplementationFactory != null)
            return ImplementationFactory.Method.DeclaringType;

        if (ImplementType != null)
            return ImplementType;

        return ServiceType;
    }

    public ServiceDefinition(object instance, Type serviceType)
    {
        ImplementationInstance = instance;
        ServiceType = serviceType;
        ServiceLifetime = ServiceLifetime.Singleton;
    }

    public ServiceDefinition(Type serviceType, ServiceLifetime serviceLifetime) : this(serviceType, serviceType, serviceLifetime)
    {
    }

    public ServiceDefinition(Type serviceType, Type implementType, ServiceLifetime serviceLifetime)
    {
        ServiceType = serviceType;
        ImplementType = implementType ?? serviceType;
        ServiceLifetime = serviceLifetime;
    }

    public ServiceDefinition(Type serviceType, Func&amp;lt;IServiceProvider, object&amp;gt; factory, ServiceLifetime serviceLifetime)
    {
        ServiceType = serviceType;
        ImplementationFactory = factory;
        ServiceLifetime = serviceLifetime;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了使用起来更方便添加了一些静态方法&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static ServiceDefinition Singleton&amp;lt;TService&amp;gt;(Func&amp;lt;IServiceProvider, object&amp;gt; factory)
{
    return new ServiceDefinition(typeof(TService), factory, ServiceLifetime.Singleton);
}

public static ServiceDefinition Scoped&amp;lt;TService&amp;gt;(Func&amp;lt;IServiceProvider, object&amp;gt; factory)
{
    return new ServiceDefinition(typeof(TService), factory, ServiceLifetime.Scoped);
}

public static ServiceDefinition Transient&amp;lt;TService&amp;gt;(Func&amp;lt;IServiceProvider, object&amp;gt; factory)
{
    return new ServiceDefinition(typeof(TService), factory, ServiceLifetime.Transient);
}

public static ServiceDefinition Singleton&amp;lt;TService&amp;gt;()
{
    return new ServiceDefinition(typeof(TService), ServiceLifetime.Singleton);
}

public static ServiceDefinition Scoped&amp;lt;TService&amp;gt;()
{
    return new ServiceDefinition(typeof(TService), ServiceLifetime.Scoped);
}

public static ServiceDefinition Transient&amp;lt;TService&amp;gt;()
{
    return new ServiceDefinition(typeof(TService), ServiceLifetime.Transient);
}

public static ServiceDefinition Singleton&amp;lt;TService, TServiceImplement&amp;gt;() where TServiceImplement : TService
{
    return new ServiceDefinition(typeof(TService), typeof(TServiceImplement), ServiceLifetime.Singleton);
}

public static ServiceDefinition Scoped&amp;lt;TService, TServiceImplement&amp;gt;() where TServiceImplement : TService
{
    return new ServiceDefinition(typeof(TService), typeof(TServiceImplement), ServiceLifetime.Scoped);
}

public static ServiceDefinition Transient&amp;lt;TService, TServiceImplement&amp;gt;() where TServiceImplement : TService
{
    return new ServiceDefinition(typeof(TService), typeof(TServiceImplement), ServiceLifetime.Transient);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;servicecontainer&quot;&gt;ServiceContainer&lt;/h2&gt;
&lt;h3 id=&quot;servicecontainer-v1&quot;&gt;serviceContainer v1&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceContainer : IServiceContainer
{
    internal readonly List&amp;lt;ServiceDefinition&amp;gt; _services;

    private readonly ConcurrentDictionary&amp;lt;Type, object&amp;gt; _singletonInstances;

    private readonly ConcurrentDictionary&amp;lt;Type, object&amp;gt; _scopedInstances;
    
    private readonly List&amp;lt;object&amp;gt; _transientDisposables = new List&amp;lt;object&amp;gt;();

    private readonly bool _isRootScope;

    public ServiceContainer()
    {
        _isRootScope = true;
        _singletonInstances = new ConcurrentDictionary&amp;lt;Type, object&amp;gt;();
        _services = new List&amp;lt;ServiceDefinition&amp;gt;();
    }

    internal ServiceContainer(ServiceContainer serviceContainer)
    {
        _isRootScope = false;
        _singletonInstances = serviceContainer._singletonInstances;
        _services = serviceContainer._services;
        _scopedInstances = new ConcurrentDictionary&amp;lt;Type, object&amp;gt;();
    }

    public void Add(ServiceDefinition item)
    {
        _services.Add(item);
    }

    public IServiceContainer CreateScope()
    {
        return new ServiceContainer(this);
    }

    private bool _disposed;

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        if (_isRootScope)
        {
            lock (_singletonInstances)
            {
                if (_disposed)
                {
                    return;
                }

                _disposed = true;
                foreach (var instance in _singletonInstances.Values)
                {
                    (instance as IDisposable)?.Dispose();
                }

                foreach (var o in _transientDisposables)
                {
                    (o as IDisposable)?.Dispose();
                }
            }
        }
        else
        {
            lock (_scopedInstances)
            {
                if (_disposed)
                {
                    return;
                }

                _disposed = true;
                foreach (var instance in _scopedInstances.Values)
                {
                    (instance as IDisposable)?.Dispose();
                }

                foreach (var o in _transientDisposables)
                {
                    (o as IDisposable)?.Dispose();
                }
            }
        }
    }

    private object GetServiceInstance(Type serviceType, ServiceDefinition serviceDefinition)
    {
        if (serviceDefinition.ImplementationInstance != null)
            return serviceDefinition.ImplementationInstance;

        if (serviceDefinition.ImplementationFactory != null)
            return serviceDefinition.ImplementationFactory.Invoke(this);

        var implementType = (serviceDefinition.ImplementType ?? serviceType);

        if (implementType.IsInterface || implementType.IsAbstract)
        {
            throw new InvalidOperationException($&quot;invalid service registered, serviceType: {serviceType.FullName}, implementType: {serviceDefinition.ImplementType}&quot;);
        }

        var ctorInfos = implementType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
        if (ctorInfos.Length == 0)
        {
            throw new InvalidOperationException($&quot;service {serviceType.FullName} does not have any public constructors&quot;);
        }

        ConstructorInfo ctor;
        if (ctorInfos.Length == 1)
        {
            ctor = ctorInfos[0];
        }
        else
        {
            // try find best ctor
            ctor = ctorInfos
                .OrderBy(_ =&amp;gt; _.GetParameters().Length)
                .First();
        }

        var parameters = ctor.GetParameters();
        if (parameters.Length == 0)
        {
            // TODO: cache New Func
            return Expression.Lambda&amp;lt;Func&amp;lt;object&amp;gt;&amp;gt;(Expression.New(ctor)).Compile().Invoke();
        }
        else
        {
            var ctorParams = new object[parameters.Length];
            for (var index = 0; index &amp;lt; parameters.Length; index++)
            {
                var parameter = parameters[index];
                var param = GetService(parameter.ParameterType);
                if (param == null &amp;amp;&amp;amp; parameter.HasDefaultValue)
                {
                    param = parameter.DefaultValue;
                }

                ctorParams[index] = param;
            }
            return Expression.Lambda&amp;lt;Func&amp;lt;object&amp;gt;&amp;gt;(Expression.New(ctor, ctorParams.Select(Expression.Constant))).Compile().Invoke();
        }
    }

    public object GetService(Type serviceType)
    {
        var serviceDefinition = _services.LastOrDefault(_ =&amp;gt; _.ServiceType == serviceType);
        if (null == serviceDefinition)
        {
            return null;
        }

        if (_isRootScope &amp;amp;&amp;amp; serviceDefinition.ServiceLifetime == ServiceLifetime.Scoped)
        {
            throw new InvalidOperationException($&quot;can not get scope service from the root scope, serviceType: {serviceType.FullName}&quot;);
        }

        if (serviceDefinition.ServiceLifetime == ServiceLifetime.Singleton)
        {
            var svc = _singletonInstances.GetOrAdd(serviceType, (t) =&amp;gt; GetServiceInstance(t, serviceDefinition));
            return svc;
        }
        else if (serviceDefinition.ServiceLifetime == ServiceLifetime.Scoped)
        {
            var svc = _scopedInstances.GetOrAdd(serviceType, (t) =&amp;gt; GetServiceInstance(t, serviceDefinition));
            return svc;
        }
        else
        {
            var svc = GetServiceInstance(serviceType, serviceDefinition);
            if (svc is IDisposable)
            {
                _transientDisposables.Add(svc);
            }
            return svc;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了使得服务注册更加方便，可以写一些扩展方法来方便注册：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IServiceContainer AddSingleton&amp;lt;TService&amp;gt;([NotNull]this IServiceContainer serviceContainer, [NotNull]TService service)
{
    serviceContainer.Add(new ServiceDefinition(service, typeof(TService)));
    return serviceContainer;
}

public static IServiceContainer AddSingleton([NotNull]this IServiceContainer serviceContainer, [NotNull]Type serviceType)
{
    serviceContainer.Add(new ServiceDefinition(serviceType, ServiceLifetime.Singleton));
    return serviceContainer;
}

public static IServiceContainer AddSingleton([NotNull]this IServiceContainer serviceContainer, [NotNull]Type serviceType, [NotNull]Type implementType)
{
    serviceContainer.Add(new ServiceDefinition(serviceType, implementType, ServiceLifetime.Singleton));
    return serviceContainer;
}

public static IServiceContainer AddSingleton&amp;lt;TService&amp;gt;([NotNull]this IServiceContainer serviceContainer, [NotNull]Func&amp;lt;IServiceProvider, object&amp;gt; func)
{
    serviceContainer.Add(ServiceDefinition.Singleton&amp;lt;TService&amp;gt;(func));
    return serviceContainer;
}


public static IServiceContainer AddSingleton&amp;lt;TService&amp;gt;([NotNull]this IServiceContainer serviceContainer)
{
    serviceContainer.Add(ServiceDefinition.Singleton&amp;lt;TService&amp;gt;());
    return serviceContainer;
}


public static IServiceContainer AddSingleton&amp;lt;TService, TServiceImplement&amp;gt;([NotNull]this IServiceContainer serviceContainer) where TServiceImplement : TService
{
    serviceContainer.Add(ServiceDefinition.Singleton&amp;lt;TService, TServiceImplement&amp;gt;());
    return serviceContainer;
}

public static IServiceContainer AddScoped([NotNull]this IServiceContainer serviceContainer, [NotNull]Type serviceType)
{
    serviceContainer.Add(new ServiceDefinition(serviceType, ServiceLifetime.Scoped));
    return serviceContainer;
}

public static IServiceContainer AddScoped([NotNull]this IServiceContainer serviceContainer, [NotNull]Type serviceType, [NotNull]Type implementType)
{
    serviceContainer.Add(new ServiceDefinition(serviceType, implementType, ServiceLifetime.Scoped));
    return serviceContainer;
}

public static IServiceContainer AddScoped&amp;lt;TService&amp;gt;([NotNull]this IServiceContainer serviceContainer, [NotNull]Func&amp;lt;IServiceProvider, object&amp;gt; func)
{
    serviceContainer.Add(ServiceDefinition.Scoped&amp;lt;TService&amp;gt;(func));
    return serviceContainer;
}


public static IServiceContainer AddScoped&amp;lt;TService&amp;gt;([NotNull]this IServiceContainer serviceContainer)
{
    serviceContainer.Add(ServiceDefinition.Scoped&amp;lt;TService&amp;gt;());
    return serviceContainer;
}


public static IServiceContainer AddScoped&amp;lt;TService, TServiceImplement&amp;gt;([NotNull]this IServiceContainer serviceContainer) where TServiceImplement : TService
{
    serviceContainer.Add(ServiceDefinition.Scoped&amp;lt;TService, TServiceImplement&amp;gt;());
    return serviceContainer;
}

public static IServiceContainer AddTransient([NotNull]this IServiceContainer serviceContainer, [NotNull]Type serviceType)
{
    serviceContainer.Add(new ServiceDefinition(serviceType, ServiceLifetime.Transient));
    return serviceContainer;
}

public static IServiceContainer AddTransient([NotNull]this IServiceContainer serviceContainer, [NotNull]Type serviceType, [NotNull]Type implementType)
{
    serviceContainer.Add(new ServiceDefinition(serviceType, implementType, ServiceLifetime.Transient));
    return serviceContainer;
}

public static IServiceContainer AddTransient&amp;lt;TService&amp;gt;([NotNull]this IServiceContainer serviceContainer, [NotNull]Func&amp;lt;IServiceProvider, object&amp;gt; func)
{
    serviceContainer.Add(ServiceDefinition.Transient&amp;lt;TService&amp;gt;(func));
    return serviceContainer;
}


public static IServiceContainer AddTransient&amp;lt;TService&amp;gt;([NotNull]this IServiceContainer serviceContainer)
{
    serviceContainer.Add(ServiceDefinition.Transient&amp;lt;TService&amp;gt;());
    return serviceContainer;
}


public static IServiceContainer AddTransient&amp;lt;TService, TServiceImplement&amp;gt;([NotNull]this IServiceContainer serviceContainer) where TServiceImplement : TService
{
    serviceContainer.Add(ServiceDefinition.Transient&amp;lt;TService, TServiceImplement&amp;gt;());
    return serviceContainer;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码就可以实现基本依赖注入了，但是从功能上来说，上面的代码只支持获取单个服务的实例，不支持注册一个接口的多个实现，获取接口的所有实现，为此对 &lt;code&gt;ServiceContainer&lt;/code&gt; 中的 Instance 的 &lt;code&gt;ConcurrentDictionary&lt;/code&gt; 的 Key 进行一下改造，使得可以能够以接口类型和实现类型联合作为 key，为此就有了第二版的 &lt;code&gt;ServiceContainer&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;servicecontainer-v2&quot;&gt;&lt;code&gt;ServiceContainer&lt;/code&gt; v2&lt;/h3&gt;
&lt;p&gt;为此定义了一个 &lt;code&gt;ServiceKey&lt;/code&gt; 的类型，请注意这里一定要重写 &lt;code&gt;GetHashCode&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private class ServiceKey : IEquatable&amp;lt;ServiceKey&amp;gt;
{
    public Type ServiceType { get; }

    public Type ImplementType { get; }

    public ServiceKey(Type serviceType, ServiceDefinition definition)
    {
        ServiceType = serviceType;
        ImplementType = definition.GetImplementType();
    }

    public bool Equals(ServiceKey other)
    {
        return ServiceType == other?.ServiceType &amp;amp;&amp;amp; ImplementType == other?.ImplementType;
    }

    public override bool Equals(object obj)
    {
        return Equals((ServiceKey)obj);
    }

    public override int GetHashCode()
    {
        var key = $&quot;{ServiceType.FullName}_{ImplementType.FullName}&quot;;
        return key.GetHashCode();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二版的 &lt;code&gt;ServiceContainer&lt;/code&gt; :&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceContainer : IServiceContainer
{
    internal readonly ConcurrentBag&amp;lt;ServiceDefinition&amp;gt; _services;

    private readonly ConcurrentDictionary&amp;lt;ServiceKey, object&amp;gt; _singletonInstances;

    private readonly ConcurrentDictionary&amp;lt;ServiceKey, object&amp;gt; _scopedInstances;
    private ConcurrentBag&amp;lt;object&amp;gt; _transientDisposables = new ConcurrentBag&amp;lt;object&amp;gt;();

    private class ServiceKey : IEquatable&amp;lt;ServiceKey&amp;gt;
    {
        public Type ServiceType { get; }

        public Type ImplementType { get; }

        public ServiceKey(Type serviceType, ServiceDefinition definition)
        {
            ServiceType = serviceType;
            ImplementType = definition.GetImplementType();
        }

        public bool Equals(ServiceKey other)
        {
            return ServiceType == other?.ServiceType &amp;amp;&amp;amp; ImplementType == other?.ImplementType;
        }

        public override bool Equals(object obj)
        {
            return Equals((ServiceKey)obj);
        }

        public override int GetHashCode()
        {
            var key = $&quot;{ServiceType.FullName}_{ImplementType.FullName}&quot;;
            return key.GetHashCode();
        }
    }

    private readonly bool _isRootScope;

    public ServiceContainer()
    {
        _isRootScope = true;
        _singletonInstances = new ConcurrentDictionary&amp;lt;ServiceKey, object&amp;gt;();
        _services = new ConcurrentBag&amp;lt;ServiceDefinition&amp;gt;();
    }

    private ServiceContainer(ServiceContainer serviceContainer)
    {
        _isRootScope = false;
        _singletonInstances = serviceContainer._singletonInstances;
        _services = serviceContainer._services;
        _scopedInstances = new ConcurrentDictionary&amp;lt;ServiceKey, object&amp;gt;();
    }

    public IServiceContainer Add(ServiceDefinition item)
    {
        if (_disposed)
        {
            throw new InvalidOperationException(&quot;the service container had been disposed&quot;);
        }
        if (_services.Any(_ =&amp;gt; _.ServiceType == item.ServiceType &amp;amp;&amp;amp; _.GetImplementType() == item.GetImplementType()))
        {
            return this;
        }

        _services.Add(item);
        return this;
    }

    public IServiceContainer TryAdd(ServiceDefinition item)
    {
        if (_disposed)
        {
            throw new InvalidOperationException(&quot;the service container had been disposed&quot;);
        }
        if (_services.Any(_ =&amp;gt; _.ServiceType == item.ServiceType))
        {
            return this;
        }
        _services.Add(item);
        return this;
    }

    public IServiceContainer CreateScope()
    {
        return new ServiceContainer(this);
    }

    private bool _disposed;

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        if (_isRootScope)
        {
            lock (_singletonInstances)
            {
                if (_disposed)
                {
                    return;
                }

                _disposed = true;
                foreach (var instance in _singletonInstances.Values)
                {
                    (instance as IDisposable)?.Dispose();
                }

                foreach (var o in _transientDisposables)
                {
                    (o as IDisposable)?.Dispose();
                }

                _singletonInstances.Clear();
                _transientDisposables = null;
            }
        }
        else
        {
            lock (_scopedInstances)
            {
                if (_disposed)
                {
                    return;
                }

                _disposed = true;
                foreach (var instance in _scopedInstances.Values)
                {
                    (instance as IDisposable)?.Dispose();
                }

                foreach (var o in _transientDisposables)
                {
                    (o as IDisposable)?.Dispose();
                }

                _scopedInstances.Clear();
                _transientDisposables = null;
            }
        }
    }

    private object GetServiceInstance(Type serviceType, ServiceDefinition serviceDefinition)
    {
        if (serviceDefinition.ImplementationInstance != null)
            return serviceDefinition.ImplementationInstance;

        if (serviceDefinition.ImplementationFactory != null)
            return serviceDefinition.ImplementationFactory.Invoke(this);

        var implementType = (serviceDefinition.ImplementType ?? serviceType);

        if (implementType.IsInterface || implementType.IsAbstract)
        {
            throw new InvalidOperationException($&quot;invalid service registered, serviceType: {serviceType.FullName}, implementType: {serviceDefinition.ImplementType}&quot;);
        }

        if (implementType.IsGenericType)
        {
            implementType = implementType.MakeGenericType(serviceType.GetGenericArguments());
        }

        var ctorInfos = implementType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
        if (ctorInfos.Length == 0)
        {
            throw new InvalidOperationException($&quot;service {serviceType.FullName} does not have any public constructors&quot;);
        }

        ConstructorInfo ctor;
        if (ctorInfos.Length == 1)
        {
            ctor = ctorInfos[0];
        }
        else
        {
            // TODO: try find best ctor
            ctor = ctorInfos
                .OrderBy(_ =&amp;gt; _.GetParameters().Length)
                .First();
        }

        var parameters = ctor.GetParameters();
        if (parameters.Length == 0)
        {
            // TODO: cache New Func
            return Expression.Lambda&amp;lt;Func&amp;lt;object&amp;gt;&amp;gt;(Expression.New(ctor)).Compile().Invoke();
        }
        else
        {
            var ctorParams = new object[parameters.Length];
            for (var index = 0; index &amp;lt; parameters.Length; index++)
            {
                var parameter = parameters[index];
                var param = GetService(parameter.ParameterType);
                if (param == null &amp;amp;&amp;amp; parameter.HasDefaultValue)
                {
                    param = parameter.DefaultValue;
                }

                ctorParams[index] = param;
            }
            return Expression.Lambda&amp;lt;Func&amp;lt;object&amp;gt;&amp;gt;(Expression.New(ctor, ctorParams.Select(Expression.Constant))).Compile().Invoke();
        }
    }

    public object GetService(Type serviceType)
    {
        if (_disposed)
        {
            throw new InvalidOperationException($&quot;can not get scope service from a disposed scope, serviceType: {serviceType.FullName}&quot;);
        }

        var serviceDefinition = _services.LastOrDefault(_ =&amp;gt; _.ServiceType == serviceType);
        if (null == serviceDefinition)
        {
            if (serviceType.IsGenericType)
            {
                var genericType = serviceType.GetGenericTypeDefinition();
                serviceDefinition = _services.LastOrDefault(_ =&amp;gt; _.ServiceType == genericType);
                if (null == serviceDefinition)
                {
                    var innerServiceType = serviceType.GetGenericArguments().First();
                    if (typeof(IEnumerable&amp;lt;&amp;gt;).MakeGenericType(innerServiceType)
                        .IsAssignableFrom(serviceType))
                    {
                        var innerRegType = innerServiceType;
                        if (innerServiceType.IsGenericType)
                        {
                            innerRegType = innerServiceType.GetGenericTypeDefinition();
                        }
                        //
                        var list = new List&amp;lt;object&amp;gt;(4);
                        foreach (var def in _services.Where(_ =&amp;gt; _.ServiceType == innerRegType))
                        {
                            object svc;
                            if (def.ServiceLifetime == ServiceLifetime.Singleton)
                            {
                                svc = _singletonInstances.GetOrAdd(new ServiceKey(innerServiceType, def), (t) =&amp;gt; GetServiceInstance(innerServiceType, def));
                            }
                            else if (def.ServiceLifetime == ServiceLifetime.Scoped)
                            {
                                svc = _scopedInstances.GetOrAdd(new ServiceKey(innerServiceType, def), (t) =&amp;gt; GetServiceInstance(innerServiceType, def));
                            }
                            else
                            {
                                svc = GetServiceInstance(innerServiceType, def);
                                if (svc is IDisposable)
                                {
                                    _transientDisposables.Add(svc);
                                }
                            }
                            if (null != svc)
                            {
                                list.Add(svc);
                            }
                        }

                        var methodInfo = typeof(Enumerable)
                            .GetMethod(&quot;Cast&quot;, BindingFlags.Static | BindingFlags.Public);
                        if (methodInfo != null)
                        {
                            var genericMethod = methodInfo.MakeGenericMethod(innerServiceType);
                            var castedValue = genericMethod.Invoke(null, new object[] { list });
                            if (typeof(IEnumerable&amp;lt;&amp;gt;).MakeGenericType(innerServiceType) == serviceType)
                            {
                                return castedValue;
                            }
                            var toArrayMethod = typeof(Enumerable).GetMethod(&quot;ToArray&quot;, BindingFlags.Static | BindingFlags.Public)
                                .MakeGenericMethod(innerServiceType);

                            return toArrayMethod.Invoke(null, new object[] { castedValue });
                        }
                        return list;
                    }

                    return null;
                }
            }
            else
            {
                return null;
            }
        }

        if (_isRootScope &amp;amp;&amp;amp; serviceDefinition.ServiceLifetime == ServiceLifetime.Scoped)
        {
            throw new InvalidOperationException($&quot;can not get scope service from the root scope, serviceType: {serviceType.FullName}&quot;);
        }

        if (serviceDefinition.ServiceLifetime == ServiceLifetime.Singleton)
        {
            var svc = _singletonInstances.GetOrAdd(new ServiceKey(serviceType, serviceDefinition), (t) =&amp;gt; GetServiceInstance(t.ServiceType, serviceDefinition));
            return svc;
        }
        else if (serviceDefinition.ServiceLifetime == ServiceLifetime.Scoped)
        {
            var svc = _scopedInstances.GetOrAdd(new ServiceKey(serviceType, serviceDefinition), (t) =&amp;gt; GetServiceInstance(t.ServiceType, serviceDefinition));
            return svc;
        }
        else
        {
            var svc = GetServiceInstance(serviceType, serviceDefinition);
            if (svc is IDisposable)
            {
                _transientDisposables.Add(svc);
            }
            return svc;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就不仅支持了 &lt;code&gt;IEnumerable&amp;lt;TService&amp;gt;&lt;/code&gt; 的注册，也支持 &lt;code&gt;IReadOnlyList&amp;lt;TService&amp;gt;&lt;/code&gt;/ &lt;code&gt;IReadOnlyCollection&amp;lt;TService&amp;gt;&lt;/code&gt; 的注册&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;GetService&lt;/code&gt; 返回是 object , 不是强类型的，所以为了使用起来方便，定义了几个扩展方法，类似于微软的依赖注入框架里的 &lt;code&gt;GetService&amp;lt;TService&amp;gt;()&lt;/code&gt;/&lt;code&gt;GetServices&amp;lt;TService&amp;gt;()&lt;/code&gt;/&lt;code&gt;GetRequiredService&amp;lt;TService&amp;gt;()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// ResolveService
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;TService&quot;&amp;gt;TService&amp;lt;/typeparam&amp;gt;
/// &amp;lt;param name=&quot;serviceProvider&quot;&amp;gt;serviceProvider&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static TService ResolveService&amp;lt;TService&amp;gt;([NotNull]this IServiceProvider serviceProvider)
    =&amp;gt; (TService)serviceProvider.GetService(typeof(TService));

/// &amp;lt;summary&amp;gt;
/// ResolveRequiredService
/// throw exception if can not get a service instance
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;TService&quot;&amp;gt;TService&amp;lt;/typeparam&amp;gt;
/// &amp;lt;param name=&quot;serviceProvider&quot;&amp;gt;serviceProvider&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static TService ResolveRequiredService&amp;lt;TService&amp;gt;([NotNull] this IServiceProvider serviceProvider)
{
    var serviceType = typeof(TService);
    var svc = serviceProvider.GetService(serviceType);
    if (null == svc)
    {
        throw new InvalidOperationException($&quot;service had not been registered, serviceType: {serviceType}&quot;);
    }
    return (TService)svc;
}

/// &amp;lt;summary&amp;gt;
/// Resolve services
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;TService&quot;&amp;gt;TService&amp;lt;/typeparam&amp;gt;
/// &amp;lt;param name=&quot;serviceProvider&quot;&amp;gt;serviceProvider&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static IEnumerable&amp;lt;TService&amp;gt; ResolveServices&amp;lt;TService&amp;gt;([NotNull]this IServiceProvider serviceProvider)
    =&amp;gt; serviceProvider.ResolveService&amp;lt;IEnumerable&amp;lt;TService&amp;gt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;后面还更新了一版，主要优化性能，目前来说还不太满意，暂时这里先不提了&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Mon, 28 Oct 2019 15:36:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>动手造轮子：实现一个简单的依赖注入(一)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/implement-dependency-injection-01.html</dc:identifier>
</item>
<item>
<title>.NET Core System.Drawing.Common 中文乱码的坑 - 中国.NET研究协会</title>
<link>http://www.cnblogs.com/dotnet-org-cn/p/11756285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnet-org-cn/p/11756285.html</guid>
<description>&lt;p&gt;最近在写一个汉字取点阵的程序，最开始是在win环境下运行的，没发现什么异常，然后今天把程序放在centos 下后发现英文正常，中文完全变成两位的字了，最开始是字体的原因&lt;/p&gt;
&lt;p&gt;在把宋体等安装到centos 后发现中文出来了 但完全变了另外的字，然后使用第三方的ZKWeb.System.Drawing 运行程序，发现正常，但切换回System.Drawing.Common 就会完全不认识 或者完全变了字&lt;/p&gt;
&lt;p&gt;比如 ：我是中文&lt;br/&gt;画出来后变成了&lt;img src=&quot;https://img2018.cnblogs.com/blog/542536/201910/542536-20191028230933862-795453975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 这完全不是这个了，阅读System.Drawing.Common的源码也并没有发现其中的坑在哪里 ，跟ZKWeb.System.Drawing 也对比了下，&lt;/p&gt;
&lt;p&gt;找到关键性代码进行对比  System.Drawing.Common 中的源码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.Drawing.Common/src/System/Drawing/GdiplusNative.cs&quot;&gt;https://github.com/dotnet/corefx/blob/master/src/System.Drawing.Common/src/System/Drawing/GdiplusNative.cs&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 [DllImport(LibraryName, ExactSpelling = &lt;span&gt;true&lt;/span&gt;, CharSet =&lt;span&gt; CharSet.Unicode)]
 &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GdipDrawString(HandleRef graphics, &lt;span&gt;string&lt;/span&gt; textString, &lt;span&gt;int&lt;/span&gt; length, HandleRef font, &lt;span&gt;ref&lt;/span&gt; RectangleF layoutRect, HandleRef stringFormat, HandleRef brush);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及ZKWeb.System.Drawing中的源码&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/zkweb-framework/ZKWeb.System.Drawing/blob/master/src/ZKWeb.System.Drawing/System.Drawing/gdipFunctions.cs&quot;&gt;https://github.com/zkweb-framework/ZKWeb.System.Drawing/blob/master/src/ZKWeb.System.Drawing/System.Drawing/gdipFunctions.cs&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[DllImport(GdiPlus, CharSet=&lt;span&gt;CharSet.Unicode)]
 &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; Status GdipDrawString (IntPtr graphics, &lt;span&gt;string&lt;/span&gt; text, &lt;span&gt;int&lt;/span&gt; len, IntPtr font, &lt;span&gt;ref&lt;/span&gt; RectangleF rc, IntPtr format, IntPtr brush);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行对比 并没法发现什么区别，于是就把这个定义放到自己的程序中定义 手动调用 GdipDrawString 看看是否会有中文乱码的问题，然而发现换System.Drawing.Common中的定义或者ZKWeb.System.Drawing中的定义都可以正常显示 但切换回System.Drawing.Common 使用系统的代码&lt;/p&gt;
&lt;p&gt;Graphics.DrawString 中文就是不行，看了下DrawString 的代码也非常简单 ，就是调用了GdipDrawString  api 绘画字符串的，其源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawString(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (brush == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(brush));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(s))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (font == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(font));

            CheckErrorStatus(Gdip.GdipDrawString(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HandleRef(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, NativeGraphics),
                s,
                s.Length,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HandleRef(font, font.NativeFont),
                &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; layoutRectangle,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HandleRef(format, format?.nativeFormat ??&lt;span&gt; IntPtr.Zero),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HandleRef(brush, brush.NativeBrush)));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也没有发现什么异常，最后使用反编译查看nuget包中的 System.Drawing.Common.dll 文件，居然发现System.Drawing.Common.dll 中的GdipDrawString 居然少了&lt;span class=&quot;pl-en&quot;&gt;CharSet 标记，判定是导致问题的所在，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-en&quot;&gt;于是怀疑是我没有更新到最新版本导致的，上nuget一看发现是最新的版本 4.6的版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-en&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/542536/201910/542536-20191028231836898-1499925113.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;于是估计是微软没更新导致的，暂时解决方法就是使用ZKWeb.System.Drawing 代替或者自己把这个api自己定义并抛弃系统的Graphics.DrawString 函数 &lt;/p&gt;

</description>
<pubDate>Mon, 28 Oct 2019 15:22:00 +0000</pubDate>
<dc:creator>中国.NET研究协会</dc:creator>
<og:description>最近在写一个汉字取点阵的程序，最开始是在win环境下运行的，没发现什么异常，然后今天把程序放在centos 下后发现英文正常，中文完全变成两位的字了，最开始是字体的原因 在把宋体等安装到centos</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dotnet-org-cn/p/11756285.html</dc:identifier>
</item>
<item>
<title>Spring Boot构建的Web项目如何在服务端校验表单输入 - javaadu</title>
<link>http://www.cnblogs.com/javaadu/p/11756248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaadu/p/11756248.html</guid>
<description>&lt;blockquote readability=&quot;1.5789473684211&quot;&gt;
&lt;p&gt;本文首发于个人网站：&lt;a href=&quot;http://www.javaadu.online/?p=633&quot;&gt;Spring Boot构建的Web项目如何在服务端校验表单输入&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个例子用于演示在Spring Boot应用中如何验证Web 应用的输入，我们将会建立一个简单的Spring MVC应用，来读取用户输入并使用validation注解来检查，并且当用户输入错误时，应用需要再屏幕上显示错误信息提示用户重新输入。&lt;/p&gt;
&lt;p&gt;首先构建Maven项目，该项目的pom文件内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;validating-form-input&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.5.1.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- thymeleaf模板，用于前段渲染 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 用于输入验证 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 用于支持嵌入式tomcat --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-embed-el&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 用于spring boot应用的测试 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring Boot Maven插件提供了很多方便的特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它将该项目中需要的各个Jar包收集起来，并打包成可直接运行的Jar包，以更方便得部署和传输；&lt;/li&gt;
&lt;li&gt;它会搜索包含“public static void main()”方法的类，该类就是可运行Jar包的启动类；&lt;/li&gt;
&lt;li&gt;它提供了内在的支持，去匹配Spring Boot的版本号。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;form对象&quot;&gt;Form对象&lt;/h2&gt;
&lt;p&gt;创建一个Form对象，用于对应HTML页面中输入的对象——PersonForm，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package hello;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * Created by IntelliJ IDEA.
 * User: duqi
 * Date: 2017/2/28
 * Time: 21:53
 */
public class PersonForm {

    @NotNull
    @Size(min = 2, max = 30)
    private String name;

    @NotNull
    @Min(18)
    private Integer age;

    public String getName() {
        return name;
    }

    public Integer getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String toString() {
        return &quot;Person(Name: &quot; + this.name + &quot;, Age: &quot; + this.age + &quot;)&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，@NotNull注解表示该属性不能为空、@Size（min=2, max=30）表示name属性的长度在[2,30]之间，@Min(18)表示age属性最小值为18。&lt;/p&gt;
&lt;h2 id=&quot;web控制器&quot;&gt;web控制器&lt;/h2&gt;
&lt;p&gt;编写一个web控制器，引用为：src/main/java/hello/WebController.java，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package hello;

import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

import javax.validation.Valid;

/**
 * Created by IntelliJ IDEA.
 * User: duqi
 * Date: 2017/3/2
 * Time: 14:07
 */
@Controller
public class WebController extends WebMvcConfigurerAdapter {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController(&quot;/results&quot;).setViewName(&quot;results&quot;);
    }

    @GetMapping(&quot;/&quot;)
    public String showForm(PersonForm personForm) {
        return &quot;form&quot;;
    }

    @PostMapping(&quot;/&quot;)
    public String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            return &quot;form&quot;;
        }

        return &quot;redirect:/results&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个控制器中，GET方法和POST方法都映射到“/”url下，showForm方法会返回“form”字符串，表示模板的名称，视图控制器根据这个字符串查找模板文件form.html，在&lt;code&gt;showForm&lt;/code&gt;的方法签名中定义了PersonForm参数，以便模板将属性绑定到PersonForm对象的属性中，&lt;code&gt;checkPersonFormInfo&lt;/code&gt;方法定义了两个入参：（1）person对象，在这个参数前用@Valid修饰，用于检查从form页面提交过来的属性值；（2）bindingResult对象，用于存放@Valid注解检查的结果。&lt;/p&gt;
&lt;p&gt;可以从PersonForm表格中提取属性值，并存入PersonForm对象。@Valid注解会检查这些属性的有效性，如果有错也会把错误信息渲染到模板中并显示到页面上。&lt;/p&gt;
&lt;p&gt;如果所有的属性都通过校验，该方法会将浏览器重定向到results页面。&lt;/p&gt;
&lt;h2 id=&quot;构建thymeleaf页面&quot;&gt;构建thymeleaf页面&lt;/h2&gt;
&lt;p&gt;spring boot默认从src/main/resources/templates目录下查找html页面，form.html和results.html都放在这里。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Spring Boot Thymeleaf Hello World Example&amp;lt;/title&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;#&quot; th:action=&quot;@{/}&quot; th:object=&quot;${personForm}&quot; method=&quot;post&quot;&amp;gt;
        &amp;lt;table&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;Name:&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;input type=&quot;text&quot; th:field=&quot;*{name}&quot; /&amp;gt;&amp;lt;/td&amp;gt;
                &amp;lt;td th:if=&quot;${#fields.hasErrors('name')}&quot; th:errors=&quot;*{name}&quot;&amp;gt;Name Error&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;Age:&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;input type=&quot;text&quot; th:field=&quot;*{age}&quot; /&amp;gt;&amp;lt;/td&amp;gt;
                &amp;lt;td th:if=&quot;${#fields.hasErrors('age')}&quot; th:errors=&quot;*{age}&quot;&amp;gt;Age Error&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;button type=&quot;submit&quot;&amp;gt;Submit&amp;lt;/button&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;form.html页面包含一个简单的form表格，这个表格和post方法绑定。&lt;code&gt;th:object&lt;/code&gt;表示该表格和后端的person对象绑定，这就是&lt;strong&gt;bean-backed form&lt;/strong&gt;，在PersonForm对象中，可以看到&lt;code&gt;th:field=&quot;*{name}&quot;&lt;/code&gt;和&lt;code&gt;th:field=*{age}&lt;/code&gt;。在form表格中，紧挨着name和age标签，有两个用于显示错误信息的标签。页面的最后有个Submit按钮，如果用户输入的name和age不合法，页面会显示错误提示信息，如果用户输入的name和age不合法，页面会被路由到下一个页面。&lt;/p&gt;
&lt;p&gt;results.html内容如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    Congratulations! You are old enough to sign up for this site.
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建程序启动类&quot;&gt;创建程序启动类&lt;/h2&gt;
&lt;p&gt;创建一个Application类，用于启动Spring Boot应用，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Created by IntelliJ IDEA.
 * User: duqi
 * Date: 2017/3/2
 * Time: 15:50
 */
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@SpringBootApplication注解也为Thymeleaf提供了默认配置：默认情况下会从resources/templates目录下查找模板文件，并将*.html文件中的后缀忽略掉后剩下的文件名称解析为视图。可以通过在application.properties里设置相关属性来修改Thymeleaf的配置，这里我们不再细说。&lt;/p&gt;
&lt;p&gt;演示的代码：https://github.com/duqicauc/validatingforminput&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-1.x系列&quot;&gt;Spring Boot 1.x系列&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=487&quot;&gt;Spring Boot的自动配置、Command-line-Runner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=495&quot;&gt;了解Spring Boot的自动配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=499&quot;&gt;Spring Boot的@PropertySource注解在整合Redis中的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=515&quot;&gt;Spring Boot项目中如何定制HTTP消息转换器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=518&quot;&gt;Spring Boot整合Mongodb提供Restful接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=521&quot;&gt;Spring中bean的scope&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=526&quot;&gt;Spring Boot项目中使用事件派发器模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=530&quot;&gt;Spring Boot提供RESTful接口时的错误处理实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=535&quot;&gt;Spring Boot实战之定制自己的starter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=538&quot;&gt;Spring Boot项目如何同时支持HTTP和HTTPS协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=546&quot;&gt;自定义的Spring Boot starter如何设置自动配置注解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=575&quot;&gt;Spring Boot项目中使用Mockito&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=588&quot;&gt;在Spring Boot项目中使用Spock测试框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=590&quot;&gt;Spring Boot项目中如何定制拦截器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=593&quot;&gt;Spring Boot项目中如何定制PropertyEditors&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本号专注于后端技术、JVM问题排查和优化、Java面试题、个人成长和自我管理等主题，为读者提供一线开发者的工作和成长经验，期待你能在这里有所收获。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/721786/201910/721786-20191028231229946-1592811132.png&quot; alt=&quot;javaadu&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Oct 2019 15:13:00 +0000</pubDate>
<dc:creator>javaadu</dc:creator>
<og:description>本文首发于个人网站： 'Spring Boot构建的Web项目如何在服务端校验表单输入' 这个例子用于演示在Spring Boot应用中如何验证Web 应用的输入，我们将会建立一个简单的Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaadu/p/11756248.html</dc:identifier>
</item>
<item>
<title>redis之Scan - 不懒人</title>
<link>http://www.cnblogs.com/wuwuyong/p/11756207.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuwuyong/p/11756207.html</guid>
<description>&lt;p&gt;scan 相比&lt;br/&gt;keys 具备有以下特点:&lt;br/&gt;1、复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;&lt;br/&gt;2、提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是一个 hint，返回的&lt;br/&gt;结果可多可少;&lt;br/&gt;3、同 keys 一样，它也提供模式匹配功能;&lt;br/&gt;4、服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;&lt;br/&gt;5、返回的结果可能会有重复，需要客户端去重复，这点非常重要;&lt;br/&gt;6、遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;&lt;br/&gt;7、单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零&lt;/p&gt;

&lt;p&gt;scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三&lt;br/&gt;个是遍历的 limit hint。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为&lt;br/&gt;下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。&lt;br/&gt;127.0.0.1:6379&amp;gt; scan 0 match key99* count 1000&lt;br/&gt;1) &quot;13976&quot;&lt;br/&gt;2) 1) &quot;key9911&quot;&lt;br/&gt;2) &quot;key9974&quot;&lt;br/&gt;3) &quot;key9994&quot;&lt;br/&gt;4) &quot;key9910&quot;&lt;br/&gt;5) &quot;key9907&quot;&lt;br/&gt;6) &quot;key9989&quot;&lt;br/&gt;7) &quot;key9971&quot;&lt;br/&gt;8) &quot;key99&quot;&lt;br/&gt;9) &quot;key9966&quot;&lt;br/&gt;10) &quot;key992&quot;&lt;br/&gt;11) &quot;key9903&quot;&lt;br/&gt;12) &quot;key9905&quot;&lt;br/&gt;127.0.0.1:6379&amp;gt; scan 13976 match key99* count 1000&lt;br/&gt;1) &quot;1996&quot;&lt;br/&gt;2) 1) &quot;key9982&quot;&lt;br/&gt;2) &quot;key9997&quot;&lt;br/&gt;3) &quot;key9963&quot;&lt;br/&gt;4) &quot;key996&quot;&lt;br/&gt;5) &quot;key9912&quot;&lt;br/&gt;6) &quot;key9999&quot;&lt;br/&gt;7) &quot;key9921&quot;&lt;br/&gt;8) &quot;key994&quot;&lt;br/&gt;9) &quot;key9956&quot;&lt;br/&gt;10) &quot;key9919&quot;&lt;br/&gt;127.0.0.1:6379&amp;gt; scan 1996 match key99* count 1000&lt;br/&gt;1) &quot;12594&quot;&lt;br/&gt;2) 1) &quot;key9939&quot;&lt;br/&gt;2) &quot;key9941&quot;&lt;br/&gt;3) &quot;key9967&quot;&lt;br/&gt;4) &quot;key9938&quot;&lt;br/&gt;5) &quot;key9906&quot;&lt;br/&gt;6) &quot;key999&quot;&lt;br/&gt;7) &quot;key9909&quot;&lt;br/&gt;8) &quot;key9933&quot;&lt;br/&gt;9) &quot;key9992&quot;&lt;br/&gt;......&lt;br/&gt;127.0.0.1:6379&amp;gt; scan 11687 match key99* count 1000&lt;br/&gt;1) &quot;0&quot;&lt;br/&gt;2) 1) &quot;key9969&quot;&lt;br/&gt;2) &quot;key998&quot;&lt;br/&gt;3) &quot;key9986&quot;&lt;br/&gt;4) &quot;key9968&quot;&lt;br/&gt;5) &quot;key9965&quot;&lt;br/&gt;6) &quot;key9990&quot;&lt;br/&gt;7) &quot;key9915&quot;&lt;br/&gt;8) &quot;key9928&quot;&lt;br/&gt;9) &quot;key9908&quot;&lt;br/&gt;10) &quot;key9929&quot;&lt;br/&gt;11) &quot;key9944&quot;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Oct 2019 15:00:00 +0000</pubDate>
<dc:creator>不懒人</dc:creator>
<og:description>scan 相比keys 具备有以下特点:1、复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;2、提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是一个 hin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuwuyong/p/11756207.html</dc:identifier>
</item>
<item>
<title>Spring 源码阅读之 深入理解 finishBeanFactoryInitialization - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11755973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11755973.html</guid>
<description>&lt;h3 id=&quot;源码入口&quot;&gt;源码入口&lt;/h3&gt;
&lt;p&gt;上篇博文中我们看到了将Spring环境中的 BeanPostProcessor找出来,添加到BeanFactory中的beanPostProcessors中,统一维护,本片博文继续往下拓展,看下Spring如何实例化bean,以及如何实现在bean的实例化通过各种各样的后置处理器完成bean的增强&lt;/p&gt;
&lt;p&gt;所以本次的程序入口是&lt;code&gt;AbstractApplicationContext&lt;/code&gt;中的&lt;code&gt;finishBeanFactoryInitialization(beanFactory);&lt;/code&gt;,源码如下,主要做了如下几件事&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // Initialize conversion service for this context.
    // 为上下文初始化类型转换器
    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;amp;&amp;amp;
            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(
                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }

    // 检查上下文中是否存在类型转换器
    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver(strVal -&amp;gt; getEnvironment().resolvePlaceholders(strVal));
    }
    // 尽早初始化LoadTimeWeaverAware bean，以便尽早注册它们的转换器。
    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    for (String weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    // Stop using the temporary ClassLoader for type matching.
    // 禁止使用临时类加载器进行类型匹配
    beanFactory.setTempClassLoader(null);

    // Allow for caching all bean definition metadata, not expecting further changes
    // 允许缓存所有的bean的定义数据
    beanFactory.freezeConfiguration();

    // Instantiate all remaining (non-lazy-init) singletons.
    // 准备实例化bean
    beanFactory.preInstantiateSingletons();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们着重看他是如何创建实例化bean的,&lt;strong&gt;跟进&lt;code&gt;beanFactory.preInstantiateSingletons();&lt;/code&gt;&lt;/strong&gt;,调用beanFactory的方法准备实例化bean, 这个beanFactory就是Spring默认是bean工厂, &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;, 源码如下：方法不算很长，逻辑也很清楚，　一开始Spring取出当前上下文中所有的BeanName列表,因为在执行到这里之前,已经完成包扫描了所以说这个盛放beanName的list里面存放的就是所有的需要实例化的对象的全集,包含Spring自己的,和程序员自己添加的还包含Aspectj的&lt;/p&gt;
&lt;p&gt;所以说,当前方法的目标很明了,就是遍历这个list中的每一个beanName,然后实例化当前beanName相应的bean&lt;/p&gt;
&lt;p&gt;当然,如果想实例化,前提是不能是抽象类,不能是接口,非懒加载, 而且针对&lt;code&gt;FactoryBean&lt;/code&gt;还有不同的处理模式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void preInstantiateSingletons() throws BeansException {
if (logger.isDebugEnabled()) {
    logger.debug(&quot;Pre-instantiating singletons in &quot; + this);
}
//所有bean的名字
// Iterate over a copy to allow for init methods which in turn register new bean definitions.
// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
//todo 遍历一个副本以允许init方法，而init方法反过来注册新的bean定义。
// todo 盛放所有的beanName,所有的需要实例化的beanName都在这里,包括Spring断断续续添加的, Aspectj的, 程序员通过注解标识的
List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames);

// Trigger initialization of all non-lazy singleton beans...
// todo 触发所有非延迟加载单例beans的初始化，主要步骤为调用getBean
for (String beanName : beanNames) {

    // todo 合并父类BeanDefinition,可以进入查看
    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);

    //todo 三个条件,抽象,单例,非懒加载
    if (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()) {

        if (isFactoryBean(beanName)) {
            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
            // todo 如果是FactoryBean则加上&amp;amp;
            // todo 检验是否是 FactoryBean 类型的对象
            if (bean instanceof FactoryBean) {
                final FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) bean;
                boolean isEagerInit;
                if (System.getSecurityManager() != null &amp;amp;&amp;amp; factory instanceof SmartFactoryBean) {
                    isEagerInit = AccessController.doPrivileged((PrivilegedAction&amp;lt;Boolean&amp;gt;)
                                    ((SmartFactoryBean&amp;lt;?&amp;gt;) factory)::isEagerInit,
                            getAccessControlContext());
                }
                else {
                    isEagerInit = (factory instanceof SmartFactoryBean &amp;amp;&amp;amp;
                            ((SmartFactoryBean&amp;lt;?&amp;gt;) factory).isEagerInit());
                }
                if (isEagerInit) {
                    getBean(beanName);
                }
            }
        }
        else {
            // todo 因为我们没有添加FactoryBean类型的对象, 一般都会进入这个getBean
            getBean(beanName);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面接着跟进&lt;code&gt;getBean(beanName);&lt;/code&gt;方法,&lt;strong&gt;顾名思义获取Bean,再往下跟下去,就算是本文的正文开始部分了,但是我想在这里级具体一下,一个比较有分量的剧透吧,当前的&lt;code&gt;getBean(beanName)&lt;/code&gt;它是有返回值的,一会当我们往下跟进的是时候会发现会存在递归的现象,这一点巧妙的实现了&lt;code&gt;@Autowired&lt;/code&gt;处理setter方式实现循环引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ok,现在继续看代码,经过了几个空方法的传递,我们来到下面的代码中,它主要做了如下几件事&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先将传递进来的name转换成了beanName&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原因1: FactoryBean的实现类的存储方式和其他的类完全相同,添加上&amp;amp;是获取不到的, 因此我们将&amp;amp;去掉 原因2: 解决别名的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么在创建bean之前先调用&lt;code&gt;getSingleton()&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回想一下,现在是Spring启动的过程中,是在准备实例化bean,为什么一开始就来&lt;code&gt;getSingleton()&lt;/code&gt;,跟进源码查看这个方法,它最终实现中有一行代码是这样的&lt;code&gt;Object singletonObject = this.singletonObjects.get(beanName);&lt;/code&gt;而这个&lt;code&gt;singletonObjects&lt;/code&gt;就是微观层面的IOC容器,循环创建刚开始时,IOC确实是空的,但是我前面存在剧透,一开始的&lt;code&gt;getBean()&lt;/code&gt;方法是存在递归调用现象的,&lt;strong&gt;直接举2个例子: 第一:假如现在在实例化A,结果有发现需要给A注入B, 那Spring是不是得获得B,怎么获得呢? 递归使用&lt;code&gt;getBean(BName)&lt;/code&gt;完成, 第二个例子: A被添加上了@Lazy注解,是懒加载的,但是终究有一个会通过&lt;code&gt;getBean(AName)&lt;/code&gt;获取A,这是发现A是实例化需要B,B肯定已经实例化完事了,同样是通过递归&lt;code&gt;getBean(BName)&lt;/code&gt;实现注入, 在这两个过程中就是&lt;code&gt;getSingleton()&lt;/code&gt;保证不会重复创建已经存在的实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们关注的重点其实是第二个&lt;code&gt;getSingleton(beanName()-&amp;gt;{xxx})&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在第二个&lt;code&gt;getSingleton()&lt;/code&gt;方法中才是真正的去实例化bean的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后,在当前的方法最后将bean返回了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面我就是说过了,&lt;code&gt;getBean(beanName)&lt;/code&gt;存在递归调用的情况,为什么我会一直说这个事呢,因为如果不知道这个事的话,这些代码看起来是没有头绪的,但是明白这个事,看代码就变得很有逻辑,我在简单总结一下&lt;strong&gt;怎个玩这个递归呢? 假设现在通过&lt;code&gt;getBean(AName)&lt;/code&gt;来注入A对象,但是呢发现了A依赖B对象,于是在&lt;code&gt;getBean(AName)&lt;/code&gt;里面调用&lt;code&gt;getBean(BName)&lt;/code&gt;,通过这个方法返回出B对象完成A的注入&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
    @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

// 将传递进来的name
final String beanName = transformedBeanName(name);
Object bean;

// Eagerly check singleton cache for manually registered singletons.
// 及早的检查一下有没有已经注册了的单例对象
Object sharedInstance = getSingleton(beanName);// todo ::: name=myService时,这次来调用的就是 DefaultSingletonBeanRegistry中的 getSingleton() , 不同之处是多传递了一个true
if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
    // 如果存在的话,将其取出赋值给bean,后续直接返回这个bean
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
} else {
    // Fail if we're already creating this bean instance:
    // We're assumably within a circular reference.
    // 来到这里就说明要获取的bean还没有实例化过
    // 于是检验一下,如果是原形,直接抛异常
    if (isPrototypeCurrentlyInCreation(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }

    // Check if bean definition exists in this factory.
    // 检查是否存在默认的父工厂
    BeanFactory parentBeanFactory = getParentBeanFactory();
    if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
        // Not found -&amp;gt; check parent.
        String nameToLookup = originalBeanName(name);
        if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                    nameToLookup, requiredType, args, typeCheckOnly);
        }
        else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
        }
        else {
            // No args -&amp;gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
        }
    }

    if (!typeCheckOnly) {
        // 将当前的beanName存放到AlreadeyCreated这个set集中,标识这个bean被创建了
        markBeanAsCreated(beanName);
    }

    try {
        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
        checkMergedBeanDefinition(mbd, beanName, args);

        // Guarantee initialization of beans that the current bean depends on.
        // 确保当前bean所依赖的bean都已经初始化好了
        String[] dependsOn = mbd.getDependsOn();
        if (dependsOn != null) {
            for (String dep : dependsOn) {
                if (isDependent(beanName, dep)) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
                }
                registerDependentBean(dep, beanName);
                try {
                    getBean(dep);
                }
                catch (NoSuchBeanDefinitionException ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
                }
            }
        }

        // Create bean instance.
        if (mbd.isSingleton()) {
          // 实例化bean
            sharedInstance = getSingleton(beanName, () -&amp;gt; { 
                    // 真正的完成bean的创建
                    return createBean(beanName, mbd, args);
            
            });

            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
        }
        // 下面是进行其他的检查工作,这里不再深究了
        else if (mbd.isPrototype()) {
            // It's a prototype -&amp;gt; create a new instance.
            Object prototypeInstance = null;
            try {
                beforePrototypeCreation(beanName);
                prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
                afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
        }

        else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
                throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
            }
            try {
                Object scopedInstance = scope.get(beanName, () -&amp;gt; {
                    beforePrototypeCreation(beanName);
                    try {
                        return createBean(beanName, mbd, args);
                    }
                    finally {
                        afterPrototypeCreation(beanName);
                    }
                });
                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
                throw new BeanCreationException(beanName,
                        &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
                        &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                        ex);
            }
        }
    }
    catch (BeansException ex) {
        cleanupAfterBeanCreationFailure(beanName);
        throw ex;
    }
}

// Check if required type matches the type of the actual bean instance.
if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) {
    try {
        T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
        if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
        }
        return convertedBean;
    }
    catch (TypeMismatchException ex) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
                    ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
        }
        throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
    }
}
return (T) bean;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过了上面一顿扯,然后我们继续往下跟,看看&lt;code&gt;createBean(beanName, mbd, args)&lt;/code&gt;方法中是如何实例化我们的Bean的, 上面的方法是在&lt;code&gt;AbstractBeanFactory&lt;/code&gt;中,&lt;code&gt;createBean(beanName, mbd, args)&lt;/code&gt;是它的抽象方法, 那实现类是哪个呢?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;&lt;/strong&gt;,隆重的夸一下这个类,Spring都称赞这个类是有&lt;strong&gt;有才华的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在这个方法中,主要做了两件事:&lt;strong&gt;两件大事!!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一件大事:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实例化Bean前,&lt;strong&gt;第一次调用后置处理器&lt;/strong&gt;, 这件大事绝对是有历史意义的!!!为啥呢?大家想想,bean还没有创建呢!就已经可以插手bean的创建过程了,不是很刺激吗?接着看回调了什么后置处理器呢? Spring会循环所有的处理器检查当前被遍历的处理器是否是&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;类型的,如果是的话呢,就执行这个后置处理器的&lt;code&gt;postProcessBeforeInstantiation(beanClass, beanName);&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;postProcessBeforeInstantiation()&lt;/code&gt;是允许有返回值的,大家可以想想,这一点是不是有点可怕? 事实也是这样,后置处理器的目的是为了增强对象,而我们却可以在这里返回一个任何东西,狸猫换台子替换掉原始的,还没有被创建的对象,还有一点,就是一旦我们在这里真的是没有返回null,那后续Spring就没有义务在去为我们创建本来应该创建的对象了,代码通过if-else的选择分支会使得当前的对象不再经历其他后置处理器的增强,最终执行它父类的&lt;code&gt;postProcessorAfterInitialization()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充一点,我们通过@EnableAspectjAutoProxy添加到Spring上下文中的&lt;code&gt;AnnotationAwareAspectjAutoProxyCreator&lt;/code&gt;对象其实就是这个类型&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;,也就是说在这里这个接口的相关方法会被回调,下面看看他的实现类&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;对这个&lt;code&gt;before()&lt;/code&gt;方法的重写实现,源码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要逻辑就是找出需要产生代理增强的bean(切面类),和普通的bean, 需要增强的bean放在&lt;code&gt;advisedBeans&lt;/code&gt;里面,因为需要增强的bean是需要动态植入其他逻辑的,所以不放在一起&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判断当前bean是否是基础类型的,比如: Advice PointCut Advisor AopInfrastructureBean 或者是 切面Aspectj 都算是基础类型,标注这些信息的类,是不会被增强的,标记false&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主意啊，上面说的都是作用都是进行了一下标记&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//todo 跟进来
@Override
public Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
    Object cacheKey = getCacheKey(beanClass, beanName);

    if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {
        if (this.advisedBeans.containsKey(cacheKey)) {
            return null;
        }
        // todo 亮点就是在这里,  如果是我们切面类来到这里,条件是满足的
        // todo advicedBeans    见名知意: 通知beans
        // todo Spring用它标识,  被放在这个方法中的类,全部都不会被增强
        // todo 满足什么条件时,通过检查呢? 就是检查是否标记有 @Aspectj  @Before ... 等注解

        // todo 说的再直接一点, 就是返回了null, 表示当前的切面仍然需要按照正常的流程创建出来,但是这里进行标记了
        if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
            this.advisedBeans.put(cacheKey, Boolean.FALSE);
            return null;
        }
    }

    // Create proxy here if we have a custom TargetSource. todo 如果我们有一个自定义的TargetSource，在这里创建代理
    // Suppresses unnecessary default instantiation of the target bean: // todo 抑制不必要的目标bean的默认实例化:
    // The TargetSource will handle target instances in a custom fashion. todo TargetSource将以自定义方式处理目标实例。
    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
    if (targetSource != null) {
        if (StringUtils.hasLength(beanName)) {
            this.targetSourcedBeans.add(beanName);
        }
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }

    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;经过上面的标记,在哪里产生的代理对象呢?其实是在&lt;code&gt;AbstractAutowireCapeableBeanFactory&lt;/code&gt;中的&lt;code&gt;initializeBean()&lt;/code&gt;方法中实现的&lt;code&gt;postProcessAfterInitialization()&lt;/code&gt;实现的,在本文的末尾展开讨论&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;第二件大事:&lt;/strong&gt; 实例化对象, 继续跟进&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
        throws BeanCreationException {

    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;);
    }
    RootBeanDefinition mbdToUse = mbd;

    // Make sure bean class is actually resolved at this point, and
    // clone the bean definition in case of a dynamically resolved Class which cannot be stored in the shared merged bean definition.
    // todo 做各种各样的属性值的赋值, 比如这种 通过Spring的Bean传递给Spring框架的值  ==&amp;gt; bd.setPropertyValue(&quot;aaa&quot;)
    Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);
    if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) {
        mbdToUse = new RootBeanDefinition(mbd);
        mbdToUse.setBeanClass(resolvedClass);
    }

    // Prepare method overrides.
    // todo 处理 lookup-method 和 replace-method 配置，Spring 将这两个配置统称为 override method
    try {
        mbdToUse.prepareMethodOverrides();
    }
    catch (BeanDefinitionValidationException ex) {
        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
                beanName, &quot;Validation of method overrides failed&quot;, ex);
    }

    try {
        // todo 在实例化之前完成一次解析操作,这也是
        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);

        if (bean != null) {
            return bean;
        }
    }
    catch (Throwable ex) {
        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
    }

    try {
        //todo 调用 doCreateBean 创建bean
        Object beanInstance = doCreateBean(beanName, mbdToUse, args);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
        }
        return beanInstance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们继续跟进&lt;code&gt;doCreateBean(beanName, mbdToUse, args);&lt;/code&gt;方法, 同样是本类&lt;code&gt;AbstarctAutowireCapableBeanFactory&lt;/code&gt;的方法,源码如下: 这个方法也是&lt;strong&gt;无与伦比的重要&lt;/strong&gt;,那这个方法中做了什么事情呢?如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个 BeanWrapper,用来存放bean+其他属性&lt;/li&gt;
&lt;li&gt;创建bean的实例,封装进上面的BeanWrapper中&lt;/li&gt;
&lt;li&gt;分两次调用处理处理器&lt;/li&gt;
&lt;li&gt;设置属性，填充属性&lt;/li&gt;
&lt;li&gt;经过AOP处理,将原生对象转换成Proxy&lt;/li&gt;
&lt;li&gt;返回BeanWrapper&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;因为这个方法简直太重要了,上面列举的每一点都值得我们仔细分析,我们每一条的分析都写在下面代码的下面&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
            throws BeanCreationException {

        // Instantiate the bean.
        // todo BeanWrapper 用来包装bean
        BeanWrapper instanceWrapper = null;
        if (mbd.isSingleton()) {
            // todo 一开始 factoryBeanInstanceCache 这个map中是没有值的， 所以进入下面的if
            instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
        }
        if (instanceWrapper == null) {

            instanceWrapper = createBeanInstance(beanName, mbd, args);
        }
        // todo ！！！！！！！！这里获取出来的对象是原生对象！！！！！！！！！！！！
        final Object bean = instanceWrapper.getWrappedInstance();
        Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class) {
            mbd.resolvedTargetType = beanType;
        }

        // Allow post-processors to modify the merged bean definition.
        synchronized (mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {
    
                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Post-processing of merged bean definition failed&quot;, ex);
                }
                mbd.postProcessed = true;
            }
        }

        // Eagerly cache singletons to be able to resolve circular references
        // even when triggered by lifecycle interfaces like BeanFactoryAware.
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Eagerly caching bean '&quot; + beanName +
                        &quot;' to allow for resolving potential circular references&quot;);
            }

            addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
        }

        // Initialize the bean instance.
        Object exposedObject = bean; // todo 到目前为止还是原生对象
    
            //todo  用来填充属性
            //设置属性，非常重要
            populateBean(beanName, mbd, instanceWrapper);
            
            // todo 经过AOP处理,原生对象转换成了代理对象,跟进去
            //执行后置处理器，aop就是在这里完成的处理
            exposedObject = initializeBean(beanName, exposedObject, mbd);
    
        return exposedObject;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实例化对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我把源码贴在了下面,下面方法的目的就是选出一个策略来实例化一个对象, 那有什么策略呢? &lt;strong&gt;这就看程序员是怎么配置的了, 程序员可以配置工厂方法,指定构造方法,或者是程序员没有做出任何干涉,让Spring按自己的方式去实例化&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
        // Make sure bean class is actually resolved at this point.
        Class&amp;lt;?&amp;gt; beanClass = resolveBeanClass(mbd, beanName);

        /**
         * todo 检测一个类的访问权限， Spring默认是 允许访问非public类型的方法
         */
        if (beanClass != null &amp;amp;&amp;amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;amp;&amp;amp; !mbd.isNonPublicAccessAllowed()) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());
        }

        /**
         *  创建一个bean的快捷方式
         */
        boolean resolved = false;
        boolean autowireNecessary = false; // todo 是否是必须自动装配
        if (args == null) {
            synchronized (mbd.constructorArgumentLock) {

                // todo
                if (mbd.resolvedConstructorOrFactoryMethod != null) {
                    resolved = true;
                    //如果已经解析了构造方法的参数，则必须要通过一个带参构造方法来实例
                    autowireNecessary = mbd.constructorArgumentsResolved;
                }
            }
        }

        if (resolved) {
            if (autowireNecessary) {// todo 如果是需要自动注入的，就使用构造方法自动注入
                // 通过构造方法自动装配的方式构造 bean 对象
                return autowireConstructor(beanName, mbd, null, null);
            }
            else {
                //通过默认的无参构造方法进行
                //todo 通过默认的无参构造方法
                return instantiateBean(beanName, mbd);
            }
        }

        Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
        if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
            // todo 使用特定的构造方法完成自动装配
            return autowireConstructor(beanName, mbd, ctors, args);
        }

        // No special handling: simply use no-arg constructor.
        //todo 使用默认的无参构造方法进行初始化
        return instantiateBean(beanName, mbd);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们主要关注上面代码的&lt;code&gt;determineConstructorsFromBeanPostProcessors(beanClass, beanName)&lt;/code&gt;这个方法的目的就是推测实例化需要的构造方法, 为什么需要先推测构造方法呢? 因为Spring实例化对象时,需要使用特定的构造方法才能反射出对象,&lt;strong&gt;这时如果程序员指定了带参数的构造方法,spring就会使用这个构造方法实例化对象,如果程序员提供了一个不带任何参数的默认构造方法,Spring会忽略它,按自己的逻辑使用默认的无参构造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以上面的if-else分支目的很明确,先是尝试获取全部的构造方法,然后看看有没有解析出来构造方法, 解析出来的话,就使用第一种逻辑,按照 特殊的构造方法模式进行处理,有解析出来,就使用默认的构造方法&lt;/p&gt;
&lt;p&gt;我们进一步跟进这个&lt;code&gt;determineConstructorsFromBeanPostProcessors(beanClass, beanName)&lt;/code&gt;方法,&lt;strong&gt;可以发现方法里面又是一波后置处理器的回调工作,这次选出的后置处理器的类型是&lt;code&gt;SmartInstantiationAwareBeanPostProcessor&lt;/code&gt;,见名知意,这种处理器可以感知到心仪的构造方法,它的主要实现逻辑就是,查看这个将被实例化的对象中有没有添加了&lt;code&gt;@Lookup&lt;/code&gt;注解的方法,有的话为这种方法生成代理,循环遍历所有的构造方法,看看这些构造方法上存在不存在&lt;code&gt;@Value&lt;/code&gt;或者&lt;code&gt;@Autowired&lt;/code&gt;注解,因为这些注解中存在required=true,只要存在这种注解,Spring就将他当成候选的构造方法,但是如果存在多个的话,Spring也不知道到底用哪一个,但是在这里Spring会将所有符合条件的都选出来,但是一般情况下,都可以正确的选出合适的构造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择出合适构造方法之后,就根据不同的构造方法,选择使用不同的方式去实例化对象, 都有什么方式呢? 两种方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是比较复杂的方式,此时Spring需要在这个方法内存比较好几个候选的构造方法,计算它们的差异值,最终值最小的构造函数就是将要用来实例化对象的构造函数,当然很可能是选不出合适的构造函数的,于是Spring没有立即抛出异常,而是将异常添加进bean工厂的suppressedExceptions这个set集合中&lt;/p&gt;
&lt;p&gt;如果成功的选择出来一个构造函数,就会使用jdk原生的反射机制,实例化一个对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; autowireConstructor(beanName, mbd, ctors, args);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接使用JDK原生的反射机制,实例化一个对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;instantiateBean(beanName, mbd);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小结:&lt;/p&gt;
&lt;p&gt;代码看到这里,方才说的有才华的那个类&lt;code&gt;AbstactAutowiredCapatableBeanFactory&lt;/code&gt;中的&lt;code&gt;doCreateBean()&lt;/code&gt;方法的&lt;code&gt;instanceWrapper = createBeanInstance(beanName, mbd, args);&lt;/code&gt; 也就看完了, &lt;strong&gt;到这里也就知道了,Spring会先把所有满足条件的bean全部实例化存放起来,这里的对象是百分百原生java对象,不掺水不含糖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着往下看,我把代码重写贴出来, 下面还有五件大事,这四件大事说完了,本文就结束了&lt;/p&gt;
&lt;p&gt;第一: 是&lt;code&gt;applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&lt;/code&gt; 回调后置处理器,进行有关注解的缓存操作&lt;/p&gt;
&lt;p&gt;第二: 是&lt;code&gt;getEarlyBeanReference(beanName, mbd, bean)&lt;/code&gt; 获取一个提早暴露的beanDefinition对象,用于解决循环依赖问题&lt;/p&gt;
&lt;p&gt;第三: 将刚才创建原生java对象存放一个叫&lt;code&gt;singletonFactories&lt;/code&gt;的map中,这也是为了解决循环依赖而设计的数据结构,举个例子: 现在准备创建A实例, 然后将A实例添加到这个&lt;code&gt;singletonFactories&lt;/code&gt;中, 继续运行发现A实例依赖B实例,于是在创建B实例,接着又发现B实例依赖A实例,于是从&lt;code&gt;singletonFactories&lt;/code&gt;取出A实例完成装配,再将B返回给A,完成A的装配&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    synchronized (mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {

                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Post-processing of merged bean definition failed&quot;, ex);
                }
                mbd.postProcessed = true;
            }
        }

        // Eagerly cache singletons to be able to resolve circular references
        // even when triggered by lifecycle interfaces like BeanFactoryAware.
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Eagerly caching bean '&quot; + beanName +
                        &quot;' to allow for resolving potential circular references&quot;);
            }

            // todo  重点再来看这个 addSingleFactory
            // todo  将原始对象new出来之后放到了  这个方法中的map中
            addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
        }

        // Initialize the bean instance.
        Object exposedObject = bean; // todo 到目前为止还是原生对象
        try {
            //todo  用来填充属性
            //设置属性，非常重要
            populateBean(beanName, mbd, instanceWrapper);

            // todo 经过AOP处理,原生对象转换成了代理对象,跟进去
            //执行后置处理器，aop就是在这里完成的处理
            exposedObject = initializeBean(beanName, exposedObject, mbd);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着看&lt;code&gt;populateBean(beanName, mbd, instanceWrapper);&lt;/code&gt;方法,&lt;strong&gt;这个方法很重要,就是在这个方法中进行bean属性的装配工作,啥意思呢? 比如现在装配A实例,结果发现A实例中存在一个属性是B实例,这是就得完成自动装配的工作,源码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果仔细看,就会发现两个事:&lt;/p&gt;
&lt;p&gt;第一: 如果不出意外,就会出现两次后置处理器的回调,第一后置处理器的回调是判断当前的bean中是否存在需要装配的属性,而第二波后置处理器的回调就是实打实的去完成装配的动作&lt;/p&gt;
&lt;p&gt;第二: 下面的第一个处理器其实就是spring启动过程中第一个回调的处理器,只不过调用了这个处理器的不同的方法&lt;code&gt;postProcessAfterInstantiation()&lt;/code&gt;,默认返回ture表示按照正常的流程装配对象的属性,返回false,表示不会继续装配对象中的任何属性&lt;/p&gt;
&lt;p&gt;而我们则继续关注下面方法中的第二个后置处理器的,看看Spring是如何完成属性的自动装配的,关于这部分的跟踪,我写在下面代码的后面&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
        if (bw == null) {
            if (mbd.hasPropertyValues()) {
                throw new BeanCreationException(
                        mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
            }
            else {
                // Skip property population phase for null instance.
                return;
            }
        }

        // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
        // state of the bean before properties are set. This can be used, for example,
        // to support styles of field injection.
        boolean continueWithPropertyPopulation = true;

        if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof InstantiationAwareBeanPostProcessor) {
                    //todo 进行了强转, InstantiationAwareBeanPostProcessor这个接口前面说过
                    // todo 只要是通过这个接口返回出来的bean Spring不在管这个bean,不给他装配任何属性
                    //todo 当前这里没有用它这个变态的特性
                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    // todo postProcessAfterInstantiation()默认是返回true, 加上! 表示false
                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                        continueWithPropertyPopulation = false;
                        break;
                    }
                }
            }
        }

        if (!continueWithPropertyPopulation) {
            return;
        }
        // todo Spring内部可以对BeanDefinition进行设置值, 参照自定义的 BeanFactory中获取到BeanDefinition.getPropertyValue().addXXX();
        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

        // todo 判断当前bean的解析模型是 byName 还是 byType
        // todo 再次验证了:::   当程序员直接使用@Autowired注解时, 既不是ByName 也不是ByType, 而是No
        if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {
            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
            // Add property values based on autowire by name if applicable.
            if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) {
                autowireByName(beanName, mbd, bw, newPvs);
            }
            // Add property values based on autowire by type if applicable.
            if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {
                autowireByType(beanName, mbd, bw, newPvs);
            }
            pvs = newPvs;
        }

        boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
        boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

        if (hasInstAwareBpps || needsDepCheck) {
            if (pvs == null) {
                pvs = mbd.getPropertyValues();
            }
            //todo 获取出对象的所有set get方法,现在是有一个 getClass()方法,因为继承了Object, 没什么其他卵用
            PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            if (hasInstAwareBpps) {

                for (BeanPostProcessor bp : getBeanPostProcessors()) {
                    if (bp instanceof InstantiationAwareBeanPostProcessor) {
                    
                        pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                        if (pvs == null) {
                            return;
                        }
                    }
                }
            }
            if (needsDepCheck) {
                checkDependencies(beanName, mbd, filteredPds, pvs);
            }
        }

        if (pvs != null) {
            applyPropertyValues(beanName, mbd, bw, pvs);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好,继续跟进&lt;code&gt;pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(),&lt;/code&gt;,看看spring如何完成属性的自动装配,当然,还是那句话,如果我们直接跟进去这个方法进入的是&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;抽象接口抽象方法,而我们关注的是它的实现类&lt;code&gt;AutowiredAnnotationBeanDefinitionPostProcessor&lt;/code&gt;的实现,打上断点依次跟进&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public PropertyValues postProcessPropertyValues(
            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {

        InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
        try {
            // todo 跟进来, 目的是  为 beanName 填充上属性 bean
            metadata.inject(bean, beanName, pvs);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;metadata.inject(bean, beanName, pvs);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码如下:&lt;/p&gt;
&lt;p&gt;可以这样理解,在下面的方法中遍历当前对象中所有可能需要依赖注入的属性字段&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
        // todo 这里的  InjectedElement 表示单个的需要注入的元素对象
        Collection&amp;lt;InjectedElement&amp;gt; checkedElements = this.checkedElements;
        Collection&amp;lt;InjectedElement&amp;gt; elementsToIterate = (checkedElements != null ? checkedElements : this.injectedElements);
        if (!elementsToIterate.isEmpty()) {
            for (InjectedElement element : elementsToIterate) {
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Processing injected element of bean '&quot; + beanName + &quot;': &quot; + element);
                }
                //todo 跟进  AutowiredAnnotationBeanPostProcessor 对这个方法的实现, 在600多行处
                element.inject(target, beanName, pvs);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进这个&lt;code&gt;inject()&lt;/code&gt; 我是手动删除了这个方法中其他的很多判断,仅仅保存下来了下面我们关注的逻辑,&lt;strong&gt;逻辑很清楚,上面的代码中不是在遍历所有需要自动装配的field吗?如果找到了的话,就得完成自动装配,自动装配什么呢? 其实就是自动装配上当前对象依赖的其他的对象而已,因为我们使用的后置处理器是&lt;code&gt;AutowireAnnotationBeanPostProcessor&lt;/code&gt;通过下面的代码就能得出结论就是&lt;code&gt;@Autowired&lt;/code&gt;默认情况下是通过反射实现的自动装配&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // todo 来到这里
        @Override
        protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
            Field field = (Field) this.member;
            Object value;
            value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
            if (value != null) {
                ReflectionUtils.makeAccessible(field);
                field.set(bean, value);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们一路往下跟进&lt;code&gt;resolveDependency()&lt;/code&gt;我们关注这个方法如下代码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (instanceCandidate instanceof Class) {// todo !!!!!当运行到这行代码时, myService还没有被实例化(singletonObjects中没有) 执行完这一个行代码之后, IndexDao1完成了对myService的装配
        instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进这个&lt;code&gt;resolveCandidate()&lt;/code&gt;源码如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很直接发现,出现的递归的现象,这其实解析清楚了Spring是如何完成属性注入的,就是只不过前前后后很多接口很多类,会扰乱这个阅读的过程&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Object resolveCandidate(String beanName, Class&amp;lt;?&amp;gt; requiredType, BeanFactory beanFactory)
        throws BeansException {
    // todo 从bean工厂的获取,  beanName = myService   requiredType = com.changwu...OrderService2 , 跟进去这个方法, 他调用了AbstractBeanFactory中的getBean(){ doGetBean();}
    return beanFactory.getBean(beanName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成装配后,其实现在的对象依然是原生的java对象 回到&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;中的&lt;code&gt;initializeBean()&lt;/code&gt;方法,源码如下, 看了下面的代码就是知道了为什么&lt;code&gt;applyBeanPostProcessorsBeforeInitialization&lt;/code&gt;和&lt;code&gt;init()&lt;/code&gt;和&lt;code&gt;applyBeanPostProcessorsAfterInitialization()&lt;/code&gt;之间的调用顺序了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有最后一个秘密需要揭开: Spring的AOP不是产生了代理对象? 那什么时候完成的代理呢?毕竟从我开始写这篇文章到最后都没有看到,其实AOP的实现就在下面的代码中&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
    if (System.getSecurityManager() != null) {
        AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
            invokeAwareMethods(beanName, bean);
            return null;
        }, getAccessControlContext());
    }
    else {
        invokeAwareMethods(beanName, bean);
    }

    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        //todo 执行全部的后置处理器的 Before方法
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }

    try {
        // todo 执行所有的init方法
        invokeInitMethods(beanName, wrappedBean, mbd);
    }
    catch (Throwable ex) {
        throw new BeanCreationException(
                (mbd != null ? mbd.getResourceDescription() : null),
                beanName, &quot;Invocation of init method failed&quot;, ex);
    }
    if (mbd == null || !mbd.isSynthetic()) {
        // todo 执行所有的后置处理器的 after方法
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }

    return wrappedBean;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在前面知道当遇到这个&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;时,回调它的&lt;code&gt;before()&lt;/code&gt;方法时,仅仅是标记哪些对象需要进行增强哪些对象不需增强,而没有立即生成代理对象&lt;/p&gt;
&lt;p&gt;现在我们关注这行代码&lt;code&gt;wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);&lt;/code&gt; ,生成代理对象的逻辑就在这里面&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException {
    if (bean != null) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        if (!this.earlyProxyReferences.contains(cacheKey)) {
            // todo 进入
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看这个方法&lt;code&gt;wrapIfNecessary(bean, beanName, cacheKey);&lt;/code&gt;最终会进入这个实现中&lt;/p&gt;
&lt;p&gt;大家可以看到Spring为bean生成了代理对象,默认会先检查被代理的对象有没有实现接口,如果实现了接口,就是用jdk动态代理,否则就看看有没有cglib的相关依赖,如果存在的相关依赖而没有实现接口,就会使用cglib的代理模式&lt;/p&gt;
&lt;p&gt;另外,补充通过编码的方式控制 下面的if条件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;config.isOptimize()&lt;/code&gt; -&amp;gt; 可以通过XMl配置， 默认false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config.isProxyTargetClass()&lt;/code&gt; -&amp;gt; &lt;code&gt;@EnableAspectjAutoPeoxy(true)&lt;/code&gt; 默认也是false&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SuppressWarnings(&quot;serial&quot;)
public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {
@Override
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {

    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
        Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
        if (targetClass == null) {
            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                    &quot;Either an interface or a target is required for proxy creation.&quot;);
        }
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            //todo 目标对象是一个接口, 同样是使用jdk的动态代理
            return new JdkDynamicAopProxy(config);
        }
        return new ObjenesisCglibAopProxy(config);
    }
    else {
        // todo 所以默认使用的是 jdk的动态代理
        return new JdkDynamicAopProxy(config);
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 28 Oct 2019 14:20:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>源码入口 上篇博文中我们看到了将Spring环境中的 BeanPostProcessor找出来,添加到BeanFactory中的beanPostProcessors中,统一维护,本片博文继续往下拓展,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11755973.html</dc:identifier>
</item>
</channel>
</rss>