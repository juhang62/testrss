<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Android之友盟多渠道打包与数据统计 - 故事爱人</title>
<link>http://www.cnblogs.com/WUXIAOCHANG/p/10683942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WUXIAOCHANG/p/10683942.html</guid>
<description>&lt;h2&gt;文章大纲&lt;/h2&gt;
&lt;p&gt;一、多渠道打包与数据统计介绍&lt;br/&gt;二、友盟实现多渠道打包实战&lt;br/&gt;三、友盟数据统计实战&lt;br/&gt;四、项目源码下载&lt;br/&gt;五、参考文章&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1239&quot; data-height=&quot;584&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-ffeb5447ff1cbe66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-ffeb5447ff1cbe66.png&quot; data-original-width=&quot;1239&quot; data-original-height=&quot;584&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;112432&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;一、多渠道打包与数据统计介绍&lt;/h2&gt;
&lt;p&gt;  多渠道打包，相信很多同学都知道。在Android Studio中只要经过配置，就能打出对应市场的渠道包。打过包的同学可能都会有这样的感受：散热器疯狂地转、打包速度那叫一个慢。这时候除了无奈，还是无奈。&lt;br/&gt;  app上线后，一般公司都希望跟踪app在市场上的使用情况。包括新增用户、活跃用户、渠道信息、错误信息等，还有例如商城类的app，需要跟踪用户最喜欢浏览哪种类型的店铺或商品&lt;br/&gt;  针对上面问题，如果我们自己手动去一个个处理，那么会崩溃的，因此已经有相关第三方平台做好了这方面功能，我们进行集成即可。多渠道打包和数据统计的第三方有很多，在此我们使用友盟平台进行实战。&lt;/p&gt;
&lt;h2&gt;二、友盟实现多渠道打包实战&lt;/h2&gt;
&lt;h3&gt;1. 接入前准备工作&lt;/h3&gt;
&lt;h4&gt;（1）获取AppKey&lt;/h4&gt;
&lt;p&gt;  集成【友盟+】SDK之前，您首先需要到 【友盟+】&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.umeng.com%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;注册并且添加新应用，获得AppKey。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;特别提醒 ：我们建议开发者在注册账号时使用企业邮箱，避免使用个人邮箱注册，防止由于个人离职带来的问题，建议使用的账号形式：umeng@企业域名、apps@企业域名、dev@企业域名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;640&quot; data-height=&quot;480&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-6a82116f045f8490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-6a82116f045f8490.png&quot; data-original-width=&quot;640&quot; data-original-height=&quot;480&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;102095&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;常见问题&lt;br/&gt;问题1 ：应用的安卓版和iOS版能否共用一个AppKey。&lt;br/&gt;答案：不同平台的应用禁止使用相同的AppKey，需要分开注册。&lt;br/&gt;问题2 ：注册应用时，提示应用名称已存在。&lt;br/&gt;答案 ：【友盟+】后台的应用名与实际应用名和包名无关，建议命名为应用名+平台（iOS/Android)。&lt;/p&gt;
&lt;h4&gt;（2）build.gradle添加相关配置&lt;/h4&gt;
&lt;p&gt;  在工程build.gradle配置脚本中buildscript和allprojects段中添加【友盟+】sdk 新maven仓库地址&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;buildscript {
    
    repositories {
        google()
        jcenter()
        mavenCentral()

        &lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（3）工程build.gradle配置&lt;/h4&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;   &lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（4）添加相关权限&lt;/h4&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;/&gt;
&lt;/pre&gt;
&lt;h4&gt;（5）AndroidManifest清单配置文件方式初始化appkey和channel&lt;/h4&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;/&gt;
&lt;/pre&gt;
&lt;h4&gt;（6）自定义Application&lt;/h4&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyApplication &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Application {

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate();
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;2. 实现多渠道打包代码&lt;/h3&gt;
&lt;h4&gt;（1）添加多渠道打包&lt;/h4&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;更新项目时候出现异常&lt;br/&gt;  当我们更新项目时候，可能会出现以下异常&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Error:All flavors must now belong to a named flavor dimension. Learn more at https:&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法如下：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;defaultConfig {
      ...
      &lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（2）配置完成后project的build.gradle&lt;/h4&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;h4&gt;（3）配置完成后app的build.gradle&lt;/h4&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;code class=&quot;php&quot;&gt;apply plugin: &lt;span class=&quot;hljs-string&quot;&gt;'com.android.application'

android {
    compileSdkVersion &lt;span class=&quot;hljs-number&quot;&gt;28
    defaultConfig {
        applicationId &lt;span class=&quot;hljs-string&quot;&gt;&quot;com.example.wxc.testpackage&quot;
        minSdkVersion &lt;span class=&quot;hljs-number&quot;&gt;15
        targetSdkVersion &lt;span class=&quot;hljs-number&quot;&gt;28
        versionCode &lt;span class=&quot;hljs-number&quot;&gt;1
        versionName &lt;span class=&quot;hljs-string&quot;&gt;&quot;1.0&quot;
        testInstrumentationRunner &lt;span class=&quot;hljs-string&quot;&gt;&quot;android.support.test.runner.AndroidJUnitRunner&quot;

        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（4）配置完成后的AndroidManifest.xml&lt;/h4&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1.0&quot; encoding=&lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;&lt;span class=&quot;hljs-meta&quot;&gt;?&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;manifest &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:android=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;
    &lt;span class=&quot;hljs-attr&quot;&gt;package=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.example.wxc.testpackage&quot;&amp;gt;

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（5）添加多渠道信息统计&lt;/h4&gt;
&lt;p&gt;  即启动数据的统计（包括新增用户、活跃用户、启动次数、使用时长等基本数据）&lt;br/&gt;  需要在每个Activity的onResume方法中调用 MobclickAgent.onResume(Context),&lt;br/&gt;onPause方法中调用 MobclickAgent.onPause(Context)，如下：&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MainActivity &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;AppCompatActivity {

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;(Bundle savedInstanceState) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        MobclickAgent.onResume(&lt;span class=&quot;hljs-keyword&quot;&gt;this);

        Button button = findViewById(R.id.checkButton);

        button.setOnClickListener(&lt;span class=&quot;hljs-keyword&quot;&gt;new View.OnClickListener() {
            &lt;span class=&quot;hljs-meta&quot;&gt;@Override
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onClick&lt;span class=&quot;hljs-params&quot;&gt;(View v) {

                Toast.makeText(MainActivity.&lt;span class=&quot;hljs-keyword&quot;&gt;this, &lt;span class=&quot;hljs-string&quot;&gt;&quot;点击了&quot;, Toast.LENGTH_SHORT).show();

                MobclickAgent.onEvent(MainActivity.&lt;span class=&quot;hljs-keyword&quot;&gt;this, &lt;span class=&quot;hljs-string&quot;&gt;&quot;checkButton&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;温馨提示：&lt;br/&gt;（1）如果Activity之间有继承或者控制关系请不要同时在父和子Activity中重复添加nPause和nResume方法，否则会造成重复统计。例如在BaseActivity中添加过，则它的子类就不需要添加了。&lt;br/&gt;（2）当应用在后台运行超过30秒（默认）再回到前端，将被认为是两个独立的session(启动)，例如用户回到home，或进入其他程序，经过一段时间后再返回之前的应用。可通过接口：setSessionContinueMillis(long interval) 来自定义这个间隔（参数单位为毫秒）。&lt;br/&gt;（3）如果开发者调用kill或者exit之类的方法杀死进程，请务必在此之前调用onKillProcess(Context context)方法，用来保存统计数据。&lt;/p&gt;
&lt;h4&gt;（6）项目打包&lt;/h4&gt;
&lt;p&gt;选择Generate Signed APK&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;586&quot; data-height=&quot;672&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-2f985f9db1fd7022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/586/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-2f985f9db1fd7022.png&quot; data-original-width=&quot;586&quot; data-original-height=&quot;672&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;218303&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;新建一个签名文件&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1234&quot; data-height=&quot;678&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2720645-71c56ff9552fb8ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/2720645-71c56ff9552fb8ff.png&quot; data-original-width=&quot;1234&quot; data-original-height=&quot;678&quot; data-original-format=&quot;&quot; data-original-filesize=&quot;91403&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;填写信息&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1000&quot; data-height=&quot;896&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-cf10c9f217e5f06d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-cf10c9f217e5f06d.png&quot; data-original-width=&quot;1000&quot; data-original-height=&quot;896&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;425197&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;486&quot; data-height=&quot;312&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-ccb9161ead5465d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/486/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-ccb9161ead5465d6.png&quot; data-original-width=&quot;486&quot; data-original-height=&quot;312&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27743&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1016&quot; data-height=&quot;571&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-821a60b215f7c9da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-821a60b215f7c9da.png&quot; data-original-width=&quot;1016&quot; data-original-height=&quot;571&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;97410&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;补充说明：&lt;br/&gt;（1）android 7.0中引入了APK Signature Scheme v2，v1呢是jar Signature来自JDKV1：应该是通过ZIP条目进行验证，这样APK 签署后可进行许多修改 - 可以移动甚至重新压缩文件。（2）V2：验证压缩文件的所有字节，而不是单个 ZIP 条目，因此，在签名后无法再更改(包括 zipalign)。正因如此，现在在编译过程中，我们将压缩、调整和签署合并成一步完成。好处显而易见，更安全而且新的签名可缩短在设备上进行验证的时间（不需要费时地解压缩然后验证），从而加快应用安装速度。v1和v2的签名使用：&lt;br/&gt;（4）只勾选v1签名并不会影响什么，但是在7.0上不会使用更安全的验证方式，只勾选V2签名7.0以下会直接安装完显示未安装，7.0以上则使用了V2的方式验证。同时勾选V1和V2则所有机型都没问题&lt;/p&gt;
&lt;p&gt;运行结果如下所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1109&quot; data-height=&quot;358&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-8e44a3861cc32fbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-8e44a3861cc32fbe.png&quot; data-original-width=&quot;1109&quot; data-original-height=&quot;358&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;88353&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;（7）运行结果&lt;/h4&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1109&quot; data-height=&quot;358&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-bf480c46c8976fe6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-bf480c46c8976fe6.png&quot; data-original-width=&quot;1109&quot; data-original-height=&quot;358&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;88353&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当我们用手机安装apk后，在友盟后台可看到以下统计&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1439&quot; data-height=&quot;801&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-fe5a6e9f516fa776.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-fe5a6e9f516fa776.png&quot; data-original-width=&quot;1439&quot; data-original-height=&quot;801&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;119785&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;三、友盟数据统计实战&lt;/h2&gt;
&lt;h3&gt;1. 自定义点击事件&lt;/h3&gt;
&lt;p&gt;  自定义事件可以实现在应用程序中埋点来统计用户的点击行为。例如我们的应用需要统计用户是点击了“，还是cheackButton按钮。自定义事件目前包括&quot;计数事件&quot;和&quot;计算事件&quot;，这里主要讲下计数事件。&lt;br/&gt;1、首先需要在友盟后台添加自定义事件：设置-事件-手工添加-添加事件。如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1439&quot; data-height=&quot;690&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-849751e612b3df8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-849751e612b3df8e.png&quot; data-original-width=&quot;1439&quot; data-original-height=&quot;690&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;81370&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在需要统计位置中加入以下代码&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;button.setOnClickListener(&lt;span class=&quot;hljs-keyword&quot;&gt;new View.OnClickListener() {
            &lt;span class=&quot;hljs-meta&quot;&gt;@Override
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onClick&lt;span class=&quot;hljs-params&quot;&gt;(View v) {

                Toast.makeText(MainActivity.&lt;span class=&quot;hljs-keyword&quot;&gt;this, &lt;span class=&quot;hljs-string&quot;&gt;&quot;点击了&quot;, Toast.LENGTH_SHORT).show();

                MobclickAgent.onEvent(MainActivity.&lt;span class=&quot;hljs-keyword&quot;&gt;this, &lt;span class=&quot;hljs-string&quot;&gt;&quot;checkButton&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序后，在友盟后台可看到以下结果&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1439&quot; data-height=&quot;559&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-7407c48086313ee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-7407c48086313ee4.png&quot; data-original-width=&quot;1439&quot; data-original-height=&quot;559&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;87417&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2. 错误统计&lt;/h3&gt;
&lt;p&gt;  组件化统计SDK内建JVM层错误统计。SDK通过Thread.UncaughtExceptionHandler 捕获程序崩溃日志，并在程序下次启动时发送到服务器。&lt;br/&gt;  如不需要错误统计功能，可通过此方法关闭：&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;参数 含义&lt;br/&gt;isEnable 错误统计开关，false-关闭错误统计功能；true-打开错误统计功能（默认打开）。&lt;br/&gt;如果开发者自己捕获了错误，需要手动上传到【友盟+】服务器可以调用下面方法：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;代码:复制代码到剪切板
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;reportError&lt;span class=&quot;hljs-params&quot;&gt;(Context context, String error);   
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数 含义&lt;br/&gt;context 当前宿主进程的ApplicationContext上下文。&lt;br/&gt;error 错误内容字符串。&lt;br/&gt;e 错误发生时抛出的异常对象。&lt;/p&gt;
&lt;h3&gt;3.总结&lt;/h3&gt;
&lt;p&gt;  友盟还提供了其他的统计方法，包括页面统计、账号统计等，具体的功能事情请参考友盟的开发者文档：&lt;br/&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.umeng.com%2Fdocs%2F66632%2Fdetail%2F101848%23h2-u9519u8BEFu7EDFu8BA111&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://developer.umeng.com/docs/66632/detail/101848#h2-u9519u8BEFu7EDFu8BA111&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;四、项目源码下载&lt;/h2&gt;
&lt;p&gt;链接:&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1sUKsyJUNQLJ4j65_ZxkNZQ&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1sUKsyJUNQLJ4j65_ZxkNZQ&lt;/a&gt;&lt;br/&gt;密码:yvqs&lt;/p&gt;
&lt;h2&gt;五、参考文章&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/e4da2f477cd8&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/e4da2f477cd8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/e4da2f477cd8&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/e4da2f477cd8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/3acba4233bc6&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/3acba4233bc6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/476ba5953d94&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/476ba5953d94&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 10 Apr 2019 07:55:00 +0000</pubDate>
<dc:creator>故事爱人</dc:creator>
<og:description>文章大纲 一、多渠道打包与数据统计介绍二、友盟实现多渠道打包实战三、友盟数据统计实战四、项目源码下载五、参考文章 一、多渠道打包与数据统计介绍 多渠道打包，相信很多同学都知道。在Android Stu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WUXIAOCHANG/p/10683942.html</dc:identifier>
</item>
<item>
<title>浅谈ETL架构中ODS的作用以及如何在HaoheDI中自动创建ODS表 - 昊合DI</title>
<link>http://www.cnblogs.com/haohedi/p/10683596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haohedi/p/10683596.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是ODS表？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在ETL架构中，源数据很少会直接抽取加载到数据仓库EDW，二者之间往往会设置一个源数据的临时存储区域，存储数据在清洗转换前的原始形态，通常被大家称做操作型数据存储，简称ODS，在Kimball维度建模理论中，将其称之为Staging Area（意为部队从一个战场转往另一个战场的集结地），翻译过来称之为数据登台区，如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151808394-1183803190.jpg&quot;&gt;&lt;img title=&quot;img_20190307_112911&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151808977-729762590.jpg&quot; alt=&quot;img_20190307_112911&quot; width=&quot;861&quot; height=&quot;486&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;上图摘自Ralph Kimball的《数据仓库生命周期工具箱》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么需要ODS？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ODS在整个数据中心体系架构中的具有非常重要的作用，体现在以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;统一源数据的数据格式，降低数据清洗转换的复杂性&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;一般的数据仓库应用系统都具有非常复杂的数据来源，这些数据存放在不同的地理位置、不同的数据库、不同的应用之中，从这些业务系统对数据进行抽取并不是一件容易的事，比如有时源和目标不能直接连通，数据可能会用文件方式上传上来，这就需要将原始数据先落地到ODS中。因此，ODS用于存放从业务系统直接抽取出来的数据，这些数据从数据结构、数据之间的逻辑关系上都与业务系统基本保持一致，因此在抽取过程中极大降低了数据转化的复杂性，而主要关注数据抽取的接口、数据量大小、抽取方式等方面的问题。各种原始数据以统一的格式存放在一个数据库中，更加便于后续的数据清洗与转换。&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;span&gt;保留原始数据当时时点的快照，便于数据转换后的校验排错和批次重跑&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;业务系统中的数据是会发生增删改变化的，尤其是像客户、产品、机构这样的维度数据，其状态和属性都会随着时间不断改变，而数据仓库是需要记录并分析其历史状态的，如缓慢变化维（拉链表）和快照型事实表，在得到最终的统计分析结果之前，数据会经过一层一层的转换加工，期间会有大量的计算和处理逻辑，在ETL开发和运维过程中，经常会发现某些公式或处理逻辑有误，修改之后不得不重跑之前一系列的批次数据，如果之前没有保留这些时点上的原始数据，则很多数据重跑将变得不可能，因为源系统中的部分数据已经发生了变化，另外将数据快照下来也便于和前端统计查询结果进行校验核对，以便找出出错原因。&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;转移一部分业务系统细节查询的功能，并可以支持实时数据的查询统计&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;在数据仓库建立之前，大量的报表、分析是由业务系统直接支持的，在一些比较复杂的报表生成过程中，对业务系统的运行产生相当大的压力。ODS的数据从粒度、 组织方式等各个方面都保持了与业务系统的一致，那么原来由业务系统产生的报表、细节数据的查询自然能够从ODS中进行，从而降低业务系统的查询压力。另外由于从源数据到最终的分析结果，需要经历较长时间的ETL转换，所以一些对实时性要求比较高的查询分析是可以直接从ODS中取数的，比如风控预警和实时仪表盘。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ODS表长什么样？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ODS通常采用数据库进行存储，只存储对数据分析有价值的源数据，数据结构通常和源非常相似，在源表结构基础上会扩充字段以表示数据来源、数据日期、导入时间等审计信息。一个ODS表的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151809346-1954731360.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151809775-968430365.png&quot; alt=&quot;clipboard&quot; width=&quot;943&quot; height=&quot;427&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个表存储每天按时间戳增量抽取的血糖检测记录，名称用O_前缀进行标识。红色区域的字段基本上和源表结构保持一致，也可以只存后期数仓中需要的字段，去掉一些没有必要的字段，另外一些字段类型也可以做简单的改变，但要确保可以记录原始数据的原貌。开头的两个字段是ODS表新增的审计字段，其中ETLBATCHID表示数据的批次号，用于表示是哪个时期（点）的数据，如果数据每天一个批次的话，这里将会存一个数字型日期如20190301（YYYYMMDD），如果是每小时一个批次的话，这里可能会存一个带小时的数字型时间如2019030108（YYYYMMDDHH），之所以存成数字型，是因为数字型占的空间更小，检索更快，另外在书写SQL是也比较简便。当然也可根据需要设为字符型或日期型。PROCESSTIME字段用来表示数据被抽取加载到ODS表的系统时间，该字段也可以省略。另外如果ODS表中的数据来自于多个数据源，则可以增加一个审计字段来表示数据的来源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于某些没有时间戳的维度表、代码表，其对应的ODS表要如何设计呢？其实也和上边的表一样，只需要在源表的结构之前增加批次号等审计字段即可，比如用户信息表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151810287-1244636112.png&quot;&gt;&lt;img title=&quot;clipboard[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151810849-1691296419.png&quot; alt=&quot;clipboard[1]&quot; width=&quot;954&quot; height=&quot;586&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果无法通过时间戳或操作日志来判断哪些用户信息发生了改变的话，则每次抽取数据时选择全量抽取，即将源表中的这个时点的数据全部抽到ODS表，由于每次的快照都已存储下来，虽然有较大的冗余，但却非常便于在后续的ETL中利用比对的方式来判断哪些数据发生了变化。如果数据量较大，也可以采用表分区的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何快速批量的创建ODS表？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源系统的数据库类型多种多样，其中的表成百上千，针对这么多需要抽取的源表，有什么简便的方式能快速生成对应这些源表的ODS表吗？HaoheDI提供了一个的功能可以快速生成这些表，操作步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、在数据连接中选择要生成ODS表的目标数据库（数据中心），点击创建ODS表按钮：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151811354-970477461.png&quot;&gt;&lt;img title=&quot;clipboard[2]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151812051-1568385700.png&quot; alt=&quot;clipboard[2]&quot; width=&quot;809&quot; height=&quot;527&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、弹出页面后，点击“选择源表”，选择对应的源连接和源表。如图：选择源数据库LOCALMYSQL中的这6张源表作为在HYDW目标数据库中对应的ODS表的模板。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151812825-555004134.png&quot;&gt;&lt;img title=&quot;clipboard[3]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151813309-215960459.png&quot; alt=&quot;clipboard[3]&quot; width=&quot;813&quot; height=&quot;550&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、删减部分表中不必要的字段，这样在ODS表中将不会创建这个字段，默认是创建全部字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151813793-498689427.png&quot;&gt;&lt;img title=&quot;clipboard[4]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151814277-631541873.png&quot; alt=&quot;clipboard[4]&quot; width=&quot;814&quot; height=&quot;439&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、设置ODS表的命名规则，比如在源表名之前增加O_，也可以在表名之后添加后缀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151814638-1940617903.png&quot;&gt;&lt;img title=&quot;clipboard[5]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151815001-1149509149.png&quot; alt=&quot;clipboard[5]&quot; width=&quot;614&quot; height=&quot;261&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、在自定义字段一栏中，选择要在ODS表中添加的审计字段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151815413-1978871018.png&quot;&gt;&lt;img title=&quot;clipboard[6]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151815806-451509596.png&quot; alt=&quot;clipboard[6]&quot; width=&quot;616&quot; height=&quot;305&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：每个表都将创建三个审计字段，设定其名称、字段类型、字段长度以及创建位置，保存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151816182-1799637162.png&quot;&gt;&lt;img title=&quot;clipboard[7]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151816618-119510872.png&quot; alt=&quot;clipboard[7]&quot; width=&quot;819&quot; height=&quot;316&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、其它表如果各项设定相同则选择同上即可，按Ctrl键选择全部或部分表，点击创建ODS表按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151817068-1741635617.png&quot;&gt;&lt;img title=&quot;clipboard[8]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151817558-2028773061.png&quot; alt=&quot;clipboard[8]&quot; width=&quot;821&quot; height=&quot;270&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显示ODS表创建成功或失败的信息，建表语句在后台hhdilogs\common\日志中查看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151818067-628102989.png&quot;&gt;&lt;img title=&quot;clipboard[9]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151818524-1268976837.png&quot; alt=&quot;clipboard[9]&quot; width=&quot;824&quot; height=&quot;315&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、在目标数据连接的元数据中将新生成的ODS表结构导入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151819015-128135092.png&quot;&gt;&lt;img title=&quot;clipboard[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151819393-552012569.png&quot; alt=&quot;clipboard[10]&quot; width=&quot;420&quot; height=&quot;473&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看表结构，检查表结构是否符合设定的规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151820180-1035089580.png&quot;&gt;&lt;img title=&quot;clipboard[11]&quot; src=&quot;https://img2018.cnblogs.com/blog/1492996/201904/1492996-20190410151820812-1565311033.png&quot; alt=&quot;clipboard[11]&quot; width=&quot;789&quot; height=&quot;515&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建完ODS表后，可以通过导入Excel模板的方式批量创建数据抽取任务。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 07:18:00 +0000</pubDate>
<dc:creator>昊合DI</dc:creator>
<og:description>什么是ODS表？ 在ETL架构中，源数据很少会直接抽取加载到数据仓库EDW，二者之间往往会设置一个源数据的临时存储区域，存储数据在清洗转换前的原始形态，通常被大家称做操作型数据存储，简称ODS，在Ki</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haohedi/p/10683596.html</dc:identifier>
</item>
<item>
<title>Eureka-Client（Golang实现） - bener</title>
<link>http://www.cnblogs.com/bener/p/10683404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bener/p/10683404.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Golang实现eureka-client&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;根据Java版本的源码，可以看出client主要是通过REST请求来与server进行通信。&lt;/p&gt;
&lt;p&gt;Java版本的核心实现：&lt;code&gt;com.netflix.discovery.DiscoveryClient&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其中主要逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;client启动时注册信息到server&lt;/li&gt;
&lt;li&gt;定时心跳、刷新服务列表，主要是两个线程池：&lt;code&gt;heartbeatExecutor&lt;/code&gt;、&lt;code&gt;cacheRefreshExecutor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;client关闭时删除注册信息&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;这里不限制语言，主要是发送REST请求到server。&lt;/p&gt;
&lt;h3 id=&quot;注册信息&quot;&gt;注册信息&lt;/h3&gt;
&lt;p&gt;通过POST请求，将服务信息注册到server。&lt;/p&gt;
&lt;p&gt;请求地址：&lt;code&gt;POST /eureka/apps/{APP_NAME}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;信息如下：（不是完整的信息）&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;instance&quot;:{
        &quot;instanceId&quot;:&quot;192.168.1.107:golang-example:10000&quot;,
        &quot;hostName&quot;:&quot;192.168.1.107&quot;,
        &quot;ipAddr&quot;:&quot;192.168.1.107&quot;,
        &quot;app&quot;:&quot;golang-example&quot;,
        &quot;port&quot;:{
            &quot;@enabled&quot;:&quot;true&quot;,
            &quot;$&quot;:10000
        },
        &quot;securePort&quot;:{
            &quot;@enabled&quot;:&quot;true&quot;,
            &quot;$&quot;:443
        },
        &quot;status&quot;:&quot;UP&quot;,
        &quot;overriddenStatus&quot;:&quot;UNKNOWN&quot;,
        &quot;dataCenterInfo&quot;:{
            &quot;name&quot;:&quot;MyOwn&quot;,
            &quot;@class&quot;:&quot;com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo&quot;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定时心跳刷新服务列表&quot;&gt;定时心跳、刷新服务列表&lt;/h3&gt;
&lt;p&gt;服务启动后，接下来就是维持client与server之间的心跳等。&lt;/p&gt;
&lt;h4 id=&quot;定时心跳&quot;&gt;定时心跳&lt;/h4&gt;
&lt;p&gt;默认情况下是30秒发送心跳信息到server。&lt;/p&gt;
&lt;p&gt;请求地址：&lt;code&gt;PUT /eureka/apps/{APP_NAME}/{INSTANCE_ID}?status=UP&amp;amp;lastDirtyTimestamp={TIMESTAMP}&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;定时刷新服务列表&quot;&gt;定时刷新服务列表&lt;/h4&gt;
&lt;p&gt;默认情况下是30秒刷新服务列表。&lt;/p&gt;
&lt;p&gt;刷新服务列表有全量和增量两种方式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全量：&lt;code&gt;GET /eureka/apps&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;增量（delta）：&lt;code&gt;GET /eureka/apps/delta&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，全量就是每次都拉取到所有服务信息；而增量拉取变化的服务信息，然后本地去做更新。&lt;/p&gt;
&lt;p&gt;为了方便我&lt;strong&gt;只实现了全量拉取&lt;/strong&gt;，没有实现delta。&lt;/p&gt;
&lt;h3 id=&quot;删除注册信息&quot;&gt;删除注册信息&lt;/h3&gt;
&lt;p&gt;在服务停止时，删除注册的信息即可。&lt;/p&gt;
&lt;p&gt;请求地址：&lt;code&gt;DELETE /eureka/apps/{APP_NAME}/{INSTANCE_ID}&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;golang核心实现&quot;&gt;Golang核心实现&lt;/h2&gt;
&lt;p&gt;有2个定时器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;refreshTicker&lt;/code&gt;来刷新服务列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heartbeatTicker&lt;/code&gt;进行心跳&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (c *Client) Start() {
    c.mutex.Lock()
    c.Running = true
    c.mutex.Unlock()

    refreshTicker := time.NewTicker(c.EurekaClientConfig.RefreshIntervalSeconds)
    heartbeatTicker := time.NewTicker(c.EurekaClientConfig.HeartbeatIntervalSeconds)

    go func() {
        for range refreshTicker.C {
            if c.Running {
                if err := c.doRefresh(); err != nil {
                    fmt.Println(err)
                }
            } else {
                break
            }
        }
    }()

    go func() {
        if err := c.doRegister(); err != nil {
            fmt.Println(err)
        }
        for range heartbeatTicker.C {
            if c.Running {
                if err := c.doHeartbeat(); err != nil {
                    fmt.Println(err)
                }
            } else {
                break
            }
        }
    }()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;
&lt;p&gt;下面是使用的例子，为了在client停止时删除注册信息，这里用到了&lt;code&gt;signal&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;

    client &quot;github.com/xuanbo/eureka-client&quot;
)

func main() {
    // 1.创建客户端
    c := client.NewClient(&amp;amp;client.EurekaClientConfig{
        DefaultZone: &quot;http://127.0.0.1:8080/eureka/&quot;,
        App:         &quot;golang-example&quot;,
        Port:        10000,
    })
    // 2.启动client，注册到server。并定心跳、刷新服务列表
    c.Start()

    sigs := make(chan os.Signal)
    exit := make(chan bool, 1)
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

    // 随便弄一个请求
    http.HandleFunc(&quot;/services&quot;, func(writer http.ResponseWriter, request *http.Request) {
        // 3.获取所有服务（status均为UP）
        services := c.Services
        
        b, _ := json.Marshal(services)
        _, _ = writer.Write(b)
    })
    server := &amp;amp;http.Server{
        Addr:    &quot;:10000&quot;,
        Handler: http.DefaultServeMux,
    }

    // 启动http服务
    go func() {
        if err := server.ListenAndServe(); err != nil {
            fmt.Println(err)
        }
    }()

    // 关闭
    go func() {
        fmt.Println(&amp;lt;-sigs)

        // 停止http服务
        if err := server.Close(); err != nil {
            panic(err)
        }

        // 4.停止客户端，并删除注册信息
        c.Shutdown()

        exit &amp;lt;- true
    }()

    &amp;lt;-exit
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要是4步，用起来比较简单。&lt;/p&gt;
&lt;h2 id=&quot;github地址&quot;&gt;Github地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuanbo/eureka-client&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;未在生产中使用&lt;/strong&gt;，只是想把Golang的服务与Java的Spring Cloud结合起来玩耍。&lt;/p&gt;
&lt;p&gt;Just for fun!&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 06:52:00 +0000</pubDate>
<dc:creator>bener</dc:creator>
<og:description>Eureka Client Golang实现eureka client 原理 根据Java版本的源码，可以看出client主要是通过REST请求来与server进行通信。 Java版本的核心实现： 。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bener/p/10683404.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Alibaba基础教程：使用Sentinel实现接口限流 - 程序猿DD</title>
<link>http://www.cnblogs.com/didispace/p/10683049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/didispace/p/10683049.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最近管点闲事浪费了不少时间，感谢网友&lt;code&gt;libinwalan&lt;/code&gt;的留言提醒。及时纠正路线，继续跟大家一起学习Spring Cloud Alibaba。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nacos作为注册中心和配置中心的基础教程，到这里先告一段落，后续与其他结合的内容等讲到的时候再一起拿出来说，不然内容会有点跳跃。接下来我们就来一起学习一下Spring Cloud Alibaba下的另外一个重要组件：Sentinel。&lt;/p&gt;
&lt;h2 id=&quot;sentinel是什么&quot;&gt;Sentinel是什么&lt;/h2&gt;
&lt;p&gt;Sentinel的官方标题是：分布式系统的流量防卫兵。从名字上来看，很容易就能猜到它是用来作服务稳定性保障的。对于服务稳定性保障组件，如果熟悉Spring Cloud的用户，第一反应应该就是Hystrix。但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，在未来我们还有什么更好的选择呢？除了Spring Cloud官方推荐的resilience4j之外，目前Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。&lt;/p&gt;
&lt;p&gt;Sentinel的功能和细节比较多，一篇内容很难介绍完整。所以下面我会分多篇来一一介绍Sentinel的重要功能。本文就先从限流入手，说说如何把Sentinel整合到Spring Cloud应用中，以及如何使用Sentinel Dashboard来配置限流规则。通过这个简单的例子，先将这一套基础配置搭建起来。&lt;/p&gt;
&lt;h2 id=&quot;使用sentinel实现接口限流&quot;&gt;使用Sentinel实现接口限流&lt;/h2&gt;
&lt;p&gt;Sentinel的使用分为两部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sentinel-dashboard：与hystrix-dashboard类似，但是它更为强大一些。除了与hystrix-dashboard一样提供实时监控之外，还提供了流控规则、熔断规则的在线维护等功能。&lt;/li&gt;
&lt;li&gt;客户端整合：每个微服务客户端都需要整合sentinel的客户端封装与配置，才能将监控信息上报给dashboard展示以及实时的更改限流或熔断规则等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就分两部分来看看，如何使用Sentienl来实现接口限流。&lt;/p&gt;
&lt;h3 id=&quot;部署sentinel-dashboard&quot;&gt;部署Sentinel Dashboard&lt;/h3&gt;
&lt;p&gt;本文采用的spring cloud alibaba版本是0.2.1，可以查看依赖发现当前版本使用的是sentinel 1.4.0。为了顺利完成本文的内容，我们可以挑选同版本的sentinel dashboard来使用是最稳妥的。&lt;/p&gt;
&lt;p&gt;下载地址：https://github.com/alibaba/Sentinel/releases/download/1.4.0/sentinel-dashboard-1.4.0.jar&lt;br/&gt;其他版本：https://github.com/alibaba/Sentinel/releases&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;同以往的Spring Cloud教程一样，这里也不推荐大家跨版本使用，不然可能会出现各种各样的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过命令启动：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;java -jar sentinel-dashboard-1.4.0.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sentinel-dashboard不像Nacos的服务端那样提供了外置的配置文件，比较容易修改参数。不过不要紧，由于sentinel-dashboard是一个标准的spring boot应用，所以如果要自定义端口号等内容的话，可以通过在启动命令中增加参数来调整，比如：&lt;code&gt;-Dserver.port=8888&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;默认情况下，sentinel-dashboard以8080端口启动，所以可以通过访问：&lt;code&gt;localhost:8080&lt;/code&gt;来验证是否已经启动成功，如果一切顺利的话，可以看到如下页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201904/626506-20190410140012251-712309739.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;整合sentinel&quot;&gt;整合Sentinel&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;：在Spring Cloud应用的&lt;code&gt;pom.xml&lt;/code&gt;中引入Spring Cloud Alibaba的Sentinel模块：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-sentinel&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.18.2&amp;lt;/version&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：在Spring Cloud应用中通过&lt;code&gt;spring.cloud.sentinel.transport.dashboard&lt;/code&gt;参数配置sentinel dashboard的访问地址，比如：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.application.name=alibaba-sentinel-rate-limiting
server.port=8001

# sentinel dashboard
spring.cloud.sentinel.transport.dashboard=localhost:8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：创建应用主类，并提供一个rest接口，比如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }

    @Slf4j
    @RestController
    static class TestController {

        @GetMapping(&quot;/hello&quot;)
        public String hello() {
            return &quot;didispace.com&quot;;
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;：启动应用，然后通过postman或者curl访问几下&lt;code&gt;localhost:8001/hello&lt;/code&gt;接口。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ curl localhost:8001/hello
didispace.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，在上一节启动的Sentinel Dashboard中就可以当前我们启动的&lt;code&gt;alibaba-sentinel-rate-limiting&lt;/code&gt;这个服务以及接口调用的实时监控了。具体如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201904/626506-20190410140027274-1487151908.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置限流规则&quot;&gt;配置限流规则&lt;/h3&gt;
&lt;p&gt;在完成了上面的两节之后，我们在&lt;code&gt;alibaba-sentinel-rate-limiting&lt;/code&gt;服务下，点击&lt;code&gt;簇点链路&lt;/code&gt;菜单，可以看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201904/626506-20190410140038773-1210468793.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;/hello&lt;/code&gt;接口，就是我们上一节中实现并调用过的接口。通过点击&lt;code&gt;流控&lt;/code&gt;按钮，来为该接口设置限流规则，比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201904/626506-20190410140119112-664951384.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里做一个最简单的配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阈值类型选择：QPS&lt;/li&gt;
&lt;li&gt;单机阈值：2&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综合起来的配置效果就是，该接口的限流策略是每秒最多允许2个请求进入。&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;新增&lt;/code&gt;按钮之后，可以看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201904/626506-20190410140127713-344664834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实就是左侧菜单中&lt;code&gt;流控规则&lt;/code&gt;的界面，这里可以看到当前设置的所有限流策略。&lt;/p&gt;
&lt;h3 id=&quot;验证限流规则&quot;&gt;验证限流规则&lt;/h3&gt;
&lt;p&gt;在完成了上面所有内容之后，我们可以尝试一下快速的调用这个接口，看看是否会触发限流控制，比如：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ curl localhost:8001/hello
didispace.com
$ curl localhost:8001/hello
didispace.com
$ curl localhost:8001/hello
Blocked by Sentinel (flow limiting)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，快速的调用两次&lt;code&gt;/hello&lt;/code&gt;接口之后，第三次调用被限流了。&lt;/p&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;代码示例&lt;/h2&gt;
&lt;p&gt;本文介绍内容的客户端代码，示例读者可以通过查看下面仓库中的&lt;code&gt;alibaba-sentinel-rate-limiting&lt;/code&gt;项目：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果您对这些感兴趣，欢迎star、follow、收藏、转发给予支持！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;下面是Sentinel的仓库地址与官方文档，读者也可以自己查阅文档学习：&lt;/p&gt;
&lt;h2 id=&quot;专题推荐&quot;&gt;专题推荐&lt;/h2&gt;
</description>
<pubDate>Wed, 10 Apr 2019 06:03:00 +0000</pubDate>
<dc:creator>程序猿DD</dc:creator>
<og:description>最近管点闲事浪费了不少时间，感谢网友 的留言提醒。及时纠正路线，继续跟大家一起学习Spring Cloud Alibaba。 Nacos作为注册中心和配置中心的基础教程，到这里先告一段落，后续与其他结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/didispace/p/10683049.html</dc:identifier>
</item>
<item>
<title>ABP实践(1)-通过官方模板创建ASP.NET Core 2.x版本+vue.js单页面模板-启动运行项目 - wuyubing</title>
<link>http://www.cnblogs.com/wuyubing/p/10678309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyubing/p/10678309.html</guid>
<description>&lt;p&gt;1,打开&lt;a href=&quot;https://aspnetboilerplate.com/Templates&quot; target=&quot;_blank&quot;&gt;ABP官网下载模板页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2,根据下图选择对应的选项及输入项目名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190409165931662-1741929117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注:上图验证码下方的选择框打钩表示下载最新稳定版,不打钩表示下载最新版本(有可能是预览版)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 3,解压下载的压缩包&lt;/p&gt;
&lt;p&gt;解压之后是个abp版本号命名的文件夹如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190409172512976-1039770925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动服务端项目步骤如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1,vs2017打开服务端项目xxx.sln,打开之后右键解决方案还原Nuget包(vs2017打开之后放着会自动还原其他版本有些需要下图的操作)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190409175925109-1797537251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2,项目打开之后解决方案分层分析定义如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410142715579-560005451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.1删除基础层xxx.EntityFrameworkCore下的Migrations默认的所有文件(项目下载完之后&lt;span&gt;第一次需要删掉里面自带的历史记录&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;3.2打开工具&amp;gt;程序控制台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190409182058723-368538124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190409182220282-685370711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;①先设置迁移层xxx.migrator为启动项&lt;/p&gt;
&lt;p&gt;然后打开展现层xxx.Web.Host下的appsettings.json修改数据库连接字符串ConnectionStrings&lt;span&gt;(这里有个疑问?迁移层下也有个配置数据库的文件,但是没有效果后续研究看看---疑问可以忽略不看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410094635528-2023011609.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;连接字符串Data Source=ip;Initial Catalog=数据库名称;user=用户名;password=密码;&lt;/p&gt;
&lt;p&gt;②新增数据迁移执行命令Add-Migration first_init结果如下图表示成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190409183346257-2096803406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③执行更新数据库命令Update-Database结果如下图表示成功(执行完之后可以看到根据EF模型Model自动创建了数据库和表)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190409192415250-1312387068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ④设置展现层xxx.Web.Host为启动项f5运行可以看到如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410085821919-1111502862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动前端vue项目步骤如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1,前提是有vue运行环境(&lt;a href=&quot;http://nodejs.cn/download/&quot; target=&quot;_blank&quot;&gt;nodejs下载安装&lt;/a&gt;+&lt;a href=&quot;https://yarn.bootcss.com/docs/install/#windows-stable&quot; target=&quot;_blank&quot;&gt;yarn&lt;/a&gt;类似npm包管理)&lt;/p&gt;
&lt;p&gt;2,运行cmd→进入vue前端项目的目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410091842584-1723760395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3,①执行yarn install&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410092622566-1234350806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②执行yarn serve --open&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410092845352-1441417768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动之后&lt;/span&gt;在浏览器看到的是&lt;span&gt;空白页面&lt;/span&gt;如果是用chrome浏览器按f12就可以看到如下图的报错,这说明存在跨域问题&lt;span&gt;看下面第③步&lt;/span&gt;我们来解决这个问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410093112632-797233646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③停止服务端运行,就是停止vs;然后打开展现层xxx.Web.Host项目下的appsettings.json文件找到&lt;span&gt;CorsOrigins&lt;/span&gt;在这个值加上&lt;span&gt;,http://localhost:8082&lt;/span&gt;&lt;span&gt;这里是控制有哪些域名端口可访问,根据实际情况设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410094108136-639861544.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 修改之后重新运行服务端,然后刷新页面可看到页面如下表示成功运行(默认账号是admin密码是123qwe)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190410095259865-1959478337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 10 Apr 2019 05:41:00 +0000</pubDate>
<dc:creator>wuyubing</dc:creator>
<og:description>1,打开ABP官网下载模板页面 2,根据下图选择对应的选项及输入项目名 注:上图验证码下方的选择框打钩表示下载最新稳定版,不打钩表示下载最新版本(有可能是预览版) 3,解压下载的压缩包 解压之后是个a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyubing/p/10678309.html</dc:identifier>
</item>
<item>
<title>微服务架构 - 基于Harbor构建本地镜像仓库 - 架构与我</title>
<link>http://www.cnblogs.com/atcloud/p/10682907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atcloud/p/10682907.html</guid>
<description>&lt;p&gt;之前写过&lt;a href=&quot;https://www.toutiao.com/i6674114186835919367/&quot;&gt;《搭建docker本地镜像仓库并提供权限校验及UI界面》&lt;/a&gt;文章，然后有同仁评论道这样做太复杂了，如果Harbor来搭建会更简单同时功能也更强大。于是抽时间研究了基于Harbor构建本地镜像仓库，感觉Harbor的确更简单同时功能更强大，再此感谢各位同仁的建议。下面将基于Harbor构建本地镜像仓库的步骤分享出来，再次欢迎各位同仁点评。&lt;/p&gt;
&lt;h2 id=&quot;harbor&quot;&gt;1、Harbor&lt;/h2&gt;
&lt;p&gt;Harbor是VMware公司开源了企业级Registry项目, 其的目标是帮助用户迅速搭建一个企业级的Docker registry服务。它以Docker公司开源的registry为基础，额外提供了如下功能:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Cloud native registry&lt;/strong&gt;:支持容器镜像和Helm Charts，为云原生环境提供服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Role based access control&lt;/strong&gt;：基于角色的访问控制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Policy based image replication&lt;/strong&gt;：基于策略的镜像复制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vulnerability Scanning&lt;/strong&gt;：镜像的漏洞扫描&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LDAP/AD support&lt;/strong&gt;：AD/LDAP集成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Image deletion &amp;amp; garbage collection&lt;/strong&gt;：镜像的删除和空间清理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Notary&lt;/strong&gt;：可以保证镜像的真实性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Graphical user portal&lt;/strong&gt;：友好的管理UI&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Auditing&lt;/strong&gt;：日志审计&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RESTful API&lt;/strong&gt;：提供RESTfull接口易于与外部系统集成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Easy deployment&lt;/strong&gt;：部署简单&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上功能是将官网的内容做了简单翻译，如果大家想深层次了解一下，可以查看Harbor官网内容。&lt;/p&gt;
&lt;h2 id=&quot;部署&quot;&gt;2、部署&lt;/h2&gt;
&lt;p&gt;部署Harbor前，首先得有docker环境、docker-compose的环境，如果大家没有docker环境，可以参考我之前的一篇文章&lt;a href=&quot;https://www.toutiao.com/i6660002521202819596/&quot;&gt;《CentOS7离线部署docker》&lt;/a&gt;搭建环境，对于安装docker-compose是很简单，只如下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：如果运行环境不能直接联外网，则可以先下载二进制包，然后手动放置到相应目录，并授权即可。&lt;/p&gt;
&lt;p&gt;有了docker环境、docker-compose的环境后，可以开始部署Harbor了，步骤如下：&lt;/p&gt;
&lt;p&gt;（1）、到Github上下载目前Harbor的最新版本，它提供两种下载方式，一种是离线安装包和在线安装包，大家可以根据自己的情况下载，此处下载的是离线安装包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410132904148-1287551148.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）、下载后，将该文件解压到/opt/harbor目录下，当然大家也可以根据自己的使用情况放到相应的目录即可&lt;/p&gt;
&lt;p&gt;（3）、此处要开启https访问，所以得生成证书（注意：如果不以https访问，这一个步骤就是不需要的），操作如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /opt/harbor/certs
cd /opt/harbor/certs
openssl req \
    -new \
    -newkey rsa:4096 \
    -days 365 \
    -subj &quot;/CN=192.168.208.147&quot; \
    -nodes \
    -x509 \
    -keyout auth.key \
    -out auth.cert&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：此处的ip地址192.168.208.147，是搭建Harbor服务所在的ip地址&lt;/p&gt;
&lt;p&gt;（4）、修改harbor.cfg配置文件信息，分别修改以下配置信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 主机名改成本服务器的ip
hostname = 192.168.208.147
# 访问的协议https
ui_url_protocol = https
# 由于前一步我们自己生成了证书，所以该值改为off
customize_crt = off
# ssl证书的路径
ssl_cert = /opt/harbor/certs/auth.cert
# ssl密钥的路径
ssl_cert_key = /opt/harbor/certs/auth.key
# 设置ui系统的admin账号的密码，默认为Harbor12345
harbor_admin_password = Adminjgyw&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）、安装，执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./install.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）、执行上面的安装脚本，实质是执行docker compose来部署应用的，所以可以通过docker compose命令查看服务信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410132917756-1378339761.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）、访问https://192.168.208.147，如果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410132927746-620473600.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;3、测试&lt;/h2&gt;
&lt;p&gt;部署完成之后，测试一下镜像的pull和push功能，首先将admin账号登录，并创建jgyw项目，即：&lt;/p&gt;
&lt;p&gt;（1）、点击“新建项目”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410132940174-415308758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）、填写项目信息，名称为jgyw，访问级别为公开，即所有人都可以pull镜像下来，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410132948769-635311413.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）、创建用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410132956514-200410921.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）、为jgyw项目添加成员，同时角色为开发人员，这样可以将镜像push到该项目中，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410133004855-1376582713.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）、push镜像&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker login 192.168.208.147
# 输入上面新建的jgyw用户名和密码即可登录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果此处发生如下错误:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error response from daemon: Get https://192.168.208.147/v1/users/: x509: cannot validate certificate for 192.168.208.147 because it doesn't contain any IP SANs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则需要将/usr/lib/systemd/system/docker.service文件中ExecStart值修改为如下形式，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ExecStart=/usr/bin/dockerd --insecure-registry 192.168.208.147&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试openzipkin/zipkin:2.12.1镜像&lt;/p&gt;
&lt;p&gt;将openzipkin/zipkin:2.12.1镜像打上标签，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker tag openzipkin/zipkin:2.12.1 192.168.208.147/jgyw/zipkin:2.12.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行push命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker push 192.168.208.147/jgyw/zipkin:2.12.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完成后，可以查到jgyw项目中就有了该镜像，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410133018901-641121552.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）、pull镜像&lt;/p&gt;
&lt;p&gt;首先将本机的192.168.208.147/jgyw/zipkin:2.12.1镜像删除掉，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker rmi 192.168.208.147/jgyw/zipkin:2.12.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行pull命令，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull 192.168.208.147/jgyw/zipkin:2.12.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;镜像就拉取下来了。&lt;/p&gt;
&lt;h2 id=&quot;关注我&quot;&gt;关注我&lt;/h2&gt;
&lt;p&gt;以你最方便的方式关注我：&lt;br/&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190410133045955-1929198029.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 05:31:00 +0000</pubDate>
<dc:creator>架构与我</dc:creator>
<og:description>之前写过 '《搭建docker本地镜像仓库并提供权限校验及UI界面》' 文章，然后有同仁评论道这样做太复杂了，如果Harbor来搭建会更简单同时功能也更强大。于是抽时间研究了基于Harbor构建本地镜</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atcloud/p/10682907.html</dc:identifier>
</item>
<item>
<title>Java 重建二叉树 根据前序中序重建二叉树 - DingYu</title>
<link>http://www.cnblogs.com/dddyyy/p/10682890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dddyyy/p/10682890.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解题所需的知识&quot;&gt;解题所需的知识&lt;/h2&gt;
&lt;h3 id=&quot;二叉树的遍历&quot;&gt;二叉树的遍历&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;这个先中后，是根据何时遍历根节点命名的，左的优先级大于后，比如先序就先遍历根结点,再遍历左节点，最后遍历右节点，中序同理，先左中根最后右，后序，先左再右后根。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201904/1248002-20190410133014172-1281912660.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二叉树的先序遍历&quot;&gt;二叉树的先序遍历&lt;/h3&gt;
&lt;p&gt;​ 来！ 根据上面的的顺序我们来走一遍，先根再左最后右。&lt;/p&gt;
&lt;p&gt;​ 首先，显而意见，1是根节点&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201904/1248002-20190410133045774-1049355269.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 那么现在往左走，发现 2，4，7 也是一棵二叉树，他也是二叉树，我们可不能区别对待，所以理应也满足先序遍历，先根再左最后右。那么2就是这颗小二叉树的根节点啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201904/1248002-20190410133112464-1260286549.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 找到了小二叉树的根节点，按照先序再走左，发现4，7也是一棵二叉树，这颗小小二叉树也得满足先序哦，4为根节点，再走左，发现左没了，还记得先序得遍历规则嘛 先根再左后右，左没了那就轮到右啦，所以应该走7了，走完7以后，4，7这棵小小小二叉树算是走完了，走完之后该走2，4，7这颗小二叉树的右节点了，依次类推哦。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;先序遍历为 1，2，4，7，3，5，6，8&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉树的中序遍历&quot;&gt;二叉树的中序遍历&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;同上 4，7，2，1，5，3，8，6&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉树的后序遍历&quot;&gt;二叉树的后序遍历&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;同上 7,4,2,5,8,6,3,1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根据先序中序构建二叉树&quot;&gt;根据先序，中序构建二叉树&lt;/h3&gt;
&lt;p&gt;​ 举例 前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}&lt;/p&gt;
&lt;p&gt;​ 首先，先序先遍历根节点，那么1显然就是最上面的那个根节点，中序是中间遍历根节点，那么显然可以得出如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201904/1248002-20190410133141399-1108147748.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 那么继续去前序得数组中找，发现4，7，2最先出现的是2，那显然2是4，7，2的根结点，去中序找，4，7都在2之前，那显然都是2的左子树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201904/1248002-20190410133205328-781233860.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 再去先序找，发现4先出现，那么4就是4，7的根节点，去中序找，发现7在4的右边，说明是右子树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201904/1248002-20190410133217496-29033344.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 右子树依次类推。。。。。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;​ 人用迭代，神用递归&lt;/p&gt;
&lt;p&gt;​ 我们用递归的思想，首先先序{1,&lt;strong&gt;2,4,7&lt;/strong&gt;,3,5,6,8}，中序{&lt;strong&gt;4,7,2&lt;/strong&gt;,1,5,3,8,6}，那么我们找到1是根节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201904/1248002-20190410133230684-690658006.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 那么现在我们把4，7，2当成一棵二叉树，那么先序从上面知道是&lt;strong&gt;{2，4，7}&lt;/strong&gt; 中序根据上面也知道是&lt;strong&gt;{4，7，2}&lt;/strong&gt;，那接下来跟我们找出1是根节点然后分左右是不是一模一样，只不过先序的数组和后序的数组变了&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
   //前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}
    public TreeNode reConstructBinaryTree(int[] pre, int[] in) {

        int len = pre.length;

        TreeNode root = new TreeNode(pre[0]);
        //说明只剩下一个了，表示叶子节点,递归可以退出了
        if (pre.length == 1) {
            root.left = null;
            root.right = null;
            return root;
        }

        //中间值 在{4,7,2,1,5,3,8,6} 这个中间值第一次应该是3
        int flag = 0;
        for (int i = 0; i &amp;lt; len; i++) {
            //在中序中找到
            if (pre[0] == in[i]) {
                flag = i;
                break;
            }
        }
        if (flag &amp;gt; 0) {
            //左子树的先序
            int[] leftPre = new int[flag];
            //左子树的后序
            int[] leftIn = new int[flag];
            for (int j = 0; j &amp;lt; flag; j++) {
                leftPre[j] = pre[j + 1];
            }
            for (int j = 0; j &amp;lt; flag; j++) {
                leftIn[j] = in[j];
            }
            //左子树递归
            root.left = reConstructBinaryTree(leftPre, leftIn);
        } else {
            root.left = null;
        }
        if (pre.length - flag - 1 &amp;gt; 0) {
            //右子树的先序,长度为 总-根-左子树
            int[] rightPre = new int[pre.length - 1 - flag];
            //右子树的中序
            int[] rightIn = new int[pre.length - 1 - flag];

            for (int j = flag + 1; j &amp;lt; len; j++) {
                //右子树中序，为什么要j-flag-1呢 因为我的rightIn要从0开始 而j是k+1开始的 ，所以很尴尬，只能用j-flag-1
                rightIn[j - flag - 1] = in[j];

                rightPre[j - flag - 1] = pre[j];
            }

            root.right = reConstructBinaryTree(rightPre, rightIn);
        } else {
            root.right = null;
        }

        return root;

    }
 
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 10 Apr 2019 05:27:00 +0000</pubDate>
<dc:creator>DingYu</dc:creator>
<og:description>解题所需的知识 二叉树的遍历 ​ 这个先中后，是根据何时遍历根节点命名的，左的优先级大于后，比如先序就先遍历根结点,再遍历左节点，最后遍历右节点，中序同理，先左中根最后右，后序，先左再右后根。 二叉树</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dddyyy/p/10682890.html</dc:identifier>
</item>
<item>
<title>深入理解redis复制原理 - 五色花的博客</title>
<link>http://www.cnblogs.com/luao/p/10682830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10682830.html</guid>
<description>&lt;ul&gt;&lt;li&gt;1.复制过程&lt;/li&gt;
&lt;li&gt;2.数据间的同步&lt;/li&gt;
&lt;li&gt;3.全量复制&lt;/li&gt;
&lt;li&gt;4.部分复制&lt;/li&gt;
&lt;li&gt;5.心跳&lt;/li&gt;
&lt;li&gt;6.异步复制&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;1.复制过程&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;从节点执行 slaveof 命令。      &lt;/li&gt;
&lt;li&gt;从节点只是保存了 slaveof 命令中主节点的信息，并没有立即发起复制。      &lt;/li&gt;
&lt;li&gt;从节点内部的定时任务发现有主节点的信息，开始使用 socket 连接主节点。    &lt;/li&gt;
&lt;li&gt;连接建立成功后，发送 ping 命令，希望得到 pong 命令响应，否则会进行重连。      &lt;/li&gt;
&lt;li&gt;如果主节点设置了权限，那么就需要进行权限验证，如果验证失败，复制终止。        &lt;/li&gt;
&lt;li&gt;权限验证通过后，进行数据同步，&lt;strong&gt;这是耗时最长的操作&lt;/strong&gt;，主节点将把所有的数据全部发送给从节点。    &lt;/li&gt;
&lt;li&gt;当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，&lt;strong&gt;主节点就会持续的把写命令发送给从节点，保证主从数据一致性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190409172218776-1183286039.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2.数据间的同步&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;上面说的复制过程，其中有一个步骤是“同步数据集”，这个就是现在讲的“数据间的同步”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redis 同步有 2 个命令：sync 和 psync&lt;/strong&gt;，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。我们会重点关注 2.8 的 psync 命令。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;psync 命令需要 3 个组件支持&lt;/strong&gt;：&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;主从节点各自复制偏移量  &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主节点复制积压缓冲区  &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主节点运行 ID&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;主从节点各自复制偏移量：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;参与复制的主从节点都会维护自身的复制偏移量。      &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 info replication 中的 masterreploffset 指标中。      &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从节点每秒钟上报自身的的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。        &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在 info replication 中。       &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;主节点复制积压缓冲区：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列，默认大小 1MB。        &lt;/li&gt;
&lt;li&gt;这个队列在 slave 连接是创建。这时主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区。        &lt;/li&gt;
&lt;li&gt;他的作用就是用于部分复制和复制命令丢失的数据补救。通过 info replication 可以看到相关信息。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;主节点运行 ID：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;每个 redis 启动的时候，都会生成一个 40 位的运行 ID。        &lt;/li&gt;
&lt;li&gt;运行 ID 的主要作用是用来识别 Redis 节点。如果使用 ip+port 的方式，那么如果主节点重启修改了 RDB/AOF 数据，从节点再基于偏移量进行复制将是不安全的。所以，当运行 id 变化后，从节点将进行全量复制。也就是说，redis 重启后，默认从节点会进行全量复制。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;如果在重启时不改变运行 ID 呢？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;可以通过 debug reload 命令重新加载 RDB 并保持运行 ID 不变，从而有效的避免不必要的全量复制。&lt;/li&gt;
&lt;li&gt;缺点是：debug reload 命令会阻塞当前 Redis 节点主线程，因此对于大数据量的主节点或者无法容忍阻塞的节点，需要谨慎使用。一般通过故障转移机制可以解决这个问题。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;psync 命令的使用方式：&lt;/h3&gt;
&lt;p&gt;　　命令格式为  &lt;code&gt;psync{runId}{offset}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　runId：从节点所复制主节点的运行 id        &lt;/p&gt;
&lt;p&gt;　　offset：当前从节点已复制的数据偏移量&lt;/p&gt;
&lt;h3&gt;psync 执行流程：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190409135822454-545860229.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流程说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从节点发送 psync 命令给主节点，runId 就是目标主节点的 ID，如果没有默认为 -1，offset 是从节点保存的复制偏移量，如果是第一次复制则为 -1.&lt;/p&gt;
&lt;p&gt;主节点会根据 runid 和 offset 决定返回结果：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程。      &lt;/li&gt;
&lt;li&gt;如果回复 +CONTINUE，从节点将触发部分复制。        &lt;/li&gt;
&lt;li&gt;如果回复 +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到这里，数据之间的同步就讲的差不多了，篇幅还是比较长的。主要是针对 psync 命令相关之间的介绍。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.全量复制&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;全量复制是 Redis 最早支持的复制方式，也是主从第一次建立复制时必须经历的的阶段。触发全量复制的命令是 sync 和 psync。之前说过，这两个命令的分水岭版本是 2.8，redis 2.8 之前使用 sync 只能执行全量不同，2.8 之后同时支持全量同步和部分同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190409171619009-91793260.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流程如下&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发送 psync 命令（spync ？ -1）        &lt;/li&gt;
&lt;li&gt;主节点根据命令返回 FULLRESYNC        &lt;/li&gt;
&lt;li&gt;从节点记录主节点 ID 和 offset        &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主节点 bgsave 并保存 RDB 到本地&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主节点发送 RBD 文件到从节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从节点收到 RDB 文件并加载到内存中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;主节点在从节点接受数据的期间，将新数据保存到“复制客户端缓冲区”，当从节点加载 RDB 完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败）   &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭.        &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上加粗的部分是整个全量同步耗时的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如过 RDB 文件大于 6GB，并且是千兆网卡，Redis 的默认超时机制（60 秒），会导致全量复制失败。可以通过调大 repl-timeout 参数来解决此问题。        &lt;/li&gt;
&lt;li&gt;Redis 虽然支持无盘复制，即直接通过网络发送给从节点，但功能不是很完善，生产环境慎用。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;strong&gt;4.部分复制&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据，主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190409171057463-1136190862.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当从节点出现网络中断，超过了 repl-timeout 时间，主节点就会中断复制连接。&lt;/li&gt;
&lt;li&gt;主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB。&lt;/li&gt;
&lt;li&gt;当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点。     &lt;/li&gt;
&lt;li&gt;主节点校验后，如果偏移量的数后的数据在缓冲区中，就发送 cuntinue 响应 —— 表示可以进行部分复制。&lt;/li&gt;
&lt;li&gt;主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;strong&gt;5.心跳&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;主从节点在建立复制后，他们之间维护着长连接并彼此发送心跳命令。&lt;/p&gt;
&lt;p&gt;心跳的关键机制如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;中从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。 &lt;/li&gt;
&lt;li&gt;主节点默认每隔 10 秒对从节点发送 ping 命令，可修改配置 repl-ping-slave-period 控制发送频率。&lt;/li&gt;
&lt;li&gt;从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量。&lt;/li&gt;
&lt;li&gt;主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190409171250623-2027233108.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了降低主从延迟，一般把 redis 主从节点部署在相同的机房/同城机房，避免网络延迟带来的网络分区造成的心跳中断等情况。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.异步复制&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;主节点不但负责数据读写，还负责把写命令同步给从节点，写命令的发送过程是异步完成，也就是说主节点处理完写命令后立即返回客户度，并不等待从节点复制完成。&lt;/p&gt;
&lt;p&gt;异步复制的步骤很简单，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主节点接受处理命令。&lt;/li&gt;
&lt;li&gt;主节点处理完后返回响应结果 。&lt;/li&gt;
&lt;li&gt;对于修改命令，异步发送给从节点，从节点在主线程中执行复制的命令。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190409171329303-429603382.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本文主要分析了 Redis 的复制原理，包括复制过程，数据之间的同步，全量复制的流程，部分复制的流程，心跳设计，异步复制流程。其中，可以看出，RDB 数据之间的同步非常耗时。所以，Redis 在 2.8 版本退出了类似增量复制的 psync 命令，当 Redis 主从直接发生了网络中断，不会进行全量复制，而是将数据放到缓冲区（默认 1MB）里，在通过主从之间各自维护复制 offset 来判断缓存区的数据是否溢出，如果没有溢出，只需要发送缓冲区数据即可，成本很小，反之，则要进行全量复制，因此，控制缓冲区大小非常的重要。&lt;/p&gt;

</description>
<pubDate>Wed, 10 Apr 2019 05:13:00 +0000</pubDate>
<dc:creator>五色花的博客</dc:creator>
<og:description>1.复制过程 2.数据间的同步 3.全量复制 4.部分复制 5.心跳 6.异步复制 1.复制过程 2.数据间的同步 上面说的复制过程，其中有一个步骤是“同步数据集”，这个就是现在讲的“数据间的同步”。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10682830.html</dc:identifier>
</item>
<item>
<title>TensorFlow从1到2（二）续讲从锅炉工到AI专家 - 俺踏月色而来</title>
<link>http://www.cnblogs.com/andrewwang/p/10682766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andrewwang/p/10682766.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201801/ml/tensorflowlogo.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;图片样本可视化&quot;&gt;图片样本可视化&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.17study.com.cn/2018/01/10/tensorFlow-series-4/&quot;&gt;原文第四篇&lt;/a&gt;中，我们介绍了官方的入门案例MNIST，功能是识别手写的数字0-9。这是一个非常基础的TensorFlow应用，地位相当于通常语言学习的&quot;Hello World!&quot;。&lt;br/&gt;我们先不进入TensorFlow 2.0中的MNIST代码讲解，因为TensorFlow 2.0在Keras的帮助下抽象度比较高，代码非常简单。但这也使得大量的工作被隐藏掉，反而让人难以真正理解来龙去脉。特别是其中所使用的样本数据也已经不同，而这对于学习者，是非常重要的部分。模型可以看论文、在网上找成熟的成果，数据的收集和处理，可不会有人帮忙。&lt;br/&gt;在原文中，我们首先介绍了MNIST的数据结构，并且用一个小程序，把样本中的数组数据转换为JPG图片，来帮助读者理解原始数据的组织方式。&lt;br/&gt;这里我们把小程序也升级一下，直接把图片显示在屏幕上，不再另外保存JPG文件。这样图片看起来更快更直观。&lt;br/&gt;在TensorFlow 1.x中，是使用程序input_data.py来下载和管理MNIST的样本数据集。当前官方仓库的master分支中已经取消了这个代码，为了不去翻仓库，你可以在&lt;a href=&quot;http://files.17study.com.cn/201904/tensorFlow2/input_data.py&quot;&gt;这里&lt;/a&gt;下载，放置到你的工作目录。&lt;br/&gt;在TensorFlow 2.0中，会有keras.datasets类来管理大部分的演示和模型中需要使用的数据集，这个我们后面再讲。&lt;br/&gt;MNIST的样本数据来自&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;Yann LeCun&lt;/a&gt;的项目网站。如果网速比较慢的话，可以先用下载工具下载，然后放置到自己设置的数据目录，比如工作目录下的data文件夹，input_data检测到已有数据的话，不会重复下载。&lt;br/&gt;下面是我们升级后显示训练样本集的源码，代码的讲解保留在注释中。如果阅读有疑问的，建议先去原文中看一下样本集数据结构的图示部分：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/env python3

# 引入mnist数据预读准备库
# 2.0之后建议直接使用官方的keras.datasets.mnist.load_data
# 此处为了同以前的讲解对比，沿用之前的引用文件
import input_data
# tensorflow 2.0库
import tensorflow as tf
# 引入绘图库
import matplotlib.pyplot as plt

# 这里使用mnist数据预读准备库检查给定路径是已经有样本数据，
# 没有的话去网上下载，并保存在指定目录
# 已经下载了数据的话，将数据读入内存，保存到mnist对象中
mnist = input_data.read_data_sets(&quot;data/&quot;, one_hot=True)

# 样本集的结构如下：
# mnist.train 训练数据集
# mnist.validation 验证数据集
# mnist.test 测试数据集
# len(mnist.train.images)=55000
# len(mnist.train.images[0])=784
# len(mnist.train.labels[0])=10


def plot_image(i, imgs, labels):
    # 将1维的0-1的数据转换为标准的0-255的整数数据，2维28x28的图片
    image = tf.floor(256.0 * tf.reshape(imgs[i], [28, 28]))
    # 原数据为float，转换为uint8字节数据
    image = tf.cast(image, dtype=tf.uint8)
    # 标签样本为10个字节的数组，为1的元素下标就是样本的标签值
    # 这里使用argmax方法直接转换为0-9的整数
    label = tf.argmax(labels[i])
    plt.grid(False)
    plt.xticks([])
    plt.yticks([])
    # 绘制样本图
    plt.imshow(image)
    # 显示标签值
    plt.xlabel(&quot;{}&quot;.format(label))


def show_images(num_rows, num_cols, images, labels):
    num_images = num_rows*num_cols
    plt.figure('Train Samples', figsize=(2*num_cols, 2*num_rows))
    # 循环显示前num_rows*num_cols副样本图片
    for i in range(num_images):
        plt.subplot(num_rows, num_cols, i+1)
        plot_image(i, images, labels)
    plt.show()

# 显示前4*6=24副训练集样本
show_images(4, 6, mnist.train.images, mnist.train.labels)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这个代码只是用来把样本集可视化。TensorFlow 2.0新特征，在这里只体现了取消Session和Session.run()。目的只是为了延续原来的讲解，让图片直接显示而不是保存为图像文件，以及升级到Python3和TensorFlow 2.0的执行环境。&lt;br/&gt;样本集显示出来效果是这样的：&lt;br/&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/mnist-train_Samples.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;tensorflow-2.0中的模型构建&quot;&gt;TensorFlow 2.0中的模型构建&lt;/h4&gt;
&lt;p&gt;原文第四篇中，我们使用了一个并不实用的线性回归模型来做手写数字识别。这样做可以简化中间层，从而能够使用可视化的手段来讲解机器视觉在数学上的基本原理。因为线性回归模型我们在本系列第一篇中讲过了，这里就跳过，直接说使用神经网络来解决MNIST问题。&lt;br/&gt;神经网络模型的构建在TensorFlow 1.0中是最繁琐的工作。我们曾经为了讲解vgg-19神经网络的使用，首先编写了一个复杂的辅助类，用于从字符串数组的遍历中自动构建复杂的神经网络模型。&lt;br/&gt;而在TensorFlow 2.0中，通过高度抽象的keras，可以非常容易的构建神经网络模型。&lt;br/&gt;为了帮助理解，我们先把TensorFlow 1.0中使用神经网络解决MNIST问题的代码原文粘贴如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding=UTF-8 -*-

import input_data
mnist = input_data.read_data_sets('data/', one_hot=True)

import tensorflow as tf
sess = tf.InteractiveSession()

#对W/b做初始化有利于防止算法陷入局部最优解，
#文档上讲是为了打破对称性和防止0梯度及神经元节点恒为0等问题，数学原理是类似问题
#这两个初始化单独定义成子程序是因为多层神经网络会有多次调用
def weight_variable(shape):
    #填充“权重”矩阵，其中的元素符合截断正态分布
    #可以有参数mean表示指定均值及stddev指定标准差
  initial = tf.truncated_normal(shape, stddev=0.1)
  return tf.Variable(initial)
def bias_variable(shape):
    #用0.1常量填充“偏移量”矩阵
  initial = tf.constant(0.1, shape=shape)
  return tf.Variable(initial)


#定义占位符，相当于tensorFlow的运行参数，
#x是输入的图片矩阵，y_是给定的标注标签，有标注一定是监督学习
x = tf.placeholder(&quot;float&quot;, shape=[None, 784])
y_ = tf.placeholder(&quot;float&quot;, shape=[None, 10])

#定义输入层神经网络，有784个节点，1024个输出，
#输出的数量是自己定义的，要跟第二层节点的数量吻合
W1 = weight_variable([784, 1024])
b1 = bias_variable([1024])
#使用relu算法的激活函数，后面的公式跟前一个例子相同
h1 = tf.nn.relu(tf.matmul(x, W1) + b1)

#定义第二层（隐藏层）网络，1024输入，512输出
W2 = weight_variable([1024, 512])
b2 = bias_variable([512])
h2 = tf.nn.relu(tf.matmul(h1, W2) + b2)

#定义第三层（输出层），512输入，10输出，10也是我们希望的分类数量
W3 = weight_variable([512, 10])
b3 = bias_variable([10])
#最后一层的输出同样用softmax分类（也算是激活函数吧）
y3=tf.nn.softmax(tf.matmul(h2, W3) + b3)

#交叉熵代价函数
cross_entropy = -tf.reduce_sum(y_*tf.log(y3))
#这里使用了更加复杂的ADAM优化器来做&quot;梯度最速下降&quot;，
#前一个例子中我们使用的是：GradientDescentOptimizer
train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)
#计算正确率以评估效果
correct_prediction = tf.equal(tf.argmax(y3,1), tf.argmax(y_,1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))
#tf初始化及所有变量初始化
sess.run(tf.global_variables_initializer())
#进行20000步的训练
for i in range(20000):
    #每批数据50组
  batch = mnist.train.next_batch(50)
  #每100步进行一次正确率计算并显示中间结果
  if i%100 == 0:
    train_accuracy = accuracy.eval(feed_dict={
        x:batch[0], y_: batch[1]})
    print &quot;step %d, training accuracy %g&quot;%(i, train_accuracy)
    #使用数据集进行训练
  train_step.run(feed_dict={x: batch[0], y_: batch[1]})

#完成模型训练给出最终的评估结果
print &quot;test accuracy %g&quot;%accuracy.eval(feed_dict={
    x: mnist.test.images, y_: mnist.test.labels})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下上面TensorFlow 1.x版本MNIST代码中的工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用了一个三层的神经网络，每一层都使用重复性的代码构建&lt;/li&gt;
&lt;li&gt;每一层的代码中，要精心计算输入和输出数据的格式、维度，使得每一层同上、下两层完全吻合&lt;/li&gt;
&lt;li&gt;精心设计损失函数（代价函数）和选择回归算法&lt;/li&gt;
&lt;li&gt;复杂的训练循环&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你理解了我总结的这几点，请继续看TensorFlow 2.0的实现：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/env python3

# 引入mnist数据预读准备库
# 2.0之后建议直接使用官方的keras.datasets.mnist.load_data
# 此处为了同以前的讲解对比，沿用之前的引用文件
import input_data
# tensorflow库
import tensorflow as tf
# tensorflow 已经内置了keras
from tensorflow import keras
# 引入绘图库
import matplotlib.pyplot as plt

# 这里使用mnist数据预读准备库检查给定路径是已经有样本数据，
# 没有的话去网上下载，并保存在指定目录
# 已经下载了数据的话，将数据读入内存，保存到mnist对象中
mnist = input_data.read_data_sets(&quot;data/&quot;, one_hot=True)

# 样本集的结构如下：
# mnist.train 训练数据集
# mnist.validation 验证数据集
# mnist.test 测试数据集
# len(mnist.train.images)=55000
# len(mnist.train.images[0])=784
# len(mnist.train.labels[0])=10


def plot_image(i, imgs, labels, predictions):
    # 将1维的0-1的数据转换为标准的0-255的整数数据，2维28x28的图片
    image = tf.floor(256.0 * tf.reshape(imgs[i], [28, 28]))
    # 原数据为float，转换为uint8字节数据
    image = tf.cast(image, dtype=tf.uint8)
    # 标签样本为10个字节的数组，为1的元素下标就是样本的标签值
    # 这里使用argmax方法直接转换为0-9的整数
    label = tf.argmax(labels[i])
    prediction = tf.argmax(predictions[i])
    plt.grid(False)
    plt.xticks([])
    plt.yticks([])
    # 绘制样本图
    plt.imshow(image)
    # 显示标签值，对比显示预测值和实际标签值
    plt.xlabel(&quot;predict:{} label:{}&quot;.format(prediction, label))


def show_images(num_rows, num_cols, images, labels, predictions):
    num_images = num_rows*num_cols
    plt.figure('Predict Samples', figsize=(2*num_cols, 2*num_rows))
    # 循环显示前num_rows*num_cols副样本图片
    for i in range(num_images):
        plt.subplot(num_rows, num_cols, i+1)
        plot_image(i, images, labels, predictions)
    plt.show()

# 原文中已经说明了，当前是10个元素数组表示一个数字，
# 值为1的那一元素的索引就是代表的数字，这是分类算法决定的
# 下面是直接转换为0-9的正整数，用作训练的标签
train_labels = tf.argmax(mnist.train.labels, 1)

# 定义神经网络模型
model = keras.Sequential([
    # 输入层为28x28共784个元素的数组,节点1024个
    keras.layers.Dense(1024, activation='relu', input_shape=(784,)),
    keras.layers.Dense(512, activation='relu'),
    keras.layers.Dense(10, activation='softmax')
])
# 编译模型
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
# 使用训练集数据训练模型
model.fit(mnist.train.images, train_labels, epochs=3)

# 测试集的标签同样转成0-9数字
test_labels = tf.argmax(mnist.test.labels, 1)
# 使用测试集样本验证识别准确率
test_loss, test_acc = model.evaluate(mnist.test.images, test_labels)
print('\nTest accuracy:', test_acc)

# 完整预测测试集样本
predictions = model.predict(mnist.test.images)
# 图示结果的前4*6个样本
show_images(4, 6, mnist.test.images, mnist.test.labels, predictions)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;代码讲解&quot;&gt;代码讲解&lt;/h4&gt;
&lt;p&gt;通常我都是直接在注释中对程序做仔细的讲解，这次例外一下，因为我们需要从大局观上看清楚代码的结构。&lt;br/&gt;这几行代码是定义神经网络模型：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 定义神经网络模型
model = keras.Sequential([
    # 输入层为28x28共784个元素的数组,节点1024个
    keras.layers.Dense(1024, activation='relu', input_shape=(784,)),
    keras.layers.Dense(512, activation='relu'),
    keras.layers.Dense(10, activation='softmax')
])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每一行实际就代表一层神经网络的节点。在第一行中特别指明了输入数据的形式，即可以有未知数量的样本，每一个样本784个字节(28x28)。实际上这个输入样本可以不指定形状，在没有指定的情况下，Keras会自动识别训练数据集的形状，并自动将模型输入匹配到训练集形状。只是这种习惯并不一定好，除了效率问题，当样本集出错的时候，模型的定义也无法帮助开发者提前发现问题。所以建议产品化的模型，应当在模型中指定输入数据类型。&lt;br/&gt;除了第一层之外，之后的每一层都无需指定输入样本形状。Keras会自动匹配相邻两个层的数据。这节省了开发人员大量的手工计算也不易出错。&lt;br/&gt;最后，激活函数的选择成为一个参数。整体代码看上去简洁的令人惊讶。&lt;/p&gt;
&lt;p&gt;接着在编译模型的代码中，直接指定Keras中预定义的“sparse_categorical_crossentropy”损失函数和“adam”优化算法。一个函数配合几个参数选择就完成了这部分工作：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 编译模型
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对原本复杂的训练循环部分，TensorFlow 2.0优化的最为彻底，只有一行代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 使用训练集数据训练模型
model.fit(mnist.train.images, train_labels, epochs=3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用测试集数据对模型进行评估同样只需要一行代码，这里就不摘出来了，在上面完整代码中能看到。&lt;br/&gt;可以想象，TensorFlow 2.0正式发布后，模型搭建、训练、评估的工作量大幅减少，会催生很多由实验性模型创新而出现的新算法。机器学习领域会再次涌现普及化浪潮。&lt;br/&gt;这一版代码中，我们还细微修改了样本可视化部分的程序，将原来显示训练集样本，改为显示测试集样本。主要是增加了一个图片识别结果的参数。将图片的识别结果同数据集的标注一同显示在图片的下面作为对比。&lt;br/&gt;程序运行的时候，控制台输出如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3 mnist-show-predict-pic-v1.py 
Extracting data/train-images-idx3-ubyte.gz
Extracting data/train-labels-idx1-ubyte.gz
Extracting data/t10k-images-idx3-ubyte.gz
Extracting data/t10k-labels-idx1-ubyte.gz
Epoch 1/3
55000/55000 [==============================] - 17s 307us/sample - loss: 0.1869 - accuracy: 0.9420
Epoch 2/3
55000/55000 [==============================] - 17s 304us/sample - loss: 0.0816 - accuracy: 0.9740
Epoch 3/3
55000/55000 [==============================] - 16s 298us/sample - loss: 0.0557 - accuracy: 0.9821
10000/10000 [==============================] - 1s 98us/sample - loss: 0.0890 - accuracy: 0.9743

Test accuracy: 0.9743&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的结果表示，模型通过3次的训练迭代之后。使用测试集数据进行验证，手写体数字识别正确率为97.43%。&lt;br/&gt;程序最终会显示测试集前24个图片及预测结果和标注信息的对比：&lt;br/&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/mnist_predict_samples.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（待续...）&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 04:49:00 +0000</pubDate>
<dc:creator>俺踏月色而来</dc:creator>
<og:description>图片样本可视化 '原文第四篇' 中，我们介绍了官方的入门案例MNIST，功能是识别手写的数字0 9。这是一个非常基础的TensorFlow应用，地位相当于通常语言学习的'Hello World!'。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andrewwang/p/10682766.html</dc:identifier>
</item>
<item>
<title>结合JDK源码看设计模式——模板方法模式 - 方块人</title>
<link>http://www.cnblogs.com/Cubemen/p/10682708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cubemen/p/10682708.html</guid>
<description>&lt;p&gt;　　相信很多人都听过一个问题：把大象关进冰箱门，需要几步？&lt;/p&gt;
&lt;p&gt;　　第一，把冰箱门打开；第二，把大象放进去；第三，把冰箱门关上。我们可以看见，这个问题的答案回答的很有步骤。接下来我们介绍一种设计模式——模板方法模式，你会发现，它与这个问题的答案实际上有很多共同之处。&lt;/p&gt;

&lt;p&gt;　　定义一个算法骨架，允许子类为一个或多个步骤提供实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。&lt;/p&gt;

&lt;h4&gt;　　一次性实现一个算法的不变的部分，将可变的行为留给子类实现&lt;/h4&gt;
&lt;p&gt;　　也就是将各子类中公共行为被提取出来并集中到一个公共父类中，从而避免代码重复。还是拿上面大象放进冰箱里面的例子，打开冰箱和关上冰箱都是不变的行为，我们可以将其放在公共父类实现。但是放大象，怎么放？是先放背对着冰箱放，还是面对着冰箱放。不想放大象，放老虎或者其他动物呢？这些就是我们可变的行为，这个就放入子类中实现。可以说，模板方法提供了一个很好的代码复用平台&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1646058/201904/1646058-20190410105913601-216850875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在刚接触ArrayList的时候一直没注意它继承的类和实现的接口。直到现在讲到了模板方法模式，再去看ArrayList的时候能明白不少。在前面的博客中有提到List接口和Cloneable接口是用来实现什么设计模式的。今天就来看看这个ArrayList的父类AbstractList。&lt;/p&gt;
&lt;p&gt;　　AbstractList就是我们前面适用场景中介绍的父类（也叫模板类），这个类里面即提供了公共的方法（不可供子类修改），又提供了可让子类修改的方法。下面我们直接看源码，由于方法很多，我们就介绍一下addAll方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractList&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractCollection&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(&lt;span&gt;int&lt;/span&gt; index, Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        rangeCheckForAdd(index);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; modified = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (E e : c) {
            add(index&lt;/span&gt;++&lt;span&gt;, e);
            modified &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modified;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的是AbstractList的addAll方法，可以看见这个方法没有限定子类是否去修改，子类由需要就去修改，如果子类不想修改，完全能够按照AbstractList中的逻辑添加元素。事实上我看了一遍AbstractList中的方法发现除了一些私有的方法不能给子类给子类访问之外，其余的基本上都是可以给子类去选择是否修改的。如果子类觉得父类的方法可行，那么直接使用父类的方法即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayList&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt;
        &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;&lt;span&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(&lt;span&gt;int&lt;/span&gt; index, Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        rangeCheckForAdd(index);

        Object[] a &lt;/span&gt;=&lt;span&gt; c.toArray();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numNew =&lt;span&gt; a.length;
        ensureCapacityInternal(size &lt;/span&gt;+ numNew);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt; numMoved = size -&lt;span&gt; index;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; 0&lt;span&gt;)
            System.arraycopy(elementData, index, elementData, index &lt;/span&gt;+&lt;span&gt; numNew,
                             numMoved);

        System.arraycopy(a, &lt;/span&gt;0&lt;span&gt;, elementData, index, numNew);
        size &lt;/span&gt;+=&lt;span&gt; numNew;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; numNew != 0&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个就是ArrayList中的addAll方法。&lt;/p&gt;
&lt;p&gt;　　但是AbstractList里面有一个方法，就是get()方法，AbstractList明确要求要让子类实现。由于代码较少，我就直接截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1646058/201904/1646058-20190410114813423-1725247730.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1646058/201904/1646058-20190410114846465-1423726656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 左边是父类AbstractList中的，右边是ArrayList中的方法。在父类中没有直接写出实现代码，而是让子类自己手动去实现。除此之外其实还有一个方法就是AbstractList父类AbstractCollection中的toString方法。在ArrayList中是没有的，但是平常在写代码时候，是可以直接调用的，这就是一个公共的方法。&lt;/p&gt;

&lt;p&gt;　　模板方法模式只需要简单的继承关系就可以完成。相信平常我们在写代码的时候也是使用过模板方法模式，只是我们并不知道是这种设计模式。这里多说一下，如果我们希望子类不要修改父类的方法，只需要加上final修饰即可；如果希望子类一定重写父类的方法，就将父类的方法用abstract修饰；如果子类可以修改也可以不修改，就可以像addAll方法那样设计即可。重点理解模板，这个模板尽量使用抽象类。因为抽象类比接口更加的灵活，能将模板定义的更好。其实看完上面的源码解析，总结起来就是一句话AbstractList是ArrayList的模板。&lt;/p&gt;

</description>
<pubDate>Wed, 10 Apr 2019 04:30:00 +0000</pubDate>
<dc:creator>方块人</dc:creator>
<og:description>前言： 相信很多人都听过一个问题：把大象关进冰箱门，需要几步？ 第一，把冰箱门打开；第二，把大象放进去；第三，把冰箱门关上。我们可以看见，这个问题的答案回答的很有步骤。接下来我们介绍一种设计模式——模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cubemen/p/10682708.html</dc:identifier>
</item>
</channel>
</rss>