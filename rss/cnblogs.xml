<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>系统模块划分设计的思考 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/12776537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/12776537.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;首先明确一下，这里所说的系统模块划分，是针对client，service，common这样的技术划分，而不是针对具体业务的模块划分。避免由于歧义，造成你的时间浪费。&lt;/p&gt;
&lt;h3 id=&quot;直接原因&quot;&gt;直接原因&lt;/h3&gt;
&lt;p&gt;公司内部某技术团队，在引用我们系统的client包时，启动失败。&lt;br/&gt;失败原因是由于client下有一个cache相关的依赖，其注入失败导致的。&lt;/p&gt;
&lt;p&gt;然后，就发出了这样一个疑问：我只是希望使用一个hsf接口，为什么还要引入诸如缓存，web处理工具等不相关的东西。&lt;/p&gt;
&lt;p&gt;这也就自然地引出了前辈对我的一句教导：对外的client需要尽可能地轻便。&lt;/p&gt;
&lt;p&gt;很明显，我们原有的client太重了，包含了对外的RPC接口，相关模型（如xxxDTO），工具包等等。&lt;/p&gt;
&lt;p&gt;可能有人就要提出，直接RPC+模型一个包，其它内容一个包不就OK了嘛？&lt;/p&gt;
&lt;p&gt;问题真的就这么简单嘛？&lt;/p&gt;
&lt;h3 id=&quot;根本原因&quot;&gt;根本原因&lt;/h3&gt;
&lt;p&gt;其实出现上述问题，是因为在系统设计之初，并没有深入思考client包的定位，以及日后可能遇到的情况。&lt;/p&gt;
&lt;p&gt;这也就导致了今天这样的局面，所幸目前的外部引用并不多，更多是内部引用。及时调整，推广新的依赖，与相关规范为时不晚。&lt;/p&gt;
&lt;h2 id=&quot;常见模块拆分&quot;&gt;常见模块拆分&lt;/h2&gt;
&lt;p&gt;先说说我以前的模块拆分。最早的拆分是每个业务模块主要拆分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;xxx-service：具体业务实现模块。&lt;/li&gt;
&lt;li&gt;xxx-client：对外提供的RPC接口模块。&lt;/li&gt;
&lt;li&gt;xxx-common：对外的工具，以及模型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种拆分方式，是我早期从一份微服务教程中看到的。优点是简单明了，调用方可选择性地选择需要的模块引入。&lt;/p&gt;
&lt;p&gt;至于一些通用的组件，如统一返回格式（如ServerResponse，RtObject），则放在了最早的核心（功能核心，但内容很少）模块上。&lt;/p&gt;
&lt;p&gt;后来，认为这样并不合适，不应该将通用组件放在一个业务模块上。所以建立了一个base模块，用来将通用的组件，如工具，统一返回格式等都放入其中。&lt;/p&gt;
&lt;p&gt;另外，将每个服务都有的xxx-common模块给取消了。将其中的模型，放入了xxx-client，毕竟是外部调用需要的。将其中的工具，根据需要进行拆分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;base：多个服务都会使用的。&lt;/li&gt;
&lt;li&gt;xxx-service：只有这个服务本身使用&lt;/li&gt;
&lt;li&gt;xxx-client：有限的服务使用，并且往往是服务提供方和服务调用方都要使用。但是往往这种情况，大多是由于接口设计存在问题导致的。所以多为过渡方案。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述这个方案，也就是我在负责某物联网项目时采用的最终模块划分方式。&lt;/p&gt;
&lt;p&gt;在当时的业务下，该方案的优点是模块清晰，较为简洁，并且尽可能满足了迪米特原则（可以参考《阿里Java开发手册相关实践》）。缺点则是需要一定的技术水平，对组件的功能域认识清晰。并且需要有一定的设计思考与能力（如上述工具拆分的第三点-xxx-client，明白为什么这是设计缺陷导致，并能够解决）。&lt;/p&gt;
&lt;h2 id=&quot;新的问题&quot;&gt;新的问题&lt;/h2&gt;
&lt;p&gt;那么，既然上述的方案挺不错的，为什么不复用到现在的项目呢？&lt;/p&gt;
&lt;p&gt;因为业务变了，导致应用场景变了。而这也带来了新的问题，新的考虑角度。&lt;/p&gt;
&lt;p&gt;原先的物联网业务规模并不大，所以依赖也较为简单，也并不需要进行依赖的封装等，所以针对主要是client的内/外这一维度考虑的。&lt;/p&gt;
&lt;p&gt;但是现有的业务场景，由于规模较大，模块依赖层级较多，导致上层模块引入过多的依赖。如有一个缓存模块，依赖tair-starter（一个封装的key-value的存储），然后日志模块依赖该缓存模块（进行性能优化），紧接着日志模块作为一个通用模块，被放入了common模块中。依赖链路如下：&lt;/p&gt;
&lt;p&gt;调用方 -&amp;gt; common模块 -&amp;gt; 日志模块 -&amp;gt; 缓存模块 -&amp;gt; tair-starter依赖&lt;/p&gt;
&lt;p&gt;但是有的调用方表示，根本就不需要日志模块，却引入了tair-starter这一重依赖（starter作为封装，都比较重），甚至由于tair-starter的内部依赖与自身原有依赖冲突，得去排查依赖，进行exclude。&lt;br/&gt;但是同时，也有的调用方，系统通过rich客户端，达到性能优化等目标。&lt;/p&gt;
&lt;p&gt;所以，现有的业务场景除了需要考虑client的内/外这一维度，还需要考虑client的pool/rich这一维度。&lt;/p&gt;
&lt;p&gt;可能有的小伙伴，看到这里有点晕乎乎的，这两个维度考量的核心在哪里？&lt;/p&gt;
&lt;p&gt;内/外，考虑的是按照内外这条线，尽量将client设计得简洁，避免给调用方引入无用依赖。&lt;/p&gt;
&lt;p&gt;而pool/rich，考虑的是性能，用户的使用成本（是否开箱即用）等。&lt;/p&gt;
&lt;h2 id=&quot;最终解决方案&quot;&gt;最终解决方案&lt;/h2&gt;
&lt;p&gt;最终的解决方案是对外提供3+n&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;xxx-client（1个）：所有外部系统引用都需要的内容，如统一返回格式等。&lt;/li&gt;
&lt;li&gt;xxx-yyy-client（n个）：对具体业务依赖的引用，进行了二次拆分。如xxx-order-client（这里是用订单提花那你一下，大家理解意思就OK）。&lt;/li&gt;
&lt;li&gt;xxx-pool-client（1个）：系统引用所需要的基本依赖，如Lindorm的依赖等。&lt;/li&gt;
&lt;li&gt;xxx-rich-client（1个）：系统引用所需要的依赖与对应starter，如一些自定义的自动装载starter（不需要用户进行配置）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个方案，换个思路，理解也简单。&lt;br/&gt;我们提供相关的能力，具体如何选择，交给调用方决定。&lt;/p&gt;
&lt;p&gt;其实，讨论中还提到了BOM方案（通过DependentManagement进行jar包版本管理）。不过分析后，我们认为BOM方案更适合那些依赖集比较稳定的client，如一些中间件。而我们目前的业务系统，还在快速发展，所以并不适用。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;简单来说，直接从用户需求考虑（这里的用户就是调用方）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外部依赖：
&lt;ul&gt;&lt;li&gt;额外引入的依赖尽可能地少，最好只引入二方依赖（我们提供的jar），不引入第三方依赖。&lt;/li&gt;
&lt;li&gt;引入的二方依赖不“夹带”私货（如二方jar引入了一堆大第三方依赖）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自动配置：
&lt;ul&gt;&lt;li&gt;可以傻瓜式使用。如引入对应的starter依赖，就可以自动装配对应默认配置。&lt;/li&gt;
&lt;li&gt;也可以自定义配置。用户可以在自定义配置，并不用引入无效的配置（因为starter经常引入不需要的依赖）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;性能：
&lt;ul&gt;&lt;li&gt;可以通过starter，提供一定的封装，保证一定的性能（如接口缓存，请求合并等）。&lt;/li&gt;
&lt;li&gt;可以自定义实现基础功能。因为有些人并不放心功能封装（虽然只是少数，但是稳定性前辈提出的）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;补充&quot;&gt;补充&lt;/h3&gt;
&lt;p&gt;这里补充一点，我对讨论中一个问题的回答，这里提一下。&lt;/p&gt;
&lt;p&gt;有人提到工具类，应该如何划分。因为有的工具类，是不依赖于服务状态的，如CookieUtil进行Cookie处理。有的工具类，是依赖于服务状态的，如RedisUtil包含RedisPool状态，直连Redis，处理Redis请求与响应。&lt;/p&gt;
&lt;p&gt;其实这里有两个细节：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具应该按照上面的方式进行划分为两种。单一模块系统，不依赖服务状态的工具往往置于util包，依赖服务状态的工具往往置于common包中。这里还有一个明显的区分点：前者的方法可以设为static，而后者并不能（因为依赖于new出来的状态）。&lt;/li&gt;
&lt;li&gt;依赖于状态的工具类，其实是一种拆分不完全的体现。如RedisUtil，可以拆分为连接状态管理的RedisPool与请求响应处理的RedisUitl。两者的组合方式有很多，取决于使用者的需要，以后有机会写一篇相关的博客。不过，我希望大家记住 面向接口编程的原则。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;愿与诸君共进步。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Apr 2020 00:41:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>系统模块划分设计的思考 前言 首先明确一下，这里所说的系统模块划分，是针对client，service，common这样的技术划分，而不是针对具体业务的模块划分。避免由于歧义，造成你的时间浪费。 直接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/12776537.html</dc:identifier>
</item>
<item>
<title>在.NET Core中用最原生的方式读取Nacos的配置 - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/12776725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/12776725.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;之前老黄写过一篇《ASP.NET Core结合Nacos来完成配置管理和服务发现》简单介绍了如何让.NET Core程序接入Nacos，之前的SDK里面更多的是对Nacos的Open API进行了封装以及对服务注册和发现的封装。&lt;/p&gt;
&lt;p&gt;配置这一块当时并没有过多的处理，用起来有时感觉不会特别顺手，所以将它和.NET Core的配置结合起来了，让它用起来更简便。&lt;/p&gt;
&lt;p&gt;怎么个简便法呢？&lt;/p&gt;
&lt;p&gt;可以说，除了多添加一下provider，其他的操作都是和最原始的一模一样，你想用&lt;code&gt;IConfiguration&lt;/code&gt;就用&lt;code&gt;IConfiguration&lt;/code&gt;，想用&lt;code&gt;IOptions&lt;/code&gt;系列就用&lt;code&gt;IOptions&lt;/code&gt;系列。&lt;/p&gt;
&lt;p&gt;更容易做到无缝迁移！&lt;/p&gt;
&lt;p&gt;当然，这个SDK出自老黄的手，难免会有一些坑和bug，这个就请各位多多包涵！！&lt;/p&gt;
&lt;h2 id=&quot;前提条件&quot;&gt;前提条件&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;启动Nacos Server&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最简单的方式，用docker启动一个单机版的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose -f example/standalone-mysql-8.yaml up
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建一个.NET Core项目，并安装相应nuget包&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里将用ASP.NET Core Web Api做示例，同时要安装下面的nuget包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet add package nacos-sdk-csharp-unofficial.Extensions.Configuration --version 0.2.6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更直接点，直接修改csproj&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;nacos-sdk-csharp-unofficial.Extensions.Configuration&quot; Version=&quot;0.2.6&quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进行配置&quot;&gt;进行配置&lt;/h2&gt;
&lt;p&gt;打开&lt;code&gt;Program.cs&lt;/code&gt;，在&lt;code&gt;CreateHostBuilder&lt;/code&gt;加入Nacos的provider配置，都是Nacos的一些基础配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
        Host.CreateDefaultBuilder(args)
             .ConfigureAppConfiguration((context, builder) =&amp;gt;
             {
                 var c = builder.Build();
                 var dataId = c.GetValue&amp;lt;string&amp;gt;(&quot;nacosconfig:DataId&quot;);
                 var group = c.GetValue&amp;lt;string&amp;gt;(&quot;nacosconfig:Group&quot;);
                 var tenant = c.GetValue&amp;lt;string&amp;gt;(&quot;nacosconfig:Tenant&quot;);
                 var optional = c.GetValue&amp;lt;bool&amp;gt;(&quot;nacosconfig:Optional&quot;);
                 var serverAddresses = c.GetSection(&quot;nacosconfig:ServerAddresses&quot;).Get&amp;lt;List&amp;lt;string&amp;gt;&amp;gt;();
                               
                 // 0.2.6版本之前，只支持这种方式
                 builder.AddNacosConfiguration(x =&amp;gt;
                 {
                     x.DataId = dataId;
                     x.Group = group;
                     x.Tenant = tenant;
                     x.Optional = optional;
                     x.ServerAddresses = serverAddresses;
                 });

                 //// 0.2.6版本之后可以从配置文件读取Nacos的基本配置
                 //builder.AddNacosConfiguration(c.GetSection(&quot;nacosconfig&quot;));
                 
             })
            .ConfigureWebHostDefaults(webBuilder =&amp;gt;
            {
                webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，我们还要修改&lt;code&gt;appsettings.json&lt;/code&gt;，把Nacos的配置写进去，主要是用来区分不同环境的配置来源。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Warning&quot;,
        &quot;Microsoft&quot;: &quot;Warning&quot;,
        &quot;Microsoft.Hosting.Lifetime&quot; :&quot;Information&quot;
    }  
  },
  &quot;nacosconfig&quot;:{
    &quot;Optional&quot;: false,
    &quot;DataId&quot;: &quot;msconfigapp&quot;,
    &quot;Group&quot;: &quot;&quot;,
    &quot;Tenant&quot;: &quot;ca31c37e-478c-46ed-b7ea-d0ebaa080221&quot;,
    &quot;ServerAddresses&quot;: [&quot;localhost:8848&quot;]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到这里，用于配置Nacos相关的内容就结束了。接下来，要做的就是在nacos控制台进行配置的维护。&lt;/p&gt;
&lt;h2 id=&quot;配置使用&quot;&gt;配置使用&lt;/h2&gt;
&lt;p&gt;新建一个配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202004/558945-20200426081109420-1797436758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加一个对应的实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class AppSettings
{
        public string Str { get; set; }

        public int Num { get; set; }

        public List&amp;lt;int&amp;gt; Arr { get; set; }

        public SubObj SubObj { get; set; }
}

public class SubObj
{
        public string a { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为要验证IOptions模式，所以要在&lt;code&gt;Startup&lt;/code&gt;中加点代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
    services.Configure&amp;lt;AppSettings&amp;gt;(Configuration.GetSection(&quot;AppSettings&quot;));
    services.AddControllers();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就是真正的使用了！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class ConfigController : ControllerBase
{
    private readonly IConfiguration _configuration;
    private readonly AppSettings _settings;
    private readonly AppSettings _sSettings;
    private readonly AppSettings _mSettings;
    
    public ConfigController(
        IConfiguration configuration,
        IOptions&amp;lt;AppSettings&amp;gt; options,
        IOptionsSnapshot&amp;lt;AppSettings&amp;gt; sOptions,
        IOptionsMonitor&amp;lt;AppSettings&amp;gt; _mOptions
        )
    {
        _configuration = configuration;
        _settings = options.Value;
        _sSettings = sOptions.Value;
        _mSettings = _mOptions.CurrentValue;
    }
    
    [HttpGet]
    public string Get()
    {
        string id = Guid.NewGuid().ToString(&quot;N&quot;);
    
        Console.WriteLine($&quot;============== begin {id} =====================&quot;);
    
        var conn = _configuration.GetConnectionString(&quot;Default&quot;);
        Console.WriteLine($&quot;{id} conn = {conn}&quot;);
    
        var version = _configuration[&quot;version&quot;];
        Console.WriteLine($&quot;{id} version = {version}&quot;);
    
        var str1 = Newtonsoft.Json.JsonConvert.SerializeObject(_settings);
        Console.WriteLine($&quot;{id} IOptions = {str1}&quot;);
    
        var str2 = Newtonsoft.Json.JsonConvert.SerializeObject(_sSettings);
        Console.WriteLine($&quot;{id} IOptionsSnapshot = {str2}&quot;);
    
        var str3 = Newtonsoft.Json.JsonConvert.SerializeObject(_mSettings);
        Console.WriteLine($&quot;{id} IOptionsMonitor = {str3}&quot;);
    
        Console.WriteLine($&quot;===============================================&quot;);
    
        return &quot;ok&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码，看上去应该熟悉的不能再熟悉了吧！这些配置的用法，就是.NET Core里面提供的最原始的，原汁原味。&lt;/p&gt;
&lt;p&gt;启动访问这个接口，可以看到下面的输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202004/558945-20200426081137629-1476704869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在控制台修改这个配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202004/558945-20200426081146761-393207831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次访问，可以发现，除了&lt;code&gt;IOptions&lt;/code&gt;之外，都读取到了新的配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202004/558945-20200426081203521-453632963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之所以&lt;code&gt;IOptions&lt;/code&gt;没有获取到最新的配置，那是因为它的默认实现不会进行更新操作，也就是从启动到结束，它都是不会变的。&lt;/p&gt;
&lt;p&gt;在有配置变更的情景，请尽可能不要用&lt;code&gt;IOptions&lt;/code&gt;，用&lt;code&gt;IOptionsSnapshot&lt;/code&gt;和&lt;code&gt;IOptionsMonitor&lt;/code&gt;来替代！&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这里介绍了如何让.NET Core更容易对接Nacos配置的方法，希望对各位有所帮助。&lt;/p&gt;
&lt;p&gt;如果您对 nacos-sdk-charp 这个项目感兴趣，也欢迎一起开发和维护这个项目。&lt;/p&gt;
&lt;p&gt;本文首发于我的公众号：不才老黄&lt;/p&gt;
&lt;p&gt;感兴趣的可以关注一下。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Apr 2020 00:17:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<og:description>在.NET Core中用最原生的方式读取Nacos的配置，原汁原味！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/catcher1994/p/12776725.html</dc:identifier>
</item>
<item>
<title>一份热乎乎的腾讯后端面试真题 - Jay_huaxiao</title>
<link>http://www.cnblogs.com/jay-huaxiao/p/12776714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-huaxiao/p/12776714.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近有个好朋友换工作了，面了腾讯后端，跟他要了份面试真题，大家一起来探讨一下，哈哈~&lt;/p&gt;
&lt;h2 id=&quot;腾讯后端一面&quot;&gt;腾讯后端一面&lt;/h2&gt;
&lt;h3 id=&quot;①-jvm内存模型&quot;&gt;① JVM内存模型&lt;/h3&gt;
&lt;p&gt;这个可以复习一下《深入理解Java虚拟机》第12章（Java内存模型和线程）哈&lt;sub&gt;，也可以看看我之前的文章哈&lt;/sub&gt;&lt;a href=&quot;https://juejin.im/post/5d35ca5b518825449c64bc31&quot;&gt;JVM常见面试题解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JVM内存结构：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/26/171b3b57de3b838c?w=727&amp;amp;h=478&amp;amp;f=png&amp;amp;s=203974&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java内存模型图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/26/171b3a11106f2cad?w=823&amp;amp;h=759&amp;amp;f=png&amp;amp;s=231498&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;②cms和g1有没有了解过，它们有什么区别&quot;&gt;②cms和g1有没有了解过，它们有什么区别&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；&lt;/li&gt;
&lt;li&gt;G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；&lt;/li&gt;
&lt;li&gt;CMS收集器以最小的停顿时间为目标的收集器；&lt;/li&gt;
&lt;li&gt;G1收集器可预测垃圾回收的停顿时间&lt;/li&gt;
&lt;li&gt;CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片&lt;/li&gt;
&lt;li&gt;G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个点是可以看《深入理解Java虚拟机》第三章，垃圾收集器与内存分配策略哈&lt;/p&gt;
&lt;h3 id=&quot;③谈谈你对垃圾回收的了解，什么时候发生垃圾回收，回收过程&quot;&gt;③谈谈你对垃圾回收的了解，什么时候发生垃圾回收，回收过程&lt;/h3&gt;
&lt;p&gt;可以讲JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，如Minor GC，Major GC，full GC这几个讲清楚，还有对象存活判断方法，还有垃圾回收算法，复制算法等等&lt;/p&gt;
&lt;p&gt;这个点也是可以看《深入理解Java虚拟机》第三章，垃圾收集器与内存分配策略哈&lt;/p&gt;
&lt;h3 id=&quot;④-对于数据的一致性是怎么保证的&quot;&gt;④ 对于数据的一致性是怎么保证的&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这个如果是我的思路的话，我会谈缓存与数据库的一致性，可以看看我之前这篇文章&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d4a3196f265da03ab423727&quot;&gt;并发环境下，先操作数据库还是先操作缓存？&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;也可以谈谈分布式事务下的数据一致性，也可以看看之前我的这篇文章&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e47bc14518825491b11bef4&quot;&gt;后端程序员必备：分布式事务基础篇&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;⑤-redis集群有没有了解过，主从和选举是怎么样子的&quot;&gt;⑤ Redis集群有没有了解过，主从和选举是怎么样子的&lt;/h3&gt;
&lt;p&gt;这个可以回答这些关键词，主从复制 ，哨兵机制等这些&lt;sub&gt;可以看看网上这篇啦，或者亲爱的读者，去网上看一下资料哈&lt;/sub&gt;&lt;br/&gt;&lt;a href=&quot;https://aiylqy.com/archives/213.html&quot;&gt;Redis 主从复制架构和Sentinel哨兵机制&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;⑥-看你们公司使用的是mysql，你们使用的是哪种存储引擎，为什么？myisam和innodb的区别&quot;&gt;⑥ 看你们公司使用的是MySQL，你们使用的是哪种存储引擎，为什么？MyISAM和InnoDB的区别&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MyISAM：如果执行大量的SELECT，MyISAM是更好的选择&lt;/li&gt;
&lt;li&gt;InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表&lt;/li&gt;
&lt;li&gt;mysiam表不支持外键，而InnoDB支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MyISAM适合：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;做很多count 的计算；&lt;/li&gt;
&lt;li&gt;插入不频繁，查询非常频繁；&lt;/li&gt;
&lt;li&gt;没有事务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;InnoDB适合：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;列表内容 可靠性要求比较高，或者要求事务；&lt;/li&gt;
&lt;li&gt;表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;⑦-索引的底层数据结构是什么，为什么选择这种数据结构&quot;&gt;⑦ 索引的底层数据结构是什么，为什么选择这种数据结构&lt;/h3&gt;
&lt;p&gt;可以看看网上的这篇，写得不错~&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxMzk3Mjg5MQ==&amp;amp;mid=2247483916&amp;amp;idx=1&amp;amp;sn=bfc33b53f8176e6f4d7e64c087ad36a4&amp;amp;chksm=97afe0f8a0d869eeaa14d8b26eca9d6fa09f9fda4557b40cb22ebe75851aa4dfb67d822233d9&amp;amp;scene=0&amp;amp;subscene=90&amp;amp;sessionid=1539434820&amp;amp;ascene=7&amp;amp;devicetype=andro&quot;&gt;MySQL索引为什么要用B+树实现？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;⑧sql优化，怎么判断需要优化，从哪些方面着手优化&quot;&gt;⑧SQL优化，怎么判断需要优化，从哪些方面着手优化&lt;/h3&gt;
&lt;p&gt;从索引角度出发，就很多点可以讲，&lt;br/&gt;这个可以看看我的这两篇文章哈~&lt;/p&gt;
&lt;h3 id=&quot;⑨-手写代码：设计一个分布式自增id生成服务&quot;&gt;⑨ 手写代码：设计一个分布式自增id生成服务&lt;/h3&gt;
&lt;p&gt;可以去网上找一下答案哈，这个我也没什么思路~参考分库分表一些想法？nginx负载均衡一些想法？哈哈，亲爱的读者，如果你会的话，可不可以告诉我呢&lt;/p&gt;
&lt;h2 id=&quot;腾讯后端二面：&quot;&gt;腾讯后端二面：&lt;/h2&gt;
&lt;h3 id=&quot;①有没有了解过网络安全问题，常见的网络攻击有哪些，原理是什么，可以怎么解决&quot;&gt;①有没有了解过网络安全问题，常见的网络攻击有哪些，原理是什么，可以怎么解决&lt;/h3&gt;
&lt;p&gt;XSS，跨站脚本攻击？CSRF,跨站请求伪造？DDOS，分布式拒绝服务攻击？SQL注入？&lt;/p&gt;
&lt;p&gt;对于SQL注入，可以进行后台处理，比如，使用预编译语句PreparedStatement进行预处理，又比如Mybatis映射语句中，用#{xxx}而不是${}&lt;/p&gt;
&lt;h3 id=&quot;②平时在开发接口或者设计项目的时候如何保证安全性的&quot;&gt;②平时在开发接口或者设计项目的时候如何保证安全性的&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;签名&lt;/li&gt;
&lt;li&gt;加密&lt;/li&gt;
&lt;li&gt;ip检测限流？&lt;/li&gt;
&lt;li&gt;接口幂等&lt;/li&gt;
&lt;li&gt;特殊字符实现过滤 防止xss、sql注入的攻击？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;③使用redis集群时可能会存在什么问题&quot;&gt;③使用Redis集群时可能会存在什么问题&lt;/h3&gt;
&lt;p&gt;数据一致性问题&lt;/p&gt;
&lt;h3 id=&quot;④有没有了解过cap和base原则&quot;&gt;④有没有了解过cap和base原则&lt;/h3&gt;
&lt;h4 id=&quot;cap理论&quot;&gt;CAP理论&lt;/h4&gt;
&lt;p&gt;CAP理论作为分布式系统的基础理论，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），这三个要素最多只能同时实现两点。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/20/16c0f6675fee8222?w=302&amp;amp;h=289&amp;amp;f=png&amp;amp;s=25862&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性(C：Consistency)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一致性是指数据在多个副本之间能否保持一致的特性。例如一个数据在某个分区节点更新之后，在其他分区节点读出来的数据也是更新之后的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用性(A：Availability)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是&quot;有限时间内&quot;和&quot;返回结果&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分区容错性（P:Partition tolerance）:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;选择&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CA&lt;/td&gt;
&lt;td&gt;放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AP&lt;/td&gt;
&lt;td&gt;放弃一致性，分区容错性和可用性，这是很多分布式系统设计时的选择&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CP&lt;/td&gt;
&lt;td&gt;放弃可用性，追求一致性和分区容错性，网络问题会直接让整个系统不可用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;base-理论&quot;&gt;BASE 理论&lt;/h4&gt;
&lt;p&gt;BASE 理论， 是对CAP中AP的一个扩展，对于我们的业务系统，我们考虑牺牲一致性来换取系统的可用性和分区容错性。BASE是Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Basically Available&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本可用：通过支持局部故障而不是系统全局故障来实现的。如将用户分区在 5 个数据库服务器上，一个用户数据库的故障只影响这台特定主机那 20% 的用户，其他用户不受影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Soft State&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软状态，状态可以有一段时间不同步&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Eventually Consistent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终一致，最终数据是一致的就可以了，而不是时时保持强一致。&lt;/p&gt;
&lt;h3 id=&quot;⑤zk是如何保证一致性的&quot;&gt;⑤zk是如何保证一致性的&lt;/h3&gt;
&lt;p&gt;可以看这本书哈~&lt;br/&gt;《从paxos到Zookeeper分布式一致性原理与实践》，&lt;/p&gt;
&lt;p&gt;也可以看这篇文章：&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25594630&quot;&gt;浅析Zookeeper的一致性原理&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;⑥你如何设计一个能抗住大流量的系统，说说设计方案&quot;&gt;⑥你如何设计一个能抗住大流量的系统，说说设计方案&lt;/h3&gt;
&lt;p&gt;nginx负载均衡，流量防卫兵sentinel，服务拆分，缓存，消息队列，集群、限流、降级这些都可以搬出来啦~&lt;/p&gt;
&lt;h3 id=&quot;⑦有没有了解过缓存策略有哪些&quot;&gt;⑦有没有了解过缓存策略有哪些&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Cache-Aside&lt;/li&gt;
&lt;li&gt;Read-Through&lt;/li&gt;
&lt;li&gt;Write-Through&lt;/li&gt;
&lt;li&gt;Write-Behind&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有兴趣还是可以看看我这篇文章，哈哈&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d4a3196f265da03ab423727&quot;&gt;并发环境下，先操作数据库还是先操作缓存？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;个人公众号&quot;&gt;个人公众号&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/28/16c381c89b127bbb?w=344&amp;amp;h=344&amp;amp;f=jpeg&amp;amp;s=8943&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你是个爱学习的好孩子，可以关注我公众号，一起学习讨论。&lt;/li&gt;
&lt;li&gt;如果你觉得本文有哪些不正确的地方，可以评论，也可以关注我公众号，私聊我，大家一起学习进步哈。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 26 Apr 2020 00:11:00 +0000</pubDate>
<dc:creator>Jay_huaxiao</dc:creator>
<og:description>前言 最近有个好朋友换工作了，面了腾讯后端，跟他要了份面试真题，大家一起来探讨一下，哈哈~ 腾讯后端一面 ① JVM内存模型 这个可以复习一下《深入理解Java虚拟机》第12章（Java内存模型和线程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jay-huaxiao/p/12776714.html</dc:identifier>
</item>
<item>
<title>Java面试系列第2篇-Object类中的方法 - 归去来兮辞</title>
<link>http://www.cnblogs.com/extjs4/p/12772027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/extjs4/p/12772027.html</guid>
<description>&lt;p&gt;Java的Object是所有引用类型的父类，定义的方法&lt;span class=&quot;bjh-p&quot;&gt;按照用途可以分为以下几种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（1）构造函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（2）hashCode() 和 equals() 函数用来判断对象是否相同&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（3）wait()、wait(long)、wait(long,int)、notify()、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;notifyAll() 线程等待和唤醒&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（4）toString() &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（5）getClass() 获取运行时类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（5）clone()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（6）finalize() 用于在垃圾回收。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;这些方法经常会被问题到，所以需要记得。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;由这几类方法涉及到的知识点非常多，我们现在总结一下根据这几个方法涉及的面试题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-ul&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;1、对象的克隆涉及到的相关面试题目&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;涉及到的方法就是clone()。克隆就是为了快速构造一个和已有对象相同的副本。如果克隆对象，一般需要先创建一个对象，然后将原对象中的数据导入到新创建的对象中去，而不用根据已有对象进行手动赋值操作。&lt;/p&gt;
&lt;p&gt;任何克隆的过程最终都将到达java.lang.Object 的clone()方法，而其在Object接口中定义如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
protected native Object clone() throws CloneNotSupportedException;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在面试中需要分清深克隆与浅克隆。克隆就是复制一个对象的复本。但一个对象中可能有基本数据类型，也同时含有引用类型。克隆后得到的新对象的基本类型的值修改了，原对象的值不会改变，这种适合shadow clone（浅克隆）。&lt;/p&gt;
&lt;p&gt;如果你要改变一个非基本类型的值时,原对象的值却改变了，比如一个数组，内存中只copy地址，而这个地址指向的值并没有 copy。当clone时，两个地址指向了一个值。一旦这个值改变了，原来的值当然也变了，因为他们共用一个值。这就必须得用deep clone（深克隆）。举个例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class ShadowClone implements Cloneable {

        private int a; // 基本类型
        private String b; // 引用类型
        private int[] c; // 引用类型
        // 重写Object.clone()方法,并把protected改为public

        @Override
        public Object clone() {
                ShadowClone sc = null;
                try {
                        sc = (ShadowClone) super.clone();
                } catch (CloneNotSupportedException e) {
                        e.printStackTrace();
                }
                return sc;
        }

        public int getA() {
                return a;
        }

        public void setA(int a) {
                this.a = a;
        }

        public String getB() {
                return b;
        }

        public void setB(String b) {
                this.b = b;
        }

        public int[] getC() {
                return c;
        }

        public void setC(int[] c) {
                this.c = c;
        }

        public static void main(String[] args) throws CloneNotSupportedException{
        ShadowClone c1 = new ShadowClone();
        //对c1赋值
        c1.setA(50) ;
        c1.setB(&quot;test1&quot;);
        c1.setC(new int[]{100}) ;
        
        System.out.println(&quot;克隆前c1:  a=&quot;+c1.getA()+&quot; b=&quot;+c1.getB()+&quot; c=&quot;+c1.getC()[0]);
        
        
        ShadowClone c2 = (ShadowClone) c1.clone();
        c2.setA(100) ;
        c2.setB(&quot;test2&quot;);
        int []c = c2.getC() ;
        c[0]=500 ;
        System.out.println(&quot;克隆前c1:  a=&quot;+c1.getA()+ &quot; b=&quot;+c1.getB()+&quot; c[0]=&quot;+c1.getC()[0]);
        System.out.println(&quot;克隆后c2:  a=&quot;+c2.getA()+ &quot; b=&quot;+c2.getB()+&quot; c[0]=&quot;+c2.getC()[0]);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后打印如下信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
克隆前c1:  a=50  b=test1 c=100
克隆后c1:  a=50  b=test1 c[0]=500
克隆后c2:  a=100 b=test2 c[0]=500
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c1与c2对象中的c数组的第1个元素都变为了500。需要要实现相互不影响，必须进行深copy，也就是对引用对象也调用clone()方法，如下实现深copy：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
@Override
public Object clone() {
        ShadowClone sc = null;
        try {
                sc = (ShadowClone) super.clone();
                sc.setC(b.clone());
        } catch (CloneNotSupportedException e) {
                e.printStackTrace();
        }
        return sc;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就不会相互影响了。　&lt;/p&gt;
&lt;p&gt;另外需要注意，对于引用类型来说，并没有在clone()方法中调用b.clone()方法来实现b对象的复制，但是仍然没有相互影响，这是由于Java中的字符串不可改变。就是在调用c1.clone()方法时，有两个指向同一字符串test1对象的引用，当调用c2.setB(&quot;test2&quot;)语句时，c2中的b指向了自己的字符串test2，所以就不会相互影响了。 &lt;/p&gt;
&lt;h3&gt;2、hashCode()和equals()相关面试题目&lt;/h3&gt;
&lt;p&gt; equals()方法定义在Object类内并进行了简单的实现，如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public boolean equals(Object obj) {
        return (this == obj);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较两个原始类型比较的是内容，而如果比较引用类型的话，可以看到是通过==符号来比较的，所以比较的是引用地址，如果要自定义比较规则的话，可以覆写自己的equals()方法。 String 、Math、还有Integer、Double等封装类重写了Object中的equals()方法，让它不再简单的比较引用，而是比较对象所表示的实际内容。其实就是自定义我们实际想要比较的东西。比如说，班主任要比较两个学生Stu1和Stu2的成绩，那么需要重写Student类的equals()方法，在equals()方法中只进行简单的成绩比较即可，如果成绩相等，就返回true，这就是此时班主任眼中的相等。&lt;br/&gt;首先来看第1道面试题目，手写equals()方法，在手写时需要注意以下几点：&lt;/p&gt;
&lt;p&gt;当我们自己要重写equals()方法进行内容的比较时，可以遵守以下几点： &lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;（1）使用instanceof 操作符检查“实参是否为正确的类型”。&lt;/p&gt;
&lt;p&gt;（2）对于类中的每一个“关键域”，检查实参中的域与当前对象中对应的域值。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;对于非float和double类型的原语类型域，使用==比较；&lt;/li&gt;
&lt;li&gt;对于float域，使用Float.floatToIntBits(afloat)转换为int，再使用==比较；&lt;/li&gt;
&lt;li&gt;对于double域，使用Double.doubleToLongBits(adouble) 转换为int，再使用==比较；&lt;/li&gt;
&lt;li&gt;对于对象引用域，递归调用equals()方法；&lt;/li&gt;
&lt;li&gt;对于数组域，调用Arrays.equals()方法。　　&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;给一个字符串String实现的equals()实例，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public boolean equals(Object anObject) {
        if (this == anObject) {            // 反射性
            return true;
        }
        if (anObject instanceof String) { // 只有同类型的才能比较
            String anotherString = (String) anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                            return false;
                    i++;
                }
                return true;  // 返回true时，表示长度相等,且字符序列中含有的字符相等
            }
        }
        return false;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外的高频面试题目就是equals()和hashCode()之间的相互关系。　&lt;/p&gt;
&lt;div readability=&quot;40.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;如果两个对象是相等的，那么他们必须拥有一样的hashcode，这是第一个前提；&lt;/li&gt;
&lt;li&gt;如果两个对象有一样的hashcode，但仍不一定相等，因为还需要第二个要求，也就是equals()方法的判断。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我觉得如上2句的总结必须要有一个非常重要的前提，就是要在使用hashcode进行散列的前提下，否则谈不上equals()相等，hashcode一定相等这种说法。&lt;/p&gt;
&lt;p&gt;对于使用hashcode的map来说，map判断对象的方法就是先判断hashcode是否相等，如果相等再判断equals方法是否返回true，只有同时满足两个条件，最后才会被认为是相等的。&lt;/p&gt;
&lt;p&gt;Map查找元素比线性搜索更快，这是因为map利用hashkey去定位元素，这个定位查找的过程分成两步，内部原理中，map将对象存储在类似数组的数组的区域，所以要经过两个查找，先找到hashcode相等的，然后在再在其中按线性搜索使用equals方法，通过这2步来查找一个对象。 &lt;/p&gt;
&lt;p&gt;另外还有在书写hashCode()方法时，为什么要用31这个数字？ 例如String类的hashCode()的实现如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
public int hashCode() {
        int h = hash;
        if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
            char val[] = value;

            for (int i = 0; i &amp;lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;循环中的每一步都对上一步的结果乘以一个系数31，选择这个数主要原因如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;奇数 乘法运算时信息不丢失；&lt;/li&gt;
&lt;li&gt;质数（质数又称为素数，是一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数） 特性能够使得它和其他数相乘后得到的结果比其他方式更容易产成唯一性，也就是hashCode值的冲突概率最小；&lt;/li&gt;
&lt;li&gt;可优化为31 * i == (i &amp;lt;&amp;lt; 5) - i，这样移位运算比乘法运算效率会高一些。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3、线程等待和唤醒相关面试题　　&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;最常见的面试题就是sleep()与wait()方法的区别，这个问题很简单，调用sleep()方法不会释放锁，而调用wait()方法会阻塞当前线程并释放当前线程持有的锁。。&lt;/p&gt;
&lt;p&gt;另外就是问wait()与notify()、notifyAll()方法相关的问题了，比如这几个方法为什么要定义在Object类中，一句话，因为Java中所有的对象都能当成锁，也就是监视器对象。&lt;/p&gt;
&lt;p&gt;我们需要明白，调用这几个方法时，当前线程一定要持有锁，否则调用这几个方法会引起异常（也是一道面试题）。&lt;/p&gt;
&lt;p&gt;有时候还需要书写生产者-消费者模式，我们就用wait()与notify()、notifyAll()方法写一个吧，如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// 仓库
class Godown {
        public static final int max_size = 100; // 最大库存量
        public int curnum; // 当前库存量

        Godown(int curnum) {
                this.curnum = curnum;
        }

        // 生产指定数量的产品
        public synchronized void produce(int neednum) {
                while (neednum + curnum &amp;gt; max_size) {
                        try {
                                wait(); // 当前的生产线程等待，并让出锁
                        } catch (InterruptedException e) {
                                e.printStackTrace();
                        }
                }
                // 满足生产条件，则进行生产，这里简单的更改当前库存量
                curnum += neednum;
                System.out.println(&quot;已经生产了&quot; + neednum + &quot;个产品，现仓储量为&quot; + curnum);
                notifyAll();  // 唤醒在此对象监视器上等待的所有线程
        }

        // 消费指定数量的产品
        public synchronized void consume(int neednum) {
                while (curnum &amp;lt; neednum) {
                        try {
                                wait(); // 当前的消费线程等待，并让出锁
                        } catch (InterruptedException e) {
                                e.printStackTrace();
                        }
                }
                // 满足消费条件，则进行消费，这里简单的更改当前库存量
                curnum -= neednum;
                System.out.println(&quot;已经消费了&quot; + neednum + &quot;个产品，现仓储量为&quot; + curnum);
                notifyAll(); // 唤醒在此对象监视器上等待的所有线程
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在同步方法开始时都会测试，如果生产了过多或不够消费时，调用wait()方法阻塞当前线程并让锁。在同步方法最后都会调用notifyAll()方法，这算是给所有线程一个公平竞争锁的机会吧，他会唤醒在synchronized方法和wait()上阻塞等待的线程，因为他们都将当前对象做为锁对象。&lt;/p&gt;







&lt;/div&gt;

</description>
<pubDate>Sat, 25 Apr 2020 23:36:00 +0000</pubDate>
<dc:creator>归去来兮辞</dc:creator>
<og:description>Java的Object是所有引用类型的父类，定义的方法按照用途可以分为以下几种： （1）构造函数 （2）hashCode() 和 equals() 函数用来判断对象是否相同 （3）wait()、wai</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/extjs4/p/12772027.html</dc:identifier>
</item>
<item>
<title>程序员买房的一些想法 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12776661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12776661.html</guid>
<description>&lt;p&gt;我在苏州刚参加工作那会，对未来充满了希望，信誓旦旦地以为，凭借自己的努力，三五年后就能在苏州买一套房子。&lt;/p&gt;
&lt;p&gt;凭良心讲，苏州就是我的第二个故乡，因为它治好了我的青春痘——这玩意从高一下半学期就开始困扰我。我姑姑家的一个姐姐每次见到我就念叨，真的是越长越丑了，这特么都怪青春痘啊。&lt;/p&gt;
&lt;p&gt;在苏州生活了差不多半年，久治不愈的青春痘竟然挥挥手和我告别了，只留下了一些近距离才能看得出的痘印。总之，我对苏州的印象极佳。&lt;/p&gt;
&lt;p&gt;刚去那会，人生地不熟的，经常思念起家乡，想父母，想女朋友。夜不能寐的时候，就暗下决心，一定要混出个模样，在苏州买套房。如果有可能的话，把父母也接过来住。&lt;/p&gt;
&lt;p&gt;等到工作了三年后，在苏州买房的想法变得越来越不切合实际，因为房价比工资高很多。&lt;/p&gt;
&lt;p&gt;有一个和我一起进公司的同事，人相处起来非常愉快，我们一起打过篮球，打过 DOTA，K 过歌，关键是身高、颜值、品味，都属于我们那群新人中的佼佼者。由于他是我们当中第一个买车的，我们就亲切地改叫他“车夫”，毕竟我们只负责蹭车，连油费也懒得出。&lt;/p&gt;
&lt;p&gt;在我离开苏州的两三个月前，车夫买了房，房价一万多。我们之间的工资差的不多，还完月供，剩下的钱也只能勉强维持生活，毕竟他还要把妹。&lt;/p&gt;
&lt;p&gt;车夫的家境不错，买房的钱，家里资助了一些。换做是我，绝壁买不起啊。现在我们联系的少了，但只要想起苏州，我就会想起他，因为做同事做三年半，感情是有的。&lt;/p&gt;
&lt;p&gt;2014 年春节前，我提交了辞职报告，但领导迟迟没有批，他们都劝我留下，要涨薪，要委以重任。但我心里明白，离开是迟早的事。&lt;/p&gt;
&lt;p&gt;一方面，我和之前关系非常好的领导闹掰了，在大领导沟通无果的情况下，我换到了其他部门，虽然在新的部门干得不错，但心里终究不是滋味。&lt;/p&gt;
&lt;p&gt;另一方面，女朋友已经回到了洛阳，异地恋再搞下去只会无疾而终。&lt;/p&gt;
&lt;p&gt;还有一方面，在苏州买不起房，失去了归属感。&lt;/p&gt;
&lt;p&gt;眼瞅着外地的同事纷纷请假回了家，我是归心似箭啊，再不批我就只能在苏州过年了。&lt;strong&gt;找领导继续谈，软磨硬泡了一周时间，领导看我这个人才实在是留不住了，就批了&lt;/strong&gt;。这么一折腾，我回到老家那天，已经是大年三十的晚上了。&lt;/p&gt;
&lt;p&gt;原计划初六就从老家去洛阳准备面试，无奈初五那天就大雪封路。窝在老家那几天，提心吊胆的，真怕错过了机会，毕竟洛阳的软件岗位本来就寥寥无几。&lt;/p&gt;
&lt;p&gt;我是 2 月 14 号入的职，实习工资 2500。干了一个半月，我就找领导谈话了，要求转正，并且缴纳公积金，虽然少，但有总比没有强。&lt;/p&gt;
&lt;p&gt;2500 一个月，实在是太特么少了，什么都不敢买。由于表现突出，三个月的实习期没满，我就转正了，工资涨到 3800，加上一个月的绩效奖，到手能拿到 4500 左右，偶尔能到 6000。&lt;/p&gt;
&lt;p&gt;我当时还没有买房的概念，觉得租房住挺好的。一开始是女朋友公司的宿舍，虽然旧了点，但两个人久别重逢，窝在一起住的日子甭提有多幸福了。&lt;/p&gt;
&lt;p&gt;女朋友每天早上起来烙饼，中午做面条，晚上熬点粥。三个月时间，我的体重硬生生从 100 出头飙升到了 135，原来棱角分明的脸庞仿佛一夜之间就圆润了起来。&lt;/p&gt;
&lt;p&gt;上衣都还好，裤子是越来越勒肚子，最后都被淘汰了。顺带吐槽一句：结了婚后，老婆做饭的技能包也丢了。&lt;/p&gt;
&lt;p&gt;半年后，我们租了一套大房子，1200，三室两厅两卫，真的是奢侈极了。我那时候，仍然没有买房的概念。&lt;/p&gt;
&lt;p&gt;但女朋友坐不住了，她家里开始催她结婚。要结婚，就必须得买房子啊。&lt;/p&gt;
&lt;p&gt;我这个人，花钱一向是大手大脚，挣多少就花多少。工作了四年多，没攒几个钱，和女朋友的加起来，也就十几万块。&lt;/p&gt;
&lt;p&gt;要知道，这时候，洛阳的房价已经飙升到 7000 多了。而我的工资，不说了，完全没有上涨的意思，毕竟是洛阳啊，一上来就巅峰。&lt;/p&gt;
&lt;p&gt;但不买已经不行了，不买的话，我俩搞不好迫于压力要散伙。&lt;strong&gt;于是每逢周末，就去转啊，不是去抢钱啊，去看房&lt;/strong&gt;。然后开始筹钱，东拼西凑的。我父母那时候铺地板砖攒了一些钱，加起来三十多万，终于算是凑够了首付。&lt;/p&gt;
&lt;p&gt;对于我们这样普通到不能再普通的家庭来说，买房是头等头的大事。&lt;/p&gt;
&lt;p&gt;于是第一套房也就有了。据中介说，我们现在住的房，已经飙升到 12000 一平了，真特么贵。但我们又不卖，贵不贵与我们无关啊，贷款接着还。&lt;/p&gt;
&lt;p&gt;买房、结婚、生娃、买车，两三年折腾下来，真的是非常不容易，我都不知道怎么过来的。隔三差五，就有读者跑过来问我，“二哥，洛阳现在 IT 环境怎么样了？想回去啊。”&lt;/p&gt;
&lt;p&gt;真不怎么样，现在是 2020 年，水平和 2014 年的时候差不多。想回来，真的是比我当初还要难，因为房价涨得太猛了，而工资水平，基本上还维持在当初那个样子。&lt;/p&gt;
&lt;p&gt;我属于比较幸运的那一种。&lt;strong&gt;老婆很努力，我也很努力，所以日子才渐渐好转，就有了买第二套房的打算&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;之所以买房，并不是一时冲动。像我这般年纪的，到这个岁数，混得还算过得去的，基本上都开始准备二套房了。毕竟存钱利息就那么点，而炒股、理财，对于我们普通人来说，风险有点大。&lt;/p&gt;
&lt;p&gt;而买房，可以算是最稳健的投资了。&lt;/p&gt;
&lt;p&gt;并不是说，非要通过买房卖房赚钱，而是对手里面的现金没有更好的处理方式。&lt;/p&gt;
&lt;p&gt;今年的大环境不太好，房价丝毫没有下降的意思，仍然在继续飙升。中介的意思是，洛阳地铁修通后，房价肯定会再涨一波，现在买就是最好的机会。&lt;/p&gt;
&lt;p&gt;我们就动心了。&lt;/p&gt;
&lt;p&gt;买房并不会让我们变得更富裕，因为如果你不变卖的话，房子还是那个房子，而房贷还是要还的。打工嘛，给谁打不是打，给银行打也是打，对吧？&lt;/p&gt;
&lt;p&gt;你要说买房有没有担忧，肯定是有的。经济危机了怎么办？赚不到钱了怎么办？公司倒闭了怎么办？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人生说长不长，说短不短，充满了不确定性。而我们要做的，就是尽力而为。得不到的不强求，得到的一定要珍惜。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了，亲爱的读者朋友，以上就是本文的全部内容了，能看到这里的都是最优秀的程序员，我必须要伸出可爱的大拇指为你点个赞。&lt;/p&gt;
&lt;blockquote readability=&quot;5.6791443850267&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。本文已收录 GitHub，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;&lt;strong&gt;传送门~&lt;/strong&gt;&lt;/a&gt; ，里面更有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，嘻嘻&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Apr 2020 23:19:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>我在苏州刚参加工作那会，对未来充满了希望，信誓旦旦地以为，凭借自己的努力，三五年后就能在苏州买一套房子。 凭良心讲，苏州就是我的第二个故乡，因为它治好了我的青春痘——这玩意从高一下半学期就开始困扰我。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12776661.html</dc:identifier>
</item>
<item>
<title>C# 基础知识系列- 13 常见类库介绍（二）日期时间类 - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/12776644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/12776644.html</guid>
<description>&lt;p&gt;上一篇内容介绍了Console类和Math类，这篇内容着重介绍一下C#中时间日期的处理方式。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上一篇勘误： 上一篇中关于静态类没有构造函数，这一表述有误。正确的说法是C#中静态类不包含常规构造函数，但可以添加一个静态构造函数。&lt;br/&gt;静态构造函数与普通普通构造函数的区别是，静态构造函数没有访问修饰符，即访问修饰符是默认的，且静态构造函数只能是无参的，并添加 static 修饰符；静态构造函数不能手动调用，会在类加载的时候由系统自己加载。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;DateTime表示时间点，TimeSpan表示 时间段。在C#中，这两个都是结构体，结构体与类都能继承并实现接口，但是与类不同的是结构体在内存中存放在栈里。这部分在微软官方文档中关于CLR有过介绍。后续也会针对CLR写一个系列。这里就不做过多的介绍了。&lt;/p&gt;
&lt;p&gt;DateTime延伸开来也有很多内容要讲，这里只做一个大体的介绍：&lt;/p&gt;
&lt;h2 id=&quot;1-创建一个datetime&quot;&gt;1. 创建一个DateTime&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;DateTime time = new DateTime(2018,1,20);// 2018年1月20日 0时0分0秒
DateTime time = new DateTime(2019,11,30, 12, 01, 59);// 2019年11月30日，12:01:59
DateTime time = DateTime.Now;// 表示代码运行到这里的系统时间，一般意义上的当前时间
DateTime time = new DateTime(long ticks);// 以时间刻度计算日期，以公历 0001 年 1 月 1 日 00:00:00.000 以来所经历的以 100 纳秒为间隔的间隔数来表示
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些是我们常用的创建日期的方法，还有一些通过日历对象结合日历来创建日期时间，不过这块在不涉及到程序国际化之前不需要做过多的深入。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;DateTime.Now&lt;/code&gt;在每次运行结果都不一样，这个属性返回的是系统运行时&lt;strong&gt;当前时间&lt;/strong&gt;，而不是程序编写时的时间。与之对应的还有一个&lt;code&gt;DaTime.Today&lt;/code&gt;，这个属性返回结果是&lt;strong&gt;当天&lt;/strong&gt;，也就是Now去掉时分秒的时间。&lt;/p&gt;
&lt;h2 id=&quot;2-日期变更&quot;&gt;2. 日期变更&lt;/h2&gt;
&lt;p&gt;DateTime提供了很多可以变更日期的方法，这些方法可以获取一个计算之后的时间值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public DateTime AddDays (double value);// 计算天数，正数代表 天数增加，负数代表天数减少
public DateTime AddHours (double value);// 返回一个新的 DateTime，它将指定的小时数加到此实例的值上。
public DateTime AddMilliseconds (double value);//返回一个新的 DateTime，它将指定的毫秒数加到此实例的值上。
public DateTime AddMonths (int months);//返回一个新的 DateTime，它将指定的月数加到此实例的值上
public DateTime AddMonths (int months);// 返回一个新的 DateTime，它将指定的月数加到此实例的值上
public DateTime AddSeconds (double value);/// 返回一个新的 DateTime，它将指定的秒数加到此实例的值上。
public DateTime AddTicks (long value);// 返回一个新的 DateTime，它将指定的刻度数加到此实例的值上，也就是构造函数里的ticks
public DateTime AddYears (int value);//返回一个新的 DateTime，它将指定的年份数加到此实例的值上。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是DateTime类对日期计算的支持，其中参数如果是正的表示时间后移，如果是负的则表示时间向前移。&lt;/p&gt;
&lt;p&gt;需要注意的一点就是，日期的变更不会在原有的DateTime元素上变更，会返回一个计算之后的日期类型。&lt;/p&gt;
&lt;h2 id=&quot;3-日期算术运算&quot;&gt;&lt;strong&gt;3. 日期算术运算&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;说了这么多DateTime，没有介绍TimeSpan，那么这里就会介绍一下TimeSpan是什么了。TimeSpan表示一个时间间隔，也就是两个DateTime之间的差值。说到这里，大家也应该明白日期的算术运算应该是指什么了。以下来看一组示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        DateTime lastYear = new DateTime(2019, 03, 08, 20,49, 36);
        DateTime now = DateTime.Now;
        TimeSpan span = now - lastYear;
        DateTime newTime = lastYear + span;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是C#中关于日期运算的基本内容。那我们来看看 TimeSpan里封装了哪些内容吧。&lt;/p&gt;
&lt;p&gt;TimeSpan的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public int Days { get; }//获取当前 TimeSpan 结构所表示的时间间隔的天数部分。
public int Hours { get; }// 获取当前 TimeSpan 结构所表示的时间间隔的小时数部分。
public int Milliseconds { get; }//获取当前 TimeSpan 结构所表示的时间间隔的毫秒数部分。
public int Minutes { get; }//获取当前 TimeSpan 结构所表示的时间间隔的分钟数部分。
public int Seconds { get; }//获取当前 TimeSpan 结构所表示的时间间隔的秒数部分。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上属性表示一个TimeSpan的代表的时间间隔中的天数、小时、分钟等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public double TotalDays { get; }//获取以整天数和天的小数部分表示的当前 TimeSpan 结构的值。
public double TotalHours { get; }//获取以整小时数和小时的小数部分表示的当前 TimeSpan 结构的值。
public double TotalMinutes { get; }//获取以整分钟数和分钟的小数部分表示的当前 TimeSpan 结构的值。
public double TotalSeconds { get; }//获取以整秒数和秒的小数部分表示的当前 TimeSpan 结构的值。
public double TotalMilliseconds { get; }//获取以整毫秒数和毫秒的小数部分表示的当前 TimeSpan 结构的值。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述几组属性表示以XXX为单位，返回的TimeSpan的值，与之相对应的TimeSpan提供了一组FormXXX的方法，可以将double类型的值还原成TimeSpan。&lt;/p&gt;
&lt;p&gt;因为TimeSpan表示时间间隔，所以TimeSpan也允许两个TimeSpan进行加法运算，并提供了一个&lt;code&gt;Add(TimeSpan ts)&lt;/code&gt;的方法。&lt;/p&gt;
&lt;p&gt;这些是TimeSpan最常用的一些属性和方法。不过在使用TimeSpan中需要注意的地方是，TimeSpan计算返回的值可正可负，正值表示时间间隔的头在前尾在后，负值表示头在后尾在前；TimeSpan中没有提供TotalMonths这个方法，这是因为每个月具体有多少天不是固定值，如果想计算两个日期直接相差几个月，则需要自定义对应的计算方法了。&lt;/p&gt;
&lt;h2 id=&quot;4-datetime与字符串之间的恩怨情仇&quot;&gt;4. DateTime与字符串之间的恩怨情仇&lt;/h2&gt;
&lt;p&gt;在程序中，用户或者三方输入的日期大多都是字符串格式的，而且系统获取到的时间也大多会转成字符串给其他人展示，所以这里就会涉及到DateTime与字符串之间的相互转换。&lt;/p&gt;
&lt;p&gt;我们先试试日期的各种ToString会产生什么样的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        DateTime now = DateTime.Now;
        Console.WriteLine(&quot;ToString :{0}&quot;, now.ToString());
        Console.WriteLine(&quot;ToLongDateString :{0}&quot;, now.ToLongDateString());
        Console.WriteLine(&quot;ToLongTimeString :{0}&quot;, now.ToLongTimeString());
        Console.WriteLine(&quot;ToShortDateString :{0}&quot;,now.ToShortDateString());
        Console.WriteLine(&quot;ToShortTimeString :{0}&quot;,now.ToShortTimeString());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200426061031730-1567504832.png&quot; alt=&quot;image-20200425111100330&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是DateTime的默认输出结果，当然会根据系统的语言和地区等设置变化而产生不同的变化。为了避免这种变化，C#提供了一种日期类型的格式化模板，这里介绍几个常用的格式代表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;格式符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;yy&lt;/td&gt;
&lt;td&gt;年份。00~99，如果年份大于99，则只保留后两位。如2020年则显示20,2019年则显示19&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;yyyy&lt;/td&gt;
&lt;td&gt;年份，显示四位。0000~9999&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;月份，显示1~12&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MM&lt;/td&gt;
&lt;td&gt;月份，显示01~12&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;天，1~31（具体看月份允许的最大天数）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dd&lt;/td&gt;
&lt;td&gt;与d一致，显示为01~31&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;小时，12小时制显示1~12&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hh&lt;/td&gt;
&lt;td&gt;与h一致，显示为01~12&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;小时，24小时制，显示0~23&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;HH&lt;/td&gt;
&lt;td&gt;小时，24小时制，显示00~23&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;分钟，显示0~59&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mm&lt;/td&gt;
&lt;td&gt;分钟，显示00~59&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;秒，显示0~59&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ss&lt;/td&gt;
&lt;td&gt;秒，显示00~59&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;表示日期和时间值的十分之几秒，显示0~9&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ff&lt;/td&gt;
&lt;td&gt;表示百分之几秒，显示00～99&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;最后的f，f的次数越多精度越细，但需要考虑系统的时钟精度。&lt;/p&gt;
&lt;p&gt;在实际开发中，最常用的格式是：&lt;code&gt;yyyy-MM-dd HH:mm:ss&lt;/code&gt;，显示效果就是：2020-04-25 12:00:00。其中连接符可以根据开发需求更换。&lt;/p&gt;
&lt;p&gt;上述是时间转字符串，反过来也有字符串转时间。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;DateTime.Parse&lt;/code&gt;或者&lt;code&gt;Convert.ToDateTime&lt;/code&gt;就可以将字符串转换为时间类型。C#并不需要在字符串转日期的时候指定字符串的显示格式，这是因为一个约定优于配置的设计理念。C#通过分析字符串，然后将字符串转换成对应的时间类型。当然，在正确解析到时间的时候，C#会抛出异常。为此，C#提供了&lt;code&gt;DateTime.TryParse&lt;/code&gt;方法，该方法不会抛出异常，会返回一个是否正确转换的bool值。&lt;/p&gt;
&lt;p&gt;它的声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static bool TryParse (string s, out DateTime result);// 使用了result作为实际转换结果
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然C# 不用提供转换格式就可以读取，但是如果时间字符串的格式比较少见呢，或者说就想指定一个格式字符串，怎么办？别急，C#还提供了一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static DateTime ParseExact (string s, string format, IFormatProvider provider);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，这个方法需要指定一个区域性的格式信息：provider。这个信息可以通过&lt;code&gt;CultureInfo.CurrentCulture&lt;/code&gt;来获取，这个属性表示系统的当前区域信息。&lt;/p&gt;
&lt;p&gt;以上是DateTime的基本内容，有兴趣的小伙伴可以查阅一下微软的官方文档继续深入研究一下。&lt;/p&gt;
&lt;blockquote readability=&quot;3.3333333333333&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://blogs.attachie.club&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200426061032018-1179323252.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Apr 2020 22:11:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0. 前言 上一篇内容介绍了Console类和Math类，这篇内容着重介绍一下C 中时间日期的处理方式。 上一篇勘误： 上一篇中关于静态类没有构造函数，这一表述有误。正确的说法是C 中静态类不包含常规</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/12776644.html</dc:identifier>
</item>
<item>
<title>负载均衡服务之HAProxy基础配置（三）  - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12776261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12776261.html</guid>
<description>&lt;p&gt;　　前文我们聊到了haproxy的代理配置段中比较常用的配置指令的用法以及说明，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12770930.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12770930.html&lt;/a&gt;；今天我们来说说haproxy的状态页的配置，以及基于cookie实现的会话保持配置；&lt;/p&gt;
&lt;p&gt;　　haproxy和nginx一样，都有一个状态页，这个页面对于运维人员来说是一个比较重要的页面，里面包含了haproxy代理的后端服务器的各种指标，通常我们要了解后端主机是否健康，当前负载情况，我们可以通过状态页去了解；haproxy的状态页配置起来很简单，用stats enable指令去开启即可；&lt;/p&gt;
&lt;p&gt;　　stats enable：开启状态页；该指令可以配置在frontend或者listen或者backend，如果定义在backend中，那么我们必须要用前端去调用该banckend才能够看到状态页，所以通常我们都定义在listen中或者frontend中；具体示例如下&lt;/p&gt;
&lt;p&gt;　　示例：定义在backend中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425215525503-539129226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：定义在backend中必须要用frontend去调用该backend；&lt;/p&gt;
&lt;p&gt;　　示例：定义在frontend中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425215834365-80753364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　示例：定义在listen中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425220014014-2055288813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上三种方式都不影响访问状态页面，推荐配置在fonrtend或listen中；&lt;/p&gt;
&lt;p&gt;　　配置好stats enable参数后，重启haproxy，我们就可以通过浏览器访问haproxy所在主机的对应端口，我这里监听在81端口上，所以访问http://192.168.0.22:81/haporxy?stats就可以访问到状态页；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425220513106-24205357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：之所以访问/haproxy?stats这个uri才能够访问到状态页，是因为我们没有在配置文件中明确指定把状态页绑定到那个uri上，默认情况不指定就是这个/haproxy?stats，当然我们如果要指定需要用stats uri &amp;lt;prefix&amp;gt;来指定对应的rui即可，如下&lt;/p&gt;
&lt;p&gt;　　 stats uri &amp;lt;prefix&amp;gt;：自定义stats page uri，默认值：/haproxy?stats&lt;/p&gt;
&lt;p&gt;　　示例：更改状态也都uri&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425220852664-1544521016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示访问状态页，的uri为/admin??status&lt;/p&gt;
&lt;p&gt;　　测试：用浏览器访问81端口上的/admin??status这个uri看看是否能够访问到状态页？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425221347086-1556955339.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们更改了uri后，默认的uri就不可以访问了，必须键入我们指定uri才可以被访问到，这在一定程度上降低了任何人访问状态页的风险；&lt;/p&gt;
&lt;p&gt;　　stats auth &amp;lt;user&amp;gt;:&amp;lt;passwd&amp;gt;：配置状态页面认证的账号和密码，可使用多次；默认：no authentication，表示不验证&lt;/p&gt;
&lt;p&gt;　　示例：配置状态页只允许admin用户访问并且密码为admin123.com&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425221749400-179805413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示开启状态页的认证功能，并且添加admin为用户名，admin123.com为密码&lt;/p&gt;
&lt;p&gt;　　测试：现在我们访问状态页，看看是否需要验证？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425222233878-616722544.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们现在访问状态页，需要我们提供用户名和密码了，这相对于前面的配置，对于状态页的获取更加安全了；&lt;/p&gt;
&lt;p&gt;　　stats realm &amp;lt;realm&amp;gt;：设置认证时弹出输入用户名密码的提示信息；&lt;/p&gt;
&lt;p&gt;　　tats refresh &amp;lt;delay&amp;gt;：设置自动刷新时长；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425222650080-1836899604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示设定弹出输入用户名和密码的提示，设置自动刷新时长为每4秒自动刷新一次&lt;/p&gt;
&lt;p&gt;　　测试：重启haproxy，看看对应配置是否生效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425223114503-1608920784.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们配置的输入用户名和密码提示的字符串和自动刷新页都实现了，这里说一下，设定提示字符串需要把空白字符通过“\”转义，否则不会生效，加引号好像都不可以；&lt;/p&gt;
&lt;p&gt;　　stats admin { if | unless } &amp;lt;cond&amp;gt;：启用stats page中的管理功能&lt;/p&gt;
&lt;p&gt;　　示例：配置可以在状态页管理后端主机的权限；通常会通过后面的acl去控制，我这里为了演示方便，就用TRUE这个内置的ACL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425224113115-143738854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示开启状态页管理功能，在条件为真的情况下，if TRUE表示一直为真，这意味着只要登录状态页，就有管理后端主机的权限；&lt;/p&gt;
&lt;p&gt;　　测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425224320109-421613376.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们可以把后端主机的状态任意调整；&lt;/p&gt;
&lt;p&gt;　　stats hide-version：隐藏版本&lt;/p&gt;
&lt;p&gt;　　示例：隐藏haproxy状态也的版本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425224847451-752402041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　测试：登录状态页看看是否还有版本信息？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425225115893-1055660295.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此状态页的配置相关指令说完了，接下来我们来说说状态页里边的内容；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425230227201-1014088160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：pid = 11712 (process #4, nbproc = 4) #pid为当前pid号，process为当前进程号，nbproc和nbthread为一共多少进程和每个进程多少个线程（多线程需要在1.7以上的版本才支持）；uptime = 0d 0h08m17s #启动了多长时间；system limits: memmax = unlimited; ulimit-n = 8035表示系统资源限制：内存/最大打开文件数/；maxsock = 8035; maxconn = 4000; maxpipes = 0表示最大socket连接数/单进程最大连接数/最大管道数maxpipes；current conns = 1; current pipes = 0/0; conn rate = 1/sec；表示当前连接数/当前管道数/当前连接速率；Running tasks: 1/8; idle = 100 %表示运行的任务/当前空闲率；&lt;/p&gt;
&lt;p&gt;　　active UP：绿色表示在线服务器； backup UP：天蓝色表示标记为backup的服务器；active UP, going down：淡黄色表示监测未通过正在进入down过程；backup UP, going down：深紫色表示备份服务器正在进入down过程；active DOWN, going up：黄色表示down的服务器正在进入up过程；backup DOWN, going up：浅紫色表示备份服务器正在进入up过程；active or backup DOWN：粉红色表示在线的服务器或者是backup的服务器已经转换成了down状态； not checked：灰色表示标记为不监测的服务器（没有对它做健康状态监测）；active or backup DOWN for maintenance (MAINT) ：棕色表示active或者backup服务器认为下线的；active or backup SOFT STOPPED for maintenance ：深蓝色表示active或者backup被认为软下线(人为将weight改成0)；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200425233705458-1630057168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：session rate(每秒的连接会话信息)中的指标有cur,max,limit;其中cur表示每秒的当前会话数量；max表示每秒的最大会话数量；limit表示每秒新的会话限制量；sessions(会话信息)，cur:表示当前会话量；max:表示最大会话量；limit: 表示限制会话量；Total:表示总共会话量；LBTot:表示选中一台服务器所用的总时间；Last：表示和服务器的持续连接时间；Bytes(流量统计)：In表示网络的字节输入总量；Out表示网络的字节输出总量；Denied(拒绝统计信息)：Req表示拒绝请求量；Resp表示拒绝恢复量；Errors(错误统计信息)：Req表示错误请求量；conn表示错误连接量；Resp表示错误响应量；Warnings(警告统计信息)：Retr表示重新尝试次数；Redis表示再次发送次数；Server(real server信息)：Status表示后端server的状态，包含UP和DOWN；LastChk表示持续监测后端服务器的时间，其中L4OK表示基于4层tcp检查OK，L7OK表示基于7层应用层检查OK；Wght表示权重；Act表示活动链接数量；Bck表示备份的服务器数量；Chk表示心跳监测时间；Dwn表示后端服务器连接后都是DOWN的数量；Dwntme表示总的downtime时间；Thrtle表示server的状态；&lt;/p&gt;
&lt;p&gt;　　了解了上面的状态页信息说明后，接下来我们来聊一聊haproxy基于cookie做会话保持；&lt;/p&gt;
&lt;p&gt;　　首先我们要清楚什么叫cookie?它的主要作用是干什么的？众所周知http是无状态的，所谓无状态就是前一秒客户端访问服务端，后一秒同一客户端访问服务端，服务端是无法判断是不是同一客户端；就相当于服务端没有任何能力记住客户端；这样一来就存在一个问题；如果是一需要验证的网站，如果服务端不能辨别客户端身份，这意味着它不能够辨认到底是哪个客户端登录了，这样一来用户每刷新一次网页，服务端就会要求客户端重新登录；这很显然不是正常的逻辑；为了解决这样的问题，服务端每当客户端登录的时候，就会检查请求报文中是否携带cookie信息；如果没有携带cookie服务端在响应客户端的时候就会在响应报文中添加一个set-cookie的首部，意思是告诉客户端，这是你的cookie；客户端拿到服务端的响应的同时，它会自动的把服务端发来的cookie保存到一个特定的地方，下次客户端再次访问服务端的时候，就会把上次服务器发送过来的cookie信息带上去访问服务器；这样一来服务端收到客户端的请求，一看请求报文中的cookie信息，服务端就知道这个请求是那个用户发送过来的；这样一来服务端就通过cookie来辨认客户端了；这也是cookie的主要作用；通常情况下保存在客户端的叫cookie;在服务端一侧类似cookie的功能的东西我们叫session；通常两者通过某些信息来对应的；比如在客户端cookie信息里记录了服务端上的session的号码；当客户端再次访问服务端时，就会把cookie中的信息发送给服务端；服务端收到客户端发送过来的cookie就会去找对应的session；从而实现了，服务端知道对应客户端上次的操作；cookie是有时限性的；通常在有效的时间内去访问服务端，服务端都能够准确的辨认客户端；过期以后，服务端会重新给客户端发送cookie信息；&lt;/p&gt;
&lt;p&gt;　　从上面的描述，我们不难理解，cookie就是用来让服务端辨识客户端的一种机制；而对于haproxy来讲，基于cookie来做会话保持的原理就是通过对后端服务器响应报文中的cookie信息中添加(或覆盖的方式)一个键值对，在客户端下次访问时，检查对应cookie首部的信息，从而让haproxy能够判断把该请求调度在那个后端服务器上；通常我们会在server上设置一个cookie的值，在listen或backend中设置一个cookie的键，明确说明以怎样的方式设置cookie的键；通过listen或backend中设置的cookie的键结合server后面的cookie的值组成的cookie信息，从而实现不同的cookie信息调度到不同的server上去；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200426003552227-1959659143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上cookie COOKIE insert nocache表示在后端服务器响应报文首部中添加一个cookie的名称为COOKIE，而对应cookie的值就来源于后面server中的cookie的值；nocache表示该cookie不被共有缓存系统缓存；&lt;/p&gt;
&lt;p&gt;　　测试：重启haproxy，用浏览器访问看看响应首部有什么变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200426004313741-216631215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当客户端第一次访问时，响应首部set-Cookie中就会设置一个COOKIE=web1的值；这个值就是我们刚才在haproxy配置的，从这个值上看，我们本次访问被调度到web1上了，之后我们再次访问时，就不会被调度到其他服务器上，在cookie过期之前始终都会被调度到web1上响应；这是因为下次我们访问时，会自动把这个cookie信息携带上；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200426004914434-282132710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：正是因为我们携带的cookie信息是COOKIE=web1和haproxy上的web1上的cookie的值相同，所以我们只要携带COOKIE=web1就会被调度到web1上；&lt;/p&gt;
&lt;p&gt;　　用curl 模拟cookie信息访问不同后端服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200426010049992-1153561595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：通过不同的cookie信息，就可以访问到不同后端server了；这样就实现了基于cookie信息来把相同cookie的请求发送给同一后端server的目的；实现了会话保持；&lt;/p&gt;
</description>
<pubDate>Sat, 25 Apr 2020 17:21:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊到了haproxy的代理配置段中比较常用的配置指令的用法以及说明，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/12770930.html；今天我们来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12776261.html</dc:identifier>
</item>
<item>
<title>详细分析Redis的持久化操作——RDB与AOF - 特务依昂</title>
<link>http://www.cnblogs.com/tuyang1129/p/12776526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tuyang1129/p/12776526.html</guid>
<description>&lt;p&gt;  由于疫情的原因，学校还没有开学，这也就让我有了很多的时间。趁着时间比较多，我终于可以开始学习那些之前一直想学的技术了。最近这几天开始学习&lt;code&gt;Redis&lt;/code&gt;，买了本&lt;code&gt;《Redis实战》&lt;/code&gt;，看到了第四章，前三章都是讲一些&lt;code&gt;Redis&lt;/code&gt;的基本使用以及命令，第四章才开始涉及到原理相关的内容。&lt;code&gt;《Redis实战》&lt;/code&gt;的第四章涉及到了&lt;code&gt;Redis&lt;/code&gt;的持久化、主从复制以及事务等内容，我个人认为这些应该属于&lt;code&gt;Redis&lt;/code&gt;中比较重要的部分，也是面试的常考内容。这篇博客就来记录一下&lt;code&gt;Redis&lt;/code&gt;的持久化机制。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;21-为什么需要持久化&quot;&gt;2.1 为什么需要持久化&lt;/h2&gt;
&lt;p&gt;  学习过&lt;code&gt;Redis&lt;/code&gt;的应该都知道，&lt;code&gt;Redis&lt;/code&gt;与&lt;code&gt;MySQL&lt;/code&gt;等关系型数据库不同，它的数据不是存储在硬盘中，而是存放在内存，所以&lt;code&gt;Redis&lt;/code&gt;的速度非常快。而这也就会造成一个问题：&lt;strong&gt;电脑如果宕机，或者由于某些原因需要重启，此时内存中的数据就会丢失&lt;/strong&gt;。&lt;code&gt;Redis&lt;/code&gt;既然把数据存放在内存，自然也就无法避免这个问题。所以，为了在电脑重启后，能够恢复原来的数据，&lt;code&gt;Redis&lt;/code&gt;就需要提供持久化的机制，将&lt;code&gt;Redis&lt;/code&gt;数据库存储在内存中的数据，在磁盘中进行备份，也就是持久化。而当&lt;code&gt;Redis&lt;/code&gt;重启后，去磁盘中将持久化的数据重新读取到内存，便能避免数据的丢失。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;22-redis的持久化方式&quot;&gt;2.2 Redis的持久化方式&lt;/h2&gt;
&lt;p&gt;  &lt;code&gt;Redis&lt;/code&gt;提供了两种持久化的方式，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快照持久化；&lt;/li&gt;
&lt;li&gt;AOF持久化；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  下面我就来详细地介绍这两种持久化的方式。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;23-快照持久化（rdb）&quot;&gt;2.3 快照持久化（RDB）&lt;/h2&gt;
&lt;p&gt;  快照持久化也就做&lt;code&gt;RDB&lt;/code&gt;持久化。快照持久化的实现方式简单来说就是：&lt;strong&gt;Redis将当前内存中存储的数据写入到一个文件中，将这个文件作为Redis当前的一个快照，保存在磁盘中。当Redis重启时，将这个快照文件中存储的内容加载进内存，即可恢复Redis之前的状态&lt;/strong&gt;。默认情况下，&lt;code&gt;Redis&lt;/code&gt;将快照保存在一个叫做&lt;code&gt;dump.rdb&lt;/code&gt;的文件中，我们也可以在配置文件中，通过&lt;code&gt;dbfilename&lt;/code&gt;选项来设置快照文件的名称；默认情况下快照文件就保存在&lt;code&gt;Redis&lt;/code&gt;的安装目录下，我们可以在配置文件中，通过&lt;code&gt;dir&lt;/code&gt;选项来配置快照文件的存储路径（其实也是AOF的路径）。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;24-执行快照持久化的方式&quot;&gt;2.4 执行快照持久化的方式&lt;/h2&gt;
&lt;p&gt;  执行快照持久化有两种方式：&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;2.4.1 使用配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  第一种方式就是在&lt;code&gt;Redis&lt;/code&gt;的配置文件中（&lt;code&gt;windows&lt;/code&gt;下这个文件叫&lt;code&gt;redis.windows-service.conf&lt;/code&gt;）加上&lt;code&gt;save&lt;/code&gt;配置项，比如像下面这样：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;save 60 100&lt;/strong&gt;：在配置文件中加上这一条的意思是，Redis会每60秒检查一次，若在这60秒中，Redis数据库执行了100次以上的写操作，那Redis就会生成一个快照文件，替换原来的快照文件；若不满足这个条件，则不生成快照，继续等待60秒；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  我们可以根据自己的需求，调整每次等待的时间，以及对写操作次数的要求。而且，我们可以在配置文件中，添加多个&lt;code&gt;save&lt;/code&gt;选项，比如一个&lt;code&gt;save 60 100&lt;/code&gt;，一个&lt;code&gt;save 5 10&lt;/code&gt;，则&lt;code&gt;Redis&lt;/code&gt;每&lt;code&gt;5&lt;/code&gt;秒以及每&lt;code&gt;100&lt;/code&gt;秒都会判断一次。需要注意的是，我们不应该让生成快照太过频繁，因为这是一个比较消耗资源的工作，会降低&lt;code&gt;Redis&lt;/code&gt;的响应速度。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;2.4.2 使用指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  执行快照持久化的第二个方法就是使用&lt;code&gt;Redis&lt;/code&gt;指令，&lt;code&gt;Redis&lt;/code&gt;提供了两个指令来请求服务器进行快照持久化，这两个指令分别是&lt;strong&gt;SAVE&lt;/strong&gt;和&lt;strong&gt;BGSAVE&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;（a）BGSAVE指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;BGSAVE&lt;/code&gt;的执行流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;调用系统的&lt;code&gt;fork()&lt;/code&gt;，创建出一个子进程；&lt;/li&gt;
&lt;li&gt;子进程将当前&lt;code&gt;Redis&lt;/code&gt;中的数据，写入到一个临时文件中；同时父进程不受影响，继续执行客户端的请求；&lt;/li&gt;
&lt;li&gt;子进程将所有的数据写入到了临时文件后，于是使用这个文件替换原来的快照文件（默认是&lt;code&gt;dump.rdb&lt;/code&gt;）；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  值得一提的是，通过配置文件执行快照持久化的方式，实际上就是&lt;code&gt;Redis&lt;/code&gt;在判断满足条件时，调用&lt;code&gt;BGSAVE&lt;/code&gt;指令来实现的。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;（b）SAVE指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;SAVE&lt;/code&gt;指令生成快照的方式与&lt;code&gt;BGSAVE&lt;/code&gt;不同，&lt;code&gt;Redis&lt;/code&gt;执行&lt;code&gt;SAVE&lt;/code&gt;指令时，不会创建一个子进程，异步的生成快照文件，而是直接使用&lt;code&gt;Redis&lt;/code&gt;当前进程。执行&lt;code&gt;SAVE&lt;/code&gt;指令在创建快照的过程中，&lt;code&gt;Redis&lt;/code&gt;服务器会阻塞所有的&lt;code&gt;Redis&lt;/code&gt;客户端，直到快照生成完毕，并更新到磁盘之后，才会继续执行客户端发来的增删改查的指令。&lt;/p&gt;
&lt;p&gt;  当然，这个指令一般很少使用，因为会阻塞客户端，造成停顿。但是实际上，这个指令的执行效率一般比&lt;code&gt;BGSAVE&lt;/code&gt;更高，因为不需要创建子进程，而且在这个过程中，其他操作被阻塞，&lt;code&gt;Redis&lt;/code&gt;服务器一心一意地生成快照。在&lt;code&gt;《Redis实战》&lt;/code&gt;中，作者提到了使用&lt;code&gt;SAVE&lt;/code&gt;指令的一个案例：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  当前服务器的Redis数据库中保存了大量数据，使用BGSAVE指令生成快照会非常的耗时 ，而且由于所剩内存不多，甚至无法创建子进程，于是作者编写了一个shell脚本，这个脚本的内容就是让服务器每天凌晨3点，执行SAVE命令，生成快照，这样就不需要创建子进程，而且由于是凌晨三点，用户较少，SAVE的阻塞机制也不会有太大的影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;h2 id=&quot;25-快照持久化的优缺点&quot;&gt;2.5 快照持久化的优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;快照的&lt;code&gt;rdb&lt;/code&gt;文件是一个经过压缩的紧凑文件，它保存了&lt;code&gt;Redis&lt;/code&gt;在某个时间点上的数据集，这个文件非常适合用来备份。我们可以存储&lt;code&gt;Redis&lt;/code&gt;服务器在不同时间点上的&lt;code&gt;rbd&lt;/code&gt;文件，比如说一小时存储一次，一个月存储一次，这样就可以在遇到问题或有特殊需求时，将&lt;code&gt;Redis&lt;/code&gt;恢复到某一个时间点；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;RDB非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的服务器上；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;RDB 可以最大化 Redis 的性能：父进程在保存 &lt;code&gt;RDB&lt;/code&gt; 文件时唯一要做的就是 &lt;code&gt;fork&lt;/code&gt; 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘&lt;code&gt;I/O&lt;/code&gt;操作，所以不会影响父进程处理客户端的请求；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;RDB&lt;/code&gt; 在恢复大数据集时的速度比 &lt;code&gt;AOF&lt;/code&gt; 的恢复速度要快。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;（2）缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当我们的服务器发生异常，导致停机时，那我们将会丢失最后一次创建快照后，所作的所有写操作，因为这些操作发生在内存中，还没来得及同步到磁盘。比如我们在配置文件中配置每&lt;code&gt;5&lt;/code&gt;分钟生成一次快照，那当系统发生故障导致宕机时，我们将会丢失好几分钟内的操作；&lt;/li&gt;
&lt;li&gt;每次执行&lt;code&gt;BGSAVE&lt;/code&gt;创建快照，都需要先创建出一个子进程，再由子进程执行后续操作，当内存中数据较大时，创建一个子进程将会非常耗时，造成服务器等待数毫秒，甚至达到一秒，影响用户体验。而且从这一点也可以说明，我们不能通过提高生成快照的频率，来解决第一个缺点；&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;&lt;h2 id=&quot;26-aof持久化&quot;&gt;2.6 AOF持久化&lt;/h2&gt;
&lt;p&gt;  &lt;code&gt;AOF&lt;/code&gt;全称为只追加文件（append-only file），它的实现方式简单来说就是：&lt;strong&gt;AOF持久化机制，会将Redis执行的所有写指令，追加到到AOF的末尾，当服务器发生宕机，或者由于某些原因需要重启时，在重启后，读取AOF文件，重新执行其中记录的写操作，以此达到恢复数据的目的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;AOF&lt;/code&gt;持久化机制默认是关闭的，我们可以在配置文件中，配置&lt;strong&gt;appendonly yes&lt;/strong&gt;来开启。同时我们也可以通过配置&lt;strong&gt;appendfsync&lt;/strong&gt;，控制写操作追加到&lt;code&gt;AOF&lt;/code&gt;中的频率，它有如下三种选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;always&lt;/strong&gt;：&lt;code&gt;Redis&lt;/code&gt;每次执行写指令，都会立即将这个写指令同步到&lt;code&gt;AOF&lt;/code&gt;中；使用这个选项时，&lt;code&gt;Redis&lt;/code&gt;发生异常，则最多只会丢失一次写操作（也就是在同步的过程中宕机，没同步完成），但是这也会导致&lt;code&gt;Redis&lt;/code&gt;的响应速度变慢，因为此选项会造成频繁的&lt;code&gt;IO&lt;/code&gt;操作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;everysec（默认）&lt;/strong&gt;：每秒同步一次，使用此选项，速度足够快，而且发生宕机时也只会丢失&lt;code&gt;1s&lt;/code&gt;内的写操作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no&lt;/strong&gt;：让操作系统来决定什么时候进行同步，这个选项速度更快，但是不安全，宕机时丢失数据的多少是不确定的；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  推荐（也是默认），使用第二个选项&lt;code&gt;everysec&lt;/code&gt;，每秒进行一次同步，因为这个选项兼顾了速度与安全性，而第一个选项太慢，第三个选项无法保证安全性。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;27-aof的重写机制&quot;&gt;2.7 AOF的重写机制&lt;/h2&gt;
&lt;p&gt;  &lt;code&gt;AOF&lt;/code&gt;持久化的执行机制就是，不断地将写指令追加到&lt;code&gt;AOF&lt;/code&gt;的末尾，这样就会导致&lt;code&gt;AOF&lt;/code&gt;越来越大。为了解决&lt;code&gt;AOF&lt;/code&gt;越来越大的问题，&lt;code&gt;Redis&lt;/code&gt;实现了一种优化机制——&lt;strong&gt;AOF重写&lt;/strong&gt;。当&lt;code&gt;Redis&lt;/code&gt;检查到&lt;code&gt;AOF&lt;/code&gt;已经很大时，就会触发重写机制，优化其中的内容，将它优化为能够得到相同结果的最小的指令集合。&lt;/p&gt;
&lt;p&gt;  比如说，我们在&lt;code&gt;Redis&lt;/code&gt;中使用&lt;code&gt;SET&lt;/code&gt;指令创建了一个&lt;code&gt;String&lt;/code&gt;类型的数据，最后使用&lt;code&gt;DEL&lt;/code&gt;指令将它删除了。如果开启了&lt;code&gt;AOF&lt;/code&gt;持久化，那么则&lt;code&gt;AOF&lt;/code&gt;中，将会记录这条&lt;code&gt;SET&lt;/code&gt;和&lt;code&gt;DEL&lt;/code&gt;指令。但是，在执行重写的过程中，这个String最后被删除了，那么&lt;code&gt;Redis&lt;/code&gt;就不会将这两条指令加入新的&lt;code&gt;AOF&lt;/code&gt;中，因为已经被删除的数据，不需要恢复。再比如说，我们使用&lt;code&gt;Redis&lt;/code&gt;维护了一个计数器&lt;code&gt;cnt&lt;/code&gt;，我们使用了&lt;code&gt;100&lt;/code&gt;次&lt;code&gt;INCR&lt;/code&gt;指令，让&lt;code&gt;cnt&lt;/code&gt;自增到了&lt;code&gt;100&lt;/code&gt;，而&lt;code&gt;Redis&lt;/code&gt;重写&lt;code&gt;AOF&lt;/code&gt;时，可以将这&lt;code&gt;100&lt;/code&gt;条&lt;code&gt;incr&lt;/code&gt;修改为一条&lt;code&gt;SET&lt;/code&gt;指令，直接将&lt;code&gt;cnt&lt;/code&gt;设置为&lt;code&gt;100&lt;/code&gt;，而不是保留&lt;code&gt;100&lt;/code&gt;条&lt;code&gt;INCR&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;  经过了重写后，&lt;code&gt;AOF&lt;/code&gt;的大小将会大大减小，而且也去除了不必要的操作，优化了恢复数据的指令集。而&lt;code&gt;AOF&lt;/code&gt;重写的过程与生成一个快照文件类似，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;执行&lt;code&gt;fock()&lt;/code&gt;，创建一个子进程用来执行后续操作，而父进程继续处理发送到&lt;code&gt;Redis&lt;/code&gt;的执行请求；&lt;/li&gt;
&lt;li&gt;子进程重写旧&lt;code&gt;AOF&lt;/code&gt;文件，将重写后的内容写入到一个临时文件；&lt;/li&gt;
&lt;li&gt;如果这个过程中，有新的写指令到达，那么&lt;code&gt;Redis&lt;/code&gt;会将这些写指令依旧追加到旧的&lt;code&gt;AOF&lt;/code&gt;中，同时也会将这些指令加入到内存的一个缓冲区中。这样做的目的是，如果服务器发生异常，&lt;code&gt;AOF&lt;/code&gt;重写失败，这些指令依然能够保存在旧&lt;code&gt;AOF&lt;/code&gt;，不会丢失；&lt;/li&gt;
&lt;li&gt;当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有写指令追加到新 &lt;code&gt;AOF&lt;/code&gt; 文件的末尾；&lt;/li&gt;
&lt;li&gt;使用新&lt;code&gt;AOF&lt;/code&gt;替换旧的&lt;code&gt;AOF&lt;/code&gt;，这之后执行的所有写指令都将追加到新的&lt;code&gt;AOF&lt;/code&gt;中；&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;&lt;h2 id=&quot;28-aof的错误处理&quot;&gt;2.8 AOF的错误处理&lt;/h2&gt;
&lt;p&gt;  &lt;code&gt;AOF&lt;/code&gt;文件是有可能发生错误的，比如上面提过，如果当前&lt;code&gt;Redis&lt;/code&gt;正在向&lt;code&gt;AOF&lt;/code&gt;中追加一个写指令，但是此时服务器宕机，那么这个存入&lt;code&gt;AOF&lt;/code&gt;中的这个写指令就是不完整的，也就是&lt;code&gt;AOF&lt;/code&gt;出现了错误。如果停机造成了 &lt;code&gt;AOF&lt;/code&gt; 文件出错（corrupt）， 那么 &lt;code&gt;Redis&lt;/code&gt; 在重启时会拒绝载入这个 &lt;code&gt;AOF&lt;/code&gt; 文件， 从而确保数据的一致性不会被破坏。&lt;/p&gt;
&lt;p&gt;  那么，当&lt;code&gt;AOF&lt;/code&gt;发生了错误，应该如何处理呢？我们可以使用如下命令：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;redis-check-aof --fix&lt;/strong&gt;：redis-check-aof用来检测AOF是否存在错误，如果指定了--fix参数，那么Redis在检测到AOF的错误后，会对AOF进行修复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  &lt;code&gt;redis-check-aof&lt;/code&gt;修复&lt;code&gt;AOF&lt;/code&gt;的方式非常简单：&lt;strong&gt;扫描AOF文件，寻找其中不正确或不完整的指令，当发现第一个出错的指令后，就将这个指令以及这之后的所有指令删除&lt;/strong&gt;。为什么需要删除出错指令之后的所有指令呢？因为当一条指令出错，很有可能影响到后续的操作，导致后续操作的都是脏数据，而&lt;code&gt;Redis&lt;/code&gt;无法检测哪些指令是受到影响的，所以为了保险起见，就将后续指令全部删除。不过不用担心，因为在大多数情况下，出错的都是&lt;code&gt;AOF&lt;/code&gt;最末尾的指令。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;29-aof的优缺点&quot;&gt;2.9 AOF的优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 &lt;code&gt;AOF&lt;/code&gt; 持久化会让 &lt;code&gt;Redis&lt;/code&gt; 变得非常耐久，意思就是说，当发生异常导致需要重启服务器时，只会丢失很少的一部分数据，因为&lt;code&gt;AOF&lt;/code&gt;持久化默认&lt;code&gt;1s&lt;/code&gt;同步一次，也就是说，&lt;code&gt;Redis&lt;/code&gt;最多只会丢失&lt;code&gt;1s&lt;/code&gt;中所做的修改；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt; 可以在 &lt;code&gt;AOF&lt;/code&gt; 文件体积变得过大时，自动地在后台对 &lt;code&gt;AOF&lt;/code&gt; 进行重写： 重写后的新 &lt;code&gt;AOF&lt;/code&gt; 文件包含了恢复当前数据集所需的最小命令集合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AOF&lt;/code&gt; 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 &lt;code&gt;Redis&lt;/code&gt; 协议的格式保存， 因此 &lt;code&gt;AOF&lt;/code&gt; 文件的内容非常容易被人读懂， 对文件进行分析（&lt;code&gt;parse&lt;/code&gt;）也很轻松。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AOF&lt;/code&gt; 文件是一个只进行追加操作的日志文件（&lt;code&gt;append only log&lt;/code&gt;）， 因此对 &lt;code&gt;AOF&lt;/code&gt; 文件的写入不需要进行 &lt;code&gt;seek&lt;/code&gt; ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， &lt;code&gt;redis-check-aof&lt;/code&gt; 工具也可以轻易地修复这种问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;（2）缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于相同的数据集来说，&lt;code&gt;AOF&lt;/code&gt; 文件的体积通常要大于快照&lt;code&gt;RDB&lt;/code&gt;文件的体积大，因为&lt;code&gt;RDB&lt;/code&gt;只存储数据，而&lt;code&gt;AOF&lt;/code&gt;中的写指令，既包含指令，也包含数据；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;AOF&lt;/code&gt;体积太大，那么恢复数据将要花费较长的时间，因为需要重做指令；&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;&lt;h2 id=&quot;210-选择快照还是aof？&quot;&gt;2.10 选择快照还是AOF？&lt;/h2&gt;
&lt;p&gt;  说到这里，可能就有人要问了，在实际生产中，我们应该使用快照持久化还是&lt;code&gt;AOF&lt;/code&gt;持久化呢？&lt;/p&gt;
&lt;p&gt;1、如果希望自己的数据库有很高的安全性，则应该两者同时使用，&lt;code&gt;AOF&lt;/code&gt;用作精确记录，而快照用作数据备份，前面也说过，快照非常适合用来做数据备份，因为它只存储数据库中的数据，并且经过了压缩，而且它恢复&lt;code&gt;Redis&lt;/code&gt;数据的速度一般要快于&lt;code&gt;AOF&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;2、如果可以容忍一段时间内的数据丢失，则可以考虑只使用快照持久化，减小服务器的开销；&lt;/p&gt;
&lt;p&gt;  值得一提的是，如果我们同时开启了快照持久化和&lt;code&gt;AOF&lt;/code&gt;持久化，&lt;code&gt;Redis&lt;/code&gt;在重启后，会优先选择&lt;code&gt;AOF&lt;/code&gt;来恢复数据，因为一般情况下，&lt;code&gt;AOF&lt;/code&gt;能够更加完整地恢复数据。&lt;/p&gt;
&lt;p&gt;  快照持久化和&lt;code&gt;AOF&lt;/code&gt;持久化各有优劣，在实际生产环境中，我们一般是两者配合使用，快照持久化消耗较低，而且适合用于备份，但是会丢失一段时间的数据；&lt;code&gt;AOF&lt;/code&gt;持久化更加地耐久，可靠性更高，但是开销可能相对较高。以上就对&lt;code&gt;Redis&lt;/code&gt;的持久化机制做了一个比较详细的介绍，相信看完只后，对&lt;code&gt;Redis&lt;/code&gt;会有一个更加深入的理解。&lt;/p&gt;
&lt;br/&gt;</description>
<pubDate>Sat, 25 Apr 2020 17:07:00 +0000</pubDate>
<dc:creator>特务依昂</dc:creator>
<og:description>一、前言 由于疫情的原因，学校还没有开学，这也就让我有了很多的时间。趁着时间比较多，我终于可以开始学习那些之前一直想学的技术了。最近这几天开始学习 ，买了本 ，看到了第四章，前三章都是讲一些 的基本使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tuyang1129/p/12776526.html</dc:identifier>
</item>
<item>
<title>设计模式 - 命令模式详解及其在JdbcTemplate中的应用 - 农夫三拳有点疼~</title>
<link>http://www.cnblogs.com/songjilong/p/12776479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songjilong/p/12776479.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在软件设计中，我们经常需要向某些对象发送一些请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需要在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令模式（Command Pattern）可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。&lt;/p&gt;
&lt;p&gt;命令模式将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200425234945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Invoker：调用者，发送命令&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Receiver：接收者，接收命令&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Command：抽象命令类，定义了所有的命令&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ConcreteCommand：具体命令类，调用接收者的操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;现有许多家电（电灯、电视机、空调....），每个家电都有自己的控制装置，如果需要控制它们，需要逐个开启、逐个关闭，这时候，如果有一个万能遥控器（如下如所示），操作不同的家电只需要按对应的按钮即可，如何使用命令模式实现？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200425233344.png&quot;/&gt;&lt;p&gt;1、创建电灯的命令接收者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LightReceiver {
    public void on() {
        System.out.println(&quot;电灯打开了&quot;);
    }

    public void off() {
        System.out.println(&quot;电灯关闭了&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、创建抽象的命令接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Command {
    /**
     * 执行命令
     */
    void execute();

    /**
     * 撤销命令
     */
    void undo();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、创建电灯的开启、关闭命令类，实现命令接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LightOnCommand implements Command {
    private LightReceiver lightReceiver;

    public LightOnCommand(LightReceiver lightReceiver) {
        this.lightReceiver = lightReceiver;
    }

    @Override
    public void execute() {
        lightReceiver.on();
    }

    @Override
    public void undo() {
        lightReceiver.off();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LightOffCommand implements Command {
    private LightReceiver lightReceiver;

    public LightOffCommand(LightReceiver lightReceiver) {
        this.lightReceiver = lightReceiver;
    }

    @Override
    public void execute() {
        lightReceiver.off();
    }

    @Override
    public void undo() {
        lightReceiver.on();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、创建空的命令类，用于初始化按钮&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NullCommand implements Command {
    @Override
    public void execute() { }

    @Override
    public void undo() { }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、创建命令调用者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RemoteController {
    /**
     * 操作对象的个数
     */
    private static final int COUNT = 5;
    /**
     * 开启命令组
     */
    Command[] onCommands;
    /**
     * 关闭命令组
     */
    Command[] offCommands;
    /**
     * 执行撤销的命令
     */
    Command undoCommand;

    /**
     * 初始化
     */
    public RemoteController() {
        onCommands = new Command[COUNT];
        offCommands = new Command[COUNT];
        for (int i = 0; i &amp;lt; COUNT; i++) {
            onCommands[i] = new NullCommand();
            offCommands[i] = new NullCommand();
        }
    }

    /**
     * 设置按钮
     */
    public void setCommand(int no, Command onCommand, Command offCommand) {
        onCommands[no] = onCommand;
        offCommands[no] = offCommand;
    }

    /**
     * 按下开按钮
     */
    public void pressOnButton(int no) {
        onCommands[no].execute();
        //记录按钮，以便撤销
        undoCommand = onCommands[no];
    }

    /**
     * 按下关按钮
     */
    public void pressOffButton(int no) {
        offCommands[no].execute();
        //记录按钮，以便撤销
        undoCommand = offCommands[no];
    }

    /**
     * 按下撤销按钮
     */
    public void pressUndoButton(int no) {
        if (undoCommand != null) {
            undoCommand.undo();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    @Test
    public void testLight() {
        //创建命令接收者
        LightReceiver lightReceiver = new LightReceiver();
        //创建电灯的一组操作（开和关）
        LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);
        LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);
        //创建命令调用者
        RemoteController remoteController = new RemoteController();
        //设置命令
        remoteController.setCommand(0, lightOnCommand, lightOffCommand);
        //执行命令
        System.out.println(&quot;----按下开灯按钮----&quot;);
        remoteController.pressOnButton(0);
        System.out.println(&quot;----按下关灯按钮----&quot;);
        remoteController.pressOffButton(0);
        System.out.println(&quot;----按下撤销按钮----&quot;);
        remoteController.pressUndoButton(0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----按下开灯按钮----
电灯打开了
----按下关灯按钮----
电灯关闭了
----按下撤销按钮----
电灯打开了
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、如果再添加一个电视机，不需要改动任何已有的代码，添加 &lt;code&gt;TvReceiver&lt;/code&gt;、&lt;code&gt;TvOnCommand&lt;/code&gt;、&lt;code&gt;TvOffCommand&lt;/code&gt; 这几个类即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;🎉 优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;降低系统的耦合度&lt;/li&gt;
&lt;li&gt;新的命令可以很容易的加入到系统中&lt;/li&gt;
&lt;li&gt;容易设计一个命令队列。只要把命令对象放到队列，就可以多线程的执行命令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;💣 缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;🍳 适用环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。&lt;/li&gt;
&lt;li&gt;系统需要在不同的时间指定请求、将请求排队和执行请求。&lt;/li&gt;
&lt;li&gt;系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。&lt;/li&gt;
&lt;li&gt;系统需要将一组操作组合在一起，即支持宏命令。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;🍻 实际应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;界面的一个按钮都是一个命令&lt;/li&gt;
&lt;li&gt;模拟CMD（DOS命令）&lt;/li&gt;
&lt;li&gt;订单的撤销 / 恢复&lt;/li&gt;
&lt;li&gt;触发 - 反馈机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Spring 的 JdbcTemplate 这个类中有 query() 方法，query() 方法中定义了一个内部类 QueryStatementCallback，QueryStatementCallback 又实现了 StatementCallback 接口，另外还有其它类实现了该接口，StatementCallback 接口中又有一个抽象方法 doInStatement()。在 execute() 中又调用了 query()。&lt;/p&gt;
&lt;p&gt;将其关系缕一缕就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200426002752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Apr 2020 16:39:00 +0000</pubDate>
<dc:creator>农夫三拳有点疼~</dc:creator>
<og:description>基本介绍 在软件设计中，我们经常需要向某些对象发送一些请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需要在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来设计，使得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songjilong/p/12776479.html</dc:identifier>
</item>
<item>
<title>性能优化有感 - ingxx</title>
<link>http://www.cnblogs.com/ingxx/p/12776224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ingxx/p/12776224.html</guid>
<description>&lt;p&gt;性能优化是个枯燥，却又有趣的过程&lt;br/&gt;性能优化我大致分为几个方面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码优化&lt;/li&gt;
&lt;li&gt;线程优化、异步&lt;/li&gt;
&lt;li&gt;JVM优化&lt;/li&gt;
&lt;li&gt;数据库优化&lt;/li&gt;
&lt;li&gt;缓存优化&lt;/li&gt;
&lt;li&gt;架构优化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面来展开谈谈感悟，也可以参考&lt;a href=&quot;https://tech.meituan.com/2016/12/02/performance-tunning.html&quot;&gt;美团技术团队常见性能优化&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码优化&quot;&gt;代码优化&lt;/h2&gt;
&lt;p&gt;代码是跟我们接触最多的东西，代码优化主要有&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代码结构优化，可以方便日后扩展和代码标准化
&lt;ul&gt;&lt;li&gt;是否可以进行抽象避免冗余代码&lt;/li&gt;
&lt;li&gt;是否可以利用设计模式&lt;/li&gt;
&lt;li&gt;代码是否遵循阿里巴巴Java开发手册&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里可以采用&lt;a href=&quot;https://github.com/alibaba/p3c&quot;&gt;阿里巴巴Java开发规范插件&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;代码是否有多重循环，无效的查询等
&lt;ul&gt;&lt;li&gt;多重循环可以根据数据量采用HashMap进行查询，属于利用空间换取时间&lt;/li&gt;
&lt;li&gt;无效的查询等可以进行删除&lt;br/&gt;这里推荐&lt;a href=&quot;http://findbugs.sourceforge.net/&quot;&gt;Findbugs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;线程优化&quot;&gt;线程优化&lt;/h2&gt;
&lt;p&gt;线程优化是一个复杂的过程，多线程如何运用，如何避免死锁、饥饿、活锁等问题&lt;/p&gt;
&lt;ol readability=&quot;2.8494809688581&quot;&gt;&lt;li&gt;
&lt;p&gt;线程使用的地方&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在查询中可以运用到多线程，把串行化操作变化为并行化操作&lt;/li&gt;
&lt;li&gt;I/O阻塞的操作，最经典的莫过于BIO&lt;/li&gt;
&lt;li&gt;计算量大的操作，使用多线程可以更好的运用CPU的运算能力&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0.88187372708758&quot;&gt;
&lt;p&gt;线程池&lt;br/&gt;需要了解线程池的状态，线程池的参数，以及内部原理，并选择合适的线程池&lt;br/&gt;这里推荐一篇文章&lt;a href=&quot;https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html&quot;&gt;Java线程池实现原理及其在美团业务中的实践&lt;/a&gt; 再次感谢美团技术团队&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程池分为
&lt;ul&gt;&lt;li&gt;newCachedThreadPool&lt;/li&gt;
&lt;li&gt;newFixedThreadPool&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor&lt;/li&gt;
&lt;li&gt;newScheduleThreadPool&lt;/li&gt;
&lt;li&gt;forkjoinPool&lt;br/&gt;注意：这里不建议使用Executors来创建线程池，方式OOM等问题，参考阿里巴巴开发规范，建议使用new ThreadPoolExecutor()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;异步&lt;br/&gt;异步建议采用MQ，使用范围例如insert、update操作，可以丢到MQ，这里要注意MQ消息丢失问题，同时MQ也可以实现延迟队列，例如30分钟关闭订单，采用Job的方式并不是一个好的解决方案，可以采用MQ延时队列实现，这里推荐rocketmq(阿里巴巴牛逼)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;并发容器的选择&lt;br/&gt;concurrenthashmap和synchronizedmap性能差距很大，建议选择合适的并发容器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jvm优化&quot;&gt;JVM优化&lt;/h2&gt;
&lt;p&gt;JVM优化这里本人也不是特别的熟练，只是讲一些自己所知道的&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无日志不优化&lt;br/&gt;在没有日志的情况下，该怎么优化，如何优化，哪些方面需要优化，这里都是未知的，所以需要日志才能进行优化&lt;/li&gt;
&lt;li&gt;工具&lt;br/&gt;优化要有趁手的工具，好在JDK本身就为我们提供了不少，在JDK的bin目录下有一堆自带的工具，这里介绍几个我熟悉且用过的
&lt;ul&gt;&lt;li&gt;jps：查看当前机器上的java程序&lt;/li&gt;
&lt;li&gt;jcmd：跟jps差不多但是能看到启动命令&lt;/li&gt;
&lt;li&gt;jstat：查看JVM信息，例如GC信息&lt;/li&gt;
&lt;li&gt;jinfo：查看JVM参数&lt;/li&gt;
&lt;li&gt;jmap：JVM在内存中的情况，可以导出Dump&lt;/li&gt;
&lt;li&gt;jstack：栈信息，可以用来查看死锁等&lt;/li&gt;
&lt;li&gt;jconsole：一个可视化工具&lt;/li&gt;
&lt;li&gt;jvisualvm：也是一个可视化工具比jconsole功能强一些，但是都有局限性，在服务器上无法使用&lt;/li&gt;
&lt;li&gt;eclipse memory analyer：分析dump文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;参数优化&lt;br/&gt;使用上面的工具对服务器进行监控，可以根据信息适当的调整堆大小，GC收集器等。建议开启-XX:+HeapDumpOnOutOfMemoryError&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;数据库优化&quot;&gt;数据库优化&lt;/h2&gt;
&lt;p&gt;数据库是优化中重要的一环，具体优化方法如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SQL优化：是否可以去掉不必要的查询，使用explain对sql进行分析，避免回表等&lt;/li&gt;
&lt;li&gt;分库分表：一台数据库可能存在性能瓶颈，可以采用分库分表的方式，拆分主要采用冷热数据分离、日期分割、HASH取模等。&lt;/li&gt;
&lt;li&gt;读写分离：对数据的修改可以操作主库，对数据的查询可以操作从库，进行读写分离&lt;br/&gt;分库分表以及读写分离后可能会出现分布式事务、读写分离操作的复杂性等问题这里需要引入中间件例如：&lt;a href=&quot;http://www.mycat.io/&quot;&gt;MyCat&lt;/a&gt; &lt;a href=&quot;https://shardingsphere.apache.org/document/current/cn/manual/sharding-jdbc/&quot;&gt;sharding jdbc&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;缓存优化&quot;&gt;缓存优化&lt;/h2&gt;
&lt;p&gt;缓存是个优化的好办法但是也有弊端&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存分类
&lt;ul&gt;&lt;li&gt;JVM缓存：concurrenthashmap、guava缓存&lt;/li&gt;
&lt;li&gt;Redis等NoSQL数据库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缓存拆分&lt;br/&gt;可以在代码中对接口进行拆分，可以缓存的和不可以缓存的写成多个方法，对可以缓存的进行缓存&lt;/li&gt;
&lt;li&gt;缓存带来的弊端&lt;br/&gt;缓存并不是越多越好，缓存给系统带来了复杂性，例如：何时添加缓存、何时删除缓存、缓存雪崩、缓存击穿、缓存穿透、缓存预热、Redis集群如何实现、Redis哨兵、Redis脑裂等问题&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;架构优化&quot;&gt;架构优化&lt;/h2&gt;
&lt;p&gt;架构优化其实就程序员来说能做的并不是很多&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;限流：GateWay进行限流，限流方法有滑动窗口、漏桶、令牌桶算法，这里建议采用合适的方法进行限流防止应用崩溃&lt;/li&gt;
&lt;li&gt;熔断：可以采用hystrix防止服务雪崩&lt;/li&gt;
&lt;li&gt;CDN优化：对静态资源采用CDN可以提交响应速率&lt;/li&gt;
&lt;li&gt;DNS优化：这个暂时不熟可以交给运维处理&lt;/li&gt;
&lt;li&gt;服务扩容：可以采用K8S和Docker的技术对服务进行动态扩容，这里也是运维实现&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;优化了这么多，体现当然是压力测试，这里因为不熟悉性能指标，单机TPS部分接口可以达到800+ RT在300ms以内，希望大家提供一个单机性能标准，以上采用的是LoadRuner测试的结果&lt;/p&gt;
&lt;p&gt;洋洋洒洒写了这么多，主要的还是平时的积累以及思考，也希望您对内容进行补充。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Apr 2020 15:29:00 +0000</pubDate>
<dc:creator>ingxx</dc:creator>
<og:description>性能优化有感 性能优化是个枯燥，却又有趣的过程 性能优化我大致分为几个方面 代码优化 线程优化、异步 JVM优化 数据库优化 缓存优化 架构优化 下面来展开谈谈感悟，也可以参考 &amp;quot;美团技术团</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ingxx/p/12776224.html</dc:identifier>
</item>
</channel>
</rss>