<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>LeetCode 41，一题解读in-place思想 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12501792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12501792.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;LeetCode题解系列第21篇&lt;/strong&gt;，今天来看一道人狠话不多的题目。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;题面&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题目非常简单，只有一句话，给定一个整数数组，要求返回最小的不在数组当中的正整数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来有些拗口，简单解释一下。我们都知道正整数就是从1开始的整数，所以这道题就是从1开始找到第一个不在数组当中的元素。我们来看下样例：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;样例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code&gt;Input: [1,2,0]
Output: 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;样例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code&gt;Input: [3,4,-1,1]
Output: 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;样例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code&gt;Input: [7,8,9,11,12]
Output: 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法的&lt;strong&gt;时间复杂度&lt;/strong&gt;必须是&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=O(n)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;，并且只能使用&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=O(1)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;的存储空间。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分析&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在注意出来之前，我们可能觉得这道题也不是那么难，很容易就想到解法，但是有了这两条限制之后就没那么简单了。我们遍历数组就需要&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=O(n)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;的复杂度了，怎么还能找出最小未出现的元素呢？而且还不能申请额外的数组，只能用常数级的存储，显然各种辅助数组和容器是不能用了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接这么苦苦思索是很难想出解法的，不如来&lt;strong&gt;循序渐进&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来假设没有这些限制条件的话应该用什么方法，最容易想到的应该是&lt;strong&gt;排序&lt;/strong&gt;。我们将数组排序，一旦数组有序了之后就方便了。我们从小到大遍历，很容易就确定哪些元素出现过哪些元素没有。那么想要找出来不在数组当中的最小自然数自然也是轻而易举。分析一下排序我们可以发现，在此过程当中我们并没有用到额外的空间，唯一不满足条件的只有我们的时间复杂度是&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=O(nlogn)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;而不是&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=O(n)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们写下代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;firstMissingPositive&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;nums = sorted(nums)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; len(nums) == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; nums[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;p&gt;mark = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; nums:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i == mark:&lt;br/&gt;mark += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; mark&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们反过来，如果保证空间可以随意使用，但是对时间复杂度进行限制，我们能想到什么办法呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该也很容易想出来，就是引入额外的容器。比如hashset。hashset的增删改查的复杂度都可以近似看成是常数级。我们只需要遍历一次数组，将所有元素插入hashset当中，同时记录下元素的最大最小值，最后遍历一下最小值和最大值这个区间，找出不在hashset当中最小的元素即可。n个元素的数组我们可以很容易证明，我们一定可以在n次查找以内找到不在数组当中的自然数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码也不难写：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;7&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;firstMissingPositive&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;st = set()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; len(nums) == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;p&gt;mini, maxi = &lt;span class=&quot;hljs-number&quot;&gt;3e9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;-3e9&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; nums:&lt;br/&gt;st.add(i)&lt;br/&gt;mini = min(mini, i)&lt;br/&gt;maxi = max(maxi, i)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, maxi):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; st:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; max(maxi+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;in-place&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的两种做法一种进行了高复杂度的排序，另一种则用到了额外的存储。看起来这是一个两难问题，我们不想排序就需要用到存储，如果不想用存储呢，那么则需要元素有序。我们仔细分析一下这两种情况，就可以找到问题的症结了，我们有没有什么办法可以两全其美，&lt;strong&gt;既不用额外的存储又可以保证元素的有序呢&lt;/strong&gt;？如果我们可以找到一种方法，那么这个问题就解决了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是我们解题的时候的一个常规的套路，就是对于一些题目而言有一些算法是比较明显的，但是可能因为这样或那样的限制使得并不能应用在当前的问题当中。但是没关系，我们一样可以往这方面去想，先找到一个不那么合适的解法，在此基础上谋求突破，很多时候要比凭空想出一个完美的方法来容易许多。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么突破呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还要从题目的要求入手，题目当中规定只能使用常数的存储空间，意味着我们不能额外开辟数组或者其他容器来存储数据。有经验的同学可能已经反映过来了，这是&lt;strong&gt;in-place的套路&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;in-place并不是一个算法，而是一种思想。它出现的原因也非常简单，因为我们申请数组等容器的时候需要&lt;strong&gt;通过操作系统向内存申请连续的内存&lt;/strong&gt;，这会涉及到一系列内存管理算法的执行，所以是需要&lt;strong&gt;消耗大量时间&lt;/strong&gt;的。所以在一些高性能的场景下，我们会希望尽量避免空间申请操作。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们想要对数组进行排序，我们直接调用sorted方法的时候，其实在函数内部对数组进行了拷贝，最后返回的其实是拷贝数组排序之后的结果。也就是说我们&lt;strong&gt;获得的是一个新的数组&lt;/strong&gt;，只是其中的元素和原来一模一样。而如果是in-place的方法，我们则不会另外创建数组，而在原数组上进行修改。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非in-place的接口不会修改原值，这方便我们追踪数据的变化，以及撤销操作。比如Python机器学习领域的大量numpy和pandas的接口默认都不是in-place的，就是这个原因。而in-place的则相反，由于它会直接修改原值，所以如果我们一旦执行错了，无法撤销，原数据就找不回了。比如我们排序错了，明明要降序，不小心排成了升序，一旦执行就无法还原了。但是和非in-place相比，它的&lt;strong&gt;耗时更少，也更节约内存&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这题其实已经暗示得很明显了，我们需要存储数据，但是又不让我们申请空间，于是我们只有in-place一条路可以走了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要设计一个in-place的算法，让我们可以判断元素的存在性。再加上题目中的限制是正整数，而且我们要找的是第一个没有出现的正整数。如果数组的长度是n，那么其实我们可以锁定，&lt;strong&gt;答案一定在[1, n+1]之间&lt;/strong&gt;。原因也很简单，因为最理想的情况是这个数组当中的n个元素刚好是1到n，这样我们从1开始遍历，一直找到n就能得到答案是n+1。否则的话，我们一定可以在遍历到n+1之前就找到答案，所以综合一下，答案一定在[1, n+1]之间。如果我们能把这个区间写出来，其实解法已经就在我们眼前了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然答案在区间[1, n+1]中间，我们又需要设计一个in-place的方法，那么我们可以很正常地想到，我们可以&lt;strong&gt;将数字放到对应的下标当中去&lt;/strong&gt;。1放到下标1当中，0放到0当中。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如[3, 1, 0, 5]，我们拿到第一个元素是3，我们把它放到它应该在的位置，也就是5的位置下去，这个时候我们再来放5，由于5超过了数组的长度，所以进行丢弃。我们往下重复如上的过程，到最后的时候，我们得到的数据情况如下：[0, 1, 5, 3]，我们遍历一下数组，发现和下标不匹配的位置就是5，它应该对应的数据是2，所以2就是答案。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我一开始是先想到的算法，几乎是凭空想出来的，没有前后推导的过程，觉得非常惊艳，有种天马行空的感觉。后来关联上的in-place思想之后，才发现隐藏的思路其实非常合情合理。思路有了，代码真的很简单：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;firstMissingPositive&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;n = len(nums)&lt;br/&gt;nums.append(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i == nums[i]:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:&lt;br/&gt;val = nums[i]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; val &amp;gt; n &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; val &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; val == i &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; val == nums[val]:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;&lt;br/&gt;nums[i], nums[val] = nums[val], val&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, n+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i != nums[i]:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; n+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来分析一下这个算法的复杂度，为什么我们在一重循环当中还套了一个while循环，但是它仍然是&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=O(n)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;的算法呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题我们之前在介绍two pointers和尺取法的时候就曾经介绍过，我们在分析复杂度的时候&lt;strong&gt;不能只简单地看有几重循环&lt;/strong&gt;，我们需要细致地分析。我们要忽略循环，回到问题的本质。我们用循环的本质是为了能够让每个元素放到对应的位置，一共需要安排的元素数量是固定的是n个，位置也是固定的是n个，一个元素只有一个位置。那么我们一次交换至少可以让一个元素放到正确的位置，那么问题来了，我们想要把所有元素放置好，需要循环多少次？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这样问，大家应该很清楚，一次最少放一个，一共n个，显然最多放n次。那我们再看while循环当中，每执行一次，不就是放好了一个元素吗？外围的循环只是用来枚举元素的，并不会引入额外的计算，所以这当然是一个&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=O(n)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;的算法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，今天的题目官方标的难度是Hard，题目本身不难，由于加上了很多限制才提升了难度。今天的题目没有用到新的算法，纯粹是对思维和逻辑的考验。也因此，我觉得它是一道非常纯粹的题，纯粹在于它并用不到新的算法，也用不到新的数据结构，就是考察我们分析问题和思考问题的能力。而许多问题则针对性很强，如果之前没有学过对应的算法则无法做得出来，所以从这点上来说这题&lt;strong&gt;更加公平，非常适合面试&lt;/strong&gt;。我已经进行了预约，以后如果有面试机会，我可能会问候选人这个问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就是这些，如果觉得有所收获，请顺手点个&lt;strong&gt;关注或者转发&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1906483/202003/1906483-20200316085914343-841407199.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Mar 2020 00:57:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是LeetCode题解系列第21篇，今天来看一道人狠话不多的题目。 题面 题目非常简单，只有一句话，给定一个整数数组，要求返回最小的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12501792.html</dc:identifier>
</item>
<item>
<title>开源项目在闲鱼、b 站上被倒卖？这是什么骚操作？ - 我是13</title>
<link>http://www.cnblogs.com/han-1034683568/p/12499045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/han-1034683568/p/12499045.html</guid>
<description>&lt;p&gt;我只希望看到这篇文章的朋友，如果你们需要代码，直接去开源网站上搜就完事儿了，我当时开源的时候也还考虑了网络问题，不止是 GitHub 上，我在国内的开源平台 Gitee 上也有代码的备份，大家喜欢的话直接去下载就好了，希望大家不要被骗钱啦。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;159.36790638025&quot;&gt;
&lt;h2 id=&quot;起因---又是一封邮件&quot;&gt;起因 - 又是一封邮件&lt;/h2&gt;
&lt;p&gt;2020 年 3 月 2 日，收到了一封邮件，对，这次故事的起因又是一封邮件，和上次&lt;a href=&quot;https://juejin.im/post/5df0c0705188251222737053&quot;&gt;写个bug被国家信息安全漏洞共享平台抓到了&lt;/a&gt;一样。&lt;/p&gt;
&lt;p&gt;这是一条评论通知邮件，一开始我以为只是正常的评论内容，后来看到内容才发现事情并不简单，邮件内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315180840629-97963065.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过截图，大家应该也能够清楚大致的情况，b 站上有 up 主用我的开源项目做了视频并且进行源码的贩卖和宣传。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315180856274-374952259.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我之前写过一个开源的商城项目，代码和所有的资源文件都是免费给大家用的，名称叫“新蜂商城”，开源仓库的地址是&lt;a href=&quot;https://github.com/newbee-ltd/newbee-mall&quot; class=&quot;uri&quot;&gt;https://github.com/newbee-ltd/newbee-mall&lt;/a&gt;，就是这样一个开源的项目，有人把项目的运行情况进行了视频的录制并且放到了 b 站里，而且，如果想获取视频中演示网站的源码，你就需要付费 300 元，这些内容都有截图的，我并不是随口胡诌，有人看到了这些内容于是就在我的文章下面留言了。&lt;/p&gt;
&lt;p&gt;这件事情呢我并没有特别在意，当天就是看了一眼，然后和几个朋友聊了一下这个事情，针对这种情况，我也是第一次遇到，也就没做太多事情，因为我觉得有些没头绪，开源的项目源码也能被你拿去卖，太骚了。&lt;/p&gt;
&lt;h2 id=&quot;万事皆可骚&quot;&gt;万事皆可骚&lt;/h2&gt;
&lt;p&gt;本来以为这件事情就此打住，也就没管了，但是事情肯定不会这么简单的，不然我也不会写这篇文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315180910621-1357279543.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你说巧不巧，2020 年 3 月 5 日，又收到了一个类似的消息，这次是 QQ 交流群里的一位朋友发过来的，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315180924317-605957265.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我当时就乐了，现在写这些事情的时候我还是会觉得很好笑，就是那种很难形容的情绪，非常的莫名其妙又非常的不解导致了一种很情绪化的快乐，和雷总一样，差点儿就翻了几个跟头。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315180939747-2038234962.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好家伙，开源项目的源码不止在 b 站有市场，他马的闲鱼也可以卖这玩意儿？竟然有人！竟然有人！！！竟然有人在闲鱼上去卖我写的项目源码？我不得不说，你们真的好骚啊！&lt;/p&gt;
&lt;p&gt;接下来就给你们看一下这些骚东西。&lt;/p&gt;
&lt;h2 id=&quot;b-站视频&quot;&gt;b 站视频&lt;/h2&gt;
&lt;p&gt;首先说一下 b 站的这个情况，截止到我发这篇文章为止，这个视频还在那里，视频的地址为 &lt;a href=&quot;https://www.bilibili.com/video/av92760883&quot; class=&quot;uri&quot;&gt;https://www.bilibili.com/video/av92760883&lt;/a&gt;，好奇的朋友也可以去看看这个视频，进去你就会发现这位几千粉丝的 up 主，连开源项目的 Java 源码包名都没改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315180956400-129189109.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多余的话就不说了，全在截图里了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这位 up 主投稿投的是原创，嗯，原创。&lt;/li&gt;
&lt;li&gt;还能代做毕业设计，嗯，要恰饭的，恰饭没有错，方式是不是有点问题？&lt;/li&gt;
&lt;li&gt;看看视频里的项目截图、看看源码结构，你品，你细品。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再来看看人家多赚钱，这样一份代码卖多少？300 块.....&lt;/p&gt;
&lt;p&gt;开源项目的源码下载下来，改个 LOGO 图片，录个视频宣传，轻松入账。&lt;/p&gt;
&lt;p&gt;我抽出下班时间，断断续续写了半年的项目，不是心血也算是我的小作品吧，开源出去就是给你这么玩的？佩服。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315181008293-1463298135.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;闲鱼&quot;&gt;闲鱼&lt;/h2&gt;
&lt;p&gt;真的是&lt;strong&gt;天下之大，无奇不有&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;说完 b 站 up 主，再来说一下闲鱼上的情况，我当时下载这个 APP 的时候真的特别搞笑，我知道这个 APP 不过很少用这个 APP，但是竟然有人在这玩意儿上卖我的项目源码？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我得去开开眼界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到了闲鱼，一开始还没找到，后来换了几条搜索的关键字后终于搜到了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315181019445-1370885760.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当时有些被惊到了，“springboot商城”这个关键字搜索出来的结果里竟然大部分都是新蜂商城，截图里有 8 条数据，仔细看一下你会发现其中有一半是新蜂商城，仅仅看截图就看得出来。&lt;/p&gt;
&lt;p&gt;我一时竟不知是该开心还是该沮丧，数据看起来这个商城还挺受欢迎的？但是你们的这些骚操作真的好吗？&lt;/p&gt;
&lt;p&gt;一个个点开来看吧。&lt;/p&gt;
&lt;p&gt;第一个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315181031757-673883593.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确认过眼神，是新蜂商城没错了。&lt;/p&gt;
&lt;p&gt;第二个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315181036956-416762568.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这位老哥还录了视频，改了不少的图片，但还是一眼就看出是新蜂商城。&lt;/p&gt;
&lt;p&gt;第三个、第四个也差不多：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315181042364-1777467329.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本可以确认，确实有人在卖开源项目新蜂商城的源码，从这些截图里也看得出他们的要价不同，而且使用的源码版本应该也不一样，因为中间我改过几次代码所以页面会有些区别，我一眼就看得出来。&lt;/p&gt;
&lt;p&gt;也就是说这些人卖这个项目源码应该有一段时间了，这究竟是道德的沦丧，还是人性的扭曲？&lt;/p&gt;
&lt;p&gt;真是什么搞笑的事情都能被我给碰到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315181055647-1208780767.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过说实在的，闲鱼这几位老哥还算是“有良心”的，b 站上有位“大佬”直接卖了300元，相比较下来还算是“有良心”吧，新蜂商城这份源代码，我自己都不敢说能卖得出去，而且还要卖很多钱，给你们跪了！&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;只是展示一下客观事实，其他多余的内容暂时就都不写了。&lt;/p&gt;
&lt;p&gt;其实一开始我不在意，是我觉得不管是视频也好、截图也罢，这玩意儿一眼就能够看出来是新蜂商城这个项目，所以我当时就觉得，莫慌莫慌。后来看了一些数据和评论后就小小的改了一下主意，因为这个开源项目毕竟还没有流行到每个人都知道，那如果有人不知道这个项目，真的花钱去买了源码，影响不太好。&lt;/p&gt;
&lt;p&gt;还有就是那些对我说这件事情的人，他们往往都会问，这个视频是你录制的吗？闲鱼上是你在卖代码吗？&lt;/p&gt;
&lt;p&gt;不是啊！不是啊！不是啊！我哪有他们的商业头脑啊！妈耶，源码是免费的，免费的！都在开源仓库里啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315181102626-1929710840.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，暂时就讲到这里，我只希望看到这篇文章的朋友，如果你们需要代码，直接去开源网站上搜就完事儿了，我当时开源的时候也还考虑了网络问题，不止是 GitHub 上，我在国内的开源平台 Gitee 上也有代码的备份，大家喜欢的话直接去下载就好了，希望大家不要被骗钱啦。&lt;/p&gt;
&lt;p&gt;对这些人呢，没啥要说的，我也不知道说什么，也不知道该做什么，毕竟我又不会发律师函（还不至于，哈哈哈哈...），惹不起。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/859549/202003/859549-20200315181114591-1077442893.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感谢大家的观看，我是十三，文章首发于我的公众号“程序员的小故事”。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 16 Mar 2020 00:56:00 +0000</pubDate>
<dc:creator>我是13</dc:creator>
<og:description>我只希望看到这篇文章的朋友，如果你们需要代码，直接去开源网站上搜就完事儿了，我当时开源的时候也还考虑了网络问题，不止是 GitHub 上，我在国内的开源平台 Gitee 上也有代码的备份，大家喜欢的话</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/han-1034683568/p/12499045.html</dc:identifier>
</item>
<item>
<title>java环境配置 - 龚哞哞</title>
<link>http://www.cnblogs.com/gongsuiqing/p/12501773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gongsuiqing/p/12501773.html</guid>
<description>&lt;p&gt;1，安装好jdk和jre后，打开环境配置，即点击电脑右键-属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1440360/202003/1440360-20200316084231154-1752633947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2，高级系统设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1440360/202003/1440360-20200316084302444-379479961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3，环境变量：&lt;/p&gt;
&lt;p&gt;设置三个值：&lt;/p&gt;
&lt;p&gt;①新建环境变量，JAVA_HOME，蓝色为jdk安装路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1440360/202003/1440360-20200316084401845-1567949011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; ②新建CLASSPATH,复制 这一段.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;（点和分号都不要漏掉）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1440360/202003/1440360-20200316084512520-651599181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;③Path：复制这一段字符（百分号开头，bin结尾）不要加逗号分号啥的！！！&lt;/p&gt;
&lt;p&gt;变量值：%JAVA_HOME%\bin&lt;/p&gt;
&lt;p&gt;变量值：%JAVA_HOME%\jre\bin&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1440360/202003/1440360-20200316084648635-1322405252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 4，点击确定，然后测试一下： 如果有东西出来就是正确的了。&lt;/p&gt;
&lt;p&gt;java ，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1440360/202003/1440360-20200316084957193-1607320140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;java  -version，（如果是64位的会有64 bit的字样，我的是32位，如下）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1440360/202003/1440360-20200316085045174-220287715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; javac&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1440360/202003/1440360-20200316085155809-1072068506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;以上就是配置环境变量的所有步骤了&lt;/p&gt;
&lt;p&gt;亲测的，质量杠杠的！&lt;/p&gt;

</description>
<pubDate>Mon, 16 Mar 2020 00:54:00 +0000</pubDate>
<dc:creator>龚哞哞</dc:creator>
<og:description>1，安装好jdk和jre后，打开环境配置，即点击电脑右键-属性 2，高级系统设置 3，环境变量： 设置三个值： ①新建环境变量，JAVA_HOME，蓝色为jdk安装路径： ②新建CLASSPATH,复</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gongsuiqing/p/12501773.html</dc:identifier>
</item>
<item>
<title>【BIM】BIMFACE中创建矢量文本 - 悠扬的牧笛</title>
<link>http://www.cnblogs.com/xhb-bky-blog/p/12454863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhb-bky-blog/p/12454863.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;在三维模型产品的设计中，针对空间的管理存在这样一个普遍的需求，那就是在三维模型中，将模型所代表的空间通过附加文本的方式来展示其所代表的实际位置或功能，之前尝试过若干方式，比如直接在建模的时候，将文本以构件的方式建在模型里，其优点是展示效果好、位置可控、放大后不失真，但是缺少灵活性，一旦加入到模型中，相当于焊死在上面；另一种方式则是通过&lt;code&gt;Canvas&lt;/code&gt;绘制文本后动态追加到模型之上，这种方式解决了灵活性的问题，但是在模型放大时会产生失真，变得模糊。那么有没有一种方式，既能保证文本在模型中的灵活性，又能保证其矢量特性，放大模型不失真呢？答案是有的。&lt;/p&gt;
&lt;h2 id=&quot;平台&quot;&gt;平台&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://bimface.com/&quot;&gt;BIMFACE&lt;/a&gt;是基于THREEJS 3D库的图形引擎，有很多的优异特性，但在某些功能上仍然不满足现有的需求，例如对矢量文本的支持。但是它提供了一个允许添加外部构件的接口，我称之为开放接口，它允许任何符合THREEJS标准的三维物体添加到场景中，这就给开发者提供了脑洞大开的机会，比如我可以自己创建各种各样的&lt;code&gt;Mesh&lt;/code&gt;添加到场景、可以自定义任何类型的灯光效果，当然也可以将矢量图形加入场景。本文的矢量文本就是基于SVG的矢量图形，通过开放接口加入到场景中的。&lt;/p&gt;
&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;
&lt;p&gt;如果我们对&lt;code&gt;SVG(Scalable Vector Graphics)&lt;/code&gt;了解的话，就会知道它是可缩放的矢量图形，以下是来自百度百科对它的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;严格来说应该是一种开放标准的矢量图形语言，可让你设计激动人心的、高分辨率的Web图形页面。用户可以直接用代码来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来观看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来就是字体文件的转换，字体文件需要转换成json格式才可以被THREEJS的&lt;code&gt;FontLoader&lt;/code&gt;所识别，网络上已经有大牛实现了这种转换算法，具体地址如下：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://gero3.github.io/facetype.js/&quot; class=&quot;uri&quot;&gt;http://gero3.github.io/facetype.js/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过该网站可以将字体文件转换成可被识别的json文件，然后通过&lt;code&gt;FontLoader&lt;/code&gt;导入后即可开始后续的操作。核心代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function loadText(){
    var loader = new THREE.FontLoader();
    loader.load('fonts/FZDaBiaoSong-B06S_Regular.json',  (font) =&amp;gt; {
        var xMid, text;
        var textShape = new THREE.BufferGeometry();
        var color = 0xff0009;
        var matDark = new THREE.LineBasicMaterial({
            color: color,
            side: THREE.DoubleSide
        });

        var matLite = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            wireframe: false,
            opacity: 0.9,
            side: THREE.DoubleSide
        });
        
        // 显示文本
         var message = &quot;THREEJS&quot;;

        // 根据文本产生路径
        // 参数列表：文本 | 字体大小
        var shapes = font.generateShapes(message, 5000);
        var geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();
        xMid = - 0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
        geometry.translate(xMid, 0, 0);
        geometry.rotateX(45);

        textShape.fromGeometry(geometry);
        text = new THREE.Mesh(textShape, matLite);
        text.position.z = 0;
        text.position.x = 70000;

        var group = new THREE.Group();
        groupt.add(text);
        
        // 加入到场景中
        viewer.addExternalObject(&quot;text&quot;, group);
        viewer.render();
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://files-cdn.cnblogs.com/files/xhb-bky-blog/addScene.bmp&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在BIMFACE平台实现矢量文本，一般需要四个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择目标字体；&lt;/li&gt;
&lt;li&gt;将目标字体通过转换平台转换成可识别的json文件；&lt;/li&gt;
&lt;li&gt;通过THREEJS的FontLoader导入该文件生成Mesh；&lt;/li&gt;
&lt;li&gt;将该Mesh对象加入到场景中；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下一步将继续探索如何将文本放置在正确的平面位置上。&lt;/p&gt;
&lt;div readability=&quot;8.1842818428184&quot;&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://www.cnblogs.com/xhb-bky-blog&quot;&gt;悠扬的牧笛&lt;/a&gt;&lt;br/&gt;地址：&lt;a href=&quot;https://www.cnblogs.com/xhb-bky-blog/p/12454863.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/xhb-bky-blog/p/12454863.html&lt;/a&gt;&lt;br/&gt;声明：本博客原创文字只代表本人工作中在某一时间内总结的观点或结论，与本人所在单位没有直接利益关系。非商业，未授权贴子请以现状保留，转载时必须保留此段声明，且在文章页面明显位置给出原文连接。&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;



</description>
<pubDate>Mon, 16 Mar 2020 00:52:00 +0000</pubDate>
<dc:creator>悠扬的牧笛</dc:creator>
<og:description>背景 在三维模型产品的设计中，针对空间的管理存在这样一个普遍的需求，那就是在三维模型中，将模型所代表的空间通过附加文本的方式来展示其所代表的实际位置或功能，之前尝试过若干方式，比如直接在建模的时候，将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhb-bky-blog/p/12454863.html</dc:identifier>
</item>
<item>
<title>Flutter json 2 model with Built Value - 圣骑士wind</title>
<link>http://www.cnblogs.com/mengdd/p/flutter-json-2-model-with-built-value.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengdd/p/flutter-json-2-model-with-built-value.html</guid>
<description>&lt;p&gt;Flutter中json转换model, 除了手动转之外, 就是利用第三方库做一些代码生成. 流行的库有: [json_serializable](https://pub.dev/packages/json_serializable)和[built_value](https://pub.dev/packages/built_value) 本文介绍[built_value](https://pub.dev/packages/built_value)的实际使用及问题处理.&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;368.9828493802&quot;&gt;

&lt;p&gt;Flutter中json转换model, 除了手动转之外, 就是利用第三方库做一些代码生成.&lt;br/&gt;流行的库有: &lt;a href=&quot;https://pub.dev/packages/json_serializable&quot;&gt;json_serializable&lt;/a&gt;和&lt;a href=&quot;https://pub.dev/packages/built_value&quot;&gt;built_value&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍&lt;a href=&quot;https://pub.dev/packages/built_value&quot;&gt;built_value&lt;/a&gt;的实际使用及问题处理.&lt;/p&gt;
&lt;h2 id=&quot;flutter中的json转model方法&quot;&gt;Flutter中的json转model方法&lt;/h2&gt;
&lt;p&gt;Flutter中json到model类型的转换可以有多种方式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用官方自带的dart convert中的json解码. 该方法只能将json转换为List或Map, 剩下的工作需要手动完成, 根据key取值赋值给model的字段.&lt;/li&gt;
&lt;li&gt;利用第三方的库, 做代码生成, 流行的库有: &lt;a href=&quot;https://pub.dev/packages/json_serializable&quot;&gt;json_serializable&lt;/a&gt;和&lt;a href=&quot;https://pub.dev/packages/built_value&quot;&gt;built_value&lt;/a&gt;. 原理都是相同的, 先写一些模板代码, 说明一下model是什么样子的, 然后运行命令行生成一些代码, 之后就可以很方便地调用, 将json转换为model了.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用json_serializable可以看:&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍built value的使用.&lt;/p&gt;
&lt;h2 id=&quot;built-value使用指南&quot;&gt;built value使用指南&lt;/h2&gt;
&lt;p&gt;实例: 用github api拿到的events: https://api.github.com/events?per_page=10&lt;br/&gt;如何转化成model对象呢?&lt;/p&gt;
&lt;h3 id=&quot;tdd&quot;&gt;TDD&lt;/h3&gt;
&lt;p&gt;先写个测试, 明确一下我们想要的目标.&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;test&lt;/code&gt;下建立一个文件, 比如叫&lt;code&gt;json_test.dart&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;里面写main函数和两个测试:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void main() {
  test(&quot;parse events list&quot;, () {
    const jsonString = &quot;&quot;&quot;replace with events list json string&quot;&quot;&quot;;

    expect(Event.fromEventsListJson(jsonString).first.id, &quot;11732023561&quot;);
  });

  test(&quot;parse event&quot;, () {
    const jsonString = &quot;&quot;&quot;replace with event json string&quot;&quot;&quot;;

    expect(Event.fromJson(jsonString).id, &quot;11732036753&quot;);
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面应该放json字符串的, 太长了我就省略了, 这样看比较清晰.&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;之后可以支持多行. (IDE里面可以折叠的.)&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;Event&lt;/code&gt;类和方法我们都还没有写, 所以暂时报错.&lt;/p&gt;
&lt;h3 id=&quot;setup&quot;&gt;setup&lt;/h3&gt;
&lt;p&gt;添加依赖, 去package页面看添加什么版本: https://pub.dev/packages/built_value&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;pubspec.yaml&lt;/code&gt;中添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies:
  flutter:
    sdk: flutter

  # other dependencies here

  built_value: ^7.0.9
  built_collection: ^4.3.2

dev_dependencies:
  flutter_test:
    sdk: flutter

  # other dev_dependencies here

  build_runner: ^1.8.0
  built_value_generator: ^7.0.9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后点&lt;code&gt;Packages get&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;live-templates&quot;&gt;Live Templates&lt;/h3&gt;
&lt;p&gt;这个是IntelliJ系IDE(包括Android Studio)的快捷设置, 目的是为了减少手动输入. (可选.)&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;Preferences&lt;/code&gt;, 搜&lt;code&gt;Live Templates&lt;/code&gt;.&lt;br/&gt;在&lt;code&gt;Dart&lt;/code&gt;的部分点+号新增一个Live Template.&lt;/p&gt;
&lt;p&gt;下面Abbreviation选一个适当的缩写, 比如&lt;code&gt;built&lt;/code&gt;.&lt;br/&gt;Template text贴入这段:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class $CLASS_NAME$ implements Built&amp;lt;$CLASS_NAME$, $CLASS_NAME$Builder&amp;gt; {
  $CLASS_NAME$._();
  factory $CLASS_NAME$([void Function($CLASS_NAME$Builder) updates]) = _$$$CLASS_NAME$;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Applicable in Dart选: top-level.&lt;/p&gt;
&lt;p&gt;建好之后以后就直接用啦.&lt;/p&gt;
&lt;h3 id=&quot;建立models抽象类&quot;&gt;建立models抽象类&lt;/h3&gt;
&lt;p&gt;输入刚才建立的live template的关键字&lt;code&gt;built&lt;/code&gt;, 就会出现要生成的代码, 其中写好自己的类名.&lt;/p&gt;
&lt;p&gt;比如我们要建立的model类型是&lt;code&gt;Event&lt;/code&gt;类.&lt;br/&gt;新建&lt;code&gt;event.dart&lt;/code&gt;文件.&lt;/p&gt;
&lt;p&gt;在其中输入&lt;code&gt;built&lt;/code&gt;按确认之后, 输入类名&lt;code&gt;Event&lt;/code&gt;, 就建好了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class Event implements Built&amp;lt;Event, EventBuilder&amp;gt; {
  Event._();
  factory Event([void Function(EventBuilder) updates]) = _$Event;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包括一个私有构造和一个工厂方法. 此时会有一些红色的报错.&lt;br/&gt;这里&lt;code&gt;import 'package:built_value/built_value.dart'&lt;/code&gt;消除&lt;code&gt;Built&lt;/code&gt;类的报错.&lt;/p&gt;
&lt;p&gt;根据观察API: https://api.github.com/events 返回的json, 发现还应该有&lt;code&gt;Actor&lt;/code&gt;, &lt;code&gt;Repo&lt;/code&gt;, &lt;code&gt;Payload&lt;/code&gt;三个类.&lt;br/&gt;也都按这个方法建立好.&lt;/p&gt;
&lt;p&gt;然后在其中添加字段, 现在看起来是这样了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import 'package:built_value/built_value.dart';
// imports for models

part 'event.g.dart';

abstract class Event implements Built&amp;lt;Event, EventBuilder&amp;gt; {
  String get id;

  String get type;

  Actor get actor;

  Repo get repo;

  Payload get payload;

  bool get public;

  String get createdAt;

  Event._();

  factory Event([void Function(EventBuilder) updates]) = _$Event;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很重要的一步, 就是在类前面添加上一句: &lt;code&gt;part 'event.g.dart';&lt;/code&gt;.&lt;br/&gt;&lt;code&gt;g.dart&lt;/code&gt;是一个惯例, 表明这个文件是生成的代码. &lt;code&gt;part&lt;/code&gt;表示目前这个文件是另一个文件的一部分.&lt;/p&gt;
&lt;p&gt;按照同样的方法把几个类都建好.&lt;/p&gt;
&lt;p&gt;注意如果有列表字段, 要声明为&lt;code&gt;BuiltList&lt;/code&gt;类型.&lt;/p&gt;
&lt;h3 id=&quot;运行生成命令&quot;&gt;运行生成命令&lt;/h3&gt;
&lt;p&gt;生成命令:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter packages pub run build_runner build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要持续构建和可以用:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter packages pub run build_runner watch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就不用每次改完代码都需要跑一次命令了.&lt;/p&gt;
&lt;p&gt;我们这里用watch, 因为还没有改完.&lt;br/&gt;运行完成之后, 可以看到&lt;code&gt;.g.dart&lt;/code&gt;的文件们都生成了, 报错也消失了.&lt;/p&gt;
&lt;h3 id=&quot;写serializers&quot;&gt;写Serializers&lt;/h3&gt;
&lt;p&gt;新建文件&lt;code&gt;serializers.dart&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import 'package:built_value/serializer.dart';
import 'package:built_value/standard_json_plugin.dart';

// imports for models

part 'serializers.g.dart';

@SerializersFor(const [
  Event,
  Actor,
  Repo,
  Payload,
])
final Serializers serializers =
    (_$serializers.toBuilder()..addPlugin(StandardJsonPlugin())).build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@SerializersFor&lt;/code&gt;里面列出想要序列化的类.&lt;/p&gt;
&lt;p&gt;注意这里要加上&lt;code&gt;StandardJsonPlugin&lt;/code&gt;, 因为built value的json格式不是标准的, 而是所有字段逗号分隔的.&lt;br/&gt;用了&lt;code&gt;StandardJsonPlugin&lt;/code&gt;之后就转换成了标准的JSON格式.&lt;/p&gt;
&lt;p&gt;因为我们跑命令的时候用的是&lt;code&gt;watch&lt;/code&gt;, 所以保存修改后&lt;code&gt;serializers.g.dart&lt;/code&gt;文件此时自动生成了.&lt;/p&gt;
&lt;h3 id=&quot;添加model序列化和反序列化代码&quot;&gt;添加model序列化和反序列化代码&lt;/h3&gt;
&lt;p&gt;在Event类中添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  static Serializer&amp;lt;Event&amp;gt; get serializer =&amp;gt; _$eventSerializer;

  String toJson() {
    return json.encode(serializers.serializeWith(Event.serializer, this));
  }

  static Event fromJson(String jsonString) {
    return serializers.deserializeWith(
        Event.serializer, json.decode(jsonString));
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;import中除了model类还有:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import 'dart:convert';

import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';
import 'serializers.dart';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时其他几个model类也要添加&lt;code&gt;serializer&lt;/code&gt;, 比如&lt;code&gt;Actor&lt;/code&gt;类中添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static Serializer&amp;lt;Actor&amp;gt; get serializer =&amp;gt; _$actorSerializer;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新build生成代码, 报错消失.&lt;/p&gt;
&lt;p&gt;现在可以运行测试:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  test(&quot;parse event&quot;, () {
    const jsonString = &quot;&quot;&quot;replace with event json string&quot;&quot;&quot;;

    expect(Event.fromJson(jsonString).id, &quot;11732036753&quot;);
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来检验单个的Event model建立.&lt;/p&gt;
&lt;p&gt;可能会遇到的失败情况:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一些字段需要被标记为可为空&lt;code&gt;@nullable&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;一些字段名和key不匹配, 用&lt;code&gt;@BuiltValueField&lt;/code&gt;的&lt;code&gt;wireName&lt;/code&gt;标记.&lt;br/&gt;详见后面的&lt;code&gt;Troubleshooting&lt;/code&gt;部分.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何反序列化顶层列表&quot;&gt;如何反序列化顶层列表?&lt;/h3&gt;
&lt;p&gt;Event的API返回的是一个Event的数组: &lt;code&gt;[]&lt;/code&gt;. 这种怎么做呢?&lt;/p&gt;
&lt;p&gt;这里有个issue就是关于这个问题, 里面的解决办法挺好: https://github.com/google/built_value.dart/issues/565&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;serializers.dart&lt;/code&gt;中添加方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;T deserialize&amp;lt;T&amp;gt;(dynamic value) =&amp;gt;
    serializers.deserializeWith&amp;lt;T&amp;gt;(serializers.serializerForType(T), value);

BuiltList&amp;lt;T&amp;gt; deserializeListOf&amp;lt;T&amp;gt;(dynamic value) =&amp;gt; BuiltList.from(
    value.map((value) =&amp;gt; deserialize&amp;lt;T&amp;gt;(value)).toList(growable: false));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;BuiltList&lt;/code&gt;需要&lt;code&gt;import 'package:built_collection/built_collection.dart';&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;反序列化&lt;code&gt;Event&lt;/code&gt;数组的方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  static List&amp;lt;Event&amp;gt; fromEventsListJson(String jsonString) {
    final BuiltList&amp;lt;Event&amp;gt; listOfEvents =
        deserializeListOf&amp;lt;Event&amp;gt;(json.decode(jsonString));
    return listOfEvents.toList();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这一步, 跑我们开头写的两个测试应该都绿了. 如果没绿见&lt;code&gt;Troubleshooting&lt;/code&gt;部分.&lt;/p&gt;
&lt;h3 id=&quot;泛型的fromjson方法.&quot;&gt;泛型的fromJson方法.&lt;/h3&gt;
&lt;p&gt;上面给&lt;code&gt;serializers&lt;/code&gt;中添加了两个方法. 其中第一个方法是一个泛型的&lt;code&gt;fromJson&lt;/code&gt;方法.&lt;/p&gt;
&lt;p&gt;我们测试中的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expect(Event.fromJson(jsonString).id, &quot;11732036753&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以这样写:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expect(deserialize&amp;lt;Event&amp;gt;(json.decode(jsonString)).id, &quot;11732036753&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样不用给每一个类都写一个&lt;code&gt;fromJson&lt;/code&gt;方法了.&lt;/p&gt;
&lt;h2 id=&quot;troubleshooting&quot;&gt;Troubleshooting&lt;/h2&gt;
&lt;p&gt;可能会有的报错, 问题原因和解决方式.&lt;/p&gt;
&lt;h3 id=&quot;报错1-failed-due-to-invalid-arguments-unknown-type-on-deserialization.-need-either-specifiedtype-or-discriminator-field.&quot;&gt;报错1: &lt;code&gt;failed due to: Invalid argument(s): Unknown type on deserialization. Need either specifiedType or discriminator field.&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;比如这个样子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Deserializing '[id, 11732036753, type, PushEvent, actor, {id: 54496419, login: supershell201...' to 'Event' failed due to: Invalid argument(s): Unknown type on deserialization. Need either specifiedType or discriminator field.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为&lt;code&gt;Event&lt;/code&gt;中依赖的类(&lt;code&gt;Actor&lt;/code&gt;, &lt;code&gt;Repo&lt;/code&gt;, &lt;code&gt;Payload&lt;/code&gt;)没有添加serializer.&lt;/p&gt;
&lt;p&gt;比如&lt;code&gt;Actor&lt;/code&gt;中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static Serializer&amp;lt;Actor&amp;gt; get serializer =&amp;gt; _$actorSerializer;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加上重新build生成代码即可.&lt;/p&gt;
&lt;h3 id=&quot;报错2-tried-to-construct-class-xxx-with-null-field&quot;&gt;报错2: &lt;code&gt;Tried to construct class &quot;XXX&quot; with null field&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Deserializing '[id, 11732036753, type, PushEvent, actor, {id: 54496419, login: supershell201...' to 'Event' failed due to: Deserializing '[id, 54496419, login, supershell2019, display_login, supershell2019, gravatar...' to 'Actor' failed due to: Tried to construct class &quot;Actor&quot; with null field &quot;displayLogin&quot;. This is forbidden; to allow it, mark &quot;displayLogin&quot; with @nullable.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时, 先不要着急把字段标记为&lt;code&gt;@nullable&lt;/code&gt;.&lt;br/&gt;而是要看这个字段是否真的为null, 很有可能是因为字段名称和json中的key不匹配造成的, 比如json中是个蛇形命名.&lt;/p&gt;
&lt;p&gt;查看了一下果然就是, 解决办法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @BuiltValueField(wireName: 'display_login')
  String get displayLogin;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果字段真的是有可能为null的情况, 那么加上&lt;code&gt;@nullable&lt;/code&gt;:&lt;br/&gt;比如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @BuiltValueField(wireName: 'ref_type')
  @nullable
  String get refType;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;报错3-formatexception-control-character-in-string&quot;&gt;报错3: &lt;code&gt;FormatException: Control character in string&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FormatException: Control character in string (at line 25, character 129)
... replica::on_client_write(dsn::message_ex *request, bool ignore_throttling)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关issue: https://github.com/dart-lang/convert/issues/10&lt;/p&gt;
&lt;p&gt;解决的办法就是在测试的字符串声明前加一个&lt;code&gt;r&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const jsonString = r&quot;&quot;&quot;replace with events list json string&quot;&quot;&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;model生成工具推荐&quot;&gt;Model生成工具推荐&lt;/h2&gt;
&lt;p&gt;有个很棒的工具: https://charafau.github.io/json2builtvalue/&lt;br/&gt;左边输入json字符串, 写好命名, 点击之后右边就会出现那些本来需要手动写的代码.&lt;/p&gt;
&lt;p&gt;生成的&lt;code&gt;Event&lt;/code&gt;类是这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;library event;

import 'dart:convert';

import 'package:built_collection/built_collection.dart';
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';

part 'event.g.dart';

abstract class Event implements Built&amp;lt;Event, EventBuilder&amp;gt; {
  Event._();

  factory Event([updates(EventBuilder b)]) = _$Event;

  @BuiltValueField(wireName: 'id')
  String get id;
  @BuiltValueField(wireName: 'type')
  String get type;
  @BuiltValueField(wireName: 'actor')
  Actor get actor;
  @BuiltValueField(wireName: 'repo')
  Repo get repo;
  @BuiltValueField(wireName: 'payload')
  Payload get payload;
  @BuiltValueField(wireName: 'public')
  bool get public;
  @BuiltValueField(wireName: 'created_at')
  String get createdAt;
  String toJson() {
    return json.encode(serializers.serializeWith(Event.serializer, this));
  }

  static Event fromJson(String jsonString) {
    return serializers.deserializeWith(
        Event.serializer, json.decode(jsonString));
  }

  static Serializer&amp;lt;Event&amp;gt; get serializer =&amp;gt; _$eventSerializer;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈, 看到这里是不是有种被骗了的感觉.&lt;/p&gt;
&lt;p&gt;有了这个很棒的工具之后根本不用自己很小心地写一个一个model类了, 只需要写一个&lt;code&gt;serializers.dart&lt;/code&gt;文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;part 'serializers.g.dart';

@SerializersFor(const [
  Event,
  Actor,
  Repo,
  Payload,
])
final Serializers serializers =
    (_$serializers.toBuilder()..addPlugin(StandardJsonPlugin())).build();

T deserialize&amp;lt;T&amp;gt;(dynamic value) =&amp;gt;
    serializers.deserializeWith&amp;lt;T&amp;gt;(serializers.serializerForType(T), value);

BuiltList&amp;lt;T&amp;gt; deserializeListOf&amp;lt;T&amp;gt;(dynamic value) =&amp;gt; BuiltList.from(
    value.map((value) =&amp;gt; deserialize&amp;lt;T&amp;gt;(value)).toList(growable: false));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把要反序列化的类加进来, 再跑命令行生成代码, 就可以了.&lt;/p&gt;
&lt;p&gt;经历一下前面的手动过程可能理解得更好一些, 也知道各种问题的原因.&lt;br/&gt;以后使用直接用工具就方便多了.&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;官方文档: https://flutter.dev/docs/development/data-and-backend/json&lt;/li&gt;
&lt;li&gt;Flutter实战11.7: https://book.flutterchina.club/chapter11/json_model.html&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/built_value.dart&quot;&gt;built value github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;生成工具: https://charafau.github.io/json2builtvalue/&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Mon, 16 Mar 2020 00:37:00 +0000</pubDate>
<dc:creator>圣骑士wind</dc:creator>
<og:description>Flutter中json转换model, 除了手动转之外, 就是利用第三方库做一些代码生成.  流行的库有: [json_serializable](https://pub.dev/packages/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengdd/p/flutter-json-2-model-with-built-value.html</dc:identifier>
</item>
<item>
<title>Java Grammar（二）：运算符 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12501717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12501717.html</guid>
<description>&lt;h3 id=&quot;运算符简介&quot;&gt;运算符简介&lt;/h3&gt;
&lt;p&gt;计算机自打诞生以来，用作最多的就是进行&lt;strong&gt;计算&lt;/strong&gt;，而计算离不开运算符，所以运算符在我们的Java语言中的地位举足轻重，我们现在就来了解一下Java给我们提供的运算符。&lt;/p&gt;
&lt;p&gt;从运算的元素的个数来区分，可以分为一元运算符，二元运算符，三元运算符。&lt;/p&gt;
&lt;p&gt;其中一元运算符包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;+（正数）&lt;/li&gt;
&lt;li&gt;-（负数）&lt;/li&gt;
&lt;li&gt;++（自增1）&lt;/li&gt;
&lt;li&gt;—（自减1）&lt;/li&gt;
&lt;li&gt;~（按位取反）&lt;/li&gt;
&lt;li&gt;!（逻辑取反）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实自增和自减也可以看成是特殊的二元运算符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二元运算符包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算术运算符：&lt;code&gt;+ ，-，*，/，%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;逻辑运算符：&lt;code&gt;&amp;amp;&amp;amp;，||&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关系运算符：&lt;code&gt;==，!=，&amp;gt;，&amp;lt;，&amp;gt;=，&amp;lt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;位运算符：&lt;code&gt;&amp;amp;，|，^，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;赋值运算符：&lt;code&gt;=，+=，-=，*=，/=，%=，&amp;lt;&amp;lt;=，&amp;gt;&amp;gt;=，&amp;amp;=，^=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;instanceof运算符：&lt;code&gt;instanceof&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三元运算符就只有一种：&lt;code&gt;？：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006tNc79gy1g5vscu7kf5j30tq0kcgnd.jpg&quot; alt=&quot;7CF6586D-17A7-43B7-BC31-A29EBDD1B23A&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些运算相信绝大部分已经被在座的各位所熟知，只有极个别的不是很清楚的，下面我所了解的一些面试热点知识来进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;一些运算符的小常识&quot;&gt;一些运算符的小常识&lt;/h3&gt;
&lt;h4 id=&quot;自增自减的前后位置&quot;&gt;自增，自减的前后位置&lt;/h4&gt;
&lt;p&gt;老生常谈的一个问题，但是还是容易被搞混，自增和自减的顺序前后到底有何不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单独使用&lt;/strong&gt;的时候，两种&lt;strong&gt;没有&lt;/strong&gt;任何区别（温馨提示：&lt;strong&gt;面试的时候切记不要忘记第一点哟&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;表达式&lt;/strong&gt;中使用的时候，前缀会&lt;strong&gt;先进行&lt;/strong&gt;+1（-1）的运算，而后缀会先运算&lt;strong&gt;后进行&lt;/strong&gt;+1（-1）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在无视掉第一种情况的下，可以简单记为&lt;strong&gt;前缀前，后缀后&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;逻辑运算符的短路特性&quot;&gt;逻辑运算符的短路特性&lt;/h4&gt;
&lt;p&gt;我们在使用逻辑运算符&lt;code&gt;&amp;amp;&amp;amp;,||&lt;/code&gt;的时候，可以利用逻辑运算符的短路特性减少运算次数，所谓短路特性就是&lt;strong&gt;当第一个条件可以判断最终结果的时候，就不会去判断第二个条件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;A &amp;amp;&amp;amp; B (当A为false，直接跳过第二个条件的判断，判定为false)
A || B (当A为true，直接跳过第二个条件的判断，判定为true)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三元运算符&quot;&gt;三元运算符&lt;/h4&gt;
&lt;p&gt;该运算符的主要是决定哪个值应该赋值给变量。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        int a , b;
    a = 10;
    // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
    b = (a == 1) ? 20 : 30;
    System.out.println( &quot;Value of b is : &quot; +  b );
    // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
    b = (a == 10) ? 20 : 30;
    System.out.println( &quot;Value of b is : &quot; + b );&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;instanceof&quot;&gt;instanceof&lt;/h4&gt;
&lt;p&gt;该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Vehicle a = new Car();
boolean result =  a instanceof Car;
System.out.println( result);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;位运算符&quot;&gt;位运算符&lt;/h3&gt;
&lt;p&gt;位运算符可能在我们日常中使用的并不是很多，算是一个小盲区。但是其实这个运算符还是非常的重要的，我们首先来了解一下运算的机制，与其他运算符不同的是，位运算符是要讲数值转换成二进制后，再进行运算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tNc79gy1g5vsebfv8uj30o00d8wht.jpg&quot; alt=&quot;95D04C0D-1F8E-483D-9737-7FA44129BE31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006tNc79gy1g5vsej2kc3j30qi0cqdj9.jpg&quot; alt=&quot;AD20CC8F-CAFD-4C48-94BD-ABED28D279AE&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt;是按位异或运算符，只有两个对应的运算位不一致的时候，对应计算出的位置为1，否则为0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;~&lt;/code&gt;是按位取反运算符，将每一位取反（1 -&amp;gt; 0，0 -&amp;gt;1）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79gy1g5vsf7vdshj310u0b0tbz.jpg&quot; alt=&quot;57BB3EC6-07B2-4B57-B9CC-2A3FFA4DFD33&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;存在一定的区别：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ：该数对应的二进制码整体右移，左边的用&lt;strong&gt;原有标志位&lt;/strong&gt;补充，右边超出的部分舍弃。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; ：不管正负标志位为0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。&lt;/p&gt;
&lt;p&gt;其余操作部分与&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;类似，就不再画图演示&lt;/p&gt;
&lt;h4 id=&quot;位运算符的运用场景&quot;&gt;位运算符的运用场景&lt;/h4&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;计算 &lt;span class=&quot;math inline&quot;&gt;\(m * 2^n\)&lt;/span&gt; 次方&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2 &amp;lt;&amp;lt; 3 = 16;
2 * (2 * 2 * 2) = 16;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;判断一个数n的奇偶性&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;a &amp;amp; 1 = 0; // 偶数
a &amp;amp; 1 = 1; // 奇数&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;不用临时变量交换两个数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;a = a^b; 
b = b^a; 
a = a^b; &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;x 的 相反数 表示为 (~x+1)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-x = (~x+1)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;取绝对值 (a^(a&amp;gt;&amp;gt;31))-(a&amp;gt;&amp;gt;31)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其余的一些在算法中用到的场景，我这里就不再多少，有兴趣的同学可以去研究一下~&lt;/p&gt;
&lt;h3 id=&quot;运算符优先级&quot;&gt;运算符优先级&lt;/h3&gt;
&lt;p&gt;最高优先级的在该表上方，最低优先级的在该表底部&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;后缀&lt;/td&gt;
&lt;td&gt;（）[].(点操作符)&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;一元&lt;/td&gt;
&lt;td&gt;++ - ！~&lt;/td&gt;
&lt;td&gt;右到左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;乘性&lt;/td&gt;
&lt;td&gt;* / %&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;加性&lt;/td&gt;
&lt;td&gt;+ -&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;移位&lt;/td&gt;
&lt;td&gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;关系&lt;/td&gt;
&lt;td&gt;&amp;gt; &amp;gt;= = &amp;lt; &amp;lt;=&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;相等&lt;/td&gt;
&lt;td&gt;== ~=&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;按位与&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;按位异或&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;按位或&lt;/td&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;逻辑与&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;逻辑或&lt;/td&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;条件&lt;/td&gt;
&lt;td&gt;？：&lt;/td&gt;
&lt;td&gt;从右到左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;赋值&lt;/td&gt;
&lt;td&gt;=，+=，-=，等等&lt;/td&gt;
&lt;td&gt;从右到左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;逗号&lt;/td&gt;
&lt;td&gt;，&lt;/td&gt;
&lt;td&gt;左到右&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;动动小手点点关注，就是对创作者最大的支持和赞同&lt;br/&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-15-qrcode_for_gh_a65beceb0947_258.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Mar 2020 00:35:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>运算符简介 计算机自打诞生以来，用作最多的就是进行 计算 ，而计算离不开运算符，所以运算符在我们的Java语言中的地位举足轻重，我们现在就来了解一下Java给我们提供的运算符。 从运算的元素的个数来区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12501717.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.11：回暖的 GitHub 迎来上千星的图片流项目 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12500926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12500926.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225340557-1872478769.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;摘要：连着两周成绩平平的 GitHub Trending 榜，终于和三月的天气一样进入全面变暖的模式，无论是本周刚开源搭乘 ocr 热点并获得 1,500+ star 的 chineseocr_lite，还是借着国外疫情大爆发这股“东风”一周获得近 5,000+ star 的可视化项目 COVID-19，或是 Google Drive 升级版可备份的云盘项目 MyDrive 都交上了不错的成绩单，500，1,000，2,000…这是本周 GitHub 新生项的成绩单，当然老而弥坚的 GitHub 老项目表现也不错，你可以在本周的 #尚能星否 GitHub 老项目# 看到他们不孬的表现，当然本周的安全主题收录的 3 个项目也是高 star 项，值得一马。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自上周微博的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间超过 30 天的项目一律称之为成熟稳重老项目，由于文章篇幅问题还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;可怕 GitHub 新生&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 中文 ocr：chineseocr_lite&lt;/li&gt;
&lt;li&gt;1.2 可视化疫情数据：COVID-19&lt;/li&gt;
&lt;li&gt;1.3 先马为敬：ultimate-coding-resources&lt;/li&gt;
&lt;li&gt;1.4 升级版 Google Drive&lt;/li&gt;
&lt;li&gt;1.5 个性化的 Apple Music：AppleMusicUltra&lt;/li&gt;
&lt;li&gt;1.6 专属图片流：photo-stream&lt;/li&gt;
&lt;li&gt;1.7 预训练工具：ELECTRA&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;尚能星否 GitHub 老项目&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 数据同步：DataX&lt;/li&gt;
&lt;li&gt;2.2 软件逆向：Ghidra&lt;/li&gt;
&lt;li&gt;2.3 正则快速入门：learn-regex&lt;/li&gt;
&lt;li&gt;2.4 payload 大全：Payloads All The Things&lt;/li&gt;
&lt;li&gt;2.5 后台管理：EL-ADMIN&lt;/li&gt;
&lt;li&gt;2.6 计算机视觉库：Kornia&lt;/li&gt;
&lt;li&gt;2.7 自动生成字幕：video-srt-windows&lt;/li&gt;
&lt;li&gt;2.8 Sweet Java：Hutool&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周 GitHub Trending #安全#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 变身黑客：TheFatRat&lt;/li&gt;
&lt;li&gt;3.2 安全测试伴侣：SecLists&lt;/li&gt;
&lt;li&gt;3.3 安全第一：Dangerzone&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可怕-github-新生&quot;&gt;1. 可怕 GitHub 新生&lt;/h2&gt;
&lt;h3 id=&quot;中文-ocrchineseocr_lite&quot;&gt;1.1 中文 ocr：chineseocr_lite&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1750+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;chineseocr_lite 是个超轻量级中文 ocr，支持竖排文字识别，支持 ncnn 推理，总模型仅 17M，包含 psenet (8.5M)、crnn (6.3M)、anglenet (1.5M)。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.2903225806452&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/ouyanghuiyu/chineseocr_lite&quot; class=&quot;uri&quot;&gt;https://github.com/ouyanghuiyu/chineseocr_lite&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225351519-964856009.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;可视化疫情数据covid-19&quot;&gt;1.2 可视化疫情数据：COVID-19&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：4700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着国外 nCoV 进入爆发式增长，GitHub 上关于 nCoV 的项目也跟着“水涨船高”，COVID-19 是 Johns Hopkins 大学系统科学与工程中心开源的 COVID-19 全球疫情数据可视化图，该项目已在 GitHub Trending 榜上呆过一周，且可实时查看到最新数据。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3793103448276&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/CSSEGISandData/COVID-19&quot; class=&quot;uri&quot;&gt;https://github.com/CSSEGISandData/COVID-19&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225400267-1015676647.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;先马为敬ultimate-coding-resources&quot;&gt;1.3 先马为敬：ultimate-coding-resources&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ultimate-coding-resources，美其名曰：无尽的编程技巧源泉，它收录了编程、Web 开发、计算科学等方面的最佳实践，并将它分类成书籍、课程、Coding 网站、算法平台、组件库、文档、招聘、黑客马拉松、工具、Chrome 扩展等等 10+ 大类，而且每个分类尽量全面地收录对应的资源，如果你要编程之类的资源不妨先搜索下这个项目是否已帮你收录了 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;1.0810810810811&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/PizzaPokerGuy/ultimate-coding-resources&quot; class=&quot;uri&quot;&gt;https://github.com/PizzaPokerGuy/ultimate-coding-resources&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;升级版-google-drive&quot;&gt;1.4 升级版 Google Drive&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyDrive 是一个用 Node.js、React 和 MongoDB 搭建的类 Google Drive 项目，此外，MyDrive 还提供了一些内置服务器工具，比如备份数据库、还原数据库等操作，用 MyDrive 再也不怕删除东西之后说找不回来了。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6326530612245&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/subnub/myDrive&quot; class=&quot;uri&quot;&gt;https://github.com/subnub/myDrive&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225410930-498431330.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;个性化的-apple-musicapplemusicultra&quot;&gt;1.5 个性化的 Apple Music：AppleMusicUltra&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AppleMusicUltra 是一个用 Swift 开发的音乐应用，它用 WKWebView 组件、CSS、Javascript 技术实现音乐播放器个性化的自定义设置，如果你想学习 WKWebView 不妨试试这个项目。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3559322033898&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/revblaze/AppleMusicUltra&quot; class=&quot;uri&quot;&gt;https://github.com/revblaze/AppleMusicUltra&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225436964-408330780.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;专属图片流photo-stream&quot;&gt;1.6 专属图片流：photo-stream&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;photo-stream 是一个刚开源仅仅用于托管图片的项目。喜欢拍照分享的我们在社交平台很难拥有图片的所有权，为此项目作者制作了这个用于存放图片的项目，你可以自托管你的图片并在 Netlify、GitHub Pages 等地方使用。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4035087719298&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/maxvoltar/photo-stream&quot; class=&quot;uri&quot;&gt;https://github.com/maxvoltar/photo-stream&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225451488-1543932353.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;预训练工具electra&quot;&gt;1.7 预训练工具：ELECTRA&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ELECTRA 是一种新的自监督语言表示学习方法，它可以用相对较少的计算量对变压器网络进行预训练。ELECTRA 模型被训练来区分“真实的”输入标记和由另一个神经网络产生的“虚假的”输入标记，类似于 GAN 鉴别器。在小范围内，ELECTRA 甚至可以在单 GPU 上实现强大的性能。在大范围内，ELECTRA 在 SQuAD 2.0 数据集上实现了最先进的结果。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3793103448276&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/google-research/electra&quot; class=&quot;uri&quot;&gt;https://github.com/google-research/electra&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;!&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225501964-1988011129.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;尚能星否-github-老项目&quot;&gt;2. 尚能星否 GitHub 老项目&lt;/h2&gt;
&lt;h3 id=&quot;数据同步datax&quot;&gt;2.1 数据同步：DataX&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DataX 是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS 等各种异构数据源之间高效的数据同步功能。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/alibaba/DataX&quot; class=&quot;uri&quot;&gt;https://github.com/alibaba/DataX&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225516047-638588528.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;软件逆向ghidra&quot;&gt;2.2 软件逆向：Ghidra&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ghidra 是美国国家安全局(NSA)开源的一个软件逆向工程（SRE）框架，包括一套功能齐全的高端软件分析工具，使用户能够在各种平台上分析编译后的代码，支持 Windows、MacOS 和 Linux。&lt;/p&gt;
&lt;p&gt;Ghidra 支持的功能包括反汇编，汇编，反编译，绘图和脚本，以及数百个其他功能，它也支持各种处理器指令集和可执行格式，可以在用户交互模式和自动模式下运行，你还可以用公开的 API 开发自己的 Ghidra 插件和脚本。&lt;/p&gt;
&lt;blockquote readability=&quot;1.25&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/NationalSecurityAgency/ghidra&quot; class=&quot;uri&quot;&gt;https://github.com/NationalSecurityAgency/ghidra&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;正则快速入门learn-regex&quot;&gt;2.3 正则快速入门：learn-regex&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么？你还不回正则？不妨试试 learn-regex，它可以让你快速学会正则表达式，它详细地讲解了每种场景下正则实现的原理，并配有对应的在线练习，让你更好地掌握正则使用。目前该项目已经被翻译成中文、日文、英文、法语等 10 + 个语言版本，Star 超 30k+。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4285714285714&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot; class=&quot;uri&quot;&gt;https://github.com/ziishaned/learn-regex&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225526713-1486207843.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;payload-大全payloads-all-the-things&quot;&gt;2.4 payload 大全：Payloads All The Things&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Payloads All The Things 收录可用于 Web 应用安全防护的有效负载及绕过现有规则的技能。它每个章节都包含以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;README：描述了漏洞以及如何利用漏洞&lt;/li&gt;
&lt;li&gt;Intruder：给 Burp Intruder 用的一组文件&lt;/li&gt;
&lt;li&gt;Images：给 README 用的图片&lt;/li&gt;
&lt;li&gt;Files：README 会引用的一些文件&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1.1940298507463&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/swisskyrepo/PayloadsAllTheThings&quot; class=&quot;uri&quot;&gt;https://github.com/swisskyrepo/PayloadsAllTheThings&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;后台管理el-admin&quot;&gt;2.5 后台管理：EL-ADMIN&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eladmin 是一个基于 Spring Boot 2.1.0 、 Jpa、 Spring Security、redis、Vue的前后端分离的后台管理系统，项目采用分模块开发方式， 权限控制采用 RBAC，支持数据字典与数据权限管理，支持一键生成前后端代码，支持动态路由&lt;/p&gt;
&lt;blockquote readability=&quot;1.6326530612245&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/elunez/eladmin&quot; class=&quot;uri&quot;&gt;https://github.com/elunez/eladmin&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225536377-816747234.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算机视觉库kornia&quot;&gt;2.6 计算机视觉库：Kornia&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kornia 是一个基于 PyTorch 的可微分计算机视觉库，它包含了一组例程和可微分模块，并致力于解决通用计算机视觉问题。在 Kornia 的核心代码中，它使用 PyTorch 作为主要后端，并高效地利用反向模式自动微分机制来定义并计算复杂函数的梯度。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/kornia/kornia&quot; class=&quot;uri&quot;&gt;https://github.com/kornia/kornia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225545431-2105377190.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自动生成字幕video-srt-windows&quot;&gt;2.7 自动生成字幕：video-srt-windows&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;video-srt-windows 是用 Go 编写的可用于识别视频语音自动生成字幕 SRT 文件的开源 Windows-GUI 软件工具，适用于快速、批量的为视频创建中/英文字幕文件的业务场景。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.3559322033898&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/wxbool/video-srt-windows&quot; class=&quot;uri&quot;&gt;https://github.com/wxbool/video-srt-windows&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225555355-2097408035.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sweet-javahutool&quot;&gt;2.8 Sweet Java：Hutool&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：350+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hutool 是一个小而全的 Java 工具类库，通过静态方法封装，降低相关 API 的学习成本，提高工作效率，使 Java 拥有函数式语言般的优雅，让 Java 语言也可以“甜甜的。Hutool 的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。&lt;/p&gt;
&lt;p&gt;以计算 MD5 为例：&lt;br/&gt;【以前】打开搜索引擎 -&amp;gt; 搜“Java MD5加密” -&amp;gt; 打开某篇博客-&amp;gt; 复制粘贴 -&amp;gt; 改改好用&lt;br/&gt;【现在】引入 Hutool -&amp;gt; SecureUtil.md5()&lt;br/&gt;Hutool 的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的 bug。&lt;/p&gt;
&lt;blockquote readability=&quot;1.7021276595745&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/looly/hutool&quot; class=&quot;uri&quot;&gt;https://github.com/looly/hutool&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225604594-1123130796.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本周-github-trending-安全主题的主力军&quot;&gt;3. 本周 GitHub Trending #安全#主题的主力军&lt;/h2&gt;
&lt;p&gt;无论是前端还是后端，还是运维同学，安全都是大家需要考虑的第一要素，，在这里小鱼干给你分享 3 个本周 GitHub Trending 上和安全相关的项目，希望这 3 个项目能让你的项目“平平安安”~&lt;/p&gt;
&lt;h3 id=&quot;变身黑客thefatrat&quot;&gt;3.1 变身黑客：TheFatRat&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：250+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TheFatRat 是一种利用恶意软件编译具有著名负载的恶意软件，然后可以在 Linux，Windows，Mac 和Android 上执行该恶意软件。TheFatRat 提供了一种轻松创建后门和有效负载的方法，可以绕过大多数防病毒软件。特征&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全自动MSFvenom和Metasploit&lt;/li&gt;
&lt;li&gt;本地或远程侦听器生成&lt;/li&gt;
&lt;li&gt;按类别轻松地制作后门操作系统&lt;/li&gt;
&lt;li&gt;生成各种格式的有效载荷&lt;/li&gt;
&lt;li&gt;绕过反病毒后门&lt;/li&gt;
&lt;li&gt;可用于增加文件大小的文件泵&lt;/li&gt;
&lt;li&gt;能够检测外部 IP 和接口地址&lt;/li&gt;
&lt;li&gt;自动创建用于 USB / CDROM 的 AutoRun 文件&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1.4814814814815&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/Screetsec/TheFatRat&quot; class=&quot;uri&quot;&gt;https://github.com/Screetsec/TheFatRat&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225614516-552063740.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安全测试伴侣seclists&quot;&gt;3.2 安全测试伴侣：SecLists&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SecLists 是安全测试人员的工具箱，它收录了渗透测试资源，包括用户名、密码字典、URL、敏感数据、模糊测试 payloads、Webshell、XSS 等方面内容。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.3793103448276&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/danielmiessler/SecLists&quot; class=&quot;uri&quot;&gt;https://github.com/danielmiessler/SecLists&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225624250-1835867996.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安全第一dangerzone&quot;&gt;3.3 安全第一：Dangerzone&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dangerzone 是一个可将潜在危险的 PDF、办公文档、图片等转换为安全 PDF 发的工具，如果你不知道某个文件是否安全，可以交给 Dangerzone 它会在沙箱中将它变成安全的 PDF 文件。目前它支持的格式有 .pdf .docx .doc .xls .xlsx .pptx .ppt .odt .odp .odg .jpg .jpeg .gif .png .tif .tiff&lt;/p&gt;
&lt;blockquote readability=&quot;1.3333333333333&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/firstlookmedia/dangerzone&quot; class=&quot;uri&quot;&gt;https://github.com/firstlookmedia/dangerzone&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200315225632434-1076610106.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 11 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200217165012919-1203910757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Mar 2020 00:23:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 摘要：连着两周成绩平平的 GitHub Trending 榜，终于和三月的天气一样进入全面变暖的模式，无论是本周刚开源搭乘 ocr 热点并获得 1,500+ st</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12500926.html</dc:identifier>
</item>
<item>
<title>《ASP.NET Core 3框架揭秘》博文汇总 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-3-summary.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-3-summary.html</guid>
<description>&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/artech/158198/o_200308031938inside-asp-net-core.png&quot; class=&quot;desc_img&quot;/&gt;在过去一段时间内，写了一系列关于ASP.NET Core 3相关的文章，其中绝大部分来源于即将出版的《ASP.NET Core 3框架揭秘》，先将它们汇总在这里。如果对《ASP.NET Core 3框架揭秘》感兴趣，可以通过这里加入读者群。</description>
<pubDate>Mon, 16 Mar 2020 00:13:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>在过去一段时间内，写了一系列关于ASP.NET Core 3相关的文章，其中绝大部分来源于即将出版的《ASP.NET Core 3框架揭秘》（博文只能算是“初稿”，与书中相应章节具有一定差异），先将它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-3-summary.html</dc:identifier>
</item>
<item>
<title>【.net core】电商平台升级之微服务架构应用实战（core-grpc） - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12491505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12491505.html</guid>
<description>&lt;p&gt;本来这篇文章是继续分享IdentityServer4 的相关文章的，由于之前有博友问我关于微服务相关的问题，我就先跳过IdentityServer4的分享，进行微服务相关的技术学习和分享；微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;289.73164244324&quot;&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;这篇文章本来是继续分享&lt;code&gt;IdentityServer4&lt;/code&gt; 的相关文章，由于之前有博友问我关于&lt;code&gt;微服务&lt;/code&gt;相关的问题，我就先跳过&lt;code&gt;IdentityServer4&lt;/code&gt;的分享，进行&lt;code&gt;微服务&lt;/code&gt;相关的技术学习和分享。&lt;code&gt;微服务&lt;/code&gt;在我的分享目录里面是放到四月份开始系列文章分享的，这里就先穿越下，提前安排&lt;code&gt;微服务&lt;/code&gt;应用的开篇文章 &lt;code&gt;电商系统升级之微服务架构的应用&lt;/code&gt;。&lt;br/&gt;本博客以及公众号&lt;strong&gt;坚持以架构的思维来分享技术，不仅仅是单纯的分享怎么使用的Demo&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二场景&quot;&gt;二、场景&lt;/h2&gt;
&lt;p&gt;先来回顾下我上篇文章 &lt;a href=&quot;https://www.cnblogs.com/jlion/p/12447081.html&quot;&gt;Asp.Net Core 中IdentityServer4 授权中心之应用实战&lt;/a&gt; 中，电商架构由&lt;code&gt;单体式架构&lt;/code&gt;拆分升级到&lt;code&gt;多网关架构&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;升级之前&quot;&gt;升级之前&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200310110017008-1660735876.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;升级之后&quot;&gt;升级之后:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200310111100212-1434441217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而升级之后问题又来了，由于之前增加了代理商业务并且把&lt;code&gt;授权中心&lt;/code&gt;和&lt;code&gt;支付网关&lt;/code&gt;单独拆出来了，这使得公司的业务订单量翻了几十倍，这个时候整个电商系统达到了瓶颈，如果再不找解决方案系统又得宕机了。&lt;/p&gt;
&lt;h3 id=&quot;问题及解决方案&quot;&gt;2.1 问题及解决方案&lt;/h3&gt;
&lt;p&gt;经过技术的调研及问题分析，导致这个瓶颈的问题主要有以下几个原因，只需要把下面问题解决就可以得到很大的性能提升&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每天的订单量暴增，导致订单数据太大，然而整个电商系统数据存储在一个数据库中，并且是&lt;code&gt;单表&lt;/code&gt;、&lt;code&gt;单数据库&lt;/code&gt;（未进行读写分离），以致于订单数据持续暴增。&lt;/li&gt;
&lt;li&gt;相关业务需要依赖订单查询，订单数据查询慢以至于拖垮数据库&lt;/li&gt;
&lt;li&gt;整个电商系统连接数达到瓶颈（已经分布式部署，在多加服务器会损耗更多的经费而达不到最佳性价比）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了一劳永逸的解决以上问题，经过技术的调研，决定对订单业务做如下升级改造：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拆分独立的订单微服务（本章节着重分享）&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ES&lt;/code&gt;进行数据迁移（按年进行划分，并且进行读写分离，这里就不着重讲，下次来跟大家一起学习和分享）&lt;/li&gt;
&lt;li&gt;增加&lt;code&gt;分布式缓存&lt;/code&gt; （也不是本次的重点，后续再来跟大家学习和分享）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过升级后的架构图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314122846964-397634622.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;架构图说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;右边同一颜色的代表还是原先电商系统的&lt;code&gt;单体式架构&lt;/code&gt;，为拆分的单体架构业务，其中在业务处理上夹杂了一层分布式缓存的处理&lt;/li&gt;
&lt;li&gt;左边的是微服务的架构，是这次升级拆分后的架构，其中数据库也已经从原有的数据库拆分并且数据迁移到了ES集群中，并进行了读写分离。&lt;/li&gt;
&lt;li&gt;订单服务可以随意扩容成分布式服务，通过一些工具动态扩展服务及服务器的支持。&lt;/li&gt;
&lt;li&gt;右边的业务后续也可以进行拆分，拆分成不同的业务服务。&lt;/li&gt;
&lt;li&gt;后续升级还可以考虑消息队列等相关方面,架构图中未构思（后续再来分享升级用到的相关技术，这里还是回归到本文的核心&lt;code&gt;微服务&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三微服务概述&quot;&gt;三、微服务概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;微服务&lt;/code&gt;的相关概念我就不多说了，以下就先简单概况下微服务带来的利和弊。&lt;/p&gt;
&lt;h3 id=&quot;微服务的优势&quot;&gt;3.1 微服务的优势&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使大型的复杂应用程序可以持续交付和持续部署：持续交付和持续部署是DevOps的一部分，DevOps是一套快速、频繁、可靠的软件交付实践。高效的DevOps组织通常将软件部署到生产环境时面临更少的问题和故障。DevOps工具有&lt;code&gt;Docker&lt;/code&gt;、&lt;code&gt;Kubernets&lt;/code&gt;、&lt;code&gt;Jenkins&lt;/code&gt;、&lt;code&gt;Git&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;每个服务相对较小并容易维护：微服务架构相比单体应用要小的多，开发者理解服务中的逻辑代码更容易。代码库小，打包，启动服务速度也快。&lt;/li&gt;
&lt;li&gt;服务可以独立部署：每个服务都可以独立于其他服务进行部署&lt;/li&gt;
&lt;li&gt;服务可以独立扩展：服务可以独立扩展，不论是采用X轴扩展的实例克隆，还是Z轴的流量分区方式。此外每个服务都可以部署到适合它们需求的硬件之上&lt;/li&gt;
&lt;li&gt;微服务架构可以实现团队的自治：可以根据服务来把开发团队拆分。每个团队都有自己负责的微服务，而不用关心不属于他们负责的服务。&lt;/li&gt;
&lt;li&gt;更容易实验和采纳新的技术：最后，微服务可以消除对某个技术栈的长期依赖。因为服务更小，使用更换的编程语言和技术来重写一项服务变得有可能，这也意味着，对一项新技术尝试失败后，可以直接丢弃这部分工作而不至于给整个应用带来失败的风险。&lt;/li&gt;
&lt;li&gt;更好的容错性：微服务架构也可以实现更换的故障隔离。例如，某个服务引发的致命错误，不会影响其他服务。其他服务仍然正常运行。&lt;/li&gt;
&lt;li&gt;服务可以独立扩容：对于整个架构来说，可以随意选择相关业务进行扩容和负载，通过相关技术工具动态进行随意扩容&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;微服务的劣势&quot;&gt;3.2 微服务的劣势&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;服务拆分和定义是一项挑战：采用微服务架构首当其冲的问题，就是根本没有一个具体的、良好定义的算法可以完成服务的拆分工作。与软件开发一样，服务的拆分和定义更像一门艺术。更糟糕的是，如果对系统的服务拆分出现了偏差，很有可能会构建出一个分布式的单体应用；一个包含了一大堆互相之间紧耦合的服务，却又必须部署在一起的所谓分布式系统。这将会把单体架构和微服务架构两者的弊端集于一身。&lt;/li&gt;
&lt;li&gt;分布式系统带来的各种复杂性、使开发、测试和部署变得更困难：使用微服务架构的另一个问题是开发人员必须处理创建分布式系统的额外复杂性。服务必须是进程间通信。这比简单的方法调用要复杂的多。&lt;/li&gt;
&lt;li&gt;当部署跨越多个服务的功能时需要谨慎地协调更多的开发团队：使用微服务架构的另外一项挑战在于当部署跨越多个服务的功能时需要谨慎地协调更多开发团队。必须制定一个发布计划，把服务按照依赖关系进行排序。这跟单体架构下部署多个组件的方式截然不同。&lt;/li&gt;
&lt;li&gt;开发者需要思考到底应该在应用的什么阶段使用微服务架构：使用微服务架构的另一个问题是决定在应用程序生命周期的哪个阶段开始使用这种架构。&lt;/li&gt;
&lt;li&gt;跨服务数据的问题：在单体应用中，所有的数据都在一个数据库中，而在微服务架构中，每个服务都有自己的数据库，想要获取，操作其他服务的数据，只能通过该服务提供API进行调用，这样就带来一个问题，进程通信的问题，如果涉及到事务，那么还需要使用Saga来管理事务，增加了开发的难度。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;微服务拆分原则&quot;&gt;3.3 微服务拆分原则&lt;/h3&gt;
&lt;p&gt;说到&lt;code&gt;单体架构&lt;/code&gt;拆分，那也不是随意拆分，是要有一定的原则，拆分的好是优势，拆分的不好是混乱。以下是我查阅资料以及我的经验总结出来的拆分原则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、单一职责、高内聚低耦合&lt;/li&gt;
&lt;li&gt;2、微服务粒度适中&lt;/li&gt;
&lt;li&gt;3、考虑团队结构&lt;/li&gt;
&lt;li&gt;4、以业务模型切入&lt;/li&gt;
&lt;li&gt;5、演进式拆分&lt;/li&gt;
&lt;li&gt;6、避免环形依赖与双向依赖&lt;/li&gt;
&lt;li&gt;7、DDD（可以考虑使用&lt;code&gt;领域驱动设计&lt;/code&gt;去进行底层服务的设计,后续会单独分析该设计的相关文章）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四微服务实战&quot;&gt;四、微服务实战&lt;/h2&gt;
&lt;p&gt;好了，到这里大家已经对微服务有了一定的理解，就不继续详细概述相关理念的东西，下面来直接撸代码，让大家熟悉微服务的应用。这里我使用 &lt;code&gt;莫堇蕈&lt;/code&gt; 在github 上开源的&lt;strong&gt;微服务框架&lt;/strong&gt;，框架源代码地址 ：&lt;a href=&quot;https://github.com/overtly/core-grpc&quot; class=&quot;uri&quot;&gt;https://github.com/overtly/core-grpc&lt;/a&gt; （&lt;strong&gt;我这里强烈推荐该框架，目前已经比较成熟的用于公司生产环境&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了更好的维护开源项目以及技术交流，特意创建了一个交流群，群号：1083147206 有兴趣者开源加入交流&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;core-grpc-微服务框架的优势&quot;&gt;4.1 &lt;code&gt;core-grpc&lt;/code&gt; 微服务框架的优势：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;集成Consul 实现服务发现和注册以及健康检查等机制&lt;/li&gt;
&lt;li&gt;实时监听服务状态&lt;/li&gt;
&lt;li&gt;多节点 轮询机制&lt;/li&gt;
&lt;li&gt;故障转移，拉入黑名单&lt;/li&gt;
&lt;li&gt;支持.Net Core 和Framework 两种框架&lt;/li&gt;
&lt;li&gt;实现基于Grpc的微服务&lt;/li&gt;
&lt;li&gt;部署支持环境变量&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实战&quot;&gt;4.2 实战&lt;/h3&gt;
&lt;h4 id=&quot;创建jlion.netcore.orderservice-订单微服务&quot;&gt;创建&lt;code&gt;Jlion.NetCore.OrderService&lt;/code&gt; 订单微服务&lt;/h4&gt;
&lt;p&gt;我们用&lt;code&gt;vs2019&lt;/code&gt; 创建控制台应用程序 选择框架.Net Core 3.1 命名为&lt;code&gt;Jlion.NetCore.OrderService&lt;/code&gt; 后面简称&lt;code&gt;订单服务&lt;/code&gt;，创建完后我们通过&lt;code&gt;nuget&lt;/code&gt;包引入 &lt;code&gt;core-grpc&lt;/code&gt;微服务框架，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314140932240-924518816.png&quot;/&gt;&lt;br/&gt;目前&lt;code&gt;core-grpc&lt;/code&gt;微服务框架，最新正式发布版本是 1.0.3&lt;/p&gt;
&lt;p&gt;引用了&lt;code&gt;core-grpc&lt;/code&gt; 后我们还需要安装一个工具&lt;code&gt;VS RPC Menu&lt;/code&gt;，这个工具也是大神免费提供的，图片如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314142038399-880772553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于微软官方下载比较慢，我这里共享到 百度网盘，百度网盘下载地址如下：&lt;/p&gt;
&lt;blockquote readability=&quot;1.6901408450704&quot;&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1twpmA4_aErrsg-m0ICmOPw&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1twpmA4_aErrsg-m0ICmOPw&lt;/a&gt; 提取码: cshs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果通过下载后安装不是vs 集成安装方式，下载完成后需要关闭vs 2019相关才能正常安装。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;VS RPC Menu 工具说明如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;OrderRequest.proto&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;syntax = &quot;proto3&quot;;
package Jlion.NetCore.OrderService.Service.Grpc;


//定义订单查找参数实体
message OrderSearchRequest{
    string OrderId = 1; //定义订单ID
    string Name = 2;
}

//定义订单实体
message OrderRepsonse{
    string OrderId = 1;
    string Name = 2;
    double Amount = 3;
    int32 Count = 4;
    string Time = 5;
}

//定义订单查找列表
message OrderSearchResponse{
    bool Success = 1;
    string ErrorMsg = 2;
    repeated OrderRepsonse Data = 3;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面主要是定义了几个消息实体，&lt;br/&gt;我们再创建&lt;code&gt;JlionOrderService.proto&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;syntax = &quot;proto3&quot;;
package Jlion.NetCore.OrderService.Service.Grpc;

import &quot;OrderRequest.proto&quot;;

service JlionOrderService{
    rpc Order_Search(OrderSearchRequest) returns (OrderSearchResponse){} 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中都可以看到最上面有 &lt;code&gt;package Jlion.NetCore.OrderService.Service.Grpc&lt;/code&gt; 代码，这是声明包名也就是后面生成代码后的命名空间，&lt;strong&gt;这个很重要&lt;/strong&gt;。&lt;br/&gt;同时定义了&lt;code&gt;JlionOrderService&lt;/code&gt;服务入口，并且定义了一个订单搜索的方法&lt;code&gt;Order_Search&lt;/code&gt;，到这里我们已经完成了一小部分了。&lt;/p&gt;
&lt;h4 id=&quot;生成客户端代码&quot;&gt;生成客户端代码&lt;/h4&gt;
&lt;p&gt;再在&lt;code&gt;JlionOrderService.proto&lt;/code&gt;文件里面右键 》选择Grpc代码生成》Grpc 代码 会自动生存微服务客户端代码 。&lt;br/&gt;生存工具中具有如下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生存Grpc客户端代码&lt;/li&gt;
&lt;li&gt;Grpc 编译（不常用）&lt;/li&gt;
&lt;li&gt;Grpc 打包（常用，用来把客户端dll发布到nuget服务器上）&lt;/li&gt;
&lt;li&gt;还可以对Thrift 代码进行生成和打包&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;创建jlion.netcore.orderservice.grpc-类库&quot;&gt;创建&lt;code&gt;Jlion.NetCore.OrderService.Grpc&lt;/code&gt; 类库&lt;/h4&gt;
&lt;p&gt;把刚刚通过工具生成的&lt;code&gt;Grpc&lt;/code&gt;客户端代码直接copy到 &lt;code&gt;Jlion.NetCore.OrderService.Grpc&lt;/code&gt;这个类库中（必须和上面Grpc 的代码声明的package 一致）以下简称&lt;code&gt;订单服务客户端&lt;/code&gt;，并且需要通过&lt;code&gt;Nuget&lt;/code&gt;包添加&lt;code&gt;Overt.Core.Grpc&lt;/code&gt; 的依赖，代码结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314154132290-1968561026.png&quot;/&gt;&lt;br/&gt;&lt;code&gt;Jlion.NetCore.OrderService.Grpc&lt;/code&gt;类库已经构建完成，现在让 &lt;code&gt;Jlion.NetCore.OrderService&lt;/code&gt; 服务引用&lt;code&gt;Jlion.NetCore.OrderService.Grpc&lt;/code&gt; 类库&lt;/p&gt;
&lt;h4 id=&quot;订单服务中-实现自己的ihostedservice&quot;&gt;&lt;code&gt;订单服务&lt;/code&gt;中 实现自己的&lt;code&gt;IHostedService&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;创建&lt;code&gt;HostService&lt;/code&gt;类，继承&lt;code&gt;IHostedService&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HostedService : IHostedService
{
    readonly ILogger _logger;
    readonly JlionOrderServiceBase _grpcServImpl;
    public HostedService(
        ILogger&amp;lt;HostedService&amp;gt; logger,
        JlionOrderServiceBase grpcService)
    {
        _logger = logger;
        _grpcServImpl = grpcService;
    }

    //服务的启动机相关配置
    public Task StartAsync(CancellationToken cancellationToken)
    {
        return Task.Factory.StartNew(() =&amp;gt;
        {
            var channelOptions = new List&amp;lt;ChannelOption&amp;gt;()
            {
                 new ChannelOption(ChannelOptions.MaxReceiveMessageLength, int.MaxValue),
                 new ChannelOption(ChannelOptions.MaxSendMessageLength, int.MaxValue),
            };
            GrpcServiceManager.Start(BindService(_grpcServImpl), channelOptions: channelOptions, whenException: (ex) =&amp;gt;
            {
                _logger.LogError(ex, $&quot;{typeof(HostedService).Namespace.Replace(&quot;.&quot;, &quot;&quot;)}开启失败&quot;);
                throw ex;
            });
            System.Console.WriteLine(&quot;服务已经启动&quot;);
            _logger.LogInformation($&quot;{nameof(Jlion.NetCore.OrderService.Service).Replace(&quot;.&quot;, &quot;&quot;)}开启成功&quot;);
        }, cancellationToken);
    }

    //服务的停止
    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.Factory.StartNew(() =&amp;gt;
        {
            GrpcServiceManager.Stop();

            _logger.LogInformation($&quot;{typeof(HostedService).Namespace.Replace(&quot;.&quot;, &quot;&quot;)}停止成功&quot;);
        }, cancellationToken);
    }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码主要是创建宿主机并且实现了&lt;code&gt;StartAsync&lt;/code&gt; 服务启动及&lt;code&gt;StopAsync&lt;/code&gt; 服务停止方法。&lt;br/&gt;我们创建完&lt;code&gt;HostedServicce&lt;/code&gt;代码再来创建之前定义的&lt;code&gt;Grpc&lt;/code&gt;服务的方法实现类&lt;code&gt;JlionOrderServiceImpl&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public partial class JlionOrderServiceImpl : JlionOrderServiceBase
{
    private readonly ILogger _logger;
    private readonly IServiceProvider _serviceProvider;

    public JlionOrderServiceImpl(ILogger&amp;lt;JlionOrderServiceImpl&amp;gt; logger, IServiceProvider provider)
    {
        _logger = logger;
        _serviceProvider = provider;
    }

    public override async Task&amp;lt;OrderSearchResponse&amp;gt; Order_Search(OrderSearchRequest request, ServerCallContext context)
    {
        //TODO 从底层ES中查找订单数据，
        //可以设计成DDD 方式来进行ES的操作，这里我就为了演示直接硬编码了

        var response = new OrderSearchResponse();
        try
        {
            response.Data.Add(new OrderRepsonse()
            {
                Amount = 100.00,
                Count = 10,
                Name = &quot;订单名称测试&quot;,
                OrderId = DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;),
                Time = DateTime.Now.ToString()
            });

            response.Data.Add(new OrderRepsonse()
            {
                Amount = 200.00,
                Count = 10,
                Name = &quot;订单名称测试2&quot;,
                OrderId = DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;),
                Time = DateTime.Now.ToString()
            });

            response.Data.Add(new OrderRepsonse()
            {
                Amount = 300.00,
                Count = 10,
                Name = &quot;订单名称测试2&quot;,
                OrderId = DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;),
                Time = DateTime.Now.ToString()
            });
            response.Success = true;
        }
        catch (Exception ex)
        {
            response.ErrorMsg = ex.Message;
            _logger.LogWarning(&quot;异常&quot;);
        }
        return response;
    }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改&lt;code&gt;Program&lt;/code&gt;代码，并把&lt;code&gt;HostedService&lt;/code&gt;和&lt;code&gt;JlionOrderServiceImpl&lt;/code&gt; 注入到容器中，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; class Program
 {
    static void Main(string[] args)
    {
        var host = new HostBuilder()
           .UseConsoleLifetime() //使用控制台生命周期
           .ConfigureAppConfiguration((context, configuration) =&amp;gt;
           {
               configuration
               .AddJsonFile(&quot;appsettings.json&quot;, optional: true)
               .AddEnvironmentVariables();
           })
           .ConfigureLogging(logger =&amp;gt;
           {
               logger.AddFilter(&quot;Microsoft&quot;, LogLevel.Critical)
                     .AddFilter(&quot;System&quot;, LogLevel.Critical);
           })
           .ConfigureServices(ConfigureServices)
           .Build();

        AppDomain.CurrentDomain.UnhandledException += (sender, e) =&amp;gt;
        {
            var logFactory = host.Services.GetService&amp;lt;ILoggerFactory&amp;gt;();
            var logger = logFactory.CreateLogger&amp;lt;Program&amp;gt;();
            logger.LogError(e.ExceptionObject as Exception, $&quot;UnhandledException&quot;);
        };

        host.Run();
    }

    /// &amp;lt;summary&amp;gt;
    /// 通用DI注入
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;
    private static void ConfigureServices(HostBuilderContext context, IServiceCollection services)
    {
        //HostedService 单例注入到DI 中
        services.AddSingleton&amp;lt;IHostedService, HostedService&amp;gt;();
        services.AddTransient&amp;lt;JlionOrderServiceBase, JlionOrderServiceImpl&amp;gt;();
    }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了这里简单的&lt;code&gt;微服务&lt;/code&gt;已经编码完成，但是还缺少两个配置文件，我们创建&lt;code&gt;appsettings.json&lt;/code&gt;配置文件和&lt;code&gt;consulsettings.json&lt;/code&gt; 服务注册发现的配置文件&lt;br/&gt;&lt;code&gt;consulsettings.json&lt;/code&gt;配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;ConsulServer&quot;: {
    &quot;Service&quot;: {
      &quot;Address&quot;: &quot;127.0.0.1：8500&quot;// 你的Consul 服务注册及发现配置地址
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的地址配置只是简单的例子，我这里假定我的&lt;code&gt;Consul&lt;/code&gt;服务地址是 127.0.0.1：8500 等下服务启动是会通过这个地址进行注册。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appsettings.json&lt;/code&gt;配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;GrpcServer&quot;: {
    &quot;Service&quot;: {
      &quot;Name&quot;: &quot;JlionOrderService&quot;,
      &quot;Port&quot;: 10001,
      &quot;HostEnv&quot;: &quot;serviceaddress&quot;,
      &quot;Consul&quot;: {
        &quot;Path&quot;: &quot;dllconfigs/consulsettings.json&quot;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里服务监听了10001 端口，后面注册到&lt;code&gt;Consul&lt;/code&gt;中也会看到该端口&lt;br/&gt;官方完整的配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;GrpcServer&quot;: {
    &quot;Service&quot;: {
      &quot;Name&quot;: &quot;OvertGrpcServiceApp&quot;,                    // 服务名称使用服务名称去除点：OvertGrpcServiceApp
      &quot;Host&quot;: &quot;service.g.lan&quot;,                          // 专用注册的域名 （可选）格式：ip[:port=default]
      &quot;HostEnv&quot;: &quot;serviceaddress&quot;,                      // 获取注册地址的环境变量名字（可选，优先）环境变量值格式：ip[:port=default]
      &quot;Port&quot;: 10001,                                    // 端口自定义
      &quot;Consul&quot;: {
        &quot;Path&quot;: &quot;dllconfigs/consulsettings.json&quot;        // Consul路径
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，&lt;code&gt;订单服务&lt;/code&gt;已经全部完成了，&lt;code&gt;订单服务&lt;/code&gt;服务整体结构图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314164656785-2129915807.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，我们这里通过命令行启动下&lt;code&gt;JlionOrderService&lt;/code&gt;服务，生产环境你们可以搭建在&lt;code&gt;Docker&lt;/code&gt; 容器里面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314165357311-817378551.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以来看下我之前搭建好的&lt;code&gt;Consul&lt;/code&gt;服务 ，打开管理界面，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314165513459-1651269728.png&quot;/&gt;&lt;br/&gt;图片中可以发现刚刚启动的服务已经注册进去了，但是里面有一个健康检查未通过，主要是由于服务端不能访问我本地的&lt;code&gt;订单服务&lt;/code&gt;，所有健康检查不能通过。你可以在你本地搭建 &lt;code&gt;Consul&lt;/code&gt;服务用于测试。&lt;/p&gt;
&lt;p&gt;我本地再来开启一个服务，配置中的的端口号由10001 改成10002，再查看下&lt;code&gt;Consul&lt;/code&gt;的管理界面，如下图:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314165736341-1838405733.png&quot;/&gt;&lt;br/&gt;发现已经注册了两个服务，端口号分别是10001 和10002，这样可以通过自定化工具自动添加服务及下架服务，分布式服务也即完成。&lt;br/&gt;到这里&lt;code&gt;订单服务&lt;/code&gt;的启动已经完全成功了，我们接下来是需要客户端也就是上面架构图中的&lt;code&gt;电商业务网关&lt;/code&gt;或者&lt;code&gt;支付网关&lt;/code&gt;等等要跟&lt;code&gt;订单服务&lt;/code&gt;进行通讯了。&lt;/p&gt;
&lt;h4 id=&quot;创建订单网关跟订单服务进行通信&quot;&gt;创建订单网关（跟订单服务进行通信）&lt;/h4&gt;
&lt;p&gt;创建订单网关之前我先把上面的 &lt;code&gt;订单服务客户端&lt;/code&gt; 类库发布到我的nuget包上，这里就不演示了。我发布的测试包名称&lt;code&gt;JlionOrderServiceDemo&lt;/code&gt; nuget官方可以搜索找到。你们也可以直接搜索添加到你们的Demo中进行测试。&lt;br/&gt;我通过VS 2019 创建Asp.Net Core 3.1 框架的&lt;code&gt;WebApi&lt;/code&gt; 取名为&lt;code&gt;Jlion.NetCore.OrderApiService&lt;/code&gt; 下面简称&lt;code&gt;订单网关服务&lt;/code&gt;&lt;br/&gt;现在我把前面发布的&lt;code&gt;微服务&lt;/code&gt;客户端依赖包 &lt;code&gt;JlionOrderServiceDemo&lt;/code&gt; 添加到&lt;code&gt;订单网关服务&lt;/code&gt;中，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314172605904-911890551.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在在&lt;code&gt;订单网关服务&lt;/code&gt;中添加&lt;code&gt;OrderController&lt;/code&gt; api控制器，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Jlion.NetCore.OrderApiService.Controllers
{
    [Route(&quot;[controller]&quot;)]
    [ApiController]
    public class OrderController : ControllerBase
    {
        private readonly IGrpcClient&amp;lt;OrderService.Service.Grpc.JlionOrderService.JlionOrderServiceClient&amp;gt; _orderService;
        public OrderController (IGrpcClient&amp;lt;OrderService.Service.Grpc.JlionOrderService.JlionOrderServiceClient&amp;gt; orderService)
        {
            _orderService = orderService;
        }
     
        [HttpGet(&quot;getlist&quot;)]
        public async Task&amp;lt;List&amp;lt;OrderRepsonse&amp;gt;&amp;gt; GetList()
        {
            var respData =await _orderService.Client.Order_SearchAsync(new OrderService.Service.Grpc.OrderSearchRequest()
            {
                Name = &quot;test&quot;,
                OrderId = &quot;&quot;,
            });

            if ((respData?.Data?.Count ?? 0) &amp;lt;= 0)
            {
                return new List&amp;lt;OrderRepsonse&amp;gt;();
            }

            return respData.Data.ToList();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中通过构造函数注入 &lt;code&gt;OrderService&lt;/code&gt; 并且提供了一个&lt;code&gt;GetList&lt;/code&gt;的接口方法。接下来我们还需要把&lt;code&gt;OrderService.Service.Grpc.JlionOrderService&lt;/code&gt;注入到容器中，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
     services.AddControllers();

     //注册Grpc 客户端，具体可以查看源代码
     services.AddGrpcClient();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在整个&lt;code&gt;订单网关服务&lt;/code&gt;项目结构如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314175223455-775032078.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目中有两个最重要的配置&lt;code&gt;dllconfig//Jlion.NetCore.OrderService.Grpc.dll.json&lt;/code&gt; 和&lt;code&gt;consulsettings.json&lt;/code&gt; 他们分别是干什么的呢？我们先分别来看我本地这两个配置的内容&lt;br/&gt;&lt;code&gt;Jlion.NetCore.OrderService.Grpc.dll.json&lt;/code&gt; 配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
   &quot;GrpcClient&quot;: {
       &quot;Service&quot;: {
        &quot;Name&quot;: &quot;JlionOrderService&quot;,  // 服务名称与服务端保持一致
        &quot;MaxRetry&quot;: 0,                // 最大可重试次数，默认不重试
        &quot;Discovery&quot;: {
            &quot;Consul&quot;: {              // Consul集群,集群优先原则
                &quot;Path&quot;: &quot;dllconfigs/consulsettings.json&quot;
            }，
            &quot;EndPoints&quot;: [           // 单点模式
                {
                    &quot;Host&quot;: &quot;127.0.0.1&quot;,
                    &quot;Port&quot;: 10001
             }]
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Jlion.NetCore.OrderService.Grpc.dll.json&lt;/code&gt; 配置主要是告诉&lt;code&gt;订单网关服务&lt;/code&gt;和&lt;code&gt;订单服务&lt;/code&gt;应该怎样进行通信，以及通信当中的一些参数配置。我为了测试，本地使用单点模式，不使用Consul模式&lt;br/&gt;&lt;code&gt;consulsettings.json&lt;/code&gt; 配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;ConsulServer&quot;: {
    &quot;Service&quot;: {
      &quot;Address&quot;: &quot;127.0.0.1:8500&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有没有发现这个配置和之前服务端的配置一样，主要是告诉&lt;code&gt;订单网关服务&lt;/code&gt;（客户端调用者）和&lt;code&gt;订单服务&lt;/code&gt;服务端服务发现的集群地址，如果上面的配置是单点模式则这个配置不会起作用。&lt;/p&gt;
&lt;p&gt;到这里&lt;code&gt;订单网关服务&lt;/code&gt; （客户调用端）编码完成，我们开始启动它：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314180253929-956598381.png&quot;/&gt;&lt;br/&gt;我这里固定5003端口，现在完美的启动了，我们访问下订单接口，看下是否成功。访问结果如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200314181438804-166900734.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微服务完美的运行成功。&lt;/p&gt;
&lt;p&gt;上面的构建微服务还是比较麻烦，官方提供了比较快速构建你需要的微服务方式，不需要写上面的那些代码，那些代码全部通过模板的方式进行构建你的微服务，有需要学习的可以到点击&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jlion/p/12494525.html&quot;&gt;微服务项目构建模板使用教程&lt;/a&gt;&lt;br/&gt;教程地址：&lt;a href=&quot;https://www.cnblogs.com/jlion/p/12494525.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/jlion/p/12494525.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章中的Demo 代码已经提交到github 上，代码地址：&lt;a href=&quot;https://github.com/a312586670/IdentityServerDemo&quot; class=&quot;uri&quot;&gt;https://github.com/a312586670/IdentityServerDemo&lt;/a&gt;&lt;br/&gt;微服务框架开源项目地址：&lt;a href=&quot;https://github.com/overtly/core-grpc&quot; class=&quot;uri&quot;&gt;https://github.com/overtly/core-grpc&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 15 Mar 2020 23:40:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>本来这篇文章是继续分享IdentityServer4 的相关文章的，由于之前有博友问我关于微服务相关的问题，我就先跳过IdentityServer4的分享，进行微服务相关的技术学习和分享；微服务是一种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12491505.html</dc:identifier>
</item>
<item>
<title>TLS/SSL 梳理 - opticor</title>
<link>http://www.cnblogs.com/mckc/p/12501558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mckc/p/12501558.html</guid>
<description>&lt;p&gt;数据加密通篇都是为了防止第三方的劫持伪造，保证连接安全，&lt;/p&gt;
&lt;p&gt;毫无遮掩的明文传输只有民风淳朴的时候才是安全的。&lt;/p&gt;
&lt;p&gt;先是一些基础的内容：&lt;/p&gt;
&lt;h3&gt;对称加密&lt;/h3&gt;
&lt;p&gt;最开始为了对数据进行加密，使用的是对称加密算法，即双方协商好一个密钥，传输的时候使用这个密钥对数据进行加密和解密，但是这个密钥当然不能使用网络传输，不然同样被第三方劫持就没有意义了，所以只能私下协商交换密钥。&lt;/p&gt;
&lt;p&gt;最开始的DES(Data Encryption Standard)对称加密算法使用的是56bit的密钥，这个密钥稍微有点短，在后来完全可以暴力破解加密信息，对于56位的密码，只需要2的56次方就可以暴力穷举。&lt;/p&gt;
&lt;p&gt;然后又有了新的算法，triple—DES也交3DES，三重加密算法，最高168位密钥，还有AES，以前搭梯子的时候经常能见到，最高256bit密钥，安全性和速度都很出色。&lt;/p&gt;
&lt;p&gt;但是，和谁通信都私下传密钥明显不现实，于是就有了&lt;/p&gt;
&lt;h3&gt;非对称加密&lt;/h3&gt;
&lt;p&gt;各自有个私钥，使用公钥传输，全程只暴露公钥，具体过程：&lt;/p&gt;
&lt;p&gt;A先用自己的私钥加密数据，然后传递公钥和密文给B，B可以用自己的私钥解密&lt;/p&gt;
&lt;p&gt;(在一篇文章中提到，使用私钥加密的是hash值，而数据本身是明文的，因为使用密钥加密任意的数据内容存在风险，比如可以刻意的上传一些特定的数据在下载下来，从而破解得到密钥(如RSA），对数据只是payload，所以文章中的逻辑是这样的：A用自己的私钥加密hash，用B的公钥加密加入了其他信息的数据，然后给B，B用A的公钥解得数据，再用私钥解得hash，然后用hash验证完整性。但是目前还不清楚，看了很多，在原理类文章中也并未提及是对什么类型的数据加密，大体逻辑是括号前的，至少rsa是这样)&lt;/p&gt;
&lt;p&gt;但如果仅仅是上面这样就没有意义了，因为中间人仍然可以拦截AB的公钥，然后把自己的公钥给他们，AB还以为是对方的公钥，这样中间人就可以在中间对数据为所欲为了。&lt;/p&gt;
&lt;p&gt;这时候&lt;/p&gt;
&lt;h3&gt;CA证书&lt;/h3&gt;
&lt;p&gt;就出现了，我们可以向CA申请数字证书，而证书中包含我们的公钥和用户信息，有效时间，机构签字等等，而客户端择装有机构的&lt;strong&gt;根证书&lt;/strong&gt;，这个根证书有机构的公钥，用于确认机构所发的证书，&lt;/p&gt;
&lt;p&gt;为了分CA和TLS/SSL两节，脑子有点乱，不知道怎么写了，用问题的形式自我理一理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;中间人拦截服务器发出的证书并将自己伪造的证书发给客户端？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不可能，因为证书无法伪造，CA所发的公钥只能对证书进行校验，而不能生产证书，私钥在CA手上，如果中间人把自己的申请到的证书发给客户端，则证书的身份和客户端所要访问的服务器的身份对不上。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;中间人拦截后向客户端发送伪造的CA证书？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CA证书即根证书，一般安装在客户端中，并不是用网络进行传输的，除非被恶意程序改了，所以破解什么的风险之一就在这里，万一他把你的根证书改成了他伪造的，只能说完蛋。&lt;/p&gt;
&lt;p&gt;但是服务器的私钥泄漏了的话，就要需要吊销证书了，&lt;/p&gt;
&lt;p&gt;所以对于没到期但是撤销了的证书又有了CRL证书吊销列表，后来还有了OCSP在线证书状态协议，需要和第三方连接来验证证书状态，信息量较少，响应要比CRL块很多，可以减轻网络和客户端的负担，但是balabala可以看wiki：&lt;a href=&quot;[https://zh.wikipedia.org/zh-hans/%E5%9C%A8%E7%BA%BF%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE](https://zh.wikipedia.org/zh-hans/%E5%9C%A8%E7%BA%BF%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE)&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有关免费证书申请可以看我的&lt;a href=&quot;https://www.seyana.life/post/15&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;TLS/SSL&lt;/h3&gt;
&lt;p&gt;终于到这了，TLS(Transport Layer Security)传输层安全性协议，SSL(Secure Sockets Layer)安全套接层&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;SSL是TLS的前身，SSL标准化之后就是TLS，TLS处在最高层应用层也就是最接近用户的layer之下，与应用层无耦合，http,ftp,ssh生么的都能运行在TLS之上。&lt;/p&gt;
&lt;p&gt;用wireshark抓一下我博客的包，可以看到TLS1.2中需要两个RTT(round-trip time)来完成握手，&lt;/p&gt;
&lt;p&gt;（这里TCP segment of a reassembled PDU是指tcp对过大的数据分包发送，wireshark用此来标记同一个包，我把其他隐藏了方便看）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.seyana.life/media/2020/03/image-20200307231619862.png&quot; alt=&quot;image-20200307231619862&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;p&gt;客户端向服务器发出请求，提过支持的密码算法列表，&lt;/p&gt;
&lt;p&gt;服务器收到后决定加密和散列函数，发送CA证书给客户端，&lt;/p&gt;
&lt;p&gt;客户端收到后，验证证书，不通过over，通过就随机生成一个密钥（这个密钥用作对称加密），用服务器的公钥（在证书里）加密，用相应的算法计算hash，然后再用随机的密钥对hash加密，发给服务器，&lt;/p&gt;
&lt;p&gt;然后服务器用自己的私钥解密获得对称密钥，通过hash验证数据的是否完整&lt;/p&gt;
&lt;p&gt;之后的连接都是基于对称加密的，安全且更为高效。&lt;/p&gt;
&lt;br/&gt;&lt;h4&gt;session 重用&lt;/h4&gt;
&lt;p&gt;在TLS1.2之后支持了sessionid重用，对连接的速度进行了优化，&lt;/p&gt;
&lt;p&gt;再次访问我的博客抓包，可以看到客户端把之前服务器传来的Session id发给服务器 ，而在服务器中存有对应的sessio id，服务器查到对应纪录后可以直接使用之前的加密信息，之后只需要一个RTT即可完成握手&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.seyana.life/media/2020/03/image-20200307223104465.png&quot; alt=&quot;image-20200307223104465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是呢，我这用的还是TLS1.2，在1.3中又进一步对握手过程进行了优化，&lt;/p&gt;
&lt;p&gt;对于第一次连接，TLS1.2需要2个RTT，1.3只用1个RTT&lt;/p&gt;
&lt;p&gt;而对于session重用之后，1.2只用1个RTT，而1.3是0个。&lt;/p&gt;
&lt;p&gt;而对于分布式，session ID就不起作用了，在以前似乎是通过radis来跨服务器缓存什么的，&lt;/p&gt;
&lt;p&gt;现在提供了session Ticket，它是用对称密钥加密过的，保留在客户端，如果服务器能解密就能加快完成握手，&lt;/p&gt;
&lt;p&gt;在1.2session Ticket没有时间限制，1.3中加了过期时间&lt;/p&gt;

&lt;p&gt;同时还废弃了一些算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.seyana.life/media/2020/03/image-20200308005631116.png&quot; alt=&quot;image-20200308005631116&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多详细的内容可以看 &lt;a href=&quot;%5Bhttps://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A#TLS_1.2%5D(https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A#TLS_1.2)&quot;&gt;wiki wiki wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用1.3也很简单，nginx中只需要在server块给ssl_protocols加上TLSv1.3即可，需要 OpenSSL 1.1.1库，&lt;/p&gt;
&lt;p&gt;我这里用的ubuntu18.04，似乎自带的1.1.1，可以openssl version -a看一下。&lt;/p&gt;

&lt;h3&gt;HTTPS&lt;/h3&gt;
&lt;p&gt;HTTP over SSL，顾名思义了，通过TLS/SSL加密http，默认443端口， 现在浏览器都会验证是否是https，不是就给你打上警告，是就给你加小锁锁，证明你们的连接是安全的，可以开心的网上冲浪了，当然连接是安全的，网站本身不一定是安全的。&lt;/p&gt;
&lt;p&gt;来自我的博客：&lt;a href=&quot;https://www.seyana.life/post/16&quot;&gt;Opticor&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Mar 2020 18:45:00 +0000</pubDate>
<dc:creator>opticor</dc:creator>
<og:description>数据加密通篇都是为了防止第三方的劫持伪造，保证连接安全， 毫无遮掩的明文传输只有民风淳朴的时候才是安全的。 先是一些基础的内容： 对称加密 最开始为了对数据进行加密，使用的是对称加密算法，即双方协商好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mckc/p/12501558.html</dc:identifier>
</item>
</channel>
</rss>