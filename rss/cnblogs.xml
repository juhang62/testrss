<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Fiddler抓包和修改WebSocket数据，支持wss - xiangyuecn</title>
<link>http://www.cnblogs.com/xiangyuecn/p/10618982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiangyuecn/p/10618982.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;记录一下用&lt;code&gt;Fiddler&lt;/code&gt;对&lt;code&gt;WebSocket&lt;/code&gt;收发的数据进行抓包分析和篡改数据，只找到这么一个方法，能用就行吧。&lt;br/&gt;时间：2019-3-29&lt;br/&gt;环境： &lt;code&gt;win7&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;Fiddler 5.0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;fiddler抓取websocket数据&quot;&gt;Fiddler抓取WebSocket数据&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Fiddler&lt;/code&gt;中双击&lt;code&gt;WebSocket Session&lt;/code&gt;即可查看此连接收发的数据。可惜此选项卡内没有带发送数据的功能（一个输入框(HEX文本) + 一个按钮），要是有就基本完美了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2152669-9872240897b28079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;开启https支持&quot;&gt;开启https支持&lt;/h3&gt;
&lt;p&gt;如果需要抓取&lt;code&gt;https&lt;/code&gt;、&lt;code&gt;wss&lt;/code&gt;请求，需要在&lt;code&gt;Fiddler&lt;/code&gt;菜单&lt;code&gt;Tools&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;Options&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;HTTPS&lt;/code&gt; 中开启&lt;code&gt;HTTPS&lt;/code&gt;支持。在&lt;code&gt;Actions&lt;/code&gt;菜单中，设置电脑系统信任&lt;code&gt;Fiddler&lt;/code&gt;的根证书。&lt;/p&gt;
&lt;h3 id=&quot;手机简单支持&quot;&gt;手机简单支持&lt;/h3&gt;
&lt;p&gt;如果需要抓取手机中的数据，需要在&lt;code&gt;Tools&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;Options&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;Connections&lt;/code&gt;中设置允许客户端连接，然后在手机&lt;code&gt;wifi&lt;/code&gt;连接中设置使用电脑的&lt;code&gt;ip&lt;/code&gt;和&lt;code&gt;Fiddler监听的端口&lt;/code&gt;作为代理。&lt;/p&gt;
&lt;p&gt;然后手机浏览器访问电脑&lt;code&gt;ip&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;端口&lt;/code&gt; 进入&lt;code&gt;Fiddler&lt;/code&gt;页面下载根证书，并信任(安装)此证书。&lt;/p&gt;
&lt;p&gt;完成以上操作才有可能监控&lt;code&gt;https&lt;/code&gt;和&lt;code&gt;wss&lt;/code&gt;请求，大部分是能监控的。&lt;/p&gt;
&lt;h2 id=&quot;修改websocket数据&quot;&gt;修改WebSocket数据&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;Fiddler&lt;/code&gt;界面中并未找到修改&lt;code&gt;WebSocket&lt;/code&gt;数据的地方，搜索也没找到多少直接的资料信息，不过写怎么打印&lt;code&gt;WebSocket&lt;/code&gt;数据日志的倒蛮多（&lt;code&gt;Fiddler 4.5&lt;/code&gt;开始已没有这个必要了）。另外看到一篇&lt;code&gt;利用fiddler core api 拦截修改 websocket 数据&lt;/code&gt;的。两个综合一下就大功告成了。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Fiddler&lt;/code&gt;菜单&lt;code&gt;Rules&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;Customize Rules&lt;/code&gt;中实现&lt;code&gt;Handlers&lt;/code&gt;类的&lt;code&gt;OnWebSocketMessage&lt;/code&gt;方法，此方法可以得到&lt;code&gt;WebSocket&lt;/code&gt;收发的数据，而且可以修改。另：&lt;code&gt;Fildder&lt;/code&gt;主界面中&lt;code&gt;FildderScript&lt;/code&gt;也可以直接修改脚本代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2152669-ecb2f498ce2b8168.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;脚本语法&quot;&gt;脚本语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Fiddler&lt;/code&gt;采用的&lt;code&gt;JScript.Net&lt;/code&gt;语法，这个语法不熟？没关系，我也不熟，但对&lt;code&gt;JavaScript&lt;/code&gt;和&lt;code&gt;C#&lt;/code&gt;任意一个熟就行了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Classic ASP&lt;/code&gt; 用户可能对&lt;code&gt;JScript&lt;/code&gt;和它的好基友&lt;code&gt;VBScript&lt;/code&gt;比较熟，这两个除了写&lt;code&gt;ASP&lt;/code&gt;外，&lt;code&gt;Windows&lt;/code&gt;上的&lt;code&gt;vbs&lt;/code&gt; &lt;code&gt;js&lt;/code&gt;脚本代码也是主力使用方向。&lt;/p&gt;
&lt;p&gt;简单点，把&lt;code&gt;JScript&lt;/code&gt;当做&lt;code&gt;IE 6&lt;/code&gt;来写就ojbk了，绝对的原味，反正下面的例子里面&lt;code&gt;js&lt;/code&gt;代码居多。参考文章结尾的测试代码，不要在意那些拼音或者缩写的奇丑变量名。&lt;/p&gt;
&lt;h3 id=&quot;echo测试结果&quot;&gt;Echo测试结果&lt;/h3&gt;
&lt;p&gt;测试完整代码在文章结尾。&lt;/p&gt;
&lt;p&gt;发送&lt;code&gt;echo&lt;/code&gt;测试数据&lt;code&gt;test edit:ddd&lt;/code&gt;，结果截图：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2152669-c68e4f4f3ce79260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;Log中已打印我们的修改日志信息，可以看到&lt;code&gt;echo&lt;/code&gt;响应中完全包含了被修改后的发送数据，我特意用不同颜色标记了一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2152669-46f1b4c93893261b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;code&gt;Fiddler&lt;/code&gt;自己的&lt;code&gt;WebSocket&lt;/code&gt;记录信息，它记录的为我们修改之后的。&lt;/p&gt;
&lt;h2 id=&quot;websocket发送数据&quot;&gt;&lt;del&gt;WebSocket发送数据&lt;/del&gt;&lt;/h2&gt;
&lt;p&gt;&lt;del&gt;没找到方法，不知道怎么用&lt;code&gt;Fiddler&lt;/code&gt;来发送&lt;code&gt;WebSocket&lt;/code&gt;数据，参考第一节中的遗憾。&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;附测试代码&quot;&gt;附：测试代码&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Handlers
{
    //实现此方法，拦截处理数据
    static function OnWebSocketMessage(oMsg: WebSocketMessage) {
        var arr=oMsg.PayloadAsBytes();
        var bs=Utilities.ByteArrayToString(arr);
        var txt=bytesToViewText(arr);//此文本为英文，可读的文本信息，不可读的乱码、中文都过滤掉了
        var newTxt=&quot;&quot;;
        
        //假设的修改场景，只要收发的数据中包含了 test edit: 就干它
        var edit=false;
        if(txt.indexOf(&quot;test edit:&quot;)+1){
            var nbs=bs;
            var m1=/(test edit:)(.*)/.exec(txt)||[];
            nbs=nbs.Replace(strToHex(m1[0]||&quot;&quot;),strToHex(m1[1]+(oMsg.IsOutbound?&quot;send&quot;:&quot;onmessage&quot;)+&quot; change:&quot;+m1[2]));
            
            edit=true;
            oMsg.SetPayload(hexToBytes(nbs));
            
            newTxt=bytesToViewText(oMsg.PayloadAsBytes());
        }
        
        //并未直接提供获取SessionID的方法，应该是没有公开
        var all=oMsg.ToString();
        var m1=/#(\d+)/.exec(all)||[];
        var sessionID=m1[1]||-1;
        
        FiddlerApplication.Log.LogString(
            sessionID+&quot;:[&quot;+oMsg.ID+&quot;]&quot;
            +&quot;[&quot;+(oMsg.IsOutbound?&quot;出&quot;:&quot;入&quot;)+&quot;]&quot;
            +&quot;[&quot;+(edit?&quot;改:&quot;+newTxt:&quot;&quot;)+&quot;]&quot;
            +txt+&quot;\n&quot;);
    }
    
    //以下为一些功能函数
    static function bytesToViewText(arr:byte[]){
        var s=&quot;&quot;;
        for(var i=0;i&amp;lt;arr.length;i++){
            if(arr[i]&amp;gt;=32 &amp;amp;&amp;amp; arr[i]&amp;lt;=126){
                s+=String.fromCharCode(arr[i]);
            }
        }
        return s;
    }
    static function strToHex(str:String){
        var byts=new byte[str.Length];
        for(var i=0;i&amp;lt;str.Length;i++){
            byts[i]=(byte)(str.charCodeAt(i));
        }
        return Utilities.ByteArrayToString(byts);
    }
    static function hexToBytes(hexString:String)
    {
        hexString = hexString.Replace(&quot; &quot;, &quot;&quot;);
        var length = hexString.Length / 2;
        var hexChars = hexString.ToCharArray();
        var d = new byte[length];
        for (var i = 0; i &amp;lt; length; i++)
        {
            var pos = i * 2;
            d[i] = (byte)(charToByte(hexChars[pos]) &amp;lt;&amp;lt; 4 | charToByte(hexChars[pos + 1]));
        }
        return d;
    }
    static function charToByte(c:String)
    {
        return &quot;0123456789ABCDEF&quot;.indexOf(c);
    }

.......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只找到这么一个方法对&lt;code&gt;WebSocket&lt;/code&gt;抓包分析和篡改数据，比较土，完.&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 23:41:00 +0000</pubDate>
<dc:creator>xiangyuecn</dc:creator>
<og:description>记录一下用 对`WebSocket`收发的数据进行抓包分析和篡改数据，只找到这么一个方法，能用就行吧。 时间：2019 3 29 环境： `+ Fiddler 5.0` Fiddler抓取WebSoc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiangyuecn/p/10618982.html</dc:identifier>
</item>
<item>
<title>上次被人说TK不好咯，这次给你整个高大上的 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/10618975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/10618975.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019032906483892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;python GUI&quot;/&gt;&lt;/p&gt;

&lt;p&gt;操作系统：Windows&lt;/p&gt;
&lt;p&gt;Python版本：3.6.0&lt;/p&gt;

&lt;p&gt;PyQt是一个创建GUI应用程序的工具包。它是Python编程语言和Qt库的成功融合。Qt库是目前最强大的库之一。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190329065034523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;依赖包安装&quot;&gt;3.1 依赖包安装&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install pyqt5
pip install pyqt5-tools&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;图形设计界面工具&quot;&gt;3.2 图形设计界面工具&lt;/h2&gt;
&lt;p&gt;同学们如果需要qt的图形设计界面，可以使用Pycharm+Python3+PyQt5+QtDesigner的方式搭建。QtDesigner可以直接拖控件设计ui，非常方便。&lt;/p&gt;
&lt;p&gt;搭建方法详见：&lt;a href=&quot;https://www.jianshu.com/p/094928ac0b73&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/094928ac0b73&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;QtDesigner下载链接：&lt;a href=&quot;https://download.qt.io/archive/qt/&quot; class=&quot;uri&quot;&gt;https://download.qt.io/archive/qt/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装完以后效果大概就像下面这样：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190329065048950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：Pycharm+Python3+PyQt5+QtDesigner环境搭建有些复杂，笔者也花了不少时间去研究怎么安装。限于篇幅，这里不方便展开来讲。反正还是一句话，要善于使用搜索引擎。&lt;/p&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;4.1 hello world&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
from PyQt5.QtWidgets import QApplication, QWidget


if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple')
    w.show()
    sys.exit(app.exec_())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190329065105458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;hello-world代码详解&quot;&gt;4.2 hello world代码详解&lt;/h2&gt;
&lt;p&gt;笔者这边来一句句解释一下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
from PyQt5.QtWidgets import QApplication, QWidget&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引入了PyQt5.QtWidgets模块，这个模块包含了基本的组件。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;app = QtGui.QApplication(sys.argv)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个PyQt5应用都必须创建一个应用对象。sys.argv是一组命令行参数的列表。Python可以在shell里运行，这个参数提供对脚本控制的功能。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;w = QtGui.QWidget()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;QWidge控件是一个用户界面的基本控件，它提供了基本的应用构造器。默认情况下，构造器是没有父级的，没有父级的构造器被称为窗口（window）。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;w.resize(250, 150)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;resize()方法能改变控件的大小，这里的意思是窗口宽250px，高150px。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;w.move(300, 300)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;move()是修改控件位置的的方法。它把控件放置到屏幕坐标的(300, 300)的位置。&lt;/p&gt;
&lt;p&gt;注：屏幕坐标系的原点是屏幕的左上角。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;w.setWindowTitle('Simple')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们给这个窗口添加了一个标题，在标题栏展示。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;w.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;show()能让控件在桌面上显示出来。控件在内存里创建，之后才能在显示器上显示出来。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sys.exit(app.exec_())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们进入了应用的主循环中，事件处理器这个时候开始工作。主循环从窗口上接收事件，并把事件传入到派发到应用控件里。当调用exit()方法或直接销毁主控件时，主循环就会结束。&lt;/p&gt;
&lt;p&gt;sys.exit()方法能确保主循环安全退出。外部环境能通知主控件怎么结束。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190329065126685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190329065132336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190329065138631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;逻辑大概分为以下两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化ui（包括窗口位置，大小，图标，点击按钮等）&lt;/li&gt;
&lt;li&gt;在初始化ui方法中调用点击事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想要熟练使用PyQt，还是需要深入研究下这个库的使用，笔者这里只是抛砖引玉。&lt;/p&gt;
&lt;p&gt;关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，后台回复：&lt;strong&gt;zsxq06&lt;/strong&gt;，获取本文全套代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201902/649191-20190228222044609-1976101388.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; alt=&quot;Python专栏二维码&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 22:55:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>想要熟练使用PyQt，还是需要深入研究下这个库的使用，笔者这里只是抛砖引玉。 关注公众号「**Python专栏**」，后台回复：**zsxq06**，获取本文全套代码。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moonhmily/p/10618975.html</dc:identifier>
</item>
<item>
<title>C#闭包 - Minotauros</title>
<link>http://www.cnblogs.com/minotauros/p/10618913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minotauros/p/10618913.html</guid>
<description>&lt;p&gt;　　1.匿名方法和Lambda表达式中可以访问到声明该匿名方法或Lambda表达式所在方法中的参数或局部变量，这些变量称为外部变量（Outer Variable），外部变量的生命周期会持续到引用匿名方法或Lambda表达式的委托实例被垃圾回收器回收为止：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; myNum = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
Action myAction &lt;/span&gt;= () =&amp;gt;&lt;span&gt;
{
    Console.WriteLine(myNum); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处的myNum即该Lambda表达式的一个外部变量&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.调用匿名方法或Lambda表达式时，访问到的是外部变量最终的值，而不是声明该匿名方法或Lambda表达式时的值；同样，在匿名方法或Lambda表达式中修改外部变量的值后，在外部访问到的也是修改后的值；这个特性被称为闭包（Closure）；&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Action myAction = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
{
　　myAction &lt;/span&gt;+= () =&amp;gt;&lt;span&gt;
　　{
　　　　Console.Write(i); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于Lambda表达式调用了该变量i，此处会将i提升为一个字段，该字段最后取值为5
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或使用以下方式：
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int x = i;
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.Write(x);&lt;/span&gt;
　　　&lt;span&gt;};
}
myAction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;55555&lt;/span&gt;
&lt;span&gt;
myAction &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
{
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; closureIndex = i; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次都声明一个新的局部变量，由于Lambda表达式内调用了该新声明的变量closureIndex，此处相当于每次都会声明一个新的字段，并且互不影响取值&lt;/span&gt;
   myAction += () =&amp;gt;&lt;span&gt;
   {
       Console.Write(closureIndex);
   };
}
myAction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;01234&lt;/span&gt;
&lt;span&gt;
myAction &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; closureIndex =&lt;span&gt; i;
    myAction &lt;/span&gt;+=() =&amp;gt;&lt;span&gt;
    {
        Console.Write(closureIndex);
    };
    &lt;/span&gt;++&lt;span&gt;closureIndex;
}
myAction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12345    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.实际上，在声明匿名方法和Lambda表达式时，如果在方法或表达式内部调用了外部变量，编译器会创建一个以&amp;lt;&amp;gt;c__DisplayClass开头的匿名嵌套类，它包含该方法或表达式内调用的所有外部变量的字段，运行时会创建该匿名嵌套类的一个实例，并将外部变量的值传入该实例对应的字段，外部对该变量的所有操作也会变成对该嵌套类实例中字段的操作；&lt;/p&gt;
&lt;p&gt;　　此处以外部变量为值类型举例，对于引用类型，匿名嵌套类中会保存该引用类型的对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; myNum = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    Action myAction &lt;/span&gt;= () =&amp;gt;&lt;span&gt;
    {
        Console.WriteLine(myNum);
    };
    myNum &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    myAction();
    Console.Read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“推荐”按钮，您的认可是我写作的最大动力！&lt;/p&gt;
&lt;p&gt;作者：&lt;a title=&quot;Minotauros&quot; href=&quot;https://www.cnblogs.com/minotauros/&quot; target=&quot;_blank&quot;&gt;Minotauros&lt;/a&gt;&lt;br/&gt;出处：&lt;a title=&quot;https://www.cnblogs.com/minotauros/&quot; href=&quot;https://www.cnblogs.com/minotauros/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/minotauros/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;

</description>
<pubDate>Thu, 28 Mar 2019 18:08:00 +0000</pubDate>
<dc:creator>Minotauros</dc:creator>
<og:description>1.匿名方法和Lambda表达式中可以访问到声明该匿名方法或Lambda表达式所在方法中的参数或局部变量，这些变量称为外部变量（Outer Variable），外部变量的生命周期会持续到引用匿名方法或</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minotauros/p/10618913.html</dc:identifier>
</item>
<item>
<title>TICTOC: Header Only C++ Timer - 喵耳朵</title>
<link>http://www.cnblogs.com/idiotgroup/p/10618891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idiotgroup/p/10618891.html</guid>
<description>&lt;p&gt;感觉最近的更新频率略高啊～哈哈～&lt;/p&gt;
&lt;p&gt;这次的带来的是一个十分简单便利的C++计时库。&lt;/p&gt;

&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/miaoerduo/tictoc&quot; target=&quot;_blank&quot;&gt;https://github.com/miaoerduo/tictoc&lt;/a&gt; 欢迎&lt;strong&gt;Start&lt;/strong&gt;和提&lt;strong&gt;MR&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;项目中有详细的说明和Demo，可以很直观的体验到这个库的易用性。&lt;/p&gt;
&lt;p&gt;先看一下效果，如果我们正确使用的话，大致会出现类似下面的信息：&lt;/p&gt;
&lt;pre class=&quot;wp-block-code&quot;&gt;
&lt;code&gt;demo.cpp @ main [    8,   13]   elapsed:      0.025 s      24.786 ms       24786 us
demo.cpp @ main [    8,   18]   elapsed:      0.049 s      48.709 ms       48709 us
demo.cpp @ main [    8,   23]   elapsed:      0.072 s      72.211 ms       72211 us
demo.cpp @ main [    8,   24]   elapsed:      0.072 s      72.225 ms       72225 us
demo.cpp @ main [   30,   36]   elapsed:      0.022 s      21.747 ms       21747 us
demo.cpp @ main [   36,   41]   elapsed:      0.021 s      21.463 ms       21463 us&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以显示，我们的每个区域的代码（包括行号）的消耗时间。精确到微秒。&lt;/p&gt;
&lt;p&gt;起因是这样的，之前有很长时间的工作内容是优化一些特定的函数，保证新旧的SDK的速度的对齐。然后C++虽然有一些工具可以分析运行状态，但通常还是简单的打印时间来的方便 &lt;span&gt;/* Print大法好 */&lt;/span&gt; 。之后，和工程的小伙伴一起Debug的时候，就发现他写了一个头文件，然后用绝对路径的方式去include，二头文件里面就是各种常用的小工具，而最常用到的就是时间的打印。&lt;/p&gt;
&lt;p&gt;之后，我专门要到了他的百宝箱，仔细分析了一下，发现计时器模块仍然存在一些问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在Debug的时候，如果加上工具代码，在Release的时候，还得一点点删掉，很麻烦。&lt;/li&gt;
&lt;li&gt;修改时间精度的话，需要修改源码，略麻烦。&lt;/li&gt;
&lt;li&gt;打印的时间戳的信息不完整，看不出来该段时间具体的代码的范围。&lt;/li&gt;
&lt;li&gt;计时器如果在多个文件中都用到，会有各种奇怪的错误，重复定义变量啊，或者找不到变量啥的。&lt;/li&gt;
&lt;li&gt;对更复杂的程序，比如各种库的编译，多个库的链接调用不支持。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面说的问题，说大不大，说小不小。如果能有个工具能解决上面5个问题，那也是一件十分惬意的事情。所以，也就有了本文和&lt;strong&gt;TICTOC&lt;/strong&gt;这个库。接下来，我们会从上面的5个问题开始，一点一点介绍C++的小技巧。&lt;/p&gt;
&lt;h3&gt;〇、设计思路&lt;/h3&gt;
&lt;p&gt;其实计时器的思路很简单，就是定义两个宏TIC和TOC，如果插入TIC，则记录为起始时间，当插入TOC的时候，则计算与上一次TIC之间的时间，并打印出来。&lt;/p&gt;
&lt;p&gt;比较麻烦的是，如果我在使用TIC的时候，生成一个变量，那连续使用两次TIC的话，就会出现变量的重复定义。另一个方案就是在全局定义一个时间的变量，但这样会带来另一个问题，就是所有函数都共享这个变量，如果函数内部再运行一次TIC，会覆盖掉这个时间戳，但是其他的TOC的结果不直观。&lt;/p&gt;
&lt;p&gt;所以，这里就使用了一个字典，来存放TIC的时间戳。这个字典本身是使用单例模式去生成和维护的。每次TIC的时候都会初始化一次它，但是由于是单例，所以只有第一次会耗时。而字典的键是个字符串，由文件名+函数名联合构成。这样针对每个函数，都会有自己的一个计时器，就不用担心冲突了。之后运行TOC的时候，也会检查当前的文件名和函数名，从而与对应的TIC时间戳相减。是不是听起来很简单！&lt;/p&gt;
&lt;p&gt;当然还会碰到很多奇怪的问题，其中最无语的是，当动态库使用这个库，而主程序也使用这个库的时候，所谓的单例模式就失效了，两段程序里面都会有这个字典，然后就冲突了，出现double free的情况。查了半天，才发现是动态库只在静态表导出这个单例，动态连接器默认查询动态表，没找到，从而主程序自己又重复构建了这个实例，导致了存在两个实例。最终用-rdynamic的方式编译就可以解决。但是用这种方式的话，又会显得很麻烦。我采用的解决方法是匿名命名空间，在每个文件中生成自己的单例。细节我们在后面会谈到。&lt;/p&gt;
&lt;h3&gt;一、Debug or Release？&lt;/h3&gt;
&lt;p&gt;因为我们不希望在Deliver的时候，再修改代码，所以有没有办法，使用不同的宏来控制我们的程序呢？当然是可以的。C/C++最常用到的预处理语句：#define, #ifdef, #ifndef，#else, #endif。采用下面的方式来进行就可以。&lt;/p&gt;
&lt;pre class=&quot;wp-block-code&quot;&gt;
&lt;code&gt;#ifndef TICTOC_HPP
#define TICTOC_HPP

#ifdef WITH_TICTOC
// 一些计时器的逻辑单元
// 函数啥的
#else
// 一些假的信息
// 比如宏函数，内容空的，免得编译不过
#endif

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，这个TICTOC_HPP的宏定义，是为了防止头文件的多次包含。不然在多处include这个头文件的时候，会出现函数重复定义的问题。是一个良好的编程习惯。&lt;/p&gt;
&lt;p&gt;WITH_TICTOC这个宏才是用来控制我们的Debug/Release的关键。在Debug的时候，编译加入一个宏定义，用g++直接编译的话，就是编译的时候加上&lt;em&gt;&lt;strong&gt;-DWITH_TICTOC&lt;/strong&gt;&lt;/em&gt;。用CMakeList的话，就是另一套了，自己查一下吧。在Release的时候，去掉这个宏定义就行，这样编译走的就是#else的分之，里面可以不写代码（我这里还是写了几行，定义了一些宏，但是宏的操作是空的）。&lt;/p&gt;
&lt;p&gt;总之，灵活的使用宏定义，就可以让我们的编译器按照我们的想法去工作！&lt;/p&gt;
&lt;h3&gt;二、多种精度&lt;/h3&gt;
&lt;p&gt;问题二就比较简单了，既然每设置一种精度，都要修改一下代码，不如一次性的将所有的精度都打印出来了！这部分似乎没有什么好说的，就简单的说一下，我这里用到的计时的函数吧。&lt;/p&gt;
&lt;pre class=&quot;wp-block-code&quot;&gt;
&lt;code&gt;#include&amp;lt;sys/time.h&amp;gt;
/*
struct timeval {
    time_t       tv_sec;     // seconds
    suseconds_t  tv_usec;    // microseconds
};
*/
struct timeval get_tick() {
    struct timeval time;
    gettimeofday(&amp;amp;time, NULL);
    return time;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;timeval是一个表示时间的结构体，可以精确到微秒级别，完全够我们使用了。&lt;/p&gt;
&lt;h3&gt;三、打印完整的信息&lt;/h3&gt;
&lt;p&gt;首先，对于一个计时器，为了方便调试，我们希望知道什么信息呢？这里列出来我比较关心的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个时间戳所在的位置，包括：文件名，函数名&lt;/li&gt;
&lt;li&gt;时间戳是哪一段代码产生的，即：起始和结束的代码行号&lt;/li&gt;
&lt;li&gt;具体的时间（按不同精度显示）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于3，上文已经介绍了。那么如何获取文件名、函数名以及行号呢？&lt;/p&gt;
&lt;p&gt;其实C++中（C语言中也有的）早就给我们定义好了一些宏。这里就简单的列一下常用的几个，大家感兴趣也可以自己去查询：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;__FILE__ : 宏所在的文件名&lt;/li&gt;
&lt;li&gt;__FUNCTION__ : 宏所在的函数名&lt;/li&gt;
&lt;li&gt;__LINE__ : 当前行号&lt;/li&gt;
&lt;li&gt;__DATE__, __TIME__ : 最后一次编译的时间&lt;/li&gt;
&lt;li&gt;__TIMESTAMP__ : 文件最后的修改时间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，我们这里主要用到三个：__FILE__, __FUNCTION__, __LINE__ 。&lt;/p&gt;
&lt;h3&gt;四、Working Everywhere&lt;/h3&gt;
&lt;p&gt;上面的问题4和5，放在一起介绍。&lt;/p&gt;
&lt;p&gt;针对问题4，是我们在多个文件同时使用了计时器，如果通过全局变量的方式去存储时间戳，那么每个文件都会有自己的时间戳，从而导致冲突（当然，把时间戳改成static的可能可以解决）。而且，同一个文件中，如果出现函数调用，也有修改这个全局的时间戳，导致打印时间很不友好。&lt;/p&gt;
&lt;p&gt;这里使用字典来存放时间戳，给每个文件都创建自己的时间戳，从而解决了这个问题。在〇章中，也有介绍。&lt;/p&gt;
&lt;p&gt;那么问题5就很复杂了，多个动态库同时使用时，会崩溃。首先，为了让字典在程序中，只存在一份，我这里使用了单例模式。如果把所有的文件都编译在一起，是完全OK的。问题就出在，如果动态库使用了这个工具，而主程序也使用该工具，且又链接了动态库，那么程序中就会出现多个字典，在程序退出析构的时候，就会出现多次free的情况（很奇怪吧，明明是两个实例，居然两次析构函数都调用同一个实例）。之前也说了，用-rdynamic的方式编译会很麻烦，而且我们不可能给整个大项目的每个部分都加这个编译选项吧。我们的工具库要足够的独立！&lt;/p&gt;
&lt;p&gt;按照之前的分析，我们其实只需要给每个函数都分配自己的一个键就可以了，其实完全没必要只有一个Global的字典，只需要给每个文件都生成自己的字典不就OK了吗。但是，怎么去实现呢？&lt;/p&gt;
&lt;p&gt;常见的方法有两个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;static 变量，static 关键字有一个功能，是保证这个变量只在该文件中使用。不会导出。&lt;/li&gt;
&lt;li&gt;匿名命名空间，也叫匿名名字空间，这里采用的就是这个方案。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;wp-block-code&quot;&gt;
&lt;code&gt;namespace {
    void print() {
        std::cout &amp;lt;&amp;lt; &quot;hello world&quot; &amp;lt;&amp;lt; std::endl;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是最简单的匿名命名空间，如果我们在代码中这么定义，其等价于：&lt;/p&gt;
&lt;pre class=&quot;wp-block-code&quot;&gt;
&lt;code&gt;namespace thisisaspecificnamespace {
    void print() {
        std::cout &amp;lt;&amp;lt; &quot;hello world&quot; &amp;lt;&amp;lt; std::endl;
    }
}

using namespace thisisaspecificnamespace;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;里面的这个大长串是啥意思？&lt;/p&gt;
&lt;p&gt;其实thisisaspecificnamespace这个名字是我瞎写的，对于编译器，他会给这个匿名命名空间生成一个独一无二的名字，保证一定不重复，然后在改文件中，using它。所以自然就只有这个文件本身能够调用里面的函数了。&lt;/p&gt;
&lt;p&gt;我们的工具是一个纯头文件，所有的库想依赖该文件，都会直接include它，而include操作其实就是简单的copy文件的内容，所以这段代码就会进入每个文件自身中，成为其源码的一部分。如此，只要我们把单例维护的代码放在匿名命名空间中，就可以保证其在每个文件中有且只有一个。就不用担心不同的库之间的冲突了。&lt;/p&gt;
&lt;h3&gt;五、补充&lt;/h3&gt;
&lt;p&gt;最后，我编写的这个库，并没有花费太多的时间，不过编程的过程中，确实还是感受到一点快乐的。不知不觉，现在写代码的时候，更喜欢以一种工具或是框架的角度去审核自己的作品。相比于追求编程的速度，慢慢蜕变成追求更优雅的设计，更简洁和实用的功能以及尽可能好的兼容性。&lt;/p&gt;
&lt;p&gt;这里，小喵与你共同进步！&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 17:32:00 +0000</pubDate>
<dc:creator>喵耳朵</dc:creator>
<og:description>Header Only C++ Timer，简易实用的C++计时器，本文的重点在于项目中用到的C++编程的知识（单例、宏、名字空间等，我也不知道为啥这个功能需要这么多技术，但确实都是要用到的），以及安</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idiotgroup/p/10618891.html</dc:identifier>
</item>
<item>
<title>React 精要面试题讲解(五) 高阶组件真解 - 散场丶丶</title>
<link>http://www.cnblogs.com/sanchang/p/10614074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanchang/p/10614074.html</guid>
<description>&lt;h3 id=&quot;说明与目录&quot;&gt;说明与目录&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; 在学习本章内容之前，最好是具备react中‘插槽(children)’及‘组合与继承’ 这两点的知识积累。
 详情请参照React 精要面试题讲解(四) 组合与继承不得不说的秘密。
 哦不好意思忘记了，四还没写呢。==！回头补上。
  __首先，我们要知道高阶组件能够做到什么：  对复用UI、数据逻辑等进行封装，对参数组件进行制式处理，从而让参数组建具备特定的ui或功能__
 那么本节的学习目录： &lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;高阶函数的认知&lt;/li&gt;
&lt;li&gt;类的修饰器(decorator)的认知(类比高阶函数)&lt;/li&gt;
&lt;li&gt;高阶组件的认知(类比修饰器)&lt;/li&gt;
&lt;li&gt;高阶组件的两种形式(类比插槽)&lt;/li&gt;
&lt;li&gt;高阶组件之组合(代理)类型的高阶组件&lt;/li&gt;
&lt;li&gt;高阶组件之继承类型的高阶组件&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;高阶组件的认知总结&lt;/p&gt;
&lt;p&gt;必须深刻认知，以上内容是循序渐进且相互关联的关系，按照流程，我们将彻底把高阶组件安排的明明白白，玩个透彻。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;高阶函数的认知&quot;&gt;1. 高阶函数的认知&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;在本系列之前的学习中，你应当明白——组件的本质是函数。
那么什么是高阶函数？ 
高阶函数也是一个函数，__它接受函数为参数,返回处理过后的函数或者一个新函数__。
那么我们知道，高阶函数的作用是对参数函数进行统一的加工处理。
形如：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    //这里我们写了一个函数作为之后的参数
    //思考一下为什么把参数函数定义在上面
    function testedFunc(){
          this.a = 1;
    }

    // 在此定义一个高阶函数
    function highOrderFunc(func){
        func.prototype.aaa = 3;
        return func;    
    }

    //这里测试一下我们写的高阶函数
   var newFunc =  highOrderFunc(testedFunc);
  
   //打印看看处理后的函数原型及实例
   console.log(newFunc.prototype,1);
   console.log(new newFunc(),2);
   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（别那么懒，赶紧复制粘贴f12）&lt;br/&gt;打印结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190328112712880-707396687.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190328112719664-1651193687.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;那么我们知道了，高阶函数 作用是 处理(加工)传入的函数，以达成某种目的…&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;类的修饰器decorator的认知&quot;&gt;2. 类的修饰器(decorator)的认知&lt;/h3&gt;
&lt;p&gt;ES6增添了class类，我们知道，类的本质也是函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     class testClass{
       a = 1;
    }
     console.log( typeof testClass)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;打印结果如下：&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190328120116124-1272779002.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;那么类的修饰器——decorator 是个怎样的东西咧？
__类的修饰器是es6的提案之一，在es7标准中实现。 修饰器也是一个函数，把传入的原有类修饰一下，return 出处理后的类或新类。__
这时候我们脑海中应该闪过一个词——高阶类…(？？？黑人问号)
不觉得太难听了吗？ &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;ok,我们还是以代码来演示一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //注意，下面这种@xx的写法是修饰器的标准写法，是属于es7的产物，要用babel哦~


    //定义一个修饰器decF
    function  decF(adornedClass){
        return class extends adornedClass{
                b= 2
        }
    }
 
// 使用方式1 ： @decF
   @decF
   class foo{
       a =  1 
   }
 console.log( new foo(),1)

 class bar{
    a='bar'
 }
// 使用方式2 ： decF(); 
 const newBar =  decF(bar);
 console.log( new newBar(),2);
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190328155949943-57646521.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;瞧啊，修饰器就是这么个东西。&lt;br/&gt;要注意的是，类的修饰器能否修饰函数？为什么？&lt;br/&gt;// 可以自己去找答案，再讲别的就跑题了。&lt;br/&gt;___&lt;/p&gt;
&lt;h3 id=&quot;高阶组件的认知类比修饰器&quot;&gt;3. 高阶组件的认知(类比修饰器)&lt;/h3&gt;
&lt;p&gt;那么经过类的修饰器的认知，高阶组件的概念就很明朗了。&lt;br/&gt;React高阶组件(high-order-component,简称hoc)就是一个类的修饰器啊…它接受一个组件类为参数，返回出一个新的组件类;&lt;br/&gt;形如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   // 用法1 高阶函数式写法 
    hoc(WrapedComponent);
   // 用法2  decorator 修饰器写法 
   @hoc
   class A extends React.Component{
      //...
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家有木有很眼熟啊 ？&lt;/p&gt;
&lt;p&gt;ok， 我们写一个常规的高阶组件并暴露出去;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   export default  WrapedComponent  =&amp;gt; class  NewComponent extends React.Component{

         render(){
           return &amp;lt;WrapedComponent  a = '添加了一个属性' /&amp;gt;
         }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种箭头函数的写法好理解吧。&lt;br/&gt;如代码所示，我们写了一个高阶组件，返回的新组件 NewComponent里，用组合的形式使用了传入的组件WrapedComponent。（所以不明白组合与继承的童鞋，赶紧补一补再来看啊）&lt;br/&gt;这里有人问 connect为啥两个括号啊&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //形如
 connect(func1,func2 )( WrapedComponent)   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK ，我们也手写一下它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     export default (func1,func2)=&amp;gt;WrapedComponent=&amp;gt;class NewComponent extends React.Component{
        // ....
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个两层箭头函数好理解吧？&lt;/p&gt;
&lt;p&gt;顺便说下，一般像connect这样多嵌套了一层的高阶函数，我称之为二阶高阶函数。此后类推，三个括号就叫三阶高阶函数…&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;高阶组件的两种形式类比插槽&quot;&gt;4. 高阶组件的两种形式(类比插槽)&lt;/h3&gt;
&lt;p&gt;同children 一样，高阶组件也存在组合(也可称之为代理)和继承两种形式。&lt;br/&gt;那么高阶组件和children插槽有什么关系呢？&lt;br/&gt;我们来类比以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  //写一个组合形式的具备插槽功能的组件Provider 
   class Provider extends React.Component{
        render(){
            return (
                &amp;lt;div&amp;gt;
                    {this.props.children}
                &amp;lt;/div&amp;gt;
            )
        }
   }
  // 下面是使用的方式
    import ComA from  './ComA'
    const  useB =  (&amp;lt;Provider &amp;gt; &amp;lt;ComA  a='使用Provider时添加了a属性'/&amp;gt; &amp;lt;/Provider &amp;gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;   // 写一个组合形式的高阶组件
   const hocAddA = WrapedComponent =&amp;gt; class NewComponent extends React.component{
        render(){
            return (
                &amp;lt;div&amp;gt;
                      &amp;lt;WrapedComponent  a ='定义hocAddA时添加了a属性'/&amp;gt;
                &amp;lt;/div&amp;gt;
            )
        }
    }
   // 我们来尝试使用它
   const NewA  =  hocAddA(ComA);
   // 或者
   @hocAddA 
   class ComB ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok, 上述两种代码在使用后的表现几乎是一致的(同样实现了给ComA添加属性a的功能)。&lt;br/&gt;但是注意，插槽(children)的实现，不关心插槽组件的功能变化。只是把插槽当作当前组件的子组件去使用(这就是组合)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   //同样的，我现在这样使用
    import ComA from  './ComA'
    const  useB =  (&amp;lt;Provider &amp;gt; &amp;lt;ComA  b='使用Provider时添加了b属性'/&amp;gt; &amp;lt;/Provider &amp;gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而高阶函数，在定义时就写死了参数组件的功能变化。&lt;br/&gt;传入组件，得出的组件只会添加属性a。&lt;br/&gt;当然，我们也可以通过二阶高阶函数实现 用参数控制参数组件的功能变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  定义一个二阶高阶组件
   const hocAddProps =  props =&amp;gt; WrapedComponent =&amp;gt; class NewComponent extends React.Component{
        render(){
            return (
                &amp;lt;div&amp;gt;
                      &amp;lt;WrapedComponent  {...props}/&amp;gt;
                &amp;lt;/div&amp;gt;
            )
        }
  }
  //  于是我们这样使用它
  const  propsAdded = { 
        a: '添加了一个属性a',
        b: ‘添加了一个属性b'
  } 
  const  NewA = hocAddProps(propsAdded)(ComA)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;诸如此类。实际上组合形式的高阶组件能做到的事，用children基本都能做到。&lt;/p&gt;
&lt;p&gt;那么组合形式的高阶组件和继承形式的高阶组件的区别在哪呢？&lt;br/&gt;&lt;strong&gt;组合形式(也称之为代理形式)： 返回的新组件，继承的还是React.Component,只是把参数组件作为新组件的子组件去使用，能够实现给参数组件进行包装、属性的增删改、状态抽离等功能.&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;继承形式： 返回的新组件，继承的是 参数组件 ，从而实现以参数组件为模版，改写参数组件的功能。&lt;/strong&gt;&lt;br/&gt;上述划重点，要考。&lt;br/&gt;我们再回过头来思考类的修饰器——返回一个新的类或改写参数类。&lt;br/&gt;是不是一样的道理啊。&lt;br/&gt;所以说高阶组件啥的，还是js啊,最多加了jsx的语法嘛。&lt;/p&gt;
&lt;h3 id=&quot;高阶组件之组合代理类型的高阶组件&quot;&gt;5. 高阶组件之组合(代理)类型的高阶组件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;上述我们已经知道了组合(代理)类型的高阶组件的概念和思想，以及它能实现的功能。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们上demo代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     
import React,{Component,createRef} from  'react';
export default  title=&amp;gt;WrapedComponent=&amp;gt; class NewComponent extends Component{
    //抽离状态
    state={
        value:''
    }
    // 访问refs 
    myref=createRef();
    handleInputChange=(e)=&amp;gt;{
        this.setState({
            value:e.target.value
        })
    }

    render(){
        const {wap,...otherprops} = this.props;
        const newProps = {
            value:this.state.value,
            onChange:this.handleInputChange
        }
        //包装组件
        return (
            &amp;lt;div&amp;gt;
                我是组件NewComponent，是典型的代理形式的高阶组件，我除了做自己的事，还可以对 我的参数组件：
                  1增加/删减props 2抽离状态 3访问ref  4包装组件
                &amp;lt;div&amp;gt;我的title：{title}&amp;lt;/div&amp;gt;
                &amp;lt;WrapedComponent {...otherprops} ref={this.myref} inputProps={newProps}/&amp;gt;
            &amp;lt;/div&amp;gt;
        )
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要单独说一下上述功能中的状态抽离。&lt;br/&gt;&lt;strong&gt;状态抽离(状态提升): 把参数组件(即代理形式中使用的子组件)的状态提升到NewComponent(即代理形式中的当前组件，也就是父组件) 中，这样一来，子组件只负责UI渲染，而父组件通过props传递state实现数据的控制&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;也就是说， NewComponent 成为参数组件的容器组件，参数组建单纯作为UI组件&lt;/strong&gt;&lt;br/&gt;ps： 容器组件和UI组件的概念是相对的。 例如 把B的状态抽离到父组件A上，那么A相对于B来说是B的容器组件，要这么去理解。后续讲react-redux中会提到。&lt;br/&gt;___&lt;/p&gt;
&lt;h3 id=&quot;高阶组件之继承类型的高阶组件&quot;&gt;6. 高阶组件之继承类型的高阶组件&lt;/h3&gt;
&lt;p&gt;同样的，上述我们已经知道了 继承类型的高阶组件的概念和思想，那么我们也直接上demo代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React from  'react'

//这个是给返回的新组件起名用的函数，有兴趣可以结合调试器玩玩。
function getDisplayName(WrapedComponent){
    return WrapedComponent.displayName||WrapedComponent.name||'component'
}

export default  color=&amp;gt;WrapedComponent=&amp;gt; class NewComponent extends WrapedComponent{
    // static displayName = `E(${getDisplayName(Inconponent)})`
;    
    aaa = '我改写了参数组件中的aaa属性'
    compoenentDidMount(){
        console.log('我不仅可以改写属性和方法，我还能改写钩子')
    }
    render(){
        const {wap,...otherprops} = this.props;
        const element = super.render();
        console.log(element);
        const newStyle = {
            color:element.type==='div'?color:null
        }
        const newProps = {
            ...otherprops,
            style:newStyle
        }
       // 我甚至还改写了参数组件的UI
        return React.cloneElement(element,newProps,element.props.children)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上述代码所示(跟着敲一下啊懒虫),我们成功做到了以参数组件为模版，改写了参数组件中已定义的属性、方法、钩子，甚至UI，增添了参数组件中未定义的属性、方法、钩子等。&lt;br/&gt;当然，同官方文档中 ‘组合和继承’ 这一章中的思想一致，绝大部分情况下，我们用不到继承类型的高阶组件，也不提倡这种形式的用法(其实我个人觉得挺好玩的)。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;高阶组件的认知总结&quot;&gt;7. 高阶组件的认知总结&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;那么我们通过以上学习，已经完完整整掌握了高阶组件的使用。
在日常项目中，我们也可以在合适的场景中使用高阶组件完成对应的需求。
回顾最上面提到过的高阶组件的使用场景:
 __对复用UI、数据逻辑等进行封装，对参数组件进行制式处理，从而让参数组建具备特定的ui或功能__

再回顾下上述讲到过的高阶函数，类的修饰器等——
你get到了吗？

面试中会问到高阶组件的问题，消化掉这一篇，那么你便可以连续不断的给面试官讲上半个小时征服他。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，如果本章内容对你的react学习有帮助，记得点个关注，等待更新哦。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 17:15:00 +0000</pubDate>
<dc:creator>散场丶丶</dc:creator>
<og:description>高阶组件存在组合(也可称之为代理)和继承两种形式，学习本章内容，让你彻底消化React高阶组件。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanchang/p/10614074.html</dc:identifier>
</item>
<item>
<title>Java 集合系列（二）—— ArrayList - 那一叶随风</title>
<link>http://www.cnblogs.com/phpstudy2015-6/p/10618707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/phpstudy2015-6/p/10618707.html</guid>
<description>&lt;h4&gt;ArrayList&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;　　ArrayList 是通过一个数组来实现的，因此它是在连续的存储位置存放对象的引用，只不过它比 Array 更智能，能够根据集合长度进行自动扩容。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　假设让我们来实现一个简单的能够自动扩容的数组，我们最容易想到的点就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;add()的时候需要判断当前数组size+1是否等于此时定义的数组大小；&lt;/li&gt;
&lt;li&gt;若小于直接添加即可；否则，需要先扩容再进行添加。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实际上，ArrayList的内部实现原理也是这样子，我们可以来研究分析一下ArrayList的源码&lt;/p&gt;
&lt;h4&gt; &lt;code&gt;add(E e) &lt;/code&gt;源码分析&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Appends the specified element to the end of this list.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e element to be appended to this list
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; (as specified by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Collection#add})
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         ensureCapacityInternal(size + 1);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行扩容校验&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         elementData[size++] = e;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将值添加到数组后面，并将 size+1&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * The array buffer into which the elements of the ArrayList are stored.
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * The capacity of the ArrayList is the length of this array buffer. Any
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * will be expanded to DEFAULT_CAPACITY when the first element is added.
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; Object[] elementData; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; non-private to simplify nested class access&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ensureCapacityInternal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; elementData 数组&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * Default initial capacity.
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     * Shared empty array instance used for default sized empty instances. We
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * first element is added.
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回最大的 index&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; calculateCapacity(Object[] elementData, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  与空数组实例对比&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.max(DEFAULT_CAPACITY, minCapacity);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; minCapacity;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ensureExplicitCapacity(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (minCapacity - elementData.length &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            grow(minCapacity);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩容调用方法，实际也就是数组复制的过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Increases the capacity to ensure that it can hold at least the
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * number of elements specified by the minimum capacity argument.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; minCapacity the desired minimum capacity
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; grow(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; elementData.length;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             newCapacity =&lt;span&gt; minCapacity;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             newCapacity =&lt;span&gt; hugeCapacity(minCapacity);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; minCapacity is usually close to size, so this is a win:&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         elementData =&lt;span&gt; Arrays.copyOf(elementData, newCapacity);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; &lt;code&gt;add(int index, E element) &lt;/code&gt;源码分析&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Inserts the specified element at the specified position in this
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * list. Shifts the element currently at that position (if any) and
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * any subsequent elements to the right (adds one to their indices).
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index index at which the specified element is to be inserted
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; element element to be inserted
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         rangeCheckForAdd(index);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 校验index是否超过当前定义的数组大小范围，超过则抛出 IndexOutOfBoundsException&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         ensureCapacityInternal(size + 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount!!&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         System.arraycopy(elementData, index, elementData, index + 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                          size - index);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复制，向后移动&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         elementData[index] =&lt;span&gt; element;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         size++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * A version of rangeCheck used by add and addAll.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheckForAdd(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (index &amp;gt; size || index &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的源码分析可知，扩容和随机插入元素的消耗比较大，因此在实际开发中，应尽量指定ArrayList大小，减少在随机插入操作。&lt;/p&gt;

&lt;h4&gt;优缺点&lt;/h4&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装了一个动态再分配的对象数组&lt;/li&gt;
&lt;li&gt;使用索引进行随机访问效率高&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺陷&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在数组中增删一个元素，所有元素都要往后往前移动，效率低下&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;知识脑图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/789055/201903/789055-20190329000534675-1715331614.png&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在 github 上建了一个 repository ，Java Core Knowledge Tree，各位看官若是喜欢请给个star，以示鼓励，谢谢。&lt;br/&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsuifeng412%2FJCKTree&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/suifeng412/JCKTree&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（以上是自己的一些见解，若有不足或者错误的地方请各位指出）&lt;/p&gt;
&lt;p&gt; 作者：&lt;a href=&quot;http://www.cnblogs.com/phpstudy2015-6/&quot; target=&quot;_blank&quot;&gt;那一叶随风&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/phpstudy2015-6/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/phpstudy2015-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 原文地址： &lt;a href=&quot;https://www.cnblogs.com/phpstudy2015-6/p/10618707.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/phpstudy2015-6/p/10618707.html&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/phpstudy2015-6/p/%20https://www.cnblogs.com/phpstudy2015-6/p/6732784.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 声明：本博客文章为原创，只代表本人在工作学习中某一时间内总结的观点或结论。转载时请在文章页面明显位置给出原文链接&lt;/p&gt;

</description>
<pubDate>Thu, 28 Mar 2019 16:20:00 +0000</pubDate>
<dc:creator>那一叶随风</dc:creator>
<og:description>ArrayList ArrayList 是通过一个数组来实现的，因此它是在连续的存储位置存放对象的引用，只不过它比 Array 更智能，能够根据集合长度进行自动扩容。 假设让我们来实现一个简单的能够自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/phpstudy2015-6/p/10618707.html</dc:identifier>
</item>
<item>
<title>EIGRP 高级实验 - Pretty_girll</title>
<link>http://www.cnblogs.com/prettygirll/p/10617761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/prettygirll/p/10617761.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、环境准备&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 软件：GNS3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 路由：c7200&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、实验操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;WordSection1&quot; readability=&quot;75.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实验要求：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、掌握EIGRP  的不等价均衡的条件。&lt;/p&gt;
&lt;p&gt;2、掌握EIGRP  的metric  值修改方法。&lt;/p&gt;
&lt;p&gt;3、掌握 EIGRP  的 AD、FD、FC、Successor、FS  概念。&lt;/p&gt;
&lt;p&gt;4、理解EIGRP  的认证过程。&lt;/p&gt;
&lt;p&gt;5、掌握EIGRP  的认证的配置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;实验拓扑：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328212431384-2113792628.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实验过程：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;WordSection1&quot; readability=&quot;55.5&quot;&gt;
&lt;p&gt;1、配置各台路由器的IP  地址，并且使用ping  命令确认各路由器的直连口的互通性&lt;/p&gt;
&lt;p&gt;     参照作者 路由协议与交换技术~&lt;span lang=&quot;EN-US&quot;&gt;RIP实验&lt;span lang=&quot;EN-US&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、在每个路由器上配置 EIGRP 协议&lt;/p&gt;
&lt;p&gt;参考命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span readability=&quot;3&quot;&gt;R1 配置：&lt;p&gt;R1(config)#router eigrp 33                              

R1(config-router)#network 192.33.1.0

R1(config-router)# network 192.33.3.0

R1(config-router)# network 192.33.4.0&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 R2 和 R3 上做相同的配置，注意 network  后面的网络地址不同。&lt;/p&gt;
&lt;p&gt;问题 1：在 R1 中查看路由表，到达哪个网络的路由实现了负载均衡，是等代价的还是不等代价的，为什么？&lt;/p&gt;
&lt;p&gt;R1 路由器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328214219442-1313250786.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：到达192.33.2.0网络的路由实现了负载均衡。两条路由是等价的，因为两条路由的FD值相同。&lt;/p&gt;
&lt;p&gt;问题 2：在 R1 中查看拓扑表，看到达网络 192.168.6.0 的 AD 和 FD 是多少，在 R2 中查看拓扑表，到达网络 192.168.6.0 的 AD 和 FD 是多少？&lt;/p&gt;
&lt;p&gt;R1 拓扑表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328214529362-1871008176.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：R1 到达网络 192.168.6.0 的 AD：128256 、FD：156160。&lt;/p&gt;
&lt;p&gt;R2 拓扑表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328215518383-1881533300.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;272&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：R2 到达网络 192.168.6.0 的 AD：128256 、FD：156160。&lt;/p&gt;
&lt;p&gt;3、为了实现负载均衡，修改 R2 的 f0/1 接口的带宽为 200Mbps，针对网络 192.168.6.0，让R2 成为 R1 的可行后继路由。&lt;/p&gt;
&lt;p&gt;参考命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R2(config)#int f0/1

R2(config-if)#bandwidth 200000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题 3：在 R1 中查看拓扑表，看到达网络 192.168.6.0 的 AD 和 FD 是多少，在 R2 中查看拓扑表，到达网络 192.168.6.0 的 AD 和 FD 是多少？&lt;/p&gt;
&lt;p&gt;R1 拓扑表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328221109732-64534910.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;WordSection1&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;答：R1 到达网络 192.168.6.0 的路径有两条。&lt;/p&gt;
&lt;p&gt;　　1、后继中 AD：128256 、FD：156160&lt;/p&gt;
&lt;p&gt;　　2、可行后继中 AD：143360 、FD：158720&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;R2 拓扑表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328221352931-405584726.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：R2 到达网络 192.168.6.0 的后继中 AD：128256 、FD：143360&lt;/p&gt;
&lt;p&gt;问题 4：通过对问题 2 和问题 3 的对比，哪些发生了变化。&lt;/p&gt;
&lt;p&gt;答：R1的拓扑表中多了一条到达192.33.6.0网络的可行后继路由，因为R2上到达网络192.33.6.0网络的FD值小于R1上到达网络192.33.6.0网络的FD值。同时，R2上到达网络192.33.6.0网络的FD值变小了。&lt;/p&gt;
&lt;p&gt;问题 5：在 R1 中查看拓扑表，看到达网络 192.168.6.0 的路径有几条？每条的 AD 和 FD 是多少？&lt;/p&gt;
&lt;p&gt;R1 拓扑表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328221109732-64534910.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：R1 到达网络 192.168.6.0 的路径有两条。&lt;/p&gt;
&lt;p&gt;　　1、后继中 AD：128256 、FD：156160&lt;/p&gt;
&lt;p&gt;　　2、可行后继中 AD：143360 、FD：158720&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;问题 6：为了实现不等代价负载均衡，应该在 R1 中修改 variance 值为多少？&lt;/p&gt;
&lt;p&gt;答：variance=2 &lt;/p&gt;
&lt;p&gt;4、为了实现不等代价负载均衡，在 R1 中修改 variance 值。&lt;/p&gt;
&lt;p&gt;参考命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1(config)#router eigrp 33                       

R1(config-router)#variance 2                     注：此参数修改为你在问题 6 中计算出来的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题 7：查看路由表，在路由条目 192.168.6.0 中有什么变化？&lt;/p&gt;
&lt;p&gt;R1 路由表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328235120268-1445823435.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：R1 到达192.168.6.0网络的路由条目有两条，实现了不等价的负载均衡。&lt;/p&gt;
&lt;p&gt;5、在 R1 和 R2 之间配置认证，和 RIP 的认证类似。&lt;/p&gt;
&lt;p&gt;参考命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1(config)#key chain xcu

R1(config-keychain)#key 1

R1(config-keychain-key)#key-string jiang              

R1(config)#interface FastEthernet0/0

R1(config-if)#ip authentication mode eigrp 33 md5           

R1(config-if)#ip authentication key-chain eigrp 33 xcu            

R1(config-if)#shutdown

R1(config-if)#no shutdown                  注：此处让重新生成路由表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题 8：此时在 R1 中查看路由表到达网络 192.168.5.0 的下一条，是否还是 192.168.1.2？为什么？&lt;/p&gt;
&lt;p&gt;R1 路由表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190328235815357-208943709.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：R1 到达网络 192.168.5.0 的下一条不是 192.168.1.2，而是192.33.3.2，因为R1和R2在192.33.2.0网络之间的通信不可以通过认证。&lt;/p&gt;
&lt;p&gt;6、参考步骤 5，在 R2 中做同样的配置，接口为 f0/0&lt;/p&gt;
&lt;p&gt;问题 9：配置后再查看 R1 的路由表，到达目标网络 192.168.5.0 的下一条是多少？为什么？&lt;/p&gt;
&lt;p&gt;R1 路由表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190329000531441-854469635.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：R1 到达网络 192.168.5.0 的下一条是 192.168.1.2，因为R1和R2在192.33.2.0网络之间的通信可以通过认证。&lt;/p&gt;
&lt;p&gt;7、将路由器 R1 修改为 stub 网络&lt;/p&gt;
&lt;p&gt;参考命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1(config)#router eigrp 33                           

R1(config-router)#eigrp stub receive-only&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题 10：配置后，在 R2 和 R3 上还能否看到 192.168.4.0 网段的路由？为什么？&lt;/p&gt;
&lt;p&gt;R2 路由表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190329001518971-1658982653.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;R3 路由表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190329001601168-441025530.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：在 R2 和 R3 上不能看到 192.168.4.0 网段的路由，因为R1经过配置之后，只能接收邻居发送过来路由信息，而不能发送自己的路由信息。&lt;/p&gt;


&lt;/div&gt;
</description>
<pubDate>Thu, 28 Mar 2019 16:19:00 +0000</pubDate>
<dc:creator>Pretty_girll</dc:creator>
<og:description>一、环境准备 1. 软件：GNS3 2. 路由：c7200 二、实验操作 实验要求： 1、掌握EIGRP 的不等价均衡的条件。 2、掌握EIGRP 的metric 值修改方法。 3、掌握 E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/prettygirll/p/10617761.html</dc:identifier>
</item>
<item>
<title>Kubernetes的DaemonSet（下篇） - 编程一生</title>
<link>http://www.cnblogs.com/xiexj/p/10618714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/10618714.html</guid>
<description>&lt;h3&gt;用Daemon Pod来进行通信&lt;/h3&gt;
&lt;p&gt;使用Pod来再DaemonSet中通信的手段有：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;推的方式:在DaemonSet中的Pod会被配置成发送更新到如状态数据库这样的服务。这些都没有客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;IP+端口方式：DaemonSet中的Pod可以使用主机端口。因此通过node的IP就可以访问。客户端知道了node的IP，就可以用实现约定配置好的端口进行通信了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;DNS方式：用同样的Pod选择器创建一个headless service，可以通过DNS使用终端资源或者获取数据的方式来探测DaemonSets。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;服务方式：用同样的Pod选择器来创建一个服务，使用这个服务来与任意一个node的后台进程通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;更新一个DaemonSet&lt;/h3&gt;
&lt;p&gt;node标签一旦被改变，DaemonSet会迅速的添加Pod到最新匹配的node上，并且从最新不匹配的node上删除Pod。&lt;/p&gt;
&lt;p&gt;修改DaemonSet创建的Pod是可以修改的。但是Pod不允许所有的字段都被更新。而且，DaemonSet控制器会使用原来的模板进行下一次的node创建。&lt;/p&gt;
&lt;p&gt;DaemonSet也是可以删除的。如果用kubectl指定了--cascade=false，那Pod就会留在node上。可以用一个不同的模板创建一个新的DaemonSet。当有匹配的标签出现时，可以用不同模板生成的新的DaemonSet来识别出所有已经存在的Pods。如果Pod模板不匹配，则不会修改或者删除Pod。&lt;/p&gt;
&lt;p&gt;在Kuberntes版本1.6或以后，可以使用DaemonSet的滚动更新。&lt;/p&gt;

&lt;h3&gt;DaemonSet的可选项&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;初始化脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接在node上运行守护进程肯定是可以的（比如使用init,upstartd或者systemd方式来启动）。但是如果使用DaemonSet会有很多好处。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;像管理应用一样监控和管理守护进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;与应用使用相同的配置语言和工具(如Pod templates，Kubectl)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在container里使用资源限制运行守护进程增强了守护线程和app容器的隔离性。然而，这个也可以通过在container而不是pod里运行daemon进程完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;裸Pod&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接指定node来创建Pod是可以实现的。但是DaemonSet可以自动替换由于任何原因被删除的或者停止的Pod，以防止node挂了或者其他类型的node维护，比如kernel升级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态Pod&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过在被Kubelet监听的目录下创建文件的方式生成Pod是可以实现的，它们被称为静态Pod。不像DaemonSet，静态Pod不能被kubectl或者其他K9s API客户端管理。静态Pod不依赖apiserver。一般是集群启动时候用到的。在后续的版本中，静态Pod可能被废弃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deployment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DaemonSet与Deployment的相同点是他们都用于创建Pod，这些Pod是不期望被意外停止的。&lt;/p&gt;
&lt;p&gt;使用Deployment可以管理无状态服务，如前端服务，它需要扩容和缩容指定的副本数，还可以滚动升级。而使用DaemonSet最重要的是产生一个Pod一直运行在指定的或者全部的宿主机上，或者是需要比其他的Pod先启动的场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247483841&amp;amp;idx=1&amp;amp;sn=c236d6829a2cce8ad56236bf75085bbf&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《两地书》--K8s基础知识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484268&amp;amp;idx=1&amp;amp;sn=d71f12722b0c031e4727359d0913ad5d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Kubernetes的污点和容忍（上篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484280&amp;amp;idx=4&amp;amp;sn=1fcddeb72c78ac671115977d9c71db5a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Kubernetes的污点和容忍（下篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484293&amp;amp;idx=1&amp;amp;sn=8891fcda24788e06f0d596c4e3c6fd1e&amp;amp;chksm=fafde92bcd8a603dd901aecb040f16900f8d46a90e29600573827a22410f5538f5c2c3b7bd4b&amp;amp;token=427554610&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Kubernetes的DaemonSet（上篇）&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者是一个有美国硅谷、日本东京工作经验，十二年坚持一线写代码的程序媛。坚持原创文章。欢迎技术交流！&lt;/p&gt;
&lt;p&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1112728/201903/1112728-20190324141710465-188141124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 16:07:00 +0000</pubDate>
<dc:creator>编程一生</dc:creator>
<og:description>用Daemon Pod来进行通信 使用Pod来再DaemonSet中通信的手段有： 推的方式:在DaemonSet中的Pod会被配置成发送更新到如状态数据库这样的服务。这些都没有客户端。 IP+端口方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/10618714.html</dc:identifier>
</item>
<item>
<title>Oracle 10g RAC OCR、Voting disk更换 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10618658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10618658.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;OEL 5.7 + Oracle 10.2.0.5 RAC&lt;br/&gt;&lt;strong&gt;需求：&lt;/strong&gt;更换存储，OCR、Voting disk同时需要更换到新存储。&lt;/p&gt;

&lt;p&gt;替换OCR（Oracle Cluster Registry）首先需要关闭RAC所有节点的crs，然后导出当前的ocr配置文件，手工修改ocr.loc文件后，导入ocr配置文件，可选择性创建ocrmirror。&lt;br/&gt;本次实验演示就是将原来的/dev/raw/raw1替换为/dev/raw/raw14，并创建ocrmirror为/dev/raw/raw15.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--replace ocr
--两个节点关闭crs
/s01/oracle/product/10.2.0/crs_1/bin/crsctl stop crs
--ocrcheck
/s01/oracle/product/10.2.0/crs_1/bin/ocrcheck 
--导出ocr的配置
/s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -export /tmp/ocrfile.dmp 
--查看文件大小
ls -lrt /tmp/ocrfile.dmp 
--两个节点修改ocr为新的/dev/raw/raw14
cat /etc/oracle/ocr.loc 
--导入ocr配置文件
/s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -import /tmp/ocrfile.dmp 
/s01/oracle/product/10.2.0/crs_1/bin/ocrcheck 
--增加ocrmirror
/s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -replace ocrmirror /dev/raw/raw15
/s01/oracle/product/10.2.0/crs_1/bin/ocrcheck
--最后查看ocr.loc文件
cat /etc/oracle/ocr.loc &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际测试替换OCR的关键操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl stop crs
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -export /tmp/ocrfile.dmp 
[root@rac1-server rules.d]# vi /etc/oracle/ocr.loc 
ocrconfig_loc=/dev/raw/raw14
local_only=FALSE
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/ocrconfig -replace ocrmirror /dev/raw/raw15
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/ocrcheck
Status of Oracle Cluster Registry is as follows :
         Version                  :          2
         Total space (kbytes)     :      96144
         Used space (kbytes)      :       4652
         Available space (kbytes) :      91492
         ID                       : 1953645605
         Device/File Name         : /dev/raw/raw14
                                    Device/File integrity check succeeded
         Device/File Name         : /dev/raw/raw15
                                    Device/File integrity check succeeded

         Cluster registry integrity check succeeded

[root@rac1-server ~]#  cat /etc/oracle/ocr.loc 
#Device/file  getting replaced by device /dev/raw/raw15 
ocrconfig_loc=/dev/raw/raw14
ocrmirrorconfig_loc=/dev/raw/raw15
local_only=false
[root@rac1-server ~]# &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;替换voting disk比较简单，只需要把新的voting disk加进来，然后把旧的删除即可。&lt;br/&gt;本次实验演示就是新加/dev/raw/raw11,/dev/raw/raw12,/dev/raw/raw13,然后将原来的/dev/raw/raw2删除。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--replace voting disk
--which crsctl确认crsctl的全路径
/s01/oracle/product/10.2.0/crs_1/bin/crsctl
--查询当前的votedisk
crsctl query css votedisk
--添加新的votedisk
crsctl add css votedisk /dev/raw/raw11 -force
crsctl add css votedisk /dev/raw/raw12 -force
crsctl add css votedisk /dev/raw/raw13 -force
--删除旧的votedisk
crsctl delete css votedisk /dev/raw/raw2 -force&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际替换voting disk的关键操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl add css votedisk /dev/raw/raw11 
Cluster is not in a ready state for online disk addition
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl add css votedisk /dev/raw/raw11 -force
Now formatting voting disk: /dev/raw/raw11
successful addition of votedisk /dev/raw/raw11.
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl query css votedisk
 0.     0    /dev/raw/raw2
 1.     0    /dev/raw/raw11

located 2 votedisk(s).
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl add css votedisk /dev/raw/raw12 -force
Now formatting voting disk: /dev/raw/raw12
successful addition of votedisk /dev/raw/raw12.
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl add css votedisk /dev/raw/raw13 -force
Now formatting voting disk: /dev/raw/raw13
successful addition of votedisk /dev/raw/raw13.
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl query css votedisk
 0.     0    /dev/raw/raw2
 1.     0    /dev/raw/raw11
 2.     0    /dev/raw/raw12
 3.     0    /dev/raw/raw13

located 4 votedisk(s).
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl delete css votedisk /dev/raw/raw2
Cluster is not in a ready state for online disk removal
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl delete css votedisk /dev/raw/raw2 -force
successful deletion of votedisk /dev/raw/raw2.
[root@rac1-server rules.d]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl query css votedisk
 0.     0    /dev/raw/raw11
 1.     0    /dev/raw/raw12
 2.     0    /dev/raw/raw13

located 3 votedisk(s).
[root@rac1-server rules.d]# &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;附录：本次实验环境：&lt;/strong&gt;&lt;br/&gt;1.旧存储模拟：4块盘：其中第1块盘分成了2个区，绑定为raw设备raw1和raw2，分别给ocr和voting disk使用，剩余3块是给ASM使用的：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/846011/o_NewStorage3.png&quot;/&gt;&lt;br/&gt;2.新存储模拟：10块盘：其中前三块（raw11，raw12，raw13）给voting disk使用，第4块和第5块（raw14和raw15）给ocr使用：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/846011/o_NewStorage2.png&quot;/&gt;&lt;br/&gt;3.使用新存储3块10G的盘和2块5G的盘分别新增DATADG和FRA2个ASM磁盘组，其中DATADG是Normal冗余，FRA是External冗余：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/846011/o_NewStorage4.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 15:55:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>环境： OEL 5.7 + Oracle 10.2.0.5 RAC 需求： 更换存储，OCR、Voting disk同时需要更换到新存储。 '1.替换OCR' '2.替换voting disk' 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10618658.html</dc:identifier>
</item>
<item>
<title>生产与学术之Pytorch模型导出为安卓Apk尝试记录 - lart</title>
<link>http://www.cnblogs.com/lart/p/10618665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lart/p/10618665.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;写于 2019-01-08 的旧文, 当时是针对一个比赛的探索. 觉得可能对其他人有用, 就放出来分享一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1535540878298-a155c6d065ef?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=750&amp;amp;q=80&quot; alt=&quot;upsplash&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生产与学术, 真实的对立...&lt;/p&gt;
&lt;p&gt;这是我这两天对&lt;code&gt;pytorch深度学习-&amp;gt;android实际使用&lt;/code&gt;的这个流程的一个切身感受.&lt;/p&gt;
&lt;p&gt;说句实在的, 对于模型转换的探索, 算是我这两天最大的收获了...&lt;/p&gt;
&lt;p&gt;全部浓缩在了这里: &lt;a href=&quot;https://github.com/lartpang/DHSNet-PyTorch/blob/master/converter.ipynb&quot; class=&quot;uri&quot;&gt;https://github.com/lartpang/DHSNet-PyTorch/blob/master/converter.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;鉴于github加载ipynb太慢, 这里可以使用这个链接 &lt;a href=&quot;https://nbviewer.jupyter.org/github/lartpang/DHSNet-PyTorch/blob/master/converter.ipynb&quot; class=&quot;uri&quot;&gt;https://nbviewer.jupyter.org/github/lartpang/DHSNet-PyTorch/blob/master/converter.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;这两天&quot;&gt;这两天&lt;/h2&gt;
&lt;p&gt;最近在研究将pytorch的模型转换为独立的app, 网上寻找, 找到了一个流程: pytorch-&amp;gt;onnx-&amp;gt;caffe2-&amp;gt;android apk. 主要是基于这篇文章的启发: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/32342366&quot;&gt;caffe2&amp;amp;pytorch之在移动端部署深度学习模型(全过程!)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;这两天就在折腾这个工具链，为了导出onnx的模型, 不确定要基于怎样的网络, 是已经训练好的, 还是原始搭建网络后再训练来作为基础. 所以不断地翻阅&lt;a href=&quot;https://pytorch.org/tutorials/advanced/super_resolution_with_caffe2.html&quot;&gt;pytorch&lt;/a&gt;和&lt;a href=&quot;https://github.com/onnx/tutorials/tree/master/tutorials&quot;&gt;onnx&lt;/a&gt;的官方示例, 想要研究出来点什么, 可是, 都是自己手动搭建的模型. 而且使用的是预训练权重, 不是这样:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def squeezenet1_1(pretrained=False, **kwargs):
    r&quot;&quot;&quot;SqueezeNet 1.1 model from the `official SqueezeNet repo
    &amp;lt;https://github.com/DeepScale/SqueezeNet/tree/master/SqueezeNet_v1.1&amp;gt;`_.
    SqueezeNet 1.1 has 2.4x less computation and slightly fewer parameters
    than SqueezeNet 1.0, without sacrificing accuracy.
    Args:
        pretrained (bool): If True, returns a model pre-trained on ImageNet
    &quot;&quot;&quot;
    model = SqueezeNet(version=1.1, **kwargs)
    if pretrained:
        model.load_state_dict(model_zoo.load_url(model_urls['squeezenet1_1']))
    return model
# Get pretrained squeezenet model
torch_model = squeezenet1_1(True)

from torch.autograd import Variable
batch_size = 1    # just a random number
# Input to the model
x = Variable(torch.randn(batch_size, 3, 224, 224), requires_grad=True)
# Export the model
torch_out = torch.onnx._export(
    torch_model,        # model being run
    x,                  # model input (or a tuple for multiple inputs)
    &quot;squeezenet.onnx&quot;,  # where to save the model (can be a file or file-like object)
    export_params=True) # store the trained parameter weights inside the model file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这样:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Create the super-resolution model by using the above model definition.
torch_model = SuperResolutionNet(upscale_factor=3)
# Load pretrained model weights
model_url = 'https://s3.amazonaws.com/pytorch/test_data/export/superres_epoch100-44c6958e.pth'
batch_size = 1    # just a random number
# Initialize model with the pretrained weights
torch_model.load_state_dict(model_zoo.load_url(model_url))
# set the train mode to false since we will only run the forward pass.
torch_model.train(False)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种都在载入预训练权重, 直接加载到搭建好的网络上. 对于我手头有的已经训练好的模型, 似乎并不符合这样的条件.&lt;/p&gt;
&lt;h3 id=&quot;导出整体模型&quot;&gt;导出整体模型&lt;/h3&gt;
&lt;p&gt;最后采用尽可能模仿上面的例子代码的策略, 将整个网络完整的导出(&lt;code&gt;torch.save(model)&lt;/code&gt;), 然后再仿照上面那样, 将完整的网络加载(&lt;code&gt;torch.load()&lt;/code&gt;)到转换的代码中, 照猫画虎, 以进一步处理.&lt;/p&gt;
&lt;blockquote readability=&quot;2.7115384615385&quot;&gt;
&lt;p&gt;这里也很大程度上受到这里的启发: &lt;a href=&quot;https://github.com/akirasosa/mobile-semantic-segmentation&quot; class=&quot;uri&quot;&gt;https://github.com/akirasosa/mobile-semantic-segmentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本来想尝试使用之前找到的不论效果还是性能都很强的R3Net进行转换, 可是, 出于作者搭建网络使用的特殊手段, 加上&lt;a href=&quot;http://www.cnblogs.com/lart/p/10618665.html#pickle和onnx的限制&quot;&gt;pickle和onnx的限制&lt;/a&gt;, 这个尝试没有奏效, 只好转回头使用之前学习的DHS-Net的代码, 因为它的实现是基于VGG的, 里面的搭建的网络也是需要修改来符合onnx的要求, 主要是更改上采样操作为转置卷积(也就是分数步长卷积, 这里顺带温习了下pytorch里的&lt;code&gt;nn.ConvTranspose2d()&lt;/code&gt;的&lt;a href=&quot;https://github.com/lartpang/Machine-Deep-Learning/issues/39&quot;&gt;计算方式&lt;/a&gt;), 因为pytorch的上采样在onnx转换过程中有很多的问题, 特别麻烦, 外加上修改最大池化的一个参数(&lt;code&gt;nn.MaxPool2d(kernel_size=2, stride=2, ceil_mode=False)&lt;/code&gt;的参数&lt;code&gt;ceil_mode&lt;/code&gt;改为&lt;code&gt;ceil_mode=False&lt;/code&gt;, 这里参考自前面的知乎专栏的那篇文章), 这样终于可以转换了, 为了方便和快速的测试, 我只是训练了一个epoch, 就直接导出模型, 这次终于可以顺利的&lt;code&gt;torch.save()&lt;/code&gt;了.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;filename_opti = ('%s/model-best.pth' % check_root_model)
torch.save(model, filename_opti)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后便利用类似的代码进行了书写.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;IMG_SIZE = 224
TMP_ONNX = 'cache/onnx/DHSNet.onnx'
MODEL_PATH = 'cache/opti/total-opti-current.pth'

# Convert to ONNX once
model = torch.load(MODEL_PATH).cuda()
model.train(False)

x = Variable(torch.randn(1, 3, 224, 224), requires_grad=True).cuda()
torch_out = torch.onnx._export(model, x, TMP_ONNX, export_params=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;caffe2模型转换&quot;&gt;caffe2模型转换&lt;/h3&gt;
&lt;p&gt;载入模型后, 便可以开始转换了, 这里需要安装caffe2, 官方推荐直接conda安装pytorch1每夜版即可, 会自动安装好依赖.&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;说起来这个conda, 就让我又爱又恨, 用它装pytorch从这里可以看出来, 确实不错, 对系统自身的环境没有太多的破坏, 可是用它装tensorflow-gpu的时候, 却是要自动把conda源里的cuda, cudnn工具包都给带上, 有时候似乎会破坏掉系统自身装载的cuda环境(? 不太肯定, 反正现在我不这样装, 直接上pip装, 干净又快速).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之后的代码中, 主要的问题也就是tensor的cpu/cuda, 或者numpy的转换的问题了. 多尝试一下, 输出下类型就可以看到了.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Let's also save the init_net and predict_net to a file that we will later use for running them on mobile
with open('./cache/model_mobile/init_net.pb', &quot;wb&quot;) as fopen:
    fopen.write(init_net.SerializeToString())
with open('./cache/model_mobile/predict_net.pb', &quot;wb&quot;) as fopen:
    fopen.write(predict_net.SerializeToString())&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预处理的补充&quot;&gt;预处理的补充&lt;/h3&gt;
&lt;p&gt;这里记录下, 查看pytorch的tensor的形状使用&lt;code&gt;tensor.size()&lt;/code&gt;方法, 查看numpy数组的形状则使用numpy数组的&lt;code&gt;adarray.shape&lt;/code&gt;方法, 而对于PIL(&lt;code&gt;from PIL import Image&lt;/code&gt;)读取的Image对象而言, 使用&lt;code&gt;Image.size&lt;/code&gt;查看, 而且, 这里只会显示宽和高的长度, 而且Image的对象, 是三维, 在于pytorch的tensor转换的时候, 或者输入网络的时候, 要注意添加维度, 而且要调整通道位置(&lt;code&gt;img = img.transpose(2, 0, 1)&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;由于网络保存的部分中, 只涉及到了网络的结构内的部分, 对于数据的预处理的部分并不涉及, 所以说要想真正的利用网络, 还得调整真实的输入, 来作为更适合网络的数据输入.&lt;/p&gt;
&lt;p&gt;要注意, 这里针对导出的模型的相关测试, 程实际上是&lt;strong&gt;按照测试网络的流程&lt;/strong&gt;来的.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# load the resized image and convert it to Ybr format
mean = np.array([0.485, 0.456, 0.406])
std = np.array([0.229, 0.224, 0.225])
img = Image.open(&quot;./data/ILSVRC2012_test_00000004_224x224.jpg&quot;)
img = np.array(img)
img = img.astype(np.float64) / 255
img -= mean
img /= std
img = img.transpose(2, 0, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安卓的尝试&quot;&gt;安卓的尝试&lt;/h3&gt;
&lt;p&gt;首先安卓环境的配置就折腾了好久, 一堆破事, 真实的生产开发, 真心不易啊...&lt;/p&gt;
&lt;p&gt;这里最终还是失败了, 因为对于安卓的代码是在是不熟悉, 最起码的基础认知都不足, 只有这先前学习Java的一点皮毛知识, 根本不足以二次开发. 也就跑了跑几个完整的demo而已.&lt;/p&gt;
&lt;h4 id=&quot;aicamera&quot;&gt;&lt;a href=&quot;https://github.com/caffe2/AICamera&quot;&gt;AiCamera&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个跑通了, 但是这是个分类网络的例子, 对于我们要做的分割的任务而言, 有很多细节不一样.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入有差异: 比赛要求的是若是提交apk, 那么要求可以从相册读取图片, 而例子是从摄像头读取的视频数据流. 虽然也处理的是视频帧, 但是要我们再次补充的内容又多了起来, 还是那句话, android一窍不通.&lt;/li&gt;
&lt;li&gt;输出有差异: 自我猜测, 比赛为了测评, 输出必然也要输出到相册里, 不然何来测评一说?&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aicamera-style-transfer&quot;&gt;&lt;a href=&quot;https://github.com/caffe2/AICamera-Style-Transfer&quot;&gt;AICamera-Style-Transfer&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个例子我们参考了一下, 只是因为它的任务是对摄像头视频流数据风格迁移, 而且会直接回显到手机屏幕上, 这里我们主要是想初步实现对于我们网络模型安卓迁移的测试, 在第一个例子的基础上能否实现初步的摄像头视频流的分割, 然后下一步再进一步满足比赛要求.&lt;/p&gt;
&lt;p&gt;可是, 尝试失败了. 虽然AS打包成了APK, &lt;a href=&quot;http://www.cnblogs.com/lart/p/10618665.html#打包apk安装&quot;&gt;手机也安装上了&lt;/a&gt;, 可是莫名的, 在&quot;loading...&quot;中便闪退了...&lt;/p&gt;
&lt;h4 id=&quot;jejunet&quot;&gt;&lt;a href=&quot;https://github.com/tantara/JejuNet&quot;&gt;JejuNet&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这个例子很给力, 但是使用的是tensorflowlite, 虽然可以用, 能够实现下面的效果, 可是, 不会改.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tantara/JejuNet/master/docs/20180726-current-results-deeplabv3_on_tf-lite.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且是量化网络, 准确率还是有待提升.&lt;/p&gt;
&lt;h2 id=&quot;最后的思考&quot;&gt;最后的思考&lt;/h2&gt;
&lt;p&gt;最后还是要思考一下的, 做个总结.&lt;/p&gt;
&lt;h3 id=&quot;没经验&quot;&gt;没经验&lt;/h3&gt;
&lt;p&gt;吃就吃在没经验的亏上了, 都是初次接触, 之前没怎么接触过安卓, 主要是安卓的开发对于电脑的配置要求太高了, 自己的笔记本根本不够玩的. 也就没有接触过了.&lt;/p&gt;
&lt;p&gt;外加上之前的研究学习, 主要是在学术的环境下搞得, 和实际的生产还有很大的距离, 科研与生产的分离, 这对于深度学习这一实际上更偏重实践的领域来说, 有些时候是尤为致命的. 关键时刻下不去手, 这多么无奈, 科学技术无法转化为实实在在的生产力, 忽然有些如梦一般的缥缈.&lt;/p&gt;
&lt;p&gt;当然, 最关键的还是, 没有仔细分析赛方的需求, 没有完全思考清楚, 直接就开干了, 这个鲁莽的毛病, 还是没有改掉, 浪费时间不说, 也无助于实际的进度. 赛方的说明含糊, 应该问清楚.&lt;/p&gt;
&lt;p&gt;若是担心时间, 那更应该看清楚要求, 切莫随意下手. 比赛说明里只是说要提交一个打包好的应用, 把环境, 依赖什么都处理好, 但是不一定是安卓apk呀, 可以有很多的形式, 但是这也只是最后的一点额外的辅助而已, 重点是模型的性能和效率呢.&lt;/p&gt;
&lt;p&gt;莫忘初心, 方得始终. 为什么我想到的是这句.&lt;/p&gt;
&lt;h3 id=&quot;下一步&quot;&gt;下一步&lt;/h3&gt;
&lt;p&gt;基本上就定了还是使用R3Net, 只能是进一步的细节修改了, 换换后面的循环结构了, 改改连接什么的.&lt;/p&gt;
&lt;p&gt;我准备再开始看论文, 学姐的论文可以看看, 似乎提出了一种很不错的后处理的方法, 效果提升很明显, 需要研究下.&lt;/p&gt;
&lt;h2 id=&quot;pickle和onnx的限制&quot;&gt;pickle和onnx的限制&lt;/h2&gt;
&lt;p&gt;pytorch的&lt;code&gt;torch.save(model)&lt;/code&gt;保存模型的时候, 模型架构的代码里&lt;strong&gt;不能使用一些特殊的构建形式&lt;/strong&gt;, &lt;a href=&quot;https://github.com/zijundeng/R3Net/blob/master/resnext/resnext_101_32x4d_.py&quot;&gt;R3Net的ResNeXt结构&lt;/a&gt;就用了, 主要是一些lambda结构, 虽然不是太清楚, 但是一般的搭建手段都是可以的.&lt;/p&gt;
&lt;p&gt;onnx对于pytorch的支持的操作, 在我的转化中, 主要是最大池化和上采样的问题, 前者可以修改&lt;code&gt;ceil_mode&lt;/code&gt;为&lt;code&gt;False&lt;/code&gt;, 后者则建议修改为转置卷积, 避免不必要的麻烦. 可见&lt;a href=&quot;http://www.cnblogs.com/lart/p/10618665.html#导出整体模型&quot;&gt;&quot;导出整体模型&quot;&lt;/a&gt;小节的描述.&lt;/p&gt;
&lt;h2 id=&quot;打包apk安装&quot;&gt;打包apk安装&lt;/h2&gt;
&lt;p&gt;这里主要是用release版本构建的apk.&lt;/p&gt;
&lt;p&gt;未签名的apk在我的mi 8se (android 8.1)上不能安装, 会解析失败, 需要签名, AS的签名的生成也很简单, 和生成apk在同一级上, 有生成的选项.&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 15:53:00 +0000</pubDate>
<dc:creator>lart</dc:creator>
<og:description>生产与学术 写于 2019 01 08 的旧文, 当时是针对一个比赛的探索. 觉得可能对其他人有用, 就放出来分享一下 生产与学术, 真实的对立... 这是我这两天对 的这个流程的一个切身感受. 说句</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lart/p/10618665.html</dc:identifier>
</item>
</channel>
</rss>