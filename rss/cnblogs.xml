<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Asp.Net Core IdentityServer4 中的基本概念 - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12437441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12437441.html</guid>
<description>&lt;p&gt;这篇文章可能大家会觉得很空洞，没有实际的实战东西，主要是自己整理出来的IdentityServer4 的一些概念性的东西；如果你对IdentityServer4有过一定的实战经验，可以跳过不需要阅读该文章，后续我会以一个Demo 来给大家带来IdentityServer4深入的实战分享&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;94.404911049862&quot;&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;这篇文章可能大家会觉得很空洞，没有实际的实战东西，主要是自己整理出来的IdentityServer4 的一些概念性的东西；如果你对&lt;code&gt;IdentityServer4&lt;/code&gt;有过一定的实战经验，可以跳过不需要阅读该文章，后续我会以一个Demo 来给大家带来IdentityServer4深入的实战分享 。&lt;/p&gt;
&lt;h2 id=&quot;二概述&quot;&gt;二、概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;IdentityServer4&lt;/code&gt;是一个用于ASP.Net Core的&lt;code&gt;OpenID Connect&lt;/code&gt;和&lt;code&gt;OAuth 2.0&lt;/code&gt;框架&lt;/p&gt;
&lt;h3 id=&quot;什么是oauth-2.0&quot;&gt;2.1 什么是OAuth 2.0？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;OAuth 2.0&lt;/code&gt;是授权的行业标准协议。OAuth 2.0侧重于客户端开发人员的简单性，同时为web应用程序、桌面应用程序、移动应用等提供特定的授权流。该规范及其扩展正在IETF OAuth工作组内开发。&lt;/p&gt;
&lt;p&gt;简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。&lt;/p&gt;
&lt;p&gt;OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。下面就是这四种授权方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;authorization code（授权码模式）&lt;/li&gt;
&lt;li&gt;implicit（简化模式）&lt;/li&gt;
&lt;li&gt;resource owner password credentials（密码模式）&lt;/li&gt;
&lt;li&gt;client credentials（客户端模式）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OAuth 整体流程图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190708144314592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxeTI0OA==,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的OAuth 2.0 四大授权方式请参考 阮一峰 的博客 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html&quot;&gt;OAuth 2.0 的四种方式&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是openid-connect&quot;&gt;2.2 什么是OpenId Connect&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;OpenID Connect的&lt;/code&gt; 的简称是&lt;code&gt;OIDC&lt;/code&gt;，OIDC=(Identity, Authentication) + OAuth 2.0。它在OAuth2上构建了一个身份层，是一个基于OAuth2协议的身份认证标准协议。我们都知道OAuth2是一个授权协议，它无法提供完善的身份认证功能，OIDC使用OAuth2的授权服务器来为第三方客户端提供用户的身份认证，并把对应的身份认证信息传递给客户端，且可以适用于各种类型的客户端（比如服务端应用，移动APP，JS应用），且完全兼容OAuth2，也就是说你搭建了一个OIDC的服务后，也可以当作一个OAuth2的服务来用。应用场景如图：&lt;br/&gt;&lt;img src=&quot;https://identityserver4.readthedocs.io/en/latest/_images/protocols.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;identityserver4功能特性&quot;&gt;2.3 IdentityServer4功能特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IdentityServer4&lt;/code&gt;集成到你的应用具有如下功能特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Authentication as a Service：可以为你的应用（如网站、本地应用、移动端、服务）做集中式的登录逻辑和工作流控制。IdentityServer是完全实现了OpenID Connect协议标准&lt;/li&gt;
&lt;li&gt;Single Sign-on / Sign-out：在多个应用程序类型上进行单点登录(和单点退出)。&lt;/li&gt;
&lt;li&gt;Access Control for APIs：为不同类型的客户端，例如服务器到服务器、web应用程序、SPAs和本地/移动应用程序，发出api的访问令牌。&lt;/li&gt;
&lt;li&gt;Federation Gateway：支持来自Azure Active Directory, Google, Facebook这些知名应用的身份认证，可以不必关心连接到这些应用的细节就可以保护你的应用。&lt;/li&gt;
&lt;li&gt;Focus on Customization：最重要的是identityserver可以根据需求自行开发来适应应用程序的变化。identityserver不是一个框架、也不是一个盒装产品或一个saas系统，您可以编写代码来适应各种场景。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220175002815-985346258.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;identityserver4-可以帮助我们做什么&quot;&gt;2.4 IdentityServer4 可以帮助我们做什么？&lt;/h3&gt;
&lt;p&gt;IdentityServer是将规范兼容的OpenID Connect和OAuth 2.0端点添加到任意ASP.NET Core应用程序的中间件。通常，您构建（或重新使用）包含登录和注销页面的应用程序，IdentityServer中间件会向其添加必要的协议头，以便客户端应用程序可以与其对话 使用这些标准协议。&lt;br/&gt;&lt;img src=&quot;https://identityserver4.readthedocs.io/en/latest/_images/middleware.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您觉的不错，请微信扫码关注 【dotNET博士】公众号，后续给您带来更精彩的分享&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200302122728756-456586765.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上如果有错误的地方，请大家积极纠正，谢谢大家的支持！！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 08 Mar 2020 00:15:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>这篇文章可能大家会觉得很空洞，没有实际的实战东西，主要是自己整理出来的IdentityServer4 的一些概念性的东西；如果你对IdentityServer4有过一定的实战经验，可以跳过不需要阅读该</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12437441.html</dc:identifier>
</item>
<item>
<title>基于 Redis 实现 CAS 操作 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/redis-based-cas.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/redis-based-cas.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;在 .NET 里并发情况下我们可以使用 &lt;code&gt;Interlocked.CompareExchange&lt;/code&gt; 来实现 CAS （Compare And Swap） 操作，在分布式的情景下很多时候我们都会使用 Redis ，最近在改之前做的一个微信小游戏项目，之前是单机运行的，有些数据存储是基于内存的，直接基于对象操作的，最近要改成支持分布式的，于是引入了 redis，原本基于内存的数据就要迁移到 redis 中存储，原来的代码里有一些地方使用了 &lt;code&gt;Interlocked.CompareExchange&lt;/code&gt; 来实现 CAS 操作，迁移到 redis 中之后也需要类似的功能，于是就想基于 redis 实现 CAS 操作。&lt;/p&gt;
&lt;h2 id=&quot;cas&quot;&gt;CAS&lt;/h2&gt;
&lt;p&gt;CAS (Compare And Swap) 通常可以使用在并发操作中更新某一个对象的值，CAS 是无锁操作，CAS 相当于是一种乐观锁，而直接加锁相当于是悲观锁，所以相对来说 CAS 操作 是会比直接加锁更加高效的。&lt;/p&gt;
&lt;h2 id=&quot;redis-lua&quot;&gt;Redis Lua&lt;/h2&gt;
&lt;p&gt;redis 从 2.6.0 版本开始支持 Lua 脚本，Lua 脚本的执行是原子性的，所以我们在实现基于 redis 的分布式锁释放锁的时候或者下面要介绍的实现CAS 操作的，要执行多个操作但是希望操作是原子操作的时候就可以借助 Lua 脚本来实现（也可以使用事务来做）&lt;/p&gt;
&lt;h2 id=&quot;基于-redis-lua-实现-cas&quot;&gt;基于 Redis Lua 实现 CAS&lt;/h2&gt;
&lt;p&gt;String CAS Lua Script:&lt;/p&gt;
&lt;p&gt;KEYS[1] 对应要操作的String 类型的 redis 缓存的 key，ARGV[1]对应要比较的值，值相同则更新成 ARGV[2]，并返回 1，否则返回 0&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;if redis.call(&quot;&quot;get&quot;&quot;, KEYS[1]) == ARGV[1] then
    redis.call(&quot;&quot;set&quot;&quot;, KEYS[1], ARGV[2])
    return 1
else
    return 0
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hash CAS Lua Script:&lt;/p&gt;
&lt;p&gt;KEYS[1] 对应要操作的 Hash 类型的 redis 缓存的 key，ARGV[1] 对应 Hash 的 field，ARGV[2]对应要比较的值，值相同则更新成 ARGV[3]，并返回 1，否则返回 0&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;if redis.call(&quot;&quot;hget&quot;&quot;, KEYS[1], ARGV[1]) == ARGV[2] then
    redis.call(&quot;&quot;hset&quot;&quot;, KEYS[1], ARGV[1], ARGV[3])
    return 1
else
    return 0
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于-stackexchange.redis-的实现&quot;&gt;基于 StackExchange.Redis 的实现&lt;/h2&gt;
&lt;p&gt;为了方便使用，基于 &lt;code&gt;IDatabase&lt;/code&gt; 提供了几个方便使用的扩展方法，实现如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static bool StringCompareAndExchange(this IDatabase db, RedisKey key, RedisValue newValue, RedisValue originValue)
{
    return (int)db.ScriptEvaluate(StringCasLuaScript, new[] { key }, new[] { originValue, newValue }) == 1;
}

public static async Task&amp;lt;bool&amp;gt; StringCompareAndExchangeAsync(this IDatabase db, RedisKey key, RedisValue newValue, RedisValue originValue)
{
    return await db.ScriptEvaluateAsync(StringCasLuaScript, new[] { key }, new[] { originValue, newValue })
        .ContinueWith(r =&amp;gt; (int)r.Result == 1);
}

public static bool HashCompareAndExchange(this IDatabase db, RedisKey key, RedisValue field, RedisValue newValue, RedisValue originValue)
{
    return (int)db.ScriptEvaluate(HashCasLuaScript, new[] { key }, new[] { field, originValue, newValue }) == 1;
}

public static async Task&amp;lt;bool&amp;gt; HashCompareAndExchangeAsync(this IDatabase db, RedisKey key, RedisValue field, RedisValue newValue, RedisValue originValue)
{
    return await db.ScriptEvaluateAsync(HashCasLuaScript, new[] { key }, new[] { field, originValue, newValue })
        .ContinueWith(r =&amp;gt; (int)r.Result == 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实际使用&quot;&gt;实际使用&lt;/h2&gt;
&lt;p&gt;使用可以参考下面的测试代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void StringCompareAndExchangeTest()
{
    var key = &quot;test:String:cas&quot;;
    var redis = DependencyResolver.Current
        .GetRequiredService&amp;lt;IConnectionMultiplexer&amp;gt;()
        .GetDatabase();
    redis.StringSet(key, 1);

    // set to 3 if now is 2
    Assert.False(redis.StringCompareAndExchange(key, 3, 2));
    Assert.Equal(1, redis.StringGet(key));

    // set to 4 if now is 1
    Assert.True(redis.StringCompareAndExchange(key, 4, 1));
    Assert.Equal(4, redis.StringGet(key));

    redis.KeyDelete(key);
}

[Fact]
public void HashCompareAndExchangeTest()
{
    var key = &quot;test:Hash:cas&quot;;
    var field = &quot;testField&quot;;

    var redis = DependencyResolver.Current
        .GetRequiredService&amp;lt;IConnectionMultiplexer&amp;gt;()
        .GetDatabase();
    redis.HashSet(key, field, 1);

    // set to 3 if now is 2
    Assert.False(redis.HashCompareAndExchange(key, field, 3, 2));
    Assert.Equal(1, redis.HashGet(key, field));

    // set to 4 if now is 1
    Assert.True(redis.HashCompareAndExchange(key, field, 4, 1));
    Assert.Equal(4, redis.HashGet(key, field));

    redis.KeyDelete(key);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
</description>
<pubDate>Sat, 07 Mar 2020 17:45:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>基于 redis 实现分布式下的 CAS 操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/redis-based-cas.html</dc:identifier>
</item>
<item>
<title>【DPDK】谈谈DPDK如何实现bypass内核的原理 其一 PCI设备与UIO驱动 - Jungle1996</title>
<link>http://www.cnblogs.com/jungle1996/p/12398915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jungle1996/p/12398915.html</guid>
<description>&lt;p&gt;&lt;span&gt;【前言】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　随着网络的高速发展，对网络的性能要求也越来越高，DPDK框架是目前的一种加速网络IO的解决方案之一，也是最为流行的一套方案。DPDK通过bypass内核协议栈与内核驱动，将驱动的工作从内核态移至用户态，并利用polling mode的线程工作模式加速网络I/O使得网络IO性能出现大幅度的增长。&lt;/p&gt;
&lt;p&gt;　　在使用DPDK的时候，我们常常会说提到用DPDK来接管网卡以达到bypass内核驱动以及内核协议栈的操作，本篇文章将主要分析DPDK是如何实现的bypass内核驱动来实现所谓的“接管网卡”的功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;本篇文章会涉及一些pci设备的内容，但是不会重点讲解pci设备，pci设备中的某些规则就是这么设计的，并没有具体原因。&lt;/li&gt;
&lt;li&gt;本篇部分原理的讲解会以Q&amp;amp;A的方式拖出，因为DPDK bypass内核的这部分涉及的知识维度比较多，没有办法按照线性的思路讲解。&lt;/li&gt;
&lt;li&gt;本人能力以及&lt;span&gt;水平有限，没办法保证没有疏漏&lt;/span&gt;，如有疏漏还请各路神仙进行指正，本篇内容都是本人个人理解，也就是&lt;span&gt;原创内容&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;由于内容过多，本篇文章会着重基础的将PCI以及igb_uio相关的知识与分析，以便于不光是从DPDK本身，而是全面的了解DPDK如果做到的bypass内核驱动，另外关于DPDK的代码部分实现将会放在后续文章中放出，另外还有DPDK的中断模式以及vfio也会在后续的文章中依次发出（先开个坑，立个flag）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;【1.谈一谈使用】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通常启动一个基于dpdk开发的应用，都需要几步准备来完成。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先需要插入igb_uio/vfio-pci这两个驱动中的一个，接下来会以igb_uio为例讲解（因为简单...vfio还是有点复杂的...vfio的解析会放在以后的文章中放出）。&lt;/li&gt;
&lt;li&gt;其次需要运行dpdk-devbinds.py这个dpdk官方给出的py脚本，以此来完成内核驱动到igb_uio/vfio的接管。接管之后，再次运行dpdk-devbinds可以很明显的看到驱动从ixgbe转为了igb_uio。请见图1.&lt;/li&gt;
&lt;li&gt;运行dpdk应用，以-p参数指定要接管的网口，例如-c 0x03，那么接管的网口便是port 0和port 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200305223316638-142466278.jpg&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;494&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.接管前后pci设备驱动发生的变化&lt;/p&gt;

&lt;p&gt;　　那么经过上述三个操作，至少脑子里会产生这么几个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Q:igb_uio/vfio-pci的作用是什么？为什么要用这两个驱动？这里的“驱动”和dpdk内部对网卡的“驱动”（dpdk/driver/）有什么区别呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Q:dpdk-devbinds是如何做到的将内核驱动解绑后绑定新的驱动呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Q:dpdk应用内部是如何操作pci设备的呢？是怎么让pci设备可以将数据包直接扔到用户态的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这三个问题，实际上也是我当初在研究这一部分是遇到的三个问题。首先我们先来看第一个问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【问题一：igb_uio/vfio-pci是什么？】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们会以igb_uio驱动为例进行讲解。这里其实很难一步讲清楚igb_uio的作用以及实现原理，所以接下来的讲解还是会以Q&amp;amp;A和“挖坑式”的方式进行逐步将原理展现给各位看官面前。先说说操作一个外设，最先想到的是什么呢？如果有过单片机等嵌入式外设开发的朋友肯定会冒出这样的一个想法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
我得配置这个外设，为此我需要找到它的寄存器，但是找到它的寄存器前提是我得先拿到基地址才行，接下来通过基地址+寄存器偏移就能找到寄存器所在的地址，然后就可以配置了
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以第一个任务便是我们要拿到”基地址“，首先有必要先科普一下pci设备的基地址。因此我必须得掏出一张图，即描述pci配置空间的一张图，如果图2所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200305224848168-58809806.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;529&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2.pci设备的配置空间&lt;/p&gt;
&lt;p&gt;　　图2为pci配置空间的分布图，在图中，0x0010 ~ 0x0028这24个字节中，分布着6个PCI BAR（base address register），也就是最最重要的&lt;strong&gt;“基地址”&lt;/strong&gt;，那这里有人可能会想问“这个图和我们有关系么？这个图中的空间在哪？我们该怎么解析？”，答案是“无关”，这些图中的信息事实上在系统启动时，就已经被解析完成了，以文件系统的方式供用户态程序取读取。但是这里其实有这样的一个问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
PCI设备为啥有6个BAR，而不是3个、8个？这些BAR都有啥区别？实际访问寄存器的时候以哪一个BAR为基准呢？
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实解释这个问题，是一件简单而又不简单的事情。简单是因为pci设备规定就是有6个bar空间，而不简单是因为不知道为什么规定6个bar空间。那么这些BAR又有什么区别呢？这里要引用一下stackoverflow上面一位老哥说的话，见图3.（这里其实我之前也一直不太明白，因为国内的很多论坛帖子都是千篇一律...很难筛选出自己想要的信息...）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200305231030138-633411734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3.不同BAR空间的区别之StackOverflow&lt;/p&gt;
&lt;p&gt;　　其实关键就是&lt;strong&gt;蓝色&lt;/strong&gt;的那句话，即”6个槽(BAR)允许设备以不同的目的提供不同的区域“，根据这个线索，我们来看一下&lt;strong&gt;intel 82599&lt;/strong&gt;这款经典的10G网卡的&lt;strong&gt;datasheet&lt;/strong&gt;中9.3.6中的解释。见图4.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200305231730264-38128766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图4.intel 82599 datasheet中关于不同pci bar的划分&lt;/p&gt;
&lt;p&gt;　　可以看到这款经典网卡（其实intel的卡基本都是这么分的）主要将6个pci bar分成了三块区域：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Memory BAR : 内存BAR，Memory BAR标志着这块BAR空间位于内存空间，通过mmap映射后可以直接访问。&lt;/li&gt;
&lt;li&gt;I/O BAR : IO BAR空间，I/O BAR标志着这块BAR空间位于IO空间，对其的访问不能像Memory BAR那样映射之后就可以随心所欲访问，IO BAR必须通过专门的操作来进行读写。&lt;/li&gt;
&lt;li&gt;MSI-X BAR : 这个BAR空间主要是用来配置MSI -X 中断向量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　那么这里可能有人会问，一共不是6个BAR空间么？这里只分了3个区域，那么每个区域分多少呢？这里请注意的是关于图3中6个PCI BAR，每个PCI BAR都是32位的，但是像82599这种工作在64位的网卡，其实就只有三个BAR。BAR0 BAR1为Memory BAR，BAR2 BAR3为I/O BAR，BAR4 BAR5为MSI-X BAR。这里我们可以对照一款低端网卡I350的datasheet，见图5.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200305232433240-87345367.png&quot; alt=&quot;&quot; width=&quot;971&quot; height=&quot;645&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6.I350网卡datasheet中关于BAR分布的描述&lt;/p&gt;

&lt;p&gt; 　　从图6可以看到，对于I350这种低端的千兆网卡，可以将其配置位工作在32位还是64位模式下，但是对于82599这种万兆10g的卡，就没那么多选择余地了，只能工作在64位模式下，因此回到图3中，我们可以根据intel 82599的datasheet来得知intel的64bit网卡的bar分布是长什么样子的，如图7.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200305233441329-597847534.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图7.intel 82599网卡的BAR分布&lt;/p&gt;
&lt;p&gt;　　所以PCI配置空间的规范结合intel的I350和82599这两款网卡的datasheet进行分析，我们可以得出这样的一个结论：&lt;span&gt;”PCI有6个BAR是规范，6个BAR的区别和作用取决于具体的PCI外设，需要查看datasheet才能给出答案“。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　说完6个BAR的作用以及分布，接下来还有个问题，实际访问PCI BAR的时候以哪一个BAR为基准呢？这里主要有疑问的地方会出现在Memory BAR还是I/O BAR。因为需要搞清楚这两者的区别，才能真正判断在哪个BAR写配置。关于IO BAR和Memory BAR的区别首先需要科普一下，在x86体系架构下，内存的编址情况。接下来进入科普时间。&lt;/p&gt;
&lt;p&gt;　　其实这里是比较晦涩难懂的，首先我们得知道，为什么会出现I/O空间和外设空间？在讨论区别之前我们可以看一张图，看看I/O空间和Memory空间长什么样子，这里可以看宝华叔经典的《Linux设备驱动开发详解》的第11章部分，这里我就简单的说一下，x86下的I/O空间和Memory空间到底长啥样子。见图8.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200306231909954-243405960.jpg&quot; alt=&quot;&quot; width=&quot;1029&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图8.I/O空间与内存空间，来自宝华叔的《Linux设备驱动开发详解》中第11章&lt;/p&gt;
&lt;p&gt;　　另外需要注意的时，非x86体系架构下，例如ARM、PowerPC这些架构下，所有的外设和主存（RAM）都会进行统一的编址，所以kernel可以像访问正常的内存空间一样访问内设。而x86体系架构下，外设是进行独立编址的，如图8所示，因此也就出现了IO空间和Memory空间的区别。（其实可以将RAM看成一种”专门用来内存映射的IO设备“）。另外我们从图8还可一看到另外一个信息，那就是访问外设其实可以有两种方式，一种是通过I/O空间用专有的指令进行访问，另外一种便是访问内存空间，而访问内存空间就相对而言容易的多，也随便的多，那么为什么外设会同时拥有两个空间呢？这里是由于外设通常会自带“存储器”。另外宝华叔还特地提到了如下一句话：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
访问外设可以通过访问内存空间，而访问外设其实可以不必通过IO空间，也间接说明了IO空间实际上不是访问设备所必要的，而内存空间才是必要的
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里常常还有一个容易懵逼的概念，叫做“I/O端口”和”I/O内存“（趁着说DPDK，这里就把这些基础的概念依次科普一下），首先访问I/O空间是必须通过一些专有指令进行访问的，通过独特的in、out指令进行访问，端口号表示了外设的寄存器地址。Intel语法中的in、out指令格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
IN 累加器, {端口号 |&lt;span&gt; DX}
OUT {端口号 &lt;/span&gt;| DX}, 累加器
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两个指令实际上不需要知道是什么意思，只需要知道访问I/O空间需要独特的in、out指令来访问寄存器地址，这些寄存器地址就像“开放了端口”一样供cpu访问，因此称为“I/O端口”。而I/O内存便是正常访问内存空间的I/O设备所在的寄存器地址。简而言之，&lt;strong&gt;通过I/O指令通过I/O端口来访问I/O空间的外设寄存器；通过内存映射后通过I/O内存访问内存空间的外设寄存器&lt;/strong&gt;，在这里所谓的I/O端口或者I/O内存可以理解为一种“通道”，主语是“CPU”，谓语是“访问”，宾语是”外设寄存器“，而I/O端口则是“状语”。并且实际上，在现在的计算机体系架构下，已经不再推荐通过I/O端口的方式取访问寄存器了，而是推荐采用IO内存的方式。&lt;/p&gt;
&lt;p&gt;　　经历了上面的关于PCI BAR、IO空间、内存空间、IO端口、IO内存的科普，接下来我们回归DPDK的驱动托管流程。上面的科普说到了一个关键就是&lt;strong&gt;“访问寄存器实际上可以I/O内存的方式取访问内存空间的外设寄存器，而不必通过I/O端口的方式访问位于I/O端口的外设寄存器”。&lt;/strong&gt;补充了这些关键的基本知识后，我们再梳理一下可以得到哪些关键性的结论：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;PCI有6个BAR，6个BAR的不同划分跟pci设备设计有关，intel的网卡有Memory Bar、IO Bar还有MSI-X Bar。&lt;/li&gt;
&lt;li&gt;这些Bar，想操作寄存器的话，不必通过I/O Bar，通过Memory Bar即可，也就是intel网卡中的Bar0空间。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　知道要访问哪一块Bar后，接下来就要想办法拿到BAR空间供用户态访问。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【4.如何拿到BAR？】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如何拿到BAR，关于这个问题，可以通过阅读DPDK的源代码来解决，接下来不会系统性的分析DPDK是如何在启动阶段扫描PCI设备，这里会留到以后新开一篇文章阐述，接下来的分析将会从代码中的某一点出发进行分析。&lt;/p&gt;
&lt;p&gt;　　进入DPDK源代码中的drivers/bus/pci/linux/pci.c中的函数，上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; PCI_MAX_RESOURCE 6
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * pci扫描文件系统下的resource文件
 * @param filename 通常为/sys/bus/pci/devices/[pci_addr]/resource文件
 * @param dev[out] dpdk中对一个pci设备的抽象
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;
pci_parse_sysfs_resource(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *filename, &lt;span&gt;struct&lt;/span&gt; rte_pci_device *&lt;span&gt;dev)
{
    FILE &lt;/span&gt;*&lt;span&gt;f;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; buf[BUFSIZ];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    uint64_t phys_addr, end_addr, flags;

    f &lt;/span&gt;= fopen(filename, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先打开resource文件，resource文件是一个只读文件，任何的写操作都会被忽略掉&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (f ==&lt;span&gt; NULL) {
        RTE_LOG(ERR, EAL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot open sysfs resource\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描6次，为什么是6次，在之前已经提到，PCI最多有6个BAR&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;PCI_MAX_RESOURCE; i++&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fgets(buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), f) ==&lt;span&gt; NULL) {
            RTE_LOG(ERR, EAL,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s(): cannot read resource\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __func__);
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描resource文件拿到BAR&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (pci_parse_one_sysfs_resource(buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &amp;amp;&lt;span&gt;phys_addr,
                &lt;/span&gt;&amp;amp;end_addr, &amp;amp;flags) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是Memory BAR，则进行记录&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; IORESOURCE_MEM) {
            dev&lt;/span&gt;-&amp;gt;mem_resource[i].phys_addr =&lt;span&gt; phys_addr;
            dev&lt;/span&gt;-&amp;gt;mem_resource[i].len = end_addr - phys_addr + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; not mapped for now &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            dev&lt;/span&gt;-&amp;gt;mem_resource[i].addr =&lt;span&gt; NULL;
        }
    }
    fclose(f);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

error:
    fclose(f);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 扫描pci resource文件中的某一行
 * @param line 某一行
 * @param len 长度，为第一个参数字符串的长度
 * @param phys_addr[out] PCI BAR的起始地址，这个地址要mmap才能用
 * @param end_addr[out] PCI BAR的结束地址
 * @param flags[out] PCI BAR的标志
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
pci_parse_one_sysfs_resource(&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *line, size_t len, uint64_t *&lt;span&gt;phys_addr,
    uint64_t &lt;/span&gt;*end_addr, uint64_t *&lt;span&gt;flags)
{
    union pci_resource_info {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;phys_addr;
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;end_addr;
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;flags;
        };
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;ptrs[PCI_RESOURCE_FMT_NVAL];
    } res_info;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串处理&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (rte_strsplit(line, len, res_info.ptrs, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;) != &lt;span&gt;3&lt;/span&gt;&lt;span&gt;) {
        RTE_LOG(ERR, EAL,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s(): bad resource format\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __func__);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    errno &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串处理，拿到PCI BAR起始地址、PCI BAR结束地址、PCI BAR标志&lt;/span&gt;
    *phys_addr = strtoull(res_info.phys_addr, NULL, &lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;*end_addr = strtoull(res_info.end_addr, NULL, &lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;*flags = strtoull(res_info.flags, NULL, &lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errno != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        RTE_LOG(ERR, EAL,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s(): bad resource format\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __func__);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码1.&lt;/p&gt;
&lt;p&gt;　　可以看到这段代码的逻辑非常简单，就是扫描某个pci设备的resource文件获得PCI BAR。也就是/sys/bus/pci/[pci_addr]/resource这个文件，接下来让我们看一下这个文件长什么样子，见图9.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200307191124838-1928341918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图9.pci目录下的resource文件&lt;/p&gt;
&lt;p&gt;　　可以看到resource文件内部的特点，前6行为PCI设备的6个BAR，每行共3列，其中第1列为PCI BAR的起始地址，第2列为PCI BAR的终止地址，第3列为PCI BAR的标识。图中的例子是ixgbe驱动的intel 82599网卡，之前在第3节也说过，对于82599这张卡工作在64bit模式，前两个BAR为Memory BAR，中间两个BAR为IO BAR，最后两个BAR为MSI-X BAR，因此实际上只有第一行是对我们有用的。通过读取resource文件便完成了BAR的获取。另外PCI目录下还有很多其他关于PCI设备的信息，见图10.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200307192025677-572326149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图10.PCI设备目录内容&lt;/p&gt;

&lt;p&gt; 　　这张图中的目录结构和图2是不是有些眼熟呢？没错这些文件起始就是系统在启动时根据PCI设备信息自动进行处理并建立的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;config: PCI配置空间，二进制，可读写；&lt;/li&gt;
&lt;li&gt;device: PCI设备ID，只读。很重要；&lt;/li&gt;
&lt;li&gt;driver: 为PCI设备采用的驱动目录的软连接，真正的目录位于/sys/bus/pci/drivers/目录下，可以看图10中显示这个PCI设备采用的是内核ixgbe驱动；&lt;/li&gt;
&lt;li&gt;enable: 设备是否正常使能，可读写；&lt;/li&gt;
&lt;li&gt;irq: 被分到的中断号，只读；&lt;/li&gt;
&lt;li&gt;local_cpulist: 这个网卡的内存空间位于和同处于一个NUMA节点上的cpu有哪些，列表方式呈现，只读。举个例子，比如网卡的内存空间位于numa node 0，cpu 1-6同样位于numa node0，那么读取这个文件的内容便是：1-6。重要，因为跨numa节点访问内存会带来极大的性能开销。&lt;/li&gt;
&lt;li&gt;local_cpu: 与local_cpulist的作用相同，不过是以掩码的方式给出，例如1-6号cpu和pci设备处于同一个numa节点，那么掩码便是0x7E(0111 1110)。重要，重要程度等价于local_cpulist。&lt;/li&gt;
&lt;li&gt;numa_node: 只读，告诉这个PCI设备属于哪一个numa节点。重要，会影响性能。&lt;/li&gt;
&lt;li&gt;resource: BAR空间记录文件，只读，任何写操作将会被忽略，通常有三列组成，第一列为PCI BAR起始地址，第二列为PCI BAR终止地址，第三列为这个PCI BAR的标识，见图9.&lt;/li&gt;
&lt;li&gt;resource0..N: 某一个PCI BAR空间，二进制，只读，可以映射，如果用户态程序向操作PCI设备必须通过mmap这个resource0..N，也就意味着这个文件是可以mmap的。重要。&lt;/li&gt;
&lt;li&gt;sriov_numfs: 只读，虚拟化常用的技术，sriov透传技术，可以理解在这个网卡上可以虚拟出多个虚拟网卡，这些虚拟网卡可以直接透传到qemu中的客户机，并且网卡内部会有一个小的交换机实现VM客户机数据包的收发，可以极大的减少时延，这个numvfs便是告诉这个pci设备目前虚拟出多少个虚拟网卡（vf）。重要，主要应用在虚拟化场合。&lt;/li&gt;
&lt;li&gt;sriov_totalvfs: 只读，作用与sriov_numfs相同，不过是总数，揭示这个PCI设备一共可以申请多少个vf。&lt;/li&gt;
&lt;li&gt;subsystem_device: PCI子系统设备ID，只读。&lt;/li&gt;
&lt;li&gt;subsystem_vendor: PCI子系统生产商ID，只读。&lt;/li&gt;
&lt;li&gt;vendor：PCI生产商ID，比如intel便是0x8086.重要。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　上面便是关于PCI设备目录下的一些文件的解释。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;但是DPDK真的是通过读取resource文件来拿到BAR的么？答案其实是否定的&lt;/strong&gt;...DPDK获取PCI BAR并不是这么获取的。接下来上代码，代码位于drivers/bus/pci/linux/pci_uio.c文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 映射resource资源获取PCI BAR
 * @param DPDK中关于某一个PCI设备的抽象实例
 * @param res_id下标，说白了就是获取第几个BAR
 * @param uio_res用来存放PCI BAR资源的结构
 * @param map_idx uio_res数组的计数器
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
pci_uio_map_resource_by_index(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; rte_pci_device *dev, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; res_idx,
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mapped_pci_resource *uio_res, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; map_idx)
{
    ..... &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开/dev/bus/pci/devices/[pci_addr]/resource0..N文件&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!wc_activate || fd &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        snprintf(devname, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(devname),
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; PCI_PRI_FMT &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/resource%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            rte_pci_get_sysfs_path(),
            loc&lt;/span&gt;-&amp;gt;domain, loc-&amp;gt;bus, loc-&amp;gt;&lt;span&gt;devid,
            loc&lt;/span&gt;-&amp;gt;&lt;span&gt;function, res_idx);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; then try to map resource file &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        fd &lt;/span&gt;=&lt;span&gt; open(devname, O_RDWR);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fd &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            RTE_LOG(ERR, EAL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot open %s: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                devname, strerror(errno));
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error;
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; try mapping somewhere close to the end of hugepages &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (pci_map_addr ==&lt;span&gt; NULL)
        pci_map_addr &lt;/span&gt;=&lt;span&gt; pci_find_max_end_va();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行mmap映射，拿到PCI BAR在进程虚拟空间下的地址&lt;/span&gt;
    mapaddr = pci_map_resource(pci_map_addr, fd, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
            (size_t)dev&lt;/span&gt;-&amp;gt;mem_resource[res_idx].len, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    close(fd);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mapaddr ==&lt;span&gt; MAP_FAILED)
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error;

    pci_map_addr &lt;/span&gt;=&lt;span&gt; RTE_PTR_ADD(mapaddr,
            (size_t)dev&lt;/span&gt;-&amp;gt;&lt;span&gt;mem_resource[res_idx].len);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将拿到的PCI BAR映射至进程虚拟空间内的地址存起来&lt;/span&gt;
    maps[map_idx].phaddr = dev-&amp;gt;&lt;span&gt;mem_resource[res_idx].phys_addr;
    maps[map_idx].size &lt;/span&gt;= dev-&amp;gt;&lt;span&gt;mem_resource[res_idx].len;
    maps[map_idx].addr &lt;/span&gt;=&lt;span&gt; mapaddr;
    maps[map_idx].offset &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    strcpy(maps[map_idx].path, devname);
    dev&lt;/span&gt;-&amp;gt;mem_resource[res_idx].addr =&lt;span&gt; mapaddr;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

error:
    rte_free(maps[map_idx].path);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 对pci/resource0..N进行mmap，将PCI BAR空间通过mmap的方式映射到进程内部的虚拟空间，供用户态应用来操作设备
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;
pci_map_resource(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *requested_addr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fd, off_t offset, size_t size,
         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; additional_flags)
{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;mapaddr;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心便是这句mmap，其中要注意的是，offset必须为0&lt;/span&gt;
    mapaddr = mmap(requested_addr, size, PROT_READ |&lt;span&gt; PROT_WRITE,
            MAP_SHARED &lt;/span&gt;|&lt;span&gt; additional_flags, fd, offset);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mapaddr ==&lt;span&gt; MAP_FAILED) {
        RTE_LOG(ERR, EAL,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s(): cannot mmap(%d, %p, 0x%zx, 0x%llx): %s (%p)\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            __func__, fd, requested_addr, size,
            (unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;)offset,
            strerror(errno), mapaddr);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        RTE_LOG(DEBUG, EAL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  PCI memory mapped at %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, mapaddr);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapaddr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码2&lt;/p&gt;
&lt;p&gt;　　关于内存映射resource0..N的方法来让用户空间得到PCI BAR空间的操作其实在Linux kernel doc中早有说明：&lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/sysfs-pci.txt&quot;&gt;https://www.kernel.org/doc/Documentation/filesystems/sysfs-pci.txt&lt;/a&gt;，具体可以看图11.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200307195443405-272088458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图11.Linux Kernel Doc中关于PCI设备resource0..N的说明&lt;/p&gt;
&lt;p&gt;　　可以看到，DPDK是怎么拿到PCI BAR的呢？&lt;strong&gt;是igb_uio将pci bar暴露给用户态的么？其实完全不是&lt;/strong&gt;，而是直接mmap resource0..N就做到了，至于resource0..N则是内核自带的一个供用户态程序通过mmap的方式访问PCI BAR。网上很多的文章提到igb_uio的作用，基本都是以下两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;igb_uio负责将PCI BAR提供给用户态应用，也就是DPDK；&lt;/li&gt;
&lt;li&gt;igb_uio负责处理中断，形成用户态程序和内核中断的一个桥梁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这两点中，第二点是正确的，但是第一点则是非常不准确的，&lt;strong&gt;第一点很容易误导人&lt;/strong&gt;，让人产生“&lt;strong&gt;DPDK之所以能bypass内核空间获得PCI BAR靠的就是igb_uio&lt;/strong&gt;”，&lt;strong&gt;事实不然&lt;/strong&gt;，&lt;strong&gt;DPDK访问PCI BAR完全绕过了igb_uio&lt;/strong&gt;，igb_uio的确提供了方法可以让用户态空间应用来访问PCI BAR，不过DPDK没有用。关于这个地方，intel 包处理专家、《DPDK深入浅出》一书的作者梁存铭梁大师给出的解释是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
UIO提供了（PCI BAR）访问方式，但是DPDK直接mmap了resource，Kernel对resource实现的mmap跟在igb_uio中实现一个mmap是一样的实现，没有区别，用kernel自己的方式不是更好么？
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以我们可以确定的是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;igb_uio负责创建uio设备并加载igb_uio驱动，负责将内核驱动接管的网卡抢过来，以此来先屏蔽掉内核驱动以及内核协议栈；&lt;/li&gt;
&lt;li&gt;igb_uio负责一个桥梁的作用，衔接中断信号以及用户态应用，因为中断只能在内核态处理，所以igb_uio相当于提供了一个接口，衔接用户态与内核态的驱动，关于驱动，后续会开文章专门讲解DPDK的中断；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　事实上，igb_uio做的就是上面两点，接下来会从代码以及函数的角度分析igb_uio.ko的实现以及uio如何将PCI BAR暴露给用户态（虽然DPDK没有使用这种方式，但是如何将PCI BAR暴露给用户态，是UIO驱动的一大特色）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【5.igb_uio以及uio的部分代码分析】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　想读懂一个内核模块的作用，首先得确定其工作流程。&lt;/p&gt;
&lt;p&gt;　　igb_uio.ko初始化流程如图12所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200307214719972-1723548280.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图12.igb_uio.ko的初始化流程&lt;/p&gt;
&lt;p&gt;　　igb_uio.ko初始化主要是做了两件事:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一件事是配置中断模式;&lt;/li&gt;
&lt;li&gt;第二种模式便是注册驱动，见图13.;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200307212846402-541094476.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;469&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图13.igbuio_pci_init_module函数注册igb_uio驱动&lt;/p&gt;
&lt;p&gt;　　注册驱动后，剩余的进入内核处理内核模块的流程，也就是内核遍历注册的driver，调用driver的probe方法，在igb_uio.c中，也就是igbuio_pci_probe函数，见图14.。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181050/202003/1181050-20200308003953234-2045413418.jpg&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图14.内核处理注册的驱动以及调用probe的流程&lt;/p&gt;
&lt;p&gt;　　接下来便进入igbuio_pci_probe函数，处理主要的注册uio驱动的逻辑，函数调用图如图14所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181050/202003/1181050-20200307215415523-709262634.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图15.igbuio_pci_probe函数的内部调用流程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pci_enable_device : 使能PCI设备&lt;/li&gt;
&lt;li&gt;igbuio_pci_bars : 对PCI BAR进行ioremap的映射，拿到所有的PCI BAR。&lt;/li&gt;
&lt;li&gt;uio_register_device : 注册uio设备&lt;/li&gt;
&lt;li&gt;pci_set_drvdata : 设置私有变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　其中在igbuio_pci_bars函数中，会遍历6个PCI BAR，获得其PCI BAR的起始地址，并对这些起始地址进行ioremap，见代码3。这里需要注意的是，内核空间若想通过IO内存的方式访问外设在内存空间的寄存器，必须利用ioremap对PCI BAR的起始地址进行映射后才能访问。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;
igbuio_setup_bars(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; pci_dev *dev, &lt;span&gt;struct&lt;/span&gt; uio_info *&lt;span&gt;info)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, iom, iop, ret;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; flags;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *bar_names[PCI_STD_RESOURCE_END + &lt;span&gt;1&lt;/span&gt;]  =&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAR0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAR1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAR2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAR3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAR4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAR5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    };

    iom &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    iop &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历PCI设备的6个BAR&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ARRAY_SIZE(bar_names); i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;PCI BAR空间不等于0且起始地址不等于0，认为为有效BAR&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (pci_resource_len(dev, i) != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                pci_resource_start(dev, i) &lt;/span&gt;!= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到BAR的标识，如果为0x00000200则为内存空间&lt;/span&gt;
            flags =&lt;span&gt; pci_resource_flags(dev, i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; IORESOURCE_MEM) {
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对内存空间的PCI BAR进行映射&lt;/span&gt;
                ret =&lt;span&gt; igbuio_pci_setup_iomem(dev, info, iom,
                                 i, bar_names[i]);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
                iom&lt;/span&gt;++&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IO空间不再讨论范围内&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; IORESOURCE_IO) {
                ret &lt;/span&gt;=&lt;span&gt; igbuio_pci_setup_ioport(dev, info, iop,
                                  i, bar_names[i]);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
                iop&lt;/span&gt;++&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (iom != &lt;span&gt;0&lt;/span&gt; || iop != &lt;span&gt;0&lt;/span&gt;) ? ret : -&lt;span&gt;ENOENT;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对内存BAR进行映射，以及填充数据结构&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;
igbuio_pci_setup_iomem(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; pci_dev *dev, &lt;span&gt;struct&lt;/span&gt; uio_info *&lt;span&gt;info,
               &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; pci_bar, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name)
{
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; addr, len;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;internal_addr;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt;= ARRAY_SIZE(info-&amp;gt;&lt;span&gt;mem))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EINVAL;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到PCI BAR的起始地址&lt;/span&gt;
    addr =&lt;span&gt; pci_resource_start(dev, pci_bar);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到PCI BAR的长度&lt;/span&gt;
    len =&lt;span&gt; pci_resource_len(dev, pci_bar);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (addr == &lt;span&gt;0&lt;/span&gt; || len == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;wc_activate为igb_uio.ko的参数，默认为0，会进入if条件&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (wc_activate == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对PCI BAR进行ioremap，映射到内核空间，得到可以在内核空间映射后的PCI BAR地址，虽然没什么用，因为igb_uio完全不需要操作PCI设备，因此获得此地址意义不大&lt;/span&gt;
        internal_addr =&lt;span&gt; ioremap(addr, len);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (internal_addr ==&lt;span&gt; NULL)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        internal_addr &lt;/span&gt;=&lt;span&gt; NULL;
    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充数据结构&lt;/span&gt;
    info-&amp;gt;mem[n].name = name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PCI  BAR名，例如BAR0、BAR1&lt;/span&gt;
    info-&amp;gt;mem[n].addr = addr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PCI BAR起始地址，物理地址&lt;/span&gt;
    info-&amp;gt;mem[n].internal_addr = internal_addr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;经过ioremap映射后的PCI BAR，可以供内核空间访问&lt;/span&gt;
    info-&amp;gt;mem[n].size = len; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PCI BAR长度&lt;/span&gt;
    info-&amp;gt;mem[n].memtype = UIO_MEM_PHYS; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PCI BAR类型，为内存BAR&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码3&lt;/p&gt;
&lt;p&gt;　　可以看到igbuio_set_bars做的工作也非常简单，就是填充数据结构加上对PCI BAR的IO内存（物理地址）进行ioremap，但是在这里ioremap其实没什么用，进行ioremap映射后会得到一个可以供内核空间访问的PCI BAR地址（虚拟地址），不过从设计角度上讲，igb_uio不需要对PCI设备得到BAR空间，并对PCI设备进行配置，因此意义不大。接下来便是调用uio_register_devcie注册uio设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181050/202003/1181050-20200307221340368-452886309.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 图16.uio_register_device调用流程&lt;/p&gt;
&lt;p&gt;　　uio_register_device的流程主要是做了4件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dev_set_name : 给设备设置名称，uio0...N，为/dev/uio0..N&lt;/li&gt;
&lt;li&gt;device_register : 注册设备&lt;/li&gt;
&lt;li&gt;uio_dev_add_attribute : 主要是创建一些设备属性，这里说属性也有点不太恰当，从表现形式来看是在/sys/class/uio/uio0/目录中创建maps目录，里面包含的主要也是和resource文件一致，就是pci设备经过uio驱动接受以后再把resource资源通过文件系统暴露给用户态而已，可以看图17.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1181050/202003/1181050-20200307222825892-1434383885.png&quot; alt=&quot;&quot; width=&quot;1352&quot; height=&quot;482&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图17.uio_dev_add_attribute的作用&lt;/p&gt;
&lt;p&gt;　　到这里位置，igb_uio的初始化以及注册过程都已经完成了，最终表现形式便是在/dev/uio创建了一个uio设备，这个设备是用来衔接内核态的中断信号与用户态应用的，关于uio申请中断这里的细节以后会专门开一篇文章介绍DPDK的中断，这里先不予介绍。介绍到这里，贴一张数据结构关系图供大家理解，见图18.&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1181050/202003/1181050-20200307232530113-1699186129.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图18.数据结构关系&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;struct resource : 内核将PCI BAR的信息存储在这个数据结果中，可以理解为PCI BAR的抽象，可以理解这个resource结构体就对应了/sys/bus/pci/devices/[pci_addr]/resource文件
&lt;ol&gt;&lt;li&gt;start : PCI BAR空间起始地址（这里不一定是内存空间还是IO空间）；&lt;/li&gt;
&lt;li&gt;end : PCI BAR空间的结束地址；&lt;/li&gt;
&lt;li&gt;name : PCI BAR的名字，例如BAR 0、BAR1、BAR2....BAR5；&lt;/li&gt;
&lt;li&gt;flags : PCI BAR的标识，如果flags &amp;amp; 0x00000200则为内存空间，如果flags &amp;amp; 0x00000100则为IO空间；&lt;/li&gt;
&lt;li&gt;desc : IO资源描述符&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;struct pci_dev : pci设备的抽象，可以理解为一个struct pci_dev就代表一个pci设备
&lt;ol&gt;&lt;li&gt;vendor : 生产商id，intel为0x0806，见/sys/bus/pci/devices/[pci_addr]/vendor文件；&lt;/li&gt;
&lt;li&gt;device : 设备id；&lt;/li&gt;
&lt;li&gt;subsystem_vendor : 子系统生产商id；&lt;/li&gt;
&lt;li&gt;subsystem_device : 子系统设备id；&lt;/li&gt;
&lt;li&gt;driver : 当前PCI设备所用驱动；&lt;/li&gt;
&lt;li&gt;resource : 当前pci设备的pci bar资源；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;struct rte_uio_pci_dev : igb_uio的抽象，可以理解为igb_uio本身
&lt;ol&gt;&lt;li&gt;info : 用于关联uio信息；&lt;/li&gt;
&lt;li&gt;pdev : 用于关联pci设备；&lt;/li&gt;
&lt;li&gt;mode : 中断模式配置&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;struct uio_info : uio 信息配置的抽象
&lt;ol&gt;&lt;li&gt;uio_dev : 用来指向所属于的uio设备实例；&lt;/li&gt;
&lt;li&gt;name : 这个uio设备的名字，例如/dev/uio0，/dev/uio1，/dev/uio2；&lt;/li&gt;
&lt;li&gt;mem : 同样是PCI BAR资源，不过这里是已经做了区分，特指Memory BAR，这里的值仍然来自于内核的resource结构体，不过这里往往是将内核resource结构体映射后的值，可以理解为原始数据“加工”后的值；&lt;/li&gt;
&lt;li&gt;port : 同样是PCI BAR资源，不过这里是已经做了区分，特质Port BAR，这里的值仍然来自于内核的resource结构体，不过这里往往是将内核resource结构体映射后的值，可以理解为原始数据“加工”后的值；&lt;/li&gt;
&lt;li&gt;irq : 中断号；&lt;/li&gt;
&lt;li&gt;irq_flags : 中断标识；&lt;/li&gt;
&lt;li&gt;priv : 一个回调指针，指向dpdk的igb_uio驱动实例，其实这个字段的设计并不是为了专门服务于dpdk的igb_uio；&lt;/li&gt;
&lt;li&gt;handler、mmap、open、release、irqcontrol：分别为几个函数钩子，例如对/dev/uio进行open操作后，最终就会通过uio的file_operations -&amp;gt; open调用到igbuio_pci_open中，可以理解为open操作的内部实现；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;struct uio_device : uio设备的抽象，其实例可以代表一个uio设备
&lt;ol&gt;&lt;li&gt;这里的内容不多加介绍，因为关于一个uio设备的主要配置和信息都在uio_info结构中&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;struct uio_mem : 经过对resource进行处理后的Memory BAR信息，这里的信息主要是指的对PCI BAR进行ioremap
&lt;ol&gt;&lt;li&gt;name : PCI Memory BAR的名字，例如BAR 0、BAR1、BAR2....BAR5；&lt;/li&gt;
&lt;li&gt;addr : PCI Memory BAR的起始地址，为物理地址，这个地址必须经过ioremap映射后才可以给内核空间使用；&lt;/li&gt;
&lt;li&gt;offs : 偏移，一般为0；&lt;/li&gt;
&lt;li&gt;size : PCI Memory BAR的大小，通常可以用resource文件中的第二列（PCI BAR的终止地址）和resource文件中的第一列（PCI BAR的起始地址） + 1计算得出；&lt;/li&gt;
&lt;li&gt;memtype : 这个Memory Bar的内存类型，可以选择为物理地址、逻辑地址、虚拟地址三种类型，在DPDK的igb_uio中赋值为物理地址；&lt;/li&gt;
&lt;li&gt;internal_addr : 这个是一个关键，这个值即为PCI Memory BAR起始地址经过ioremap映射后得到的可以在内核空间直接访问的虚拟地址，当然之前也描述过，这个地址对于uio这种设计理念的设备而言是不需要的；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　以上便是关于igb_uio、uio代码中主要的数据结构关系以及数据结构之间的字段介绍，那么重新思考那个问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
假设不局限于DPDK的igb_uio，也不考虑内核开放出来的resource0..N，uio该怎么向用户空间暴露PCI BAR提供给用户空间使用呢？
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过上述的流程分析和数据结构的分析，我们起码可以知道一个事实，那就是uio内部其实是拿得到PCI BAR资源的，那么该怎么将这个BAR资源给用户态应用使用呢？答案其实也很简单，就是对/dev/uio0..N这个设备调用mmap进行内存映射，调用mmap之后，将会转到内核态事先注册好的file_operations.mmap钩子函数上，也就是调用uio_mmap，调用流程如图19所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181050/202003/1181050-20200308000231911-1895476712.jpg&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图19.mmap /dev/uio0..N的内核态函数调用流程&lt;/p&gt;
&lt;p&gt;　　当然之前也说过，igb_uio其实完全没有做mmap这块的工作，因此uio_info-&amp;gt;mmap这个钩子函数其实是NULL，所以DPDK完全不靠igb_uio得到PCI BAR，而是直接调用内核已经映射过的resource0..N即可。&lt;/p&gt;
&lt;p&gt;　　现在回到第二章的那三个Question上，现在经过3、4、5这三章的讲解，已经完全可以回答第一个Questions&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Q:igb_uio/vfio-pci的作用是什么？为什么要用这两个驱动？这里的“驱动”和dpdk内部对网卡的“驱动”（dpdk/driver/&lt;span&gt;）有什么区别呢？
A:igb_uio主要作用是实现了两个功能，第一个功能是将PCI设备进行take&lt;/span&gt;-over，以此来屏蔽掉内核驱动和内核协议栈；第二个功能是实现了一个桥梁的作用，衔接内核态的中断与用户态（当然中断的内容会在后续开始讲解）。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【6.如何将PCI设备的驱动重新绑定】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个操作其实只需要两个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将当前PCI设备的现有驱动目录下的unbind写入PCI设备的PCI地址，例如：
&lt;ul&gt;&lt;li&gt;echo &quot;0000:81:00.0&quot; &amp;gt; /sys/bus/pci/drivers/ixgbe/unbind&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拿到当前PCI设备的device id和vendor id，并将其写入新的驱动的new_id中，例如我手头上的intel 82599网卡的device id是10fb，intel的vendor id是8086，那么绑定例子如下：
&lt;ul&gt;&lt;li&gt;echo &quot;8086 10fb&quot; &amp;gt; /sys/bus/pci/drivers/igb_uio/new_id&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　那这么做背后的原理是什么呢？其实也很简单，在内核源代码目录/include/linux/devices.h中有这么一组宏：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; DRIVER_ATTR_RW(_name) \
    &lt;span&gt;struct&lt;/span&gt; driver_attribute driver_attr_##_name =&lt;span&gt; __ATTR_RW(_name)
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; DRIVER_ATTR_RO(_name) \
    &lt;span&gt;struct&lt;/span&gt; driver_attribute driver_attr_##_name =&lt;span&gt; __ATTR_RO(_name)
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; DRIVER_ATTR_WO(_name) \
    &lt;span&gt;struct&lt;/span&gt; driver_attribute driver_attr_##_name = __ATTR_WO(_name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码5.对于attribute的三种声明&lt;/p&gt;
&lt;p&gt;　　利用这三种宏声明的attribute，最终在文件系统中就是这个驱动中的attribute文件的状态，Linux中万物皆文件，这些attribute实际上就是/sys/bus/pci/drivers/[driver_name]/目录下的文件。例如以上述两个步骤中使用的unbind和new_id为例，代码位于/driver/base/bus.c中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * PCI设备驱动的unbind属性实现
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; ssize_t unbind_store(&lt;span&gt;struct&lt;/span&gt; device_driver *drv, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;buf,
                size_t count)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; bus_type *bus = bus_get(drv-&amp;gt;&lt;span&gt;bus);
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; device *&lt;span&gt;dev;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; err = -&lt;span&gt;ENODEV;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先根据写入的参数找到设备，根据例子命令，便是根据&quot;0000:08:00.0&quot;这个pci地址找到对应的pci设备实例&lt;/span&gt;
    dev =&lt;span&gt; bus_find_device_by_name(bus, NULL, buf);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dev &amp;amp;&amp;amp; dev-&amp;gt;driver ==&lt;span&gt; drv) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dev-&amp;gt;parent &amp;amp;&amp;amp; dev-&amp;gt;bus-&amp;gt;&lt;span&gt;need_parent_lock)
            device_lock(dev&lt;/span&gt;-&amp;gt;&lt;span&gt;parent);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pci设备释放驱动，其中调用的就是driver或者bus的remove钩子函数，然后再将device中的driver指针置空&lt;/span&gt;
&lt;span&gt;        device_release_driver(dev);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dev-&amp;gt;parent &amp;amp;&amp;amp; dev-&amp;gt;bus-&amp;gt;&lt;span&gt;need_parent_lock)
            device_unlock(dev&lt;/span&gt;-&amp;gt;&lt;span&gt;parent);
        err &lt;/span&gt;=&lt;span&gt; count;
    }
    put_device(dev);
    bus_put(bus);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;
}
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; DRIVER_ATTR_WO(unbind); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行attribute生命，声明为只写&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码6.unbind attribute的实现&lt;/p&gt;
&lt;p&gt;　　可以看到对unbind文件进行写操作后，最终会转到内核态的pci设备的unbind_store函数，这个函数的内容也非常简单，首先根据输入的PCI 地址找到对应的PCI设备实例，然后调用device_release_driver函数释放device相关联的driver，而new_id的属性实现则是在/drivers/pci/pci-driver.c中，函数调用流程即为图14中的下半部分，最终会调到驱动的probe钩子上，在igb_uio驱动中即为igbuio_pci_probe函数。&lt;/p&gt;
&lt;p&gt;　　以上，便是dpdk-devbinds实现驱动的解绑以及重绑的实现，有兴趣的可以自己写个pyhon或者shell脚本试一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181050/202003/1181050-20200308011725118-1308067273.jpg&quot; alt=&quot;&quot; width=&quot;519&quot; height=&quot;517&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图20,层级结构&lt;/p&gt;
&lt;p&gt;图20是个人理解:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内核接管硬件并将PCI BAR通过sysfs暴露给用户态,供用户态对其mmap后直接访问Memory BAR空间;&lt;/li&gt;
&lt;li&gt;应用层程序通过sysfs接口实现pci设备的驱动的unbind/bind;&lt;/li&gt;
&lt;li&gt;UIO为一框架,无法独立生存,需要在框架的基础上开发出igb_uio,igb_uio实现了uio设备的生命周期管理全权交给用户态应用掌管;&lt;/li&gt;
&lt;li&gt;其中中断信号仍然只能在内核态处理,不过uio通过创建/dev/uio来实现了一个&quot;桥梁&quot;来衔接用户态和内核态的中断处理,这时已经可以将用户态应用视为一种&quot;中断下半部&quot;;&lt;/li&gt;
&lt;li&gt;Application为最终的业务层,只需要调用PMD的对上接口即可;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;【7.后话】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.3-6章的讲解，基本解决了第二章的前两个Questions，最后一个Questions以及DPDK如何实现的中断，以及vfio的解析会在后续文章中逐一发出。&lt;/p&gt;
&lt;p&gt;2.这篇文章花费了较多的精力完成，并且内容较多，涉及到的知识也多为底层知识，因此其中难免会存在错别字、语法不通顺、以及笔误的情况，当然理解错误的地方也可能存在，还望各位朋友能够点明其中不合理的分析以及疏漏。&lt;/p&gt;
&lt;p&gt;3.写完这篇文章后，不禁再次感慨，毕业如今一年半，遇到令我震撼的项目一共有两个，第一个是DPDK，第二个便是VPP，经过分析原理才发现，设计者是真的牛逼，根本不是我等菜鸡所能企及的存在...&lt;/p&gt;

</description>
<pubDate>Sat, 07 Mar 2020 17:05:00 +0000</pubDate>
<dc:creator>Jungle1996</dc:creator>
<og:description>【前言】 随着网络的高速发展，对网络的性能要求也越来越高，DPDK框架是目前的一种加速网络IO的解决方案之一，也是最为流行的一套方案。DPDK通过bypass内核协议栈与内核驱动，将驱动的工作从内核态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jungle1996/p/12398915.html</dc:identifier>
</item>
<item>
<title>Servlet的生命周期 - 一点教程网</title>
<link>http://www.cnblogs.com/yiidian/p/12439327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yiidian/p/12439327.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;http://www.yiidian.com/servlet/servlet-lifecycle.html&quot; class=&quot;uri&quot;&gt;http://www.yiidian.com/servlet/servlet-lifecycle.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web容器（如：Tomcat）维护Servlet实例的生命周期。让我们看一下servlet的生命周期：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet类加载。&lt;/li&gt;
&lt;li&gt;Servlet实例创建。&lt;/li&gt;
&lt;li&gt;init方法被调用。&lt;/li&gt;
&lt;li&gt;service方法被调用。&lt;/li&gt;
&lt;li&gt;调用destroy方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202003/1516040-20200307234633479-1967991967.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，Servlet处于三种状态：New新建，Ready就绪和End结束。如果创建了Servlet实例，则Servlet处于新状态。调用init（）方法后，Servlet进入就绪状态。在就绪状态下，Servlet执行所有任务。当Web容器调用destroy（）方法时，它将转换为结束状态。&lt;/p&gt;
&lt;h3 id=&quot;加载servlet类&quot;&gt;1）加载Servlet类&lt;/h3&gt;
&lt;p&gt;类加载器负责加载Servlet类。当Web容器收到对Servlet的第一个请求时，将加载Servlet类。&lt;/p&gt;
&lt;h3 id=&quot;创建servlet实例&quot;&gt;2）创建Servlet实例&lt;/h3&gt;
&lt;p&gt;Web容器在加载Servlet类之后创建Servlet的实例。Servlet实例在Servlet生命周期中仅创建一次。&lt;/p&gt;
&lt;h3 id=&quot;init方法被调用&quot;&gt;3）init方法被调用&lt;/h3&gt;
&lt;p&gt;Web容器在创建Servlet实例后仅调用一次init方法。init方法用于初始化servlet。它是javax.servlet.Servlet接口的生命周期方法。init方法的语法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void init(ServletConfig config) throws ServletException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;### 4）service被调用&lt;/p&gt;
&lt;p&gt;每当接收到对Servlet的请求时，Web容器都会调用服务方法。如果未初始化servlet，则它遵循上述的前三个步骤，然后调用service方法。如果servlet被初始化，它将调用service方法。注意，Servlet仅初始化一次。Servlet接口的服务方法的语法如下：&lt;br/&gt;&lt;code&gt;java public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;调用destroy方法&quot;&gt;5）调用destroy方法&lt;/h3&gt;
&lt;p&gt;Web容器在从服务中删除Servlet实例之前调用destroy方法。它使Servlet有机会清理任何资源，例如内存，线程等。Servlet接口的destroy方法的语法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void destroy()  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202003/1516040-20200307234633792-839048733.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.6507936507937&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：：一点教程。获得独家整理的学习资源和日常干货推送。&lt;br/&gt;如果您对我的系列教程感兴趣，也可以关注我的网站：&lt;a href=&quot;http://www.yiidian.com&quot;&gt;yiidian.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 07 Mar 2020 15:47:00 +0000</pubDate>
<dc:creator>一点教程网</dc:creator>
<og:description>原文链接：http://www.yiidian.com/servlet/servlet lifecycle.html Web容器（如：Tomcat）维护Servlet实例的生命周期。让我们看一下ser</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yiidian/p/12439327.html</dc:identifier>
</item>
<item>
<title>单例模式你真的会了吗(上篇)？ - 程序员之道</title>
<link>http://www.cnblogs.com/chanllenge/p/12439289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanllenge/p/12439289.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;单例模式相信是很多程序员接触最多的了，也是面试过程中考察最频繁的一个了，不知道你有没有被问过这道面试题？欢迎留言讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来重点讨论一下单例的几个问题，及如何正确的实现一个单例，然后你再来回顾一下，你之前的回答或者使用方式是否正确。&lt;/p&gt;
&lt;h2 id=&quot;为何要使用单例&quot;&gt;为何要使用单例&lt;/h2&gt;
&lt;p&gt;单例非常简单，一个类只允许创建一个对象或者实例，这个类就是一个单例类。这种设计模式就叫做单例设计模式，是创建型的第一种设计模式，简称单例模式。&lt;/p&gt;
&lt;p&gt;单例模式什么时候使用呢？又或者说这种情况下为什么要使用单例？&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;解决资源冲突问题&lt;br/&gt;比如说，我们现在的java处理程序中是使用打印机，而我们的服务端程序是多线程的，但是打印机只有一个，不能重复创建打印机资源啊。当然我们也可以定义普通类，在调用打印添加synchronized关键字。&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;全局唯一类&lt;br/&gt;有时候，我们做业务设计时，有些数据在系统中只应该保留一份，这时候就应该设计为单例。&lt;br/&gt;比如配置信息类，系统的配置文件应该只有一份，加载到内存之后以对象的形式存在，理所应当只有一份。&lt;br/&gt;再比如说，我们设计一个抽奖系统，每点击一次生成一个抽奖序号，可以设计一个单例，内部存储好所有的序号，每次随机取出一个序号。如果使用普通类对象的话，那就需要通过共享内存共享所有抽奖序号。&lt;/p&gt;
&lt;h2 id=&quot;单例应该怎么写&quot;&gt;单例应该怎么写？&lt;/h2&gt;
&lt;p&gt;学习任何东西，因为大脑的容量是有限的，首先我们要理解概念，知道为什么，来后追求怎么做，怎么实现，做的过程可能很复杂，比如有一二三四五步骤，但我们要化繁为简，概括精简。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;单例需要考虑以下几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造函数要是private的，这样才能避免外部通过new创建实例嘛，不然怎么叫单例，别人可以随便通过new来创建啊。&lt;/li&gt;
&lt;li&gt;多线程创建时是否有线程安全问题。&lt;/li&gt;
&lt;li&gt;支持延迟加载吗？&lt;/li&gt;
&lt;li&gt;getInstance()性能高吗？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;单例典型实现方式&quot;&gt;单例典型实现方式&lt;/h2&gt;
&lt;h3 id=&quot;饿汉式&quot;&gt;饿汉式&lt;/h3&gt;
&lt;p&gt;通过这种形容方式，可以直观的理解一下，饿汉一直担心自己吃不饱，所以先吃了再说，也就是说实例是事先初始化好的，也就没有办法延迟加载了。&lt;br/&gt;不支持懒加载，有人就说这种方式不好，说我都没有使用单例，你都给我加载了，浪费啊。但是有坏处也有好处，提前把类加载进来，提前暴露问题，这样如果类的设计有问题，在程序启动时就会报错，而不是等到程序运行中才暴露出来。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SingleTon {
    private static final SingleTon instance = new SingleTon();
    
    private SingleTon() {}
    
    public static SingleTon getInstance() {
        return instance;
    }
    
    public void method() {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;懒汉式&quot;&gt;懒汉式&lt;/h3&gt;
&lt;p&gt;所谓懒汉式，那就是支持延迟加载喽。总体思路类似，但在类内部并不是默认就把instance实例化好。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SingleTon {
    private static SingleTon instance;

    private SingleTon() {}

    public static synchronized SingleTon getInstance() {
        if (instance == null) {
            instance = new SingleTon();
        }
        return instance;
    }

    public void method() {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么要加synchronized呢？如果是多线程同时调用getInstance()，会有并发问题啊，多个线程可能同时拿到instance == null的判断，这样就会重复实例化，单例就不是单例。所以为了解决多线程并发的问题，这里牺牲了性能，变成了严格的串行制。多线程下性能很低。&lt;/p&gt;
&lt;h3 id=&quot;双重检测懒汉式&quot;&gt;双重检测懒汉式&lt;/h3&gt;
&lt;p&gt;饿汉方式不支持延迟加载。&lt;br/&gt;懒汉方式，多线程下性能低下，那怎么修改呢，就是改进的懒汉方式，又叫双重检测。&lt;br/&gt;具体怎么做呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SingleTon {
    private static volatile SingleTon instance;

    private SingleTon() {}

    public static SingleTon getInstance() {
        if (instance == null) {
            synchronized (SingleTon.class) {
                if (instance == null) {
                    instance = new SingleTon();
                }
            }
        }
        return instance;
    }

    public void method() {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类里的volatile十分关键，如果没有volatile关键字修饰instance变量，如果线程1执行到instance = new SingleTon();的时候，线程2此时判断instance已经不等于null了，会直接返回instance，但此时instance并未初始化完毕，为什么这么说呢？因为对象的初始化分为三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分配内存&lt;/li&gt;
&lt;li&gt;内存初始化&lt;/li&gt;
&lt;li&gt;对象指向新分配的内存地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然是分为三步，那就不是原子操作，而且可能会发生指令重排，也就是说可能先执行第三步，这时候其他线程判断instance也就不是null了。加上volatile关键字，可以禁止机器指令重排，就不会有这个问题了。&lt;/p&gt;
&lt;h3 id=&quot;静态内部类&quot;&gt;静态内部类&lt;/h3&gt;
&lt;p&gt;这种方式，避免双重检测，利用java静态内部类，类似饿汉方式，又做到延迟加载。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SingleTon {

    private SingleTon() {}
    
    private static class SingleTonHolder {
        private static final SingleTon instance = new SingleTon();
    }

    public static SingleTon getInstance() {
        return SingleTonHolder.instance;
    }

    public void method() {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是觉得很简洁？推荐大家使用这种方式，类SingleTon加载时，并不会加载SingleTonHolder类，只要调用getInstance方法时，SingleTonHolder才会被加载，并创建instance，这些都是由JVM来保证的。&lt;/p&gt;
&lt;h3 id=&quot;枚举方式&quot;&gt;枚举方式&lt;/h3&gt;
&lt;p&gt;还有一种更简单的，但是理解起来可能有点费解，枚举的构造函数默认就是私有的。java的枚举类型本身就保证了线程安全性和实例唯一性。&lt;br/&gt;只需要简单几行，就可以使用枚举单例INSTANCE的方法了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum SingleTon {
    INSTANCE;
    
    public void method() {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是单例模式真的就好吗？下面我们会讨论一下为什么不推荐单例模式？如何替代，以及如何做到集群下的分布式单例模式？&lt;/p&gt;
&lt;p&gt;程序员的小伙伴们，学习之路，同行的人越多才可以走的更远，加入公众号[程序员之道]，一起交流沟通，走出我们的程序员之道！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191101152112767.jpeg&quot; alt=&quot;扫码加入吧！&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Mar 2020 15:39:00 +0000</pubDate>
<dc:creator>程序员之道</dc:creator>
<og:description>单例模式相信是很多程序员接触最多的了，也是面试过程中考察最频繁的一个了，不知道你有没有被问过这道面试题？欢迎留言讨论。 今天我们来重点讨论一下单例的几个问题，及如何正确的实现一个单例，然后你再来回顾一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chanllenge/p/12439289.html</dc:identifier>
</item>
<item>
<title>总结：利用asp.net core日志进行生产环境下的错误排查（asp.net core version 2.2，用IIS做服务器） - Bob1227</title>
<link>http://www.cnblogs.com/sdBob/p/12436281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdBob/p/12436281.html</guid>
<description>&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调试asp.net core程序时，在输出窗口中，在输出来源选择“调试”或“xxx-ASP.NET Core Web服务器”时，可以看到类似“info:Microsoft.AspNetCore.Hosting.Internal.WebHost[2] Request finished in 285.6ms 200 text/css”这样的内容，这就是asp.net core的日志。如果出现了未捕获的异常，在输出窗口中可以看到出错信息，如：fail: Microsoft.AspNetCore.Server.Kestrel[13]……An unhandled exception was thrown by the application. System.NullReferenceException: 未将对象引用设置到对象的实例。在……行号 xx 在……行号 xx。在网站运行过程中，如果可以把这些出错信息保存下来，就可以排查代码错误了。方法很简单：把web.config文件中aspNetCore标签的stdoutLogEnabled属性设置为true，这样，在网站运行后，默认会在/logs文件夹下产生一个stdout_xxx_xxx.log的文件，日志会保存到这里面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;logging provider&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从名称“stdoutLogEnabled”来看，stdout，表示“标准输出”，即控制台输出。试着写一句Console.WriteLine(xxx)，在.log文件中果然就可以看到输出的内容。如果是在调试环境，可以在输出窗口/ASP.NET Core Web服务器看到Console输出的内容。asp.net core mvc项目代码模板默认添加了三个&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.2#add-providers&quot; target=&quot;_blank&quot;&gt;logging provider&lt;/a&gt;：Console、Debug、EventSource。VS的输出窗口/ASP.NET Core Web服务器，显示的就是Console这个logging provider输出的内容，而输出窗口/调试，显示的是Debug的。所以，stdout_xxx_xxx.log文件，保存的就是Console logging provider输出的日志。&lt;/p&gt;
&lt;p&gt;观察VS的输出窗口，可以发现，同一条日志内容，在“调试”和“ASP.NET Core Web服务器”中输出的格式是不同的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;日志级别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core定义了几个&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.2#log-level&quot; target=&quot;_blank&quot;&gt;日志级别&lt;/a&gt;，表示日志的严重程度，从低到高分别是Trace 、Debug 、Information 、Warning 、Error 、Critical 。可以设置一个最低日志级别，比如设置成Warning，将屏蔽Trace 、Debug 、Information级别的日志。最低日志级别可以给每个logging provider分别设置，如果没有具体设置，将采用默认设置。如，设置默认日志级别为Information：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;Default&quot;: &quot;Information&quot;&lt;span&gt;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别设置Debug、Console的日志级别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;Debug&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Default&quot;: &quot;Information&quot;&lt;span&gt;
      }
    },
    &lt;/span&gt;&quot;Console&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Default&quot;: &quot;Debug&quot;&lt;span&gt;
      }
    },
    &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;Default&quot;: &quot;Debug&quot;&lt;span&gt;
    }
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么针对具体的logging provider也标上&quot;Default&quot;？因为可以再针对日志的&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.2#log-category&quot; target=&quot;_blank&quot;&gt;Log category&lt;/a&gt;分别设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;Console&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Microsoft.AspNetCore.Mvc.Razor.Internal&quot;: &quot;Warning&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Microsoft.AspNetCore.Mvc.Razor.Razor&quot;: &quot;Debug&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Microsoft.AspNetCore.Mvc.Razor&quot;: &quot;Error&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Default&quot;: &quot;Information&quot;&lt;span&gt;
      }
    },
    &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;Default&quot;: &quot;Debug&quot;&lt;span&gt;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于Log category的概念请自行查阅&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.2#log-category&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;，不再赘述。&lt;/p&gt;
&lt;p&gt;值得注意的时，在网站运行状态下，修改appsettings.json中的上述配置，不会造成网站重启（而修改web.config会造成网站重启），但对日志级别的控制会立即生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;添加web.config到源代码项目中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建的asp.net core 2.2项目，默认没有web.config文件。可以通过“添加”、“新建项”、“Web配置文件”的方式手动添加。这样就可以在源码项目中设定web.config的内容了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使日志包含时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、安装nuget包LoggingAdvanced.Console&lt;/p&gt;
&lt;p&gt;2、修改Program.cs的CreateWebHostBuilder方法，在其中的方法调用链的最后，调用ConfigureLogging方法，修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .ConfigureLogging((hostingContext, loggingBuilder) &lt;/span&gt;=&amp;gt;&lt;span&gt;
                 {
                     loggingBuilder.ClearProviders();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除所有提供程序&lt;/span&gt;
&lt;span&gt;
                     loggingBuilder.AddDebug();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加Debug提供程序&lt;/span&gt;
&lt;span&gt;
                     loggingBuilder.AddEventSourceLogger();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加EventSource提供程序&lt;/span&gt;

                     &lt;span&gt;var&lt;/span&gt; loggingSection = hostingContext.Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                     loggingBuilder.AddConsoleAdvanced(loggingSection);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加LoggingAdvanced.Console提供程序&lt;/span&gt;
                 });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、修改appsettings.json的中的Logging部分，修改后如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;IncludeTimestamp&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;IncludeLogNamespace&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;TimestampPolicy&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;TimeZone&quot;: &quot;Ulaanbaatar Standard Time&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;Format&quot;: &quot;yyyy/MM/dd HH:mm:ss.fff&quot;&lt;span&gt;
    },
    &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;Default&quot;: &quot;Warning&quot;&lt;span&gt;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用浏览器查看.log文件，日志有更新，刷新一下就好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、有关“日志提供程序”、“日志级别”、“日志筛选”等概念，请参考官方文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.2&quot; target=&quot;_blank&quot;&gt;Logging in .NET Core and ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://github.com/ilya-chumakov/LoggingAdvanced&quot; target=&quot;_blank&quot;&gt;LoggingAdvanced.Console&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Mar 2020 15:35:00 +0000</pubDate>
<dc:creator>Bob1227</dc:creator>
<og:description>概述 调试asp.net core程序时，在输出窗口中，在输出来源选择“调试”或“xxx-ASP.NET Core Web服务器”时，可以看到类似“info:Microsoft.AspNetCore.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdBob/p/12436281.html</dc:identifier>
</item>
<item>
<title>Spring配置cache（concurrentHashMap，guava cache、redis实现）附源码 - 寻觅beyond</title>
<link>http://www.cnblogs.com/-beyond/p/12436704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-beyond/p/12436704.html</guid>
<description>&lt;p&gt;　　在应用程序中，数据一般是存在数据库中（磁盘介质），对于某些被频繁访问的数据，如果每次都访问数据库，不仅涉及到网络io，还受到数据库查询的影响；而目前通常会将频繁使用，并且不经常改变的数据放入缓存中，从缓存中查询数据的效率要高于数据库，因为缓存一般KV形式存储，并且是将数据存在“内存”中，从内存访问数据是相当快的。&lt;/p&gt;
&lt;p&gt;　　对于频繁访问，需要缓存的数据，我们一般是这样做的：&lt;/p&gt;
&lt;p&gt;　　1、当收到查询请求，先去查询缓存，如果缓存中查询到数据，那么直接将查到的数据作为响应数据；&lt;/p&gt;
&lt;p&gt;　　2、如果缓存中没有找到要查询的数据，那么就从其他地方，比如数据库中查询出来，如果从数据库中查到了数据，就将数据放入缓存后，再将数据返回，下一次可以直接从缓存查询；&lt;/p&gt;
&lt;p&gt;　　这里就不进一步探究“缓存穿透”的问题，有兴趣可以自己学习一下。&lt;/p&gt;
&lt;p&gt;　　本文就根据Spring框架分别对ConcurrentHashMap、Guava Cache、Redis进行阐释如何使用，完整代码已上传到github：&lt;a href=&quot;https://github.com/searchingbeyond/ssm&quot;&gt;https://github.com/searchingbeyond/ssm&lt;/a&gt; &lt;/p&gt;

&lt;h2&gt;一、使用ConcurrentHashMap&lt;/h2&gt;
&lt;h3&gt;1.1、特点说明&lt;/h3&gt;
&lt;p&gt;　　ConcurrentHashMap是JDK自带的，所以不需要多余的jar包；&lt;/p&gt;
&lt;p&gt;　　使用ConcurrentHashMap，是直接使用将数据存放在内存中，并且&lt;strong&gt;没有数据过期的概念&lt;/strong&gt;，也&lt;strong&gt;没有数据容量的限制&lt;/strong&gt;，所以只要不主动清理数据，那么数据将一直不会减少。&lt;/p&gt;
&lt;p&gt;　　另外，ConcurrentHashMap在多线程情况下也是安全的，不要使用HashMap存缓存数据，因为HashMap在多线程操作时容易出现问题。&lt;/p&gt;

&lt;h3&gt;1.2、创建user类&lt;/h3&gt;
&lt;p&gt;　　下面是user类代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package cn.ganlixin.ssm.model.entity;

import lombok.Data;

@Data
public class UserDO {
    private Integer id;
    private String name;
    private Integer age;
    private Integer gender;
    private String addr;
    private Integer status;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1.3、创建spring cache的实现类&lt;/h3&gt;
&lt;p&gt;　　创建一个UserCache类（类名随意），实现org.springframework.cache.Cache接口，然后override需要实现的接口方法，主要针对getName、get、put、evict这4个方法进行重写。&lt;/p&gt;
&lt;p&gt;　　注意，我在缓存user数据时，指定了缓存的规则：key用的是user的id，value就是user对象的json序列化字符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package cn.ganlixin.ssm.cache.origin;

import cn.ganlixin.ssm.constant.CacheNameConstants;
import cn.ganlixin.ssm.model.entity.UserDO;
import cn.ganlixin.ssm.util.common.JsonUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.cache.Cache;
import org.springframework.cache.support.SimpleValueWrapper;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class UserCache implements Cache {

    // 使用ConcurrentHashMap作为数据的存储
    private Map&amp;lt;String, String&amp;gt; storage = new ConcurrentHashMap&amp;lt;&amp;gt;();

    // getName获取cache的名称，存取数据的时候用来区分是针对哪个cache操作
    @Override
    public String getName() {
        return CacheNameConstants.USER_ORIGIN_CACHE;// 我用一个常量类来保存cache名称
    }

    // put方法，就是执行将数据进行缓存
    @Override
    public void put(Object key, Object value) {
        if (Objects.isNull(value)) {
            return;
        }

        // 注意我在缓存的时候，缓存的值是把对象序列化后的（当然可以修改storage直接存放UserDO类也行）
        storage.put(key.toString(), JsonUtils.encode(value, true));
    }

    // get方法，就是进行查询缓存的操作，注意返回的是一个包装后的值
    @Override
    public ValueWrapper get(Object key) {
        String k = key.toString();
        String value = storage.get(k);
        
        // 注意返回的数据，要和存放时接收到数据保持一致，要将数据反序列化回来。
        return StringUtils.isEmpty(value) ? null : new SimpleValueWrapper(JsonUtils.decode(value, UserDO.class));
    }

    // evict方法，是用来清除某个缓存项
    @Override
    public void evict(Object key) {
        storage.remove(key.toString());
    }

    /*----------------------------下面的方法暂时忽略不管-----------------*/

    @Override
    public Object getNativeCache() { return null; }

    @Override
    public void clear() { }

    @Override
    public &amp;lt;T&amp;gt; T get(Object key, Class&amp;lt;T&amp;gt; type) { return null; }

    @Override
    public &amp;lt;T&amp;gt; T get(Object key, Callable&amp;lt;T&amp;gt; valueLoader) { return null; }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1.4、创建service&lt;/h3&gt;
&lt;p&gt;　　这里就不写贴出UserMapper的代码了，直接看接口就明白了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package cn.ganlixin.ssm.service;

import cn.ganlixin.ssm.model.entity.UserDO;

public interface UserService {

    UserDO findUserById(Integer id);

    Boolean removeUser(Integer id);

    Boolean addUser(UserDO user);

    Boolean modifyUser(UserDO user);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现UserService，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package cn.ganlixin.ssm.service.impl;

import cn.ganlixin.ssm.constant.CacheNameConstants;
import cn.ganlixin.ssm.mapper.UserMapper;
import cn.ganlixin.ssm.model.entity.UserDO;
import cn.ganlixin.ssm.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.Objects;

@Service
@Slf4j
public class UserServiceImpl implements UserService {

    @Resource
    private UserMapper userMapper;

    @Override
    @Cacheable(value = CacheNameConstants.USER_ORIGIN_CACHE, key = &quot;#id&quot;)
    public UserDO findUserById(Integer id) {
        try {
            log.info(&quot;从DB查询id为{}的用户&quot;, id);
            return userMapper.selectById(id);
        } catch (Exception e) {
            log.error(&quot;查询用户数据失败，id:{}, e:{}&quot;, id, e);
        }

        return null;
    }

    @Override
    @CacheEvict(
            value = CacheNameConstants.USER_ORIGIN_CACHE,
            key = &quot;#id&quot;,
            condition = &quot;#result != false&quot;
    )
    public Boolean removeUser(Integer id) {
        if (Objects.isNull(id) || id &amp;lt;= 0) {
            return false;
        }

        try {
            int cnt = userMapper.deleteUserById(id);
            return cnt &amp;gt; 0;
        } catch (Exception e) {
            log.error(&quot;删除用户数据失败，id:{}, e:{}&quot;, id, e);
        }

        return false;
    }

    @Override
    public Boolean addUser(UserDO user) {
        if (Objects.isNull(user)) {
            log.error(&quot;添加用户异常，参数不能为null&quot;);
            return false;
        }

        try {
            return userMapper.insertUserSelectiveById(user) &amp;gt; 0;
        } catch (Exception e) {
            log.error(&quot;添加用户失败，data:{}, e:{}&quot;, user, e);
        }

        return false;
    }

    @Override
    @CacheEvict(
            value = CacheNameConstants.USER_ORIGIN_CACHE,
            key = &quot;#user.id&quot;,
            condition = &quot;#result != false&quot;
    )
    public Boolean modifyUser(UserDO user) {
        if (Objects.isNull(user) || Objects.isNull(user.getId()) || user.getId() &amp;lt;= 0) {
            log.error(&quot;更新用户异常，参数不合法，data:{}&quot;, user);
            return false;
        }

        try {
            return userMapper.updateUserSelectiveById(user) &amp;gt; 0;
        } catch (Exception e) {
            log.error(&quot;添加用户失败，data:{}, e:{}&quot;, user, e);
        }

        return false;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1.5、@Cachable、@CachePut、@CacheEvict&lt;/h3&gt;
&lt;p&gt;　　上面方法声明上有@Cachable、@CachePut、@CacheEvict注解，用法如下：&lt;/p&gt;
&lt;p&gt;　　@Cachable注解的方法，先查询缓存中有没有，如果已经被缓存，则从缓存中查询数据并返回给调用方；如果查缓存没有查到数据，就执行被注解的方法（一般是从DB中查询），然后将从DB查询的结果进行缓存，然后将结果返回给调用方；&lt;/p&gt;
&lt;p&gt;　　@CachePut注解的方法，不会查询缓存是否存在要查询的数据，而是每次都执行被注解的方法，然后将结果的返回值先缓存，然后返回给调用方；&lt;/p&gt;
&lt;p&gt;　　@CacheEvict注解的方法，每次都会先执行被注解的方法，然后再将缓存中的缓存项给清除；&lt;/p&gt;
&lt;p&gt;　　这三个注解都有几个参数，分别是value、key、condition，这些参数的含义如下：&lt;/p&gt;
&lt;p&gt;　　value，用来指定将数据放入哪个缓存，比如上面是将数据缓存到UserCache中；&lt;/p&gt;
&lt;p&gt;　　key，表示放入缓存的key，也就是UserCache中的put方法的key；&lt;/p&gt;
&lt;p&gt;　　condition，表示数据进行缓存的条件，condition为true时才会缓存数据；&lt;/p&gt;
&lt;p&gt;　　最后缓存项的值，这个值是指的K-V的V，其实只有@Cachable和@CachePut才需要注意缓存项的值（也就是put方法的value），缓存项的值就是被注解的方法的返回值。&lt;/p&gt;

&lt;h3&gt;1.6、创建一个controller进行测试&lt;/h3&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package cn.ganlixin.ssm.controller;

import cn.ganlixin.ssm.enums.ResultStatus;
import cn.ganlixin.ssm.model.Result;
import cn.ganlixin.ssm.model.entity.UserDO;
import cn.ganlixin.ssm.service.UserService;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import java.util.Objects;

@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {

    @Resource
    private UserService userService;

    @GetMapping(value = &quot;/getUserById&quot;)
    public Result&amp;lt;UserDO&amp;gt; getUserById(Integer id) {
        UserDO data = userService.findUserById(id);

        if (Objects.isNull(data)) {
            return new Result&amp;lt;&amp;gt;(ResultStatus.DATA_EMPTY.getCode(), ResultStatus.DATA_EMPTY.getMsg(), null);
        }

        return new Result&amp;lt;&amp;gt;(ResultStatus.OK.getCode(), ResultStatus.OK.getMsg(), data);
    }

    @PostMapping(value = &quot;removeUser&quot;)
    public Result&amp;lt;Boolean&amp;gt; removeUser(Integer id) {
        Boolean res = userService.removeUser(id);
        return res ? new Result&amp;lt;&amp;gt;(ResultStatus.OK.getCode(), ResultStatus.OK.getMsg(), true)
                : new Result&amp;lt;&amp;gt;(ResultStatus.FAILED.getCode(), ResultStatus.FAILED.getMsg(), false);
    }

    @PostMapping(value = &quot;addUser&quot;)
    public Result&amp;lt;Boolean&amp;gt; addUser(@RequestBody UserDO user) {
        Boolean res = userService.addUser(user);

        return res ? new Result&amp;lt;&amp;gt;(ResultStatus.OK.getCode(), ResultStatus.OK.getMsg(), true)
                : new Result&amp;lt;&amp;gt;(ResultStatus.FAILED.getCode(), ResultStatus.FAILED.getMsg(), false);
    }

    @PostMapping(value = &quot;modifyUser&quot;)
    public Result&amp;lt;Boolean&amp;gt; modifyUser(@RequestBody UserDO user) {
        Boolean res = userService.modifyUser(user);

        return res ? new Result&amp;lt;&amp;gt;(ResultStatus.OK.getCode(), ResultStatus.OK.getMsg(), true)
                : new Result&amp;lt;&amp;gt;(ResultStatus.FAILED.getCode(), ResultStatus.FAILED.getMsg(), false);
    }

}
&lt;/pre&gt;&lt;/div&gt;



&lt;h2&gt;二、使用Guava Cache实现&lt;/h2&gt;
&lt;p&gt;　　使用Guava Cache实现，其实只是替换ConcurrentHashMap，其他的逻辑都是一样的。&lt;/p&gt;
&lt;h3&gt;2.1、特点说明&lt;/h3&gt;
&lt;p&gt;　　Guava是google开源的一个集成包，用途特别广，在Cache也占有一席之地，对于Guava Cache的用法，如果没有用过，可以参考：&lt;a href=&quot;https://www.cnblogs.com/-beyond/p/12272551.html&quot; target=&quot;_blank&quot;&gt;guava cache使用方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　使用Guava Cache，&lt;strong&gt;可以设置缓存的容量以及缓存的过期时间&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.2、实现spring cache接口&lt;/h3&gt;
&lt;p&gt;　　仍旧使用之前的示例，重新创建一个Cache实现类，这里对“Book”进行缓存，所以缓存名称为BookCache。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package cn.ganlixin.ssm.cache.guava;

import cn.ganlixin.ssm.constant.CacheNameConstants;
import cn.ganlixin.ssm.model.entity.BookDO;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.springframework.cache.support.SimpleValueWrapper;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

/**
 * 书籍数据缓存
 */
@Component
public class BookCache implements org.springframework.cache.Cache {

    // 下面的Cache是Guava对cache
    private Cache&amp;lt;String, BookDO&amp;gt; storage;

    @PostConstruct
    private void init() {
        storage = CacheBuilder.newBuilder()
                // 设置缓存的容量为100
                .maximumSize(100)
                // 设置初始容量为16
                .initialCapacity(16)
                // 设置过期时间为写入缓存后10分钟过期
                .refreshAfterWrite(10, TimeUnit.MINUTES)
                .build();
    }

    @Override
    public String getName() {
        return CacheNameConstants.BOOK_GUAVA_CACHE;
    }

    @Override
    public ValueWrapper get(Object key) {
        if (Objects.isNull(key)) {
            return null;
        }

        BookDO data = storage.getIfPresent(key.toString());
        return Objects.isNull(data) ? null : new SimpleValueWrapper(data);
    }

    @Override
    public void evict(Object key) {
        if (Objects.isNull(key)) {
            return;
        }

        storage.invalidate(key.toString());
    }

    @Override
    public void put(Object key, Object value) {
        if (Objects.isNull(key) || Objects.isNull(value)) {
            return;
        }

        storage.put(key.toString(), (BookDO) value);
    }

    /*-----------------------忽略下面的方法-----------------*/

    @Override
    public &amp;lt;T&amp;gt; T get(Object key, Class&amp;lt;T&amp;gt; type) { return null; }

    @Override
    public Object getNativeCache() { return null; }

    @Override
    public &amp;lt;T&amp;gt; T get(Object key, Callable&amp;lt;T&amp;gt; valueLoader) { return null; }

    @Override
    public void clear() { }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;三、使用Redis实现&lt;/h2&gt;
&lt;h3&gt;3.1、特点说明&lt;/h3&gt;
&lt;p&gt;　　由于ConcurrentHashMap和Guava Cache都是将数据直接缓存在服务主机上，很显然，缓存数据量的多少和主机的内存直接相关，一般不会用来缓存特别大的数据量；&lt;/p&gt;
&lt;p&gt;　　而比较大的数据量，我们一般用Redis进行缓存。&lt;/p&gt;
&lt;p&gt;　　使用Redis整合Spring Cache，其实和ConcurrentHashMap和Guava Cache一样，只是在实现Cache接口的类中，使用Redis进行存储接口。&lt;/p&gt;

&lt;h3&gt;3.2、创建Redis集群操作类&lt;/h3&gt;
&lt;p&gt;　　建议自己搭建一个redis测试集群，可以参考：&lt;/p&gt;
&lt;p&gt;　　redis配置如下（application.properties)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
#redis集群的节点信息
redis.cluster.nodes=192.168.1.3:6379,192.168.1.4:6379,192.168.1.5:6379
# redis连接池的配置
redis.cluster.pool.max-active=8
redis.cluster.pool.max-idle=5
redis.cluster.pool.min-idle=3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package cn.ganlixin.ssm.config;

import org.apache.commons.collections4.CollectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.JedisCluster;
import redis.clients.jedis.JedisPoolConfig;

import java.util.Set;
import java.util.stream.Collectors;

@Configuration
public class RedisClusterConfig {

    private static final Logger log = LoggerFactory.getLogger(RedisClusterConfig.class);

    @Value(&quot;${redis.cluster.nodes}&quot;)
    private Set&amp;lt;String&amp;gt; redisNodes;

    @Value(&quot;${redis.cluster.pool.max-active}&quot;)
    private int maxTotal;

    @Value(&quot;${redis.cluster.pool.max-idle}&quot;)
    private int maxIdle;

    @Value(&quot;${redis.cluster.pool.min-idle}&quot;)
    private int minIdle;

    // 初始化redis配置
    @Bean
    public JedisCluster redisCluster() {

        if (CollectionUtils.isEmpty(redisNodes)) {
            throw new RuntimeException();
        }

        // 设置redis集群的节点信息
        Set&amp;lt;HostAndPort&amp;gt; nodes = redisNodes.stream().map(node -&amp;gt; {
            String[] nodeInfo = node.split(&quot;:&quot;);
            if (nodeInfo.length == 2) {
                return new HostAndPort(nodeInfo[0], Integer.parseInt(nodeInfo[1]));
            } else {
                return new HostAndPort(nodeInfo[0], 6379);
            }
        }).collect(Collectors.toSet());

        // 配置连接池
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(maxTotal);
        jedisPoolConfig.setMaxIdle(maxIdle);
        jedisPoolConfig.setMinIdle(minIdle);

        // 创建jediscluster，传入节点列表和连接池配置
        JedisCluster cluster = new JedisCluster(nodes, jedisPoolConfig);
        log.info(&quot;finish jedis cluster initailization&quot;);

        return cluster;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 3.3、创建spring cache实现类&lt;/h3&gt;
&lt;p&gt;　　只需要在涉及到数据操作的时候，使用上面的jedisCluster即可，这里存在redis的数据，我设置为Music，所以叫做music cache：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package cn.ganlixin.ssm.cache.redis;

import cn.ganlixin.ssm.constant.CacheNameConstants;
import cn.ganlixin.ssm.model.entity.MusicDO;
import cn.ganlixin.ssm.util.common.JsonUtils;
import com.google.common.base.Joiner;
import org.apache.commons.lang3.StringUtils;
import org.springframework.cache.Cache;
import org.springframework.cache.support.SimpleValueWrapper;
import org.springframework.stereotype.Component;
import redis.clients.jedis.JedisCluster;

import javax.annotation.Resource;
import java.util.Objects;
import java.util.concurrent.Callable;

@Component
public class MusicCache implements Cache {

    // 使用自定义的redisCluster
    @Resource
    private JedisCluster redisCluster;

    /**
     * 构建redis缓存的key
     *
     * @param type   类型
     * @param params 参数（不定长）
     * @return 构建的key
     */
    private String buildKey(String type, Object... params) {
        // 自己设定构建方式
        return Joiner.on(&quot;_&quot;).join(type, params);
    }

    @Override
    public String getName() {
        return CacheNameConstants.MUSIC_REDIS_CACHE;
    }

    @Override
    public void put(Object key, Object value) {
        if (Objects.isNull(value)) {
            return;
        }

        // 自己定义数据类型和格式
        redisCluster.set(buildKey(&quot;music&quot;, key), JsonUtils.encode(value, true));
    }

    @Override
    public ValueWrapper get(Object key) {
        if (Objects.isNull(key)) {
            return null;
        }

        // 自己定义数据类型和格式
        String music = redisCluster.get(buildKey(&quot;music&quot;, key));
        return StringUtils.isEmpty(music) ? null : new SimpleValueWrapper(JsonUtils.decode(music, MusicDO.class));
    }

    @Override
    public void evict(Object key) {
        if (Objects.isNull(key)) {
            return;
        }

        redisCluster.del(buildKey(&quot;music&quot;, key));
    }

    @Override
    public &amp;lt;T&amp;gt; T get(Object key, Class&amp;lt;T&amp;gt; type) { return null; }

    @Override
    public &amp;lt;T&amp;gt; T get(Object key, Callable&amp;lt;T&amp;gt; valueLoader) { return null; }

    @Override
    public void clear() { }

    @Override
    public Object getNativeCache() { return null; }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　使用spring cache的便捷之处在于@Cachable、@CachePut、@CacheEvict等几个注解的使用，可以让数据的处理变得更加的便捷，但其实，也并不是很便捷，因为我们需要对数据的存储格式进行设定，另外还要根据不同情况来选择使用哪一种缓存（ConcurrentHashMap、Guava Cache、Redis？）；&lt;/p&gt;
&lt;p&gt;　　其实使用@Cachable、@CachePut、@CacheEvict也有很多局限的地方，比如删除某项数据的时候，我希望清空多个缓存，因为这一项数据关联的数据比较多，此时要么在实现spring cache的接口方法上进行这些操作，但是这就涉及到在一个cache service中操作另外一个cache。&lt;/p&gt;
&lt;p&gt;　　针对上面说的情况，就不推荐使用spring cache，而是应该自己手动实现缓存的处理，这样可以做到条理清晰；但是一般的情况，spring cache已经能够胜任了。&lt;/p&gt;

</description>
<pubDate>Sat, 07 Mar 2020 15:31:00 +0000</pubDate>
<dc:creator>寻觅beyond</dc:creator>
<og:description>在应用程序中，数据一般是存在数据库中（磁盘介质），对于某些被频繁访问的数据，如果每次都访问数据库，不仅涉及到网络io，还受到数据库查询的影响；而目前通常会将频繁使用，并且不经常改变的数据放入缓存中，从</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/-beyond/p/12436704.html</dc:identifier>
</item>
<item>
<title> .NET异步程序设计之async&amp;await - shanzm</title>
<link>http://www.cnblogs.com/shanzhiming/p/12439214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanzhiming/p/12439214.html</guid>
<description>&lt;p&gt;shanzm-2020年3月7日 23:12:53&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;背景引入&quot;&gt;0.背景引入&lt;/h2&gt;
&lt;p&gt;现在的.net异步编程中，一般都是使用 &lt;strong&gt;基于任务异步模式&lt;/strong&gt;(Task-based Asynchronous Pattern，TAP)实现异步编程&lt;/p&gt;
&lt;p&gt;可参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern&quot;&gt;微软文档：使用基于任务的异步模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于任务的异步模式，是使用&lt;code&gt;System.Threading.Tasks&lt;/code&gt; 命名空间中的&lt;code&gt;System.Threading.Tasks.Task&amp;lt;TResult&amp;gt;&lt;/code&gt; 和 &lt;code&gt;System.Threading.Tasks .Task&lt;/code&gt;类型实现异步编程，&lt;/p&gt;
&lt;p&gt;配合着C#5.0(.net 4.5)中添加的两个关于异步编程的关键字&lt;code&gt;async&lt;/code&gt;和 &lt;code&gt;await&lt;/code&gt;,可以快速的实现异步操作。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;async和await基本语法&quot;&gt;1.async和await基本语法&lt;/h2&gt;
&lt;h4 id=&quot;简介&quot;&gt;1.1 简介&lt;/h4&gt;
&lt;p&gt;在C#5.0(.net 4.5)中添加了两个关于异步编程的关键字&lt;code&gt;async&lt;/code&gt;和 &lt;code&gt;await&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;两个关键字可以快速的创建和使用异步方法。&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;关键字只是编译器功能，编译后会用Task类创建代码，实现异步编程。其实只是C#对异步编程的语法糖，本质上是对Task对象的包装操作。&lt;/p&gt;
&lt;p&gt;所以，如果不使用这两个关键字，也可以用C#4.0中Task类的方法来实现同样的功能，只是没有那么方便。(见:&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12315548.html&quot;&gt;.NET异步程序设计之任务并行库&lt;/a&gt;)&lt;/p&gt;
&lt;h4 id=&quot;具体使用方法&quot;&gt;1.2 具体使用方法&lt;/h4&gt;
&lt;ol readability=&quot;4.9052631578947&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;:用于异步方法的函数名前做修饰符，处于返回类型左侧。async只是一个标识符，只是说明该方法中有一个或多个await表达式，async本身并不创建异步操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5.8137931034483&quot;&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt;:用于异步方法内部，用于指明需要异步执行的操作（称之为&lt;strong&gt;await表达式&lt;/strong&gt;），注意一个异步方法中可以有多个await表达式，而且应该至少有一个（若是没有的话编译的时候会警告，但还是可以构建和执行，只不过就相当于同步方法而已）。&lt;/p&gt;
&lt;p&gt;其实这里你有没有想起Task类中为了实现延续任务而使用的等待者，比如:使用&lt;code&gt;task.GetAwaiter()&lt;/code&gt;方法为task类创建一个等待者（可以参考；&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12315548.html#%E4%B8%BAtask%E6%B7%BB%E5%8A%A0%E5%BB%B6%E7%BB%AD%E4%BB%BB%E5%8A%A1&quot;&gt;3.3.2使用Awaiter&lt;/a&gt;）。&lt;code&gt;await&lt;/code&gt;关键字就是基于 .net 4.5中的awaiter对象实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;总而言之，若是有&lt;code&gt;await&lt;/code&gt;表达式则函数一定要用&lt;code&gt;async&lt;/code&gt;修饰，若是使用了&lt;code&gt;async&lt;/code&gt;修饰的方法中没有&lt;code&gt;await&lt;/code&gt;表达式，编译的时候会警告！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;返回值类型&quot;&gt;1.3 返回值类型&lt;/h4&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;定义的异步方法的返回值只有三种：&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Task&lt;/code&gt;、&lt;code&gt;void&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;异步方法中有return语句，则返回值类型为&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;,其中&lt;code&gt;T&lt;/code&gt;是return语句返回对象的类型。（编译器帮我们把&lt;code&gt;T&lt;/code&gt;类型数据转换为&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;类型）。所以不要使用return返回一个&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;类型的对象，而是只需要返回一个&lt;code&gt;T&lt;/code&gt;类型数据即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;异步方法中没有return语句，但是你需要查看异步方法的状态或是要对Task对象操作（比如task.Wait()），则可定义返回值类型为&lt;code&gt;Task&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;异步方法中没有return语句且不需要查看异步方法的状态，则可认为是返回值是&lt;code&gt;void&lt;/code&gt;类型。此时称之为“&lt;strong&gt;调用并忘记&lt;/strong&gt;”（fire and forget），其实这并不是一个很好的用法（具体的分析可以看：异步方法的异常处理）！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;若是真的需要返回一个&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;类型的数据 (比如在非async修饰的方法中，定义返回值类型就是一个&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;类型)，则：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;return Task.Run(()=&amp;gt;{……})&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将&lt;code&gt;T&lt;/code&gt;类型转换为&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;类型:&lt;code&gt;return Task.FromResult(T data)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将&lt;code&gt;IAsyncResult&lt;/code&gt;类型对象转换为Task类型：&lt;code&gt;return Task.Factory.FromTask(IAsyncResult data)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;其他细节&quot;&gt;1.4 其他细节&lt;/h4&gt;
&lt;ol readability=&quot;0.44746376811594&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;修饰符&lt;strong&gt;只能&lt;/strong&gt;用于返回&lt;code&gt;Task&lt;/code&gt;、&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;和&lt;code&gt;viod&lt;/code&gt;的方法,或者Lambda表达式中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.84324324324324&quot;&gt;
&lt;p&gt;&lt;del&gt;&lt;code&gt;async&lt;/code&gt;不能用于程序的入口点，即Main()不能使用&lt;code&gt;async&lt;/code&gt;修饰符。&lt;/del&gt; 谢谢@coredx提醒:C#7.1中应用程序的入口点可以具有async修饰符,&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-1&quot;&gt;参考：What's new in C# 7.1&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;async传染性&quot;&gt;1.5 async传染性&lt;/h4&gt;
&lt;ol readability=&quot;8.1651031894934&quot;&gt;&lt;li readability=&quot;14.115168539326&quot;&gt;
&lt;p&gt;简单的说：函数体中含有&lt;code&gt;await&lt;/code&gt;表达式的函数，必须使用&lt;code&gt;async&lt;/code&gt;修饰！&lt;/p&gt;
&lt;p&gt;而一个使用了&lt;code&gt;async&lt;/code&gt;修饰的方法，在调用它的时候如有必要则必须使用&lt;code&gt;await&lt;/code&gt;等待！&lt;/p&gt;
&lt;p&gt;使用了&lt;code&gt;await&lt;/code&gt;等待的方法，则其调用方法又必须使用&lt;code&gt;async&lt;/code&gt;修饰，这从而形成了一个循环，这就是&lt;strong&gt;async传染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;换句话说就是哪里调用了&lt;code&gt;async&lt;/code&gt;修饰的方法则&lt;code&gt;async&lt;/code&gt;就会传染到哪！&lt;/p&gt;
&lt;p&gt;可以有的时候我们并不想要我们的方法变为&lt;code&gt;async&lt;/code&gt;修饰的方法，所以需要避免&lt;code&gt;async&lt;/code&gt;传染&lt;/p&gt;
&lt;p&gt;避免的主要方法就是使用&lt;strong&gt;延续任务&lt;/strong&gt;来避免，你想一想之前在Task类中，使用延续任务时，主要就是避免使用&lt;code&gt;await&lt;/code&gt;等待！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kechuang.org/t/79529&quot;&gt;参考：C# 5.0中同步执行异步方法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;之前我们说了：&lt;del&gt;主函数Main()不能使用&lt;code&gt;async&lt;/code&gt;修饰符，因为Main函数不能够是异步方法，这也就意味着一切的异步方法最终的调用方法一定是同步方法&lt;/del&gt;（C#7.1Main可以是异步的），而调用异步方法的那个同步方法，称之为&lt;strong&gt;病源隔断方法&lt;/strong&gt;，因为在这里开始，不再会发生async传染。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;简单示例&quot;&gt;1.6 简单示例&lt;/h4&gt;
&lt;p&gt;示例1：定义一个异步方法,并调用它&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{   
    Task&amp;lt;int&amp;gt; t = SumAsync(1, 2);
    t.ContinueWith(t =&amp;gt; Console.WriteLine( &quot;异步操作结果为：&quot; + t.Result));
    for (int i = 0; i &amp;lt; 10; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine($&quot;循环次数{i}&quot;);
    }
    Console.ReadKey();
}

private static async Task&amp;lt;int&amp;gt; SumAsync(int num1, int num2)
{
    int sum = await Task.Run(() =&amp;gt; { Thread.Sleep(3000); return num1 + num2; });
    return sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例说明&lt;/strong&gt; ：&lt;/p&gt;
&lt;ol readability=&quot;10.152317880795&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;异步方法SumAsync()函数体中返回的是整型sum，即返回的是一个整型,但是在声明函数时，返回值需写为：&lt;code&gt;Task&amp;lt;int&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;反过来说：&lt;strong&gt;若是异步方法的返回值类型为&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;,则在方法中只需要返回&lt;code&gt;T&lt;/code&gt;类型的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这一点就是和Task.Run()的返回值的书写方式一样，即若&lt;code&gt;Task.Run()&lt;/code&gt;参数是有返回值的委托&lt;code&gt;Func&amp;lt;TResult&amp;gt;&lt;/code&gt;,则&lt;code&gt;Task.Run()&lt;/code&gt;返回值是&lt;code&gt;Task&amp;lt;TResult&amp;gt;&lt;/code&gt;泛型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;异步方法的命名默认是在最后加&quot;Async&quot;,即&quot;XXXAsync&quot;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;调用异步方法的方法称之为&lt;strong&gt;调用方法&lt;/strong&gt;（在这里就是主函数Main()）,&lt;strong&gt;调用方法和被调用的异步方法，不一定在不同的线程中&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.84674329501916&quot;&gt;
&lt;p&gt;其实你看上面示例的代码也会发现，单独把异步操作封装为一个异步方法，这样可以为异步操作传参！&lt;br/&gt;你可以还记得的在&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12315548.html#task%E7%B1%BB%E7%AE%80%E4%BB%8B&quot;&gt;.net异步程序设计之任务并行库&lt;/a&gt;中，多次说明Task.Run()的参数只能是无参委托。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;有一点在这里说明一下：关于异步匿名方法，或是异步Lambda表达式。&lt;br/&gt;在为一个事件绑定事件处理程序的时候，对于一些简单的事件处理程序，我们可以使用Lambda表达式&lt;br/&gt;但是我们想要异步操作Lambda表达式，则可以直接写为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    Butten.Click+=async(sender,e)=&amp;gt;{...await...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细可以参照《C#图解教程:20.5使用异步Lambda表达式》&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;异步方法的执行顺序&quot;&gt;2.异步方法的执行顺序&lt;/h2&gt;
&lt;p&gt;依旧是上面的示例，我们在每个操作中、操作前、操作后都打印其当前所处的线程，仔细的观察，异步方法的执行顺序。&lt;/p&gt;
&lt;p&gt;再次强调，这里用async修饰的方法，称之为&lt;strong&gt;异步方法&lt;/strong&gt;，这里调用该异步方法的方法，称之为&lt;strong&gt;调用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;//调用方法
static void Main(string[] args)
{
    Console.WriteLine($&quot;-1-.正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}------------------调用方法中调用异步方法之前的代码&quot;);
    Task&amp;lt;int&amp;gt; result = SumAsync(1, 2);
    Console.WriteLine($&quot;-3-.正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}------------------调用方法中调用异步方法之后的代码&quot;);
    result.ContinueWith(t =&amp;gt; Console.WriteLine($&quot;-8-.正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}------------------这是延续任务的线程&quot; + &quot;-异步操作结果为：&quot; + result.Result));
    Console.WriteLine($&quot;-4-.正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}------------------调用方法中延续任务之后的代码&quot;);
    for (int i = 0; i &amp;lt; 5; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine($&quot;正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}&quot;+$&quot;循环次数{i}--------------------------------------调用方法中延续任务之后的代码&quot;);
    }
    Console.ReadKey();
}

//异步方法
private static async Task&amp;lt;int&amp;gt; SumAsync(int num1, int num2)
{
    Console.WriteLine($&quot;-2-.正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}------------------异步方法中await表达式之前的代码&quot;);
    int sum1 = await Task.Run(() =&amp;gt; { Thread.Sleep(3000); Console.WriteLine($&quot;-5-.正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}------------------这是第一个await表达式的线程&quot;); return num1 + num2; });
    Console.WriteLine($&quot;-6-.正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}------------------异步方法中await表达式之后的代码&quot;);
    int sum2=await Task.Run(() =&amp;gt; { Thread.Sleep(3000); Console.WriteLine($&quot;-7-.正在执行的线程，线程ID：{Thread.CurrentThread.ManagedThreadId,2}------------------这是第二个await表达式的线程&quot;); return num1 + num2; });
    return sum1+sum2;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202003/1576687-20200307231445752-1740785731.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;注意运行顺序：&lt;/p&gt;
&lt;p&gt;调用异步方法方法后，按照同步顺序执行异步方法中await表达式之前的代码，&lt;/p&gt;
&lt;p&gt;当运行到第1个await表达式后，创建一个新的线程，后台执行该await表达式，实现异步。&lt;/p&gt;
&lt;p&gt;第1个await表达式，未完成之前，继续执行&lt;strong&gt;调用函数中&lt;/strong&gt;的异步方法之后的代码（&lt;strong&gt;注意await表达式后台未完成之前，不是继续执行await表达式之后的代码，而是继续执行调用函数中的异步方法之后的代码&lt;/strong&gt;），&lt;/p&gt;
&lt;p&gt;当第1个await表达式在后台完成后，继续执行&lt;strong&gt;异步方法中&lt;/strong&gt;第1个await表达式之后的代码，&lt;/p&gt;
&lt;p&gt;当运行到第2个await表达式后，创建一个新的线程，后台运行该await表达式，&lt;/p&gt;
&lt;p&gt;第2个await表达式，未完成之前，继续执行&lt;strong&gt;调用函数中&lt;/strong&gt;被第1个await完成后打断的的代码&lt;/p&gt;
&lt;p&gt;当第2个await表达式在后台运行完成后，继续执行&lt;strong&gt;异步方法中&lt;/strong&gt;第2个await表达式之后的代码，&lt;/p&gt;
&lt;p&gt;当异步方法运行到return后，则开始&lt;strong&gt;调用方法中&lt;/strong&gt;的对该异步方法的延续任务&lt;/p&gt;
&lt;p&gt;该延续任务和调用方法不在一个线程中，这里有可能和第2个await表达式在同一个线程中，也有可能和第1个await表达式在同一个线程中。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;取消一个异步操作&quot;&gt;3.取消一个异步操作&lt;/h2&gt;
&lt;p&gt;具体可参考：&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12315548.html#%E5%8F%96%E6%B6%88%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C&quot;&gt;.net异步编程值任务并行库-3.6取消异步操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原理是一样的，都是使用&lt;code&gt;CancellationToken&lt;/code&gt;和&lt;code&gt;CancellationTokenSource&lt;/code&gt;两个类实现取消异步操作&lt;/p&gt;
&lt;p&gt;看一个简单的示例：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        static void Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();//生成一个CancellationTokenSource对象，
            CancellationToken ct = cts.Token;//该对象可以创建CancellationToken对象，即一个令牌（token)
            Task result = DoAsync(ct, 50);
            for (int i = 0; i &amp;lt;= 5; i++)//主线程中的循环（模拟在异步方法声明之后的工作）
            {
                Thread.Sleep(1000);
                Console.WriteLine(&quot;主线程中的循环次数：&quot; + i);
            }
            cts.Cancel();//注意在主线程中的循环结束后（5s左右），运行到此处，
                         //则此时CancellationTokenSource对象中的token.IsCancellationRequested==true
                         //则在异步操作DoAsync()中根据此判断，则取消异步操作
            Console.ReadKey();
            CancellTask();

            CancellTask2();
        }

        //异步方法：取消异步操作的令牌通过参数传入
        static async Task DoAsync(CancellationToken ct, int Max)
        {
            await Task.Run(() =&amp;gt;
            {
                for (int i = 0; i &amp;lt;= Max; i++)
                {
                    if (ct.IsCancellationRequested)//一旦CancellationToken对象的源CancellationTokenSource运行了Cancel();此时CancellationToken.IsCancellationRequested==ture
                    {
                        return;
                    }
                    Thread.Sleep(1000);
                    Console.WriteLine(&quot;次线程中的循环次数：&quot; + i);
                }
            }/*,ct*/);//这里取消令牌可以作为Task.Run()的第二个参数，也可以不写！
        }&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h2 id=&quot;同步和异步等待任务&quot;&gt;4.同步和异步等待任务&lt;/h2&gt;
&lt;h4 id=&quot;在调用方法中同步等待任务&quot;&gt;4.1 在调用方法中同步等待任务&lt;/h4&gt;
&lt;p&gt;“调用方法可以调用任意多个异步方法并接收它们返回的Task对象。然后你的代码会继续执行其他任务，但在某个点上可能会需要等待某个特殊Task对象完成，然后再继续。为此，Task类提供了一个实例方法wait，可以在Task对象上调用该方法。”--《C#图解教程》&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12315548.html#%E5%88%9B%E5%BB%BA%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84task%E4%BB%BB%E5%8A%A1&quot;&gt;使用&lt;code&gt;task.Wait();&lt;/code&gt;等待异步任务task完成&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Wait&lt;/code&gt;方法用于单一Task的对象。若是想要等待多个Task，可以使用Task类中的两个静态方法,其中&lt;code&gt;WaitAll&lt;/code&gt;等待所有任务都结束，&lt;code&gt;WaitAny&lt;/code&gt;等待任一任务结束。&lt;/p&gt;
&lt;p&gt;示例：使用Task.WaitAll()和Task.WaitAny()&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2 }:Task之前...&quot;);
    Task&amp;lt;int&amp;gt; t1 = DoAsync(2000);
    Task&amp;lt;int&amp;gt; t2 = DoAsync(6000);

    //Task.WaitAll(t1, t2);//等待t1和t2都完毕后才进行后续的代码（即阻塞了主线程）
    //Task.WaitAny(t1, t2);//等待t1和t2中有任一个完成（调试的时候，你就会发现当t1完成后就开始执行后续的循代码）

    for (int i = 0; i &amp;lt; 10; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2}:循环中&quot;);
    }
    Console.ReadKey();
}

private static async Task&amp;lt;int&amp;gt; DoAsync(int num)
{
    int result = await Task.Run(() =&amp;gt; { Thread.Sleep(num); Console.WriteLine($&quot;当前线程ID{Thread.CurrentThread.ManagedThreadId,2}:异步操作之等待：{num}s&quot;); return num; });
     return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明1&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;对代码中注释掉的代码分别调试，则可以发现其中的不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Task.WaitAll(params Task[] tasks)&lt;/code&gt;:表示停止当前主线程，等待Task类型数组tasks中的所有Task操作结束，即会发生阻塞&lt;/p&gt;
&lt;p&gt;Task.WaitAll()调试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202003/1576687-20200307232000440-1447660197.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明2&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Task.WaitAny(params Task[] tasks)&lt;/code&gt;:表示停止当前主线程，等待Task类型数组tasks中的任一个Task操作结束，也是会发生阻塞，单是阻塞主线程在任一个Task操作结束，之后主线程会继续，其他的Task在后台继续&lt;/p&gt;
&lt;p&gt;Task.WaitAny()调试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202003/1576687-20200307232059311-1926134820.gif&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;在调用方法中异步等待任务&quot;&gt;4.2 在调用方法中异步等待任务&lt;/h4&gt;
&lt;h4 id=&quot;使用await等待异步任务&quot;&gt;4.2.1使用await等待异步任务&lt;/h4&gt;
&lt;p&gt;其实在一个方法中调用多个异步方法时候，当某个异步方法依赖于另外一个异步方法的结果的时候，我们一般是在每一个调用的异步方法处使用&lt;code&gt;await&lt;/code&gt;关键字等待该异步操作的结果，但是这样就会出现&lt;code&gt;async&lt;/code&gt;传染。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt;不同于&lt;code&gt;Wait()&lt;/code&gt;,&lt;code&gt;await&lt;/code&gt;等待是异步的，不会阻塞线程，而&lt;code&gt;Wait()&lt;/code&gt;会阻塞线程&lt;/p&gt;
&lt;p&gt;注意如无必用，或是不存在对某个异步操作的等待，尽量不要使用&lt;code&gt;await&lt;/code&gt;,直接把异步操作的返回值给&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;类型的变量，可以使程序运行的更快！&lt;/p&gt;
&lt;p&gt;其实你也注意到了：不使用&lt;code&gt;await&lt;/code&gt;等待异步操作，则异步操作的返回值就是定义的返回值&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;，但是使用&lt;code&gt;await&lt;/code&gt;等待则异步操作的返回值就是具体的简单类型，比如int类型等。&lt;br/&gt;换言之：&lt;strong&gt;异步方法的返回值是&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;,则使用&lt;code&gt;await&lt;/code&gt;等待可以直接获取异步方法的&lt;code&gt;T&lt;/code&gt;类型的返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
  ReferencingMethodAsync();
}

//该调用函数也要使用async关键字修饰（即async传染），因为使用了await等待，
private static async void ReferencingMethodAsync()
{
    int result1 = await SumAsync(1, 2);//这里使用了await 关键字则，调用方法MultipleMethod2()必须使用async修饰（即async传染性）
    int result2 = await SumAsync(1, result1);
    Console.WriteLine(result2);
}

private static async Task&amp;lt;int&amp;gt; SumAsync(int num1, int num2)
{
    int sum = await Task.Run(() =&amp;gt; { Thread.Sleep(3000); return num1 + num2; });
    return sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用whenall和whenany&quot;&gt;4.2.2使用WhenAll()和WhenAny()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Task.WhenAll()&lt;/code&gt;和&lt;code&gt;Task.WhenAny()&lt;/code&gt;是&lt;code&gt;Task.WaitAll()&lt;/code&gt;和&lt;code&gt;Task.WaitAny()&lt;/code&gt;的异步版本，即异步等待Task完成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例:使用Task.WhenAll()和Task.WhenAny()&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2 }:Task之前...&quot;);
    Task&amp;lt;int&amp;gt; t1 = DoAsync(2000);
    Task&amp;lt;int&amp;gt; t2 = DoAsync(6000);
    //Task.WhenAll(t1, t2);//异步等待t1和t2两个完成（调试的时候你会发现任务t1和t2都在新的线程中执行，主线继续执行后续的循环代码）
    //Task.WhenAny(t1, t2);//异步等待t1和t2中任一个完成（调试的时候你就会发现两个任务分别在新线程中执行，线程继续执行后续的循环代码，当t1完成后，继续后续的循环代码）
       
    for (int i = 0; i &amp;lt; 10; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2}:循环中&quot;);
    }
    Console.ReadKey();
}

private static async Task&amp;lt;int&amp;gt; DoAsync(int num)
{
    int result = await Task.Run(() =&amp;gt; { Thread.Sleep(num); Console.WriteLine($&quot;当前线程ID{Thread.CurrentThread.ManagedThreadId,2}:异步操作之等待：{num}s&quot;); return num; });
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明1&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在示例中看到Task.WhenAll和Task.WhenAny的使用，但是在实际中有什么作用呢？&lt;/p&gt;
&lt;p&gt;首先，如前所所述，Task.WhenAll()和Task.WhenAny()是Task.WaitAll()和Task.WaitAny()的异步版本，但是呢，Task.WaitAll()和Task.WaitAny()是没有返回值的，&lt;code&gt;Task.WhenAll()&lt;/code&gt;和&lt;code&gt;Task.WhenAny()&lt;/code&gt;是有返回值，返回值类型是一个Task对象，所以你可以给其一个延续任务，即在异步等待的Task完成后，指定继续执行的Task。&lt;/p&gt;
&lt;p&gt;所以当调用的异步方法没有相互的依赖的时候，一般还是使用WhenAll(),来等待异步方法，同时也可以给所有的异步方法结束后添加一个延续任务！&lt;/p&gt;
&lt;p&gt;示例：为异步等待后添加延续工作&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;
static void Main(string[] args)
{
    Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2 }:Task之前...&quot;);
    Task&amp;lt;int&amp;gt; t1 = DoAsync(2000);
    Task&amp;lt;int&amp;gt; t2 = DoAsync(6000);

    //Task.WhenAll(t1, t2).ContinueWith(t =&amp;gt; Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2 }:延续任务，两个异步操作返回值是一个int[],其中元素分别是{t.Result[0]}、{t.Result[1]}&quot;));

    //Task.WhenAny(t1, t2).ContinueWith(t =&amp;gt; Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2 }:延续任务，第一个完成的异步操作返回值是{t.Result.Result}&quot;));


    for (int i = 0; i &amp;lt; 8; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2}:循环中&quot;);
    }
    Console.ReadKey();
}

private static async Task&amp;lt;int&amp;gt; DoAsync(int num)
{
    int result = await Task.Run(() =&amp;gt; { Thread.Sleep(num); Console.WriteLine($&quot;当前线程ID：{Thread.CurrentThread.ManagedThreadId,2}:异步操作之等待：{num}s&quot;); return num; });
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明1&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;若是&lt;code&gt;Task.WhenAll()&lt;/code&gt;后的延续工作，则注意&lt;code&gt;Task.WhenAll()&lt;/code&gt;的返回的&lt;code&gt;Task&amp;lt;TResult&amp;gt;&lt;/code&gt;的&lt;code&gt;Result&lt;/code&gt;是&lt;code&gt;TResult[]&lt;/code&gt;类型&lt;br/&gt;即多个Task的返回值，存放在一个数组中&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202003/1576687-20200307231639171-80345781.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明2&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;若是&lt;code&gt;Task.WhenAny()&lt;/code&gt;后的延续工作，则注意&lt;code&gt;Task.WhenAny()&lt;/code&gt;的返回的是&lt;code&gt;Task&amp;lt;Task&amp;gt;&lt;/code&gt;类型，即其&lt;code&gt;Result&lt;/code&gt;是&lt;code&gt;Task&amp;lt;TResutl&amp;gt;&lt;/code&gt;类型，所以为了获取第一结束的Task的返回值，需要：&lt;code&gt;t.Result.Result&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202003/1576687-20200307231711372-1347117219.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明3&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Task.WhenAll(Task[] tasks).ContinueWith(Action&amp;lt;Task&amp;gt;)&lt;/code&gt;&lt;br/&gt;等价于&lt;code&gt;Task.Factory.ContinueWhenAll(Task[] tasks, Action&amp;lt;Tast&amp;gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Task.WhenAny(Task[] tasks).ContinueWith(Action&amp;lt;Task&amp;gt;)&lt;/code&gt;&lt;br/&gt;等价于&lt;code&gt;Task.Factory.ContinueWhenAny(Task[] tasks, Action&amp;lt;Tast&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;异步操作中的异常处理&quot;&gt;5.异步操作中的异常处理&lt;/h2&gt;
&lt;h4 id=&quot;异常处理&quot;&gt;5.1 异常处理&lt;/h4&gt;
&lt;p&gt;一般程序中对异常的处理使用&lt;code&gt;try{……} catch{……}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先看一个捕获异常失败的示例：&lt;/p&gt;
&lt;p&gt;在Main()中调用&lt;code&gt;ThrowEx(2000,&quot;这是异常信息&quot;)&lt;/code&gt;,第一个参数是ThrowEx中的Tast延迟的时间，第二个参数是ThrowEx中的抛出异常的信息。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    try
    {
        ThrowEx(2000, &quot;这是异常信息&quot;);
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
    Console.ReadKey();
}
private async static Task ThrowEx(int ms, string message)//注意这里的返回值类型为Task，若是写成void也是无法在catch语句中捕获异常，但是运行vs会报错(见：说明2)
{
    await Task.Delay(ms).ContinueWith(t =&amp;gt; Console.WriteLine(&quot;hello word&quot;));
    throw new Exception(message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多打断点,就可以发现为何捕捉不到异常了。&lt;/p&gt;
&lt;p&gt;因为当调用&lt;code&gt;ThrowEx(2000, &quot;异常信息&quot;)&lt;/code&gt;，开始异步方法中的await表达式，&lt;/p&gt;
&lt;p&gt;即创建一个新的线程，在后台执行await表达式，而主线程中此时会继续执行&lt;code&gt;ThrowEx(2000, &quot;异常信息&quot;);&lt;/code&gt;后的代码:&lt;code&gt;catch (Exception ex)&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;此时，异步方法中还在等待await表达式的执行，还没有抛出我们自己定义的异常,所以此时压根就没有异常抛出，所以catch语句也就捕获不到异常，&lt;/p&gt;
&lt;p&gt;而当异步方法抛出异常，此时主线程中catch语句已经执行完毕了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;1.基本语法-返回值类型&lt;/strong&gt;中我们说道：在编写异步方法的时候，有时后没有返回值，也不需要查看异步操作的状态，我们设置返回值类型为&lt;code&gt;void&lt;/code&gt;，而且称之为“调用并忘记”。然而这种异步代码编写方式,并不值得提倡。&lt;/p&gt;
&lt;p&gt;为什么呢？若是没有返回值，异步方法中抛出的异常就无法传递到主线程，在主线程中的&lt;code&gt;catch&lt;/code&gt;语句就无法捕获拍异常！所以&lt;strong&gt;异步方法最好返回一个Task类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;异步方法有返回值的时候，抛出的在异常会置于Task对象中，可以通过task.IsFlauted属性查看是否有异常，在主线程的调用方法中，使用&lt;code&gt;catch&lt;/code&gt;语句可以捕获异常！&lt;/p&gt;

&lt;p&gt;正确示例：只需要给调用的异步方法，添加一个&lt;code&gt;await&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    try
    {
       await ThrowEx(2000, &quot;这是异常信息&quot;);
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
    Console.ReadKey();
}
private async static Task ThrowEx(int ms, string message)
{
    await Task.Delay(ms).ContinueWith(t =&amp;gt; Console.WriteLine(&quot;hello word&quot;));
    throw new Exception(message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多个异步方法的异常处理&quot;&gt;5.2 多个异步方法的异常处理&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;Task.WhenAll()&lt;/code&gt;处理多个异步方法中抛出异常&lt;/p&gt;
&lt;p&gt;当有多个异步操作，使用WhenAll异步等待，其返回值是一个Task类型对象，该对象的异常为&lt;code&gt;AggregateException&lt;/code&gt;类型的异常，每一个的子任务（即WhenAll所等待的所有任务）抛出的异常都是包装在这一个AggregateException中，若是需要打印其中的异常，则需要遍历&lt;code&gt;AggregateException.InnerExceptions&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    Task taskResult = null;//注意因为在catch语句中需要使用这个WhenAll的返回值，所以定义在try语句之外。
    try
    {
        Console.WriteLine($&quot;当前的线程Id：{Thread.CurrentThread.ManagedThreadId,2}:do something before task&quot;);
        Task t1 = ThrowEx($&quot;这是第一个抛出的异常信息:异常所在线程ID：{Thread.CurrentThread.ManagedThreadId,2}&quot;, 3000);
        Task t2 = ThrowEx($&quot;这是第二个抛出的异常信息:异常所在线程ID：{Thread.CurrentThread.ManagedThreadId,2}&quot;, 5000);

        await (taskResult = Task.WhenAll(t1, t2));
    }
    catch (Exception)//注意这里捕获的异常只是WhenAll()等待的异步任务中第一抛出的异常
    {
        foreach (var item in taskResult.Exception.InnerExceptions)//通过WhenAll()的返回对象的Exception属性来查阅所有的异常信息
        {
            Console.WriteLine($&quot;当前的线程Id：{Thread.CurrentThread.ManagedThreadId,2}:{item.Message}&quot;);
        }
    }
}

private async static Task ThrowEx(int ms, string message)
{
    await Task.Delay(ms).ContinueWith(t =&amp;gt; Console.WriteLine(&quot;hello word&quot;));
    throw new Exception(message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202003/1576687-20200307231800069-161393712.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Task.WhenAll()&lt;/code&gt;返回的Task对象中的Exception属性是&lt;code&gt;AggregateException&lt;/code&gt;类型的异常.&lt;/p&gt;
&lt;p&gt;注意，该访问该异常&lt;code&gt;InnerExcption&lt;/code&gt;属性则只包含第一个异常，该异常的&lt;code&gt;InnerExcptions&lt;/code&gt;属性，则包含所有子任务异常.&lt;/p&gt;
&lt;h4 id=&quot;aggregateexception中的方法&quot;&gt;5.3 AggregateException中的方法&lt;/h4&gt;
&lt;p&gt;首先多个异步操作的异常会包装在一个AggregateException异常中，被包装的异常可以也是AggregateException类型的异常，所以若是需要打印异常信息可能需要循环嵌套，比较麻烦。&lt;/p&gt;
&lt;p&gt;故可以使用 &lt;code&gt;AggregateException.Flatten()&lt;/code&gt;打破异常的嵌套。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，凡是使用&lt;code&gt;await&lt;/code&gt;等待的异步操作，它抛出的异常无法使用&lt;code&gt;catch(AggregateException)&lt;/code&gt;捕获！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只能使用&lt;code&gt;catch (Exception)&lt;/code&gt;对异常捕获，在通过使用Task的返回值的Exception属性对异性进行操作。&lt;/p&gt;
&lt;p&gt;当然你要是想使用&lt;code&gt;catch(AggregateException)&lt;/code&gt;捕获到异常，则可以使用task.Wait()方法等待异步任务，则抛出的异常为AggregateException类型的异常&lt;/p&gt;
&lt;p&gt;示例：（&lt;a href=&quot;https://github.com/shanzm/AsynchronousProgramming/blob/master/009AggregateException%E4%B8%AD%E6%96%B9%E6%B3%95/Program.cs&quot;&gt;完整Demo&lt;/a&gt;）&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;catch (AggregateException ae)//AggregateException类型异常的错误信息是“发生一个或多个异常”
{
    foreach (var exception in ae.Flatten().InnerExceptions)
    //使用AggregateException的Flatten()方法，除去异常的嵌套,这里你也可以测试不使用Flatten(),抛出的信息为“有一个或多个异常”
    {
        if (exception is TestException)
        {
             Console.WriteLine(exception.Message);
        }
        else
        {
            throw;
        }
    }               
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若是需要针对&lt;code&gt;AggregateException&lt;/code&gt;中某个或是某种异常进行处理，可以使用&lt;code&gt;Handle()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Handel()&lt;/code&gt;的参数是一个有返回值的委托：&lt;code&gt;Func&amp;lt;Exception,bool&amp;gt; predicate&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：（&lt;a href=&quot;https://github.com/shanzm/AsynchronousProgramming/blob/8c36d6a90954c5a14d93d29b7f68b4c6d47af6f5/009AggregateException%E4%B8%AD%E6%96%B9%E6%B3%95/Program.cs#L95&quot;&gt;完整Demo&lt;/a&gt;）&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;catch (Exception)
{
    t.Exception.Handle(e =&amp;gt;
    {
        if (e is TestException)//如果是TestException类型的异常
        {
            Console.WriteLine(e.Message);
        }
        return e is TestException;
    });
}&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h2 id=&quot;多线程和异步的区分&quot;&gt;6.多线程和异步的区分&lt;/h2&gt;
&lt;p&gt;不要把&lt;strong&gt;多线程&lt;/strong&gt;和&lt;strong&gt;异步&lt;/strong&gt;两个概念混为一谈！&lt;strong&gt;异步是最终目的,多线程只是我们实现异步的一种手段！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，使用异步和多线程都可以避免线程的阻塞，但是原理是不一样的。&lt;/p&gt;
&lt;p&gt;多线程：当前线程中创建一个新的线程，当前线程线程则不会被锁定了，但是锁定新的线程执行某个操作。换句话说就是换一条线程用来代替原本会被锁定的主线程！优点就是，线程中的处理程序的运行顺序还是从上往下的，方便理解，但是线程间的共享变量可能造成死锁的出现。&lt;/p&gt;
&lt;p&gt;异步：异步概念是与同步的概念相对的，&lt;strong&gt;简单的说就是：调用者发送一个调用请求后，调用者不需要等待被被调用者返回结果而可以继续做其他的事情&lt;/strong&gt;。实现异步一般是通过多线程，但是还可以通过多进程实现异步！&lt;/p&gt;
&lt;p&gt;多线程和异步可以解决不同的问题&lt;/p&gt;
&lt;p&gt;但是首先我们要区分当前需要长时间操作的任务是:CPU密集型还是IO密集型，具体可参考&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12292710.html#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B&quot;&gt;长时间的复杂任务又分为两种&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CPU Bound：使用多线程&lt;/p&gt;
&lt;p&gt;IO Bound：使用异步&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;在-.net-mvc中异步编程&quot;&gt;7. 在 .NET MVC中异步编程&lt;/h2&gt;
&lt;p&gt;现在的 ASP .NET MVC项目中，若使用的.net中的方法有异步版本的就尽量使用异步的方法。&lt;/p&gt;
&lt;p&gt;在MVC项目中异步编程可以大大的提高网站服务器的吞吐量，即可以可以大大的提高网站的同时受理的请求数量&lt;/p&gt;
&lt;p&gt;据传，MVC网站若是异步编程则可以提高网站的同时访问量的2.6倍。&lt;/p&gt;
&lt;p&gt;注意是提高网站的同时访问量，而不是提高网站的访问速度！&lt;/p&gt;
&lt;p&gt;在MVC项目异步编程的的方式和在控制台中一样，使用async和await，基于任务的异步编程模式&lt;/p&gt;
&lt;p&gt;简单的示例：同步和异步两种方式分别读取桌面1.txt文件&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;//同步操作
public ActionResult Index()
{
    string msg = &quot;&quot;;
    using (StreamReader sr = new StreamReader(@&quot;C:\Users\shanzm\Desktop\1.txt&quot;, Encoding.Default))
    {
        while (!sr.EndOfStream)
        {
            msg = sr.ReadToEnd();
        }
    }
    return Content(msg);
}


//异步操作
public async Task&amp;lt;ActionResult&amp;gt; Index2()
{
    string msg = &quot;&quot;;
    using (StreamReader sr = new StreamReader(@&quot;C:\Users\shanzm\Desktop\1.txt&quot;, Encoding.Default))
    {
        while (!sr.EndOfStream)
        {
            msg = await sr.ReadToEndAsync();//使用异步版本的方法
        }
    }
    return Content(msg);
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h2 id=&quot;参考及示例源码&quot;&gt;8. 参考及示例源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shanzm/AsynchronousProgramming&quot;&gt;源码：点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12439214.html&quot;&gt;书籍：C#高级编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12439214.html&quot;&gt;书籍：精通C#&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/task-based-asynchronous-programming&quot;&gt;微软：基于任务的异步编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/exception-handling-task-parallel-library#using-the-handle-method-to-filter-inner-exceptions&quot;&gt;微软：异常处理（任务并行库）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Mar 2020 15:23:00 +0000</pubDate>
<dc:creator>shanzm</dc:creator>
<og:description>[TOC] shanzm 2020年3月7日 23:12:53 0.背景引入 现在的.net异步编程中，一般都是使用 基于任务异步模式 (Task based Asynchronous Pattern</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanzhiming/p/12439214.html</dc:identifier>
</item>
<item>
<title>mongoose-面向对象操作mongodb的Nodejs框架 - efonfighting</title>
<link>http://www.cnblogs.com/efonfighting/p/12439210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/efonfighting/p/12439210.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/efonfighting/1663883/o_200307150757image-20200307223313117.png&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;70.654922279793&quot;&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;无论是mysql还是mongodb，传统的与数据库交互的方式都是按照他们提供的API来写代码。它们提供的API往往不是很容易理解，而且难以记忆，如果传错了参数，写错一个符号都要查文档。&lt;/p&gt;
&lt;p&gt;ORM（对象关系映射，Object Relational Mapping）框架，允许我们面向对象操作，不需要记忆任何的数据库API，只需要操作对象即可，由框架底层去调用数据库API，这样就大大提高了程序员的开发效率。&lt;/p&gt;
&lt;p&gt;不过既然多了一层封装，肯定要损失一点点的性能，可以忽略不计。&lt;/p&gt;
&lt;p&gt;在NodeJS中，操作mongodb最好的ORM框架就是&lt;strong&gt;mongoose&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;hmongoose&quot;&gt;&lt;span&gt;安装mongoose&lt;/span&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;bash language-bash hljs&quot;&gt;npm install mongoose --save&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你本机没有安装nodejs驱动，会自动安装nodejs驱动，因为mongoose依赖nodejs驱动。&lt;/p&gt;
&lt;p&gt;文档参考：&lt;a href=&quot;http://mongoosejs.com/docs/index.html&quot;&gt;mongoose官方文档&lt;/a&gt;：&lt;code&gt;http://mongoosejs.com/docs/index.html&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;连接数据库&lt;/span&gt;&lt;/h2&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;javascript language-javascript hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;'use strict'&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; User = &lt;span class=&quot;hljs-built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'./model/user'&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; mongoose = &lt;span class=&quot;hljs-built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'mongoose'&lt;/span&gt;);&lt;br/&gt;mongoose.connect(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mongodb://127.0.0.1/test&quot;&lt;/span&gt;);&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; db = mongoose.connection;&lt;br/&gt;db.on(&lt;span class=&quot;hljs-string&quot;&gt;'error'&lt;/span&gt;, err =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(err);&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;db.once(&lt;span class=&quot;hljs-string&quot;&gt;'open'&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;'mongodb connect successfully!'&lt;/span&gt;);&lt;br/&gt;highOrderQuery()&lt;br/&gt;});&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;模型定义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mongoose&lt;/code&gt;使用&lt;code&gt;schema&lt;/code&gt;来描述数据的格式、字段、规则，有了&lt;code&gt;schema&lt;/code&gt;之后可以生成&lt;code&gt;model&lt;/code&gt;来操作数据。&lt;/p&gt;
&lt;p&gt;一般我们新建一个model目录来存放这些模型文件，比如这里我们新建一个&lt;code&gt;model/user.js&lt;/code&gt;&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;js language-js hljs javascript&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;'use strict'&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; mongoose = &lt;span class=&quot;hljs-built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'mongoose'&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; schema = mongoose.Schema({&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;Number&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;address&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;fav&lt;/span&gt;: [&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;]&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;versionKey&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;);&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module&lt;/span&gt;.exports = mongoose.model(&lt;span class=&quot;hljs-string&quot;&gt;&quot;users&quot;&lt;/span&gt;, schema);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-3&quot;&gt;&lt;span&gt;增删改查&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;直接查看文档中Model相关API。&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;js language-js hljs javascript&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testCRUD&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; arr = [&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;李连杰&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;address&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;北京&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;fav&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;功夫&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;演电影&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;旅游&quot;&lt;/span&gt;]&lt;br/&gt;},&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;吴京&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;address&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;北京&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;fav&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;功夫&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;演电视剧&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;运动&quot;&lt;/span&gt;]&lt;br/&gt;},&lt;br/&gt;];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; User.create(arr);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(res);&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; User.findOne({&lt;span class=&quot;hljs-attr&quot;&gt;address&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;北京&quot;&lt;/span&gt;}); &lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(res);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; User.find({&lt;span class=&quot;hljs-attr&quot;&gt;address&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;北京&quot;&lt;/span&gt;}); &lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(res);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; User.updateOne({&lt;span class=&quot;hljs-attr&quot;&gt;_id&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;5b4065e548651d0b7035843d&quot;&lt;/span&gt;}, {&lt;span class=&quot;hljs-attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;address&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;深圳&quot;&lt;/span&gt;});&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(res);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; User.deleteOne({&lt;span class=&quot;hljs-attr&quot;&gt;_id&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;5b4065e548651d0b7035843d&quot;&lt;/span&gt;});&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(res);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-4&quot;&gt;&lt;span&gt;高级查询&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;所有条件操作符：&lt;code&gt;https://docs.mongodb.com/manual/reference/operator/query/&lt;/code&gt;。&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;js language-js hljs javascript&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;highOrderQuery&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; User.find({&lt;span class=&quot;hljs-attr&quot;&gt;age&lt;/span&gt;: {&lt;span class=&quot;hljs-attr&quot;&gt;$gt&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;}});&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; User.find({&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;fav&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;玩游戏&quot;&lt;/span&gt;&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; User.find().skip(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;).limit(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;).sort(&lt;span class=&quot;hljs-string&quot;&gt;&quot;-age&quot;&lt;/span&gt;).select(&lt;span class=&quot;hljs-string&quot;&gt;&quot;-fav&quot;&lt;/span&gt;); &lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(res);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-5&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一番雾语：操作mongodb最好的NodeJS框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 07 Mar 2020 15:22:00 +0000</pubDate>
<dc:creator>efonfighting</dc:creator>
<og:description>介绍 无论是mysql还是mongodb，传统的与数据库交互的方式都是按照他们提供的API来写代码。它们提供的API往往不是很容易理解，而且难以记忆，如果传错了参数，写错一个符号都要查文档。 ORM（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/efonfighting/p/12439210.html</dc:identifier>
</item>
<item>
<title> 《即时消息技术剖析与实战》学习笔记11——IM系统如何保证服务高可用 - 鹿呦呦</title>
<link>http://www.cnblogs.com/sunshineliulu/p/12439206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshineliulu/p/12439206.html</guid>
<description>&lt;p&gt;IM 系统的不可用主要有以下两个原因：&lt;br/&gt;一是无法预测突发流量，即使进行了服务拆分、自动扩容，但流量增长过快时，服务已经不可用了；&lt;br/&gt;二是业务中依赖的这些接口、资源不可用或变慢时，比如发消息可能需要依赖“垃圾内容识别”的 API 来进行消息内容的过滤，下推图片消息可能需要依赖图片服务获取缩略图来进行推流，会导致业务整体失败或者被拖慢而造成超时，影响服务的整体可用性。&lt;/p&gt;
&lt;p&gt;如何保证系统的高可用呢？&lt;/p&gt;
&lt;h4 id=&quot;一流量控制&quot;&gt;一、流量控制&lt;/h4&gt;
&lt;p&gt;在即时消息系统中，突发超高流量时，为了避免服务器整体被流量打死，我们可以通过流控来扔掉或者通过排队的方式来保护系统在能力范围内的运转。&lt;/p&gt;
&lt;p&gt;流控算法主要有&lt;strong&gt;漏桶算法&lt;/strong&gt;和&lt;strong&gt;令牌桶算法&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;漏桶算法比较形象，把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。&lt;/td&gt;
&lt;td&gt;令牌桶算法控制的是一个时间窗口内通过的数据量，以恒定的速率产生令牌，然后把令牌放到令牌桶中。来一个请求，就会从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，则拒绝该请求或等待新的令牌放入桶中。若令牌桶满了，则新令牌会被丢弃，不再放入桶中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202003/953680-20200307232132516-640633223.png&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202003/953680-20200307232146856-264470074.png&quot; width=&quot;100%&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;漏桶算法通过控制数据注入到网络的速率，平滑网络上的突发流量。&lt;/td&gt;
&lt;td&gt;令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;二熔断机制&quot;&gt;二、熔断机制&lt;/h4&gt;
&lt;p&gt;当下游服务因访问压力过大而响应变慢或失败，依赖于下游的上游服务也会受到影响，出现整体性能被拖累变慢的情况，最终可能导致系统整体性能的雪崩。这种当下游服务出问题时，为了保护系统整体的可用性而暂时切断对下游服务的调用的行为就是“熔断”。&lt;/p&gt;
&lt;p&gt;自动熔断机制主要通过持续收集被依赖服务或者资源的访问数据和性能指标，当性能出现一定程度的恶化或者失败量达到某个阈值时，会自动触发熔断，让当前依赖快速失败（Fail-fast），并降级到其他备用依赖，或者暂存到其他地方便于后续重试恢复。在熔断过程中，再通过不停探测被依赖服务或者资源是否恢复，来判断是否自动关闭熔断，恢复业务。&lt;/p&gt;
&lt;blockquote readability=&quot;2.6538461538462&quot;&gt;
&lt;p&gt;关于“熔断”，可以看这篇博客文章，写得很形象：&lt;a href=&quot;https://www.cnblogs.com/Zachary-Fan/p/9976197.html&quot;&gt;分布式系统关注点(8)——99%的人都能看懂的「熔断」以及最佳实践&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;三总结&quot;&gt;三、总结&lt;/h4&gt;
&lt;p&gt;限流、熔断机制和缓存，是应对系统高并发、保证系统高可用的有效利器。&lt;/p&gt;
&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;这篇文章于我的意义更多的是拓宽我的知识层面，让我不至于那么孤陋寡闻🤔&lt;/p&gt;
</description>
<pubDate>Sat, 07 Mar 2020 15:21:00 +0000</pubDate>
<dc:creator>鹿呦呦</dc:creator>
<og:description>IM系统如何保证服务高可用：流量控制和熔断机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunshineliulu/p/12439206.html</dc:identifier>
</item>
</channel>
</rss>