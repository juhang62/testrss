<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Error while instantiating 'org.apache.spark.sql.hive.HiveSessionStateBuilder':  —— windows 开发环境使用spark 无法访问hdfs 问题解决 - 努力就是魅力</title>
<link>http://www.cnblogs.com/nulijiushimeili/p/14147751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nulijiushimeili/p/14147751.html</guid>
<description>&lt;p&gt;## 错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1364969/202012/1364969-20201217084126030-1722667915.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; ## 解决方案：&lt;/p&gt;
&lt;p&gt;下载 hadoop 的可执行tar包，解压放在windows 本地，并配置环境变量。 在 解压后的文件夹的bin目录下放入两个文件： winutils.exe, hadoop.dll  &lt;/p&gt;
&lt;p&gt;## windows 上hadoop 工具的获取：https://github.com/steveloughran/winutils/tree/master/hadoop-2.6.4/bin       (或者自行百度一下)&lt;/p&gt;

</description>
<pubDate>Thu, 17 Dec 2020 00:46:00 +0000</pubDate>
<dc:creator>努力就是魅力</dc:creator>
<og:description>## 错误： ## 解决方案： 下载 hadoop 的可执行tar包，解压放在windows 本地，并配置环境变量。 在 解压后的文件夹的bin目录下放入两个文件： winutils.exe, had</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nulijiushimeili/p/14147751.html</dc:identifier>
</item>
<item>
<title>单精度浮点数转化为10进制数的原理 - 青椒肉丝丶</title>
<link>http://www.cnblogs.com/qingjiaorousi/p/14147729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingjiaorousi/p/14147729.html</guid>
<description>&lt;p&gt;在做MODBUS通讯时经常会用到单精度浮点数来表示测量值，比如41 20 00 00代表十进制的10，用代码可以轻松实现转换，但是他是怎么计算出来的呢？查了一些资料后我知道了计算的方法，在此记录一下。&lt;/p&gt;
&lt;p&gt;比如10，他的单精度浮点数时41 20 00 00，先将其从16进制转换为10进制，就是65 32 00 00，再把他们对应的8位二进制数写出来01000001 00100000 00000000 00000000一共32位（32位是单精度，64位是双精度），再将其从右往左数划分为三部分：31位，30到23位，22到0位。&lt;br/&gt;1、其中第31位为1位符号位，0表示正数，1表示负数；&lt;br/&gt;2、30到23位为8位指数位，得到1000 0010，十进制为130；&lt;br/&gt;3、22到0位为尾数位，得到010 0000 0000 0000 0000 0000，这里直接在前面加“0.”，得到0.010 0000 0000 0000 0000 0000，也就是二进制小数的0.01，得到十进制0.25；&lt;br/&gt;4、最后是计算的公式：10进制数=(-1)^符号位 * (1+尾数位) * 2^(指数位-127),把1~3的值代入，(-1 ^ 0) * (1+0.25) * 2 ^（130 - 127) = 1 * 1.25 * 2^3 = 10。&lt;/p&gt;
&lt;p&gt;再推荐一个单精度浮点数在线转换的网址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.styb.cn/cms/ieee_754.php&quot; target=&quot;_blank&quot;&gt;http://www.styb.cn/cms/ieee_754.php&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Dec 2020 00:31:00 +0000</pubDate>
<dc:creator>青椒肉丝丶</dc:creator>
<og:description>在做MODBUS通讯时经常会用到单精度浮点数来表示测量值，比如41 20 00 00代表十进制的10，用代码可以轻松实现转换，但是他是怎么计算出来的呢？查了一些资料后我知道了计算的方法，在此记录一下。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qingjiaorousi/p/14147729.html</dc:identifier>
</item>
<item>
<title>IDEA 2020.3 更新了，机器学习都整上了 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/14147692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/14147692.html</guid>
<description>&lt;p&gt;Hello，大家好,我是楼下小黑哥~&lt;/p&gt;
&lt;p&gt;上周 Java 开发申请神器 IDEA 2020.3 新版正式发布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080557241-424080896.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小黑哥第一时间就在开发机上更新了新版本，并且完整体验了两周了。&lt;/p&gt;
&lt;p&gt;下面介绍一下这个版本的主要功能：&lt;/p&gt;
&lt;h3 id=&quot;1、全新的欢迎窗口，更加人性化&quot;&gt;1、全新的欢迎窗口，更加人性化&lt;/h3&gt;
&lt;p&gt;IDEA 欢迎窗口全新升级，首页增加三个选项卡，一个用于设置 IDE 界面的 &lt;em&gt;Customize&lt;/em&gt;，一个用于插件安装的 &lt;em&gt;Plugins&lt;/em&gt;，一个于访问帮助和学习资源的 &lt;em&gt;Learn IntelliJ IDEA&lt;/em&gt;，另外包括之前用于管理项目的 &lt;em&gt;Projects&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080557901-526855778.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是特别提一下 &lt;strong&gt;Learn IntelliJ IDEA&lt;/strong&gt; ，我们可以从首页打开进入Learn IntelliJ IDEA 页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080558228-1612337260.jpg&quot; alt=&quot;Learn IntelliJ IDEA&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个页面，你可以选择多个交互课程，从中学习 IDEA 基本功能，快捷键等等。&lt;/p&gt;
&lt;p&gt;如果你是一个 IDEA 初学者建议你多使用 &lt;strong&gt;Learn IntelliJ IDEA&lt;/strong&gt; 功能，多加练习 IDEA 快捷键等功能，这可以成倍的提升你的编码效率。&lt;/p&gt;
&lt;p&gt;如果你使用其他版本的 IDEA，暂时不能升级，也没关系的。&lt;/p&gt;
&lt;p&gt;你可以安装一个插件 &lt;strong&gt;IDE Features Trainer&lt;/strong&gt;，安装之后将会有上面练习功能了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080558603-1539095277.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、阅读器模式&quot;&gt;2、阅读器模式&lt;/h3&gt;
&lt;p&gt;现在，我们如果打开二方包类、文件或者说其他只读文件，IDEA 将会默认在阅读器模式下打开。&lt;/p&gt;
&lt;p&gt;这个模式，注释内容将会被格式化，更加容易被阅读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080559345-1058717633.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击右上的 &lt;strong&gt;Reader Mode&lt;/strong&gt;，可以还原成之前的模式，并且按钮将会变成下方的形状。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080559617-1042256464.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、窗口拆分更加方便&quot;&gt;3、窗口拆分更加方便&lt;/h3&gt;
&lt;p&gt;之前 IDEA 中，如果我们想拆分窗口，打开两个编辑窗口，只能在选择菜单栏中拆分选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080559807-704094763.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前拆分完成之后，左右两个窗口打开是同一份文件，我们还需要手动在左边切换文件。&lt;/p&gt;
&lt;p&gt;现在 IDEA 提供了 &lt;strong&gt;Split and Move Right&lt;/strong&gt; 的功能，不用再额外操作切换。&lt;/p&gt;
&lt;p&gt;现在拆分更加方便，直接使用鼠标拖拽就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080601056-2068369417.gif&quot; alt=&quot;拖放选项卡&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外我们还可以把终端窗口移到从最小方移动到上方编辑窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080601933-314960633.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4、优化重构功能&quot;&gt;4、优化重构功能&lt;/h3&gt;
&lt;p&gt;这个版本简化了重构的 &lt;strong&gt;Extract method&lt;/strong&gt; 功能，无需重新打开一个新的窗口声明方法名，方法变量等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080602546-1918488327.gif&quot; alt=&quot;新的 Extract method 布局&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外这个版本重构的 &lt;strong&gt;Rename&lt;/strong&gt; 功能，还可以选择将代码注释中的字符串一块一起 &lt;strong&gt;Rename&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080603393-465688870.gif&quot; alt=&quot;更新的 Rename 重构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;不得不说使用 IDEA 重构代码真的是丝滑般体验~&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;5、debug-功能升级&quot;&gt;5、DEBUG 功能升级&lt;/h3&gt;
&lt;p&gt;这个版本我们 debug 的时候，右边将会显示当前变量，直接点击，将会快速弹出变量的查看窗口。&lt;/p&gt;
&lt;p&gt;这下就不用跳到下方的调试窗口，或者打开变量查看窗口查看变量了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080603761-63516813.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个窗口双击变量的值，我们就可以快速修改变量，丝般顺滑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080604400-2090793765.gif&quot; alt=&quot;调试器交互式提示&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，IDEA 新增一种 &lt;strong&gt;Inline Watch&lt;/strong&gt;，可以在特定上下文环境中，仅仅显示一个变量中某一个值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080605585-1772324304.gif&quot; alt=&quot;调试器内联监视&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们还可以在调试器中进行基本的内存分析：&lt;/p&gt;
&lt;p&gt;第一个功能是 &lt;em&gt;Show referring objects&lt;/em&gt;，用于查找从对象到 GC 根的最短路径。 第二个功能是 &lt;em&gt;Calculate retained size&lt;/em&gt;，用于计算对象的保留大小并显示其保留集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080606195-2037042114.gif&quot; alt=&quot;在调试器中显示引用对象&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6、代码提示更加智能&quot;&gt;6、代码提示更加智能&lt;/h3&gt;
&lt;p&gt;这个版本代码补单引入机器学习技术，基于成千上万的真实用户的代码补全用法，对方法进行智能排序，使我们可以更加快速选择相应的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080606739-249602711.jpg&quot; alt=&quot;机器学习代码补全&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在全球 IDEA 使用者这么多，每天大量样本可以被用作机器学习，猜想 IDEA 后续版本推出更加智能的功能。&lt;/p&gt;
&lt;h3 id=&quot;7、search-everywhere-优化&quot;&gt;7、Search Everywhere 优化&lt;/h3&gt;
&lt;p&gt;这个版本我们可以在 Search Everywhere 窗口中，直接使用 git 提交记录哈希和消息、标记以及分支进行快速的查找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080607058-1539758024.jpg&quot; alt=&quot;随处搜索提交哈希&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外 Search Everywhere 窗口还支持简单的数学计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080607680-178833528.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;8、优化-java-15-新特性体验&quot;&gt;8、优化 Java 15 新特性体验&lt;/h3&gt;
&lt;p&gt;Java 15 引入 &lt;code&gt;Record&lt;/code&gt;新语法，可以创建一个&lt;strong&gt;纯数据载体&lt;/strong&gt;类，而我们无需编写 Geter/Setter 等方法。&lt;/p&gt;
&lt;p&gt;这个版引入一个转化操作，可以快速将 &lt;code&gt;Record&lt;/code&gt;转换成普通 Java 类，方便我们快速降级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080608159-2144136837.gif&quot; alt=&quot;将记录转换为类&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外对于 Java 15 另一个新语法 &lt;code&gt;sealed&lt;/code&gt;，这个版本补全、代码洞察和重构等功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080608676-1261619877.gif&quot; alt=&quot;支持密封类&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;9、其他改动&quot;&gt;9、其他改动&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;IDEA 自带数据库工具，现在可以支持使用 SQL 查询 MongoDB。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080609001-1073658724.jpg&quot; alt=&quot;使用 SQL 查询 MongoDB&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Lombok 目前成为 IDEA 官方内置插件，以后版本升级，再也不用担心 Lombok 插件不适配，导致全部代码工程一片红了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;VSC 菜单升级优化，将会根据当前使用版本控制系统命名 VCS 菜单，并且当前菜单栏更加简洁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080609216-1067651312.jpg&quot; alt=&quot;更新的 VCS 菜单&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;上面介绍只是这次改动一部分功能，全部功能点请查看 IDEA 官网。&lt;/p&gt;
&lt;p&gt;另外补充一点，IDEA 官方现在已经支持中文了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080609502-391314761.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你使用梯子打开，显示还是英文，那么可以将页面拉到最下面，重新选择语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202012/1419561-20201217080609727-1839854032.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于 2020.3 只是一个小版本，所以这次并没有额外增特别的加新功能。这次新版本主要还是优化 IDEA 用户体验，让开发者使用起来越来越流畅。&lt;/p&gt;
&lt;p&gt;2020 年还有一个月就过去看，IDEA 2021 版本相信很快就来了，期待这次大版本的功能升级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后感叹一句，IDEA 牛逼🚀！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5555555555556&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：小黑十一点半，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot; target=&quot;_blank&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 17 Dec 2020 00:06:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>Hello，大家好,我是楼下小黑哥~ 上周 Java 开发申请神器 IDEA 2020.3 新版正式发布： 小黑哥第一时间就在开发机上更新了新版本，并且完整体验了两周了。 下面介绍一下这个版本的主要功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/14147692.html</dc:identifier>
</item>
<item>
<title>SpringBoot-2.3镜像方案为什么要做多个layer - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14147683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14147683.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/bolingcavalry/p/14147683.html&quot;&gt;《体验SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;一文中，我们体验了官方推荐的镜像制作方案，执行docker history命令观察镜像内部，发现是由多个layer组成的，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201217075129842-2113679791.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;问题来了：搞这么多layer干啥？接下来以图文方式，您一起理解docker镜像layer对java开发者的的作用；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;声明&quot;&gt;声明&lt;/h3&gt;
&lt;p&gt;本文的目标是通过图文帮助java开发者理解docker镜像的layer作用，内容和实际情况并未完全保持一致，例如基础镜像的layer没有提到，而且java镜像的layer可能不止业务镜像、配置文件、依赖库这三层；&lt;/p&gt;
&lt;h3 id=&quot;常见角色&quot;&gt;常见角色&lt;/h3&gt;
&lt;p&gt;使用docker时，有三个常见角色：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;镜像制作者：本文中就是SpringBoot应用开发者，写完代码把应用做成docker镜像；&lt;/li&gt;
&lt;li&gt;docker公共镜像仓库：镜像制作者将镜像推送到仓库给大家使用；&lt;/li&gt;
&lt;li&gt;镜像使用者：从镜像仓库将镜像下载到本地使用；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来的故事围绕上述三个角色展开；&lt;/p&gt;
&lt;h3 id=&quot;从制作到使用的过程&quot;&gt;从制作到使用的过程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如下图，SpringBoot应用开发者，写完代码把应用做成docker镜像，该镜像的TAG是1.0，此时开发者将镜像推送到公共仓库时，一共要推送三个layer：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201217075131151-1122989543.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来，使用者要下载镜像，就从镜像仓库下载三个layer：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201217075132073-1261637252.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;此时，三个角色拥有的内容都是一样，都是三个layer：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201217075133093-637014222.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;这时候SpringBoot开发者修改了业务代码，于是做了个新的镜像（TAG是2.0），然后推送到镜像仓库；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;重点来了&lt;/span&gt;：因为只改了业务代码，因此只有业务class的layer是新的，只有这个layer会被推送到仓库，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201217075134493-2033748941.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;对镜像使用者来说，如果之前下载过1.0的镜像，此时要用2.0镜像的话，只要从仓库下载最新的业务class的layer即可：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201217075135193-455393040.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;最终结果如下，公共仓库和镜像使用者都已最小的代价得到了2.0镜像：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201217075135795-1977062764.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可见，使用多个layer的镜像，在镜像的分发过程中，相比单一layer的镜像会更加高效，尤其是使用hub.docker.com这样的外网公有仓库，以及频繁发布新版的场景下；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 16 Dec 2020 23:52:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14147683.html</dc:identifier>
</item>
<item>
<title>揭开DRF序列化技术的神秘面纱 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14145364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14145364.html</guid>
<description>&lt;p&gt;在RESTful API中，接口返回的是JSON，JSON的内容对应的是数据库中的数据，DRF是通过序列化（Serialization）的技术，把数据模型转换为JSON的，反之，叫做反序列化（deserialization）。本文就来揭开DRF序列化技术的神秘面纱。&lt;/p&gt;

&lt;p&gt;虚拟环境是独立的Python环境，可以和系统环境分离，只安装需要的包即可，使用以下命令创建并激活：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 创建Python虚拟环境
python -m venv env
# 激活虚拟环境
env\Scripts\activate.bat  
# Mac中使用`source env/bin/activate`
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;退出虚拟环境用deactivate。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着在虚拟环境中安装本文用到的包：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;pip install django
pip install djangorestframework
pip install pygments  # 代码高亮
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建project：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;django-admin startproject tutorial
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建app：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd tutorial
python manage.py startapp snippets
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;tutorial/settings.py&lt;/code&gt;中的&lt;code&gt;INSTALLED_APPS&lt;/code&gt;添加&lt;code&gt;snippets&lt;/code&gt;和&lt;code&gt;rest_framework&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;INSTALLED_APPS = [
    ...
    'rest_framework',
    'snippets.apps.SnippetsConfig',
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只有添加后，app才会生效哦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;编辑&lt;code&gt;snippets/models.py&lt;/code&gt;，创建Snippet模型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.db import models
from pygments.lexers import get_all_lexers
from pygments.styles import get_all_styles

LEXERS = [item for item in get_all_lexers() if item[1]]
LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS])
STYLE_CHOICES = sorted([(item, item) for item in get_all_styles()])


class Snippet(models.Model):
    created = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=100, blank=True, default='')
    code = models.TextField()
    linenos = models.BooleanField(default=False)
    language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100)
    style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100)

    class Meta:
        ordering = ['created']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Snippet有6个字段，created、title、code、linenos、language、style。&lt;/p&gt;
&lt;p&gt;接着同步数据库：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;python manage.py makemigrations snippets
python manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;rest_framework.serializers的结构如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201216180531041-178360855.png&quot;/&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;查看Python模块中的成员，需要勾选：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201216180531437-744565507.png&quot;/&gt;&lt;/center&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前我们用过HyperlinkedModelSerializer，是封装后的符合RESTful良好设计的序列化器，这里直接使用更底层的Serializer。在&lt;code&gt;snippets&lt;/code&gt;目录下创建&lt;code&gt;serializers.py&lt;/code&gt;，添加以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from rest_framework import serializers
from snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICES


class SnippetSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(required=False, allow_blank=True, max_length=100)
    code = serializers.CharField(style={'base_template': 'textarea.html'})
    linenos = serializers.BooleanField(required=False)
    language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python')
    style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly')

    def create(self, validated_data):
        &quot;&quot;&quot;
        Create and return a new `Snippet` instance, given the validated data.
        &quot;&quot;&quot;
        return Snippet.objects.create(**validated_data)

    def update(self, instance, validated_data):
        &quot;&quot;&quot;
        Update and return an existing `Snippet` instance, given the validated data.
        &quot;&quot;&quot;
        instance.title = validated_data.get('title', instance.title)
        instance.code = validated_data.get('code', instance.code)
        instance.linenos = validated_data.get('linenos', instance.linenos)
        instance.language = validated_data.get('language', instance.language)
        instance.style = validated_data.get('style', instance.style)
        instance.save()
        return instance
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码第一部分定义了序列化/反序列化的字段，字段定义方式类似于Form。第二部分的&lt;code&gt;create()&lt;/code&gt;和&lt;code&gt;update()&lt;/code&gt;方法定义了调用&lt;code&gt;serializer.save()&lt;/code&gt;时，创建和更新实例的处理方式。&lt;/p&gt;

&lt;p&gt;既然已经创建好了Serializer，何不玩玩它？只有玩了才知道序列化的技术细节。这里用到了Django shell，可以在命令行实时看到输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;python manage.py shell
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先通过模型新增2条测试数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from snippets.models import Snippet
from snippets.serializers import SnippetSerializer
from rest_framework.renderers import JSONRenderer
from rest_framework.parsers import JSONParser

snippet = Snippet(code='foo = &quot;bar&quot;\n')
snippet.save()

snippet = Snippet(code='print(&quot;hello, world&quot;)\n')
snippet.save()
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201216180531657-1439258875.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;接着把它序列化看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;serializer = SnippetSerializer(snippet)
serializer.data
# {'id': 2, 'title': '', 'code': 'print(&quot;hello, world&quot;)\n', 'linenos': False, 'language': 'python', 'style': 'friendly'}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为&lt;code&gt;snippet&lt;/code&gt;变量最后引用的是第2个数据模型的实例，所以这里只显示第2条数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;serializer.data返回的是个字典，最后把字典转换为JSON：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;content = JSONRenderer().render(serializer.data)
content
# b'{&quot;id&quot;: 2, &quot;title&quot;: &quot;&quot;, &quot;code&quot;: &quot;print(\\&quot;hello, world\\&quot;)\\n&quot;, &quot;linenos&quot;: false, &quot;language&quot;: &quot;python&quot;, &quot;style&quot;: &quot;friendly&quot;}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是序列化的过程，模型实例→Python字典→JSON。&lt;/p&gt;
&lt;p&gt;反序列化的过程是类似的，先把JSON转换为Python字典：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import io

stream = io.BytesIO(content)
data = JSONParser().parse(stream)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再把字典转换为模型实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;serializer = SnippetSerializer(data=data)
serializer.is_valid()
# True
serializer.validated_data
# OrderedDict([('title', ''), ('code', 'print(&quot;hello, world&quot;)\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])
serializer.save()
# &amp;lt;Snippet: Snippet object&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为SnippetSerializer的create()方法代码是&lt;code&gt;return Snippet.objects.create(**validated_data)&lt;/code&gt;，所以&lt;code&gt;serializer.save()&lt;/code&gt;会在数据库中新增1条数据，并返回Snippet模型实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，序列化对象不只有模型实例，也可以是数据集：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;serializer = SnippetSerializer(Snippet.objects.all(), many=True)
serializer.data
# [OrderedDict([('id', 1), ('title', ''), ('code', 'foo = &quot;bar&quot;\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 2), ('title', ''), ('code', 'print(&quot;hello, world&quot;)\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 3), ('title', ''), ('code', 'print(&quot;hello, world&quot;)'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])]
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;rest_framework.serializers.Serializers比较底层，需要重复定义model中的字段，DRF的作者当然也想到了这个问题，并且给出了解决办法：把Serializers封装成ModelSerializers。在&lt;code&gt;snippets/serializers.py&lt;/code&gt;中替换&lt;code&gt;SnippetSerializer&lt;/code&gt;为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class SnippetSerializer(serializers.ModelSerializer):
    class Meta:
        model = Snippet
        fields = ['id', 'title', 'code', 'linenos', 'language', 'style']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写法果然简洁了很多。使用Django shell打印出来看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from snippets.serializers import SnippetSerializer
serializer = SnippetSerializer()
print(repr(serializer))
# SnippetSerializer():
#    id = IntegerField(label='ID', read_only=True)
#    title = CharField(allow_blank=True, max_length=100, required=False)
#    code = CharField(style={'base_template': 'textarea.html'})
#    linenos = BooleanField(required=False)
#    language = ChoiceField(choices=[('Clipper', 'FoxPro'), ('Cucumber', 'Gherkin'), ('RobotFramework', 'RobotFramework'), ('abap', 'ABAP'), ('ada', 'Ada')...
#    style = ChoiceField(choices=[('autumn', 'autumn'), ('borland', 'borland'), ('bw', 'bw'), ('colorful', 'colorful')...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和手动定义的字段一模一样。其实ModelSerializer并没有做额外的处理，我们可以从它的部分代码片段看到:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;  serializer_field_mapping = {
        models.AutoField: IntegerField,
        models.BigIntegerField: IntegerField,
        models.BooleanField: BooleanField,
  
  
  # Default `create` and `update` behavior...
  def create(self, validated_data):
  
  
  def update(self, instance, validated_data):
      raise_errors_on_nested_writes('update', self, validated_data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立字段映射，定义&lt;code&gt;create()&lt;/code&gt;和&lt;code&gt;update()&lt;/code&gt;等方法，只做了最简单的封装。&lt;/p&gt;

&lt;p&gt;我们之前用的是已经封装好的rest_framework.viewsets，这里直接用Django原生的view。在&lt;code&gt;snippets/views.py&lt;/code&gt;中添加代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.http import HttpResponse, JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.parsers import JSONParser
from snippets.models import Snippet
from snippets.serializers import SnippetSerializer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先创建snippet_list视图，返回snippets列表或者新建1个snippet：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@csrf_exempt
def snippet_list(request):
    &quot;&quot;&quot;
    List all code snippets, or create a new snippet.
    &quot;&quot;&quot;
    if request.method == 'GET':
        snippets = Snippet.objects.all()
        serializer = SnippetSerializer(snippets, many=True)
        return JsonResponse(serializer.data, safe=False)

    elif request.method == 'POST':
        data = JSONParser().parse(request)
        serializer = SnippetSerializer(data=data)
        if serializer.is_valid():
            serializer.save()
            return JsonResponse(serializer.data, status=201)
        return JsonResponse(serializer.errors, status=400)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文示例中，客户端发起POST请求是不带CSRF token的，所以需要添加csrf_exempt（exempt翻译为免除）装饰器，允许跨域访问。这里只是演示，实际会使用&lt;code&gt;django-cors-headers&lt;/code&gt;来解决跨域问题，而不是给每个view都加上&lt;code&gt;@csrf_exempt&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;CSRF是指跨站请求伪造，攻击者盗用你的身份，以你的名义发送恶意请求。CSRF token是指服务器通过token来认证，如果请求中没有token或者token不匹配，那么就认为可能是CSRF而拒绝该请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着添加一个view，对单个snippet进行删（delete）、改（update）、查（retrieve）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@csrf_exempt
def snippet_detail(request, pk):
    &quot;&quot;&quot;
    Retrieve, update or delete a code snippet.
    &quot;&quot;&quot;
    try:
        snippet = Snippet.objects.get(pk=pk)
    except Snippet.DoesNotExist:
        return HttpResponse(status=404)

    if request.method == 'GET':
        serializer = SnippetSerializer(snippet)
        return JsonResponse(serializer.data)

    elif request.method == 'PUT':
        data = JSONParser().parse(request)
        serializer = SnippetSerializer(snippet, data=data)
        if serializer.is_valid():
            serializer.save()
            return JsonResponse(serializer.data)
        return JsonResponse(serializer.errors, status=400)

    elif request.method == 'DELETE':
        snippet.delete()
        return HttpResponse(status=204)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，前面create返回的status为201，这里retrieve返回的默认的200，附上几个常见状态码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;200 OK - GET/PUT/PATCH：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）&lt;/li&gt;
&lt;li&gt;201 CREATED - POST：用户新建数据成功&lt;/li&gt;
&lt;li&gt;204 NO content - DELETE：用户删除数据成功&lt;/li&gt;
&lt;li&gt;400 Invalid request - POST/PUT/PATCH：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的&lt;/li&gt;
&lt;li&gt;401 Unauthorized - *：表示用户没有权限（令牌、用户名、密码错误）&lt;/li&gt;
&lt;li&gt;403 Forbidden - *：表示用户得到授权（与401错误相对），但是访问是被禁止的&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;最后，添加路由，新建文件&lt;code&gt;snippets/urls.py&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path
from snippets import views

urlpatterns = [
    path('snippets/', views.snippet_list),
    path('snippets/&amp;lt;int:pk&amp;gt;/', views.snippet_detail),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再配置到&lt;code&gt;tutorial/urls.py&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path, include

urlpatterns = [
    path('', include('snippets.urls')),
]
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;启动项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;python manage.py runserver
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新开一个Terminal，安装HTTP命令行工具：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pip install httpie
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求snippets列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;http http://127.0.0.1:8000/snippets/

HTTP/1.1 200 OK
...
[
  {
    &quot;id&quot;: 1,
    &quot;title&quot;: &quot;&quot;,
    &quot;code&quot;: &quot;foo = \&quot;bar\&quot;\n&quot;,
    &quot;linenos&quot;: false,
    &quot;language&quot;: &quot;python&quot;,
    &quot;style&quot;: &quot;friendly&quot;
  },
  {
    &quot;id&quot;: 2,
    &quot;title&quot;: &quot;&quot;,
    &quot;code&quot;: &quot;print(\&quot;hello, world\&quot;)\n&quot;,
    &quot;linenos&quot;: false,
    &quot;language&quot;: &quot;python&quot;,
    &quot;style&quot;: &quot;friendly&quot;
  }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求id为2的snippet：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;http http://127.0.0.1:8000/snippets/2/

HTTP/1.1 200 OK
...
{
  &quot;id&quot;: 2,
  &quot;title&quot;: &quot;&quot;,
  &quot;code&quot;: &quot;print(\&quot;hello, world\&quot;)\n&quot;,
  &quot;linenos&quot;: false,
  &quot;language&quot;: &quot;python&quot;,
  &quot;style&quot;: &quot;friendly&quot;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;不得不说DRF的Tutorial实践性很强，基本上照着做都能敲出来，体验比较好。序列化的过程，就是模型实例→Python字典→JSON的过程。通过本文也理解了在app中&lt;code&gt;models.py&lt;/code&gt;→&lt;code&gt;serializers.py&lt;/code&gt;→&lt;code&gt;views.py&lt;/code&gt;→&lt;code&gt;urls.py&lt;/code&gt;的代码编写顺序。&lt;/p&gt;
&lt;blockquote readability=&quot;0.84397163120567&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.django-rest-framework.org/tutorial/1-serialization/&quot; target=&quot;_blank&quot;&gt;https://www.django-rest-framework.org/tutorial/1-serialization/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yexudengzhidao/article/details/93527586&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/yexudengzhidao/article/details/93527586&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 16 Dec 2020 23:37:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>在RESTful API中，接口返回的是JSON，JSON的内容对应的是数据库中的数据，DRF是通过序列化（Serialization）的技术，把数据模型转换为JSON的，反之，叫做反序列化（dese</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14145364.html</dc:identifier>
</item>
<item>
<title>【震惊】padding-top的百分比值参考对象竟是父级元素的宽度 - 胡哥有话说</title>
<link>http://www.cnblogs.com/justbecoder/p/14147650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justbecoder/p/14147650.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;书写页面样式与布局是前端工程师&lt;code&gt;Coding&lt;/code&gt; 中必不可少的一项工作，在定义页面元素的样式时，&lt;code&gt;padding&lt;/code&gt; 属性也是经常被使用到的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;padding&lt;/code&gt; 属性用于设置元素的内边距，其值可以是&lt;code&gt;length&lt;/code&gt;、&lt;code&gt;inherit&lt;/code&gt;，当然也可以是&lt;code&gt;百分比&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;今天为什么会聊到&lt;code&gt;padding-top&lt;/code&gt;设置百分比时的参考对象这个话题呢，这还要从一道不那么正经的面试题说起~&lt;/p&gt;
&lt;h2 id=&quot;一道不那么正经的css布局面试题&quot;&gt;一道不那么正经的css布局面试题&lt;/h2&gt;
&lt;p&gt;在对面，一本正经的面试官和蔼可亲的说道：我们来道简单的面试题，写写代码吧。你一脸微笑的说道：好哒。&lt;/p&gt;
&lt;h4 id=&quot;题目须知：&quot;&gt;题目须知：&lt;/h4&gt;
&lt;p&gt;页面中有一个元素A，请实现以下需求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;元素A在页面内水平、垂直居中；&lt;/li&gt;
&lt;li&gt;元素A距离页面左右的间距为10px，元素A的宽度随页面宽度变大而变大；&lt;/li&gt;
&lt;li&gt;设置元素A的高度始终为宽度的一半；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;只要是对CSS了解的一些的同学，实现1和2都是非常简单的，而且方式也是多种多样的。那如何能设置让元素A的高度始终为宽度的一半呢？上代码~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;页面布局：要考虑DOM的结构和CSS的样式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    * {
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      /* 设置子元素A垂直水平居中 */ 
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .a {
      /* 设置margin左右间距为10px */
      margin: 0 10px;
      background: #F00;
      /* 设置宽度为100vw，实际宽度会受到弹性盒子的影响 */
      width: 100vw;
      /* calc方法动态计算：height的值为宽度的1/2，所以是 (100vw - 20px) / 2 */
      height: calc(50vw - 10px);
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&quot;a&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在上述的代码中我们借助calc方法实现了设置元素的高度为宽度的1/2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时内心是否有些窃喜，又搞定了一个问题，饱含自信(&lt;strong&gt;傲娇&lt;/strong&gt;)的目光看向了面试官。&lt;br/&gt;然而，当你没有get到面试官的&lt;code&gt;G&lt;/code&gt;点时，面试官又和蔼可亲（&lt;strong&gt;冷若冰霜&lt;/strong&gt;）的说道“还有别的方法吗？”&lt;/p&gt;
&lt;p&gt;还能有啥别的办法呢？你无助的捋了捋自己那为数不多的秀发。&lt;/p&gt;
&lt;p&gt;啦啦啦，快来使用&lt;code&gt;padding-top&lt;/code&gt;，哼哼哈嘿...&lt;/p&gt;
&lt;h2 id=&quot;探究padding-top的秘密&quot;&gt;探究padding-top的秘密&lt;/h2&gt;
&lt;p&gt;当padding-top的值为百分比时，参考的对象是父级元素的宽度&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这句话圈起来，是重点，要考~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    * {
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      /* 设置子元素A垂直水平居中 */ 
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .a {
      /* 设置margin左右间距为10px */
      margin: 0 10px;
      background: #F00;
      /* 设置宽度为100%，父级容器宽度的100%，实际宽度会受到弹性盒子的影响 */
      width: 100%;
      height: 0;
      /* calc方法动态计算：padding-top的值为父级容器宽度的1/2，所以是 (100vw - 20px) / 2 */
      padding-top: calc(50% - 10px);
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&quot;a&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此处也可以选择使用&lt;code&gt;padding-bottom&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此刻你再抬头时，看到了面试官那饱含了心满意足、孺子可教的热烈眼神...&lt;/p&gt;
&lt;h2 id=&quot;最后的秘密&quot;&gt;最后的秘密&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;padding-top&lt;/code&gt;、&lt;code&gt;padding-bottom&lt;/code&gt;、&lt;code&gt;margin-top&lt;/code&gt;、&lt;code&gt;margin-bottom&lt;/code&gt;属性设置为百分比时，参考对象都是父级元素的宽度&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;要记住呀，下回还得考~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;收藏&lt;/code&gt;呦，关注胡哥有话说，学习前端不迷路，欢迎多多留言交流...&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;胡哥有话说，专注于大前端技术领域，分享前端系统架构，框架实现原理，最新最高效的技术实践！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 16 Dec 2020 18:49:00 +0000</pubDate>
<dc:creator>胡哥有话说</dc:creator>
<og:description>引言 书写页面样式与布局是前端工程师Coding 中必不可少的一项工作，在定义页面元素的样式时，padding 属性也是经常被使用到的。 padding 属性用于设置元素的内边距，其值可以是lengt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justbecoder/p/14147650.html</dc:identifier>
</item>
<item>
<title>G1 收集器 - buttercup</title>
<link>http://www.cnblogs.com/buttercup/p/13829881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buttercup/p/13829881.html</guid>
<description>&lt;h2 id=&quot;性能指标&quot;&gt;性能指标&lt;/h2&gt;
&lt;p&gt;在调优Java应用程序时，重点通常放在两个主要目标上：&lt;strong&gt;响应性&lt;/strong&gt; 或 &lt;strong&gt;吞吐量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;响应性&lt;/strong&gt;&lt;code&gt;Responsiveness&lt;/code&gt; 是指应用程序对请求的数据做出响应的速度：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;桌面用户界面对事件的响应速度&lt;/li&gt;
&lt;li&gt;网站返回页面的速度&lt;/li&gt;
&lt;li&gt;数据库查询的返回速度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　&lt;strong&gt;吞吐量&lt;/strong&gt;&lt;code&gt;Throughput&lt;/code&gt; 专注于最大程度地提高应用程序在特定时间段内的工作量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在给定时间内完成的事务次数&lt;/li&gt;
&lt;li&gt;批处理程序在一小时内可以完成的作业数&lt;/li&gt;
&lt;li&gt;一小时内可以完成的数据库查询数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;较长的暂停时间&lt;code&gt;Pause Time&lt;/code&gt;对于注重响应性的应用程序是不可接受的，但对于注重吞吐量的应用程序来说可以接受的。前者重点是在短时间内做出响应，后者则侧重与长时间运行的处理效率。&lt;/p&gt;
&lt;h2 id=&quot;gc-基础&quot;&gt;GC 基础&lt;/h2&gt;
&lt;h3 id=&quot;gc-root&quot;&gt;GC Root&lt;/h3&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/05/Java-GC-mark-and-sweep.png&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可达性分析是 Java GC 算法的基础，基本思路就是以一系列名为 &lt;code&gt;GC Roots&lt;/code&gt; 对象作为起始点，通过引用关系遍历对象图，如果一个对象到 &lt;code&gt;GC Roots&lt;/code&gt; 间没有任何可达路径相连时，则说明此对象可以被回收。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14041675-df1525e1beadcb43.png?imageMogr2/auto-orient/strip|imageView2/2/w/1108/format/webp&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以作为 &lt;code&gt;GC Roots&lt;/code&gt; 的对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI（即一般说的native方法）中引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三色标记&quot;&gt;三色标记&lt;/h3&gt;
&lt;p&gt;可达性分析中重要的一环就是遍历整个堆，并标记其中的存活对象。一种常用的标记算法是 &lt;strong&gt;三色标记法&lt;/strong&gt;&lt;code&gt;tri-color marking&lt;/code&gt;：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1d/Animation_of_tri-color_garbage_collection.gif/330px-Animation_of_tri-color_garbage_collection.gif&quot; width=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个对象可能为以下 3 种颜色之一：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;white&lt;/strong&gt; — 未被标记&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gray&lt;/strong&gt; — 本身已标记，但部分引用的对象完成标记（动图的黄色对象）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;black&lt;/strong&gt; — 本身已标记，且所有引用的对象完成标记（动图的蓝色对象）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;标记算法从 GC Roots 出发遍历堆，可达对象先标记 gray，然后再标记 为 black。&lt;/p&gt;
&lt;p&gt;遍历完成之后所有可达对象都是 black 的，此时所有标记为 white 的对象都是可以回收的。&lt;/p&gt;
&lt;p&gt;当实现并发标记算法时，必须防止 white 对象被漏标，否则可能导致不该回收的对象被回收。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;分代收集&quot;&gt;分代收集&lt;/h3&gt;
&lt;p&gt;传统垃圾收集器将堆分成三个部分：年轻代&lt;code&gt;YoungGen = Eden + Survivor&lt;/code&gt;，老年代&lt;code&gt;OldGen&lt;/code&gt;和永久代&lt;code&gt;PermGen&lt;/code&gt;，每个区域内存连续且大小固定。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;年轻代：一次性使用的临时对象（例如：方法中构造的临时对象）&lt;/li&gt;
&lt;li&gt;老年代：被长期引用的常驻对象（例如：缓存对象、单例对象）&lt;/li&gt;
&lt;li&gt;永久代：JVM 运行过程中一直存在的对象（例如：字符串常量、类信息）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将堆内存进行划分后，可以按照对象生命周期长短，在不同区域使用不同的回收算法，提高 GC 的效率。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;算法分类&quot;&gt;算法分类&lt;/h3&gt;
&lt;h4 id=&quot;mark-and-sweep标记-清除&quot;&gt;&lt;strong&gt;Mark and Sweep&lt;/strong&gt;&lt;code&gt;标记-清除&lt;/code&gt;&lt;/h4&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/GC-sweep.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　用一个空闲列表&lt;code&gt;free-list&lt;/code&gt;记录失效对象占用的内存区域，方便后续重新分配给新对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回收原理简单，GC 停顿时间短&lt;/li&gt;
&lt;li&gt;维护空闲列表需要一定的空间开销&lt;/li&gt;
&lt;li&gt;内存碎片较多，可能导致内存分配失败&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mark-sweep-compact标记-整理&quot;&gt;&lt;strong&gt;Mark-Sweep-Compact&lt;/strong&gt;&lt;code&gt;标记-整理&lt;/code&gt;&lt;/h4&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/GC-mark-sweep-compact.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　将所有存活对象移动到内存区域的开头，剩余的连续内存区域都是可用的空闲空间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过指针碰撞查找空闲空间，分配速度快&lt;/li&gt;
&lt;li&gt;内存碎片少，内存分配失败概率低&lt;/li&gt;
&lt;li&gt;复制对象会导致较长时间的 GC 停顿&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mark-and-copy标记-复制&quot;&gt;&lt;strong&gt;Mark and Copy&lt;/strong&gt;&lt;code&gt;标记-复制&lt;/code&gt;&lt;/h4&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/GC-mark-and-copy-in-Java.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　将内存划分为&lt;strong&gt;活动区间&lt;/strong&gt;与&lt;strong&gt;空闲区间&lt;/strong&gt;，前者用于动态分配对象，后者用于容纳 GC 存活对象。&lt;br/&gt;　GC 时只需将存活对象从前者复制到后者，然后交换两者的角色即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记和复制在同一阶段同时进行，当存活对象少时回收效率极高&lt;/li&gt;
&lt;li&gt;需要预留一个空闲空间用于容纳存活对象，造成内存浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CMS &lt;code&gt;Concurrent Mark-Sweep&lt;/code&gt; 是一个采用 &lt;strong&gt;标记-清除&lt;/strong&gt; 算法的老年代收集器。&lt;br/&gt;它通过与应用程序线程并发执行大多数垃圾回收工作，来最大程度地减少由于 GC 导致的暂停。&lt;/p&gt;
&lt;p&gt;通常情况下，CMS 收集器不会复制或压缩活动对象，这意味着无需移动活动对象即可完成垃圾回收。&lt;br/&gt;然而过多的内存碎片可能造成分配失败，最终导致 FullGC。可以通过分配更大的堆来规避这一问题。&lt;/p&gt;
&lt;p&gt;CMS 对老年代的回收可以分为以下几个步骤：&lt;/p&gt;
&lt;ul readability=&quot;27&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Initial Mark &lt;em&gt;(STW)&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;初始标记&lt;/code&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/g1-06.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记 GC Roots 直接可达的老年代对象&lt;/li&gt;
&lt;li&gt;遍历新生代存活对象，标记直接可达的老年代对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;Concurrent Mark&lt;/strong&gt; &lt;code&gt;并发标记&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GC 线程遍历 &lt;strong&gt;Initial Mark&lt;/strong&gt; 阶段标记出来存活的老年代对象，然后递归标记这些可达的对象。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/g1-07.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该阶段与应用线程并发运行，期间会发生新生代对象晋升、老年代对象引用关系更新，需要对这些对象进行重新标记，避免发生遗漏。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/g1-08.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CMS 用一个&lt;code&gt;card-table&lt;/code&gt;管理老年代，并发标记过程中，某个对象的引用关系发生了变化，则将对象所在的内存块标记为 &lt;strong&gt;Dirty Card&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CMS 使用&lt;strong&gt;增量更新&lt;/strong&gt;&lt;code&gt;incremental update&lt;/code&gt;解决并发修改导致的漏标问题：把 black 对象重新标记为 grey，下次重新扫描其引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;Preclean&lt;/strong&gt; &lt;code&gt;预清理&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这一阶段主要是处理 &lt;strong&gt;Concurrent Mark&lt;/strong&gt; 阶段中引用关系改变，导致没有标记到的存活对象的。通过并发地重新扫描这些对象，预清理阶段可以减少 &lt;strong&gt;Remark&lt;/strong&gt; 阶段的 STW。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/g1-09.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个阶段会处理前一个阶段被标记为 &lt;strong&gt;Dirty Card&lt;/strong&gt; 的部分，将其中变化了的对象作为 GC Root 再进行扫描并重新标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Abortable Preclean&lt;/strong&gt; &lt;code&gt;可终止的预清理&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个阶段作用与 &lt;strong&gt;Preclean&lt;/strong&gt; 类似，但可以通过设置 &lt;strong&gt;扫描时长&lt;/strong&gt;（默认5秒）或 &lt;strong&gt;Eden 区使用占比&lt;/strong&gt;（默认50%）控制本阶段的结束时机。&lt;/p&gt;
&lt;p&gt;增加这一阶段的原因，是期待这期间能发生一次 YoungGC 清理无效的年轻代对象，减少 &lt;strong&gt;Remark&lt;/strong&gt; 阶段扫描年轻代的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;Remark &lt;em&gt;(STW)&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;重新标记&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;这个阶段同时扫描 YoungGen 与 OldGen，重新标记整个老年代中所有存活对象。&lt;/p&gt;
&lt;p&gt;由于之前的 &lt;strong&gt;Concurrent Mark&lt;/strong&gt; 与 &lt;strong&gt;Preclean&lt;/strong&gt; 阶段是与用户线程并发执行的，年轻代对老年代的引用可能已经发生了改变，&lt;strong&gt;Remark&lt;/strong&gt; 要花很多时间处理这些改变，会导致长时间的 STW。&lt;/p&gt;
&lt;p&gt;此外，即使新生代的对象已经不可达了，CMS 也会使用这些不可达的对象当做的 GC Roots 来扫描老年代，导致部分失效的老年代对象无法被及时回收。&lt;/p&gt;
&lt;p&gt;可以加入参数 -XX:+CMSScavengeBeforeRemark，在重新标记之前，先执行一次 YoungGC，回收掉年轻代的对象无用的对象。这样进行年轻代扫描时，只需要扫描 Survivor 区的对象即可，一般 Survivor 区非常小，这大大减少了扫描时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;Concurrent Sweep&lt;/strong&gt; &lt;code&gt;并发清理&lt;/code&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/g1-10.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，老年代所有存活的对象已经被标记完成。这个阶段主要是清除那些没有标记的对象并且回收空间。&lt;/p&gt;
&lt;p&gt;被回收的空间会被添加到 &lt;strong&gt;空闲列表&lt;/strong&gt;中，以供以后分配。这一过程可能会对空闲空间进行合并，但是不会移动存活对象。&lt;/p&gt;
&lt;p&gt;由于该阶段是与应用线程并发运行的，自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，无法在当次收集中处理掉它们。只好留待下一次GC时再清理掉。这一部分垃圾就称为 &lt;strong&gt;浮动垃圾&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Resetting&lt;/strong&gt; &lt;code&gt;重置&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;清除数据结构，并重置定时器，为下一轮 GC 做准备。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;设计目的&quot;&gt;设计目的&lt;/h2&gt;
&lt;p&gt;G1 &lt;code&gt;Garbage-First&lt;/code&gt; 是一种服务器端的垃圾收集器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以与应用程序线程并行运行，减少 STW&lt;/li&gt;
&lt;li&gt;整理空闲空间减少内存碎片，但不引入较长的 GC 暂停时间&lt;/li&gt;
&lt;li&gt;提供可预测的GC暂停时间，无需牺牲很多吞吐量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;G1 能够在大内存的多处理器计算机上，保证 GC 暂停时间可控，并实现高吞吐量。&lt;/p&gt;
&lt;p&gt;其最终目的是取代 CMS 成为服务端 GC 更好的解决方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;采用 &lt;strong&gt;标记-整理&lt;/strong&gt; 算法，可以避免使用细粒度的空闲列表进行分配。简化了收集器设计并消除了潜在的碎片问题。&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;增量回收&lt;/strong&gt;&lt;code&gt;incremental collecting&lt;/code&gt; 算法，其 GC 暂停时间比 CMS 更具可预测性，并允许用户指定期望的暂停时间。&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;G1 将堆划分为一组大小相等的且连续的堆区域&lt;code&gt;Region&lt;/code&gt;：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/g1-011.png&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;G1 中新生代与老年代不再连续，每个区域可以在 &lt;strong&gt;Eden&lt;/strong&gt;、&lt;strong&gt;Survivor&lt;/strong&gt; 与 &lt;strong&gt;Old&lt;/strong&gt; 之间切换角色。此外，还有一类被称为 &lt;strong&gt;Humongous&lt;/strong&gt; 的巨型区域，用于容纳体积 ≥ 标准区域大小的50％的对象。JVM 通常会将内存划分为 2000个区域，每个大小从 1 到 32Mb 不等，由 JVM 在启动时通过 -XX:G1HeapRegionSize 指定。&lt;/p&gt;
&lt;p&gt;每个区域会被进一步细分成多个卡片&lt;code&gt;Card&lt;/code&gt;，每个大小为 512Kb，用于实现细粒度的引用统计。&lt;/p&gt;
&lt;p&gt;分区设计可以避免一次收集整个堆，每次 GC 只收集区域的一个子集 &lt;strong&gt;CSet&lt;/strong&gt;&lt;code&gt;collection set&lt;/code&gt;，其中必然包含所有 &lt;strong&gt;Young&lt;/strong&gt; 区域，同时可能包括部分 &lt;strong&gt;Old&lt;/strong&gt; 区域：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2015/06/g1-02.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据回收区域的不同，可以将 GC 分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;YoungGC&lt;/strong&gt;：&lt;strong&gt;CSet&lt;/strong&gt; 只包含 &lt;strong&gt;Young&lt;/strong&gt; 区域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MixedGC&lt;/strong&gt;： &lt;strong&gt;CSet&lt;/strong&gt; 同时包含 &lt;strong&gt;Young&lt;/strong&gt; 与 &lt;strong&gt;Old&lt;/strong&gt; 区域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FullGC&lt;/strong&gt;： 回收整个堆（可用空间耗尽时触发，单线程执行）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;G1 根据存活对象的字节数统计每个区域的 &lt;strong&gt;活跃度&lt;/strong&gt;&lt;code&gt;liveness&lt;/code&gt;，然后根据期望停顿时间来确定该 &lt;strong&gt;CSet&lt;/strong&gt; 的大小，并保证那些垃圾多（活跃度低）的区域会被优先回收，故此得名 &lt;strong&gt;垃圾优先&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;G1 的执行过程可以表示为由 3 个阶段组成的循环：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1901291/o_201216040643g1_cycle.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;young-gc&quot;&gt;Young GC&lt;/h2&gt;
&lt;p&gt;堆中一开始只有 &lt;strong&gt;YoungGen&lt;/strong&gt;，因此只会触发 &lt;strong&gt;YoungGC&lt;/strong&gt;，将 &lt;strong&gt;Eden&lt;/strong&gt; 与 &lt;strong&gt;Survivor&lt;/strong&gt; 区域中的活动对象复制到另一个空闲的 &lt;strong&gt;Survivor&lt;/strong&gt; 区域。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png&quot; width=&quot;300&quot;/&gt;&lt;img src=&quot;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png&quot; width=&quot;300&quot;/&gt;&lt;/center&gt;
&lt;p&gt;G1 中将 &lt;strong&gt;将存活对象复制到其他区域&lt;/strong&gt; 的过程称为 &lt;strong&gt;疏散&lt;/strong&gt;&lt;code&gt;Evacuation&lt;/code&gt;。为了减少停顿时间，疏散工作由多个 GC 线程并行完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;YoungGC&lt;/strong&gt; 过程中会根据预期目标停顿时间 &lt;strong&gt;-XX:MaxGCPauseMillis&lt;/strong&gt; 动态调整新生代的大小，通过 &lt;strong&gt;-XX:G1NewSizePercent&lt;/strong&gt; 参数可以人为干预这一过程，但会让预期停顿时间参数失效。&lt;/p&gt;
&lt;p&gt;当堆的整体占用空间足够大时（超过45%），就会进入 &lt;strong&gt;Concurrent Marking&lt;/strong&gt; 阶段。通过 &lt;strong&gt;-XX:InitiatingHeapOccupancyPercent&lt;/strong&gt; 选项可以配置这一行为。&lt;/p&gt;
&lt;h2 id=&quot;concurrent-marking&quot;&gt;Concurrent Marking&lt;/h2&gt;
&lt;p&gt;与 CMS 类似，G1 中的并发标记包括多个阶段，其中一些阶段是并发的，另一些阶段则会 STW。&lt;br/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;Initial Mark &lt;em&gt;(STW)&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;初始标记&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;扫描并标记 &lt;strong&gt;GC Root&lt;/strong&gt; 对象直接可达的老年代存活对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Initial Mark&lt;/strong&gt; 并没有独立的执行阶段，而是嵌入 &lt;strong&gt;YoungGC&lt;/strong&gt; 中执行的，其停顿时间会被分摊，因此实际的开销非常低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;ul readability=&quot;18&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Root Region Scan&lt;/strong&gt; &lt;code&gt;扫描根区域&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;扫描 &lt;strong&gt;Root Region&lt;/strong&gt; 并标记所有可达的老年代存活对象。&lt;/p&gt;
&lt;p&gt;此处的 &lt;strong&gt;Root Region&lt;/strong&gt; 就是先前 &lt;strong&gt;YoungGC&lt;/strong&gt; 中生成的 &lt;strong&gt;Survivor&lt;/strong&gt; 区域，其包含的对象都会被视为 &lt;strong&gt;GC Root&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了避免移动对象对标记产生影响，该过程必须在下次 &lt;strong&gt;YongGC&lt;/strong&gt; 启动前完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;Concurrent Mark&lt;/strong&gt; &lt;code&gt;并发标记&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动并发标记线程，扫描并标记整个堆中的存活对象（线程数可以通过 &lt;strong&gt;-XX:ConcGCThread&lt;/strong&gt; 进行配置）。&lt;/p&gt;
&lt;p&gt;为了避免重复标记，G1 使用 &lt;strong&gt;SATB&lt;/strong&gt;&lt;code&gt;snapshot-at-the-beginning&lt;/code&gt;算法解决漏标问题：&lt;/p&gt;
&lt;p&gt;应用线程对在 &lt;strong&gt;Concurrent Mark&lt;/strong&gt; 执行期间进行的所有并发更新，都应保留先前的已知标记信息。&lt;/p&gt;
&lt;p&gt;该约束是通过&lt;strong&gt;预写屏障&lt;/strong&gt;&lt;code&gt;pre-write barrier&lt;/code&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Concurrent Mark&lt;/strong&gt; 扫描过程中，当应用线程修改某个字段时，会将先前的引用对象存储在&lt;strong&gt;日志缓冲区&lt;/strong&gt;&lt;code&gt;log buffers&lt;/code&gt;中，然后交由并发标记线程处理。&lt;/p&gt;
&lt;p&gt;为了避免移动对象对标记产生影响，该过程必须在下次 &lt;strong&gt;YoungGC&lt;/strong&gt; 启动前完成。所有的标记任务必须在堆满前完成，如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行 &lt;strong&gt;FullGC&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;Remark &lt;em&gt;(STW)&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;重新标记&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动并行标记线程，完成对整个堆中存活对象的标记（线程数可以通过 &lt;strong&gt;-XX:ParallelGCThread&lt;/strong&gt; 进行配置）。&lt;/p&gt;
&lt;p&gt;该阶段会暂停所有应用线程，避免发生引用更新，并完成对&lt;strong&gt;SATB 日志缓冲区&lt;/strong&gt;中剩余对象的标记，找出所有未被访问的存活对象。&lt;/p&gt;
&lt;p&gt;该阶段还执行一些额外的清理操作，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;卸载不可达的类（通过 &lt;strong&gt;-XX:+ClassUnloadingWithConcurrentMark&lt;/strong&gt; 开启）&lt;/li&gt;
&lt;li&gt;处理引用对象（弱引用、软引用、虚引用、最终引用）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Cleanup&lt;/strong&gt; &lt;code&gt;清理垃圾&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;整理统计信息并识别出高收益的老年代分区，为 &lt;strong&gt;MixedGC&lt;/strong&gt; 做准备。&lt;/p&gt;
&lt;p&gt;主要工作有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RSet 梳理（后续说明）&lt;/li&gt;
&lt;li&gt;识别回收收益高的老年代分区 (基于释放空间和暂停目标)&lt;/li&gt;
&lt;li&gt;直接回收的没有活跃对象的空闲分区&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外还会执行一些清理工作，为下一次 &lt;strong&gt;Concurrent Marking&lt;/strong&gt; 做好准备。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mixed-gc&quot;&gt;Mixed GC&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MixedGC&lt;/strong&gt; 主要流程与 &lt;strong&gt;YoungGC&lt;/strong&gt; 类似，不同的地方在于 &lt;strong&gt;CSet&lt;/strong&gt; 中包含了 &lt;strong&gt;Old&lt;/strong&gt; 区域。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;Concurrent Marking&lt;/strong&gt; 结束后，并不一定会立即触发 &lt;strong&gt;MixedGC&lt;/strong&gt;，中间可能会穿插多次的 &lt;strong&gt;YoungGC&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当收集某个区域时，我们必须知道是否有来自非收集区域引用，来确定它们的活动性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从非收集区域到收集区域的 &lt;strong&gt;incoming reference&lt;/strong&gt; 是重要的（被非收集区引用的对象必须存活）&lt;/li&gt;
&lt;li&gt;从收集区域到非收集区域的 &lt;strong&gt;outgoing reference&lt;/strong&gt; 是可忽略的（非收集区域不参与GC）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但查找整个堆非常耗时，同时也失去了增量收集的优势。为了解决这一问题，G1 为每个区域维护了一个 &lt;strong&gt;RSet&lt;/strong&gt;&lt;code&gt;remembered set&lt;/code&gt;，用于记忆从其他区域指向自己的引用。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;收集过程&quot;&gt;收集过程&lt;/h3&gt;
&lt;p&gt;在执行收集时，&lt;strong&gt;RSet&lt;/strong&gt; 中引用信息会扮演局部 &lt;strong&gt;GC Roots&lt;/strong&gt; 的角色，避免耗时的引用查找，保证每个区域的 GC 能够独立进行：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2016/01/g1-03.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，象如果 &lt;strong&gt;Old&lt;/strong&gt; 区域中对在 &lt;strong&gt;Concurrent Marking&lt;/strong&gt; 阶段被确定为垃圾，即使有外部引用，该对象也会被作为垃圾回收。&lt;/p&gt;
&lt;p&gt;接下来发生的事情与其他收集器所做的相同：多个并行GC线程找出哪些对象是活动的，哪些对象是垃圾：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2016/01/g1-04.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，释放空闲区域，将活动对象移到 &lt;strong&gt;Survivor&lt;/strong&gt; 区域，并在必要时创建新对象：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://plumbr.io/app/uploads/2016/01/g1-05-v2.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;rset-维护&quot;&gt;&lt;strong&gt;RSet&lt;/strong&gt; 维护&lt;/h3&gt;
&lt;p&gt;为了维护 RSet，在应用线程对字段执行写操作时，会触发&lt;strong&gt;写后屏障&lt;/strong&gt;&lt;code&gt;post-write barrier&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;如果更新后的引用是跨区域的（即从一个区域指向另一个区域），则对应的条目将出现在目标区域的 &lt;strong&gt;RSet&lt;/strong&gt; 中。&lt;/p&gt;
&lt;p&gt;为了减少写屏障带来的开销，该过程是异步的：&lt;/p&gt;
&lt;p&gt;应用线程只负责把更新字段所在的 Card 信息插入一个&lt;strong&gt;DCQ&lt;/strong&gt;&lt;code&gt;Dirty Card Queue&lt;/code&gt;，然后由 Refine 线程将其拾取并将信息传播到被引用区域的 RSet。&lt;/p&gt;
&lt;p&gt;如果应用线程插入速度过快，会导致 Refine 线程来不及处理，那么应用线程将接管 RSet 更新的任务，从而导致性能下降。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;并发标记&lt;/strong&gt; 与 &lt;strong&gt;增量收集&lt;/strong&gt; 是 G1 实现高性能与可预测回收的关键。&lt;/p&gt;
&lt;p&gt;对于 CPU 资源充足且对延迟敏感的服务端应用来说，G1 算法能够在大堆上提供良好的响应速度。&lt;/p&gt;
&lt;p&gt;作为代价，额外的写屏障与更活跃GC线程，会对应用的吞吐量产生负面影响。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Wed, 16 Dec 2020 16:53:00 +0000</pubDate>
<dc:creator>buttercup</dc:creator>
<og:description>基础知识 性能指标 在调优Java应用程序时，重点通常放在两个主要目标上：响应性 或 吞吐量。 响应性Responsiveness 是指应用程序对请求的数据做出响应的速度： 桌面用户界面对事件的响应速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buttercup/p/13829881.html</dc:identifier>
</item>
<item>
<title>SpringCloud 源码系列（4）—— 负载均衡 Ribbon - bojiangzhou</title>
<link>http://www.cnblogs.com/chiangchou/p/ribbon-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiangchou/p/ribbon-1.html</guid>
<description>&lt;p&gt;深入研究 Ribbon 负载均衡的核心原理，RestTemplate 如何具备负载均衡的能力，以及 Ribbon 核心接口特性等。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;664&quot;&gt;
&lt;h2&gt;一、负载均衡&lt;/h2&gt;
&lt;h3&gt;1、RestTemplate&lt;/h3&gt;
&lt;p&gt;在研究 eureka 源码上篇中，我们在 demo-consumer 消费者服务中定义了用 @LoadBalanced 标记的 RestTemplate，然后使用 RestTemplate 通过服务名的形式来调用远程服务 demo-producer，然后请求会轮询到两个 demo-producer 实例上。&lt;/p&gt;
&lt;p&gt;RestTemplate 是 Spring Resources 中一个访问第三方 RESTful API 接口的网络请求框架。RestTemplate 是用来消费 REST 服务的，所以 RestTemplate 的主要方法都与 REST 的 Http协议的一些方法紧密相连，例如 HEAD、GET、POST、PUT、DELETE 和 OPTIONS 等方法，这些方法在 RestTemplate 类对应的方法为 headForHeaders()、getForObject()、postForObject()、put() 和 delete() 等。&lt;/p&gt;
&lt;p&gt;RestTemplate 本身是不具备负载均衡的能力的，如果 RestTemplate 未使用 @LoadBalanced 标记，就通过服务名的形式来调用，必然会报错。用 @LoadBalanced 标记后，调用 RestTemplate 的 REST 方法就会通过负载均衡的方式通过一定的策略路由到某个服务实例上，底层负责负载均衡的组件就是 Ribbon。后面我们再来看 @LoadBalanced 是如何让 RestTemplate 具备负载均衡的能力的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerApplication {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @LoadBalanced
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         SpringApplication.run(ConsumerApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger =&lt;span&gt; LoggerFactory.getLogger(getClass());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     @GetMapping(&quot;/v1/id&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;String&amp;gt;&lt;span&gt; getId() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         ResponseEntity&amp;lt;String&amp;gt; result = restTemplate.getForEntity(&quot;http://demo-producer/v1/uuid&quot;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         String uuid =&lt;span&gt; result.getBody();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         logger.info(&quot;request id: {}&quot;&lt;span&gt;, uuid);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResponseEntity.ok(uuid);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、Ribbon 与负载均衡&lt;/h3&gt;
&lt;p&gt;① 负载均衡&lt;/p&gt;
&lt;p&gt;负载均衡是指将负载分摊到多个执行单元上，负载均衡主要可以分为集中式负载均衡与进程内负载均衡：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集中式负载均衡指位于因特网与执行单元之间，并负责把网络请求转发到各个执行单元上，比如 Nginx、F5。集中式负载均衡也可以称为服务端负载均衡。&lt;/li&gt;
&lt;li&gt;进程内负载均衡是将负载均衡逻辑集成到客户端上，客户端维护了一份服务提供者的实例列表，实例列表一般会从注册中心比如 Eureka 中获取。有了实例列表，就可以通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。进程内负载均衡一般也称为客户端负载均衡。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ribbon 是一个客户端负载均衡器，可以很好地控制 HTTP 和 TCP 客户端的负载均衡行为。Ribbon 是 Netflix 公司开源的一个负载均衡组件，已经整合到 SpringCloud 生态中，它在 Spring Cloud 生态内是一个不可缺少的组件，少了它，服务便不能横向扩展。&lt;/p&gt;
&lt;p&gt;② Ribbon 模块&lt;/p&gt;
&lt;p&gt;Ribbon 有很多子模块，官方文档中说明，目前 Netflix 公司主要用于生产环境的 Ribbon 子模块如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ribbon-loadbalancer：可以独立使用或与其他模块一起使用的负载均衡器 API。&lt;/li&gt;
&lt;li&gt;ribbon-eureka：Ribbon 结合 Eureka 客户端的 API，为负载均衡器提供动态服务注册列表信息。&lt;/li&gt;
&lt;li&gt;ribbon-core：Ribbon 的核心API。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201211104128888-78357727.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ springcloud 与 ribbon 整合&lt;/p&gt;
&lt;p&gt;与 eureka 整合到 springcloud 类似，springcloud 提供了对应的 spring-cloud-starter-netflix-eureka-client(server) 依赖包，ribbon 则整合到了 spring-cloud-starter-netflix-ribbon 中。一般也不需要单独引入 ribbon 的依赖包，spring-cloud-starter-netflix-eureka-client 中已经依赖了 spring-cloud-starter-netflix-ribbon。因此我们引入了 spring-cloud-starter-netflix-eureka-client 就可以使用 Ribbon 的功能了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201210154234989-2083153458.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④ Ribbon 与 RestTemplate 整合使用&lt;/p&gt;
&lt;p&gt;在 Spring Cloud 构建的微服务系统中，Ribbon 作为服务消费者的负载均衡器，有两种使用方式，一种是和 RestTemplate 相结合，另一种是和 Feign 相结合。前面已经演示了带有负载均衡的 RestTemplate 的使用，下面用一张图来看看 RestTemplate 基于 Ribbon 的远程调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201210161132350-70457225.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、RestTemplate 负载均衡&lt;/h2&gt;
&lt;h3&gt;1、@LoadBalanced 注解&lt;/h3&gt;
&lt;p&gt;以 RestTemplate 为切入点，来看 Ribbon 的负载均衡核心原理。那么首先就要先看看 @LoadBalanced 注解如何让 RestTemplate 具备负载均衡的能力了。&lt;/p&gt;
&lt;p&gt;首先看 @LoadBalanced 这个注解的定义，可以得到如下信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个注解使用 @Qualifier 标记，其它地方就可以注入 LoadBalanced 注解的 bean 对象。&lt;/li&gt;
&lt;li&gt;从注释中可以了解到，@LoadBalanced 标记的 RestTemplate 或 WebClient 将使用 LoadBalancerClient 来配置 bean 对象。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Annotation to mark a RestTemplate or WebClient bean to be configured to use a LoadBalancerClient.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Spencer Gibb
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Inherited
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Qualifier
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; LoadBalanced {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意 @LoadBalanced 是 spring-cloud-commons 模块下 loadbalancer 包下的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201211103801082-786294042.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、RestTemplate  负载均衡自动化配置&lt;/h3&gt;
&lt;p&gt;在 @LoadBalanced 同包下，有一个 LoadBalancerAutoConfiguration 自动化配置类，从注释也可以看出，这是客户端负载均衡 Ribbon 的自动化配置类。&lt;/p&gt;
&lt;p&gt;从这个自动化配置类可以得到如下信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先要有 RestTemplate 的依赖和定义了 LoadBalancerClient 对象的前提下才会触发这个自动化配置类，这也对应了前面，RestTemplate 要用 LoadBalancerClient  来配置。&lt;/li&gt;
&lt;li&gt;接着可以看到这个类注入了带有 @LoadBalanced 标识的 RestTemplate 对象，就是要对这部分对象增加负载均衡的能力。&lt;/li&gt;
&lt;li&gt;从 SmartInitializingSingleton 的构造中可以看到，就是在 bean 初始化完成后，用 RestTemplateCustomizer 定制化 RestTemplate。&lt;/li&gt;
&lt;li&gt;再往下可以看到，RestTemplateCustomizer 其实就是向 RestTemplate 中添加了 LoadBalancerInterceptor 这个拦截器。&lt;/li&gt;
&lt;li&gt;而 LoadBalancerInterceptor 的构建又需要 LoadBalancerClient 和 LoadBalancerRequestFactory，LoadBalancerRequestFactory 则通过 LoadBalancerClient 和 LoadBalancerRequestTransformer 构造完成。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Auto-configuration for Ribbon (client-side load balancing).
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; @ConditionalOnClass(RestTemplate.&lt;span&gt;class&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有 RestTemplate 的依赖&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; @ConditionalOnBean(LoadBalancerClient.&lt;span&gt;class&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义了 LoadBalancerClient 的 bean 对象&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @EnableConfigurationProperties(LoadBalancerRetryProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerAutoConfiguration {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注入 @LoadBalanced 标记的 RestTemplate 对象&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @LoadBalanced
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;RestTemplate&amp;gt; restTemplates =&lt;span&gt; Collections.emptyList();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;LoadBalancerRequestTransformer&amp;gt; transformers =&lt;span&gt; Collections.emptyList();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SmartInitializingSingleton loadBalancedRestTemplateInitializerDeprecated(
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; ObjectProvider&amp;lt;List&amp;lt;RestTemplateCustomizer&amp;gt;&amp;gt;&lt;span&gt; restTemplateCustomizers) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; () -&amp;gt; restTemplateCustomizers.ifAvailable(customizers -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (RestTemplate restTemplate : LoadBalancerAutoConfiguration.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.restTemplates) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RestTemplateCustomizer customizer : customizers) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用 RestTemplateCustomizer 定制化 restTemplate&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    customizer.customize(restTemplate);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerRequestFactory loadBalancerRequestFactory(
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            LoadBalancerClient loadBalancerClient) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LoadBalancerRequestFactory(loadBalancerClient, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.transformers);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptorConfig {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 LoadBalancerInterceptor 需要 LoadBalancerClient 和 LoadBalancerRequestFactory&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor ribbonInterceptor(
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                LoadBalancerClient loadBalancerClient,
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                LoadBalancerRequestFactory requestFactory) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor(loadBalancerClient, requestFactory);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplateCustomizer restTemplateCustomizer(
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;final&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor loadBalancerInterceptor) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; restTemplate -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 List&amp;lt;ClientHttpRequestInterceptor&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                        restTemplate.getInterceptors());
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向 restTemplate 添加 LoadBalancerInterceptor 拦截器&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                list.add(loadBalancerInterceptor);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                restTemplate.setInterceptors(list);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、RestTemplate 拦截器 LoadBalancerInterceptor&lt;/h3&gt;
&lt;p&gt;LoadBalancerAutoConfiguration 自动化配置主要就是给 RestTemplate 添加了一个负载均衡拦截器 LoadBalancerInterceptor。从 setInterceptors 的参数可以看出，拦截器的类型是 ClientHttpRequestInterceptor，如果我们想定制化 RestTemplate，就可以实现这个接口来定制化，然后还可以用 @Order 标记拦截器的先后顺序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setInterceptors(List&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt; interceptors) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.interceptors !=&lt;span&gt; interceptors) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interceptors.clear();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interceptors.addAll(interceptors);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 @Order 注解的顺序排序&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         AnnotationAwareOrderComparator.sort(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interceptors);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;interceptors 拦截器是在 RestTemplate 的父类 InterceptingHttpAccessor 中的， RestTemplate 的类结构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201211115801109-1362148308.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 restTemplate.getForEntity(&quot;http://demo-producer/v1/uuid&quot;, String.class) 这个GET请求进去看看，是如何使用 LoadBalancerInterceptor 的。一步步进去，可以看到最终是进入到 doExecute 这个方法了。&lt;/p&gt;
&lt;p&gt;在 doExecute 方法中，首先根据 url、method 创建一个 ClientHttpRequest，然后利用 ClientHttpRequest 来发起请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         @Nullable ResponseExtractor&amp;lt;T&amp;gt; responseExtractor) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     ClientHttpResponse response = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个 ClientHttpRequest&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         ClientHttpRequest request =&lt;span&gt; createRequest(url, method);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (requestCallback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            requestCallback.doWithRequest(request);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 ClientHttpRequest 的 execute() 方法&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         response =&lt;span&gt; request.execute();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理返回结果&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        handleResponse(url, method, response);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (responseExtractor != &lt;span&gt;null&lt;/span&gt; ? responseExtractor.extractData(response) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (response != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            response.close();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//////////////////////////////////////
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; ClientHttpRequest createRequest(URI url, HttpMethod method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     ClientHttpRequest request =&lt;span&gt; getRequestFactory().createRequest(url, method);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    initialize(request);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         logger.debug(&quot;HTTP &quot; + method.name() + &quot; &quot; +&lt;span&gt; url);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; request;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InterceptingHttpAccessor 中重写了父类 HttpAccessor 的 getRequestFactory 方法，父类默认的 requestFactory 是 SimpleClientHttpRequestFactory。&lt;/p&gt;
&lt;p&gt;重写后的 getRequestFactory 方法中，如果拦截器不为空，则基于父类默认的 SimpleClientHttpRequestFactory 和拦截器创建了 InterceptingClientHttpRequestFactory。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ClientHttpRequestFactory getRequestFactory() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     List&amp;lt;ClientHttpRequestInterceptor&amp;gt; interceptors =&lt;span&gt; getInterceptors();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;CollectionUtils.isEmpty(interceptors)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         ClientHttpRequestFactory factory = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interceptingRequestFactory;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (factory == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入 SimpleClientHttpRequestFactory 和 ClientHttpRequestInterceptor 拦截器&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             factory = &lt;span&gt;new&lt;/span&gt; InterceptingClientHttpRequestFactory(&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getRequestFactory(), interceptors);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.interceptingRequestFactory =&lt;span&gt; factory;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getRequestFactory();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说调用了 InterceptingClientHttpRequestFactory 的 createRequest 方法来创建 ClientHttpRequest。进去可以看到，ClientHttpRequest 的实际类型就是 InterceptingClientHttpRequest。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod, ClientHttpRequestFactory requestFactory) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InterceptingClientHttpRequest(requestFactory, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interceptors, uri, httpMethod);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InterceptingClientHttpRequest 的类结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201211145750724-2039774128.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RestTemplate 的 doExecute 中调用 request.execute() 其实是调用了 InterceptingClientHttpRequest 父类 AbstractClientHttpRequest 中的 execute 方法。一步步进去可以发现最终其实是调用了 InterceptingClientHttpRequest 的 executeInternal 方法。&lt;/p&gt;
&lt;p&gt;在 InterceptingClientHttpRequest  的 executeInternal 方法中，创建了 InterceptingRequestExecution 来执行请求。在 InterceptingRequestExecution 的 execute 方法中，会先遍历执行所有拦截器，然后通过 ClientHttpRequest 发起真正的 http 请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ClientHttpResponse executeInternal(HttpHeaders headers, &lt;span&gt;byte&lt;/span&gt;[] bufferedOutput) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 InterceptingRequestExecution&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     InterceptingRequestExecution requestExecution = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterceptingRequestExecution();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求调用&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; requestExecution.execute(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, bufferedOutput);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptingRequestExecution &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ClientHttpRequestExecution {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt; iterator;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; InterceptingRequestExecution() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拦截器迭代器&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.iterator =&lt;span&gt; interceptors.iterator();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ClientHttpResponse execute(HttpRequest request, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.hasNext()) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             ClientHttpRequestInterceptor nextInterceptor = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.next();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用拦截器拦截处理，并传入 InterceptingRequestExecution&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; nextInterceptor.intercept(request, body, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拦截器遍历完后开始发起真正的 http 请求&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             HttpMethod method =&lt;span&gt; request.getMethod();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             Assert.state(method != &lt;span&gt;null&lt;/span&gt;, &quot;No standard HTTP method&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             ClientHttpRequest delegate =&lt;span&gt; requestFactory.createRequest(request.getURI(), method);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             request.getHeaders().forEach((key, value) -&amp;gt;&lt;span&gt; delegate.getHeaders().addAll(key, value));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (body.length &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (delegate &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; StreamingHttpOutputMessage) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     StreamingHttpOutputMessage streamingOutputMessage =&lt;span&gt; (StreamingHttpOutputMessage) delegate;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     streamingOutputMessage.setBody(outputStream -&amp;gt;&lt;span&gt; StreamUtils.copy(body, outputStream));
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    StreamUtils.copy(body, delegate.getBody());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.execute();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入到 LoadBalancerInterceptor 的 intercept 拦截方法内，可以看到从请求的原始地址中获取了服务名称，然后调用了 loadBalancer 的 execute 方法，也就是 LoadBalancerClient。&lt;/p&gt;
&lt;p&gt;到这里，其实已经可以想象，loadBalancer.execute 这行代码就是根据服务名称去获取一个具体的实例，然后将原始地址替换为实例的IP地址。那这个 loadBalancer 又是什么呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ClientHttpResponse intercept(&lt;span&gt;final&lt;/span&gt; HttpRequest request, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] body, &lt;span&gt;final&lt;/span&gt; ClientHttpRequestExecution execution) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原始地址：&lt;/span&gt;&lt;span&gt;http://demo-producer/v1/uuid&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; URI originalUri =&lt;span&gt; request.getURI();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; host 就是服务名：demo-producer&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     String serviceName =&lt;span&gt; originalUri.getHost();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Assert.state(serviceName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &quot;Request URI does not contain a valid hostname: &quot; +&lt;span&gt; originalUri);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.loadBalancer.execute(serviceName,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestFactory.createRequest(request, body, execution));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、负载均衡客户端 LoadBalancerClient&lt;/h3&gt;
&lt;p&gt;在配置 LoadBalancerInterceptor 时，需要两个参数，LoadBalancerClient 和 LoadBalancerRequestFactory，LoadBalancerRequestFactory前面已经知道是如何创建的了。LoadBalancerClient 又是在哪创建的呢？通过 IDEA 搜索，可以发现是在 spring-cloud-netflix-ribbon 模块下的 RibbonAutoConfiguration 中配置的，可以看到 LoadBalancerClient 的实际类型是 RibbonLoadBalancerClient。&lt;/p&gt;
&lt;p&gt;配置类的顺序是 EurekaClientAutoConfiguration、RibbonAutoConfiguration、LoadBalancerAutoConfiguration，因为使 RestTemplate 具备负载均衡的能力需要 LoadBalancerInterceptor 拦截器，创建 LoadBalancerInterceptor 又需要 LoadBalancerClient，而 LoadBalancerClient 底层要根据服务名获取某个实例，肯定又需要一个实例库，比如从配置文件、注册中心获取。从这里就可以看出来，RibbonLoadBalancerClient 默认会从 Eureka 注册中心获取实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @Conditional(RibbonAutoConfiguration.RibbonClassesConditions.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@RibbonClients
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后于 EurekaClientAutoConfiguration 配置&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; @AutoConfigureAfter(name = &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先于 LoadBalancerAutoConfiguration 配置&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @AutoConfigureBefore({ LoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;,    AsyncLoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; @EnableConfigurationProperties({ RibbonEagerLoadProperties.&lt;span&gt;class&lt;/span&gt;, ServerIntrospectorProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonAutoConfiguration {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;RibbonClientSpecification&amp;gt; configurations = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SpringClientFactory springClientFactory() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         SpringClientFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringClientFactory();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         factory.setConfigurations(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.configurations);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     @ConditionalOnMissingBean(LoadBalancerClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerClient loadBalancerClient() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonLoadBalancerClient(springClientFactory());
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LoadBalancerClient 主要提供了三个接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; LoadBalancerClient &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ServiceInstanceChooser {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 LoadBalancer 找一个 Server 来发送请求&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;T&amp;gt; T execute(String serviceId, LoadBalancerRequest&amp;lt;T&amp;gt; request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从传入的 ServiceInstance 取 Server 来发送请求  &lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;T&amp;gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&amp;lt;T&amp;gt; request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对原始 URI 重构&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    URI reconstructURI(ServiceInstance instance, URI original);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;进入到 RibbonLoadBalancerClient 的 execute 方法中可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先根据服务名获取服务对应的负载均衡器 ILoadBalancer。&lt;/li&gt;
&lt;li&gt;然后从 ILoadBalancer 中根据一定策略选出一个实例 Server。&lt;/li&gt;
&lt;li&gt;然后将 server、serviceId 等信息封装到 RibbonServer 中，也就是一个服务实例 ServiceInstance。&lt;/li&gt;
&lt;li&gt;最后调用了 LoadBalancerRequest 的 apply，并传入 ServiceInstance，将地址中的服务名替换为真实的IP地址。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T execute(String serviceId, LoadBalancerRequest&amp;lt;T&amp;gt; request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; execute(serviceId, request, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T execute(String serviceId, LoadBalancerRequest&amp;lt;T&amp;gt;&lt;span&gt; request, Object hint)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据服务名获取一个负载均衡器 ILoadBalancer&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     ILoadBalancer loadBalancer =&lt;span&gt; getLoadBalancer(serviceId);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用负载均衡器获取实例 Server&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     Server server =&lt;span&gt; getServer(loadBalancer, hint);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;No instances available for &quot; +&lt;span&gt; serviceId);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装实例信息：RibbonServer 的父类是 ServiceInstance&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     RibbonServer ribbonServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonServer(serviceId, server,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            isSecure(server, serviceId),
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            serverIntrospector(serviceId).getMetadata(server));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; execute(serviceId, ribbonServer, request);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T execute(String serviceId, ServiceInstance serviceInstance,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         LoadBalancerRequest&amp;lt;T&amp;gt; request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     Server server = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (serviceInstance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RibbonServer) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         server =&lt;span&gt; ((RibbonServer) serviceInstance).getServer();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;No instances available for &quot; +&lt;span&gt; serviceId);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理地址，将服务名替换为真实的IP地址&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         T returnVal =&lt;span&gt; request.apply(serviceInstance);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnVal;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个 LoadBalancerRequest 其实就是 LoadBalancerInterceptor 的 intercept 中创建的一个匿名类，在它的函数式接口内，主要是用装饰器 ServiceRequestWrapper 将 request 包了一层。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; LoadBalancerRequest&amp;lt;ClientHttpResponse&amp;gt; createRequest(&lt;span&gt;final&lt;/span&gt; HttpRequest request, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] body, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ClientHttpRequestExecution execution) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; instance -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装 HttpRequest，ServiceRequestWrapper 重载了 getURI 方法。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         HttpRequest serviceRequest = &lt;span&gt;new&lt;/span&gt; ServiceRequestWrapper(request, instance, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.loadBalancer);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.transformers != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (LoadBalancerRequestTransformer transformer : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.transformers) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 serviceRequest =&lt;span&gt; transformer.transformRequest(serviceRequest, instance);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续执行拦截器&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; execution.execute(serviceRequest, body);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServiceRequestWrapper 主要就是重写了 getURI 方法，在重写的 getURI 方法内，它用 loadBalancer 对 URI 进行了重构，进去可以发现，就是将原始地址中的服务名替换为 Server 的真实IP、端口地址。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; URI getURI() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重构 URI&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     URI uri = &lt;span&gt;this&lt;/span&gt;.loadBalancer.reconstructURI(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.instance, getRequest().getURI());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uri;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; URI reconstructURI(ServiceInstance instance, URI original) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Assert.notNull(instance, &quot;instance can not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 服务名&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     String serviceId =&lt;span&gt; instance.getServiceId();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     RibbonLoadBalancerContext context = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientFactory.getLoadBalancerContext(serviceId);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    URI uri;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    Server server;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (instance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RibbonServer) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         RibbonServer ribbonServer =&lt;span&gt; (RibbonServer) instance;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         server =&lt;span&gt; ribbonServer.getServer();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         uri =&lt;span&gt; updateToSecureConnectionIfNeeded(original, ribbonServer);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         server = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Server(instance.getScheme(), instance.getHost(), instance.getPort());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         IClientConfig clientConfig =&lt;span&gt; clientFactory.getClientConfig(serviceId);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         ServerIntrospector serverIntrospector =&lt;span&gt; serverIntrospector(serviceId);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         uri =&lt;span&gt; updateToSecureConnectionIfNeeded(original, clientConfig, serverIntrospector, server);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重构地址&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; context.reconstructURIWithServer(server, uri);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reconstructURIWithServer：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_ed14d2b7-360a-4bfd-a46b-88286c7edd70&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_ed14d2b7-360a-4bfd-a46b-88286c7edd70&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ed14d2b7-360a-4bfd-a46b-88286c7edd70&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; URI reconstructURIWithServer(Server server, URI original) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     String host =&lt;span&gt; server.getHost();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; port =&lt;span&gt; server.getPort();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     String scheme =&lt;span&gt; server.getScheme();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (host.equals(original.getHost()) 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &amp;amp;&amp;amp; port ==&lt;span&gt; original.getPort()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &amp;amp;&amp;amp; scheme ==&lt;span&gt; original.getScheme()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; original;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (scheme == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         scheme =&lt;span&gt; original.getScheme();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (scheme == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         scheme =&lt;span&gt; deriveSchemeAndPortFromPartialUri(original).first();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         StringBuilder sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         sb.append(scheme).append(&quot;://&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Strings.isNullOrEmpty(original.getRawUserInfo())) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             sb.append(original.getRawUserInfo()).append(&quot;@&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        sb.append(host);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (port &amp;gt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             sb.append(&quot;:&quot;&lt;span&gt;).append(port);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        sb.append(original.getRawPath());
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Strings.isNullOrEmpty(original.getRawQuery())) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             sb.append(&quot;?&quot;&lt;span&gt;).append(original.getRawQuery());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Strings.isNullOrEmpty(original.getRawFragment())) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             sb.append(&quot;#&quot;&lt;span&gt;).append(original.getRawFragment());
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         URI newURI = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URI(sb.toString());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newURI;            
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (URISyntaxException e) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;5、RestTemplate 负载均衡总结&lt;/h3&gt;
&lt;p&gt;到这里，我们基本就弄清楚了一个简单的 @LoadBalanced 注解如何让 RestTemplate 具备了负载均衡的能力了，这一节来做个小结。&lt;/p&gt;
&lt;p&gt;① RestTemplate 如何获得负载均衡的能力&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）首先 RestTemplate 是 spring-web 模块下一个访问第三方 RESTful API 接口的网络请求框架&lt;/li&gt;
&lt;li&gt;2）在 spring cloud 微服务架构中，用 @LoadBalanced 对 RestTemplate 做个标记，就可以使 RestTemplate 具备负载均衡的能力&lt;/li&gt;
&lt;li&gt;3）使 RestTemplate 具备负载均衡的核心组件就是 LoadBalancerAutoConfiguration 配置类中向其添加的 LoadBalancerInterceptor 负载均衡拦截器&lt;/li&gt;
&lt;li&gt;4）RestTemplate 在发起 http 调用前，会遍历所有拦截器来对 RestTemplate 定制化，LoadBalancerInterceptor 就是在这时将URI中的服务名替换为实例的真实IP地址。定制完成后，就会发起真正的 http 请求。&lt;/li&gt;
&lt;li&gt;5）LoadBalancerInterceptor 又主要是使用负载均衡客户端 LoadBalancerClient 来完成URI的重构的，LoadBalancerClient 就可以根据服务名查找一个可用的实例，然后重构URI。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;② 核心组件&lt;/p&gt;
&lt;p&gt;这里会涉及多个模块，下面是核心组件的所属模块：&lt;/p&gt;
&lt;p&gt;spring-web：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RestTemplate&lt;/li&gt;
&lt;li&gt;InterceptingClientHttpRequest：执行拦截器，并发起最终http调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;spring-cloud-commons：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@LoadBalanced&lt;/li&gt;
&lt;li&gt;LoadBalancerAutoConfiguration&lt;/li&gt;
&lt;li&gt;LoadBalancerRequestFactory：创建装饰类 ServiceRequestWrapper 替换原来的 HttpRequest，重载 getURI 方法。&lt;/li&gt;
&lt;li&gt;LoadBalancerInterceptor：负载均衡拦截器&lt;/li&gt;
&lt;li&gt;LoadBalancerClient：负载均衡客户端接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;spring-cloud-netflix-ribbon：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RibbonLoadBalancerClient：LoadBalancerClient 的实现类，Ribbon 的负载均衡客户端&lt;/li&gt;
&lt;li&gt;RibbonAutoConfiguration&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ribbon-loadbalancer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ILoadBalancer：负载均衡器&lt;/li&gt;
&lt;li&gt;Server：实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;③ 最后再用一张图把 RestTemplate 这块的关系捋一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201213173012493-1028244863.png&quot; alt=&quot;&quot; width=&quot;1661&quot; height=&quot;976&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、ILoadBalancer 获取 Server&lt;/h2&gt;
&lt;p&gt;从前面 RestTemplate 那张图可以看出，使 RestTemplate 具备负载均衡的能力，最重要的一个组件之一就是 ILoadBalancer，因为要用它来获取能调用的 Server，有了 Server 才能对原始带有服务名的 URI 进行重构。这节就来看下 Ribbon 的负载均衡器 ILoadBalancer 是如何创建的以及如何通过它获取 Server。&lt;/p&gt;
&lt;h3&gt;1、创建负载均衡器 ILoadBalancer&lt;/h3&gt;
&lt;p&gt;① SpringClientFactory与上下文&lt;/p&gt;
&lt;p&gt;ILoadBalancer 是用 SpringClientFactory 的 getLoadBalancer 方法根据服务名获取的，从 getInstance 一步步进去可以发现，每个服务都会创建一个 AnnotationConfigApplicationContext，也就是一个应用上下文 ApplicationContext。相当于就是一个服务绑定一个 ILoadBalancer。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;C&amp;gt; C getInstance(String name, Class&amp;lt;C&amp;gt;&lt;span&gt; type) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     C instance = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getInstance(name, type);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (instance != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     IClientConfig config = getInstance(name, IClientConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instantiateWithConfig(getContext(name), type, config);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getInstance(String name, Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据名称获取&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     AnnotationConfigApplicationContext context =&lt;span&gt; getContext(name);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context, type).length &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; context.getBean(type);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AnnotationConfigApplicationContext getContext(String name) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; contexts =&amp;gt; Map&amp;lt;String, AnnotationConfigApplicationContext&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contexts.containsKey(name)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contexts) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contexts.containsKey(name)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contexts.put(name, createContext(name));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contexts.get(name);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调试看下 AnnotationConfigApplicationContext 上下文，可以看到放入了与这个服务绑定的 ILoadBalancer、IClientConfig、RibbonLoadBalancerContext 等。&lt;/p&gt;
&lt;p&gt;它这里为什么要每个服务都绑定一个 ApplicationContext 呢？我猜想应该是因为服务实例列表可以有多个来源，比如可以从 eureka 注册中心获取、可以通过代码配置、可以通过配置文件配置，另外每个服务还可以有很多个性化的配置，有默认的配置、定制的全局配置、个别服务的特定配置等，它这样做就便于用户定制每个服务的负载均衡策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201213181808005-2030427626.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② Ribbon的饥饿加载&lt;/p&gt;
&lt;p&gt;而且这个Ribbon客户端的应用上下文默认是懒加载的，并不是在启动的时候就加载上下文，而是在第一次调用的时候才会去初始化。&lt;/p&gt;
&lt;p&gt;如果想服务启动时就初始化，可以指定Ribbon客户端的具体名称，在启动的时候就加载配置项的上下文：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;ribbon:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   eager-&lt;span&gt;load:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     enabled: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     clients: demo-producer,demo-xxx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ RibbonClientConfiguration&lt;/p&gt;
&lt;p&gt;ILoadBalancer 的创建在哪呢？看 RibbonClientConfiguration，这个配置类提供了 ILoadBalancer 的默认创建方法，ILoadBalancer 的默认实现类为 ZoneAwareLoadBalancer。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonClientConfiguration {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECT_TIMEOUT = 1000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_READ_TIMEOUT = 1000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; DEFAULT_GZIP_PAYLOAD = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @RibbonClientName
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String name = &quot;client&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PropertiesFactory propertiesFactory;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IClientConfig ribbonClientConfig() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         DefaultClientConfigImpl config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultClientConfigImpl();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         config.loadProperties(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule ribbonRule(IClientConfig config) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(IRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(IRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         ZoneAvoidanceRule rule = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZoneAvoidanceRule();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        rule.initWithNiwsConfig(config);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rule;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IPing ribbonPing(IClientConfig config) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(IPing.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(IPing.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DummyPing();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ServerList&amp;lt;Server&amp;gt;&lt;span&gt; ribbonServerList(IClientConfig config) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ServerList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ServerList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         ConfigurationBasedServerList serverList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBasedServerList();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        serverList.initWithNiwsConfig(config);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; serverList;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServerListUpdater ribbonServerListUpdater(IClientConfig config) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PollingServerListUpdater(config);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ServerListFilter&amp;lt;Server&amp;gt;&lt;span&gt; ribbonServerListFilter(IClientConfig config) {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ServerListFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ServerListFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         ZonePreferenceServerListFilter filter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZonePreferenceServerListFilter();
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        filter.initWithNiwsConfig(config);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; filter;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ILoadBalancer ribbonLoadBalancer(IClientConfig config,
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;             ServerList&amp;lt;Server&amp;gt; serverList, ServerListFilter&amp;lt;Server&amp;gt;&lt;span&gt; serverListFilter,
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;            IRule rule, IPing ping, ServerListUpdater serverListUpdater) {
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先判断配置文件中是否配置了负载均衡器&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ILoadBalancer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过反射创建&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ILoadBalancer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ZoneAwareLoadBalancer&amp;lt;&amp;gt;&lt;span&gt;(config, rule, ping, serverList,
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;                serverListFilter, serverListUpdater);
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到创建 ILoadBalancer 需要 IClientConfig、ServerList&amp;lt;Server&amp;gt;、ServerListFilter&amp;lt;Server&amp;gt;、IRule、IPing、ServerListUpdater，其实这6个接口加上 ILoadBalancer 就是 Ribbon 的核心接口，它们共同定义了 Ribbon 的行为特性。&lt;/p&gt;
&lt;p&gt;这7个核心接口和默认实现类如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201213184838393-167017566.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、客户端 Ribbon 定制&lt;/h3&gt;
&lt;p&gt;可以看到在 RibbonClientConfiguration 中创建 IRule、IPing、ServerList&amp;lt;Server&amp;gt;、ServerListFilter&amp;lt;Server&amp;gt;、ILoadBalancer 时，都先通过 propertiesFactory.isSet 判断是否已配置了对应类型的实现类，没有才使用默认的实现类。&lt;/p&gt;
&lt;p&gt;也就是说针对特定的服务，这几个类可以自行定制化，也可以通过配置指定其它的实现类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201213185516288-1021170746.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 全局策略配置&lt;/p&gt;
&lt;p&gt;如果想要全局更改配置，需要加一个配置类，比如像下面这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GlobalRibbonConfiguration {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule ribbonRule() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RandomRule();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IPing ribbonPing() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoOpPing();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 基于注解的配置&lt;/p&gt;
&lt;p&gt;如果想针对某一个服务定制配置，可以通过 @RibbonClients 来配置特定服务的配置类。&lt;/p&gt;
&lt;p&gt;需要先定义一个服务配置类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProducerRibbonConfiguration {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule ribbonRule() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RandomRule();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IPing ribbonPing() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoOpPing();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用 @RibbonClients 注解为服务指定特定的配置类，并排除掉，不让 Spring 扫描，否则就变成了全局配置了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@RibbonClients({
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     @RibbonClient(name = &quot;demo-producer&quot;, configuration = ProducerRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; @ComponentScan(excludeFilters =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = ProducerRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 配置文件配置&lt;/p&gt;
&lt;p&gt;通过配置文件的方式来配置，配置的格式就是 &amp;lt;服务名称&amp;gt;.ribbon.&amp;lt;属性&amp;gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; demo-&lt;span&gt;producer:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  ribbon:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    # ILoadBalancer
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    NFLoadBalancerClassName: com.netflix.loadbalancer.NoOpLoadBalancer
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    # IRule
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    # IPing
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    NFLoadBalancerPingClassName:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     # ServerList&amp;lt;Server&amp;gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    NIWSServerListClassName:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     # ServerListFilter&amp;lt;Server&amp;gt;
&lt;span&gt;12&lt;/span&gt;     NIWSServerListFilterClassName:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 优先级顺序&lt;/p&gt;
&lt;p&gt;这几种配置方式的优先级顺序是 配置文件配置 &amp;gt; @RibbonClients 配置 &amp;gt; 全局配置 &amp;gt; 默认配置。&lt;/p&gt;
&lt;h3&gt;3、ZoneAwareLoadBalancer 选择 Server&lt;/h3&gt;
&lt;p&gt;获取到 ILoadBalancer 后，就要去获取 Server 了，可以看到，就是用 ILoadBalancer 来获取 Server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Server getServer(ILoadBalancer loadBalancer, Object hint) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (loadBalancer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use 'default' on a null hint, or just pass it on?&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; loadBalancer.chooseServer(hint != &lt;span&gt;null&lt;/span&gt; ? hint : &quot;default&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ILoadBalancer  的默认实现类是 ZoneAwareLoadBalancer，进入它的 chooseServer 方法内，如果只配置了一个 zone，就走父类的 chooseServer，否则从多个 zone 中去选择实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server chooseServer(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ENABLED =&amp;gt; ZoneAwareNIWSDiscoveryLoadBalancer.enabled 默认 true
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AvailableZones 配置的只有一个 defaultZone&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!ENABLED.get() || getLoadBalancerStats().getAvailableZones().size() &amp;lt;= 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         logger.debug(&quot;Zone aware logic disabled or there is only one zone&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 走父类获取 Server 的逻辑&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.chooseServer(key);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多 zone 逻辑....&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看下 ZoneAwareLoadBalancer 的类继承结构，ZoneAwareLoadBalancer 的直接父类是 DynamicServerListLoadBalancer，DynamicServerListLoadBalancer 的父类又是 BaseLoadBalancer。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201215110125267-931853835.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ZoneAwareLoadBalancer 调用父类的 chooseServer 方法是在 BaseLoadBalancer 中的，进去可以看到，它主要是用 IRule 来选择实例，最终选择实例的策略就交给了 IRule 接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server chooseServer(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (counter == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         counter =&lt;span&gt; createCounter();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    counter.increment();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (rule == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IRule&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rule.choose(key);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             logger.warn(&quot;LoadBalancer [{}]:  Error choosing server for key {}&quot;&lt;span&gt;, name, key, e);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、ZoneAvoidanceRule 断言筛选、轮询选择 Server&lt;/h3&gt;
&lt;p&gt;IRule 的默认实现类是 ZoneAvoidanceRule，先看下 ZoneAvoidanceRule 的继承结构，ZoneAvoidanceRule 的直接父类是 PredicateBasedRule。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201215111847730-941911802.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;rule.choose 的逻辑在 PredicateBasedRule 中，getPredicate() 返回的是 ZoneAvoidanceRule 创建的一个组合断言 CompositePredicate，就是用这个断言来过滤出可用的 Server，并通过轮询的策略返回一个 Server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server choose(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     ILoadBalancer lb =&lt;span&gt; getLoadBalancer();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; getPredicate() Server断言 =&amp;gt; CompositePredicate
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RoundRobin 轮询方式获取实例&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     Optional&amp;lt;Server&amp;gt; server =&lt;span&gt; getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (server.isPresent()) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; server.get();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }       
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在初始化 ZoneAvoidanceRule 配置时，创建了 CompositePredicate，可以看到这个组合断言主要有两个断言，一个是断言 Server 的 zone 是否可用，一个断言 Server 本身是否可用，例如 Server 无法 ping 通。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initWithNiwsConfig(IClientConfig clientConfig) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 断言 Server 的 zone 是否可用，只有一个 defaultZone 的情况下都是可用的&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     ZoneAvoidancePredicate zonePredicate = &lt;span&gt;new&lt;/span&gt; ZoneAvoidancePredicate(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, clientConfig);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 断言 Server 是否可用&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     AvailabilityPredicate availabilityPredicate = &lt;span&gt;new&lt;/span&gt; AvailabilityPredicate(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, clientConfig);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装组合断言&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     compositePredicate =&lt;span&gt; createCompositePredicate(zonePredicate, availabilityPredicate);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CompositePredicate createCompositePredicate(ZoneAvoidancePredicate p1, AvailabilityPredicate p2) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建造者模式创建断言&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; CompositePredicate.withPredicates(p1, p2)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                         .addFallbackPredicate(p2)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                         .addFallbackPredicate(AbstractServerPredicate.alwaysTrue())
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                         .build();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看选择Server的 chooseRoundRobinAfterFiltering，参数 servers 是通过 ILoadBalancer 获取的所有实例，可以看到它其实就是返回了 ILoadBalancer 在内存中缓存的服务所有 Server。这个 Server 从哪来的我们后面再来看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; List&amp;lt;Server&amp;gt;&lt;span&gt; getAllServers() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; allServerList =&amp;gt; List&amp;lt;Server&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.unmodifiableList(allServerList);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先对所有实例通过断言过滤掉不可用的 Server，然后是通过轮询的方式获取一个 Server 返回。这就是默认配置下 ILoadBalancer（ZoneAwareLoadBalancer） 通过 IRule（ZoneAvoidanceRule） 选择 Server 的流程了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Optional&amp;lt;Server&amp;gt; chooseRoundRobinAfterFiltering(List&amp;lt;Server&amp;gt;&lt;span&gt; servers, Object loadBalancerKey) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 断言获取可用的 Server&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     List&amp;lt;Server&amp;gt; eligible =&lt;span&gt; getEligibleServers(servers, loadBalancerKey);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (eligible.size() == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Optional.absent();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过取模的方式轮询 Server&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; List&amp;lt;Server&amp;gt; getEligibleServers(List&amp;lt;Server&amp;gt;&lt;span&gt; servers, Object loadBalancerKey) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (loadBalancerKey == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; ImmutableList.copyOf(Iterables.filter(servers, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getServerOnlyPredicate()));            
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         List&amp;lt;Server&amp;gt; results =&lt;span&gt; Lists.newArrayList();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对每个 Server 断言&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Server server: servers) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.apply(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PredicateKey(loadBalancerKey, server))) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                results.add(server);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; results;            
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; incrementAndGetModulo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; modulo) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; current =&lt;span&gt; nextIndex.get();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模运算取余数&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; next = (current + 1) %&lt;span&gt; modulo;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS 更新 nextIndex&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (nextIndex.compareAndSet(current, next) &amp;amp;&amp;amp; current &amp;lt;&lt;span&gt; modulo)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、Ribbon 整合 Eureka Client 拉取Server列表&lt;/h2&gt;
&lt;p&gt;前面在通过 IRule 选择 Server 的时候，首先通过 lb.getAllServers() 获取了所有的 Server，那这些 Server 从哪里来的呢，这节就来看下。&lt;/p&gt;
&lt;h3&gt;1、ILoadBalancer 初始化&lt;/h3&gt;
&lt;p&gt;ILoadBalancer 的默认实现类是 ZoneAwareLoadBalancer，先从 ZoneAwareLoadBalancer 的构造方法进去看看都做了些什么事情。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ILoadBalancer ribbonLoadBalancer(IClientConfig config,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         ServerList&amp;lt;Server&amp;gt; serverList, ServerListFilter&amp;lt;Server&amp;gt;&lt;span&gt; serverListFilter,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        IRule rule, IPing ping, ServerListUpdater serverListUpdater) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ILoadBalancer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ILoadBalancer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ZoneAwareLoadBalancer&amp;lt;&amp;gt;&lt;span&gt;(config, rule, ping, serverList,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            serverListFilter, serverListUpdater);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，ZoneAwareLoadBalancer 直接调用了父类 DynamicServerListLoadBalancer 的构造方法，DynamicServerListLoadBalancer 先调用父类 BaseLoadBalancer 初始化，然后又做了一些剩余的初始化工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ZoneAwareLoadBalancer(IClientConfig clientConfig, IRule rule,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                              IPing ping, ServerList&amp;lt;T&amp;gt; serverList, ServerListFilter&amp;lt;T&amp;gt;&lt;span&gt; filter,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                             ServerListUpdater serverListUpdater) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DynamicServerListLoadBalancer&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(clientConfig, rule, ping, serverList, filter, serverListUpdater);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DynamicServerListLoadBalancer(IClientConfig clientConfig, IRule rule, IPing ping,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                                      ServerList&amp;lt;T&amp;gt; serverList, ServerListFilter&amp;lt;T&amp;gt;&lt;span&gt; filter,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                                     ServerListUpdater serverListUpdater) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BaseLoadBalancer&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(clientConfig, rule, ping);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.serverListImpl =&lt;span&gt; serverList;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.filter =&lt;span&gt; filter;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.serverListUpdater =&lt;span&gt; serverListUpdater;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (filter &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AbstractServerListFilter) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        ((AbstractServerListFilter) filter).setLoadBalancerStats(getLoadBalancerStats());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 剩余的一些初始化&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    restOfInit(clientConfig);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseLoadBalancer(IClientConfig config, IRule rule, IPing ping) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; createLoadBalancerStatsFromConfig =&amp;gt; LoadBalancerStats 统计&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    initWithConfig(config, rule, ping, createLoadBalancerStatsFromConfig(config));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看 BaseLoadBalancer 的 initWithConfig，主要做了如下的初始化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置 IPing 和 IRule，ping 的间隔时间是 30 秒，setPing 会启动一个后台定时任务，然后每隔30秒运行一次 PingTask 任务。&lt;/li&gt;
&lt;li&gt;设置了 ILoadBalancer 的 统计器 LoadBalancerStats，对 ILoadBalancer 的 Server 状态进行统计，比如连接失败、成功、熔断等信息。&lt;/li&gt;
&lt;li&gt;在启用 PrimeConnections 请求预热的情况下，创建 PrimeConnections 来预热客户端 与 Server 的链接。默认是关闭的。&lt;/li&gt;
&lt;li&gt;最后是注册了一些监控、开启请求预热。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initWithConfig(IClientConfig clientConfig, IRule rule, IPing ping, LoadBalancerStats stats) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.config =&lt;span&gt; clientConfig;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     String clientName =&lt;span&gt; clientConfig.getClientName();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; clientName;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ping 间隔时间，默认30秒&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; pingIntervalTime = Integer.parseInt(&quot;&quot;
&lt;span&gt; 7&lt;/span&gt;             +&lt;span&gt; clientConfig.getProperty(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    CommonClientConfigKey.NFLoadBalancerPingInterval,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     Integer.parseInt(&quot;30&quot;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没看到用的地方                &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; maxTotalPingTime = Integer.parseInt(&quot;&quot;
&lt;span&gt;12&lt;/span&gt;             +&lt;span&gt; clientConfig.getProperty(
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    CommonClientConfigKey.NFLoadBalancerMaxTotalPingTime,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     Integer.parseInt(&quot;2&quot;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 ping 间隔时间，并重新设置了 ping 任务&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    setPingInterval(pingIntervalTime);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    setMaxTotalPingTime(maxTotalPingTime);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 IRule、IPing&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    setRule(rule);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    setPing(ping);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    setLoadBalancerStats(stats);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     rule.setLoadBalancer(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ping &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AbstractLoadBalancerPing) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         ((AbstractLoadBalancerPing) ping).setLoadBalancer(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     logger.info(&quot;Client: {} instantiated a LoadBalancer: {}&quot;, name, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PrimeConnections，请求预热，默认关闭
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 作用主要用于解决那些部署环境(如读EC2)在实际使用实时请求之前，从防火墙连接/路径进行预热（比如先加白名单、初始化等等动作比较耗时，可以用它先去打通）。&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; enablePrimeConnections =&lt;span&gt; clientConfig.get(
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            CommonClientConfigKey.EnablePrimeConnections, DefaultClientConfigImpl.DEFAULT_ENABLE_PRIME_CONNECTIONS);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (enablePrimeConnections) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.setEnablePrimingConnections(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         PrimeConnections primeConnections = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrimeConnections(
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getName(), clientConfig);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setPrimeConnections(primeConnections);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册一些监控&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    init();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     Monitors.registerObject(&quot;LoadBalancer_&quot; + name, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; register the rule as it contains metric for available servers count&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     Monitors.registerObject(&quot;Rule_&quot; + name, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRule());
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认关闭&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (enablePrimingConnections &amp;amp;&amp;amp; primeConnections != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        primeConnections.primeConnections(getReachableServers());
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看下 DynamicServerListLoadBalancer 的初始化，核心的初始化逻辑在 restOfInit 中，主要就是做了两件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启动态更新 Server 的特性，比如实例上线、下线、故障等，要能够更新 ILoadBalancer 的 Server 列表。&lt;/li&gt;
&lt;li&gt;然后就全量更新一次本地的 Server 列表。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; restOfInit(IClientConfig clientConfig) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; primeConnection = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEnablePrimingConnections();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.setEnablePrimingConnections(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启动态更新 Server 的特性&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    enableAndInitLearnNewServersFeature();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新 Server 列表&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    updateListOfServers();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启请求预热的情况下，对可用的 Server 进行预热&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (primeConnection &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.getPrimeConnections() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getPrimeConnections()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                .primeConnections(getReachableServers());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setEnablePrimingConnections(primeConnection);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     LOGGER.info(&quot;DynamicServerListLoadBalancer for client {} initialized: {}&quot;, clientConfig.getClientName(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toString());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、全量更新Server列表&lt;/h3&gt;
&lt;p&gt;先看下 updateListOfServers() 是如何更新 Server 列表的，进而看下 ILoadBalancer 是如何存储 Server 的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先使用 ServerList 获取所有的 Server 列表，在 RibbonClientConfiguration 中配置的是 ConfigurationBasedServerList，但和 eureka 集合和，就不是 ConfigurationBasedServerList 了，这块下一节再来看。&lt;/li&gt;
&lt;li&gt;然后使用 ServerListFilter 对 Server 列表过滤，其默认实现类是 ZonePreferenceServerListFilter，它主要是过滤出当前 Zone（defaultZone）下的 Server。&lt;/li&gt;
&lt;li&gt;最后就是更新所有 Server 列表，先是设置 Server alive，然后调用父类（BaseLoadBalancer）的 setServersList 来更新Server列表，这说明 Server 是存储在 BaseLoadBalancer 里的。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateListOfServers() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     List&amp;lt;T&amp;gt; servers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;T&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (serverListImpl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 ServerList 获取所有 Server 列表&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         servers =&lt;span&gt; serverListImpl.getUpdatedListOfServers();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         LOGGER.debug(&quot;List of Servers for {} obtained from Discovery client: {}&quot;&lt;span&gt;, getIdentifier(), servers);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (filter != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用 ServerListFilter 过滤 Server&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             servers =&lt;span&gt; filter.getFilteredListOfServers(servers);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             LOGGER.debug(&quot;Filtered List of Servers for {} obtained from Discovery client: {}&quot;&lt;span&gt;, getIdentifier(), servers);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新所有 Server 到本地缓存&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    updateAllServerList(servers);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateAllServerList(List&amp;lt;T&amp;gt;&lt;span&gt; ls) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (serverListUpdateInProgress.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (T s : ls) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 s.setAlive(&lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 Server alive&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            setServersList(ls);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制初始化 Ping&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.forceQuickPing();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             serverListUpdateInProgress.set(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setServersList(List lsrv) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BaseLoadBalancer&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.setServersList(lsrv);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 Server 更新到 LoadBalancerStats 统计中 ....&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看父类的 setServersList，可以看出，存储所有 Server 的数据结构 allServerList 是一个加了 synchronized 的线程安全的容器，setServersList 就是直接将得到的 Server 列表替换  allServerList。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setServersList(List lsrv) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Lock writeLock =&lt;span&gt; allServerLock.writeLock();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     ArrayList&amp;lt;Server&amp;gt; newServers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Server&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加写锁&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    writeLock.lock();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for 循环将 lsrv 中的 Server 转移到 allServers&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         ArrayList&amp;lt;Server&amp;gt; allServers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Server&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object server : lsrv) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (server &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 server = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Server((String) server);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (server &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Server) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 logger.debug(&quot;LoadBalancer [{}]:  addServer [{}]&quot;&lt;span&gt;, name, ((Server) server).getId());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                allServers.add((Server) server);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Type String or Server expected, instead found:&quot; +&lt;span&gt; server.getClass());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; listChanged = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; allServerList =&amp;gt; volatile List&amp;lt;Server&amp;gt; allServerList = Collections.synchronizedList(new ArrayList&amp;lt;Server&amp;gt;())&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;allServerList.equals(allServers)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             listChanged = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 服务列表变更监听器 ServerListChangeListener， 发出服务变更通知...&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启用了服务预热，开始 Server 预热...
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接替换&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         allServerList =&lt;span&gt; allServers;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (canSkipPing()) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Server s : allServerList) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 s.setAlive(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             upServerList =&lt;span&gt; allServerList;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (listChanged) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            forceQuickPing();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放写锁&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        writeLock.unlock();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面 chooseRoundRobinAfterFiltering 获取所有 Server 时就是返回的这个 allServerList列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; List&amp;lt;Server&amp;gt;&lt;span&gt; getAllServers() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.unmodifiableList(allServerList);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、Eureka Ribbon 客户端配置&lt;/h3&gt;
&lt;p&gt;获取 Server 的组件是 ServerList，RibbonClientConfiguration 中配置的默认实现类是 ConfigurationBasedServerList。ConfigurationBasedServerList 默认是从配置文件中获取，可以像下面这样配置服务实例地址，多个 Server 地址用逗号隔开。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; demo-&lt;span&gt;producer:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  ribbon:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     listOfServers: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.215.0.92:8010,&lt;/span&gt;&lt;span&gt;http://10.215.0.92&lt;/span&gt;&lt;span&gt;:8011&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是和 eureka-client 结合后，也就是引入 spring-cloud-starter-netflix-eureka-client 的客户端依赖，它会帮我们引入 spring-cloud-netflix-eureka-client 依赖，这个包中有一个 RibbonEurekaAutoConfiguration 自动化配置类，它通过 @RibbonClients 注解定义了全局的 Ribbon 客户端配置类 为 EurekaRibbonClientConfiguration&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@EnableConfigurationProperties
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@ConditionalOnRibbonAndEurekaEnabled
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; @AutoConfigureAfter(RibbonAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; @RibbonClients(defaultConfiguration = EurekaRibbonClientConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonEurekaAutoConfiguration {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入 EurekaRibbonClientConfiguration  可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IPing 的默认实现类为 NIWSDiscoveryPing。&lt;/li&gt;
&lt;li&gt;ServerList 的默认实现类为 DomainExtractingServerList，但是 DomainExtractingServerList 在构造时又传入了一个类型为 DiscoveryEnabledNIWSServerList 的 ServerList。看名字大概也可以看出，DiscoveryEnabledNIWSServerList 就是从 EurekaClient 获取 Server 的组件。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaRibbonClientConfiguration {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     @Value(&quot;${ribbon.eureka.approximateZoneFromHostname:false}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; approximateZoneFromHostname = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @RibbonClientName
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String serviceId = &quot;client&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PropertiesFactory propertiesFactory;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IPing ribbonPing(IClientConfig config) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(IPing.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, serviceId)) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(IPing.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, serviceId);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         NIWSDiscoveryPing ping = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NIWSDiscoveryPing();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        ping.initWithNiwsConfig(config);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ping;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ServerList&amp;lt;?&amp;gt;&lt;span&gt; ribbonServerList(IClientConfig config,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             Provider&amp;lt;EurekaClient&amp;gt;&lt;span&gt; eurekaClientProvider) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ServerList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, serviceId)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ServerList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, serviceId);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         DiscoveryEnabledNIWSServerList discoveryServerList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiscoveryEnabledNIWSServerList(config, eurekaClientProvider);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         DomainExtractingServerList serverList = &lt;span&gt;new&lt;/span&gt; DomainExtractingServerList(discoveryServerList, config, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.approximateZoneFromHostname);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; serverList;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、从 DiscoveryClient 获取Server列表&lt;/h3&gt;
&lt;p&gt;DynamicServerListLoadBalancer 中通过 ServerList 的 getUpdatedListOfServers 方法全量获取服务列表，在 eureka-client 环境下，ServerList 默认实现类为 DomainExtractingServerList，那就先看下它的 getUpdatedListOfServers 方法。&lt;/p&gt;
&lt;p&gt;可以看出，DomainExtractingServerList 先用 DomainExtractingServerList 获取服务列表，然后根据 Ribbon 客户端配置重新构造 Server 对象返回。获取服务列表的核心在 DiscoveryEnabledNIWSServerList 中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; List&amp;lt;DiscoveryEnabledServer&amp;gt;&lt;span&gt; getUpdatedListOfServers() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; list =&amp;gt; DiscoveryEnabledNIWSServerList&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     List&amp;lt;DiscoveryEnabledServer&amp;gt; servers = setZones(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.list.getUpdatedListOfServers());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; servers;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; List&amp;lt;DiscoveryEnabledServer&amp;gt; setZones(List&amp;lt;DiscoveryEnabledServer&amp;gt;&lt;span&gt; servers) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     List&amp;lt;DiscoveryEnabledServer&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; isSecure = &lt;span&gt;this&lt;/span&gt;.ribbon.isSecure(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; shouldUseIpAddr = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ribbon.isUseIPAddrForServer();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据客户端配置重新构造 DomainExtractingServer 返回&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (DiscoveryEnabledServer server : servers) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         result.add(&lt;span&gt;new&lt;/span&gt; DomainExtractingServer(server, isSecure, shouldUseIpAddr, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.approximateZoneFromHostname));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看下 DiscoveryEnabledNIWSServerList  的构造初始化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主要是传入了 Provider&amp;lt;EurekaClient&amp;gt; 用来获取 EurekaClient&lt;/li&gt;
&lt;li&gt;另外还设置了客户端名称 clientName ，以及 vipAddresses 也是客户端名称，这个后面会用得上。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; DiscoveryEnabledNIWSServerList(IClientConfig clientConfig, Provider&amp;lt;EurekaClient&amp;gt;&lt;span&gt; eurekaClientProvider) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.eurekaClientProvider =&lt;span&gt; eurekaClientProvider;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    initWithNiwsConfig(clientConfig);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initWithNiwsConfig(IClientConfig clientConfig) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端名称，就是服务名称&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     clientName =&lt;span&gt; clientConfig.getClientName();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; vipAddresses 得到的也是客户端名称&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     vipAddresses =&lt;span&gt; clientConfig.resolveDeploymentContextbasedVipAddresses();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其它的一些配置....&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看获取实例的 getUpdatedListOfServers，可以看到它的核心逻辑就是根据服务名从 EurekaClient 获取 InstanceInfo 实例列表，然后封装 Server 信息返回。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; List&amp;lt;DiscoveryEnabledServer&amp;gt;&lt;span&gt; getUpdatedListOfServers(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obtainServersViaDiscovery();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; List&amp;lt;DiscoveryEnabledServer&amp;gt;&lt;span&gt; obtainServersViaDiscovery() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     List&amp;lt;DiscoveryEnabledServer&amp;gt; serverList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;DiscoveryEnabledServer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (eurekaClientProvider == &lt;span&gt;null&lt;/span&gt; || eurekaClientProvider.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;DiscoveryEnabledServer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到 EurekaClient，实际类型是 CloudEurekaClient，其父类是 DiscoveryClient&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     EurekaClient eurekaClient =&lt;span&gt; eurekaClientProvider.get();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (vipAddresses!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分割 vipAddresses，默认就是服务名称&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (String vipAddress : vipAddresses.split(&quot;,&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据服务名称从 EurekaClient 获取实例信息&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             List&amp;lt;InstanceInfo&amp;gt; listOfInstanceInfo =&lt;span&gt; eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (InstanceInfo ii : listOfInstanceInfo) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ii.getStatus().equals(InstanceStatus.UP)) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据实例信息 InstanceInfo 创建 Server&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                     DiscoveryEnabledServer des =&lt;span&gt; createServer(ii, isSecure, shouldUseIpAddr);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    serverList.add(des);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (serverList.size()&amp;gt;0 &amp;amp;&amp;amp;&lt;span&gt; prioritizeVipAddressBasedServers){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if the current vipAddress has servers, we dont use subsequent vipAddress based servers&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; serverList;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里的 vipAddress 其实就是服务名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201215234148091-320779200.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后看 EurekaClient 的 getInstancesByVipAddress，到这里就很清楚了，其实就是从 DiscoveryClient 的本地应用 Applications 中根据服务名取出所有的实例列表。&lt;/p&gt;
&lt;p&gt;这里就和 Eureka 源码那块衔接上了，eureka-client 全量抓取注册表以及每隔30秒增量抓取注册表，都是合并到本地的 Applications 中。Ribbon 与 Eureka 结合后，Ribbon 获取 Server 就从 DiscoveryClient 的 Applications 中获取 Server 列表了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; List&amp;lt;InstanceInfo&amp;gt; getInstancesByVipAddress(String vipAddress, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; secure, String region) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    Applications applications;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (instanceRegionChecker.isLocalRegion(region)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取本地应用 Applications&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         applications = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.localRegionApps.get();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         applications =&lt;span&gt; remoteRegionVsApps.get(region);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; applications) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;secure) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回服务名对应的实例&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; applications.getInstancesByVirtualHostName(vipAddress);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; applications.getInstancesBySecureVirtualHostName(vipAddress);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、定时更新Server列表&lt;/h3&gt;
&lt;p&gt;DynamicServerListLoadBalancer 初始化时，有个方法还没说，就是 enableAndInitLearnNewServersFeature()。这个方法只是调用 ServerListUpdater 启动了一个 UpdateAction，这个 UpdateAction 又只是调用了一下 updateListOfServers 方法，就是前面讲解过的全量更新 Server 的逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enableAndInitLearnNewServersFeature() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    serverListUpdater.start(updateAction);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ServerListUpdater.UpdateAction updateAction = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerListUpdater.UpdateAction() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doUpdate() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 updateListOfServers&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        updateListOfServers();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServerListUpdater 的默认实现类是 PollingServerListUpdater，看下它的 start 方法：&lt;/p&gt;
&lt;p&gt;其实就是以固定的频率，每隔30秒调用一下 updateListOfServers 方法，将 DiscoveryClient 中 Applications 中缓存的实例同步到 ILoadBalancer 中的 allServerList 列表中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; UpdateAction updateAction) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (isActive.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Runnable wrapperRunnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行一次 updateListOfServers&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                    updateAction.doUpdate();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置最后更新时间&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                     lastUpdated =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     logger.warn(&quot;Failed one update cycle&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 固定频率调度&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         scheduledFuture =&lt;span&gt; getRefreshExecutor().scheduleWithFixedDelay(
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                wrapperRunnable,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 initialDelayMs, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认 1000&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 refreshIntervalMs, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认 30 * 1000&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                TimeUnit.MILLISECONDS
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         logger.info(&quot;Already active, no-op&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6、判断Server是否存活&lt;/h3&gt;
&lt;p&gt;在创建 ILoadBalancer 时，IPing 还没有看过是如何工作的。在初始化的时候，可以看到，主要就是设置了当前的 ping，然后重新设置了一个调度任务，默认每隔30秒调度一次 PingTask 任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPing(IPing ping) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ping != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!ping.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ping)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.ping =&lt;span&gt; ping;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 Ping 任务&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            setupPingTask();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.ping = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cancel the timer task&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        lbTimer.cancel();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setupPingTask() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个定时调度器&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     lbTimer = &lt;span&gt;new&lt;/span&gt; ShutdownEnabledTimer(&quot;NFLoadBalancer-PingTimer-&quot; + name, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pingIntervalTime 默认为 30 秒，每隔30秒调度一次 PingTask&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     lbTimer.schedule(&lt;span&gt;new&lt;/span&gt; PingTask(), 0, pingIntervalSeconds * 1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 立即发起以 Ping&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    forceQuickPing();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ShutdownEnabledTimer 可以简单了解下，它是继承自 Timer 的，它在创建的时候向 Runtime 注册了一个回调，在 jvm 关闭的时候来取消 Timer 的执行，进而释放资源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_1e8a8969-2487-4d0c-bb9f-2b986607f461&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_1e8a8969-2487-4d0c-bb9f-2b986607f461&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1e8a8969-2487-4d0c-bb9f-2b986607f461&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ShutdownEnabledTimer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Timer {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(ShutdownEnabledTimer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Thread cancelThread;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ShutdownEnabledTimer(String name, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; daemon) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name, daemon);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取消定时器的线程&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.cancelThread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 ShutdownEnabledTimer.&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.cancel();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         LOGGER.info(&quot;Shutdown hook installed for: {}&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向 Runtime 注册一个钩子，在 jvm 关闭时，调用 cancelThread 取消定时任务&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Runtime.getRuntime().addShutdownHook(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cancelThread);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cancel() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.cancel();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         LOGGER.info(&quot;Shutdown hook removed for: {}&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             Runtime.getRuntime().removeShutdownHook(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cancelThread);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalStateException ise) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             LOGGER.info(&quot;Exception caught (might be ok if at shutdown)&quot;&lt;span&gt;, ise);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;再来看下 PingTask，PingTask 核心逻辑就是遍历 allServers 列表，使用 IPingStrategy 和 IPing 来判断 Server 是否存活，并更新 Server 的状态，以及将所有存活的 Server 更新到 upServerList 中，upServerList 缓存了所有存活的 Server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_ba897ff2-b983-4326-bbe1-f182b5d2644e&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_ba897ff2-b983-4326-bbe1-f182b5d2644e&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ba897ff2-b983-4326-bbe1-f182b5d2644e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PingTask &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TimerTask {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pingStrategy =&amp;gt; SerialPingStrategy&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pinger(pingStrategy).runPinger();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             logger.error(&quot;LoadBalancer [{}]: Error pinging&quot;&lt;span&gt;, name, e);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Pinger {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; IPingStrategy pingerStrategy;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Pinger(IPingStrategy pingerStrategy) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pingerStrategy =&lt;span&gt; pingerStrategy;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; runPinger() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!pingInProgress.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) { 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ping in progress - nothing to do&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         Server[] allServers = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt;[] results = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         Lock allLock = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Lock upLock = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             allLock =&lt;span&gt; allServerLock.readLock();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            allLock.lock();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加读锁，取出 allServerList 中的 Server&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             allServers = allServerList.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Server[allServerList.size()]);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            allLock.unlock();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; numCandidates =&lt;span&gt; allServers.length;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 IPingStrategy 和 IPing 对所有 Server 发起 ping 请求&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             results =&lt;span&gt; pingerStrategy.pingServers(ping, allServers);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; List&amp;lt;Server&amp;gt; newUpList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Server&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; List&amp;lt;Server&amp;gt; changedServers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Server&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; numCandidates; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;boolean&lt;/span&gt; isAlive =&lt;span&gt; results[i];
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 Server svr =&lt;span&gt; allServers[i];
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;boolean&lt;/span&gt; oldIsAlive =&lt;span&gt; svr.isAlive();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 alive 是否存活&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                svr.setAlive(isAlive);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例变更&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (oldIsAlive !=&lt;span&gt; isAlive) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                    changedServers.add(svr);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                     logger.debug(&quot;LoadBalancer [{}]:  Server [{}] status changed to {}&quot;,  name, svr.getId(), (isAlive ? &quot;ALIVE&quot; : &quot;DEAD&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加存活的 Server&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isAlive) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                    newUpList.add(svr);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             upLock =&lt;span&gt; upServerLock.writeLock();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            upLock.lock();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新 upServerList，upServerList 只保存了存活的 Server&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;             upServerList =&lt;span&gt; newUpList;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            upLock.unlock();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知变更&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            notifyServerStatusChangeListener(changedServers);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             pingInProgress.set(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;IPingStrategy 的默认实现类是 SerialPingStrategy，进入可以发现它只是遍历所有 Server，然后用 IPing 判断 Server 是否存活。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SerialPingStrategy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IPingStrategy {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[] pingServers(IPing ping, Server[] servers) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; numCandidates =&lt;span&gt; servers.length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt;[] results = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[numCandidates];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; numCandidates; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             results[i] = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (ping != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 IPing 判断 Server 是否存活&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                     results[i] =&lt;span&gt; ping.isAlive(servers[i]);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 logger.error(&quot;Exception while pinging Server: '{}'&quot;&lt;span&gt;, servers[i], e);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; results;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在集成 eureka-client 后，IPing默认实现类是 NIWSDiscoveryPing，看它的 isAlive 方法，其实就是判断对应 Server 的实例 InstanceInfo 的状态是否是 UP 状态，UP状态就表示 Server 存活。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isAlive(Server server) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; isAlive = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server!=&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; server &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; DiscoveryEnabledServer){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         DiscoveryEnabledServer dServer =&lt;span&gt; (DiscoveryEnabledServer)server;                
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         InstanceInfo instanceInfo =&lt;span&gt; dServer.getInstanceInfo();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (instanceInfo!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){                    
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             InstanceStatus status =&lt;span&gt; instanceInfo.getStatus();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (status!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断Server对应的实例状态是否是 UP&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 isAlive =&lt;span&gt; status.equals(InstanceStatus.UP);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; isAlive;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7、一张图总结 Ribbon 核心原理&lt;/h3&gt;
&lt;p&gt;① Ribbon 核心工作原理总结&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，Ribbon 的7个核心接口共同定义了 Ribbon 的行为特性，它们就是 Ribbon 的核心骨架。&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216140622046-1368656207.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;使用 Ribbon 来对客户端做负载均衡，基本的用法就是用 @LoadBalanced 注解标注一个 RestTemplate 的 bean 对象，之后在 LoadBalancerAutoConfiguration 配置类中会对带有 @LoadBalanced 注解的 RestTemplate 添加 LoadBalancerInterceptor 拦截器。&lt;/li&gt;
&lt;li&gt;LoadBalancerInterceptor 会拦截 RestTemplate 的 HTTP 请求，将请求绑定进 Ribbon 负载均衡的生命周期，然后使用 LoadBalancerClient 的 execute 方法来处理请求。&lt;/li&gt;
&lt;li&gt;LoadBalancerClient 首先会得到一个 ILoadBalancer，再使用它去得到一个 Server，这个 Server 就是具体某一个实例的信息封装。得到 Server 之后，就用 Server 的 IP 和端口重构原始 URI。&lt;/li&gt;
&lt;li&gt;ILoadBalancer 最终在选择实例的时候，会通过 IRule 均衡策略来选择一个 Server。&lt;/li&gt;
&lt;li&gt;ILoadBalancer 的父类 BaseLoadBalancer 中有一个 allServerList 列表缓存了所有 Server，Ribbon 中 Server 的来源就是 allServerList。&lt;/li&gt;
&lt;li&gt;在加载Ribbon客户端上下文时，ILoadBalancer 会用 ServerList 从 DiscoveryClient 的 Applications 中获取客户端对应的实例列表，然后使用 ServerListFilter 过滤，最后更新到 allServerList 中。&lt;/li&gt;
&lt;li&gt;ILoadBalancer 还会开启一个后台任务 ServerListUpdater ，每隔30秒运行一次，用 ServerList 将 DiscoveryClient 的 Applications 中的实例列表同步到 allServerList 中。&lt;/li&gt;
&lt;li&gt;ILoadBalancer 还会开启一个后台任务 PingTask，每隔30秒运行一次，用 IPing 判断 Server 的存活状态，EurekaClient 环境下，就是判断 InstanceInfo 的状态是否为 UP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;② 下面用一张图来总结下 Ribbon 这块获取Server的核心流程以及对应的核心接口间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216131525181-1966349629.png&quot; width=&quot;1500&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、Ribbon 核心接口&lt;/h2&gt;
&lt;p&gt;前面已经了解到 Ribbon 核心接口以及默认实现如何协作来查找要调用的一个实例，这节再来看下各个核心接口的一些特性及其它实现类。&lt;/p&gt;
&lt;h3&gt;1、客户端配置 — IClientConfig&lt;/h3&gt;
&lt;p&gt;IClientConfig 就是管理客户端配置的核心接口，它的默认实现类是 DefaultClientConfigImpl。可以看到在创建 IClientConfig 时，设置了 Ribbon 客户端默认的连接和读取超时时间为 1 秒，例如读取如果超过1秒，就会返回超时，这两个一般需要根据实际情况来调整。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IClientConfig ribbonClientConfig() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     DefaultClientConfigImpl config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultClientConfigImpl();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载配置&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     config.loadProperties(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接超时默认 1 秒&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取超时默认 1 秒&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CommonClientConfigKey 这个类定义了 Ribbon 客户端相关的所有配置的键常量，可以通过这个类来看有哪些配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_b3458058-9eb5-4669-a230-06257fe7c8cb&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_b3458058-9eb5-4669-a230-06257fe7c8cb&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b3458058-9eb5-4669-a230-06257fe7c8cb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CommonClientConfigKey&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; IClientConfigKey&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; AppName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;AppName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; Version = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;Version&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; Port = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;Port&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; SecurePort = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;SecurePort&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; VipAddress = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;VipAddress&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; ForceClientPortConfiguration = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;ForceClientPortConfiguration&quot;){}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use client defined port regardless of server advert&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; DeploymentContextBasedVipAddresses = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;DeploymentContextBasedVipAddresses&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxAutoRetries = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxAutoRetries&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxAutoRetriesNextServer = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxAutoRetriesNextServer&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; OkToRetryOnAllOperations = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;OkToRetryOnAllOperations&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; RequestSpecificRetryOn = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;RequestSpecificRetryOn&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ReceiveBufferSize = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ReceiveBufferSize&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnablePrimeConnections = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnablePrimeConnections&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; PrimeConnectionsClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;PrimeConnectionsClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxRetriesPerServerPrimeConnection = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxRetriesPerServerPrimeConnection&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxTotalTimeToPrimeConnections = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxTotalTimeToPrimeConnections&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Float&amp;gt; MinPrimeConnectionsRatio = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Float&amp;gt;(&quot;MinPrimeConnectionsRatio&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; PrimeConnectionsURI = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;PrimeConnectionsURI&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; PoolMaxThreads = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;PoolMaxThreads&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; PoolMinThreads = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;PoolMinThreads&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     
&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; PoolKeepAliveTime = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;PoolKeepAliveTime&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; PoolKeepAliveTimeUnits = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;PoolKeepAliveTimeUnits&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableConnectionPool = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableConnectionPool&quot;&lt;span&gt;) {};
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;     * Use {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MaxConnectionsPerHost}
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;    @Deprecated    
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxHttpConnectionsPerHost = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxHttpConnectionsPerHost&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;     * Use {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MaxTotalConnections}
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxTotalHttpConnections = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxTotalHttpConnections&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxConnectionsPerHost = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxConnectionsPerHost&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxTotalConnections = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxTotalConnections&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; IsSecure = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;IsSecure&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     
&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; GZipPayload = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;GZipPayload&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ConnectTimeout = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ConnectTimeout&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; BackoffInterval = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;BackoffTimeout&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ReadTimeout = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ReadTimeout&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; SendBufferSize = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;SendBufferSize&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     
&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; StaleCheckingEnabled = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;StaleCheckingEnabled&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; Linger = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;Linger&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ConnectionManagerTimeout = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ConnectionManagerTimeout&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; FollowRedirects = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;FollowRedirects&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; ConnectionPoolCleanerTaskEnabled = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;ConnectionPoolCleanerTaskEnabled&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     
&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ConnIdleEvictTimeMilliSeconds = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ConnIdleEvictTimeMilliSeconds&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ConnectionCleanerRepeatInterval = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ConnectionCleanerRepeatInterval&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableGZIPContentEncodingFilter = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableGZIPContentEncodingFilter&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     
&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; ProxyHost = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;ProxyHost&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     
&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ProxyPort = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ProxyPort&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; KeyStore = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;KeyStore&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; KeyStorePassword = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;KeyStorePassword&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; TrustStore = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;TrustStore&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; TrustStorePassword = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;TrustStorePassword&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if this is a secure rest client, must we use client auth too?    &lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; IsClientAuthRequired = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;IsClientAuthRequired&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; CustomSSLSocketFactoryClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;CustomSSLSocketFactoryClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; must host name match name in certificate?&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; IsHostnameValidationRequired = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;IsHostnameValidationRequired&quot;&lt;span&gt;){}; 
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; see also &lt;/span&gt;&lt;span&gt;http://hc.apache.org/httpcomponents-client-ga/tutorial/html/advanced.html&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; IgnoreUserTokenInConnectionPoolForSecureClient = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;IgnoreUserTokenInConnectionPoolForSecureClient&quot;&lt;span&gt;){}; 
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Client implementation&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; ClientClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;ClientClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;LoadBalancer Related&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; InitializeNFLoadBalancer = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;InitializeNFLoadBalancer&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     
&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NFLoadBalancerClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NFLoadBalancerClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     
&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NFLoadBalancerRuleClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NFLoadBalancerRuleClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NFLoadBalancerPingClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NFLoadBalancerPingClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; NFLoadBalancerPingInterval = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;NFLoadBalancerPingInterval&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     
&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; NFLoadBalancerMaxTotalPingTime = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;NFLoadBalancerMaxTotalPingTime&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NFLoadBalancerStatsClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NFLoadBalancerStatsClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;     
&lt;span&gt;133&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NIWSServerListClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NIWSServerListClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; ServerListUpdaterClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;ServerListUpdaterClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     
&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NIWSServerListFilterClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NIWSServerListFilterClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     
&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ServerListRefreshInterval = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ServerListRefreshInterval&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableMarkingServerDownOnReachingFailureLimit = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableMarkingServerDownOnReachingFailureLimit&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;     
&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ServerDownFailureLimit = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ServerDownFailureLimit&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;     
&lt;span&gt;145&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ServerDownStatWindowInMillis = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ServerDownStatWindowInMillis&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;     
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableZoneAffinity = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableZoneAffinity&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;     
&lt;span&gt;149&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableZoneExclusivity = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableZoneExclusivity&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;     
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; PrioritizeVipAddressBasedServers = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;PrioritizeVipAddressBasedServers&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;     
&lt;span&gt;153&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; VipAddressResolverClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;VipAddressResolverClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     
&lt;span&gt;155&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; TargetRegion = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;TargetRegion&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;     
&lt;span&gt;157&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; RulePredicateClasses = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;RulePredicateClasses&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;     
&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; RequestIdHeaderName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;RequestIdHeaderName&quot;&lt;span&gt;) {};
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;     
&lt;span&gt;161&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; UseIPAddrForServer = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;UseIPAddrForServer&quot;&lt;span&gt;) {};
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;     
&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; ListOfServers = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;listOfServers&quot;&lt;span&gt;) {};
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Set&amp;lt;IClientConfigKey&amp;gt; keys = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;IClientConfigKey&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         
&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;进入到 DefaultClientConfigImpl，可以看到 CommonClientConfigKey 中的每个配置都对应了一个默认值。在加载配置的时候，如果用户没有定制配置，就会使用默认的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_8fdc619a-c340-43da-8dec-6c8af1229c7a&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_8fdc619a-c340-43da-8dec-6c8af1229c7a&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8fdc619a-c340-43da-8dec-6c8af1229c7a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;109&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultClientConfigImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IClientConfig {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_PRIORITIZE_VIP_ADDRESS_BASED_SERVERS =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_NFLOADBALANCER_PING_CLASSNAME = &quot;com.netflix.loadbalancer.DummyPing&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DummyPing.class.getName();&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_NFLOADBALANCER_RULE_CLASSNAME = &quot;com.netflix.loadbalancer.AvailabilityFilteringRule&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_NFLOADBALANCER_CLASSNAME = &quot;com.netflix.loadbalancer.ZoneAwareLoadBalancer&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; DEFAULT_USEIPADDRESS_FOR_SERVER =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_CLIENT_CLASSNAME = &quot;com.netflix.niws.client.http.RestClient&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_VIPADDRESS_RESOLVER_CLASSNAME = &quot;com.netflix.client.SimpleVipAddressResolver&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_PRIME_CONNECTIONS_URI = &quot;/&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_TOTAL_TIME_TO_PRIME_CONNECTIONS = 30000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_RETRIES_PER_SERVER_PRIME_CONNECTION = 9&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_PRIME_CONNECTIONS =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_REQUESTS_ALLOWED_PER_WINDOW =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_REQUEST_THROTTLING_WINDOW_IN_MILLIS = 60000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_REQUEST_THROTTLING =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_GZIP_CONTENT_ENCODING_FILTER =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_CONNECTION_POOL_CLEANER_TASK_ENABLED =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_FOLLOW_REDIRECTS =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_PERCENTAGE_NIWS_EVENT_LOGGED = 0.0f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_AUTO_RETRIES = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_BACKOFF_INTERVAL = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_READ_TIMEOUT = 5000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECTION_MANAGER_TIMEOUT = 2000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECT_TIMEOUT = 2000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_CONNECTION_POOL =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_HTTP_CONNECTIONS_PER_HOST = 50&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_TOTAL_HTTP_CONNECTIONS = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_CONNECTIONS_PER_HOST = 50&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_TOTAL_CONNECTIONS = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_MIN_PRIME_CONNECTIONS_RATIO = 1.0f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_PRIME_CONNECTIONS_CLASS = &quot;com.netflix.niws.client.http.HttpPrimeConnection&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_SEVER_LIST_CLASS = &quot;com.netflix.loadbalancer.ConfigurationBasedServerList&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_SERVER_LIST_UPDATER_CLASS = &quot;com.netflix.loadbalancer.PollingServerListUpdater&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECTION_IDLE_TIMERTASK_REPEAT_IN_MSECS = 30000; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; every half minute (30 secs)&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECTIONIDLE_TIME_IN_MSECS = 30000; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; all connections idle for 30 secs&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;     
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; properties = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     
&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Map&amp;lt;IClientConfigKey&amp;lt;?&amp;gt;, Object&amp;gt; typedProperties = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;IClientConfigKey&amp;lt;?&amp;gt;, Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOG = LoggerFactory.getLogger(DefaultClientConfigImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String clientName = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; VipAddressResolver resolver = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; enableDynamicProperties = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;     * Defaults for the parameters for the thread pool used by batchParallel
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;     * calls
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_POOL_MAX_THREADS =&lt;span&gt; DEFAULT_MAX_TOTAL_HTTP_CONNECTIONS;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_POOL_MIN_THREADS = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; DEFAULT_POOL_KEEP_ALIVE_TIME = 15 * 60L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; TimeUnit DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS =&lt;span&gt; TimeUnit.SECONDS;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_ZONE_AFFINITY =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_ZONE_EXCLUSIVITY =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_PORT = 7001&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_LOADBALANCER =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_PROPERTY_NAME_SPACE = &quot;ribbon&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String propertyNameSpace =&lt;span&gt; DEFAULT_PROPERTY_NAME_SPACE;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_OK_TO_RETRY_ON_ALL_OPERATIONS =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_NIWS_EVENT_LOGGING =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_IS_CLIENT_AUTH_REQUIRED =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, DynamicStringProperty&amp;gt; dynamicProperties = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, DynamicStringProperty&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultPrioritizeVipAddressBasedServers() {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PRIORITIZE_VIP_ADDRESS_BASED_SERVERS;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultNfloadbalancerPingClassname() {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_NFLOADBALANCER_PING_CLASSNAME;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultNfloadbalancerRuleClassname() {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_NFLOADBALANCER_RULE_CLASSNAME;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultNfloadbalancerClassname() {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_NFLOADBALANCER_CLASSNAME;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getDefaultUseIpAddressForServer() {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_USEIPADDRESS_FOR_SERVER;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultClientClassname() {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CLIENT_CLASSNAME;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultVipaddressResolverClassname() {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_VIPADDRESS_RESOLVER_CLASSNAME;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultPrimeConnectionsUri() {
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PRIME_CONNECTIONS_URI;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxTotalTimeToPrimeConnections() {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_TOTAL_TIME_TO_PRIME_CONNECTIONS;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxRetriesPerServerPrimeConnection() {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_RETRIES_PER_SERVER_PRIME_CONNECTION;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnablePrimeConnections() {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_PRIME_CONNECTIONS;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; 
&lt;span&gt;155&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxRequestsAllowedPerWindow() {
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_REQUESTS_ALLOWED_PER_WINDOW;
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultRequestThrottlingWindowInMillis() {
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_REQUEST_THROTTLING_WINDOW_IN_MILLIS;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableRequestThrottling() {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_REQUEST_THROTTLING;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableGzipContentEncodingFilter() {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_GZIP_CONTENT_ENCODING_FILTER;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultConnectionPoolCleanerTaskEnabled() {
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECTION_POOL_CLEANER_TASK_ENABLED;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultFollowRedirects() {
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_FOLLOW_REDIRECTS;
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getDefaultPercentageNiwsEventLogged() {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PERCENTAGE_NIWS_EVENT_LOGGED;
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; 
&lt;span&gt;183&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxAutoRetriesNextServer() {
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxAutoRetries() {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_AUTO_RETRIES;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; 
&lt;span&gt;191&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultReadTimeout() {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_READ_TIMEOUT;
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; 
&lt;span&gt;195&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultConnectionManagerTimeout() {
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECTION_MANAGER_TIMEOUT;
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultConnectTimeout() {
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECT_TIMEOUT;
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; 
&lt;span&gt;203&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxHttpConnectionsPerHost() {
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_HTTP_CONNECTIONS_PER_HOST;
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxTotalHttpConnections() {
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_TOTAL_HTTP_CONNECTIONS;
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxConnectionsPerHost() {
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_CONNECTIONS_PER_HOST;
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxTotalConnections() {
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_TOTAL_CONNECTIONS;
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;     
&lt;span&gt;221&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getDefaultMinPrimeConnectionsRatio() {
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MIN_PRIME_CONNECTIONS_RATIO;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; 
&lt;span&gt;225&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultPrimeConnectionsClass() {
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PRIME_CONNECTIONS_CLASS;
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; 
&lt;span&gt;229&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultSeverListClass() {
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_SEVER_LIST_CLASS;
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; 
&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultConnectionIdleTimertaskRepeatInMsecs() {
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECTION_IDLE_TIMERTASK_REPEAT_IN_MSECS;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultConnectionidleTimeInMsecs() {
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECTIONIDLE_TIME_IN_MSECS;
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;     
&lt;span&gt;241&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; VipAddressResolver getResolver() {
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolver;
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; 
&lt;span&gt;245&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEnableDynamicProperties() {
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; enableDynamicProperties;
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; 
&lt;span&gt;249&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPoolMaxThreads() {
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_POOL_MAX_THREADS;
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; 
&lt;span&gt;253&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPoolMinThreads() {
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_POOL_MIN_THREADS;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; 
&lt;span&gt;257&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getDefaultPoolKeepAliveTime() {
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_POOL_KEEP_ALIVE_TIME;
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; 
&lt;span&gt;261&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimeUnit getDefaultPoolKeepAliveTimeUnits() {
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS;
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableZoneAffinity() {
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_ZONE_AFFINITY;
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; 
&lt;span&gt;269&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableZoneExclusivity() {
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_ZONE_EXCLUSIVITY;
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; 
&lt;span&gt;273&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPort() {
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PORT;
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt; 
&lt;span&gt;277&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableLoadbalancer() {
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_LOADBALANCER;
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; 
&lt;span&gt;281&lt;/span&gt; 
&lt;span&gt;282&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultOkToRetryOnAllOperations() {
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_OK_TO_RETRY_ON_ALL_OPERATIONS;
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; 
&lt;span&gt;286&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultIsClientAuthRequired(){
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_IS_CLIENT_AUTH_REQUIRED;
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt; 
&lt;span&gt;290&lt;/span&gt; 
&lt;span&gt;291&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;292&lt;/span&gt; &lt;span&gt;     * Create instance with no properties in default name space {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #DEFAULT_PROPERTY_NAME_SPACE}
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;294&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultClientConfigImpl() {
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dynamicProperties.clear();
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.enableDynamicProperties = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt; 
&lt;span&gt;299&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;300&lt;/span&gt; &lt;span&gt;     * Create instance with no properties in the specified name space
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;302&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultClientConfigImpl(String nameSpace) {
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.propertyNameSpace =&lt;span&gt; nameSpace;
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt; 
&lt;span&gt;307&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; loadDefaultValues() {
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxHttpConnectionsPerHost, getDefaultMaxHttpConnectionsPerHost());
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxTotalHttpConnections, getDefaultMaxTotalHttpConnections());
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnableConnectionPool, getDefaultEnableConnectionPool());
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxConnectionsPerHost, getDefaultMaxConnectionsPerHost());
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxTotalConnections, getDefaultMaxTotalConnections());
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ConnectTimeout, getDefaultConnectTimeout());
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ConnectionManagerTimeout, getDefaultConnectionManagerTimeout());
&lt;/span&gt;&lt;span&gt;315&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ReadTimeout, getDefaultReadTimeout());
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxAutoRetries, getDefaultMaxAutoRetries());
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, getDefaultMaxAutoRetriesNextServer());
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.OkToRetryOnAllOperations, getDefaultOkToRetryOnAllOperations());
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.FollowRedirects, getDefaultFollowRedirects());
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.ConnectionPoolCleanerTaskEnabled, getDefaultConnectionPoolCleanerTaskEnabled());
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ConnIdleEvictTimeMilliSeconds, getDefaultConnectionidleTimeInMsecs());
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ConnectionCleanerRepeatInterval, getDefaultConnectionIdleTimertaskRepeatInMsecs());
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnableGZIPContentEncodingFilter, getDefaultEnableGzipContentEncodingFilter());
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt;         String proxyHost =&lt;span&gt; ConfigurationManager.getConfigInstance().getString(getDefaultPropName(CommonClientConfigKey.ProxyHost.key()));
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (proxyHost != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; proxyHost.length() &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt; &lt;span&gt;            setProperty(CommonClientConfigKey.ProxyHost, proxyHost);
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt;         Integer proxyPort =&lt;span&gt; ConfigurationManager
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt; &lt;span&gt;                .getConfigInstance()
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt; &lt;span&gt;                .getInteger(
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt; &lt;span&gt;                        getDefaultPropName(CommonClientConfigKey.ProxyPort),
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;                         (Integer.MIN_VALUE + 1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; + 1 just to avoid potential clash with user setting&lt;/span&gt;
&lt;span&gt;333&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (proxyPort != (Integer.MIN_VALUE + 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; &lt;span&gt;            setProperty(CommonClientConfigKey.ProxyPort, proxyPort);
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.Port, getDefaultPort());
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnablePrimeConnections, getDefaultEnablePrimeConnections());
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxRetriesPerServerPrimeConnection, getDefaultMaxRetriesPerServerPrimeConnection());
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxTotalTimeToPrimeConnections, getDefaultMaxTotalTimeToPrimeConnections());
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.PrimeConnectionsURI, getDefaultPrimeConnectionsUri());
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.PoolMinThreads, getDefaultPoolMinThreads());
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.PoolMaxThreads, getDefaultPoolMaxThreads());
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt; &lt;span&gt;        putDefaultLongProperty(CommonClientConfigKey.PoolKeepAliveTime, getDefaultPoolKeepAliveTime());
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt; &lt;span&gt;        putDefaultTimeUnitProperty(CommonClientConfigKey.PoolKeepAliveTimeUnits, getDefaultPoolKeepAliveTimeUnits());
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnableZoneAffinity, getDefaultEnableZoneAffinity());
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnableZoneExclusivity, getDefaultEnableZoneExclusivity());
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.ClientClassName, getDefaultClientClassname());
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.NFLoadBalancerClassName, getDefaultNfloadbalancerClassname());
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.NFLoadBalancerRuleClassName, getDefaultNfloadbalancerRuleClassname());
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.NFLoadBalancerPingClassName, getDefaultNfloadbalancerPingClassname());
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.PrioritizeVipAddressBasedServers, getDefaultPrioritizeVipAddressBasedServers());
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt; &lt;span&gt;        putDefaultFloatProperty(CommonClientConfigKey.MinPrimeConnectionsRatio, getDefaultMinPrimeConnectionsRatio());
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.PrimeConnectionsClassName, getDefaultPrimeConnectionsClass());
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.NIWSServerListClassName, getDefaultSeverListClass());
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.VipAddressResolverClassName, getDefaultVipaddressResolverClassname());
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.IsClientAuthRequired, getDefaultIsClientAuthRequired());
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; putDefaultStringProperty(CommonClientConfigKey.RequestIdHeaderName, getDefaultRequestIdHeaderName());&lt;/span&gt;
&lt;span&gt;358&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.UseIPAddrForServer, getDefaultUseIpAddressForServer());
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt;         putDefaultStringProperty(CommonClientConfigKey.ListOfServers, &quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;也可以在配置文件中定制配置，例如配置超时和重试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 全局配置
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;ribbon:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  # 客户端读取超时时间
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   ReadTimeout: 3000
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  # 客户端连接超时时间
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   ConnectTimeout: 3000
&lt;span&gt; 7&lt;/span&gt;   # 默认只重试 GET，设置为 &lt;span&gt;true&lt;/span&gt;&lt;span&gt; 时将重试所有类型，如 POST、PUT、DELETE
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   OkToRetryOnAllOperations: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  # 重试次数
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   MaxAutoRetries: 1
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  # 最多重试几个实例
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   MaxAutoRetriesNextServer: 1
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; # 只针对 demo-&lt;span&gt;producer 客户端
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; demo-&lt;span&gt;producer:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  ribbon:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    # 客户端读取超时时间
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     ReadTimeout: 5000
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    # 客户端连接超时时间
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     ConnectTimeout: 3000
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、均衡策略 — IRule&lt;/h3&gt;
&lt;p&gt;IRule 是最终选择 Server 的策略规则类，核心的接口就是 choose。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IRule{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选择 Server&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server choose(Object key);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 ILoadBalancer&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLoadBalancer(ILoadBalancer lb);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 ILoadBalancer&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ILoadBalancer getLoadBalancer();    
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ribbon 提供了丰富的负载均衡策略，我们也可以通过配置指定使用某个均衡策略。下面是整个Ribbon提供的 IRule 均衡策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216141424713-1149639373.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216141550724-1761844405.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、服务检查 — IPing&lt;/h3&gt;
&lt;p&gt;IPing 是用于定期检查 Server 的可用性的，它只提供了一个接口，用来判断 Server 是否存活：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPing {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isAlive(Server server);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IPing 也提供了多种策略可选，下面是整个 IPing 体系结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216143650669-1089978409.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216155204028-959715095.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4、获取服务列表 — ServerList&lt;/h3&gt;
&lt;p&gt;ServerList 提供了两个接口，一个是第一次获取 Server 列表，一个是更新 Server 列表，其中 getUpdatedListOfServers 会每被 Loadbalancer 隔 30 秒调一次来更新 allServerList。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ServerList&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Server&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; getInitialListOfServers();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * Return updated list of servers. This is called say every 30 secs
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * (configurable) by the Loadbalancer's Ping cycle
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; getUpdatedListOfServers();   
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServerList 也提供了多种实现，ServerList 体系结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216153448922-1665417546.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216155415765-1116927601.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、过滤服务 — ServerListFilter&lt;/h3&gt;
&lt;p&gt;ServerListFilter 提供了一个接口用来过滤出可用的 Server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ServerListFilter&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Server&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt; getFilteredListOfServers(List&amp;lt;T&amp;gt;&lt;span&gt; servers);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServerListFilter 体系结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216155723158-899384324.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6、服务列表更新 — ServerListUpdater&lt;/h3&gt;
&lt;p&gt;ServerListUpdater 有多个接口，最核心的就是 start 开启定时任务调用 updateAction 来更新 allServerList。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ServerListUpdater {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * an interface for the updateAction that actually executes a server list update
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UpdateAction {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doUpdate();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * start the serverList updater with the given update action
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * This call should be idempotent.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start(UpdateAction updateAction);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认有两个实现类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216160325559-919949316.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7、负载均衡器 — ILoadBalancer&lt;/h3&gt;
&lt;p&gt;ILoadBalancer 是负载均衡选择服务的核心接口，主要提供了如下的获取Server列表和根据客户端名称选择Server的接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ILoadBalancer {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加Server&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addServers(List&amp;lt;Server&amp;gt;&lt;span&gt; newServers);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据key选择一个Server&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server chooseServer(Object key);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取存活的Server列表，返回 upServerList&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Server&amp;gt;&lt;span&gt; getReachableServers();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有Server列表，返回 allServerList&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Server&amp;gt;&lt;span&gt; getAllServers();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ILoadBalancer 的体系结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216160719383-1823772896.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Wed, 16 Dec 2020 16:26:00 +0000</pubDate>
<dc:creator>bojiangzhou</dc:creator>
<og:description>深入研究 Ribbon 负载均衡的核心原理，RestTemplate 如何具备负载均衡的能力，以及 Ribbon 核心接口特性等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chiangchou/p/ribbon-1.html</dc:identifier>
</item>
<item>
<title>C++学习总结 - 不妨不妨，来日方长</title>
<link>http://www.cnblogs.com/masbay/p/13942453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/masbay/p/13942453.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一些需要知道的基础知识点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在程序代码中是通过变量名对内存单元进行存取操作的，但是代码经过编译后将变量名转换为该变量在内存中的存放地址，对变量值的存取都是通过地址进行的。比如i+j的运算，如果i等于3，j等于4，程序是先根据变量名与地址的对应关系，找到变量i的地址，从第一个地址开始顺序读取四个字节数据放到CPU寄存器中；再找到j的地址，依次读取四个放到寄存器中，然后通过CPU的加法中断计算出结果。&lt;/p&gt;
&lt;p&gt;在低级的汇编语言中都是直接通过地址来访问内存单元的，而在高级语言中才使用变量名访问内存单元，C语言作为高级语言却提供了通过地址来访问内存单元的方法，C++也继承了这一特性。地址可以形象地称为指针，意思是通过指针能找到内存单元，因为原本是通过地址找到内存单元的，所以一个变量的地址称为该变量的指针。如果有一个变量专门存放另一个变量的地址，它就是指针变量。在C++语言中，专门用来存放内存单元地址的变量类型，称为指针类型。&lt;/p&gt;
&lt;p&gt;指针是一种数据类型，通常所说的指针就是指针变量，是专门用来存放地址的变量。而变量的指针说的就是变量在内存中的地址。变量地址在编写代码时无法获得，只有在程序运行时才可以得到。&lt;/p&gt;
&lt;p&gt;指针跟常规的变量为赋值相同，没有具体指向的指针不会导致编译出错，但是可能会导致难以预料的错误，所以一旦定义指针，一定要让它有一个具体的指向，也就是说要有一个地址赋给它。&lt;/p&gt;
&lt;p&gt;另外，定义指针变量的时候，跟其他常规变量为了区分，要加*号，但其实真正的指针变量是没有*号的，在使用的时候要注意。&lt;/p&gt;
&lt;p&gt;指针进行运算其实就是地址进行运算，指针的加减运算是跟指针的类型有关的，比如int类型的指针加1，地址值并不是加1而是加4，因为int类型占四个字节。&lt;/p&gt;
&lt;p&gt;※指针还可以指向空类型void。空类型指针可以接受任何类型的数据，例如void *p = NULL&lt;/p&gt;
&lt;p&gt;这里有点问题，NULL代替空指针存在二义性，所以后来用nullptr来代替空指针。总之，只要记住nullptr代表空指针就可以了，而NULL在C++中都把它理解为0就可以了。&lt;/p&gt;
&lt;p&gt;※const int *p = &amp;amp;i  表示这个指针是指向常量的指针，只能用来“读”内存数据，无法通过*p的方式更改内存的内容，即更改变量的值，但是可以改变自身的地址值，就是指向别的内存地址；&lt;/p&gt;
&lt;p&gt;※int* const p = &amp;amp;i  表示这个指针是一个常量指针，什么意思呢，以为指针变量里存放的是地址，定义为常量指针的话，说明这个指针变量存放的地址值是不可以改变的，但是呢，可以通过*p的方式改变内存的数据；&lt;/p&gt;
&lt;p&gt;※const int* const p = &amp;amp;i  表示这个指针是指向常量的常量指针，有点拗口，跟上面的对比，反正就是只能用来“读”内存数据，也无法通过*p的方式更改内存的内容，也无法改变自身的地址值。&lt;/p&gt;

&lt;p&gt;指针和一维数组&lt;/p&gt;
&lt;p&gt;一维数组和二维数组在内存中的存放结构都是线性的。数组第一元素的地址就是整个数组的存储首地址，该地址存放在数组名中，看吧，其实数组名就相当于一个指针变量了，里头存放的是数组的首地址。访问数组元素的方式有下标法和指针法。用数组名[i]这个方式可以访问数组内容，其实也可以通过*(a+i)的方式，当然我们也可以再单独定义一个指针变量，将数组的首地址存放到这个指针变量中，当然了，可以用&amp;amp;a[0]也可以直接用a即数组名，因为我们说过了数组名本来就存放的是数组的首地址。&lt;/p&gt;
&lt;p&gt;*(p++)相当于a[i++]，先对p进行*运算，再使p自增。&lt;/p&gt;
&lt;p&gt;指针与二维数组&lt;/p&gt;
&lt;p&gt;a[0]是二维数组第一个元素的地址，可以赋值给一个指针变量。&lt;/p&gt;
&lt;p&gt;a代表二维数组的地址，通过指针运算符可以获取数组中的元素。&lt;/p&gt;
&lt;p&gt;a+n表示第n行的首地址；&lt;/p&gt;
&lt;p&gt;&amp;amp;a[0][0]既可以看做数组0行0列的首地址，还可以看做是二维数组的首地址；&lt;/p&gt;
&lt;p&gt;&amp;amp;a[0]是第0行的首地址；&lt;/p&gt;
&lt;p&gt;a[0]+n是第0行第n个元素的地址；&lt;/p&gt;
&lt;p&gt;*(*(a+n)+m)表示第n行第m列元素；&lt;/p&gt;
&lt;p&gt;*(a[n]+m)表示第n行第m列元素。&lt;/p&gt;
&lt;p&gt;数组指针和指针数组&lt;/p&gt;
&lt;p&gt;这个还没有理解好，尤其是数组指针，指针数组还好理解，就是存储指针变量的数组。&lt;/p&gt;
&lt;p&gt;指针和字符数组&lt;/p&gt;
&lt;p&gt;字符数组就是一个字符串，通过字符指针可以指向一个字符串，然后通过地址的加减实现读取。&lt;/p&gt;
&lt;p&gt;传递地址&lt;/p&gt;
&lt;p&gt;之前接触的函数都是实参传递进函数体后，生成的是实参的副本，函数体内改变副本的值并不会影响到实参，但是如果传递进去的是指针，即使是副本指针，指向的地址还是一样的，因此可以改变指针指向地址的内容。&lt;/p&gt;
&lt;p&gt;指向函数的指针&lt;/p&gt;
&lt;p&gt;指针变量也可以指向一个函数。一个函数在编译时被分配给了一个入口地址，这个地址可以理解为存放在函数名中，可以定义函数指针，指向这个函数，通过指针来调用函数。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;p&gt;int sum(int x, int y)&lt;/p&gt;
&lt;p&gt;int *a(int, int);&lt;/p&gt;
&lt;p&gt;a = sum;&lt;/p&gt;
&lt;p&gt;调用的时候这样：&lt;/p&gt;
&lt;p&gt;int c,d;&lt;/p&gt;
&lt;p&gt;(*a)(c,d);&lt;/p&gt;
&lt;p&gt;还可以定义指针函数，返回值是指针，也就是地址了。&lt;/p&gt;
&lt;p&gt;空指针调用函数&lt;/p&gt;
&lt;p&gt;空类型指针指向任意类型函数或者将任意类型的函数指针赋值给空类型指针都是合法的。使用空指针调用自身所指向的函数仍然按照强制转换的形式使用。&lt;/p&gt;
&lt;p&gt;指针数组&lt;/p&gt;

&lt;p&gt;&lt;span&gt;构造数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;C++ struct结构体变量其实跟数组有点像，只不过数组是相同类型元素的集合，而结构体变量可以是不同类型数据的集合。&lt;/p&gt;
&lt;p&gt;定义结构体变量有两种方式：1、在定义结构体的时候定义；2、定义完之后定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct PersonInfo
{
    int index;
    char name[30];
    short age;
}XiaoMing;

或者
struct PersonInfo
{
    int index;
    char name[30];
    short age;
}
PersonInfo XiaoMing;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引用方式：1.使用成员运算符.来引用；2.定义结构体指针变量之后，使用指向运算符-&amp;gt;来引用&lt;/p&gt;

&lt;p&gt;结构体还可以进行嵌套，结构体的大小一般情况下都是结构体内成员的大小之和。&lt;/p&gt;
&lt;p&gt;使用typedef可以给一个复杂的数据类型定义一个别名，比如int(*)(int i)很复杂，就可以用一个别名来代替。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;枚举类型enum的应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;枚举类型就是用大括号将不同标识符放到一起，变量的值只能取自括号内的值，在定义时，编译器默认将标识符自动赋上整形常数。还可以自行修改整形常数的值，说白了就是一个标识符对应一个常数，用于一些判断或者什么，用起来方便一些。赋值的时候，不能直接赋整型数，但是可以通过强制类型转换来赋值。枚举类型的变量，实质其实是整型的数字，所以可以进行比较和运算。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;结构体变量还可以做函数的参数，还可以使用结构体指针，使用结构体指针减少了时间和空间上的开销，能够提高程序的运行效率。&lt;/p&gt;
&lt;p&gt;结构体还可以创建结构体数组，跟创建结构体变量一样，在定义结构体时创建或者定义完了之后用结构体名这种数据类型创建。可以定义结构体指针，指向数组，使用指向符号-&amp;gt;进行读取，但是要注意，指针加1，指向的就是数组里的下一个结构体了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;共用体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;共用体union数据类型其实和结构体很像，声明共用体数据类型变量和声明共用体变量一样，都有三种方式，前两种应该知道，第三种是省略了共用体数据类型变量名，在定义共用体之后接着声明变量。&lt;/p&gt;
&lt;p&gt;要注意共用体跟结构体最大的区别在于内存方面。共用体变量所占的内存长度等于最长的成员的长度，一个共用体变量不能同时存放多个成员的值，某一时刻只能存放其实一个成员的值，这就是最后赋予他的值。&lt;/p&gt;
&lt;p&gt;共用体的特点是：1.使用共用体变量的目的是希望用同一个内存段存放几种不同类型的数据，但是某个瞬间只能存放一种，而不是同时存放几种；2.能够被访问的是最后一个被赋值的变量，对新的赋值后原来的就失去作用了；3.共用体变量的地址和它的各成员的地址都是同一地址。4.不能对共用体变量名赋值，不能引用变量名来得到哦一个值，不能在定义共用体变量时对它初始化，不能作为函数参数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;跟前面的数据类型重命名一样的，使用typedef标识符进行类型的重命名，或者说是自定义数据类型，其实是为了写起来方便或者用特定的单词代表特殊的意思。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;宏定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用#define 可以对程序中经常出现的参数进行宏定义，这样在之后写代码的时候就可以用宏定义替换，一定程度上减轻了写代码的复杂度，程序在编译的时候自动进行替换，比如PI，一般标识符习惯用大写字母表示，以和变量名进行区分，要注意宏定义不是C语言，不需要在后面加分号，还可以定义数组和运算，定义运算的时候，括号建议都加上，以防止出现错误。如果字符串长于一行，可以在该行末尾用反斜杠\来续行。一般来讲，定义只有，作用域即有效范围指的是定义命令之后到此源文件结束，但也可通过#undef命令终止宏定义的作用域。&lt;/p&gt;

</description>
<pubDate>Wed, 16 Dec 2020 15:47:00 +0000</pubDate>
<dc:creator>不妨不妨，来日方长</dc:creator>
<og:description>一些需要知道的基础知识点： 在程序代码中是通过变量名对内存单元进行存取操作的，但是代码经过编译后将变量名转换为该变量在内存中的存放地址，对变量值的存取都是通过地址进行的。比如i+j的运算，如果i等于3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/masbay/p/13942453.html</dc:identifier>
</item>
<item>
<title>为什么类只能用public修饰? - 阿廖莎</title>
<link>http://www.cnblogs.com/aliaosha/p/14146817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aliaosha/p/14146817.html</guid>
<description>&lt;p&gt;首先，类只能使用public修饰是一个伪命题，应该说我们只见到过使用public修饰的类，还有一些类没有访问修饰符，此时访问权限为default。其次，类实际上分为外部类和内部类（inner class），一般的类都是外部类，内部类需要依赖外部类生成，内部类可以用各种访问修饰符修饰。所以问题转化成，为什么不能使用private和protected修饰外部类？&lt;/p&gt;
&lt;p&gt;我们知道，在Java中，访问修饰符可以修饰类、方法、变量和构造方法。&lt;/p&gt;
&lt;p&gt;访问权限由高到低有以下4种&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;类内部&lt;/th&gt;
&lt;th&gt;本包&lt;/th&gt;
&lt;th&gt;子包&lt;/th&gt;
&lt;th&gt;外部包&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;public&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;protected&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们使用访问修饰符去修饰类，就是为了让类之间根据各种权限来访问。&lt;/p&gt;
&lt;p&gt;假如外部类使用private修饰，则不能被其它类所访问，这个类也就失去了意义。&lt;/p&gt;
&lt;p&gt;假如外部类使用protected修饰，看起来与default相比，在包内可访问的基础上，包外的子类也可访问。但包外想成为子类需要先继承父类，然而无法找到该父类实际上无法继承（先有鸡还是先有蛋的问题），效果与default一致，也就没必要存在了。&lt;/p&gt;
&lt;h2 id=&quot;关于内部类：&quot;&gt;关于内部类：&lt;/h2&gt;
&lt;p&gt;内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。&lt;/p&gt;
&lt;p&gt;成员内部类是定义在另一个类中的类，是最普通的一种内部类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Circle {
    double radius = 0;
     
    public Circle(double radius) {
        this.radius = radius;
    }
     
    class Draw {     //内部类
        public void drawSahpe() {
            System.out.println(&quot;drawshape&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。&lt;/p&gt;
&lt;p&gt;内部类可以用private、protected、default、public修饰，使用private修饰只能在外部类内访问。&lt;/p&gt;
&lt;h2 id=&quot;关于接口&quot;&gt;关于接口&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Comparable&amp;lt;T&amp;gt;{
    int compareTo(T other);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口中的所有方法&lt;strong&gt;自动地&lt;/strong&gt;属于public，在接口中声明方法时不必提供关键字public。&lt;/p&gt;
&lt;h2 id=&quot;修饰构造方法&quot;&gt;修饰构造方法&lt;/h2&gt;
&lt;p&gt;在单例设计模式中，我们使用private修饰构造方法，将构造器私有化，表示在类外部不能实例化该类。在类内部实例化后，提供一个可供外部访问的方法，返回实例对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SingletonTest {
        public static void main(String[] args) {
                //测试
                Singleton instance = Singleton.getInstance();
                Singleton instance2 = Singleton.getInstance();
                System.out.println(instance == instance2); // true
                System.out.println(&quot;instance.hashCode=&quot; + instance.hashCode());
                System.out.println(&quot;instance2.hashCode=&quot; + instance2.hashCode());
        }
}

//饿汉式
class Singleton {
        //1. 构造器私有化
        private Singleton() {
        }
        
        //2.本类内部创建对象实例
        private final static Singleton instance = new Singleton();
        
        //3. 提供一个公有的静态方法，返回实例对象
        public static Singleton getInstance() {
                return instance;
        }
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 16 Dec 2020 15:04:00 +0000</pubDate>
<dc:creator>阿廖莎</dc:creator>
<og:description>为什么类只能使用public修饰？ 首先，类只能使用public修饰是一个伪命题，应该说我们只见到过使用public修饰的类，还有一些类没有访问修饰符，此时访问权限为default。其次，类实际上分为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aliaosha/p/14146817.html</dc:identifier>
</item>
</channel>
</rss>