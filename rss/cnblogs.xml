<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>css怪异盒模型和弹性盒布局(flex)详解及其案例 - 飘逸1997</title>
<link>http://www.cnblogs.com/piaoyi1997/p/12702911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/piaoyi1997/p/12702911.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;一、怪异盒模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;怪异盒模型的属性是box-sizing，他有两个属性值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、content-box&lt;/p&gt;
&lt;p&gt;　　这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;简而言之就是&lt;/strong&gt;，一般的盒子都是属于这种，最显著的特点就是加上padding后，盒子会被撑大，需要减去对应的高度或宽度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1955160/202004/1955160-20200415081111442-614130566.png&quot; alt=&quot;&quot;/&gt;2、border-box&lt;/p&gt;
&lt;p&gt;　　为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。&lt;/p&gt;
&lt;p&gt;通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。&lt;/p&gt;
&lt;p&gt;　　简而言之，为盒子添加高度或宽度之后，再给盒子添加border和padding不会使盒子撑大，边框和padding都限制在盒子内部，常用于移动端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1955160/202004/1955160-20200415081125995-2034074151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、弹性盒布局&lt;/h2&gt;
&lt;p&gt;Flex容器：采用 Flex 布局的元素的父元素；&lt;br/&gt;Flex项目：采用 Flex 布局的元素的父元素的子元素；&lt;br/&gt;容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；&lt;/p&gt;
&lt;p&gt;交叉轴的开始位置叫做cross start，结束位置叫做cross end。&lt;em id=&quot;__mceDel&quot;&gt;项目默认沿主轴排列。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;能实现下面这种骰子布局，那么恭喜你，就说明弹性盒已经掌握了，下面介绍弹性盒具体的用法及案例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1955160/202004/1955160-20200415081530806-141189647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;flex容器属性&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;1、触发弹性盒：display:flex、inline-flex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　　注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;2、flex-direction属性 决定主轴的方向（即项目的排列方向）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　　flex-direction: row | row-reverse | column | column-reverse;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;3、flex-wrap属性，定义子元素是否换行显示　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　　flex-wrap: nowrap(默认值，不换行) | wrap（换行） | wrap-reverse(反向换行);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;4、 flex-flow&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　　flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;5、 justify-content属性 定义了项目在主轴（）上的对齐方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　　justify-content: flex-start | flex-end | center | space-between(两端对齐) | space-around（自动分配）;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;6、align-items属性定义项目在侧轴上如何对齐&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　　align-items: flex-start | flex-end | center | baseline | stretch（默认值）;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;7、align-content属性定义了多根轴线的对齐方式。对于单行子元素，该属性不起作用。&lt;/span&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　align-content: flex-start | flex-end | center | space-between | space-around | stretch;&lt;br/&gt;　　align-content在侧轴上执行样式的时候，会把默认的间距给合并。对于单行子元素，该属性不起作用&lt;/p&gt;

&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;flex项目属性&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;1、align-self属性&lt;/span&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;　　Internet Explorer 和 Safari 浏览器不支持 align-self 属性&lt;br/&gt;　　align-self 属性规定灵活容器内被选中项目的对齐方式。&lt;br/&gt;　　注意：align-self 属性可重写灵活容器的 align-items 属性。&lt;br/&gt;　　属性值&lt;br/&gt;　　　　auto 默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 &quot;stretch&quot;。&lt;br/&gt;　　　　Stretch 元素被拉伸以适应容器。&lt;br/&gt;　　　　Center 元素位于容器的中心。&lt;br/&gt;　　　　flex-start 元素位于容器的开头。&lt;br/&gt;　　　　flex-end 元素位于容器的结尾。&lt;/p&gt;
&lt;p&gt;2、order&lt;/p&gt;
&lt;p&gt;说明：&lt;br/&gt;　　number排序优先级，数字越大越往后排，默认为0，支持负数。&lt;/p&gt;
&lt;p&gt;3、flex　&lt;/p&gt;
&lt;p&gt;说明：&lt;br/&gt;　　复合属性。设置或检索弹性盒模型对象的子元素如何分配空间&lt;br/&gt;　　详细属性值：&lt;br/&gt;　　缩写「flex: 1」, 则其计算值为「1 1 0%」&lt;br/&gt;　　缩写「flex: auto」, 则其计算值为「1 1 auto」&lt;br/&gt;　　flex: none」, 则其计算值为「0 0 auto」&lt;br/&gt;　　flex: 0 auto」或者「flex: initial」, 则其计算值为「0 1 auto」，即「flex」初始值&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;4、flex-xxx&lt;/span&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　flex-grow&lt;br/&gt;　　　　一个数字，规定项目将相对于其他灵活的项目进行扩展的量。&lt;br/&gt;　　flex-shrink&lt;br/&gt;　　　　一个数字，规定项目将相对于其他灵活的项目进行收缩的量。&lt;br/&gt;　　flex-basis&lt;br/&gt;　　　　项目的长度&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;具体实现代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;172&quot;&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;style&amp;gt;&lt;/p&gt;
&lt;p&gt;        *{&lt;/p&gt;
&lt;p&gt;            margin: 0;&lt;/p&gt;
&lt;p&gt;            padding: 0;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        html,body{&lt;/p&gt;
&lt;p&gt;            width: 100%;&lt;/p&gt;
&lt;p&gt;            height: 100%;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        body{&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            justify-content: space-around;&lt;/p&gt;
&lt;p&gt;            align-items: center;&lt;/p&gt;
&lt;p&gt;            flex-wrap: wrap;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        body&amp;gt;div{&lt;/p&gt;
&lt;p&gt;            width: 100px;&lt;/p&gt;
&lt;p&gt;            height: 100px;&lt;/p&gt;
&lt;p&gt;            background-color: #eee;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        span{&lt;/p&gt;
&lt;p&gt;            display: block;&lt;/p&gt;
&lt;p&gt;            width: 24px;&lt;/p&gt;
&lt;p&gt;            height: 24px;&lt;/p&gt;
&lt;p&gt;            background-color: #000;&lt;/p&gt;
&lt;p&gt;            border-radius: 12px;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(1){&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            justify-content: center;&lt;/p&gt;
&lt;p&gt;            align-items: center;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(2){&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            justify-content: space-between;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(2) span:nth-child(2){&lt;/p&gt;
&lt;p&gt;            align-self: flex-end;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(3){&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            justify-content: space-between;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(3) span:nth-child(2){&lt;/p&gt;
&lt;p&gt;            align-self: center;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(3) span:nth-child(3){&lt;/p&gt;
&lt;p&gt;            align-self: flex-end;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(4){&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            justify-content: space-between;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(4) p{&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            flex-direction: column;&lt;/p&gt;
&lt;p&gt;            justify-content: space-between;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(5){&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            justify-content: space-between;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(5) p{&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            flex-direction: column;&lt;/p&gt;
&lt;p&gt;            justify-content: space-between;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(5) p:nth-child(2){&lt;/p&gt;
&lt;p&gt;            justify-content: center;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(6){&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            justify-content: space-between;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        div:nth-child(6) p{&lt;/p&gt;
&lt;p&gt;            display: flex;&lt;/p&gt;
&lt;p&gt;            flex-direction: column;&lt;/p&gt;
&lt;p&gt;            justify-content: space-between;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    &amp;lt;/style&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;div&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;div&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;div&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;div&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;p&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;p&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;div&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;p&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;p&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;p&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;div&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;p&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;p&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;如果感觉对自己有帮助，麻烦点一下关注，会一直盒大家分享知识的，谢谢！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 15 Apr 2020 00:27:00 +0000</pubDate>
<dc:creator>飘逸1997</dc:creator>
<og:description>一、怪异盒模型 怪异盒模型的属性是box-sizing，他有两个属性值： 1、content-box 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/piaoyi1997/p/12702911.html</dc:identifier>
</item>
<item>
<title>15分钟从零开始搭建支持10w+用户的生产环境(一) - Tiger.Wang</title>
<link>http://www.cnblogs.com/tiger-wang/p/12699547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-wang/p/12699547.html</guid>
<description>
&lt;p&gt;这是一个基于中小型企业或团队的架构设计。&lt;/p&gt;

&lt;p&gt;不考虑大厂。有充分的理由相信，大厂有绝对的实力来搭建一个相当复杂的环境。&lt;/p&gt;

&lt;p&gt;中小型企业或团队是个什么样子？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发团队人员配置不全，部分人员身兼开发过程上下游的数个职责；&lt;/li&gt;
&lt;li&gt;没有专职的维护人员，或者维护人员实力不足以完全掌控生产和开发环境。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种情况下，过于复杂的生产环境设计，规划、安装、调试、修改会牵扯太多的精力。一旦使用过程中出现问题，涉及的技术复杂性会带来不可预估的灾难。&lt;/p&gt;

&lt;p&gt;同时，中小型团队的系统，也有其特殊要求，主要表现在：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生产环境的搭建要简单。这个主要是考虑到人员的技术实力。毕竟要求一个开发人员，能熟练安装各种系统的运行环境，是有点太高了；&lt;/li&gt;
&lt;li&gt;生产环境的扩展性要足够。因为资金原因，通常前期的服务器资源会比较紧张，而一旦有资金进入，用户量会短时间扩大，服务器资源需求也相应扩大，就需要在不改动代码的情况下，通过简单的操作，把生产环境扩展成较大规模的架构；&lt;/li&gt;
&lt;li&gt;需要充分考虑到开发环境与生产环境的衔接。国内大多数开发团队，是采用windows开发，linux布署的模式。这种模式下，开发和生产环境中各个部分的选择尤为重要。最理想的情况，是开发和生产在不同的操作系统下，同环境同代码，避免代码重编译和移植。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文就是针对这样的要求，进行的设计。&lt;/p&gt;



&lt;p&gt;Linux。毫无疑问，服务器的操作系统，必须是linux。&lt;/p&gt;

&lt;p&gt;很多人选择windows做为服务器操作系统，是因为windows更熟悉，有图形管理界面，比较容易操作。&lt;/p&gt;

&lt;p&gt;但实际上，linux做为操作系统的优势更明显：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;命令行跟图形界面，仅是输入方式的区别，从功能上没有实质性的区别；命令行更快捷，而且可以形成命令序列，即脚本。&lt;/p&gt;
&lt;p&gt;装linux一定不要装GUI，这是一个非常重要的习惯，而且会显得很&lt;strong&gt;专业&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Linux是开源免费的，或接近免费的，既不存在版权问题，也不存在成本问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在相同硬件的情况下，linux更&lt;strong&gt;容易获得&lt;/strong&gt;更高的性能。更容易的意思是，不需要进行太多的配置和调整。在一般使用下，安装完直接使用，性能就很高了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linux有很多发行版。通常的选择是Redhat、CentOS、Debian。Redhat是个商业版本，有一定的费用。CentOS、Debian，是免费版本。&lt;/p&gt;
&lt;p&gt;中小团队，收费版本就不考虑了。两个免费的版本中，CentOS相对激进点，预装软件会采用比较新的版本，甚至会有测试版本；Debian相对保守，预装的软件都是稳定的版本。另外，CentOS预装的软件比Debian多，所以体积大一些，启动时要加载的东西多一些。&lt;/p&gt;
&lt;p&gt;我建议选择用Debian，稳定，占用硬盘小，占用运行内存少。&lt;/p&gt;
&lt;p&gt;至于Ubunut、Arch Linux、Mint，学习linux的时候可以好好用，服务器上就算了。如果linux您自己本身不熟悉，就别自找麻烦。&lt;/p&gt;

&lt;p&gt;至于linux的内核版本，在购买VPS服务器的时候，镜像都是做好的，没多少可选，用最高版本就好。内核的每个升级，都解决了一些问题，也带来了一些问题。如果不清楚这些问题在哪，或者不知道怎么解决这些问题，就假装不知道。操作系统的问题，包括BUG，包括遗留的内容，我们很难遇到的。&lt;/p&gt;

&lt;p&gt;最后多说一句，服务器操作系统一定选择x64的版本，即64位的版本。在服务器上安装应用软件，也要优先选择x64的版本。现在的主流硬件，PC都是x64的，更别说服务器了。&lt;/p&gt;

&lt;p&gt;Debian官网：&lt;a href=&quot;https://www.debian.org/&quot;&gt;https://www.debian.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;独立的服务器，需要从Debian官网下载ISO进行安装。云服务器，在购买时会先选择安装的镜像。安装的步骤略过，如果需要我可以另开一个贴子写写。&lt;/p&gt;

&lt;p&gt;有几个简单的安全方面的内容需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;远程连接服务器时，一定要用ssh。命令是：&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt; username@ip
&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt; username@domain
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Windows下没有内建的ssh命令，可以下一个Putty，也要使用ssh模式。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;远程登录时，尽量少用root。安装完成后，建一个普通用户，用这个普通用户进行远程登录。进去后，用su升权或用sudo进行操作。&lt;/li&gt;
&lt;li&gt;上传文件使用ssh通道。命令是：&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scp&lt;/span&gt; source_file username@ip:~/target_folder/&lt;span&gt;target_file
&lt;/span&gt;&lt;span&gt;scp&lt;/span&gt; source_file username@domain:~/target_folder/target_file
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;　Windows下可以装一个WinScp来上传文件。&lt;/span&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;小心使用网上建议的任何方式来改动服务器，除非你知道你在做什么。&lt;/li&gt;
&lt;li&gt;在绝大多数情况下，自己开发的应用跑在服务器上时，如果服务器出现了CPU高或内存满的情况，去查代码，而不是怀疑服务器如何如何，也不是去调整服务器的运行参数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;(未完待续)&lt;/p&gt;

&lt;hr/&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/907112/202004/907112-20200411144539593-552337529.jpg&quot; alt=&quot;&quot; width=&quot;159&quot; height=&quot;159&quot;/&gt;&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;微信公众账号：老王Plus&lt;/p&gt;
&lt;p&gt;如果你想及时得到个人文章以及内容的消息推送，或者想看看个人推荐的技术资料，可以扫描左边二维码（或者长按识别二维码）关注个人公众号）。&lt;/p&gt;
&lt;p&gt;本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 15 Apr 2020 00:18:00 +0000</pubDate>
<dc:creator>Tiger.Wang</dc:creator>
<og:description>前言 这是一个基于中小型企业或团队的架构设计。 不考虑大厂。有充分的理由相信，大厂有绝对的实力来搭建一个相当复杂的环境。 中小型企业或团队是个什么样子？ 开发团队人员配置不全，部分人员身兼开发过程上下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tiger-wang/p/12699547.html</dc:identifier>
</item>
<item>
<title>大专学历以后就职会不会有瓶颈 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12702817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12702817.html</guid>
<description>&lt;blockquote readability=&quot;4.9333333333333&quot;&gt;
&lt;p&gt;二哥，看了你的那篇&lt;a href=&quot;https://mp.weixin.qq.com/s/MH9o6JyrMNF1N2ISqsfTnw&quot;&gt;外包程序员的文章&lt;/a&gt;，想问问您，大专学历以后就职会不会有瓶颈，升职难什么的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是读者阿莫私信我的一个问题，我觉得很有必要认真地谈一谈。单从这个问句上，我现在就可以给出一个无比肯定的回答：“谁要说没有瓶颈，那绝对是骗人的。”&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/dazhuan-01.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;先说一点。这句提问很简短，但有一个瑕疵，眼睛雪亮的读者一眼就能看得出来——先用了“你”，再用了“您”。不是我在故意鸡蛋里挑骨头，我没那么闲，用“您”肯定是为了表示尊重，这点值得褒奖，但如果前后不一致就会透露出一点：做事不够细心谨慎，还不如都用“你”。&lt;/p&gt;
&lt;p&gt;PS：&lt;strong&gt;做事细心谨慎对职业发展有着极其大的好处，这也是很多职场新人容易忽视的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其实对于我来说，是极不习惯用“您”的，因为我个人感觉有点不自然。虽然出于礼貌，我偶尔在别人用“您”的时候选择用“您”来投桃报李，但聊天就会变得拘谨。如果你也想问我问题，大可不必纠结在这两个字，用“你”就好。因为我是一个挺接地气的人，没那么高冷。相信我，所以好的提问我都会认真回答的，如果时间来不及，我会把聊天对话置顶的。&lt;/p&gt;
&lt;p&gt;然后来说说大专学历的事。&lt;/p&gt;
&lt;p&gt;直接说吧。我是一名大专生，虽然复读了一年，成绩仍然不理想，离二本分数线差点，这倒不是说我不争气，学习不好，也有一些偶然的因素，比如说高考前一天失眠。&lt;/p&gt;
&lt;p&gt;我相信在数也数不清的高考经历中，失眠是挺正常的一件事。我两次的成绩都离二本线差了两道语文选择题的分数吧，如果没记错的话。因为三本学费家里也负担不起，就上了大专。&lt;/p&gt;
&lt;p&gt;我妹妹去年参加了高考，成绩没够到本科线（不存在一本二本三本了），于是我强烈建议她选择了复读。&lt;/p&gt;
&lt;p&gt;妹妹比我小十一岁，代沟都有了。十年前的大专生和现在的大专生在社会上受到的歧视程度肯定也发生了变化。因为学校在扩招，意味着大专学历的竞争力在下降。&lt;/p&gt;
&lt;p&gt;毕业那年，我虽然成功找到了一份工作，但学历上没少受到歧视。要不是在工作能力上脱颖而出，很难在公司混出个模样。毕竟公司三四百号员工，大专生也就三四个人——我就占据了一个名额，凭什么要重视你？&lt;/p&gt;
&lt;p&gt;我那时候就挺难，何况十年后的现在呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你是一名大专生，首先要考量的就是专升本，能升就升&lt;/strong&gt;。升到本科后，我的建议就和之前的一样了，别想着考研了。考研是需要时间、金钱、智力的，不是说所有人都能考研成功的，不要抱着试一试的心态。专升本的难度显然要比考研的难度低，但性价比是极高的。&lt;/p&gt;
&lt;p&gt;除了提升学历，你必须要再做一些其他方面的事情，来提高你整体的竞争力。比如说写博客、搞开源、学英语——这三项不仅能提高你技术上的硬实力，还会给你带来无限的可能性。&lt;/p&gt;
&lt;p&gt;如果你有自学能力的话，大专三年加上专升本两年，五年时间，足够你破茧成蝶了。&lt;/p&gt;
&lt;p&gt;我第二次高考失败后选择上了大专，大三就去参加了工作。我有一个高中同学，关系一直很铁，他第二次高考失败后选择了复读，第三年终于考上了本科。这就意味着，我比他提前两年遭受社会的毒打了。&lt;/p&gt;
&lt;p&gt;对于我们的选择来说，没有孰对孰错。但私下里交流的时候，他总说羡慕我的决定，&lt;strong&gt;提前到社会上锤炼比把时间浪费在高考上面更值得去做&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在我看来，高考两次足够了，因为第三次会彻底把一个人对未来的憧憬扼杀掉，无论成功与否——我身边有好几个活生生的例子。&lt;/p&gt;
&lt;p&gt;如果必须接受大专生的命运，那么专升本无疑是首选，哪怕仍然会受到歧视，但本科的学历有总比没有好一些，除非你有其他的竞争力。&lt;/p&gt;
&lt;p&gt;这些年，我认识了太多优秀的年轻人。在他们身上，我看到了一种优秀的品质，无论他们的学历如何，他们自信，善于模仿和思考，然后付诸行动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接受那些不可改变的，然后努力去改变那些可以改变的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就拿我来说吧，自从高考失败后，我就特别讨厌考试。大学两年挂科了三次，英语四级考了两次均告失败，学渣无疑了。经过培训参加工作后，领导一开始是不认可的，因为那时候表达能力也很弱，自卑的很。&lt;/p&gt;
&lt;p&gt;后来得知公司非常重视 Flex，就提前半年去钻源码，顺带搞了个聊天工具，积攒了一大把实战经验。当时一块进入公司的同事呢，都还处在领导安排什么就做什么的阶段。这种情况下，学历就不再是我升职加薪的瓶颈了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/dazhuan-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;很明显，公司更看重的是你解决问题的能力，&lt;strong&gt;不管白猫黑猫，总要会逮老鼠&lt;/strong&gt;。如果你学历好，解决不了问题那肯定不会受到重视；如果你学历不好，又解决不了问题，那肯定是被优化的对象；如果你学历不好，但像我，项目需要你，你能带给公司其他同事带来不了的东西，那肯定就会受到重视。&lt;/p&gt;
&lt;p&gt;综上来看，我能提供的两种思路就是：第一，能专升本就升；第二，如果升不了，已经进入了公司，千万别只做一名搬砖工，你得赢得先机。&lt;/p&gt;
&lt;p&gt;通过和领导同事的交流，你一定能够得到公司要发展某些项目、某些技术的信息，提前做好准备，把一些成果亮出来给他们看，通过博客也好、产品也好、开源也好。&lt;/p&gt;
&lt;p&gt;公司里不乏平庸的领导，但能成为公司，肯定会有肯发掘人才的领导，他们一定能够发现你领先别人的才能，那么一旦抓住机会，学历就不再是你升职加薪的绊脚石了。&lt;/p&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。&lt;/p&gt;
&lt;p&gt;我是沉默王二，一枚有趣的程序员。&lt;strong&gt;原创不易，莫要白票&lt;/strong&gt;，请你为本文点个赞吧，这将是我写作更多优质文章的最强动力。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Apr 2020 23:10:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>二哥，看了你的那篇外包程序员的文章，想问问您，大专学历以后就职会不会有瓶颈，升职难什么的？ 以上是读者阿莫私信我的一个问题，我觉得很有必要认真地谈一谈。单从这个问句上，我现在就可以给出一个无比肯定的回</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12702817.html</dc:identifier>
</item>
<item>
<title>CVPR2020文章汇总 | 点云处理、三维重建、姿态估计、SLAM、3D数据集等(12篇) - 3D视觉工坊</title>
<link>http://www.cnblogs.com/YongQiVisionIMAX/p/12702797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YongQiVisionIMAX/p/12702797.html</guid>
<description>&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;aq30b-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aq30b-0-0&quot;&gt;作者：Tom Hardy&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2fl7t-0-0&quot;&gt;Date：2020-04-15&lt;/span&gt;&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;csm50-0-0&quot;&gt;1.PVN3D: A Deep Point-wise 3D Keypoints Voting Network for 6DoF PoseEstimation&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;c380k-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c380k-0-0&quot;&gt;文章链接：https://arxiv.org/abs/1911.04231&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;bjog7-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bjog7-0-0&quot;&gt;代码链接：https://github.com/ethnhe/PVN3D&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;e1ku5-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e1ku5-0-0&quot;&gt;在这项工作中，论文提出了一种新的数据驱动下的方法，可以从单一的RGB-D图像中进行鲁棒的6自由度物体姿态估计。与往前直接回归姿态参数的方法不同，本文使用基于关键点的方法来处理这一具有挑战性的任务。具体地说，提出了一个深度Hough投票网络来检测物体的三维关键点，并使用最小二乘拟合的方式估计6D姿态参数。论文的方法是二维关键点方法的自然扩展，成功地用于基于RGB的六自由度估计。它可以充分利用具有额外深度信息的刚性物体的几何约束，便于网络学习和优化。通过大量的实验验证了三维关键点检测在6D姿态估计任务中的有效性。实验结果还表明，论文的方法在多个基准上都比最新的方法有很大的性能提升。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-991afd532cb6e5762f2a38d26d30c357_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;253&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-991afd532cb6e5762f2a38d26d30c357.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-1a98717df87c4ab6940d0e321f7b6f30.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-abc93e8a0395c8ae9cd7440fea3193ec_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;241&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-abc93e8a0395c8ae9cd7440fea3193ec.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-018449db45d7a7af5c640bd12e0dade4.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;55c2a-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;2.D3VO: Deep Depth, Deep Pose and Deep Uncertainty for Monocular VisualOdometry&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;4p9fi-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4p9fi-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：https://arxiv.org/abs/2003.01060&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;9atd9-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9atd9-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文提出D3VO作为一个新的单目视觉里程测量框架，它利用深度、姿态和不确定性三个层次的深层网络。本文首先提出了一种新的无需外部监控的立体视频单目深度估计网络，它通过预测亮度变换参数将训练图像对对齐到相似的照明条件中。此外，还对输入图像上像素的光度不确定性进行了建模，提高了深度估计的精度，并为直接（无特征）视觉里程测量中的光度残差提供了学习的加权函数。评价结果表明，网络的性能优于现有的自监督深度估计网络。D3VO将预测的深度、姿态和不确定性紧密地结合到一种直接的视觉里程测量方法中，既提高了前端跟踪性能，又提高了后端非线性优化性能。论文在KITTI odometry基准和EuRoC MAV数据集上根据单目视觉里程计评估D3VO。结果表明，D3VO算法在很大程度上优于目前最先进的单目VO算法。它在仅使用一个摄像头下还获得了与KITTI上最先进的立体声/激光雷达里程表和EuRoC MAV上最先进的视觉惯性里程表相当的结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-2c795f3b4751075af520d2a84123894d_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;388&quot; data-rawheight=&quot;309&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-2c795f3b4751075af520d2a84123894d.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-67bc01daf68e1451e6dbb0cd2579670c.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-f371aa353b123e84b2ff31f1a42739bf_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;276&quot; data-rawheight=&quot;301&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-f371aa353b123e84b2ff31f1a42739bf.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-2347aa5ded0c82999bc4ef9fa9427298.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/80/v2-0480dcda48f88099873b624e4a6b4e17_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;377&quot; data-rawheight=&quot;209&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-0480dcda48f88099873b624e4a6b4e17.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-2e738a9ebed9ac2fe1d2e160c64b4623.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;3ap98-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;3.Total3DUnderstanding: Joint Layout, Object Pose and MeshReconstruction for Indoor Scenes from a Single Image&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;2ntup-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2ntup-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：http://arxiv.org/abs/2002.12212v1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;9bt7h-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9bt7h-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;室内场景的语义重建是指场景理解和物体重建。现有的工作要么解决这个问题的一部分，要么关注独立的对象。本文将理解与重建之间的鸿沟联系起来，提出了一种端到端的方法来从单个图像中联合重建房间布局、对象边界框和网格。本文的方法没有分别解决场景理解和对象重建问题，而是建立在整体场景上下文的基础上，提出了一个由粗到细的层次结构，该层次结构由三个部分组成：带相机姿势的房间布局、三维对象边界框、对象网格。我们认为，理解每个组件的上下文有助于解析其他组件，从而实现联合理解和重构。在SUN-RGBD和Pix3D数据集上的实验表明，该方法在室内布局估计、三维目标检测和网格重建方面均优于现有方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-1b8e8b090e8da4d6bbd1b47f5ca1c9e2_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;266&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-1b8e8b090e8da4d6bbd1b47f5ca1c9e2.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-4b3f505d38887e194b45442970d93a7d.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-c2cee6f7e3b0463fcaf663e72d2459e2_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;178&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-c2cee6f7e3b0463fcaf663e72d2459e2.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-e594d8da9e569901eb6c2c019a5108f3.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-8a7ba9f0941db720816118d354180e1c_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;390&quot; data-rawheight=&quot;145&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-8a7ba9f0941db720816118d354180e1c.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-fcf3c096e1353679e0445e313fb18124.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-a2dd4fae264d1efc93dae0b16d1f5258_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;449&quot; data-rawheight=&quot;199&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-a2dd4fae264d1efc93dae0b16d1f5258.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-138d8a3ce67965254e867b421c4f866a.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-23341682861d6f755ba85ef0030eabea_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;331&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-23341682861d6f755ba85ef0030eabea.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-7c6dbf5111bb23307b2cb7820aa794d1.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;8kiph-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;4.RPM-Net: Robust Point Matching using Learned Features&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;9b7lc-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9b7lc-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：http://arxiv.org/abs/2003.13479v1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;fm27l-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fm27l-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;代码链接：https://github.com/yewzijian/RPMNet&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;8ppkh-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8ppkh-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;迭代最近点法（ICP）分两步迭代求解刚性点云配准问题：（1）对空间上最近点对应关系进行硬赋值，然后（2）求出最小二乘刚性变换。基于空间距离的最近点对应的硬赋值对初始刚性变换和噪声/离群点敏感，往往导致ICP收敛到错误的局部极小值。本文提出了RPM网络，一种对初始化不敏感的基于深度学习的刚性点云配准方法。网络使用可微Sinkhorn层和退火算法从空间坐标和局部几何中学习的混合特征中获得点对应的软分配。为了进一步提高配准性能，论文引入二次网络来预测最优退火参数。与某些现有方法不同，RPM网络可以处理缺少的对应关系和部分可见性的点云。实验结果表明，与现有的非深度学习和最新的深度学习方法相比，本文的RPM网络达到了SOTA。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-1af21166679f2bdcc019d0417473c886_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;263&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-1af21166679f2bdcc019d0417473c886.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-094beab59cd1a55897cf6166f9147cf6.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-52c54409dc57273fe235beef70f0141c_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;375&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-52c54409dc57273fe235beef70f0141c.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-a44e8007a60c6517ee4cccfee0d1424b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;82kff-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;5.Learning multiview 3D point cloud registration&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;2g88c-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2g88c-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：https://arxiv.org/abs/2001.05119v2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;dq0du-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dq0du-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;代码链接：https://github.com/zgojcic/3D_multiview_reg&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;d694m-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;d694m-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文提出了一种新的、端到端可学习的多视点三维点云配准算法。多个扫描的注册通常遵循两个阶段的流程：初始成对对齐和全局一致优化。前者由于相邻点云重叠程度低、对称性强、场景部分重复等原因，往往具有模糊性。因此，后一种全局求精旨在建立跨多个扫描的循环一致性，并有助于解决不明确的情况。本文提出了第一个端到端的算法来联合学习这两个阶段的问题。在公认的基准数据集上进行的实验评估表明，论文的方法比目前最先进的方法有显著的优势，同时具有端到端可训练和计算成本较低的特点。此外，还提出了详细的分析和消融研究，验证了论文方法的新组成部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-d6b2b7c17fc5cd0e3e2ac8e8706e9332_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;376&quot; data-rawheight=&quot;202&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-d6b2b7c17fc5cd0e3e2ac8e8706e9332.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-f14030fceebec1e1fef589e9d686da8f.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-6c6c3b18f1fb83af88644a8fd1b6eed8_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;151&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-6c6c3b18f1fb83af88644a8fd1b6eed8.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-5fc11a727a41242178f354cf04bdce16.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;2q518-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;6.D3Feat: Joint Learning of Dense Detection and Description of 3DLocal Features&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;elr5i-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;elr5i-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：http://arxiv.org/abs/2003.03164v1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;aq47i-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aq47i-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;代码链接：https://github.com/XuyangBai/D3Feat&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;osiq-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;osiq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;一个成功的点云配准通常依赖于通过区分三维局部特征建立稀疏匹配。尽管基于学习的三维特征描述子的发展很快，但是对于三维特征检测器的学习却没有引起足够的重视，更不用说对这两个任务的联合学习了。本文利用三维全卷积网络对三维点云进行学习，提出了一种新的、实用的学习机制，该学习机制可以对每个三维点的检测分数和描述特征进行密集预测。特别地，提出了一种克服三维点云固有密度变化的关键点选择策略，并进一步提出了一种在训练过程中由实时特征匹配结果引导的自监督检测器损耗。最后，本文的方法在室内和室外场景下都取得了最新的结果，在3DMatch和KITTI数据集上进行了评估，并在ETH数据集上显示出了很强的泛化能力。在实际应用中，采用可靠的特征检测器，对少量特征进行采样，就可以实现精确快速的点云对齐。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-9def471bef83381102c4d36b744267bf_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;112&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-9def471bef83381102c4d36b744267bf.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-f930e3d81b6593baf0aa98fac6afeb03.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-4d25971ab69a241ef419ed646a682115_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;122&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-4d25971ab69a241ef419ed646a682115.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-7c15fa23c8bcc21781ba2613db03c1bf.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7vb60-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;7.SPARE3D: A Dataset for SPAtial REasoning on Three-View Line Drawings&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;9atft-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9atft-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：http://arxiv.org/abs/2003.14034v1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;5uhkb-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5uhkb-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;数据集链接：https://ai4ce.github.io/SPARE3D&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;nrql-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;nrql-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;空间推理是人类智能的重要组成部分。我们可以想象三维物体的形状和它们的空间关系的原因，只需在二维中查看它们的三个视图线，它们具有不同的层次&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;5eepk-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5eepk-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;能力。深层网络能被训练来执行空间推理任务吗？我们如何测量他们的“空间智能”？为了回答这些问题，论文展示了SPARE3D数据集。基于认知科学和心理测量学，SPARE3D包含视图一致性、相机姿态和形状生成三种类型的2D-3D推理任务，难度越来越大。我们设计了一种方法来自动生成大量具有挑战性的问题，每个任务都有基本的真实答案。它们用于提供监督，以使用最先进的架构（如ResNet）来培训基线模型。实验表明，尽管卷积网络在许多视觉学习任务中都取得了超人的性能，但它们在SPARE3D中的空间推理性能几乎等同于随机猜测。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;9eqah-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9eqah-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们希望SPARE3D能够激发新的空间推理问题公式和网络设计，使智能机器人能够通过二维传感器在三维世界中有效地工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-0ba15dd1b7b453a36205b43b19440423_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;413&quot; data-rawheight=&quot;250&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-0ba15dd1b7b453a36205b43b19440423.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-0d8266a21e44aaed479b501fa716d99c.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-12294155001234a3df7c5287dfffea15_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;352&quot; data-rawheight=&quot;305&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-12294155001234a3df7c5287dfffea15.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-998741359181f5529b7431428840abd1.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-2e4f758b49f0fc8eadae7070c66ac42f_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;240&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-2e4f758b49f0fc8eadae7070c66ac42f.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-518ff1c786e7585698322fb4393006c9.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;430t7-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;8.InPerfectShape: Certifiably Optimal 3D Shape Reconstruction from 2DLandmarks&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;fa2hr-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fa2hr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：http://arxiv.org/abs/1911.11924v2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;6v3lh-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6v3lh-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;本文研究了从单个图像中提取的二维地标进行三维形状重建的问题。采用三维可变形形状模型，将重建过程描述为摄像机姿态和线性形状参数的联合优化。论文的第一个贡献是应用Lasserre的凸平方和（SOS）松弛层次来解决形状重建问题，并证明了最小2阶的SOS松弛在经验上精确地解决了原非凸问题。论文的第二个贡献是利用目标函数中多项式的结构，找到SOS松弛的基单项式的约化集，该约化集在不影响精度的情况下显著减小了得到的半定程序（SDP）的大小。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;fniug-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fniug-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这两个贡献导致了第一个可证明的三维形状重建最优解算器，我们称之为shape*。论文的第三个贡献是利用截断最小二乘（TLS）鲁棒代价函数和梯度非凸性求解TLS添加了一个离群拒绝层的shape*，无需初始化。结果是一个健壮的重建算法，命名为Shape#，它可以容忍大量的异常值测量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-d7d5402da38538e17bf629bfb7ea2e45_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;292&quot; data-rawheight=&quot;360&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-d7d5402da38538e17bf629bfb7ea2e45.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-c8efb63f1c01026eaa8400e41a79653c.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;a7euq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;9.PFNet: Point Fractal Network for 3D Point Cloud Completion&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;91it3-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;91it3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：http://arxiv.org/abs/2003.00410v1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;4lluu-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4lluu-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;本文提出了一种新的基于学习的点云精确高保真完成方法——点分形网络（PFNet）。PFNet不同于现有的点云补全网络，它从不完整的点云中生成点云的整体形状，并且总是改变现有的点，遇到噪声和几何损失，它保留了不完整点云的空间布局，并能计算出缺失点云的详细几何结构预测中的区域。为了成功地完成这一任务，PF-Net利用基于特征点的多尺度生成网络，对缺失点云进行分层估计。此外，论文将多阶段完成损失和对抗性损失相加，生成更为真实的缺失区域。在预测中，对抗性损失可以更好地处理多种模式。实验证明了论文中的方法对于一些具有挑战性的点云补全任务的有效性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-a4d005117d0b24172ecfeefe15ac4c49_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;334&quot; data-rawheight=&quot;186&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-a4d005117d0b24172ecfeefe15ac4c49.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-61de611d31c68dc4430f3726e62424dc.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-c8f6b52ca2151af13ad6fcd8fd6e9ae5_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;211&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-c8f6b52ca2151af13ad6fcd8fd6e9ae5.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-ce9c019abcf1006acc73b9b0b12b6b0f.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-b175daaf86f0fe050919036a5a6ff91f_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;397&quot; data-rawheight=&quot;254&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-b175daaf86f0fe050919036a5a6ff91f.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-2314fc7bbe0c8af930c13d36a287a567.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;biaps-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;10.PointAugment: An Auto-Augmentation Framework for Point CloudClassification&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;9m4f6-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9m4f6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：http://arxiv.org/abs/2002.10876v2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;847qn-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;847qn-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文提出了一种新的自动增强框架PointAugment，它在训练分类网络时自动优化和增强点云样本，以丰富数据的多样性。与现有的二维图像自增强方法不同，PointAugment具有样本感知能力，采用对抗学习策略对增强器网络和分类器网络进行联合优化，使增强器能够学习生成最适合分类器的增强器样本。此外，本文还利用形状变换和点位移构造了一个可学习的点增广函数，并根据分类器的学习进度精心设计了采用增广样本的损失函数。大量的实验也证实了PointAugment的有效性和鲁棒性，以及提高各种网络在形状分类和检索方面的性能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-a4c22ed844a66e457561a39bc3e159d2_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;327&quot; data-rawheight=&quot;185&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-a4c22ed844a66e457561a39bc3e159d2.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-29e41aed45539bde867c5369392bafd5.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-a271ae0c247e503953168646086a079a_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;360&quot; data-rawheight=&quot;267&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-a271ae0c247e503953168646086a079a.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-d20cddf8454609e73f2a4e20c0918a9e.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;aljr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;11.PointASNL: Robust Point Clouds Processing using Nonlocal NeuralNetworks with Adaptive Sampling&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;dp4m5-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dp4m5-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：https://arxiv.org/abs/2002.10876v2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;6s45t-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6s45t-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;代码链接：https://github.com/yanx27/PointASNL&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;aso26-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aso26-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;原始点云数据通过三维传感器采集或重建算法，不可避免地会包含异常点或噪声。本文提出了一种新的端到端的点云处理网络PointASNL，它能有效地处理带有噪声的点云。该方法的关键部分是自适应采样（AS）模块。它首先从最远点采样（FPS）开始对初始采样点周围的邻域重新加权，然后自适应地调整整个点云之外的采样点。AS模块不仅有利于点云的特征学习，而且可以缓解异常点的偏倚效应。为了进一步捕获针对采样点的邻域依赖性和长距离依赖性，论文提出了一种基于非局部操作的局部非局部（L-NL）模型。这种L-NL模块使得学习过程对噪声不敏感。大量实验验证了该方法在点云处理任务中的稳健性和优越性，无论是合成数据、室内数据和有无噪声的室外数据。PointASNL在所有数据集上实现了分类和分割任务的最新鲁棒性能，并且在噪声情况下，在SemanticKITTI数据集上显著地优于以前的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/80/v2-050995cd1da89195e85418c6a30b60d4_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;413&quot; data-rawheight=&quot;182&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-050995cd1da89195e85418c6a30b60d4.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-804f90ecae8da2919801b3d6b7e46f5f.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-28c90653f1348ef0bd350482a719f9a0_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;173&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-28c90653f1348ef0bd350482a719f9a0.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-b08656176ec50d8ae754fe720b65ae11.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-d95de82b40980e681a827d7ad5a0f0d4_720w.webp&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;353&quot; data-rawheight=&quot;174&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-d95de82b40980e681a827d7ad5a0f0d4.webp&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-423df3554d1505568e2408a3caea6292.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;a9t22-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;12.RandLANet: Efficient Semantic Segmentation of Large-Scale PointClouds&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;8hf20-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8hf20-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;论文链接：http://arxiv.org/abs/1911.11236v2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;1ohk0-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1ohk0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;本文研究了大规模三维点云的有效语义分割问题。依靠昂贵的采样技术或计算量大的前/后处理步骤，大多数现有方法只能在小尺度点云上进行训练和操作。本文介绍了一种高效、轻量级的神经网络结构RandLA-Net，用于直接推断大规模点云的逐点语义。论文方法的关键是使用随机点采样而不是更多复杂点选择方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e6mf0&quot; data-offset-key=&quot;6l1fl-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6l1fl-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;尽管随机抽样具有显著的计算效率和存储效率，但它可能会偶然丢弃关键特征。为了克服这一缺点，论文引入了一种新的局部特征聚合模块来逐步增加每个3D点的接收场，从而有效地保留几何细节。大量实验表明，RandLA网络在一次传递中可以处理100万个点，比现有方法快200倍。此外， RandLA网络Semantic3D 和SemanticKITTI两个大规模基准上明显超过了最新的语义分割方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-8199c80473dbd13b2b83ecd7bb3f5054_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;352&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-8199c80473dbd13b2b83ecd7bb3f5054.png&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-7185a8afd38f8b3da8fc51880f16740c.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/80/v2-0c48a5c905a9a525dc38b35db888b7d0_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;203&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-0c48a5c905a9a525dc38b35db888b7d0.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-866f9ed52866f8301e80b6830a395ad3.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-f5036a06e66f82978dcff9a378f09645_720w.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;170&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-f5036a06e66f82978dcff9a378f09645.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-28fc559495c6d37bd1ee8d6a95c64568.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 14 Apr 2020 22:22:00 +0000</pubDate>
<dc:creator>3D视觉工坊</dc:creator>
<og:description>作者：Tom Hardy Date：2020-04-15 来源：CVPR2020文章汇总 | 点云处理、三维重建、姿态估计、SLAM、3D数据集等(12篇) 1.PVN3D: A Deep Point</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/YongQiVisionIMAX/p/12702797.html</dc:identifier>
</item>
<item>
<title>面试官在“逗”你系列：不借助第三变量交换两个变量值的方案你有几种？ - 胡哥有话说</title>
<link>http://www.cnblogs.com/justbecoder/p/12702624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justbecoder/p/12702624.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在我们学习编程之初，就学习过变量的赋值操作，同时也学习了将一个变量的值赋值给另外一个变量。对于交换两个变量的值，很多童鞋都有解决方案。然鹅，对于面试官提出的不借助第三变量来交换两个变量的值，你能想到几种解决方案呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你只知道一种方案，请你认真看下去...&lt;br/&gt;如果你知道两种方案，那么你可以来了解更多方案了...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、最简单的实现-最初的记忆&quot;&gt;一、最简单的实现-最初的记忆&lt;/h2&gt;
&lt;p&gt;让我们由浅入深，来了解交换变量值的最简单、最初的解决方案：借助于第三个变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 声明变量a和b
let a = 5
let b = 4
// 1. 临时将变量a的值赋值给变量tmp
let tmp = a
// 2. 将变量b的值赋值给a
a = b
// 3. 将变量a的值(tmp的值)赋值给b
b = tmp

console.log(a) // 4
console.log(b) // 5

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;so east!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二、不借助第三变量的实现-es6版&quot;&gt;二、不借助第三变量的实现-ES6版&lt;/h2&gt;
&lt;p&gt;面试官在听到上面给出的解决方案后，微微一笑（脑海中闪现到：你以为就这么简单）说道，有其他解决方案吗，不借助第三变量呢？&lt;/p&gt;
&lt;p&gt;了解学习了JS ES6的数组解构赋值的童鞋对此冷冷一笑，嘴角一撇，冷酷酷地说道：也可以使用ES6的数组解构赋值来交换变量的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = 5;
let b = 4; // 请注意此位置的分号;是一定要存在的呀

// 数组结构赋值，交换变量a,b的值
[a, b] = [b, a]

console.log(a) // 4
console.log(b) // 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;看到面试官的脸色似乎渐渐露出了满意的神色，内心是不是有点儿窃喜。&lt;br/&gt;如果此刻面试官又说道，还有没有其他的解决方案，小朋友，你是不是有许多问号？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三、不借助第三变量的实现-终极版本一：单纯数学运算&quot;&gt;三、不借助第三变量的实现-终极版本一：单纯数学运算&lt;/h2&gt;
&lt;p&gt;胡哥在这里再次强调，这绝对不是一个考验“智商”的答案，只是考验了在编程的变通能力以及经验问题，下面请看代码的实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = 5
let b = 4

// 接下来就是见证神奇的时刻，来，镜头请对准我。

// 二者之和
a = a + b
// 二者之和 - b的值，剩余a的值赋值给变量b
b = a - b
// 此刻a还是二者之和，a - b此刻相当于二者之和 - 变量b(a的值)，那么此刻剩余的就是变量b的值，赋值给a变量
a = a - b

// yes, we did!
console.log(a) // 4
console.log(b) // 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果此刻面试官再问出还有没有其他的方案，此刻你会慌的一比呢，还是内心大喊“wc”呢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四、不借助第三变量的实现-终极版本二：位运算符&quot;&gt;四、不借助第三变量的实现-终极版本二：位运算符^&lt;/h2&gt;
&lt;p&gt;不要怕，兄弟们，接下来给大家来分享第四种方式，位运算符 ^ 异或。在变量的运算中这个操作符有什么作用呢？&lt;/p&gt;
&lt;p&gt;异或运算符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;是执行位运算的，二进制运算，参与变量运算的两个变量要转为二进制进行运算。
如果相同二进制位的值相同，则转为0，否则转为1.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那交换两个变量的值具体代码是如何实现的呢？请看大屏幕，哦，不，请往下看。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = 5 // 0101
let b = 4 // 0100

// 按位异或运算
a = a ^ b // 0101 ^ 0100 ===&amp;gt; 0001，此时a的值为1
b = a ^ b // 0001 ^ 0100 ===&amp;gt; 0101，此时b的值为5
a = a ^ b // 0001 ^ 0101 ===&amp;gt; 0100，此时a的值为4

console.log(a) // 4
console.log(b) // 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;惊不惊喜，意不意外。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上四种实现交换两个变量值得方案你都掌握了吗，如果掌握了，可以对面试官反手就是一个“吊打”了。&lt;br/&gt;如果你有更多的解决交换两个变量值的方案，欢迎留言交流呀！&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;收藏&lt;/code&gt;呦，关注胡哥有话说，学习前端不迷路，欢迎多多留言交流...&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;胡哥有话说，一个有技术，有情怀的胡哥！现任京东前端攻城狮一枚。&lt;br/&gt;胡哥有话说，专注于大前端技术领域，分享前端系统架构，框架实现原理，最新最高效的技术实践！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 14 Apr 2020 16:50:00 +0000</pubDate>
<dc:creator>胡哥有话说</dc:creator>
<og:description>引言 在我们学习编程之初，就学习过变量的赋值操作，同时也学习了将一个变量的值赋值给另外一个变量。对于交换两个变量的值，很多童鞋都有解决方案。然鹅，对于面试官提出的不借助第三变量来交换两个变量的值，你能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justbecoder/p/12702624.html</dc:identifier>
</item>
<item>
<title>从JDK源码学习HashSet和HashTable - tr1ple</title>
<link>http://www.cnblogs.com/tr1ple/p/12701149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tr1ple/p/12701149.html</guid>
<description>&lt;p&gt;Java中的集合（Collection）有三类，一类是List，一类是Queue，再有一类就是Set。 前两个集合内的元素是有序的，元素可以重复；最后一个集合内的元素无序，但元素不可重复。&lt;/p&gt;
&lt;p&gt;Set:&lt;/p&gt;
&lt;p&gt;1.用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复&lt;/p&gt;
&lt;p&gt;2.对象的相等性本质是对象hashCode值（java是依据对象的内存地址计算出的此序号,不同对象的hashcode不一定不一样）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法，比如string类就重写了hashcode方法，算出的hashcode值并不是对象的实际内存地址，equals也被重写了&lt;/p&gt;
&lt;p&gt;String.hashcode()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414203324734-2128661353.png&quot; alt=&quot;&quot; width=&quot;648&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt; String.equals&lt;/p&gt;
&lt;p&gt;1.先验证是否是否是同一个对象&lt;/p&gt;
&lt;p&gt;2.再验证是否是同一类型(String),然后验证值是否相等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414203437256-2145488525.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;468&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hashset也是支持序列化、浅拷贝的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414203926257-1308712453.png&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hashset内部还是Hashset，只不过调用它的add直接放入的不再是键值对&lt;/p&gt;
&lt;p&gt;看下其add方法：&lt;/p&gt;
&lt;p&gt;直接调用map.put放入e所代表的的键以及present成员变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414204659699-1294174393.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;57&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这里的map就是hashset内部存储值的结构，可以看到其键是放入的，键所对应的值是object的实例&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414204800230-460358021.png&quot; alt=&quot;&quot; width=&quot;727&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然其用的hashmap，那么其构造方法实际上就是定义hashmap，所以就是hashmap的那四种构造方法&lt;/p&gt;
&lt;p&gt;那么取值的时候不像hashmap那么方便可以直接取某个键对应的值，取hashset中的值是获得一个迭代器，取得内部hashmap所有的键然后遍历再进行操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414210251829-1106863201.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 所以其内部存储时结构也和hashmap结构一样了，同时hashset也是非线程安全的&lt;/p&gt;
&lt;h2&gt;ArrayList和HashSet的区别&lt;/h2&gt;
&lt;p&gt;1.前者有序，可存放重复值，后者无序，不可存放重复值，因为hashmap键不能重复&lt;/p&gt;
&lt;p&gt;2.Arraylist被填满扩充1.5倍，Hashset扩充机制和hashmap相同&lt;/p&gt;

&lt;p&gt;HashTable实现的map接口，支持序列化和浅拷贝&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414212601301-1612881431.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hashtable也是&quot;拉链法&quot;实现的hash表(只是数组加单链表)，其内部存储结构为entry数组，和hashmap类似，其也有负载因子和初始容量&lt;/p&gt;
&lt;p&gt;其构造方法也有4种&lt;/p&gt;
&lt;p&gt;第一种如下支持初始指定容量和负载因子，此时将给entry分配内存空间，并且初始化阈值为初始容量和(2的31次-1)-8(最大值字节数)+1的较小值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414223958455-734898345.png&quot; alt=&quot;&quot; width=&quot;789&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二种只指定初始化大小&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414230157516-1250332.png&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;35&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三种使用默认初始容量和负载因子，初始容量为11&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414230239834-969137291.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;72&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四种则是直接放入一个map进来初始化构造一个hashtable，此时的hashtable容量将变为放入的map的键值对的个数的2倍和默认容量的较大值，然后再将map放入&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414230325596-1057277781.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;85&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而hashmap这里是和hashtable不一样的，初始化时将用放入的map的键值数量/负载因子+0.75，算出的值再和2的30次方做比较，取两者较小值和阈值进行比较，并赋值阈值为大于算出值最接近的2的次方值，便于后面resize扩容，然后后面再通过循坏将map中的值依次放入&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414230726884-1514268633.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类， AbstractMap 是基于 Map 接口的实现，但hashtable和hashmap二者都实现了Map接口&lt;/p&gt;
&lt;p&gt;2.hashmap可以放键和值均为null的值，但是这样的值你也只能放一个进去，所以hashmap中判断是否存在某个键要用containskey(键必定是唯一的)，而不能用get，因此能有多个键对应的value都是null，而hashtable的键和值不可以为null，否则将会报空指针错误&lt;/p&gt;
&lt;p&gt;hashmap的处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414234228152-972999728.png&quot; alt=&quot;&quot; width=&quot;783&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以hashmap考虑到了这种key为null的情况，让其hash算出来为0，不为null的key再调用object的hashcode方法算hash&lt;/p&gt;
&lt;p&gt;hashmap的get方法如下图，不存在也有可能返回null或者键的值为null，无法判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414235716485-1300831286.png&quot; alt=&quot;&quot; width=&quot;789&quot; height=&quot;106&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hashtable的处理：&lt;/p&gt;
&lt;p&gt;hashtable的设计并没有考虑这么多，而是直接调用其key的hashcode，那么null.hashcode，必将报错&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414234405607-877891525.png&quot; alt=&quot;&quot; width=&quot;793&quot; height=&quot;143&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hashtable将检测放入的键对应的值是否为null&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200414233717036-1098637294.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.hashmap在默认情况下是非线程安全的，而hashtable以为基本public方法都是用synchronized修饰的，因此其为同步的&lt;/p&gt;
&lt;p&gt;4.两者的扩容方式不一样，hashmap扩容是resize方法，容量变为old*2，而hashtable是rehash方法，容量变为old*2+1，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200415000745207-952531579.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.两者内部遍历实现不一样：&lt;/p&gt;
&lt;p&gt;hashmap的键值遍历为iterator&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200415001502589-984004176.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;333&quot;/&gt;&lt;/p&gt;

&lt;p&gt;hashtable的键值遍历为Enumerator&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200415001659695-1462575811.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 6.获取键所在的位置时的方法不同：&lt;/p&gt;
&lt;p&gt;hashmap中首先用与逻辑代替了模运算加快了速度，2的n次方-1位全1二进制位再与key的hash与算出键值对的位置，并且其hash值并不是单纯的hashcode，而是用到了key的hashcode的高16位来做异或运算&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200415002052014-196912221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200415002205405-1456251120.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;

&lt;p&gt; hashtable中是根据key直接算一个hashcode(可能为负值)，然后再和2的31次方-1做与算出来的正值再模当前hash表的长度，然后确定键值对的位置，那么取模的效率肯定没有与逻辑的运行效率更高&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1063309/202004/1063309-20200415002353342-1387718631.png&quot; alt=&quot;&quot; width=&quot;789&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fujiakai/article/details/51585767&quot;&gt;https://blog.csdn.net/fujiakai/article/details/51585767&lt;/a&gt; hashmap和hashtable区别&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.jikexueyuan.com/project/java-collection/hashtable.html&quot;&gt;https://wiki.jikexueyuan.com/project/java-collection/hashtable.html&lt;/a&gt; hashmap实现原理&lt;/p&gt;
</description>
<pubDate>Tue, 14 Apr 2020 16:34:00 +0000</pubDate>
<dc:creator>tr1ple</dc:creator>
<og:description>HashSet Java中的集合（Collection）有三类，一类是List，一类是Queue，再有一类就是Set。 前两个集合内的元素是有序的，元素可以重复；最后一个集合内的元素无序，但元素不可重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tr1ple/p/12701149.html</dc:identifier>
</item>
<item>
<title>Gradle系列之初识Gradle - 躬行之</title>
<link>http://www.cnblogs.com/jzmanu/p/12702356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jzmanu/p/12702356.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文首发于微信公众号：躬行之(jzman-blog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习 Android 有一段时间了，开发中经常使用到 Gradle ，但是不知道 Gradle 构建项目的原理，计划花一点时间学习一下 Gradle 相关的知识。Gradle 是一个非常优秀的项目构建工具，其 DSL(领域特定语言)基于 Groovy 实现，大部分功能通过插件的方式来实现，也可以自定义 Gradle 插件，下面开始入门 Gradle 系列的第一篇。&lt;/p&gt;
&lt;h4 id=&quot;配置-gradle-环境&quot;&gt;配置 Gradle 环境&lt;/h4&gt;
&lt;p&gt;首先确保在环境变量中配置好 JAVA_HOME，使用如下命令查看是否配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行日志如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190421231509484.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准备一个 Gradle 版本，下载之后进行解压，解压之后的目录说明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin：gradle批处理文件
docs：说明文档
init.d：初始化的脚本文件
lib：相关库
media：自带的图标资源
samples：案例
src：源文件
getting-started.html：入门指导链接
LICENSE
NOTICE
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在环境变量中配置 GRADLE_HOME ，具体指的是 Gradle 的解压目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190421231554557.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，添加将 GRADLE_HOME\bin 配置到 Path 中，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190421231621580.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后打开控制台，使用命令 gradle -v 查看 Gradle 版本信息，如果能够正确显示 Gradle 版本号、Groovy 版本号、JVM 等相关信息，说明 Gradle 环境已经配置成功，配置成功 gradle -v 执行结果参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study&amp;gt; gradle -v
------------------------------------------------------------
Gradle 4.1
------------------------------------------------------------

Build time:   2017-08-07 14:38:48 UTC
Revision:     941559e020f6c357ebb08d5c67acdb858a3defc2

Groovy:       2.4.11
Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015
JVM:          1.8.0_91 (Oracle Corporation 25.91-b14)
OS:           Windows 10 10.0 amd64
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，Window 上的 Gradle 构建环境就搭建好了。&lt;/p&gt;
&lt;h4 id=&quot;gradle-版-hello-world&quot;&gt;Gradle 版 Hello World&lt;/h4&gt;
&lt;p&gt;学习任何一门语言，毫无疑问当然是运行 Hello World ，这里实现一个 Hello World 的 Gradle 脚本，创建一个名为 build.gradle 的脚本，脚本内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;task hello{
        doLast{
                println 'Hello world'
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 gradle -q hello 命令执行上述脚本，结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study&amp;gt; gradle -q hello
Hello world
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;build.gradle 是 Gradle 默认的构建脚本文件，执行命令时会默认加载当前目录下的 build.gradle 脚本文件，这个构建脚本定义了一个名为 hello 的任务（Task），里面的 doLast 是 Task 中的一个 Action，当这个 Task 执行完毕之后要回调 doLast 里面的代码，使用 gradle 命令时的参数 -q 是指定输出的日志级别，关于 gradle 日志输出级别将在下文中介绍。&lt;/p&gt;
&lt;h4 id=&quot;gradle-wrapper&quot;&gt;Gradle Wrapper&lt;/h4&gt;
&lt;p&gt;Wrapper 是对 Gradle 的一层包装，方便在团队中统一管理 Gradle 的版本，项目开发中通常使用的 Wrapper 这种方式，使用 Wrapper 之后就不需要采用配置 Gradle 的构建环境的方式，使用 Wrapper 启用 Gradle 的时候，Wrapper 会检查 Gradle 有没有下载关联，如果没有下载则从配置的地址下载并进行构建，这就一定程度上方便开发人员构建项目。&lt;/p&gt;
&lt;h5 id=&quot;生成-wrapper&quot;&gt;生成 Wrapper&lt;/h5&gt;
&lt;p&gt;Gradle 提供了内置的 Wrapper Task 来生成 Wrapper 所需的目录文件，在相应的目录执行 gradle wrapper 命令即可生成，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study&amp;gt; gradle wrapper

BUILD SUCCESSFUL in 3s
1 actionable task: 1 executed
PS E:\Gradle\study&amp;gt; cd wrapper
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 gradle wrapper 生成的文件目录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;│─gradlew
│─gradlew.bat
└─gradle
    └─wrapper
            gradle-wrapper.jar
            gradle-wrapper.properties
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 gradlew 和 gradlew.bat 分别是 Linux 和 Window 下的可执行脚本，使用方式和原生的 gradle 命令一样，gradle-wrapper.jar 是根据具体业务实现的 jar 包，gradlew 最终还是通过这个 jar 包来执行相关的 gradle 相关操作，gradle-wrapper.properties 是用来配置使用哪一个版本的 gradle 进行构建操作。&lt;/p&gt;
&lt;h5 id=&quot;wrapper-配置&quot;&gt;Wrapper 配置&lt;/h5&gt;
&lt;p&gt;在使用 gradle wrapper 生成相关文件的时候，可以指定 wrapper 要使用的版本号以及 gradle 的下载地址，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//指定使用的Gradle版本
gradle wrapper --gradle-version 3.3
//指定下载Gradle的地址
gradle wrapper --gradle-distribution-url ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Gradle 默认的版本是当前 Gradle 的版本，下载地址参考如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https\://services.gradle.org/distributions/gradle-4.1-all.zip
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面来看一看 Gradle 的配置文件 gradle-wrapper.properties 的几个字段含义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;distributionBase //下载的Gradle压缩包解压后存储的主目录
distributionPath //相对于distributionBase解压后压缩包的路径
zipStoreBase //相对于distributionBase存放Gradle压缩包的
zipStorePath //相对于distributionPath存放Gradle压缩包的
distributionUrl //Gradle的下载地址，一般是官网地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个 Android 项目的 Gradle 的配置文件，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#Mon Dec 28 10:00:20 PST 2015
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顺便介绍一下几个属性值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//表示用户目录，用户目录下 .gradle 下的目录
GRADLE_USER_HOME
//表示项目目录，项目底下 gradlew 所在的目录
PROJECT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个值可以用来设置 distributionBase 和 zipStoreBase 的值&lt;/p&gt;
&lt;h5 id=&quot;自定义-wrapper-task&quot;&gt;自定义 Wrapper Task&lt;/h5&gt;
&lt;p&gt;Gradle 的配置文件 gradle-wrapper.properties 是由 Wrapper Task 生成的，可以不通过自定义 Wrapper Task 可以用来配置 gradle-wrapper.properties 文件，下面是自定义 Wrapper Task 的一个实例，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;task wrapper(type: Wrapper){
        gradleVersion = '3.3'
        distributionBase='GRADLE_USER_HOME'
        distributionPath='wrapper/dists'
        //注意不要这样写：https\://services...
        distributionUrl=&quot;https://services.gradle.org/distributions/gradle-3.3-all.zip&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样可以定义生成 Wrapper 的 Gradle 版本及相关存储目录。&lt;/p&gt;
&lt;h4 id=&quot;gradle-日志&quot;&gt;Gradle 日志&lt;/h4&gt;
&lt;p&gt;使用 Gradle 构建项目时，可以指定日志级别来显示相关的日志信息，Gradle 的日志级别主要有六种，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ERROR //错误消息
QUIET //重要消息
WARNING //警告消息
LIFECYCLE //进度消息
INFO //信息消息
DEBUG //调试信息
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用时可以通过命令行的方式控制日志显示级别，下面是可以使用命令控制的日志选项，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-q 或 --quiet //表示QUIET及其更高级别
-i 或 --info //表示INFO及其更高级别
-d 或 --debug //DEBUG 及其更高级别（输出所有日志）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不指定，则默认输出的日志是 LIFECYCLE 及其更高级别的日志。&lt;/p&gt;
&lt;p&gt;日志主要跟踪构建过程以及调试错误，下面介绍在项目构建过程中堆栈信息的输出以及如何使用日志信息来进行调试。&lt;/p&gt;
&lt;h5 id=&quot;输出堆栈信息&quot;&gt;输出堆栈信息&lt;/h5&gt;
&lt;p&gt;默认情况下，堆栈信息的输出是关闭的，可以通过命令行的堆栈信息开关打开它，当构建失败后，Gradle 会将输出错误的堆栈信息，方便定位和分析问题，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-s 或 --stacktrace //输出关键性的堆栈信息
-S 或 --full--stacktrace //输出全部堆栈信息
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般使用 -s 就可以了。&lt;/p&gt;
&lt;h5 id=&quot;日志信息调试&quot;&gt;日志信息调试&lt;/h5&gt;
&lt;p&gt;最简单的日志记录当然是在合适的位置打印想要看的变量即可，可以使用 print 系列方法将日志输出到控制台，这属于 QUIET 级别的日志，也可以使用内置的 logger 来控制不同级别日志的显示，及 DEBUG 输出日志最完整、ERROR 输出日志最少，使用方式参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//日志测试
task hello{
        doLast{
                println 'Hello world'
                print 'Hi'
                logger.quiet('quiet 日志')
                logger.lifecycle('lifecycle 日志')
                logger.error('error 日志')
                logger.info('info 日志')
                logger.warn('warn 日志')
                logger.debug('debug 日志')
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Gradle 日志基本内容如上，多在实际项目中实践才是最重要的。&lt;/p&gt;
&lt;h4 id=&quot;gradle-命令行&quot;&gt;Gradle 命令行&lt;/h4&gt;
&lt;p&gt;使用命令行在一定程度上了解构建过程，相较在 IDE 上的便捷性，使用命令行可以知其然知其所以然，只要是可以使用命令行的，都可以通过帮助获取命令来查看可执行的命令，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gradle -h
gradle -?
gradle -help
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过如上命令查看可执行的命令。&lt;/p&gt;
&lt;h5 id=&quot;查看可执行-tasks&quot;&gt;查看可执行 Tasks&lt;/h5&gt;
&lt;p&gt;这里以 Wrapple 为例，可以使用 ./gradlew tasks 查看可执行的 Tasks，执行结果以分组形式输出，一个是关于构建的(Build Setup tasks)，另一个是关于帮助的(Help tasks)，执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\wrapper&amp;gt; ./gradlew tasks
:tasks

------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Build Setup tasks
-----------------
init - Initializes a new Gradle build. [incubating]
wrapper - Generates Gradle wrapper files. [incubating]

Help tasks
----------
components - Displays the components produced by root project 'wrapper'. [incubating]
dependencies - Displays all dependencies declared in root project 'wrapper'.
dependencyInsight - Displays the insight into a specific dependency in root project 'wrapper'.
help - Displays a help message.
model - Displays the configuration model of root project 'wrapper'. [incubating]
projects - Displays the sub-projects of root project 'wrapper'.
properties - Displays the properties of root project 'wrapper'.
tasks - Displays the tasks runnable from root project 'wrapper'.

To see all tasks and more detail, run gradlew tasks --all

To see more detail about a task, run gradlew help --task &amp;lt;task&amp;gt;

BUILD SUCCESSFUL

Total time: 8.4 secs
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;查看某个-task-的帮助&quot;&gt;查看某个 Task 的帮助&lt;/h5&gt;
&lt;p&gt;Gradle 内置一个 help task,这个 Task 可以可以了解某一个 Task 的使用帮助，具体命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//命令格式
gradle help --task Task名称
//举例
gradle help --task projects
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\wrapper&amp;gt; gradle help --task projects

&amp;gt; Task :help
Detailed task information for projects

Path
     :projects

Type
     ProjectReportTask (org.gradle.api.tasks.diagnostics.ProjectReportTask)

Description
     Displays the sub-projects of root project 'wrapper'.

Group
     help


BUILD SUCCESSFUL in 1s
1 actionable task: 1 executed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 Task 的帮助信息可以看到当前 Task 的分组、类型以及额外参数。&lt;/p&gt;
&lt;p&gt;此外，开发中常常使用第三方库，那么如何强制刷新第三方依赖呢，使用命令构建项目的时候添加参数 --refresh-dependencies，有时候需要同时运行多个任务，可将具体的任务使用空格分开，如 ./gradlew t1 t2，Gradle 提供了基于驼峰命名法的缩写调用，可以使用如下方式简写调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//Task
newTask
//命令
./gradlew nt
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;这是初识 Gradle 的第一篇文章，主要对 Gradle 及相关命令有了一定的了解，也是以后学习 Gradle 构建项目的基础，关于 Gradle 的学习希望能够将这个系列写完。&lt;/p&gt;
&lt;p&gt;如果感兴趣，可以关注公众号：躬行之(jzman-blog)，一起交流学习。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/758808/202004/758808-20200414234923568-2057374025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Apr 2020 16:00:00 +0000</pubDate>
<dc:creator>躬行之</dc:creator>
<og:description>原文首发于微信公众号：躬行之(jzman blog) 学习 Android 有一段时间了，开发中经常使用到 Gradle ，但是不知道 Gradle 构建项目的原理，计划花一点时间学习一下 Gradl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jzmanu/p/12702356.html</dc:identifier>
</item>
<item>
<title>Golang Web入门（1）：自顶向下理解Http服务器 - 红鸡菌</title>
<link>http://www.cnblogs.com/hongjijun/p/12702292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongjijun/p/12702292.html</guid>
<description>&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;由于Golang优秀的并发处理，很多公司使用Golang编写微服务。对于Golang来说，只需要短短几行代码就可以实现一个简单的Http服务器。加上Golang的协程，这个服务器可以拥有极高的性能。然而，正是因为代码过于简单，我们才应该去研究他的底层实现，做到会用，也知道为什么这么用。&lt;/p&gt;
&lt;p&gt;在本文中，会以自顶向下的方式，从如何使用，到如何实现，一点点的分析Golang中net/http这个包中关于Http服务器的实现方式。内容可能会越来越难理解，作者会尽量把这些源码讲的更清楚一些，希望对各位有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;1-创建&quot;&gt;1 创建&lt;/h2&gt;
&lt;p&gt;首先，我们以怎么用为起点。&lt;/p&gt;
&lt;p&gt;毕竟，知道了怎么用，才能一步一步的深入挖掘为什么这么用。&lt;/p&gt;
&lt;p&gt;先来看&lt;strong&gt;第一种&lt;/strong&gt;最简单的创建方式（省略了导包）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func helloWorldHandler(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &quot;Hello World !&quot;)
}

func main() {
        http.HandleFunc(&quot;/&quot;, helloWorldHandler)
        http.ListenAndServe(&quot;:8000&quot;, nil)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实在这一部分中，代码应该很容易理解。就是先做一个映射，把&lt;strong&gt;需要访问的地址&lt;/strong&gt;，和&lt;strong&gt;访问后执行的函数&lt;/strong&gt;，写在一起。然后再加上监听的端口，就可以了。&lt;/p&gt;
&lt;p&gt;如果你是一个Java程序员，你应该能发觉这个和Java中的&lt;strong&gt;Servlet&lt;/strong&gt;很相似。也是创建一个个的Servlet，然后注册。&lt;/p&gt;
&lt;p&gt;再来看看&lt;strong&gt;第二种&lt;/strong&gt;创建方式，也一样省略了导包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type helloWorldHandler struct {
        content string
}

func (handler *helloWorldHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, handler.content)
}

func main() {
        http.Handle(&quot;/&quot;, &amp;amp;helloWorldHandler{content: &quot;Hello World!&quot;})
        http.ListenAndServe(&quot;:8000&quot;, nil)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我们能发现相较于第一种方法，有&lt;strong&gt;些许&lt;/strong&gt;的改动。&lt;/p&gt;
&lt;p&gt;我们定义了一个结构体，然后又给这个结构体编写了一个&lt;strong&gt;方法&lt;/strong&gt;。根据我们之前对于接口的概念：要实现一个接口必须要实现这个接口的&lt;strong&gt;所有方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么我们是不是可以推测：存在这么一个接口A，里面有一个名为ServeHTTP的方法，而我们所编写的这个结构体，他已经实现了这个接口A了，他现在是属于这个A类型的一个结构体了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type A interface{
    ServeHTTP()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且，在main函数中关于映射URI和方法的参数部分，需要调用实现了这个接口A的一个对象。&lt;/p&gt;
&lt;p&gt;带着这个问题，我们可以继续往下。&lt;/p&gt;
&lt;h2 id=&quot;2-注册&quot;&gt;2 注册&lt;/h2&gt;
&lt;p&gt;在第一部分，我们提到了两种注册方式，一种是传入一个函数，一种是传入一个结构体指针。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.HandleFunc(&quot;/&quot;, helloWorldHandler)

http.Handle(&quot;/&quot;, &amp;amp;helloWorldHandler{content: &quot;Hello World!&quot;})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看看http包内的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package http

func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
            DefaultServeMux.HandleFunc(pattern, handler)
}

func Handle(pattern string, handler Handler) {
        DefaultServeMux.Handle(pattern, handler) 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看一下这里的代码，他们被称为&lt;strong&gt;注册函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先研究一下&lt;code&gt;HandleFunc&lt;/code&gt;这个函数。在&lt;code&gt;main&lt;/code&gt;函数中，调用了这个具有&lt;code&gt;func(pattern string, handler func(ResponseWriter, *Request))&lt;/code&gt;签名的函数，这里的&lt;code&gt;pattern&lt;/code&gt;是&lt;code&gt;string&lt;/code&gt;类型的，指的是匹配的URI，这个很容易理解。第二个参数是一个具有&lt;code&gt;func(ResponseWriter, *Request)&lt;/code&gt;签名的函数。&lt;/p&gt;
&lt;p&gt;然后我们继续看，在这个函数中，调用了这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
        if handler == nil {
                panic(&quot;http: nil handler&quot;)
        }
        mux.Handle(pattern, HandlerFunc(handler))
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，最终是调用了&lt;code&gt;DefaultServeMux&lt;/code&gt;对象的&lt;strong&gt;Handle方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;好，先到这里，我们再看一看刚刚提到的签名为&lt;code&gt;func (pattern string, handler Handler)&lt;/code&gt;另外一个函数。在这个函数里面，&lt;strong&gt;同样&lt;/strong&gt;是调用了&lt;code&gt;DefaultServeMux&lt;/code&gt;对象的&lt;strong&gt;Handle方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就是说，无论我们使用哪种注册函数，最终调用的都是这个函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (mux *ServeMux) Handle(pattern string, handler Handler)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里涉及到了两种对象，第一是&lt;code&gt;ServeMux&lt;/code&gt;对象，第二是&lt;code&gt;Handler&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ServeMux&lt;/code&gt;对象我们一会再聊，先聊聊&lt;code&gt;Handler&lt;/code&gt;对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Golang中，Handler是一种接口类型，只要实现了&lt;code&gt;ServeHTTP&lt;/code&gt;这个方法，那个就可以称这个结构体是&lt;code&gt;Handler&lt;/code&gt;类型的。&lt;/p&gt;
&lt;p&gt;注意到，在前面有一行代码是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mux.Handle(pattern, HandlerFunc(handler))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有人可能会想，&lt;code&gt;HandlerFunc func(ResponseWriter, *Request)&lt;/code&gt;这个函数，是输入一个函数，返回一个&lt;code&gt;Handler&lt;/code&gt;类型的对象，其实这是不对的。我们来看看这个函数的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
        f(w, r)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以发现，这个函数，他是一个结构体类型，而且这个结构体也是实现了&lt;code&gt;ServeHTTP&lt;/code&gt;方法的，也就是说，这个结构体也是一个&lt;code&gt;Handler&lt;/code&gt;类型。所以，这个方法其实并不是输入一组参数，返回一个&lt;code&gt;Handler&lt;/code&gt;类型，而是他本身就是一个&lt;code&gt;Handler&lt;/code&gt;类型，可以直接调用&lt;code&gt;ServeHTTP&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;这里比较绕，但是相信当你理解了之后，会感觉&lt;strong&gt;妙啊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;说完了&lt;code&gt;Handler&lt;/code&gt;，我们再来聊聊&lt;code&gt;ServeMux&lt;/code&gt;。先来看看他的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type ServeMux struct {
        mu    sync.RWMutex
        m     map[string]muxEntry
        es    []muxEntry // slice of entries sorted from longest to shortest.
        hosts bool       // whether any patterns contain hostnames
}

type muxEntry struct {
        h       Handler
        pattern string
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先关注一下这个结构里面的&lt;code&gt;m&lt;/code&gt;字段。这个字段是一个&lt;code&gt;map&lt;/code&gt;类型，key是&lt;code&gt;URI&lt;/code&gt;，value是&lt;code&gt;muxEntry&lt;/code&gt;类型。而这个&lt;code&gt;muxEntry&lt;/code&gt;类型，里面包含了一个&lt;code&gt;Handler&lt;/code&gt;和&lt;code&gt;URI&lt;/code&gt;。也就是说，通过这个&lt;code&gt;m&lt;/code&gt;字段，我们可以用&lt;code&gt;URI&lt;/code&gt;找到对应的&lt;code&gt;Handler&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;继续说回上面提到的&lt;code&gt;func (mux *ServeMux) Handle(pattern string, handler Handler)&lt;/code&gt;方法。我们已经知道了调用这个方法的对象是&lt;code&gt;ServeMux&lt;/code&gt;，也知道了这个方法的参数中的&lt;code&gt;Handler&lt;/code&gt;是什么，下面让我们来看看这个方法的详细实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (mux *ServeMux) Handle(pattern string, handler Handler) {
        mux.mu.Lock()
        defer mux.mu.Unlock()

        if pattern == &quot;&quot; {
                panic(&quot;http: invalid pattern&quot;)
        }
        if handler == nil {
                panic(&quot;http: nil handler&quot;)
        }
        if _, exist := mux.m[pattern]; exist {
                panic(&quot;http: multiple registrations for &quot; + pattern)
        }

        if mux.m == nil {
                mux.m = make(map[string]muxEntry)
        }
        e := muxEntry{h: handler, pattern: pattern}
        mux.m[pattern] = e
        if pattern[len(pattern)-1] == '/' {
                mux.es = appendSorted(mux.es, e)
        }

        if pattern[0] != '/' {
                mux.hosts = true
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法中，我们可以看到，Handle方法会先判断传入的&lt;code&gt;URI&lt;/code&gt;和&lt;code&gt;handler&lt;/code&gt;是否合法，然后判断这个&lt;code&gt;URI&lt;/code&gt;对应的处理器是否已经注册，然后将这个&lt;code&gt;URI&lt;/code&gt;和&lt;code&gt;handler&lt;/code&gt;对应的&lt;code&gt;map&lt;/code&gt;写入&lt;code&gt;ServeMux&lt;/code&gt;对象中。&lt;/p&gt;
&lt;p&gt;注意，这里还有一个步骤。如果这个&lt;code&gt;URI&lt;/code&gt;是以&lt;code&gt;/&lt;/code&gt;结尾的，将会被送入&lt;code&gt;es数组&lt;/code&gt;中，按长度排序。至于为什么会这么做，我们在后面的内容将会提到。&lt;/p&gt;
&lt;p&gt;说完了这些，我们应该可以猜到这个&lt;code&gt;ServeMux&lt;/code&gt;对象的作用了。他可以存储我们注册的&lt;code&gt;URI&lt;/code&gt;和&lt;code&gt;Handler&lt;/code&gt;，以实现当有请求进来的时候，可以委派给相对应的&lt;code&gt;Handler&lt;/code&gt;的功能。&lt;/p&gt;
&lt;p&gt;考虑到这个功能，那么我们也可以推断出，这个&lt;code&gt;ServeMux&lt;/code&gt;也是一个&lt;code&gt;Handler&lt;/code&gt;，只不过他和其他的&lt;code&gt;Handler&lt;/code&gt;不同。其他的&lt;code&gt;Handler&lt;/code&gt;处理的是具体的请求，而这个&lt;code&gt;ServeMux&lt;/code&gt;处理的是请求的分配。&lt;/p&gt;
&lt;p&gt;所以，ServeMux也实现了ServeHTTP方法，他也是一个Handler。而对于他是怎么实现ServeHTTP方法的，我们也在后面的内容提到。&lt;/p&gt;
&lt;h2 id=&quot;3-监听&quot;&gt;3 监听&lt;/h2&gt;
&lt;p&gt;现在，让我们来聊聊main函数中的第二行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http.ListenAndServe(&quot;:8000&quot;, nil)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照惯例，我们来看一看这个方法的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func ListenAndServe(addr string, handler Handler) error {
        server := &amp;amp;Server{Addr: addr, Handler: handler}
        return server.ListenAndServe()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的Server，是一个复杂的结构体，里面包含了设置服务器的很多参数，但是这里我们只聊&lt;code&gt;Addr&lt;/code&gt;和&lt;code&gt;Handler&lt;/code&gt;这两个属性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Addr&lt;/code&gt;很容易理解，就是这个服务器所监听的地址。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt;是处理器，负责把请求分配给各个对应的&lt;code&gt;handler&lt;/code&gt;。在这里留空，则使用Golang默认的处理器，也就是上文中我们提到的实现了&lt;code&gt;ServeHTTP&lt;/code&gt;方法的&lt;code&gt;ServeMux&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;知道了这些，我们继续往下看&lt;code&gt;server.ListenAndServe()&lt;/code&gt;的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (srv *Server) ListenAndServe() error {
        if srv.shuttingDown() {
                return ErrServerClosed
        }
        addr := srv.Addr
        if addr == &quot;&quot; {
                addr = &quot;:http&quot;
        }
        ln, err := net.Listen(&quot;tcp&quot;, addr)
        if err != nil {
                return err
        }
        return srv.Serve(ln)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里比较重要的有两行，第一是&lt;code&gt;ln, err := net.Listen(&quot;tcp&quot;, addr)&lt;/code&gt;，也就是说，开始监听&lt;code&gt;addr&lt;/code&gt;这个地址的&lt;strong&gt;tcp连接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后，调用&lt;code&gt;srv.Serve(ln)&lt;/code&gt;，我们来看看代码（省略部分，只保留与本文有关的逻辑）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (srv *Server) Serve(l net.Listener) error {
    ...
    for{
        ...
        c := srv.newConn(rw)
                c.setState(c.rwc, StateNew) // before Serve can return
                go c.serve(connCtx)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来讲，在这个方法中，有一个死循环，他不断接收新的连接，然后启动一个协程，处理这个连接。我们来看看&lt;code&gt;c.serve(connCtx)&lt;/code&gt;的具体实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (c *conn) serve(ctx context.Context) {
    ...
    serverHandler{c.server}.ServeHTTP(w, w.req)
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;省略其他所有的细节，最关键的就是这一行代码了，然后我们再看看这个&lt;code&gt;ServeHTTP&lt;/code&gt;方法。注意，这里的&lt;code&gt;c.server&lt;/code&gt;，还是指的是最开始的那个Server结构体。坚持一下下，马上就到最关键的地方啦：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type serverHandler struct {
        srv *Server
}

func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
        handler := sh.srv.Handler
        if handler == nil {
                handler = DefaultServeMux
        }
        if req.RequestURI == &quot;*&quot; &amp;amp;&amp;amp; req.Method == &quot;OPTIONS&quot; {
                handler = globalOptionsHandler{}
        }
        handler.ServeHTTP(rw, req)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;ServeHTTP&lt;/code&gt;方法逻辑很容易看出，如果最开始没有定义一个全局处理的&lt;code&gt;Handler&lt;/code&gt;，则会使用Golang的默认&lt;code&gt;handler&lt;/code&gt;：&lt;code&gt;DefaultServeMux&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;假设，我们这里使用的是&lt;code&gt;DefaultServeMux&lt;/code&gt;，执行&lt;code&gt;ServeHTTP&lt;/code&gt;方法。说到这里你是否有印象，我们在上一个章节里提到的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所以，ServeMux也实现了ServeHTTP方法，他也是一个Handler。而对于他是怎么实现ServeHTTP方法的，我们也在后面的内容提到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是这里，对于&lt;code&gt;ServeMux&lt;/code&gt;来说，他就是一个处理请求分发的&lt;code&gt;Handler&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你学过Java，我跟你说他和&lt;code&gt;ServletDispatcher&lt;/code&gt;很相似，你应该能理解吧。&lt;/p&gt;
&lt;h2 id=&quot;4-处理&quot;&gt;4 处理&lt;/h2&gt;
&lt;p&gt;到了这里，就是最后一步了，我们来看看这里处理请求分发的&lt;code&gt;ServeHTTP&lt;/code&gt;方法具体实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
        ...
        h, _ := mux.Handler(r)
        h.ServeHTTP(w, r)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在省去其他细节之后我们应该可以推断，这个&lt;code&gt;mux.Handler(r)&lt;/code&gt;方法返回的&lt;code&gt;h&lt;/code&gt;，应该是所请求的&lt;code&gt;URI&lt;/code&gt;所对应的&lt;code&gt;Handler&lt;/code&gt;。然后，执行这个&lt;code&gt;Handler&lt;/code&gt;所对应的&lt;code&gt;ServeHTTP&lt;/code&gt;方法。我们来看看&lt;code&gt;mux.Handler(r)&lt;/code&gt;这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
    ...
    host := stripHostPort(r.Host)
        path := cleanPath(r.URL.Path)
        ...
        return mux.handler(host, r.URL.Path)
}

func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
        mux.mu.RLock()
        defer mux.mu.RUnlock()

        // Host-specific pattern takes precedence over generic ones
        if mux.hosts {
                h, pattern = mux.match(host + path)
        }
        if h == nil {
                h, pattern = mux.match(path)
        }
        if h == nil {
                h, pattern = NotFoundHandler(), &quot;&quot;
        }
        return
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了这里，代码就变得简洁明了了。重点就是这个&lt;code&gt;mux.match&lt;/code&gt;方法，会根据地址，来返回对应的Handler。我们来看看这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (mux *ServeMux) match(path string) (h Handler, pattern string) {
        // Check for exact match first.
        v, ok := mux.m[path]
        if ok {
                return v.h, v.pattern
        }

        // Check for longest valid match.  mux.es contains all patterns
        // that end in / sorted from longest to shortest.
        for _, e := range mux.es {
                if strings.HasPrefix(path, e.pattern) {
                        return e.h, e.pattern
                }
        }
        return nil, &quot;&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码也应该很容易理解。如果在&lt;code&gt;ServeMux&lt;/code&gt;中存储了&lt;code&gt;key&lt;/code&gt;为这个URI的路由规则的映射，则直接返回这个&lt;code&gt;URI&lt;/code&gt;对应的&lt;code&gt;Handler&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;否则，就去匹配&lt;code&gt;es数组&lt;/code&gt;。还记得吗，这个数组是之前注册路由的时候提到的，如果&lt;code&gt;URI&lt;/code&gt;是以&lt;code&gt;/&lt;/code&gt;结尾的，就会把这个路由映射添加到&lt;code&gt;es数组中&lt;/code&gt;，并由长到短进行排序。&lt;/p&gt;
&lt;p&gt;这样的作用是，可以优先匹配到最长的&lt;code&gt;URI&lt;/code&gt;，以达到近似匹配的时候能够匹配到最合适的路由的目的。&lt;/p&gt;
&lt;p&gt;至此，返回对应的&lt;code&gt;Handler&lt;/code&gt;，然后执行，就成功的实现了处理相对应的请求了。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;首先，谢谢你能看到这里！&lt;/p&gt;
&lt;p&gt;不知道你有没有理解我所说的内容，希望这篇文章可以给你一些帮助。&lt;/p&gt;
&lt;p&gt;其实写这篇文章的目的是这样的，学完了Golang的基础之后作者准备开始研究Golang Web。但是查找各种资料后发现，并没有找到一条很合适的学习路线。然后本来作者打算去直接研究一个框架，如MeeGo，Gin等。但是又考虑到，框架只是用来解决问题的，学会了框架却不知道基础内容，有种知其然不知其所以然的感觉。&lt;/p&gt;
&lt;p&gt;所以，作者打算从Golang的net/http包的源码开始，慢慢去了解怎么用原生的Go语言去建立一个HTTP服务器，然后去了解一下怎么进行缓存，做持久化等，这也是作者思考之后决定的一条学习路线。当能够把这些内容都研究明白之后，再去研究框架，去看这些框架是怎么解决问题的，可能才是比较合适的。&lt;/p&gt;
&lt;p&gt;当然了，作者也是刚入门。所以，可能会有很多的疏漏。如果在阅读的过程中，有哪些解释不到位，或者理解出现了偏差，也请你留言指正。&lt;/p&gt;
&lt;p&gt;再次感谢~&lt;/p&gt;
</description>
<pubDate>Tue, 14 Apr 2020 15:40:00 +0000</pubDate>
<dc:creator>红鸡菌</dc:creator>
<og:description>摘要 由于Golang优秀的并发处理，很多公司使用Golang编写微服务。对于Golang来说，只需要短短几行代码就可以实现一个简单的Http服务器。加上Golang的协程，这个服务器可以拥有极高的性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hongjijun/p/12702292.html</dc:identifier>
</item>
<item>
<title>【java设计模式】（7）---策略模式（案例解析） - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/12359523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/12359523.html</guid>
<description>[unable to retrieve full-text content]策略模式 一、概念 1、理解策略模式 策略模式是一种行为型模式，它将对象和行为分开，将行为定义为 和 。策略模式最大的特点是行为的变化，行为之间可以相互替换。 每个if判断都可以理解为就是一个策略。 2、策略模式特点 策略模式把对象本身和行为区分开来，因此我们整个模式也分为三个部分。 3、举例理解(</description>
<pubDate>Tue, 14 Apr 2020 15:29:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>摘要 由于Golang优秀的并发处理，很多公司使用Golang编写微服务。对于Golang来说，只需要短短几行代码就可以实现一个简单的Http服务器。加上Golang的协程，这个服务器可以拥有极高的性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hongjijun/p/12702292.html</dc:identifier>
</item>
<item>
<title>存储基础知识：扇区与块/簇 - 潇湘隐者</title>
<link>http://www.cnblogs.com/kerrycode/p/12701772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kerrycode/p/12701772.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一直以来，个人对于磁盘的底层技术很少关注，可能更多的是关注磁盘IO性能，读写速率，这篇博文就磁盘扇区（Sector）和块/簇这方面的知识做一些深入性的总结，希望对你有所帮助！如有不足或错误的地方，也敬请指正！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;扇区（Sector）的概念&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;什么是扇区（Sector）呢？我们先看看维基百科关于扇区的定义：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;In computer disk storage, a &lt;strong&gt;sector&lt;/strong&gt; is a subdivision of a &lt;u&gt;&lt;span&gt;&lt;span&gt;track&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; on a &lt;u&gt;&lt;span&gt;&lt;span&gt;magnetic disk&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; or &lt;u&gt;&lt;span&gt;&lt;span&gt;optical disc&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;. Each sector stores a fixed amount of user-accessible data, traditionally 512 &lt;u&gt;&lt;span&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; for &lt;u&gt;&lt;span&gt;&lt;span&gt;hard disk drives&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; (HDDs) and 2048 bytes for &lt;u&gt;&lt;span&gt;&lt;span&gt;CD-ROMs&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; and &lt;u&gt;&lt;span&gt;&lt;span&gt;DVD-ROMs&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;. Newer HDDs use 4096-byte (4 &lt;u&gt;&lt;span&gt;&lt;span&gt;KiB&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;) sectors, which are known as the &lt;u&gt;&lt;span&gt;&lt;span&gt;Advanced Format&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; (AF).&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;The sector is the minimum storage unit of a hard drive.&lt;u&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; Most disk partitioning schemes are designed to have files occupy an integral number of sectors regardless of the file's actual size. Files that do not fill a whole sector will have the remainder of their last sector filled with zeroes. In practice, operating systems typically operate on &lt;u&gt;&lt;span&gt;&lt;span&gt;blocks of data&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;, which may span multiple sectors.&lt;u&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;Geometrically, the word &lt;u&gt;&lt;span&gt;&lt;span&gt;sector&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; means a portion of a &lt;u&gt;&lt;span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; between a center, two &lt;u&gt;&lt;span&gt;&lt;span&gt;radii&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; and a corresponding &lt;u&gt;&lt;span&gt;&lt;span&gt;arc&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; (see Figure 1, item B), which is shaped like a slice of a pie. Thus, the &lt;em&gt;disk sector&lt;/em&gt; (Figure 1, item C) refers to the intersection of a &lt;em&gt;track&lt;/em&gt; and geometrical &lt;em&gt;sector&lt;/em&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;In modern disk drives, each physical sector is made up of two basic parts, the sector &lt;u&gt;&lt;span&gt;&lt;span&gt;header&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; area (typically called &quot;ID&quot;) and the data area. The sector header contains information used by the drive and controller; this information includes sync bytes, &lt;em&gt;address identification&lt;/em&gt;, flaw flag and error detection and correction information. The header may also include an alternate address to be used if the data area is undependable. The &lt;em&gt;address identification&lt;/em&gt; is used to ensure that the mechanics of the drive have positioned the read/write head over the correct location. The data area contains the sync bytes, user data and an &lt;u&gt;&lt;span&gt;&lt;span&gt;error-correcting code&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; (ECC) that is used to check and possibly correct errors that may have been introduced into the data.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在计算机磁盘存储中，扇区是磁盘或光盘上磁道的细分。每个扇区存储固定数量的用户可访问数据，传统上，硬盘（&lt;span lang=&quot;X-NONE&quot;&gt;HDD&lt;/span&gt;）上的扇区大小为&lt;span lang=&quot;X-NONE&quot;&gt;512&lt;/span&gt;字节，&lt;span lang=&quot;X-NONE&quot;&gt;CD-ROM&lt;/span&gt;和&lt;span lang=&quot;X-NONE&quot;&gt;DVD-ROM&lt;/span&gt;的扇区大小为&lt;span lang=&quot;X-NONE&quot;&gt;2048&lt;/span&gt;字节。较新的硬盘（&lt;span lang=&quot;X-NONE&quot;&gt;HDD&lt;/span&gt;）使用&lt;span lang=&quot;X-NONE&quot;&gt;4096&lt;/span&gt;字节（&lt;span lang=&quot;X-NONE&quot;&gt;4 KiB&lt;/span&gt;）扇区，这些扇区称为高级格式（&lt;span lang=&quot;X-NONE&quot;&gt;AF&lt;/span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;扇区是硬盘的最小存储单元&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;。&lt;span lang=&quot;X-NONE&quot;&gt;[1]&lt;/span&gt;大多数磁盘分区方案旨在使文件占据整数个扇区，而不管文件的实际大小如何。未填充完整个扇区的文件将最后一个扇区的其余部分填充零。实际上，操作系统通常使用数据块操作，数据块可跨越多个扇区。&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从几何学上讲，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;扇形&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一词是指圆盘中心，两个半径和相应弧之间的一部分（请参见图&lt;span lang=&quot;X-NONE&quot;&gt;1&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;B&lt;/span&gt;项 紫色部分），其形状像一块馅饼。因此，磁盘扇区（图&lt;span lang=&quot;X-NONE&quot;&gt;1&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;C&lt;/span&gt;项 玫红色部分）是指磁道和几何扇区的交集。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在现代磁盘驱动器中，每个物理扇区都由两个基本部分组成，即扇区头区域（通常称为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;ID&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）和数据区域。扇区头包含驱动器和控制器使用的信息。该信息包括同步字节，地址标识，缺陷标志以及错误检测和纠正信息。如果数据区域不可靠，则标头还可以包含要使用的备用地址。地址标识用于确保驱动器的机械手已将读&lt;span lang=&quot;X-NONE&quot;&gt;/&lt;/span&gt;写头定位在正确的位置上。数据区域包含同步字节，用户数据和纠错码（&lt;span lang=&quot;X-NONE&quot;&gt;ECC&lt;/span&gt;），用于检查并可能纠正可能已引入数据中的错误。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们来看看下面维基百科上的图，形象的介绍了扇区、磁道等概念：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;Track&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;磁盘磁道（粉红色部分）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;Geometrical sector&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;几何学中的扇形（紫色部分）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;C&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;Track sector&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;磁盘扇区（玫红色部分）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;D&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;Cluster&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;&lt;span&gt;块&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;簇（绿色部分）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;                        &lt;/span&gt; &lt;strong&gt;图（1）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414225358636-1188159839.png&quot;&gt;&lt;img title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414225359754-659342879.png&quot; width=&quot;768&quot; height=&quot;768&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;说完扇区，就不得不提一些其他相关概念，因为它们相辅相成，不能孤立开来，这里也简单介绍一下，不详细展开&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;磁头（&lt;span lang=&quot;X-NONE&quot;&gt;head&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;磁头就是读写盘片的设备。如下所示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222243268-879750384.png&quot;&gt;&lt;img title=&quot;clip_image003&quot; border=&quot;0&quot; alt=&quot;clip_image003&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222243927-586304119.png&quot; width=&quot;626&quot; height=&quot;467&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;盘片（&lt;span lang=&quot;X-NONE&quot;&gt;platter&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;硬盘中一般会有多个盘片组成，这个如果拆解过磁盘的人都会知道，银白色的盘片像镜子一样，曾有同事将其当镜子用。大多数盘片的材质是铝合金，上面覆盖一些磁性涂层。&lt;span lang=&quot;X-NONE&quot;&gt;IBM&lt;/span&gt;曾经生产过玻璃材质的盘片，不过早已退出了历史舞台。每个盘片包含两个面，每个盘面都对应地有一个读&lt;span lang=&quot;X-NONE&quot;&gt;/&lt;/span&gt;写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在&lt;span lang=&quot;X-NONE&quot;&gt;5&lt;/span&gt;片以内。盘片的编号自下向上从&lt;span lang=&quot;X-NONE&quot;&gt;0&lt;/span&gt;开始，如最下边的盘片有&lt;span lang=&quot;X-NONE&quot;&gt;0&lt;/span&gt;面和&lt;span lang=&quot;X-NONE&quot;&gt;1&lt;/span&gt;面，再上一个盘片就编号为&lt;span lang=&quot;X-NONE&quot;&gt;2&lt;/span&gt;面和&lt;span lang=&quot;X-NONE&quot;&gt;3&lt;/span&gt;面。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;柱面（&lt;span lang=&quot;X-NONE&quot;&gt;cylinder&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，&lt;strong&gt;盘面数&lt;/strong&gt;等于总的磁头数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;所有盘面上的同一磁道构成一个圆柱，称作柱面。数据的读&lt;span lang=&quot;X-NONE&quot;&gt;/&lt;/span&gt;写按柱面从外向内进行，而不是按盘面进行。定位时，首先确定柱面，再确定盘面，然后确定扇区。之后所有磁头一起定位到指定柱面，再旋转盘面使指定扇区位于磁头之下。写数据时，当前柱面的当前磁道写满后，开始在当前柱面的下一个磁道写入，只有当前柱面全部写满后，才将磁头移动到下一个柱面。在对硬盘分区时，各个分区也是以柱面为单位划分的，即从什么柱面到什么柱面；不存在一个柱面同属于多个分区&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;了解完上面概念，你再看一下下面两张图【来自维基百科】，基本上就能有个形象的认知了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222244495-591152931.png&quot;&gt;&lt;img title=&quot;clip_image005&quot; border=&quot;0&quot; alt=&quot;clip_image005&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222244960-1418281476.png&quot; width=&quot;400&quot; height=&quot;341&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222245410-1657345931.png&quot;&gt;&lt;img title=&quot;clip_image006&quot; border=&quot;0&quot; alt=&quot;clip_image006&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222245914-1411545261.png&quot; width=&quot;550&quot; height=&quot;446&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;物理扇区（&lt;span lang=&quot;X-NONE&quot;&gt;physical sector&lt;/span&gt;）与逻辑扇区（&lt;span lang=&quot;X-NONE&quot;&gt;logical sector&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;关于物理扇区（&lt;span lang=&quot;X-NONE&quot;&gt;physical setctor&lt;/span&gt;）与逻辑扇区，这个还得扯上扇区大小，由于近年来，随着对硬盘容量的要求不断增加，为了提高数据记录密度，硬盘厂商往往采用增大扇区大小的方法，于是出现了扇区大小为&lt;span lang=&quot;X-NONE&quot;&gt;4096&lt;/span&gt;字节的硬盘。我们将这样的扇区称之为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;物理扇区&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。但是这样的大扇区会有兼容性问题，有的系统或软件无法适应。为了解决这个问题，硬盘内部将物理扇区在逻辑上划分为多个扇区片段并将其作为普通的扇区（一般为&lt;span lang=&quot;X-NONE&quot;&gt;512&lt;/span&gt;字节大小）报告给操作系统及应用软件。这样的扇区片段我们称之为&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;逻辑扇区&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。实际读写时由硬盘内的程序（固件）负责在逻辑扇区与物理扇区之间进行转换，上层程序&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;感觉&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;不到物理扇区的存在。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;逻辑扇区是硬盘可以接受读写指令的最小操作单元，是操作系统及应用程序可以访问的扇区，多数情况下其大小为&lt;span lang=&quot;X-NONE&quot;&gt;512&lt;/span&gt;字节。我们通常所说的扇区一般就是指的逻辑扇区。物理扇区是硬盘底层硬件意义上的扇区，是实际执行读写操作的最小单元。是只能由硬盘直接访问的扇区，操作系统及应用程序一般无法直接访问物理扇区。一个物理扇区可以包含一个或多个逻辑扇区（比如多数硬盘的物理扇区包含了&lt;span lang=&quot;X-NONE&quot;&gt;8&lt;/span&gt;个逻辑扇区）。当要读写某个逻辑扇区时，硬盘底层在实际操作时都会读写逻辑扇区所在的整个物理扇区。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;关于扇区的一些疑问&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;回过头来，我们仔细捋一捋图（&lt;span lang=&quot;X-NONE&quot;&gt;1&lt;/span&gt;）这张图片，基本上就能把扇区的概念理解得七七八八了，那么还有几个问题，这个是我学习过程的一些疑问和自我解答（这里仅仅指传统硬盘，不涉及&lt;span lang=&quot;X-NONE&quot;&gt;SSD&lt;/span&gt;磁盘）：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：扇区的大小是固定的吗？ 同一块磁盘上的扇区大小是否可以不一致。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;扇区&lt;span lang=&quot;X-NONE&quot;&gt;(Sector)&lt;/span&gt;大小是固定的，默认情况下，每个扇区（&lt;span lang=&quot;X-NONE&quot;&gt;Sector&lt;/span&gt;）为&lt;span lang=&quot;X-NONE&quot;&gt;512&lt;/span&gt;字节，&lt;span lang=&quot;X-NONE&quot;&gt;2009&lt;/span&gt;年后，硬盘厂商开始发布&lt;span lang=&quot;X-NONE&quot;&gt;4KB&lt;/span&gt;字节扇区的硬盘了，&lt;span lang=&quot;X-NONE&quot;&gt;4KB&lt;/span&gt;扇区硬盘已经在消费级市场广泛应用。但是&lt;strong&gt;同一块硬盘上的扇区大小一定是一致的&lt;/strong&gt;。不可能存在多种不同大小的扇区。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;至于为什么之前的扇区大小为&lt;span lang=&quot;X-NONE&quot;&gt;512&lt;/span&gt;字节呢？这是&lt;span lang=&quot;X-NONE&quot;&gt;1956&lt;/span&gt;年由&lt;span lang=&quot;X-NONE&quot;&gt;industry trade organization, International Disk Drive Equipment&lt;/span&gt;和&lt;span lang=&quot;X-NONE&quot;&gt;Materials Association&lt;/span&gt;三家机构确定的行业标准。有时代和技术的限制，因为磁盘技术发展初期，存储容量非常小。&lt;span lang=&quot;X-NONE&quot;&gt;512&lt;/span&gt;字节的扇区也够用，但是随着时代的发展，&lt;span lang=&quot;X-NONE&quot;&gt;512&lt;/span&gt;字节大小的扇区（&lt;span lang=&quot;X-NONE&quot;&gt;Sector&lt;/span&gt;）明显太小了，由于每个扇区（&lt;span lang=&quot;X-NONE&quot;&gt;Sector&lt;/span&gt;）还要存放很多其他信息，因此增大&lt;span lang=&quot;X-NONE&quot;&gt;sector size&lt;/span&gt;可以降低扇区（&lt;span lang=&quot;X-NONE&quot;&gt;Sector&lt;/span&gt;）的数量，从而提高实际存储量，同时降低了差错校验等很多&lt;span lang=&quot;X-NONE&quot;&gt;CPU&lt;/span&gt;计算量。但遗憾的是由于这个标准太根深蒂固，要想改变一些底层代码或架构势必非常困难，所以现在&lt;span lang=&quot;X-NONE&quot;&gt;4KB&lt;/span&gt;扇区硬盘暂时还没有全部普及。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;至于为什么要采用&lt;span lang=&quot;X-NONE&quot;&gt;4KB&lt;/span&gt;扇区的硬盘呢？这是因为它可以提高可靠性且增加磁盘容量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;—&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;至少从理论上讲是这样。 更多相关详细资料，建议参阅下面资料：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://www.ituring.com.cn/article/22103&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://www.ibm.com/developerworks/cn/linux/l-4kb-sector-disks/index.html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://www.ibm.com/developerworks/cn/linux/l-linux-on-4kb-sector-disks/index.html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：每个磁道（&lt;span lang=&quot;X-NONE&quot;&gt;Track&lt;/span&gt;）上的扇区数量都是一样的吗？ 还是只是相同柱面（&lt;span lang=&quot;X-NONE&quot;&gt;cylinder&lt;/span&gt;）上的扇区数量一致。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;要回答这个问题，我们首先有必要了解一下&lt;span lang=&quot;X-NONE&quot;&gt;CLV&lt;/span&gt;、&lt;span lang=&quot;X-NONE&quot;&gt;CAV&lt;/span&gt;、&lt;span lang=&quot;X-NONE&quot;&gt;ZBR&lt;/span&gt;等技术，当然这里仅仅是入门介绍，更多相关知识（例如&lt;span lang=&quot;X-NONE&quot;&gt;P-CAV&lt;/span&gt;、&lt;span lang=&quot;X-NONE&quot;&gt;Z-CLV&lt;/span&gt;等技术），自行去搜索查阅。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;CLV&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;技术&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;一开始的技术叫做&lt;span lang=&quot;X-NONE&quot;&gt;CLV&lt;/span&gt;，称为恒定线速度，这个技术要求无论在哪个圈上，线速度都要一样，所以对马达的要求非常高，寿命非常短，在低于&lt;span lang=&quot;X-NONE&quot;&gt;12&lt;/span&gt;倍速的光驱中使用的技术。光碟片和硬碟不同，光碟片上每个部分的密度都是一样的，在同样旋转一圈的情况下，圆周较长的外圈部分在读取资料时会比内圈部分快，所谓的恒定线速度是指从内到外都是同样的读取速度，而为了保持一开始速度，读到外圈时会降低光碟片的转速来配合读取速度，读到内圈时会提高转速。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;CAV&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;技术&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;CLV&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;因为不停的更改马达的转速，会对机器的寿命造成一定的影响，而且磁盘转速也不能无限制的加快。后来又有了一种磁盘技术叫做&lt;span lang=&quot;X-NONE&quot;&gt;CAV&lt;/span&gt;，叫做恒定角速度，马达的转速恒定，寿命有了很大提高，光盘上的内沿数据比外沿数据传输速度要低，越往外越能体现光驱的速度，倍速指的是最高数据传输率。但是也有缺点，浪费会很大，因为磁头读盘片的扫描频率基本是恒定的，外圈的有效磁介质单元会很稀疏。这时候，各个磁道的扇区数应该是一样的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;ZBR&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;技术&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在计算机存储中，区域位记录（&lt;span lang=&quot;X-NONE&quot;&gt;ZBR&lt;/span&gt;）是磁盘驱动器用来优化磁道以增加数据容量的一种方法。它通过在外部磁道上每个区域放置比内部磁道更多的扇区来实现此目的。这与其他方法相反，例如恒定角速度（&lt;span lang=&quot;X-NONE&quot;&gt;CAV&lt;/span&gt;）驱动器，其中每个磁道的扇区数相同。在由大致同心的轨道组成的磁盘上（无论是实现为单独的圆形轨道还是实现为单个螺旋轨道），物理轨道的长度（周长）随着距中心轮毂的距离增加而增加。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如下图片所示，可以看到粉红色、绿色、灰色部分的扇区数量不一样。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222246416-1447185205.png&quot;&gt;&lt;img title=&quot;clip_image008&quot; border=&quot;0&quot; alt=&quot;clip_image008&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222247003-1253692099.png&quot; width=&quot;600&quot; height=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;ZBR&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;区位记录，也称为&lt;span lang=&quot;X-NONE&quot;&gt;zone-bit recording&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;zone recording&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;zone-density recording&lt;/span&gt;或者&lt;span lang=&quot;X-NONE&quot;&gt;multiple-zone recording&lt;/span&gt;，是指为了提高磁盘的存储容量，充分利用磁盘外面磁道的存储能力，现代磁盘不再把内外磁道划分为相同数目的扇区。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所有的硬盘驱动器都是由一些磁盘片组成。在每个磁盘片中，数据存放的物理位置呈同心圆状，这些同心圆称为磁道。每个磁道上包含若干扇区。每个扇区存储的数据容量是一致的。磁道的周长与同心圆的直径成正比。在早期的硬盘驱动器中，所有的磁道包含的扇区数目都是一样的，按照固定的圆心角辐射出去，就可以简单的将各磁道的扇区数进行统一。这样，在磁道边缘的扇区弧长就要大于内部的扇区弧长，其存储数据的密度也要比内部磁道的密度要小。最终，导致外部磁道的空间浪费。为了有效利用外部磁道空间，让所有的磁道扇区存储数据密度一致，就需要保证所有扇区的&lt;strong&gt;弧长一致&lt;/strong&gt;。这样就要根据磁道的半径来重新分配扇区数目。&lt;span lang=&quot;X-NONE&quot;&gt;Zoned0bit recording&lt;/span&gt; 方法通过将磁道分组（这种磁道组称为&lt;span lang=&quot;X-NONE&quot;&gt;zone&lt;/span&gt;）实现了这一目标。内部磁道的扇区数目较少，外部磁道的扇区数目较多。这样，外部磁道和内部磁道的存储空间利用率都相等，充分利用了整个硬盘的空间。【来自百科】&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;ZDR(Zone Data Recording),&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;即区域数据记录技术。主要工作方式还是&lt;span lang=&quot;X-NONE&quot;&gt;CAV&lt;/span&gt;，但是采取了分区方式，是每个区域内为恒定角速度，各个区域内选取的角速度不一样。从磁盘的最外圈到内圈划分出若干个区域。每个区域内的每磁道扇区一致，但靠内的区域比外侧的区域的每磁道扇区数要少，从而可以根据不同的磁道长度来合理设定扇区的数量，以达到充分利用磁盘存储空间的目的。但设置多少个区域，每个区域的扇区数设定也都是有讲究的。否则会在向内跨区域读写时造成传输率下降过大而影响整体性能。大多数产品划分了&lt;span lang=&quot;X-NONE&quot;&gt;16&lt;/span&gt;个区域，最外圈的每磁道扇区数正好是最内圈的一倍，与最大的持续传输率的参数基本成比例。比如&lt;span lang=&quot;X-NONE&quot;&gt;0&lt;/span&gt;到&lt;span lang=&quot;X-NONE&quot;&gt;100&lt;/span&gt;磁道采用每小时&lt;span lang=&quot;X-NONE&quot;&gt;120&lt;/span&gt;码的速度，&lt;span lang=&quot;X-NONE&quot;&gt;101&lt;/span&gt;到&lt;span lang=&quot;X-NONE&quot;&gt;200&lt;/span&gt;磁道采用每小时&lt;span lang=&quot;X-NONE&quot;&gt;100&lt;/span&gt;码的速度，&lt;span lang=&quot;X-NONE&quot;&gt;201&lt;/span&gt;到&lt;span lang=&quot;X-NONE&quot;&gt;300&lt;/span&gt;采用每小时&lt;span lang=&quot;X-NONE&quot;&gt;80&lt;/span&gt;码的速度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所以要回答这个问题，要根据磁盘的数据记录方式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;1.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;旧式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;——&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;非&lt;span lang=&quot;X-NONE&quot;&gt;ZBR&lt;/span&gt;区位记录（不同磁道扇区数相同）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;所有磁道（&lt;span lang=&quot;X-NONE&quot;&gt;Track&lt;/span&gt;）上的扇区数量一致。以前的硬盘技术（&lt;span lang=&quot;X-NONE&quot;&gt;CAV&lt;/span&gt;）&lt;span lang=&quot;X-NONE&quot;&gt;,&lt;/span&gt;内圈外圈每个磁道的扇区数是相同的&lt;span lang=&quot;X-NONE&quot;&gt;,&lt;/span&gt;所以速度都是一样的。旧的磁盘驱动器中，外轨道和内轨道具有相同的扇区数，因此外磁道数据密度低。这是低效率的对可用空间的利用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;2.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;新式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;——&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;ZBR&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;区位记录（不同磁道扇区数不同）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;不同磁道（&lt;span lang=&quot;X-NONE&quot;&gt;Track&lt;/span&gt;）上的扇区数量不一致，离圆心越远的磁道的扇区数量越多（外层环带的磁道拥有较内层环带的磁道更多的扇区）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：扇区在磁道上的&lt;strong&gt;面积大小是固定吗&lt;/strong&gt;？&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;对于旧式磁盘（非&lt;span lang=&quot;X-NONE&quot;&gt;ZBR&lt;/span&gt;区位记录）。如上,图&lt;span lang=&quot;X-NONE&quot;&gt;(1&lt;/span&gt;）所示，扇区在不同的磁道，扇区的面积大小不一样。这个图只是为了形象的说明扇区的逻辑概念，实际情况呢？ 准确答案是：扇区的大小在不同的磁道确实不一样。因为所有的磁道（&lt;span lang=&quot;X-NONE&quot;&gt;Track&lt;/span&gt;）的扇区数量是一样的，那么离圆心越远的磁道的面积就越大，&lt;span&gt;&lt;span&gt;如果全部扇区的大小都一样的话，那么离圆心越远的磁道（&lt;span lang=&quot;X-NONE&quot;&gt;Track&lt;/span&gt;）的扇区数量就应该越多，显然不是这样的&lt;/span&gt;&lt;/span&gt;。&lt;strong&gt;硬盘的每个磁道具有相同数量的扇区，并且扇区大小一致。这意味着，内部磁道中的位密度远高于外部扇区中的位密度。也就是说不同磁道的位密度（&lt;span lang=&quot;X-NONE&quot;&gt;bit density&lt;/span&gt;）有差别&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;显然，对于新式磁盘（&lt;span lang=&quot;X-NONE&quot;&gt;ZBR&lt;/span&gt;区位记录），所有的磁道扇区存储数据密度一致，所有扇区的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;弧长一致。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：磁盘介质中存储的密度是否不一样？&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其实问题&lt;span lang=&quot;X-NONE&quot;&gt;3&lt;/span&gt;已经顺带回答了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们再来聊聊块（Block）/簇（cluster）跟扇区（sector）的关系吧，关于扇区，经过上面的介绍，相信我们已经全面了解了扇区的基本概念。其实磁盘读写的基本单位是扇区，而块（Block）/簇（cluster）是一个逻辑概念，或者说是操作系统中的概念，其实对于实际物理磁盘，并没有所谓的块（Block）这样的东东。操作系统为什么要虚拟个这样的概念出来呢？这样又有什么好处呢？相信你也有不少这类疑问！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;块/簇&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;块（Block）/簇（Cluster）是逻辑上的概念，或者说是虚拟出来的概念。 分别对应Linux与Windows操作系统中的概念。注意：有些文章或资料叫做磁盘块/磁盘簇。这里统一用块（Block）/簇称呼，这篇文章你看到的块（Block）指磁盘块。后面不再做声明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;Unix与Linux系统中，块（Block）是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是块（Block）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;在Windows下如NTFS等文件系统中叫做簇；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如下所示，Windows下E盘的Cluster的大小为4Kb大小，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222247442-1014777154.png&quot;&gt;&lt;img title=&quot;clip_image009&quot; border=&quot;0&quot; alt=&quot;clip_image009&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222247829-953142345.png&quot; width=&quot;635&quot; height=&quot;331&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Linux下查看Block大小的语句如下:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;9&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# stat /home | grep &quot;IO Block&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
  Size: 47              Blocks: 0          IO Block: 4096   directory
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# tune2fs -l /dev/mapper/VolGroup03-LogVol00 | grep Block&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
Block count:              47177728
&lt;/pre&gt;
&lt;pre&gt;
Block size:               4096
&lt;/pre&gt;
&lt;pre&gt;
Blocks per group:         32768
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
#dumpe2fs /dev/sda1|grep -i &lt;span&gt;&quot;block size&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为什么要用磁盘块/簇？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们知道磁盘的最小单位就是扇区，那么为什么操作系统不用扇区作为IO的基本单位呢？ 为什么操作系统一定要整出块（Block）/簇（Cluster）这样的概念呢？主要是因为下面两个原因：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;读取方便：由于扇区的Size比较小，数目众多时寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其实我们生活中也有类似的例子，例如我们生活中，现在见到最小币值是角了，小时候的一分钱、两分钱现在已经很难见到了，因为随着经济发展和生活水平提高，如果还有分或角的话，非常不方便，你能想象你用一大袋币值&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为1分的钱去买个几千块的商品吗？ 想想都觉得这画面很滑稽。既不方便携带，也不方便计算。而且扇区是对硬盘而言，块是对文件系统而言。出于不同的需要。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;块/簇是越大越好吗？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Linux系统&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;块（Block），也称为逻辑块，是文件系统层面的概念。文件系统不是一个扇区一个扇区的来读数据，太慢了，另外由于扇区的Size比较小，数目众多时寻址时比较困难。所以它是一个块一个块的读取数据，就是说块（Block）是文件系统存取数据的最小单位，一般大小是4KB（这个值可以修改，在格式化分区的时候修改）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;读取一个块，实际上是从硬件设备读取一个或多个扇区，一个块只能存放一个文件的内容，无论这个文件有多小。一个文件可能会占用一个或多个Block，每读取一个block就会消耗一次磁盘IO。如果要提升磁盘IO性能，那么尽可能一次IO读取更多的数据，但是Block也不是越大越好，需要结合业务来设置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;试想，如果块的大小为8KB，但是很多小文件都是1KB大小，我们知道一个块只能存放一个文件的内容，那么就会造成很大的浪费。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Windows系统&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;磁盘簇&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：扇区是磁盘最小的物理存储单元，但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起，形成一个簇，然后再对簇进行管理。每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；而如果文件实际大小小于一簇，它也要占一簇的空间。所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这种以簇为最小分配单位的机制，使硬盘对数据的管理变得相对容易，但也造成了磁盘空间的浪费，尤其是小文件数目较多的情况下，一个上千兆的大硬盘，其浪费的磁盘空间可达上百兆字节。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所以块/簇的大小不是越大越好，而是对读写性能与节省空间的多方权衡考虑。块和簇的大小都是可以调整的。Windows在格式磁盘时，可以通过&quot;Allocation unit size&quot;来调整簇的大小。如下所示，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222248161-714468664.png&quot;&gt;&lt;img title=&quot;clip_image010&quot; border=&quot;0&quot; alt=&quot;clip_image010&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222248436-2067284926.png&quot; width=&quot;330&quot; height=&quot;240&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果我选择&quot;Allocation unit size&quot;为8192， 也就是簇大小为8KB重新格式化，那么你会看到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Bytes Per Cluster&quot;值为8192了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222248774-758988015.png&quot;&gt;&lt;img title=&quot;clip_image011&quot; border=&quot;0&quot; alt=&quot;clip_image011&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222249151-1517338005.png&quot; width=&quot;640&quot; height=&quot;307&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当然， Linux也可以在格式化时调整。如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;#mkfs.ext4 -b 4096 /dev/sda&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;磁盘块大小必须是扇区大小的整数倍呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;磁盘读取数据的基本单位就是一个扇区的大小，一个块的大小对于磁盘来说就是一次获取数据读取的扇区数*扇区大小，如果是整数倍的扇区数对于磁盘的IO更好，速度更快，也会更合理的利用资源。否则会对扇区进行分割。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一个扇区是512字节。有些硬盘厂商会提供4k大小扇区。这是物理结构。磁盘定下来的结构就是没法修改的。所以必须要将块设置为磁盘的大小。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何映射磁盘块？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;磁盘控制器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，其作用除了读取数据、控制磁头等作用外，还有的功能就是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;映射扇区和磁盘块的关系&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何查看磁盘的扇区大小呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在Linux系统下面，我们可以下面命令查看操作系统逻辑块与物理块的大小，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;You can display what physical/logical sector sizes your disk reports via the&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;/sys&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;pseudo filesystem, for instance:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;# cat /sys/block/sda/queue/physical_block_size&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;4096&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;# cat /sys/block/sda/queue/logical_block_size&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;512&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们可以查看具体磁盘的扇区大小（物理扇区大小与逻辑扇区大小）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;17&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;29&quot;&gt;
&lt;pre&gt;
[root@KerryDB ~]&lt;span&gt;# fdisk -l /dev/sda&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
Disk /dev/sda: 500.1 GB, 500107862016 bytes, 976773168 sectors
&lt;/pre&gt;
&lt;pre&gt;
Units = sectors of 1 * 512 = 512 bytes
&lt;/pre&gt;
&lt;pre&gt;
Sector size (logical/physical): 512 bytes / 4096 bytes
&lt;/pre&gt;
&lt;pre&gt;
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
&lt;/pre&gt;
&lt;pre&gt;
Disk label type: dos
&lt;/pre&gt;
&lt;pre&gt;
Disk identifier: 0x8de02bd4
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
   Device Boot      Start         End      Blocks   Id  System
&lt;/pre&gt;
&lt;pre&gt;
/dev/sda1   *          63      208844      104391   83  Linux
&lt;/pre&gt;
&lt;pre&gt;
Partition 1 does not start on physical sector boundary.
&lt;/pre&gt;
&lt;pre&gt;
/dev/sda2          208896     2306047     1048576   83  Linux
&lt;/pre&gt;
&lt;pre&gt;
/dev/sda3         2306048   976773119   487233536   8e  Linux LVM
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222249522-1411146729.png&quot;&gt;&lt;img title=&quot;clip_image012&quot; border=&quot;0&quot; alt=&quot;clip_image012&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222249875-609003069.png&quot; width=&quot;650&quot; height=&quot;242&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;15&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;25&quot;&gt;
&lt;pre&gt;
[root@mylnx11 ~]&lt;span&gt;# fdisk -l /dev/sda&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
Disk /dev/sda: 64.4 GB, 64424509440 bytes, 125829120 sectors
&lt;/pre&gt;
&lt;pre&gt;
Units = sectors of 1 * 512 = 512 bytes
&lt;/pre&gt;
&lt;pre&gt;
Sector size (logical/physical): 512 bytes / 512 bytes
&lt;/pre&gt;
&lt;pre&gt;
I/O size (minimum/optimal): 512 bytes / 512 bytes
&lt;/pre&gt;
&lt;pre&gt;
Disk label type: dos
&lt;/pre&gt;
&lt;pre&gt;
Disk identifier: 0x000b86b7
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
   Device Boot      Start         End      Blocks   Id  System
&lt;/pre&gt;
&lt;pre&gt;
/dev/sda1   *        2048     2099199     1048576   83  Linux
&lt;/pre&gt;
&lt;pre&gt;
/dev/sda2         2099200   125829119    61864960   8e  Linux LVM
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;注意，一些老旧的操作系统，使用fdisk -l没有明确显示扇区大小的信息，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;12.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;20&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# more /etc/issue&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
Oracle Linux Server release 5.7
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# fdisk -l /dev/sdb&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
Disk /dev/sdb: 171.7 GB, 171798691840 bytes
&lt;/pre&gt;
&lt;pre&gt;
255 heads, 63 sectors/track, 20886 cylinders
&lt;/pre&gt;
&lt;pre&gt;
Units = cylinders of 16065 * 512 = 8225280 bytes
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
   Device Boot      Start         End      Blocks   Id  System
&lt;/pre&gt;
&lt;pre&gt;
/dev/sdb1               1       20886   167766763+  83  Linux
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是其Units计算，暗示了扇区大小为512字节。对于Windows系统而言，可以使用命令fsutil fsinfo ntfsinfo查看，如下截图所示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222250270-1836227718.png&quot;&gt;&lt;img title=&quot;clip_image011[1]&quot; border=&quot;0&quot; alt=&quot;clip_image011[1]&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222250867-782527755.png&quot; width=&quot;640&quot; height=&quot;307&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;查看块（Block)的大小。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;8&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# stat /home | grep &quot;IO Block&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
  Size: 47              Blocks: 0          IO Block: 4096   directory
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# tune2fs -l /dev/mapper/VolGroup03-LogVol00 | grep Block&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
Block count:              47177728
&lt;/pre&gt;
&lt;pre&gt;
Block size:               4096
&lt;/pre&gt;
&lt;pre&gt;
Blocks per group:         32768
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;磁盘一次物理IO是读取一个扇区还是多个扇区？ 这个是和朋友讨论的时候，最纠结的一个问题，因为之前确实没有了解过。咨询了不少人，得到的答案是一次IO会读取一个或多个扇区。虽然磁盘最小操作单位是扇区，但是不代表一次只能读取一个扇区。当然对于写操作也是如此。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;读/写IO，最为常见说法，读IO，就是发指令，从磁盘读取&lt;strong&gt;某段扇区&lt;/strong&gt;的内容。指令一般是通知磁盘开始扇区位置，然后给出需要从&lt;strong&gt;这个初始扇区往后读取的连续扇区个数&lt;/strong&gt;，同时给出动作是读，还是写。磁盘收到这条指令，就会按照指令的要求，读或者写数据。控制器发出的这种指令＋数据，就是一次IO，读或者写。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;有兴趣的话，可以了解一下&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Multiple sector I/O&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;来自：Managing RAID on Linux: Fast, Scalable, Reliable Data Storage&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222251455-54142229.png&quot;&gt;&lt;img title=&quot;clip_image013&quot; border=&quot;0&quot; alt=&quot;clip_image013&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202004/73542-20200414222253796-1666266168.png&quot; width=&quot;804&quot; height=&quot;553&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://en.wikipedia.org/wiki/Disk_sector&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://en.wikipedia.org/wiki/Cylinder-head-sector&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://en.wikipedia.org/wiki/Zone_bit_recording&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://blog.csdn.net/badbad_boy/article/details/4313645&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://www.ibm.com/developerworks/cn/linux/l-4kb-sector-disks/index.html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://www.ibm.com/developerworks/cn/linux/l-linux-on-4kb-sector-disks/index.html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;https://blog.csdn.net/lyh__521/article/details/46795201&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://unix.stackexchange.com/questions/178899/optimizing-logical-sector-size-for-physical-sector-size-4096-hdd&quot;&gt;&lt;span&gt;&lt;span&gt;https://unix.stackexchange.com/questions/178899/optimizing-logical-sector-size-for-physical-sector-size-4096-hdd&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Apr 2020 14:23:00 +0000</pubDate>
<dc:creator>潇湘隐者</dc:creator>
<og:description>一直以来，个人对于磁盘的底层技术很少关注，可能更多的是关注磁盘IO性能，读写速率，这篇博文就磁盘扇区（Sector）和块/簇这方面的知识做一些深入性的总结，希望对你有所帮助！如有不足或错误的地方，也敬</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kerrycode/p/12701772.html</dc:identifier>
</item>
</channel>
</rss>