<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>流媒体与实时计算，Netflix公司Druid应用实践 - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/12866898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/12866898.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511082946898-1723482156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Netflix(Nasdaq NFLX)，也就是网飞公司，成立于1997年，是一家在线影片[租赁]提供商，主要提供Netflix超大数量的[DVD]并免费递送，总部位于美国加利福尼亚州洛斯盖图。1999年开始订阅服务。2009年，该公司可提供多达10万部DVD电影，并有1千万的订户。2007年2月25日，Netflix宣布已经售出第10亿份DVD。&lt;/p&gt;
&lt;p&gt;Netflix已经连续五次被评为顾客最满意的网站。可以通过PC、TV及iPad、iPhone收看电影、电视节目，可通过[Wii]，[Xbox360]，[PS3]等设备连接TV。Netflix是全球领先的经营在线业务公司。它成功地把传统的影像租赁业务和现代化的市场营销手段、先进的IT网络技术结合起来，从而开创了在线影像租赁的新局面。Netflix通过整合其自身的营销手段和最近的IT网络技术，成功地改变了消费习惯和打造了自己的品牌优势。&lt;/p&gt;
&lt;p&gt;Netflix在2011年开始探索自制内容的举动并不被看好。直到2013年，其首部自制剧《纸牌屋》取得爆红后，舆论冲击及股票下滑的趋势才得以扭转。这也让Netflix成功打响了平台自制内容的第一炮。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083001898-92428784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2019 年 7 月 4 日，网飞的原创剧《怪奇物语》第三季开播，一如往常地一口气放出 12 集，再次掀起话题热潮。取得这样的成功，网飞自然是高兴不已。7 月 8 日，这家通常并不爱自夸成绩的公司表示，有近 4100 万家庭在四天之内观看了《怪奇物语》最新季，超过 1800 万家庭已经把整 8 集全部刷完。如果需要对比数据的话，4 月份 HBO 发布的《权力的游戏》最终季首播集观看人数为 1740 万。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083009315-1504723279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在持续推动创新技术更新的同时，Netflix确保始终如一的出色的用户体验绝非易事。如何才能确信更新系统的时候不会影响用户的使用？而且实际上如何得到更多的反馈，可以对系统进行不断地改进也是一个巨大的挑战。&lt;/p&gt;
&lt;p&gt;最终，Netflix公司通过对设备的数据进行采集，使用来自设备的实时日志作为事件源，得到了大量的数据，通过实时的大数据了解和量化了用户设备，最终成功的近乎无缝地处理了视频的浏览和回放，完美的解决了这些问题。&lt;/p&gt;
&lt;p&gt;下面我们来具体了解一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083015418-1489044290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，整个系统架构通过对用户设备日志收集，通过kafka的消息传递，最终存储在Druid中。&lt;/p&gt;
&lt;p&gt;一旦有了这些数据，就将它们存入数据库，这里使用的是实时分析数据库Druid。&lt;/p&gt;
&lt;p&gt;每项数据流均标有关于所用设备类型的匿名详细信息，例如，该设备是智能电视，iPad还是Android手机。这使得能够根据各个方面对设备进行分类并查看数据。反过来，这又使我们能够定向的分析仅影响特定人群的问题，例如应用程序的版本，特定类型的设备或特定国家/地区。&lt;/p&gt;
&lt;p&gt;可通过仪表板或临时查询立即使用此聚合数据进行查询。还可以连续检查指标是否有警报信号，例如新版本是否正在影响某些用户或设备的播放或浏览。这些检查用于警告负责的团队，他们可以尽快解决该问题。&lt;/p&gt;
&lt;p&gt;在软件更新期间，为部分用户启用新版本，并使用这些实时指标来比较新版本与以前版本的性能。指标中的任何问题都会使我们立刻发现并中止更新，并将那些使新版本直接恢复到先前版本。&lt;/p&gt;
&lt;p&gt;由于每秒需要处理超过200万个事件，因此将其放入可以快速查询的数据库是一个非常艰巨的任务。我们需要一个拥有足够的性能与多维度查询的数据库，来处理每天产生超过1,150亿行的数据。在Netflix，最终选择利用Apache Druid来应对这一挑战。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083034429-1413204388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Druid是一个分布式的支持实时分析的数据存储系统。通俗一点：高性能实时分析数据库。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://druid.apache.org/&quot;&gt;Apache Druid&lt;/a&gt;是一个高性能的实时分析数据库。它是为需要快速查询和提取的工作流而设计的。德鲁伊在即时数据可视性，即席查询，运营分析和处理高并发方面表现出色。” — druid.io&lt;/p&gt;
&lt;p&gt;因此，Druid非常适合现在我们面临的这种用例。事件数据的摄取频率非常高，具有大数据量和快速查询要求。&lt;/p&gt;
&lt;p&gt;Druid不是关系数据库，但是某些概念是可移植的。我们有数据源，而不是表。与关系数据库一样，这些是表示为列的数据的逻辑分组。Druid的Join性能目前还不是很优秀。因此，我们需要确保每个数据源中都包含我们要过滤或分组依据的任何列。&lt;/p&gt;
&lt;p&gt;数据源中主要有三类列-时间，维度和指标。&lt;/p&gt;
&lt;p&gt;德鲁伊中的一切都取决于时间。每个数据源都有一个timestamp列，它是主要的分区机制。维度是可用于过滤，查询或分组依据的值。指标是可以汇总的值，几乎总是数字。&lt;/p&gt;
&lt;p&gt;我们假设数据由时间戳作为键，Druid可以对存储，分配和查询数据的方式进行一些优化，从而使我们能够将数据源扩展到数万亿行，并且仍然可以实现查询响应时间在&lt;strong&gt;十毫秒&lt;/strong&gt;内。&lt;/p&gt;
&lt;p&gt;为了达到这种级别的可伸缩性，Druid将存储的数据划分为多个时间块。时间块的持续时间是可配置的。可以根据您的数据和用例选择适当的持续时间。对于我们的数据和用例，我们使用1小时时间块。时间块内的数据存储在一个或多个&lt;a href=&quot;https://druid.apache.org/docs/latest/design/segments.html&quot;&gt;段中&lt;/a&gt;。每个段都保存有所有数据行，这些行均落在其时间戳键列所确定的时间块内。可以配置段的大小，以使行数或段文件的总大小有上限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083046070-191866240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查询数据时，Druid将查询发送到集群中所有包含查询范围内时间块的分段的节点。每个节点在将中间结果发送回查询代理节点之前，都会对所保存的数据进行并行处理。代理将执行最终合并和聚合，然后再将结果集发送回客户端。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083257641-1090775085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083200729-582525306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把数据实时插入到此数据库。这些事件（在本例中为指标）不是从单个记录插入到数据源中，而是从Kafka流中读取。每个数据源使用1个主题。在Druid中，我们使用Kafka索引编制任务，该任务创建了多个在实时节点中间管理者之间分布的索引编制工作器。&lt;/p&gt;
&lt;p&gt;这些索引器中的每一个都订阅该主题，并从流中读取其事件共享。索引器根据摄入规范从事件消息中提取值，并将创建的行累积在内存中。一旦创建了行，就可以对其进行查询。到达索引器仍在填充一个段的时间块的查询将由索引器本身提供。由于索引编制任务实际上执行两项工作，即摄取和现场查询，因此及时将数据发送到“历史节点”以更优化的方式将查询工作分担给历史节点非常重要。&lt;/p&gt;
&lt;p&gt;Druid可以在提取数据时对其进行汇总，以最大程度地减少需要存储的原始数据量。汇总是一种汇总或预聚合的形式。在某些情况下，汇总数据可以极大地减少需要存储的数据大小，从而有可能将行数减少几个数量级。但是，减少存储量确实要付出一定的代价：我们失去了查询单个事件的能力，只能以预定义的查询粒度进行查询。对于我们的用例，我们选择了1分钟的查询粒度。&lt;/p&gt;
&lt;p&gt;在提取期间，如果任何行具有相同的维度，并且它们的时间戳在同一分钟内（我们的查询粒度），则这些行将被汇总。这意味着通过将所有度量值加在一起并增加一个计数器来合并行，因此我们知道有多少事件促成了该行的值。这种汇总形式可以显着减少数据库中的行数，从而加快查询速度，因为这样我们就可以减少要操作和聚合的行。&lt;/p&gt;
&lt;p&gt;一旦累积的行数达到某个阈值，或者该段已打开太长时间，则将这些行写入段文件中并卸载到深度存储中。然后，索引器通知协调器段已准备好，以便协调器可以告诉一个或多个历史节点加载该段。一旦将段成功加载到“历史”节点中，就可以从索引器中将其卸载，并且历史记录节点现在将为所有针对该数据的查询提供服务。&lt;/p&gt;

&lt;p&gt;就像您想象的那样，随着维数基数的增加，在同一分钟内发生相同事件的可能性降低。管理基数以及因此汇总，是获得良好查询性能的有力手段。&lt;/p&gt;
&lt;p&gt;为了达到所需的摄取速率，我们运行了许多索引器实例。即使在索引任务中合并了相同行的汇总，在相同的索引任务实例中获得所有相同行的机会也非常低。为了解决这个问题并实现最佳的汇总，我们安排了一个任务，在将给定时间块的所有段都移交给历史节点之后运行。&lt;/p&gt;
&lt;p&gt;计划的压缩任务从深度存储中获取所有分段以进行时间块化，并执行映射/缩小作业以重新创建分段并实现完美的汇总。然后，由“历史记录”节点加载并发布新的细分，以替换并取代原始的，较少汇总的细分。在我们的案例中，通过使用此额外的压缩任务，我们发现行数提高了2倍。&lt;/p&gt;
&lt;p&gt;知道何时收到给定时间块的所有事件并不是一件容易的事。可能有关于Kafka主题的迟到数据，或者索引器可能会花一些时间将这些片段移交给“历史”节点。为了解决此问题，我们在运行压缩之前强加了一些限制并执行检查。&lt;/p&gt;
&lt;p&gt;首先，我们丢弃任何非常迟到的数据。我们认为这太旧了，无法在我们的实时系统中使用。这样就可以确定数据的延迟时间。其次，压缩任务是有延迟地安排的，这给了段足够的时间以正常流程分流到历史节点。最后，当给定时间块的计划压缩任务开始时，它查询段元数据以检查是否还有任何相关段仍在写入或移交。如果有，它将等待几分钟后重试。这样可以确保所有数据都由压缩作业处理。&lt;/p&gt;
&lt;p&gt;如果没有这些措施，我们发现有时会丢失数据。开始压缩时仍要写入的段将被具有更高版本的新压缩的段覆盖，因此具有优先权。这有效地删除了尚未完成移交的那些段中包含的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083208750-911267314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Druid支持两种查询语言：Druid SQL和原生查询。在后台，Druid SQL查询被转换为本地查询。原生查询作为JSON提交到REST端点，这是我们使用的主要机制。&lt;/p&gt;
&lt;p&gt;对集群的大多数查询都是由自定义内部工具（例如仪表板和警报系统）生成的。这些系统最初旨在与我们内部开发的开源时间序列数据库&lt;a href=&quot;https://github.com/Netflix/atlas&quot;&gt;Atlas一起使用&lt;/a&gt;。因此，这些工具使用Atlas Stack查询语言。&lt;/p&gt;
&lt;p&gt;为了加快采用Druid查询的速度并实现对现有工具的重用，我们添加了一个转换层，该层接受Atlas查询，将其重写为Druid查询，发布查询并将结果重新格式化为Atlas结果。这个抽象层使现有工具可以按原样使用，并且不会为用户访问我们的Druid数据存储中的数据创建任何额外的学习曲线。&lt;/p&gt;

&lt;p&gt;在调整群集节点的配置时，我们以很高的速度运行了一系列可重复和可预测的查询，以便获得每个给定配置的响应时间和查询吞吐量的基准。这些查询旨在隔离集群的各个部分，以检查查询性能是否有所改善或降低。&lt;/p&gt;
&lt;p&gt;例如，我们针对最新数据运行了有针对性的查询。同样，对于更长的持续时间，但只有较旧的数据可以确保我们仅查询“历史”节点以测试缓存配置。再次使用按非常高的基数维度分组的查询，以检查结果合并是如何受到影响的。我们继续调整并运行这些基准测试，直到对查询性能感到满意为止。&lt;/p&gt;
&lt;p&gt;在这些测试中，我们发现调整缓冲区的大小，线程数，查询队列长度和分配给查询缓存的内存对查询性能产生了有效影响。但是，引入压缩工作将占用我们汇总不良的细分，并以完美汇总将它们重新压缩，这对查询性能产生了更大的影响。&lt;/p&gt;
&lt;p&gt;我们还发现，在历史节点上启用缓存非常有好处，而在代理节点上启用缓存则没有那么多。太多了，我们不使用代理上的缓存。这可能是由于我们的用例所致，但是我们几乎进行的每个查询都未命中代理上的缓存，这可能是因为查询通常包含最新数据，因为这些数据始终会到达，因此不会包含在任何缓存中。&lt;/p&gt;

&lt;p&gt;经过多次迭代，针对我们的用例和数据速率进行了调整和定制，德鲁伊已被证明具有我们最初希望的能力。&lt;/p&gt;
&lt;p&gt;我们已经能够使用功能强大且可用的系统，但是还有更多工作要做。我们的摄入量和摄入率不断提高，查询的数量和复杂性也在不断增加。随着更多团队实现这些详细数据的价值，我们经常添加更多指标和维度，从而推动系统更加努力地工作。我们必须继续监视和调整，以保持查询性能。&lt;/p&gt;
&lt;p&gt;目前，我们每秒接收超过200万个事件，并查询超过1.5万亿行，以深入了解我们的用户如何体验该服务。所有这些都有助于我们保持高质量的Netflix体验，同时实现不断的创新。&lt;/p&gt;
&lt;p&gt;实时流式计算与流媒体的碰撞才刚刚开始，而Druid作为一款极易上手的高性能实时查询数据库，也会得到越来越多的广泛使用。&lt;/p&gt;
&lt;p&gt;更多实时数据分析相关博文与科技资讯，欢迎关注 “实时流式计算”&lt;/p&gt;
&lt;p&gt;获取《Druid实时大数据分析》电子书，请在公号后台回复 “Druid”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083216576-1437389309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 May 2020 00:34:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<og:description>Netflix(Nasdaq NFLX)，也就是网飞公司，成立于1997年，是一家在线影片[租赁]提供商，主要提供Netflix超大数量的[DVD]并免费递送，总部位于美国加利福尼亚州洛斯盖图。199</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/12866898.html</dc:identifier>
</item>
<item>
<title>事务的四种隔离级别 - Code2020</title>
<link>http://www.cnblogs.com/cxy2020/p/12866859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxy2020/p/12866859.html</guid>
<description>&lt;p&gt;数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Read uncommitted&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。&lt;/p&gt;
&lt;p&gt;事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。&lt;/p&gt;
&lt;p&gt;分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Read committed&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。&lt;/p&gt;
&lt;p&gt;事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…&lt;/p&gt;
&lt;p&gt;分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;那怎么解决可能的不可重复读问题？Repeatable read ！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Repeatable read&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重复读，就是在开始读取数据（事务开启）时，不再允许修改操作&lt;/p&gt;
&lt;p&gt;事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。&lt;/p&gt;
&lt;p&gt;分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;什么时候会出现幻读？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;那怎么解决幻读问题？Serializable！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Serializable 序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。&lt;/p&gt;
</description>
<pubDate>Mon, 11 May 2020 00:13:00 +0000</pubDate>
<dc:creator>Code2020</dc:creator>
<og:description>数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxy2020/p/12866859.html</dc:identifier>
</item>
<item>
<title>架构设计 | 分布式系统调度，Zookeeper集群化管理 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12865994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12865994.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1、基础简介&quot;&gt;1、基础简介&lt;/h2&gt;
&lt;p&gt;Zookeeper基于观察者模式设计的组件，主要应用于分布式系统架构中的，统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等场景。&lt;/p&gt;
&lt;h2 id=&quot;2、集群选举&quot;&gt;2、集群选举&lt;/h2&gt;
&lt;p&gt;Zookeeper集群基于半数机制，集群中半数以上机器存活，集群处于可用状态。所以建议Zookeeper集群安装为奇数台服务器。在集群的配置文件中并没有指定Master和Slave。在Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202005/1691717-20200510233814575-1695698996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有三台服务器组成的Zookeeper集群，每个节点的myid编号依次1-3，依次启动服务器，会发现server2被选择为Leader节点。&lt;/p&gt;
&lt;p&gt;server1启动，执行一次选举。服务器1投自己一票。此时服务器1票数一票，未达到半数以上（2票），选举无法完成，服务器1状态保持为LOOKING；&lt;/p&gt;
&lt;p&gt;server2启动，再执行一次选举。服务器1和2分别投自己一票，并交换选票信息，因为服务器2的myid比服务器1的myid大，服务器1会更改选票为投服务器2。此时服务器1票数0票，服务器2票数2票，达到半数以上，选举完成，服务器1状态为follower，2状态保持leader，此时集群可用，服务器3启动后直接为follower。&lt;/p&gt;

&lt;h2 id=&quot;1、创建配置目录&quot;&gt;1、创建配置目录&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# mkdir -p /data/zookeeper/data
# mkdir -p /data/zookeeper/logs
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、基础配置&quot;&gt;2、基础配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# vim /opt/zookeeper-3.4.14/conf/zoo.cfg

tickTime=2000
initLimit=10
syncLimit=5
dataDir=/data/zookeeper/data
dataLogDir=/data/zookeeper/logs
clientPort=2181
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、单节点配置&quot;&gt;3、单节点配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# vim /data/zookeeper/data/myid 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个节点服务，分别在myid文件中写入[1,2,3]&lt;/p&gt;
&lt;h2 id=&quot;4、集群服务&quot;&gt;4、集群服务&lt;/h2&gt;
&lt;p&gt;在每个服务的zoo.cfg配置文件中写入如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server.1=192.168.72.133:2888:3888
server.2=192.168.72.136:2888:3888
server.3=192.168.72.137:2888:3888
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5、启动集群&quot;&gt;5、启动集群&lt;/h2&gt;
&lt;p&gt;分别启动三台zookeeper服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[zookeeper-3.4.14]# bin/zkServer.sh start
Starting zookeeper ... STARTED
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6、查看集群状态&quot;&gt;6、查看集群状态&lt;/h2&gt;
&lt;p&gt;Mode: leader是Master节点&lt;/p&gt;
&lt;p&gt;Mode: follower是Slave节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[zookeeper-3.4.14]# bin/zkServer.sh status
Mode: leader
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7、集群状态测试&quot;&gt;7、集群状态测试&lt;/h2&gt;
&lt;p&gt;随便登录一台服务的客户端，创建一个测试节点，然后在其他服务上查看。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[zookeeper-3.4.14 bin]# ./zkCli.sh
[zk: 0] create /node-test01 node-test01  
Created /node-test01
[zk: 1] get /node-test01
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者关闭leader节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[zookeeper-3.4.14 bin]# ./zkServer.sh stop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则会重新选举该节点。&lt;/p&gt;
&lt;h2 id=&quot;8、nginx统一管理&quot;&gt;8、Nginx统一管理&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[rnginx-1.15.2 conf]# vim nginx.conf

stream {
    upstream zkcluster {
        server 192.168.72.133:2181;
        server 192.168.72.136:2181;
        server 192.168.72.136:2181;
    }
    server {
        listen 2181;
        proxy_pass zkcluster;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1、基本原理&quot;&gt;1、基本原理&lt;/h2&gt;
&lt;p&gt;分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知到主节点服务器的上下线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202005/1691717-20200510233802104-652576202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程描述：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动Zookeeper集群服务；&lt;/li&gt;
&lt;li&gt;RegisterServer模拟服务端注册；&lt;/li&gt;
&lt;li&gt;ClientServer模拟客户端监听；&lt;/li&gt;
&lt;li&gt;启动服务端注册三次，注册不同节点的zk-node服务；&lt;/li&gt;
&lt;li&gt;依次关闭注册的服务端，模拟服务下线流程；&lt;/li&gt;
&lt;li&gt;查看客户端日志，可以监控到服务节点变化；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先创建一个节点：serverList，用来存放服务器列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[zk: 0] create /serverList &quot;serverList&quot; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、服务端注册&quot;&gt;2、服务端注册&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.zkper.cluster.monitor;
import java.io.IOException;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.ZooDefs.Ids;

public class RegisterServer {

    private ZooKeeper zk ;
    private static final String connectString = &quot;127.0.0.133:2181,127.0.0.136:2181,127.0.0.137:2181&quot;;
    private static final int sessionTimeout = 3000;
    private static final String parentNode = &quot;/serverList&quot;;

    private void getConnect() throws IOException{
        zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
            }
        });
    }

    private void registerServer(String nodeName) throws Exception{
        String create = zk.create(parentNode + &quot;/server&quot;, nodeName.getBytes(),
                                  Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        System.out.println(nodeName +&quot; 上线：&quot;+ create);
    }

    private void working() throws Exception{

        Thread.sleep(Long.MAX_VALUE);
    }

    public static void main(String[] args) throws Exception {
        RegisterServer server = new RegisterServer();
        server.getConnect();
        // 分别启动三次服务，注册不同节点，再一次关闭不同服务端看客户端效果
        // server.registerServer(&quot;zk-node-133&quot;);
        // server.registerServer(&quot;zk-node-136&quot;);
        server.registerServer(&quot;zk-node-137&quot;);
        server.working();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、客户端监听&quot;&gt;3、客户端监听&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.zkper.cluster.monitor;
import org.apache.zookeeper.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class ClientServer {
    private ZooKeeper zk ;
    private static final String connectString = &quot;127.0.0.133:2181,127.0.0.136:2181,127.0.0.137:2181&quot;;
    private static final int sessionTimeout = 3000;
    private static final String parentNode = &quot;/serverList&quot;;

    private void getConnect() throws IOException {
        zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent event) {
                try {
                    // 监听在线的服务列表
                    getServerList();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
    }

    private void getServerList() throws Exception {
        List&amp;lt;String&amp;gt; children = zk.getChildren(parentNode, true);
        List&amp;lt;String&amp;gt; servers = new ArrayList&amp;lt;&amp;gt;();
        for (String child : children) {
            byte[] data = zk.getData(parentNode + &quot;/&quot; + child, false, null);
            servers.add(new String(data));
        }
        System.out.println(&quot;当前服务列表：&quot;+servers);
    }

    private void working() throws Exception{
        Thread.sleep(Long.MAX_VALUE);
    }

    public static void main(String[] args) throws Exception {
        ClientServer client = new ClientServer();
        client.getConnect();
        client.getServerList();
        client.working();
    }

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/data-manage-parent
GitEE·地址
https://gitee.com/cicadasmile/data-manage-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：数据和架构管理&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 May 2020 23:53:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、框架简介 1、基础简介 Zookeeper基于观察者模式设计的组件，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12865994.html</dc:identifier>
</item>
<item>
<title>vue+.netcore可支持业务代码扩展的开发框架 VOL.Vue 2.0版本发布 - bububu。</title>
<link>http://www.cnblogs.com/-clouds/p/12704899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-clouds/p/12704899.html</guid>
<description>&lt;div id=&quot;vol-doc&quot;&gt;
&lt;div class=&quot;vol-desc&quot;&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;这是一个基于vue、element-ui、iview、.netcore3.1 可支持前端、后台动态扩展业务代码快速开发框架。&lt;/li&gt;
&lt;li&gt;框架内置定制开发的代码生成器，生成的代码不需要复制也不需要更改，直接就能运行。&lt;/li&gt;
&lt;li&gt;后台基于.netcore3.1、EntityFramework Core3.1、Dapper、Autofac框架底层搭建。&lt;/li&gt;
&lt;li&gt;前端基于vue、element-ui、iview二次开发了多个可直接上手使用的组件,适用于编写各种后台restful api或前端表单开发。&lt;/li&gt;
&lt;li&gt;前、后端累计提供了超过300个扩展方法与属性；并且后台提供了大量的基础功能。&lt;/li&gt;
&lt;li&gt;框架前、后端代码进行自定义扩展。&lt;/li&gt;
&lt;li&gt;框架2.0已补全开发文档。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vol-desc&quot;&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;框架1.0第一个版本于2019.10月发布，期间得到了许多朋友的反馈；至今框架做了大量内部优化改进与bug修复及功能增加。&lt;/li&gt;
&lt;li&gt;在此感谢使用1.0版本的朋友对框架提出的改进与issue表示忠心的感谢。&lt;/li&gt;
&lt;li&gt;同时也感谢各位老板对本框架赞助, &lt;a href=&quot;http://donate.volcore.xyz/&quot; target=&quot;_blank&quot;&gt;查看&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vol-desc&quot;&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;快速开发(基础功能全部由代码生成器生成)&lt;/li&gt;
&lt;li&gt;支持前端、后台自定义业务代码扩展,后台提供了大量常用扩展与通用类&lt;/li&gt;
&lt;li&gt;前端、后台提供了近300个扩展方法与属性,开发人员可在此功能上编写扩展自定义业务代码&lt;/li&gt;
&lt;li&gt;代码生成(代码生成器可直接生成主/从表前后端业务代码,有30多种属性可在线配置生成的代码)&lt;/li&gt;
&lt;li&gt;前端table自动转换key/value&lt;/li&gt;
&lt;li&gt;前端表单select/checkbox自动绑定数据源,不需要写任何代码&lt;/li&gt;
&lt;li&gt;支持(主从表)一对一前后端代码全自动生成、并支持数据源自动绑定与业务代码扩展,不需要写任何代码&lt;/li&gt;
&lt;li&gt;支持一对多从表自定义扩展(不限从表类型与从表数量)&lt;/li&gt;
&lt;li&gt;如果能上手框架，可以体会到不用996,更不用掉头发的感觉^_^&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vol-desc&quot;&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;前后端分离项目&lt;/li&gt;
&lt;li&gt;编写各种后台restful api接口。后台基础代码由代码生成器完成,在生成的代码上继续编写业务即可&lt;/li&gt;
&lt;li&gt;前端表单开发(直接上手看demo即可)&lt;/li&gt;
&lt;li&gt;配合app做H5或全h5开发&lt;/li&gt;
&lt;li&gt;发布静态(h5)页面,框架已经提供了demo&lt;/li&gt;
&lt;li&gt;在现有的代码生成器功能上，继续定制开发代码生成器功能,解决重复性工作&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vol-desc&quot;&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;后台：VS2019 、.NetCore3.1 、EFCore3.1、JWT、Dapper、Autofac、SqlServer/MySql、Redis(可选,默认使用内置IMemory)&lt;/li&gt;
&lt;li&gt;前端：VsCode、Vue2.0（webpack、node.js,如果没有此环境自行搜索:vue webpack npm)、vuex、axios、promise、iview、element-ui&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;vol-desc&quot; readability=&quot;10&quot;&gt;

&lt;p&gt;对1.0版本已补全框架文档,文档几乎覆盖了整个框架,包括前端；并且框架对1.0版本增加了大量功能及内部代码优化与bug修复&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;vol-desc&quot; readability=&quot;7&quot;&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998968/202004/998968-20200415134541114-157642630.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;更多优化及优化日志见demo文档中更新日志&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;vol-desc&quot;&gt;

&lt;div&gt;
&lt;div class=&quot;vol-desc&quot;&gt;

&lt;ul&gt;&lt;li&gt;框架内置了大量的通用组件可直接使用,并内置了基于本框架定制开发的代码生成器，尽量避免重复性代码编写。&lt;/li&gt;
&lt;li&gt;框架不仅仅是快速开发，更多的是倾向于业务代码扩展的编写与代码规范。&lt;/li&gt;
&lt;li&gt;如果有什么问题或建议，提issue或加QQ：283591387&lt;/li&gt;
&lt;li&gt;QQ交流群：45221949&lt;/li&gt;
&lt;li&gt;如果觉得框架对你有用，帮忙点个star，非常感谢!&lt;/li&gt;
&lt;li&gt;demo服务器是腾讯云linux服务器带宽1M，多人访问会出现延迟情况&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 10 May 2020 23:53:00 +0000</pubDate>
<dc:creator>bububu。</dc:creator>
<og:description>框架介绍 这是一个基于vue、element-ui、iview、.netcore3.1 可支持前端、后台动态扩展业务代码快速开发框架。 框架内置定制开发的代码生成器，生成的代码不需要复制也不需要更改，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/-clouds/p/12704899.html</dc:identifier>
</item>
<item>
<title>深入理解JS中的对象（一） - forcheng</title>
<link>http://www.cnblogs.com/forcheng/p/12866827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/forcheng/p/12866827.html</guid>
<description>&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一切皆是对象吗？&lt;/li&gt;
&lt;li&gt;对象
&lt;ul&gt;&lt;li&gt;原型与原型链&lt;/li&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;参考&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1.一切皆是对象吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，“在 JavaScript 中，一切皆是对象”这种表述是不完全正确的。&lt;/p&gt;
&lt;p&gt;JavaScript 的数据类型分为两类：原始值类型和对象（Object类型）。&lt;/p&gt;
&lt;p&gt;原始值类型（ES5）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;null - typeof null 的值为&quot;object&quot;，是因为 ES5 规范规定：对于 null 值的 typeof 字符串值返回&quot;object&quot;&lt;/li&gt;
&lt;li&gt;true/false - 布尔值&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var a = undefined
var b = null
var c = true
var d = 1
var e = &quot;abc&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些值是在底层上直接实现的，它们不是object，所以没有原型（__proto__），没有构造函数（constructor）。&lt;/p&gt;
&lt;p&gt;但我们再实践过程中，会发现虽然字符串，布尔值和数字是原始值类型，但却表现得有点像对象。&lt;/p&gt;
&lt;p&gt;以字符串为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/898684/202005/898684-20200511073026309-115340623.png&quot; alt=&quot;字符串原始值类型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，可以看到定义了一个值为&quot;abc&quot;的字符串变量 e，访问其 &lt;em&gt;_proto&lt;/em&gt;_ 和 constructor 属性，发现其居然有值？不是说原始值类型没有原型和构造函数，这是怎么回事呢？&lt;/p&gt;
&lt;p&gt;原来原始值类型（布尔值、数字、字符串）有其对应的包装器对象：Boolean（布尔对象）、Number（数字对象）、String（字符串对象），在这些原始值类型上尝试调用属性或方法（比如 constructor 等）时，JS会自动进行 Auto-Boxing（临时包装）的过程，首先将其转换为临时包装器对象，再访问其上的属性或方法，而不会影响原始值类型的属性。&lt;/p&gt;
&lt;p&gt;这也能解释为什么我们直接对原始值类型变量（布尔值、数字、字符串）添加了一些属性，再次访问依旧为 undefined，因为我们访问属性操作的是临时包装器对象，不会影响基本原始值类型本身。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/898684/202005/898684-20200511073112797-2132777052.png&quot; alt=&quot;临时包装器对象&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而原始值类型（null 与 undefined）没有对应的包装器对象，所以在其上尝试访问任何属性或方法都会报错。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/898684/202005/898684-20200511073151945-920483988.png&quot; alt=&quot;null 与 undefined 没有包装器对象&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JS中，Object 是一个属性的集合，并且拥有一个单独的原型对象 [prototype object] （其可以是一个 object 或 null 值）。&lt;/p&gt;
&lt;p&gt;在浏览器或 Node.js 中，可以通过 &lt;em&gt;_proto&lt;/em&gt;_ 属性访问这个原型对象， &lt;em&gt;_proto&lt;/em&gt;_ 被称为该对象的原型，但为了和函数的原型属性（prototype）区分，一般称其为隐式原型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var position = {
  x: 10,
  y: 20,
  z: 30,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，对象与隐式原型的关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/898684/202005/898684-20200511073236583-166584668.png&quot; alt=&quot;对象与隐式原型的关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）原型与原型链&lt;/p&gt;
&lt;p&gt;在JS中，对象的继承关系是通过隐式原型（__proto__）来实现的。对象的隐式原型在对象创建时由对象的构造函数自动关联，也可以通过修改隐式原型，更改对象的继承关系。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由 Object 构造函数创建的对象，其隐式原型指向 Object.prototype。而 Object.prototype 对象的隐式原型的值默认为 nulll。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// x, y, z 的隐式原型 __proto__ 默认都指向 Object.prototype
var x = {
    a: 10,
}
var y = {
    a: 20,
    b: 30,
}
var z = {
    a: 40,
    b: 50,
    c: 60,
}
  
// 设置 x 的隐式原型为 y
// 设置 y 的隐式原型为 z
x.__proto__ = y
y.__proto__ = z
  
console.log(x.a)  // 10 - 来自 x 自身的属性
console.log(x.b)  // 30 - 来自 y 的属性
console.log(x.c)  // 60 - 来自 z 的属性

// 修改 y 的属性 b 的值
y.b = 70

console.log(x.b)  // 70 - 来自 y 的属性

// 移除 z 的属性 c
delete z.c

console.log(x.c)  // undefined - 沿着隐式原型一级一级往上找，没有找到该属性
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述代码，我们可以看到，当访问一个对象的属性时，会优先在这个对象的属性中查找是否存在所要访问的属性，若存在，则获取成功，停止查找；若没有找到该属性，则会继续去查找该对象的隐式原型中是否存在，若存在，则获取成功，停止查找；若还是没有查找到，将继续再往上一级的隐式原型中查找，直到找到则返回找到的属性值 或 直到遇到隐式原型值为 null 则返回 undefined。&lt;/p&gt;
&lt;p&gt;这种由原型相互关联（指向）的关系就形成了所谓的原型链，而对象的属性或方法的查找就是沿着原型链顺序进行查找的。&lt;/p&gt;
&lt;p&gt;上述代码示例中的原型链关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/898684/202005/898684-20200511073303555-1849276931.png&quot; alt=&quot;代码示例中的原型链关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）构造函数&lt;/p&gt;
&lt;p&gt;首先要明白，函数也是一个特殊的对象，除了和其他对象一样有 &lt;em&gt;_proto&lt;/em&gt;_ 属性外，还有自己特有的属性——显示原型（prototype），这个属性指向一个对象，其用途就是包含所有实例共享的属性和方法。显示原型对象也有一个 constructor 属性，这个属性指向原构造函数。&lt;/p&gt;
&lt;p&gt;而所谓构造函数，就是提供一个生成对象的模板，并描述对象的基本结构的函数。一个构造函数，可以生成多个对象，每个对象都有相同的结构。而JS中所有函数（除了箭头函数）都可以当做构造函数。&lt;/p&gt;
&lt;p&gt;一个对象由构造函数创建时，其隐式原型（__proto__）指向构造该对象的构造函数（constructor）的显示原型（prototype），这保证了实例能够访问在构造函数原型中定义的属性和方法。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 构造函数 C
function C(x) {
    this.x = x
}

// 继承属性 y
C.prototype.y = 30

// new 两个对象实例a、b
var a = new C(10)
var b = new C(20)

console.log(a.x) // 10
console.log(a.y) // 30
console.log(b.x) // 20
console.log(b.y) // 30

// 对象实例 a、b 的隐式原型（__proto__）指向构造该对象的构造函数 C 的显示原型（prototype）
console.log(a.__proto__ === C.prototype) // true
console.log(b.__proto__ === C.prototype) // true

// 构造函数的显示原型（prototype）的 constructor 属性指向原构造函数
console.log(C === C.prototype.constructor) // true

// 构造函数 C、Function 与 Object 的隐式原型（__proto__）指向构造该对象的构造函数 Function 的显示原型（prototype）
console.log(C.__proto__ === Function.prototype) // true
console.log(Function.__proto__ === Function.prototype) // true
console.log(Object.__proto__ === Function.prototype) // true

// C.prototype 与 Function.prototype 的隐式原型（__proto__）指向构造该对象的构造函数 Object 的显示原型（prototype）
console.log(C.prototype.__proto__ === Object.prototype) // true
console.log(Function.prototype.__proto__ === Object.prototype) // true

// Object.prototype 的隐式原型（__proto__）等于 null
console.log(Object.prototype.__proto__ === null) // true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码示例中的完整原型链关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/898684/202005/898684-20200511073332815-104712634.png&quot; alt=&quot;代码示例中的完整原型链关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图我们可以总结：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有的（隐式）原型链的最末端最终都会指向 null（JS不允许有循环原型链，避免死循环）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有函数默认都是有 Function 构造函数创建，即所有函数的隐式原型（__proto__）都指向 Function.prototype。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有对象默认都继承自Object对象，即默认情况下，所有对象的（隐式）原型链的末端都指向 Object.prototype。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注：所谓默认情况，即没有手动修改原型链关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65059409&quot;&gt;JS中一切都是对象吗？看这一篇就知道了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/34183746&quot;&gt;js中__proto__和prototype的区别和关系？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html&quot;&gt;深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/TomXu/archive/2012/02/06/2330609.html&quot;&gt;深入理解JavaScript系列（18）：面向对象编程之ECMAScript实现（推荐）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 May 2020 23:36:00 +0000</pubDate>
<dc:creator>forcheng</dc:creator>
<og:description>目录 一切皆是对象吗？ 对象 原型与原型链 构造函数 参考 1.一切皆是对象吗？ 首先，“在 JavaScript 中，一切皆是对象”这种表述是不完全正确的。 JavaScript 的数据类型分为两类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/forcheng/p/12866827.html</dc:identifier>
</item>
<item>
<title>不要把异常当做业务逻辑，这性能可能你无法承受 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/12866824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/12866824.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;在项目中摸爬滚打几年，应该或多或少的见过有人把异常当做业务逻辑处理的情况(┬＿┬)，比如说判断一个数字是否为整数,就想当然的用&lt;code&gt;try catch&lt;/code&gt; 包起来，再进行 &lt;code&gt;int.Parse&lt;/code&gt;，如果抛异常就说明不是整数，简单粗暴，也不需要写正则或者其他逻辑，再比如一个字符串强制转化为Enum，直接用&lt;code&gt;Enum.Parse&lt;/code&gt;，可能是因为对异常的开销不是特别了解，这种不好的使用习惯也许被官方发现了，后续给我们补了很多的Try前缀的方法，比如：&lt;code&gt;int.TryParse&lt;/code&gt; , &lt;code&gt;Enum.TryParse&lt;/code&gt;, &lt;code&gt;dict.TryGetValue&lt;/code&gt; ,用代码展示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;            //原始写法
            var num = int.Parse(&quot;1&quot;);

            //使用try方式
            var result = 0;
            var b = int.TryParse(&quot;1&quot;, out result);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用Try系列方法没毛病，但这写法让人吐槽，还要单独定义result变量，没撤，官方还得靠我们这些开发者给他们发扬光大😄😄😄，终于在C# 7.0 中新增了一个 &lt;code&gt;out variables&lt;/code&gt; 语法糖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
            //try out 变量模式
            var c = int.TryParse(&quot;1&quot;, out int result2);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种 &lt;code&gt;out 变量&lt;/code&gt; 模式就🐮👃了，一个方法获取两个值，还没有抛异常的风险。&lt;/p&gt;
&lt;h2 id=&quot;二：为什么要用tryxxx方法&quot;&gt;二：为什么要用tryxxx方法&lt;/h2&gt;
&lt;p&gt;有了tryxxx方法之后，你就应该明白微软已经在提醒我们开发人员不要滥用异常，尤其在可预知可预见的场景下，毕竟他们知道异常的开销真的是太大了，不知者不怪哈。&lt;/p&gt;
&lt;h3 id=&quot;1-肉眼看得见的低性能&quot;&gt;1. 肉眼看得见的低性能&lt;/h3&gt;
&lt;p&gt;为了让大家肉眼能看见，我们就用异常方法和tryxxx方法做一个性能比较，迭代50w次，看看各自的性能如何？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
            for (int i = 0; i &amp;lt; 3; i++)
            {
                var watch = Stopwatch.StartNew();
                for (int k = 0; k &amp;lt; 50000; k++)
                {
                    try
                    {
                        var num = int.Parse(&quot;xxx&quot;);
                    }
                    catch (Exception ex) { }
                }
                watch.Stop();

                Console.WriteLine($&quot;i={i + 1},耗费：{watch.ElapsedMilliseconds}&quot;);
            }
            Console.WriteLine(&quot;---------------------------------------------&quot;);
            for (int i = 0; i &amp;lt; 3; i++)
            {
                var watch = Stopwatch.StartNew();

                for (int k = 0; k &amp;lt; 50000; k++)
                {
                   var num = int.TryParse(&quot;xxx&quot;, out int reuslt);
                }

                watch.Stop();

                Console.WriteLine($&quot;i={i + 1},耗费：{watch.ElapsedMilliseconds}&quot;);
            }
            Console.ReadLine();

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200511073046017-1672463736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看结果还挺吓人的，相差480倍， 好熟悉的一个数字。。。 &lt;code&gt;南朝四百八十寺，多少楼台烟雨中&lt;/code&gt; 😄😄😄&lt;/p&gt;
&lt;h2 id=&quot;三：-异常的超强开销&quot;&gt;三： 异常的超强开销&lt;/h2&gt;
&lt;p&gt;为什么异常有那么大的开销？ 只有知己知彼才能心中有数，看过我多线程视频的朋友应该知道，线程的创建和销毁代价都是非常大的，其中有一项就是需要代码从用户态切换到了内核态，毕竟线程是操作系统层面的事情，和你CLR无关，CLR只是做了一层系统包装而已，其实很多人都想不到，我们用的 &lt;code&gt;try catch finally&lt;/code&gt; 底层也是封装了操作系统层面的（Windows 结构化异常处理），也叫做SEH，什么意思？ 就是当你throw之后，代码需要从用户态切换到内核态，这个开销是不会小的，还有一个开销来自于Exception中的StackTrace，这里面的值需要从当前异常的线程栈中去抓取调用堆栈，栈越深，开销就越大。&lt;/p&gt;
&lt;h3 id=&quot;1-从用户态到内核态&quot;&gt;1. 从用户态到内核态&lt;/h3&gt;
&lt;p&gt;大家肯定会说，甭那么玄乎，凡事都要讲个证据, &lt;code&gt;Do more,Talk less&lt;/code&gt;， 这里我准备分两种情况讲解。&lt;/p&gt;
&lt;h4 id=&quot;1-有catch情况&quot;&gt;&amp;lt;1&amp;gt; 有catch情况&lt;/h4&gt;
&lt;p&gt;准备在catch的时候阻塞住，然后抓它的dump文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            try
            {
                var num = int.Parse(&quot;xxx&quot;);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.ReadLine();
            }
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;!dumpstack&lt;/code&gt; 把当前 0号线程 的所有托管和非托管堆栈全部打出来，简化后如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; ~0s
ntdll!NtReadFile+0x14:
00007fff`f805aa64 c3              ret
0:000&amp;gt; !dumpstack
OS Thread Id: 0x2bf0 (0)
Current frame: ntdll!NtReadFile+0x14
Caller, Callee
(MethodDesc 00007fffde3a40b8 +0x18 System.Console.ReadLine())
(MethodDesc 00007fff810d59f8 +0xa5 ConsoleApp4.Program.Main(System.String[])), calling (MethodDesc 00007fffde3a40b8 +0 System.Console.ReadLine())
00000044433fc700 00007fffe07a29e0 clr!ExceptionTracker::CallCatchHandler+0x9c, calling clr!ExceptionTracker::CallHandler
clr!ClrUnwindEx+0x40, calling ntdll!RtlUnwindEx
ntdll!RtlRaiseException+0x4e, calling ntdll!RtlpCaptureContext
clr!IL_Throw+0x114, calling clr!RaiseTheExceptionInternalOnly
(MethodDesc 00007fffde4f95c0 System.Number.StringToNumber(System.String, System.Globalization.NumberStyles, NumberBuffer ByRef, System.Globalization.NumberFormatInfo, Boolean)), calling mscorlib_ni+0x53976a
(MethodDesc 00007fffde3b5330 +0xae System.Number.ParseInt32(System.String, System.Globalization.NumberStyles, System.Globalization.NumberFormatInfo)), calling (MethodDesc 00007fffde4f95c0 +0 System.Number.StringToNumber(System.String, System.Globalization.NumberStyles, NumberBuffer ByRef, System.Globalization.NumberFormatInfo, Boolean))
(MethodDesc 00007fffde1ebfa8 +0x2eb System.Globalization.NumberFormatInfo..ctor(System.Globalization.CultureData)), calling (MethodDesc 00007fffde1eba68 +0 System.Globalization.CultureData.GetNFIValues(System.Globalization.NumberFormatInfo))
(MethodDesc 00007fff810d59f8 +0x49 ConsoleApp4.Program.Main(System.String[])), calling (MethodDesc 00007fffde3b1708 +0 System.Int32.Parse(System.String))

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为是堆栈，所以执行流就要从后往前看，你会发现流程大概是这个样子 &lt;code&gt;int.Parse -&amp;gt; CLR -&amp;gt; ntdll -&amp;gt; CLR -&amp;gt; Console.ReadLine&lt;/code&gt; ，很显然 ntdll.dll 是操作系统层级的一个核心文件，这就从用户态切入到了内核态，如果不是很明白，我画一张简图吧。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200511073108013-1346185352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-无catch处理&quot;&gt;&amp;lt;2&amp;gt;. 无catch处理&lt;/h4&gt;
&lt;p&gt;大家肯定很好奇，如果无catch会是怎么样，大家也可以用windbg去挖一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            var num = int.Parse(&quot;xxx&quot;);
        }


0:000&amp;gt; !dumpstack
OS Thread Id: 0xd68 (0)
Current frame: ntdll!NtTerminateProcess+0x14
Caller, Callee
mscoreei!RuntimeDesc::ShutdownAllActiveRuntimes+0x285, calling KERNEL32!ExitProcessImplementation
mscoreei!CLRRuntimeHostInternalImpl::ShutdownAllRuntimesThenExit+0x14, calling mscoreei!RuntimeDesc::ShutdownAllActiveRuntimes
clr!EEPolicy::ExitProcessViaShim+0x9c
clr!SafeExitProcess+0x9d, calling clr!EEPolicy::ExitProcessViaShim
ntdll!KiUserExceptionDispatch+0x53, calling ntdll!NtRaiseException
clr!RaiseTheExceptionInternalOnly+0x188426, calling clr!EEPolicy::HandleFatalError
clr!IL_Throw+0x45, calling clr!LazyMachStateCaptureState
(MethodDesc 00007fffde4f95c0 System.Number.StringToNumber(System.String, System.Globalization.NumberStyles, NumberBuffer ByRef, System.Globalization.NumberFormatInfo, Boolean)), calling mscorlib_ni+0x53976a
(MethodDesc 00007fffde3b5330 +0xae System.Number.ParseInt32(System.String, System.Globalization.NumberStyles, System.Globalization.NumberFormatInfo)), calling (MethodDesc 00007fffde4f95c0 +0 System.Number.StringToNumber(System.String, System.Globalization.NumberStyles, NumberBuffer ByRef, System.Globalization.NumberFormatInfo, Boolean))
(MethodDesc 00007fffde1ebfa8 +0x2eb System.Globalization.NumberFormatInfo..ctor(System.Globalization.CultureData)), calling (MethodDesc 00007fffde1eba68 +0 System.Globalization.CultureData.GetNFIValues(System.Globalization.NumberFormatInfo))
(MethodDesc 00007fff810e59f8 +0x37 ConsoleApp4.Program.Main(System.String[])), calling (MethodDesc 00007fffde3b1708 +0 System.Int32.Parse(System.String))

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到进程的退出逻辑给了托管程序入口 &lt;code&gt;mscoreei.dll&lt;/code&gt; 而再也没有进入Main函数了， 为此我也补一张图给大家看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200511073118686-1526295638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-抓取线程调用栈&quot;&gt;2. 抓取线程调用栈&lt;/h3&gt;
&lt;p&gt;当大家慌慌张张的看到异常的时候，第一眼会去看异常信息是什么？ 第二眼会去看异常出在了哪一行代码，这就是线程的调用栈，这个信息非常重要，可以快捷的帮助我们找到问题解决问题，放在Exception的StackTrace中，先上一段代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    public static void Main(string[] args)
        {
            Run();
            Console.ReadLine();
        }

        public static void Run()
        {
            var ex = new FormatException(&quot;你的格式错误啦！！！&quot;);
            throw ex;
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1-stacktrace何时塞入的&quot;&gt;&amp;lt;1&amp;gt; StackTrace何时塞入的&lt;/h4&gt;
&lt;p&gt;到目前为止还没看到哪本书说到StackTrace是何时被塞入的？ 由于水平有限，我也试着探测一下下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200511073132968-1363946746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从代码中可以看到不是在new的时候塞入的，那会是哪里呢？&lt;/p&gt;
&lt;h4 id=&quot;2-从clr中寻找答案&quot;&gt;&amp;lt;2&amp;gt; 从CLR中寻找答案&lt;/h4&gt;
&lt;p&gt;既然不在用户代码，那就到CLR中去看看，在windbg中用 &lt;code&gt;dumpstack&lt;/code&gt; 去查看非托管堆栈。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !dumpstack
OS Thread Id: 0x4090 (0)
Current frame: ntdll!NtTerminateProcess+0x14
Caller, Callee
clr!EETypeHashTable::FindItem+0x532, calling clr!NgenHashTable&amp;lt;EEClassHashTable,EEClassHashEntry,4&amp;gt;::PersistedBucketList::GetBucket
clr!JIT_StrCns+0xd0, calling clr!HelperMethodFrameRestoreState
(MethodDesc 00007fff810f5a08 +0x70 ConsoleApp4.Program.Run()), calling clr!IL_Throw
clr!IL_Throw+0x45, calling clr!LazyMachStateCaptureState
(MethodDesc 00007fff810f5a08 +0x70 ConsoleApp4.Program.Run()), calling clr!IL_Throw
(MethodDesc 00007fff810f59f8 +0x28 ConsoleApp4.Program.Main(System.String[])), calling 00007fff81200488 (stub for ConsoleApp4.Program.Run())

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从简化后的流程看，怀疑是由 &lt;code&gt;clr!HelperMethodFrameRestoreState&lt;/code&gt; 处理的，为什么这么说呢？ 因为我们定义的 &lt;code&gt;FormatException ex&lt;/code&gt; 会传给CLR的，不信可以用 &lt;code&gt;kb&lt;/code&gt; 看一看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; kb
 # RetAddr           : Args to Child                                                           : Call Site
00 00007fff`e07a3181 : 00000000`e0434352 0000006d`4a7fe938 0000017b`30ad2d48 0000017b`2f081690 : KERNELBASE!RaiseException+0x68
01 00007fff`e07a45f4 : ffffffff`fffffffe 0000017b`2ef02542 00000000`0000000a 0000017b`2f040910 : clr!RaiseTheExceptionInternalOnly+0x31f
02 00007fff`811d0950 : 00000000`70000001 00007fff`810c4140 0000006d`4a7fedb8 0000006d`4a7fec78 : clr!IL_Throw+0x114
03 00007fff`811d08b8 : 0000017b`30ad2d30 00007fff`810c4140 00000000`00000000 00007fff`00000000 : 0x00007fff`811d0950
04 00007fff`e0736c93 : 0000017b`30ad2d30 00007fff`810c4140 00000000`00000000 00007fff`00000000 : 0x00007fff`811d08b8
05 00007fff`e0736b79 : 00000000`00000000 00007fff`e0737aae 0000006d`4a7fefb8 00000000`00000000 : clr!CallDescrWorkerInternal+0x83
06 00007fff`e0737410 : 0000006d`4a7fefb8 0000006d`4a7ff048 0000006d`4a7feeb8 00000000`00000001 : clr!CallDescrWorkerWithHandler+0x4e
07 00007fff`e08dcaf2 : 0000006d`4a7fee00 00000000`00000001 00000000`00000001 0000017b`2efcecf0 : clr!MethodDescCallSite::CallTargetWorker+0x102
08 00007fff`e08dd4b3 : 00000000`00000001 00000000`00000000 0000017b`30ad2d30 0000017b`30ad2d30 : clr!RunMain+0x25f
09 00007fff`e08dd367 : 0000017b`2f040910 0000006d`4a7ff420 0000017b`2f040910 0000017b`2f082770 : clr!Assembly::ExecuteMainMethod+0xb7
0a 00007fff`e08dccb3 : 00000000`00000000 0000017b`2ef00000 00000000`00000000 00000000`00000000 : clr!SystemDomain::ExecuteMainMethod+0x643
0b 00007fff`e08dcc31 : 0000017b`2ef00000 00007fff`e08de090 00000000`00000000 00000000`00000000 : clr!ExecuteEXE+0x3f
0c 00007fff`e08de0a4 : ffffffff`ffffffff 00007fff`e08de090 00000000`00000000 00000000`00000000 : clr!_CorExeMainInternal+0xb2
0d 00007fff`e1208a61 : 00000000`00000000 00007fff`00000091 00000000`00000000 0000006d`4a7ff9f8 : clr!CorExeMain+0x14
0e 00007fff`e133a4cc : 00000000`00000000 00007fff`e08de090 00000000`00000000 00000000`00000000 : mscoreei!CorExeMain+0x112
0f 00007fff`f5cc4034 : 00007fff`e1200000 00000000`00000000 00000000`00000000 00000000`00000000 : MSCOREE!CorExeMain_Exported+0x6c
10 00007fff`f8033691 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : KERNEL32!BaseThreadInitThunk+0x14
11 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ntdll!RtlUserThreadStart+0x21


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第一行的 &lt;code&gt;00 00007fff&lt;/code&gt;e07a3181 : 00000000&lt;code&gt;e0434352 0000006d&lt;/code&gt;4a7fe938 0000017b&lt;code&gt;30ad2d48 0000017b&lt;/code&gt;2f081690 : KERNELBASE!RaiseException+0x68&lt;code&gt;中的第三个参数地址&lt;/code&gt; 0000017b30ad2d48` 就是我们的异常类，打印出来看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !do 0000017b30ad2d48
Name:        System.FormatException
MethodTable: 00007fffde285c38
EEClass:     00007fffde3930e0
Size:        160(0xa0) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007fffde2059c0  40002a2        8        System.String  0 instance 0000017b30ad4c80 _className
00007fffde282a50  40002a3       10 ...ection.MethodBase  0 instance 0000000000000000 _exceptionMethod
00007fffde2059c0  40002a4       18        System.String  0 instance 0000000000000000 _exceptionMethodString
00007fffde2059c0  40002a5       20        System.String  0 instance 0000017b30ad2de8 _message
00007fffde2883d8  40002a6       28 ...tions.IDictionary  0 instance 0000000000000000 _data
00007fffde205b70  40002a7       30     System.Exception  0 instance 0000000000000000 _innerException
00007fffde2059c0  40002a8       38        System.String  0 instance 0000000000000000 _helpURL
00007fffde205dd8  40002a9       40        System.Object  0 instance 0000017b30ad2e98 _stackTrace
00007fffde205dd8  40002aa       48        System.Object  0 instance 0000017b30ad2f28 _watsonBuckets
00007fffde2059c0  40002ab       50        System.String  0 instance 0000000000000000 _stackTraceString
00007fffde2059c0  40002ac       58        System.String  0 instance 0000000000000000 _remoteStackTraceString
00007fffde2085a0  40002ad       88         System.Int32  1 instance                0 _remoteStackIndex
00007fffde205dd8  40002ae       60        System.Object  0 instance 0000000000000000 _dynamicMethods
00007fffde2085a0  40002af       8c         System.Int32  1 instance      -2146233033 _HResult
00007fffde2059c0  40002b0       68        System.String  0 instance 0000000000000000 _source
00007fffde2831f8  40002b1       78        System.IntPtr  1 instance                0 _xptrs
00007fffde2085a0  40002b2       90         System.Int32  1 instance       -532462766 _xcode
00007fffde21e720  40002b3       80       System.UIntPtr  1 instance                0 _ipForWatsonBuckets
00007fffde1f5080  40002b4       70 ...ializationManager  0 instance 0000017b30ad2e18 _safeSerializationManager
00007fffde205dd8  40002a1      100        System.Object  0   shared           static s_EDILock
                                 &amp;gt;&amp;gt; Domain:Value  0000017b2efe0af0:NotInit  &amp;lt;&amp;lt;

0:000&amp;gt; !do 0000017b30ad2e98
Name:        System.SByte[]
MethodTable: 00007fffde20dde8
EEClass:     00007fffde390920
Size:        120(0x78) bytes
Array:       Rank 1, Number of elements 96, Type SByte (Print Array)
Content:     .........../{...P.......@..Jm....Z.........................Jm....Y..............................
Fields:
None


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时 &lt;code&gt;_stackTrace&lt;/code&gt; 已经有值了，毕竟Console上已经打印出来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200511073149165-7171626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后补充一下大家也可以通过 &lt;code&gt;!threads&lt;/code&gt; 去找异常的线程，如下图的中 &lt;code&gt;System.FormatException 0000017b30ad2d48&lt;/code&gt;，然后通过 &lt;code&gt;!printexception&lt;/code&gt; 去打印这个地址 &lt;code&gt;0000017b30ad2d48&lt;/code&gt; 上异常对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !threads
ThreadCount:      2
UnstartedThread:  0
BackgroundThread: 1
PendingThread:    0
DeadThread:       0
Hosted Runtime:   no
                                                                                                        Lock  
       ID OSID ThreadOBJ           State GC Mode     GC Alloc Context                  Domain           Count Apt Exception
   0    1  80c 0000016816f508f0    2a020 Preemptive  0000016818CCE3B8:0000016818CCFFD0 0000016816ef0b10 0     MTA System.FormatException 0000017b30ad2d48
   6    2 12d8 0000016816f7b0e0    2b220 Preemptive  0000000000000000:0000000000000000 0000016816ef0b10 0     MTA (Finalizer) 


0:000&amp;gt; !printexception 0000017b30ad2d48
Exception object: 0000017b30ad2d48
Exception type:   System.FormatException
Message:          你的格式错误啦！！！
InnerException:   &amp;lt;none&amp;gt;
StackTrace (generated):
    SP               IP               Function
    0000001F8F7FEE90 00007FFF811E0951 ConsoleApp4!ConsoleApp4.Program.Run()+0x71
    0000001F8F7FEEE0 00007FFF811E08B9 ConsoleApp4!ConsoleApp4.Program.Main(System.String[])+0x29

StackTraceString: &amp;lt;none&amp;gt;
HResult: 80131537

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三：总结&quot;&gt;三：总结&lt;/h2&gt;
&lt;p&gt;不要把异常当做业务逻辑处理，这开销有可能你承受不起，把那些真正不可期的情况留给异常吧，如: TimeoutException。。。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_200414062434170x170.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_200414065053baijiahao.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 May 2020 23:30:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 在项目中摸爬滚打几年，应该或多或少的见过有人把异常当做业务逻辑处理的情况(┬＿┬)，比如说判断一个数字是否为整数,就想当然的用 包起来，再进行 ，如果抛异常就说明不是整数，简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/12866824.html</dc:identifier>
</item>
<item>
<title>优秀的程序员真的不写注释吗？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12866817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12866817.html</guid>
<description>&lt;p&gt;我在很多地方看到这样一个观点，“请停止写注释，因为只有烂的代码才需要注释。”这个观点非常巧妙，它让我想起了孟子的一句话，“杨氏为我，是无君也；墨氏兼爱，是无父也。无父无君，是禽兽也。”&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/zhushi-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;动不动就骂别人是“禽兽”，我总觉得有点不妥，这很不符合孟子的浩然之气啊。有些大牛也有孟子这样的觉悟，如果有人要他给自己的代码加上注释，就好像是对他的一种侮辱：“我的代码写得这么优雅，你难道看不懂吗？注释是多余的！”&lt;/p&gt;
&lt;p&gt;我必须得承认，每个程序员都应该有一颗追求“优雅”的心，力争自己的代码更易阅读和理解——不只是针对机器，还有我们程序员同行。但不是每个程序员在一开始都能写出“高标准”的代码的，就好像不是所有君王和百姓都能搞清楚孟子的治国齐家理念的。&lt;/p&gt;
&lt;p&gt;在我刚回洛阳的那段时间，过得非常痛苦。因为我刚接手了别人留下的一个项目，关于大宗期货交易的。后端代码是用 Java 写的，但有很多 bug 在里面，动不动就资金结算失败，甚至内存溢出，要解决这些问题，只有一个办法，就是彻底搞懂这些代码。&lt;/p&gt;
&lt;p&gt;否则，根本无从下手。这就好像，你和朋友开车出去自驾游，去很远很远的地方，朋友开累了，需要休息，这时候，如果你没考过驾照，那就抓瞎了，只能把车停路边，等朋友的疲劳消退了，才能继续上路。&lt;/p&gt;
&lt;p&gt;我就抓瞎了。凭良心说，前同事留下的代码是精彩绝伦的，如果换做是我来写，真不一定能写得出来。毕竟大宗期货交易本身还是有点难度的，需要竞价撮合，这个业务理解起来比股票还要复杂些。&lt;/p&gt;
&lt;p&gt;股票涨了就赚，跌了就亏。期货不同的，买涨能赚，买跌也能赚。不过业务上的复杂还是次要的，重要的是代码里的注释非常稀有，就好像詹姆斯高斯林头上的发丝一样稀有。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/zhushi-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;况且，国内程序员的英语功底你懂的，变量、方法、类、接口、枚举的命名无法做到真正意义上的名如其意。再加上，有些方法的行数多达三四百行，从头看到尾，看得只想捶自己。&lt;/p&gt;
&lt;p&gt;没办法，我的解决办法就是，看懂一行就加一行注释，毕竟注释总比代码要容易理解啊。就好像，我们在调用一个不熟悉的 API 时，只要代码的文档说清楚它是干嘛的，我们就可以用，就敢用，至于实现的细节，暂时没有理解也没关系。&lt;/p&gt;
&lt;p&gt;差不多花了两个月的时间（非常漫长、非常煎熬）吧，我总算是把项目中核心的代码给研究清楚了。搞清楚之后，那些之前怎么改都改不掉的 bug 也就迎刃而解了。&lt;/p&gt;
&lt;p&gt;这也就是为什么，我倡导大家去读源码的一部分原因了，除了学习，读源码是解决 bug 的杀手锏。要读懂源码，注释是必不可少的。不信，你看看 Java 的源码，每个变量、每个方法、每个类，注释都非常详细，详细到你替源码的作者感到心累。&lt;/p&gt;
&lt;p&gt;在我看来，Java 源码的作者绝对是这个世界上最优秀的程序员，连他们都写注释，那些声称“请停止写注释”的号召者是不是要啪啪啪地打脸，直到打肿为止。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/zhushi-03.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;不要怀疑自己，写注释并不会证明你的代码就是烂代码。我相信，你应该买过电子产品，比如说鼠标、键盘、耳机、手机等等，所有的产品包装里除了产品本身，使用说明书是必不可少的。我就问一句，“手机没有使用说明书，咱这些后浪还能不会用？”&lt;/p&gt;
&lt;p&gt;写注释不是我们的错，软件本来就是复杂的。尤其是我们这些英语不是主力语言的人来说，注释显得尤为重要。我可能属于记忆力不好的那一种，隔个十天半个月，再去回头看那些我自己敲的代码，有时候真有点见着陌生人的感觉：“这代码是我写的吗？怎么有点面生啊？”&lt;/p&gt;
&lt;p&gt;大部分人写的代码都要升级重构，对吧？不论是语言本身版本的升级，还是我们自身能力的成长。假如在升级重构的时候，没有这些注释的帮助，真有点爬泰山的感觉，累啊，亲。&lt;/p&gt;
&lt;p&gt;再者说，大牛也不敢保证自己的代码是没有问题的，对吧？但注释是不会骗人的，它的意义是明确的。你可能会忘记代码是干嘛的，但我敢保证，注释能够唤醒你的记忆。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/zhushi-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;写出好的、有意义的注释其实是有难度的，就像写代码一样&lt;/strong&gt;。在追求卓越的路上，代码和注释其实是相辅相成的。注释会让你的代码更易阅读，代码会让你的注释更富有逻辑。&lt;/p&gt;
&lt;p&gt;即便是你的代码已经优雅到不需要注释，那只是在你的层面上。对于你的同事，你代码后来的负责者，就不一定了。所见略同的英雄并不会很多，你以为很优雅的代码没准在别人眼里就是一坨垃圾，而你的注释很可能会帮助别人“恍然大悟”，明白代码的意义。乖乖地写注释吧，对你对别人都有好处。&lt;/p&gt;
&lt;p&gt;另外，我想说一句，注释就好像是代码的一个蓝图，也或者是对代码的一个总结。在你写代码之前，脑子里肯定要想清楚你要实现什么，怎么实现，把这些作为注释写下来绝对可以帮助你写出更优雅的代码。在代码写完之后，通过注释进行总结，还能对代码进行一些升华，没准还能在总结的过程中想到更好的代码方案。&lt;/p&gt;
&lt;p&gt;我还见到有大牛信誓旦旦地说，写注释就好像是给不会游泳的人扔一个救生圈，他永远也学不会游泳。咋眼一看，这句话说得很有道理，对吧？在大牛们看来，要让一个新人快速成长，最好的办法就是把没有注释的代码扔给他看。&lt;/p&gt;
&lt;p&gt;纯属扯淡，恐怕这个新人没入门就放弃了吧？我已经三十一岁了，不，我已经十八岁了，还不会游泳呢？别听那些大牛们的鬼话，我就不信，他自己没写过注释。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/zhushi-05.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;总之一点，&lt;strong&gt;注释并不会妨碍你写出优雅简洁的代码，它只是程序固有的一部分而已&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读，回复「&lt;strong&gt;简历&lt;/strong&gt;」更有一份 3000+ 人下载过的优质简历模板，从此你的简历再也不会石沉大海了。本文已收录 GitHub，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;&lt;strong&gt;传送门~&lt;/strong&gt;&lt;/a&gt; ，里面更有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，嘻嘻&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 10 May 2020 23:19:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>我在很多地方看到这样一个观点，“请停止写注释，因为只有烂的代码才需要注释。”这个观点非常巧妙，它让我想起了孟子的一句话，“杨氏为我，是无君也；墨氏兼爱，是无父也。无父无君，是禽兽也。” 动不动就骂别人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12866817.html</dc:identifier>
</item>
<item>
<title>如何写好、管好单元测试？基于Roslyn+CI分析单元测试，严控产品提测质量 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/12822936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/12822936.html</guid>
<description>&lt;p&gt;上一篇文章中，我们谈到了通过Roslyn进行代码分析，通过自定义代码扫描规则，将有问题的代码、不符合编码规则的代码扫描出来，禁止签入，提升团队的代码质量。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tianqing/p/12815747.html&quot; target=&quot;_blank&quot;&gt;.NET Core技术研究-通过Roslyn全面提升代码质量&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天我们基于第二篇：基于Roslyn技术，扫描单元测试代码，通过单元测试覆盖率和执行通过率，严控产品提测质量，覆盖率和通过率达不到标准，无法提交测试。&lt;/p&gt;
&lt;p&gt;首先，我们先讨论一下，什么是单元测试，单元测试的覆盖率统计。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、什么是单元测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，C#里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。&lt;/p&gt;
&lt;p&gt;总的来说，单元就是人为规定的最小的被测功能模块。同时，&lt;/p&gt;
&lt;p&gt;   单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。&lt;/p&gt;
&lt;p&gt;   在实际研发中，很多团队浪费大量的时间和精力编写单元测试，那么“好的”单元测试是什么样的呢？   &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;好的单元测试可以覆盖应用程序行为的不同情况和方面&lt;/li&gt;
&lt;li&gt;好的单元测试应该结构良好的代码，包含测试准备、执行、断言、测试清理&lt;/li&gt;
&lt;li&gt;好的单元测试每个都只测试一个最新的功能、代码单元&lt;/li&gt;
&lt;li&gt;好的单元测试是独立和隔离的：什么都不依赖，不访问全局状态，文件系统或数据库。&lt;/li&gt;
&lt;li&gt;好的单元测试是可描述的：见名知意。&lt;/li&gt;
&lt;li&gt;好的单元测试是可重复执行的：无论何时运行，无论在何处运行都通过。&lt;/li&gt;
&lt;li&gt;好的单元测试运行的很快&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、如何管理、评估单元测试的覆盖率和通过率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   业界通常的做法有：   &lt;/p&gt;
&lt;p&gt;1. 代码行数覆盖率&lt;br/&gt;2. 类、方法、条件分支覆盖率&lt;br/&gt;3. 单元测试类型覆盖情况：正常、异常、性能、边界&lt;br/&gt;4. 业务场景覆盖情况&lt;/p&gt;
&lt;p&gt;   但是会产生对单元测试一些误区、错误理解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。（比如上面第一个除零Bug）&lt;/li&gt;
&lt;li&gt;不要过于相信覆盖率数据。&lt;/li&gt;
&lt;li&gt;不要只拿语句覆盖率(行覆盖率)来考核研发交付质量&lt;/li&gt;
&lt;li&gt;路径覆盖率 &amp;gt; 判定覆盖 &amp;gt; 语句覆盖&lt;/li&gt;
&lt;li&gt;开发人员不能盲目追求代码覆盖率，而应该想办法设计更多更好的用例，哪怕多设计出来的用例对覆盖率一点影响也没有&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    经过内部架构师团队的技术交流和讨论，我们达成了以下共识：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; 我们如何写好、用好、管好单元测试？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面：覆盖核心微服务的实现，即：核心重要的微服务必须覆盖单元测试&lt;/li&gt;
&lt;li&gt;点：单元测试场景要尽可能地覆盖&lt;/li&gt;
&lt;li&gt;结构：单元测试要有完备的断言&lt;/li&gt;
&lt;li&gt;类型：单元测试尽可能的覆盖正常、异常、性能、边界&lt;/li&gt;
&lt;li&gt;可设计评估：概要设计时，确定并录入功能的单元测试场景，开发完成提测时保证单元测试覆盖率&lt;/li&gt;
&lt;li&gt;管理：单元测试情况能全面上报管理起来，以进一步控制开发交付的质量&lt;/li&gt;
&lt;li&gt;通过率：100%通过方可发起CI，生成补丁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    在此基础上，我们启动了今年单元测试推动工作，主要的方案是这样的：&lt;/p&gt;
&lt;p&gt;    1. 增加一个单元测试注解，将一些关键的业务属性进行标注、上报，比如：微服务标识、微服务类型、单元测试集、单元测试说明、负责人、单元测试类型（正常、异常、性能、边界等）&lt;/p&gt;
&lt;p&gt;    2. CI持续集成时，必须运行单元测试工程，通过将单元测试执行结果上报到研发效能平台，保障后续补丁提测时控制单元测试通过率，同时单元测试通过率低于95%，无法生成补丁&lt;/p&gt;
&lt;p&gt;    3. 单元测试统一在研发效能平台中管理，即支持单元测试信息上报到管理平台中，方便后续代码提测时进行：核心微服务单元测试覆盖率控制&lt;/p&gt;
&lt;p&gt;    通过以上系统约束+管理规定，实现产品提测质量的控制。如何实现上述三个关键技术点呢？&lt;/p&gt;
&lt;p&gt;    增加单元测试注解、扫描单元测试注解情况、上报单元测试到研发效能平台。&lt;/p&gt;
&lt;p&gt;    接下来，第三部分，我们将引入Roslyn来完成单元测试代码分析&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、增加单元测试注解，让单元测试具备更多有价值的信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    正如上面所讲，我们增加一个了单元测试注解，将一些关键的业务属性进行标注、上报，比如：微服务标识、微服务类型、单元测试集、单元测试说明、负责人、单元测试类型（正常、异常、性能、边界等）。&lt;/p&gt;
&lt;p&gt;    UnitTestAttribute&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202005/23525-20200503185000248-863300500.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       有了自定义单元测试注解后，我们将这个单元测试注解，打到了单元测试方法上：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202005/23525-20200503185340895-1858094115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      单元测试方法有了更多的业务信息之后，我们就可以基于Roslyn实现单元测试代码分析了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、基于Roslyn实现单元测试代码分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      现有的业务代码到底有多少单元测试，是否全部完成了UnitTest单元测试注解改造，这个统计工作很重要。&lt;/p&gt;
&lt;p&gt;      这里就用到了Roslyn代码分析技术，大家可以参考第一篇中对Roslyn的详细介绍：&lt;a href=&quot;https://www.cnblogs.com/tianqing/p/12815747.html&quot; target=&quot;_blank&quot;&gt;.NET Core技术研究-通过Roslyn全面提升代码质量&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      基于Roslyn实现单元测试代码分析，并将分析后的结果上报到研发效能平台，这样就实现了单元测试数据集中管理，方便后续分析和改进。&lt;/p&gt;
&lt;p&gt;      通过Roslyn实现单元测试方法的分析过程主要有：      &lt;/p&gt;
&lt;p&gt;  ① 创建一个编译工作区MSBuildWorkspace.Create()&lt;/p&gt;
&lt;p&gt;  ② 打开解决方案文件OpenSolutionAsync(slnPath);  &lt;/p&gt;
&lt;p&gt;  ③ 遍历Project中的Document&lt;/p&gt;
&lt;p&gt;  ④ 拿到代码语法树、找到所有的方法&lt;/p&gt;
&lt;p&gt;  ⑤ 判断方法是否有UnitTest注解，如果有，将单元测试注解信息统计并上报&lt;/p&gt;
&lt;p&gt;看一下实际的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public async Task&amp;lt;List&amp;lt;CodeCheckResult&amp;gt;&amp;gt; CheckSln(string slnPath)
        {
            var results = new List&amp;lt;CodeCheckResult&amp;gt;();
            try
            {
                var slnFile = new FileInfo(slnPath);
                
                var solution = await MSBuildWorkspace.Create().OpenSolutionAsync(slnPath);

                if (solution.Projects != null &amp;amp;&amp;amp; solution.Projects.Count() &amp;gt; 0)
                {
                    foreach (var project in solution.Projects.ToList())
                    {
                        var documents = project.Documents.Where(x =&amp;gt; x.Name.Contains(&quot;.cs&quot;));

                        foreach (var document in documents)
                        {
                            var tree = await document.GetSyntaxTreeAsync();
                            var root = tree.GetCompilationUnitRoot();
                            if (root.Members == null || root.Members.Count == 0) continue;
                            //member
                            var classDeclartions = root.DescendantNodes().Where(i =&amp;gt; i is ClassDeclarationSyntax);

                            foreach (var classDeclare in classDeclartions)
                            {
                                var programDeclaration = classDeclare as ClassDeclarationSyntax;
                                if (programDeclaration == null) continue;

                                foreach (var method in programDeclaration.Members)
                                {
                                    if (method.GetType() != typeof(MethodDeclarationSyntax)) continue;

                                    //方法 Method                                
                                    var methodDeclaration = (MethodDeclarationSyntax)method;
                                    var testAnnotations = methodDeclaration.AttributeLists.Where(i =&amp;gt; i.Attributes.FirstOrDefault(a =&amp;gt; a.Name.GetText().ToString() == &quot;TestMethod&quot;) != null);
                                    var teldUnitTestAnnotation = methodDeclaration.AttributeLists.FirstOrDefault(i =&amp;gt; i.Attributes.FirstOrDefault(a =&amp;gt; a.Name.GetText().ToString() == &quot;UnitTest&quot;) != null);

                                    if (testAnnotations.Count() &amp;gt; 0)
                                    {
                                        var result = new UnitTestCodeCheckResult()
                                        {
                                            Sln = slnFile.Name,
                                            ProjectName = project.Name,
                                            ClassName = programDeclaration.Identifier.Text,
                                            MethodName = methodDeclaration.Identifier.Text,
                                        };

                                        if (methodDeclaration.Body.GetText().Lines.Count &amp;lt;= 3)
                                        {
                                            result.IsEmptyMethod = true;
                                        }

                                        var methodBody = methodDeclaration.Body.GetText().ToString();
                                        methodBody = methodBody.Replace(&quot;{&quot;, &quot;&quot;);
                                        methodBody = methodBody.Replace(&quot;}&quot;, &quot;&quot;);
                                        methodBody = methodBody.Replace(&quot; &quot;, &quot;&quot;);
                                        methodBody = methodBody.Replace(&quot;\r\n&quot;, &quot;&quot;);
                                        if (methodBody.Length == 0)
                                        {
                                            result.IsEmptyMethod = true;
                                        }

                                        if (teldUnitTestAnnotation != null)
                                        {
                                            result.IsTeldUnitTest = true;
                                            var args = teldUnitTestAnnotation.Attributes.FirstOrDefault().ArgumentList.Arguments;
                                            result.UnitTestCase = args[0].GetText().ToString();
                                            result.SeqNo = args[1].GetText().ToString();
                                            result.UnitTestName = args[2].GetText().ToString();
                                            result.UserName = args[3].GetText().ToString();
                                            result.ServiceType = args[4].GetText().ToString().Replace(&quot; &quot;, &quot;&quot;);

                                            if (args.Count &amp;gt;= 7)
                                            {
                                                result.ServiceID = args[5].GetText().ToString();
                                                result.UnitTestType = args[6].GetText().ToString();
                                            }
                                        }

                                        results.Add(result);
                                    }
                                }
                            }
                        }
                    }
                }

                return results;
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                return results;
            }
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码中，最关键的是以下两句： &lt;/p&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot; readability=&quot;5&quot;&gt;
 var methodDeclaration = (MethodDeclarationSyntax)method;
 var testAnnotations = methodDeclaration.AttributeLists.Where(i =&amp;gt; i.Attributes.FirstOrDefault(a =&amp;gt; a.Name.GetText().ToString() == &quot;&lt;span&gt;&lt;strong&gt;TestMethod&lt;/strong&gt;&lt;/span&gt;&quot;) != null);
 var teldUnitTestAnnotation = methodDeclaration.AttributeLists.FirstOrDefault(i =&amp;gt; i.Attributes.FirstOrDefault(a =&amp;gt; a.Name.GetText().ToString() == &lt;span&gt;&quot;&lt;strong&gt;UnitTest&lt;/strong&gt;&quot;&lt;/span&gt;) != null);&lt;p&gt;&lt;span&gt;快速定位到打了UnitTest注解的单元测试方法，然后将注解的信息扫描上报：&lt;br/&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
if (teldUnitTestAnnotation != null)
{
   result.IsTeldUnitTest = true;
   var args = 
   teldUnitTestAnnotation.Attributes.FirstOrDefault().ArgumentList.Arguments;
   result.UnitTestCase = args[0].GetText().ToString();
   result.SeqNo = args[1].GetText().ToString();
   result.UnitTestName = args[2].GetText().ToString();
   result.UserName = args[3].GetText().ToString();
   result.ServiceType = args[4].GetText().ToString().Replace(&quot; &quot;, &quot;&quot;);

   if (args.Count &amp;gt;= 7)
  {
       result.ServiceID = args[5].GetText().ToString();
       result.UnitTestType = args[6].GetText().ToString();
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体上报的代码在这里不做详细的描述了，大致的思路就是通过HttpClient发送JSON数据到研发效能平台中。&lt;/p&gt;
&lt;p&gt;       完成单元测试上报后，研发效能平台中就有了单元测试的基础信息了，基于这个数据，就可以实现核心微服务单元测试覆盖率统计和控制了。&lt;/p&gt;
&lt;p&gt;       然后，如何统计单元测试的执行通过率呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、统计上报单元测试执行情况，并控制补丁是否满足提测要求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   上一个章节中，我们提到了“代码check in后，开发人员可以通过CI触发持续构建，生成补丁，在这个CI过程中，按照要求必须添加一步单元测试扫描的工作”，同时，CI的过程中必须执行单元测试。如何获取到单元测试的执行结果？&lt;/p&gt;
&lt;p&gt;   这里我们增加了一个单元测试父类：TUnitTest，在父类中实现了单元测试执行结果统计和上报：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 单元测试基类，业务单元测试继承该类
    /// &amp;lt;/summary&amp;gt;
    [TestClass]
    public abstract class TUnitTest
    {
        bool isReportData = true;
        /// &amp;lt;summary&amp;gt;
        /// 构造函数
        /// &amp;lt;/summary&amp;gt;
        public TUnitTest()
        {
            //
            //TODO:  在此处添加构造函数逻辑
            //
        }

        private TestContext testContextInstance;

        public System.Diagnostics.Stopwatch _stopWatch;

        /// &amp;lt;summary&amp;gt;
        ///获取或设置测试上下文，该上下文提供
        ///有关当前测试运行及其功能的信息。
        ///&amp;lt;/summary&amp;gt;
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region 附加测试特性       

        /// &amp;lt;summary&amp;gt;
        ///  在每个测试运行完之后，使用 TestCleanup 来运行代码
        /// &amp;lt;/summary&amp;gt;
        [TestCleanup()]
        public virtual void TestCleanup()
        {
            var recordFilePath = &quot;&quot;;
            if (!isReportData)
            {
                Console.WriteLine(&quot;TESTREPORTIPS：TestCleanup设置为不上报，请检查TestInitialize代码处理&quot;);
                return;
            }
            if (this.TestContext != null)
            {
                try
                {
                    var tt = this.GetType();
                    var testClass = this.TestContext.FullyQualifiedTestClassName;
                    var type = this.GetType();
                                       
                    var tenantID = Convert.ToString(this.TestContext.Properties[&quot;TenantID&quot;]);
                    var batchID = Convert.ToString(this.TestContext.Properties[&quot;BatchID&quot;]);

                    var testMethod = type.GetMethod(this.TestContext.TestName);
                    if (testMethod != null)
                    {
                        var utAttr = testMethod.GetCustomAttributes(false).FirstOrDefault(i =&amp;gt; i.GetType() == typeof(UnitTestAttribute));
                        if (utAttr != null)
                        {
                            var unitTestAttr = utAttr as UnitTestAttribute;
                            var testcase = new UnitTestCase
                            {
                                SequenceNumber = unitTestAttr.SequenceNumber,
                                Description = unitTestAttr.Description,
                                Passed = this.TestContext.CurrentTestOutcome == UnitTestOutcome.Passed,
                                ExecuteTime = Convert.ToDateTime(DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)),
                                HostName = System.Net.Dns.GetHostName(),
                                ServiceID = unitTestAttr.ServiceID,
                                ServiceType = unitTestAttr.ServiceType,
                                Tag = unitTestAttr.Tag,
                                UnitTestName = unitTestAttr.UnitTestName,
                                UserName = unitTestAttr.UserName,
                                TestSuiteCode = unitTestAttr.TestSuiteCode,
                                UnitTestAssembly = tt.Assembly.FullName,
                                UnitTestClass = testClass,
                                UnitTestMethod = testMethod.Name,
                                UnitTestType = unitTestAttr.UnitTestType,
                                TenantID = tenantID,
                                BatchID = batchID,

                            };
                            testcase.TestFile = UnitTestUtil.GetUnitTestFile(tt.Assembly.Location,ref recordFilePath);
                            if (_stopWatch != null)
                                testcase.Duration = Math.Round(_stopWatch.Elapsed.TotalSeconds, 2);
                            UnitTestCaseManager.Report(testcase);
                            Console.WriteLine($&quot;TestCleanup执行{testcase.TestSuiteCode}-{testcase.SequenceNumber}-{testcase.UnitTestName}上报完成&quot;);
                        }
                        else
                        {
                            Console.WriteLine($&quot;TESTREPORTIPS：TestCleanup执行上报时测试方法{testMethod.Name}未配置UnitTestAttribute的注解&quot;);
                        }
                    }
                    else
                    {
                        Console.WriteLine($&quot;TESTREPORTIPS：TestCleanup执行上报时未能通过{this.TestContext.TestName}获取到测试方法&quot;);
                    }
                }
                catch (Exception ex)
                {
                    if (!string.IsNullOrEmpty(recordFilePath) &amp;amp;&amp;amp; File.Exists(recordFilePath))
                    {
                        try
                        {
                            File.Delete(recordFilePath);
                        }
                        catch { }
                    }                    
                    Console.WriteLine(&quot;TestCleanup执行异常: &quot; + ex.ToString());
                }
                finally
                {
                    if (_stopWatch != null)
                        _stopWatch = null;
                }
            }
            else
            {
                Console.WriteLine(&quot;TESTREPORTIPS：TestCleanup执行异常:context为空&quot;);
            }
        } 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　如上代码所述，在每个测试运行完之后，TestCleanup 方法中进行了以下操作：&lt;/p&gt;
&lt;p&gt;   ① 获取当前单元测试方法的自定义UnitTest注解信息&lt;/p&gt;
&lt;p&gt;   ② 获取单元测试执行是否通过&lt;/p&gt;
&lt;p&gt;   ③ 获取单元测试代码内容，这一步可以做一些Assert检查，方法是否为空检查，实现有效的单元测试代码合理性控制&lt;/p&gt;
&lt;p&gt;   ④ 将单元测试执行信息上报到研发效能平台&lt;/p&gt;
&lt;p&gt;   ⑤ 完成输出一些提示信息，方便排查问题&lt;/p&gt;
&lt;p&gt;   有了这个父类后，所有的单元测试类，都继承与TUnitTest，实现单元测试执行情况上报。&lt;/p&gt;
&lt;p&gt;   单元测试执行通过率如果低于某个设置值的话，可以控制在CI的过程中是否生产补丁。&lt;/p&gt;
&lt;p&gt;   同时，研发效能平台中，有了单元测试数据，单元测试注解改造数据，单元测试执行数据，可以实现补丁提测前二次质量控制：即单元测试覆盖率和执行通过率控制，如果达不到要求，补丁无法提测，进而实现产品提测质量的控制。&lt;/p&gt;
&lt;p&gt;   以上是如何写好、用好、管好单元测试，基于Roslyn分析单元测试，严控产品提测质量的一些实践分享。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2020/5/11&lt;/p&gt;
</description>
<pubDate>Sun, 10 May 2020 23:02:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>上一篇文章中，我们谈到了通过Roslyn进行代码分析，通过自定义代码扫描规则，将有问题的代码、不符合编码规则的代码扫描出来，禁止签入，提升团队的代码质量。 .NET Core技术研究-通过Roslyn</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tianqing/p/12822936.html</dc:identifier>
</item>
<item>
<title>CSS躬行记（10）——CSS方法论 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12558686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12558686.html</guid>
<description>&lt;p&gt;　　方法论是一个哲学术语，会对一系列具体的方法进行分析研究、系统总结并最终提出较为一般性的原则。CSS方法论是一种面向CSS、由个人和组织设计、已被诸多项目检验且公认有效的最佳实践。这些方法论都会涉及结构化的命名约定，并且在组织CSS时可提供相应的指南，从而提升代码的性能、可读性以及可维护性。本章会讲解三种CSS方法论：OOCSS、BEM和SMACSS。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;http://oocss.org/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;OOCSS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（Object-Oriented CSS）是指面向对象的CSS，由Nicole Sullivan在2009年提出，借鉴了面向对象编程的抽象思维。其核心概念是采用模块化的实现方式，将CSS分解成可复用和继承的对象，也就是将关注点从页面转移到页面内的组件。OOCSS包含两条核心原则，如下所列，每条原则下都给出了相应的示例。&lt;/p&gt;
&lt;p&gt;　　（1）结构与皮肤分离，即不要将位置、尺寸等结构属性和字体、颜色等皮肤属性写在一个选择器中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .col &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .line &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;line col&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）内容与容器分离，即让对象的行为可预测，避免对位置的依赖，子元素即使离开了容器也应该能正确显示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .line &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .unit &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;line&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;unit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）命名约定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在OOCSS中，类名既要能传递对象的用途，也要有通用性，例如mod、complex、pop等。如果将CSS类命名的太语义化，例如navigation-bar，那么就会将其限制在导航栏，无法应用到网页的其它位置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　OOCSS的缺点也很明显，如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）虽然样式的粒度变小了，但同时会产生许多充满类的HTML元素。&lt;/p&gt;
&lt;p&gt;　　（2）在避免特殊性冲突时，OOCSS选择的方案是放弃层叠，这样就无法最大程度地利用关系选择器的优势。&lt;/p&gt;
&lt;p&gt;　　（3）为了让类能更通用，在命名时就得弱化语义。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;http://getbem.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;BEM&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（Block Element Modifier）是指块级元素修饰符，也是在2009年提出，起源于Yandex（俄语版的Google）。BEM分为三部分：&lt;/p&gt;
&lt;p&gt;　　（1）块（Block）是一个独立实体，最高级抽象，相当于OOCSS中的对象，例如菜单、文本框等。&lt;/p&gt;
&lt;p&gt;　　（2）元素（Element）是块的组成部分，被包含在块中，无法自成一体，例如菜单项、标题等。&lt;/p&gt;
&lt;p&gt;　　（3）修饰符（Modifier）是块或元素的状态，可更改它们的外观或行为，例如高亮、选中等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）命名约定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　BEM中的块、元素和修饰符需要全部小写，名称中的单词用连字符（-）分隔，元素由双下划线（__）分隔，修饰符由双连字符（--）分隔。注意，块和元素都既不能是HTML元素名或ID，也不依赖其它块或元素。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，.form是块，.form__input和.form__submit是其元素，.form--theme-xmas是其修饰符，而.form__submit--disabled是.form__submit的修饰符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .form &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .form--theme-xmas &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .form__input &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .form__submit &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .form__submit--disabled &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form form--theme-xmas&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form__input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form__submit form__submit--disabled&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　BEM的核心思想就是用这种命名约定来清晰的表达出类的含义以及与其它类之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　BEM的缺点如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）BEM与OOCSS一样，也抛弃了层叠，因此也不能完全挖掘出关系选择器的潜力。&lt;/p&gt;
&lt;p&gt;　　（2）CSS类名可能会比较长而且复杂。&lt;/p&gt;
&lt;p&gt;　　（3）需要完善规则说明文档，否则HTML结构将难以阅读。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;http://smacss.com&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;SMACSS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（Scalable and Modular Architecture for CSS）是指可伸缩及模块化的CSS架构，由Jonathan Snook在2011年雅虎工作时提出。他在OOCSS和BEM的基础上添加了五种类别的组件的处理规则，具体如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）基础（Base）是为HTML元素定义默认样式，可以包含属性、伪类等选择器。&lt;/p&gt;
&lt;p&gt;　　（2）布局（Layout）会将页面分为几部分，可作为高级容器包含一个或多个模块，例如左右分栏、栅格系统等。&lt;/p&gt;
&lt;p&gt;　　（3）模块（Module）又名对象或块，是可重用的模块化部分，例如导航栏、产品列表等。&lt;/p&gt;
&lt;p&gt;　　（4）状态（State）描述的是任一模块或布局在特定状态下的外观，例如隐藏、激活等。&lt;/p&gt;
&lt;p&gt;　　（5）主题（Theme）也就是换肤，描述了页面的外观，它可修改前面四个类别的样式，例如链接颜色、布局方式等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）命名约定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　推荐使用前缀来区分布局、模块、状态和主题，如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）“l-”或“layout-”用作布局的前缀，例如.l-inline、.layout-grid等。&lt;/p&gt;
&lt;p&gt;　　（2）“m-”或模块自身的命名用作其前缀，例如.m-profile、.field等。&lt;/p&gt;
&lt;p&gt;　　（3）“is-”用作状态的前缀，例如.is-collapsed、.is-active等。&lt;/p&gt;
&lt;p&gt;　　（4）“theme-”用作主题的前缀，例如.theme-a-background、.theme-l-grid等。&lt;/p&gt;
&lt;p&gt;　　注意，由于基础规则是直接作用于元素的，因此不需要前缀。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）共享&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在实际工作中，不需要局限于某一个CSS方法论，很多时候可以结合使用，共享模块化CSS的规则。例如遵循OOCSS的第一条分离原则，BEM的命名约定，以及SMACSS的分类前缀，具体如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）基础仍旧沿用SMACSS的规则，布局和模块使用SMACSS的前缀。&lt;/p&gt;
&lt;p&gt;　　（2）子元素用双下划线（__）分隔，其状态前缀沿用“is-”。&lt;/p&gt;
&lt;p&gt;　　（3）修饰符也以“is-”为前缀，与模块组合时用双连字符（--）分隔。&lt;/p&gt;
&lt;p&gt;　　（4）适当层叠，最好保持在一层。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，.m-notice__img和.m-notice__content是模块的子元素，.is-important是子元素h6的状态，.m-notice--is-active是模块的修饰符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .l-notice &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .m-notice &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .m-notice--is-active &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .m-notice__img &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .m-notice__content h6 &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;
  .is-important &lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;m-notice l-notice&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;m-notice__img&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;m-notice__content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h6&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;......&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h6&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h6 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;is-important&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;......&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h6&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 10 May 2020 22:51:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>方法论是一个哲学术语，会对一系列具体的方法进行分析研究、系统总结并最终提出较为一般性的原则。CSS方法论是一种面向CSS、由个人和组织设计、已被诸多项目检验且公认有效的最佳实践。这些方法论都会涉及结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12558686.html</dc:identifier>
</item>
<item>
<title>【译】Using .NET for Apache Spark to Analyze Log Data - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/12866355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/12866355.html</guid>
<description>&lt;p&gt;    .NET for Spark可用于处理成批数据、实时流、机器学习和ad-hoc查询。在这篇博客文章中，我们将探讨如何使用.NET for Spark执行一个非常流行的大数据任务，即日志分析。&lt;/p&gt;


&lt;p&gt;    日志分析的目标是从这些日志中获得有关工具或服务的活动和性能的有意义的见解。NET for Spark使我们能够快速高效地分析从兆字节到千兆字节的日志数据！&lt;/p&gt;
&lt;p&gt;    在这篇文章中，我们将分析一组Apache日志条目，这些条目表示用户如何与web服务器上的内容交互。您可以在这里查看Apache日志条目的示例。&lt;/p&gt;


&lt;p&gt;    日志分析是Spark批量处理的一个例子。批处理是静态数据的转换，意味着源数据已经加载到数据存储中。在我们的例子中，输入文本文件已经填充了日志，并且在处理时不会接收新的或更新的日志。&lt;/p&gt;
&lt;p&gt;    在为Spark应用程序创建新的.NET时，我们只需要遵循以下几个步骤，就可以开始从我们的数据中获得这些有趣的见解：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;创建Spark会话&lt;/li&gt;
&lt;li&gt;读取输入数据，通常使用DataFrame&lt;/li&gt;
&lt;li&gt;操作和分析输入数据，通常使用Spark SQL&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4487-1583894180935&quot;&gt;2.1 创建Spark会话&lt;/h2&gt;
&lt;div readability=&quot;22.937276626162&quot;&gt;    在任何Spark应用程序中，我们首先建立一个新的SparkSession，它是使用Spark编程的入口点：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SparkSession spark =&lt;span&gt; SparkSession
    .Builder()
    .AppName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apache User Log Processing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .GetOrCreate();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;1519-1583896679539&quot;&gt;2.2 读取输入数据&lt;/h2&gt;
&lt;p&gt;    我们将输入数据存储在DataFrame中，DataFrame是数据的分布式集合，它把数据组织为命名列的集合：&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
DataFrame generalDf = spark.Read().Text(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;path to input data set&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3 操纵和分析输入的数据&lt;/h2&gt;
&lt;p&gt;    重要的第一步是数据准备。数据准备包括以某种方式清理我们的数据。这可能包括删除不完整的条目以避免以后计算中出现错误，或者删除不相关的输入以提高性能。&lt;/p&gt;
&lt;p&gt;    在我们的示例中，我们应该首先确保所有条目都是完整的日志。我们可以通过将每个日志条目与一个正则表达式进行匹配来实现这一点。&lt;/p&gt;
&lt;div readability=&quot;25.25888108913&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; s_apacheRx = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^(\S+) (\S+) (\S+) [([\w:/]+\s[+-]\d{4})] \&quot;(\S+) (\S+) (\S+)\&quot; (\d{3}) (\d+)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    我们如何对DataFrame的每一行执行计算，比如将每个日志条目与上面的s_apacheRx进行匹配？答案是Spark SQL。&lt;/p&gt;
&lt;h2 id=&quot;6026-1583897944615&quot;&gt;2.4 Spark SQL&lt;/h2&gt;
&lt;p&gt;    Spark SQL为处理DataFrame中存储的结构化数据提供了许多很棒的函数。Spark SQL最流行的特性之一是UDF（用户自定义函数）。我们定义它们接受的输入类型和产生的输出类型，然后定义它们如何执行计算或筛选。&lt;/p&gt;
&lt;div readability=&quot;47.90782525204&quot;&gt;    让我们定义一个新的UDF GeneralReg，将每个日志条目与s_apacheRx 进行匹配。我们的UDF需要一个Apache日志条目，它是一个字符串，并根据日志是否与s_apacheRx匹配返回true或false：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
spark.Udf().Register&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GeneralReg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, log =&amp;gt; Regex.IsMatch(log, s_apacheRx));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    除了UDF之外，Spark SQL还提供了编写SQL调用来分析我们的数据的能力，通常编写一个SQL调用来将UDF应用于每一行数据：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
DataFrame generalDf = spark.Sql(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT logs.value, GeneralReg(logs.value) FROM Logs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    这个SQL调用测试generalDf的每一行，以确定它是否是一个有效且完整的日志。&lt;/p&gt;
&lt;p&gt;    我们可以使用.Filter（）只在数据中保留完整的日志条目，然后使用.Show（）显示新筛选的DataFrame：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
generalDf = generalDf.Filter(generalDf[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GeneralReg(value)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
generalDf.Show();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    现在我们已经完成了一些初始数据准备，我们可以继续过滤和分析我们的数据。让我们从以10开头的IP地址中查找与垃圾邮件相关的日志条目：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Choose valid log entries that start with 10&lt;/span&gt;
spark.Udf().Register&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IPReg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    log &lt;/span&gt;=&amp;gt; Regex.IsMatch(log, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^(?=10)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

generalDf.CreateOrReplaceTempView(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IPLogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Apply UDF to get valid log entries starting with 10&lt;/span&gt;
DataFrame ipDf =&lt;span&gt; spark.Sql(
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT iplogs.value FROM IPLogs WHERE IPReg(iplogs.value)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
ipDf.Show();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Choose valid log entries that start with 10 and deal with spam&lt;/span&gt;
spark.Udf().Register&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SpamRegEx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    log &lt;/span&gt;=&amp;gt; Regex.IsMatch(log, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\b(?=spam)\\b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

ipDf.CreateOrReplaceTempView(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SpamLogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Apply UDF to get valid, start with 10, spam entries&lt;/span&gt;
DataFrame spamDF =&lt;span&gt; spark.Sql(
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT spamlogs.value FROM SpamLogs WHERE SpamRegEx(spamlogs.value)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    最后，让我们计算最后清理的数据集中GET请求的数量。.NET for Spark的神奇之处在于，我们可以将其与其他流行的.NET功能结合起来编写我们的应用程序。我们将使用LINQ分析Spark应用程序中的数据：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; numGetRequests =&lt;span&gt; spamDF 
    .Collect() 
    .Where(r &lt;/span&gt;=&amp;gt; ContainsGet(r.GetAs&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))) 
    .Count();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在上面的代码中，ContainsGet（）使用regex匹配检查GET请求：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use regex matching to group data 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Each group matches a column in our log schema 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; i.e. first group = first column = IP&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ContainsGet(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; logLine) 
{ 
    Match match &lt;/span&gt;=&lt;span&gt; Regex.Match(logLine, s_apacheRx);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine if valid log entry is a GET request&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (match.Success)
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Full log entry: '{0}'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, match.Groups[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Value);
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5th column/group in schema is &quot;method&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (match.Groups[&lt;span&gt;5&lt;/span&gt;].Value == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    作为最后一步，我们调用Spark.Stop（）关闭底层的Spark会话和Spark上下文。&lt;/p&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;    需要使用spark-submit命令，该命令将提交您的应用程序以便在Apache Spark上运行。&lt;/p&gt;
&lt;p&gt;    spark-submit命令包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;–class,用于调用DotnetRunner&lt;/li&gt;
&lt;li&gt;–master, 用于定义是本地还是云端的Spark提交&lt;/li&gt;
&lt;li&gt;Path，Microsoft.Spark jar的路径&lt;/li&gt;
&lt;li&gt;应用程序的其他参数或依赖项，例如输入文件或包含UDF定义的dll的路径。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    运行应用程序的Windows命令示例如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.8460710441335&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
spark-submit --&lt;span&gt;class&lt;/span&gt; org.apache.spark.deploy.dotnet.DotnetRunner --master local /path/to/microsoft-spark-&amp;lt;version&amp;gt;.jar dotnet /path/to/netcoreapp&amp;lt;version&amp;gt;/LoggingApp.dll
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;8.5699588477366&quot;&gt;
&lt;p&gt;    这里只是一个简单的介绍，.NET for Apache Spark是一个免费、开源、跨平台的大数据分析框架，更多的功能需要读者进一步深入学习。&lt;/p&gt;
&lt;div readability=&quot;8.7032667876588&quot;&gt;

&lt;h2 id=&quot;2485-1583893577428&quot;&gt;Ad-hoc Query&lt;/h2&gt;
&lt;p&gt;    Ad-hoc Query是一种“on-the-fly”的特殊查询。也就是说，在每一个查询操作被执行之前，查询的目标对象是不明确的。&lt;/p&gt;
&lt;p&gt;    比如下面这样一条语句：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; mySqlQuery = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT * FROM table WHERE id = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + std_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    每次执行这一条查询的时候返回的结果都可能会不一样，这取决于std_name的值。&lt;/p&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;





</description>
<pubDate>Sun, 10 May 2020 18:12:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>.NET for Spark可用于处理成批数据、实时流、机器学习和ad-hoc查询。在这篇博客文章中，我们将探讨如何使用.NET for Spark执行一个非常流行的大数据任务，即日志分析。 1 什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/12866355.html</dc:identifier>
</item>
</channel>
</rss>