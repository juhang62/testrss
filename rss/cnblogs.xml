<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>auto类型推导 - 倔强的铃铛</title>
<link>http://www.cnblogs.com/0xfffffff0/p/10285472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0xfffffff0/p/10285472.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;auto : 类型推导.&lt;/strong&gt; 在使用c++的时候会经常使用, 就像在考虑STL时迭代器类型, 写模板的时候使用auto能少写代码, 也能帮助我们避免一些隐患的细节.&lt;/p&gt;
&lt;h3 id=&quot;auto初始化&quot;&gt;auto初始化&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;auto&lt;/code&gt;型别推导要求&lt;strong&gt;必须在定义时初始化&lt;/strong&gt;, 毕竟需要根据对象的类型推导左值对象的型别.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto j;     // error. 必须初始化
auto i = 0; // i 推导型别为 int
vector&amp;lt;int&amp;gt; v; 
auto vv = v.cbegin();   // vv  推导型别为 const int*&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;但是&lt;code&gt;auto&lt;/code&gt;型别推导会&lt;strong&gt;忽略引用和顶层const&lt;/strong&gt;, 所以要对对象加上想要的修饰.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int ci = 0;
auto i = ci;    // i 推导型别为 int, 忽略了顶层const
int &amp;amp;ri = i;
auto ii = ri;   //ii 推导型别为 int, 忽略了引用&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;C11之前只能通过&lt;code&gt;()&lt;/code&gt;和&lt;code&gt;=&lt;/code&gt;对变量初始化, C++11增加了对定义的对象初始化的方法，可以使用&lt;code&gt;{}&lt;/code&gt;对变量初始化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;c11之前的初始化方法&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i(0);   // i 初始化 0
int j = 0;  // j 初始化 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;c11后的初始化方法&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto i(0); auto j = i;  // 支持c11前
auto ii{0}; // 使用 {} 进行初始化, 但是auto推导只能接受一个参数
auto jj = { 0 };    // jj 的推导型别为 initializer_list&amp;lt;int&amp;gt;型别&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面jj的推导居然不是int型别, 而是 &lt;code&gt;initializer_list&amp;lt;int&amp;gt;&lt;/code&gt;, 这不能怪auto推导出问题, 这主要是后者的对象初始化就是使用&lt;code&gt;={}&lt;/code&gt;, 可以说是auto推导的是最精确的型别. 不管新添的初始化方法, 找一个习惯的就行了.&lt;/p&gt;
&lt;h3 id=&quot;auto与for&quot;&gt;auto与for&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;最常见的就是与&lt;code&gt;for&lt;/code&gt;联用, 特别是类型特别复杂的时候. 但是auto又有多种选择, 如 : auto, auto &amp;amp;等, 不同的选择其效率也不一样.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;auto&lt;/code&gt;, 即 for(auto i:range)&lt;/strong&gt; . 这使range中的每一个元素都会产生一个副本, 所以即使修改了 i 也不会实际影响到range.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;const auto&lt;/code&gt;, 及for(const auto i : range)&lt;/strong&gt;. 这也会是range的每一个元素产生一个副本, 但是这个副本竟不能被修改.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;auto &amp;amp;&lt;/code&gt;, 即for(auto &amp;amp;i : range)&lt;/strong&gt;. 引用, 因为i 直接引用range里面的元素, 所以并不会产生一个副本, 但是 i 的修改也会影响range里元素的值. &lt;strong&gt;通常我们需要修改range是会考虑用到.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;const auto&amp;amp;&lt;/code&gt;, 即for(const auto &amp;amp;&amp;amp;i : range)&lt;/strong&gt;. i 直接引用range里面的元素, 所以并不会产生一个副本, 并且i 也不能修改. &lt;strong&gt;一般初始化的是一个左值时而且是读取range里的元素时都是用&lt;code&gt;const auto&amp;amp;&lt;/code&gt;而不用&lt;code&gt;auto&lt;/code&gt;, 因为前者不会产生副本, 效率要高&lt;/strong&gt;. &lt;em&gt;当然一般初始化的是一个左值时效率低, 但是如果是右值还是使用&lt;code&gt;const auto&lt;/code&gt;效率高, 因为&lt;code&gt;const auto &amp;amp;&lt;/code&gt;需要把 i 存储在内存中的一个位置，间接访问会更消耗时间&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;, 即for(auto &amp;amp;&amp;amp;i : range)&lt;/strong&gt;. 如果初始化是左值, 那么 i 就是左值引用, 如果初始化是右值, 那么 i 就是右值引用,&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还有&lt;code&gt;const auto &amp;amp;&lt;/code&gt;, 当然具体的选择还是看具体的情况而定.&lt;/p&gt;
&lt;p&gt;最后, 当用&lt;code&gt;auto&lt;/code&gt;推导多维数组的时, 保证除最内层循环外, 其他的外层循环都应该是引用类型, 否则很容易出错, 即 :&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int a[10][10][10];
for (const auto &amp;amp;i : a)
    for(const auto &amp;amp;j : i)
        for(const auto k : j)
            ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最好使用auto型别推导&quot;&gt;最好使用auto型别推导&lt;/h3&gt;
&lt;h4 id=&quot;初始化&quot;&gt;1. 初始化&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在定义对象的时候可能或多或少会忘记对变量进行初始化, 但当我们使用该变量的时候就会出错, 而且问题也不好找出来, 但是使用&lt;strong&gt;auto定义对象就要求必须初始化&lt;/strong&gt;有时还能减少代码量, 上面我们已经分析过了.&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;auto&lt;/code&gt;初始化在平台上还有一点好处, 比如 :&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;vector&amp;lt;int&amp;gt; v;
unsigned size = v.size();   // size()返回size_t型别
auto sizet = v.size();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 在32的平台&lt;code&gt;unsigned&lt;/code&gt;代表的是32位, &lt;code&gt;size_t&lt;/code&gt;是32位, 在64的平台&lt;code&gt;unsigned&lt;/code&gt;代表的也是23位, 但是&lt;code&gt;size_t&lt;/code&gt;却是64位, 这样平台差异可能就会带来问题, 使用&lt;code&gt;auto&lt;/code&gt;代替就没有这样的问题.&lt;/p&gt;
&lt;p&gt;不过只有这几点可能不会让人心动, 下面我们还有auto的好处.&lt;/p&gt;
&lt;h4 id=&quot;stl使用型别推导&quot;&gt;2. STL使用型别推导&lt;/h4&gt;
&lt;p&gt;还记得在前言中个说过调用STL最好使用&lt;code&gt;auto&lt;/code&gt;推导型别, 如果你还记得&lt;code&gt;map&lt;/code&gt;与&lt;code&gt;pair&lt;/code&gt; 吗? 是这样 &lt;code&gt;map&amp;lt;pair&amp;lt;key, type&amp;gt;&amp;gt;&lt;/code&gt;? 还是&lt;code&gt;map&amp;lt;pair&amp;lt;const key, type&amp;gt;&amp;gt;&lt;/code&gt;? 答案是最后一种, 那么现在我们就来分析的使用&lt;code&gt;auto&lt;/code&gt;推导还是显示型别比较好.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main()
{
    std::map&amp;lt;string, std::function&amp;lt;type(type, type)&amp;gt;&amp;gt;func = {
        { &quot;+&quot;, [](auto i, auto j)-&amp;gt;auto {return i + j; } },
        { &quot;-&quot;, [](auto i, auto j)-&amp;gt;auto {return i - j; } },
        { &quot;*&quot;, [](auto i, auto j)-&amp;gt;auto {return i * j; } },
        { &quot;/&quot;, [](auto i, auto j)-&amp;gt;auto {return i / j; } }
    };

    for (const auto &amp;amp;i : func) ;

    for(const std::pair&amp;lt;string, std::function&amp;lt;type(type, type)&amp;gt;&amp;gt; &amp;amp;pa : func) ;

    system(&quot;pause&quot;);
    exit(EXIT_SUCCESS);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到上面的例子毫无问题, 但是深究起来显示型别还是些不完美. 我们知道map的&lt;code&gt;key&lt;/code&gt;不能被改变, 所以显示型别的&lt;code&gt;string&lt;/code&gt;与map的&lt;code&gt;const string&lt;/code&gt;不是匹配, 编译器就会将map对象都会产生一个临时对象再隐式的转为&lt;code&gt;string&lt;/code&gt;, 等等. 是不是注意到有一点了, 为了型别匹配赋值会产生临时变量, 那岂不是每一循环都会产生一个临时变量, 但是&lt;code&gt;auto&lt;/code&gt;型别推导就是精确匹配的, 不会产生临时变量.&lt;/p&gt;
&lt;p&gt;可能觉得将显示型别的key改为&lt;code&gt;const string&lt;/code&gt;就能解决这个问题了, 确实是这样, 但是如果没有注意到这一点细节, 那就会损失效率了, 使用auto可以完全不想这些问题啊.&lt;/p&gt;
&lt;p&gt;当然使用显示型别还是型推导看实际也看个人, 不是必要.&lt;/p&gt;
&lt;h3 id=&quot;auto与函数返回类型&quot;&gt;auto与函数返回类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;不能被声明为返回值，&lt;code&gt;auto&lt;/code&gt;不能作为形参，&lt;code&gt;auto&lt;/code&gt;不能被修饰为模板参数. 那么这里&lt;code&gt;auto&lt;/code&gt;还能怎么和函数关联起来? 能.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;auto放在函数名前面告诉编译器，真正的返回值在函数声明之后. 简单说auto可以作为返回值占位符来使返回值后置.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就像这样来写.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto Return(std::size_t N) -&amp;gt; std::size_t
{
    return N;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然c++规定可以这样写肯定有其意义. 其实这个写法主要用于&lt;code&gt;template&lt;/code&gt;中, 当返回值的类型是一个模板类型时使用, 而返回值类型通过&lt;code&gt;decltype&lt;/code&gt;来推导.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里就解释一下&lt;code&gt;decltype&lt;/code&gt;的简单运用. , &lt;code&gt;decltype&lt;/code&gt;也是类似与&lt;code&gt;auto&lt;/code&gt;的关键字, 都能够进行参数类型推导, 但是&lt;code&gt;decltype&lt;/code&gt;必须要接受一个参数, 如下:&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i = 1;
decltype(i) j = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;与模板函数连用时用模板参数作为返回值. &lt;span&gt;因为编译器并不能直接推断出返回值为类型参数的实际类型, 所以在STL中采用&lt;code&gt;traits&lt;/code&gt;编程解决这个问题, 这里时另一种实现方法.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先看一个错误的例子:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T1, class T2, class T3&amp;gt;
    T3 fun(T1 t1, T2 t2) {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;T3的类型要在函数返回的时候才能知道, 而&lt;strong&gt;函数这样写就必须要编译期间就要知道返回值类型.&lt;/strong&gt; 所以编译器会报错.&lt;/p&gt;
&lt;p&gt;以下这样写就是正确的, 但是必须保证编译器能推导出类型.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T1, class T2, class T3&amp;gt;
    T1 fun(T1 t1, T3 t3) {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用auto将返回值类型放在最后, 就是告诉编译器&lt;span&gt;真正的返回值在编译后动态获取, 而auto在这里的作用也称为&lt;strong&gt;返回值占位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T1, class T2&amp;gt;
    auto fun(T1 t1, T2, t2) -&amp;gt; decltype(*t1) {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上可以将返回类型放在函数尾做尾置是C11中的要求, 但是C14已经可以将&lt;strong&gt;返回型别放推导&lt;/strong&gt;在函数头. 如 :&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T1&amp;gt;
decltype(auto)fun() {...}   // 这样的写法同上式一样&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然规定能够这样写, 有时为了兼容也还是写成尾置.&lt;/p&gt;
&lt;h3 id=&quot;auto与new运算符&quot;&gt;auto与new运算符&lt;/h3&gt;
&lt;p&gt;我们可以使用&lt;code&gt;auto&lt;/code&gt;来推断出&lt;code&gt;new&lt;/code&gt;对象的类型, 但是局限在于, 必须对&lt;code&gt;new&lt;/code&gt;出来的对象进行单一的初始化.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto i = new int; // 这中写法根本没有用到auto的推导哦, 因为new的类型已经确定了

auto i = new auto(1);       // 这里就是用到了auto推导
auto size = new auto;       // error, 不能推导出size的类型
auto j = new auto(1,2);     // error, 只能接收一个初始化值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;const&lt;/code&gt;中我们分析到顶层&lt;code&gt;const&lt;/code&gt;会被忽略, 所以&lt;code&gt;auto&lt;/code&gt;是无法推断出顶层const, 即 :&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto i = new const auto(1);     // 这里auto并没有推导出顶层const, 所以i的类型实际上是int
const auto j = new const auto(1);   // 只有显示的定义j的类型是const&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想直接推导出顶层const的话, 最好还是&lt;code&gt;decltype&lt;/code&gt;进行推导.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意 : &lt;code&gt;auto&lt;/code&gt;推导只能推导出int, double等, 不能推导出short类型&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本节对C11的auto用法做了一个浅显的分析, 分别对使用&lt;code&gt;auto&lt;/code&gt;的好处, 定义时注意&lt;code&gt;{}&lt;/code&gt;对象也必须初始化, &lt;code&gt;auto&lt;/code&gt;在与for连用的时候要根据实际参数确定选择哪种实现, 这样效率才会达到最大, 当然一般都使用&lt;code&gt;const auto&amp;amp;&lt;/code&gt;和&lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;. 最后还对&lt;code&gt;auto&lt;/code&gt;与函数返回值关联, 可以将返回型别放在函数名尾也可以, 这样的做法一般在模板中将模板参数作为返回值才考虑用, 平时也不必这样定义函数.&lt;/p&gt;
&lt;p&gt;参考 :&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt; Effective Modern C++ &amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25148592&quot;&gt;auto, auto&amp;amp;, const auto&amp;amp;以及其它形式的auto变种在for-range loop的选择&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 15:27:00 +0000</pubDate>
<dc:creator>倔强的铃铛</dc:creator>
<og:description>引言 auto : 类型推导. 在使用c++的时候会经常使用, 就像在考虑STL时迭代器类型, 写模板的时候使用auto能少写代码, 也能帮助我们避免一些隐患的细节. auto初始化 1. 使用 型别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0xfffffff0/p/10285472.html</dc:identifier>
</item>
<item>
<title>AOP 还在配置吗改用打标签模式吧！ - 鱼东东</title>
<link>http://www.cnblogs.com/yudongdong/p/10285392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudongdong/p/10285392.html</guid>
<description>&lt;p&gt;&lt;span&gt;为什么我喜欢打标签来配置AOP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 配置多很混乱，代码里面很难分辨出来哪些是AOP容器(比如属性注入)&lt;/p&gt;
&lt;p&gt;2. 对于代码生成器生成的代码里面还需要手动加到配置里面&lt;/p&gt;
&lt;p&gt;3. 连java spring现在都是清一色的注解来代替xml，这个就是趋势所在&lt;/p&gt;

&lt;p&gt;我基于&lt;span&gt;Autofac开发了一个基于标签来配置AOP的扩展&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;NUGET ：&lt;span&gt;Install-Package Autofac.Annotation&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;开源地址：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;帮忙点个star 谢谢！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;特色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.打个Bean标签就能注入到AOP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.打个Autowired标签自动装配注入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.打个Value标签自动注入配置值(Soure标签配合使用)具体使用方法看下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.支持拦截器&lt;/p&gt;
&lt;p&gt;5.更多等你发现&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如何使用&lt;/span&gt;&lt;/p&gt;

&lt;div id=&quot;3200-1547734396925&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContainerBuilder();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册autofac打标签模式&lt;/span&gt;
builder.RegisterModule(&lt;span&gt;new&lt;/span&gt; AutofacAnnotationModule(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AnotationTest).Assembly));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要开启支持循环注入
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;builder.RegisterModule(new AutofacAnnotationModule(typeof(AnotationTest).Assembly).SetAllowCircularDependencies(true));&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; container =&lt;span&gt; builder.Build();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceB = container.Resolve&amp;lt;B&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;AutofacAnnotationModule有两种构造方法&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;可以传一个Assebly列表 （&lt;/span&gt;&lt;span&gt;这种方式会注册传入的Assebly里面打了标签的类&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以传一个AsseblyName列表 (&lt;/span&gt;&lt;span&gt;这种方式是先会根据AsseblyName查找Assebly 然后在注册&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;支持的标签说明&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Bean标签&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：只能打在class上面 把某个类注册到autofac容器 例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.无构造方法的方式 等同于 builder.RegisterType();&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;4414-1547734869050&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把class A 注册到容器&lt;/span&gt;
&lt;span&gt;[Bean]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;2.&lt;span&gt;指定Scope [需要指定AutofacScope属性 如果不指定为则默认为AutofacScope.InstancePerDependency]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;4620-1547734891937&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 [Bean(AutofacScope =&lt;span&gt; AutofacScope.SingleInstance)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;3.&lt;span&gt;指定类型注册 等同于 builder.RegisterType().As()&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;1886-1547734907404&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; B
    {

    }
    //将class A6以父类B注册到容器
    [Bean(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(B))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A6:B
    {

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;4.&lt;span&gt;指定名字注册 等同于 builder.RegisterType().Keyed(&quot;a4&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;3843-1547734918304&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [Bean(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]//注册A4到容器 并给他起了一个名字叫a4 假设容器有多个A4被注册就可以用这个名字来区别自动装配
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A4
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;


&lt;p&gt;&lt;span&gt;5.其他属性说明&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;InjectProperties 是否默认装配属性 【默认为true】&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;InjectPropertyType 属性自动装配的类型&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Autowired 【默认值】代表打了Autowired标签的才会自动装配&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ALL 代表会装配所有 等同于 builder.RegisterType().PropertiesAutowired()&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;AutoActivate 【默认为false】 如果为true代表autofac build完成后会自动创建 具体请参考 &lt;/span&gt;&lt;a href=&quot;https://autofaccn.readthedocs.io/en/latest/configuration/xml.html&quot;&gt;&lt;span&gt;autofac官方文档&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Ownership 【默认为空】 具体请参考 &lt;/span&gt;&lt;a href=&quot;https://autofaccn.readthedocs.io/en/latest/configuration/xml.html&quot;&gt;&lt;span&gt;autofac官方文档&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Interceptor 【默认为空】指定拦截器的Type&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;InterceptorType 拦截器类型 拦截器必须实现 Castle.DynamicProxy的 IInterceptor 接口， 有以下两种&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Interface 【默认值】代表是接口型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Class 代表是class类型 这种的话是需要将要拦截的方法标virtual&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;InterceptorKey 如果同一个类型的拦截器有多个 可以指定Key&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;InitMethod 当实例被创建后执行的方法名称 类似Spring的init-method 可以是有参数(只能1个参数类型是IComponentContext)和无参数的方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DestroyMetnod 当实例被Release时执行的方法 类似Spring的destroy-method 必须是无参数的方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div id=&quot;7171-1547734956665&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  [Bean(InitMethod = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,DestroyMetnod = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A30
    {
        [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaaaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Test { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; A29 a29;

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; start(IComponentContext context)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Test = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            a29 &lt;/span&gt;= context.Resolve&amp;lt;A29&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Test = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            a29.Test &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;4510-1547734963222&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; B
    {

    }
    
    [Bean(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(B),&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A5:B
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试a5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetSchool()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.School;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Autowired 自动装配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以打在Field Property 构造方法的Parameter上面 其中Field 和 Property 支持在父类&lt;/span&gt;&lt;/p&gt;

&lt;div id=&quot;4172-1547734982524&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [Bean]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A16
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; A16([Autowired]A21 a21)
        {
            Name &lt;/span&gt;=&lt;span&gt; name;
            A21 &lt;/span&gt;=&lt;span&gt; a21;
        }
        
        [Autowired(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; B b1;


        [Autowired]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; B B { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Required默认为true 如果装载错误会抛异常出来。如果指定为false则不抛异常&lt;/span&gt;
    [Autowired(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adadada&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; B b1;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Value 和 PropertySource&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;PropertySource类似Spring里面的PropertySource 可以指定数据源 支持 xml json格式 支持内嵌资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.json格式的文件&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;9940-1547735011133&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;a10&quot;: &quot;aaaaaaaaa1&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;list&quot;: [ 1, 2, 3&lt;span&gt; ],
  &lt;/span&gt;&quot;dic&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;name&quot;: &quot;name1&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;testInitField&quot;: 1&lt;span&gt;,
  &lt;/span&gt;&quot;testInitProperty&quot;: 1&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;3089-1547735017950&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   [Bean]
    [PropertySource(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/file/appsettings1.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A10
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; A10([Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{a10}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;string&lt;/span&gt; school,[Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{list}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list,[Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{dic}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; dic)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.School =&lt;span&gt; school;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dic =&lt;span&gt; dic;

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt; dic { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
        
    [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{testInitField}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; test;
        
    [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{testInitProperty}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; test2 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以直接指定值&lt;/span&gt;
    [Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; test3 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. xml格式的文件&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;9419-1547735044089&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;autofac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a11&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aaaaaaaaa1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a11&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dic &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;name1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dic&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;autofac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div id=&quot;2749-1547735050033&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [Bean]
    [PropertySource(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/file/appsettings1.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A11
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; A11([Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{a11}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;string&lt;/span&gt; school,[Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{list}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list,[Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{dic}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; dic)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.School =&lt;span&gt; school;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dic =&lt;span&gt; dic;

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt; dic { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;不指定PropertySource的话会默认从工程目录的 appsettings.json获取值&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 14:53:00 +0000</pubDate>
<dc:creator>鱼东东</dc:creator>
<og:description>为什么我喜欢打标签来配置AOP 1. 配置多很混乱，代码里面很难分辨出来哪些是AOP容器(比如属性注入) 2. 对于代码生成器生成的代码里面还需要手动加到配置里面 3. 连java spring现在都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudongdong/p/10285392.html</dc:identifier>
</item>
<item>
<title>深度解密HTTP通信细节 - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/10285348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/10285348.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href=&quot;https://www.cnblogs.com/qcrao-2018/p/10182185.html&quot;&gt;文章&lt;/a&gt;——《“三次握手，四次挥手”，你真的懂吗》中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的&lt;code&gt;锤子&lt;/code&gt;，拿着&lt;code&gt;锤子&lt;/code&gt;，看什么都像&lt;code&gt;钉子&lt;/code&gt;！在这篇文章中，我们对准了&lt;code&gt;HTTP&lt;/code&gt;这颗钉子砸下去，哈哈。&lt;/p&gt;
&lt;p&gt;为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，支持http方式调用。从客户端（本地）用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节。悲剧是把美好的东西撕碎给人看，而我们是把复杂的东西撕碎了给人看。&lt;/p&gt;
&lt;p&gt;文章稍长，请你看本文时保持耐心。我们先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。保证全篇读完之后，你对HTTP的理解会上升一个台阶！&lt;/p&gt;

&lt;h2 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;我手头现有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是&lt;code&gt;Fence2Area&lt;/code&gt;. 使用方传入一个围栏（点的列表组成，点由&amp;lt;经度，纬度&amp;gt;表示）、点的坐标系类型（谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系），接口输出的则是围栏的面积。&lt;/p&gt;
&lt;p&gt;我们请求服务的“Fence2Area”接口，输入多边形的围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，返回多边形的面积(area)。&lt;/p&gt;
&lt;p&gt;一次正常的请求示例url, 这个大家都不陌生:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;http://docker_ip:7080/data?cmd=Fence2Area&amp;amp;meta={&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;}&amp;amp;request={&quot;fence&quot;:[{&quot;lng&quot;:10.2,&quot;lat&quot;:10.2}, {&quot;lng&quot;:10.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:10.2}],&quot;coordtype&quot;:2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求发出后，服务器进行处理，之后，客户端收到的返回数据如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;data&quot;: {
        &quot;area&quot;: 48764135597.842606
    },
    &quot;errstr&quot;: &quot;&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;area&lt;/code&gt;字段表示面积，而&lt;code&gt;errstr&lt;/code&gt;则是空，即没有出错信息。&lt;/p&gt;
&lt;h2 id=&quot;抓包&quot;&gt;抓包&lt;/h2&gt;
&lt;p&gt;在我们真正发送请求之前，需要进行抓包前的设置。在本地mac，我们用wireshark; 而在远程docker上，我们用tcpdump工具。&lt;/p&gt;
&lt;h3 id=&quot;mac本地&quot;&gt;mac本地&lt;/h3&gt;
&lt;p&gt;设置wireshark包过滤器，监控本地主机和远程docker之间的通信。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ip.addr eq docker_ip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击开始捕获。&lt;/p&gt;
&lt;h3 id=&quot;远程docker&quot;&gt;远程docker&lt;/h3&gt;
&lt;p&gt;该服务通过7080对外提供，使用如下命令捕获网络包：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tcpdump -w /tmp/testHttp.cap port 7080 -s0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;请求-分析&quot;&gt;请求 &amp;amp;&amp;amp; 分析&lt;/h2&gt;
&lt;p&gt;准备工作做完，我挑选了一个神圣的时刻，在本地通过浏览器访问如下url:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;http://docker_ip:7080/data?cmd=Fence2Area&amp;amp;meta={&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;}&amp;amp;request={&quot;fence&quot;:[{&quot;lng&quot;:10.2,&quot;lat&quot;:10.2}, {&quot;lng&quot;:10.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:10.2}],&quot;coordtype&quot;:2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样本地的wireshark和远程的tcpdump都能抓取到HTTP网络数据包。&lt;/p&gt;
&lt;h3 id=&quot;关闭服务进程&quot;&gt;关闭服务进程&lt;/h3&gt;
&lt;p&gt;首先，关闭gcs服务进程，请求直接返回RST报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51288531-97929400-1a37-11e9-8425-c6a2ca6405ad.png&quot; alt=&quot;rst&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，我在请求的时候，改用了另一个接口&lt;code&gt;5010&lt;/code&gt;, 这个接口没有服务监听，和关闭gcs服务进程是同样的效果，可以看到，客户端尝试发送SYN报文，直接被远程docker RST掉了。&lt;/p&gt;
&lt;h3 id=&quot;关闭docker&quot;&gt;关闭docker&lt;/h3&gt;
&lt;p&gt;关闭docker, 由于发送的SYN报文段得不到响应，因此会进行重试，mac下重试的次数为10次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50555866-08823e00-0d0d-11e9-97cd-f1cdcca2f641.png&quot; alt=&quot;mac retry&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先每隔1秒重试了5次，再用“指数退避”的时间间隔重试，2s, 4s, 8s, 16s, 32s. 最后结束。&lt;/p&gt;
&lt;p&gt;重启docker。并再次在本地访问以上url, 浏览器这时还是用的上一次的端口，但是服务端已经没有这个连接的消息了。因此会返回一个RST报文。&lt;/p&gt;
&lt;h3 id=&quot;正常请求&quot;&gt;正常请求&lt;/h3&gt;
&lt;p&gt;服务正常启动，正常发送请求，这次请求成功，那是当然的，嘿嘿！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50638281-2e6f4300-0f98-11e9-8d8b-0f3c0cc7eb85.png&quot; alt=&quot;normal_req_wireshark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是在mac上用wireshark捕获的数据包，共7个包，前三个包为3次握手的包，第四个包为&lt;code&gt;HTTP&lt;/code&gt;层发送的请求数据，第五个包为服务端的TCP 确认报文，第六个包为服务端在&lt;code&gt;HTTP&lt;/code&gt;层发送的响应数据，第七个包为mac对第六个包的确认报文。&lt;/p&gt;
&lt;p&gt;重点来关注第四个包，&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;0x0000:  4500 0295 0000 4000 3606 623b ac17 ccdc
0x0010:  0a60 5cd4 db9b 1ba8 a59a 46ce 6d03 e87d
0x0020:  8018 1015 0ee7 0000 0101 080a 2e4c b2ef
0x0030:  0f20 3acf 4745 5420 2f64 6174 613f 636d
0x0040:  643d 4665 6e63 6532 4172 6561 266d 6574
0x0050:  613d 7b25 3232 6361 6c6c 6572 2532 323a
0x0060:  2532 3274 6573 7425 3232 2c25 3232 5472
0x0070:  6163 6549 6425 3232 3a25 3232 7465 7374
0x0080:  2532 327d 2672 6571 7565 7374 3d7b 2532
0x0090:  3266 656e 6365 2532 323a 5b7b 2532 326c
0x00a0:  6e67 2532 323a 3130 2e32 2c25 3232 6c61
0x00b0:  7425 3232 3a31 302e 327d 2c25 3230 7b25
0x00c0:  3232 6c6e 6725 3232 3a31 302e 322c 2532
0x00d0:  326c 6174 2532 323a 382e 327d 2c25 3230
0x00e0:  7b25 3232 6c6e 6725 3232 3a38 2e32 2c25
0x00f0:  3232 6c61 7425 3232 3a38 2e32 7d2c 2532
0x0100:  307b 2532 326c 6e67 2532 323a 382e 322c
0x0110:  2532 326c 6174 2532 323a 3130 2e32 7d5d
0x0120:  2c25 3232 636f 6f72 6474 7970 6525 3232
0x0130:  3a32 7d20 4854 5450 2f31 2e31 0d0a 486f
0x0140:  7374 3a20 3130 2e39 362e 3932 2e32 3132
0x0150:  3a37 3038 300d 0a55 7067 7261 6465 2d49
0x0160:  6e73 6563 7572 652d 5265 7175 6573 7473
0x0170:  3a20 310d 0a41 6363 6570 743a 2074 6578
0x0180:  742f 6874 6d6c 2c61 7070 6c69 6361 7469
0x0190:  6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 7070
0x01a0:  6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d30
0x01b0:  2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 5573
0x01c0:  6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c
0x01d0:  612f 352e 3020 284d 6163 696e 746f 7368
0x01e0:  3b20 496e 7465 6c20 4d61 6320 4f53 2058
0x01f0:  2031 305f 3133 5f36 2920 4170 706c 6557
0x0200:  6562 4b69 742f 3630 352e 312e 3135 2028
0x0210:  4b48 544d 4c2c 206c 696b 6520 4765 636b
0x0220:  6f29 2056 6572 7369 6f6e 2f31 322e 302e
0x0230:  3220 5361 6661 7269 2f36 3035 2e31 2e31
0x0240:  350d 0a41 6363 6570 742d 4c61 6e67 7561
0x0250:  6765 3a20 7a68 2d63 6e0d 0a41 6363 6570
0x0260:  742d 456e 636f 6469 6e67 3a20 677a 6970
0x0270:  2c20 6465 666c 6174 650d 0a43 6f6e 6e65
0x0280:  6374 696f 6e3a 206b 6565 702d 616c 6976
0x0290:  650d 0a0d 0a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来逐字节分析。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;IP版本为ipv4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;首部长度为5 * 4字节=20B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;服务类型，现在基本都置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0295&lt;/td&gt;
&lt;td&gt;总长度为661字节，即整个包的长度是661字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x4000&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3bit 标志 + 13bit 片偏移&lt;/code&gt;。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x36&lt;/td&gt;
&lt;td&gt;生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x623b&lt;/td&gt;
&lt;td&gt;16bitIP首部校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0xac17 ccdc&lt;/td&gt;
&lt;td&gt;32bit源ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0a60 5cd4&lt;/td&gt;
&lt;td&gt;32bit目的ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xdb9b&lt;/td&gt;
&lt;td&gt;16bit源端口。56219&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x1ba8&lt;/td&gt;
&lt;td&gt;16bit目的端口7080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xa59a 46ce&lt;/td&gt;
&lt;td&gt;32bit序列号。2778351310&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x6d03 e87d&lt;/td&gt;
&lt;td&gt;32bit确认号。1828972669&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0b000000&lt;/td&gt;
&lt;td&gt;6bit保留位。目前置为0.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0b011000&lt;/td&gt;
&lt;td&gt;6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效，同时psh有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x1015&lt;/td&gt;
&lt;td&gt;滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4117&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0ee7&lt;/td&gt;
&lt;td&gt;16bit校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可变长度部分，协议如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0402&lt;/td&gt;
&lt;td&gt;表示支持SACK&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x080a 2e4c b2ef 0f20 3acf&lt;/td&gt;
&lt;td&gt;时间戳。Ts val=0x2e4c b2ef=776778479, ecr=0x0f20 3acf=253770447&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩下来的就是数据部分了。我们一行一行地看。因为http是字符流，所以我们先看一下ascii字符集，执行命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;man ascii&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;00 nul   01 soh   02 stx   03 etx   04 eot   05 enq   06 ack   07 bel
08 bs    09 ht    0a nl    0b vt    0c np    0d cr    0e so    0f si
10 dle   11 dc1   12 dc2   13 dc3   14 dc4   15 nak   16 syn   17 etb
18 can   19 em    1a sub   1b esc   1c fs    1d gs    1e rs    1f us
20 sp    21  !    22  &quot;    23  #    24  $    25  %    26  &amp;amp;    27  '
28  (    29  )    2a  *    2b  +    2c  ,    2d  -    2e  .    2f  /
30  0    31  1    32  2    33  3    34  4    35  5    36  6    37  7
38  8    39  9    3a  :    3b  ;    3c  &amp;lt;    3d  =    3e  &amp;gt;    3f  ?
40  @    41  A    42  B    43  C    44  D    45  E    46  F    47  G
48  H    49  I    4a  J    4b  K    4c  L    4d  M    4e  N    4f  O
50  P    51  Q    52  R    53  S    54  T    55  U    56  V    57  W
58  X    59  Y    5a  Z    5b  [    5c  \    5d  ]    5e  ^    5f  _
60  `    61  a    62  b    63  c    64  d    65  e    66  f    67  g
68  h    69  i    6a  j    6b  k    6c  l    6d  m    6e  n    6f  o
70  p    71  q    72  r    73  s    74  t    75  u    76  v    77  w
78  x    79  y    7a  z    7b  {    7c  |    7d  }    7e  ~    7f del&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;41.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0030&lt;/td&gt;
&lt;td&gt;4745 5420 2f64 6174 613f 636d&lt;/td&gt;
&lt;td&gt;GE T /d at a? cm&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0040&lt;/td&gt;
&lt;td&gt;643d 4665 6e63 6532 4172 6561 266d 6574&lt;/td&gt;
&lt;td&gt;d= Fe nc e2 Ar ea &amp;amp;m et&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0050&lt;/td&gt;
&lt;td&gt;613d 7b25 3232 6361 6c6c 6572 2532 323a&lt;/td&gt;
&lt;td&gt;a= {% 22 ca ll er %2 2:&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0060&lt;/td&gt;
&lt;td&gt;2532 3274 6573 7425 3232 2c25 3232 5472&lt;/td&gt;
&lt;td&gt;%2 2t es t% 22 ,% 22 Tr&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0070&lt;/td&gt;
&lt;td&gt;6163 6549 6425 3232 3a25 3232 7465 7374&lt;/td&gt;
&lt;td&gt;ac eI d% 22 :% 22 te st&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0080&lt;/td&gt;
&lt;td&gt;2532 327d 2672 6571 7565 7374 3d7b 2532&lt;/td&gt;
&lt;td&gt;%2 2} &amp;amp;r eq ue st ={ %2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0090&lt;/td&gt;
&lt;td&gt;3266 656e 6365 2532 323a 5b7b 2532 326c&lt;/td&gt;
&lt;td&gt;2f en ce %2 2: [{ %2 2l&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00a0&lt;/td&gt;
&lt;td&gt;6e67 2532 323a 3130 2e32 2c25 3232 6c61&lt;/td&gt;
&lt;td&gt;ng %2 2: 10 .2 ,% 22 la&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00b0&lt;/td&gt;
&lt;td&gt;7425 3232 3a31 302e 327d 2c25 3230 7b25&lt;/td&gt;
&lt;td&gt;t% 22 :1 0. 2} ,% 20 {%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00c0&lt;/td&gt;
&lt;td&gt;3232 6c6e 6725 3232 3a31 302e 322c 2532&lt;/td&gt;
&lt;td&gt;22 ln g% 22 :1 0. 2, %2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00d0&lt;/td&gt;
&lt;td&gt;326c 6174 2532 323a 382e 327d 2c25 3230&lt;/td&gt;
&lt;td&gt;2l at %2 2: 8. 2} ,% 20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00e0&lt;/td&gt;
&lt;td&gt;7b25 3232 6c6e 6725 3232 3a38 2e32 2c25&lt;/td&gt;
&lt;td&gt;{% 22 ln g% 22 :8 .2 ,%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00f0&lt;/td&gt;
&lt;td&gt;3232 6c61 7425 3232 3a38 2e32 7d2c 2532&lt;/td&gt;
&lt;td&gt;22 la t% 22 :8 .2 }, %2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0100&lt;/td&gt;
&lt;td&gt;307b 2532 326c 6e67 2532 323a 382e 322c&lt;/td&gt;
&lt;td&gt;0{ %2 2l ng %2 2: 8. 2,&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0110&lt;/td&gt;
&lt;td&gt;2532 326c 6174 2532 323a 3130 2e32 7d5d&lt;/td&gt;
&lt;td&gt;%2 2l at %2 2: 10 .2 } ]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0120&lt;/td&gt;
&lt;td&gt;2c25 3232 636f 6f72 6474 7970 6525 3232&lt;/td&gt;
&lt;td&gt;,% 22 co or dt yp e% 22&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0130&lt;/td&gt;
&lt;td&gt;3a32 7d20 4854 5450 2f31 2e31 0d0a 486f&lt;/td&gt;
&lt;td&gt;:2 } HT TP /1 .1 crnl Ho&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0140&lt;/td&gt;
&lt;td&gt;7374 3a20 3130 2e39 362e 3932 2e32 3132&lt;/td&gt;
&lt;td&gt;st : 10 .9 6. 92 .2 12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0150&lt;/td&gt;
&lt;td&gt;3a37 3038 300d 0a55 7067 7261 6465 2d49&lt;/td&gt;
&lt;td&gt;:7 08 0cr nlU pg ra de -I&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0160&lt;/td&gt;
&lt;td&gt;6e73 6563 7572 652d 5265 7175 6573 7473&lt;/td&gt;
&lt;td&gt;ns ec ur e- Re qu es ts&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0170&lt;/td&gt;
&lt;td&gt;3a20 310d 0a41 6363 6570 743a 2074 6578&lt;/td&gt;
&lt;td&gt;: 1cr nlA cc ep t: t ex&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0180&lt;/td&gt;
&lt;td&gt;742f 6874 6d6c 2c61 7070 6c69 6361 7469&lt;/td&gt;
&lt;td&gt;t/ ht ml ,a pp li ca ti&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0190&lt;/td&gt;
&lt;td&gt;6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 7070&lt;/td&gt;
&lt;td&gt;on /x ht ml +x ml ,a pp&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01a0&lt;/td&gt;
&lt;td&gt;6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d30&lt;/td&gt;
&lt;td&gt;li ca ti on /x ml ;q =0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x01b0&lt;/td&gt;
&lt;td&gt;2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 5573&lt;/td&gt;
&lt;td&gt;.9 ,* /* ;q =0 .8 crnl Us&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01c0&lt;/td&gt;
&lt;td&gt;6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c&lt;/td&gt;
&lt;td&gt;er -A ge nt : Mo zi ll&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01d0&lt;/td&gt;
&lt;td&gt;612f 352e 3020 284d 6163 696e 746f 7368&lt;/td&gt;
&lt;td&gt;a/ 5. 0 (M ac in to sh&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01e0&lt;/td&gt;
&lt;td&gt;3b20 496e 7465 6c20 4d61 6320 4f53 2058&lt;/td&gt;
&lt;td&gt;; In te l Ma c OS X&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01f0&lt;/td&gt;
&lt;td&gt;2031 305f 3133 5f36 2920 4170 706c 6557&lt;/td&gt;
&lt;td&gt;1 0_ 13 _6 ) Ap pl eW&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0200&lt;/td&gt;
&lt;td&gt;6562 4b69 742f 3630 352e 312e 3135 2028&lt;/td&gt;
&lt;td&gt;eb Ki t/ 60 5. 1. 15 (&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0210&lt;/td&gt;
&lt;td&gt;4b48 544d 4c2c 206c 696b 6520 4765 636b&lt;/td&gt;
&lt;td&gt;KH TM L, l i k e Ge ck&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0220&lt;/td&gt;
&lt;td&gt;6f29 2056 6572 7369 6f6e 2f31 322e 302e&lt;/td&gt;
&lt;td&gt;o) V er si o n /1 2. 0.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0230&lt;/td&gt;
&lt;td&gt;3220 5361 6661 7269 2f36 3035 2e31 2e31&lt;/td&gt;
&lt;td&gt;2 Sa fa ri /6 05 .1 .1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0240&lt;/td&gt;
&lt;td&gt;350d 0a41 6363 6570 742d 4c61 6e67 7561&lt;/td&gt;
&lt;td&gt;5cr nlA cc ep t- La ng ua&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0250&lt;/td&gt;
&lt;td&gt;6765 3a20 7a68 2d63 6e0d 0a41 6363 6570&lt;/td&gt;
&lt;td&gt;ge : zh -c ncr nlA cc ep&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0260&lt;/td&gt;
&lt;td&gt;742d 456e 636f 6469 6e67 3a20 677a 6970&lt;/td&gt;
&lt;td&gt;t- En co di ng : gz ip&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0270&lt;/td&gt;
&lt;td&gt;2c20 6465 666c 6174 650d 0a43 6f6e 6e65&lt;/td&gt;
&lt;td&gt;, de fl at ecr nlC on ne&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0280&lt;/td&gt;
&lt;td&gt;6374 696f 6e3a 206b 6565 702d 616c 6976&lt;/td&gt;
&lt;td&gt;ct io n: k ee p- al iv&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0290&lt;/td&gt;
&lt;td&gt;650d 0a0d 0a&lt;/td&gt;
&lt;td&gt;ecr nl cr nl&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;把上表的最后一列连起来，就是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;GET /data?cmd=Fence2Area&amp;amp;meta={%22caller%22:%22test%22,%22TraceId%22:%22test%22}&amp;amp;request={%22fence%22:[{%22lng%22:10.2,%22lat%22:10.2},%20{%22lng%22:10.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:10.2}],%22coordtype%22:2} HTTP/1.1 
Host: 10.96.92.212:7080 
Upgrade-Insecure-Requests: 1 
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15 
Accept-Language: zh-cn 
Accept-Encoding: gzip, deflate 
Connection: keep-alive 
 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，cr nl表示回车，换行。&lt;/p&gt;
&lt;p&gt;docker收到数据后，会回复一个ack包。第四个包的总长度为661字节，去掉IP头部20字节，TCP头部固定部分20字节，TCP头部可选长度为12字节，共52字节，因此TCP数据部分总长度为661-52=609字节。&lt;/p&gt;
&lt;p&gt;序列号为2778351310.&lt;/p&gt;
&lt;p&gt;再来看第5个包，字节流如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;        0x0000:  4500 0034 d28b 4000 4006 8810 0a60 5cd4
        0x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f
        0x0020:  8010 00ec e04e 0000 0101 080a 0f20 3af7
        0x0030:  2e4c b2ef&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;IP版本为ipv4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;首部长度为5 * 4字节=20B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;服务类型，现在基本都置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0034&lt;/td&gt;
&lt;td&gt;总长度为52字节，即整个包的长度是52字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0xd28b&lt;/td&gt;
&lt;td&gt;标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x4000&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3bit 标志 + 13bit 片偏移&lt;/code&gt;。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x40&lt;/td&gt;
&lt;td&gt;生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x8810&lt;/td&gt;
&lt;td&gt;16bitIP首部校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x0a60 5cd4&lt;/td&gt;
&lt;td&gt;32bit源ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xac17 ccdc&lt;/td&gt;
&lt;td&gt;32bit目的ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x1ba8&lt;/td&gt;
&lt;td&gt;16bit源端口7080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xdb9b&lt;/td&gt;
&lt;td&gt;16bit目的端口。56219&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x6d03 e87d&lt;/td&gt;
&lt;td&gt;32bit序列号。1828972669&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0xa59a 492f&lt;/td&gt;
&lt;td&gt;32bit确认号。2778351919. 第三个包的序列号为2778351310, 加上数据长度609, 正好相等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0b000000&lt;/td&gt;
&lt;td&gt;6bit保留位。目前置为0.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0b010000&lt;/td&gt;
&lt;td&gt;6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00ec&lt;/td&gt;
&lt;td&gt;滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4117&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xe04e&lt;/td&gt;
&lt;td&gt;16bit校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可变长度部分，协议如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0402&lt;/td&gt;
&lt;td&gt;表示支持SACK&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x080a 2e4c b2ef 0f20 3acf&lt;/td&gt;
&lt;td&gt;时间戳。Ts val=253770487, ecr=776778479&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;数据部分为空，这个包仅为确认包。&lt;/p&gt;
&lt;p&gt;再来看第六个包，字节流如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;0x0000:  4500 00f9 d28c 4000 4006 874a 0a60 5cd4
0x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f
0x0020:  8018 00ec e113 0000 0101 080a 0f20 3af8
0x0030:  2e4c b2ef 4854 5450 2f31 2e31 2032 3030
0x0040:  204f 4b0d 0a41 6363 6573 732d 436f 6e74
0x0050:  726f 6c2d 416c 6c6f 772d 4f72 6967 696e
0x0060:  3a20 2a0d 0a44 6174 653a 2054 6875 2c20
0x0070:  3033 204a 616e 2032 3031 3920 3132 3a32
0x0080:  333a 3437 2047 4d54 0d0a 436f 6e74 656e
0x0090:  742d 4c65 6e67 7468 3a20 3438 0d0a 436f
0x00a0:  6e74 656e 742d 5479 7065 3a20 7465 7874
0x00b0:  2f70 6c61 696e 3b20 6368 6172 7365 743d
0x00c0:  7574 662d 380d 0a0d 0a7b 2264 6174 6122
0x00d0:  3a7b 2261 7265 6122 3a34 3837 3634 3133
0x00e0:  3535 3937 2e38 3432 3630 367d 2c22 6572
0x00f0:  7273 7472 223a 2222 7d&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;IP版本为ipv4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;首部长度为5 * 4字节=20B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;服务类型，现在基本都置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00f9&lt;/td&gt;
&lt;td&gt;总长度为249字节，即整个包的长度是249字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0xd28c&lt;/td&gt;
&lt;td&gt;标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x4000&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3bit 标志 + 13bit 片偏移&lt;/code&gt;。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x40&lt;/td&gt;
&lt;td&gt;生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为64.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x874a&lt;/td&gt;
&lt;td&gt;16bitIP首部校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x0a60 5cd4&lt;/td&gt;
&lt;td&gt;32bit源ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xac17 ccdc&lt;/td&gt;
&lt;td&gt;32bit目的ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x1ba8&lt;/td&gt;
&lt;td&gt;16bit源端口7080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xdb9b&lt;/td&gt;
&lt;td&gt;16bit目的端口。56219&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x6d03 e87d&lt;/td&gt;
&lt;td&gt;32bit序列号。1828972669&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xa59a 492f&lt;/td&gt;
&lt;td&gt;32bit确认号。2778351919&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0b000000&lt;/td&gt;
&lt;td&gt;6bit保留位。目前置为0.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0b011000&lt;/td&gt;
&lt;td&gt;6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效，同时psh有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00ec&lt;/td&gt;
&lt;td&gt;滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。236&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xe113&lt;/td&gt;
&lt;td&gt;16bit校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可变长度部分，协议如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0402&lt;/td&gt;
&lt;td&gt;表示支持SACK&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x080a 0f20 3af8 2e4c b2ef&lt;/td&gt;
&lt;td&gt;时间戳。Ts val=0x2e4c b2ef=253770488, ecr=0x0f20 3acf=776778479&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩下来的就是数据部分了。我们一行一行地看。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0030&lt;/td&gt;
&lt;td&gt;4854 5450 2f31 2e31 2032 3030&lt;/td&gt;
&lt;td&gt;HTTP/1.1 200&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0040&lt;/td&gt;
&lt;td&gt;204f 4b0d 0a41 6363 6573 732d 436f 6e74&lt;/td&gt;
&lt;td&gt;OK \r\n Access-Cont&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0050&lt;/td&gt;
&lt;td&gt;726f 6c2d 416c 6c6f 772d 4f72 6967 696e&lt;/td&gt;
&lt;td&gt;rol-Allow-Origin&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0060&lt;/td&gt;
&lt;td&gt;3a20 2a0d 0a44 6174 653a 2054 6875 2c20&lt;/td&gt;
&lt;td&gt;: * \r\n Date: Thu,&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0070&lt;/td&gt;
&lt;td&gt;3033 204a 616e 2032 3031 3920 3132 3a32&lt;/td&gt;
&lt;td&gt;03 Jan 2019 12:2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0080&lt;/td&gt;
&lt;td&gt;333a 3437 2047 4d54 0d0a 436f 6e74 656e&lt;/td&gt;
&lt;td&gt;3:47 GMT \r\n Conten&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0090&lt;/td&gt;
&lt;td&gt;742d 4c65 6e67 7468 3a20 3438 0d0a 436f&lt;/td&gt;
&lt;td&gt;t-Length: 48\r\n Co&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00a0&lt;/td&gt;
&lt;td&gt;6e74 656e 742d 5479 7065 3a20 7465 7874&lt;/td&gt;
&lt;td&gt;ntent-Type: text&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00b0&lt;/td&gt;
&lt;td&gt;2f70 6c61 696e 3b20 6368 6172 7365 743d&lt;/td&gt;
&lt;td&gt;/plain; charset=&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00c0&lt;/td&gt;
&lt;td&gt;7574 662d 380d 0a0d 0a7b 2264 6174 6122&lt;/td&gt;
&lt;td&gt;utf-8\r\n\r\n{&quot;data&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00d0&lt;/td&gt;
&lt;td&gt;3a7b 2261 7265 6122 3a34 3837 3634 3133&lt;/td&gt;
&lt;td&gt;:{&quot;area&quot;:4876413&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00e0&lt;/td&gt;
&lt;td&gt;3535 3937 2e38 3432 3630 367d 2c22 6572&lt;/td&gt;
&lt;td&gt;5597.842606},&quot;er&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x00f0&lt;/td&gt;
&lt;td&gt;7273 7472 223a 2222 7d&lt;/td&gt;
&lt;td&gt;rstr&quot;:&quot;&quot;}&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;把上表的最后一列连起来，就是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;HTTP/1.1 200 OK 
Access-Control-Allow-Origin: * 
Date: Thu, 03 Jan 2019 12:23:47 GMT 
Content-Length: 48 
Content-Type: text/plain; charset=utf-8 
{&quot;data&quot;:{&quot;area&quot;:48764135597.842606},&quot;errstr&quot;:&quot;&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Content-Length: 48，最后一行的长度即为48个字节。&lt;/p&gt;
&lt;p&gt;最后，第七个包，字节流如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;0x0000:  4500 0034 0000 4000 3606 649c ac17 ccdc
0x0010:  0a60 5cd4 db9b 1ba8 a59a 492f 6d03 e942
0x0020:  8010 100f 1eb9 0000 0101 080a 2e4c b314
0x0030:  0f20 3af8&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;IP版本为ipv4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;首部长度为5 * 4字节=20B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;服务类型，现在基本都置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0034&lt;/td&gt;
&lt;td&gt;总长度为52字节，即整个包的长度是52字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x4000&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3bit 标志 + 13bit 片偏移&lt;/code&gt;。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x36&lt;/td&gt;
&lt;td&gt;生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x649c&lt;/td&gt;
&lt;td&gt;16bitIP首部校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0xac17 ccdc&lt;/td&gt;
&lt;td&gt;32bit源ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0a60 5cd4&lt;/td&gt;
&lt;td&gt;32bit目的ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xdb9b&lt;/td&gt;
&lt;td&gt;16bit源端口。56219&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x1ba8&lt;/td&gt;
&lt;td&gt;16bit目的端口7080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xa59a 492f&lt;/td&gt;
&lt;td&gt;32bit序列号。2778351919&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x6d03 e942&lt;/td&gt;
&lt;td&gt;32bit确认号号。1828972866. 第六个包的序列号为1828972669, 加上数据长度197, 正好相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0b000000&lt;/td&gt;
&lt;td&gt;6bit保留位。目前置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0b010000&lt;/td&gt;
&lt;td&gt;6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x100f&lt;/td&gt;
&lt;td&gt;滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4111&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x1eb9&lt;/td&gt;
&lt;td&gt;16bit校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可变长度部分，协议如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x080a 2e4c b314 0f20 3af8&lt;/td&gt;
&lt;td&gt;时间戳。Ts val=0x2e4c b314=776778516, ecr=0x0f20 3af8=253770488&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;至此，一次完整的http请求的报文就解析完了。你是否觉得也就那样，sso easy？&lt;/p&gt;

&lt;p&gt;上面我们把HTTP协议相关的数据给解构了，下面我将对照上面的数据拆解结果，一步步深入理解HTTP的协议。&lt;/p&gt;
&lt;h2 id=&quot;整体介绍&quot;&gt;整体介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt;(Hypertext Transfer Protocol)超文本传输协议，是在互联网上进行通信时使用的一种协议。更形象一点：&lt;code&gt;HTTP&lt;/code&gt;是现代互联网中使用的公共语言。它最著名的应用是用在浏览器的服务器间的通信。&lt;/p&gt;
&lt;p&gt;HTTP属于应用层协议，底层是靠TCP进行可靠地信息传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51079842-4b2f1780-170a-11e9-9b22-ad68fe4541cc.png&quot; alt=&quot;HTTP层次&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTTP在传输一段报文时，会以&lt;code&gt;流&lt;/code&gt;的形式将报文数据的内容通过&lt;code&gt;一条打开&lt;/code&gt;的TCP连接按序传输。TCP接到上层应用交给它的数据流之后，会按序将数据流打散成一个个的分段。再交到IP层，通过网络进行传输。另一端的接收方则相反，它们将接收到的分段按序组装好，交给上层HTTP协议进行处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50802850-15adb700-1323-11e9-87b8-892139c3104d.png&quot; alt=&quot;tcp http structure&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;编码&quot;&gt;编码&lt;/h2&gt;
&lt;p&gt;我们再来回顾一下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;12&quot;&gt;&lt;td&gt;原始url&lt;/td&gt;
&lt;td&gt;/data?cmd=Fence2Area&amp;amp;meta={&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;}&amp;amp;request={&quot;fence&quot;:[{&quot;lng&quot;:10.2,&quot;lat&quot;:10.2}, {&quot;lng&quot;:10.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:10.2}],&quot;coordtype&quot;:2}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;13&quot;&gt;&lt;td&gt;编码后url&lt;/td&gt;
&lt;td&gt;/data?cmd=Fence2Area&amp;amp;meta={%22caller%22:%22test%22,%22TraceId%22:%22test%22}&amp;amp;request={%22fence%22:[{%22lng%22:10.2,%22lat%22:10.2},%20{%22lng%22:10.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:10.2}],%22coordtype%22:2}&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们看到多了很多&lt;code&gt;%22&lt;/code&gt;，&lt;code&gt;0x22&lt;/code&gt;是&lt;code&gt;&quot;&lt;/code&gt;的ascii值，&lt;/p&gt;
&lt;p&gt;一方面，URL描述的资源为了能通过其他各种协议传送，但是有些协议在传输过程中会剥去一些特定的字符；另一方面，URL还是可读的，所以那些不可打印的字符就不能在URL中使用了，如空格；最后，URL还得是完整的，它需要支持所有语言的字符。&lt;/p&gt;
&lt;p&gt;总之，基于很多原因，URL设计者将US-ASCII码和其转义序列集成到URL中，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符或数据进行编码了。&lt;/p&gt;
&lt;p&gt;转义的方法：百分号(&lt;code&gt;%&lt;/code&gt;)后跟着两个表示ASCII码的十六进制数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51080616-322e6280-171a-11e9-8deb-28ca0a472d51.png&quot; alt=&quot;转义法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以上面在浏览器发送给服务器的URL进行了非“安全字符”编码，也就不奇怪了吧？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51294507-3aeea380-1a4e-11e9-9f52-2fb248a2d5de.png&quot; alt=&quot;url保留及受限的字符&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在URL中，当上面的保留字符用在保留用途之外的场合时，需要对URL进行编码。&lt;/p&gt;
&lt;h2 id=&quot;mime类型&quot;&gt;MIME类型&lt;/h2&gt;
&lt;p&gt;响应数据中，我们注意到有一个首部：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Content-Type: text/plain; charset=utf-8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;互联网上有数千种不同的数据类型，HTTP给每种对象都打上了MIME(Multipurpose Internet Media Extension, 多用途因特网邮件扩展)标签，也就是响应数据中的&lt;code&gt;Content-Type&lt;/code&gt;. MIME本来是用在邮件中的，后来被移植到了HTTP中。浏览器从服务器上取回了一个对象时，会去查看MIME类型，从而得知如何处理这种对象，如展示图片，调用声卡播放声音。MIME通过斜杠来标识对象的主类型和其中的特定的子类型，下表中的实体主体是指body部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51149947-3768ea00-189f-11e9-8fcd-d40f2f2ccf0a.png&quot; alt=&quot;MIME类型&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;uriurlurn&quot;&gt;URI/URL/URN&lt;/h2&gt;
&lt;p&gt;URI(Uniform Resource Identifier, 统一资源标识符)表示服务器资源，URL(Uniform Resource Locator)和URN(Uniform Resource Name, 统一资源名)是URI的具体实现。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL通过位置、URN通过名字来标识资源。&lt;/p&gt;
&lt;p&gt;URL定义了资源的位置，表示资源的实际地址，在使用URL的过程中，如果URL背后的资源发生了位置移动，访问者就找不到它了。这个时候就要用到URN了，它给定资源一个名字，无论它移动到哪里，都可以通过这个名字来访问到它，简直完美！&lt;/p&gt;
&lt;p&gt;URL通常的格式是：协议方案(scheme)(如 &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;ftp&lt;/code&gt;，告知web客户端怎样访问资源)+服务器地址(如 &lt;code&gt;www.oreilly.com&lt;/code&gt;)+具体的资源路径(如 &lt;code&gt;index.html&lt;/code&gt;)。如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51070533-b5e64180-167d-11e9-8dc3-4c54b3cbf1a2.png&quot; alt=&quot;URL举例&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;http方法&quot;&gt;HTTP方法&lt;/h2&gt;
&lt;p&gt;HTTP支持几种不同的请求方法，每种方法对服务器要求的动作不同，如下图是几种常见的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51070644-a0721700-167f-11e9-8579-8702abdb860b.png&quot; alt=&quot;常见的http方法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HEAD方法只获取头部，不获取数据部分。通过头部可以获取比如资源的类型(Content-Type)、资源的长度(Content-Length)这些信息。&lt;/p&gt;
&lt;p&gt;POST用于向服务器发送数据，PUT用于向服务器上的资源存储数据。&lt;/p&gt;
&lt;h2 id=&quot;状态码&quot;&gt;状态码&lt;/h2&gt;
&lt;p&gt;每条HTTP的响应报文都会带上一个三位数字的状态码和一条解释性的“原因短语”，通知客户端本次请求的状态，帮助客户端快速理解事务处理结果，最常见的是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;200 OK 
404 Not Found
500 Internal Server Error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们平时使用浏览器的时候，很多的错误码其实是由浏览器处理的，我们感知不到。但是&lt;code&gt;404 Not Found&lt;/code&gt;会穿透重重迷雾，来到我们面前，那是因为他对我们爱的深沉啊！&lt;/p&gt;
&lt;p&gt;客户端可以据此状态码，决定下一步的行动（如重定向等）。&lt;/p&gt;
&lt;p&gt;三位数字的第一位表示分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51070802-2f802e80-1682-11e9-8a02-f60e2f11c3e6.png&quot; alt=&quot;http状态分类&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;报文格式&quot;&gt;报文格式&lt;/h2&gt;
&lt;p&gt;HTTP报文实际上是由一行行的字符串组成的，每行字符串的mowei用&lt;code&gt;\r\n&lt;/code&gt;分隔，人类可以很方便的阅读。顺便说一句，不是所有的协议都对人类这么友好的，像thrift协议，直接甩一堆字节给你，告诉你说&lt;code&gt;0x0001&lt;/code&gt;表示调用方法，诸如此类的，你只能对着一个十六进制的数据块一个个地去“解码”。&lt;/p&gt;
&lt;p&gt;请求报文和响应报文的格式，还可以结合上面的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51070991-6dcb1d00-1685-11e9-8dae-25b63ad7ad52.png&quot; alt=&quot;请求响应报文示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，请求报文也是可以有body（主体）部分的。请求报文是由&lt;code&gt;请求行（request line）、请求头部（header）、空行和请求数据&lt;/code&gt;四个部分组成。唯一要注意的一点就是，请求报文即使body部分是空的，请求头部后的&lt;code&gt;回车换行&lt;/code&gt;符也是必须要有的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51071026-c4d0f200-1685-11e9-81ca-87c8da1dfc30.png&quot; alt=&quot;请求报文格式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;响应报文的格式和请求报文的格式类似：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51074380-67ef2f00-16b9-11e9-81e7-d5ecaa8d4537.png&quot; alt=&quot;响应报文格式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求报文、响应报文的起始行和响应头部里的字段都是文本化、结构化的。而请求body却可以包含任意二进制数据（如图片、视频、软件等），当然也可以包含文本。&lt;/p&gt;
&lt;p&gt;有些首部是通用的，有些则是请求或者响应报文才会有的。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;通用&lt;/td&gt;
&lt;td&gt;Thu, 03 Jan 2019 12:23:47 GMT&lt;/td&gt;
&lt;td&gt;报文构建的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;请求报文&lt;/td&gt;
&lt;td&gt;text/html,application/xhtml+xml,application/xm&lt;/td&gt;
&lt;td&gt;客户端能接收的数据类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;响应报文&lt;/td&gt;
&lt;td&gt;Content-Type: text/plain; charset=utf-8&lt;/td&gt;
&lt;td&gt;响应报文中的body部分的数据类型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;顺便提一下， 用telnet直连服务器的http端口，telnet命令会建立一条TCP通道，然后我们可以直接发送请求数据，获取响应数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51079989-318fcf00-170e-11e9-9958-daf87d65972b.png&quot; alt=&quot;telnet与http对话&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;代理&quot;&gt;代理&lt;/h2&gt;
&lt;p&gt;HTTP的代理是服务器即是Web服务器，又是Web客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51082793-23ab6f80-1749-11e9-8247-1a3fc5ac4d1d.png&quot; alt=&quot;HTTP代理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性，它可以限制哪些应用层的协议数据可以通过，过滤“病毒”等数据；代理可以存储缓存的文件，直接返回给访问者，无需请求原始的服务器资源；对于访问慢速网络上的公共内容时，可以假扮服务器提供服务，从而提高访问速度；这被称为&lt;code&gt;反向代理&lt;/code&gt;；可以作为内容路由器，如对付费用户，则将请求导到缓存服务器，提高访问速度；可以将页面的语言转换到与客户端相匹配，这称为“内容转码器”；“匿名代理”会主动从HTTP报文中删除身份相关的信息，如&lt;code&gt;User-Agent&lt;/code&gt;, &lt;code&gt;Cookie&lt;/code&gt;等字段。&lt;/p&gt;
&lt;p&gt;现实中，请求通过以下几种方式打到代理服务器上去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51083035-c534c000-174d-11e9-9cab-ddc4a0de2314.png&quot; alt=&quot;代理获取流量的方式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报文每经过一个中间点（代理或网关），都需要在首部via字段的末尾插入一个可以代表本节点的独特的字符串，包含实现的协议版本和主机地址。&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51083254-e7304180-1751-11e9-95f8-a833a0d10d51.png&quot; alt=&quot;via字段&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求和响应的报文传输路径通常都是一致的，只不过方向是相反的。因此，响应报文上的via字段表示的中间节点的顺序是刚好相反的。&lt;/p&gt;
&lt;h2 id=&quot;缓存&quot;&gt;缓存&lt;/h2&gt;
&lt;p&gt;当有很多请求访问同一个页面时，服务器会多次传输同一份数据，这些数据重复地在网络中传输着，消耗着大量带宽。如果将这些数据缓存下来，就可以提高响应速度，节省网络带宽了。&lt;/p&gt;
&lt;p&gt;大部分缓存只有在客户端发起请求，并且副本已经比较旧的情况下才会对副本的新鲜度进行检测。最常用的请求首部是&lt;code&gt;If-Modified-Since&lt;/code&gt;, 如果在xx(此时间即为If-Modified-Since的值)时间之后内容没有变化，服务器会回应一个&lt;code&gt;304 Not Modified&lt;/code&gt;. 否则，服务器会正常响应，并返回原始的文件数据，而这个过程中被称为&lt;code&gt;再验证命中&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再验证可能出现命中或未命中的情况。未命中时，服务器回复&lt;code&gt;200 OK&lt;/code&gt;，并且返回完整的数据；命中时，服务器回复&lt;code&gt;304 Not Modified&lt;/code&gt;; 还有一种情况，缓存被删除了，那么缓存服务器也会删除自己缓存的副本。&lt;/p&gt;
&lt;p&gt;顺带提一句，若要在项目中使用缓存，就一定要关注缓存命中比例。若命中比例不高，就要重新考虑设置缓存的必要性了。&lt;/p&gt;
&lt;p&gt;缓存服务器返回响应的时候，是基于已缓存的服务器响应的首部，对一些首部字段做一些微调。比如向其中插入新鲜度信息（如&lt;code&gt;Age&lt;/code&gt;, &lt;code&gt;Expires&lt;/code&gt;首部等），而且通常会包含一个&lt;code&gt;via&lt;/code&gt;首部来说明缓存是由一个缓存代理提供的。注意，这时不要修改&lt;code&gt;Date&lt;/code&gt;字段，它表示原始服务器最初构建这条响应的日期。&lt;/p&gt;
&lt;p&gt;HTTP通过&lt;code&gt;文档过期机制&lt;/code&gt;和&lt;code&gt;服务器再验证机制&lt;/code&gt;保持已缓存数据和服务器间的数据充分一致。&lt;/p&gt;
&lt;p&gt;文档过期通过如下首部字段来表示缓存的有效期：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51092170-60ba4500-17cf-11e9-8689-71b3c552bff3.png&quot; alt=&quot;缓存有效期&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当上面两个字段暗示的过期时间已到，需要向服务器再次验证文档的新鲜度。如果这时缓存仍和服务器上的原始文档一致，缓存只需要更新头部的相关字段。&lt;/p&gt;
&lt;p&gt;为了更好的节省网络流量，缓存服务器可以通过相关首部向原始服务器发送一个&lt;code&gt;条件GET&lt;/code&gt;请求, 这样只有在缓存真正过期的情况下，才会返回原始的文档，否则只会返回相关的首部。&lt;code&gt;条件GET&lt;/code&gt;请求会用到如下的字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51092289-8562ec80-17d0-11e9-9e35-47a010a3f7a3.png&quot; alt=&quot;缓存条件GET&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;cookie&lt;/h2&gt;
&lt;p&gt;cookie是服务器“贴在”客户端身上的标签，由客户端维护的状态片段，并且只会回送给合适的站点。&lt;/p&gt;
&lt;p&gt;有两类cookie: 会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；而持久cookie则保存在硬盘中，计算机重启后仍然存在。&lt;/p&gt;
&lt;p&gt;服务器在给客户端的响应字段首部加上&lt;code&gt;Set-cookie&lt;/code&gt;或&lt;code&gt;Set-cookie2&lt;/code&gt;, 值为名字=值的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过&lt;code&gt;Cookie&lt;/code&gt;带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。&lt;/p&gt;
&lt;p&gt;浏览器只会向产生这条cookie的站点发生cookie. &lt;code&gt;Set-cookie&lt;/code&gt;字段的值会包含&lt;code&gt;domain&lt;/code&gt;这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。&lt;code&gt;path&lt;/code&gt;字段也是相似的功能。如i浏览器收到如下的cookie:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Set-cookie: user=&quot;mary&quot;; domain=&quot;stefno.com&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么浏览器在访问任意以&lt;code&gt;stefno.com&lt;/code&gt;结尾的站点都会发送：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Cookie: user=&quot;mary&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实体和编码&quot;&gt;实体和编码&lt;/h2&gt;
&lt;p&gt;响应报文中的body部分传输的数据本质上都是二进制。我们从上面的报文数据也可以看出来，都是用十六进制数来表示，关键是怎么解释这块内容。如果&lt;code&gt;Content-Type&lt;/code&gt;定义是&lt;code&gt;text/plain&lt;/code&gt;, 那说明body内容就是文本，我们直接按文本编码来解释；如果&lt;code&gt;Content-Type&lt;/code&gt;定义是&lt;code&gt;image/png&lt;/code&gt;, 说明body部分是一幅图片，那我们就按图片的格式去解释数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Content-Length&lt;/code&gt;标示报文主体部分的数据长度大小，如果内容是压缩的，那它表示的就是压缩后的大小。另外，&lt;code&gt;Content-Length&lt;/code&gt;在长连接的情况下，可以对多个报文进行正确地分段。所以，如果没有采用分块编码，响应数据中必须带上&lt;code&gt;Content-Length&lt;/code&gt;字段。分块编码的情形中，数据被拆分成很多小块，每块都有大小说明。因此，任何带有主体部分的报文（请求或是响应）都应带上正确的&lt;code&gt;Content-Length&lt;/code&gt;首部。&lt;/p&gt;
&lt;p&gt;HTTP的早期版本采用关闭连接的方式来划定报文的结束。这带来的问题是显而易见的：客户端并不能分清是因为服务器正常结束还是中途崩溃了。这里，如果是客户端用关闭来表示请求报文主体部分的结束，是不可取的，因为关闭之后，就无法获取服务器的响应了。当然，客户端可以采用半关闭的方式，只关闭数据发送方向，但是很多服务器是不识别的，会把半关闭当成客户端要成服务器断开来处理。&lt;/p&gt;
&lt;p&gt;HTTP报文在传输的过程中可能会遭到代理或是其他通信实体的无意修改，为了让接收方知道这种情况，服务器会对body部分作一个md5, 并把值放到&lt;code&gt;Content-MD5&lt;/code&gt;这个字段中。但是，如果中间的代理即修改了报文主体，又修改了md5, 就不好检测了。因此规定代理是不能修改&lt;code&gt;Content-MD5&lt;/code&gt;首部的。这样，客户端在收到数据后，先进行解码，再算出md5, 并与&lt;code&gt;Content-MD5&lt;/code&gt;首部进行比较。&lt;/p&gt;
&lt;p&gt;HTTP在发送内容之前需要对其进行编码，它是对报文主体进行的可逆变换。比如将报文用gzip格式进行压缩，减少传输时间。常见的编码类型如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51150609-12c24180-18a2-11e9-9ca4-032f5abcd474.png&quot; alt=&quot;编码类型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，客户端为了避免服务器返回自己不能解码的数据，请求的时候，会在&lt;code&gt;Accept-Encoding&lt;/code&gt;首部里带上自己支持的编码方式。如果不传输的话，默认可以接受任何编码方式。&lt;/p&gt;
&lt;p&gt;上面提到的编码是内容编码，它只是在响应报文的主体报文将原始数据进行编码，改变的是内容的格式。还有另一种编码：传输编码。它与内容无关，它是为了改变报文数据在网络上传输的方式。传输编码是在HTTP 1.1中引入的一个新特性。&lt;/p&gt;
&lt;p&gt;通常，服务器需要先生成数据，再进行传输，这时，可以计算数据的长度，并将其编码到&lt;code&gt;Content-Length&lt;/code&gt;中。但是，有时，内容是动态生成的，服务器希望在数据生成之前就开始传输，这时，是没有办法知道数据大小的。这种情况下，就要用到&lt;code&gt;传输编码&lt;/code&gt;来标注数据的结束的。&lt;/p&gt;
&lt;p&gt;HTTP协议中通过如下两个首部来描述和控制传输编码：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;发送方告知接收方，我方已经进行了何种传输编码&lt;/td&gt;
&lt;td&gt;chuncked 分块编码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;TE&lt;/td&gt;
&lt;td&gt;请求方告知服务器可以用哪种传输编码&lt;/td&gt;
&lt;td&gt;trailers, chuncked 接受分块编码，并且愿意接受在报文结尾上的拖挂&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;分块编码的报文形式是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51151337-671af080-18a5-11e9-80ad-926461f90f6a.png&quot; alt=&quot;分块编码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个分块包含一个长度值（十六进制，字节数）和该分块的数据。&lt;code&gt;&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;/code&gt;用于区隔长度值和数据。长度值不包含分块中的任何&lt;code&gt;&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;/code&gt;序列。最后一个分块，用长度值0来表示结束。注意看报文首部包含一个&lt;code&gt;Trailer: Content-MD5&lt;/code&gt;, 所以在紧跟着最后一个报文结束之后，就是一个拖挂。其他如，&lt;code&gt;Content-Length&lt;/code&gt;, &lt;code&gt;Trailer&lt;/code&gt;, &lt;code&gt;Transfer-Encoding&lt;/code&gt;也可以作为拖挂。&lt;/p&gt;
&lt;p&gt;内容编码和传输编码是可以结合起来使用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51151680-ae55b100-18a6-11e9-819c-5cffcc35cd69.png&quot; alt=&quot;内容编码和传输编码结合&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;国际化支持&quot;&gt;国际化支持&lt;/h2&gt;
&lt;p&gt;HTTP为了支持国际化的内容，客户端要告知服务器自己能理解的何种语言，浏览器上安装了何种字母表编码算法。这通过&lt;code&gt;Accept-Charset&lt;/code&gt;和&lt;code&gt;Accept-Language&lt;/code&gt;首部实现。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Accept-Language: fr, en;q=0.8
Accept-Charset: iso-8859-1, utf-8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示：客户端接受法语（优先级默认为1.0）、英语（优先级为0.8），支持iso-8859-1, utf-8两种字符集编码。服务器则会在&lt;code&gt;Content-Type&lt;/code&gt;首部里放上&lt;code&gt;charset&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;本质上，HTTP报文的body部分存放的就是一串二进制码，我们先把二进制码转换成字符代码（如ascii是一个字节表示一个字符，而utf-8则表示一个字符的字节数不定，每个字符1~6个字节），之后，用字符代码支字符集中找到对应的元素。&lt;/p&gt;
&lt;p&gt;比较常见的字符集是&lt;code&gt;US-ASCII&lt;/code&gt;: 这个字符集是所有字符集的始祖，早在1968年就发布了标准。ASCII码的代码值从0到127, 只需要7个bit位就可以覆盖代码空间。HTTP报文的首部、URL使用的字符集就是ASCII码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;US-ASCII&lt;/code&gt;是把每个字符编码成固定的7位二进制值。&lt;code&gt;UTF-8&lt;/code&gt;则是无固定的编码方案。第一个字节的高位用来表示编码后的字符所用的字节数（如果所用的字节数是5，则第一个字节前5bit都是1，第6bit是0），所需的后续的字节都含有6位的代码值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51167193-e2e65e80-18e0-11e9-97da-caea0244386d.png&quot; alt=&quot;utf-8编码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子，汉字“严”的Unicode编码为&lt;code&gt;4E25&lt;/code&gt;(&lt;code&gt;100111000100101&lt;/code&gt;), 共有15位，落在上表中的第三行，因此“严”的编码就需要三个字节。将&lt;code&gt;100111000100101&lt;/code&gt;填入上表中的&lt;code&gt;c&lt;/code&gt;位即可。因此，严的&lt;code&gt;UTF-8&lt;/code&gt;编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5. 比如我在谷歌搜索框里搜索“严”字，google发出的请求如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;https://www.google.com.hk/search?q=%E4%B8%A5&amp;amp;oq=%E4%B8%A5&amp;amp;aqs=chrome..69i57j0l5.3802j0j4&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8&amp;amp;gws_rd=cr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;q=%E4%B8%A5&lt;/code&gt;这个就是搜索的词了。&lt;/p&gt;
&lt;h2 id=&quot;重点向与负载均衡&quot;&gt;重点向与负载均衡&lt;/h2&gt;
&lt;p&gt;Web内容通常分散地分布在很多地方，这可以防止“单点故障”，万一某个地方发生地震了，机房被毁了，那还有其他地方的机房可以提供服务。所谓&lt;code&gt;狡兔三窟&lt;/code&gt;嘛。&lt;/p&gt;
&lt;p&gt;这样，用户的请求会根据&lt;code&gt;负载均衡&lt;/code&gt;的原则，被&lt;code&gt;重定向&lt;/code&gt;到它应该去的地方。&lt;/p&gt;
&lt;h3 id=&quot;http重定向&quot;&gt;HTTP重定向&lt;/h3&gt;
&lt;p&gt;服务器收到客户端请求后，向客户端返回一条带有状态码&lt;code&gt;302&lt;/code&gt;重定向的报文，告诉他们应该去其他的地方试试。web站点将重定向看成一种简单的负载均衡策略来使用，&lt;code&gt;重定向&lt;/code&gt;服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。&lt;/p&gt;
&lt;p&gt;当然，缺点也是显而易见的，由于客户端要发送两次请求，因此增加耗时。&lt;/p&gt;
&lt;h3 id=&quot;dns重定向&quot;&gt;DNS重定向&lt;/h3&gt;
&lt;p&gt;DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的&lt;code&gt;轮转&lt;/code&gt;；也可以是更高级的算法，返回负载最轻的服务器的IP地址，称为&lt;code&gt;负载均衡算法&lt;/code&gt;；如果考虑地理位置，并返回给客户端最近位置的地址，称为&lt;code&gt;邻接路由算法&lt;/code&gt;；还有一种是绕过出现故障的地址，称为&lt;code&gt;故障屏蔽算法&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。&lt;/p&gt;
&lt;h2 id=&quot;http连接&quot;&gt;HTTP连接&lt;/h2&gt;
&lt;p&gt;HTTP连接是HTTP报文传输的关键通道。&lt;/p&gt;
&lt;h3 id=&quot;并行连接&quot;&gt;并行连接&lt;/h3&gt;
&lt;p&gt;对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，看起来速度会快起来。&lt;/p&gt;
&lt;p&gt;如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。如果采用串行方式，那么连接时延会进行叠加。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50803988-0f213e80-1327-11e9-93d9-10339ee54864.png&quot; alt=&quot;串行连接&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用并行连接之后：&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50803776-13992780-1326-11e9-8752-defd450ca639.png&quot; alt=&quot;并行连接&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接。&lt;/p&gt;
&lt;p&gt;另一方面，如果客户端网络带宽较小，每个连接都会去争抢有限的带宽，每个连接都会获取较小的速度，即每个对象都会以较小的速度去加载。这样，并行连接带来的速度提升就会比较小，甚至没有提升。&lt;/p&gt;
&lt;h3 id=&quot;持久连接&quot;&gt;持久连接&lt;/h3&gt;
&lt;p&gt;HTTP keep-alive机制&lt;/p&gt;
&lt;p&gt;我们知道HTTP请求是“请求-应答”模式，每次请求-应答都要新建一个连接，完成之后要断开连接。HTTP是无状态的，连接之间没有任何关系。&lt;/p&gt;
&lt;p&gt;HTTP是应用层协议，TCP是传输层协议。HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。&lt;/p&gt;
&lt;p&gt;HTTP 1.1默认开启keep-alive机制，从上面抓到的包也可以看到。这样，数据传输完成之后保持TCP连接不断开，之后同域名下复用连接，继续用这个通道传输数据。服务器在响应一个请求后，可以保持这个连接keep-alive timeout的时间，在这个时间内没有请求，则关闭此连接；否则，重新开始倒计时keep-alive timeout时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51286420-e4716d00-1a2d-11e9-9b95-79b1e0a1984a.png&quot; alt=&quot;http keep alive&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTTP有keep-alive机制，目的是可以在一个TCP&lt;br/&gt;连接上传输多个HTTP事务，以此提高通信效率。底层的TCP其实也有keep-alive机制，它是为了探测TCP连接的活跃性。TCP层的keepalive可以在任何一方设置，可以是一端设置、两端同时设置或者两端都没有设置。新建socket的时候需要设置，从而使得协议栈调用相关函数tcp_set_keepalive，来激活连接的keep-alive属性。&lt;/p&gt;
&lt;p&gt;当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）时间超过&lt;code&gt;tcp_keepalive_time&lt;/code&gt;后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 &lt;code&gt;tcp_keepalive_intvl&lt;/code&gt;后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试&lt;code&gt;tcp_keepalive_probes&lt;/code&gt;次后,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。&lt;/p&gt;
&lt;h3 id=&quot;管道化连接&quot;&gt;管道化连接&lt;/h3&gt;
&lt;p&gt;在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。所以最好是在响应中附带一些可以标识请求的参数。&lt;/p&gt;
&lt;p&gt;为了安全起见，管道化的连接只适合“幂等”的请求，一般我们认为：GET/HEAD/PUT/DELETE/TRACE/OPTIONS等方法都是幂等的。&lt;/p&gt;

&lt;p&gt;以上，就是所有HTTP的通信细节了。其实比较简单，更多的细节可以在用到的时候再去仔细研究。&lt;/p&gt;
&lt;p&gt;不知道你对HTTP的理解有没有更上一层楼？欢迎一起交流探讨。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51325279-8bdeb600-1aa7-11e9-860d-2063fbae105b.png&quot; alt=&quot;wechat QR&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 14:44:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>本文将带领你深入二进制的天地，深入分析HTTP通信的所有细节！看完本文，相信你对HTTP的理解会上一个台阶！ 为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcrao-2018/p/10285348.html</dc:identifier>
</item>
<item>
<title>利用Topshelf把.NET Core Generic Host管理的应用程序部署为Windows服务 - Elder_James</title>
<link>http://www.cnblogs.com/ElderJames/p/Using-Topshelf-To-Deploy-Net-Core-Generic-Host-App-To-Windows-Services.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ElderJames/p/Using-Topshelf-To-Deploy-Net-Core-Generic-Host-App-To-Windows-Services.html</guid>
<description>&lt;p&gt;2019第一篇文章。&lt;/p&gt;
&lt;p&gt;此文源于前公司在迁移项目到.NET Core的过程中，希望使用Generic Host来管理定时任务程序时，没法部署到Windows服务的问题，而且官方也没给出解决方案，只能关注一下&lt;a href=&quot;https://github.com/aspnet/Extensions/issues/809&quot;&gt;官方issue #809&lt;/a&gt; 等他们方解决了。&lt;/p&gt;
&lt;p&gt;官方文档只提供了一个&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/windows-service?spm=a2c4e.11153940.blogcont676413.12.65753eb0BIzfmE&amp;amp;view=aspnetcore-2.1&quot;&gt;《在 Windows 服务中托管 ASP.NET Core》&lt;/a&gt;的方案，可以使用&lt;code&gt;Microsoft.AspNetCore.Hosting.WindowsServices&lt;/code&gt;类库来把Web应用部署为Windows服务。但是ASP.NET Core虽然是控制台程序，但是它本身是使用了含有HTTP管道的Web Host来负责应用程序的生命周期管理，用它来作为定时任务的话，会有很多不必要的工作负载，例如占用端口、增加了很多依赖等等。&lt;/p&gt;
&lt;p&gt;官方意识到这个问题之后，在.NET Core 2.1版本新增了Generic Host通用主机，剥离了原来WebHost的Http管道相关的API，源码中可以发现Web Host已经基于Generic Host实现。它才是作为纯粹定时任务程序的最佳拍档。&lt;/p&gt;
&lt;p&gt;但是由于Generic Host本身非常简单，用它运行的程序设置在注册为Windows服务启动之后会自动停止。研究很久之后才知道，想在Windows上启动服务，还是不能像Linux上那么简单——&lt;/p&gt;
&lt;p&gt;于是尝试结合Topshelf来创建Windows服务，最终成功了。&lt;/p&gt;
&lt;h2 id=&quot;实现方法&quot;&gt;实现方法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;先实现&lt;code&gt;IHostLifetime&lt;/code&gt;接口来接管应用程序的生命周期，其实就是用空的实现来替换掉默认的ConsoleLifetime，这样就可以在之后由Topshelf框架内部去管理生命周期。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    internal class TopshelfLifetime : IHostLifetime
    {
        public TopshelfLifetime(IApplicationLifetime applicationLifetime, IServiceProvider services)
        {
            ApplicationLifetime = applicationLifetime ?? throw new ArgumentNullException(nameof(applicationLifetime));
        }

        private IApplicationLifetime ApplicationLifetime { get; }

        public Task WaitForStartAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;然后实现&lt;code&gt;IHostedService&lt;/code&gt;接口，把后台任务逻辑写到&lt;code&gt;StartAsync&lt;/code&gt;方法中，参见官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.1#ihostedservice-interface&quot;&gt;《在 ASP.NET Core 中使用托管服务实现后台任务》&lt;/a&gt;，本文示例使用定时写入文本到一个文件来测试定时任务是否成功运行。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    internal class FileWriterService : IHostedService, IDisposable
    {
        private static string path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, @&quot;test.txt&quot;);

        private Timer _timer;

        public Task StartAsync(CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested) return Task.FromCanceled(cancellationToken);

            _timer = new Timer(
                (e) =&amp;gt; WriteTimeToFile(),
                null,
                TimeSpan.Zero,
                TimeSpan.FromSeconds(10));

            return Task.CompletedTask;
        }

        public void WriteTimeToFile()
        {
            if (!File.Exists(path))
            {
                using (var sw = File.CreateText(path))
                {
                    sw.WriteLine(DateTime.Now);
                }
            }
            else
            {
                using (var sw = File.AppendText(path))
                {
                    sw.WriteLine(DateTime.Now);
                }
            }
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            _timer?.Change(Timeout.Infinite, 0);

            return Task.CompletedTask;
        }

        public void Dispose()
        {
            _timer?.Dispose();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;构建Generic Host，在&lt;code&gt;ConfigureServices&lt;/code&gt;方法中注册&lt;code&gt;TopshelfLifetime&lt;/code&gt;，并且注册一个托管服务&lt;code&gt;FileWriterService&lt;/code&gt;，就能完成Generic Host的简单构建，当然完整的项目应该还包含配置、日志等等。最后，使用Topshelf来接管Generic Host，创建Windows服务。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    internal class Program
    {
        private static void Main(string[] args)
        {
            var builder = new HostBuilder()
                .ConfigureServices((hostContext, services) =&amp;gt;
                {
                    services.AddSingleton&amp;lt;IHostLifetime, TopshelfLifetime&amp;gt;();
                    services.AddHostedService&amp;lt;FileWriterService&amp;gt;();
                });

            HostFactory.Run(x =&amp;gt;
            {
                x.SetServiceName(&quot;GenericHostWindowsServiceWithTopshelf&quot;);
                x.SetDisplayName(&quot;Topshelf创建的Generic Host服务&quot;);
                x.SetDescription(&quot;运行Topshelf创建的Generic Host服务&quot;);

                x.Service&amp;lt;IHost&amp;gt;(s =&amp;gt;
                {
                    s.ConstructUsing(() =&amp;gt; builder.Build());
                    s.WhenStarted(service =&amp;gt;
                    {
                        service.Start();
                    });
                    s.WhenStopped(service =&amp;gt;
                    {
                        service.StopAsync();
                    });
                });
            });
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;最后发布应用程序，并安装到Windows服务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以管理员权限开启终端，执行命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;  dotnet publish -c release -r win-x64
  
  cd path-to-project/bin/release/netcoreapp2.1/win-x64/publish

  ./project-name install

  net start GenericHostWindowsServiceWithTopshelf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://yangshunjie.com/images/generic-host/generic-host-install.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样这个Windows服务就启动了！查看输出文件，可以看到定时写入成功，服务也一直没关闭~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yangshunjie.com/images/generic-host/generic-host-result.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;https://github.com/ElderJames/GenericHostWindowsServiceWithTopshelf&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;p&gt;官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1&quot;&gt;《.NET 通用主机》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.1&quot;&gt;《在 ASP.NET Core 中使用托管服务实现后台任务》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 14:34:00 +0000</pubDate>
<dc:creator>Elder_James</dc:creator>
<og:description>背景 2019第一篇文章。 此文源于前公司在迁移项目到.NET Core的过程中，希望使用Generic Host来管理定时任务程序时，没法部署到Windows服务的问题，而且官方也没给出解决方案，只</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ElderJames/p/Using-Topshelf-To-Deploy-Net-Core-Generic-Host-App-To-Windows-Services.html</dc:identifier>
</item>
<item>
<title>ML.NET 0.9特性简介 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10284906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10284906.html</guid>
<description>&lt;p&gt;ML.NET 0.9已于上周发布，距离上次0.8版本的发布只有一个多月，此次增加的新特性主要包括特征贡献计算，模型可解释性增强，ONNX转换对GPU的支持，Visual Studio ML.NET项目模板预览，以及API改进。&lt;/p&gt;

&lt;p&gt;特征贡献计算(Feature Contribution Calculation)通过决定每个特征对模型分数的贡献，从而显示哪些特征在对特别个体的数据样本的模型预测最有影响力。&lt;/p&gt;
&lt;p&gt;当你面临历史数据中有许多特征时而又想选择使用最重要的特征时，特征贡献计算显得十分重要。因为使用太多的特征(尤其是包含对模型没有影响的特征)会减少模型的性能与准确性。因此，使用特征贡献计算你可以从原始特征集中识别最有影响力的正向与负向的贡献。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 创建特征贡献计算器
// 对已有训练模型参数的所有特征进行计算贡献

var featureContributionCalculator = mlContext.Model.Explainability.FeatureContributionCalculation(model.Model, model.FeatureColumn, numPositiveContributions: 11, normalize: false);

// FeatureContributionCalculatingEstimator可被用作管道中的一个步骤
// 被FeatureContributionCalculatingEstimator保存的特征将在FeatureContribution列中

var pipeline = mlContext.Model.Explainability.FeatureContributionCalculation(model.Model, model.FeatureColumn, numPositiveContributions: 11)
    .Append(mlContext.Regression.Trainers.OrdinaryLeastSquares(featureColumn: &quot;FeatureContributions&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果可下：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;The output of the above code is:

  Label   Score   BiggestFeature         Value   Weight   Contribution

  24.00   27.74   RoomsPerDwelling        6.58    98.55   39.95
  21.60   23.85   RoomsPerDwelling        6.42    98.55   39.01
  34.70   29.29   RoomsPerDwelling        7.19    98.55   43.65
  33.40   27.17   RoomsPerDwelling        7.00    98.55   42.52&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;除了特征贡献计算之外，排列特征重要性(PFI)与广义加性模型(GAM)也有加强。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;排列特征重要性支持大多数学习任务：回归，二元分类，多元分类与排序。&lt;/li&gt;
&lt;li&gt;排列特征重要性允许你在特征重要性分数上计算置信区间，以便可以得到更好的平均值估计。&lt;/li&gt;
&lt;li&gt;广义加性模型支持特征贡献计算，以便你可以迅速看到哪些特征驱动个体的预测。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201901/991496-20190117214901389-1936956853.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ML.NET 0.9中通过集成高性能的ONNX运行时库添加了使用激活GPU的CUDA 10.0运行ONNX模型的功能。ONNX模型的GPU支持现在已经可以在Windows 64位系统上使用，不久之后将支持Linux与Mac系统。&lt;/p&gt;

&lt;p&gt;Visual Studio项目模板现在推出了支持ML.NET的预览版本。&lt;a href=&quot;https://aka.ms/mlnettemplates&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201901/991496-20190117222511934-2105582242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板涵盖以下场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ML.NET控制台应用程序&lt;/li&gt;
&lt;li&gt;ML.NET模型类库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;简化文本数据加载&quot;&gt;简化文本数据加载&lt;/h2&gt;
&lt;p&gt;ML.NET 0.9以前你需要显示的标明列名：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var mlContext = new MLContext();

var reader = mlContext.Data.CreateTextReader(new[] {
        new TextLoader.Column(&quot;IsOver50K&quot;, DataKind.BL, 0),
        new TextLoader.Column(&quot;Workclass&quot;, DataKind.TX, 1)
    },hasHeader: true
);
var dataView = reader.Read(dataPath);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在你可以直接使用泛型：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var mlContext = new MLContext();

var dataView = mlContext.Data.ReadFromTextFile&amp;lt;InspectedRow&amp;gt;(dataPath, hasHeader: true);

private class InspectedRow
{
    [LoadColumn(0)]
    public bool IsOver50K { get; set; }
    [LoadColumn(1)]
    public string Workclass { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取预测置信因子&quot;&gt;获取预测置信因子&lt;/h2&gt;
&lt;p&gt;通过Calibrator Estimators，除了在评估模型质量时可以获得分数列之外，还可以得到置信因子。&lt;/p&gt;
&lt;p&gt;例如，你可以获得每个预测值的概率：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;Score - 0.458968    Probability 0.4670409
Score - 0.7022135   Probability 0.3912723
Score 1.138822      Probability 0.8703266&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;新的键-值匹配估测器及转换&quot;&gt;新的键-值匹配估测器及转换&lt;/h2&gt;
&lt;p&gt;新特性替换了TermLookupTransform，同时提供了指定值之间匹配的新方法。你可以指定键列与值列的匹配关系，但需保证两者数量一致。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;允许ML.NET在Windows Nano容器及Windows机器上运行，而无需安装Visual C++运行时。&lt;/li&gt;
&lt;li&gt;在包含模型信息的DataView构造器中提供元数据支持，比如被编码为元数据的评估指标可以通过代码解析出来，由此能够使用任何工具进行可视化。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 17 Jan 2019 14:29:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>ML.NET 0.9已于上周发布，距离上次0.8版本的发布只有一个多月，此次增加的新特性主要包括特征贡献计算，模型可解释性增强，ONNX转换对GPU的支持，Visual Studio ML.NET项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10284906.html</dc:identifier>
</item>
<item>
<title>开发框架数据库配置的几种应用场景 - 伍华聪</title>
<link>http://www.cnblogs.com/wuhuacong/p/10283050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhuacong/p/10283050.html</guid>
<description>&lt;p&gt;在我的开发框架系列中，底层数据库的配置处理都是差不多的，框架整体支持SQLServer、DB2、MySql、ODP.NET（Oracle）、PostgreSQL、SQLite、SqlEx等数据库的，往往客户在使用框架的时候会问，框架支持哪些数据库、各种数据库配置信息、如何实现数据库分库处理、如何同时支持SQLServer和Oracle等数据库支持、如何实现数据库连接字符串加密等问题，本篇随笔逐一进行介绍。&lt;/p&gt;
&lt;h3&gt;1、框架支持的数据库介绍&lt;/h3&gt;
&lt;p&gt;框架底层数据库访问采用了微软企业库实现，因此在处理多种数据库访问的时候，能够提供统一的访问处理操作，同时对不同的数据库支持操作也是非常不错的。下图是框架底层数据库的支持情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/8867/201609/8867-20160912215456898-1744597836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用了微软企业库Enterprise Library作为我们底层的数据库访问模块后，对于多种数据库的访问操作，就会统一采用这个企业库的数据库访问对象，操作起来非常一致，为了对不同数据库的常规增删改查等一些操作进行进一步的封装，以达到简化代码的目的，因此我们可以为每个不同的数据库定义一个数据访问操作基类，以便实现一些不同数据库差异性的处理，但是它们还是有一个共同的数据访问基类。&lt;/p&gt;
&lt;p&gt;采用不同的数据库，我们需要为不同数据库的访问层进行生成处理，如为SQLServer数据的表生成相关的数据访问层DALSQL，里面放置各个表对象的内容，不过由于采用了相关的继承类处理和基于数据库的代码生成，需要调整的代码很少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/8867/201609/8867-20160912221847039-433368706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样整合多种数据库支持的底层后，整个数据访问的架构设计如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/8867/201609/8867-20160912220432133-748392124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、各种数据库配置信息&lt;/h3&gt;
&lt;p&gt;对于默认支持的SQLServer数据库，它的连接字符串如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configSections&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataConfiguration&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Practices.EnterpriseLibrary.Data.Configuration.DatabaseSettings, Microsoft.Practices.EnterpriseLibrary.Data&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configSections&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;SQLServer数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sqlserver&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SqlClient&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Persist Security Info=False;Data Source=(local);Initial Catalog=WinFramework;Integrated Security=SSPI&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataConfiguration &lt;/span&gt;&lt;span&gt;defaultDatabase&lt;/span&gt;&lt;span&gt;=&quot;sqlserver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的sqlserver数据库连接信息是采用信任模式配置的，如果我们基于局域网，那么需要配置对应的IP或者sa用户名和密码的方式，配置信息如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sqlserver2&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SqlClient&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=192.168.1.10;Initial Catalog=CRM;Persist Security Info=True;User ID=sa;Password=123456&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过对于一些扩展支持的数据库，我们还需要添加一些映射处理，如对于MySQL的支持，我们需要添加连接字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;MySQL数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;MySql.Data.MySqlClient&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Server=localhost;Database=WinFramework;Uid=root;Pwd=123456;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还需要添加ProviderMappings的支持，如下所示的XML。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataConfiguration &lt;/span&gt;&lt;span&gt;defaultDatabase&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;providerMappings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;databaseType&lt;/span&gt;&lt;span&gt;=&quot;EntLibContrib.Data.MySql.MySqlDatabase, EntLibContrib.Data.MySql&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;MySql.Data.MySqlClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;providerMappings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我列出所有不同数据库的连接字符串以及映射关系的一个完整版本，供参考。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configSections&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataConfiguration&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Practices.EnterpriseLibrary.Data.Configuration.DatabaseSettings, Microsoft.Practices.EnterpriseLibrary.Data&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configSections&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Sqlserver数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sqlserver&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SqlClient&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Persist Security Info=False;Data Source=(local);Initial Catalog=WinFramework;Integrated Security=SSPI&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;PostgreSQL数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;npgsql&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;Npgsql&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Server=localhost;Port=5432;Database=postgres;User Id=postgres;Password=123456&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;MySQL数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;MySql.Data.MySqlClient&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Server=localhost;Database=WinFramework;Uid=root;Pwd=root;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;路径符号|DataDirectory|代表当前运行目录&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;access&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.OleDb&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=|DataDirectory|\WinFramework.mdb;User ID=Admin;Jet OLEDB:Database Password=;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;sqlite数据库字符串，路径符号|DataDirectory|代表当前运行目录&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sqlite&quot;&lt;/span&gt;&lt;span&gt;  providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SQLite&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=|DataDirectory|\WinFramework.db;Version=3;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Oracle数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;oracle&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.OracleClient&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=orcl;User ID=win;Password=win&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;达梦数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Dm&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;Dm&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Server=localhost;User ID=SYSDBA;PWD=SYSDBA;Database=WINFRAMEWORK;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;IBM DB2数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;db2&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;IBM.Data.DB2&quot;&lt;/span&gt;&lt;span&gt;    connectionString&lt;/span&gt;&lt;span&gt;=&quot;database=whc;uid=whc;pwd=123456&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;采用OdpNet方式的Oracle数据库的连接字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;oracle2&quot;&lt;/span&gt;&lt;span&gt;    providerName&lt;/span&gt;&lt;span&gt;=&quot;Oracle.DataAccess.Client&quot;&lt;/span&gt;&lt;span&gt;    connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=orcl;User id=win;Password=win;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataConfiguration &lt;/span&gt;&lt;span&gt;defaultDatabase&lt;/span&gt;&lt;span&gt;=&quot;sqlserver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;providerMappings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;databaseType&lt;/span&gt;&lt;span&gt;=&quot;EntLibContrib.Data.PostgreSql.NpgsqlDatabase, EntLibContrib.Data.PostgreSql&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Npgsql&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;databaseType&lt;/span&gt;&lt;span&gt;=&quot;EntLibContrib.Data.MySql.MySqlDatabase, EntLibContrib.Data.MySql&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;MySql.Data.MySqlClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;databaseType&lt;/span&gt;&lt;span&gt;=&quot;EntLibContrib.Data.SQLite.SQLiteDatabase, EntLibContrib.Data.SqLite&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SQLite&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;databaseType&lt;/span&gt;&lt;span&gt;=&quot;EntLibContrib.Data.Dm.DmDatabase, EntLibContrib.Data.Dm&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Dm&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;databaseType&lt;/span&gt;&lt;span&gt;=&quot;EntLibContrib.Data.DB2.DB2Database, EntLibContrib.Data.DB2&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;IBM.Data.DB2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;databaseType&lt;/span&gt;&lt;span&gt;=&quot;EntLibContrib.Data.OdpNet.OracleDatabase, EntLibContrib.Data.OdpNet&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Oracle.DataAccess.Client&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;providerMappings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appSettings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;组件的数据库类型：access、sqlserver、sqlite、oracle等，默认为sqlserver可不写&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;ComponentDbType&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;sqlserver&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appSettings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;startup &lt;/span&gt;&lt;span&gt;useLegacyV2RuntimeActivationPolicy&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;supportedRuntime &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;v4.0&quot;&lt;/span&gt;&lt;span&gt; sku&lt;/span&gt;&lt;span&gt;=&quot;.NETFramework,Version=v4.0&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;supportedRuntime &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;v2.0.50727&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;里面包括了支持的各种数据库的连接字符串的写法。&lt;/p&gt;

&lt;h3&gt;3、如何实现数据库分库处理、如何同时支持SQLServer和Oracle等数据库支持 &lt;/h3&gt;
&lt;p&gt;由于整个框架的设计抽象了多种数据库的处理模型，因此数据库分库处理实现也是比较方便的，数据库的分库处理和同时支持SQLServer和Oracle等数据库的操作是类似的，他们都是对多个数据库（包括不同各类型）进行访问处理。&lt;/p&gt;
&lt;p&gt;之前我在随笔《&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/wuhuacong/p/3783294.html&quot;&gt;Winform开发框架中实现多种数据库类型切换以及分拆数据库的支持&lt;/a&gt;》这里也介绍了具体的实现处理，其实我们使用的同时支持多数据库的操作代码是比较简单的，我们可以在代码里面通过调用BLL层类的接口SetConfitName来指定特定的数据库，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定业务类的数据库配置&lt;/span&gt;
            BLLFactory&amp;lt;Asset&amp;gt;.Instance.SetConfigName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;workflow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
            BLLFactory&lt;/span&gt;&amp;lt;StoreAddress&amp;gt;.Instance.SetConfigName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;workflow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时候，可能BLL对象有可能出现相同的情况，但是需要访问不同库里面的表对象，那么我们可以在使用后恢复默认的配置信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            BLLFactory&amp;lt;DictData&amp;gt;.Instance.SetConfigName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;workflow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用业务库&lt;/span&gt;
            Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; dict = BLLFactory&amp;lt;DictData&amp;gt;&lt;span&gt;.Instance.GetDictByDictType(dictTypeName);
            BLLFactory&lt;/span&gt;&amp;lt;DictData&amp;gt;.Instance.SetConfigName(&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复默认&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码就是先访问workflow配置的数据库信息，获取字典信息后恢复默认的数据库信息。&lt;/p&gt;
&lt;p&gt;上面那种方式是对于同种类型数据库的接口切换，如果不同的数据库类型，如一个是SQLServer，一个是Oracle，那么就可以多指定一个参数即可，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定使用oracle类型的数据库配置&lt;/span&gt;
            BLLFactory&amp;lt;DictData&amp;gt;.Instance.SetConfigName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;workflow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oracle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用业务库&lt;/span&gt;
            Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; dict = BLLFactory&amp;lt;DictData&amp;gt;&lt;span&gt;.Instance.GetDictByDictType(dictTypeName);
            BLLFactory&lt;/span&gt;&amp;lt;DictData&amp;gt;.Instance.SetConfigName(&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复默认&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然我们一般使用一个库，但是如果是分库，或者要同时支持多个数据库类型，基本上处理还是很方便的。&lt;/p&gt;
&lt;p&gt;如果对于通用类型的数据库处理，我们可以使用公用类库里面的CommonDAL类进行处理。这个类库可以很方便的处理视图、存储过程、或者常规的接口查询操作，不需要和具体的实体类绑定的接口。&lt;/p&gt;
&lt;p&gt;它的定义如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/8867/201505/152124568927527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4、数据库字符串加密处理&lt;/h3&gt;
&lt;p&gt;很多情况下，我们为了部署应用，需要公开数据库连接字符串信息，但是我们又不想让使用者很容易的获取到我们的连接字符串里面的用户名和密码敏感信息，这时候连接字符串加密就是比较必要的了。&lt;/p&gt;
&lt;p&gt;处理方式就是我们创建一个工具，使用自己知道的加解密规则来处理连接字符串的加解密处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201901/8867-20190117165807329-811654682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;处理的过程大概如下所示。&lt;/p&gt;
&lt;p&gt;1）找到app.config文件，打开内容编辑。&lt;br/&gt;2）找到数据库（如SQLServer）连接字符串的connectionString字符串，如下所示。&lt;br/&gt;&amp;lt;add name=&quot;sqlserver&quot; providerName=&quot;System.Data.SqlClient&quot; connectionString=&quot;Persist Security Info=False;Data Source=(local);Initial Catalog=CRM;Integrated Security=SSPI&quot;/&amp;gt;&lt;br/&gt;3）提取里面的connectionString字符串部分，放到上面的加密软件里面进行加密，然后把加密内容替换connectionString字符串，变为如下所示的配置信息。&lt;br/&gt;&amp;lt;add name=&quot;sqlserver&quot; providerName=&quot;System.Data.SqlClient&quot; connectionString=&quot;9Fs/vPhm24CYa0mXCLAMYOJmbBHq/qQAjdbVdbeOhS5L0d8WGhHUR3iIyFZydEV8cPmlPHfDTnwJZMr9xkMAxuNtPKUsIdKTjlWInpf+Vc+UD2gtYIE3FnvL06KcHzX+&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;4）保存文件，配置加密字符串完成。&lt;/p&gt;
&lt;p&gt;这个配置信息在框架的处理的时候有对应的解密处理规则，可以正常解析加密字符串即可。&lt;/p&gt;
&lt;p&gt;如果要了解或者修改其中的对应解密处理操作，可以定位扩展公用类库里面数据库访问层，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201901/8867-20190117170328857-514568185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定位到对应的数据库访问类，然后找到下面的对应函数了解即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201901/8867-20190117170500336-979970288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 17 Jan 2019 14:25:00 +0000</pubDate>
<dc:creator>伍华聪</dc:creator>
<og:description>在我的开发框架系列中，底层数据库的配置处理都是差不多的，框架整体支持SQLServer、DB2、MySql、ODP.NET（Oracle）、PostgreSQL、SQLite、SqlEx等数据库的，往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhuacong/p/10283050.html</dc:identifier>
</item>
<item>
<title>MapServer Tutorial——MapServer7.2.1教程学习——第一节用例实践：Example1.1 A map with single layer - eshine</title>
<link>http://www.cnblogs.com/eshinex/p/10276449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eshinex/p/10276449.html</guid>
<description>&lt;p&gt;&lt;strong&gt;MapServer Tutorial——MapServer7.2.1教程学习——第一节用例实践：Example1.1 A map with single layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;开始MapServer用例实践之旅，做项目算是可以比喻为考试，但是考试之前，还是以做练习题模拟考为主。下面实践一下官网的第一个例子：&lt;strong&gt;Example1.1 A map with single layer&lt;/strong&gt;（官网地址：&lt;a href=&quot;https://www.mapserver.org/tutorial/example1-1.html#example1-1&quot; target=&quot;_blank&quot;&gt;https://www.mapserver.org/tutorial/example1-1.html#example1-1&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.打开案例相关介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.1.MapServer能够创建图像并投影到本地目录或者直接的投影到你所使用请求的浏览器上面。本用例你可以通过浏览器直接打开：&lt;a href=&quot;http://localhost/cgi-bin/mapserv?map=/ms4w/apps/tutorial/htdocs/example1-1.map&amp;amp;layer=states&amp;amp;mode=map&quot; target=&quot;_blank&quot;&gt;http://localhost/cgi-bin/mapserv?map=/ms4w/apps/tutorial/htdocs/example1-1.map&amp;amp;layer=states&amp;amp;mode=map&lt;/a&gt;查看。&lt;/p&gt;
&lt;p&gt;　　　　　　注意：这个位置的地址是按照官网上面翻译的地址，如果是根据自己的个人安装环境以及建站配置等设置的，需要修改。&lt;/p&gt;
&lt;p&gt;　　　　1.2.当前URL分为两个部分&lt;/p&gt;
&lt;p&gt;　　　　　　第一部分：&quot;http://localhost/cgi-bin/mapserv?&quot;部分，调用MapServer CGI进程。如果你在浏览器中打开http://localhost/cgi-bin/mapserv?，会出现“No query information to decode. QUERY_STRING is set, but empty”。&lt;/p&gt;
&lt;p&gt;　　　　　　第二部分：URL中的三个参数 map、layer、mode&lt;/p&gt;
&lt;p&gt;　　　　　　　　map=/ms4w/apps/tutorial/htdocs/example1-1.map：此处表示告诉MapServer的CGI进程去解析哪一个map文件。可以是绝对路径，也可以是相对路径（相对路径是针对mapserv.exe而言的）。&lt;/p&gt;
&lt;p&gt;　　　　　　　　layer=states：此处告诉MapServer“打开”layer状态，回调时，我们命名layer对象为“states”&lt;/p&gt;
&lt;p&gt;　　　　　　　　mode=map：告诉MapServer对mapfile文件的输出格式，这里是告诉MapServer直接将图像投影到浏览器，无需先在服务器端创建零时的图像。&lt;/p&gt;
&lt;p&gt;　　　　　　注意：mapserver模式cgi变量采用的值不是map。例如，如果使用mode=browse，mapserver将把映像转储到服务器上的临时目录。浏览模式现在不起作用，但稍后我们将再次实践。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.mapfile的文件结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　官网用例“&lt;strong&gt;Example1.1 A map with single layer&lt;/strong&gt;”的mapfile文件结构请查看此链接：&lt;a href=&quot;https://www.mapserver.org/tutorial/example1-1-map.html#example1-1-map&quot; target=&quot;_blank&quot;&gt;https://www.mapserver.org/tutorial/example1-1-map.html#example1-1-map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/249616/201901/249616-20190116130751262-463191663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　MapFile文件介绍请查看此链接：&lt;a href=&quot;https://www.mapserver.org/mapfile/index.html#mapfile&quot; target=&quot;_blank&quot;&gt;https://www.mapserver.org/mapfile/index.html#mapfile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　后续再添加一篇文章，对MapFile做详细介绍。&lt;/p&gt;
&lt;p&gt;　　　　Mapefile是MapServer的基础配置机制（个人理解就是告诉MapServer的站点是如何运行的）。它有对象组成，如：LAYERT。每个对象有自己的关键之，并可以包含其他对象。它包含的对象有一定的层次结构，如：LAYER对象中包含CLASS，CLASS是属于LAYER的。&lt;/p&gt;
&lt;p&gt;　　　　当前是一个非常简单的文件结构，当学习完其他用例时，你会了解更复杂的mapfile层次结构。&lt;/p&gt;
&lt;p&gt;　　　　我们定义mapfile中的内容时，以对象名称开头，END结尾；#表示注释。&lt;/p&gt;
&lt;p&gt;　　　　目前的层次结构为：&lt;/p&gt;
&lt;p&gt;　　　　　　MAP&lt;/p&gt;
&lt;p&gt;　　　　　　　　|----LAYER&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　|----CLASS&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　|----STYLE&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.Mapfile中的对象解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　3.1Map对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　MAP：&lt;/strong&gt;每个mapfile均以MAP开头，END结尾。只有这样格式的文件才会被识别为mapfile文件。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;IMAGETYPE：&lt;/strong&gt;图片类型，imagetype为mapserver的CGI定义输出图片格式。当前样例使用PNG作为输出格式（老版本用GIF）。如果需要使用GIF，在编译源码时，需要开启GIF，WBMP或 JPEG 支持（在cmd里面输入mapserv -v可以查看输出的格式支持）。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　   　　当然也能够指定输出其他格式，如：PDF、SWF、GeoTIFF等。只要编译的时候在OUTPUTFORMAT加上相关的支持即可。输出支持详见：&lt;a href=&quot;https://mapserver.org/documentation.html#output&quot; target=&quot;_blank&quot;&gt;https://mapserver.org/documentation.html#output&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;EXTENT：&lt;/strong&gt;此参数指定地图的输出范围-初始地图的边界框。范围值的格式如：&amp;lt;Lower Left X&amp;gt; &amp;lt;Lower Left Y&amp;gt; &amp;lt;Upper Right X&amp;gt; &amp;lt;Upper Right Y&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　每个值用空格分开。这需要与数据使用相同的单位，或者，如果指定了不同的输出投影，则需要与输出投影使用相同的单位。&lt;/p&gt;
&lt;p&gt; 　　　　　　　　   　　在这个例子中，我们的数据是地理投影的，所以单位是十进制的。&lt;/p&gt;
&lt;p&gt;　　　　　　　　   　　你可以使用ogrinfo（官网：&lt;a href=&quot;http://gdal.org/ogrinfo.html&quot; target=&quot;_blank&quot;&gt;http://gdal.org/ogrinfo.html&lt;/a&gt;）提供的工具，其作为GDAL/OGR二级制包的一部分，作为shapefile数据集的一部分（或者其他支持向量格式数据集）。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　使用cmd命令定位到.shp文件所在目录，输入：ogrinfo -al -so &lt;span&gt;states_ugl.shp&lt;/span&gt; 查看 states_ugl.shp 文件信息（红色部分根据实际查看文件信息填写）&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　运行此命令的先决条件是，你安装了MapServer，同时环境变量中添加了GDAL&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/249616/201901/249616-20190116174513742-1667339055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　   　　当然，你也可以使用ArcView或者其他开元GIS软件查看，比如&lt;a href=&quot;https://www.qgis.org/en/site/&quot; target=&quot;_blank&quot;&gt;QGIS&lt;/a&gt;、&lt;a href=&quot;http://thuban.intevation.org/&quot; target=&quot;_blank&quot;&gt;Thuban&lt;/a&gt; 等。请随意更改范围的值，以便更好地了解范围如何更改地图。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;SIZE：&lt;/strong&gt;表示MapServer生成map图片的大小，但是为像素。当前例子是宽400像素，高300像素。在mapfile中修改这个值，可以查看在地图中的变化。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;SHAPEPATH：&lt;/strong&gt;图层数据的路径。可以是绝对路径，也可以是mapfile的相对路径（如：../data 或 &lt;span&gt;E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\apps\Example1.1\data&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　此路径不需要通过web访问，通常根本不需要对其访问，除非你愿意提供给别人下载你的原始数据。在web浏览器上面，它没有任何作用，所以不要考虑提供下载此源文件的URL。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　    　　只需要保证你的应用程序池可以访问到此shape文件（在Unix上面，是“nobdy”或“Apache”用户组），并对其读取权限。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;IMAGECOLOR：&lt;/strong&gt;地图的背景颜色。使用RGB值组成。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3.2 LAYER对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　LAYER：&lt;/strong&gt;map对象图层的开始标签，详见：&lt;a href=&quot;https://www.mapserver.org/mapfile/layer.html#layer&quot; target=&quot;_blank&quot;&gt;https://www.mapserver.org/mapfile/layer.html#layer&lt;/a&gt;。你可以指定多个layer对象。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;NAME：&lt;/strong&gt;NAME是LAYER对象的唯一标识符。MapServer通过NAME控制LAYER的开关。这个案例中LAYER的STATUS为默认值，所以NAME是无法控制工作的。后续案例中再做详细介绍。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;DATA：&lt;/strong&gt;数据的名称（当前案例中是shape文件的数据名称）。MapServer通过OGR（GDAL库的一部分）库支持ESRI的shapefile格式以及以外的矢量数据解析。你可以通过访问GDAL数据支持学习MapServer所支持的不同的矢量数据格式（&lt;a class=&quot;reference external&quot; href=&quot;http://gdal.org/ogr_formats.html&quot;&gt;http://gdal.org/ogr_formats.html&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　  然后官网上面也有相关的数据支持文档&lt;a class=&quot;reference internal&quot; href=&quot;https://www.mapserver.org/input/vector/index.html#vector&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;guide to using vector data for MapServer&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;TYPE：&lt;/strong&gt;数据是什么类型的？如果是矢量数据，你可以指定为POLYGON（多边形），LINE（线）（即使是POLYLINE在技术上也可以使用LINE），或者POINT（点）。你也可以指定为RASTER（栅格）或ANNOTATION（标注）数据。当前案例是POLYGON（多边形）。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;STATUS：&lt;/strong&gt;层级（layers）是通过他们的STATUS来设置开关的。DEFAULT 状态默认是打开的。层级（layers）的开关控制是通过URL中LAYER的名称参数控制的。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3.3 CLASS 对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　CLASS：&lt;/strong&gt;在LAYER对象中，以CLASS标签开始，END结尾。你可以在一个layer中指定多个CLASS。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;NAME：&lt;/strong&gt;CLASS对象的唯一标识符。一个layer对象可以有多个class对象，就像一个MAP对象可以有多个layer对象一样。MapServer通过CLASS对象的NAME标记命名CLASS等对象，所以最好给每个CLASS对象有一个适当的名称描述。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3.4 STYLE 对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　STYLE：&lt;/strong&gt;一个CLASS对象中可以定义多个style对象。可以通过一个style覆盖或重载其他style。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;CLOLR：&lt;/strong&gt;多边形的填充颜色。如果是线形（TYPE值为LINE），则表示线的颜色。COLOR是一个RGB格式颜色值。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;OUTLINECOLOR：&lt;/strong&gt;多边形的边线颜色。RGB颜色值格式。默认情况下，MapServer不会绘制多边形（TYPE值为POLYGON）的边线。如果你想查看多边形的边界，你需要在mapfile中定义OUTLINECOLOR参数。&lt;/p&gt;
&lt;p&gt;　　最后，你可以在mapfile中修改相关参数值，以便让你更加轻松的学习相关关键之的用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、根据用例创建自己实际运行的站点应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. 观察URL根据自己的实际情况加以调整&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1.1 新建一个自己的 &lt;strong&gt;Example1.1 A map with single layer&lt;/strong&gt; 站点&lt;/p&gt;
&lt;p&gt;　　　　　　根据map参数的相对路径是基于mapserv.exe的相对路径所决定的。我建议将站点建立在&lt;span&gt;E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\apps&lt;span&gt;目录下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　这样发布站点时，URL中的map参数可以为相对路径。mapfile中SHAPEPATH也使用相对路径比较方便。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　　　　　后续所有的案例均放在&lt;strong&gt;apps&lt;/strong&gt;文件夹下面，每个案例的命名规则为&lt;strong&gt;Example + section + 编号 + . + 案例编号&lt;/strong&gt;。所以第一节第一个案例的目录名称为：&lt;strong&gt;Example1.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在cmd中输入：cd /d &lt;span&gt;E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\apps&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在cmd中输入：md Example1.1&lt;/p&gt;
&lt;p&gt;　　　　　　在cmd中输入：cd  Example1.1&lt;/p&gt;
&lt;p&gt;　　　　　　在cmd中输入：cd.&amp;gt;web.config&lt;/p&gt;
&lt;p&gt;　　　　　　以上操作是创建相关文件夹以及web.config文件。&lt;/p&gt;
&lt;p&gt;　　　　　　在web.config文件呢中天下如下内容，配置FastCGI指向。（详情请参考《&lt;a href=&quot;https://www.cnblogs.com/eshinex/p/10272104.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;MapServer Configuring with IIS&lt;/strong&gt;&lt;/a&gt;》）　　　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;system.webServer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;handlers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;MapServerFastCgi&quot;&lt;/span&gt;&lt;span&gt; path&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt; verb&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; modules&lt;/span&gt;&lt;span&gt;=&quot;FastCgiModule&quot;&lt;/span&gt;&lt;span&gt; scriptProcessor&lt;/span&gt;&lt;span&gt;=&quot;E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\bin\mapserv.exe&quot;&lt;/span&gt;&lt;span&gt; resourceType&lt;/span&gt;&lt;span&gt;=&quot;Unspecified&quot;&lt;/span&gt;&lt;span&gt; requireAccess&lt;/span&gt;&lt;span&gt;=&quot;Script&quot;&lt;/span&gt;&lt;span&gt; allowPathInfo&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; preCondition&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;  &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;handlers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;caching &lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; enableKernelCache&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;system.webServer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　其中“scriptProcessor”的实际路径根据你安装的MapServer填写。&lt;/p&gt;

&lt;p&gt;　　　　　　站点的物理文件路径为：E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\apps\Example1.1&lt;/p&gt;
&lt;p&gt;　　　　　　端口为：8011&lt;/p&gt;
&lt;p&gt;　　　　　　应用程序池名称为：Example1.1&lt;/p&gt;

&lt;p&gt;　　　　1.2 配置当前 &lt;strong&gt;Example1.1 &lt;/strong&gt;站点&lt;/p&gt;
&lt;p&gt;　　　　　　其中，当前站点需要运行，涉及到：mapfile文件、shape文件等存放。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　在cmd中输入：cd /d E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\apps\Example1.1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　在cmd中输入：md data&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　在cmd中输入：md logs&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　在cmd中输入：cd.&amp;gt;example1_1.map&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　创建相关文件夹和数据存放文件夹，日志记录文件夹，以及Example1.1站点运行时调用MapServer的mapfile文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　将tutorial\data文件夹里面的states_ugl.dbf、states_ugl.shp、states_ugl.shx拷贝到“&lt;/span&gt;E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\apps\Example1.1\data&lt;/span&gt;&lt;span&gt;&lt;span&gt;”文件夹下面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　输入文件详见：&lt;a href=&quot;https://www.mapserver.org/input/vector/format_types.html&quot; target=&quot;_blank&quot;&gt;https://www.mapserver.org/input/vector/format_types.html&lt;/a&gt;。这里解释了上个文件的类型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　修改example1_1.map文件，内容如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;MAP
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  IMAGETYPE      PNG
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   EXTENT         -97.238976 41.619778 -82.122902 49.385620
&lt;span&gt; 4&lt;/span&gt;   SIZE           400 300
&lt;span&gt; 5&lt;/span&gt;   SHAPEPATH      &quot;./data&quot; #可以使exmaple1_1.map的相对路径，也可以是绝对路径 E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\apps\Example1.1&lt;span&gt;\data
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   IMAGECOLOR     255 255 255
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  LAYER 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    NAME         states
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    DATA         states_ugl
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    STATUS       OFF
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    TYPE         POLYGON
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    CLASS
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       NAME       &quot;The Upper Great Lakes States&quot;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      STYLE
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         COLOR        232 232 232
&lt;span&gt;19&lt;/span&gt;         OUTLINECOLOR 32 32 32
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;      END
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    END
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  END 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;   DEBUG 5 
&lt;span&gt;24&lt;/span&gt;   CONFIG &quot;MS_ERRORFILE&quot; &quot;logs\ms.log&quot;
&lt;span&gt;25&lt;/span&gt; END 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　　配置web站点程序池对日志文件读写权限&lt;/p&gt;
&lt;p&gt;　　　　 在cmd中输入：icacls &quot;E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\apps\Example1.1\logs&quot; /grant &quot;IIS AppPool\Example1.1&quot;:(OI)(CI)RW&lt;/p&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/249616/201901/249616-20190117105653565-970493587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　测试站点能否访问，在浏览器中输入：http://localhost:8011/mapserv?map=../apps/Example1.1/example1_1.map&amp;amp;layer=states&amp;amp;mode=map&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/249616/201901/249616-20190117213925942-1610817985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　  map=../apps/Example1.1/example1_1.map  表示 MapServer 与 mapfile （example1_1.map）的相对路径&lt;/p&gt;
&lt;p&gt;　　　　mapfile （example1_1.map）中 SHAPEPATH      &quot;./data&quot; 也是使用的相对路径。&lt;/p&gt;
&lt;p&gt;　　　　两处均使用了相对路径。这样URL显得比较安全，毕竟没有路径盘符信息了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在写此案例的过程中，遇到了一些相对路径的问题。修修改改，总算完成，其中也有很多不懂的知识，但是就像做题一样，做错了，就能马上知道自己错了。然后找答案，查询知识点。就能一一解决。&lt;/p&gt;
&lt;p&gt;　　下一篇按照大纲接续写。&lt;/p&gt;

</description>
<pubDate>Thu, 17 Jan 2019 13:56:00 +0000</pubDate>
<dc:creator>eshine</dc:creator>
<og:description>MapServer Tutorial——MapServer7.2.1教程学习——第一节用例实践：Example1.1 A map with single layer 一、前言 开始MapServer用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eshinex/p/10276449.html</dc:identifier>
</item>
<item>
<title>Shiro01 功能点框图、架构图、身份认证逻辑、身份认证代码实现 - 寻渝记</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/10284811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/10284811.html</guid>
<description>&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190117215343979-762673520.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;基本功能点&lt;/h2&gt;
&lt;h3 id=&quot;h-3&quot;&gt;功能点框图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190117214717210-1821257575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;功能点说明&lt;/h3&gt;
&lt;p&gt;1、Authentication：身份认证/登录，验证用户是不是拥有相应的身份；&lt;br/&gt;2、Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用 户对某个资源是否具有某个权限；&lt;br/&gt;3、SessionManager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信 息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；&lt;br/&gt;4、Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；&lt;br/&gt;5、Web Support：Web 支持，可以非常容易的集成到 Web 环境；&lt;br/&gt;6、Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；&lt;br/&gt;7、Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能 把权限自动传播过去；&lt;br/&gt;8、Testing：提供测试支持；&lt;br/&gt;9、Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；&lt;br/&gt;10、RememberMe：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。&lt;br/&gt;11、注意：Shiro 不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过 相应的接口注入给 Shiro 即可。&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;外部架构图&lt;/h3&gt;
&lt;p&gt;1、架构图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190117214833004-1504249113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、架构说明&lt;br/&gt;2.1、应用代码直接交互的对象是Subject， 也就是说Shiro的对外API核心就是Subject；&lt;br/&gt;2.2、应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager；&lt;br/&gt;2.3、我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法 的用户及其权限进行判断。&lt;br/&gt;3、API说明&lt;br/&gt;3.1、Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互 的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定 到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认 为是一个门面；SecurityManager 才是实际的执行者；&lt;br/&gt;3.2、SecurityManager：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互； 且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行 交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；&lt;br/&gt;3.3、Realm：域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看 成 DataSource，即安全数据源。&lt;br/&gt;4 注意：Shiro 不提供维护用户/权限，而是通过 Realm 让开发人员自己注入。&lt;/p&gt;
&lt;h3 id=&quot;h-6&quot;&gt;内部架构图&lt;/h3&gt;
&lt;p&gt;1、架构图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190117214855080-1683572851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、模块说明&lt;br/&gt;2.1、Subject：主体，可以看到主体可以是任何可以与应用交互的“用户”；&lt;br/&gt;2.2、SecurityManager ： 相当于 SpringMVC 中 的 DispatcherServlet 或者 Struts2 中 的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管 理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。&lt;br/&gt;2.3、Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的 不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户 认证通过了；&lt;br/&gt;2.4、Authrizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制 着用户能访问应用中的哪些功能；&lt;br/&gt;2.5、Realm：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；&lt;br/&gt;2.6、SessionManager：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理 它的生命周期，这个组件就是 SessionManager；而ShiroWeb环境，也 可以用在如普通的 JavaSE环境、EJB等环境；所有呢Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方， 这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；&lt;br/&gt;2.7、SessionDAO：DAO 大家都用过，数据访问对象，用 于 会话的 CRUD，比如我们想把 Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把 Session 放到 Memcached中，可以实现自己的MemcachedSessionDAO；另外SessionDAO 中可以使用 Cache 进行缓存，以提高性能；&lt;br/&gt;2.8、CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本 上很少去改变，放到缓存中后可以提高访问的性能；&lt;br/&gt;2.9、Cryptography：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密/解密的。&lt;/p&gt;
&lt;h2 id=&quot;h-7&quot;&gt;身份认证&lt;/h2&gt;
&lt;h3 id=&quot;h-8&quot;&gt;特殊名词&lt;/h3&gt;
&lt;p&gt;1、身份验证：即在应用中谁能证明他就是他本人。一般提供如他们的身份 ID 一些标识信息来 表明他就是他本人，如提供身份证，用户名/密码来证明。 在 shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能 验证用户身份：&lt;br/&gt;2、principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。 一个主体可以有多个 principals，但只有一个 Primary principals，一般是用户名/密码/手机号。&lt;br/&gt;3、credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。 最常见的 principals 和 credentials 组合就是用户名/密码了。接下来先进行一个基本的身份认 证。&lt;br/&gt;4、另外两个相关的概念是之前提到的Subject及Realm，分别是主体及验证主体的数据源。&lt;/p&gt;
&lt;h3&gt;认证逻辑（使用IniRealm）&lt;/h3&gt;
&lt;p&gt;1、通过一个ini文件来创建Realm&lt;br/&gt;2、接着获取 SecurityManager 并将Realm绑定到SecurityManager；&lt;br/&gt;3、将SecurityManager绑定到 SecurityUtils，这是一个全局设置，设置一次即可；&lt;br/&gt;4、通过 SecurityUtils 得到 Subject，其会自动绑定到当前线程；如果在 web 环境在请求结 束时需要解除绑定；然后获取身份验证的 Token，如用户名/密码；&lt;br/&gt;5、调用 subject.login 方法进行登录，其会自动委托给 SecurityManager.login 方法进行登录；&lt;br/&gt;6、如果身份验证失败请捕获 AuthenticationException 或 其 子类，常见的如： DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、 UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过 多）、IncorrectCredentialsException（错误的凭证）、ExpiredCredentialsException（过期的凭证）等，具体请查看其继承关系；对于页面的错误消息展示，最好使用如“用户名/密码 错误”而不是“用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库；&lt;br/&gt;7、最后可以调用 subject.logout 退出，其会自动委托给 SecurityManager.logout 方法退出。&lt;/p&gt;
&lt;h3 id=&quot;h-9&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;1、创建一个Maven工程，不同的maven工程即可，不需要时web工程&lt;br/&gt;2、引入junit、shiro依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;shiro-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;4.12&lt;/span&gt;&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、在resources目录下创建一个shiro.ini文件&lt;br/&gt;3.1、项目目录结构&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190117220512321-500384331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2、shiro.ini内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[users]
fury&lt;/span&gt;=&lt;span&gt;111111&lt;/span&gt;&lt;span&gt;
zeus&lt;/span&gt;=&lt;span&gt;222222&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4 测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xunyji.shirotest.kaitao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; jdk.nashorn.internal.parser.Token;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.SecurityUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.UsernamePasswordToken;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.mgt.DefaultSecurityManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.realm.text.IniRealm;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.subject.Subject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; AltEnter
 * @create 2019-01-17 14:58
 * @desc 认证
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestDemo01 {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDemo01() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        01 创建Realm&lt;/span&gt;
        IniRealm iniRealm = &lt;span&gt;new&lt;/span&gt; IniRealm(&quot;classpath:shiro.ini&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        02 创建SecurityManager并将Realm设置到SecurityManager中&lt;/span&gt;
        DefaultSecurityManager defaultSecurityManager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultSecurityManager();
        defaultSecurityManager.setRealm(iniRealm);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        03 将SecurityManager设置到SecurityUtils中&lt;/span&gt;
&lt;span&gt;        SecurityUtils.setSecurityManager(defaultSecurityManager);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        04 从SecurityUtils中获取Subject&lt;/span&gt;
        Subject subject =&lt;span&gt; SecurityUtils.getSubject();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        05 将用户名和用户密码封装成一个Token&lt;/span&gt;
        UsernamePasswordToken token = &lt;span&gt;new&lt;/span&gt; UsernamePasswordToken(&quot;fury&quot;, &quot;111111&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        06 通过Subject进行登录认证&lt;/span&gt;
&lt;span&gt;        subject.login(token);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        07 通过Subject判断登录认证结果&lt;/span&gt;
        System.out.println(String.format(&quot;用户名fury和密码111111的用户的认证结果为：%s&quot;&lt;span&gt;, subject.isAuthenticated()));
    } 

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;h-10&quot;&gt;认证总结&lt;/h4&gt;
&lt;p&gt;1、认证步骤&lt;br/&gt;1.1、收集用户身份/凭证，即如用户名/密码；&lt;br/&gt;1.2、调用 Subject.login 进行登录，如果失败将得到相应的 AuthenticationException 异常，根 据异常提示用户错误信息；否则登录成功；&lt;br/&gt;1.3、最后调用 Subject.logout 进行退出操作。&lt;br/&gt;2、改进方案&lt;br/&gt;2.1、用户名和密码硬编码在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储；&lt;br/&gt;2.2、用户身份Token可能不仅仅是用户名和密码，也可能还有其他的，如登录时允许用户名/ 邮箱/手机号同时登录。&lt;br/&gt;3、认证流程&lt;br/&gt;3.1、流程图&lt;br/&gt;认证外部流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190117215218581-303409201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;认证内部流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190117215144156-886832000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2、首先调用 Subject.login(token)进行登录，其会自动委托给 Security Manager，调用之前必 须通过 SecurityUtils. setSecurityManager()设置； 还需要为SecurityManager设置Realm；&lt;br/&gt;3.3、SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证；&lt;br/&gt;3.4、Authenticator才是真正的身份验证者，ShiroAPI中核心的身份认证入口点，此处可以自 定义插入自己的实现；&lt;br/&gt;3.5、Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证；&lt;br/&gt;3.6、Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返 回和抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进 行访问。&lt;br/&gt;4、技巧：从subject.login(token)往下查看源码就可以清楚地知道整个登录认证流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190117215519289-1157730046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 13:56:00 +0000</pubDate>
<dc:creator>寻渝记</dc:creator>
<og:description>基本功能点 功能点框图 功能点说明 1、Authentication：身份认证/登录，验证用户是不是拥有相应的身份； 2、Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/10284811.html</dc:identifier>
</item>
<item>
<title>万物互联之～网络编程深入篇 - 鲲逸鹏</title>
<link>http://www.cnblogs.com/dotnetcrazy/p/9612569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnetcrazy/p/9612569.html</guid>
<description>&lt;h2 id=&quot;3.RPC引入&quot;&gt;3.RPC引入&lt;a class=&quot;anchor-link&quot; href=&quot;http://www.cnblogs.com/dotnetcrazy/p/9612569.html#3.RPC引入&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上篇回顾：&lt;a href=&quot;https://mp.weixin.qq.com/s/KbiAz3Z3yyyKRHws1WW6vg&quot;&gt;万物互联之~深入篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他专栏最新篇：&lt;a href=&quot;https://mp.weixin.qq.com/s/Alv0Ds9LDvWbWSNgOgG43A&quot;&gt;协程加强之~兼容答疑篇&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/9887708.html&quot;&gt;聊聊数据库~SQL环境篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Code：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/python/6.net/6.rpc/&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/python/6.net/6.rpc/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;3.1.概念&quot;&gt;3.1.概念&lt;a class=&quot;anchor-link&quot; href=&quot;http://www.cnblogs.com/dotnetcrazy/p/9612569.html#3.1.概念&quot;&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RPC&lt;/code&gt;(&lt;code&gt;Remote Procedure Call&lt;/code&gt;)：分布式系统常见的一种通信方法（&lt;strong&gt;远程过程调用&lt;/strong&gt;），通俗讲：&lt;strong&gt;可以一台计算机的程序调用另一台计算机的子程序&lt;/strong&gt;（可以把它看成之前我们说的进程间通信，只不过这一次的进程不在同一台PC上了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;code&gt;RPC&lt;/code&gt;的设计思想是力图使远程调用中的通讯细节对于使用者透明，调用双方无需关心网络通讯的具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引用一张网上的图: &lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116092121587-579261271.png&quot; alt=&quot;1.rpc.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;HTTP&lt;/code&gt;有点相似，你可以这样理解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;老版本的&lt;code&gt;HTTP/1.0&lt;/code&gt;是短链接，而&lt;code&gt;RPC&lt;/code&gt;是长连接进行通信
&lt;ul&gt;&lt;li&gt;HTTP协议（header、body），RPC可以采取HTTP协议，也可以自定义二进制格式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;后来&lt;code&gt;HTTP/1.1&lt;/code&gt;支持了长连接(&lt;code&gt;Connection:keep-alive&lt;/code&gt;)，基本上和&lt;code&gt;RPC&lt;/code&gt;差不多了
&lt;ul&gt;&lt;li&gt;但&lt;strong&gt;&lt;code&gt;keep-alive&lt;/code&gt;一般都限制有最长时间，或者最多处理的请求数，而&lt;code&gt;RPC&lt;/code&gt;是基于长连接的，基本上没有这个限制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;后来谷歌直接基于&lt;code&gt;HTTP/2.0&lt;/code&gt;建立了&lt;code&gt;gRPC&lt;/code&gt;，它们之间的基本上也就差不多了
&lt;ul&gt;&lt;li&gt;如果硬是要区分就是：&lt;strong&gt;&lt;code&gt;HTTP-普通话&lt;/code&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;code&gt;RPC-方言&lt;/code&gt;&lt;/strong&gt;的区别了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RPC高效而小众，HTTP效率没RPC高，但更通用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PS：&lt;strong&gt;&lt;code&gt;RPC&lt;/code&gt;和&lt;code&gt;HTTP&lt;/code&gt;调用不用经过中间件，而是端到端的直接数据交互&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;网络交互可以理解为基于&lt;code&gt;Socket&lt;/code&gt;实现的（&lt;code&gt;RPC&lt;/code&gt;、&lt;code&gt;HTTP&lt;/code&gt;都是&lt;code&gt;Socket&lt;/code&gt;的读写操作）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单概括一下&lt;code&gt;RPC&lt;/code&gt;的优缺点就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;优点：
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;效率更高&lt;/strong&gt;（可以自定义二进制格式）&lt;/li&gt;
&lt;li&gt;发起RPC调用的一方，在编写代码时可忽略RPC的具体实现（&lt;strong&gt;跟编写本地函数调用一般&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通用性不如HTTP&lt;/strong&gt;（方言普及程度肯定不如普通话），如果传输协议不是HTTP协议格式，调用双方就需要专门实现通信库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PS：HTTP更多是&lt;code&gt;Client&lt;/code&gt;与&lt;code&gt;Server&lt;/code&gt;的通讯;&lt;code&gt;RPC&lt;/code&gt;更多是内部服务器间的通讯&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;3.2.引入&quot;&gt;3.2.引入&lt;a class=&quot;anchor-link&quot; href=&quot;http://www.cnblogs.com/dotnetcrazy/p/9612569.html#3.2.引入&quot;&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上面说这么多，可能还没有来个案例实在，我们看个案例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地调用&lt;code&gt;sum()&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;return a+b&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1+2={result}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;vm&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：（这个大家都知道）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1.xmlrpc案例&quot;&gt;1.xmlrpc案例&lt;a class=&quot;anchor-link&quot; href=&quot;http://www.cnblogs.com/dotnetcrazy/p/9612569.html#1.xmlrpc案例&quot;&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;官方文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://docs.python.org/3/library/xmlrpc.client.html
https://docs.python.org/3/library/xmlrpc.server.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都说&lt;code&gt;RPC&lt;/code&gt;用起来就像本地调用一样，那么用起来啥样呢？看个案例：&lt;/p&gt;
&lt;p&gt;服务端：(&lt;strong&gt;CentOS7：&lt;code&gt;192.168.36.123:50051&lt;/code&gt;&lt;/strong&gt;)&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;xmlrpc.server&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleXMLRPCServer&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;return a+b&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# PS：50051是gRPC默认端口&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleXMLRPCServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50051&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 把函数注册到RPC服务器中&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Server启动ing，Port：50051&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serve_forever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端：（&lt;strong&gt;Win10：&lt;code&gt;192.168.36.144&lt;/code&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;xmlrpc.client&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServerProxy&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServerProxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://192.168.36.123:50051&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1+2={result}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：（&lt;code&gt;Client&lt;/code&gt;用起来是不是和本地差不多？就是通过代理访问了下&lt;code&gt;RPCServer&lt;/code&gt;而已）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116103749140-1803787161.png&quot; alt=&quot;2.server.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;CentOS&lt;/code&gt;服务器不是你绑定个端口就一定能访问的，如果不能记让&lt;strong&gt;防火墙开放对应的端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个之前在说&lt;code&gt;MariaDB&lt;/code&gt;环境的时候有详细说：&lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/9887708.html#_map4&quot;&gt;https://www.cnblogs.com/dotnetcrazy/p/9887708.html#_map4&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# 添加 --permanent永久生效(没有此参数重启后失效)&lt;/span&gt;
firewall-cmd --zone&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;public --add-port&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;/tcp --permanent
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;2.ZeroRPC案例：&quot;&gt;2.ZeroRPC案例：&lt;a class=&quot;anchor-link&quot; href=&quot;http://www.cnblogs.com/dotnetcrazy/p/9612569.html#2.ZeroRPC案例：&quot;&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;zeroRPC用起来和这个差不多，也简单举个例子吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把服务的某个方法注册到&lt;code&gt;RPCServer&lt;/code&gt;中，供外部服务调用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;zerorpc&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;say_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hi，My Name is{name}&quot;&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# 注册一个Test的实例&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zerorpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tcp://0.0.0.0:50051&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;调用服务端代码&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;zerorpc&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zerorpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tcp://192.168.36.123:50051&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;say_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;RPC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3.3.简单版自定义RPC&quot;&gt;3.3.简单版自定义RPC&lt;a class=&quot;anchor-link&quot; href=&quot;http://www.cnblogs.com/dotnetcrazy/p/9612569.html#3.3.简单版自定义RPC&quot;&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;看了上面的引入案例，是不是感觉&lt;code&gt;RPC&lt;/code&gt;不过如此？NoNoNo，要是真这么简单也就谈不上&lt;code&gt;RPC架构&lt;/code&gt;了，上面两个是最简单的RPC服务了，可以这么说：生产环境基本上用不到，只能当案例练习罢了，对Python来说，最常用的RPC就两个&lt;strong&gt;&lt;code&gt;gRPC&lt;/code&gt; and &lt;code&gt;Thrift&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS：国产最出名的是&lt;strong&gt;&lt;code&gt;Dubbo&lt;/code&gt; and &lt;code&gt;Tars&lt;/code&gt;&lt;/strong&gt;，Net最常用的是&lt;code&gt;gRPC&lt;/code&gt;、&lt;code&gt;Thrift&lt;/code&gt;、&lt;code&gt;Surging&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;1.RPC服务的流程&quot;&gt;1.RPC服务的流程&lt;a class=&quot;anchor-link&quot; href=&quot;http://www.cnblogs.com/dotnetcrazy/p/9612569.html#1.RPC服务的流程&quot;&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;要自己实现一个&lt;code&gt;RPC Server&lt;/code&gt;那么就得了解整个流程了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;（调用者）以本地调用的方式发起调用&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;RPC&lt;/code&gt;服务进行&lt;strong&gt;远程过程调用&lt;/strong&gt;（RPC的目标就是要把这些步骤都封装起来，让使用者感觉不到这个过程）
&lt;ol&gt;&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件收到调用后，负责&lt;strong&gt;将被调用的&lt;code&gt;方法名、参数&lt;/code&gt;等打包编码成自定义的协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件在打包完成后通过网络把数据包发送给&lt;code&gt;RPC Server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件把通过网络接收到的数据包按照相应格式进行&lt;strong&gt;&lt;code&gt;拆包解码&lt;/code&gt;，获取方法名和参数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件&lt;strong&gt;根据方法名和参数进行本地调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;RPC Server&lt;/code&gt;&lt;/strong&gt;（被调用者）本地执行后将结果返回给服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件将返回值打包编码成自定义的协议数据包，并通过网络发送给客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件&lt;/li&gt;
&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件收到数据包后，进行拆包解码，把数据返回给&lt;code&gt;Client&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;（调用者）得到本次&lt;code&gt;RPC&lt;/code&gt;调用的返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用一张时序图来描述下整个过程： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116224934398-1277123948.png&quot; alt=&quot;4.时序图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;RPC Proxy&lt;/code&gt;有时候也叫&lt;code&gt;Stub&lt;/code&gt;（存根）：(Client Stub，Server Stub)&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;为屏蔽客户调用远程主机上的对象，必须提供某种方式来模拟本地对象,这种本地对象称为存根(stub),存根负责接收本地方法调用,并将它们委派给各自的具体实现对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PRC服务实现的过程中其实就两核心点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息协议：客户端调用的参数和服务端的返回值这些在网络上传输的数据以何种方式打包编码和拆包解码
&lt;ul&gt;&lt;li&gt;经典代表：&lt;strong&gt;&lt;code&gt;Protocol Buffers&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;传输控制：在网络中数据的收发传输控制具体如何实现（&lt;code&gt;TCP/UDP/HTTP&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;2.手写RPC&quot;&gt;2.手写RPC&lt;a class=&quot;anchor-link&quot; href=&quot;http://www.cnblogs.com/dotnetcrazy/p/9612569.html#2.手写RPC&quot;&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;下面我们就根据上面的流程来手写一个简单的RPC：&lt;/p&gt;
&lt;p&gt;1.Client调用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# client.py&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;client_stub&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClientStub&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClientStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;192.168.36.144&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50051&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sum&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1+2={result}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sum&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.1+2={result}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;time_str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;get_time&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;vm&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3
1.1+2=3.1
Wed Jan 16 22&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.Client Stub，客户端存根：(主要有&lt;code&gt;打包&lt;/code&gt;、&lt;code&gt;解包&lt;/code&gt;、和&lt;code&gt;RPC服务器通信&lt;/code&gt;的方法)&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;26&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# client_stub.py&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClientStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fm&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;address ==&amp;gt; (ip,port)&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;convert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;根据类型转换成对应的类型编号&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;打包：把方法和参数拼接成自定义的协议&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;        格式：func:函数名@params:类型-参数,类型2-参数2...&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;func:{func}&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# params:类型-参数,类型2-参数2...&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{self.convert(item)}-{item},&quot;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# 去除最后一个,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;@params:{params[:-1]}&quot;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# print(result)  # log 输出&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;解包：获取返回结果&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 格式应该是&quot;data:xxxx&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;1.客户端的RPC Proxy组件收到调用后，负责将被调用的方法名、参数等打包编码成自定义的协议&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 2.客户端的RPC Proxy组件在打包完成后通过网络把数据包发送给RPC Server&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 等待服务端返回结果&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简要说明下：（我根据流程在Code里面标注了，看起来应该很轻松）&lt;/p&gt;
&lt;p&gt;之前有说到核心其实就是&lt;code&gt;消息协议&lt;/code&gt;and&lt;code&gt;传输控制&lt;/code&gt;，我&lt;code&gt;客户端存根&lt;/code&gt;的消息协议是自定义的格式（后面会说简化方案）：&lt;strong&gt;&lt;code&gt;func:函数名@params:类型-参数,类型2-参数2...&lt;/code&gt;&lt;/strong&gt;，传输我是基于TCP进行了简单的封装&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;3.Server端：（实现很简单）&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# server.py&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;server_stub&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServerStub&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RPCServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fm&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mycode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mycode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mycode&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 服务端存根（RPC Proxy）&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server_stub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServerStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mycode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# TCP Socket&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 端口复用&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setsockopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOL_SOCKET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SO_REUSEADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 绑定端口&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# 等待客户端连接&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;client_socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;来自{client_addr}的请求：&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# 交给服务端存根（Server Proxy）处理&lt;/span&gt;
                &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server_stub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client_socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;vm&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;server_code&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyCode&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RPCServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50051&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Server启动ing，Port：50051&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了简洁，服务端代码我单独放在了&lt;code&gt;server_code.py&lt;/code&gt;中：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# 5.RPC Server（被调用者）本地执行后将结果返回给服务端的RPC Proxy&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.然后再看看重头戏&lt;code&gt;Server Stub&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;28&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# server_stub.py&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServerStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fm&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mycode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mycode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mycode&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;convert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;根据类型编号转换类型&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;3.服务端的RPC Proxy组件把通过网络接收到的数据包按照相应格式进行拆包解码，获取方法名和参数&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 格式应该是&quot;格式：func:函数名@params:类型编号-参数,类型编号2-参数2...&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;temps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# 类型转换&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;convert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# (func,args)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;打包：把方法和参数拼接成自定义的协议&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 格式：&quot;data:返回值&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;data:{result}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;sd&quot;&gt;&quot;&quot;&quot;4.服务端的RPC Proxy组件根据方法名和参数进行本地调用&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 如果没有这个方法则返回None&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;getattr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mycode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 解包&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 无参函数&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client_socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# 获取客户端发送的数据包&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client_socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 解包&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 执行无参函数&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 执行带参函数&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;RPC Server Error Code:500&quot;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;RPC Server Function Error&quot;&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# 6.服务端的RPC Proxy组件将返回值打包编码成自定义的协议数据包，并通过网络发送给客户端的RPC Proxy组件&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 把函数执行结果按指定协议打包&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# 把处理过的数据发送给客户端&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;client_socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;客户端：{client_addr}已断开&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再简要说明一下：&lt;strong&gt;里面方法其实主要就是&lt;code&gt;解包&lt;/code&gt;、&lt;code&gt;执行函数&lt;/code&gt;、&lt;code&gt;返回值打包&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出图示： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116223931438-2073811968.png&quot; alt=&quot;3.div.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再贴一下上面的时序图： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116224934398-1277123948.png&quot; alt=&quot;4.时序图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;课外拓展：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP1.0、HTTP1.1 和 HTTP2.0 的区别
https://www.cnblogs.com/heluan/p/8620312.html

简述分布式RPC框架
https://blog.csdn.net/jamebing/article/details/79610994

分布式基础—RPC
http://www.dataguru.cn/article-14244-1.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下节预估：&lt;strong&gt;RPC服务进一步简化与演变&lt;/strong&gt;、&lt;strong&gt;手写一个简单的REST接口&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 13:48:00 +0000</pubDate>
<dc:creator>鲲逸鹏</dc:creator>
<og:description>深入篇¶ 上节回顾：5种IO模型 | IO多路复用 and 万物互联之～网络编程加强篇 官方文档：https://docs.python.org/3/library/in</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnetcrazy/p/9612569.html</dc:identifier>
</item>
<item>
<title>第69节:Java中数据库的多表操作 - 达叔小生</title>
<link>http://www.cnblogs.com/dashucoding/p/10284710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashucoding/p/10284710.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-5a2a8af5a3f12a8f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;标题图&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;第69节:Java中数据库的多表操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;学习数据库的多表操作,去电商行业做项目吧!!!&lt;/p&gt;
&lt;p&gt;达叔，理工男，简书作者&amp;amp;全栈工程师，感性理性兼备的写作者，个人独立开发者，我相信你也可以！阅读他的文章，会上瘾！，帮你成为更好的自己。&lt;/p&gt;
&lt;p&gt;感谢！承蒙关照！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-296f246f472c93e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;字数&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据库的创建:&lt;br/&gt;&lt;code&gt;create database 数据库名 character set 字符集 collate 校对规则&lt;/code&gt;&lt;br/&gt;数据库的删除:&lt;br/&gt;&lt;code&gt;drop database 数据库名&lt;/code&gt;&lt;br/&gt;修改&lt;br/&gt;&lt;code&gt;alter database 数据库 character set 字符集&lt;/code&gt;&lt;br/&gt;查询&lt;br/&gt;&lt;code&gt;show databases&lt;/code&gt;&lt;br/&gt;&lt;code&gt;show create database 数据库的名字&lt;/code&gt;&lt;br/&gt;&lt;code&gt;select database();&lt;/code&gt; 当前数据库&lt;br/&gt;切换数据库&lt;br/&gt;&lt;code&gt;use&lt;/code&gt;数据库名字&lt;/p&gt;
&lt;p&gt;表操作:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table 表名(
 列名 列的类型 列的约束,
 列名 列的类型 列的约束
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;列的类型:&lt;br/&gt;&lt;code&gt;char/varchar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;列的约束&lt;br/&gt;&lt;code&gt;primary key&lt;/code&gt; 主键的约束&lt;br/&gt;&lt;code&gt;unique&lt;/code&gt; 唯一约素&lt;br/&gt;&lt;code&gt;not null&lt;/code&gt; 非空约素&lt;/p&gt;
&lt;p&gt;自动增加 &lt;code&gt;auto_increment&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除: &lt;code&gt;drop table&lt;/code&gt;表名&lt;br/&gt;修改: &lt;code&gt;alter table&lt;/code&gt;表名(&lt;code&gt;add, modify, change, drop&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;修改表名:&lt;br/&gt;&lt;code&gt;rename table&lt;/code&gt; 旧表名 &lt;code&gt;to&lt;/code&gt; 新表名&lt;br/&gt;&lt;code&gt;alter table 表名 character set 字符集&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查询:&lt;br/&gt;&lt;code&gt;show tables;&lt;/code&gt;查询所有表&lt;br/&gt;&lt;code&gt;show create table 表名;&lt;/code&gt; 查询表的定义,表的创建语句&lt;br/&gt;&lt;code&gt;desc&lt;/code&gt;用于查询表的结构&lt;/p&gt;
&lt;p&gt;表的插入:&lt;br/&gt;&lt;code&gt;insert into&lt;/code&gt; 表名(列名,列名) &lt;code&gt;values&lt;/code&gt; (值1,值2);&lt;br/&gt;表的删除:&lt;br/&gt;&lt;code&gt;delete from 表名 [where 条件]&lt;/code&gt;&lt;br/&gt;表的修改:&lt;br/&gt;&lt;code&gt;update 表名 set 列名='值', 列名='值' [where 条件];&lt;/code&gt;&lt;br/&gt;表的查询:&lt;br/&gt;&lt;code&gt;select [distinct] * [列名1,列名2] from 表名 [where 条件];&lt;/code&gt;&lt;br/&gt;&lt;code&gt;where&lt;/code&gt;的使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, !=, &amp;lt;&amp;gt;
is null is not null
in
between...and
and or not

like:
_:代表单个字符
%:代表多个字符

分组: group by
条件过滤: having

聚合函数:
sum();
avg();
count();
max();
min();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;排序:&lt;br/&gt;&lt;code&gt;order by&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;asc: 升序
desc: 降序&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;多表查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看数据库&lt;br/&gt;&lt;code&gt;show databases;&lt;/code&gt;&lt;br/&gt;创建数据库&lt;br/&gt;&lt;code&gt;create database dashu;&lt;/code&gt;&lt;br/&gt;使用数据库&lt;br/&gt;&lt;code&gt;use dashu;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多表之间的约束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多表间的关系如何维护:&lt;br/&gt;添加外键约束:&lt;br/&gt;&lt;code&gt;forerign key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;alter table product add foreign key(cno) references category(cid);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;product&lt;/code&gt;添加到&lt;code&gt;category&lt;/code&gt;里.&lt;code&gt;con&lt;/code&gt;等于&lt;code&gt;cid&lt;/code&gt;之间有关系.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;category
product&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果建立了表的外键约束,比如是产品,和产品分类,如果要删除产品分类,就要把产品分类对应产品的编码删除掉.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个项目建立一个数据库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多表之间的关系:&lt;br/&gt;一对多:商品和分类&lt;br/&gt;分类是1,商品是多.&lt;/p&gt;
&lt;p&gt;添加外键指向主键;&lt;br/&gt;口诀:在多的一方添加一个外键,指向一的一方的主键.&lt;/p&gt;
&lt;p&gt;多对多: 老师和学生,学生选课&lt;br/&gt;多对多的关系很难表示?&lt;br/&gt;口诀:多对多建表,多建一张中间表,中间表至少要有两个外建,这两个外键分别指向原来的那张表.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;就是把多对多的关系弄成一对多的关系.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中间表的关系就是一对多的关系,一个学生学课表,一对多.&lt;/p&gt;
&lt;p&gt;有两个外键以上,课表的编号对应学生.&lt;/p&gt;
&lt;p&gt;建表的原则是,多对多的关系,中间要建立一个中间表连接, 中间表的字段就是外键, 至少要有两个以上, 建表嘛, 至少两个字符, 将多对多的关系拆分成一对多的关系,然后分别指向原来的那两张表.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一对一的关系: 公民和身份证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一对一里添加一个外键指向&lt;code&gt;id&lt;/code&gt;主键,添加唯一约素,外键,&lt;code&gt;m-&amp;gt;1&lt;/code&gt;.一对一是当作一对多处理,在任意一张表中添加一个外键,并且指向另一张表.将两张表合并为一张,可以将两张表的主键建立起来,连接,并让两张表中的主键相等.&lt;/p&gt;
&lt;p&gt;拆表:&lt;/p&gt;
&lt;p&gt;用于将个人常用的信息和不常用的信息拆分出来,使得查询效率更好,提供更好用户的体验.在表关系里,多对多用得比较多,一对多,然后才一对一.&lt;/p&gt;
&lt;p&gt;用户表,订单表, 商品表,分类表&lt;/p&gt;
&lt;p&gt;用户表:&lt;br/&gt;用户ID&lt;br/&gt;用户名&lt;br/&gt;密码&lt;br/&gt;手机号&lt;/p&gt;
&lt;p&gt;订单表&lt;br/&gt;订单编号&lt;br/&gt;订单总价&lt;br/&gt;创建时间&lt;br/&gt;收货地址&lt;/p&gt;
&lt;p&gt;商品表&lt;br/&gt;商品编号&lt;br/&gt;商品名称&lt;br/&gt;商品价格&lt;/p&gt;
&lt;p&gt;商品分类&lt;br/&gt;分类ID&lt;br/&gt;分类名称&lt;br/&gt;分类描述&lt;/p&gt;
&lt;p&gt;用户id,地址&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用户表到订单表-&amp;gt;1对多&lt;/p&gt;
&lt;p&gt;订单表创建一个外键,然后指向用户id.&lt;/p&gt;
&lt;p&gt;商品表-&amp;gt;商品分类&lt;br/&gt;商品表中加外键-&amp;gt;指向商品分类的id&lt;/p&gt;
&lt;p&gt;订单表 和 商品表 -&amp;gt; 中间表&lt;br/&gt;一个订单可以买多个商品&lt;br/&gt;一个商品可以被多个用户去买,可以被多个订单所选择&lt;br/&gt;m对n:&lt;/p&gt;
&lt;p&gt;中间表 -&amp;gt; 外键约束多 -&amp;gt; 指向订单表 和 商品表为一.&lt;/p&gt;
&lt;p&gt;订单表 商品表&lt;/p&gt;
&lt;p&gt;中间表-&amp;gt; 订单编号 商品编号&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 用户表
create table user (
 uid int primary key auto_increment,
 username varchar(31),
 password varchar(31),
 phone varchar(11)
);

insert into user(1,'zhangsan','12345','13344442333');&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 订单表(订单编号,订单时间,总价,地址,外键
create table orders(
 oid int primary key auto_increment,
 sum int not null,
 otime timestamp,
 address varchar(100),
 uno int,
 foreign key(uno) references user(uid)
);

insert into orders values(1,200, null, '广州',1);
insert into orders values(2,300, null, '深圳',2);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 商品表
// 商品id,商品名称,商品价格,外键
create table product(
 pid int primary key auto_increment,
 pname varchar(10),
 price double,
 cno int,
 foreign key(cno) references category(cid)
);

// 添加商品
insert into product values(null, 'xiaomi', 233, 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 商品分类表
// 分类id,分类名称,分类描述
create table category(
 cid int primary key auto_increment,
 cname varchar(15),
 cdesc varchar(100)
);

insert into category values(null, '手机', '电子');&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;中间表,订单项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 中间表:订单id,商品id,商品数量,订单项总价
create table orderitem(
 ono int, // -&amp;gt; oid
 pno int, // -&amp;gt; pid

 foreign key (ono) references orders(oid),
 foreign key (pno) references product(pid)
 count int,
  subsum double
)

select * from orders;
select * from product;

// 订单 商品 商品数量 商品总价
insert into orderitem values(1,7,100,100);
insert into orderitem values(1,8,100,100);

// 添加商品
insert into orderitem values(2,5,1,100);
insert into orderitem values(2,3,100,100);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 多表之间关系的维护是由外键约束
foreign key
添加一个外键:
alter table product add foreign key (con) references category(cid);
foreign key (cno) references category (cid)

建表原则:
一对多:
口诀: 在多的一方添加外键并指向另一张表

多对多:
口诀: 将多对多的情况变成一对多的关系中间有一张中间表

一对一:多用于拆表
将两张表合并为一张表,将两张表的主键建立起关系,原理将一对一变成一对多去处理&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;主键和唯一约束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;唯一约素: 列里面的内容是唯一的,不能有重复的情况,但是可以为空.唯一约素是不能作为其它表的外键的,可以有多个唯一约素.&lt;/p&gt;
&lt;p&gt;主键约束是不能为空的,唯一.外键都是指向另外一张表的主键,一张表只能有一个主键.&lt;/p&gt;
&lt;p&gt;一对多:&lt;br/&gt;在多的一方添加一个外键指向另一方&lt;br/&gt;多对多:&lt;br/&gt;拆成一对多,中间创建一个表,至少有两个外键,指向原来的表&lt;br/&gt;一对一:&lt;br/&gt;合并一张表,将主键建立关系&lt;/p&gt;
&lt;p&gt;数据库软件&lt;br/&gt;&lt;code&gt;SQLyog&lt;/code&gt;和下载&lt;code&gt;mysql&lt;/code&gt;软件.&lt;br/&gt;架构设计器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;category
orderitem
orders
product
user&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// user 1-&amp;gt;m
uid
username
password
phone&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// orders
oid
sum
otime
address
uno

// orderitem
ono
pno
ocount
subsum

// product
pid
pname
price
cno&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//category
cid
cname
cdesc&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;多表查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;交叉连接查询
笛卡尔积:查出来的是两张表的乘积
select * from product,category cno = cid;
select * from product as p,category as c where p.cno = c.cid;
select * from product  p,category  c where p.cno = c.cid;

内连接查询
隐式内连接:
select * from product p, category c where p.cno = c.cid;
显示内连接
select * from product p inner join category c on p.con = c.cid;

区别:
1.在查询出结构的基础上去做的where条件过滤;
2.是带条件去查询结果的,执行效率高

// 添加数据
insert into product values(null,'dashujava',10,null);

左外连接
select * from product p left outer join category c on p.cno = c.cid;
左外连接会将左表中的所有数据都查出来,如果右表没有会用null代替.

// 右category 分类
insert into category values(100, '电脑', '详情');

右外连接
select * from product p right outer join category c on p.cno = c.cid;
右外连接是只要右边有就显示
右外连接会将右表的所有数据都查出来,如果左边没有会用null替代.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;分页查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select * from product limit 0,10;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;select * from product limit 0,3;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;select * from product limit 3,3;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;startindex = (index-1)*3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;计算启始索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-86a22d62f77bc6e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;左外连接&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from product
// 查询分类名为手机
select cid from category where cname='手机';
select * from product where cno=1;
子查询
select * from product where cno=(select cid from category where cname='手机');

// 查询信息
左连接:
select * from product  p left outer join category c on p.cno = c.cid;

// 子查询 商品名称, 商品分类名称
select pname, cno from product;
select pname, (select cname c from category where p.cno = c.cid) from product p;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;select max(sal) from emp;
select min(sal) from emp;

select * from emp where sal = (select max(sal) from emp);
select * from emp where sal = (select min(sal) from emp);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果看了觉得不错&lt;/p&gt;
&lt;p&gt;点赞！转发！&lt;/p&gt;
&lt;blockquote readability=&quot;6.6782608695652&quot;&gt;
&lt;p&gt;达叔小生：往后余生，唯独有你&lt;br/&gt;You and me, we are family !&lt;br/&gt;90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通&lt;br/&gt;简书博客： 达叔小生&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/u/c785ece603d1&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/u/c785ece603d1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注&lt;/li&gt;
&lt;li&gt;小礼物走一走 or 点赞&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 17 Jan 2019 13:40:00 +0000</pubDate>
<dc:creator>达叔小生</dc:creator>
<og:description>第69节:Java中数据库的多表操作 前言 学习数据库的多表操作,去电商行业做项目吧!!! 达叔，理工男，简书作者&amp;全栈工程师，感性理性兼备的写作者，个人独立开发者，我相信你也可以！阅读他的文章，会上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashucoding/p/10284710.html</dc:identifier>
</item>
</channel>
</rss>