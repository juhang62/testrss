<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白学 Python（10）：基础数据结构（列表）（下） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11769221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11769221.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191031084601098-91640900.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/12/2870915863/&quot;&gt;小白学 Python（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/13/2870915864/&quot;&gt;小白学 Python（2）：基础数据类型（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/15/25090937/&quot;&gt;小白学 Python（3）：基础数据类型（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/17/2392286754/&quot;&gt;小白学 Python（4）：变量基础操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/18/999362065/&quot;&gt;小白学 Python（5）：基础运算符（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/20/2416267271/&quot;&gt;小白学 Python（6）：基础运算符（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/22/979409150/&quot;&gt;小白学 Python（7）：基础流程控制（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/2184234984/&quot;&gt;小白学 Python（8）：基础流程控制（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/3066758654/&quot;&gt;小白学 Python（9）：基础数据结构（列表）（上）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;列表切片&quot;&gt;列表切片&lt;/h2&gt;
&lt;p&gt;一说到列表切片不知道各位同学有没有想起来前面我们讲过的字符串切片，没想起来的同学为自己的记忆默哀 3 秒钟吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191031084601380-1666012320.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开个玩笑：）可以返回去看看之前的文章。&lt;/p&gt;
&lt;p&gt;列表切片是指将列表其中的一部分切出来。&lt;/p&gt;
&lt;p&gt;语法： list[起始索引:终止索引:步长间隔]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这里的终止索引和字符串切片是一样的，并不会取到。&lt;/p&gt;
&lt;p&gt;下面直接上代码，解析已经添加在注释中。&lt;/p&gt;
&lt;p&gt;其实我就是懒，不想一条一条拆开写了，来打我呀~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191031084601537-1009890069.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 省略步长时默认为 1
print(list1[3:8])
# 步长为 2
print(list1[3:8:2])
# 从索引 3 开始取到最后
print(list1[3:])
# 从头开始取，取到索引 8 ，并且索引 8 娶不到
print(list1[:8])
# 取所有，步长为 3
print(list1[::3])
# 从索引 1 开始，取到倒数第 2 个，并且倒数第 2 个 取不到
print(list1[1:-2])
# 取所有
print(list1[:])
# 取逆序列表
print(list1[::-1])
# 取逆序，并且步长为 2
print(list1[8:1:-2])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[3, 4, 5, 6, 7]
[3, 5, 7]
[3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 3, 6, 9]
[1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[8, 6, 4, 2]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;列表常用方法&quot;&gt;列表常用方法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191031084601742-2102863351.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这里分别演示一下：&lt;/p&gt;
&lt;h3 id=&quot;list.appendobj&quot;&gt;list.append(obj)&lt;/h3&gt;
&lt;p&gt;在列表末尾添加新的对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list1.append(&quot;Python&quot;)
print(list1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'Python']&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list.countobj&quot;&gt;list.count(obj)&lt;/h3&gt;
&lt;p&gt;统计某个元素在列表中出现的次数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

list2.append(&quot;Python&quot;)
list2.append(&quot;Python&quot;)
list2.append(&quot;Python&quot;)
list2.append(1)
print(list2.count(&quot;Python&quot;))
print(list2.count(1))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3
2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里分别统计了字符串 &lt;code&gt;&quot;Python&quot;&lt;/code&gt; 和数字 &lt;code&gt;1&lt;/code&gt; 出现的次数。&lt;/p&gt;
&lt;h3 id=&quot;list.extendseq&quot;&gt;list.extend(seq)&lt;/h3&gt;
&lt;p&gt;在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list1.extend(list2)

print(list1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'Python', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'Python', 'Python', 'Python', 1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 list1 在经过 list2 的扩展后，同时含有了 list1 和 list2 的所有数据。&lt;/p&gt;
&lt;p&gt;extend 和 append 非常像，但是 extend 一次可以添加一个列表，而 append 一次只能添加一个元素。&lt;/p&gt;
&lt;h3 id=&quot;list.indexobj&quot;&gt;list.index(obj)&lt;/h3&gt;
&lt;p&gt;从列表中找出某个值第一个匹配项的索引位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(list1.index(&quot;Python&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list.insertindex-obj&quot;&gt;list.insert(index, obj)&lt;/h3&gt;
&lt;p&gt;将对象插入列表&lt;/p&gt;
&lt;p&gt;index 是插入的索引值， obj 是要插入的元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list1.insert(0, &quot;Hello&quot;)
print(list1)

list3 = [0, 1, 2]
list4 = [2, 2]
list3.insert(1, list4)
print(list3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['Hello', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'Python', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'Python', 'Python', 'Python', 1]
[0, [2, 2], 1, 2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然插入时可以是一个单独的元素，也可以是一个列表。&lt;/p&gt;
&lt;h3 id=&quot;list.popindex-1&quot;&gt;list.pop([index=-1])&lt;/h3&gt;
&lt;p&gt;移除列表中的一个元素（默认最后一个元素），并且返回该元素的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list3.pop()
print(list3)

list3.pop(1)
print(list3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0, [2, 2], 1]
[0, 1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样在移除索引的时候，可以移除一个元素，也可以移除一个列表。&lt;/p&gt;
&lt;h3 id=&quot;list.removeobj&quot;&gt;list.remove(obj)&lt;/h3&gt;
&lt;p&gt;移除列表中某个值的第一个匹配项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list5 = [1, 2, 3, 4, 4, 5]
list5.remove(4)
print(list5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1, 2, 3, 4, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list.reverse&quot;&gt;list.reverse()&lt;/h3&gt;
&lt;p&gt;反向列表中元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list5.reverse()
print(list5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[5, 4, 3, 2, 1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然我们刚才用步长为 -1 的形式同样做到了列表逆序，但是这两个操作是不一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list5 = [1, 2, 3, 4, 4, 5]
list5.remove(4)
print(list5)
print(id(list5))
list5.reverse()
print(list5)
print(id(list5))
print(id(list5[::-1]))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1, 2, 3, 4, 5]
2629333420040
[5, 4, 3, 2, 1]
2629333420040
2629333420104&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各位同学看明白了，通过步长获得的逆序列表实际上是一个新的列表，在内存的地址发生了变动，而通过 &lt;code&gt;list.reverse()&lt;/code&gt; 打印的逆序列表还是这个列表本身，它的内存地址并未发生改变。&lt;/p&gt;
&lt;h3 id=&quot;list.sort-keynone-reversefalse&quot;&gt;list.sort( key=None, reverse=False)&lt;/h3&gt;
&lt;p&gt;对原列表进行排序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list6 = [2, 5, 1, 9, 6, 3]
list6.sort()
print(list6)
list6.sort(reverse=True)
print(list6)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1, 2, 3, 5, 6, 9]
[9, 6, 5, 3, 2, 1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么样，对列表进行正序和逆序排序是不是很简单。&lt;/p&gt;
&lt;p&gt;后面还有两个方法 &lt;code&gt;list.clear()&lt;/code&gt; （清空列表） 和 &lt;code&gt;list.copy()&lt;/code&gt; （复制列表）我就不做演示，大家可以自己动手尝试一下，有不清楚的可以在公众号后台留言问我。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191031084601889-815066072.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-data-list&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/base-data-list&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Oct 2019 00:46:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我选Python 前文传送门 '小白学 Python（1）：开篇' '小白学 Python（2）：基础数据类型（上）' '小白学 Python（3）：基础数据类型（下）' '小白学 Pyth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11769221.html</dc:identifier>
</item>
<item>
<title>现在Java 桌面应用程序能做到什么程度（Spring Boot+JavaFX2开发） - pdai</title>
<link>http://www.cnblogs.com/pengdai/p/11769194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengdai/p/11769194.html</guid>
<description>&lt;h2 id=&quot;spring-boot---javafx-2.0应用&quot;&gt;Spring Boot - JavaFX 2.0应用&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;很多人对Java开发native程序第一反应还停留在暗灰色单一风格的Java GUI界面，开发方式还停留在AWT或者Swing。本文主要基于SpringBoot和JavaFX开发一个Demo给你展示Java Native应用可以做到什么样的程度。当然JavaFX 2.0没有流行起来也是有原因的，而且目前native的选择很多，前端是个框架都会搞个native... @pdai&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.3421052631579&quot;&gt;
&lt;p&gt;&lt;span&gt;最全的Java后端知识体系&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;https://www.pdai.tech&quot; class=&quot;uri&quot;&gt;https://www.pdai.tech&lt;/a&gt;&lt;/span&gt;, &lt;span&gt;每天更新中...&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;技术背景---java-8的新特性之javafx2.0&quot;&gt;技术背景 - Java 8的新特性之JavaFX2.0&lt;/h3&gt;
&lt;h4 id=&quot;全新现代主题modena&quot;&gt;全新现代主题：Modena&lt;/h4&gt;
&lt;p&gt;新的Modena主题来替换原来的Caspian主题。不过在Application的start()方法中，可以通过setUserAgentStylesheet(STYLESHEET_CASPIAN)来继续使用Caspian主题。&lt;/p&gt;
&lt;p&gt;参考http://fxexperience.com/2013/03/modena-theme-update/&lt;/p&gt;
&lt;h4 id=&quot;用于-css-结构的公共-api&quot;&gt;用于 CSS 结构的公共 API&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;CSS 样式设置是 JavaFX 的一项主要特性&lt;/li&gt;
&lt;li&gt;CSS 已专门在私有 API 中实现（com.sun.javafx.css 软件包）&lt;/li&gt;
&lt;li&gt;多种工具（例如 Scene Builder）需要 CSS 公共 API&lt;/li&gt;
&lt;li&gt;开发人员将能够定义自定义 CSS 样式&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;webview-增强功能&quot;&gt;WebView 增强功能&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Nashorn JavaScript 引擎 https://blogs.oracle.com/nashorn/entry/open_for_business&lt;/li&gt;
&lt;li&gt;WebSocket http://javafx-jira.kenai.com/browse/RT-14947&lt;/li&gt;
&lt;li&gt;Web Workers http://javafx-jira.kenai.com/browse/RT-9782&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;javafx-scene-builder-2.0&quot;&gt;JavaFX Scene Builder 2.0&lt;/h4&gt;
&lt;p&gt;可视化工具，加速JavaFX图形界面的开发:&lt;/p&gt;
&lt;p&gt;JavaFX Scene Builder如同NetBeans一般，通过拖拽的方式配置界面，待完成界面之後，保存为FXML格式文件，此文件以XML描述物件配置，再交由JavaFX程式处理，因此可減少直接以JavaFX编写界面的困難度。&lt;/p&gt;
&lt;p&gt;JavaFX Scene Builder 2.0新增JavaFX Theme预览功能，菜单「Preview」→「JavaFX Theme」选择不同的主題，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Modena (FX8).&lt;/li&gt;
&lt;li&gt;Modena Touch (FX8).&lt;/li&gt;
&lt;li&gt;Modena High Contrast – Black on White (FX8).&lt;/li&gt;
&lt;li&gt;Modena High Contrast – White on Black (FX8).&lt;/li&gt;
&lt;li&gt;Modena High Contrast – Yellow on Black (FX8).&lt;/li&gt;
&lt;li&gt;Caspian (FX2).&lt;/li&gt;
&lt;li&gt;Caspian Embedded (FX2).&lt;/li&gt;
&lt;li&gt;Caspian Embedded QVGA (FX2).&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;javafx-3d&quot;&gt;JavaFX 3D&lt;/h4&gt;
&lt;p&gt;在JavaFX8中提供了3D图像处理API，包括Shape3D (Box, Cylinder, MeshView, Sphere子类),SubScene, Material, PickResult, LightBase (AmbientLight 和PointLight子类),SceneAntialiasing等。Camera类也得到了更新。从JavaDoc中可以找到更多信息。&lt;/p&gt;
&lt;h4 id=&quot;富文本&quot;&gt;富文本&lt;/h4&gt;
&lt;p&gt;强化了富文本的支持&lt;/p&gt;
&lt;h4 id=&quot;treetableview&quot;&gt;TreeTableView&lt;/h4&gt;
&lt;p&gt;TreeTable支持&lt;/p&gt;
&lt;h4 id=&quot;日期控件datepicker&quot;&gt;日期控件DatePicker&lt;/h4&gt;
&lt;p&gt;增加日期控件&lt;/p&gt;
&lt;h3 id=&quot;spring-bootjavafx2-demo介绍&quot;&gt;Spring Boot+JavaFX2 Demo介绍&lt;/h3&gt;
&lt;h4 id=&quot;程序加载---loader&quot;&gt;程序加载 - Loader&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/spring/springboot-javafx-app-1.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;和web一样风格的gui&quot;&gt;和WEB一样风格的GUI&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/spring/springboot-javafx-app-2.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/spring/springboot-javafx-app-3.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;web应用嵌入---webview&quot;&gt;Web应用嵌入 - Webview&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/spring/springboot-javafx-app-4.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;多种主题切换---theme&quot;&gt;多种主题切换 - Theme&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/spring/springboot-javafx-app-5.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;消息及配置悬浮框---messageconfiguration...&quot;&gt;消息及配置悬浮框 - Message/Configuration...&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/spring/springboot-javafx-app-6.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;全屏最大化最小化---fullscreenmaxminclose&quot;&gt;全屏最大化最小化 - FullScreen/Max/Min/Close&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包括全屏是基于JavaFX的一个组件，不是原生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://www.pdai.tech/_images/spring/springboot-javafx-app-7.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;示例代码&quot;&gt;示例代码&lt;/h3&gt;
&lt;p&gt;@See https://github.com/realpdai/springboot-javafx-app-demo&lt;/p&gt;
</description>
<pubDate>Thu, 31 Oct 2019 00:38:00 +0000</pubDate>
<dc:creator>pdai</dc:creator>
<og:description>Spring Boot JavaFX 2.0应用 很多人对Java开发native程序第一反应还停留在暗灰色单一风格的Java GUI界面，开发方式还停留在AWT或者Swing。本文主要基于Sprin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pengdai/p/11769194.html</dc:identifier>
</item>
<item>
<title>Spring Cloud 网关服务 zuul 三 动态路由 - 程序员你大爷</title>
<link>http://www.cnblogs.com/cloudxlr/p/11769195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudxlr/p/11769195.html</guid>
<description>&lt;h3 id=&quot;zuul动态路由&quot;&gt;zuul动态路由&lt;/h3&gt;
&lt;p&gt;网关服务是流量的唯一入口。不能随便停服务。所以动态路由就显得尤为必要。&lt;/p&gt;
&lt;p&gt;数据库动态路由基于事件刷新机制热修改zuul的路由属性。&lt;/p&gt;
&lt;h4 id=&quot;discoveryclientroutelocator&quot;&gt;DiscoveryClientRouteLocator&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1848187/201910/1848187-20191031083759773-317284655.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到DiscoveryClientRouteLocator 是默认的刷新的核心处理类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
//重新加载路由信息方法 protected方法。需要子方法重新方法。
protected LinkedHashMap&amp;lt;String, ZuulRoute&amp;gt; locateRoutes() 

//触发刷新的方法  RefreshableRouteLocator 接口
 public void refresh() {
            this.doRefresh();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而这俩个方法都是继承与SimpleRouteLocator 类，并进行了重新操作。其实官方的方法注释说明了。如果需要动态读取加载映射关系。则需要子类重写这俩个方法。&lt;br/&gt;进行具体的实现&lt;/p&gt;
&lt;p&gt;首先pom jar包导入 需要连接mysql 数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- jdbc --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路由实体 ZuulRouteEntity&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xian.cloud.entity;

import lombok.Data;

import java.io.Serializable;
import java.util.Date;

/**
 * &amp;lt;Description&amp;gt; 路由实体类
 *
 * @author xianliru@100tal.com
 * @version 1.0
 * @createDate 2019/10/30 15:00
 */
@Data
public class ZuulRouteEntity implements Serializable {
    private static final long serialVersionUID = 1L;

    /**
     * router Id
     */
    private Integer id;
    /**
     * 路由路径
     */
    private String path;
    /**
     * 服务名称
     */
    private String serviceId;
    /**
     * url代理
     */
    private String url;
    /**
     * 转发去掉前缀
     */
    private String stripPrefix;
    /**
     * 是否重试
     */
    private String retryable;
    /**
     * 是否启用
     */
    private String enabled;
    /**
     * 敏感请求头
     */
    private String sensitiveheadersList;
    /**
     * 创建时间
     */
    private Date createTime;
    /**
     * 更新时间
     */
    private Date updateTime;
    /**
     * 删除标识（0-正常,1-删除）
     */
    private String delFlag;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建DiscoveryRouteLocator 类 父类 接口 都不变化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.xian.cloud.router;


import com.google.common.base.Strings;
import com.google.common.collect.Sets;
import com.xian.cloud.entity.ZuulRoute;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.netflix.zuul.filters.RefreshableRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.ZuulProperties;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.util.StringUtils;

import java.util.*;

/**
 * &amp;lt;Description&amp;gt;
 *
 * @author xianliru@100tal.com
 * @version 1.0
 * @createDate 2019/10/30 18:57
 */
@Slf4j
public class DiscoveryRouteLocator extends SimpleRouteLocator implements RefreshableRouteLocator {

    private ZuulProperties properties;

    private JdbcTemplate jdbcTemplate;

    public DiscoveryRouteLocator(String servletPath, ZuulProperties properties, JdbcTemplate jdbcTemplate) {
        super(servletPath, properties);
        this.properties = properties;
        this.jdbcTemplate = jdbcTemplate;
        log.info(&quot;servletPath:{}&quot;,servletPath);
    }

    @Override
    public void refresh() {
        doRefresh();
    }

    @Override
    protected Map&amp;lt;String, ZuulProperties.ZuulRoute&amp;gt; locateRoutes() {
        LinkedHashMap&amp;lt;String, ZuulProperties.ZuulRoute&amp;gt; routesMap = new LinkedHashMap&amp;lt;String, ZuulProperties.ZuulRoute&amp;gt;();
        //从配置文件中加载路由信息
        routesMap.putAll(super.locateRoutes());
        //自定义加载路由信息
        routesMap.putAll(getRouteList());
        //优化一下配置
        LinkedHashMap&amp;lt;String, ZuulProperties.ZuulRoute&amp;gt; values = new LinkedHashMap&amp;lt;&amp;gt;();
        for (Map.Entry&amp;lt;String, ZuulProperties.ZuulRoute&amp;gt; entry : routesMap.entrySet()) {
            String path = entry.getKey();
            // Prepend with slash if not already present.
            if (!path.startsWith(&quot;/&quot;)) {
                path = &quot;/&quot; + path;
            }
            if (StringUtils.hasText(this.properties.getPrefix())) {
                path = this.properties.getPrefix() + path;
                if (!path.startsWith(&quot;/&quot;)) {
                    path = &quot;/&quot; + path;
                }
            }
            values.put(path, entry.getValue());
        }
        return values;
    }

    /**
     * 从数据库读取zuul路由规则
     * @return
     */
   private LinkedHashMap&amp;lt;String, ZuulProperties.ZuulRoute&amp;gt; getRouteList() {
        LinkedHashMap&amp;lt;String, ZuulProperties.ZuulRoute&amp;gt; zuulRoutes = new LinkedHashMap&amp;lt;&amp;gt;();
        List&amp;lt;ZuulRoute&amp;gt; sysZuulRoutes = jdbcTemplate.query(&quot;select * from sys_zuul_route where del_flag = 0&quot;, new BeanPropertyRowMapper&amp;lt;&amp;gt;(ZuulRoute.class));

       for (ZuulRoute route: sysZuulRoutes) {

           // 为空跳过
           if (Strings.isNullOrEmpty(route.getPath()) &amp;amp;&amp;amp; Strings.isNullOrEmpty(route.getUrl())) {
               continue;
           }

           ZuulProperties.ZuulRoute zuulRoute = new ZuulProperties.ZuulRoute();
           try {
               zuulRoute.setId(route.getServiceId());
               zuulRoute.setPath(route.getPath());
               zuulRoute.setServiceId(route.getServiceId());
               zuulRoute.setRetryable(Objects.equals(&quot;0&quot;, route.getRetryable()) ? Boolean.FALSE : Boolean.TRUE);
               zuulRoute.setStripPrefix(Objects.equals(&quot;0&quot;, route.getStripPrefix()) ? Boolean.FALSE : Boolean.TRUE);
               zuulRoute.setUrl(route.getUrl());
               List&amp;lt;String&amp;gt; sensitiveHeadersList = Arrays.asList(route.getSensitiveheadersList().split(&quot;,&quot;));
               if (sensitiveHeadersList != null) {
                   Set&amp;lt;String&amp;gt; sensitiveHeaderSet = Sets.newHashSet();
                   sensitiveHeadersList.forEach(sensitiveHeader -&amp;gt; sensitiveHeaderSet.add(sensitiveHeader));
                   zuulRoute.setSensitiveHeaders(sensitiveHeaderSet);
                   zuulRoute.setCustomSensitiveHeaders(true);
               }
           } catch (Exception e) {
               log.error(&quot;数据库加载配置异常&quot;, e);
           }
           log.info(&quot;自定义的路由配置,path：{}，serviceId:{}&quot;, zuulRoute.getPath(), zuulRoute.getServiceId());
           zuulRoutes.put(zuulRoute.getPath(), zuulRoute);

       }
        return zuulRoutes;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还需要一个事件的生产者 和 消费者 直接图方便 集成到一个类中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xian.cloud.event;

import com.xian.cloud.router.DiscoveryRouteLocator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.discovery.event.HeartbeatEvent;
import org.springframework.cloud.client.discovery.event.HeartbeatMonitor;
import org.springframework.cloud.context.scope.refresh.RefreshScopeRefreshedEvent;
import org.springframework.cloud.netflix.zuul.RoutesRefreshedEvent;
import org.springframework.cloud.netflix.zuul.web.ZuulHandlerMapping;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Service;

/**
 * &amp;lt;Description&amp;gt; 路由刷新事件发布，与事件监听者
 *
 * @author xianliru@100tal.com
 * @version 1.0
 * @createDate 2019/10/30 15:27
 */
@Service
public class RefreshRouteService implements ApplicationListener&amp;lt;ApplicationEvent&amp;gt; {

    @Autowired
    private ZuulHandlerMapping zuulHandlerMapping;

    private HeartbeatMonitor heartbeatMonitor = new HeartbeatMonitor();

    @Autowired
    ApplicationEventPublisher publisher;

    @Autowired
    private DiscoveryRouteLocator dynamicRouteLocator;

    /**
     * 动态路由实现 调用refreshRoute() 发布刷新路由事件
     */
    public void refreshRoute() {
        RoutesRefreshedEvent routesRefreshedEvent = new RoutesRefreshedEvent(dynamicRouteLocator);
        publisher.publishEvent(routesRefreshedEvent);
    }

    /**
     * 事件监听者。监控检测事件刷新
     * @param event
     */
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if(event instanceof ContextRefreshedEvent || event instanceof RefreshScopeRefreshedEvent || event instanceof RoutesRefreshedEvent){
            //主动手动刷新。上下文刷新，配置属性刷新
            zuulHandlerMapping.setDirty(true);
        }else if(event instanceof HeartbeatEvent){
            //心跳触发，将本地映射关系。关联到远程服务上
            HeartbeatEvent heartbeatEvent = (HeartbeatEvent)event;
            if(heartbeatMonitor.update(heartbeatEvent.getValue())){
                zuulHandlerMapping.setDirty(true);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对外提供触发接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xian.cloud.controller;

import com.xian.cloud.event.RefreshRouteService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * &amp;lt;Description&amp;gt; 手动刷新对外接口
 *
 * @author xianliru@100tal.com
 * @version 1.0
 * @createDate 2019/10/30 20:23
 */
@RestController
public class RefreshController {

    @Autowired
    private RefreshRouteService refreshRouteService;

    @GetMapping(&quot;/refresh&quot;)
    public String refresh() {
        refreshRouteService.refreshRoute();
        return &quot;refresh&quot;;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库表结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE `sys_zuul_route` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'router Id',
  `path` varchar(255) NOT NULL COMMENT '路由路径',
  `service_id` varchar(255) NOT NULL COMMENT '服务名称',
  `url` varchar(255) DEFAULT NULL COMMENT 'url代理',
  `strip_prefix` char(1) DEFAULT '1' COMMENT '转发去掉前缀',
  `retryable` char(1) DEFAULT '1' COMMENT '是否重试',
  `enabled` char(1) DEFAULT '1' COMMENT '是否启用',
  `sensitiveHeaders_list` varchar(255) DEFAULT NULL COMMENT '敏感请求头',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `del_flag` char(1) DEFAULT '0' COMMENT '删除标识（0-正常,1-删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='动态路由配置表'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1848187/201910/1848187-20191031083759968-1480622529.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将配置文件client 消费者服务 路由配置注释掉。设置数据源。从数据库中读取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1848187/201910/1848187-20191031083800506-1539850176.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动服务打印日志&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019-10-30 20:49:39.946  INFO 63449 --- [TaskScheduler-1] c.xian.cloud.router.DynamicRouteLocator  : 添加数据库自定义的路由配置,path：/client/**，serviceId:cloud-discovery-client
2019-10-30 20:49:40.397  INFO 63449 --- [TaskScheduler-1] c.xian.cloud.router.DynamicRouteLocator  : 添加数据库自定义的路由配置,path：/client/**，serviceId:cloud-discovery-client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;postman 请求client 接口 看看是否能转发成功&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1848187/201910/1848187-20191031083801092-1534584784.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于zuul 动态网关路由完成。&lt;/p&gt;
&lt;p&gt;后续还会更新网关的灰度方案、swagger2 整合的调试源服务。敬请期待！&lt;/p&gt;
&lt;p&gt;摘自参考 &lt;a href=&quot;https://cloud.spring.io/&quot;&gt;spring cloud 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考书籍 重新定义spring cloud实战&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HPxianliru/Spring-cloud-alibaba-basis/&quot;&gt;示例代码地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;服务器nacos 地址 http://47.99.209.72:8848/nacos&lt;/p&gt;
&lt;p&gt;往期地址 spring cloud alibaba 地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/16e2466f7177&quot;&gt;spring cloud alibaba 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/1f573a642118&quot;&gt;Spring Cloud Alibaba (nacos 注册中心搭建)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/0f7fe16c06b2&quot;&gt;Spring Cloud Alibaba 使用nacos 注册中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/ca0f9ee38087&quot;&gt;Spring Cloud Alibaba nacos 配置中心使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/146d66ab4e31&quot;&gt;spring cloud 网关服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/31627176d2a2&quot;&gt;Spring Cloud zuul网关服务 一&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/494c39e1b0e2&quot;&gt;Spring Cloud 网关服务 zuul 二&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如何喜欢可以关注分享本公众号。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1848187/201910/1848187-20191031083801855-542905441.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。转载请附带公众号二维码&lt;/p&gt;
</description>
<pubDate>Thu, 31 Oct 2019 00:38:00 +0000</pubDate>
<dc:creator>程序员你大爷</dc:creator>
<og:description>zuul动态路由 网关服务是流量的唯一入口。不能随便停服务。所以动态路由就显得尤为必要。 数据库动态路由基于事件刷新机制热修改zuul的路由属性。 DiscoveryClientRouteLocato</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cloudxlr/p/11769195.html</dc:identifier>
</item>
<item>
<title>【Go】高效截取字符串的一些思考 - 戚银</title>
<link>http://www.cnblogs.com/thinkeridea/p/11769190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkeridea/p/11769190.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.thinkeridea.com/201910/go/efficient_string_truncation.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201910/go/efficient_string_truncation.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近我在 &lt;a href=&quot;https://forum.golangbridge.org&quot;&gt;Go Forum&lt;/a&gt; 中发现了 &lt;a href=&quot;https://forum.golangbridge.org/t/solved-string-size-of-20-character/15783&quot;&gt;[SOLVED] String size of 20 character&lt;/a&gt; 的问题，“&lt;strong&gt;hollowaykeanho&lt;/strong&gt;” 给出了相关的答案，而我从中发现了截取字符串的方案并非最理想的方法，因此做了一系列实验并获得高效截取字符串的方法，这篇文章将逐步讲解我实践的过程。&lt;/p&gt;
&lt;h2 id=&quot;字节切片截取&quot;&gt;字节切片截取&lt;/h2&gt;
&lt;p&gt;这正是 “&lt;strong&gt;hollowaykeanho&lt;/strong&gt;” 给出的第一个方案，我想也是很多人想到的第一个方案，利用 go 的内置切片语法截取字符串：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;s := &quot;abcdef&quot;
fmt.Println(s[1:4])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们很快就了解到这是按字节截取，在处理 &lt;code&gt;ASCII&lt;/code&gt; 单字节字符串截取，没有什么比这更完美的方案了，中文往往占多个字节，在 &lt;code&gt;utf8&lt;/code&gt; 编码中是3个字节，如下程序我们将获得乱码数据：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;s := &quot;Go 语言&quot;
fmt.Println(s[1:4])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;杀手锏---类型转换-rune&quot;&gt;杀手锏 - 类型转换 []rune&lt;/h2&gt;
&lt;p&gt;“&lt;strong&gt;hollowaykeanho&lt;/strong&gt;” 给出的第二个方案就是将字符串转换为 &lt;code&gt;[]rune&lt;/code&gt;，然后按切片语法截取，再把结果转成字符串。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;s := &quot;Go 语言&quot;
rs := []rune(s)
fmt.Println(strings(rs[1:4]))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们得到了正确的结果，这是最大的进步。不过我对类型转换一直比较谨慎，我担心它的性能问题，因此我尝试在搜索引擎和各大论坛查找答案，但是我得到最多的还是这个方案，似乎这已经是唯一的解。&lt;/p&gt;
&lt;p&gt;我尝试写个性能测试评测它的性能：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package benchmark

import (
    &quot;testing&quot;
)

var benchmarkSubString = &quot;Go语言是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。为了方便搜索和识别，有时会将其称为Golang。&quot;
var benchmarkSubStringLength = 20

func SubStrRunes(s string, length int) string {
    if utf8.RuneCountInString(s) &amp;gt; length {
        rs := []rune(s)
        return string(rs[:length])
    }

    return s
}

func BenchmarkSubStrRunes(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        SubStrRunes(benchmarkSubString, benchmarkSubStringLength)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我得到了让我有些吃惊的结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark
BenchmarkSubStrRunes-8            872253              1363 ns/op             336 B/op          2 allocs/op
PASS
ok      github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark     2.120s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对 69 个的字符串截取前 20 个字符需要大概 1.3 微秒，这极大的超出了我的心里预期，我发现因为类型转换带来了内存分配，这产生了一个新的字符串，并且类型转换需要大量的计算。&lt;/p&gt;
&lt;h2 id=&quot;救命稻草---utf8.decoderuneinstring&quot;&gt;救命稻草 - utf8.DecodeRuneInString&lt;/h2&gt;
&lt;p&gt;我想改善类型转换带来的额外运算和内存分配，我仔细的梳理了一遍 &lt;code&gt;strings&lt;/code&gt; 包，发现并没有相关的工具，这时我想到了 &lt;code&gt;utf8&lt;/code&gt; 包，它提供了多字节计算相关的工具，实话说我对它并不熟悉，或者说没有主动（直接）使用过它，我查看了它所有的文档发现 &lt;code&gt;utf8.DecodeRuneInString&lt;/code&gt; 函数可以转换单个字符，并给出字符占用字节的数量，我尝试了如此下的实验：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package benchmark

import (
    &quot;testing&quot;
    &quot;unicode/utf8&quot;
)

var benchmarkSubString = &quot;Go语言是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。为了方便搜索和识别，有时会将其称为Golang。&quot;
var benchmarkSubStringLength = 20

func SubStrDecodeRuneInString(s string, length int) string {
    var size, n int
    for i := 0; i &amp;lt; length &amp;amp;&amp;amp; n &amp;lt; len(s); i++ {
        _, size = utf8.DecodeRuneInString(s[n:])
        n += size
    }

    return s[:n]
}

func BenchmarkSubStrDecodeRuneInString(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        SubStrDecodeRuneInString(benchmarkSubString, benchmarkSubStringLength)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行它之后我得到了令我惊喜的结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark
BenchmarkSubStrDecodeRuneInString-8     10774401               105 ns/op               0 B/op          0 allocs/op
PASS
ok      github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark     1.250s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;较 &lt;code&gt;[]rune&lt;/code&gt; 类型转换效率提升了 &lt;strong&gt;13倍&lt;/strong&gt;，消除了内存分配，它的确令人激动和兴奋，我迫不及待的回复了 “&lt;strong&gt;hollowaykeanho&lt;/strong&gt;” 告诉他我发现了一个更好的方法，并提供了相关的性能测试。&lt;/p&gt;
&lt;p&gt;我有些小激动，兴奋的浏览着论坛里各种有趣的问题，在查看一个问题的帮助时 (忘记是哪个问题了-_-||) ，我惊奇的发现了另一个思路。&lt;/p&gt;
&lt;h2 id=&quot;良药不一定苦---range-字符串迭代&quot;&gt;良药不一定苦 - range 字符串迭代&lt;/h2&gt;
&lt;p&gt;许多人似乎遗忘了 &lt;code&gt;range&lt;/code&gt; 是按字符迭代的，并非字节。使用 &lt;code&gt;range&lt;/code&gt; 迭代字符串时返回字符起始索引和对应的字符，我立刻尝试利用这个特性编写了如下用例：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;package benchmark

import (
    &quot;testing&quot;
)

var benchmarkSubString = &quot;Go语言是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。为了方便搜索和识别，有时会将其称为Golang。&quot;
var benchmarkSubStringLength = 20

func SubStrRange(s string, length int) string {
    var n, i int
    for i = range s {
        if n == length {
            break
        }

        n++
    }

    return s[:i]
}

func BenchmarkSubStrRange(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        SubStrRange(benchmarkSubString, benchmarkSubStringLength)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我尝试运行它，这似乎有着无穷的魔力，结果并没有令我失望。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark
BenchmarkSubStrRange-8          12354991                91.3 ns/op             0 B/op          0 allocs/op
PASS
ok      github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark     1.233s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它仅仅提升了13%，但它足够的简单和易于理解，这似乎就是我苦苦寻找的那味良药。&lt;/p&gt;
&lt;p&gt;如果你以为这就结束了，不、这对我来只是探索的开始。&lt;/p&gt;
&lt;h2 id=&quot;终极时刻---自己造轮子&quot;&gt;终极时刻 - 自己造轮子&lt;/h2&gt;
&lt;p&gt;喝了 &lt;code&gt;range&lt;/code&gt; 那碗甜的腻人的良药，我似乎冷静下来了，我需要造一个轮子，它需要更易用，更高效。&lt;/p&gt;
&lt;p&gt;于是乎我仔细观察了两个优化方案，它们似乎都是为了查找截取指定长度字符的索引位置，如果我可以提供一个这样的方法，是否就可以提供用户一个简单的截取实现 &lt;code&gt;s[:strIndex(20)]&lt;/code&gt; ，这个想法萌芽之后我就无法再度摆脱，我苦苦思索两天来如何来提供易于使用的接口。&lt;/p&gt;
&lt;p&gt;之后我创造了 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exunicode/exutf8#RuneIndexInString&quot;&gt;exutf8.RuneIndexInString&lt;/a&gt; 和 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exunicode/exutf8#RuneIndex&quot;&gt;exutf8.RuneIndex&lt;/a&gt; 方法，分别用来计算字符串和字节切片中指定字符数量结束的索引位置。&lt;/p&gt;
&lt;p&gt;我用 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exunicode/exutf8#RuneIndexInString&quot;&gt;exutf8.RuneIndexInString&lt;/a&gt; 实现了一个字符串截取测试：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package benchmark

import (
    &quot;testing&quot;
    &quot;unicode/utf8&quot;

    &quot;github.com/thinkeridea/go-extend/exunicode/exutf8&quot;
)

var benchmarkSubString = &quot;Go语言是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。为了方便搜索和识别，有时会将其称为Golang。&quot;
var benchmarkSubStringLength = 20

func SubStrRuneIndexInString(s string, length int) string {
    n, _ := exutf8.RuneIndexInString(s, length)
    return s[:n]
}

func BenchmarkSubStrRuneIndexInString(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        SubStrRuneIndexInString(benchmarkSubString, benchmarkSubStringLength)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尝试运行它，我对结果感到十分欣慰：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark
BenchmarkSubStrRuneIndexInString-8      13546849                82.4 ns/op             0 B/op          0 allocs/op
PASS
ok      github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark     1.213s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性能较 &lt;code&gt;range&lt;/code&gt; 提升了 10%，让我很欣慰可以再次获得新的提升，这证明它是有效的。&lt;/p&gt;
&lt;p&gt;它足够的高效，但是却不够易用，我截取字符串需要两行代码，如果我想截取 10~20之间的字符就需要4行代码，这并不是用户易于使用的接口，我参考了其它语言的 &lt;code&gt;sub_string&lt;/code&gt; 方法，我想我应该也设计一个这个样的接口给用户。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exunicode/exutf8#RuneSubString&quot;&gt;exutf8.RuneSubString&lt;/a&gt; 和 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exunicode/exutf8#RuneSub&quot;&gt;exutf8.RuneSub&lt;/a&gt; 是我认真思索后编写的方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;func RuneSubString(s string, start, length int) string&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它有三个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;s&lt;/code&gt; : 输入的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt; : 开始截取的位置，如果 start 是非负数，返回的字符串将从 string 的 start 位置开始，从 0 开始计算。例如，在字符串 “abcdef” 中，在位置 0 的字符是 “a”，位置 2 的字符串是 “c” 等等。 如果 start 是负数，返回的字符串将从 string 结尾处向前数第 start 个字符开始。 如果 string 的长度小于 start，将返回空字符串。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;length&lt;/code&gt;：截取的长度，如果提供了正数的 length，返回的字符串将从 start 处开始最多包括 length 个字符（取决于 string 的长度）。 如果提供了负数的 length，那么 string 末尾处的 length 个字符将会被省略（若 start 是负数则从字符串尾部算起）。如果 start 不在这段文本中，那么将返回空字符串。 如果提供了值为 0 的 length，返回的子字符串将从 start 位置开始直到字符串结尾。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我为他们提供了别名，根据使用习惯大家更倾向去 &lt;code&gt;strings&lt;/code&gt; 包寻找这类问题的解决方法，我创建了&lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exstrings#SubString&quot;&gt;exstrings.SubString&lt;/a&gt; 和 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exbytes#Sub&quot;&gt;exbytes.Sub&lt;/a&gt; 作为更易检索到的别名方法。&lt;/p&gt;
&lt;p&gt;最后我需要再做一个性能测试，确保它的性能：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package benchmark

import (
    &quot;testing&quot;

    &quot;github.com/thinkeridea/go-extend/exunicode/exutf8&quot;
)

var benchmarkSubString = &quot;Go语言是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。为了方便搜索和识别，有时会将其称为Golang。&quot;
var benchmarkSubStringLength = 20

func SubStrRuneSubString(s string, length int) string {
    return exutf8.RuneSubString(s, 0, length)
}

func BenchmarkSubStrRuneSubString(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        SubStrRuneSubString(benchmarkSubString, benchmarkSubStringLength)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行它，不会让我失望：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark
BenchmarkSubStrRuneSubString-8          13309082                83.9 ns/op             0 B/op          0 allocs/op
PASS
ok      github.com/thinkeridea/go-extend/exunicode/exutf8/benchmark     1.215s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然相较 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exunicode/exutf8#RuneIndexInString&quot;&gt;exutf8.RuneIndexInString&lt;/a&gt; 有所下降，但它提供了易于交互和使用的接口，我认为这应该是最实用的方案，如果你追求极致仍然可以使用 &lt;a href=&quot;https://godoc.org/github.com/thinkeridea/go-extend/exunicode/exutf8#RuneIndexInString&quot;&gt;exutf8.RuneIndexInString&lt;/a&gt;，它依然是最快的方案。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;当看到有疑问的代码，即使它十分的简单，依然值得深究，并不停的探索它，这并不枯燥和乏味，反而会有极多收获。&lt;/p&gt;
&lt;p&gt;从起初 &lt;code&gt;[]rune&lt;/code&gt; 类型转换到最后自己造轮子，不仅得到了&lt;strong&gt;16倍&lt;/strong&gt;的性能提升，我还学习了&lt;code&gt;utf8&lt;/code&gt;包、加深了&lt;code&gt;range&lt;/code&gt; 遍历字符串的特性 以及为 &lt;a href=&quot;https://github.com/thinkeridea/go-extend&quot;&gt;go-extend&lt;/a&gt; 仓库收录了多个实用高效的解决方案，让更多 &lt;a href=&quot;https://github.com/thinkeridea/go-extend&quot;&gt;go-extend&lt;/a&gt; 的用户得到成果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/thinkeridea/go-extend&quot;&gt;go-extend&lt;/a&gt; 是一个收录实用、高效方法的仓库，读者们如果好的函数和通用高效的解决方案，期待你们不吝啬给我发送 &lt;code&gt;Pull request&lt;/code&gt;，你也可以使用这个仓库加快功能实现及提升性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文作者： 戚银（&lt;a href=&quot;https://blog.thinkeridea.com/&quot;&gt;thinkeridea&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接： &lt;a href=&quot;https://blog.thinkeridea.com/201910/go/efficient_string_truncation.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201910/go/efficient_string_truncation.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明： 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.zh&quot;&gt;CC BY 4.0 CN协议&lt;/a&gt; 许可协议。转载请注明出处！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Oct 2019 00:37:00 +0000</pubDate>
<dc:creator>戚银</dc:creator>
<og:description>原文链接：https://blog.thinkeridea.com/201910/go/efficient_string_truncation.html 最近我在 'Go Forum' 中发现了 '[</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/thinkeridea/p/11769190.html</dc:identifier>
</item>
<item>
<title>在非洲运营互联网系统-PAYGo方案 - 芊芊爸爸</title>
<link>http://www.cnblogs.com/huige-you/p/11769174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huige-you/p/11769174.html</guid>
<description>&lt;p&gt;&lt;span&gt;​&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wxRLBS4ibxYrrag5y1TYP3mGGywebStpF470C7I1ndjpM4OkpgiaSic3dfHe58yTEd8YHytribCQcwFy6HeTZP2RbQ/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-backh=&quot;443&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/wxRLBS4ibxYrrag5y1TYP3mGGywebStpF470C7I1ndjpM4OkpgiaSic3dfHe58yTEd8YHytribCQcwFy6HeTZP2RbQ/0?wx_fmt=jpeg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wxRLBS4ibxYrWM5UdbCqgSiaHoBWgwjTbx6oBRiaKCnKEkiaOynUFZEn9NicRL0XFHXjSkZaUyhp8fFSBEQBibrzPBwA/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;296.58536585365846&quot; data-cropy2=&quot;1284.4599303135885&quot; data-ratio=&quot;0.771875&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尼日利亚当地经济、支付、网络、供电、交通等基建都比较落后，虽然各方面都在缓慢增长，但当地人对高额的刚需产品仍望而却步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他非洲国家也有同样的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理国内，一些低收入人群都想买房，但房价动辄几十、上百万，一般家庭很难一次性付清。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多供应商想打开非洲市场，无奈也是困于上述现状只能望洋兴叹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面多篇文章提到PAYGo方案（也有写作PAYG，其实都是“Pay As You Go”的简写），可能很多读者都有疑惑，这里简单介绍一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PAYGo方案可以通俗的理解为国内所使用分期、租用的模式，比如共享单车、按揭购房等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wxRLBS4ibxYrrag5y1TYP3mGGywebStpFc4Fp3iaYlnTCGTBAHqSSyhS3bIL70aEAJib2ocyYD6bW2REp2VPOW3GQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;207&quot; data-backw=&quot;511&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_png/wxRLBS4ibxYrrag5y1TYP3mGGywebStpFc4Fp3iaYlnTCGTBAHqSSyhS3bIL70aEAJib2ocyYD6bW2REp2VPOW3GQ/0?wx_fmt=png&quot; data-ratio=&quot;0.4050880626223092&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;511&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对高额产品，用户使用较低的首付、押金先获得产品使用，再周期内支付分期余款、租金，然后激活继续使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前普遍的顾虑：厂商虽然可以快速把产品卖出去，但是需要承担余款收回的压力，用户不付钱、不还了怎么办？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在非洲，尤其是尼日利亚，出了名的各种诈骗、信用差，说白了，整个大环境都充斥着信用危机，很难有企业有这个资金和勇气在这种环境下应用PAYGo方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有很多厂商在实施过程中，遭受偷盗非常严重，例如：铺路灯，可能铺了200米，就已经有100米的被偷或者电池被卸走了，根本没办法继续做下去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;由于我们的PAYGo方案涉密，这里不方便过多介绍，&lt;/strong&gt;如果有想合作的可以关注公众号加我微信细聊 ：）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前业界大致的解决方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-&lt;strong&gt;防拆：&lt;/strong&gt;增大拆解难度，即使被拆，程序自毁依然用不了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-&lt;strong&gt;防破解：&lt;/strong&gt;一机一码，不存在共享激活码或批量破解的问题；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-&lt;strong&gt;激活策略：&lt;/strong&gt;用户购买激活码解锁，到期锁定；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-&lt;strong&gt;激活方式：&lt;/strong&gt;M2M、SIM、红外遥控等等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-&lt;strong&gt;软件系统&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;系统控制支付激活、激活码、分期定价策略、断供、售后、报表、CRM（销售）、WMS（物流）等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;涉密度不好把握，就不细聊了，抛几个需要解决的问题供大家思考：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当地运营商网络有地域性，偏远地区连信号都没有，更别说网络了，如何控制激活？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当地交通很差，很多村镇车都进不去，偏远地区如何获得激活码？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当地银行基本上都是民营，也有地域性，城区以外没有银行，大多都是现金交易为主，如何控制支付？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何销售？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;物流？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;售后？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，希望涉足该领域的同胞们，能够保证产品质量，做非洲人民最需要的产品，让世界相信“Made in China”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;- end -&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Oct 2019 00:30:00 +0000</pubDate>
<dc:creator>芊芊爸爸</dc:creator>
<og:description>​ 尼日利亚当地经济、支付、网络、供电、交通等基建都比较落后，虽然各方面都在缓慢增长，但当地人对高额的刚需产品仍望而却步。 其他非洲国家也有同样的问题。 同理国内，一些低收入人群都想买房，但房价动辄几</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huige-you/p/11769174.html</dc:identifier>
</item>
<item>
<title>你真的了解 volatile 关键字吗？ - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/11769011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/11769011.html</guid>
<description>&lt;p&gt;今天，让我们一起来探讨 Java 并发编程中的知识点：volatile 关键字&lt;/p&gt;
&lt;p&gt;本文主要从以下三点讲解 volatile 关键字：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;volatile 关键字是什么？&lt;/li&gt;
&lt;li&gt;volatile 关键字能解决什么问题？使用场景是什么？&lt;/li&gt;
&lt;li&gt;volatile 关键字实现的原理？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Sun 的 JDK 官方文档是这样形容 volatile 的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;The Java programming language provides a secondmechanism, volatile fields, that is more convenient than locking for somepurposes. A field may be declared volatile, in which case the Java Memory Modelensures that all threads see a consistent value for the variable.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，如果一个变量加了 volatile 关键字，就会告诉编译器和 JVM 的内存模型：这个变量是对所有线程共享的、可见的，每次 JVM 都会读取最新写入的值并使其最新值在所有 CPU 可见。volatile 可以保证线程的可见性并且提供了一定的有序性，但是无法保证原子性。在 JVM 底层 volatile 是采用内存屏障来实现的。&lt;/p&gt;
&lt;p&gt;通过这段话，我们可以知道 volatile 有两个特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保证可见性、不保证原子性&lt;/li&gt;
&lt;li&gt;禁止指令重排序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原子性是指一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么都不执行。性质和数据库中事务一样，一组操作要么都成功，要么都失败。看下面几个简单例子来理解原子性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i == 0;       //1
j = i;        //2
i++;          //3
i = j + 1;    //4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在看答案之前，可以先思考一下上面四个操作，哪些是原子操作？哪些是非原子操作？&lt;/p&gt;
&lt;p&gt;答案揭晓：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1——是：在Java中，对基本数据类型的变量赋值操作都是原子性操作（Java 有八大基本数据类型，分别是byte，short，int，long，char，float，double，boolean）
2——不是：包含两个动作：读取 i 值，将 i 值赋值给 j
3——不是：包含了三个动作：读取 i 值，i+1，将 i+1 结果赋值给 i
4——不是：包含了三个动作：读取 j 值，j+1，将 j+1 结果赋值给 i&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。&lt;/p&gt;
&lt;p&gt;注：由于以前的操作系统是 32 位， 64 位数据（long 型,double 型）在 Java 中是 8 个字节表示，一共占用 64 位，因此需要分成两次操作采用完成一个变量的赋值或者读取操作。随着 64 位操作系统越来越普及，在 64 位的 HotSpot JVM 实现中，对64 位数据（long 型,double 型）做原子性处理（由于 JVM 规范没有明确规定，不排除别的 JVM 实现还是按照 32 位的方式处理）。&lt;/p&gt;
&lt;p&gt;在单线程环境中我们可以认为上述步骤都是原子性操作，但是在多线程环境下，Java 只保证了上述基本数据类型的赋值操作是原子性的，其他操作都有可能在运算过程中出现错误。为此在多线程环境下为了保证一些操作的原子性引入了锁和 synchronized 等关键字。&lt;/p&gt;
&lt;p&gt;上面说到 volatile 关键字保证了变量的可见性，不保证原子性。原子性已经说了，下面说下可见性。&lt;/p&gt;
&lt;p&gt;可见性其实和 Java 内存模型的设定有关：Java 内存模型规定所有的变量都是存在主存（线程共享区域）当中，每个线程都有自己的工作内存（私有内存）。线程对变量的所有操作都必须在工作内存中进行，而不直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。&lt;/p&gt;
&lt;p&gt;举个简单栗子：&lt;/p&gt;
&lt;p&gt;比如上面 i++ 操作，在 Java 中，执行 &lt;code&gt;i++&lt;/code&gt; 语句：&lt;/p&gt;
&lt;p&gt;执行线程首先从主存中读取 i（原始值）到工作内存中，然后在工作内存中执行运算 +1 操作（主存的 i 值未变），最后将运算结果刷新到主存中。&lt;/p&gt;
&lt;p&gt;数据运算是在执行线程的私有内存中进行的，线程执行完运算后，并不一定会立即将运算结果刷新到主存中（虽然最后一定会更新主存），刷新到主存动作是由 CPU 自行选择一个合适的时间触发的。假设数值未更新到主存之前，当其他线程去读取时(而且优先读取的是工作内存中的数据而非主存)，此时主存中可能还是原来的旧值，就有可能导致运算结果出错。&lt;/p&gt;
&lt;p&gt;以下代码是测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wupx.test;

/**
 * @author wupx
 * @date 2019/10/31
 */
public class VolatileTest {

    private boolean flag = false;

    class ThreadOne implements Runnable {
        @Override
        public void run() {
            while (!flag) {
                System.out.println(&quot;执行操作&quot;);
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;任务停止&quot;);
        }
    }

    class ThreadTwo implements Runnable {
        @Override
        public void run() {
            try {
                Thread.sleep(2000L);
                System.out.println(&quot;flag 状态改变&quot;);
                flag = true;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        VolatileTest testVolatile = new VolatileTest();
        Thread thread1 = new Thread(testVolatile.new ThreadOne());
        Thread thread2 = new Thread(testVolatile.new ThreadTwo());
        thread1.start();
        thread2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述结果有可能在线程 2 执行完 flag = true 之后，并不能保证线程 1 中的 while 能立即停止循环，原因在于 flag 状态首先是在线程 2 的私有内存中改变的，刷新到主存的时机不固定，而且线程 1 读取 flag 的值也是在自己的私有内存中，而线程 1 的私有内存中 flag 仍未 false，这样就有可能导致线程仍然会继续 while 循环。运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;执行操作
执行操作
执行操作
flag 状态改变
任务停止&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;避免上述不可预知问题的发生就是用 volatile 关键字修饰 flag，volatile 修饰的共享变量可以保证修改的值会在操作后立即更新到主存里面，当有其他线程需要操作该变量时，不是从私有内存中读取，而是强制从主存中读取新值。即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。&lt;/p&gt;

&lt;p&gt;一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。&lt;/p&gt;
&lt;p&gt;比如下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int i = 0;             
boolean flag = false;
i = 1;        // 1
flag = true;  // 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码定义了一个 int 型变量，定义了一个 boolean 类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句 1 是在语句 2 前面的，那么 JVM 在真正执行这段代码的时候会保证语句 1 一定会在语句 2 前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（InstructionReorder）。&lt;/p&gt;
&lt;p&gt;语句 1 和语句 2 谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句 2 先执行而语句 1 后执行。&lt;/p&gt;
&lt;p&gt;但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a = 10;     // 1
int r = 2;      // 2
a = a + 3;      // 3
r = a * a;      // 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码执行的顺序可能是 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 或者是 2-&amp;gt;1-&amp;gt;3-&amp;gt;4，但是 3 和 4 的执行顺序是不会变的，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令 Instruction2 必须用到 Instruction1 的结果，那么处理器会保证 Instruction1 会在 Instruction2 之前执行。&lt;/p&gt;
&lt;p&gt;虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 线程1
String config = initConfig();    // 1
boolean inited = true;           // 2
 
// 线程2
while(!inited){
       sleep();
}
doSomeThingWithConfig(config);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，由于语句 1 和语句 2 没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程 1 执行过程中先执行语句 2，而此时线程 2 会以为初始化工作已经完成，那么就会跳出 while 循环，去执行 doSomeThingWithConfig(config) 方法，而此时 config 并没有被初始化，就会导致程序出错。&lt;/p&gt;
&lt;p&gt;从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。&lt;/p&gt;
&lt;p&gt;那么 volatile 关键字修饰的变量禁止重排序的含义是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作肯定已经全部进行，且对后面的操作可见，在其后面的操作肯定还没有进行&lt;/li&gt;
&lt;li&gt;在进行指令优化时，不能将 volatile 变量之前的语句放在对 volatile 变量的读写操作之后，也不能把 volatile 变量后面的语句放到其前面执行&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x=0;             // 1
y=1;             // 2
volatile z = 2;  // 3
x=4;             // 4
y=5;             // 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量z为 volatile 变量，那么进行指令重排序时，不会将语句 3 放到语句 1、语句 2 之前，也不会将语句 3 放到语句 4、语句 5 后面。但是语句 1 和语句 2、语句 4 和语句 5 之间的顺序是不作任何保证的，并且 volatile 关键字能保证，执行到语句 3 时，语句 1 和语句 2 必定是执行完毕了的，且语句 1 和语句 2 的执行结果是对语句 3、语句 4、语句 5是可见的。&lt;/p&gt;
&lt;p&gt;回到之前的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 线程1
String config = initConfig();   // 1
volatile boolean inited = true; // 2
 
// 线程2
while(!inited){
       sleep();
}
 
doSomeThingWithConfig(config);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前说这个例子提到有可能语句2会在语句1之前执行，那么就可能导致执行 doSomThingWithConfig() 方法时就会导致出错。&lt;/p&gt;
&lt;p&gt;这里如果用 volatile 关键字对 inited 变量进行修饰，则可以保证在执行语句 2 时，必定能保证 config 已经初始化完毕。&lt;/p&gt;

&lt;p&gt;synchronized 关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而 volatile 关键字在某些情况下性能要优于 synchronized，但是要注意 volatile 关键字是无法替代 synchronized 关键字的，因为 volatile 关键字无法保证操作的原子性。通常来说，使用 volatile 必须具备以下三个条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值&lt;/li&gt;
&lt;li&gt;该变量不会与其他状态变量一起纳入不变性条件中&lt;/li&gt;
&lt;li&gt;在访问变量时不需要加锁&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的三个条件只需要保证是原子性操作，才能保证使用 volatile 关键字的程序在高并发时能够正确执行。建议不要将 volatile 用在 getAndOperate 场合，仅仅 set 或者 get 的场景是适合 volatile 的。&lt;/p&gt;
&lt;p&gt;常用的两个场景是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;状态标记量&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;volatile boolean flag = false;

while (!flag) {
    doSomething();
}

public void setFlag () {
    flag = true;
}

volatile boolean inited = false;
// 线程 1
context = loadContext();
inited = true;

// 线程 2
while (!inited) {
    sleep();
}
doSomethingwithconfig(context);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;DCL双重校验锁-单例模式&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class Singleton {
    private volatile static Singleton instance = null;

    private Singleton() {
    }

    /**
     * 当第一次调用getInstance()方法时，instance为空，同步操作，保证多线程实例唯一
     * 当第一次后调用getInstance()方法时，instance不为空，不进入同步代码块，减少了不必要的同步
     */
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;推荐阅读：&lt;a href=&quot;https://blog.csdn.net/qq_27276045/article/details/88895177&quot;&gt;设计模式-单例模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 volatile 的原因在上面解释重排序时已经讲过了。主要在于 instance = new Singleton()，这并非是一个原子操作，在 JVM 中这句话做了三件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;给 instance分配内存&lt;/li&gt;
&lt;li&gt;调用 Singleton 的构造函数来初始化成员变量&lt;/li&gt;
&lt;li&gt;将 instance 对象指向分配的内存库存空间（执行完这步 instance 就为非 null 了）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是 JVM 即时编译器中存在指令重排序的优化，也就是说上面的第二步和第三步顺序是不能保证的，最终的执行顺序可能是 1-2-3，也可能是 1-3-2。如果是后者，线程 1 在执行完 3 之后，2 之前，被线程 2 抢占，这时 instance 已经是非 null（但是并没有进行初始化），所以线程 2 返回 instance 使用就会报空指针异常。&lt;/p&gt;

&lt;p&gt;前面讲述了关于 volatile 关键字的一些使用，下面我们来探讨一下 volatile 到底如何保证可见性和禁止指令重排序的。&lt;/p&gt;
&lt;p&gt;在《深入理解Java虚拟机》这本书中说道：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;观察加入volatile关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来举个栗子：&lt;/p&gt;
&lt;p&gt;volatile 的 Integer 自增（i++），其实要分成 3 步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;读取 volatile 变量值到 local&lt;/li&gt;
&lt;li&gt;增加变量的值&lt;/li&gt;
&lt;li&gt;把 local 的值写回，让其它的线程可见&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这 3 步的 JVM 指令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mov    0xc(%r10),%r8d ; Load
inc    %r8d           ; Increment
mov    %r8d,0xc(%r10) ; Store
lock addl $0x0,(%rsp) ; StoreLoad Barrier&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lock 前缀指令实际上相当于一个内存屏障（也叫内存栅栏），内存屏障会提供 3 个功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成（满足禁止重排序）&lt;/li&gt;
&lt;li&gt;它会强制将对缓存的修改操作立即写入主存（满足可见性）&lt;/li&gt;
&lt;li&gt;如果是写操作，它会导致其他 CPU 中对应的缓存行无效（满足可见性）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;volatile 变量规则是 happens-before(先行发生原则)中的一种：对一个变量的写操作先行发生于后面对这个变量的读操作。（该特性可以很好解释 DCL 双重检查锁单例模式为什么使用 volatile 关键字来修饰能保证并发安全性）&lt;/p&gt;

&lt;p&gt;变量声明为 volatile 类型时，编译器与运行时都会注意到这个变量是共享的，不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。&lt;/p&gt;
&lt;p&gt;在访问 volatile 变量时不会执行加锁操作，也就不会使执行线程阻塞，因此 volatile 变量是比 sychronized 关键字更轻量级的同步机制。&lt;/p&gt;
&lt;p&gt;加锁机制既可以确保可见性和原子性，而 volatile 变量只能确保可见性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201910/1356806-20191031011145104-69075284.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Oct 2019 17:12:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>今天，让我们一起来探讨 Java 并发编程中的知识点：volatile 关键字 本文主要从以下三点讲解 volatile 关键字： 1. volatile 关键字是什么？ 2. volatile 关键</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/11769011.html</dc:identifier>
</item>
<item>
<title>验证码识别 - 明说</title>
<link>http://www.cnblogs.com/cone/p/11767355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cone/p/11767355.html</guid>
<description>&lt;h2&gt;1、前言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;工作关系，在做自动化测试的时候，不可避免要碰到验证码，如果中途暂停手动输入的话，未免太繁琐，所以我在这里总结了自己搜索到的资料，结合实践经验，与各位分享。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;2、解决的问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本次我解决的问题主要是比较传统的图片验证码识别，类似下图这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1532786/201910/1532786-20191030190507869-1477859182.png&quot; alt=&quot;&quot;/&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1532786/201910/1532786-20191030190542147-1985894090.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;滑块验证和顺序点击图片那种逆天的验证码本次不涉及。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;3、方法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我这里有java和python的不同实现，背后的思路大体一致：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 图片二值化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 去噪点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ 识别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面通过代码给大家讲解，相关代码已上传至github，可在文末查看。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;4、java实现&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先列出工程目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1532786/201910/1532786-20191030191903075-1569827346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; Entrance是程序入口，DT是一些配置信息，PictureOcr是识别用到的一些方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 去噪点 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 图片去噪点
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; picPath
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; removeBackground(String picPath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         BufferedImage bufferedImage = ImageIO.read(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(picPath));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; width =&lt;span&gt; bufferedImage.getWidth();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; bufferedImage.getHeight();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = 0; x &amp;lt; width; ++&lt;span&gt;x) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = 0; y &amp;lt; height; ++&lt;span&gt;y) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (isWrite(bufferedImage.getRGB(x, y)) == 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    bufferedImage.setRGB(x, y, Color.white.getRGB());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    bufferedImage.setRGB(x, y, Color.black.getRGB());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         ImageIO.write(bufferedImage, picType, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(picPath));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 如果某个像素的三原色值大于所设定的阈值，就将此像素设为白色，即为背景
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; colorInt
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; isWrite(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; colorInt) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         Color color = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Color(colorInt);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (color.getRed() + color.getGreen() + color.getBlue() &amp;gt;&lt;span&gt; DT.DictOfOcr.threshold) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 先取得图片的分辨率（长 * 宽），然后设定一个阈值，阈值就是某个像素的R，G，B三原色值的和，大家可以使用截图工具来分析要识别图像的验证码阈值是多少，以微信为例，验证码待识别区域的RGB值即可设定为阈值，大于此阈值的像素均设为白色，否则即设为黑色，这样便可以有效去除噪点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 裁剪边框&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;裁剪边框是为了尽可能大的保留图片特征，提高识别率&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 裁剪边角
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; picPath
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cutPic(String picPath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         BufferedImage bufferedimage=ImageIO.read(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(picPath));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; width =&lt;span&gt; bufferedimage.getWidth();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; bufferedimage.getHeight();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         bufferedimage = cropPic(bufferedimage, (cutWidth / 2),0, (width - cutWidth / 2&lt;span&gt;), height);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         bufferedimage = cropPic(bufferedimage,0, (cutHeight / 2),(width - cutWidth), (height - cutHeight / 2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         ImageIO.write(bufferedimage, picType, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(picPath));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * 根据参数裁剪图片
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bufferedImage
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; startX
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; startY
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; endX
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; endY
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BufferedImage cropPic(BufferedImage bufferedImage, &lt;span&gt;int&lt;/span&gt; startX, &lt;span&gt;int&lt;/span&gt; startY, &lt;span&gt;int&lt;/span&gt; endX, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; endY) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; width =&lt;span&gt; bufferedImage.getWidth();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; bufferedImage.getHeight();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (startX == -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             startX = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (startY == -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             startY = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (endX == -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             endX = width - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (endY == -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             endY = height - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         BufferedImage result = &lt;span&gt;new&lt;/span&gt; BufferedImage(endX - startX, endY - startY, 4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = startX; x &amp;lt; endX; ++&lt;span&gt;x) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = startY; y &amp;lt; endY; ++&lt;span&gt;y) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; rgb =&lt;span&gt; bufferedImage.getRGB(x, y);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 result.setRGB(x - startX, y -&lt;span&gt; startY, rgb);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;③ 执行OCR识别&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 执行Ocr识别
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; picPath
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; TesseractException
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String executeOcr(String picPath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; TesseractException {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         ITesseract iTesseract = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tesseract();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        iTesseract.setDatapath(tessdataPath);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;iTesseract.setLanguage(&quot;eng&quot;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可根据需要引入相关的训练集&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         String ocrResult = iTesseract.doOCR(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(picPath));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ocrResult;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用到了tessdata数据包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ 效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于规范的验证码来说，识别率还是很不错的，80%左右。我在工程resources路径下建立了一个image文件夹，里面有些图片，大家可以自行尝试。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;h2&gt;5、python实现&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;思路如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构建一定数量的数据集（被打上标签的验证码图片），然后进行模型的训练：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、二值化图片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、分割并保存每一张图片中的字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、“提取分割出的中的特征值”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、生成训练集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、定义分类模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、测试分类效果&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4fe93fe6-dc96-4a01-b2bf-aabd01f840aa')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_4fe93fe6-dc96-4a01-b2bf-aabd01f840aa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4fe93fe6-dc96-4a01-b2bf-aabd01f840aa&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4fe93fe6-dc96-4a01-b2bf-aabd01f840aa',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4fe93fe6-dc96-4a01-b2bf-aabd01f840aa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; capt_process(capt):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    图像预处理，将验证码图片转为二值型图片，按字符切割
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    :param capt: image
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    :return: 一个数组包含四个元素，每个元素是一张包含单个字符的二值型图片
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转为灰度图&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     capt_gray = capt.convert(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取得图片阈值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     threshold =&lt;span&gt; get_threshold(capt_gray)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 二值化图片&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     table =&lt;span&gt; get_bin_table(threshold)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     capt_bw = capt_gray.point(table, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     capt_per_char_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(4&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         x = 5 + i * 15
&lt;span&gt;17&lt;/span&gt;         y = 2
&lt;span&gt;18&lt;/span&gt;         capt_per_char = capt_bw.crop((x, y, x + 13, y + 24&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        capt_per_char_list.append(capt_per_char)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; capt_per_char_list
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('21e7edd9-49ed-427d-809f-e2d26b31e96c')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_21e7edd9-49ed-427d-809f-e2d26b31e96c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_21e7edd9-49ed-427d-809f-e2d26b31e96c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('21e7edd9-49ed-427d-809f-e2d26b31e96c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_21e7edd9-49ed-427d-809f-e2d26b31e96c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_threshold(capt):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    获取一张图片中，像素出现次数最多的像素，作为阈值
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    :param capt:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     pixel_dict =&lt;span&gt; defaultdict(int)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取得图片长、宽&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     rows, cols =&lt;span&gt; capt.size
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(rows):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(cols):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取得这一点的(r,g,b)&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             pixel =&lt;span&gt; capt.getpixel((i, j))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以像素做key，出现的次数做value&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             pixel_dict[pixel] += 1
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取得字典中像素出现最多的次数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     count_max =&lt;span&gt; max(pixel_dict.values())
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反转字典，改为以出现次数做key，方便后面取得像素&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     pixel_dict_reverse = {v: k &lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pixel_dict.items()}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取得出现次数最多的像素&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     threshold =&lt;span&gt; pixel_dict_reverse[count_max]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; threshold
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('083c0a22-29cd-4a5e-aeb2-0fbff3227031')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_083c0a22-29cd-4a5e-aeb2-0fbff3227031&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_083c0a22-29cd-4a5e-aeb2-0fbff3227031&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('083c0a22-29cd-4a5e-aeb2-0fbff3227031',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_083c0a22-29cd-4a5e-aeb2-0fbff3227031&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_bin_table(threshold):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    按照阈值进行二值化处理
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    :param threshold:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     table =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     rate = 0.1
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(256&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; threshold * (1 - rate) &amp;lt;= i &amp;lt;= threshold * (1 +&lt;span&gt; rate):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             table.append(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            table.append(0)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; table
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;代码里都有注释，就不详细解释了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本人python实现大量参考了这篇博文：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_38641983/article/details/80899354&quot;&gt;https://blog.csdn.net/weixin_38641983/article/details/80899354&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;具体每一步怎么做的，为什么这么做，都有清楚地解释，我在这里不再赘述，感谢这位博主。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我要说明的是，训练集可能每个人都不一样，图片切割尺寸也可能都不一样，这些需要在使用时随机应变。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;6、结语&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;以上提供的方法只能识别简单的验证码，但是它为我们提供了一种问题解决范式，今后遇到类似的问题，不至于手忙脚乱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相关代码还参考了以下博文：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015240294?utm_source=tag-newest&quot;&gt;https://segmentfault.com/a/1190000015240294?utm_source=tag-newest&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/problc/article/details/5794460&quot;&gt;https://blog.csdn.net/problc/article/details/5794460&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;再次感谢以上博主。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文相关代码已上传至github，有问题欢迎与我交流。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/Thinker-Mars/Demo/tree/master/picture-ocr&quot;&gt;https://github.com/Thinker-Mars/Demo/tree/master/picture-ocr&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Wed, 30 Oct 2019 16:20:00 +0000</pubDate>
<dc:creator>明说</dc:creator>
<og:description>验证码识别 1、前言 工作关系，在做自动化测试的时候，不可避免要碰到验证码，如果中途暂停手动输入的话，未免太繁琐，所以我在这里总结了自己搜索到的资料，结合实践经验，与各位分享。 2、解决的问题 本次我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cone/p/11767355.html</dc:identifier>
</item>
<item>
<title>面试 LockSupport.park()会释放锁资源吗？ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11768904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11768904.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191031000339048-637181635.png&quot; alt=&quot;park_thread&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（手机横屏看源码更方便）&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;引子&quot;&gt;引子&lt;/h2&gt;
&lt;p&gt;大家知道，我最近在招人，今天遇到个同学，他的源码看过一些，然后我就开始了AQS连环问。&lt;/p&gt;
&lt;p&gt;我：说说AQS的大致流程？&lt;/p&gt;
&lt;p&gt;他：AQS包含一个状态变量，一个同步队列……balabala……互斥锁balabala，共享锁balabala……&lt;/p&gt;
&lt;p&gt;我：AQS中除了同步队列，还有什么队列？&lt;/p&gt;
&lt;p&gt;他：还有个Condition，Condition中有个条件队列……&lt;/p&gt;
&lt;p&gt;我：条件队列和同步队列有什么区别？&lt;/p&gt;
&lt;p&gt;他：条件队列balabala，然后调用LockSupport.park()进入休眠，等待被唤醒，……，balabala&lt;/p&gt;
&lt;p&gt;咦，这时我灵感突发：LockSupport.park()和Thread.sleep()有什么区别？&lt;/p&gt;
&lt;p&gt;他：Thread.sleep()不会释放锁资源，……，balabala&lt;/p&gt;
&lt;p&gt;我：LockSupport.park()会释放锁资源吗？&lt;/p&gt;
&lt;p&gt;他：会吧。（估计和Object.wait()搞混淆了）&lt;/p&gt;
&lt;p&gt;我：会吗？会吗？会吗？&lt;/p&gt;
&lt;p&gt;他（羞涩地低下了头）：彤哥，不知道，你的文章里没写。（这段我瞎写的哈^^）&lt;/p&gt;
&lt;p&gt;OK，今天我们就来看看LockSupport.park()到底会不会释放锁资源。&lt;/p&gt;
&lt;h2 id=&quot;thread.sleep和object.wait的区别&quot;&gt;Thread.sleep()和Object.wait()的区别&lt;/h2&gt;
&lt;p&gt;首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。&lt;/p&gt;
&lt;p&gt;（1）Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；&lt;/p&gt;
&lt;p&gt;（2）Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；&lt;/p&gt;
&lt;p&gt;（3）Thread.sleep()到时间了会自动唤醒，然后继续执行；&lt;/p&gt;
&lt;p&gt;（4）Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；&lt;/p&gt;
&lt;p&gt;（5）Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；&lt;/p&gt;
&lt;p&gt;其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。&lt;/p&gt;
&lt;h2 id=&quot;thread.sleep和condition.await的区别&quot;&gt;Thread.sleep()和Condition.await()的区别&lt;/h2&gt;
&lt;p&gt;我们再来看看Thread.sleep()和Condition.await()的区别。&lt;/p&gt;
&lt;p&gt;其实，这个题目和上面的题目比较类似，因为本来Object.wait()和Condition.await()的原理就比较类似，可以参考之前彤哥写的《死磕 java线程系列之线程的生命周期》之篇文章。&lt;/p&gt;
&lt;p&gt;这个题目的回答思路跟Object.wait()是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。&lt;/p&gt;
&lt;p&gt;实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程，可以参考之前彤哥写的《死磕 java同步系列之ReentrantLock源码解析（二）——条件锁》这篇文章。&lt;/p&gt;
&lt;p&gt;看到这里，今天开篇提的那个问题是不是就有答案了呢【本文由公从号“彤哥读源码”原创】？&lt;/p&gt;
&lt;h2 id=&quot;thread.sleep和locksupport.park的区别&quot;&gt;Thread.sleep()和LockSupport.park()的区别&lt;/h2&gt;
&lt;p&gt;LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。&lt;/p&gt;
&lt;p&gt;（1）从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且&lt;strong&gt;都不会释放当前线程占有的锁资源&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（2）Thread.sleep()没法从外部唤醒，只能自己醒过来；&lt;/p&gt;
&lt;p&gt;（3）LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；&lt;/p&gt;
&lt;p&gt;（4）Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；&lt;/p&gt;
&lt;p&gt;（5）LockSupport.park()方法不需要捕获中断异常；&lt;/p&gt;
&lt;p&gt;（6）Thread.sleep()本身就是一个native方法；&lt;/p&gt;
&lt;p&gt;（7）LockSupport.park()底层是调用的Unsafe的native方法；&lt;/p&gt;
&lt;h2 id=&quot;object.wait和locksupport.park的区别&quot;&gt;Object.wait()和LockSupport.park()的区别&lt;/h2&gt;
&lt;p&gt;二者都会阻塞当前线程的运行，他们有什么区别呢？经过上面的分析相信你一定很清楚了，真的吗？往下看！&lt;/p&gt;
&lt;p&gt;（1）Object.wait()方法需要在synchronized块中执行；&lt;/p&gt;
&lt;p&gt;（2）LockSupport.park()可以在任意地方执行；&lt;/p&gt;
&lt;p&gt;（3）Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；&lt;/p&gt;
&lt;p&gt;（4）LockSupport.park()不需要捕获中断异常【本文由公从号“彤哥读源码”原创】；&lt;/p&gt;
&lt;p&gt;（5）Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；&lt;/p&gt;
&lt;p&gt;（6）LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；&lt;/p&gt;
&lt;p&gt;（7）&lt;strong&gt;如果在wait()之前执行了notify()会怎样？抛出IllegalMonitorStateException异常&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（8）&lt;strong&gt;如果在park()之前执行了unpark()会怎样？线程不会被阻塞，直接跳过park()，继续执行后续内容；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后两点是不是没想到？！&lt;/p&gt;
&lt;p&gt;其实，在《死磕 java线程系列之自己动手写一个线程池（续）》这篇文章里代码注释里稍微提到过unpark()这个方法，它先执行，则后续的park()方法将不再起作用。&lt;/p&gt;
&lt;p&gt;park()/unpark()底层的原理是“&lt;strong&gt;二元信号量&lt;/strong&gt;”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。&lt;/p&gt;
&lt;p&gt;关于信号量的内容，可以参考《死磕 java同步系列之Semaphore源码解析》这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;locksupport.park会释放锁资源吗&quot;&gt;LockSupport.park()会释放锁资源吗？&lt;/h2&gt;
&lt;p&gt;不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;好了，上面我们交叉对比了Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别。&lt;/p&gt;
&lt;p&gt;让我们用一张思维导图结束今天的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191031000340218-1325074987.png&quot; alt=&quot;park_thread&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191031000340615-48307599.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Oct 2019 16:04:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>（手机横屏看源码更方便） 引子 大家知道，我最近在招人，今天遇到个同学，他的源码看过一些，然后我就开始了AQS连环问。 我：说说AQS的大致流程？ 他：AQS包含一个状态变量，一个同步队列……bala</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11768904.html</dc:identifier>
</item>
<item>
<title>4. SOFAJRaft源码分析— RheaKV初始化做了什么？ - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11768860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11768860.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;由于RheaKV要讲起来篇幅比较长，所以这里分成几个章节来讲，这一章讲一讲RheaKV初始化做了什么？&lt;/p&gt;
&lt;p&gt;我们先来给个例子，我们从例子来讲：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(final String[] args) throws Exception {
    final PlacementDriverOptions pdOpts = PlacementDriverOptionsConfigured.newConfigured()
            .withFake(true) // use a fake pd
            .config();
    final StoreEngineOptions storeOpts = StoreEngineOptionsConfigured.newConfigured() //
            .withStorageType(StorageType.RocksDB)
            .withRocksDBOptions(RocksDBOptionsConfigured.newConfigured().withDbPath(Configs.DB_PATH).config())
            .withRaftDataPath(Configs.RAFT_DATA_PATH)
            .withServerAddress(new Endpoint(&quot;127.0.0.1&quot;, 8181))
            .config();

    final RheaKVStoreOptions opts = RheaKVStoreOptionsConfigured.newConfigured() //
            .withClusterName(Configs.CLUSTER_NAME) //
            .withInitialServerList(Configs.ALL_NODE_ADDRESSES)
            .withStoreEngineOptions(storeOpts) //
            .withPlacementDriverOptions(pdOpts) //
            .config();
    System.out.println(opts);
    final Node node = new Node(opts);
    node.start();
    Runtime.getRuntime().addShutdownHook(new Thread(node::stop));
    System.out.println(&quot;server1 start OK&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为了简化逻辑，使用的无PD设置&lt;/p&gt;
&lt;p&gt;Node的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Node {

    private final RheaKVStoreOptions options;

    private RheaKVStore              rheaKVStore;

    public Node(RheaKVStoreOptions options) {
        this.options = options;
    }

    public void start() {
        this.rheaKVStore = new DefaultRheaKVStore();
        this.rheaKVStore.init(this.options);
    }

    public void stop() {
        this.rheaKVStore.shutdown();
    }

    public RheaKVStore getRheaKVStore() {
        return rheaKVStore;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这里是初始化一个DefaultRheaKVStore，并调用其init方法进行初始化&lt;/p&gt;
&lt;h2 id=&quot;rheakv-默认存储defaultrheakvstore&quot;&gt;RheaKV 默认存储DefaultRheaKVStore&lt;/h2&gt;
&lt;p&gt;由于DefaultRheaKVStore的初始化方法都是在init方法中完成，所以这里直接看DefaultRheaKVStore的init方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized boolean init(final RheaKVStoreOptions opts) {
    //1. 如果已经启动了，那么直接返回
    if (this.started) {
        LOG.info(&quot;[DefaultRheaKVStore] already started.&quot;);
        return true;
    }
    this.opts = opts;
    // init placement driver
    // 2.根据PDoptions设置PD
    final PlacementDriverOptions pdOpts = opts.getPlacementDriverOptions();
    final String clusterName = opts.getClusterName();
    Requires.requireNonNull(pdOpts, &quot;opts.placementDriverOptions&quot;);
    Requires.requireNonNull(clusterName, &quot;opts.clusterName&quot;);
    //设置集群
    if (Strings.isBlank(pdOpts.getInitialServerList())) {
        // if blank, extends parent's value
        pdOpts.setInitialServerList(opts.getInitialServerList());
    }
    //如果是无 PD 场景， RheaKV 提供 Fake PD Client
    if (pdOpts.isFake()) {
        this.pdClient = new FakePlacementDriverClient(opts.getClusterId(), clusterName);
    } else {
        this.pdClient = new RemotePlacementDriverClient(opts.getClusterId(), clusterName);
    }
    //初始化PD
    if (!this.pdClient.init(pdOpts)) {
        LOG.error(&quot;Fail to init [PlacementDriverClient].&quot;);
        return false;
    }
    // init store engine
    //3. 初始化存储引擎
    final StoreEngineOptions stOpts = opts.getStoreEngineOptions();
    if (stOpts != null) {
        stOpts.setInitialServerList(opts.getInitialServerList());
        this.storeEngine = new StoreEngine(this.pdClient);
        //初始化存储引擎
        if (!this.storeEngine.init(stOpts)) {
            LOG.error(&quot;Fail to init [StoreEngine].&quot;);
            return false;
        }
    }
    //获取当前节点的ip和端口号
    final Endpoint selfEndpoint = this.storeEngine == null ? null : this.storeEngine.getSelfEndpoint();
    final RpcOptions rpcOpts = opts.getRpcOptions();
    Requires.requireNonNull(rpcOpts, &quot;opts.rpcOptions&quot;);
    //4. 初始化一个RpcService，并重写getLeader方法
    this.rheaKVRpcService = new DefaultRheaKVRpcService(this.pdClient, selfEndpoint) {

        @Override
        public Endpoint getLeader(final long regionId, final boolean forceRefresh, final long timeoutMillis) {
            final Endpoint leader = getLeaderByRegionEngine(regionId);
            if (leader != null) {
                return leader;
            }
            return super.getLeader(regionId, forceRefresh, timeoutMillis);
        }
    };
    if (!this.rheaKVRpcService.init(rpcOpts)) {
        LOG.error(&quot;Fail to init [RheaKVRpcService].&quot;);
        return false;
    }
    //获取重试次数，默认重试两次
    this.failoverRetries = opts.getFailoverRetries();
    //默认5000
    this.futureTimeoutMillis = opts.getFutureTimeoutMillis();
    //是否只从leader读取数据，默认为true
    this.onlyLeaderRead = opts.isOnlyLeaderRead();
    //5.初始化kvDispatcher， 这里默认为true
    if (opts.isUseParallelKVExecutor()) {
        //获取当前cpu
        final int numWorkers = Utils.cpus();
        //向左移动4位，相当于乘以16
        final int bufSize = numWorkers &amp;lt;&amp;lt; 4;
        final String name = &quot;parallel-kv-executor&quot;;
        final ThreadFactory threadFactory = Constants.THREAD_AFFINITY_ENABLED
                //这里选择是否启用线程亲和性ThreadFactory
                ? new AffinityNamedThreadFactory(name, true) : new NamedThreadFactory(name, true);
        //初始化Dispatcher
        this.kvDispatcher = new TaskDispatcher(bufSize, numWorkers, WaitStrategyType.LITE_BLOCKING_WAIT,
                threadFactory);
    }
    this.batchingOpts = opts.getBatchingOptions();
    //默认是true
    if (this.batchingOpts.isAllowBatching()) {
        //这几个batching暂时不知道是用来做什么的，等用到再分析
        this.getBatching = new GetBatching(KeyEvent::new, &quot;get_batching&quot;,
                new GetBatchingHandler(&quot;get&quot;, false));
        this.getBatchingOnlySafe = new GetBatching(KeyEvent::new, &quot;get_batching_only_safe&quot;,
                new GetBatchingHandler(&quot;get_only_safe&quot;, true));
        this.putBatching = new PutBatching(KVEvent::new, &quot;put_batching&quot;,
                new PutBatchingHandler(&quot;put&quot;));
    }
    LOG.info(&quot;[DefaultRheaKVStore] start successfully, options: {}.&quot;, opts);
    return this.started = true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;校验是否启动，如果已经启动了，那么直接返回&lt;/li&gt;
&lt;li&gt;根据PDoptions设置PD，PD 是全局的中心总控节点，负责整个集群的调度管理，维护 RegionRouteTable 路由表。这里我们不启用 PD，所以实例化一个FakePlacementDriverClient，并初始化&lt;/li&gt;
&lt;li&gt;初始化存储引擎，目前 StoreEngine 存储引擎支持 MemoryDB 和 RocksDB 两种实现，我们这里用的是RocksDB，待会下面补充init方法讲解&lt;/li&gt;
&lt;li&gt;初始化一个rheaKVRpcService，针对 KV 存储服务的 RPC Client 客户端封装，实现 Failover 逻辑。并设置重试两次，等待超时时间futureTimeoutMillis是5000毫秒，默认只从leader读取数据&lt;/li&gt;
&lt;li&gt;初始化kvDispatcher&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;初始化存储引擎&quot;&gt;初始化存储引擎&lt;/h3&gt;
&lt;p&gt;初始化的操作时在StoreEngine的init方法里面实现的，我们直接看这个方法的实现，这个方法是初始化核心对象，逻辑较为复杂，希望有点耐心看完：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StoreEngine#init&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized boolean init(final StoreEngineOptions opts) {
    if (this.started) {
        LOG.info(&quot;[StoreEngine] already started.&quot;);
        return true;
    }
    this.storeOpts = Requires.requireNonNull(opts, &quot;opts&quot;);
    Endpoint serverAddress = Requires.requireNonNull(opts.getServerAddress(), &quot;opts.serverAddress&quot;);
    //获取ip和端口
    final int port = serverAddress.getPort();
    final String ip = serverAddress.getIp();
    //如果传入的IP为空，那么就设置启动机器ip作为serverAddress的ip
    if (ip == null || Utils.IP_ANY.equals(ip)) {
        serverAddress = new Endpoint(NetUtil.getLocalCanonicalHostName(), port);
        opts.setServerAddress(serverAddress);
    }
    //获取度量上报时间
    final long metricsReportPeriod = opts.getMetricsReportPeriod();
    // init region options
    List&amp;lt;RegionEngineOptions&amp;gt; rOptsList = opts.getRegionEngineOptionsList();
    //1. 如果RegionEngineOptions为空，则默认初始化一个
    if (rOptsList == null || rOptsList.isEmpty()) {
        // -1 region
        final RegionEngineOptions rOpts = new RegionEngineOptions();
        rOpts.setRegionId(Constants.DEFAULT_REGION_ID);
        rOptsList = Lists.newArrayList();
        rOptsList.add(rOpts);
        opts.setRegionEngineOptionsList(rOptsList);
    }
    //获取集群名
    final String clusterName = this.pdClient.getClusterName();
    //2. 遍历rOptsList集合，为其中的RegionEngineOptions对象设置参数
    for (final RegionEngineOptions rOpts : rOptsList) {
        //用集群名+“-”+RegionId 拼接设置为RaftGroupId
        rOpts.setRaftGroupId(JRaftHelper.getJRaftGroupId(clusterName, rOpts.getRegionId()));
        rOpts.setServerAddress(serverAddress);
        rOpts.setInitialServerList(opts.getInitialServerList());
        if (rOpts.getNodeOptions() == null) {
            // copy common node options
            rOpts.setNodeOptions(opts.getCommonNodeOptions() == null ? new NodeOptions() : opts
                .getCommonNodeOptions().copy());
        }
        //如果原本没有设置度量上报时间，那么就重置一下
        if (rOpts.getMetricsReportPeriod() &amp;lt;= 0 &amp;amp;&amp;amp; metricsReportPeriod &amp;gt; 0) {
            // extends store opts 300
            rOpts.setMetricsReportPeriod(metricsReportPeriod);
        }
    }
    // init store
    // 3. 初始化Store和Store里面的region
    final Store store = this.pdClient.getStoreMetadata(opts);
    if (store == null || store.getRegions() == null || store.getRegions().isEmpty()) {
        LOG.error(&quot;Empty store metadata: {}.&quot;, store);
        return false;
    }
    this.storeId = store.getId();
    // init executors
    //4. 初始化执行器
    if (this.readIndexExecutor == null) {
        this.readIndexExecutor = StoreEngineHelper.createReadIndexExecutor(opts.getReadIndexCoreThreads());
    }
    if (this.raftStateTrigger == null) {
        this.raftStateTrigger = StoreEngineHelper.createRaftStateTrigger(opts.getLeaderStateTriggerCoreThreads());
    }
    if (this.snapshotExecutor == null) {
        this.snapshotExecutor = StoreEngineHelper.createSnapshotExecutor(opts.getSnapshotCoreThreads());
    }
    // init rpc executors 默认false
    final boolean useSharedRpcExecutor = opts.isUseSharedRpcExecutor();
    //5. 初始化rpc远程执行器，用来执行RPCServer的Processors
    if (!useSharedRpcExecutor) {
        if (this.cliRpcExecutor == null) {
            this.cliRpcExecutor = StoreEngineHelper.createCliRpcExecutor(opts.getCliRpcCoreThreads());
        }
        if (this.raftRpcExecutor == null) {
            this.raftRpcExecutor = StoreEngineHelper.createRaftRpcExecutor(opts.getRaftRpcCoreThreads());
        }
        if (this.kvRpcExecutor == null) {
            this.kvRpcExecutor = StoreEngineHelper.createKvRpcExecutor(opts.getKvRpcCoreThreads());
        }
    }
    // init metrics
    //做指标度量
    startMetricReporters(metricsReportPeriod);
    // init rpc server
    //6. 初始化rpcServer，供其他服务调用
    this.rpcServer = new RpcServer(port, true, true);
    //为server加入各种processor
    RaftRpcServerFactory.addRaftRequestProcessors(this.rpcServer, this.raftRpcExecutor, this.cliRpcExecutor);
    StoreEngineHelper.addKvStoreRequestProcessor(this.rpcServer, this);
    if (!this.rpcServer.start()) {
        LOG.error(&quot;Fail to init [RpcServer].&quot;);
        return false;
    }
    // init db store
    //7. 根据不同的类型选择db
    if (!initRawKVStore(opts)) {
        return false;
    }
    // init all region engine
    // 8. 为每个region初始化RegionEngine
    if (!initAllRegionEngine(opts, store)) {
        LOG.error(&quot;Fail to init all [RegionEngine].&quot;);
        return false;
    }
    // heartbeat sender
    //如果开启了自管理的集群，那么需要初始化心跳发送器
    if (this.pdClient instanceof RemotePlacementDriverClient) {
        HeartbeatOptions heartbeatOpts = opts.getHeartbeatOptions();
        if (heartbeatOpts == null) {
            heartbeatOpts = new HeartbeatOptions();
        }
        this.heartbeatSender = new HeartbeatSender(this);
        if (!this.heartbeatSender.init(heartbeatOpts)) {
            LOG.error(&quot;Fail to init [HeartbeatSender].&quot;);
            return false;
        }
    }
    this.startTime = System.currentTimeMillis();
    LOG.info(&quot;[StoreEngine] start successfully: {}.&quot;, this);
    return this.started = true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们从上面标了号的代码往下看：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这里是校验StoreEngineOptions的regionEngineOptionsList是否为空，如果为空则默认初始化一个，然后加入到rOptsList集合里&lt;/li&gt;
&lt;li&gt;遍历rOptsList集合，并为其中的RegionEngineOptions对象设置集群信息&lt;/li&gt;
&lt;li&gt;实例化Store然后并根据RegionEngineOptions初始化里面的region&lt;/li&gt;
&lt;li&gt;初始化执行器&lt;/li&gt;
&lt;li&gt;初始化rpc远程执行器，用来执行RPCServer的Processors&lt;/li&gt;
&lt;li&gt;初始化rpcServer，供其他服务调用&lt;/li&gt;
&lt;li&gt;根据不同的类型选择db，目前 StoreEngine 存储引擎支持 MemoryDB 和 RocksDB 两种实现。MemoryDB基于 ConcurrentSkipListMap 实现。&lt;/li&gt;
&lt;li&gt;为每个region初始化RegionEngine&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;初始化store和store里面的region&quot;&gt;初始化Store和Store里面的region&lt;/h4&gt;
&lt;p&gt;这里会调用pdClient的getStoreMetadata方法进行初始化，这里我们看FakePlacementDriverClient的实现：&lt;br/&gt;&lt;strong&gt;FakePlacementDriverClient#getStoreMetadata&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Store getStoreMetadata(final StoreEngineOptions opts) {
    //实例化store
    final Store store = new Store();
    final List&amp;lt;RegionEngineOptions&amp;gt; rOptsList = opts.getRegionEngineOptionsList();
    final List&amp;lt;Region&amp;gt; regionList = Lists.newArrayListWithCapacity(rOptsList.size());
    store.setId(-1);
    store.setEndpoint(opts.getServerAddress());
    for (final RegionEngineOptions rOpts : rOptsList) {
        //根据rOpts初始化Region实例加入到regionList中
        regionList.add(getLocalRegionMetadata(rOpts));
    }
    store.setRegions(regionList);
    return store;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法里面会实例化一个store之后遍历rOptsList集合，在循环里面会根据rOptsList里面的RegionEngineOptions来调用getLocalRegionMetadata方法来实例化region，然后加入到regionList集合中。&lt;br/&gt;在这里需要主要rOptsList列表和regionList列表的下标是一一对应的关系，在下面的代码中会用到这个对应关系。&lt;/p&gt;
&lt;p&gt;在这里应该可以稍微理解到：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201910/1204119-20191030234829517-1206701300.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图的意义了，每个store下面会有很多的region。&lt;/p&gt;
&lt;p&gt;然后我们再看看Region怎么被初始化的：&lt;br/&gt;这里是调用FakePlacementDriverClient的父类AbstractPlacementDriverClient的getLocalRegionMetadata来进行初始化的&lt;br/&gt;&lt;strong&gt;AbstractPlacementDriverClient#getLocalRegionMetadata&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Region getLocalRegionMetadata(final RegionEngineOptions opts) {
    final long regionId = Requires.requireNonNull(opts.getRegionId(), &quot;opts.regionId&quot;);
    Requires.requireTrue(regionId &amp;gt;= Region.MIN_ID_WITH_MANUAL_CONF, &quot;opts.regionId must &amp;gt;= &quot;
                                                                     + Region.MIN_ID_WITH_MANUAL_CONF);
    Requires.requireTrue(regionId &amp;lt; Region.MAX_ID_WITH_MANUAL_CONF, &quot;opts.regionId must &amp;lt; &quot;
                                                                    + Region.MAX_ID_WITH_MANUAL_CONF);
    final byte[] startKey = opts.getStartKeyBytes();
    final byte[] endKey = opts.getEndKeyBytes();
    final String initialServerList = opts.getInitialServerList();
    //实例化region
    final Region region = new Region();
    final Configuration conf = new Configuration();
    // region
    region.setId(regionId);
    region.setStartKey(startKey);
    region.setEndKey(endKey);
    region.setRegionEpoch(new RegionEpoch(-1, -1));
    // peers
    Requires.requireTrue(Strings.isNotBlank(initialServerList), &quot;opts.initialServerList is blank&quot;);
    //将集群ip和端口解析到peer中
    conf.parse(initialServerList);
    //每个region都会存有集群的信息
    region.setPeers(JRaftHelper.toPeerList(conf.listPeers()));
    this.regionRouteTable.addOrUpdateRegion(region);
    return region;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Region 是最小的 KV 数据单元，可理解为一个数据分区或者分片，每个 Region 都有一个左闭右开的区间 [startKey, endKey)，这里初始化都是null，能够根据请求流量/负载/数据量大小等指标自动分裂以及自动副本搬迁。Region 有多个副本 Replication 构建 Raft Groups 存储在不同的 Store 节点，通过 Raft 协议日志复制功能数据同步到同 Group 的全部节点。&lt;/p&gt;
&lt;p&gt;最后会将region存放到regionRouteTable中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void addOrUpdateRegion(final Region region) {
    Requires.requireNonNull(region, &quot;region&quot;);
    Requires.requireNonNull(region.getRegionEpoch(), &quot;regionEpoch&quot;);
    final long regionId = region.getId();
    final byte[] startKey = BytesUtil.nullToEmpty(region.getStartKey());
    final StampedLock stampedLock = this.stampedLock;
    final long stamp = stampedLock.writeLock();
    try {
        this.regionTable.put(regionId, region.copy());
        this.rangeTable.put(startKey, regionId);
    } finally {
        stampedLock.unlockWrite(stamp);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法中将region根据regionId存入到regionTable中，然后根据startKey作为key存入到rangeTable中。&lt;/p&gt;
&lt;h4 id=&quot;为每个region初始化regionengine&quot;&gt;为每个region初始化RegionEngine&lt;/h4&gt;
&lt;p&gt;在initAllRegionEngine里面会初始化RegionEngine：&lt;br/&gt;&lt;strong&gt;StoreEngine#initAllRegionEngine&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean initAllRegionEngine(final StoreEngineOptions opts, final Store store) {
    Requires.requireNonNull(opts, &quot;opts&quot;);
    Requires.requireNonNull(store, &quot;store&quot;);
    //获取主目录
    String baseRaftDataPath = opts.getRaftDataPath();
    if (Strings.isNotBlank(baseRaftDataPath)) {
        try {
            FileUtils.forceMkdir(new File(baseRaftDataPath));
        } catch (final Throwable t) {
            LOG.error(&quot;Fail to make dir for raftDataPath: {}.&quot;, baseRaftDataPath);
            return false;
        }
    } else {
        baseRaftDataPath = &quot;&quot;;
    }
    final Endpoint serverAddress = opts.getServerAddress();
    final List&amp;lt;RegionEngineOptions&amp;gt; rOptsList = opts.getRegionEngineOptionsList();
    final List&amp;lt;Region&amp;gt; regionList = store.getRegions();
    //因为regionList是根据rOptsList来初始化的，所以这里校验一样数量是不是一样的
    Requires.requireTrue(rOptsList.size() == regionList.size());
    for (int i = 0; i &amp;lt; rOptsList.size(); i++) {
        //一一对应的获取相应的RegionEngineOptions和region
        final RegionEngineOptions rOpts = rOptsList.get(i);
        final Region region = regionList.get(i);
        //如果region路径是空的，那么就重新设值
        if (Strings.isBlank(rOpts.getRaftDataPath())) {
            final String childPath = &quot;raft_data_region_&quot; + region.getId() + &quot;_&quot; + serverAddress.getPort();
            rOpts.setRaftDataPath(Paths.get(baseRaftDataPath, childPath).toString());
        }
        Requires.requireNonNull(region.getRegionEpoch(), &quot;regionEpoch&quot;);
        //根据Region初始化RegionEngine
        final RegionEngine engine = new RegionEngine(region, this);
        if (engine.init(rOpts)) {
            //KV Server 服务端的请求处理服务
            // 每个 RegionKVService 对应一个 Region，只处理本身 Region 范畴内的请求
            final RegionKVService regionKVService = new DefaultRegionKVService(engine);
            //放入到regionKVServiceTable中
            registerRegionKVService(regionKVService);
            //设置region与engine映射表
            this.regionEngineTable.put(region.getId(), engine);
        } else {
            LOG.error(&quot;Fail to init [RegionEngine: {}].&quot;, region);
            return false;
        }
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先这个方法会初始化一个baseRaftDataPath作为主目录&lt;br/&gt;然后将rOptsList和regionList都取出来，遍历rOptsList，并将RegionEngineOptions对应的region也找出来&lt;br/&gt;然后这里会为每个region实例化一个RegionEngine，并将engine包装到RegionKVService中&lt;br/&gt;最后将RegionKVService放入到regionKVServiceTable映射表中，将region放入到regionEngineTable映射表中&lt;/p&gt;
&lt;p&gt;这里的RegionKVServic是KV Server 服务端的请求处理服务，一个 StoreEngine 中包含很多 RegionKVService, 每个 RegionKVService 对应一个 Region，只处理本身 Region 范畴内的请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化RegionEngine#init&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized boolean init(final RegionEngineOptions opts) {
    if (this.started) {
        LOG.info(&quot;[RegionEngine: {}] already started.&quot;, this.region);
        return true;
    }
    this.regionOpts = Requires.requireNonNull(opts, &quot;opts&quot;);
    //实例化状态机
    this.fsm = new KVStoreStateMachine(this.region, this.storeEngine);

    // node options
    NodeOptions nodeOpts = opts.getNodeOptions();
    if (nodeOpts == null) {
        nodeOpts = new NodeOptions();
    }
    //如果度量间隔时间大于零，那么开启度量
    final long metricsReportPeriod = opts.getMetricsReportPeriod();
    if (metricsReportPeriod &amp;gt; 0) {
        // metricsReportPeriod &amp;gt; 0 means enable metrics
        nodeOpts.setEnableMetrics(true);
    }
    //初始化集群配置
    nodeOpts.setInitialConf(new Configuration(JRaftHelper.toJRaftPeerIdList(this.region.getPeers())));
    nodeOpts.setFsm(this.fsm);
    //初始化各种日志的路径
    final String raftDataPath = opts.getRaftDataPath();
    try {
        FileUtils.forceMkdir(new File(raftDataPath));
    } catch (final Throwable t) {
        LOG.error(&quot;Fail to make dir for raftDataPath {}.&quot;, raftDataPath);
        return false;
    }
    if (Strings.isBlank(nodeOpts.getLogUri())) {
        final Path logUri = Paths.get(raftDataPath, &quot;log&quot;);
        nodeOpts.setLogUri(logUri.toString());
    }
    if (Strings.isBlank(nodeOpts.getRaftMetaUri())) {
        final Path meteUri = Paths.get(raftDataPath, &quot;meta&quot;);
        nodeOpts.setRaftMetaUri(meteUri.toString());
    }
    if (Strings.isBlank(nodeOpts.getSnapshotUri())) {
        final Path snapshotUri = Paths.get(raftDataPath, &quot;snapshot&quot;);
        nodeOpts.setSnapshotUri(snapshotUri.toString());
    }
    LOG.info(&quot;[RegionEngine: {}], log uri: {}, raft meta uri: {}, snapshot uri: {}.&quot;, this.region,
        nodeOpts.getLogUri(), nodeOpts.getRaftMetaUri(), nodeOpts.getSnapshotUri());
    final Endpoint serverAddress = opts.getServerAddress();
    final PeerId serverId = new PeerId(serverAddress, 0);
    final RpcServer rpcServer = this.storeEngine.getRpcServer();
    this.raftGroupService = new RaftGroupService(opts.getRaftGroupId(), serverId, nodeOpts, rpcServer, true);
    //初始化node节点
    this.node = this.raftGroupService.start(false);
    RouteTable.getInstance().updateConfiguration(this.raftGroupService.getGroupId(), nodeOpts.getInitialConf());
    if (this.node != null) {
        final RawKVStore rawKVStore = this.storeEngine.getRawKVStore();
        final Executor readIndexExecutor = this.storeEngine.getReadIndexExecutor();
        //RaftRawKVStore 是 RheaKV 基于 Raft 复制状态机 KVStoreStateMachine 的 RawKVStore 接口 KV 存储实现
        //RheaKV 的 Raft 入口，从这里开始 Raft 流程
        this.raftRawKVStore = new RaftRawKVStore(this.node, rawKVStore, readIndexExecutor);
        //拦截请求做指标度量
        this.metricsRawKVStore = new MetricsRawKVStore(this.region.getId(), this.raftRawKVStore);
        // metrics config
        if (this.regionMetricsReporter == null &amp;amp;&amp;amp; metricsReportPeriod &amp;gt; 0) {
            final MetricRegistry metricRegistry = this.node.getNodeMetrics().getMetricRegistry();
            if (metricRegistry != null) {
                final ScheduledExecutorService scheduler = this.storeEngine.getMetricsScheduler();
                // start raft node metrics reporter
                this.regionMetricsReporter = Slf4jReporter.forRegistry(metricRegistry) //
                    .prefixedWith(&quot;region_&quot; + this.region.getId()) //
                    .withLoggingLevel(Slf4jReporter.LoggingLevel.INFO) //
                    .outputTo(LOG) //
                    .scheduleOn(scheduler) //
                    .shutdownExecutorOnStop(scheduler != null) //
                    .build();
                this.regionMetricsReporter.start(metricsReportPeriod, TimeUnit.SECONDS);
            }
        }
        this.started = true;
        LOG.info(&quot;[RegionEngine] start successfully: {}.&quot;, this);
    }
    return this.started;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;走到了这里可以找得到我在第一讲的时候讲过熟悉的几个实例了。如果不熟悉的话，不妨去翻阅一下我的第一篇文章：&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11651414.html&quot;&gt;1. SOFAJRaft源码分析— SOFAJRaft启动时做了什么？&lt;/a&gt;&lt;br/&gt;在这里会实例化状态机，是KVStoreStateMachine的实例；&lt;br/&gt;收动为LogUri、RaftMetaUri、SnapshotUri赋值，并获取storeEngine里的rpcServer；&lt;br/&gt;启动raftGroupService返回经过初始化的node；&lt;br/&gt;接下来会实例化raftRawKVStore，这个实例是RheaKV 的 Raft 入口，从这里开始 Raft 流程，所有的RheaKV数据都是通过它来处理。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;RheaKV初始化也是讲了很多的内容，这一篇讲了RheaKV在启动时需要初始化哪些组件，Store和Region又是一个怎样的关系，已经JRaft是在哪里启动的，状态机是在哪里设置的等等，内容也是非常的丰富。从这里也可以感受到，看到一个好的架构设计就是一种享受。&lt;/p&gt;
</description>
<pubDate>Wed, 30 Oct 2019 15:50:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>由于RheaKV要讲起来篇幅比较长，所以这里分成几个章节来讲，这一章讲一讲RheaKV初始化做了什么？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11768860.html</dc:identifier>
</item>
<item>
<title>红黑树算法原理（十三） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/11610133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/11610133.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近断断续续花了一个礼拜的时间去看红黑树算法，关于此算法还是比较难，因为涉及到诸多场景要考虑，同时接下来我们要讲解的HashMap、TreeMap等原理都涉及到红黑树算法，所以我们不得不了解其原理，关于一些基础知识这里不再讲解，本文参考博文：《&lt;a title=&quot;红黑树之 原理和算法详细介绍&quot; href=&quot;https://www.cnblogs.com/aspirant/p/9084199.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/aspirant/p/9084199.html&lt;/a&gt;》，参考链接太多文字描述，看过很多关于红黑树的文章，有些越讲越懵逼，有些讲的挺好关键是不说人话（这里不是骂人哈，指的是文章讲解的还是有点抽象），在这里希望通过我个人的理解既让阅读本文的您能够充分理解其原理也能完全快速记住各种场景。&lt;/p&gt;
&lt;h2&gt;红黑树原理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;红黑树是一种自平衡二进制搜索树（BST），红黑树与AVL树相比，AVL树更加平衡，但是它们可能会在插入和删除过程中引起更多旋转。因此，如果我们的应用程序涉及许多频繁的插入和删除操作，则应首选红黑树。但是，如果插入和删除操作的频率较低，而搜索操作的频率较高，则AVL树应优先于红黑树。我们需牢记红黑树的每个节点所遵循的以下规则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）每个节点或者是黑色，或者是红色。&lt;br/&gt;（2）根节点是黑色。&lt;br/&gt;（3）每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点，在算法原理中空用Nil表示，但是在面向对象语言中空都用NULL表示]&lt;br/&gt;（4）如果一个节点是红色的，则它的子节点必须是黑色的（注意：这里指的是不能有两个连续的红色节点）。&lt;br/&gt;（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191014202558224-613622268.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解如上规则后，接下来将进入红黑树的插入和删除操作，插入操作还好，最复杂的在于删除操作，莫慌，我们一步步来，无论是插入还是删除操作都可能会引起树的再次不平衡即会打破以上红黑树的规则，在进行插入或删除操作时，为使得树再次平衡我们使用【变色】和【旋转】方法来解决。假如Z为插入节点，在这里我们做如下命名约定：父亲节点、祖父节点、叔叔节点。好了，接下来我们首先来看插入操作。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191014214552854-1053163329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;红黑树插入&lt;/h2&gt;
&lt;p&gt;一说到插入我们立马就有了疑惑，根据红黑树规则一来看，每个节点非红即黑，那么我们插入的节点到底是红色还是黑色呢？如果为黑色将很大可能性会破坏规则五，此时我们为使树再次平衡将花费很大功夫，但是如果为红色，也很有可能性破坏以上规则二和四，但是比插入节点为黑色更加易于修复。所以这就是为什么插入节点为红色的原因。所以第一步，我们执行标准的BST插入且节点颜色为红色，插入操作分为以下四种场景。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）Z是根节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Z的父亲为红色节点、叔叔为红色节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Z的父亲为红色节点、叔叔为黑色节点（直线）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Z的父亲为红色节点、叔叔为黑色节点（三角形）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Z是根节点&lt;/h3&gt;
&lt;p&gt;当Z是根节点时，因为默认插入节点为红色，但根据红黑树规则二根节点为黑色，所以进行变色，直接将红色变为黑色，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191015210540265-2015137559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Z的父亲为红色节点、叔叔为红色节点&lt;/h3&gt;
&lt;p&gt;不区分Z是在其父亲节点左侧或者右侧，也不区分Z的父亲节点是在Z的祖父节点左侧或者右侧都进行如下相同处理操作。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1） 将“父亲节点”设为黑色。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2） 将“叔叔节点”设为黑色。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（3） 将“祖父节点”设为“红色”。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（4） 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191015234651280-657676600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191015205317793-398208950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;Z的父亲为红色节点、叔叔为黑色节点（直线）&lt;/h3&gt;
&lt;p&gt;根据如上大前提，有的童鞋可能分为Z在其父亲节点左侧和右侧两种情况，这里我采用的是Z、Z的父亲节点、Z的祖父节点在同一条直线上时的两种对称情况，同理如下讲解三角形时也是一样，将Z、Z的父亲节点、Z的祖父节点构成三角形时的两种对称情况，这样在脑海中思考并画一笔是不是会更好理解一点呢。由于对称分为两种情况：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）当Z的父亲节点在Z的祖父节点左侧时：&lt;/span&gt;&lt;span&gt;【1】将“父亲节点”设置为黑色 【2】将“祖父节点”设置为红色 【3】以“父亲节点”右旋&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）当Z的父亲节点在Z的祖父节点右侧时：&lt;/span&gt;&lt;span&gt;【1】将“父亲节点”设置为黑色 【2】将“祖父节点”设置为红色 【3】以“祖父节点”左旋&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191015233850098-1676528449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191015233957001-136480429.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;Z的父亲为红色节点、叔叔为黑色节点（三角形）&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）当Z的父亲节点在Z的祖父节点左侧时：&lt;/span&gt;&lt;span&gt;【1】将“父亲节点”左旋 【2】将“父亲节点”设置为当前节点（即如下A节点）【3】演变为如上直线第1种情况，继续操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）当Z的父亲节点在Z的祖父节点右侧时：&lt;/span&gt;&lt;span&gt;【1】将“父亲节点”右旋 【2】将“父亲节点”设置为当前节点（即如下A节点）【3】演变为如上直线第2种情况，继续操作&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191015221328839-1187317730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191015213706727-1016095867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;数据结构定义&lt;/h2&gt;
&lt;p&gt;首先我们需要定义节点元素，每一个节点有左孩子、右孩子、父亲节点、节点颜色和存储的元素，所以我们对节点进行如下定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; RedBlackNode&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;黑色节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BLACK = 0&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;红色节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RED = 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T key;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点&lt;/span&gt;
    RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; parent;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左孩子&lt;/span&gt;
    RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; left;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右孩子&lt;/span&gt;
    RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; right;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点颜色&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; color;

    RedBlackNode(){
        color &lt;/span&gt;=&lt;span&gt; BLACK;
        parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    RedBlackNode(T key){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是定义红黑树，关于左旋和右旋方法就不给出了，纸上画两笔就能搞定的事情，我们简单进行如下定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedBlackTree&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; RedBlackNode&amp;lt;T&amp;gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rotateLeft(RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; x) {

    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rotateRight(RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; x) {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;插入伪代码&lt;/h2&gt;
&lt;p&gt;当进行插入操作时，我们需要明确插入节点的具体位置，也就是说我们需要查找插入节点的父亲节点、左孩子和右孩子且默认插入节点为红色，最后通过变色或旋转来进行修复，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; z) {

        RedBlackNode&lt;/span&gt;&amp;lt;T&amp;gt; y = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        RedBlackNode&lt;/span&gt;&amp;lt;T&amp;gt; x =&lt;span&gt; root;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若根节点不为空，则循环查找插入节点的父节点&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;isNull(x)) {
            y &lt;/span&gt;=&lt;span&gt; x;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果元素值小于当前元素值则从左孩子继续查找&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (z.key.compareTo(x.key) &amp;lt; 0&lt;span&gt;) {

                x &lt;/span&gt;=&lt;span&gt; x.left;
            }

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果元素值小于当前元素值则从右孩子继续查找&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

                x &lt;/span&gt;=&lt;span&gt; x.right;
            }
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以y作为z的父亲节点&lt;/span&gt;
        z.parent =&lt;span&gt; y;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若父亲节点为空，说明插入节点为根节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isNull(y))
            root &lt;/span&gt;=&lt;span&gt; z;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (z.key.compareTo(y.key) &amp;lt; 0&lt;span&gt;)
            y.left &lt;/span&gt;=&lt;span&gt; z;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            y.right &lt;/span&gt;=&lt;span&gt; z;

        z.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        z.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        z.color &lt;/span&gt;=&lt;span&gt; RedBlackNode.RED;

        insertFixup(z);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来则是实现上述插入修复方法，上述我们分析插入操作几种的情况的前提是插入节点的父亲节点为红色，所以这里我们通过循环插入节点的父亲节点若为红色来进行修复，同时呢，无论是插入还是删除都是有其对称情况，也就是说我们可将插入和删除的节点分为是在其父亲节点的左侧还是右侧两种大的情况，毫无疑问这两种操作将必定对称，最浅显易懂的插入修复方法如下（已加上注释，可再次借助于上述分析来看） &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertFixup(RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; z) {

        RedBlackNode&lt;/span&gt;&amp;lt;T&amp;gt; y = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (z.parent.color ==&lt;span&gt; RedBlackNode.RED) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果Z的父亲节点在Z祖父节点左侧&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (z.parent ==&lt;span&gt; z.parent.parent.left) {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义Z的父亲兄弟节点&lt;/span&gt;
                y =&lt;span&gt; z.parent.parent.right;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果y是红色&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (y.color ==&lt;span&gt; RedBlackNode.RED) {
                
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;z的父亲变为黑色&lt;/span&gt;
                    z.parent.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y变为黑色&lt;/span&gt;
                    y.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;z的祖父变为红色&lt;/span&gt;
                    z.parent.parent.color =&lt;span&gt; RedBlackNode.RED;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将z的祖父作为z&lt;/span&gt;
                    z =&lt;span&gt; z.parent.parent;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果y是黑色且z是右孩子&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (z ==&lt;span&gt; z.parent.right) {

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将z的父亲作为z&lt;/span&gt;
                    z =&lt;span&gt; z.parent;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以z的父亲节点进行左旋&lt;/span&gt;
&lt;span&gt;                    rotateLeft(z);
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则如果y黑色且z是左孩子&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;z的父亲变为黑色&lt;/span&gt;
                    z.parent.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;z的祖父变为红色&lt;/span&gt;
                    z.parent.parent.color =&lt;span&gt; RedBlackNode.RED;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以z的祖父右旋&lt;/span&gt;
&lt;span&gt;                    rotateRight(z.parent.parent);
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果Z的父亲节点在Z祖父节点右侧&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义Z的父亲兄弟节点&lt;/span&gt;
                y =&lt;span&gt; z.parent.parent.left;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果y是红色&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (y.color ==&lt;span&gt; RedBlackNode.RED) {
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;z的父亲变为黑色&lt;/span&gt;
                    z.parent.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y变为黑色&lt;/span&gt;
                    y.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;z的祖父变为红色&lt;/span&gt;
                    z.parent.parent.color =&lt;span&gt; RedBlackNode.RED;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以z的父亲节点进行左旋&lt;/span&gt;
                    z =&lt;span&gt; z.parent.parent;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果y是黑色且z是左孩子&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (z ==&lt;span&gt; z.parent.left) {
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将z的父亲作为z&lt;/span&gt;
                    z =&lt;span&gt; z.parent;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以z的父亲节点进行右旋&lt;/span&gt;
&lt;span&gt;                    rotateRight(z);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则如果y黑色且z是右孩子&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                   
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;z的父亲变为黑色&lt;/span&gt;
                    z.parent.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;z的祖父变为红色&lt;/span&gt;
                    z.parent.parent.color =&lt;span&gt; RedBlackNode.RED;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以z的祖父左旋&lt;/span&gt;
&lt;span&gt;                    rotateLeft(z.parent.parent);
                }
            }
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作完毕后，根节点重新变为黑色&lt;/span&gt;
        root.color =&lt;span&gt; RedBlackNode.BLACK;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;红黑树删除 &lt;/h2&gt;
&lt;p&gt;在上述插入操作中，我们主要是检查叔叔的颜色从而考虑不同的情况，也就是说插入后违反的主要是两个连续的红色。在删除操作中，我们检查同级的颜色也就是说检查兄弟节点的颜色从而考虑不同的情况，删除主要违反的属性是子树中黑色高度的更改，因为删除黑色节点可能会导致根到叶路径的黑色高度降低，换言之就是破坏了红黑树规则五，那么我们到底应该如何删除呢？&lt;span&gt;执行标准的BST删除，&lt;/span&gt;&lt;span&gt;&lt;span&gt;当我们在BST中执行标准删除操作时，我们最终总是删除一个叶子节点或只有一个孩子的节点（对于内部节点，我们复制后继节点，然后递归调用删除后继节点，后继节点始终是叶节点或一个有一个孩子的节点），因此，我们只需要处理一个节点为叶子或有一个孩子的情况&lt;/span&gt;&lt;span&gt;&lt;span&gt;，因为删除是一个相当复杂的过程，为了理解删除，我们引入双重黑色的概念，当删除黑色节点并用黑色子节点替换时，该子节点被标记为double black，此时黑色的高度将不变，所以对于删除我们主要的任务就是将双黑色转换为单黑色即可&lt;/span&gt;。好像听起来感觉还是一脸懵逼，莫慌，接下来我依然将用详细的图解给大家讲解到底双黑是怎样的一个神奇存在。删除操作总的来说分为以下三种情况：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; （1） 被删除节点没有儿子，即为叶节点。（直接删除）&lt;br/&gt; （2） 被删除节点只有一个儿子。（直接删除该节点，并用该节点的唯一子节点顶替它的位置）&lt;br/&gt; （3） 被删除节点有两个儿子。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;以上第一和第二种情况就不用我多讲，对于第三种情况就涉及到上述我们引入的双黑的概念，参考链接中这样描述：比如删除节点v（黑色），则将后继节点u占据v节点，由于删除节点u为黑色，所以导致经过此节点的黑色节点数目减少了一个，为了解决这个问题，我们将占据的v节点额外引入一个黑色节点，虽然这样解决了红黑树规则五的问题，但是我们知道红黑树规则一为每个节点非红即黑，所以破坏了规则一，然后我们通过变色或旋转解决。我们将占据u节点上额外引入一个黑色节点，所以出现双黑，是不是有点疑惑，这说的到底是什么意思呢，我们看看如下图来理解将一目了然，那么在红黑树中如何将如下出现的双黑变为单黑的呢？请往下看。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191019001308410-1818161419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;在当前节点Z为双黑且不是根节点时&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;【1】左左情况（A节点是其父节点的左节点，C是A的左节点）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Z兄弟节点即A节点的左孩子变为黑色（2）以Z的父亲节点即B节点进行右旋（注：我们将看到右旋时D节点将搭接到B节点上，此时将Z节点上的双黑给出一个黑色节点来让D进行搭接，最终双黑演变成单黑）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191029220552461-2124784633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【2】 右右情况（A节点是其父节点的右节点，C是A的右节点）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Z兄弟节点即A节点的右孩子变为黑色（2）以Z的父亲节点即B节点进行左旋（注：我们将看到左旋时D节点将搭接到B节点上，此时将Z节点上的双黑给出一个黑色节点来让D进行搭接，最终双黑演变成单黑）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191029221243704-1025834055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【3】左右情况（A节点是其父节点的左节点，C是A的右节点）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Z兄弟节点即A节点变为红色（2）将Z兄弟节点即A节点的右孩子变为黑色（3）以Z的兄弟节点A进行左旋（4）演变成如上左左情况，继续操作&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191028222324703-1659827492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【4】右左情况（A节点是其父节点的右节点，C是A的左节点） &lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Z兄弟节点即A节点变为红色（2）将Z兄弟节点即A节点的左孩子变为黑色（3）以Z的兄弟节点A进行右旋（4）演变成如上右右情况，继续操作&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191028230304659-348787175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;在当前节点Z兄弟节点为黑色节点且孩子为黑色节点时&lt;/h3&gt;
&lt;p&gt; 【1】父节点为红色情况（变色）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Z节点的父亲节点即B节点变为红色（2）将Z节点的兄弟节点即A节点变为红色（3）只需变色：红色+双黑色=单个黑色&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191029225454909-1861142757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【2】父节点为黑色情况（父节点双黑，继续递归）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Z节点的兄弟节点即A节点变为红色（2）将Z的父亲节点即B节点赋给Z节点，继续进行递归操作&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191028235412907-1780676.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;在当前节点Z兄弟节点为红色节点时&lt;/h3&gt;
&lt;p&gt;【1】Z节点的兄弟节点即A节点在Z节点的父亲节点左边情况&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Z节点的兄弟节点即A节点变为黑色（2）将Z的父亲节点即B节点变为黑色（3）以Z节点的父亲节点即B节点进行右旋（4）演变成上述父亲节点为红色情况，继续操作&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191029001746246-1939162429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【2】Z节点的兄弟节点即A节点在Z节点的父亲节点右边情况&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Z节点的兄弟节点即A节点变为黑色（2）将Z的父亲节点即B节点变为黑色（3）以Z节点的父亲节点即B节点进行左旋（4）演变成上述父亲节点为红色情况，继续操作&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201910/589642-20191029003915882-1907749170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;删除伪代码&lt;/h2&gt;
&lt;p&gt;对于删除操作，首先我们需要查找到需要删除的节点 ，如我们所分析的那样，若删除节点孩子只有其一直接删除即可，若存在两个孩子，除了找到后继执行标准的删除操作外，还需进行删除修复操作，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; remove(RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; v) {

        RedBlackNode&lt;/span&gt;&amp;lt;T&amp;gt; z =&lt;span&gt; search(v.key);

        RedBlackNode&lt;/span&gt;&amp;lt;T&amp;gt; x = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        RedBlackNode&lt;/span&gt;&amp;lt;T&amp;gt; y = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果z的孩子之一为null，则必须删除z&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isNull(z.left) ||&lt;span&gt; isNull(z.right))
            y &lt;/span&gt;=&lt;span&gt; z;
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则我们需要删除z的后继&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; y =&lt;span&gt; findSuccessor(z);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令x为y的左或右的孩子（y只能有一个子代）&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isNull(y.left))
            x &lt;/span&gt;=&lt;span&gt; y.left;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            x &lt;/span&gt;=&lt;span&gt; y.right;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置y的父亲是x的父亲&lt;/span&gt;
        x.parent =&lt;span&gt; y.parent;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果y的父亲节点是null，说明x就是根节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isNull(y.parent))
            root &lt;/span&gt;=&lt;span&gt; x;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果y是左孩子，设置x是y的左兄弟&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!isNull(y.parent.left) &amp;amp;&amp;amp; y.parent.left ==&lt;span&gt; y)
            y.parent.left &lt;/span&gt;=&lt;span&gt; x;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果y是右孩子，设置x是y的右兄弟&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!isNull(y.parent.right) &amp;amp;&amp;amp; y.parent.right ==&lt;span&gt; y)
            y.parent.right &lt;/span&gt;=&lt;span&gt; x;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果y是黑色，则违反红黑树规则需修复&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (y.color ==&lt;span&gt; RedBlackNode.BLACK)
            removeFixup(x);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; removeFixup(RedBlackNode&amp;lt;T&amp;gt;&lt;span&gt; x) {

        RedBlackNode&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; w;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当删除节点不是根节点且为黑色时&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (x != root &amp;amp;&amp;amp; x.color ==&lt;span&gt; RedBlackNode.BLACK) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果x在其父亲节点左侧&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; x.parent.left) {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义x的兄弟节点&lt;/span&gt;
                w =&lt;span&gt; x.parent.right;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w是红色时&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (w.color ==&lt;span&gt; RedBlackNode.RED) {
                
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w变为黑色&lt;/span&gt;
                    w.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲变为红色&lt;/span&gt;
                    x.parent.color =&lt;span&gt; RedBlackNode.RED;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以x的父亲左旋&lt;/span&gt;
&lt;span&gt;                    rotateLeft(x.parent);
                    &lt;/span&gt;                    w =&lt;span&gt; x.parent.right;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w两个孩子都是黑色时&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (w.left.color == RedBlackNode.BLACK &amp;amp;&amp;amp;&lt;span&gt;
                        w.right.color &lt;/span&gt;==&lt;span&gt; RedBlackNode.BLACK) {
                        
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w变为黑色    &lt;/span&gt;
                    w.color =&lt;span&gt; RedBlackNode.RED;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲作为x&lt;/span&gt;
                    x =&lt;span&gt; x.parent;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; w的右孩子为黑色时&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (w.right.color ==&lt;span&gt; RedBlackNode.BLACK) {
                    
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w的左孩子变为黑色&lt;/span&gt;
                        w.left.color =&lt;span&gt; RedBlackNode.BLACK;
                        
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w变为红色&lt;/span&gt;
                        w.color =&lt;span&gt; RedBlackNode.RED;
                        
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以w右旋&lt;/span&gt;
&lt;span&gt;                        rotateRight(w);
                        
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新将x的父亲右侧孩子赋给w&lt;/span&gt;
                        w =&lt;span&gt; x.parent.right;
                    }
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; w是黑色，右黑子为红色时
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w变为x父亲的颜色&lt;/span&gt;
                    w.color =&lt;span&gt; x.parent.color;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲变为黑色&lt;/span&gt;
                    x.parent.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w的右孩子变为黑色&lt;/span&gt;
                    w.right.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以x的父亲左旋&lt;/span&gt;
&lt;span&gt;                    rotateLeft(x.parent);
                    &lt;/span&gt;                    &lt;br/&gt;x =&lt;span&gt; root;
                }
            }
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果x在其父亲节点右侧&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义x的兄弟节点&lt;/span&gt;
                w =&lt;span&gt; x.parent.left;

                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w是红色时&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (w.color ==&lt;span&gt; RedBlackNode.RED) {
                
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w变为黑色&lt;/span&gt;
                    w.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲变为红色&lt;/span&gt;
                    x.parent.color =&lt;span&gt; RedBlackNode.RED;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以x的父亲右旋&lt;/span&gt;
&lt;span&gt;                    rotateRight(x.parent);
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新将x的父亲左侧孩子赋给w&lt;/span&gt;
                    w =&lt;span&gt; x.parent.left;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w两个孩子都是黑色时&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (w.right.color == RedBlackNode.BLACK &amp;amp;&amp;amp;&lt;span&gt;
                        w.left.color &lt;/span&gt;==&lt;span&gt; RedBlackNode.BLACK) {
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w变为黑色                        &lt;/span&gt;
                    w.color =&lt;span&gt; RedBlackNode.RED;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲作为x&lt;/span&gt;
                    x =&lt;span&gt; x.parent;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; w的右孩子为黑色时&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (w.left.color ==&lt;span&gt; RedBlackNode.BLACK) {
                    
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w的左孩子变为黑色&lt;/span&gt;
                        w.right.color =&lt;span&gt; RedBlackNode.BLACK;
                        
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w变为红色&lt;/span&gt;
                        w.color =&lt;span&gt; RedBlackNode.RED;
                        
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以w左旋&lt;/span&gt;
&lt;span&gt;                        rotateLeft(w);
                        
                        w &lt;/span&gt;=&lt;span&gt; x.parent.left;
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; w是黑色，左黑子为红色时
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w变为x父亲的颜色&lt;/span&gt;
                    w.color =&lt;span&gt; x.parent.color;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲变为黑色&lt;/span&gt;
                    x.parent.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w的左孩子变为黑色&lt;/span&gt;
                    w.left.color =&lt;span&gt; RedBlackNode.BLACK;
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以x的父亲右旋&lt;/span&gt;
&lt;span&gt;                    rotateRight(x.parent);
                    
                    x &lt;/span&gt;=&lt;span&gt; root;
                }
            }
        }
        
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作完毕后，x节点重新变为黑色&lt;/span&gt;
        x.color =&lt;span&gt; RedBlackNode.BLACK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们详细分析了红黑树原理，同时给出了大部分伪代码，为了让看文章的童鞋能立马看的懂，并未做进一步的优化。纸上得来终觉浅，得知此事要躬行，看网上其他人的分析和自己再次进行分析效果可想而知，这篇文章断断续续搞了个把月才出来，在这里我只是通过图解的方式去理解，看到这篇文章的童鞋再结合网上红黑树大量文字的描述估计也能够理解的七七八八了。有了本节的理解，接下来我们再去分析其他底层实现，必将轻而易举，文中若有叙述不当或错误之处，可在评论中提出。感谢您的阅读，我们下节再会。&lt;/p&gt;
</description>
<pubDate>Wed, 30 Oct 2019 15:48:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 最近断断续续花了一个礼拜的时间去看红黑树算法，关于此算法还是比较难，因为涉及到诸多场景要考虑，同时接下来我们要讲解的HashMap、TreeMap等原理都涉及到红黑树算法，所以我们不得不了解其原</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/11610133.html</dc:identifier>
</item>
</channel>
</rss>