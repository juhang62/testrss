<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HotSpot的对象模型（6） - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/13291427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/13291427.html</guid>
<description>&lt;p&gt;接着上一篇，我们继续来讲oopDesc相关的子类。&lt;/p&gt;
&lt;h3&gt;3、instanceOopDesc类&lt;/h3&gt;
&lt;p&gt;instanceOopDesc类的实例表示除数组对象外的其它对象。在HotSpot中，对象在内存中存储的布局可以分为三块区域：对象头（header）、对象字段数据（field data）和对齐填充（padding），如下图所示。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200703143631938-1222023973.png&quot; alt=&quot;&quot; width=&quot;284&quot; height=&quot;399&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;下面详细介绍一下这3个组成部分。&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;strong&gt;1．&lt;/strong&gt;&lt;strong&gt;对象头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看到对象头分为两个部分，一个就是“Mark Word”，另外还有存储指向方法区对象类型数据的指针_klass或_compressed_klass。这两个都在介绍oopDesc类时详细介绍过，这里不再介绍。&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;．&lt;/strong&gt;&lt;strong&gt;对象字段数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象字段数据存储Java源代码中定义的各种类型字段内容，具体包括父类继承及子类定义的对象字段。&lt;/p&gt;
&lt;p&gt;存储顺序受到HotSpot分配策略参数（FieldAllocationStyle）和字段在Java源代码中定义顺序的影响。默认分配策略为：long/double、int、short/char、boolean、oops（对象指针，32位系统占用4字节，64位系统占用8字节），可以看到，相同宽度的字段总被分配到一起。&lt;/p&gt;
&lt;p&gt;如果虚拟机的-XX:+CompactFields参数为true，子类中较窄的变量可能插入到父类变量空隙中，以压缩节省空间。例如，当碰到long/doubles时，会将一些短类型插入long/doubles和header的空隙中。（空隙：64位系统开启压缩指针，header占12个字节，剩下的4个字节就是空隙。更多字段存储顺序的内容将在第XX章详细介绍。&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;．&lt;/strong&gt;&lt;strong&gt;对齐填充部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对齐填充部分不是必须的，只起占位符作用，没有其他含义。HotSpot虚拟机要求对象大小必须是8字节的整数倍，对象头是8字节整数倍，所以填充是对实例数据没有对齐的情况来说的。  &lt;/p&gt;
&lt;p&gt;在创建instanceOop对象时会调用allocate_instance()方法，这个方法的实现如下：  &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
instanceOop InstanceKlass::allocate_instance(TRAPS) {

  int size = size_helper();  // Query before forming handle.

  KlassHandle h_k(THREAD, this);

  instanceOop i;
  i = (instanceOop)CollectedHeap::obj_allocate(h_k, size, CHECK_NULL);
  return i;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用instanceKlass中的size_helper()方法获取创建instanceOop对象所需要的内存大小，调用CollectedHeap::obj_allocate()方法分配size大小的内存。首先介绍size_helper()方法的实现，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// Use this to return the size of an instance in heap words:
int size_helper() const {
    return layout_helper_to_size_helper(layout_helper());
}

int layout_helper() const  { 
   return _layout_helper; 
}

static int layout_helper_to_size_helper(jint lh) {
    assert(lh &amp;gt; (jint)_lh_neutral_value, &quot;must be instance&quot;);
    // Note that the following expression discards _lh_instance_slow_path_bit.
    return lh &amp;gt;&amp;gt; LogHeapWordSize; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从_layout_helper属性中获取大小，之前介绍过这个综合描述符，如果为InstanceKlass，则组合数字中含有的是instanceOop对象的大小，在设置时调用的是instance_layout_helper()方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static jint instance_layout_helper(jint size, bool slow_path_flag) {
    return (size &amp;lt;&amp;lt; LogHeapWordSize)  // LogHeapWordSize=3
      |    (slow_path_flag ? _lh_instance_slow_path_bit : 0); // 实例慢速分配有关
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取size时需要向右移动3位即可。这个方法在创建InstanceKlass对象时会调用，不过size通常会初始化为0，在调用parseClassFile()方法计算完实例的大小时，还会调用此方法更新为真正需要的instanceOop对象大小，在解析类文件时会详细介绍实例大小的计算过程。　&lt;/p&gt;
&lt;p&gt;在InstanceKlass::allocate_instance()方法中调用CollectedHeap::obj_allocate()方法分配size大小的内存并将内存初始化为零值，方法将会在介绍垃圾回收时详细介绍，这里不介绍。 &lt;/p&gt;
&lt;h3&gt;4、arrayOopDesc类&lt;/h3&gt;
&lt;p&gt;arrayOopDesc类的实例表示Java数组对象。具体的基本类型数组（对象）或对象类型数组（对象）由具体的C++中定义的子类实例来表示。在HotSpot虚拟机中，数组对象在内存中存储的布局可以分为三块区域：对象头（header）、对象字段数据（field data）和对齐填充（padding），如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200703143948069-3171163.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;与Java对象内存布局唯一不同之处在于，数组对象的对象头中还会存储数组的长度length，占用的内存空间为4字节。在64位系统下，存放_metadata的空间大小是8字节，_mark是8字节，length是4字节，对象头为20字节，由于要按8字节对齐，所以会填充4字节，最终占用24字节。64位开启指针压缩的情况下，存放_metadata的空间大小是4字节，_mark是8字节，length是4字节，对象头为16字节。  &lt;/p&gt;
&lt;h3&gt;5、arrayOopDesc类的子类 &lt;/h3&gt;
&lt;p&gt;typeArrayOopDesc类的实例表示Java基本类型数组（对象），objArrayOopDesc类的实例表示Java对象类型数组（对象）。当需要创建typeArrayOopDesc对象时，通常会调用oopFactory类中定义的工厂方法，例如创建一个boolean数组，则调用new_boolArray()方法，如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static typeArrayOop    new_boolArray(int length, TRAPS) {
          TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::boolArrayKlassObj());
          return tak-&amp;gt;allocate(length, CHECK_NULL);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用Universe::boolArrayKlassObj()方法获取_charArrayKlassObj属性的值，也就是之前介绍的、调用TypeArrayKlass::create_klass(T_BOOLEAN, sizeof(jboolean), CHECK)方法创建的表示boolean数组的TypeArrayKlass对象，然后调用TypeArrayKlass中的allocate()方法创建typeArrayOop对象，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
typeArrayOop allocate(int length, TRAPS) {
          return allocate_common(length, true, THREAD);
}

typeArrayOop TypeArrayKlass::allocate_common(int length, bool do_zero, TRAPS) {
  assert(log2_element_size() &amp;gt;= 0, &quot;bad scale&quot;);
  if (length &amp;gt;= 0) {
    if (length &amp;lt;= max_length()) {
      size_t size = typeArrayOopDesc::object_size(layout_helper(), length);
      KlassHandle h_k(THREAD, this);
      typeArrayOop t;
      CollectedHeap* ch = Universe::heap();
      if (do_zero) {
        t = (typeArrayOop)CollectedHeap::array_allocate(h_k, (int)size, length, CHECK_NULL);
      } else {
        t = (typeArrayOop)CollectedHeap::array_allocate_nozero(h_k, (int)size, length, CHECK_NULL);
      }
      return t;
    } 
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数length表示创建数组的大小，而do_zero表示是否需要在分配数组内存时，将内存初始化为堆值。方法首先调用typeArrayOopDesc::object_size()方法从_layout_helper中获取数组的大小，方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
static int object_size(int lh, int length) {
    int instance_header_size = Klass::layout_helper_header_size(lh);
    int element_shift = Klass::layout_helper_log2_element_size(lh);

    julong size_in_bytes = length;
    size_in_bytes &amp;lt;&amp;lt;= element_shift;
    size_in_bytes += instance_header_size;
    // 按8字节对齐，填充的一部分
    julong size_in_words = ((size_in_bytes + (HeapWordSize-1)) &amp;gt;&amp;gt; LogHeapWordSize);

    return align_object_size((intptr_t)size_in_words); // 对齐，填充的一部分
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前介绍过，当为ArrayKlass时，_layout_helper属性是个组合数字，调用 Klass::layout_helper_header_size()方法获取数组头元素的字节数；调用Klass::layout_helper_log2_element_size()方法获取数组元素的大小，对于数组元素是boolean类型来说，这个值为1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
size = instance_header_size + length&amp;lt;&amp;lt;element_shift + 对齐填充
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是对象头加上实例数据，然后再加上对齐填充。　　&lt;/p&gt;
&lt;p&gt;在TypeArrayKlass::allocate_common()方法中获取到TypeArrayOopDesc对象所需要分配的内存大小后，就会调用CollectedHeap::array_allocate()或CollectedHeap::array_allocate_nozero()方法在堆上分配内存空间，关于在堆上分配内存的方法在后面介绍垃圾回收时会详细介绍，这里不介绍。&lt;/p&gt;
&lt;p&gt;objArrayOop的创建与typeArrayOop的创建非常类似，也是调用oopFactory类中的工厂方法new_objectArray()方法，然后调用ObjArrayKlass::allocate()方法，这里不在介绍。&lt;/p&gt;
&lt;p&gt;相关文章的链接如下：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13215548.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;2、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13217159.html&quot; target=&quot;_blank&quot;&gt;调试HotSpot源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot; target=&quot;_blank&quot;&gt;HotSpot项目结构&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;4、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13228157.html&quot; target=&quot;_blank&quot;&gt;HotSpot的启动过程&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;5、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13233607.html&quot; target=&quot;_blank&quot;&gt;HotSpot二分模型（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13237631.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（2）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;7、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13252983.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（3） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13272865.html&quot;&gt;HotSpot的类模型（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13289686.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（5） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;　&lt;/p&gt;

</description>
<pubDate>Mon, 13 Jul 2020 00:36:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>接着上一篇，我们继续来讲oopDesc相关的子类。 3、instanceOopDesc类 instanceOopDesc类的实例表示除数组对象外的其它对象。在HotSpot中，对象在内存中存储的布局可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/13291427.html</dc:identifier>
</item>
<item>
<title>使用Typora写博客，图片即时上传，无需第三方图床-EasyBlogImageForTypora - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13285420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13285420.html</guid>
<description>&lt;p&gt;习惯使用markdown的人应该都知道Typora这个神器，它非常简洁高效。虽然博客园的在线markdown编辑器也不错，但毕竟是网页版，每次写东西需要登录系统-进后台-找到文章-编辑-保存草稿。。。非常难受。。。&lt;/p&gt;
&lt;p&gt;但是使用Typora来写的话，文章图片又是个问题，本地写完粘贴到网站上，图片全丢。。。&lt;/p&gt;
&lt;p&gt;大多数解决方案是Typora+PicGo+第三方图床，图床有收费的和免费的，总结一下几个常用的：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;七牛云&lt;/p&gt;
&lt;p&gt;专业，快速，有免费的存储空间。但是免费域名有使用期限，到期后需要自己备案域名。。。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;阿里云oss&lt;/p&gt;
&lt;p&gt;专业，快速，存储空间便宜，一年9块钱40G。但是下行流量需要另外收费。。。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;github&lt;/p&gt;
&lt;p&gt;免费。但不是专业图床，国内访问速度太慢。。。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;gitee&lt;/p&gt;
&lt;p&gt;免费，快速。但不是专业图床，有防盗链风险，比如微信浏览器就打不开gitee的图，gitee官方是禁止用来做图床的。。。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;。。。。。。&lt;/p&gt;
&lt;p&gt;其实Typora除了支持PicGo上传图片以外，还支持自定义上传服务。于是自己写了个简单程序，在本地写作时，直接把图片传到自己的博客网站，就不用折腾各种第三方图床了，写完直接可以粘贴到网站。&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用Typora写作，图片即时同步到博客网站，无需第三方图床，写完可直接粘贴。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;适用范围&quot;&gt;适用范围&lt;/h2&gt;
&lt;p&gt;本程序基于.net core 3.1开发，支持在win-x64，mac osx-x64系统运行，免安装。linux暂时不考虑，如果有需要再说。&lt;/p&gt;
&lt;p&gt;程序的上传服务是使用MetaWebBlog API，MetaWebBlog API(MWA)是一个Blog程序的接口标准，理论上支持MetaWebBlog API标准的博客网站，都可以使用本程序来上传图片，你只需要在程序中配置一下你的博客基本信息即可。目前我自己测试通过的有博客园、开源中国（oschina)；CSDN的接口貌似不能用了。&lt;/p&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;h3 id=&quot;windows&quot;&gt;windows&lt;/h3&gt;
&lt;ol readability=&quot;5.160530191458&quot;&gt;&lt;li readability=&quot;2.8009259259259&quot;&gt;
&lt;p&gt;下载程序：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xiajingren/EasyBlogImageForTypora/releases/&quot;&gt;https://github.com/xiajingren/EasyBlogImageForTypora/releases/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载zip文件，解压到合适的目录。&lt;/p&gt;
&lt;p&gt;github访问慢的话去蓝奏云也可以：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wws.lanzous.com/b01hidfwh&quot;&gt;https://wws.lanzous.com/b01hidfwh&lt;/a&gt;&lt;br/&gt;密码:6jnm&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;配置博客参数：&lt;/p&gt;
&lt;p&gt;运行程序，按照界面提示输入配置信息。完成后退出就行，参数只需配置一次，如果以后要修改的话再次运行即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200711204347215-519142653.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Typora设置：&lt;/p&gt;
&lt;p&gt;Typora进入偏好设置-图像，上传服务选择Custom command，自定义命令填写EasyBlogImageForTypora所在路径，我这里是D:\EasyBlogImageForTypora\EasyBlogImageForTypora.exe&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200711115414497-1150081517.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置完成后点击验证图片上传选项：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200711115937146-467789165.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现验证成功就ok了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;macos&quot;&gt;macOS&lt;/h3&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1.4413407821229&quot;&gt;
&lt;p&gt;下载安装.net core运行时：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet-core/thank-you/runtime-3.1.5-macos-x64-installer&quot;&gt;https://dotnet.microsoft.com/download/dotnet-core/thank-you/runtime-3.1.5-macos-x64-installer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载完安装一下就好，文件很小才28M。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;剩下的步骤和windows一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200711173418486-1017714538.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200711173720907-628520961.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202007/610959-20200711173830080-1995768272.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/xiajingren/EasyBlogImageForTypora&quot;&gt;https://github.com/xiajingren/EasyBlogImageForTypora&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以给个star哦。。。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jul 2020 00:13:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>背景 习惯使用markdown的人应该都知道Typora这个神器，它非常简洁高效。虽然博客园的在线markdown编辑器也不错，但毕竟是网页版，每次写东西需要登录系统-进后台-找到文章-编辑-保存草稿</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13285420.html</dc:identifier>
</item>
<item>
<title>年中佛系求职记录 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13192977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13192977.html</guid>
<description>&lt;p&gt;　　我从事的是前端岗位，四月中旬时投过一波，很多都是找朋友或老同事内推，但都没响应，连面试机会都没有，只得作罢。&lt;/p&gt;
&lt;p&gt;　　一直到五月底开始，陆陆续续开始有人来找我投简历，我在 boss 直聘和拉勾上公开了部分工作和项目信息后，找我的人也变多了。&lt;/p&gt;
&lt;p&gt;　　我投了几家大厂或上规模的公司，都需要好几轮，基本都是电话或视频面试，只去了两个现场。面的内容可以分为两大块：技术和项目，这些年一直专注于前端基础知识的积累（&lt;span&gt;&lt;a href=&quot;https://www.kancloud.cn/pwstrick/fe-questions/1094971&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;前端躬行记系列&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;），而忽视了项目的沉淀以及团队的建设。并且由于求职的岗位都是资深或高级前端，因此相对的要求也比较高（除了技术要扎实之外，还需要时刻关注着前沿技术，并且还得是个业务专家，能为公司作出额外的贡献），使得这么多次面试都不太理想。不过，从这几次的面试中，得到的收获也不少，既然认清了当前形势，就得适当的调整一下今后的工作重点。&lt;/p&gt;
&lt;p&gt;　　目前来看求职的时候公司会看年龄、毕业院校和大厂经验，年轻名校有大厂经验的人机会会多一点。3 ～ 5 年工作经验的人特别吃香，非常建议早做职业规划，在毕业后开始几年先沉淀一下，然后去大厂历练历练，对以后的职业发展会有很大帮助。&lt;/p&gt;
&lt;p&gt;　　自己为了能更好的应对面试，也整理了&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/daily&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;一套面试资料&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，希望对大家会有所帮助。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）基础要扎实&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对于基础知识，得脱口而口，信手捏来。这次面的内容涉及 CSS 的比较少，JavaScript 和网络问的比较多，性能优化是必问的，还有时髦的 ES6 、React （我平时的项目都是用React写的）也是出现的比较多，数据结构和简单的算法也需要好好准备准备。&lt;/p&gt;
&lt;p&gt;　　除了常规的问答之外，还需要手写代码。上机测试或者现场笔试，非常建议大家平时纯手写，不要借助 IDE 的自动提示。目前来看，很多公司都会出个几道笔试题，试试求职者的编程能力。题目的话都不会很难，有空的话可以去刷刷&lt;span&gt;&lt;a href=&quot;https://www.nowcoder.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;牛客网&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;或&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;力扣&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，保持手感。简单的算法可以练练，像快速排序、递归等，数据结构中的链表、二叉树平时都可以复习一下，只靠面试前的突击很容易忘记。我这次算法没有准备的很好，遇到一道很简单的背包问题，没有答出来，可惜了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）视野要宽阔&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　不要局限于自己眼前的一亩三分地，在平时就要有意识的拓宽自己的技术视野。例如现在非常流行小程序，那么你是否对小程序的原理有所了解。还比如很多公司都在实现同构，那么你是否自己操作过。还有微前端地目的是否有过了解，市面上给出的方案是否做过对比。时刻关注前沿技术，紧跟时代潮流，这也算是前端的一个特色吧。前端技术日新月异，没过多少天，就会冒出新思想新技术。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）理解要深度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　不要只停留在表层，适当地去深究一下你所看到的技术。例如你说跨域用的方案是CORS，那么它的跨域原理是怎么样的？如果要传递Cookie，那么前后端要如何配置？什么情况下，会发出两次请求？等等。当抛出一个技术点时，可以深挖到很多知识点。平时开发中，多问自己几个为什么？或许就能注意到自己的盲点。面试官会根据你的简历，找一个技术点去慢慢的渗透，看你理解到什么程度。有次面试还被问到，你最擅长的技能点是什么？平时真的可以往某个点做些深入研究。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）团队的建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　除了完成自己手头工作之外，你为团队还带来了哪些贡献或变化？例如为新人提供技术思路，封装通用组件为成员使用，又或者制定自动化工作流改善工作效率等。多为团队着想，就能发现很多问题，试着解决这些问题，提升自己的同时也为团队带来便利。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）思路要多样&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　面试中会遇到许多场景题，然后让你给出解决方案，大部分都是你没遇到过的，而你的回答当然是方案越多越好。这时候就得用自己过往的经验以及大胆的创新来给出技术思路。例如如何在一个域名中登录，而在另一个域名中直接是登录状态。再比如当重写XMLHttpRequest后，如果遇到第三方库也重写了它，碰到问题该如何排查？&lt;/p&gt;
&lt;p&gt;　　其实平时上班的时候多向自己问几个为什么，时间长了，自己的思路也能更加开阔。还有就是平时项目中遇到的难点，自己也需要有意识的记录下来，试着多搞出些方案来。&lt;/p&gt;

&lt;p class=&quot;p1&quot;&gt;　　在考察项目时，经常会问你遇到的比较困难的项目是什么？&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;　　我自认为项目中的难点就是解决从未遇到过的问题。但说着说着自己会感觉好像也没那么难，就是有点烦。大部分人所做的业务都不会很难，那么就自己给自己加点难度。例如我平时会做广告落地页，就是个表单填线索，加个图片滑动，商品介绍，商业视频等部分。很普通很平凡，但是如果做成一个可拖拽的可视化编辑器，那么就会很有搞头，不仅能大大提升工作效率（甚至可以让非技术人员自行搭建页面），并且涉及到的技术点会很多，将碰到许许多多、形形色色的各类问题。这个时候就可以和面试官侃侃而谈了。要做成这种程度，需要大把时间的沉淀，非一朝一夕可成，所以建议大家早做打算。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;　　再比如我在简历中提到自己设计过一个&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/pineapple&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;性能监控系统&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，有次面试正好碰到一个做过多年监控系统的面试官。由于我这系统还未正式上线，很多点还未考虑到，并且还仅仅是个雏形，很不完善，面试官问到的许多问题我也答不上来，即使回答了，也感觉给出的解释非常的苍白无力。例如通过你这系统解决过哪些业务瓶颈？你的系统架构是怎么样的？一个月后你预估数据库的存储量将是多少？你在选择的服务器配置是怎么样的？非常建议大家平时在公司推动一些本职工作以外的项目，当然这些项目对业务是有益的，其实就是为自己增值，在上线后记录遇到的问题以及带来的贡献。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）企鹅杏仁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一轮 电话面试&lt;/p&gt;
&lt;p&gt;　　在开始的时候，问了点项目问题，让我挑几个有挑战的说。剩下的就都是在问题基础，下面只列出了想到的几个问题。&lt;/p&gt;
&lt;p&gt;　　（1）网络：描述TCP三次握手，四次挥手，HTTP2.0的优势，HTTP协议的特点。&lt;/p&gt;
&lt;p&gt;　　（2）数据结构：链表和数组的区别，栈和队列的特点。&lt;/p&gt;
&lt;p&gt;　　（3）简单算法：在两个数组中找到相同的元素，在数字数组中找出最大值。&lt;/p&gt;
&lt;p&gt;第二轮 技术面试&lt;/p&gt;
&lt;p&gt;　　下午三点的面试，提早到了，整层楼都是该公司的，不过工位有点小。&lt;/p&gt;
&lt;p&gt;　　先做一份笔试试卷，四道题目，三十分钟。其实四道题目可以在一张纸里打印，不过用了两张纸，第一张纸翻过来还有一道题目，被我漏掉了。&lt;/p&gt;
&lt;p&gt;　　题目做好后在一个会议室里等了四十分钟，才等到一个前端小姐姐。主要问了些比较基础的问题，集中在：&lt;/p&gt;
&lt;p&gt;　　（1）白屏处理、懒加载的实现等性能问题。&lt;/p&gt;
&lt;p&gt;　　（2）Hooks的使用等React语法问题。&lt;/p&gt;
&lt;p&gt;　　（3）Webpack使用了哪些加载器等工程化问题。&lt;/p&gt;
&lt;p&gt;　　（4）CDN的原理等网络问题。&lt;/p&gt;
&lt;p&gt;　　（5）KOA有哪些中间件等Node.js问题。&lt;/p&gt;
&lt;p&gt;　　面好后等了十几分钟，技术leader来面我，他问：&lt;/p&gt;
&lt;p&gt;　　（1）在实现一个微信聊天功能的时候会用到哪些技术。&lt;/p&gt;
&lt;p&gt;　　（2）你对目前前端现状的看法。&lt;/p&gt;
&lt;p&gt;　　（3）你未来两年的职业规划是怎样的。&lt;/p&gt;
&lt;p&gt;　　（4）小程序在微信中是如何执行的。&lt;/p&gt;
&lt;p&gt;　　（5）如何通过微信公众号获取用户信息。&lt;/p&gt;
&lt;p&gt;　　（6）JavaScript的缓存有哪些（cookie、LocalStorage等）。&lt;/p&gt;
&lt;p&gt;　　（7）如何做到在两个域名中保持登录状态，例如在淘宝登录的帐号，当从淘宝页面进入天猫时不需要重新登录。&lt;/p&gt;
&lt;p&gt;　　（8）你与其他人相比，有哪些优势。&lt;/p&gt;
&lt;p&gt;　　（9）对微前端的理解。&lt;/p&gt;
&lt;p&gt;　　（10）两个数字变量，不使用第三个临时变量，交换两者的值。&lt;/p&gt;
&lt;p&gt;　　（11）你最近在读什么书？&lt;/p&gt;
&lt;p&gt;　　（12）Charles能够解读HTTPS的原理是什么？&lt;/p&gt;
&lt;p&gt;　　再次面完后，HR与我交流，询问了我的期望薪资、居住地、籍贯等问题，最后说如果该轮通过，会在3-5个工作日内安排CTO视频面试。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）京东&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一轮 电话面试&lt;/p&gt;
&lt;p&gt;　　项目和基础相辅相成，问的问题比较全面。&lt;/p&gt;
&lt;p&gt;　　说说你最近的项目，深入讨论如何封装的组件。在简历中提到了自己设计的一个&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/PrimusUI&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UI库&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;和插件，就被问到如何使用，扩展，原理等。&lt;/p&gt;
&lt;p&gt;　　基础题包括JavaScript、网络和CSS，下面只列出了想到的几个问题。&lt;/p&gt;
&lt;p&gt;　　（1）JavaScript：闭包，Event Loop。&lt;/p&gt;
&lt;p&gt;　　（2）网络：输入URL发生的过程。&lt;/p&gt;
&lt;p&gt;　　（3）CSS：两栏布局，上下居中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）华为&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　周六下午四点钟左右，华为HR让我投个简历，和我简单介绍了一下华为的4轮面试流程。&lt;/p&gt;
&lt;p&gt;第一轮 在线做题&lt;/p&gt;
&lt;p&gt;　　在牛客网上生成的一个考试地址，有三道题，两道一星，一道两星。他们给了一个练习地址，既能熟悉考试环境，也能练练感觉。&lt;/p&gt;
&lt;p&gt;　　在准备的这两天，自己意识到平时得尽量手写方法名称，不要过于依赖自动提示。并且有空的时候就去刷刷难度在中等偏下的编程题，保持手感。&lt;/p&gt;
&lt;p&gt;第二轮 技术视频面试&lt;/p&gt;
&lt;p&gt;　　有两个面试官，第一个是当前面试部门的面试官，以项目为主，基础概念问的不多。&lt;/p&gt;
&lt;p&gt;　　（1）在内部做过哪些技术分享。&lt;/p&gt;
&lt;p&gt;　　（2）你觉得组件封装有哪些注意点。&lt;/p&gt;
&lt;p&gt;　　（3）你遇到的比较困难的项目是什么？&lt;/p&gt;
&lt;p&gt;　　（4）你平时会做哪些性能优化？&lt;/p&gt;
&lt;p&gt;　　（5）请叙述一下React的生命周期。&lt;/p&gt;
&lt;p&gt;　　（6）双向绑定的原理。&lt;/p&gt;
&lt;p&gt;　　（7）diffing算法比对过程。&lt;/p&gt;
&lt;p&gt;　　（8）有没有搞过前端架构？初始化项目的那种。&lt;/p&gt;
&lt;p&gt;　　（9）最后一道编程题&lt;/p&gt;
&lt;p&gt;　　第二个是跨部门的面试官，同样以项目为主，基础概念比较少，有几个是给你一个场景，让你来分析，还有一些是比较底层的计算机知识。&lt;/p&gt;
&lt;p&gt;　　（1）介绍一下你的项目经历&lt;/p&gt;
&lt;p&gt;　　（2）Chrome浏览器打开了几个进程。&lt;/p&gt;
&lt;p&gt;　　（3）浏览器性能优化，如果浏览器占了300M内存，该如何优化。&lt;/p&gt;
&lt;p&gt;　　（4）package.json中有哪些常用字段？package.lock.json有什么作用？&lt;/p&gt;
&lt;p&gt;　　（5）你有了解过Nginx吗？&lt;/p&gt;
&lt;p&gt;　　（6）最后一道编程题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）喜马拉雅&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一轮 视频面试&lt;/p&gt;
&lt;p&gt;　　使用了腾讯会议，下午两点的面试，天气很阴沉，随时要下阵雨的节奏，但是直到面试结束都没下大雨。视频面试的范围比较广泛，有基础也有实际项目。&lt;/p&gt;
&lt;p&gt;　　（1）用过哪些CSS动画，CSS的定位有哪些？&lt;/p&gt;
&lt;p&gt;　　（2）是否用过React Hooks？函数式编程的理解。&lt;/p&gt;
&lt;p&gt;　　（3）在浏览器输入URL后发生的过程。强缓存和协商缓存。前端状态码301和302。HTTPs为何是安全的？&lt;/p&gt;
&lt;p&gt;　　（4）设计模式实现发布订阅。&lt;/p&gt;
&lt;p&gt;　　（5）你的职业规划是怎么样的。&lt;/p&gt;
&lt;p&gt;　　（6）用Node.js做过些什么？&lt;/p&gt;
&lt;p&gt;　　（7）什么情况下会驱使你去看书？&lt;/p&gt;
&lt;p&gt;　　（8）你做过哪些比较有困难的项目？&lt;/p&gt;
&lt;p&gt;　　（9）你的开发经历跨度很大，为什么现在选择前端？&lt;/p&gt;
&lt;p&gt;　　（10）session和cookie的区别。&lt;/p&gt;
&lt;p&gt;　　（11）谈谈你对XSS和CSRF的理解。&lt;/p&gt;
&lt;p&gt;　　（12）事件委托的原理。&lt;/p&gt;
&lt;p&gt;第二轮 现场面试&lt;/p&gt;
&lt;p&gt;　　面试安排在下午，当天是雷暴预警，喜马拉雅的总部还是蛮大的，有两栋楼，楼的外层装修也很喜马拉雅。面试官会从简历中挑出一个技术点，有深度有广度的提问，很容易问到自己的技术盲点。&lt;/p&gt;
&lt;p&gt;　　（1）JSBridge原理。iOS和安卓对JSbridge的处理有哪些不同，为什么使用iframe实现？&lt;/p&gt;
&lt;p&gt;　　（2）CORS原理。跨域的时候带cookie是怎么配置的。有时候跨域请求会发送两次，为什么？&lt;/p&gt;
&lt;p&gt;　　（3）你对哪个技术点比较擅长。&lt;/p&gt;
&lt;p&gt;　　（4）同构的原理是怎么样的。为什么可以做到服务端和客户端只用一套代码就可以了。&lt;/p&gt;
&lt;p&gt;　　（5）SSR有什么特点？&lt;/p&gt;
&lt;p&gt;　　（6）你最近在看什么书？&lt;/p&gt;
&lt;p&gt;　　（7）SVG有哪些特点？和Canvas比有什么区别。&lt;/p&gt;
&lt;p&gt;　　（8）webpack的加载器和插件有什么本质区别？&lt;/p&gt;
&lt;p&gt;　　（9）Promise的原理是怎么样的？&lt;/p&gt;
&lt;p&gt;　　（10）请写一个正则，读取URL中的参数。&lt;/p&gt;
&lt;p&gt;　　（11）你平时是怎么做性能优化的？&lt;/p&gt;
&lt;p&gt;　　（12）宏任务和微任务有哪些？浏览器对它们的处理有何不同？&lt;/p&gt;
&lt;p&gt;　　（13）如何上传大图。&lt;/p&gt;
&lt;p&gt;　　（14）如何在Canvas中画一张第三方域名的图片。&lt;/p&gt;
&lt;p&gt;　　（15）服务端如何将分片的文件组合成一个完整的文件。&lt;/p&gt;
&lt;p&gt;　　（16）React为什么要推广Hooks？&lt;/p&gt;
&lt;p&gt;　　（17）请用两种方式实现前端的路由。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）饿了么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一轮 技术基础&lt;/p&gt;
&lt;p&gt;　　当天面完喜马拉雅，饿了么的人找到了我。投过简历后，过了一个小时就打我电话安排面试，正好当天没啥安排，就直接开面了。问的内容还是比较偏基础的，包括一些CSS的解决方案。&lt;/p&gt;
&lt;p&gt;　　（1）rem是如何计算的。&lt;/p&gt;
&lt;p&gt;　　（2）iframe之间是如何通信的。&lt;/p&gt;
&lt;p&gt;　　（3）有一个弹层，如何禁止下层页面的滚动？&lt;/p&gt;
&lt;p&gt;　　（4）如何实现双向绑定。&lt;/p&gt;
&lt;p&gt;　　（5）对ES6的代理有了解吗？&lt;/p&gt;
&lt;p&gt;　　（6）白屏的依据是什么？如何优化？&lt;/p&gt;
&lt;p&gt;　　（7）解释一下Event Loop。宏任务和微任务。&lt;/p&gt;
&lt;p&gt;　　（8）webpack的运行过程是怎么样的。&lt;/p&gt;
&lt;p&gt;第二轮 技术项目&lt;/p&gt;
&lt;p&gt;　　交谈了30分钟左右，主要围绕着实际项目展开。&lt;/p&gt;
&lt;p&gt;　　（1）说说你的工作经历。&lt;/p&gt;
&lt;p&gt;　　（2）你最近在了解什么新技术？有没有考虑应用到团队中？&lt;/p&gt;
&lt;p&gt;　　（3）你平时会不会关注自己的业务？有没有想过拓展公司业务？&lt;/p&gt;
&lt;p&gt;　　（4）你们跨域是怎么做的？有没有用网关实现？&lt;/p&gt;
&lt;p&gt;　　（5）你最近有没有遇到比较困难的事情？&lt;/p&gt;
&lt;p&gt;　　（6）你做了这么多年前端，有没有对这个行业提供一些产出？&lt;/p&gt;
&lt;p&gt;　　（7）在团队中，你有没有制订过标准？或者有什么贡献？&lt;/p&gt;
&lt;p&gt;　　（8）你们的代码是如何发布的？具体发布原理有了解过吗？&lt;/p&gt;
&lt;p&gt;技术负责人&lt;/p&gt;
&lt;p&gt;　　（1）你为什么选择前端？&lt;/p&gt;
&lt;p&gt;　　（2）你为什么做了5年后端后才选择前端？&lt;/p&gt;
&lt;p&gt;　　（3）你们团队几个人？你为团队做过哪些贡献？&lt;/p&gt;
&lt;p&gt;　　（4）你最拿的出手的项目是什么？&lt;/p&gt;
&lt;p&gt;　　（5）如果你还在这家公司呆着，你接下来会做什么？&lt;/p&gt;
&lt;p&gt;　　（6）你期望要加入的团队是怎么样的？&lt;/p&gt;
&lt;p&gt;　　（7）你做的性能监控系统与业界的相比，有什么特点或优势？&lt;/p&gt;
&lt;p&gt;　　（8）你有什么优势？&lt;/p&gt;
&lt;p&gt;　　（9）你简历中完成了100多个项目，这个数字很醒目，你想说明什么？&lt;/p&gt;
&lt;p&gt;第三轮 跨部门&lt;/p&gt;
&lt;p&gt;　　跨部门遇到的面试官是专门搞监控系统的，他在看了我的简历后，着重对简历上的性能监控系统开展了提问，下面只列出了几个。&lt;/p&gt;
&lt;p&gt;　　（1）你做过的比较困难的项目有哪些？&lt;/p&gt;
&lt;p&gt;　　（2）你的性能监控系统的架构是怎么样的？&lt;/p&gt;
&lt;p&gt;　　（3）你目前负责哪些业务？&lt;/p&gt;
&lt;p&gt;　　（4）你有没有计算过一个月后，你的MongoDB的存储量是多少？&lt;/p&gt;
&lt;p&gt;　　（5）在重写XMLHttpRequest后，如果遇到第三方库也重写了它，碰到问题该如何排查？&lt;/p&gt;
&lt;p&gt;　　（6）如何通过你的性能系统，来找出业务瓶颈？&lt;/p&gt;
&lt;p&gt;　　（7）是否考虑过监控多端，例如浏览器、小程序、客户端等。&lt;/p&gt;

</description>
<pubDate>Sun, 12 Jul 2020 23:19:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>我从事的是前端岗位，四月中旬时投过一波，很多都是找朋友或老同事内推，但都没响应，连面试机会都没有，只得作罢。 一直到五月底开始，陆陆续续开始有人来找我投简历，我在 boss 直聘和拉勾上公开了部分工作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13192977.html</dc:identifier>
</item>
<item>
<title>深入浅出AQS源码解析 - PinXiong</title>
<link>http://www.cnblogs.com/pinxiong/p/13288201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pinxiong/p/13288201.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;最近一直在研究AQS的源码，希望可以更深刻的理解AQS的实现原理。虽然网上有很多关于AQS的源码分析，但是看完以后感觉还是一知半解。于是，我将自己的整个理解过程记录下来了，希望对大家有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基本原理&quot;&gt;基本原理&lt;/h3&gt;
&lt;p&gt;AQS是Java中锁的基础，主要由两个队列组成。一个队列是&lt;strong&gt;同步队列&lt;/strong&gt;，另一个是&lt;strong&gt;条件队列&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;同步队列的原理&quot;&gt;同步队列的原理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;同步队列&lt;/strong&gt;的队列头部是&lt;code&gt;head&lt;/code&gt;，队列尾部是&lt;code&gt;tail&lt;/code&gt;节点，&lt;code&gt;head&lt;/code&gt;节点是一个空节点，&lt;strong&gt;同步队列&lt;/strong&gt;是一个双向链表，通过&lt;code&gt;next&lt;/code&gt;和&lt;code&gt;prev&lt;/code&gt;连接所有节点&lt;/li&gt;
&lt;li&gt;所有的线程在竞争锁的时候都会创建一个&lt;code&gt;Node&lt;/code&gt;节点，线程与节点绑定在一起，（如果是同步锁和排他锁不同之处是通过&lt;code&gt;nextWaiter&lt;/code&gt;来区分的）并且添加到&lt;strong&gt;同步队列&lt;/strong&gt;的尾部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt;的第一个节点获取锁，其余节点都需要等待被唤醒&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步队列&lt;/strong&gt;中的节点会存在取消和&lt;code&gt;null&lt;/code&gt;的情况（如：线程超时中断、线程更新节点的中间态），被取消和&lt;code&gt;null&lt;/code&gt;的节点不能被唤醒，将会被视为无效节点&lt;/li&gt;
&lt;li&gt;一个线程只能被有效的前驱节点（取消和&lt;code&gt;null&lt;/code&gt;的节点除外）唤醒&lt;/li&gt;
&lt;li&gt;持有锁的线程只能是有一个，其他有效节点对应的线程都会被挂起&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;条件队列的原理&quot;&gt;条件队列的原理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;一个&lt;strong&gt;同步队列&lt;/strong&gt;可以对应多个&lt;strong&gt;条件队列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件队列&lt;/strong&gt;是一个单向链表，通过&lt;code&gt;nextWaiter&lt;/code&gt;来连接起来，&lt;strong&gt;条件队列&lt;/strong&gt;的头节点是&lt;code&gt;firstWaiter&lt;/code&gt;，尾节点是&lt;code&gt;lastWaiter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;某个&lt;strong&gt;条件队列&lt;/strong&gt;中满足条件的节点（被&lt;code&gt;signal&lt;/code&gt;或&lt;code&gt;signalAll&lt;/code&gt;方法唤醒的节点）才会被转移到&lt;strong&gt;同步队列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件队列&lt;/strong&gt;中的被转移到&lt;strong&gt;同步队列&lt;/strong&gt;的节点是从头节点开始，&lt;strong&gt;条件队列&lt;/strong&gt;中被阻塞的线程会添加到队列的尾部&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;同步队列的实现&quot;&gt;同步队列的实现&lt;/h3&gt;
&lt;p&gt;首先，了解以下同步队列中队列的节点&lt;code&gt;Node&lt;/code&gt;的数据结构&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static final class Node {
        /** 共享锁的标识 */
        static final Node SHARED = new Node();
        /** 排他锁的标识 */
        static final Node EXCLUSIVE = null;

        /** 线程取消 */
        static final int CANCELLED =  1;
        /** 持有锁的线程的后继线程被挂起 */
        static final int SIGNAL    = -1;
        /** 条件队列标识 */
        static final int CONDITION = -2;
        /**
         * 共享锁情况下，通知所有其他节点
         */
        static final int PROPAGATE = -3;

        /**
         * waitStatus的取值如下:
         *   SIGNAL(-1): 当前节点的后继节点应该被挂起
         *   CANCELLED(1): 当前节点被取消
         *   CONDITION(-2): 当前节点在条件队列
         *   PROPAGATE(-3): 释放共享锁时需要通知所有节点
         *   0: 初始值
         *
         */
        volatile int waitStatus;

        /**
         * 前驱节点
         */
        volatile Node prev;

        /**
         * 后继节点
         */
        volatile Node next;

        /**
         * 节点对应的线程
         */
        volatile Thread thread;

        /**
         * 在共享锁的情况下，该节点的值为SHARED
         * 在排他锁的情况下，该节点的值为EXCLUSIVE
         * 在条件队列的情况下，链接的是下一个等待条件的线程
         */
        Node nextWaiter;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，我们来看一下&lt;strong&gt;同步队列&lt;/strong&gt;的链表结构&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/627770/202007/627770-20200712185156547-419642436.png&quot; alt=&quot;同步队列链表&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，我们根据同步队列的原理来分析以下&lt;code&gt;acquire&lt;/code&gt;和&lt;code&gt;release&lt;/code&gt;需要做哪些事情：&lt;/p&gt;
&lt;h3 id=&quot;实现acquire功能需要做的事情&quot;&gt;实现acquire功能需要做的事情&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建一个Node节点&lt;code&gt;node&lt;/code&gt;（该节点可能是排他锁，也可以能是共享锁）&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;node&lt;/code&gt;添加到&lt;strong&gt;同步队列&lt;/strong&gt;尾部，如果同步队列为空（初始情况下），需要先创建一个空的头节点，然后再添加到队列的尾部&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;node&lt;/code&gt;的前驱节点是&lt;code&gt;head&lt;/code&gt;，说明&lt;code&gt;node&lt;/code&gt;是第一个节点，能够获取锁，需要将&lt;code&gt;head&lt;/code&gt;修改成&lt;code&gt;node&lt;/code&gt;，释放前驱节点的资源&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;node&lt;/code&gt;的前驱节点不是&lt;code&gt;head&lt;/code&gt;，说明获取锁失败，需要检测是否需要将&lt;code&gt;node&lt;/code&gt;绑定的线程挂起，分以下几种情况：
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;node&lt;/code&gt;的&lt;code&gt;waitStatus&lt;/code&gt;已经被设置为&lt;code&gt;SIGNAL&lt;/code&gt; 表示需要被挂起&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;node&lt;/code&gt;的&lt;code&gt;waitStatus&lt;/code&gt;设置为&lt;code&gt;CANCEL&lt;/code&gt;表示该节点已经被取消，需要被去掉，并修改 &lt;code&gt;node&lt;/code&gt;的&lt;code&gt;prev&lt;/code&gt;，直到链接上一个有效的节点为止&lt;/li&gt;
&lt;li&gt;否则将&lt;code&gt;node&lt;/code&gt;的&lt;code&gt;waitStatus&lt;/code&gt;设置为&lt;code&gt;SIGNAL&lt;/code&gt;，表示即将要被挂起&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果需要将&lt;code&gt;node&lt;/code&gt;绑定的线程挂起，则让出CPU，直到当前驱节点来唤起&lt;code&gt;node&lt;/code&gt;才会开始继续从&lt;code&gt;步骤3&lt;/code&gt;开始执行&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;与acquire功能相关的代码&quot;&gt;与acquire功能相关的代码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;acquire方法：获取排他锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;amp;&amp;amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;tryAcquire(arg)&lt;/code&gt;：对外提供的一个扩展方法，常用的锁都要实现这个方法，具体实现与锁相关&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;addWaiter(Node.EXCLUSIVE)&lt;/code&gt;： 创建一个排他锁节点，并将该节点添加到&lt;strong&gt;同步队列&lt;/strong&gt;尾部，代码如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private Node addWaiter(Node mode) {
        // 创建一个node，EXCLUSIVE类型
        Node node = new Node(mode);

        for (;;) {
            // 获取尾节点
            Node oldTail = tail;
            if (oldTail != null) {
                // 设置即将成为尾节点的前驱
                node.setPrevRelaxed(oldTail);
                // CAS操作设置尾节点
                if (compareAndSetTail(oldTail, node)) {
                    // 将新尾节点的前驱节点与新的尾节点关联起来
                    oldTail.next = node;
                    // 返回添加的节点
                    // 这个节点现在不一定是尾节点，因为如果有多个线程调用这个方法时，
                    // 可能还有节点添加在这个节点后面
                    return node;
                }
            } else {
                // 如果队列为空，初始化头节点
                initializeSyncQueue();
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;acquireQueued&lt;/code&gt;：&lt;strong&gt;同步队列&lt;/strong&gt;中的节点获取排他锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
        try {
            // 线程是否中断
            boolean interrupted = false;
            for (;;) {
                // 获取前驱节点
                final Node p = node.predecessor();
                // 如果前驱节点是头节点，获取锁
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    // 修改头节点
                    setHead(node);
                    // 释放头节点的资源
                    p.next = null; // help GC
                    // 返回线程中断的状态
                    // 这也是该方法唯一的返回值
                    // 没有获取锁的线程会一直执行该方法直到获取锁以后再返回
                    return interrupted;
                }
                // 获取锁失败后是否需要将线程挂起
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt()) // 线程挂起并返回是否被中断
                    interrupted = true;
            }
        } catch (Throwable t) {
            // 取消该节点
            cancelAcquire(node);
            throw t;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;shouldParkAfterFailedAcquire&lt;/code&gt;：检测线程获取锁失败以后是否需要被挂起&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 前驱节点的状态
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * 状态已经设置成SIGNAL，可以直接挂起该节点
             */
            return true;
        // 节点被取消
        if (ws &amp;gt; 0) {
            /*
             * 找到pred第一个有效的前驱节点
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &amp;gt; 0);
            // pred可能是一个新的节点，需要将pred的next重写设置为node
            pred.next = node;
        } else {
            /*
             * CAS操作将pred节点的状态设置为SIGNAL
             */
            pred.compareAndSetWaitStatus(ws, Node.SIGNAL);
        }
        // 只有当pred节点的waitStatus已经是SIGNAL状态时，才可以安全的挂起线程
        // 否则需要不能被挂起
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;code&gt;parkAndCheckInterrupt&lt;/code&gt;：将当前线程挂起，并检测当前线程是否中断&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private final boolean parkAndCheckInterrupt() {
        // 线程挂起
        LockSupport.park(this);
        // 检测线程是否中断
        return Thread.interrupted();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;code&gt;cancelAcquire&lt;/code&gt;：取消节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; private void cancelAcquire(Node node) {
        // 如果节点为空，什么都不做
        if (node == null)
            return;
        // 释放线程
        node.thread = null;

        // 从后往前过滤掉所有的被取消的节点
        Node pred = node.prev;
        while (pred.waitStatus &amp;gt; 0)
            node.prev = pred = pred.prev;

        // 有效前驱节点的nex节点
        Node predNext = pred.next;

        // 将node设置为CANCELLED
        node.waitStatus = Node.CANCELLED;

        // 如果是尾节点，设置新的尾节点
        if (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {
            // 将新的尾节点的后续设置为null
            pred.compareAndSetNext(predNext, null);
        } else {
            // If successor needs signal, try to set pred's next-link
            // so it will get one. Otherwise wake it up to propagate.
            int ws;
            // 如果前驱节点的线程不为null并且waitStatus为SIGNAL
            if (pred != head &amp;amp;&amp;amp;
                ((ws = pred.waitStatus) == Node.SIGNAL ||
                 (ws &amp;lt;= 0 &amp;amp;&amp;amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;amp;&amp;amp;
                pred.thread != null) {
                Node next = node.next;
                // 将node设置成pred的后继节点
                if (next != null &amp;amp;&amp;amp; next.waitStatus &amp;lt;= 0)
                    pred.compareAndSetNext(predNext, next);
            } else {
                // 唤起node节点的后继节点
                // 因为node节点已经释放锁了
                unparkSuccessor(node);
            }

            node.next = node; // help GC
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;code&gt;unparkSuccessor&lt;/code&gt;：唤醒后继节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private void unparkSuccessor(Node node) {
        /*
         * 获取node节点的waitStatus
         */
        int ws = node.waitStatus;
       // 用CSA操作将waitStatus设置成初始状态
       // 不管设置是否成功，都无所谓，因为该节点即将被销毁
        if (ws &amp;lt; 0)
            node.compareAndSetWaitStatus(ws, 0);
        /*
         * 获取node的后继节点
         */
        Node s = node.next;
        // 如果后继节点为null或者被取消，
        // 通过从同步队列的尾节点开始一直往前找到一个有效的后继节点
        if (s == null || s.waitStatus &amp;gt; 0) {
            s = null;
            for (Node p = tail; p != node &amp;amp;&amp;amp; p != null; p = p.prev)
                if (p.waitStatus &amp;lt;= 0)
                    s = p;
        }
        // 如果后继节点不为空
        if (s != null)
            LockSupport.unpark(s.thread);// 唤醒后继节点的线程
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与&lt;code&gt;acquire&lt;/code&gt;方法类似的还有&lt;code&gt;acquireInterruptibly&lt;/code&gt;、&lt;code&gt;tryAcquireNanos&lt;/code&gt;、&lt;code&gt;acquireShared&lt;/code&gt;、&lt;code&gt;acquireSharedInterruptibly&lt;/code&gt;和&lt;code&gt;tryAcquireSharedNanos&lt;/code&gt;，我们都一一分析以下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;acquireInterruptibly方法：获取可中断的排他锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted()) // 如果线程中断，直接返回
            throw new InterruptedException();
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg); // 中断式的获取锁
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;doAcquireInterruptibly&lt;/code&gt;：可中断式的获取锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
       // 创建一个排他节点加入同步队列
        final Node node = addWaiter(Node.EXCLUSIVE);
        try {
            for (;;) {
                // 获取前驱节点
                final Node p = node.predecessor();
                // 如果前驱节点是头节点，说明已经获取的锁
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    // 修改头节点
                    setHead(node);
                    p.next = null; // help GC
                    return;
                }
                // 如果没有获取锁，检测是否需要挂起
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    throw new InterruptedException(); // 如果发现线程已经被中断，需要抛出异常
            }
        } catch (Throwable t) {
            // 发生异常取消节点
            cancelAcquire(node);
            throw t;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;tryAcquireNanos方法：超时中断获取排他锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final boolean tryAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException(); // 线程中断直接返回
        return tryAcquire(arg) ||
            doAcquireNanos(arg, nanosTimeout); // 超时获取排他锁
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;doAcquireNanos&lt;/code&gt;：超时获取排他锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private boolean doAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        // 如果超时直接返回
        if (nanosTimeout &amp;lt;= 0L)
            return false;
        // 获取超时时长
        final long deadline = System.nanoTime() + nanosTimeout;
        // 添加一个排他节点到同步队列尾部
        final Node node = addWaiter(Node.EXCLUSIVE);
        try {
            for (;;) {
                 // 获取前驱节点
                final Node p = node.predecessor();
                // 已经获取锁
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    return true;
                }
                nanosTimeout = deadline - System.nanoTime();
                // 如果超时了就取消
                if (nanosTimeout &amp;lt;= 0L) {
                    cancelAcquire(node);
                    return false;
                }
                // 检测节点是否需要被挂起
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    nanosTimeout &amp;gt; SPIN_FOR_TIMEOUT_THRESHOLD)
                    // 如果需要挂起，且超时时长大于SPIN_FOR_TIMEOUT_THRESHOLD
                    // 线程挂起nanosTimeout时间
                    LockSupport.parkNanos(this, nanosTimeout); 
                if (Thread.interrupted())
                    throw new InterruptedException();
            }
        } catch (Throwable t) {
            // 发生异常取消节点
            cancelAcquire(node);
            throw t;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;acquireShared方法：获取共享锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final void acquireShared(int arg) {
        // 对外提供的一个扩展方法，常用的锁都要实现这个方法，
        // 该方法的实现与锁的用途有关
        if (tryAcquireShared(arg) &amp;lt; 0) 
            doAcquireShared(arg); // 获取共享锁
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;doAcquireShared&lt;/code&gt;：获取共享锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; private void doAcquireShared(int arg) {
        // 添加一个共享节点到同步队列尾部
        final Node node = addWaiter(Node.SHARED);
        try {
            boolean interrupted = false;
            for (;;) {
                // 获取前驱节点
                final Node p = node.predecessor();
                if (p == head) {
                    // 返回结果大于等于0表示获取共享锁
                    int r = tryAcquireShared(arg);
                    if (r &amp;gt;= 0) {
                        // 设置头节点并广播通知其他获取共享锁的节点
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        // 如果线程被中断，将该线程中断
                        // 共享锁会被多个线程获取，如果需要中断
                        // 所有获取共享锁的线程都要被中断
                        if (interrupted)
                            selfInterrupt();
                        return;
                    }
                }
                // 检测是否需要挂起
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt()) // 挂起并中断
                    interrupted = true;
            }
        } catch (Throwable t) {
            // 发生异常取消节点
            cancelAcquire(node);
            throw t;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;setHeadAndPropagate&lt;/code&gt;：设置头节点并广播其他节点来获取锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // 记录旧的头节点
        setHead(node);// 设置新的头节点
        /*
         * 如果头节点为null或者是不是取消状态，尝试唤醒后继节点
         */
        if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
            (h = head) == null || h.waitStatus &amp;lt; 0) {
            Node s = node.next;
            // node节点的next是SHARED，即共享锁
            if (s == null || s.isShared())
                // 唤起获取共享锁的线程
                doReleaseShared();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;doReleaseShared&lt;/code&gt;：唤醒等待共享锁的节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; private void doReleaseShared() {
        /*
         * 唤醒时是从头节点开始先唤醒第一个共享节点，
         * 第一个共享节点被唤醒后会在doAcquireShared方法里继续执行（之前就是在这个方法里被挂起的）
         * 第一个共享节点如果获取锁会调用setHeadAndPropagate方法修改头节点，然后再调用doReleaseShared方法
         * 唤醒第二个共享节点，以此类推，最后把所有的共享节点都唤醒
         */
        for (;;) {
            Node h = head;
            if (h != null &amp;amp;&amp;amp; h != tail) {
                // 获取头节点的状态
                int ws = h.waitStatus;
                // 如果头节点是SIGNAL，需要将状态设置为0，表示已经即将被唤醒
                if (ws == Node.SIGNAL) {
                    if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))
                        continue;            // 如果失败了说明有其他线程在修改头节点，需要继续重试
                    unparkSuccessor(h); // 唤醒头节点的后继节点
                }
                else if (ws == 0 &amp;amp;&amp;amp;
                         !h.compareAndSetWaitStatus(0, Node.PROPAGATE))
                    continue;                // 将头节点状态从0设置成PROPAGATE，如果失败了继续，因为也有其他获取共享锁的线程在更改头节点
            }
            // 如果头节点未改变（因为没有后继节点需要等待共享锁），跳出循环
            if (h == head)
                break;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;selfInterrupt&lt;/code&gt;：中断当前线程&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;acquireSharedInterruptibly方法：可中断的获取共享锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException(); // 如果线程被中断抛出异常
        if (tryAcquireShared(arg) &amp;lt; 0)
            doAcquireSharedInterruptibly(arg); // 可中断的方式获取共享锁
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;doAcquireSharedInterruptibly&lt;/code&gt;：可中断的方式后去共享锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
        // 添加共享锁节点到同步队列尾部
        final Node node = addWaiter(Node.SHARED);
        try {
            for (;;) {
                // 获取前驱节点
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r &amp;gt;= 0) {
                        // 获取共享锁以后修改头节点，通知其他等待共享锁的节点
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        return;
                    }
                }
                // 线程获取共享锁失败后需要挂起，并且发现线程被中断，所以抛出异常
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } catch (Throwable t) {
            // 发生异常取消节点
            cancelAcquire(node);
            throw t;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;tryAcquireSharedNanos方法：超时中断获取共享锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted()) // 线程如果中断了，直接抛出异常
            throw new InterruptedException();
        return tryAcquireShared(arg) &amp;gt;= 0 ||
            doAcquireSharedNanos(arg, nanosTimeout); // 超时获取共享锁
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;doAcquireSharedNanos&lt;/code&gt;：超时的方式获取中断锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private boolean doAcquireSharedNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        // 超时直接返回
        if (nanosTimeout &amp;lt;= 0L)
            return false;
        final long deadline = System.nanoTime() + nanosTimeout;
        // 添加共享节点到同步队列尾部
        final Node node = addWaiter(Node.SHARED);
        try {
            for (;;) {
                // 获取前驱节点
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r &amp;gt;= 0) {
                        // 获取锁，修改头节点，通知所有其他等待共享锁的节点
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        return true;
                    }
                }
                nanosTimeout = deadline - System.nanoTime();
                if (nanosTimeout &amp;lt;= 0L) {
                    // 超时取消节点
                    cancelAcquire(node);
                    return false;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    nanosTimeout &amp;gt; SPIN_FOR_TIMEOUT_THRESHOLD)
                    // 如果需要挂起，且超时时长大于SPIN_FOR_TIMEOUT_THRESHOLD
                    // 线程挂起nanosTimeout时间
                    LockSupport.parkNanos(this, nanosTimeout);
                if (Thread.interrupted())
                    throw new InterruptedException(); // 中断了抛出异常
            }
        } catch (Throwable t) {
            // 发生异常取消节点
            cancelAcquire(node);
            throw t;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现release功能需要做的事情&quot;&gt;实现release功能需要做的事情&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;释放当前获取锁的线程持有的资源&lt;/li&gt;
&lt;li&gt;唤醒有效的一个后继节点&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;与release功能相关的代码&quot;&gt;与release功能相关的代码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;release方法：释放排他锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            // 头节点不能是一个中间态
            if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
                // 唤醒后继节点
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;release方法：释放共享锁&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            // 释放共享锁，从头节点开始一个一个的释放
            // 如果存在多个共享节点在同步队列时，doReleaseShared方式其实是递归调用
            doReleaseShared();
            return true;
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，将所有获取锁和释放锁的方法相关的源码全部分析完&lt;/p&gt;
&lt;h3 id=&quot;条件队列的实现&quot;&gt;条件队列的实现&lt;/h3&gt;
&lt;p&gt;我们来看一下&lt;strong&gt;条件队列&lt;/strong&gt;的链表结构&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/627770/202007/627770-20200712220835066-626642214.png&quot; alt=&quot;条件队列的链表结构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现await功能需要做的事情&quot;&gt;实现await功能需要做的事情&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建一个&lt;code&gt;CONDITION&lt;/code&gt;类型的节点，将该节点添加到&lt;strong&gt;条件队列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;释放已经获取的锁（因为只有当前线程先获取了锁才可能再调用&lt;code&gt;Condition.await()&lt;/code&gt;方法）&lt;/li&gt;
&lt;li&gt;如果无法获取锁，线程挂起&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;与await功能相关的代码&quot;&gt;与await功能相关的代码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;await方法：等待条件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException(); // 如果线程中断，直接抛出异常
            // 创建一个CONDITION类型的节点，将该节点添加到条件队列尾部
            Node node = addConditionWaiter();
            // 释放锁
            // 在调用await方法之前都会调用lock方法，这个时候已经获取锁了
            // 有时候锁还是可重入的，所以需要将所有的资源都释放掉
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            // 如果节点不再同步队列，全部都要挂起
            while (!isOnSyncQueue(node)) {
                LockSupport.park(this);
                // 如果在等待期间发生过中断（不管是调用signal之前还是之后），直接退出
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            // 让线程尝试去获取锁，如果无法获取锁就挂起
            if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            // 清除所有在条件队列中是取消状态的节点
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            // 发生中断，上报中断情况
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;addConditionWaiter&lt;/code&gt;：在条件队列中添加一个节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; private Node addConditionWaiter() {
            Node t = lastWaiter;
            // 清除条件队列中无效的节点
            if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
            // 创建一个节点
            Node node = new Node(Node.CONDITION);
            // 添加到条件队列尾部
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;unlinkCancelledWaiters&lt;/code&gt;：清除在条件队列中被取消的节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private void unlinkCancelledWaiters() {
            Node t = firstWaiter;
            Node trail = null;
            // 遍历条件队列将所有不是CONDITION状态的节点全部清除掉
            // 这些节点都是取消状态的节点
            while (t != null) {
                Node next = t.nextWaiter;
                if (t.waitStatus != Node.CONDITION) {
                    t.nextWaiter = null;
                    if (trail == null)
                        firstWaiter = next;
                    else
                        trail.nextWaiter = next;
                    if (next == null)
                        lastWaiter = trail;
                }
                else
                    trail = t;
                t = next;
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;fullyRelease&lt;/code&gt;：释放线程持有的所有锁资源&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;final int fullyRelease(Node node) {
        try {
            int savedState = getState();
            // 释放所有的资源
            // 如果是可重入锁，savedState就是重入的次数
            if (release(savedState))
                return savedState;
            throw new IllegalMonitorStateException();
        } catch (Throwable t) {
            // 发生异常就取消该节点
            node.waitStatus = Node.CANCELLED;
            throw t;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;code&gt;isOnSyncQueue&lt;/code&gt;：判断节点是否在同步队列&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;final boolean isOnSyncQueue(Node node) {
        // waitStatus是CONDITION或者node没有前驱节点，说明node不在同步队列
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        if (node.next != null) // 有后继节点一定在同步队列
            return true;
        /*
         * 在同步队列中查找node，看是否在同步队列中
         */
        return findNodeFromTail(node);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;code&gt;findNodeFromTail&lt;/code&gt;：在同步队列中查找节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private boolean findNodeFromTail(Node node) {
        // 从尾节点开始查找
        for (Node p = tail;;) {
            if (p == node) // 找到了
                return true;
            if (p == null) // 找到头了还没找到
                return false;
            p = p.prev;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;code&gt;checkInterruptWhileWaiting&lt;/code&gt;：检测中断的情况&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private int checkInterruptWhileWaiting(Node node) {
            // 没有发生中断返回0
            // 调用signal之前发生中断返回THROW_IE
            // 调用signal之后发生中断返回REINTERRUPT
            return Thread.interrupted() ?
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
                0;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;code&gt;transferAfterCancelledWait&lt;/code&gt;：清除在条件队列中被取消的节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 只有线程处于中断状态，才会调用此方法
// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列
// 返回 true，如果此线程在 signal 之前被取消，否则返回false
final boolean transferAfterCancelledWait(Node node) {
  
        // 用 CAS 将节点状态设置为 0 
        // 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，
       // 因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0
        if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {
            enq(node); // 将节点放入阻塞队列
            return true;
        }
        // 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0
        // signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成
        // 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断
        while (!isOnSyncQueue(node))
            Thread.yield();
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;&lt;code&gt;enq&lt;/code&gt;：把节点添加到同步队列&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private Node enq(Node node) {
        // 无限循环，将节点添加到同步队列尾部
        for (;;) {
            Node oldTail = tail;
            if (oldTail != null) {
                node.setPrevRelaxed(oldTail);
                if (compareAndSetTail(oldTail, node)) {
                    oldTail.next = node;
                    return oldTail;
                }
            } else {
                // 如果同步队列为空，初始化
                initializeSyncQueue();
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;&lt;code&gt;reportInterruptAfterWait&lt;/code&gt;：中断处理&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private void reportInterruptAfterWait(int interruptMode)
            throws InterruptedException {
            // 如果是THROW_IE状态，抛异常
            if (interruptMode == THROW_IE)
                throw new InterruptedException();
            else if (interruptMode == REINTERRUPT) // 再次中断，因为中断状态被使用过一次
                selfInterrupt();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;awaitNanos&lt;/code&gt;、&lt;code&gt;awaitUntil&lt;/code&gt;和&lt;code&gt;await(long time, TimeUnit unit)&lt;/code&gt;这几个方法的整体逻辑是一样的，就不再分析了&lt;/p&gt;
&lt;h3 id=&quot;实现signal功能需要做的事情&quot;&gt;实现signal功能需要做的事情&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;将条件队列中的节点加入同步队列&lt;/li&gt;
&lt;li&gt;唤醒线程&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;与signal功能相关的代码&quot;&gt;与signal功能相关的代码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;signal方法：唤醒等待条件的节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            // 获取条件队列中的第一个节点
            Node first = firstWaiter;
            if (first != null)
                // 唤醒等待条件的节点
                doSignal(first); 
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;doSignal&lt;/code&gt;：唤醒等待条件的节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private void doSignal(Node first) {
            do {
                // 去掉无效的节点
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                first.nextWaiter = null;
            } while (!transferForSignal(first) &amp;amp;&amp;amp;  // 将节点转移到同步队列
                     (first = firstWaiter) != null);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;transferForSignal&lt;/code&gt;：将节点转移到同步队列&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;final boolean transferForSignal(Node node) {
        /*
         * 取消的节点不需要转移
         */
        if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))
            return false;

        /*
         * 将节点加入同步队列尾部
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        // ws &amp;gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程
        // 如果 ws &amp;lt;= 0, 那么 compareAndSetWaitStatus 将会被调用
        // 节点入队后，需要把前驱节点的状态设为SIGNAL
        if (ws &amp;gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))
            // 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程
            LockSupport.unpark(node.thread);
        return true;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;signalAlll方法：唤醒所有等待条件的节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final void signalAll() {
            // 如果是当前线程
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                // 唤醒所有等待条件的节点
                doSignalAll(first);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;doSignalAll&lt;/code&gt;：唤醒所有等待条件的节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 将所有的节点都转移到同步队列
private void doSignalAll(Node first) {
            lastWaiter = firstWaiter = null;
            do {
                Node next = first.nextWaiter;
                first.nextWaiter = null;
                transferForSignal(first);
                first = next;
            } while (first != null);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在将与AQS相关的核心代码都整理了一遍，里面如果有描述不清晰或者不准确的地方希望大家可以帮忙指出！&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jul 2020 17:05:00 +0000</pubDate>
<dc:creator>PinXiong</dc:creator>
<og:description>最近一直在研究AQS的源码，希望可以更深刻的理解AQS的实现原理。虽然网上有很多关于AQS的源码分析，但是看完以后感觉还是一知半解。于是，我将自己的整个理解过程记录下来了，希望对大家有所帮助。 基本原</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pinxiong/p/13288201.html</dc:identifier>
</item>
<item>
<title>3dTiles 数据规范详解[4.1] b3dm瓦片二进制数据文件结构 - 秋意正寒</title>
<link>http://www.cnblogs.com/onsummer/p/13252896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onsummer/p/13252896.html</guid>
<description>&lt;blockquote readability=&quot;2.784&quot;&gt;
&lt;p&gt;原创。转载请规范注明出处：&lt;a href=&quot;https://www.cnblogs.com/onsummer/p/13252896.html&quot;&gt;https://www.cnblogs.com/onsummer/p/13252896.html&lt;/a&gt;&lt;br/&gt;我的git地址：&lt;a href=&quot;https://github.com/onsummer&quot;&gt;github.com/onsummer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;B3dm，Batched 3D Model，成批量的三维模型的意思。&lt;/p&gt;
&lt;p&gt;倾斜摄影数据（例如osgb）、BIM数据（如rvt）、传统三维模型（如obj、dae、3dMax制作的模型等），均可创建此类瓦片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1097074/202007/1097074-20200713010403920-1500247603.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;①-文件头：占28字节（byte）&quot;&gt;① 文件头：占28字节（byte）&lt;/h2&gt;
&lt;p&gt;位于b3dm文件最开头的28个字节，是7个属性数据：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性的官方名称&lt;/th&gt;
&lt;th&gt;字节长&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;magic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;string（或char[4]）&lt;/td&gt;
&lt;td&gt;该瓦片文件的类型，在b3dm中是 &lt;code&gt;&quot;b3dm&quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;version&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;该瓦片的版本，目前限定是 1.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;byteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;该瓦片文件的文件大小，单位：byte&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;featureTableJSONByteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;要素表的JSON文本（二进制形式）长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;featureTableBinaryByteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;要素表的二进制数据长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;batchTableJSONByteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;批量表的JSON文本（二进制形式）长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;batchTableBinaryByteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;批量表的二进制数据长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;byteLength&lt;/code&gt; = 28 + &lt;code&gt;featureTableJSONByteLength&lt;/code&gt; + &lt;code&gt;featureTableBinaryByteLength&lt;/code&gt; + &lt;code&gt;batchTableJSONByteLength&lt;/code&gt; + &lt;code&gt;batchTableBinaryByteLength&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;②-要素表&quot;&gt;② 要素表&lt;/h2&gt;
&lt;p&gt;回顾上篇，我说的是&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;要素表，记录的是整个瓦片渲染相关的数据，而不是渲染所需的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，b3dm瓦片中的要素表会记录哪些数据呢？&lt;/p&gt;
&lt;h3 id=&quot;全局属性&quot;&gt;全局属性&lt;/h3&gt;
&lt;p&gt;什么是全局属性？即对于瓦片每一个三维模型（或BATCH、要素）或者直接对当前瓦片有效的数据，在b3dm中，要素表有以下全局属性：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;属性数据类型&lt;/th&gt;
&lt;th&gt;属性描述&lt;/th&gt;
&lt;th&gt;是否必须存在&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;BATCH_LENGTH&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;当前瓦片文件内三维模型（BATCH、要素）的个数&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;RTC_CENTER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;float32[3]&lt;/td&gt;
&lt;td&gt;如果模型的坐标是相对坐标，那么相对坐标的中心即此&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意，如果glb模型并不需要属性数据，即要素表和批量表有可能是空表，那么 &lt;code&gt;BATCH_LENGTH&lt;/code&gt; 的值应设为 0 .&lt;/p&gt;
&lt;h3 id=&quot;要素属性&quot;&gt;*要素属性&lt;/h3&gt;
&lt;p&gt;对于每个模型（BATCH、要素）各自独立的数据。在b3dm中没有。&lt;/p&gt;
&lt;p&gt;我们回忆一下要素表的定义：与渲染相关的数据。&lt;/p&gt;
&lt;p&gt;b3dm瓦片与渲染相关的数据都在glb中了，所以b3dm并不需要存储每个模型各自独立的数据，即不存在要素属性。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em&gt;在i3dm、pnts两种瓦片中，要素属性会非常多。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;全局属性存在哪里？&quot;&gt;全局属性存在哪里？&lt;/h3&gt;
&lt;p&gt;全局属性存储在 要素表的JSON中，见下文：&lt;/p&gt;
&lt;h3 id=&quot;json头部数据&quot;&gt;JSON头部数据&lt;/h3&gt;
&lt;p&gt;由上图可知，文件头28字节数据之后是要素表，要素表前部是 长达 &lt;code&gt;featureTableJSONByteLength&lt;/code&gt; 字节的二进制JSON文本，利用各种语言内置的API可以将这段二进制数据转换为字符串，然后解析为JSON对象。&lt;/p&gt;
&lt;p&gt;例如，这里解析了一个b3dm文件的 要素表JSON：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JSON&quot;&gt;{
    &quot;BATCH_LENGTH&quot;: 4
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，此b3dm瓦片就有4个模型（4个要素，或4个BATCH），其 &lt;code&gt;batchId&lt;/code&gt; 是0、1、2、3.&lt;/p&gt;
&lt;h3 id=&quot;要素表的二进制本体数据&quot;&gt;要素表的二进制本体数据&lt;/h3&gt;
&lt;p&gt;无。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当要素表的 JSON 数据以引用二进制体的方式出现时，数据才会记录在要素表的二进制本体数据中，此时JSON记录的是字节偏移量等信息。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;但是在b3dm瓦片中，要素表只需要JSON就可以了，不需要自找麻烦再引用二进制数据，因为&lt;code&gt;BATCH_LENGTH&lt;/code&gt; 和 &lt;code&gt;RTC_CENTER&lt;/code&gt; 都相对好记录，一个是数值，一个是3元素的数组。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在下面的要介绍批量表中，就会出现 JSON 数据引用二进制体的情况了。在 i3dm 和 pnts 瓦片中，要素表 JSON就会大量引用其二进制体。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;③-批量表&quot;&gt;③ 批量表&lt;/h2&gt;
&lt;p&gt;批量表记录的是每个模型的属性数据，以及扩展数据（扩展数据以后再谈）。&lt;/p&gt;
&lt;p&gt;要素表和批量表唯一的联系就是 &lt;code&gt;BATCH_LENGTH&lt;/code&gt;，在 i3dm 中叫 &lt;code&gt;INSTANCE_LENGTH&lt;/code&gt;，在 pnts 中叫 &lt;code&gt;POINTS_LENGTH&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这很好理解，要素表记录了有多少个模型（BATCH、要素），那么批量表每个属性就有多少个值。&lt;/p&gt;
&lt;h3 id=&quot;json头部数据-2&quot;&gt;JSON头部数据&lt;/h3&gt;
&lt;p&gt;先上一份批量表的JSON看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JSON&quot;&gt;{
    &quot;height&quot; : {
        &quot;byteOffset&quot; : 0,
        &quot;componentType&quot; : &quot;FLOAT&quot;,
        &quot;type&quot; : &quot;SCALAR&quot;
    },   
    &quot;geographic&quot; : {
        &quot;byteOffset&quot; : 40,
        &quot;componentType&quot; : &quot;DOUBLE&quot;,
        &quot;type&quot; : &quot;VEC3&quot;
    },
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个批量表的JSON有两个属性：&lt;code&gt;height&lt;/code&gt;、&lt;code&gt;geographic&lt;/code&gt;，字面义即模型的高度值、地理坐标值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;height&lt;/code&gt; 属性通过其 &lt;code&gt;componentType&lt;/code&gt; 指定数据的值类型为 &lt;code&gt;FLOAT&lt;/code&gt;，通过其 &lt;code&gt;type&lt;/code&gt; 指定数据的元素类型为 &lt;code&gt;SCALAR&lt;/code&gt;（即标量）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;geographic&lt;/code&gt; 属性通过其 &lt;code&gt;componentType&lt;/code&gt; 指定数据的的值类型是 &lt;code&gt;DOUBLE&lt;/code&gt;，通过其 &lt;code&gt;type&lt;/code&gt; 指定数据的元素类型为 &lt;code&gt;VEC3&lt;/code&gt;（即3个double数字构成的三维向量）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;byteOffset&lt;/code&gt; ，即这个属性值在 &lt;strong&gt;二进制本体数据&lt;/strong&gt; 中从哪个字节开始存储。&lt;/p&gt;
&lt;p&gt;从上表可以看出，height 属性跨越 0 ~ 39 字节，一共40个字节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过 FeatureTableJSON 可以获取 BATCH_LENGTH 为10，那么就有10个模型，对应的，这 40 个字节就存储了10个 height 值，查相关资料得知，FLOAT类型的数据字节长度为 4，刚好 4 byte × 10 = 40 byte，即 height 属性的全部数据的总长。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;geographic 属性也同理，VEC3 代表一个 geographic 有3个 DOUBLE 类型的数字，一个 DOUBLE 数值占 8byte，那么 geographic 一共数据总长是：&lt;/p&gt;
&lt;p&gt;type × componentType × BATCH_LENGTH = 3 × 8byte × 10 = 240 byte.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1097074/202007/1097074-20200713004533574-845350488.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事实上，两个属性的总长是 40 + 240 = 280 byte，与 b3dm 文件头中的第七个属性 &lt;code&gt;batchTableBinaryByteLength&lt;/code&gt; = 280 是一致的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二进制本体数据&quot;&gt;二进制本体数据&lt;/h3&gt;
&lt;p&gt;二进制本体数据即批量表中每个属性的顺次存储。&lt;/p&gt;
&lt;h3 id=&quot;能不能不写二进制本体数据？&quot;&gt;能不能不写二进制本体数据？&lt;/h3&gt;
&lt;p&gt;可以。如果你觉得数据量比较小，可以直接把数据写在 &lt;code&gt;BatchTableJSON&lt;/code&gt; 中，还是以上述两个数据为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;height&quot;: [10.0, 20.0, 15.0, ...], // 太长了不写那么多，一共10个
    &quot;geographic&quot;: [
        [113.42, 23.10, 102.1],
        [111.08, 22.98, 24.94],
        // 太长不写
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，读者请一定注意这一点：同样是一个数字，二进制的JSON文本大多数时候体积会比二进制数据大。因为JSON文本还包括括号、逗号、冒号等JSON文本必须的符号。对于属性数据相当大的情况，建议使用 JSON引用二进制本体数据的组织形式，此时JSON充当的角色是元数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对于属性的值类型是 JSON 中的 object、string、bool 类型，则必须存于 JSON 中，因为二进制体只能存 标量、234维向量四种类型的数字数据。&lt;/p&gt;
&lt;h2 id=&quot;④-内嵌的glb&quot;&gt;④ 内嵌的glb&lt;/h2&gt;
&lt;p&gt;本部分略，对glb数据感兴趣的读者可自行查阅 glTF 数据规范。&lt;/p&gt;
&lt;p&gt;关于两大数据表如何与glb每一个顶点进行关联的，在前篇也有简略介绍。可以参考官方的说明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/Batched3DModel#binary-gltf&quot;&gt;https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/Batched3DModel#binary-gltf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;⑤-字节对齐与编码端序&quot;&gt;⑤ 字节对齐与编码端序&lt;/h2&gt;
&lt;h3 id=&quot;json二进制文本对齐&quot;&gt;JSON二进制文本对齐&lt;/h3&gt;
&lt;p&gt;FeatureTableJSON、BatchTableJSON的二进制文本，最后一个字节相对于整个b3dm文件来说，偏移量必须是8的倍数。&lt;/p&gt;
&lt;p&gt;如果不对齐，必须用二进制空格（即 &lt;code&gt;0x20&lt;/code&gt;）填够。&lt;/p&gt;
&lt;p&gt;你问我为啥不对起始偏移量也要求 8byte 对齐？因为 FeatureTableJSON 之前是28byte的 文件头，为了凑齐8倍数对齐，文件头和 FeatureTableJSON 还要塞4个字节填满，那就有点多余了。&lt;/p&gt;
&lt;p&gt;末尾对齐，即 (28 + ftJSON长)能整除8，(28 + ftTable长 + btJSON长)能整除8.&lt;/p&gt;
&lt;h3 id=&quot;数据体的起始、末尾对齐&quot;&gt;数据体的起始、末尾对齐&lt;/h3&gt;
&lt;p&gt;二进制数据体，无论是要素表、批量表，首个字节相对于b3dm文件的字节偏移量，必须是8的倍数，结束字节的字节偏移量，也必须是8的倍数。&lt;/p&gt;
&lt;p&gt;如果不满足，可以填充任意数据字节满足此要求。&lt;/p&gt;
&lt;p&gt;特别的，二进制数据体中，每一个属性值的第一个数值的第一个字节的偏移量，相对于整个b3dm文件，必须是其 &lt;code&gt;componentType&lt;/code&gt; 的倍数，如果不满足，则必须用空白字节填满。&lt;/p&gt;
&lt;p&gt;例如，上述 height 属性所在的批量表二进制数据体，理所当然位于批量表JSON之后，而批量表的JSON又是8byte对齐的，假设批量表的数据体起始字节是800，那么 height 的第一个值起始字节就是 800，由于 height 属性的 componentType 是 FLOAT，即 4字节，800 ÷ 4 能整除，所以没有问题。&lt;/p&gt;
&lt;p&gt;但是，假如 换一个属性，其 componentType 是 &lt;code&gt;BYTE&lt;/code&gt;，即 1字节，那么假设第二个属性的 componentType 是 DOUBLE，即 8字节，就会出现 第二个属性的第一个值起始偏移量是810，810 ÷ 8 并不能整除，必须补齐 6个空白字节，以满足第二个属性第一个值的起始偏移量是 810+6 = 816字节。&lt;/p&gt;
&lt;h3 id=&quot;编码端序&quot;&gt;编码端序&lt;/h3&gt;
&lt;p&gt;要素表、批量表的二进制数据，无论是JSON还是数据体，均使用小端序编码（LittleEndian）。&lt;/p&gt;

&lt;p&gt;其实，无论是要素表，还是批量表，都允许在JSON中存在扩展数据，以扩充当前瓦片模型的功能，而并不是单一的一个一个模型顺次存储在瓦片文件、glb中。&lt;/p&gt;
&lt;p&gt;有关扩展数据，在以后会专门出一篇博客介绍。&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jul 2020 16:46:00 +0000</pubDate>
<dc:creator>秋意正寒</dc:creator>
<og:description>原创。转载请规范注明出处：https://www.cnblogs.com/onsummer/p/13252896.html 我的git地址：github.com/onsummer B3dm，Batch</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/onsummer/p/13252896.html</dc:identifier>
</item>
<item>
<title>也来谈谈python编码 - 冷冰若水</title>
<link>http://www.cnblogs.com/lit10050528/p/13290825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lit10050528/p/13290825.html</guid>
<description>&lt;p&gt;让我们先来看一个示例，源码文件是utf-8格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print('你好 python')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用python2执行该程序时会收到一下报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;File &quot;./hello_world.py&quot;, line 2
SyntaxError: Non-ASCII character '\xe4' in file ./hello_world.py on line 2, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误提示的意思就是存在非ASCII字符，但是却没有encoding declared，同时给了一个连接并说明包含详细原因，这个链接是一个PEP（python enhancement proper）。&lt;br/&gt;&lt;img src=&quot;http://km.oa.com/files/photos/pictures/202007/1594305158_66_w1029_h532.png&quot; alt=&quot;enter image description here&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个PEP的内容总结下来就是：&lt;br/&gt;这行代码用于声明代码文件的编码格式，这个信息可以帮助python解析器使用指定的正确编码来解释代码文件。这样就可以允许直接在代码中使用utf-8编码了。&lt;br/&gt;另外需要注意的是：声明的编码格式要和代码文件的格式一样才行，否则会报错。&lt;/p&gt;
&lt;p&gt;来看另外一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding:utf-8 -*-
print('你好 python')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将这段代码保存为ANSI格式，并执行，会得到以下报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python ./hello_python.py
  File &quot;./hello_python.py&quot;, line 2
SyntaxError: (unicode error) 'utf-8' codec can't decode byte 0xc4 in position 0: invalid continuation byte
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以说指定编码的时候也不能全部统一指定为utf-8，而是要根据源码文件的格式来指定，两者要一致才行。&lt;/p&gt;
&lt;p&gt;另外又在python的官方文档找到一个说明：&lt;br/&gt;&lt;img src=&quot;http://km.oa.com/files/photos/pictures/202007/1594338978_34_w1616_h545.png&quot; alt=&quot;enter image description here&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;意思就是说：默认情况下，python解释器（python2）把源代码文件当做ASCII编码来处理，如果源码文件是其他格式就需要通过一个特殊的注释来说明，也就是：coding:utf-8，当然编码格式支持多中，具体看codecs的支持情况。&lt;br/&gt;这里其实也是由于python诞生的太早了，那时候Unicode都还没有诞生，因此当时作者也只能选择ASCII作为默认的编码格式。python3已经将默认编码格式改为UTF-8&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;所以总结下来就是，python2中，该行代码的作用是当源代码文件不是ASCII编码时，通过该行代码告诉python解释器正确的编码格式，这样python解释器才能正常解释其中的字符。&lt;br/&gt;另外，由于python3已经修改为默认情况下，将源代码文件当做UTF-8格式来处理，同时我们写代码时现在通常都会使用UTF-8格式来存储，因此python3其实是不用再写这一行代码的，除非你的源代码文件不是UTF-8格式的。&lt;/p&gt;

&lt;p&gt;先来看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding:utf-8 -*-
s = '你好'
s.encode('gb2312')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行以上代码会收到下面的报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;./hello_str.py&quot;, line 3, in &amp;lt;module&amp;gt;
    s.encode('gb2312')
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次遇到这个报错时，感觉很奇怪，明明我做的是encode操作，但是为什么报错确实decode失败呢？&lt;br/&gt;这里就是先提一下了：Python里面的编码和解码也就是unicode和str这两种形式的相互转化。编码是unicode-&amp;gt;str，相反的，解码就是str-&amp;gt;unicode。&lt;br/&gt;而上面定义的s是str类型的，因此当调用encode时，其实默认是先做了decode，转换为Unicode，然后再执行encode编码为指定的编码的，这里报错的原因就是当做隐式编码、解码时使用的默认格式是：ASCII，但是由于s是utf-8的编码，所以解码就失败了。&lt;br/&gt;解决办法：&lt;br/&gt;1、在文件头部添加sys.setdefaultencoding('utf-8')修改默认的编码、解码格式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import sys
sys.setdefaultencoding('utf-8')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、避免由程序做隐式的编码、解码，也就是说要明确str-Unicode的转换规则，但是需要编码时要确认类型是Unicode，如果不是就手动指定正确的解码格式转换为Unicode。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s.decode('utf-8').encode('gb2312')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结-2&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;setdefaultencoding主要在编码、解码没有明确指明编码、解码格式的时候使用。&lt;/p&gt;

&lt;p&gt;1、&lt;a href=&quot;https://www.python.org/dev/peps/pep-0263/&quot;&gt;PEP 263&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;https://docs.python.org/2.7/tutorial/interpreter.html#source-code-encoding&quot;&gt;source-code-encoding&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jul 2020 15:57:00 +0000</pubDate>
<dc:creator>冷冰若水</dc:creator>
<og:description>一、coding:utf-8 让我们先来看一个示例，源码文件是utf-8格式： print(&amp;amp;#39;你好 python&amp;amp;#39;) 当使用python2执行该程序时会收到一下报错：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lit10050528/p/13290825.html</dc:identifier>
</item>
<item>
<title>《算法笔记二》链表、栈、队列、递归、哈希表、顺序表 - 凝风</title>
<link>http://www.cnblogs.com/darope/p/13290810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/darope/p/13290810.html</guid>
<description>&lt;h2 id=&quot;链表&quot;&gt;链表&lt;/h2&gt;
&lt;h3 id=&quot;单向链表&quot;&gt;单向链表&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;单向链表的节点结构(可以实现成泛型) ：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;    public class Node {
        public int value;
        public Node next;
        
        public Node(int data) {
            value = data;
        }
        
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;双向链表&quot;&gt;双向链表&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;双向链表的节点结构(可以实现成功泛型)：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;       public static class DoubleNode {
                public int value;
                public DoubleNode last;
                public DoubleNode next;

                public DoubleNode(int data) {
                        value = data;
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;单双链表简单练习&quot;&gt;单双链表简单练习&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;单链表和双链表如何反转&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1 -&amp;gt; 2 -&amp;gt; 3 转换为 3 -&amp;gt; 2 -&amp;gt; 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;
package class02;

import java.util.ArrayList;

public class Code01_ReverseList {

        public static class Node {
                public int value;
                public Node next;

                public Node(int data) {
                        value = data;
                }
        }

        public static class DoubleNode {
                public int value;
                public DoubleNode last;
                public DoubleNode next;

                public DoubleNode(int data) {
                        value = data;
                }
        }

    // 翻转单向链表，传入头结点
        public static Node reverseLinkedList(Node head) {
                Node pre = null;
                Node next = null;
                while (head != null) {
                        next = head.next;
                        head.next = pre;
                        pre = head;
                        head = next;
                }
                return pre;
        }

    // 翻转双向链表，传入头结点
        public static DoubleNode reverseDoubleList(DoubleNode head) {
                DoubleNode pre = null;
                DoubleNode next = null;
                while (head != null) {
                        next = head.next;
                        head.next = pre;
                        head.last = next;
                        pre = head;
                        head = next;
                }
                return pre;
        }

        public static Node testReverseLinkedList(Node head) {
                if (head == null) {
                        return null;
                }
                ArrayList&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
                while (head != null) {
                        list.add(head);
                        head = head.next;
                }
                list.get(0).next = null;
                int N = list.size();
                for (int i = 1; i &amp;lt; N; i++) {
                        list.get(i).next = list.get(i - 1);
                }
                return list.get(N - 1);
        }

        public static DoubleNode testReverseDoubleList(DoubleNode head) {
                if (head == null) {
                        return null;
                }
                ArrayList&amp;lt;DoubleNode&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
                while (head != null) {
                        list.add(head);
                        head = head.next;
                }
                list.get(0).next = null;
                DoubleNode pre = list.get(0);
                int N = list.size();
                for (int i = 1; i &amp;lt; N; i++) {
                        DoubleNode cur = list.get(i);
                        cur.last = null;
                        cur.next = pre;
                        pre.last = cur;
                        pre = cur;
                }
                return list.get(N - 1);
        }

        public static Node generateRandomLinkedList(int len, int value) {
                int size = (int) (Math.random() * (len + 1));
                if (size == 0) {
                        return null;
                }
                size--;
                Node head = new Node((int) (Math.random() * (value + 1)));
                Node pre = head;
                while (size != 0) {
                        Node cur = new Node((int) (Math.random() * (value + 1)));
                        pre.next = cur;
                        pre = cur;
                        size--;
                }
                return head;
        }

        public static DoubleNode generateRandomDoubleList(int len, int value) {
                int size = (int) (Math.random() * (len + 1));
                if (size == 0) {
                        return null;
                }
                size--;
                DoubleNode head = new DoubleNode((int) (Math.random() * (value + 1)));
                DoubleNode pre = head;
                while (size != 0) {
                        DoubleNode cur = new DoubleNode((int) (Math.random() * (value + 1)));
                        pre.next = cur;
                        cur.last = pre;
                        pre = cur;
                        size--;
                }
                return head;
        }

        // 要求无环，有环别用这个函数
        public static boolean checkLinkedListEqual(Node head1, Node head2) {
                while (head1 != null &amp;amp;&amp;amp; head2 != null) {
                        if (head1.value != head2.value) {
                                return false;
                        }
                        head1 = head1.next;
                        head2 = head2.next;
                }
                return head1 == null &amp;amp;&amp;amp; head2 == null;
        }

        // 要求无环，有环别用这个函数
        public static boolean checkDoubleListEqual(DoubleNode head1, DoubleNode head2) {
                boolean null1 = head1 == null;
                boolean null2 = head2 == null;
                if (null1 &amp;amp;&amp;amp; null2) {
                        return true;
                }
                if (null1 ^ null2) {
                        return false;
                }
                if (head1.last != null || head2.last != null) {
                        return false;
                }
                DoubleNode end1 = null;
                DoubleNode end2 = null;
                while (head1 != null &amp;amp;&amp;amp; head2 != null) {
                        if (head1.value != head2.value) {
                                return false;
                        }
                        end1 = head1;
                        end2 = head2;
                        head1 = head1.next;
                        head2 = head2.next;
                }
                if (head1 != null || head2 != null) {
                        return false;
                }
                while (end1 != null &amp;amp;&amp;amp; end2 != null) {
                        if (end1.value != end2.value) {
                                return false;
                        }
                        end1 = end1.last;
                        end2 = end2.last;
                }
                return end1 == null &amp;amp;&amp;amp; end2 == null;
        }

        public static void main(String[] args) {
                int len = 50;
                int value = 100;
                int testTime = 100000;
                for (int i = 0; i &amp;lt; testTime; i++) {
                        Node node1 = generateRandomLinkedList(len, value);
                        Node reverse1 = reverseLinkedList(node1);
                        Node back1 = testReverseLinkedList(reverse1);
                        if (!checkLinkedListEqual(node1, back1)) {
                                System.out.println(&quot;oops!&quot;);
                                break;
                        }
                        DoubleNode node2 = generateRandomDoubleList(len, value);
                        DoubleNode reverse2 = reverseDoubleList(node2);
                        DoubleNode back2 = testReverseDoubleList(reverse2);
                        if (!checkDoubleListEqual(node2, back2)) {
                                System.out.println(&quot;oops!&quot;);
                                break;
                        }
                }
                System.out.println(&quot;finish!&quot;);

        }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;把给定的值都删除&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;比如给定一个链表头结点，删除该节点上值为3的节点，那么可能头结点就是3，存在删头部的情况，这里最终返回应该是删除所有值为3的节点之后的新的头部&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;
package class02;

public class Code02_DeleteGivenValue {

        public static class Node {
                public int value;
                public Node next;

                public Node(int data) {
                        this.value = data;
                }
        }

    // 先检查头部，寻找第一个不等于需要删除的值的节点，就是新的头部
        public static Node removeValue(Node head, int num) {
                while (head != null) {
                        if (head.value != num) {
                                break;
                        }
                        head = head.next;
                }
                // head来到 第一个不需要删的位置
                Node pre = head;
                Node cur = head;
                // 
                while (cur != null) {
                        if (cur.value == num) {
                                pre.next = cur.next;
                        } else {
                                pre = cur;
                        }
                        cur = cur.next;
                }
                return head;
        }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Tips: Java中也有可能产生内存泄漏，与CPP不同，CPP的内存泄漏有可能是我们开辟了内存空间忘记释放。而Java的内存泄漏大可能是程序中的变量的生存周期引起的，如果该程序是一个类似定时任务的7*24小时不间断运行，那么申请的变量（数据结构）就有可能不会被及时释放。如果不注意往里面添加一些不必要的变量，这些变量就是内存泄漏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;栈、队列&quot;&gt;栈、队列&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;逻辑概念&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;栈：数据先进后出，犹如弹夹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;队列: 数据先进先出，排队&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;底层实现方式&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;双向链表实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package class02;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class Code03_DoubleEndsQueueToStackAndQueue {

        public static class Node&amp;lt;T&amp;gt; {
                public T value;
                public Node&amp;lt;T&amp;gt; last;
                public Node&amp;lt;T&amp;gt; next;

                public Node(T data) {
                        value = data;
                }
        }

        public static class DoubleEndsQueue&amp;lt;T&amp;gt; {
                public Node&amp;lt;T&amp;gt; head;
                public Node&amp;lt;T&amp;gt; tail;

        // 从头部加节点
                public void addFromHead(T value) {
                        Node&amp;lt;T&amp;gt; cur = new Node&amp;lt;T&amp;gt;(value);
                        if (head == null) {
                                head = cur;
                                tail = cur;
                        } else {
                                cur.next = head;
                                head.last = cur;
                                head = cur;
                        }
                }

        // 从尾部加节点
                public void addFromBottom(T value) {
                        Node&amp;lt;T&amp;gt; cur = new Node&amp;lt;T&amp;gt;(value);
                        if (head == null) {
                                head = cur;
                                tail = cur;
                        } else {
                                cur.last = tail;
                                tail.next = cur;
                                tail = cur;
                        }
                }

        // 从头部弹出节点
                public T popFromHead() {
                        if (head == null) {
                                return null;
                        }
                        Node&amp;lt;T&amp;gt; cur = head;
                        if (head == tail) {
                                head = null;
                                tail = null;
                        } else {
                                head = head.next;
                                cur.next = null;
                                head.last = null;
                        }
                        return cur.value;
                }

        // 从尾部弹出节点
                public T popFromBottom() {
                        if (head == null) {
                                return null;
                        }
                        Node&amp;lt;T&amp;gt; cur = tail;
                        if (head == tail) {
                                head = null;
                                tail = null;
                        } else {
                                tail = tail.last;
                                tail.next = null;
                                cur.last = null;
                        }
                        return cur.value;
                }

        // 该双向链表结构是否为空
                public boolean isEmpty() {
                        return head == null;
                }

        }

    // 用上述双向链表结构实现栈
        public static class MyStack&amp;lt;T&amp;gt; {
                private DoubleEndsQueue&amp;lt;T&amp;gt; queue;

                public MyStack() {
                        queue = new DoubleEndsQueue&amp;lt;T&amp;gt;();
                }

                public void push(T value) {
                        queue.addFromHead(value);
                }

                public T pop() {
                        return queue.popFromHead();
                }

                public boolean isEmpty() {
                        return queue.isEmpty();
                }

        }

    // 用上述双向链表结构实现队列
        public static class MyQueue&amp;lt;T&amp;gt; {
                private DoubleEndsQueue&amp;lt;T&amp;gt; queue;

                public MyQueue() {
                        queue = new DoubleEndsQueue&amp;lt;T&amp;gt;();
                }

                public void push(T value) {
                        queue.addFromHead(value);
                }

                public T poll() {
                        return queue.popFromBottom();
                }

                public boolean isEmpty() {
                        return queue.isEmpty();
                }

        }

        public static boolean isEqual(Integer o1, Integer o2) {
                if (o1 == null &amp;amp;&amp;amp; o2 != null) {
                        return false;
                }
                if (o1 != null &amp;amp;&amp;amp; o2 == null) {
                        return false;
                }
                if (o1 == null &amp;amp;&amp;amp; o2 == null) {
                        return true;
                }
                return o1.equals(o2);
        }

        public static void main(String[] args) {
                int oneTestDataNum = 100;
                int value = 10000;
                int testTimes = 100000;
                for (int i = 0; i &amp;lt; testTimes; i++) {
                        MyStack&amp;lt;Integer&amp;gt; myStack = new MyStack&amp;lt;&amp;gt;();
                        MyQueue&amp;lt;Integer&amp;gt; myQueue = new MyQueue&amp;lt;&amp;gt;();
                        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
                        Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
                        for (int j = 0; j &amp;lt; oneTestDataNum; j++) {
                                int nums = (int) (Math.random() * value);
                                if (stack.isEmpty()) {
                                        myStack.push(nums);
                                        stack.push(nums);
                                } else {
                                        if (Math.random() &amp;lt; 0.5) {
                                                myStack.push(nums);
                                                stack.push(nums);
                                        } else {
                                                if (!isEqual(myStack.pop(), stack.pop())) {
                                                        System.out.println(&quot;oops!&quot;);
                                                }
                                        }
                                }
                                int numq = (int) (Math.random() * value);
                                if (stack.isEmpty()) {
                                        myQueue.push(numq);
                                        queue.offer(numq);
                                } else {
                                        if (Math.random() &amp;lt; 0.5) {
                                                myQueue.push(numq);
                                                queue.offer(numq);
                                        } else {
                                                if (!isEqual(myQueue.poll(), queue.poll())) {
                                                        System.out.println(&quot;oops!&quot;);
                                                }
                                        }
                                }
                        }
                }
                System.out.println(&quot;finish!&quot;);
        }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;数组实现,对于栈特别简单，对于队列，如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package class02;

public class Code04_RingArray {

        public static class MyQueue {
            // 数组结构
                private int[] arr;
                // 往当前队列添加数的下标位置
                private int pushi;
                // 当前队列需要出队列的位置
                private int polli;
                // 当前队列使用的空间大小
                private int size;
                // 数组最大大小，用户传入
                private final int limit;

                public MyQueue(int limit) {
                        arr = new int[limit];
                        pushi = 0;
                        polli = 0;
                        size = 0;
                        this.limit = limit;
                }

                public void push(int value) {
                        if (size == limit) {
                                throw new RuntimeException(&quot;栈满了，不能再加了&quot;);
                        }
                        size++;
                        arr[pushi] = value;
                        pushi = nextIndex(pushi);
                }

                public int pop() {
                        if (size == 0) {
                                throw new RuntimeException(&quot;栈空了，不能再拿了&quot;);
                        }
                        size--;
                        int ans = arr[polli];
                        polli = nextIndex(polli);
                        return ans;
                }

                public boolean isEmpty() {
                        return size == 0;
                }

                // 如果现在的下标是i，返回下一个位置，该实现可以实现环形的ringbuffer
                private int nextIndex(int i) {
                        return i &amp;lt; limit - 1 ? i + 1 : 0;
                }

        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;栈、队列常见面试题&quot;&gt;栈、队列常见面试题&lt;/h2&gt;
&lt;p&gt;一、实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能更&lt;/p&gt;
&lt;p&gt;1、pop、push、getMin操作的时间复杂度都是O(1)&lt;/p&gt;
&lt;p&gt;2、设计的栈类型可以使用现成的栈结构&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;思路：准备两个栈，一个data栈，一个min栈。数据压data栈，min栈对比min栈顶元素，谁小加谁。这样的话data栈和min栈是同步上升的，元素个数一样多，且min栈的栈顶，是data栈所有元素中最小的那个。数据弹出data栈，我们同步弹出min栈，保证个数相等，切min栈弹出的就是最小值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package class02;

import java.util.Stack;

public class Code05_GetMinStack {

        public static class MyStack1 {
                private Stack&amp;lt;Integer&amp;gt; stackData;
                private Stack&amp;lt;Integer&amp;gt; stackMin;

                public MyStack1() {
                        this.stackData = new Stack&amp;lt;Integer&amp;gt;();
                        this.stackMin = new Stack&amp;lt;Integer&amp;gt;();
                }

                public void push(int newNum) {
                    // 当前最小栈为空，直接压入
                        if (this.stackMin.isEmpty()) {
                                this.stackMin.push(newNum);
                        // 当前元素小于最小栈的栈顶，压入当前值
                        } else if (newNum &amp;lt;= this.getmin()) {
                                this.stackMin.push(newNum);
                        }
                        // 往数据栈中压入当前元素
                        this.stackData.push(newNum);
                }

                public int pop() {
                        if (this.stackData.isEmpty()) {
                                throw new RuntimeException(&quot;Your stack is empty.&quot;);
                        }
                        int value = this.stackData.pop();
                        if (value == this.getmin()) {
                                this.stackMin.pop();
                        }
                        return value;
                }

                public int getmin() {
                        if (this.stackMin.isEmpty()) {
                                throw new RuntimeException(&quot;Your stack is empty.&quot;);
                        }
                        return this.stackMin.peek();
                }
        }

        public static class MyStack2 {
                private Stack&amp;lt;Integer&amp;gt; stackData;
                private Stack&amp;lt;Integer&amp;gt; stackMin;

                public MyStack2() {
                        this.stackData = new Stack&amp;lt;Integer&amp;gt;();
                        this.stackMin = new Stack&amp;lt;Integer&amp;gt;();
                }

                public void push(int newNum) {
                        if (this.stackMin.isEmpty()) {
                                this.stackMin.push(newNum);
                        } else if (newNum &amp;lt; this.getmin()) {
                                this.stackMin.push(newNum);
                        } else {
                                int newMin = this.stackMin.peek();
                                this.stackMin.push(newMin);
                        }
                        this.stackData.push(newNum);
                }

                public int pop() {
                        if (this.stackData.isEmpty()) {
                                throw new RuntimeException(&quot;Your stack is empty.&quot;);
                        }
                        // 弹出操作，同步弹出，保证大小一致，只返回给用户data栈中的内容即可
                        this.stackMin.pop();
                        return this.stackData.pop();
                }

                public int getmin() {
                        if (this.stackMin.isEmpty()) {
                                throw new RuntimeException(&quot;Your stack is empty.&quot;);
                        }
                        return this.stackMin.peek();
                }
        }

        public static void main(String[] args) {
                MyStack1 stack1 = new MyStack1();
                stack1.push(3);
                System.out.println(stack1.getmin());
                stack1.push(4);
                System.out.println(stack1.getmin());
                stack1.push(1);
                System.out.println(stack1.getmin());
                System.out.println(stack1.pop());
                System.out.println(stack1.getmin());

                System.out.println(&quot;=============&quot;);

                MyStack1 stack2 = new MyStack1();
                stack2.push(3);
                System.out.println(stack2.getmin());
                stack2.push(4);
                System.out.println(stack2.getmin());
                stack2.push(1);
                System.out.println(stack2.getmin());
                System.out.println(stack2.pop());
                System.out.println(stack2.getmin());
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二、如何用栈结构实现队列结构，如何用队列结构实现栈结构&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这两种结构的应用实在太多，刷题时会大量见到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;/**
* 两个栈实现队列
**/
package class02;

import java.util.Stack;

public class Code06_TwoStacksImplementQueue {

        public static class TwoStacksQueue {
                public Stack&amp;lt;Integer&amp;gt; stackPush;
                public Stack&amp;lt;Integer&amp;gt; stackPop;

                public TwoStacksQueue() {
                        stackPush = new Stack&amp;lt;Integer&amp;gt;();
                        stackPop = new Stack&amp;lt;Integer&amp;gt;();
                }

                // push栈向pop栈倒入数据
                private void pushToPop() {
                        if (stackPop.empty()) {
                                while (!stackPush.empty()) {
                                        stackPop.push(stackPush.pop());
                                }
                        }
                }

                public void add(int pushInt) {
                        stackPush.push(pushInt);
                        pushToPop();
                }

                public int poll() {
                        if (stackPop.empty() &amp;amp;&amp;amp; stackPush.empty()) {
                                throw new RuntimeException(&quot;Queue is empty!&quot;);
                        }
                        pushToPop();
                        return stackPop.pop();
                }

                public int peek() {
                        if (stackPop.empty() &amp;amp;&amp;amp; stackPush.empty()) {
                                throw new RuntimeException(&quot;Queue is empty!&quot;);
                        }
                        pushToPop();
                        return stackPop.peek();
                }
        }

        public static void main(String[] args) {
                TwoStacksQueue test = new TwoStacksQueue();
                test.add(1);
                test.add(2);
                test.add(3);
                System.out.println(test.peek());
                System.out.println(test.poll());
                System.out.println(test.peek());
                System.out.println(test.poll());
                System.out.println(test.peek());
                System.out.println(test.poll());
        }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;/**
* 两个队列实现栈 
**/
package class02;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class Code07_TwoQueueImplementStack {

        public static class TwoQueueStack&amp;lt;T&amp;gt; {
                public Queue&amp;lt;T&amp;gt; queue;
                public Queue&amp;lt;T&amp;gt; help;

                public TwoQueueStack() {
                        queue = new LinkedList&amp;lt;&amp;gt;();
                        help = new LinkedList&amp;lt;&amp;gt;();
                }

                public void push(T value) {
                        queue.offer(value);
                }

                public T poll() {
                        while (queue.size() &amp;gt; 1) {
                                help.offer(queue.poll());
                        }
                        T ans = queue.poll();
                        Queue&amp;lt;T&amp;gt; tmp = queue;
                        queue = help;
                        help = tmp;
                        return ans;
                }

                public T peek() {
                        while (queue.size() &amp;gt; 1) {
                                help.offer(queue.poll());
                        }
                        T ans = queue.poll();
                        help.offer(ans);
                        Queue&amp;lt;T&amp;gt; tmp = queue;
                        queue = help;
                        help = tmp;
                        return ans;
                }

                public boolean isEmpty() {
                        return queue.isEmpty();
                }

        }

        public static void main(String[] args) {
                System.out.println(&quot;test begin&quot;);
                TwoQueueStack&amp;lt;Integer&amp;gt; myStack = new TwoQueueStack&amp;lt;&amp;gt;();
                Stack&amp;lt;Integer&amp;gt; test = new Stack&amp;lt;&amp;gt;();
                int testTime = 1000000;
                int max = 1000000;
                for (int i = 0; i &amp;lt; testTime; i++) {
                        if (myStack.isEmpty()) {
                                if (!test.isEmpty()) {
                                        System.out.println(&quot;Oops&quot;);
                                }
                                int num = (int) (Math.random() * max);
                                myStack.push(num);
                                test.push(num);
                        } else {
                                if (Math.random() &amp;lt; 0.25) {
                                        int num = (int) (Math.random() * max);
                                        myStack.push(num);
                                        test.push(num);
                                } else if (Math.random() &amp;lt; 0.5) {
                                        if (!myStack.peek().equals(test.peek())) {
                                                System.out.println(&quot;Oops&quot;);
                                        }
                                } else if (Math.random() &amp;lt; 0.75) {
                                        if (!myStack.poll().equals(test.pop())) {
                                                System.out.println(&quot;Oops&quot;);
                                        }
                                } else {
                                        if (myStack.isEmpty() != test.isEmpty()) {
                                                System.out.println(&quot;Oops&quot;);
                                        }
                                }
                        }
                }

                System.out.println(&quot;test finish!&quot;);

        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;递归&quot;&gt;递归&lt;/h2&gt;
&lt;p&gt;1、从思想上理解递归&lt;/p&gt;
&lt;p&gt;2、从实现角度出发理解递归&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;求数组arr[L...R]中的最大值，怎么用递归方法实现&lt;/p&gt;
&lt;p&gt;1、 将[L...R]范围分成左右两半。左[L...Mid],右[Mid+1...R]&lt;br/&gt;2、 左部分求最大值，右部分求最大值&lt;br/&gt;3、[L...R]范围上的最大值，就是max{左部分最大值,右部分最大值}&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;2步骤是个递归过程，当范围上只有一个数，就可以不用再递归了&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package class02;

public class Code08_GetMax {

        // 求arr中的最大值
        public static int getMax(int[] arr) {
                return process(arr, 0, arr.length - 1);
        }

        // arr[L..R]范围上求最大值  L ... R   N
        public static int process(int[] arr, int L, int R) {
                if (L == R) { // arr[L..R]范围上只有一个数，直接返回，base case
                        return arr[L];
                }
                int mid = L + ((R - L) &amp;gt;&amp;gt; 1); // 中点
                // 左部分最大值
                int leftMax = process(arr, L, mid);
                // 右部分最大值
                int rightMax = process(arr, mid + 1, R);
                return Math.max(leftMax, rightMax);
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;递归在系统中是怎么实现的？递归实际上利用的是系统栈来实现的。保存当前调用现场，去执行子问题，子问题的返回作为现场的需要的参数填充，最终构建还原栈顶的现场，返回。所以递归行为不是玄学，任何递归都可以改为非递归实现，我们自己压栈用迭代等实现就行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;递归行为的时间复杂度&quot;&gt;递归行为的时间复杂度&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对于满足&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;T(N) = aT(N/b) + O(N^d)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中： a,b,d为常数&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;公式表示，子问题的规模是一致的,该子问题调用了a次，N/b代表子问题的规模，O(N^d)为除去递归调用剩余的时间复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;比如上述问题的递归，[L...R]上有N个数，第一个子问题的规模是N/2，第二个子问题的规模也是N/2。子问题调用了2次。额为复杂度为O(1)，那么公式为：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;T(N) = 2T(N/2) + O(N^0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：如果我们的递归满足这种公式，那么该递归的时间复杂度(Master公式)为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;logb^a &amp;gt; d   =&amp;gt;  O(N ^ (logb^a))

logb^a &amp;lt; d   =&amp;gt;  O(N^d)

logb^a == d   =&amp;gt;  O(N^d * logN)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么上述问题的a=2, b=2,d=0,满足第一条，递归时间复杂度为：O(N)&lt;/p&gt;
&lt;h2 id=&quot;哈希表hashmap、hashset&quot;&gt;哈希表HashMap、HashSet&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Hash表的增删改查，在使用的时候，一律认为时间复杂度是O(1)的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在Java中，int double float基础类型，按值传递; Integer, Double, Float按引用传递的，比较包装类型的值是否相等，使用equals方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;注意：在Java底层，包装类如果范围比较小，底层仍然采用值传递，比如Integer如果范围在-128~127之间，是按值传递的&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;但是在Hash表中，即使是包装类型的key，我们也一律按值传递，例如Hash&amp;lt;Integer,String&amp;gt;如果我们put相同的key的值，那么不会产生两个值相等的key而是覆盖操作。但是Hash表并不是一直是按值传递的，只是针对包装类型，如果是我们自定义的引用类型，那么仍然按引用传递&lt;/mark&gt;&lt;/p&gt;
&lt;h2 id=&quot;顺序表-treemap、treeset&quot;&gt;顺序表 TreeMap、TreeSet&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;顺序表比哈希表功能多，但是顺序表的很多操作时间复杂度是O(logN)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有序表的底层可以有很多结构实现，比如AVL树，SB树，红黑树，跳表。其中AVL,SB，红黑都是具备各自平衡性的搜索二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于平衡二叉树每时每刻都会维持自身的平衡，所以操作为O(logN)。暂时理解，后面会单独整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于满足去重排序功能来维持底层树的平衡，所以如果是基础类型和包装类型的key直接按值来做比较，但是如果我们的key是自己定义的类型，那么我们要自己制定比较规则（比较器），用来让底层的树保持比较后的平衡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package class02;

import java.util.HashMap;
import java.util.HashSet;
import java.util.TreeMap;

public class HashMapAndSortedMap {
        
        
        public static class Node{
                public int value;
                public Node(int v) {
                         value = v;
                }
        }
        
        public static void main(String[] args) {
                // UnSortedMap
                HashMap&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
                map.put(1000000, &quot;我是1000000&quot;);
                map.put(2, &quot;我是2&quot;);
                map.put(3, &quot;我是3&quot;);
                map.put(4, &quot;我是4&quot;);
                map.put(5, &quot;我是5&quot;);
                map.put(6, &quot;我是6&quot;);
                map.put(1000000, &quot;我是1000001&quot;);
                
                System.out.println(map.containsKey(1));
                System.out.println(map.containsKey(10));
                
                System.out.println(map.get(4));
                System.out.println(map.get(10));
                
                map.put(4, &quot;他是4&quot;);
                System.out.println(map.get(4));
                
                map.remove(4);
                System.out.println(map.get(4));
                
                
                
                //       key
                HashSet&amp;lt;String&amp;gt;  set = new HashSet&amp;lt;&amp;gt;();
                set.add(&quot;abc&quot;);
                set.contains(&quot;abc&quot;);
                set.remove(&quot;abc&quot;);
                
                // 哈希表，增、删、改、查，在使用时，O（1）
                
                
                System.out.println(&quot;=====================&quot;);
                
                
                int a = 100000;
                int b = 100000;
                System.out.println(a == b);
                
                Integer c = 100000;
                Integer d = 100000;
                System.out.println(c.equals(d));
                
                Integer e = 127;  //  - 128  ~  127
                Integer f = 127;
                System.out.println(e == f);
                
                
                
                HashMap&amp;lt;Node, String&amp;gt; map2 = new HashMap&amp;lt;&amp;gt;();
                Node node1 = new Node(1);
                Node node2 = node1;
                map2.put(node1, &quot;我是node1&quot;);
                map2.put(node2, &quot;我是node1&quot;);
                System.out.println(map2.size());
                
                System.out.println(&quot;======================&quot;);
                
                TreeMap&amp;lt;Integer, String&amp;gt; treeMap = new TreeMap&amp;lt;&amp;gt;();
                
                treeMap.put(3, &quot;我是3&quot;);
                treeMap.put(4, &quot;我是4&quot;);
                treeMap.put(8, &quot;我是8&quot;);
                treeMap.put(5, &quot;我是5&quot;);
                treeMap.put(7, &quot;我是7&quot;);
                treeMap.put(1, &quot;我是1&quot;);
                treeMap.put(2, &quot;我是2&quot;);

                System.out.println(treeMap.containsKey(1));
                System.out.println(treeMap.containsKey(10));
                
                System.out.println(treeMap.get(4));
                System.out.println(treeMap.get(10));
                
                treeMap.put(4, &quot;他是4&quot;);
                System.out.println(treeMap.get(4));
                
                treeMap.remove(4);
                System.out.println(treeMap.get(4));
                
                System.out.println(treeMap.firstKey());
                System.out.println(treeMap.lastKey());
                // &amp;lt;= 4
                System.out.println(treeMap.floorKey(4));
                // &amp;gt;= 4
                System.out.println(treeMap.ceilingKey(4));
                
                // O(logN)      
                
        }
        
        
        
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 12 Jul 2020 15:54:00 +0000</pubDate>
<dc:creator>凝风</dc:creator>
<og:description>链表、栈、队列、递归、哈希 链表 单向链表 单向链表的节点结构(可以实现成泛型) ： public class Node { public int value; public Node next; p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/darope/p/13290810.html</dc:identifier>
</item>
<item>
<title>Maven 聚合与继承 - 经济人</title>
<link>http://www.cnblogs.com/jingjiren/p/13290800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingjiren/p/13290800.html</guid>
<description>&lt;h2&gt;一. 聚合&lt;/h2&gt;
&lt;p&gt;　　随着技术的飞速发展和各类用户对软件的要求越来越高，软件本身也变得越来越复杂，然后软件设计人员开始采用各种方式进行开发，于是就有了我们的分层&lt;a title=&quot;大型网站架构知识库&quot; href=&quot;http://lib.csdn.net/base/architecture&quot; target=&quot;http://blog.csdn.net/wanghantong/article/details/_blank&quot;&gt;架构&lt;/a&gt;、分模块开发，来提高代码的清晰和重用。针对于这一特性，maven也给予了相应的配置。&lt;/p&gt;
&lt;p&gt;　　我们在开发过程中，创建了2个以上的模块，每个模块都是一个独立的maven project，在开始的时候我们可以独立的编译和&lt;a title=&quot;软件测试知识库&quot; href=&quot;http://lib.csdn.net/base/softwaretest&quot; target=&quot;http://blog.csdn.net/wanghantong/article/details/_blank&quot;&gt;测试&lt;/a&gt;运行每个模块，但是随着项目的不断变大和复杂化，我们期望能够使用简单的操作来完成编译等工作，这时Maven给出了聚合的配置方式。&lt;/p&gt;
&lt;p&gt;　　所谓聚合，顾名思义，就是把多个模块或项目聚合到一起，我们可以建立一个专门负责聚合工作的Maven 工程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　建立该project的时候，我们要注意以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　1. 聚合模块本身也做为一个Maven项目，它必须有自己的POM&lt;/p&gt;
&lt;p&gt;　　　　2. 它的打包方式必须为： pom&lt;/p&gt;
&lt;p&gt;　　　　3. 引入了新的元素：modules---module&lt;/p&gt;
&lt;p&gt;　　　　4. 版本：聚合模块的版本和被聚合模块版本一致&lt;/p&gt;
&lt;p&gt;　　　　5. 相对目录：每个module的值都是一个当前POM的相对目录&lt;/p&gt;
&lt;p&gt;　　　　6. 目录名称：为了方便的快速定位内容，模块所处的目录应当与其artifactId一致(Maven约定而不是硬性要求)，总之，模块所处的目录必须和&amp;lt;module&amp;gt;模块所处的目录&amp;lt;/module&amp;gt;相一致。&lt;/p&gt;
&lt;p&gt;　　　　7. 习惯约定：为了方便构建，通常将聚合模块放在项目目录层的最顶层，其它聚合模块作为子目录存在。这样当我们打开项目的时候，第一个看到的就是聚合模块的POM&lt;/p&gt;
&lt;p&gt;　　　　8. 聚合模块减少的内容：聚合模块的内容仅仅是一个pom.xml文件，它不包含src/main/&lt;a title=&quot;Java SE知识库&quot; href=&quot;http://lib.csdn.net/base/javase&quot; target=&quot;http://blog.csdn.net/wanghantong/article/details/_blank&quot;&gt;Java&lt;/a&gt;、src/test/java等目录，因为它只是用来帮助其它模块构建的工具，本身并没有实质的内容。&lt;/p&gt;
&lt;p&gt;　　　　9. 聚合模块和子模块的目录：他们可以是父子类，也可以是平行结构，当然如果使用平行结构，那么聚合模块的POM也需要做出相应的更改。&lt;/p&gt;
&lt;h2&gt;二. 继承&lt;/h2&gt;
&lt;p&gt;　　我们在项目开发的过程中，可能多个模块独立开发，但是多个模块可能依赖相同的元素，比如说每个模块都需要Junit，使用&lt;a title=&quot;Java EE知识库&quot; href=&quot;http://lib.csdn.net/base/javaee&quot; target=&quot;http://blog.csdn.net/wanghantong/article/details/_blank&quot;&gt;spring&lt;/a&gt;的时候，其核心jar也必须都被引入，在编译的时候，maven-compiler-plugin插件也要被引入。这时我们采用继承，就不用在每个子模块分别定义了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何配置继承：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1. 说到继承肯定是一个父子结构，那么我们在父工程中来创建一个parent project&lt;/p&gt;
&lt;p&gt;　　2. &amp;lt;packaging&amp;gt;: 作为父模块的POM，其打包类型也必须为POM&lt;/p&gt;
&lt;p&gt;　　3. 结构：父模块只是为了帮助我们消除重复，所以它也不需要src/main/java、src/test/java等目录&lt;/p&gt;
&lt;p&gt;　　4. 新的元素：&amp;lt;parent&amp;gt; ， 它是被用在子模块中的&lt;/p&gt;
&lt;p&gt;　　5. &amp;lt;parent&amp;gt;元素的属性：&amp;lt;relativePath&amp;gt;: 表示父模块POM的相对路径，在构建的时候，Maven会先根据relativePath检查父POM，如果找不到，再从本地仓库查找&lt;/p&gt;
&lt;p&gt;　　6. relativePath的默认值： ../pom.xml&lt;/p&gt;
&lt;p&gt;　　7. 子模块省略groupId和version： 使用了继承的子模块中可以不声明groupId和version, 子模块将隐式的继承父模块的这两个元素&lt;/p&gt;
&lt;h2&gt;三. 聚合与继承的区别&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1539753/202007/1539753-20200712235037700-406451499.png&quot; alt=&quot;&quot; width=&quot;714&quot; height=&quot;274&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　聚合和继承通常是结合使用的，但是其作用是不同的。聚合是将多个模块的工程汇聚到一起，而继承则是指明某个模块工程要继承另一个模块功能。&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jul 2020 15:52:00 +0000</pubDate>
<dc:creator>经济人</dc:creator>
<og:description>一. 聚合 随着技术的飞速发展和各类用户对软件的要求越来越高，软件本身也变得越来越复杂，然后软件设计人员开始采用各种方式进行开发，于是就有了我们的分层架构、分模块开发，来提高代码的清晰和重用。针对于这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jingjiren/p/13290800.html</dc:identifier>
</item>
<item>
<title>Python 实现邮件发送功能（初级） - 挖挖土豆</title>
<link>http://www.cnblogs.com/potato-find/p/13290419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/potato-find/p/13290419.html</guid>
<description>&lt;p&gt;本文主要描述了利用Python发送邮件的基本方法，以及邮件发送的基本原理&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;121.19408444816&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　在我们日常项目中，会经常使用到邮件的发送功能，如何利用Python发送邮件也是一项必备的技能。&lt;/span&gt;&lt;span&gt;本文主要讲述利用Python来发送邮件的一些基本操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;本章主要包含知识点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;邮件发送原理简述即常用smtp邮箱服务器&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;发送文字邮件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;发送html邮件&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　我们一般发送邮件时，用到的代理有outlook，qq邮箱等，不管用什么代理，你都需要登录你的邮箱，而这个邮箱就是在各大邮箱服务器上开辟的一部分空间，用来接收、发送和存储你的邮件信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　说到邮件发送，不得不了解一下SMTP(Simple Mail Transfer Protocol)即简单邮件传输协议，是一种提供可靠且有效电子邮件传输的协议。邮件发送原理简单讲就是代理通过SMTP协议将信息发送到邮箱服务器上，邮箱服务器再通过POP3协议转发到收件人的邮件服务器中，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1949471/202007/1949471-20200712214736644-2109643454.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因此使用Python发送邮件时，可以将Python的解释器当做一个代理，需要首先连接到邮箱服务器，将邮件发过去，那么由于不同公司的邮箱服务器地址不尽相同，这里列出了一些常用的地址如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1949471/202007/1949471-20200712215456571-1862122374.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; 　　既然已经知道邮件发送原理，接下来就是用Python连接smtp服务器，不就可发送邮件了。其实强大的python早就封装好了一个package：email， 利用其中的几个类即可实现，具体代码如下：　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; email.mime.text &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MIMEText
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; email.header &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Header
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; email.mime.multipart &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MIMEMultipart
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; smtplib
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Email(object):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.smtp = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         self.username = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         self.password = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         self.subject = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         self.sender = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         self.receiver =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         self.cc =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; message_init(self, html):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         message =&lt;span&gt; MIMEMultipart()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;subject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(self.subject, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.sender
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(self.receiver)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(self.cc)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解决乱码, html是html格式的str&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         message_context = MIMEText(html, _subtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, _charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 邮件正文内容&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        message.attach(message_context)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　Email自定义类中属性包含了邮箱服务器的地址，邮箱登录的用户名和密码，邮件主题，发件人，收件人和抄送人。这里注意了，收件人和抄送人是个list，添加的时候使用append()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　message_init(self, html)即将发送内容进行初始化，包括邮件发送和收件人的初始化。其中 MIMEText(html, _subtype='html', _charset='utf-8') 中，参数一为发送的邮件内容，为字符串；参数二表示设置文本格式为html（邮件都是使用html格式发送的）；参数三表示设置编码格式为utf-8。如上这样一个邮件信息包就构造好了，万事俱备只欠东风，发送邮件的核心代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; send_email(self, html):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     message =&lt;span&gt; self.message_init(html)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     smtp_obj =&lt;span&gt; smtplib.SMTP(self.smtp)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  smtp_obj.login(self.username, self.password)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     smtp_obj.sendmail(self.sender, self.receiver +&lt;span&gt; self.cc, message.as_string())
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     smtp_obj.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　模拟正常客户端邮件发送，遵循登录-&amp;gt;发送-&amp;gt;退出原则， 这里注意sendmail的第二个参数为 收件人和抄送人的合集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面来测试一下这个代码是否可行，发送一段简单的文字：　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     sende =&lt;span&gt; Email()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     strs = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is a test email / 这是一封测试邮件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     sende.smtp = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     sende.username = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wjian.coming@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     sende.password = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxxxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     sende.subject = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test/测试邮件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     sende.sender = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wjian.coming@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     sende.receiver.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;948001879@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     sende.cc.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;948001879@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  sende.send_email(strs)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如上，测试了发送中文和英文两种语言，发送了测试的简单字符串，实测结果可行，截图如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1949471/202007/1949471-20200712221812902-236509597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么如何发送html格式文件呢？其实想想也很简单，将html文件全部读取出来之后，转为str即可，如何转换，可以参考我之前写的文章，读取文件生成str，参考链接：&lt;a href=&quot;https://www.cnblogs.com/potato-find/p/13216471.html&quot;&gt;https://www.cnblogs.com/potato-find/p/13216471.html&lt;/a&gt; 使用 readFile 方法即可，然后复用上述的方法。具体的代码就不在这里体现了，有兴趣的同学可以结合实现一下呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么，利用Python如何发送邮件已经都了解了吧，那么这时就会引发更深的问题：如何添加附件？如何发送图片呢？ Good question！ 关注我，下期为你解答。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　(希望我的文章能够助你一臂之力，成就更辉煌的你，关注我，我们一起进步)&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 12 Jul 2020 14:36:00 +0000</pubDate>
<dc:creator>挖挖土豆</dc:creator>
<og:description>本文主要描述了利用Python发送邮件的基本方法，以及邮件发送的基本原理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/potato-find/p/13290419.html</dc:identifier>
</item>
<item>
<title>程序员修神之路--分布式系统设计理念这么难学？ - 架构师修行之路</title>
<link>http://www.cnblogs.com/zhanlang/p/13290346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanlang/p/13290346.html</guid>
<description>&lt;h3 id=&quot;分布式系统&quot;&gt;分布式系统&lt;/h3&gt;
&lt;p&gt;身为二十一世纪的一名程序员，没听说过分布式系统就显得自己好像没有女票一样尴尬。无论是出去面试跟面试官吹水，还是在工作中和同事吹水，分布式系统永远是你显得高人一等的筹码。分布式系统已经诞生了好几十年，说起来比我们八零后程序员好要老成，随着现代互联网的崛起，对于系统在性能，可靠性上的要求大大提高。&lt;/p&gt;
&lt;p&gt;分布式系统的定义其实很简单，也很抽象：任何由处于不同物理位置的多个进程提供相同服务的系统都可以称之为分布式系统，退一万步讲，同一台服务器上的不同进程也可以组成分布式系统&lt;/p&gt;
&lt;p&gt;分布式系统的首要目标是提高系统的整体性能，但不仅限于吞吐量，可靠性，响应时间，数据一致性等，其中提高性能指标是最重要的。如果最终设计出来的分布式系统占用了更多的资源却还比不上单机的性能，那这个分布式系统是失败的，理论上没有存在的价值&lt;/p&gt;
&lt;p&gt;一个分布式系统的整体性能提高并不是单单依靠扩展来实现，提高单机的处理性能仍然很重要，一个把单机性能发挥到极致的分布式系统，在同等性能的需求下，采用的资源要远远小于其他系统。&lt;/p&gt;
&lt;h3 id=&quot;分布式系统痛点&quot;&gt;分布式系统痛点&lt;/h3&gt;
&lt;p&gt;一个好的分布式系统在性能方面要远超单机系统，但是在数据行为方面要表现的和单机系统一样优秀，其中包括数据的一致性，硬件的故障发生率，网络的不稳定性等。&lt;/p&gt;
&lt;p&gt;无论是单机系统还是分布式系统都存在无法回避并且无法彻底去除的风险，比如：硬盘发生故障，网络发生瘫痪，光纤被挖.....分布式系统随着节点的增加，把这些故障的发生率也随之增大，所以分布式系统其中一个目标是要尽量降低这些风险，也就是所谓的容错性。&lt;/p&gt;
&lt;p&gt;既要快还要不出错，这在“伦理”上是冲突的。就像我们平时说的分布式锁，如果要保证对一个资源的修改不会发生线程安全问题，就要付出降低性能的代价。至于性能和容错性怎样选择，还需要具体到每个业务场景中，比如支付场景中，数据的正确性可能要比性能指标更重要，而那些日志型数据，比如用户的登录日志，这些数据的最大特点就是允许小部分丢失，在这样的日志系统设计中，可能性能指标要大于容错性。&lt;/p&gt;
&lt;p&gt;目前烂大街的CAP原则的讲解，是针对分布式系统的一个抽象理论，包括之后BASE理论，也是针对分布式系统的一种指导方案。&lt;/p&gt;
&lt;h3 id=&quot;设计分布式系统&quot;&gt;设计分布式系统&lt;/h3&gt;
&lt;p&gt;分布式系统的特性就决定了它自出生之日起，就有多个节点如何协同工作的难题。就像一个团队，如果让这个团队有条不紊的工作本来就是个难题。一堆节点为了完成同样的任务，注定需要一个规范方圆的规则。就目前已知的方案中，主要有中心化和去中心化两种解决方案&lt;/p&gt;
&lt;h5 id=&quot;中心化&quot;&gt;中心化&lt;/h5&gt;
&lt;p&gt;中心化的分布式设计理念是目前主流的方案，在中心化的设计方案中，节点是有角色区分的：Leader节点和Work节点，即：领导和干活的。就和现实中类似，leader只负责分发任务和监督，Work节点只负责领取任务干活，多说一句，这里Work节点领取任务，当然从通信的角度来说，又可以分为push和pull（推和拉）方式。推方式是指，leader节点主动将任务分发给Work节点，拉方式是指：Work节点主动去申请任务。至于push和pull的优缺点，不作为今天的主题展开讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/553/5534532/202007/03Se8yIRj_wFSm.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在任何系统中，都无可避免的需要考虑节点down掉的问题，分布式系统也一样。在中心化分布式设计中，leader和Work也一样都存在down掉的可能性。如果leader掉的话，整个系统都陷入瘫痪，按照最简单的设计思路，leader节点需要一个从节点或者备用节点，在主节点down掉之后，从主节点或者备用主节点可以手动或者自动实现leader节点服务。至于一个Work节点down掉，一般不会使整个系统陷入瘫痪，除非全部Work节点同时down掉。一个Work节点down掉，但是会影响这个节点当前正在执行的任务，所以在必要的条件下可以设计成任务需要Ack才好，即：一个任务的完成需要确认，如果长时间没有确认，leader会发起重新分配任务的操作。&lt;/p&gt;
&lt;p&gt;说到leader的问题，现在目前大多数分布式系统都具备了自动选举leader的功能，这还要感谢paxos，raft等选举算法。在leader不可用的时候，这些系统会自动根据节点情况选举出新的leader节点来继续提供服务，这大大提高了系统可用性。&lt;/p&gt;
&lt;p&gt;在所有的中心化设计中，数据的写操作都发生在leader节点，这在某种程度上类似于单机系统，所以这种中心化设计并不适合那些大量写的操作。&lt;/p&gt;
&lt;h5 id=&quot;去中心化&quot;&gt;去中心化&lt;/h5&gt;
&lt;p&gt;在去中心化分布式系统设计中，节点类型并不区分Leader和Work，所有节点都是相等的。所以任何一个节点down掉都不会导致整个系统瘫痪，这是它的优势。但是获取系统中每个节点的信息却比中心化设计要难很多，在中心化设计中，leader节点存储着系统中所有的节点信息，并可以实时把这些信息同步到其他节点，同时可以利用相应算法来达到一致性的要求。去中心化的设计中，每个节点只能依靠和其他节点不断通信来获取整个系统的节点信息，这在技术难度上要比中心化高出很多。&lt;/p&gt;
&lt;p&gt;在网络中，网络是不可靠的。恰恰是这个原因，又加大了每个节点互相通信的难度。在极限情况下，去中心化的设计方案会出现多个小范围的“团伙”，这就是所说的脑裂。比如：现在一个由10个节点组成的分布式系统，有可能由于网络原因会划分为两个5节点互相通信的两个“团伙”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/553/5534532/202007/0TEJUnuKH_Heua.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果出现脑裂的情况，目前主流的解决方案和数据库死锁的处理情况类似，自爆一个对系统影响比较小的。&lt;/p&gt;
&lt;p&gt;完全中心化和去中心化的系统并不常见，反而现在慢慢出现的是二者的搭配者，表面看似去中心化，设计理念却是中心化的思路，在这种架构下，leader是程序根据某种算法选举出来的，而且在系统leader发生故障的时候，系统会自动重新选举leader节点。&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;p&gt;对于每个系统来说，可靠性是它要实现的主要目标之一，尤其是分布式系统。在网络通信，硬件设备等条件都非100%可靠的情况下，如何提高分布式系统的可用性是一个很深的话题。就算是国内顶尖的BAT等大厂，也没有一个系统能达到100%的可用性，4个9的可用性已经是很巅峰了。&lt;/p&gt;
&lt;p&gt;分布式系统本质上是多个节点通过网络IO组成的，其中夹杂着一些不可抗拒的元素，所以请记住一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;分布式系统是不可靠的，我们只能尽量减小故障发生率，却根除不了，如果你的老板要你设计一套100%可用性的系统，要么他是二货，要么他是二B&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 12 Jul 2020 14:24:00 +0000</pubDate>
<dc:creator>架构师修行之路</dc:creator>
<og:description>分布式系统 身为二十一世纪的一名程序员，没听说过分布式系统就显得自己好像没有女票一样尴尬。无论是出去面试跟面试官吹水，还是在工作中和同事吹水，分布式系统永远是你显得高人一等的筹码。分布式系统已经诞生了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanlang/p/13290346.html</dc:identifier>
</item>
</channel>
</rss>