<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>爬虫系列二(数据清洗---&gt;xpath解析数据) - 柳帅</title>
<link>http://www.cnblogs.com/angle6-liu/p/10437896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/angle6-liu/p/10437896.html</guid>
<description>&lt;h2&gt;一 xpath介绍&lt;/h2&gt;
&lt;p&gt;XPath 是一门在 XML 文档中查找信息的语言。XPath 用于在 XML 文档中通过&lt;span&gt;元素和属性&lt;/span&gt;进行导航。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;XPath 使用路径表达式在 XML 文档中进行导航&lt;/li&gt;
&lt;li&gt;XPath 包含一个标准函数库&lt;/li&gt;
&lt;li&gt;XPath 是 XSLT 中的主要元素&lt;/li&gt;
&lt;li&gt;XPath 是一个 W3C 标准&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;二 xpath 术语&lt;/h2&gt;
&lt;div&gt;
&lt;div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;概念&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;解释&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;举例&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;基本值（或称原子值，Atomic value）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基本值是无父或无子的节点&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;J K. Rowling，&quot;en&quot;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;项目（Item）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;项目是基本值或者节点&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;节点关系-父（Parent）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;每个元素以及属性都有一个父。&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;在上面的例子中，book 元素是 title、author、year 以及 price 元素的父：&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;节点关系-子（Children）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;元素节点可有零个、一个或多个子。&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;在上面的例子中，title、author、year 以及 price 元素都是 book 元素的子：&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;节点关系-同胞（Sibling）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;拥有相同的父的节点。&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;在上面的例子中，title、author、year 以及 price 元素都是同胞：&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;节点关系-先辈（Ancestor）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;某节点的父、父的父，等等。&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;在上面的例子中，title 元素的先辈是 book 元素和 bookstore 元素。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;后代（Descendant）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;某个节点的子，子的子，等等。&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;在上面的例子中，bookstore 的后代是 book、title、author、year 以及 price 元素。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;三 xpath术语&lt;/h2&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;nodename&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取此节点的所有子节点。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;/&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;从根节点选取。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;//&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;.&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取当前节点。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;..&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取当前节点的父节点。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;@&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取属性。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;四 助力理解&lt;/h2&gt;
&lt;div&gt;
&lt;div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;路径表达式&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;结果&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取 bookstore 元素的所有子节点。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;/bookstore&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;bookstore/book&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取属于 bookstore 的子元素的所有 book 元素。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;//book&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取所有 book 子元素，而不管它们在文档中的位置。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;bookstore//book&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;//@lang&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取名为 lang 的所有属性。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;br/&gt;&lt;div&gt;
&lt;div&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;路径表达式&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;结果&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;/bookstore/book[1]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取属于 bookstore 子元素的第一个 book 元素。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;/bookstore/book[last()]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取属于 bookstore 子元素的最后一个 book 元素。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;/bookstore/book[last()-1]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取属于 bookstore 子元素的倒数第二个 book 元素。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;/bookstore/book[position()&amp;lt;3]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取最前面的两个属于 bookstore 元素的子元素的 book 元素。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;//title[@lang]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取所有拥有名为 lang 的属性的 title 元素。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;//title[@lang=’eng’]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;/bookstore/book[price&amp;gt;35.00]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;/bookstore/book[price&amp;gt;35.00]/title&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h4&gt;以上摘抄：&lt;a href=&quot;https://www.jianshu.com/p/62ba163c5be5&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/62ba163c5be5&lt;/a&gt;&lt;/h4&gt;

&lt;h2&gt;五 xapth解析数据实例----(二手房价)&lt;/h2&gt;

&lt;pre&gt;
'''&lt;br/&gt;xpath数据解析流程:&lt;br/&gt;1.pip install lxml&lt;br/&gt;2.导包:from lxml import etree&lt;br/&gt;3.实例化一个etree对象(将页面数据加载到该对象)&lt;br/&gt;4.调用etree中的xpath函数结合着xpath表达式进行数据解析操作     &lt;br/&gt;'''
&lt;/pre&gt;
&lt;h3&gt;1 url&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://sz.58.com/ershoufang/&quot;&gt;https://sz.58.com/ershoufang/&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2 请求头&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
headers=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user-agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.20 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3 获取页面数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
page_text=requests.get(url=url,headers=headers).text
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4 使用xpath解析数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 实例化etree对象&lt;/span&gt;
tree=&lt;span&gt;etree.HTML(page_text)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2 写表达式定位到需要获取的房价信息&lt;/span&gt;
li_list=tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//ul[@class=&quot;house-list-wrap&quot;]/li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取房价的页面所有的li标签&lt;/span&gt;
&lt;span&gt;
fp&lt;/span&gt;=open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fangjia.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; li &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li_list:
    title&lt;/span&gt;=li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[@class=&quot;list-info&quot;]/h2/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取房价描述的title&lt;/span&gt;
    price=li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[@class=&quot;price&quot;]/p[@class=&quot;sum&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取房价描述的price&lt;/span&gt;
    price=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.join(price)
    fp.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+title+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;price)
fp.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;　　xpath 解析的数据的返回值是一个列表.&lt;/p&gt;

&lt;h3&gt;完整代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

url&lt;/span&gt;=f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://bj.58.com/ershoufang/pn1/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

headers&lt;/span&gt;=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user-agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.20 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

page_text&lt;/span&gt;=requests.get(url=url,headers=&lt;span&gt;headers).text


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例化etree对象&lt;/span&gt;
tree=&lt;span&gt;etree.HTML(page_text)
li_list&lt;/span&gt;=tree.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//ul[@class=&quot;house-list-wrap&quot;]/li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

fp&lt;/span&gt;=open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fangjia.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; li &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li_list:
    title&lt;/span&gt;=li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[@class=&quot;list-info&quot;]/h2/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
    price&lt;/span&gt;=li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[@class=&quot;price&quot;]/p[@class=&quot;sum&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    price&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.join(price)
    fp.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+title+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;price)
fp.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 26 Feb 2019 07:53:00 +0000</pubDate>
<dc:creator>柳帅</dc:creator>
<og:description>一 xpath介绍 XPath 是一门在 XML 文档中查找信息的语言。XPath 用于在 XML 文档中通过元素和属性进行导航。 XPath 使用路径表达式在 XML 文档中进行导航 XPath 包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/angle6-liu/p/10437896.html</dc:identifier>
</item>
<item>
<title>JavaScript快速入门 - JaminYe</title>
<link>http://www.cnblogs.com/JaminYe/p/10437883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JaminYe/p/10437883.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;/&gt;&lt;title&gt;JavaScript快速入门 - JaminYe - 博客园&lt;/title&gt;&lt;meta property=&quot;og:description&quot; content=&quot;JavaScript: 概念 :一门客户端脚本语言 运行在客户端浏览器中的,每一个浏览器都有一个JavaScript的解析引擎 脚本语言:不需要编译,直接就可以被浏览器解析执行了 功能: 可以用来增强&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=-duj5vpGTntb85GJoM3iRI972XwWcI-j8zmqDzyfu2w1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife.css?v=g4Oce5UBaUn_FUwadcT09ICEg5NkULQGtUpNhTtrI8U1&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife-mobile.css?v=nSeK_P8BAqpQ4UDLpcwd6yl-jVYCXnR833BwkQ30uqQ1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;https://www.cnblogs.com/JaminYe/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;https://www.cnblogs.com/JaminYe/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;https://www.cnblogs.com/JaminYe/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;h2 id=&quot;javascript&quot;&gt;JavaScript:&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;概念 :一门客户端脚本语言
&lt;ul&gt;&lt;li&gt;运行在客户端浏览器中的,每一个浏览器都有一个JavaScript的解析引擎&lt;/li&gt;
&lt;li&gt;脚本语言:不需要编译,直接就可以被浏览器解析执行了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;功能:
&lt;ul&gt;&lt;li&gt;可以用来增强用户和html页面的交互过程,用来控制html元素,让页面有一些动态效果,增强用户的体验&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;JavaScrpit=ECMAScript+JavaScript(BOM+DOM);&lt;/li&gt;
&lt;li&gt;ECMAScript:客户端脚本语言的标准
&lt;ol&gt;&lt;li&gt;基本语法:
&lt;ol&gt;&lt;li&gt;与html结合方式
&lt;ol&gt;&lt;li&gt;内部js:
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Tue, 26 Feb 2019 07:52:00 +0000</pubDate>
<dc:creator>JaminYe</dc:creator>
<og:description>JavaScript: 概念 :一门客户端脚本语言 运行在客户端浏览器中的,每一个浏览器都有一个JavaScript的解析引擎 脚本语言:不需要编译,直接就可以被浏览器解析执行了 功能: 可以用来增强</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JaminYe/p/10437883.html</dc:identifier>
</item>
<item>
<title>Java8  Lambda 之 Collection Stream - AaronCui</title>
<link>http://www.cnblogs.com/AaronCui/p/10437866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AaronCui/p/10437866.html</guid>
<description>&lt;h2 id=&quot;collection.stream&quot;&gt;Collection.stream()&lt;/h2&gt;
&lt;p&gt;测试实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Demo {
    private Long id;
    private String name;

    // Getters and Setters   
}

// 实例化并组成一个List
List&amp;lt;Demo&amp;gt; demos = Lists.newArrayList(new Demo(1L, &quot;SF&quot;), new Demo(2L, &quot;AXE&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map-collect用法&quot;&gt;1.map + collect用法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;场景1：获取List列表的所有id&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;No Lambda&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static List&amp;lt;Long&amp;gt; getIds(List&amp;lt;Demo&amp;gt; demos){
        List&amp;lt;Long&amp;gt; ids = Lists.newArrayList();
        for (Demo d : demos) {
            ids.add(d.getId());
        }
        return ids;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Lambda’s show&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Long&amp;gt; ids = demos.stream().map(Demo::getId).collect(toList());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后&lt;code&gt;toList()&lt;/code&gt; 可以有更多的实现,比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Set&amp;lt;Long&amp;gt; ids = demos.stream().map(Demo::getId).collect(toSet());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;场景2：list变成map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候我们把list变成map,将多次List的&lt;code&gt;O(n)&lt;/code&gt;遍历变成Map的&lt;code&gt;O(1)&lt;/code&gt;查询，拿空间换时间&lt;/p&gt;
&lt;p&gt;No lambda&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Map&amp;lt;Long, Demo&amp;gt; getIds(List&amp;lt;Demo&amp;gt; demos){
        Map&amp;lt;Long, Demo&amp;gt; map = Maps.newHashMap;
        for (Demo d : demos) {
            map.put(d.getId, d);
        }
        return map;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Lambda‘s show&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Map&amp;lt;Long, Demo&amp;gt; map = demos.stream().collect(toMap(Demo::getId, o -&amp;gt; o));
 &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;filter&quot;&gt;2.filter&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;场景1：从List中找到&lt;code&gt;name=&quot;SF&quot;&lt;/code&gt;的Demo实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;No lambda&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Demo getSpecifyDemo(String name, List&amp;lt;Demo&amp;gt; demos){

    Demo target = null;
    for (Demo demo : demos) {
        if (name.equals(demo.getName())) {
            target = demo;
        }
    }
    return target;
}
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Lambda's show--粗犷的老汉推车&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String targetName = &quot;SF&quot;;
Demo target = demos.stream().filter(d -&amp;gt; targetName.equals(d.getName())).findFirst().orElse(null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种写法非常简单，但是调用链太长，一个lambda能够绕地球好几圈，最好写成以下格式，防止步子迈得太大。&lt;/p&gt;
&lt;p&gt;Lambda's show--优雅传教士&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Demo target = demos.stream()
            .filter(d -&amp;gt; targetName.equals.equals(d.getName()))
            .findFirst()
            .orElse(null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;find()&lt;/code&gt;的结果是&lt;code&gt;Optional&lt;/code&gt;,&lt;code&gt;Optional&lt;/code&gt;号称&lt;code&gt;NPE&lt;/code&gt;终结者，于是对于&lt;code&gt;find()&lt;/code&gt;的结果你可以随意使用终结者携带的任何武器，例如&lt;code&gt;orElse()&lt;/code&gt;,&lt;code&gt;ifPresent()&lt;/code&gt;,&lt;code&gt;isPresent()&lt;/code&gt;...每个用起来都是那种哒哒哒冒蓝火的，更多姿势详见&lt;code&gt;Optional&lt;/code&gt;的裸体源码。&lt;/p&gt;
&lt;h2 id=&quot;match&quot;&gt;3.match&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;match()&lt;/code&gt;是&lt;code&gt;filter()&lt;/code&gt;的缩写版本，返回结果只有&lt;code&gt;boolean&lt;/code&gt;类型，返回是否匹配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景1：当前list中某个元素是否符合某个条件&lt;/strong&gt;&lt;br/&gt;这个例子，给出另一个用法&lt;code&gt;Demo::getId&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;No lambda&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; condition = new ArrayList&amp;lt;&amp;gt;();
condition.add(&quot;SF&quot;);

public static boolean isExist(List&amp;lt;String&amp;gt; condition, List&amp;lt;Demo&amp;gt; demos){
    boolean flag = false;

    for (Demo demo : demos) {
        if (condition.contains(demo.getName())) {
            flag = true;
            break;
        }
    }

    return flag;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Lambda's show 使用&lt;code&gt;filter&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean flag = demos.stream()
            .map(Demo::getName)
            .filter(condition::contains)
            .findAny()
            .isPresent();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Lambda's show 直接使用match&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean flag = demos.stream()
            .map(Demo::getName)
            .anyMatch(condition::contains);&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Feb 2019 07:50:00 +0000</pubDate>
<dc:creator>AaronCui</dc:creator>
<og:description>Lambda 之 Collection Stream Collection.stream() 测试实体类 1.map + collect用法 场景1：获取List列表的所有id No Lambda L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AaronCui/p/10437866.html</dc:identifier>
</item>
<item>
<title>Jmeter连接Redis，获取Redis数据集 - 倾听起风</title>
<link>http://www.cnblogs.com/zocymo/p/10437760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zocymo/p/10437760.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://redis.io/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Redis&lt;/a&gt;（REmote DIctionary Server）是一个开源的内存数据结构存储，用作数据库，缓存和消息代理。&lt;/p&gt;
&lt;p&gt;本博文是分享jmeter怎么连接使用Redis数据库。&lt;/p&gt;

&lt;p&gt;1.从JMeter插件管理器安装Redis数据集插件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下载&lt;a href=&quot;https://jmeter-plugins.org/get/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Plugins Manager JAR文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;将文件复制到Jmeter的lib / ext目录&lt;/li&gt;
&lt;li&gt;重启JMeter&lt;/li&gt;
&lt;li&gt;单击“选项”，然后单击“插件管理器”&lt;/li&gt;
&lt;li&gt;点击“可用插件”&lt;/li&gt;
&lt;li&gt;选择“Redis数据集”，然后单击“应用更改并重新启动JMeter”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 重新启动JMeter后，就能够在菜单中看到Redis Data Set配置元素：&lt;/p&gt;
&lt;p&gt; &lt;em&gt;右键单击测试计划 - &amp;gt;添加 - &amp;gt;配置元素 - &amp;gt; jp @ gc - Redis数据集&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1359601/201902/1359601-20190226150642535-1150198514.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如上，插件安装成功。&lt;/p&gt;

&lt;h2&gt;Window 下安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;下载地址：&lt;/strong&gt;&lt;a href=&quot;https://github.com/MSOpenTech/redis/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/MSOpenTech/redis/releases&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 &lt;strong&gt;Redis-x64-xxx.zip&lt;/strong&gt;压缩包到C盘（也可以选择其他路径），解压后，将文件夹重新命名为&lt;strong&gt;redis&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/11/3B8D633F-14CE-42E3-B174-FCCD48B11FF3.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开一个 &lt;strong&gt;cmd&lt;/strong&gt; 窗口 使用 cd 命令切换目录到 &lt;strong&gt;C:\redis&lt;/strong&gt; 运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
redis-server.exe redis.windows.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入之后，会显示如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/11/redis-install1.png&quot; alt=&quot;Redis 安装&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这时候另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。&lt;/p&gt;
&lt;p&gt;切换到 redis 目录下运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
redis-cli.exe -h 127.0.0.1 -p 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置键值对:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
set myKey abc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取出键值对:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/11/redis-install2.jpg&quot; alt=&quot;Redis 安装&quot;/&gt;&lt;/p&gt;
&lt;p&gt;127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
redis 127.0.0.1:6379&amp;gt; ping
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果Redis服务器设置正确，您将看到响应：“PONG”。&lt;/p&gt;

&lt;h3&gt;关闭后如果需要重新启动 Redis&lt;/h3&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;span class=&quot;pln&quot;&gt;打开一个cmd窗口，切换到 redis 目录下运行：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
redis-server
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;查看 redis 是否启动？&lt;/h3&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;span class=&quot;pln&quot;&gt;另外打开一个&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;cmd窗口，切换到 redis 目录下运行&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;　返回如下数据即可输入后续操作命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1359601/201902/1359601-20190226151932111-770380305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Redis服务器已启动并正在运行。现在填充一些数据去测试一下。 &lt;/p&gt;
&lt;p&gt;如上图所示，Redis命令行界面已经打开，现在让我们将数据添加到Redis数据库：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;LPUSH test&lt;/em&gt;demo hangzhou,shanghai&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LPUSH &lt;em&gt;test&lt;/em&gt;demo beijing,wuhan&lt;/em&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LPUSH &lt;em&gt;test&lt;/em&gt;demo nanchang,shenzhen&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;LPUSH命令使用键“&lt;em&gt;&lt;em&gt;test&lt;/em&gt;demo&lt;/em&gt;”将值添加到Redis列表。&lt;/p&gt;

&lt;p&gt; 现在我们准备创建一个测试JMeter脚本来展示如何使用Redis数据集配置元素。&lt;/p&gt;
&lt;p&gt;1、将一个线程组添加到测试计划&lt;/p&gt;
&lt;p&gt;&lt;em&gt;右键单击测试计划 - &amp;gt;添加 - &amp;gt;线程（用户） - &amp;gt;线程组&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2、将Redis数据集添加到线程组&lt;/p&gt;
&lt;p&gt;&lt;em&gt;线程组 - &amp;gt;添加 - &amp;gt;配置元素 - &amp;gt; jp @ gc - Redis数据集&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;3、设置Redis数据集&lt;/p&gt;
&lt;p&gt; 主要设置如下参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis键：这是Redis数据库中列表（有序数据）或集（无序数据）的名称，根据上面的数据填充，我们输入“&lt;em&gt;&lt;em&gt;test&lt;/em&gt;demo&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;”。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;变量名称：这些是由数据集导出到测试元素的变量的名称。&lt;/li&gt;
&lt;li&gt;分隔符：这是存储在Redis列表或集合中的行中使用的分隔符。我们使用了逗号（'，'），所以我们将其保留为默认值。&lt;/li&gt;
&lt;li&gt;Redis服务器主机：Redis服务器的IP或域。我们应该输入'localhost'，因为我们在本地运行Redis服务器。&lt;/li&gt;
&lt;li&gt;Redis服务器端口：您的Redis服务器端口。我们把它作为默认值。&lt;/li&gt;
&lt;li&gt;密码：如果您拥有受密码保护的Redis服务器，则为密码。我们把它作为默认值。&lt;/li&gt;
&lt;li&gt;数据库：数据库名称。我们把它作为默认值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1359601/201902/1359601-20190226152855411-33674404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;保留其他参数的默认值。&lt;/p&gt;
&lt;p&gt;4、添加搜索航班的HTTP请求。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;线程组 - &amp;gt;添加 - &amp;gt;采样器 - &amp;gt; HTTP请求&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;正常填写http请求的数据（可以用各种查列车或机票的查询网站测试一下），departure和destination是从Redis数据库中获取的变量，用${departure}和${destination}调用对应变量数据。&lt;/p&gt;

&lt;p&gt;调用成功就说明Jmeter连接Redis数据库成功了。&lt;/p&gt;

&lt;p&gt;总的来说就是获取Redis对应列表的数据，然后设置变量名，在jmeter里调用。&lt;/p&gt;
&lt;p&gt;我自己研究学习这个的最初目的是测试登录或充值密码之类的接口时，需要获取到短信内容。&lt;/p&gt;
&lt;p&gt;学习到的还很浅薄，不足之处，敬请指正。非常感谢~~&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 07:38:00 +0000</pubDate>
<dc:creator>倾听起风</dc:creator>
<og:description>Redis（REmote DIctionary Server）是一个开源的内存数据结构存储，用作数据库，缓存和消息代理。 本博文是分享jmeter怎么连接使用Redis数据库。 安装Redis数据集J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zocymo/p/10437760.html</dc:identifier>
</item>
<item>
<title>.NET Core + Ocelot + IdentityServer4 + Consul 基础架构实现 - Zhang_Xiang</title>
<link>http://www.cnblogs.com/Zhang-Xiang/p/10437488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zhang-Xiang/p/10437488.html</guid>
<description>&lt;h4 id=&quot;先决条件&quot;&gt;先决条件&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;关于 Ocelot
&lt;ul&gt;&lt;li&gt;针对使用 .NET 开发微服务架构或者面向服务架构提供一个统一访问系统的组件。 &lt;a href=&quot;http://threemammals.com/ocelot&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文将使用 Ocelot 构建统一入口的 Gateway。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于 IdentityServer4
&lt;ul&gt;&lt;li&gt;IdentityServer4 是一个 OpenID Connect 和 OAuth 2.0 框架用于 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.2&quot;&gt;ASP.NET Core&lt;/a&gt; 。IdentityServer4 在你的应用程序中集成了基于令牌认证、单点登录、API访问控制所需的所有协议和扩展点。&lt;a href=&quot;http://docs.identityserver.io/en/latest/&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文将使用 IdentityServer4 搭建独立认证服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于 Consul
&lt;ul&gt;&lt;li&gt;Consul 是一个服务网格解决方案，通过服务发现、配置、功能分割提供一个全功能的控制层。这些功能可以单独使用，也可以同时使用以形成一个完整的网格服务。&lt;a href=&quot;https://www.consul.io/intro/index.html&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文将使用 Consul 注册多个服务。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于 .Net Core
&lt;ul&gt;&lt;li&gt;将使用 WebApi 构建多个服务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;构建-identityserver-服务&quot;&gt;构建 IdentityServer 服务&lt;/h4&gt;
&lt;ol readability=&quot;16.540106951872&quot;&gt;&lt;li&gt;添加 ASP.Net Core Web 项目&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/IdentityServerCreate1.png&quot; height=&quot;400px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;添加空项目&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/IdentityServerCreate2.png&quot; height=&quot;400px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在程序包管理控制台中输入：Install-Package IdentityServer4.AspNetIdentity&lt;/li&gt;
&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;添加 Config.cs 文件，并添加内容如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; using System.Collections.Generic;
 using IdentityServer4.Models;
 using IdentityServer4.Test;

 namespace IdentityServer
 {
     public sealed class Config
     {
         public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources()
         {
             return new List&amp;lt;ApiResource&amp;gt;
             {
                 new ApiResource(&quot;ServiceA&quot;, &quot;ServiceA API&quot;),
                 new ApiResource(&quot;ServiceB&quot;, &quot;ServiceB API&quot;)
             };
         }

         public static IEnumerable&amp;lt;Client&amp;gt; GetClients()
         {
             return new List&amp;lt;Client&amp;gt;
             {
                 new Client
                 {
                     ClientId = &quot;ServiceAClient&quot;,
                     AllowedGrantTypes = GrantTypes.ResourceOwnerPassword,
                     ClientSecrets =
                     {
                         new Secret(&quot;ServiceAClient&quot;.Sha256())
                     },
                     AllowedScopes = new List&amp;lt;string&amp;gt; {&quot;ServiceA&quot;},
                     AccessTokenLifetime = 60 * 60 * 1
                 },
                 new Client
                 {
                     ClientId = &quot;ServiceBClient&quot;,
                     AllowedGrantTypes = GrantTypes.ResourceOwnerPassword,
                     ClientSecrets =
                     {
                         new Secret(&quot;ServiceBClient&quot;.Sha256())
                     },
                     AllowedScopes = new List&amp;lt;string&amp;gt; {&quot;ServiceB&quot;},
                     AccessTokenLifetime = 60 * 60 * 1
                 }
             };
         }

         public static List&amp;lt;TestUser&amp;gt; GetUsers()
         {
             return new List&amp;lt;TestUser&amp;gt;
             {
                 new TestUser
                 {
                     Username = &quot;test&quot;,
                     Password = &quot;123456&quot;,
                     SubjectId = &quot;1&quot;
                 }
             };
         }

         public static IEnumerable&amp;lt;IdentityResource&amp;gt; GetIdentityResources()
         {
             return new List&amp;lt;IdentityResource&amp;gt;();
         }
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里添加了两个 Client ，分别为 ServiceA、ServiceB ，因此接下来将构建这两个服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8.8247487437186&quot;&gt;
&lt;p&gt;删掉StartUp.cs文件，在Program.cs中添加内容如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; using Microsoft.AspNetCore;
 using Microsoft.AspNetCore.Builder;
 using Microsoft.AspNetCore.Hosting;
 using Microsoft.AspNetCore.Mvc;
 using Microsoft.Extensions.DependencyInjection;

 namespace IdentityServer
 {
     public class Program
     {
         public static void Main(string[] args)
         {
             CreateWebHostBuilder(args).Build().Run();
         }

         public static IWebHostBuilder CreateWebHostBuilder(string[] args)
         {
             return WebHost.CreateDefaultBuilder(args).ConfigureServices(services =&amp;gt;
             {
                 services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);

                 services.AddIdentityServer()
                     .AddDeveloperSigningCredential()
                     .AddInMemoryIdentityResources(Config.GetIdentityResources())
                     .AddInMemoryApiResources(Config.GetApiResources())
                     .AddInMemoryClients(Config.GetClients())
                     .AddTestUsers(Config.GetUsers());
             }).Configure(app =&amp;gt;
             {
                 app.UseIdentityServer();
             });
         }
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：AddDeveloperSigningCredential() 方法用于添加开发时使用的 &lt;a href=&quot;http://docs.identityserver.io/en/latest/topics/startup.html#key-material&quot;&gt;Key material&lt;/a&gt; ，生产环境中不要使用该方法。在 .NET Core 2.2 中新建的 Web 项目文件 csproj 中包含了如下内容：&lt;br/&gt;&lt;code&gt;csharp &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp2.2&amp;lt;/TargetFramework&amp;gt; &amp;lt;AspNetCoreHostingModel&amp;gt;InProcess&amp;lt;/AspNetCoreHostingModel&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&lt;/code&gt;&lt;br/&gt;这里更改&lt;br/&gt;&lt;code&gt;csharp &amp;lt;AspNetCoreHostingModel&amp;gt;InProcess&amp;lt;/AspNetCoreHostingModel&amp;gt;&lt;/code&gt;&lt;br/&gt;为或直接删除该行，这么做的原因是当值为 InProcess 时，读写 tempkey.rsa 将产生权限问题。关于 AspNetCoreHostingModel 可参考 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/aspnet-core-module?view=aspnetcore-2.2&quot;&gt;ASP.NET Core Module&lt;/a&gt; 。&lt;br/&gt;&lt;code&gt;csharp &amp;lt;AspNetCoreHostingModel&amp;gt;OutOfProcess&amp;lt;/AspNetCoreHostingModel&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.59558823529412&quot;&gt;
&lt;p&gt;F5 启动该服务，显示如下：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/IdentityServer404.png&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在浏览器中输入 &lt;a href=&quot;http://localhost:38033/.well-known/openid-configuration&quot; class=&quot;uri&quot;&gt;http://localhost:38033/.well-known/openid-configuration&lt;/a&gt; ，得到以下内容&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/IdentityServerWellKnown.png&quot; height=&quot;600px&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，一个包含两个服务认证的认证服务搭建完毕。&lt;/p&gt;
&lt;h4 id=&quot;构建-serviceaserviceb&quot;&gt;构建 ServiceA、ServiceB&lt;/h4&gt;
&lt;ol readability=&quot;15.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;添加 ASP.Net Core Web 项目，这里以 ServiceA 为例进行构建&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/CreateServiceA.png&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 ASP.Net Core API&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/CreateServiceAWebApi.png&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;在 StartUp.cs 中添加内容如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; using Microsoft.AspNetCore.Builder;
 using Microsoft.AspNetCore.Hosting;
 using Microsoft.AspNetCore.Mvc;
 using Microsoft.Extensions.Configuration;
 using Microsoft.Extensions.DependencyInjection;

 namespace ServiceA
 {
     public class Startup
     {
         public Startup(IConfiguration configuration)
         {
             Configuration = configuration;
         }

         public IConfiguration Configuration { get; }

         // This method gets called by the runtime. Use this method to add services to the container.
         public void ConfigureServices(IServiceCollection services)
         {
             services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);

             services.AddAuthentication(&quot;Bearer&quot;)
                 .AddJwtBearer(&quot;Bearer&quot;, options =&amp;gt;
                 {
                     options.Authority = &quot;http://127.0.0.1:8021&quot;;
                     options.RequireHttpsMetadata = false;
                     options.Audience = &quot;ServiceA&quot;;
                 });
         }

         // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
         public void Configure(IApplicationBuilder app, IHostingEnvironment env)
         {
             if (env.IsDevelopment())
             {
                 app.UseDeveloperExceptionPage();
             }
             app.UseAuthentication();
             app.UseMvc();
         }
     }
 }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;添加 SessionController 用于用户登录，内容如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; using System.ComponentModel.DataAnnotations;
 using System.Net.Http;
 using System.Threading.Tasks;
 using IdentityModel.Client;
 using Microsoft.AspNetCore.Mvc;

 namespace ServiceA.Controllers
 {
     [Route(&quot;api/[controller]&quot;)]
     [ApiController]
     public class SessionController : ControllerBase
     {
         public async Task&amp;lt;string&amp;gt; Login(UserRequestModel userRequestModel)
         {
             // discover endpoints from metadata
             var client = new HttpClient();
             DiscoveryResponse disco = await client.GetDiscoveryDocumentAsync(&quot;http://127.0.0.1:8021&quot;);
             if (disco.IsError)
             {
                 return &quot;认证服务器未启动&quot;;
             }
             TokenResponse tokenResponse = await client.RequestPasswordTokenAsync(new PasswordTokenRequest
             {
                 Address = disco.TokenEndpoint,
                 ClientId = &quot;ServiceAClient&quot;,
                 ClientSecret = &quot;ServiceAClient&quot;,
                 UserName = userRequestModel.Name,
                 Password = userRequestModel.Password
             });

             return tokenResponse.IsError ? tokenResponse.Error : tokenResponse.AccessToken;
         }
     }

     public class UserRequestModel
     {
         [Required(ErrorMessage = &quot;用户名称不可以为空&quot;)]
         public string Name { get; set; }

         [Required(ErrorMessage = &quot;用户密码不可以为空&quot;)]
         public string Password { get; set; }
     }
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;添加 HealthController 用于 Consul 进行服务健康检查，内容如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; using Microsoft.AspNetCore.Mvc;

 namespace ServiceA.Controllers
 {
     [Route(&quot;api/[controller]&quot;), ApiController]
     public class HealthController : ControllerBase
     {
         /// &amp;lt;summary&amp;gt;
         /// 健康检查
         /// &amp;lt;/summary&amp;gt;
         /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
         [HttpGet]
         public IActionResult Get()
         {
             return Ok();
         }
     }
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;更改 ValuesController.cs 内容如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; using System.Collections.Generic;
 using Microsoft.AspNetCore.Authorization;
 using Microsoft.AspNetCore.Mvc;

 namespace ServiceA.Controllers
 {
     [Authorize] //添加 Authorize Attribute 以使该控制器启用认证
     [Route(&quot;api/[controller]&quot;)]
     [ApiController]
     public class ValuesController : ControllerBase
     {
         // GET api/values
         [HttpGet]
         public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
         {
             return new[] { &quot;value1&quot;, &quot;value2&quot; };
         }
     }
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，以上基本完成了 ServiceA 的服务构建，但在实际应用中应做一些修改，例如：IdentityServer 地址应在 appsettings.json 中进行配置，不应把地址分散于项目中各处；认证服务启用最好在全局启用，以防止漏写等等。ServiceB 的内容与 ServiceA 大致相似，因此文章中将不再展示 ServiceB 的构建过程。&lt;/p&gt;
&lt;h4 id=&quot;gateway-构建&quot;&gt;Gateway 构建&lt;/h4&gt;
&lt;ol readability=&quot;17&quot;&gt;&lt;li&gt;
&lt;p&gt;添加ASP.Net Web&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/GatewayCreate1.png&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加空项目&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/GatewayCreate2.png&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;打开程序包管理器控制台输入命令：&lt;br/&gt;&lt;code&gt;csharp install-package Ocelot //添加 Ocelot&lt;/code&gt;&lt;br/&gt;&lt;code&gt;csharp install-package Ocelot.Provider.Consul // 添加 Consul 服务发现&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;24&quot;&gt;
&lt;p&gt;添加 ocelot.json 文件，内容如下&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt; {
 &quot;ReRoutes&quot;: [
     {
     &quot;DownstreamPathTemplate&quot;: &quot;/api/{everything}&quot;,
     &quot;DownstreamScheme&quot;: &quot;http&quot;,
     &quot;UpstreamPathTemplate&quot;: &quot;/ServiceA/{everything}&quot;,
     &quot;UpstreamHttpMethod&quot;: [ &quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot; ],
     &quot;ServiceName&quot;: &quot;ServiceA&quot;, //consul 服务中 ServiceA 的名称
     &quot;LoadBalancerOptions&quot;: {
         &quot;Type&quot;: &quot;LeastConnection&quot;
     }
     },
     {
     &quot;DownstreamPathTemplate&quot;: &quot;/api/{everything}&quot;,
     &quot;DownstreamScheme&quot;: &quot;http&quot;,
     &quot;UpstreamPathTemplate&quot;: &quot;/ServiceB/{everything}&quot;,
     &quot;UpstreamHttpMethod&quot;: [ &quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot; ],
     &quot;ServiceName&quot;: &quot;ServiceB&quot;, //consul 服务中 ServiceB 的名称
     &quot;LoadBalancerOptions&quot;: {
         &quot;Type&quot;: &quot;LeastConnection&quot;
     }
     }
 ],
 &quot;GlobalConfiguration&quot;: {
     &quot;ServiceDiscoveryProvider&quot;: {    // Consul 服务发现配置
     &quot;Host&quot;: &quot;localhost&quot;,    // Consul 地址
     &quot;Port&quot;: 8500,
     &quot;Type&quot;: &quot;Consul&quot;
     }
 }
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;删除 StartUp.cs 文件，在 Program.cs 文件中添加如下内容&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; using System.IO;
 using Microsoft.AspNetCore.Hosting;
 using Microsoft.Extensions.Configuration;
 using Ocelot.DependencyInjection;
 using Ocelot.Middleware;
 using Ocelot.Provider.Consul;

 namespace ApiGateway
 {
     public class Program
     {
         public static void Main(string[] args)
         {
             new WebHostBuilder()
                 .UseKestrel()
                 .UseContentRoot(Directory.GetCurrentDirectory())
                 .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
                 {
                     config
                         .SetBasePath(hostingContext.HostingEnvironment.ContentRootPath)
                         .AddJsonFile(&quot;appsettings.json&quot;, true, true)
                         .AddJsonFile($&quot;appsettings.{hostingContext.HostingEnvironment.EnvironmentName}.json&quot;, true, true)
                         .AddJsonFile(&quot;ocelot.json&quot;)
                         .AddEnvironmentVariables();
                 })
                 .ConfigureServices(services =&amp;gt;
                 {
                     services.AddOcelot().AddConsul();
                 })
                 .ConfigureLogging((hostingContext, logging) =&amp;gt;
                 {
                     //add your logging
                 })
                 .UseIISIntegration()
                 .Configure(app =&amp;gt;
                 {
                     app.UseOcelot().Wait();
                 })
                 .Build()
                 .Run();
         }
     }
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：打开 Gateway.csproj 文件，更改&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.2&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;AspNetCoreHostingModel&amp;gt;InProcess&amp;lt;/AspNetCoreHostingModel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.2&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;AspNetCoreHostingModel&amp;gt;OutOfProcess&amp;lt;/AspNetCoreHostingModel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，一个基础网关基本构建完成。&lt;/p&gt;
&lt;h4 id=&quot;构建-consul-服务&quot;&gt;构建 &lt;a href=&quot;https://www.consul.io/docs/index.html&quot;&gt;Consul&lt;/a&gt; 服务&lt;/h4&gt;
&lt;ol readability=&quot;11.410939691445&quot;&gt;&lt;li readability=&quot;-0.81818181818182&quot;&gt;
&lt;p&gt;使用 &lt;a href=&quot;https://chocolatey.org/&quot;&gt;Chocoletey&lt;/a&gt; 安装 Consul，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;choco install consul&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新建一个文件夹以保存 Consul 服务配置&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/ConsulConfi.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;在 consul.d 文件夹中添加配置文件，内容如下:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;    {
        &quot;services&quot;: [{
                &quot;ID&quot;: &quot;ServiceA&quot;,
                &quot;Name&quot;: &quot;ServiceA&quot;,
                &quot;Tags&quot;: [
                    &quot;ServiceAWebApi&quot;, &quot;Api&quot;
                ],
                &quot;Address&quot;: &quot;127.0.0.1&quot;,
                &quot;Port&quot;: 8010,
                &quot;Check&quot;: {
                    &quot;HTTP&quot;: &quot;http://127.0.0.1:8010/Api/health&quot;,
                    &quot;Interval&quot;: &quot;10s&quot;
                }
            }, {
                &quot;id&quot;: &quot;ServiceB&quot;,
                &quot;name&quot;: &quot;ServiceB&quot;,
                &quot;tags&quot;: [
                    &quot;ServiceBWebApi&quot;,&quot;Api&quot;
                ],
                &quot;Address&quot;: &quot;127.0.0.1&quot;,
                &quot;Port&quot;: 8011,
                &quot;Check&quot;: [{
                        &quot;HTTP&quot;: &quot;http://127.0.0.1:8011/Api/health&quot;,
                        &quot;Interval&quot;: &quot;10s&quot;
                    }
                ]
            }
        ]
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0.82142857142857&quot;&gt;
&lt;p&gt;启动 consul 服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;consul agent -dev -config-dir=./consul.d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后在浏览器中输入 &lt;a href=&quot;http://localhost:8500/ui/&quot; class=&quot;uri&quot;&gt;http://localhost:8500/ui/&lt;/a&gt; 以查看Consul服务&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/ConsulServices.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;postman-验证&quot;&gt;Postman 验证&lt;/h4&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;F5 启动 Gateway 项目，启动 Postman 发送请求到 ServiceA 获取 Token。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/GatewayGetToken.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 Token 请求 ServiceA Values 接口&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/GatewayRequestValues.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当尝试使用 ServiceA 获取到的 Token 去获取 ServiceB 的数据时，请求也如意料之中返回 401&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SoMeDay-Zhang/GatewayAuthentication/master/Documents/Images/GatewayRequestForbidden.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;至此，一个由 .NET Core、IdentityServer4、Ocelot、Consul实现的基础架构搭建完毕。&lt;a href=&quot;https://github.com/SoMeDay-Zhang/GatewayAuthentication&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 07:09:00 +0000</pubDate>
<dc:creator>Zhang_Xiang</dc:creator>
<og:description>先决条件 关于 Ocelot 针对使用 .NET 开发微服务架构或者面向服务架构提供一个统一访问系统的组件。 '参考' 本文将使用 Ocelot 构建统一入口的 Gateway。 关于 Identit</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Zhang-Xiang/p/10437488.html</dc:identifier>
</item>
<item>
<title>WebApiClient与Asp.net core DI的结合 - jiulang</title>
<link>http://www.cnblogs.com/kewei/p/10437350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kewei/p/10437350.html</guid>
<description>&lt;h2 id=&quot;webapiclient&quot;&gt;1 WebApiClient&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一款基于HttpClient封装，只需要定义c#接口并修饰相关特性，即可异步调用远程http接口的客户端库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;http接口的注册与提供&quot;&gt;2 Http接口的注册与提供&lt;/h2&gt;
&lt;h3 id=&quot;声明远程端http接口&quot;&gt;2.1 声明远程端http接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public interface IBaiduApi : IHttpApi
{
    [HttpGet(&quot;/s&quot;)]
    ITask&amp;lt;string&amp;gt; GetAsync(string word);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;远程端http的注册&quot;&gt;2.2 远程端http的注册&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用HttpClientFactory管理HttpClient的创建，利用AddTypedClient创建远程http接口的WebApiClient调用代理，同时给HttpApiConfig配置ServiceProvider实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
{
    services.AddHttpApiTypedClient&amp;lt;IBaiduApi&amp;gt;().ConfigureHttpApiConfig((c, p) =&amp;gt;
    {
        c.HttpHost = new Uri(&quot;http://www.baidu.com/&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 添加HttpApiClient的别名HttpClient
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;TInterface&quot;&amp;gt;接口类型&amp;lt;/typeparam&amp;gt;
/// &amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;configOptions&quot;&amp;gt;配置选项&amp;lt;/param&amp;gt;
/// &amp;lt;exception cref=&quot;ArgumentNullException&quot;&amp;gt;&amp;lt;/exception&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static IHttpClientBuilder AddHttpApiTypedClient&amp;lt;TInterface&amp;gt;(this IServiceCollection services, Action&amp;lt;HttpApiConfig, IServiceProvider&amp;gt; configOptions)
    where TInterface : class, IHttpApi
{
    if (configOptions == null)
    {
        throw new ArgumentNullException(nameof(configOptions));
    }

    return services
        .AddHttpClient&amp;lt;TInterface&amp;gt;()
        .AddTypedClient((httpClient, provider) =&amp;gt;
        {
            var httpApiConfig = new HttpApiConfig(httpClient)
            {
                ServiceProvider = provider
            };
            configOptions.Invoke(httpApiConfig, provider);
            return HttpApiClient.Create&amp;lt;TInterface&amp;gt;(httpApiConfig);
        });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;远程端http接口的提供&quot;&gt;2.3 远程端http接口的提供&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以使用构造器注入IBaiduApi或[FromServices]特性得到远程接口代理实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;public class HomeController : Controller
{   
    // GET: /&amp;lt;controller&amp;gt;/
    public async Task&amp;lt;IActionResult&amp;gt; Index([FromServices] IBaiduApi baiduApi)
    {
        var html = await baiduApi.GetAsync(&quot;WebApiClient&quot;);
        return Content(html);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;webapiclient过滤器的服务提供&quot;&gt;3 WebApiClient过滤器的服务提供&lt;/h2&gt;
&lt;h3 id=&quot;在接口上使用自定义logfilter&quot;&gt;3.1 在接口上使用自定义LogFilter&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[LogFilter]
public interface IBaiduApi : IHttpApi
{
    [HttpGet(&quot;/s&quot;)]
    ITask&amp;lt;string&amp;gt; GetAsync(string word);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用context.getservice获取服务实例&quot;&gt;3.2 使用context.GetService获取服务实例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class LogFilter : ApiActionFilterAttribute
{
    public override Task OnBeginRequestAsync(ApiActionContext context)
    {
        var logger = context.GetService&amp;lt;ILoggerFactory&amp;gt;().CreateLogger(&quot;Baidu&quot;);
        logger.LogWarning($&quot;request {context.ApiActionDescriptor.Name} {context.RequestMessage.RequestUri}&quot;);

        return base.OnBeginRequestAsync(context);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;日志服务输出日志样例&quot;&gt;3.3 日志服务输出日志样例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;warn: Baidu[0]
      request GetAsync http://www.baidu.com/s?word=WebApiClient&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Feb 2019 06:54:00 +0000</pubDate>
<dc:creator>jiulang</dc:creator>
<og:description>1 WebApiClient 一款基于HttpClient封装，只需要定义c 接口并修饰相关特性，即可异步调用远程http接口的客户端库 'WebApiClient' 'WebApiClient.Ex</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kewei/p/10437350.html</dc:identifier>
</item>
<item>
<title>剑指 offer 第一题： 二维数组中的查找 - 五分钟学算法</title>
<link>http://www.cnblogs.com/fivestudy/p/10437229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fivestudy/p/10437229.html</guid>
<description>&lt;p&gt;打算写 &lt;strong&gt;图解剑指 offer 66 题&lt;/strong&gt; 的系列文章，不知道大家有没有兴趣 😶&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;题目分析&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;图 1&quot; src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0hi8konm9j319q0o2dfy.jpg&quot; alt=&quot;图 1&quot;/&gt;图 1&lt;/p&gt;
&lt;p&gt;如果没有头绪的话，很显然使用 &lt;strong&gt;暴力解法&lt;/strong&gt; 是完全可以解决该问题的。&lt;/p&gt;
&lt;p&gt;即遍历二维数组中的每一个元素，时间复杂度：O(n^2)。&lt;/p&gt;
&lt;p&gt;其实到这里我们就可以发现，使用这种暴力解法并没有充分利用题目给出的信息。这个二维数组是有特点的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一行都是&lt;strong&gt;递增&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;每一列都是&lt;strong&gt;递增&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;图 2&quot; src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0hihhh8noj316m0n6gls.jpg&quot; alt=&quot;图 2&quot;/&gt;图 2&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;解法&lt;/h3&gt;
&lt;h3 id=&quot;h-3&quot;&gt;解法一：二分法&lt;/h3&gt;
&lt;p&gt;对于有序数组的查找问题而言，&lt;strong&gt;二分法&lt;/strong&gt;是最容易想到的一个解法。&lt;/p&gt;
&lt;p&gt;在这里，对每一行使用二分查找，时间复杂度为 O(nlogn) 。二分查找复杂度 O(logn)，一共 n 行，所以是总体的时间复杂度是 O(nlogn) 。&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;解法二：规律法&lt;/h3&gt;
&lt;p&gt;根据二维数组由上到下，由左到右递增的规律。&lt;/p&gt;
&lt;p&gt;从左下角开始遍历，如果当前值比 target 小则往右找，如果比 target 大则往上找，如果存在，必然可以找到目标数字。&lt;/p&gt;
&lt;p&gt;即选取右上角或者左下角的元素 a[row] [col] 与 target 进行比较， 当 target 小于元素 a[row] [col] 时，那么 target 必定在元素 a 所在行的左边,让 col-- ；当 target 大于元素 a[row] [col] 时，那么 target 必定在元素 a 所在列的下边,让 row++ ；&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 3&quot; src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0iwoz8lo3j31ks0tkdi2.jpg&quot; alt=&quot;图 3&quot;/&gt;图 3&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Solution {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;Find&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int target, &lt;span class=&quot;hljs-keyword&quot;&gt;int [][] array) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int row = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int col = array[&lt;span class=&quot;hljs-number&quot;&gt;0].length - &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while(row &amp;lt;= array.length - &lt;span class=&quot;hljs-number&quot;&gt;1 &amp;amp;&amp;amp; col &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;0){&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if(target == array[row][col])&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if(target &amp;gt; array[row][col])&lt;br/&gt;row++ ;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;br/&gt;col-- ;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-5&quot;&gt;解法三：二分规律法&lt;/h3&gt;
&lt;p&gt;将解法一和解法二进行结合：&lt;strong&gt;对每行每列都使用二分查找，此时的时间复杂度为 O(logn * logm)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 4&quot; src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0hmqw5c1hj31i90u0ab4.jpg&quot; alt=&quot;图 4&quot;/&gt;图 4&lt;/p&gt;
&lt;p&gt;比如查找数字 9，首先使用用二分查找选出一行，总共有 5 行，那么&lt;code&gt;( 0 + 5 ) / 2 = 2&lt;/code&gt;，所以我们找出了第 2 行为基准行。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 5&quot; src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0hmr8bfohj31ic0u0gmo.jpg&quot; alt=&quot;图 5&quot;/&gt;图 5&lt;/p&gt;
&lt;p&gt;接下来对这一行（即第 2 行）又使用二分查找， 找出这一行（即第 2 行）中最后一个比目标值小的值，这里是 6。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 6&quot; src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1g0hmrhdlrlj31he0u075d.jpg&quot; alt=&quot;图 6&quot;/&gt;图 6&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt; 及其所在的行和列把这个矩形划分为 &lt;strong&gt;4&lt;/strong&gt; 部分：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 7&quot; src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0hmro8i1ej31hz0u0dh2.jpg&quot; alt=&quot;图 7&quot;/&gt;图 7&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;左上部分（图 7 灰色部分）&lt;/strong&gt;，包括所在行的左边部分和所在列的上边部分：这一部分是绝对不会有目标数字的。因为这部分数字肯定比 6 小，而 6 又是小于目标数字的，所以左上部分全部小于目标数字。也就是说这个区域的数字不需要再进行判断了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右下部分（图 7 绿色部分）&lt;/strong&gt;，包括所在行的右边部分，但不包括所在列的下面部分， 这一部分也是绝对不会有目标数字的。因为这部分都比 6 右边的数字 11 大，而 11 又比目标数字 9 更大，所以右下部分全部都比目标数字大。也就是说这个区域的数字也不需要再进行判断了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左下部分（图 7 蓝色部分）&lt;/strong&gt;，可能含有目标数字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右上部分（图 7 棕色部分）&lt;/strong&gt;，可能含有目标数字。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样，实际上筛选的区域就只剩下&lt;strong&gt;左下部分（图 7 蓝色部分）&lt;/strong&gt; 和 &lt;strong&gt;右上部分（图 7 棕色部分）&lt;/strong&gt;这两块区域了，相比于解法二而言，使用这种解法&lt;strong&gt;平均情况下每一次查找，都可以把行和列的长度减少一半&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Solution {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;Find&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int target, &lt;span class=&quot;hljs-keyword&quot;&gt;int [][] array) {&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感兴趣的话可以看看我之前写的一个项目 &lt;a href=&quot;https://github.com/MisterBooo/LeetCodeAnimation&quot;&gt;LeetCodeAnimation&lt;/a&gt;,目前有 13000 star。&lt;br/&gt;原文首发于公号「五分钟学算法」链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;amp;mid=2247484783&amp;amp;idx=2&amp;amp;sn=475615f9be34e65319b7f12fa5893010&amp;amp;chksm=fa0e6aeecd79e3f8c78e092feeda4908459326329e31f8457c1d33ea13794c97165a2405056b&amp;amp;token=1226269352&amp;amp;lang=zh_CN#rd&quot;&gt;剑指 offer 第一题： 二维数组中的查找&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 06:41:00 +0000</pubDate>
<dc:creator>五分钟学算法</dc:creator>
<og:description>打算写 图解剑指 offer 66 题 的系列文章，不知道大家有没有兴趣 😶 题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fivestudy/p/10437229.html</dc:identifier>
</item>
<item>
<title>Scrapy爬虫错误日志汇总 - BoomOoO</title>
<link>http://www.cnblogs.com/beiyi888/p/10437232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/beiyi888/p/10437232.html</guid>
<description>&lt;p&gt;&lt;span&gt;1、数组越界问题(list index out of range)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1460324/201902/1460324-20190226142217475-101357778.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：第1种可能情况：list[index]index超出范围,也就是常说的数组越界。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　第2种可能情况：list是一个空的， 没有一个元素，进行list[0]就会出现该错误，这在爬虫问题中很常见，比如有个列表爬下来为空，统一处理就会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决办法：从你的网页内容解析提取的代码块中找找看啦（人家比较习惯xpath + 正则），加油 ~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、http状态代码没有被处理或允许(http status code is not handled or not allowed)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1460324/201902/1460324-20190226142906112-1717998392.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：就是你的http状态码没有被识别，需要在settings.py中添加这个状态码信息，相当于C语言中的＃define预处理宏定义命令吧（我这么理解）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决办法：在你的setting.py中，添加这么一句短小精悍的话就OK了，紧接着就等着高潮吧您呐：HTTPERROR_ALLOWED_CODES = [403]&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;此篇文章持续更新，未完待续....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎大家留下自己的问题，互相讨论，互相学习，互相总结，，，，&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Feb 2019 06:41:00 +0000</pubDate>
<dc:creator>BoomOoO</dc:creator>
<og:description>1、数组越界问题(list index out of range) 原因：第1种可能情况：list[index]index超出范围,也就是常说的数组越界。 第2种可能情况：list是一个空的， 没有一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/beiyi888/p/10437232.html</dc:identifier>
</item>
<item>
<title>C#  特性（attribute） - 阡陌染</title>
<link>http://www.cnblogs.com/forever-Ys/p/10428568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/forever-Ys/p/10428568.html</guid>
<description>&lt;p&gt;一、什么是特性&lt;/p&gt;
&lt;p&gt;　　特性是一种允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2008/z0w1kczw(v%3dvs.90)&quot; target=&quot;_blank&quot;&gt;MSDN&lt;/a&gt;中对它的解释是：特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联。特性与程序实体关联后，即可在运行时使用名为“反射”的技术查询属性。&lt;/p&gt;
&lt;p&gt;　　（有关元数据和反射的知识，点击查看 &lt;a href=&quot;https://www.cnblogs.com/forever-Ys/p/10396906.html&quot; target=&quot;_blank&quot;&gt;C# 反射&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;二、使用特性&lt;/p&gt;
&lt;p&gt;　　特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集，它可以放置在几乎所有的声明中（但特定的属性可能限制在其上有效的声明类型）。其语法为：&lt;/p&gt;
&lt;p&gt;　　● 在结构前放置特性片段来运用特性&lt;/p&gt;
&lt;p&gt;　　● 特性片段被方括号包围，其中是特性名和特性的参数列表&lt;/p&gt;
&lt;p&gt;　　例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
　　[Serializable]    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不含参数的特性&lt;/span&gt;
    public &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass
    {...}

   [MyAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;firt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;带有参数的特性&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　public &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass {...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　注： 大多数特性只针对直接跟随在一个或多个特性片段后的结构&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　单个结构可以运用多个特性，使用时可以把独立的特性片段互相叠在一起或使用分成单个特性片段，特性之间用逗号分隔&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;span&gt;[Serializable]  
[MyAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;firt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;独立的特性片段&lt;/span&gt;
...&lt;p&gt;&lt;span&gt;
[MyAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;firt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Serializable]    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;逗号分隔&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　某些属性对于给定实体可以指定多次。例如，&lt;a href=&quot;https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2008/4xssyw96%28v%3dvs.90%29&quot; data-linktype=&quot;relative-path&quot;&gt;Conditional&lt;/a&gt; 就是一个可多次使用的属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[Conditional(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Conditional(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; TraceMethod()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　 特性的目标是应用该特性的实体。例如，特性可以应用于类、特定方法或整个程序集。默认情况下，特性应用于它后面的元素。但是，您也可以显式标识要将特性应用于方法还是它的参数或返回值。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;C#中标准特性目标名称&lt;/td&gt;
&lt;td&gt;适用对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;assembly&lt;/td&gt;
&lt;td&gt;整个程序集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;module&lt;/td&gt;
&lt;td&gt;当前程序集模块(不同于Visual Basic 模块)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;field&lt;/td&gt;
&lt;td&gt;在类或结构中的字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;event&lt;/td&gt;
&lt;td&gt;Event&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;method&lt;/td&gt;
&lt;td&gt;方法或get和set属性访问器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;param&lt;/td&gt;
&lt;td&gt;方法参数或set属性访问器的参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;property&lt;/td&gt;
&lt;td&gt;Property&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;return&lt;/td&gt;
&lt;td&gt;方法、属性索引器或get属性访问器的返回值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;结构、类、接口、枚举或委托&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;typevar&lt;/td&gt;
&lt;td&gt;指定使用泛型结构的类型参数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;三、自定义特性&lt;/p&gt;
&lt;p&gt;　　特性的用法虽然很特殊，但它只是某个特殊类型的类。&lt;/p&gt;

&lt;p&gt;　　3.1 声明自定义的特性&lt;/p&gt;
&lt;p&gt;　　　　总体上声明特性和声明其他类是一样的，只是所有的特性都派生自System.Attribute。&lt;span&gt;根据惯例，特性名使用Pascal命名法并且以Attribute后缀结尾，当为目标应用特性时，我们可以不使用后缀。&lt;/span&gt;如：对于SerializableAttribute&lt;/p&gt;
&lt;p&gt;和MyAttributeAttribute这两个特性，我们在把它应用到结构的时候可以使用[Serializable和MyAttribute短名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAttributeAttribute : System.Attribute
{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　当然它也有构造函数。和其他类一样，每个特性至少有一个公共构造函数，如果你不声明构造函数，编译器会产生一个隐式、公共且无参的构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAttributeAttribute : System.Attribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Description;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ver;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Reviwer;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyAttributeAttribute(&lt;span&gt;string&lt;/span&gt; desc,&lt;span&gt;string&lt;/span&gt; ver,&lt;span&gt;string&lt;/span&gt; Rev)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
&lt;span&gt;        {
            Description &lt;/span&gt;=&lt;span&gt; desc;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ver =&lt;span&gt; ver;
            Reviwer &lt;/span&gt;=&lt;span&gt; Rev;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.2  限制特性的使用&lt;/p&gt;
&lt;p&gt;　　前面我们已经知道，可以在类上面运用特性，而特性本身就是类，&lt;span&gt;有一个很重要的预定义特性AttributeUsage可以运用到自定义特性上，我们可以用它来限制特性使用在某个目标类型上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下面的例子使自定义的特性只能应用到方法和类上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class |&lt;span&gt; AttributeTargets.Method)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAttributeAttribute : System.Attribute
    {...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　简单解读一下AttributeUsage特性，它有三个重要的公共属性，如下表&lt;/p&gt;
&lt;table border=&quot;2&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td&gt;名字&lt;/td&gt;
&lt;td&gt;意义&lt;/td&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;ValidOn&lt;/td&gt;
&lt;td&gt;指定特性允许的目标类型。构造函数的第一个参数必须是AttributeTarget类型的枚举值&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Inherited&lt;/td&gt;
&lt;td&gt;布尔值，指示特性能否被派生类和重写成员继承&lt;/td&gt;
&lt;td&gt; true&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AllowMultiple&lt;/td&gt;
&lt;td&gt;布尔值，指示特性能否被重复放置在同一个程序实体前多次&lt;/td&gt;
&lt;td&gt; false&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　在vs中按f12查阅定义我们可以看到，AttributeTarget枚举的成员有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1544400/201902/1544400-20190225174137560-503937608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看一个小例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须的,指示MyAttribute只能应用到类和方法上&lt;/span&gt;
        Inherited = &lt;span&gt;false&lt;/span&gt;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可选，表明不能被派生类继承&lt;/span&gt;
        AllowMultiple = &lt;span&gt;false&lt;/span&gt;)]   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可选，表明不能有MyAttribute的多个实例应用到同一个目标上&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAttributeAttribute : System.Attribute
    {...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.3访问特性&lt;/p&gt;
&lt;p&gt;　　定义好特性了，怎么进行访问呢？&lt;span&gt;对于自定义的特性，我们可以用Type中的IsDefined和GetCustomAttributes方法来获取&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　3.3.1 使用IsDefined方法&lt;/p&gt;
&lt;p&gt;　　public abstract bool IsDefined(Type attributeType, bool inherit)，它是用来检测某个特性是否应用到了某个类上&lt;/p&gt;
&lt;p&gt;　　参数说明：    attributeType : 要搜索的自定义特性的类型。 搜索范围包括派生的类型。&lt;/p&gt;
&lt;p&gt;　　　　　　　　inherit：true 搜索此成员继承链，以查找这些属性;否则为 false。 属性和事件，则忽略此参数&lt;/p&gt;
&lt;p&gt;　　　　　　　　返回结果： true 如果一个或多个实例 attributeType 或其派生任何的类型为应用于此成员; 否则为 false。&lt;/p&gt;
&lt;p&gt; 　　下面代码片段是用来检查MyAttribute特性是否被运用到MyClass类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MyClass mc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyClass();
Type t &lt;/span&gt;=&lt;span&gt; mc.GetType();
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; def = t.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(MyAttributeAttribute),&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (def)
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyAttribute is defined!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　3.3.2 使用GetCustomAttributes方法&lt;/p&gt;
&lt;p&gt; 　　public abstract object[] GetCustomAttributes(bool inherit)，调用它后，会创建每一个与目标相关联的特性的实例&lt;/p&gt;
&lt;p&gt;　　参数说明： inherit： true 搜索此成员继承链，以查找这些属性;否则为 false&lt;/p&gt;
&lt;p&gt;　　　　　　　 返回结果：返回所有应用于此成员的自定义特性的数组,因此我们必须将它强制转换为相应的特性类型&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义特性&lt;/span&gt;
&lt;span&gt;
[AttributeUsage(AttributeTargets.Class &lt;/span&gt;|&lt;span&gt; AttributeTargets.Method)] 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAttributeAttribute : System.Attribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Description;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ver;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Reviwer;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyAttributeAttribute(&lt;span&gt;string&lt;/span&gt; desc,&lt;span&gt;string&lt;/span&gt; ver,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; Rev)
        {
            Description &lt;/span&gt;=&lt;span&gt; desc;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ver =&lt;span&gt; ver;
            Reviwer &lt;/span&gt;=&lt;span&gt; Rev;
        }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义类&lt;/span&gt;
[MyAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;firt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass
    {

    }

 &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            MyClass mc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyClass();
            Type t &lt;/span&gt;=&lt;span&gt; mc.GetType();
            Object[] obj &lt;/span&gt;= t.GetCustomAttributes(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(Attribute a &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj)
            {
                MyAttributeAttribute attr &lt;/span&gt;= a &lt;span&gt;as&lt;/span&gt;&lt;span&gt; MyAttributeAttribute;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(attr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Description : {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, attr.Description);
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ver : {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, attr.ver);
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;review: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, attr.Reviwer);
                }
            }
        }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1544400/201902/1544400-20190225182243441-1416562881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;四、预定义的特性&lt;/p&gt;
&lt;p&gt;　　4.1 Obsolete特性&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Obsolete特性将public ObsoleteAttribute()程序结构标注为过期的，并且在代码编译时显式有用的警告信息&lt;/span&gt;，它有三种重载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　public ObsoleteAttribute()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;public ObsoleteAttribute(string message)　　参数说明： message：描述了可选的变通方法文本字符串。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　public ObsoleteAttribute(string message, bool error)　　参数说明：message：描述了可选的变通方法文本字符串。　　error：true 如果使用过时的元素将生成编译器错误; false 如果使用它将生成编译器警告。&lt;/p&gt;
&lt;p&gt;　　举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.CompilerServices;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 特性
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        [Obsolete(&quot;Use method SuperPrintOut&quot;)]
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Print(&lt;span&gt;string&lt;/span&gt; str,[CallerFilePath] &lt;span&gt;string&lt;/span&gt; filePath = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            Console.WriteLine(str);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filePath {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, filePath);
        }


        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no path&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nothing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,path);
            Console.ReadKey();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行没有问题，不过出现了警告：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1544400/201902/1544400-20190226125948984-2103690935.png&quot; alt=&quot;&quot; width=&quot;847&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果将 [Obsolete(&quot;Use method SuperPrintOut&quot;)]  改成[Obsolete(&quot;Use method SuperPrintOut&quot;，true)] 的话，编译则会出现错误信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1544400/201902/1544400-20190226130204784-352564573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　4.2 Conditional 特性&lt;/p&gt;
&lt;p&gt;　　public ConditionalAttribute(string conditionString)，指示编译器，&lt;span&gt;如果定义了conditionString编译符号，就和普通方法没有区别，否则忽略代码中方法这个方法的所有调用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; fun    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义编译符号&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.CompilerServices;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 特性
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        [Conditional(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Fun(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
        {
            Console.WriteLine(str);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Fun(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于定义了fun，所以Fun函数会被调用，如果没有定义，这忽略Fun函数的调用&lt;/p&gt;

&lt;p&gt;　　4.3 调用者信息特性&lt;/p&gt;
&lt;p&gt;　　调用者信息特性可以访问文件路径、代码行数、调用成员的名称等源代码信息，这三个特性的名称分别为CallerFilePath、CallerLineNumber和CallerMemberName，这些方法只能用于方法中的可选参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.CompilerServices;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 特性
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Print(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str,
            [CallerFilePath] &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; filePath = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
            [CallerLineNumber] &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
            [CallerMemberName] &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; name = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            Console.WriteLine(str);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filePath {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, filePath);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Line {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, num);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Call from {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, name);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nothing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1544400/201902/1544400-20190226135405292-538480463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



</description>
<pubDate>Tue, 26 Feb 2019 06:07:00 +0000</pubDate>
<dc:creator>阡陌染</dc:creator>
<og:description>一、什么是特性 特性是一种允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。 MSDN中对它的解释是：特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/forever-Ys/p/10428568.html</dc:identifier>
</item>
<item>
<title>给即将或刚进入it行业的朋友的参考--体育生转行到Java的经历 - 回首青年</title>
<link>http://www.cnblogs.com/sunzan/p/10436914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunzan/p/10436914.html</guid>
<description>&lt;p&gt;&lt;span&gt;首先声明，不喜勿喷我这个历经千辛万苦转入&lt;/span&gt;Java&lt;span&gt;行业的人。相信很多正在学校中迷茫和在毕业后对于现状不满意的朋友通过各种的渠道进行信息汇总，了解了软件行业的高工资和多机会，正摩拳擦掌准备在这个领域大干一场，我以自己的亲身经历，给大家做一些参考和我个人觉得对的建议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、转行需要很大的毅力与决心，可能第一步不太顺利。但是，如果认定了，就应该勇敢的迈出第一步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;我是通过培训转行到&lt;/span&gt;Java&lt;span&gt;的。我大学学的是体育专业，乒乓球项。当时大学的时候很迷茫，每天除了打球不知道做什么对未来有意义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/791257/201902/791257-20190226140256992-1400486897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（当时参加省里比赛的照片）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大学时间很快，&lt;/span&gt;2011&lt;span&gt;年毕业，开始要找工作了，想了很多办法，然而并不顺利，最坑的是去某会所当招聘专员，去聊才发现居然是要我当龟公，找一个妹子来有多少提成。转机是在一次上网打&lt;/span&gt;&lt;span&gt;CF&lt;/span&gt;&lt;span&gt;的时候，休息时间打开了&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;&lt;span&gt;同城，发现很多招聘信息写招聘&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;实习生，无任何要求，&lt;/span&gt;&lt;span&gt;3000-5000&lt;/span&gt;&lt;span&gt;一月，好吧，我心动了。然后我就在百度上搜索&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;，果然工资高，前景好。然后投了一份简历，记得到了当天下午，他们人事给我打了个电话，说明天上午&lt;/span&gt;&lt;span&gt;xx&lt;/span&gt;&lt;span&gt;时间面试。到了第二天，我一早就赶了过去，当时是夏天，很热。人事妹子很漂亮，衣服穿得上面口子大，下面短，裙子很可爱，全程聊的时候我机械式回答，不记得讲了些什么了，一直盯着她看。只记得最后一句明天开始上班。所谓实习生其实就是招培训生。然后就迷迷糊糊的签了个贷款协议，学六个月，学完之后开始还。当时老师上课，很蛋疼，完全不知道讲什么，那时候我以为是自己理解能力有限，学不懂。毕业后和同学聊才知道大家都不知道他讲什么，我可能比较惨，进的那家培训公司老师确实比较差&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;但是我也不怪他们，如果不是他们我可能也进不了这个行业。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/791257/201902/791257-20190226140313744-1651237008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当时在培训的某天去拓展&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、不要在最难的时候放弃自己&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;当时找工作的时候，我一家一家投，一去人家就问你些技术问题或者一张技术试卷，基本回答不出来。当时面试了三个月一两百家吧。很灰心，一个偶然的机会，认识了我第一个老板，某大学教授出来创业，当时去面试的时候是一个装修都没搞好的民房，老板当时完全没和我聊技术，只谈未来，当时急切的找工作的我看到了工作机会，一口答应了所有要求，计那时候找不到人，所以要了我，当时他给的工资是&lt;/span&gt;1600&lt;span&gt;一个月，估然后开始了我的第一份工作，那时候什么都不懂，又只有我一个人java模块，压力很大，在群里问问题人家基本除了吹牛教育你，很少有人指点你，只要也是自己当时不会好好聊天。每天就靠着百度搜代码粘上去就用，就是搜到代码自己也不知道用，最后没办法边百度边看视频学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/791257/201902/791257-20190226140334219-564402064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第一家公司工作，其实老板人很好，那时候三个月左右把我的工资从1600涨到了4500，大大减轻了我当时还贷款的压力，没找到工作之前都是通过信用卡套出来还的，只是由于项目烂，最后公司倒闭了，可惜了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、在学习上面，一定要舍得投资自己&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二家去了贷款公司搞他们的贷款平台。这个经历只有七天，却点醒了我，当时的老大把我叫到办公室，说我的基础实在太差了，什么都要百度，不太适合他们公司的需要，软性的把我辞退了。离职在家这段时间，买了很多书，不断的学习充电。一次偶然的机会，花了万多块钱在某线上平台报名了直播课程，我觉得比培训学校好，基础就是那时候打起来的（那个公司好像没看到过动静了）。在边啃书边看直播边自己写案例几个月坚持后，终于进来某一线互联网公司。在此感谢老王（不是隔壁的）当年在项目上和技术上的不吝赐教，让我受益匪浅。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、脚步不要停，拼命的向前跑，风雨之后也能见彩虹&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从那家公司出来以后我就和一个做水系统的老板合作开了家软件公司，主要是研发水系统电商平台，开始了自己的创业之旅，一路艰辛前行，向前奔跑，在去年另外一个这个行业的大佬融了&lt;/span&gt;2000w&lt;span&gt;进来，现在慢慢的公司终于走向了正规。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/791257/201902/791257-20190226140529462-717631782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后谈下我的学习方式给大家参考下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一：基础很重要，要打扎实，不断的学习，千万不要停止学习，比如书籍，视频，直播等途径都可以。多逛各种社区学习下别人的经验，如博客园等&lt;/span&gt;...&lt;span&gt;不要什么都直接百度（别人会觉得你水平很差），要有自己的想法，然后在帖子里面和别人讨论去验证。这行淘汰率高，但是淘汰的都是不向前走了的人，但是如果你真的在努力充实自己，你干到&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;岁都行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二：尝试看下源码，不管有多难，边抱着书边看，慢慢的啃。&lt;/p&gt;
&lt;p&gt;第三：明确自己的学习路线，多像可靠的并在这一行混的还可以的朋友学习请教。&lt;/p&gt;
&lt;p&gt;就讲到这里吧，后续我想系统整理自己这些年的技术所得跟职业感想大家分享，希望对大家有点帮助。&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 06:06:00 +0000</pubDate>
<dc:creator>回首青年</dc:creator>
<og:description>首先声明，不喜勿喷我这个历经千辛万苦转入Java行业的人。相信很多正在学校中迷茫和在毕业后对于现状不满意的朋友通过各种的渠道进行信息汇总，了解了软件行业的高工资和多机会，正摩拳擦掌准备在这个领域大干一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunzan/p/10436914.html</dc:identifier>
</item>
</channel>
</rss>