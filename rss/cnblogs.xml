<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[ASP.NET Core 3框架揭秘] 跨平台开发体验: Mac OS - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html</guid>
<description>&lt;p&gt;除了微软自家的Windows平台， .NET Core针对Mac OS以及各种Linux Distribution（RHEL、Ubuntu、Debian、Fedora、CentOS和SUSE等）都提供了很好的支持。我们先来体验一下使用Mac来开发.NET Core应用，在这之前我们照例先得在Mac OS上构建我们的开发环境。&lt;/p&gt;

&lt;p&gt;和Windows一样，如果我们希望在Mac上进行.NET Core应用的开发，我们只需要安装 .NET Core SDK和相应的IDE就可以了。 .NET Core SDK可以直接从&lt;a href=&quot;https://www.microsoft.com/net/core#macos&quot;&gt;微软官方站点&lt;/a&gt;下载，安装之后我们将拥有.NET Core针对Mac OS的运行时和相应工具，其中包含在前面频繁使用的命令行工具 &lt;strong&gt;dotnet&lt;/strong&gt;。顺便说一下，虽然老版本的Mac OS（比如10.12 Sierra）可以安装.NET Core 3.0 SDK，但是只有在&lt;strong&gt;10.13 High Sierra&lt;/strong&gt;或者更高版本的Mac OS才能编译和运行.NET Core 3.0应用程序。&lt;/p&gt;
&lt;p&gt;对于Mac OS X的.NET Core应用的开发人员来说，他们在IDE上同样具有广泛的选择。首先，&lt;strong&gt;Visual Studio&lt;/strong&gt;目前已经推出了Mac版本，虽然和Windows版本在功能和稳定性上还有一定的差距，但是对于习惯了Visual Studio的Mac用户来说算是最好的选择。除此之外，我们可以选择免费的&lt;strong&gt;Visual Studio Code&lt;/strong&gt;，如果不太喜欢这种风格的IDE，还可以选择JetBrains的&lt;strong&gt;Rider&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对于Windows和Mac用户来说，针对他们的开发体验基本上是一致的，因为.NET Core SDK提供的命令行（主要是dotnet这个命令行工具）在各个平台具有一致性的定义，在IDE（Visual Studio和Visual Studio Code）层面也具有相同的选择。我们先来体验一下用于创建初始 .NET Core项目的脚手架命令行在Mac OS上的应用，为此我们按照下图所示的方式执行“&lt;strong&gt;dotnet new console&lt;/strong&gt;”命令在当前目录下创建了一个控制台应用程序。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191012084556959-271527307.png&quot;&gt;&lt;img width=&quot;461&quot; height=&quot;271&quot; title=&quot;1-14&quot; alt=&quot;1-14&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191012084557388-538295812.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上图右侧所示的是执行脚手架命令行创建的控制台应用的项目结构，可以看出它与我们在Windows上执行相同命令创建的应用具有相同的文件结构。不仅如此，生成的文件内容也完全一致，如下所示的是项目文件helloworld.csproj和程序文件Program.cs的内容。&lt;/p&gt;
&lt;p&gt;helloworld.csproj：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Project &lt;/span&gt;&lt;span&gt;Sdk&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.NET.Sdk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;OutputType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Exe&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;OutputType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;netcoreapp3.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Program.cs：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;    
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; helloworld
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在无需对原文件做任何改动的情况下，我们可以直接执行dotnet命令行来启动该控制台程序。如下面的代码片段所示，在将当前目录切换到控制台应用所在项目根目录之后，我们直接执行dotnet run命令启动了我们创建的程序，随后我们看到了作为程序入口的Main方法输出到控制台上的“Hello World!”文本。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191012084557635-524538710.png&quot;&gt;&lt;img width=&quot;460&quot; height=&quot;138&quot; title=&quot;1-15&quot; alt=&quot;1-15&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191012084557847-1073134502.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在《跨平台开发体验: Windows[下篇]》中，我们演示了如何将一个通过脚手架命令行创建的控制台应用一步步改造成ASP.NET Core MVC应用，既然.NET Core提供真正的跨平台支持，那么我们按照相同方式改造的ASP.NET Core MVC应用同样可以在Mac OS上运行。接下来我们就来验证一下。我们首先直接编辑项目文件helloworld.csproj将SDK改成“&lt;strong&gt;Microsoft.NET.Sdk.Web&lt;/strong&gt;”，并将表示输出类型的属性节点（&amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;）移除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk.Web&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.&lt;span&gt;0&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们选择相应的IDE或者纯文本编辑器对Program.cs进行如下的修改，那么我们的应用就变成了一个简单的ASP.NET Core MVC应用。经过前面的介绍，相信读者朋友们已经理解了每一行代码的含义，所以在这里我们就不再赘言说明了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Hosting;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; helloworld
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            Host.CreateDefaultBuilder()
                .ConfigureWebHostDefaults(webHostBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt; webHostBuilder
                    .ConfigureServices(servicecs &lt;/span&gt;=&amp;gt;&lt;span&gt; servicecs
                        .AddRouting()
                        .AddControllersWithViews())
                    .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app
                        .UseRouting()
                        .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers())))
                .Build()
                .Run();
        }
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController
{
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SayHello() =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到目前为止，所有的编程工作都已经结束，我们只需要按照我们熟悉的方式执行dotnet run命令就可以启动这个程序。程序启动之后利用浏览器访问地址“http://localhost:5000/hello/foobar”，我们会得到如下图所示的输出结果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191012084558088-305309772.png&quot;&gt;&lt;img width=&quot;411&quot; height=&quot;178&quot; title=&quot;1-16&quot; alt=&quot;1-16&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191012084558359-206723440.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Mac OS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Linux&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-061.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Docker&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 Oct 2019 00:46:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>除了微软自家的Windows平台， .NET Core针对Mac OS以及各种Linux Distribution（RHEL、Ubuntu、Debian、Fedora、CentOS和SUSE等）都提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html</dc:identifier>
</item>
<item>
<title>Spring Boot （十一）： Spring Boot 定时任务 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11658351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11658351.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191012084456435-32756606.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际的项目开发工作中，我们经常会遇到需要做一些定时任务的工作，那么，在 Spring Boot 中是如何实现的呢？&lt;/p&gt;
&lt;h2 id=&quot;添加依赖&quot;&gt;1. 添加依赖&lt;/h2&gt;
&lt;p&gt;在 pom.xml 文件中只需引入 &lt;code&gt;spring-boot-starter&lt;/code&gt; 的依赖即可：&lt;/p&gt;
&lt;p&gt;代码清单：spring-boot-scheduler/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置文件&quot;&gt;2. 配置文件&lt;/h2&gt;
&lt;p&gt;配置文件无需过多的配置：&lt;/p&gt;
&lt;p&gt;代码清单：spring-boot-scheduler/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8080
spring:
  application:
    name: spring-boot-scheduler&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动主类&quot;&gt;3. 启动主类&lt;/h2&gt;
&lt;p&gt;启动主类需增加注解 &lt;code&gt;@EnableScheduling&lt;/code&gt; 表示我们要开启定时任务这个服务。&lt;/p&gt;
&lt;p&gt;代码清单：spring-boot-scheduler/src/main/java/com/springboot/springbootscheduler/SpringBootSchedulerApplication.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableScheduling
public class SpringBootSchedulerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootSchedulerApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定时任务实现类&quot;&gt;4. 定时任务实现类&lt;/h2&gt;
&lt;p&gt;代码清单：spring-boot-scheduler/src/main/java/com/springboot/springbootscheduler/task/Task.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class Task {

    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);

    private final Logger logger = LoggerFactory.getLogger(Task.class);

    /**
     * cron表达式
     */
    @Scheduled(cron = &quot;*/5 * * * * ?&quot;)
    private void task1() {
        logger.info(&quot;task1 正在执行，现在时间：{}&quot;, dateFormat.format(new Date()));
    }

    /**
     * 上一次开始执行时间点之后5秒再执行
     */
    @Scheduled(fixedRate = 5000)
    public void task2() {
        logger.info(&quot;task2 正在执行，现在时间：{}&quot;, dateFormat.format(new Date()));
    }

    /**
     * 上一次执行完毕时间点之后5秒再执行
     */
    @Scheduled(fixedDelay = 5000)
    public void task3() {
        logger.info(&quot;task3 正在执行，现在时间：{}&quot;, dateFormat.format(new Date()));
    }

    /**
     * 第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次
     */
    @Scheduled(initialDelay = 1000, fixedRate = 5000)
    public void task4() {
        logger.info(&quot;task4 正在执行，现在时间：{}&quot;, dateFormat.format(new Date()));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参数-cron&quot;&gt;4.1 参数 cron&lt;/h3&gt;
&lt;p&gt;cron表达式语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[秒] [分] [小时] [日] [月] [周] [年]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：[年]不是必须的域，可以省略[年]，则一共6个域&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;秒&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;td&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;分&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;td&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;时&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;0-23&lt;/td&gt;
&lt;td&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;日&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;1-31&lt;/td&gt;
&lt;td&gt;, - * ? / L W&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;月&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;1-12 / JAN-DEC&lt;/td&gt;
&lt;td&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;周&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;1-7 or SUN-SAT&lt;/td&gt;
&lt;td&gt;, - * ? / L #&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;年&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;1970-2099&lt;/td&gt;
&lt;td&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;通配符说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;,&lt;/code&gt; 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt; 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt; 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参数-zone&quot;&gt;4.2 参数 zone&lt;/h3&gt;
&lt;p&gt;时区，接收一个java.util.TimeZone#ID。cron表达式会基于该时区解析。默认是一个空字符串，即取服务器所在地的时区。比如我们一般使用的时区Asia/Shanghai。该字段我们一般留空。&lt;/p&gt;
&lt;h3 id=&quot;参数-fixeddelay-和-fixeddelaystring&quot;&gt;4.3 参数 fixedDelay 和 fixedDelayString&lt;/h3&gt;
&lt;p&gt;这两个参数其实含义是一样的，只是一个使用的是 Long 类型，一个使用的是 String 类型。&lt;/p&gt;
&lt;p&gt;含义都是上一次执行完毕时间点之后多长时间再执行，具体使用示例在上面的代码中已经给出。&lt;/p&gt;
&lt;h3 id=&quot;参数-fixedrate-和-fixedratestring&quot;&gt;4.4 参数 fixedRate 和 fixedRateString&lt;/h3&gt;
&lt;p&gt;这一组参数和上面的那组参数也是一样的，同样的是类型不同，含义是上一次开始执行时间点之后多长时间再执行。&lt;/p&gt;
&lt;h3 id=&quot;参数-initialdelay-和-initialdelaystring&quot;&gt;4.5 参数 initialDelay 和 initialDelayString&lt;/h3&gt;
&lt;p&gt;这组参数的含义是第一次延迟多长时间后再执行。&lt;/p&gt;
&lt;h3 id=&quot;附上-org.springframework.scheduling.annotation.scheduled&quot;&gt;4.6 附上 org.springframework.scheduling.annotation.Scheduled&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@Scheduled&lt;/code&gt; 注解的使用方式其实在源码里已经讲的很清楚了，这里附上供大家参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(Schedules.class)
public @interface Scheduled {

    /**
     * A special cron expression value that indicates a disabled trigger: {@value}.
     * &amp;lt;p&amp;gt;This is primarily meant for use with ${...} placeholders, allowing for
     * external disabling of corresponding scheduled methods.
     * @since 5.1
     */
    String CRON_DISABLED = &quot;-&quot;;


    /**
     * A cron-like expression, extending the usual UN*X definition to include triggers
     * on the second as well as minute, hour, day of month, month and day of week.
     * &amp;lt;p&amp;gt;E.g. {@code &quot;0 * * * * MON-FRI&quot;} means once per minute on weekdays
     * (at the top of the minute - the 0th second).
     * &amp;lt;p&amp;gt;The special value {@link #CRON_DISABLED &quot;-&quot;} indicates a disabled cron trigger,
     * primarily meant for externally specified values resolved by a ${...} placeholder.
     * @return an expression that can be parsed to a cron schedule
     * @see org.springframework.scheduling.support.CronSequenceGenerator
     */
    String cron() default &quot;&quot;;

    /**
     * A time zone for which the cron expression will be resolved. By default, this
     * attribute is the empty String (i.e. the server's local time zone will be used).
     * @return a zone id accepted by {@link java.util.TimeZone#getTimeZone(String)},
     * or an empty String to indicate the server's default time zone
     * @since 4.0
     * @see org.springframework.scheduling.support.CronTrigger#CronTrigger(String, java.util.TimeZone)
     * @see java.util.TimeZone
     */
    String zone() default &quot;&quot;;

    /**
     * Execute the annotated method with a fixed period in milliseconds between the
     * end of the last invocation and the start of the next.
     * @return the delay in milliseconds
     */
    long fixedDelay() default -1;

    /**
     * Execute the annotated method with a fixed period in milliseconds between the
     * end of the last invocation and the start of the next.
     * @return the delay in milliseconds as a String value, e.g. a placeholder
     * or a {@link java.time.Duration#parse java.time.Duration} compliant value
     * @since 3.2.2
     */
    String fixedDelayString() default &quot;&quot;;

    /**
     * Execute the annotated method with a fixed period in milliseconds between
     * invocations.
     * @return the period in milliseconds
     */
    long fixedRate() default -1;

    /**
     * Execute the annotated method with a fixed period in milliseconds between
     * invocations.
     * @return the period in milliseconds as a String value, e.g. a placeholder
     * or a {@link java.time.Duration#parse java.time.Duration} compliant value
     * @since 3.2.2
     */
    String fixedRateString() default &quot;&quot;;

    /**
     * Number of milliseconds to delay before the first execution of a
     * {@link #fixedRate()} or {@link #fixedDelay()} task.
     * @return the initial delay in milliseconds
     * @since 3.2
     */
    long initialDelay() default -1;

    /**
     * Number of milliseconds to delay before the first execution of a
     * {@link #fixedRate()} or {@link #fixedDelay()} task.
     * @return the initial delay in milliseconds as a String value, e.g. a placeholder
     * or a {@link java.time.Duration#parse java.time.Duration} compliant value
     * @since 3.2.2
     */
    String initialDelayString() default &quot;&quot;;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;5. 示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/spring-boot-examples/tree/master/spring-boot-scheduler&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/spring-boot-examples/tree/master/spring-boot-scheduler&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;6. 参考&lt;/h2&gt;
&lt;p&gt;https://www.jianshu.com/p/1defb0f22ed1&lt;/p&gt;
</description>
<pubDate>Sat, 12 Oct 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>在实际的项目开发工作中，我们经常会遇到需要做一些定时任务的工作，那么，在 Spring Boot 中是如何实现的呢？ 1. 添加依赖 在 pom.xml 文件中只需引入 的依赖即可： 代码清单：spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11658351.html</dc:identifier>
</item>
<item>
<title>Java匹马行天下之教你用学汉语式方法学编程语言 - 泰斗贤若如</title>
<link>http://www.cnblogs.com/zyx110/p/11656454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyx110/p/11656454.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;前言：&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;前段时间接连更新了带小白从入门到了解的几篇博客：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11451084.html&quot; target=&quot;_blank&quot;&gt;Java匹马行天下之编程常识知多少&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《J&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11463114.html&quot; target=&quot;_blank&quot;&gt;ava匹马行天下之走进编程的殿堂&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11525685.html&quot; target=&quot;_blank&quot;&gt;Java匹马行天下之高级语言大锅烩&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11586300.html&quot; target=&quot;_blank&quot;&gt;Java匹马行天下之C国程序员的秃头原因&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11592544.html&quot; target=&quot;_blank&quot;&gt;Java匹马行天下之Java国出了个Java&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/11601899.html&quot; target=&quot;_blank&quot;&gt;Java匹马行天下之Java帝国的崛起&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我试着从不同的角度带新手理解编程，希望能帮助一些真正需要的朋友进行学习，后面的三篇故事新手朋友就当真正看故事了，等你学了后面的知识，你就能理解了，现在留个简单印象就可以了。一个月前我的《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/10641149.html&quot; target=&quot;_blank&quot;&gt;Java匹马行天下&lt;/a&gt;》&lt;span class=&quot;md-link&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;其实已经更新到Spring框架了，但是我没有继续更新下去，因为又有一届大一新生步入了软件这个大家庭，作为“学长”，为了弥补自己内心的一丝遗憾，我毅然停下来我前进的脚步，决定再回过头去重新带他们走一遍，跟我一起行天下。或许我写的不都是对的，但我保证每一篇都是用我自己的理解认真去写的，是真的站到了作为小白的立场去写的，我也不知道我这样做的意义何在，或许是感恩，也或许是善良，也或许是自作多情，不管是什么吧，都不重要，重要的是我已经做了，那就坚持并做好，别的都让时间去解释吧。我最近注册了公众号，为了方便大家查看，我把文章发布到公众号上了，博客中因为还有别的文章，所以顺序有点乱，建议关注我的公众号，我做了系统的整理，方便你按顺序查看，公众号二维码在文章末尾有，自行关注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;用学汉语式方法学编程&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;看过上面六篇博客的朋友现在应该已经知道要跟电脑沟通交流就要学那些编程语言，现在我们要思考的问题是如何学编程语言。如何学？说句废话，“该咋学咋学呗”，认真点，你想想你小时候学汉语是怎么学的，是不是先学的“声母韵母”、“一声平二声扬三声拐弯四声降”、“嘴巴张大啊啊啊”，还有那些汉字的笔顺笔画，这些是学习汉语最基本的规则吧，等你学完了这些，你是不是才能组词、造句，然后你就能看懂别人写的优美的句子，写作的时候能引用别人的句子，直到你能自己写出更加优美的句子，再往后，你就能为所欲为了，思想有多远，世界舞台就有多大，天高任你飞。是不是勾起你的回忆了，嗯，看看下面的图片，感叹一声童年真好，再加一句时间真快，继续我们的编程语言吧。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191011195057419-305763073.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CLenovo%5CDesktop%5Cassets%5C1.png&quot;&gt;&lt;img src=&quot;file://c/Users/Lenovo/Desktop/assets/1.png?lastModify=1570794578&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实编程语言的学习过程和学汉语差不多，首先就是要学习编程语言中最基本的“规则”，等学完这些规则，你才能做一些别的事，至于要做什么那是后面的事，此篇我就只教你编程语言里的“规则”，既然我的题目是Java匹马行天下，我就以Java这门编程语言为例了，此后的所有内容都是用Java。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Java的规则&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;首先我用最简单的例子普及一下这些规则，平时上学我们都离不开数学，学数学有时候真的很头疼，现在我学高数可痛苦，那现在我们看看计算机是如何“学数学”的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;常量&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第一种：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1+1=2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;简单吧，这都不用算，但是你发现了没，加号两边的数1是固定的，1就是1，不能再改变了，这在编程语言中把1称为“常量”。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;那你知道了，&lt;strong&gt;规则一&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;就是让你识别什么是常量？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;常量&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：指在程序运行过程中其值不能改变的量。这是常量的官方定义，不难理解吧。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;变量&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第二种：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;X+Y=Z&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;看到这个你是不是想到了你学过的方程式了，没错，这就是方程式，你看，加号两边的X和Y你可以给它们赋任意值，是可以变化的，Z随着X、Y的改变而改变，在数学中我们把X、Y、Z叫未知数，但在编程语言中它们有个名字叫“变量”。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;规则二&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：识别什么是变量？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;变量：&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;用于存储可变数据的容器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;变量的特点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;必须要有大小&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;存储一定格式的可变数据&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;必须要有名字&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数据类型&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;好，明白了常量和变量，再看，上面的变量X和Y给它们赋值，我们可以赋整数，也可以赋小数，这个整数和小数在编程语言中称为”数据类型“，整数和小数只是数据类型中的两种。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;规则三&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：数据类型有哪些？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数据类型分为两种：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一种是内置数据类型，另一种是引用数据类型。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;目前我们先了解内置数据类型，引用数据类型在后面会提到。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;内置数据类型有八种：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;整数型：&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;byte&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;short int long&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;浮点型：&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;float double&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;字符型：&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;布尔型：&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;boolean&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这个数据类型要怎样理解呢？其实也简单，你把整数型、浮点型、字符型、布尔型分别看成是四个容器，生活中牛奶瓶中装的是牛奶，饮料瓶中装的是饮料，同样的道理，整数型这个容器中装的是整数，浮点型容器中装的是小数，字符型容器中装的是字符，布尔型容器是个特例，它里面就装了两个东西，true和false.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们往牛奶瓶中倒牛奶的时候，如果牛奶很多，小牛奶瓶装不了，我们是不是要换一个大点的瓶子来装牛奶，假如本来准备的是500ML的牛奶瓶，装不了，又换了个1000ML的牛奶瓶。同理，整数型容器中装的是整数，整数都有大小，byte、short、int、long就相当于容器的容量，byte最小，依次增大，这样你就要注意了，以后在往整数型这个容器中“装整数”的时候，要看所选整数的大小，特别小的数放多大的容量里都可以，但最好是物尽其用，别浪费空间，大点的数就要根据实际情况具体分析了，要做到不浪费空间，也要“装得下，不遗漏”。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;浮点型容器中装的是小数，float和double也可以看成是容器的容量，float叫单精度，double叫双精度，理解同上。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;两者的主要&lt;strong&gt;区别&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　1.在内存中占有的字节数不同&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　　　单精度浮点数在机内存占4个字节&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　　　双精度浮点数在机内存占8个字节&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　2.有效数字位数不同&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　　　单精度浮点数有效数字8位&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　　　双精度浮点数有效数字16位&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　3.数值取值范围&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　　　单精度浮点数的表示范围：-3.40E+38~3.40E+38&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　　　双精度浮点数的表示范围：-1.79E+308~-1.79E+308&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　4.在程序中处理速度不同&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　　　一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果不声明，默认小数为double类型，所以如果要用float的话，必须进行&lt;strong&gt;强转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span&gt;　　例如：float a=1.3; 会编译报错，正确的写法 float a&lt;/span&gt; = (float)1.3;或者float a = 1.3f;（f或F都可以不区分大小写）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：float是8位有效数字，第7位数字将会四舍五入&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数据类型转换&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在上面我提到了一个词叫&lt;strong&gt;强转&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;，我来解释一下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;自动类型转换&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;假如现在你分别有一个500ML和1000ML的牛奶瓶，然后你需要装300ML牛奶，你先用500ML的牛奶瓶装了那300ML牛奶，然后你又把装在500ML牛奶瓶中的牛奶装到了1000ML的牛奶瓶中，这个过程在编程语言中叫&lt;strong&gt;自动类型转换&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;(也叫隐式类型转换)，根据这个例子也可以解释为把一个数赋值给更大数值范围的变量，例如可以将byte类型的整数赋值给short类型的整数，可以将short类型的整数赋值给int类型的整数，可以将int类型的整数赋值给long类型的整数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;强制类型转换&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;好，现在再想，依旧有两个分别是500ML和1000ML的牛奶瓶，然后你需要装800ML牛奶，你先用1000ML的牛奶瓶装了那800ML牛奶，然后你现在想把装在1000ML牛奶瓶中的牛奶倒进500ML的牛奶瓶中，想想会怎样，如果你强行倒入，是不是会溢出牛奶啊，这个过程在编程语言中叫&lt;strong&gt;强制类型转换&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;(也叫显式类型转换)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对应到编程语言中，可以把byte 理解为1两的碗，short 2两的碗，int 4两的碗，long 8两的碗。1两碗的满碗酒可以倒入 2两 4两 8两的碗中。但是 4两碗的酒倒入1两碗的酒就有一些问题。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;运算符&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;上面介绍的都是编程语言中对数的理解，了解了这些之后终究离不开运算，运算离不开加减乘除，编程语言中把数学中的(+、-、*、/)叫运算符。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;OK，学完上面这些其实我们可以让计算机进行一些运算了，不过还没那么简单，你要让计算机运算，你怎么告诉计算机你需要让它运算什么啊？难道就跟平时说话一样问它1+1等于几？哈哈，开玩笑的，别忘了计算机是死的，不会思考，就拿那个方程式来说吧，你给变量X赋一个数值，你得告诉它这个数值是什么数据类型，计算机才能知道，才能进行相应的计算。这个过程在编程语言中叫&lt;strong&gt;变量的声明和赋值&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;例：&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;int X =10;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;好，下面我们让计算机做一道加法题吧，我们在现实生活中写作业是在笔记本上写的吧，那在电脑上写作业，你也得找个&quot;笔记本&quot;，在编程语言中这个“笔记本”叫编译器，然后你看你的笔记本上有画的像四线三格那样的各种线，老师让你把作业写到线里面，不要乱写，在编程中也一样，电脑老师让你把作业写到笔记本的“四线三格”中(暂且这样理解吧，等你学到后面之后就会有自己的理解了，目前就先按我说的这样理解)，下面我就开始在编译器上写加法题了：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt; public class AddDemo {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;int X=10;&lt;br/&gt;int Y=20;&lt;br/&gt;System.out.println(&quot;X+Y的和为：&quot;+(X+Y));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191011195143930-1880243680.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CLenovo%5CDesktop%5Cassets%5C2.png&quot;&gt;&lt;img src=&quot;file://c/Users/Lenovo/Desktop/assets/2.png?lastModify=1570794578&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我用的这个编译器叫IDEA,也就是我写作业的笔记本，下面图片中的这个就相当于笔记本上的四线三格，你要把你的作业写到这里面电脑才会看，你必须按老师说的做&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191011195212592-1132756383.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CLenovo%5CDesktop%5Cassets%5C3.png&quot;&gt;&lt;img src=&quot;file://c/Users/Lenovo/Desktop/assets/3.png?lastModify=1570794578&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面这个已经不陌生了吧，这个就是上面讲到的声明变量和给变量赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191011195227691-454103941.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CLenovo%5CDesktop%5Cassets%5C4.png&quot;&gt;&lt;img src=&quot;file://c/Users/Lenovo/Desktop/assets/4.png?lastModify=1570794578&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实现在你看不懂的应该是下面这句&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201910/1640688-20191011195241487-1782341580.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CLenovo%5CDesktop%5Cassets%5C5.png&quot;&gt;&lt;img src=&quot;file://c/Users/Lenovo/Desktop/assets/5.png?lastModify=1570794578&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;System.out.println()&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;这是一个函数，函数我到后面会讲到，暂时做个了解，你现在只需要知道，这个就跟生活中你跟老外说声Hello，他就知道你在跟他问好一样，你给电脑输入System.out.println()，电脑就知道你要在屏幕上输出东西，你只需要把你想要输出到电脑屏幕上的东西写道System.out.println()函数里面即可，你看，我在函数里面写的是System.out.println(&quot;X+Y的和为：&quot;+(X+Y));电脑就会给我在屏幕上输出X+Y的值，至于里面为什么要那样写，后面我也会说，这就是编程语言里面的一些规则，你只有会这些规则，你才能跟计算机进行沟通交流，让计算机做你想做的事。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;结束语&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3500字了，先打住吧，写半天了，写这东西真耗时，不知不觉几个小时过去了，我还没见过有人像我这样用大白话写过Java基础，我也不知道我这样写别人看了能不能接受，但是我说了，我已经做了，有决定总比没决定好，喜欢的朋友不要吝啬你手中的赞，该鼓励的时候鼓励一下，给我点动力，最好是也关注一下我的公众号，我也不是拉顾客赚钱啥的，只能说是增加点人气，不至于那么冷清，可以传播一下，让更多有需要的人去发现，让这篇博客有它的价值，我就知足了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;后面我会不定期更新，想追剧的朋友就点个关注吧！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;【尊重原创】&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：本文出自博客园&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/zyx110/&quot;&gt;https://www.cnblogs.com/zyx110/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 Oct 2019 00:42:00 +0000</pubDate>
<dc:creator>泰斗贤若如</dc:creator>
<og:description>Java匹马行天下之教你用学汉语式方法学编程语言 前言： 前段时间接连更新了带小白从入门到了解的几篇博客： 《Java匹马行天下之编程常识知多少》 《Java匹马行天下之走进编程的殿堂》 《Java匹</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zyx110/p/11656454.html</dc:identifier>
</item>
<item>
<title>ShutdownHook - Java 优雅停机解决方案 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/11658187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/11658187.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201910/1419561-20191012074727046-399697507.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想象一下，如果你现在刚好在 word 上写需求文档，电脑突然重启。等待开机完成，你可能会发现写了一个小时文档没有保存，就这么没了。。。&lt;/p&gt;
&lt;p&gt;一个正在运行 Java 应用如果突然将其停止，影响不止数据丢失,还会造成其他影响。比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求丢失：内存队列中等待执行请求丢失&lt;/li&gt;
&lt;li&gt;数据丢失：处于内存缓存中数据未持久化到磁盘&lt;/li&gt;
&lt;li&gt;文件损坏：正在写的文件没有没有更新完成，导致文件损坏&lt;/li&gt;
&lt;li&gt;业务中断：处理一半的业务被强行中断，如支付成功了，却没有更新到数据库中&lt;/li&gt;
&lt;li&gt;服务未下线：上游服务依然往停止节点发送请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以在关闭服务之前，我们需要先做好善后工作，比如保存数据，清理资源，下线服务，然后才退出应用。这种有计划平滑的关闭应用相对直接停止应用，就显得非常『优雅』。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps: 仔细品味，优雅停机这个词真好~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;shutdownhook&quot;&gt;ShutdownHook&lt;/h2&gt;
&lt;p&gt;Java 语言提供一种 ShutdownHook（钩子）进制，当 JVM 接受到系统的关闭通知之后，调用 ShutdownHook 内的方法，用以完成清理操作，从而平滑的退出应用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ShutdownHook代码如下：&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        Runtime.getRuntime().addShutdownHook(new Thread(() -&amp;gt; {
            System.out.println(&quot;关闭应用，释放资源&quot;);
        }));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Runtime.getRuntime().addShutdownHook(Thread)&lt;/code&gt; 需要传入一个线程对象，后续动作将会在该异步线程内完成。除了主动关闭应用（使用 kill -15 指令）,以下场景也将会触发 ShutdownHook :&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码执行结束，JVM 正常退出&lt;/li&gt;
&lt;li&gt;应用代码中调用 &lt;code&gt;System#exit&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;应用中发生 OOM 错误，导致 JVM 关闭&lt;/li&gt;
&lt;li&gt;终端中使用 &lt;code&gt;Ctrl+C&lt;/code&gt;(非后台运行)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前很多开源框架都是基于这个机制实现优雅停机，比如 Dubbo，Spring 等。&lt;/p&gt;
&lt;h2 id=&quot;相关注意点&quot;&gt;相关注意点&lt;/h2&gt;
&lt;p&gt;ShutdownHook 代码实现起来相对简单，但是我们还是需要小心下面这些坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Runtime.getRuntime().addShutdownHook(Thread)&lt;/code&gt; 可以被多次调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以多次调用 &lt;code&gt;Runtime.getRuntime().addShutdownHook(Thread)&lt;/code&gt; 方法，从而增加多个。但是需要注意的是，多个 ShutdownHook 之间并无任何顺序，Java 并不会按照加入顺序执行，反而将会并发执行。&lt;/p&gt;
&lt;p&gt;所以尽量在一个 ShutdownHook 完成所有操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ShutdownHook 需要尽快执行结束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要在 ShutdownHook 执行需要被阻塞代码，如 I/0 读写，这样就会导致应用短时间不能被关闭。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; Runtime.getRuntime().addShutdownHook(new Thread(() -&amp;gt; {
           while (true){
               System.out.println(&quot;关闭应用，释放资源&quot;);
           }
        }));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，我们使用 &lt;code&gt;while(true)&lt;/code&gt; 模拟长时间阻塞这种极端情况，关闭该应用时，应用将会一直阻塞在 &lt;code&gt;while&lt;/code&gt;代码中，导致应用没办法被关闭。&lt;/p&gt;
&lt;p&gt;除了阻塞之外，还需要小心其他会让线程阻塞的行为，比如死锁。&lt;/p&gt;
&lt;p&gt;为了避免 ShutdownHook 线程被长时间阻塞，我们可以引入超时进制。如果等待一定时间之后，ShutdownHook 还未完成，由脚本直接调用 kill -9 强制退出或者 ShutdownHook 代码中引入超时进制。&lt;/p&gt;
&lt;p&gt;文章首发于&lt;a href=&quot;https://studyidea.cn/articles/2019/09/03/1567504427330.html&quot;&gt;studyidea.cn/shutdownHook&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201910/1419561-20191012074730643-271095276.png&quot; alt=&quot;其他平台.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 23:48:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>想象一下，如果你现在刚好在 word 上写需求文档，电脑突然重启。等待开机完成，你可能会发现写了一个小时文档没有保存，就这么没了。。。 一个正在运行 Java 应用如果突然将其停止，影响不止数据丢失,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/11658187.html</dc:identifier>
</item>
<item>
<title>Currying 及应用 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/currying_and_function_compose.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/currying_and_function_compose.html</guid>
<description>&lt;p&gt;Currying，中文多翻译为&lt;strong&gt;柯里化&lt;/strong&gt;，感觉这个音译还没有达到类似 Humor 之于幽默的传神地步，后面直接使用 Currying。&lt;/p&gt;
&lt;h2&gt;什么是 Currying&lt;/h2&gt;
&lt;p&gt;Currying 是这么一种&lt;strong&gt;机制&lt;/strong&gt;，它将一个接收多个参数的函数，拆分成多个接收单个参数的函数。&lt;/p&gt;
&lt;p&gt;考察下面的代码：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b;
}

&lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; returns 7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;add&lt;/code&gt; 接收两个参数 &lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;，并返回它们的和 &lt;code&gt;a+b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;经过 curry 化处理后，函数成了如下形式：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 &lt;code&gt;add&lt;/code&gt; 接收一个参数 &lt;code&gt;a&lt;/code&gt;，返回另一个接收一个参数 &lt;code&gt;b&lt;/code&gt; 的函数。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;);

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; add3 &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;);

&lt;span class=&quot;pl-en&quot;&gt;add3&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在当调用 &lt;code&gt;add(3)&lt;/code&gt; 后，得到的不是和，而是另一个接收一个参数的函数，因此，&lt;code&gt;add&lt;/code&gt; 的返回可以继续被调用，&lt;code&gt;add(3)(4)&lt;/code&gt; 后面的这次调用才会将 4 加到 3 上得到和。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;var add3 = add(3)&lt;/code&gt; 这样的单次调用，得到的函数效果相当于是将 3 保存在了新函数的闭包中，该函数会对传入的参数加 3。&lt;/p&gt;
&lt;p&gt;注意这里提到了将入参 3 &lt;strong&gt;保存&lt;/strong&gt; 到了闭包中后续使用，很容易联想到 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;Function.prototype.bind()&lt;/code&gt;&lt;/a&gt;，它就可以对传入的函数提前绑定一些预设的入参：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;thisArg&lt;/span&gt;[, &lt;span class=&quot;pl-smi&quot;&gt;arg1&lt;/span&gt;[, &lt;span class=&quot;pl-smi&quot;&gt;arg2&lt;/span&gt;[, &lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;]]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面会看到，正因为 &lt;code&gt;bind&lt;/code&gt; 和 Currying 有点关系，在实现任意函数的 Currying 化时会用到它。&lt;/p&gt;
&lt;p&gt;注意到 Currying 化的定义，其实是将多个参数打散到多个函数中，这个过程可通过代码来自动化，以达到将任意多入参函数进行 Currying 化的目的，后面讨论实现。&lt;/p&gt;
&lt;h2&gt;偏函数/Partial Application&lt;/h2&gt;
&lt;p&gt;区别与 Currying，如果在拆分入参的过程中，这些拆分出来的函数不是一次只应用其中的一个，而是任意多个，则这些函数就是部分应用（Parital application）了原函数中的入参，称作偏函数。&lt;/p&gt;
&lt;p&gt;考察下面的 &lt;code&gt;add&lt;/code&gt; 函数，其实是将前面示例中的 &lt;code&gt;add&lt;/code&gt; 入参进行了扩充，由两个增加到四个：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;d&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; d;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么如下的函数就都是偏函数，它们都部分应用了 &lt;code&gt;add&lt;/code&gt; 的入参：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;partial1&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; d;
  };
}
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;partial2&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;d&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; d;
  };
}
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;partial3&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;d&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; d;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;偏函数中这种入参的拆分和部分应用，并不仅限于一层的拆分，可以是任意多次的:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;partial1&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;partial2&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;partial3&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;d&lt;/span&gt;) {
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; d;
    };
  };
}

&lt;span class=&quot;pl-en&quot;&gt;partial1&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;partial1&lt;/code&gt;、&lt;code&gt;partial2&lt;/code&gt;、&lt;code&gt;partial3&lt;/code&gt; 一起构成了原 &lt;code&gt;add&lt;/code&gt; 函数的偏函数。&lt;/p&gt;
&lt;p&gt;可以看到，偏函数是 Curring 更加一般（general）的形式，下面看如何实现将任意函数进行 Currying 化，或偏函数化。&lt;/p&gt;
&lt;h2&gt;将一般化函数进行 Currying 化&lt;/h2&gt;
&lt;p&gt;我们需要构造这么一个函数假设名叫 &lt;code&gt;curry&lt;/code&gt;，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;curry&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;fn&lt;/span&gt;){
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 待实现&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用 &lt;code&gt;curry&lt;/code&gt; 后，我们可以得到原函数 Curry 化后的版本，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b;
}

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; currified &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;curry&lt;/span&gt;(add);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即上述 &lt;code&gt;currified&lt;/code&gt; 应该等效为：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;currified&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，通过 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;Function.length&lt;/code&gt;&lt;/a&gt; 是可以知道一个给定函数其预期的入参个数的。&lt;/p&gt;
&lt;p&gt;再加上前面提到的 &lt;code&gt;bind&lt;/code&gt; 函数，可以得到如下的实现：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;curry&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;f&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;currify&lt;/span&gt;() {
    &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;slice&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;args&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;f&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt;
      &lt;span class=&quot;pl-smi&quot;&gt;f&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;, args) &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pl-smi&quot;&gt;currify&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;args)
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面测试一下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-j&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
function add(a&lt;span class=&quot;pl-k&quot;&gt;,&lt;/span&gt; b) &lt;span class=&quot;pl-k&quot;&gt;{&lt;/span&gt;
  return a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;}&lt;/span&gt;

var currified &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; curry(add)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;

currified(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且以上实现不只是简单的 Currying 化，可以是任意数量和任意次数的 parial application:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;b&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;d&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; b &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; d;
}

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; currified &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;curry&lt;/span&gt;(add);

&lt;span class=&quot;pl-en&quot;&gt;currified&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 10&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;currified&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 10&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;currified&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;)(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总之就是各种形状&lt;ruby&gt;和&lt;rp&gt;（&lt;/rp&gt;&lt;rt&gt;hàn&lt;/rt&gt;&lt;rp&gt;）&lt;/rp&gt;&lt;/ruby&gt;姿势，各种颜色&lt;ruby&gt;和&lt;rp&gt;（&lt;/rp&gt;&lt;rt&gt;hàn&lt;/rt&gt;&lt;rp&gt;）&lt;/rp&gt;&lt;/ruby&gt;皮肤的组合。&lt;/p&gt;
&lt;p&gt;自动化的 CurryIng 倒是实现了，可说了半天，它具体有什么实用价值。&lt;/p&gt;
&lt;h2&gt;函数的组合（function composition）&lt;/h2&gt;
&lt;p&gt;我们知道代数里面可以有函数的组合，譬如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;f(x) = x * x
g(y) = y + 1
g(f(x)) = x * x + 1

g(f(2)) = 2 * 2 + 1 = 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代数表达转成 JavaScript 即：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; y &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}

&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;)) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里用到了两个函数 &lt;code&gt;f&lt;/code&gt;，&lt;code&gt;g&lt;/code&gt; 联合起来得到一个结果，他们都分别只接收一个入参同时返回一个结果。&lt;/p&gt;
&lt;p&gt;像这样只接收一个入参并返回一个结果的函数，便符合组装的需求，可像上面这样自由组合。通过上面的讨论我们知道，任意函数都可经过 Currying 化处理后变成多个只接收单个入参的函数。这就为函数的组合提供了基础。&lt;/p&gt;
&lt;p&gt;因此我们可以将 &lt;code&gt;f&lt;/code&gt;，&lt;code&gt;g&lt;/code&gt; 的结合形成一个新的函数，这个函数作为对外的接口被调用即可。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;compose&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;fn1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;fn2&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;fn1&lt;/span&gt;(&lt;span class=&quot;pl-en&quot;&gt;fn2&lt;/span&gt;(input));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;myFn&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;compose&lt;/span&gt;(f)(g);
&lt;span class=&quot;pl-en&quot;&gt;myFn&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像上面的 &lt;code&gt;compose&lt;/code&gt; 还不够一般化，他只接收两个函数并对其进行结合，下面来看更加一般化的函数组合，将实现接收任意多个函数。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;pipe&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;fns&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;fns&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;reduce&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;mem&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;fn&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;fn&lt;/span&gt;(mem), input)

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;addOne&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; x

&lt;span class=&quot;pl-en&quot;&gt;pipe&lt;/span&gt;(square, double, addOne)(&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的 &lt;code&gt;pipe&lt;/code&gt; 将对输入依次应用 入参中的各函数，所以取名 &lt;code&gt;pipe&lt;/code&gt; 管道流。&lt;/p&gt;
&lt;p&gt;以上，函数的组装。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Fri, 11 Oct 2019 16:50:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>Currying，中文多翻译为柯里化，感觉这个音译还没有达到类似 Humor 之于幽默的传神地步，后面直接使用 Currying。 什么是 Currying Currying 是这么一种机制，它将一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/currying_and_function_compose.html</dc:identifier>
</item>
<item>
<title>Java 并发编程(三)：如何保证共享变量的可见性？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11657905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11657905.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HRAabyY-cLcAK_v9x0pMXw&quot;&gt;上一篇&lt;/a&gt;，我们谈了谈如何通过&lt;strong&gt;同步&lt;/strong&gt;来保证共享变量的原子性（一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行），本篇我们来谈一谈如何保证共享变量的可见性（多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值）。&lt;/p&gt;
&lt;p&gt;我们使用&lt;strong&gt;同步&lt;/strong&gt;的目的不仅是，不希望某个线程在使用对象状态时，另外一个线程在修改状态，这样容易造成混乱；我们还希望某个线程修改了对象状态后，其他线程能够看到修改后的状态——这就涉及到了一个新的名词：内存（可省略）可见性。&lt;/p&gt;
&lt;p&gt;要了解可见性，我们得先来了解一下 Java 内存模型。&lt;/p&gt;
&lt;p&gt;Java 内存模型（Java Memory Model，简称 JMM）描述了 Java 程序中各种变量（线程之间的共享变量）的访问规则，以及在 JVM 中将变量存储到内存→从内存中读取变量的底层细节。&lt;/p&gt;
&lt;p&gt;要知道，所有的变量都是存储在主内存中的，每个线程会有自己独立的工作内存，里面保存了该线程使用到的变量副本（主内存中变量的一个拷贝）。见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117051/201910/1117051-20191012002130076-124507741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;也就是说，线程 1 对共享变量 chenmo 的修改要想被线程 2 及时看到，必须要经过 2 个步骤:&lt;/p&gt;
&lt;p&gt;1、把工作内存 1 中更新过的共享变量刷新到主内存中。&lt;br/&gt;2、将主内存中最新的共享变量的值更新到工作内存 2 中。&lt;/p&gt;
&lt;p&gt;那假如共享变量没有及时被其他线程看到的话，会发生什么问题呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Wanger {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot; readability=&quot;2&quot;&gt;boolean chenmo = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;4&quot;&gt;false;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;(String[] args) {&lt;br/&gt;Thread thread = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (!chenmo) {&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;});&lt;br/&gt;thread.start();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;Thread.sleep(&lt;span class=&quot;hljs-number&quot;&gt;500);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;chenmo = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的本意是：在主线程中创建子线程，然后启动它，当主线程休眠 500 毫秒后，把共享变量 chenmo 的值修改为 true 的时候，子线程中的 while 循环停下来。但运行这段代码后，程序似乎进入了死循环，过了 N 个 500 毫秒，也没有要停下来的意思。&lt;/p&gt;
&lt;p&gt;为什么会这样呢？&lt;/p&gt;
&lt;p&gt;因为主线程对共享变量 chenmo 的修改没有及时通知到子线程（子线程在运行的时候，会将 chenmo 变量的值拷贝一份放在自己的工作内存当中），当主线程更改了 chenmo 变量的值之后，但是还没来得及写入到主存当中，那么子线程此时就不知道主线程对 chenmo 变量的更改，因此还会一直循环下去。&lt;/p&gt;
&lt;p&gt;换句话说，就是：普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主内存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。&lt;/p&gt;
&lt;p&gt;那怎么解决这个问题呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用 volatile 关键字修饰共享变量 chenmo。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为 volatile 变量被线程访问时，会强迫线程从主内存中重读变量的值，而当变量被线程修改时，又会强迫线程将最近的值刷新到主内存当中。这样的话，线程在任何时候总能看到变量的最新值。&lt;/p&gt;
&lt;p&gt;我们来使用 volatile 修饰一下共享变量 chenmo。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;volatile &lt;span class=&quot;hljs-keyword&quot;&gt;boolean chenmo = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行代码后，程序在一瞬间就结束了，500 毫秒毕竟很短啊。在主线程（main 方法）将 chenmo 修改为 true 后，chenmo 变量的值立即写入到了主内存当中；同时，导致子线程的工作内存中缓存变量 chenmo 的副本失效了；当子线程读取 chenmo 变量时，发现自己的缓存副本无效了，就会去主内存读取最新的值(由 false 变为 true 了)，于是 while 循环也就停止了。&lt;/p&gt;
&lt;p&gt;也就是说，在某种场景下，我们可以使用 volatile 关键字来安全地共享变量。这种场景之一就是：&lt;strong&gt;状态真正独立于程序内地其他内容，比如一个布尔状态标志（从 false 到 true，也可以再转换到 false），用于指示发生了一个重要的一次性事件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;至于 volatile 的原理和实现机制，本篇不再深入展开了（小编自己没搞懂，尴尬而不失礼貌的笑一笑）。&lt;/p&gt;
&lt;p&gt;需要再次强调地是：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 相比，volatile 变量运行时地开销比较少，但是它所能实现的功能也仅是 synchronized 的一部分（只能确保可见性，不能确保原子性）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原子性我们&lt;a href=&quot;https://mp.weixin.qq.com/s/HRAabyY-cLcAK_v9x0pMXw&quot;&gt;上一篇&lt;/a&gt;已经讨论过了，增量操作（i++）看上去像一个单独操作，但实际上它是一个由“读取－修改－写入”组成的序列操作，因此 volatile 并不能为其提供必须的原子特性。&lt;/p&gt;
&lt;p&gt;除了 volatile 和 synchronized，Lock 也能够保证可见性，它能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。关于 Lock 的更多细节，我们后面再进行讨论。&lt;/p&gt;
&lt;p&gt;好了，共享变量的可见性就先介绍到这。希望本篇文章能够对大家有所帮助，谢谢大家的阅读。&lt;/p&gt;
&lt;h3 id=&quot;h05&quot;&gt;05、最后&lt;/h3&gt;
&lt;p&gt;谢谢大家的阅读，原创不易，喜欢就点个赞，这将是我最强的写作动力。如果你觉得文章对你有所帮助，也蛮有趣的，就关注一下「沉默王二」公众号。&lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 16:22:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>上一篇，我们谈了谈如何通过同步来保证共享变量的原子性（一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行），本篇我们来谈一谈如何保证共享变量的可见性（多个线程访问同一个变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11657905.html</dc:identifier>
</item>
<item>
<title>分库分表(3) ---SpringBoot + ShardingSphere 实现读写分离 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11656205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11656205.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;有关ShardingSphere概念前面写了两篇博客:&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11608222.html&quot;&gt;分库分表(1) --- 理论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、 &lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11629883.html&quot;&gt;分库分表(2) --- ShardingSphere(理论)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面就这个项目做个整体简单介绍，并在文章最下方附上项目&lt;code&gt;Github地址&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一项目概述&quot;&gt;&lt;span&gt;一、项目概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;技术架构&quot;&gt;1、技术架构&lt;/h4&gt;
&lt;p&gt;项目总体技术选型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SpringBoot2.0.6 + shardingsphere4.0.0-RC1 + Maven3.5.4  + MySQL + lombok(插件)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;项目说明&quot;&gt;2、项目说明&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;场景&lt;/code&gt; 如果实际项目中Mysql是 &lt;strong&gt;Master-Slave&lt;/strong&gt; (主从)部署的，那么数据保存到Master库，Master库数据同步数据到Slave库，数据读取到Slave库，&lt;/p&gt;
&lt;p&gt;这样可以减缓数据库的压力。&lt;/p&gt;
&lt;h4 id=&quot;数据库设计&quot;&gt;3、数据库设计&lt;/h4&gt;
&lt;p&gt;我们这个项目中Mysql服务器并没有实现主从部署,而是同一个服务器建立两个库，一个当做Master库，一个当做Slave库。所以这里是不能实现的功能就是Master库&lt;/p&gt;
&lt;p&gt;新增数据主动同步到Slave库。这样也更有利于我们测试看效果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Master库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191009185338624-1852756872.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Slave库&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191009185349432-1461519408.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从两幅图中可以看出，我这里在同一个服务器建两个数据库来模拟主从数据库。为了方便看测试效果，这里&lt;code&gt;主从数据库中的数据是不一样的&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;二核心代码&quot;&gt;&lt;span&gt;二、核心代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 完整的代码会放到GitHub上，这里只放一些核心代码。&lt;/p&gt;
&lt;h4 id=&quot;pom.xml&quot;&gt;1、pom.xml&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;mybatis-spring-boot&amp;gt;2.0.1&amp;lt;/mybatis-spring-boot&amp;gt;
        &amp;lt;druid&amp;gt;1.1.16&amp;lt;/druid&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${mybatis-spring-boot}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--mybatis驱动--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--druid数据源--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${druid}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--shardingsphere最新版本--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;sharding-jdbc-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.0.0-RC1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--lombok实体工具--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;application.properties&quot;&gt;2、application.properties&lt;/h4&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;server.port=8088
#指定mybatis信息
mybatis.config-location=classpath:mybatis-config.xml

spring.shardingsphere.datasource.names=master,slave0
# 数据源 主库
spring.shardingsphere.datasource.master.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.master.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.master.url=jdbc:mysql://localhost:3306/master?characterEncoding=utf-8
spring.shardingsphere.datasource.master.username=root
spring.shardingsphere.datasource.master.password=123456
# 数据源 从库
spring.shardingsphere.datasource.slave0.type=com.alibaba.druid.pool.DruidDataSource
spring.shardingsphere.datasource.slave0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.slave0.url=jdbc:mysql://localhost:3306/slave?characterEncoding=utf-8
spring.shardingsphere.datasource.slave0.username=root
spring.shardingsphere.datasource.slave0.password=123456

# 读写分离
spring.shardingsphere.masterslave.load-balance-algorithm-type=round_robin
spring.shardingsphere.masterslave.name=ms
spring.shardingsphere.masterslave.master-data-source-name=master
spring.shardingsphere.masterslave.slave-data-source-names=slave0
#打印sql
spring.shardingsphere.props.sql.show=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sharding-JDBC可以通过&lt;code&gt;Java&lt;/code&gt;，&lt;code&gt;YAML&lt;/code&gt;，&lt;code&gt;Spring命名空间&lt;/code&gt;和&lt;code&gt;Spring Boot Starter&lt;/code&gt;四种方式配置，开发者可根据场景选择适合的配置方式。具体可以看官网。&lt;/p&gt;
&lt;h4 id=&quot;usercontroller&quot;&gt;3、UserController&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class UserController {

    @Autowired
    private UserService userService;
    /**
     * @Description: 保存用户
     */
    @PostMapping(&quot;save-user&quot;)
    public Object saveUser() {
        return userService.saveOne(new User(&quot;小小&quot;, &quot;女&quot;, 3));
    }
    /**
     * @Description: 获取用户列表
     */
    @GetMapping(&quot;list-user&quot;)
    public Object listUser() {
        return userService.list();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三测试验证&quot;&gt;&lt;span&gt;三、测试验证&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;读数据&quot;&gt;1、读数据&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191009185402278-1091601392.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现读取的数据是Slave库的数据。我们再来看控制台打印的SQL。可以看到读操作是Slave库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191009185411133-1376483500.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;写数据&quot;&gt;2、写数据&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;请求&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localhost:8088/save-user?name=小小&amp;amp;sex=女&amp;amp;age=3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;查看Mater数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191009185420244-1105231293.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现Master数据库已经多了一条数据了，再看控制台打印的SQL。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201910/1090617-20191009185429389-1675126607.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候如果去看Slave库的话这条新增的数据是没有的，因为没有同步过去。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github地址&lt;/code&gt;：&lt;a href=&quot;https://github.com/yudiandemingzi/spring-boot-sharding-sphere&quot; class=&quot;uri&quot;&gt;https://github.com/yudiandemingzi/spring-boot-sharding-sphere&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://shardingsphere.apache.org/document/current/cn/overview/&quot;&gt;ShardingSphere中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://shardingsphere.apache.org/&quot;&gt;ShardingSphere官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://github.com/apache/incubator-shardingsphere&quot;&gt;Shardingsphere Github库&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(18）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Fri, 11 Oct 2019 15:47:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>分库分表(3) ShardingSphere实现读写分离 有关ShardingSphere概念前面写了两篇博客: 1、 '分库分表(1) 理论' 2、 '分库分表(2) ShardingSphere(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11656205.html</dc:identifier>
</item>
<item>
<title>Linux被中断的系统调用 - 原野追逐</title>
<link>http://www.cnblogs.com/songhe364826110/p/11657198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songhe364826110/p/11657198.html</guid>
<description>&lt;p&gt;慢系统调用，指的是可能永远无法返回，从而使进程永远阻塞的系统调用，比如无客户连接时的accept、无输入时的read都属于慢速系统调用。&lt;br/&gt;在Linux中，当阻塞于某个慢系统调用的进程捕获一个信号，则该系统调用就会被中断，转而执行信号处理函数，这就是被中断的系统调用。&lt;br/&gt;然而，当信号处理函数返回时，有可能发生以下的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果信号处理函数是用signal注册的，系统调用会自动重启，函数不会返回&lt;/li&gt;
&lt;li&gt;如果信号处理函数是用sigaction注册的
&lt;ul&gt;&lt;li&gt;默认情况下，系统调用不会自动重启，函数将返回失败，同时errno被置为EINTR&lt;/li&gt;
&lt;li&gt;只有中断信号的SA_RESTART标志有效时，系统调用才会自动重启&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们编写代码，分别验证上述几种情形，其中系统调用选择read，中断信号选择SIGALRM，中断信号由alarm产生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用signal&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

void handler(int s)
{
    printf(&quot;read is interrupt by signal handler\n&quot;);
    return;
}

int main()
{
    char buf[10];
    int nread = 0;

    signal(SIGALRM, handler);
    alarm(2);

    printf(&quot;read start\n&quot;);
    nread = read(STDIN_FILENO, buf, sizeof(buf));
    printf(&quot;read return\n&quot;);

    if ((nread &amp;lt; 0) &amp;amp;&amp;amp; (errno == EINTR))
    {
        printf(&quot;read return failed, errno is EINTR\n&quot;);
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201910/1053346-20191011215420221-257079465.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用sigaction + 默认情况&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

void handler(int s)
{
    printf(&quot;read is interrupt by signal handler\n&quot;);
    return;
}

int main()
{
    char buf[10];
    int nread = 0;
    struct sigaction act;

    sigemptyset(&amp;amp;act.sa_mask);
    act.sa_handler = handler;
    act.sa_flags = 0;  //不给SIGALRM信号设置SA_RESTART标志，使用sigaction的默认处理方式
    //act.sa_flag |= SA_INTERRUPT;  //SA_INTERRUPT是sigaction的默认处理方式，即不自动重启被中断的系统调用
    //实际上，不管act.sa_flags值为多少，只要不设置SA_RESTART，sigaction都是按SA_INTERRUPT处理的

    sigaction(SIGALRM, &amp;amp;act, NULL);
    alarm(2);

    printf(&quot;read start\n&quot;);
    nread = read(STDIN_FILENO, buf, sizeof(buf));
    printf(&quot;read return\n&quot;);

    if ((nread &amp;lt; 0) &amp;amp;&amp;amp; (errno == EINTR))
    {
        printf(&quot;read return failed, errno is EINTR\n&quot;);
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201910/1053346-20191011215448119-1507741252.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用sigaction + 指定SA_RESTART标志&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

void handler(int s)
{
    printf(&quot;read is interrupt by signal handler\n&quot;);
    return;
}

int main()
{
    char buf[10];
    int nread = 0;
    struct sigaction act;

    sigemptyset(&amp;amp;act.sa_mask);
    act.sa_handler = handler;
    act.sa_flags = 0;
    act.sa_flags |= SA_RESTART;  //给SIGALRM信号设置SA_RESTART标志

    sigaction(SIGALRM, &amp;amp;act, NULL);
    alarm(2);

    printf(&quot;read start\n&quot;);
    nread = read(STDIN_FILENO, buf, sizeof(buf));
    printf(&quot;read return\n&quot;);

    if ((nread &amp;lt; 0) &amp;amp;&amp;amp; (errno == EINTR))
    {
        printf(&quot;read return failed, errno is EINTR\n&quot;);
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201910/1053346-20191011215510502-798264153.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于对被中断系统调用处理方式的差异性，因此对应用程序来说，与被中断的系统调用相关的问题是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用程序无法保证总是知道信号处理函数的注册方式，以及是否设置了SA_RESTART标志&lt;/li&gt;
&lt;li&gt;可移植的代码必须显式处理关键函数的出错返回，当函数出错且errno等于EINTR时，可以根据实际需求进行相应处理，比如重启该函数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;int nread = read(fd, buf, 1024);

if (nread &amp;lt; 0)
{
    if (errno == EINTR)
    {
        //read被中断，其实不应该算作失败，可以根据实际需求进行处理，比如重写调用read，也可以忽略它
    }
    else
    {
        //read真正的读错误
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 11 Oct 2019 13:56:00 +0000</pubDate>
<dc:creator>原野追逐</dc:creator>
<og:description>慢系统调用，指的是可能永远无法返回，从而使进程永远阻塞的系统调用，比如无客户连接时的accept、无输入时的read都属于慢速系统调用。 在Linux中，当阻塞于某个慢系统调用的进程捕获一个信号，则该</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songhe364826110/p/11657198.html</dc:identifier>
</item>
<item>
<title>Windows10+YOLOv3实现检测自己的数据集（1）——制作自己的数据集 - 李是李雅普诺夫的李</title>
<link>http://www.cnblogs.com/lky-learning/p/11640180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lky-learning/p/11640180.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、数据标注&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在深度学习的目标检测任务中，首先要使用训练集进行模型训练。训练的数据集好坏决定了任务的上限。下面介绍两种常用的图像目标检测标注工具：&lt;/span&gt;&lt;strong&gt;Labelme&lt;/strong&gt;和&lt;strong&gt;LabelImg。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）Labelme&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Labelme适用于图像分割任务和目标检测任务的数据集制作，它来自该项目：&lt;a href=&quot;https://github.com/wkentaro/labelme&quot; target=&quot;_blank&quot;&gt;https://github.com/wkentaro/labelme&lt;/a&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照项目中的教程安装完毕后，应用界面如下图所示&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565629/201910/1565629-20191009141145670-1082459319.png&quot; alt=&quot;&quot; width=&quot;581&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它能够提供多边形、矩形、圆形、直线和点的图像标注，并将结果保存为 &lt;a href=&quot;http://www.json.org/&quot; target=&quot;_blank&quot;&gt;JSON&lt;/a&gt; 文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）LabelImg&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LabelImg适用于目标检测任务的数据集制作。它来自该项目：&lt;a href=&quot;https://github.com/tzutalin/labelImg&quot; target=&quot;_blank&quot;&gt;https://github.com/tzutalin/labelImg&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应用界面如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565629/201910/1565629-20191009145215490-1265493994.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它能够提供矩形的图像标注，并将结果保存为txt（YOLO）或xml（PascalVOC）格式。如果需要修改标签的类别内容，则在主目录data文件夹中的predefined_classes.txt文件中修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我使用的就是这一个标注软件，标注结果保存为xml格式，后续还需要进行标注格式的转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作快捷键：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;Ctrl + u  加载目录中的所有图像，鼠标点击Open dir同功能&lt;/p&gt;
&lt;p&gt;Ctrl + r  更改默认注释目标目录(xml文件保存的地址) &lt;/p&gt;
&lt;p&gt;Ctrl + s  保存&lt;/p&gt;
&lt;p&gt;Ctrl + d  复制当前标签和矩形框&lt;/p&gt;
&lt;p&gt;space     将当前图像标记为已验证&lt;/p&gt;
&lt;p&gt;w         创建一个矩形框&lt;/p&gt;
&lt;p&gt;d         下一张图片&lt;/p&gt;
&lt;p&gt;a         上一张图片&lt;/p&gt;
&lt;p&gt;del       删除选定的矩形框&lt;/p&gt;
&lt;p&gt;Ctrl++    放大&lt;/p&gt;
&lt;p&gt;Ctrl--    缩小&lt;/p&gt;
&lt;p&gt;↑→↓←        键盘箭头移动选定的矩形框&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;二、数据扩增&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在某些场景下的目标检测中，样本数量较小，导致检测的效果比较差，这时就需要进行数据扩增。本文介绍常用的6类数据扩增方式，包括裁剪、平移、改变亮度、加入噪声、旋转角度以及镜像。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;考虑到篇幅问题，将这一部分单列出来，详细请参考本篇博客：&lt;a href=&quot;https://www.cnblogs.com/lky-learning/p/11653861.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lky-learning/p/11653861.html&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三、将数据转换至COCO的json格式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先让我们明确一下几种格式,参考自【&lt;a href=&quot;https://github.com/spytensor/prepare_detection_dataset#22-voc&quot; target=&quot;_blank&quot;&gt;点此处&lt;/a&gt;】：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3.1 csv&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;csv/&lt;/code&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;labels.csv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;images/&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;image1.jpg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;image2.jpg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;code&gt;labels.csv&lt;/code&gt; 的形式:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;/path/to/image,xmin,ymin,xmax,ymax,label&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;例如:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;/mfs/dataset/face/image1.jpg,450,154,754,341,face&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;/mfs/dataset/face/image2.jpg,143,154,344,341,face&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3.2 voc&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;标准的voc数据格式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;VOC2007/&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;Annotations/&lt;/code&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;0d4c5e4f-fc3c-4d5a-906c-105.xml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0ddfc5aea-fcdac-421-92dad-144/xml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;ImageSets/&lt;/code&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Main/&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;train.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;val.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trainval.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;JPEGImages/&lt;/code&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;0d4c5e4f-fc3c-4d5a-906c-105.jpg&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;0ddfc5aea-fcdac-421-92dad-144.jpg&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;...&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3.3 COCO&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;coco/&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;annotations/&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;instances_train2017.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instances_val2017.json&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;images/&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;train2017/&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;0d4c5e4f-fc3c-4d5a-906c-105.jpg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;val2017&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;0ddfc5aea-fcdac-421-92dad-144.jpg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Json file 格式:&lt;/strong&gt; （imageData那一块太长了，不展示了）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
{
  &quot;version&quot;: &quot;3.6.16&quot;,
  &quot;flags&quot;: {},
  &quot;shapes&quot;: [
    {
      &quot;label&quot;: &quot;helmet&quot;,
      &quot;line_color&quot;: null,
      &quot;fill_color&quot;: null,
      &quot;points&quot;: [
        [
          131,
          269
        ],
        [
          388,
          457
        ]
      ],
      &quot;shape_type&quot;: &quot;rectangle&quot;
    }
  ],
  &quot;lineColor&quot;: [
    0,
    255,
    0,
    128
  ],
  &quot;fillColor&quot;: [
    255,
    0,
    0,
    128
  ],
  &quot;imagePath&quot;: &quot;004ffe6f-c3e2-3602-84a1-ecd5f437b113.jpg&quot;,
  &quot;imageData&quot;: &quot;&quot;   # too long ,so not show here
  &quot;imageHeight&quot;: 1080,
  &quot;imageWidth&quot;: 1920
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在上一节中提到，经过标注后的结果保存为xml格式，我们首先要把这些xml标注文件整合成一个csv文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整合代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import os
import glob
import pandas as pd
import xml.etree.ElementTree as ET

## xml文件的路径
os.chdir('./data/annotations/scratches')
path = 'C:/Users/Admin/Desktop/data/annotations/scratches' # 绝对路径
img_path = 'C:/Users/Admin/Desktop/data/images'

def xml_to_csv(path):
    xml_list = []
    for xml_file in glob.glob(path + '/*.xml'):  #返回所有匹配的文件路径列表。
        tree = ET.parse(xml_file)
        root = tree.getroot()

        for member in root.findall('object'):
#            value = (root.find('filename').text,
#                     int(root.find('size')[0].text),
#                     int(root.find('size')[1].text),
#                     member[0].text,
#                     int(member[4][0].text),
#                     int(member[4][1].text),
#                     int(member[4][2].text),
#                     int(member[4][3].text)
#                     )
            value = (img_path +'/' + root.find('filename').text,
                     int(member[4][0].text),
                     int(member[4][1].text),
                     int(member[4][2].text),
                     int(member[4][3].text),
                     member[0].text
                     )
            xml_list.append(value)
    #column_name = ['filename', 'width', 'height', 'class', 'xmin', 'ymin', 'xmax', 'ymax']
    column_name = ['filename', 'xmin', 'ymin', 'xmax', 'ymax', 'class']
    xml_df = pd.DataFrame(xml_list, columns=column_name)
    return xml_df

if __name__ == '__main__':
    image_path = path
    xml_df = xml_to_csv(image_path)
    ## 修改文件名称
    xml_df.to_csv('scratches.csv', index=None)
    print('Successfully converted xml to csv.')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当显示 &lt;/span&gt;Successfully converted xml to csv &lt;span&gt;后，我们就得到了整理后的标记文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在有些模型下，有了图像数据和csv格式的标注文件后，就可以进行训练了。但是在YOLOv3中，标记文件的类型为COCO的json格式，因此我们还得将其转换至json格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;转换代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;87&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import os
import json
import numpy as np
import pandas as pd
import glob
import cv2
import shutil
from IPython import embed
from sklearn.model_selection import train_test_split
np.random.seed(41)

# 0为背景
classname_to_id = {&quot;scratches&quot;: 1,&quot;inclusion&quot;: 2}

class Csv2CoCo:

    def __init__(self,image_dir,total_annos):
        self.images = []
        self.annotations = []
        self.categories = []
        self.img_id = 0
        self.ann_id = 0
        self.image_dir = image_dir
        self.total_annos = total_annos

    def save_coco_json(self, instance, save_path):
        json.dump(instance, open(save_path, 'w'), ensure_ascii=False, indent=2)  # indent=2 更加美观显示

    # 由txt文件构建COCO
    def to_coco(self, keys):
        self._init_categories()
        for key in keys:
            self.images.append(self._image(key))
            shapes = self.total_annos[key]
            for shape in shapes:
                bboxi = []
                for cor in shape[:-1]:
                    bboxi.append(int(cor))
                label = shape[-1]
                annotation = self._annotation(bboxi,label)
                self.annotations.append(annotation)
                self.ann_id += 1
            self.img_id += 1
        instance = {}
        instance['info'] = 'spytensor created'
        instance['license'] = ['license']
        instance['images'] = self.images
        instance['annotations'] = self.annotations
        instance['categories'] = self.categories
        return instance

    # 构建类别
    def _init_categories(self):
        for k, v in classname_to_id.items():
            category = {}
            category['id'] = v
            category['name'] = k
            self.categories.append(category)

    # 构建COCO的image字段
    def _image(self, path):
        image = {}
        img = cv2.imread(self.image_dir + path)
        image['height'] = img.shape[0]
        image['width'] = img.shape[1]
        image['id'] = self.img_id
        image['file_name'] = path
        return image

    # 构建COCO的annotation字段
    def _annotation(self, shape,label):
        # label = shape[-1]
        points = shape[:4]
        annotation = {}
        annotation['id'] = self.ann_id
        annotation['image_id'] = self.img_id
        annotation['category_id'] = int(classname_to_id[label])
        annotation['segmentation'] = self._get_seg(points)
        annotation['bbox'] = self._get_box(points)
        annotation['iscrowd'] = 0
        annotation['area'] = 1.0
        return annotation

    # COCO的格式： [x1,y1,w,h] 对应COCO的bbox格式
    def _get_box(self, points):
        min_x = points[0]
        min_y = points[1]
        max_x = points[2]
        max_y = points[3]
        return [min_x, min_y, max_x - min_x, max_y - min_y]
    # segmentation
    def _get_seg(self, points):
        min_x = points[0]
        min_y = points[1]
        max_x = points[2]
        max_y = points[3]
        h = max_y - min_y
        w = max_x - min_x
        a = []
        a.append([min_x,min_y, min_x,min_y+0.5*h, min_x,max_y, min_x+0.5*w,max_y, max_x,max_y, max_x,max_y-0.5*h, max_x,min_y, max_x-0.5*w,min_y])
        return a
   

if __name__ == '__main__':
    
    ## 修改目录
    csv_file = &quot;data/annotations/scratches/scratches.csv&quot;
    image_dir = &quot;data/images/&quot;
    saved_coco_path = &quot;./&quot;
    # 整合csv格式标注文件
    total_csv_annotations = {}
    annotations = pd.read_csv(csv_file,header=None).values
    for annotation in annotations:
        key = annotation[0].split(os.sep)[-1]
        value = np.array([annotation[1:]])
        if key in total_csv_annotations.keys():
            total_csv_annotations[key] = np.concatenate((total_csv_annotations[key],value),axis=0)
        else:
            total_csv_annotations[key] = value
    # 按照键值划分数据
    total_keys = list(total_csv_annotations.keys())
    train_keys, val_keys = train_test_split(total_keys, test_size=0.2)
    print(&quot;train_n:&quot;, len(train_keys), 'val_n:', len(val_keys))
    ## 创建必须的文件夹
    if not os.path.exists('%ssteel/annotations/'%saved_coco_path):
        os.makedirs('%ssteel/annotations/'%saved_coco_path)
    if not os.path.exists('%ssteel/images/train/'%saved_coco_path):
        os.makedirs('%ssteel/images/train/'%saved_coco_path)
    if not os.path.exists('%ssteel/images/val/'%saved_coco_path):
        os.makedirs('%ssteel/images/val/'%saved_coco_path)
    ## 把训练集转化为COCO的json格式
    l2c_train = Csv2CoCo(image_dir=image_dir,total_annos=total_csv_annotations)
    train_instance = l2c_train.to_coco(train_keys)
    l2c_train.save_coco_json(train_instance, '%ssteel/annotations/instances_train.json'%saved_coco_path)
    for file in train_keys:
        shutil.copy(image_dir+file,&quot;%ssteel/images/train/&quot;%saved_coco_path)
    for file in val_keys:
        shutil.copy(image_dir+file,&quot;%ssteel/images/val/&quot;%saved_coco_path)
    ## 把验证集转化为COCO的json格式
    l2c_val = Csv2CoCo(image_dir=image_dir,total_annos=total_csv_annotations)
    val_instance = l2c_val.to_coco(val_keys)
    l2c_val.save_coco_json(val_instance, '%ssteel/annotations/instances_val.json'%saved_coco_path)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，我们的数据预处理工作就做好了&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;四、参考资料&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;https://blog.csdn.net/sty945/article/details/79387054&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;https://blog.csdn.net/saltriver/article/details/79680189&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;https://www.ctolib.com/topics-44419.html&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;https://www.zhihu.com/question/20666664&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;https://github.com/spytensor/prepare_detection_dataset#22-voc&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;https://blog.csdn.net/chaipp0607/article/details/79036312&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Fri, 11 Oct 2019 13:42:00 +0000</pubDate>
<dc:creator>李是李雅普诺夫的李</dc:creator>
<og:description>本文将从以下三个方面介绍如何制作自己的数据集 数据标注 数据扩增 将数据转化为COCO的json格式 参考资料 一、数据标注 在深度学习的目标检测任务中，首先要使用训练集进行模型训练。训练的数据集好坏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lky-learning/p/11640180.html</dc:identifier>
</item>
<item>
<title>QR 码详解（上） - abatei</title>
<link>http://www.cnblogs.com/abatei/p/11655984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abatei/p/11655984.html</guid>
<description>&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205110253-2109142111.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;由上图可知，版本1图形被划分为21×21个小方块，模块指的就是这些小方块，是 QR 码绘制的最小单元，在绘制 QR 码时，将存在数据的模块填充为深色，最终组成 QR 码图形。下图是版本40的模块图，由177×177个小方块组成。&lt;/p&gt;&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205127296-666074382.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 2.2 寻像图形&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;寻像图形包括三个相同的位置探测图形，分别位于二维码左上角、右上角、左下角，每个位置探测图形由7×7个模块组成如下图所示：&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205425845-1025030995.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;符号中其他地方遇到类似图形的可能性极小，因此可以在视场中迅速地识别可能的 QR 码符号。识别组成寻像图形的三个位置探测图形，可以明确地确定视场中符号的位置和方向。下图是版本1和版本6的寻像图形，由图可知，版本号越高，寻像图形在整个图案中所占比例越小。&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205442934-95353057.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3 位置探测图形分隔符&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为方便识别位置探测图形，在每个位置探测图形和编码区域之间有宽度为 1 个模块的分隔符，如下图黄色区域所示。此区域应全为空白，不能填入数据。&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205517865-1358641773.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.4 定位图形&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;水平和垂直定位图形分别为一个模块宽的一行和一列，由深色与浅色模块交替组成，其开始和结尾都是深色模块。水平和垂直定位图形分别位于第6行和第6列（行、列由0开始计数），并且避开位置探测图形。它们的作用是确定符号的密度和版本，提供决定模块坐标的基准位置。下图是绘制了定位图形后的版本1和版本6图案。&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205545160-1053138356.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.5 校正图形&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;校正图形作为一个固定的参照图形，在图像有一定程度损坏的情况下，译码软件可以通过它同步图像模块的坐标映像。每个校正图形由5×5模块组成。如下图所示：&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205609886-1381701257.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;校正图形的数量视符号和版本号而定，版本1没有校正图形，版本2及以上均含有校正图形。校正图形的数量视 QR 码的版本号而定。下表列出了前14个版本的数据，完整数据请查看国家标准 GB/T 18284-2000 中的附录 E。&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205620886-756213640.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;下面讲讲如何看懂中心模块的行/列坐标值。例如在版本 7 中，表中给出值 6、22 和 38。则校正图形的中心点位置行、列坐标为（6，22）（22，6）（22，22）（22.38）（38，22）（38，38）。由于坐标（6，6）（6，38）（38，6）坐标位置被位置探测图形占据，因此，这些坐标位置没有放置校正图形。说白了就是将中心模块的行/列坐标值中的每个值分别与自己及其他值组成坐标，然后删除左上、右上、左下坐标，即得出结果。&lt;/p&gt;
&lt;p&gt;下图是版本 1 及版本 7 的校正图形：&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205638738-808797826.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;下图是版本 15 及版本 40 的校正图形：&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011205649950-264143435.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;没有固定公式计算中心模块的行/列坐标值，但观察以上 4 张校正图形，可以发现，QR 码设计者在选择坐标值时，使得第一行和第一列校正图形正好融合进定位图形，不会使定位图形遭到破坏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 数据编码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;各种用于图像识别的功能图形已经安放完毕，下一步就是对数据进行编码了。标准 QR 码可编码数据类型有四种：数字、字母数字、8位字节和 Kanji，其中 Kanji 为日文日文字符。我们国家标准 GB/T 18284-2000 增加了 QR 码的表示范围。下表是 QR 码可表示的数据类型及其相应的模式指示符。&lt;/p&gt;

&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;模式&lt;/td&gt;
&lt;td&gt;指示符 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;模式&lt;/td&gt;
&lt;td&gt;指示符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ECI&lt;/td&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;日文 &lt;/td&gt;
&lt;td&gt;1000 &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数字&lt;/td&gt;
&lt;td&gt;0001 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;中文&lt;/td&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;字母数字&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;FNC1&lt;/td&gt;
&lt;td&gt;0101（第一位置）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8位字节&lt;/td&gt;
&lt;td&gt;0100 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;FNC1&lt;/td&gt;
&lt;td&gt;1001（第二位置）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;表 1：模式指示符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ECI 是什么东西，我很想搞懂，但很遗憾网上几乎没有资料，AIM ECI 规范的外文资料，需收费下载。没办法，等以后再说吧。现在只知道 AIM 是一家公司，ECI 是规范，有了这个规范，有了这个东西，可以使用二维码装载各类不同的字符集，也可使接收系统在数据被使用之前知道做哪些特定的扩展或解密处理。&lt;/p&gt;
&lt;p&gt;FNC1 相信读过前面写的《条码技术》这篇文章中的 GS1-128 条码的都应当很熟悉，这类编码是专为 GS1 标准准备的。本文仅针对数字、字母数字、8 位字节以及 FNC1 模式进行讲解，示例程序也只实现这四种编码方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1 数字模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数字模式只能对十进制数字 0~9 进行编码，通常的密度为 10 位表示 3 个字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.1 将数字转换为位流&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将要表示的数字从左边开始每三位分为一组，然后将每组数据转换为 10 位二进制（10 位二进制可表示的最大数字为 1023）。如果最后一组数字只剩两位，则使用 7 位二进制表示（7 位二进制可表示的最大数字为 127）这两个数字。如果最后一组数字只剩一位，则使用4位二进制表示最后一个数字（4 位二进制可表示的最大数字为 15）。将二进制数据连接起来并在前面加上模式指示符和字符计数指示符。&lt;/p&gt;
&lt;p&gt;**【例1】：** 数字`01234567`：&lt;/p&gt;
&lt;p&gt;1. 分为 3 位一组：012  345  67&lt;/p&gt;
&lt;p&gt;2. 将每组转换为二进制：&lt;/p&gt;
&lt;p&gt;    012 -&amp;gt; 0000001100&lt;/p&gt;
&lt;p&gt;    345 -&amp;gt; 0101011001&lt;/p&gt;
&lt;p&gt;     67 -&amp;gt; 1000011&lt;/p&gt;
&lt;p&gt;3. 将二进制连接为一个序列：0000001100 0101011001 1000011&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.2  将字符计数指示符转换为二进制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符计数指示符表示装载字符的个数，长度随不同的 QR 码版本以及模式而不同。表 2 列出了各版本及模式所对应的字符计数指示符的长度。&lt;/p&gt;

&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;版本&lt;/td&gt;
&lt;td&gt;数字模式&lt;/td&gt;
&lt;td&gt;字母数字模式 &lt;/td&gt;
&lt;td&gt;8 位字节模式 &lt;/td&gt;
&lt;td&gt;中国汉字模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1~9&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10~26&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;27~40 &lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;span&gt;表 2：字符计数指示符的位数&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;数据的数字位数为 8，查上表数字模式列，如果使用版本 1 来表示，则位数为 10。最终：&lt;/p&gt;
&lt;p&gt;8 -&amp;gt; 0000001000&lt;/p&gt;
&lt;p&gt;#### 加入模式指示符及字符计数指示符&lt;/p&gt;
&lt;p&gt;查表 1 ，数字模式的指示符为 0001。以【模式指示符 + 字符计数指示符 + 数字位流】的方式连接数据最终位流为：&lt;/p&gt;
&lt;p&gt;0001 0000001000 0000001100 0101011001 1000011&lt;/p&gt;
&lt;p&gt;接下来再做一个例子加深理解：&lt;/p&gt;
&lt;p&gt;**【例2】：** 数字`0123456789012345`：&lt;/p&gt;
&lt;p&gt;1. 分为 3 位一组：012  345  678  901  234  5&lt;/p&gt;
&lt;p&gt;2. 将每组转换为二进制：&lt;/p&gt;
&lt;p&gt;    012 -&amp;gt; 0000001100&lt;/p&gt;
&lt;p&gt;    345 -&amp;gt; 0101011001&lt;/p&gt;
&lt;p&gt;    678 -&amp;gt; 1010100110&lt;/p&gt;
&lt;p&gt;    901 -&amp;gt; 1110000101&lt;/p&gt;
&lt;p&gt;    234 -&amp;gt; 0011101010&lt;/p&gt;
&lt;p&gt;      5 -&amp;gt; 0101&lt;/p&gt;
&lt;p&gt;3. 将二进制连接为一个序列：&lt;/p&gt;
&lt;p&gt;    0000001100 0101011001 1010100110 1110000101 0011101010 0101&lt;/p&gt;
&lt;p&gt;4. 数字位数为 16，使用版本 1 表示，位数为 10。最终：&lt;/p&gt;
&lt;p&gt;16 -&amp;gt; 0000010000&lt;/p&gt;
&lt;p&gt;5. 加上数字模式的指示符 0001 最终位流为：&lt;/p&gt;
&lt;p&gt;    0001 0000010000 0000001100 0101011001 1010100110 1110000101 0011101010 0101&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2 字母数字模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字母数字模式对 45 个字符的字符集进行编码，即：10 个数字 0~9，26 个大写字母 A~Z，以及 9 个符号 SP、$、%、*、+、-、.、/。通常情况下，两个输入字符用 11 位表示。下表是 45 个字符及其编码：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;SP&lt;/td&gt;
&lt;td&gt;36&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;39&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;41&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;43&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;:&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;要完整表示 45 个字符中的一个，需要至 6 个位的二进制数字（$2^6=64$），那么每两个字符需要占用 12 个位的空间。QR 码使用了另一种编码方法，将表示两个字符压缩为使用 11 个位的空间。&lt;/p&gt;
&lt;p&gt;将输入的数字分为两个字符一组，将左边的字符的值乘以 45 与第二个字符的值相加，将所得的结果转换为 11 位二进制数。最大字符组为&quot;::&quot;（44×45+44=2024，而2&lt;sup&gt;11&lt;/sup&gt;=2048）。如果输入的数据的字符不是 2 的倍数，将最后一个字符编码为 6 位二进制数。将所得的二进制数连接起来并在前面加上模式指示符和字符计数指示符，得到最终编码。&lt;/p&gt;
&lt;p&gt;**【例 3】：** 数据`AC-42`，QR 码版本号 1：&lt;/p&gt;
&lt;p&gt;1. 根据表 5 查出字符的值：AC-42 -&amp;gt; (10,12,41,4,2)&lt;/p&gt;
&lt;p&gt;2. 将结果分为 2 个一组：(10,12)(41,4)(2)&lt;/p&gt;
&lt;p&gt;3. 将每组数据转换为 11 位二进制数：&lt;/p&gt;
&lt;p&gt;    (10,12) -&amp;gt; 10×45+12=462 -&amp;gt; 00111001110&lt;/p&gt;
&lt;p&gt;    (41,4) -&amp;gt; 41×45+4=1849 -&amp;gt; 11100111001&lt;/p&gt;
&lt;p&gt;    (2) -&amp;gt; 2 -&amp;gt; 000010&lt;/p&gt;
&lt;p&gt;4. 二进制数据顺次连接得到数据位流： 00111001110 11100111001 000010&lt;/p&gt;
&lt;p&gt;5. 字符数为 5，查表2，使用 9 位二进制数表示。将字符计数指示符转换为二进制，&lt;/p&gt;
&lt;p&gt;    5 -&amp;gt; 000000101&lt;/p&gt;
&lt;p&gt;6. 查表 1，模式指示符为 0010。以【模式指示符 + 字符计数指示符 + 数字位流】的方式连接数据最终位流为：&lt;/p&gt;
&lt;p&gt;    0010 000000101 00111001110 11100111001 000010&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.3  8 位字节模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 8 位字节模式中，一个 8 位码字直接表示一个输入数据字符的 ASCII 字符值（ASCII 译码表请查[这里](http://iotxfd.cn/demo/ascii.html)）。即密度为每个字符 8 位。将二进制数据连接起来并在前面加上模式指示符和字符计数指示符，得到最终编码。&lt;/p&gt;
&lt;p&gt;**【例 4】：** 数据`Ab&amp;gt;Cd`，QR 码版本号 1：&lt;/p&gt;
&lt;p&gt;1. 在 ASCII表中查出各字符的值，并转换为 8 位二进制：&lt;/p&gt;
&lt;p&gt;    A -&amp;gt; 65 -&amp;gt; 01000001&lt;/p&gt;
&lt;p&gt;    b -&amp;gt; 98 -&amp;gt; 01100010&lt;/p&gt;
&lt;p&gt;    `&amp;gt;` -&amp;gt; 62 -&amp;gt; 00111110&lt;/p&gt;
&lt;p&gt;    C -&amp;gt; 67 -&amp;gt; 01000011&lt;/p&gt;
&lt;p&gt;    d -&amp;gt; 100 -&amp;gt; 01100100&lt;/p&gt;
&lt;p&gt;2.  二进制数据顺次连接得到数据位流：01000001 01100010 00111110 01000011 01100100&lt;/p&gt;
&lt;p&gt;3. 字符数为 5，查表2，使用 8 位二进制数表示。将字符计数指示符转换为二进制，&lt;/p&gt;
&lt;p&gt;    5 -&amp;gt; 00000101&lt;/p&gt;
&lt;p&gt;4. 查表 1，模式指示符为 0100。以【模式指示符 + 字符计数指示符 + 数字位流】的方式连接数据最终位流为：&lt;/p&gt;
&lt;p&gt;    0100 00000101 01000001 01100010 00111110 01000011 01100100&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.4 混合模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前在学习 Code 128 编码时大家应该还记得，为了达到符号长度最小的目的，Code 128 条码支持混合编码的方式。QR 码也支持以混合方式进行编码。其基本结构为【模式指示符 + 字符计数指示符 + 数据】，其后紧跟下一段的指示符开始另一段。下图为有 n 段数据的结构。&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011211211747-1750637995.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;由于 GS1 标准仅支持 ASCII 码，这里只针对数字模式、字母数字模式、8 位字节模式的混合编码进行讨论。以下是针对上述模式的编码规则，完整编码规则请参考 GB/T 18284-2000 的附录 H。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.4.1 位流长度最优化的编码规则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下列是形成最短位流的算法的基础。在方括号中的字符数如[5,7,9]分别用于版本 1~9，10~26 和版本 27~40。&lt;/p&gt;
&lt;p&gt;1. 选择初始模式&lt;/p&gt;
&lt;p&gt;    * 如果初始输入数据是在 8 位字节的二进制字符的专有子集中，选择 8 位字节模式；&lt;/p&gt;
&lt;p&gt;    * 如果初始输入数据是在字母数字字符集的专有子集中，并且如果字符个数少于[6,7,8]，其后紧跟 8 位字节专有子集中的数据，那么选择 8 位字节模式，否则选择字母数据模式；&lt;/p&gt;
&lt;p&gt;    * 如果初始数据是数字，并且如果数字个数少于[4,4,5]，其后紧跟 8 位字节字符集专有子集中的数据，那么选择 8 位字节模式，否则如果少于[6,7,8]后随字母数字字符集的专有子集中的数据，那么选择字母数字模式，否则选择数字模式。&lt;/p&gt;
&lt;p&gt;2. 在 8 位字节模式中&lt;/p&gt;
&lt;p&gt;    * 如果有不少于[6,8,9]的数字字符序列出现在来自 8 位字节二进制字符集的专有子集的多个数据前，那么转至数字模式；&lt;/p&gt;
&lt;p&gt;    * 如果有字母数字字符集的专有子集的不少于[11,15,16]的字符序列出现在来自 8 位字节二进制字符集的专有子集的数据前，那么转至字母数字模式。&lt;/p&gt;
&lt;p&gt;3. 在字母数字模式中&lt;/p&gt;
&lt;p&gt;    * 如果有 8 位字节字符集的专有子集的一个或多个字符出现，转至 8 位字节模式；&lt;/p&gt;
&lt;p&gt;    * 如果有不少于[13,15,17]的数字字符数据序列在来自字母数字字符集的专有子集的数据前出现，转至数字模式。&lt;/p&gt;
&lt;p&gt;4. 在数字模式中&lt;/p&gt;
&lt;p&gt;    * 如果有一个或多个来自 8 位字节的专有子集中的字符出现，转至 8 位字节模式；&lt;/p&gt;
&lt;p&gt;    * 如果有一个或多个字母数字的专有子集中的字符出现，转至字母数字模式。&lt;/p&gt;
&lt;p&gt;&amp;gt; 编者注：上述规则摘抄至 GB/T 18284-2000，最后一句是有问题或者不完善的。如果在数字模式中出现字符`Aabcd`，因为`A`属于字母数字字符集，而`abcd`只属于 8 位字节字符集。此时按最后一句话，需先转换为字母数字模式，加入字符`A`，然后马上又转换为 8 位字节模式。很显然，这样做浪费了空间。由于字母数字字符集是 8 位字节字符集的子集，正确的做法应当是转换为 8 位字节模式，然后加入字符`Aabcd`。&lt;/p&gt;
&lt;p&gt;**【例 5】：** 数据`123456ABC123`，QR 码版本号 1：&lt;/p&gt;
&lt;p&gt;1. 根据编码规则，首先应选择数字模式作为初始模式：0001&lt;/p&gt;
&lt;p&gt;2. 加入字符计数指示符：6 -&amp;gt; 0000000110&lt;/p&gt;
&lt;p&gt;3. 加入 123 编码：123 -&amp;gt; 0001111011&lt;/p&gt;
&lt;p&gt;4. 加入 456 编码：456 -&amp;gt; 0111001000&lt;/p&gt;
&lt;p&gt;5. 根据编码规则，转换为字母数字模式：0010&lt;/p&gt;
&lt;p&gt;6. 加入字符计数指示符：6 -&amp;gt; 000000110&lt;/p&gt;
&lt;p&gt;7. 加入 AB 编码：(10,11) -&amp;gt; 10×45+11=461 -&amp;gt; 00111001101&lt;/p&gt;
&lt;p&gt;8. 加入 C1 编码：(12,1) -&amp;gt; 12×45+1=541 -&amp;gt; 01000011101&lt;/p&gt;
&lt;p&gt;9. 加入 23 编码：(2,3) -&amp;gt; 2×45+3=93 -&amp;gt; 00001011101&lt;/p&gt;
&lt;p&gt;将以上生成的二进制数据从上至下连接，生成最终位流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.5 FNC1 模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FNC1 模式有两种模式指示符，用于标识按特定的行业或应用格式化信息的符号。FNC1 在第一位置时支持 GS1 标准，FNC1 在第二位置时支持按 AIM 认可的特定行业或者特定应用规范格式化信息。由于 AIM 查不到资料，这里只介绍 FNC1 第一位置模式，即模式指示符为：0101。&lt;/p&gt;
&lt;p&gt;在 GS1-128 中，FNC1 用于数据段分隔，而 QR 码中没有专用的 FNC1 字符，在字母数字模式中用 % 字符代替，如果在数据中也有 % 符号出现，则 应按 %% 进行编码。在 8 位字节模式中用字符 GS（ASCII 值 29）代替。&lt;/p&gt;
&lt;p&gt;&amp;gt; 编者注：个人感觉，这个设计方式相比 GS1-128 来说，并不太合理。即使数据只是纯数字，但只要在其中需要分段，安置 FNC1 ，就必须转为字母数字模式，如果后面还有足够多的数字，还得再次转回来。这样做的成本太高了。数字模式，还有部分未使用的编码，应当有自已的 FNC1，即使这个编码占据 10 个位，还是合算的。&lt;/p&gt;
&lt;p&gt;**【例 6】：** 数据`(02)66901234000049(17)050101(37)10(10)ABC`，QR 码版本号 1：&lt;/p&gt;
&lt;p&gt;首先分析数据中的 AI：(02)表示物流单元内贸易项目，长度固定；(17)表示有效期，长度固定；(37)表示物流单元内贸易项目数量，长度不固定，需在此 AI 最后加入 FNC1；(10)表示批号，长度不固定，它为最后一个 AI，无需加入 FNC1 标志。最终编码变为：&lt;/p&gt;
&lt;p&gt;`(02)66901234000049(17)050101(37)10&amp;lt;FNC1&amp;gt;(10)ABC`&lt;/p&gt;
&lt;p&gt;编码过程：&lt;/p&gt;
&lt;p&gt;1. 将 FNC1 第一位置作为初始模式：0101&lt;/p&gt;
&lt;p&gt;2. 根据位流长度最优化的编码规则，加入数字模式指示符：0001&lt;/p&gt;
&lt;p&gt;3. 加入字符计数指示符：28 -&amp;gt; 0000011100&lt;/p&gt;
&lt;p&gt;4. 加入 026 编码：026 -&amp;gt; 0000011010&lt;/p&gt;
&lt;p&gt;5. 加入 690 编码：690 -&amp;gt; 1010110010&lt;/p&gt;
&lt;p&gt;6. 加入 123 编码：123 -&amp;gt; 0001111011&lt;/p&gt;
&lt;p&gt;7. 加入 400 编码：400 -&amp;gt; 0110010000&lt;/p&gt;
&lt;p&gt;8. 加入 004 编码：004 -&amp;gt; 0000000100&lt;/p&gt;
&lt;p&gt;9. 加入 917 编码：917 -&amp;gt; 1110010101&lt;/p&gt;
&lt;p&gt;10. 加入 050 编码：050 -&amp;gt; 0000110010&lt;/p&gt;
&lt;p&gt;11. 加入 101 编码：101 -&amp;gt; 0001100101&lt;/p&gt;
&lt;p&gt;12. 加入 371 编码：371 -&amp;gt; 0101110011&lt;/p&gt;
&lt;p&gt;13. 加入 0 编码：0 -&amp;gt; 0000&lt;/p&gt;
&lt;p&gt;14. 根据编码规则，转换为字母数字模式：0010&lt;/p&gt;
&lt;p&gt;15. 加入字符计数指示符：6 -&amp;gt; 000000110&lt;/p&gt;
&lt;p&gt;16. 加入 %1 编码：(38,1) -&amp;gt; 38×45+1=1711 -&amp;gt; 11010101111&lt;/p&gt;
&lt;p&gt;17. 加入 0A 编码：(0,10) -&amp;gt; 0×45+10=10 -&amp;gt; 00000001010&lt;/p&gt;
&lt;p&gt;18. 加入 BC 编码：(11,12) -&amp;gt; 11×45+12=507 -&amp;gt; 00111111011&lt;/p&gt;
&lt;p&gt;将以上生成的二进制数据从上至下连接，生成最终位流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.6  终止符&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;符号的数据结尾由紧跟在最后一个模式段后面的终止符序列 0000 表示，当数据位流数量正好填满符号容量时，它可以省略，或者当符号所余的容量不足 4 位时它可以截短。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.7  位流到码字的转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个模式段的位流需要按顺序连接在一起，最后添加终止符，除非数据位流正好填满符号容量。所得的数据位流将被分为一个个码字；所有码字长度都是 8 位，如果位流长度最后一个码字不足 8 位，则用二进制值为 0 的填充位填充至 8 位，填充位应加在数据位流最后 1 位（最低位）的后面。说白了就是将位流进行 8 位对齐。&lt;/p&gt;
&lt;p&gt;我们以【例 1】最终生成的数据位流为例说明上述过程。&lt;/p&gt;
&lt;p&gt;1. 【例 1】最终生成的数据位流：000000110001010110011000011&lt;/p&gt;
&lt;p&gt;2. 加入终止符 0000，（现在符号容量足够，不用考虑容量不足的情况）：&lt;/p&gt;
&lt;p&gt;    0000001100010101100110000110000&lt;/p&gt;
&lt;p&gt;3. 将数据位流划分为码字，这里在每 8 个位后加一个逗号表示：&lt;/p&gt;
&lt;p&gt;    00000011,00010101,10011000,0110000&lt;/p&gt;
&lt;p&gt;4. 我们发现最后一个码字只有 7 位数字，不足 8 位，补 1 个零，最终数据变为：&lt;/p&gt;
&lt;p&gt;    00000011,00010101,10011000,01100000&lt;/p&gt;
&lt;p&gt;最终【例 1】生成的数据使用了 4 个码字。&lt;/p&gt;
&lt;p&gt;接下来就要查表了，下表列出了各个版本 QR 码的码字容量，这里只列出一小部分，完整表格请参考 GB/T 18284-2000。&lt;/p&gt;
&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/29896/201910/29896-20191011213013553-652250023.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;注意表格中的红框部分，由于只使用了 4 个码字，我们完全可以选择最高纠错等级 H。所以最终选择为：版本 1 的 H 纠错等级 QR 码。在此等级中可放置 9 个码字，还剩余 5 个码字是不能放空的，需要交替填充码字 11101100 和 00010001，直至填满整个 9 个码字。&lt;/p&gt;
&lt;p&gt;5. 将空位填满至 9 个码字，最终数据变为：&lt;/p&gt;
&lt;p&gt;    00000011,00010101,10011000,01100000,11101100,00010001,11101100,00010001,11101100&lt;/p&gt;
&lt;p&gt;好！上半场结束，图多，还是分两篇写吧。下半场内容就比较抽象了。&lt;/p&gt;
</description>
<pubDate>Fri, 11 Oct 2019 13:18:00 +0000</pubDate>
<dc:creator>abatei</dc:creator>
<og:description>关于二维码，我查了下资料，现在基本都在用日本的 QR 码，PDF417以及汉信码日常基本看不到。原因在于各方面来说，的确是 QR 码最为优秀。所以我准备写一篇介绍 QR 码的文章，如果是写书，可能不方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/abatei/p/11655984.html</dc:identifier>
</item>
</channel>
</rss>