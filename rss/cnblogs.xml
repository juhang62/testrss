<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Effective Java 第三版——72. 赞成使用标准异常 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/10621893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/10621893.html</guid>
<description>&lt;blockquote readability=&quot;5.0845771144279&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;书中的源代码地址：&lt;a href=&quot;https://github.com/jbloch/effective-java-3e-source-code&quot; class=&quot;uri&quot;&gt;https://github.com/jbloch/effective-java-3e-source-code&lt;/a&gt;&lt;br/&gt;注意，书中的有些代码里方法是基于Java 9 API中的，所以JDK 最好下载 JDK 9以上的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;专家级程序员与经验较少的程序员之间的一个区别是，专家力争并通常实现高度的代码重用。代码重用是一件好事，异常也不例外。Java类库提供了一组异常，涵盖了大多数API的异常抛出需求。&lt;/p&gt;
&lt;p&gt;重用标准异常有几个好处。其中最主要的是，它使你的API更容易学习和使用，因为它符合程序员已经熟悉的既定约定。其次，使用你的API的程序更容易阅读，因为它们不会因为不熟悉的异常而混乱。最后(也是最不重要的)，更少的异常类意味着更小的内存占用和更少的加载类的时间。&lt;/p&gt;
&lt;p&gt;最常用的异常是IllegalArgumentException（条目 49）。 当调用者传入一个不合适的参数值时，通常抛出这个异常。 例如，如果调用者在表示某个操作重复次数的参数中传递了一个负数，则抛出此异常。&lt;/p&gt;
&lt;p&gt;另一个常用的异常是IllegalStateException。 如果由于接收对象的状态而调用是非法的，则通常会抛出异常。 例如，如果调用者试图使用尚未正确初始化之前的对象时，则抛出这个异常。&lt;/p&gt;
&lt;p&gt;可以说，每个错误的方法调用都可以归结为非法参数或状态，但是还有一些异常通常用于某些类型的非法参数和状态。如果调用者在禁止null值的参数中传递null，那么按照惯例，抛出NullPointerException，而不是IllegalArgumentException异常。类似地，如果调用者将表示索引的参数中的超出范围的值传递给序列，则应该抛出IndexOutOfBoundsException，而不是IllegalArgumentException。&lt;/p&gt;
&lt;p&gt;另一个可重用异常是ConcurrentModificationException。如果一个对象被设计为由单个线程使用(或与外部同步)，并且检测到它正在被并发地修改，则应该抛出该对象。这个异常最多是一个提示，因为无法可靠地检测并发修改。&lt;/p&gt;
&lt;p&gt;最后一个需要注意的标准异常是UnsupportedOperationException。如果对象不支持尝试的操作，则抛出此异常。它很少使用，因为大多数对象都支持它们的所有方法。此异常用于无法实现由其实现的接口定义的一个或多个Optional操作的类。例如，如果有人试图从仅支持追加（append-only ）的列表中删除元素，则将抛出此异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要直接重用Exception、RuntimeException、Throwable或Error&lt;/strong&gt;。将这些类视为抽象类。你不能对这些异常进行可靠的测试，因为它们是方法可能抛出的其他异常的父类。&lt;/p&gt;
&lt;p&gt;此表总结了最常见的重用异常:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IllegalArgumentException&lt;/td&gt;
&lt;td&gt;不合适的非null参数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IllegalStateException&lt;/td&gt;
&lt;td&gt;方法调用状态不适合的对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NullPointerException&lt;/td&gt;
&lt;td&gt;再禁止使用null的情况下参数值为null&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IndexOutOfBoundsException&lt;/td&gt;
&lt;td&gt;索引参数值越界&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ConcurrentModificationException&lt;/td&gt;
&lt;td&gt;在禁止并发修改对象的地方检测到该对象被并发修改&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;UnsupportedOperationException&lt;/td&gt;
&lt;td&gt;对象不支持方法&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;虽然到目前为止，这些是最常见的重用异常，但是在环境允许的情况下也可以重用其他异常。例如，如果正在实现诸如复数或有理数之类的算术对象，那么重用ArithmeticException和NumberFormatException是合适的。如果一个异常符合你的需要，那么继续使用它，但前提是抛出它的条件与异常文档描述一致：重用必须基于文档化的语义，而不仅仅是基于名称。另外，如果想添加更多的细节，可以随意子类化标准异常(条目 75)，但是请记住异常是可序列化的(第12章)。这本身就是，如果没有充分理由，不要编写自己的异常类的原因。&lt;/p&gt;
&lt;p&gt;选择重用哪个异常可能比较棘手，因为上面表格中的“使用场景”似乎并不相互排斥。考虑表示一副纸牌的对象的情况，假设有表示发一手牌的方法，该方法参数是一手牌的纸牌数量。如果调用者传递的值大于整副牌中剩余的牌的数量，则可以将其解释为IllegalArgumentException (handSize参数值过大)，或者是IllegalStateException(纸牌中包含的牌太少)。&lt;strong&gt;在这种情况下，规则是，如果没有参数值，则抛出IllegalArgumentException，否则抛出IllegalArgumentException异常&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 07:59:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 书中的源代码地址：https://github.com/jbloch/effective java 3e source code 注意，书中的有些代码里方法是基于Java 9 API中的，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/10621893.html</dc:identifier>
</item>
<item>
<title>Golang设计模式—简单工厂模式(Simple Factory Pattern) - SpiderShrimp</title>
<link>http://www.cnblogs.com/SpiderShrimp/p/10621896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SpiderShrimp/p/10621896.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们在做一款小型翻译软件，软件可以将德语、英语、日语都翻译成目标中文，并显示在前端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们会有三个具体的语言翻译结构体，或许以后还有更多，但现在分别是GermanTranslater、EnglishTranslater、JapaneseTranslater，他们都共同实现了一个接口Translator。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//翻译接口
type Translator interface {
    Translate(string) string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//德语翻译类
type GermanTranslator struct{}

func (*GermanTranslator) Translate(words string) string {

    return &quot;德语&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//英语翻译类
type EnglishTranslator struct{}

func (*EnglishTranslator) Translate(words string) string {

    return &quot;英语&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//日语翻译类
type JapaneseTranslator struct{}

func (*JapaneseTranslator) Translate(words string) string {

    return &quot;日语&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来在程序入口获取用户输入的文本，并将其翻译&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err)
        }
        time.Sleep(3 * time.Second)
    }()

    var lan int
    fmt.Printf(&quot;%s\r\n%s\r\n&quot;, &quot;以下是可翻译的语言种类，请输入代表数字&quot;, &quot;1：德语、2：英语、3：日语&quot;)
    fmt.Scanln(&amp;amp;lan)

    fmt.Println(&quot;请输入要翻译成中文的文本：&quot;)
    var inputWords string
    fmt.Scanln(&amp;amp;inputWords)

    var translator Translator

    //根据不同的语言种类，实例化不同的翻译类
    switch lan {
    case 1:
        translator = new(GermanTranslator)
    case 2:
        translator = new(EnglishTranslator)
    case 3:
        translator = new(JapaneseTranslator)
    default:
        panic(&quot;no such translator&quot;)
    }

    fmt.Println(translator.Translate(inputWords))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.aprilboy.com/wp-content/uploads/2019/03/translator.jpg&quot; alt=&quot;运行结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;违背了开闭原则，以后还可能有法语、俄语、阿拉伯语等其他翻译器，每一次添加翻译器都要在客户端代码增加对应的switch分支，维护成本高。倘若还有不止一处调用了创建逻辑，还要维护多处代码。&lt;/li&gt;
&lt;li&gt;违背了单一职责原则，客户端处理类的职责应该只是负责接收用户的输入并将其打印，现在还负责翻译类的创建逻辑，导致这个类的职责过多。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;改善&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决每次新增翻译类都要修改客户端的问题，我们引入一个很重要的设计原则，可以说每种设计模式都遵循着这个设计原则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计原则：&lt;/strong&gt;找出用中可能需要变化之处，并把它们独立出来，不要和那些不需要变化的代码混在一起。&lt;/p&gt;
&lt;p&gt;这样的话，每次当新的需求来临，我们只会改动到那些需要变化的地方，而不变的地方就不会被改动影响到。&lt;/p&gt;
&lt;p&gt;显然，翻译应用中容易变化的地方是生成翻译类的逻辑，因此我们把这部分职责抽出来，把它交给另外一个类去做（一般是一个静态方法），这个类就叫翻译工厂。而客户端再需要生成翻译类实例时，仅需调用翻译工厂提供的方法即可。就算以后翻译工厂会提供更多的翻译类，也不会修改到客户端的代码，因此也就有了我们的现在的简单工厂模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单工厂模式(Simple Factory Pattern)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UML类图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.aprilboy.com/wp-content/uploads/2019/03/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png&quot; alt=&quot;UML类图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是我们根据简单工厂模式再完善之前的代码，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工厂代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Create(lan int) Translator {
    var translator Translator

    //根据不同的语言种类，实例化不同的翻译类
    switch lan {
    case 1:
        translator = new(GermanTranslator)
    case 2:
        translator = new(EnglishTranslator)
    case 3:
        translator = new(JapaneseTranslator)
    default:
        panic(&quot;no such translator&quot;)
    }

    return translator
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err)
        }
        time.Sleep(3 * time.Second)
    }()

    var lan int
    fmt.Printf(&quot;%s\r\n%s\r\n&quot;, &quot;以下是可翻译的语言种类，请输入代表数字&quot;, &quot;1：德语、2：英语、3：日语&quot;)
    fmt.Scanln(&amp;amp;lan)

    fmt.Println(&quot;请输入要翻译成中文的文本：&quot;)
    var inputWords string
    fmt.Scanln(&amp;amp;inputWords)

    //客户端只关注如何获取翻译类，而不用关注创建翻译类的细节
    translator:=CreateTranslator(lan)

    fmt.Println(translator.Translate(inputWords))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将客户端和创建产品实例解耦开来，使客户端只需要关注如何获取实例。&lt;/li&gt;
&lt;li&gt;符合单一职责。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;增加新翻译类时还是需要改动工厂类，没有符合开闭原则。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当在代码里看到switch的时候，就应该思考是否用简单工厂模式。&lt;/p&gt;
&lt;p&gt;作者：胡金生&lt;br/&gt;出处：www.aprilboy.com&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 07:59:00 +0000</pubDate>
<dc:creator>SpiderShrimp</dc:creator>
<og:description>Golang设计模式——简单工厂模式 背景 假设我们在做一款小型翻译软件，软件可以将德语、英语、日语都翻译成目标中文，并显示在前端。 思路 我们会有三个具体的语言翻译结构体，或许以后还有更多，但现在分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SpiderShrimp/p/10621896.html</dc:identifier>
</item>
<item>
<title>《深入理解Java虚拟机》-----第7章 虚拟机类加载机制——Java高级开发必须懂的 - chen_hao</title>
<link>http://www.cnblogs.com/java-chen-hao/p/10579752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-chen-hao/p/10579752.html</guid>
<description>[unable to retrieve full-text content]代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 7.1 概述 上一章我们了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚</description>
<pubDate>Fri, 29 Mar 2019 07:55:00 +0000</pubDate>
<dc:creator>chen_hao</dc:creator>
<og:description>Golang设计模式——简单工厂模式 背景 假设我们在做一款小型翻译软件，软件可以将德语、英语、日语都翻译成目标中文，并显示在前端。 思路 我们会有三个具体的语言翻译结构体，或许以后还有更多，但现在分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SpiderShrimp/p/10621896.html</dc:identifier>
</item>
<item>
<title>Webpack 4教程 - 第七部分 减少打包体积与Tree Shaking - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/10621660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/10621660.html</guid>
<description>[unable to retrieve full-text content]在本次Webpack 4教程中，我们会更进一步讲述项目优化。我们会学习什么是tree shaking以及如何使用它。你会找到让Webpack 4中tree shaking运作起来所需要的东西，并知道怎样从中受益。开始吧！</description>
<pubDate>Fri, 29 Mar 2019 07:37:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>Golang设计模式——简单工厂模式 背景 假设我们在做一款小型翻译软件，软件可以将德语、英语、日语都翻译成目标中文，并显示在前端。 思路 我们会有三个具体的语言翻译结构体，或许以后还有更多，但现在分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SpiderShrimp/p/10621896.html</dc:identifier>
</item>
<item>
<title>程序员如何从0到1搭建自己的技术博客(Jekyll+GitHub Pages) - 周伟伟的技术博客</title>
<link>http://www.cnblogs.com/zwwhnly/p/10621642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwwhnly/p/10621642.html</guid>
<description>&lt;p&gt;记得刚毕业参加工作时，每天早上到公司后，都会逛逛博客园，看一下各位大牛前辈写的文章，也许是兴趣使然，当时就特别想搭建一个属于自己的独立的技术博客。&lt;/p&gt;
&lt;p&gt;时间就是过的这么快，转眼间这么多年过去了，我的这个梦想却一直未付诸行动，也就一直没有实现。&lt;/p&gt;
&lt;p&gt;在2018年底接近过年的时候，我的这个想法又特别的强烈，于是就花了很多时间去研究搭建个人技术博客的方法，功夫不负有心人，终于在2019年初实现了自己的这个梦想。&lt;/p&gt;
&lt;p&gt;在这个过程中，收获了很多，也看到了很多大牛的优秀的技术博客，本篇文章就记录下我的技术博客是如何从0到1搭建起来的，总结下自己的成果，也希望能帮助到有相同梦想的你。&lt;/p&gt;
&lt;h2 id=&quot;原来的认知&quot;&gt;1.原来的认知&lt;/h2&gt;
&lt;p&gt;原来我以为搭建一个个人博客至少需要完成以下几项工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;博客构思（比如博客做成什么样子，后台如何维护，登录，注册等）&lt;/li&gt;
&lt;li&gt;编码（构思完成后，如何编码实现这些功能）&lt;/li&gt;
&lt;li&gt;技术学习（比如要学习前端技术以及后端技术，全栈的节奏有没有）&lt;/li&gt;
&lt;li&gt;购买域名，服务器，数据库实例（一大笔花销有没有）&lt;/li&gt;
&lt;li&gt;部署（这个倒没有难度，但被前面的步骤卡住了，哈哈）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于这个认知，我的博客梦想一拖再拖，当时注册了一个博客园账号，偶尔把工作中遇到的问题的解决思路，写成文章发布到博客园，但写的很少。&lt;/p&gt;
&lt;h2 id=&quot;认知被打破&quot;&gt;2.认知被打破&lt;/h2&gt;
&lt;p&gt;在2018年底的时候，搭建个人博客的想法变得非常强烈，因为自己意识到写博客对自己的知识体系的构建非常重要，于是在网上找搭建个人博客的方法，然后发现了大牛&lt;a href=&quot;http://www.ityouknow.com/&quot;&gt;纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;的个人博客网站的一篇博客&lt;a href=&quot;http://www.ityouknow.com/other/2018/09/16/create-blog.html&quot;&gt;《技术人如何搭建自己的技术博客》&lt;/a&gt;，发现原来可以借助于Jekyll+GitHub Pages快速搭建一个个人博客，甚至连域名与服务器都不需要，直接把代码托管给GitHub，再简单配置一下即可。&lt;/p&gt;
&lt;h2 id=&quot;从0到1搭建博客&quot;&gt;3.从0到1搭建博客&lt;/h2&gt;
&lt;p&gt;基于此篇博客，我按照如下步骤一步一步初步搭建起了自己的个人博客（中间也是踩了一些坑并含泪解决）：&lt;/p&gt;
&lt;p&gt;1.打开&lt;a href=&quot;https://github.com/ityouknow/ityouknow.github.io&quot; class=&quot;uri&quot;&gt;https://github.com/ityouknow/ityouknow.github.io&lt;/a&gt;，点击Fork按钮复制一份到自己的仓库（需要一个GitHub账号，没有的话注册一个）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329141445797-1914073441.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过一会，你的仓库里就能看到。&lt;/p&gt;
&lt;p&gt;2.重命名仓库名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329142015452-1485364698.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.删除或修改CNAME文件&lt;/p&gt;
&lt;p&gt;假设你不需要自定义的域名，可以将根目录的CNAME文件删除。&lt;/p&gt;
&lt;p&gt;如果需要自定义的域名，就修改成自己的域名，如我的域名是：www.zwwhnly.com&lt;/p&gt;
&lt;p&gt;4.设置GitHub Pages&lt;/p&gt;
&lt;p&gt;打开Settings，找到GitHub Pages，现在默认就是从master分支构建，&lt;/p&gt;
&lt;p&gt;如果你不需要设置自定义域名，那么默认的域名就是{github username}.github.io，如我的就是zwwhnly.github.io，如果你需要自定义域名，可以在如下图所示位置设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329143458643-50785037.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.修改README.md&lt;/p&gt;
&lt;p&gt;修改该文件的内容为自己的，这个文件的内容会展示在仓库下方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329143808609-600083925.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.修改_config.yml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改该文件里，网站的标题，github账号，仓库地址，网站的域名，邮箱等信息，如我当时的修改大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329144438083-2134109786.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，如果你不需要自定义域名的话，直接使用默认的域名（我的是zwwhnly.github.io）就可以访问了。&lt;/p&gt;
&lt;p&gt;如果自定义了域名，就需要添加域名解析，如我的域名是在万网买的，添加的解析如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329144850273-437838853.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加完解析，过几分钟后，输入自己的域名&lt;a href=&quot;http://www.zwwhnly.com&quot; class=&quot;uri&quot;&gt;http://www.zwwhnly.com&lt;/a&gt;，就可以访问了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329145152333-1301460475.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;个人信息修改&quot;&gt;5.个人信息修改&lt;/h2&gt;
&lt;p&gt;感觉很简单，有没有，不过此时博客中的内容都是原作者的，Link和About页面的信息也不是自己的，可以先修改下以下几点，剩余的就看你自己想如何修改了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;删除_posts文件下的所有博客&lt;/li&gt;
&lt;li&gt;修改about.html页面信息为自己的信息&lt;/li&gt;
&lt;li&gt;修改link.html页面内容&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何发布博客&quot;&gt;6.如何发布博客&lt;/h2&gt;
&lt;p&gt;后续写博客使用Markdown语法，写完之后将文件放到_posts文件夹下，然后提交代码到GitHub，因为GitHub Pages内部，需要使用Jekyll将你提交的文件编译成最终的html，因此需要稍微过几分钟，才能在网站看到你新发布的博客。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329150859206-1817894726.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很方便有没有，但是也有一些缺点，比如访问很不稳定（毕竟用的免费的服务器），动不动就罢工：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329151520708-292632752.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且百度收录不好,不好使用百度统计（是不是百度和GitHub有过节，哈哈）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201903/424537-20190329151823007-950993286.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作为一个有追求的程序员，实在无法忍受这两点，于是趁着阿里云做活动购买了一台服务器，想把这个博客部署到自己的服务器上，谁知过程相当痛苦（搞环境花了3天左右），此过程会再写一遍博客分享。&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;7.参考链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ityouknow.com/other/2018/09/16/create-blog.html&quot;&gt;技术人如何搭建自己的技术博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 07:34:00 +0000</pubDate>
<dc:creator>周伟伟的技术博客</dc:creator>
<og:description>记得刚毕业参加工作时，每天早上到公司后，都会逛逛博客园，看一下各位大牛前辈写的文章，也许是兴趣使然，当时就特别想搭建一个属于自己的独立的技术博客。 时间就是过的这么快，转眼间这么多年过去了，我的这个梦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zwwhnly/p/10621642.html</dc:identifier>
</item>
<item>
<title>运商大数据架构--二章（1） - YN-ZJH</title>
<link>http://www.cnblogs.com/yn-zjh/p/10621591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yn-zjh/p/10621591.html</guid>
<description>&lt;p&gt;　　运营商和互联网面临不同的历史时期，因而大数据在各自领域承担的使命是不一样的&lt;/p&gt;
&lt;p&gt;　　运营商面临被管道化的挑战，营收下滑，大数据项目承担企业战略转型、数据变现的使命。同时由于成本的压力，以及大量基础设施和设备利旧的诉求，所以运营商在大数据项目中，对性能、成本和集成度提出了很高的要求。&lt;/p&gt;
&lt;p&gt;　　互联网企业近几年盈利颇丰，大数据往往是承担业务快速创新、未来探索的一种驱动因素，所以对架构的扩展性、灵活性等方面的追求优先级在成本之上。互联网企业每建一个数据中心通常就是几千台的规模，这在运营商看来是不可想象的。&lt;/p&gt;
&lt;p&gt;　　背后的商业驱动因素不一样，所带来的架构挑战也不一样。&lt;/p&gt;

&lt;p&gt;　　我们将以一个实际的大数据架构参与者、旁观者的角色讲述真正的实战经验，希望带给读者一些启发。前面讲到商业驱动因素不一样，所面临的场景不一样，选择的技术措施也会有所区别，但是其实存在即合理，实践出真知&lt;/p&gt;
&lt;p&gt;　　大数据平台架构如图2．1所示。可以看到，最上层是应用，大数据平台最后还是要解决实际的业务问题，在运营商领域分别解决&lt;strong&gt;SQM&lt;/strong&gt;（运维质量管理）、&lt;strong&gt;CSE&lt;/strong&gt;（客户体验提升）、&lt;strong&gt;MSS&lt;/strong&gt;（市场运维支撑）、&lt;strong&gt;DMP&lt;/strong&gt;（数据管理平台）等问题。这部分内容会在第3章详细介绍。&lt;/p&gt;
&lt;p&gt;　　第二层是各个组件/技术支撑，包括数据从产生获取、处理（实时、批处理）、分析（交互式查询、机器学习与数据挖掘）到最后的展现。这部分内容会在第4、8章介绍。&lt;/p&gt;
&lt;p&gt;　　第三层，为了支持数据的存储处理，需要统一的资源管理及分配。这部分内容会在第9章介绍。&lt;/p&gt;
&lt;p&gt;　　第四层，上层框架和处理都构建在存储的基础上，所以存储是基础中的基础。这部分内容会在第10章介绍。&lt;/p&gt;
&lt;p&gt;　　第五层，大数据部署形态有云化部署、物理机部署等多种部署模式。这部分内容会在第1 1章介绍。&lt;/p&gt;
&lt;p&gt;　　第12章介绍大数据技术开发文化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635516/201903/1635516-20190329152412024-960079879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Hadoop从2006年项目成立开始，已经风风雨雨走过了10年，从最开始的HDFS和MapReduce 两个组件到现在完整的生态链。展望未来，随着技术和业务的发展，下面这些趋势应该是所有设计和实现大数据平台的人需要认真考虑的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;· Cloud First&lt;/strong&gt;：云优先。服务端利用云的部署和扩展能力，保证数据访问高并发、高可用、高可靠。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　· stream Default&lt;/strong&gt;：流优先。数据源端更多的是流数据，要求实时分析，进行秒级或分钟级计算。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;· Pervasive Analytics&lt;/strong&gt;：普适分析。将分析能力推至数据源端、管道和服务端，低时延反馈结果&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;· self service&lt;/strong&gt;：自服务。无须太多的人为干预和人力投人，使得数据合理放置，转换为适合分析的数据类型，方便APP开发等。&lt;/p&gt;
&lt;p&gt;　　现在看着风光无限的组件或者平台，会不断地被后来者所替代。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;本章简要总结了本书的主要章节和内容。本书是围绕一个通用的大数据处理逻辑架构来展开的。在实际的生产环境中，该架构并不是一成不变的，会根据业务来灵活地部署和应用。当然，在一个完整的企业大数据系统里，本书介绍的内容完全不够，本书只介绍最基础的大数据平台，很多底层或者上层的内容可能没有覆盖到。另外，架构不是凭空出现的，由业务场景驱动的架构才是真正可用的架构。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;谢谢支持，喜欢关注哟！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 07:29:00 +0000</pubDate>
<dc:creator>YN-ZJH</dc:creator>
<og:description>架构驱动的因素 运营商和互联网面临不同的历史时期，因而大数据在各自领域承担的使命是不一样的 运营商面临被管道化的挑战，营收下滑，大数据项目承担企业战略转型、数据变现的使命。同时由于成本的压力，以及大量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yn-zjh/p/10621591.html</dc:identifier>
</item>
<item>
<title>数据库自动收缩带来的严重问题 - Double_K</title>
<link>http://www.cnblogs.com/double-K/p/10621461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/double-K/p/10621461.html</guid>
<description>&lt;p&gt;　　今天早上11点的时候有客户打电话过来说医院的cis系统一直有阻塞，导致系统有卡慢的现象，信息中心的电话都快被打爆了，信息科人员很头疼啊。&lt;/p&gt;
&lt;p&gt;万幸我们给数据库装了‘摄像头’会把数据库的一切状态操作都会记录下来，赶紧要了远程之后看到了系统确实存在大量的阻塞（下图）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/832221/201903/832221-20190329151130079-1377023499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过点击紫色圆点之后发现了长长的阻塞链，（注：会话标识33的语句是阻塞的源头，下面的语句为被阻塞的语句）可以看到被阻塞的语句确实等待了很长时间，系统因为大量的阻塞，前端人员的使用确实有卡慢的现象。（下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832221/201903/832221-20190329151139219-1561703659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么系统为什么会有这么严重的阻塞呢？怎么造成的？会话标识为33的语句到底是何方神圣？接下来我们来一探究竟。&lt;/p&gt;
&lt;p&gt;在sql server 管理工具里边用语句查询会话标识为33的语句为自动收缩的命令，看了看时间从2018年8月15号自动收缩已经开始运行，进度为79%，（下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832221/201903/832221-20190329151155296-961291321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来从体检项中可以看到相关数据库自动收缩配置为开启状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832221/201903/832221-20190329151209987-376180035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;通过和医院工程师交流得知，昨天下午三点半有做过数据迁移的操作，删除了100多G的数据，（下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/832221/201903/832221-20190329151222188-1966342185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;   经过分析和查询一些资料得出以下结论，数据库中的自动收缩选项在很早之前就已经开启，但是没有真正收缩过，昨天下午三点的时候删除了大量数据，触发了自动收缩数据库文件的操作，&lt;/p&gt;
&lt;p&gt;那么为什么今天早上才有阻塞的情况呢？收缩数据库对于sql server来说本身就是一件浪费资源的事情，在昨天下午三点半的时候前端业务量减小，没有影响到业务，而到了今天早上业务量增多，达到业务高峰期，才会把业务相关的语句阻塞住，严重影响了前端人员的使用。&lt;/p&gt;
&lt;h2&gt;如何缓解及解决？&lt;/h2&gt;
&lt;p&gt;因为在收缩数据文件，要重新整理数据，进度到了79%，在这个自动过程中，数据边收缩边释放，到达100%后收缩完成后，此问题会解决。另外一种方法就是重启sql服务，事务会提交或回滚，此问题也会得到解决（不建议）&lt;/p&gt;
&lt;p&gt; 下面来点技术性的东西，满足一下求知者的欲望……….&lt;/p&gt;

&lt;h2&gt; 什么是自动收缩？&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/832221/201903/832221-20190329151243049-247092702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;随着数据量的增加数据库的设备文件(MDF\LDF)会不断增长,当数据库中的某些数据删除,数据库设备文件的大小并不会随着数据量的减少而减少,数据库设备需要占用的磁盘空间就没那么大了,这时候自动收缩就可以释放出磁盘空间,主要直观体现在数据库设备文件的大小上,避免资源的浪费.&lt;/p&gt;
&lt;h2&gt;在什么条件下会触发？&lt;/h2&gt;
&lt;p&gt;在开启自动收缩选项的情况下，SQL Server定期会检查文件使用情况。如果空闲空间大于25%，SQL Server就会自动运行自动收缩数据库文件的动作。&lt;/p&gt;
&lt;p&gt;（附上微软官方链接：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/t-sql/statements/alter-database-transact-sql-set-options?view=sql-server-2017&amp;amp;viewFallbackFrom=sql-server-2014&quot;&gt;https://docs.microsoft.com/zh-cn/sql/t-sql/statements/alter-database-transact-sql-set-options?view=sql-server-2017&amp;amp;viewFallbackFrom=sql-server-2014&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;例如：数据迁移删除大量数据时，空闲空间大于25%时，会触发自动收缩功能。&lt;/p&gt;
&lt;h2&gt;带来的危害（自动收缩和手动收缩）？&lt;/h2&gt;
&lt;p&gt;对于一个磁盘空间很紧张的系统，这个设置无疑是有帮助的。但是从数据库自身的健康和性能考虑，这个设置并不建议多用。这是因为：&lt;/p&gt;
&lt;p&gt;1、数据文件收缩导致了索引的完全碎片化，索引的效率大大降低，严重影响性能。&lt;/p&gt;
&lt;p&gt;2、数据文件的收缩同样产生了大量的I/O操作，耗费大量的CPU资源，性能下降。&lt;/p&gt;
&lt;p&gt;3、在业务高峰期的时候可能会造成大量的阻塞。&lt;/p&gt;
&lt;p&gt;（附上链接资料，有兴趣的同学可以去研究一下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kerrycode/archive/2013/06/04/3116339.html&quot;&gt;https://www.cnblogs.com/kerrycode/archive/2013/06/04/3116339.html&lt;/a&gt; ）&lt;/p&gt;
&lt;h2&gt;一点点小建议：&lt;/h2&gt;
&lt;p&gt;1、不要开启自动收缩选项&lt;/p&gt;
&lt;p&gt;2、不到万不得已，千万不要收缩数据库。收缩数据库影响极大。&lt;/p&gt;
&lt;p&gt;3、如果磁盘空间真的不足，需要做收缩的时候，一定要手工来做，而且是在维护窗口期间；并且尽量使用语句来执行，可以提示错误；尽量一次不要收缩太多，分几次收缩。&lt;/p&gt;


</description>
<pubDate>Fri, 29 Mar 2019 07:20:00 +0000</pubDate>
<dc:creator>Double_K</dc:creator>
<og:description>背景 今天早上11点的时候有客户打电话过来说医院的cis系统一直有阻塞，导致系统有卡慢的现象，信息中心的电话都快被打爆了，信息科人员很头疼啊。 万幸我们给数据库装了‘摄像头’会把数据库的一切状态操作都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/double-K/p/10621461.html</dc:identifier>
</item>
<item>
<title>基于CNN的人群密度图估计方法简述 - Brook_icv</title>
<link>http://www.cnblogs.com/wangguchangqing/p/10621466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangguchangqing/p/10621466.html</guid>
<description>&lt;p&gt;人群计数的方法分为传统的视频和图像人群计数算法以及基于深度学习的人群计数算法，深度学习方法由于能够方便高效地提取高层特征而获得优越的性能是传统方法无法比拟的。本文简单了秒速了近几年，基于单张图像利用CNN估计人群密度图和计数的方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;传统的人群计数方法&lt;br/&gt;传统的人群计数方法可以分为两类，基于检测的方法和基于回归的方法。
&lt;ul readability=&quot;1.962486602358&quot;&gt;&lt;li&gt;基于检测的方法&lt;br/&gt;早期的计数方法主要是基于检测的方法，使用一个滑动窗口来检测场景中的人群，并统计人数。 基于检测的方法可以分为两类：
&lt;ul&gt;&lt;li&gt;基于整体的检测，训练一个分类器，利用从行人全身提取到的小波，HOG，边缘等特征检测行人。 学习的方法有SVM，boosting和随机森林等。 基于整体的方法主要适用于稀疏人群，随着人群密度的提升，人与人之间的遮挡越来越严重，这种方法就不再适用。&lt;/li&gt;
&lt;li&gt;基于部分的身体的检测。 为了处理人与人的遮挡问题，主要通过检测身体的部分结构，例如头，肩膀等去统计人群的数量。这种方法比之基于整体的检测，在效果上有略微的提升。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;基于回归的方法&lt;br/&gt;论何种基于检测的方法，都很难处理人群之间严重的遮挡问题。所以，基于回归的方法逐渐被用来解决人群计数的问题。 基于回归的方法，主要思想是&lt;strong&gt;学习一种特征到人群数量的映射。&lt;/strong&gt;该类方法主要分为两步：1. 提取场景的低级特征，例如例如前景特征，边缘特征，纹理和梯度特征；2. 学习一个回归模型，例如线性回归，岭回归或者高斯过程回归，学习一个低级特征到人群数的映射关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.875&quot;&gt;
&lt;p&gt;基于密度图的方法&lt;br/&gt;基于回归的方法虽然能在一定程度上解决遮挡的问题，但是由于是使用整幅图像的特征进行回归技术，从而忽略了图像的空间信息。在2010年的Visual Geometry Group University of Oxford提出了：学习图像的局部特征和其相应的&lt;strong&gt;密度图&lt;/strong&gt;之间的映射，从而在计数的过程中加入图像的空间信息。 论文地址：&lt;a href=&quot;http://www.robots.ox.ac.uk/~vgg/research/counting/&quot; title=&quot;Learning To Count Objects in Images&quot;&gt;Learning To Count Objects in Images&lt;/a&gt; . 该论文最早提出使用密度图来进行计数的方法，后来很多的图像计数多数基于此方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基于深度学习的方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;深度学习在计算机的视觉的识别，分割，检测相比传统的方法都取得了很大的进步，人群计数也不例外，近年来的方法多数是使用深度学习的方法，利用深度学习的学历能力得到图像到其相应的人群密度图或者数量。&lt;br/&gt;传统的方法通常都是输入图像的一个patch，并且通常分为两个步骤：特征的提取，回归或者分类，而基于CNN的方法则输入是一种完整的图片，并且进行end-to-end的训练。无论是使用回归或者密度图，CNN的方法都能取得较好的结果。&lt;/p&gt;
&lt;p&gt;本文主要总结下，近几年关于使用CNN基于单幅人群图像生成密度图的方法。&lt;/p&gt;
&lt;h3 id=&quot;mcnn-cvpr2016&quot;&gt;MCNN (cvpr2016)&lt;/h3&gt;
&lt;p&gt;zhang等人提出了 Multi-column Convolutional Neural Network (MCNN)网络来预测人群的密度图。MCNN中有三大创新：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提出了MCNN网络，能够处理任意大小的图像，并且使利用3个具有不同卷积核大小的网络来分别提取人群图像的特征，来适应人群头部大小的变化。&lt;/li&gt;
&lt;li&gt;提出一种根据人头标记生成人群密度图的方法&lt;/li&gt;
&lt;li&gt;构建了一个新的数据集 &lt;em&gt;Shanghaitech&lt;/em&gt; ，包含1198张图像约有330000个人头标记数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作者认为，人群计数存在着以下的困难：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前景的分割，现有的计数方法通常需要前景分割，而前景分割是很困难的。使用MCNN网络则不需要进行前景分割，输入任意的人群图像，通过CNN网络直接估计其密度图。&lt;/li&gt;
&lt;li&gt;密集人群存在严重的遮挡&lt;/li&gt;
&lt;li&gt;人群图像中人的尺度存在着较大的差异就需要融合多种图像的特征来估计人群的数量，这些特征人工则很难设计。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了应对以上问题，作者提出了MCNN网络，使用3个不同尺度的卷积网络提取图像的多尺度特征，并使用&lt;span class=&quot;math inline&quot;&gt;\(1 \times 1\)&lt;/span&gt;的卷积核将多尺度的特征融合到一起。 其网络结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201903/439761-20190329151519933-1393144419.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这类利用多个网络的模型具有较多的参数，计算量大，无法进行实时的人群计数预测。而且多阵列的网络并不能如所描述的一般，提取不同的尺度的人头特征。&lt;/p&gt;
&lt;h4 id=&quot;密度图的生成&quot;&gt;密度图的生成&lt;/h4&gt;
&lt;p&gt;人群计数的数据集，通常是标记了人头的位置，就需要根据人头位置的数据来生成相应的人群密度图。 MCNN种提出了一种自适应卷积核的方法，来生成相应的密度图。&lt;/p&gt;
&lt;p&gt;在由标记生成密度图的过程，首先将每个人头对应的位置设置为1，然后对该图像进行高斯卷积。&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;img = cv2.imread(path)
density = np.zeros((img.shape[0],img.shape[1]))

for i inr range(0,len(gt)):
    if int(gt[i][1]) &amp;lt; img.shape[0] and int(gt[i][0]) &amp;lt; img.shape[1]:
        density[int(gt[i][1]),int(gt[i][0])] = 1
density = cv2.GaussianBlur(density,(5,5))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种构建的密度图是假设人头相对于图像平面是独立存在的，事实上，由于透视畸变的村子，不同位置人头对应着不同大小的像素区域。 因此，要想生成精确的人群密度图像，就要考虑单应性引起的畸变，但是畸变参数是不容易得到的。故，作者假设每个头部周围的人群分布比较均匀，那么头部与其最近的k个邻居之间的平均距离，给出了一个合理的几何失真估计(由透视效果引起)。而且作者在拥挤的场景中，头部的大小通常与相邻两个人中心的距离有关。 作为一种折衷，对于那些拥挤场景的密度图，建议根据每个人与其邻居的平均距离来自适应地确定每个人的扩展参数，也就是高斯卷积核的方差。&lt;/p&gt;
&lt;p&gt;也是就，其为每个人头位置根据其与周围相邻的人头的距离来构建卷积的方差，然后将所有人头点卷积后的结果累加到一起，就是最终生成的密度图。具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    gt_count = np.count_nonzero(gt)
    if gt_count == 0:
        return density

    # FInd out the K nearest neighbours using a KDTree
    pts = np.array(list(zip(np.nonzero(gt)[1].ravel(), np.nonzero(gt)[0].ravel())))
    leafsize = 2048

    # build kdtree
    tree = scipy.spatial.KDTree(pts.copy(), leafsize=leafsize)

    # query kdtree
    distances, locations = tree.query(pts, k=4)

    for i, pt in enumerate(pts):
        pt2d = np.zeros(gt.shape, dtype=np.float32)
        pt2d[pt[1],pt[0]] = 1.
        if gt_count &amp;gt; 1:
            sigma = (distances[i][1]+distances[i][2]+distances[i][3])*0.1
        else:
            sigma = np.average(np.array(gt.shape))/2./2. #case: 1 point

        #Convolve with the gaussian filter
        density += scipy.ndimage.filters.gaussian_filter(pt2d, sigma,             mode='constant')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cp-cnn-cvpr-2017&quot;&gt;CP-CNN (cvpr 2017)&lt;/h3&gt;
&lt;p&gt;CP-CNN( Generating High-Quality Crowd Density Maps using Contextual Pyramid CNNs) 使用图像的全局和局部特征信息生成估计人群图像的密度图。&lt;/p&gt;
&lt;p&gt;其网络结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201903/439761-20190329151544567-421856095.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绿色子网络表示对整张输入图像做特征提取并分类（类别为作者分好的密度等级，即当前输入图像属于哪个密度等级），并将分类结果张成一个与密度特征具有相同高和宽的图像（全局上下文）；蓝色子网络对原图中割出的patch做同样的操作，得到局部上下文。最终将全局和局部上下文特征与原图产生的密度图（黄色部分）在通道维度拼接（concate）。该方法的初衷是为了考虑一幅图像中人群的全局密度和局部密度信息，最后对整个特征做约束，使得网络对任何一张图像都自适应的学到相应密度等级的特征。&lt;/p&gt;
&lt;h3 id=&quot;csrnet-cvpr-2018&quot;&gt;CSRNet (cvpr 2018)&lt;/h3&gt;
&lt;p&gt;CSRnet网络模型主要分为前端和后端网络，采用剔除了全连接层的VGG-16作为CSRnet的前端网络，提取图像的特征，输出密度图的大小为原始输入图像的1/8。采用空洞卷积神经网络作为后端网络，在保持分辨率的同时扩大感知域， 生成高质量的人群分布密度图。&lt;br/&gt;采用剔除了全连接层的VGG-16网络，并且采用3×3的卷积核。研究表明，对于相同大小的感知域，卷积核越小，卷积层数越多的模型要优于那些有着更大卷积核且卷积层数较少的模型。为了平衡准确性和资源开销，这里的VGG-16网络采用10层卷积层和3层池化层的组合。后端网络采用六层空洞卷积层，空洞率相同。最后采用一层1×1的普通卷积层输出结果，其网络结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201903/439761-20190329151603255-1268952304.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSRNet的主要思路是，使用预训练的VGG进行特征提取，后面再使用空洞卷积，在扩大感受野的同时，生成人群的密度图。&lt;/p&gt;
&lt;h3 id=&quot;ic-cnn-eccv-2018&quot;&gt;ic-CNN (ECCV 2018)&lt;/h3&gt;
&lt;p&gt;Iterative Crowd Counting，其采取的思路是首先生成低分辨率的密度图，然后进一步的细化来生成高分辨率的密度图。该网络结构由两个CNN分支组成，一个分支用来生成低分辨率的密度图，另一个使用生成的低分辨率的密度图以及提取的特征图的基础上，生成高分辨率的密度图。其网络结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201903/439761-20190329151618725-1641831403.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该网络的输入是一个三元组&lt;span class=&quot;math inline&quot;&gt;\(\mathcal{D}=\left\{\left(X_{1}, Y_{1}, Z_{1}\right), \ldots,\left(X_{n}, Y_{n}, Z_{n}\right)\right\}\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(X_i\)&lt;/span&gt;是输入的图像，&lt;span class=&quot;math inline&quot;&gt;\(Y_i\)&lt;/span&gt;是和原图像相同分辨率的密度图，&lt;span class=&quot;math inline&quot;&gt;\(Z_i\)&lt;/span&gt;则是低分辨率的密度图。&lt;/p&gt;
&lt;p&gt;对于生成低分辨率密度图的分支LR-CNN，其输入是&lt;span class=&quot;math inline&quot;&gt;\(X_i\)&lt;/span&gt;，则可以用如下公式表示&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{Z}_{i}=f_{l}\left(X_{i} ; \theta_{l}\right)\]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\hat{Z}_{i}\)&lt;/span&gt;是生成的低分辨率的密度图。&lt;/p&gt;
&lt;p&gt;对于生成高分辨率的分支HR-CNN，其输入则是&lt;span class=&quot;math inline&quot;&gt;\(X_i,\hat{Z_i}\)&lt;/span&gt;，其表示如下&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{Y}_{i}=f_{h}\left(X_{i}, \hat{Z}_{i} ; \theta_{l}, \theta_{h}\right)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其损失函数为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathcal{L}\left(\theta_{l}, \theta_{h}\right)=\frac{1}{n} \sum_{i=1}^{n}\left(\lambda_{l} L\left(\hat{Z}_{i}, Z_{i}\right)+\lambda_{h} L\left(\hat{Y}_{i}, Y_{i}\right)\right)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用HR-CNN输出的高分辨率的密度图作为最终的输出结果。其表现如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201903/439761-20190329151629494-1640556800.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;saneteccv-2018&quot;&gt;SANet(ECCV 2018)&lt;/h3&gt;
&lt;p&gt;Scale Aggregation Network for Accurate and Efficient Crowd Counting，该方法同样考虑要提取每个图像的多个尺度的人头信息，但并不采取类似MCNN的多阵列网络结构，其使用了类似于Inception架构的模块，在每个卷积层都同时使用不同大小的卷积核，最后通过反卷积得到最终的密度图。&lt;br/&gt;简单来说，就是使用一系列的Inception结构提取不同尺度的特征，再使用反卷积（Transposed CONV）生成高分辨率的密度图，其网络结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201903/439761-20190329151644758-1630365047.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;简单的梳理了下2016年到2018年出现的一些基于CNN生成人群密度图的方法。 可以看出，生成人群密度图的难点仍然是：人头的重叠以及人头尺度的变化。 这两个困难有时候有可以看作是一个：人头尺度变小了，其看着就重叠到了一起。 所以目前主流的方法，仍然是提取多尺度的人头特征信息，当然也有ic-CNN这样的从低分辨率密度图细化到高分辨率的密度图。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 07:17:00 +0000</pubDate>
<dc:creator>Brook_icv</dc:creator>
<og:description>人群计数的方法分为传统的视频和图像人群计数算法以及基于深度学习的人群计数算法，深度学习方法由于能够方便高效地提取高层特征而获得优越的性能是传统方法无法比拟的。本文简单了秒速了近几年，基于单张图像利用C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangguchangqing/p/10621466.html</dc:identifier>
</item>
<item>
<title>常用开发技巧系列（五） - Zxiao..旭</title>
<link>http://www.cnblogs.com/zhangxiaoxu/p/8297280.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxiaoxu/p/8297280.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      前面刚发了这个技巧总结系列的第四篇文章，这篇文章总结的一些日常开发中的技巧或更偏向于Cocos2d方向，因为最近在游戏中有原生的一个客服系统需要加进来，就涉及到一个游戏和原生界面的交互以及各种各样的BUG，游戏是属于在别人代码的基础上进行的二次开发，属于一个非ARC的情况，而我们现在的三方应该都是ARC，还有那些让人头疼的屏幕旋转键盘等等的问题，最近爬的坑有点多，所有这篇就主要来总结这些坑！当然在我们的普通应用中遇到这些问题我们还是同样可以依照这些技巧总结的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 一:__weak typeof(self)报错了&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      这个问题我也是觉得奇怪，在我们正常的使用中一般是不会出现这种错误的！这个一般是绝大多数的情况，应该和这游戏源码的年代有直接的关系，这个错误我也截图了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/739006/201801/739006-20180116163018584-404982719.png&quot; alt=&quot;&quot; width=&quot;763&quot; height=&quot;142&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      这个问题出现的时候上网找了一下解决的办法，解决是很简单就能解决这个问题，只要是和我的在 build setting 中下面的设置项不一致，你把它改成一致的即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/739006/201801/739006-20180116163248193-1532071786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      前面说了，这个解决起来很简单，但是我们不明不白的设置这东西就是属于稀里糊涂了：&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;二： 横屏切换竖屏&lt;/strong&gt;     &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      我们一般的游戏都是横屏的，当然也有竖屏的，在日常的需求中很有可能就涉及到游戏和原生界面的交互，就有了横屏游戏切换竖屏原生界面出来，其实最让人头疼的，是你切换界面之后还有键盘的问题！在自己的游戏中就有这样一个切换是在客服系统当中，横屏的游戏需要你切换到竖屏的一个客服聊天界面！其中就涉及到这个键盘的问题！我们再这里也总结一下在iOS应用中决定键盘的方向因素，在不同iOS版本中是不一样的。&lt;/p&gt;
&lt;p&gt;iOS8：&lt;/p&gt;
&lt;p&gt;       键盘方向是根据一个特定的window决定，打印[UIApplication sharedApplication].windows，最少有两个，第一个为UIWindow，是程序主要的keyWindow；第二个为UITextEffectsWindow，是键盘所在的window。&lt;/p&gt;
&lt;p&gt;iOS9：&lt;/p&gt;
&lt;p&gt;      键盘方向由最后一层window决定，这里有点复杂，因为iOS9新增了一个UIRemoteKeyboardWindow。那么应用可能就有3个window，依次是UIWindow，UITextEffectsWindow，UIRemoteKeyboardWindow。UIRemoteKeyboardWindow成为决定键盘方向的window了，而UITextEffectsWindow控制了键盘顶部栏的方向，如下如：&lt;/p&gt;
&lt;p&gt;iOS10：&lt;/p&gt;
&lt;p&gt;      和iOS9类似，但是，如果要强制旋转键盘的话，它的坐标计算方法又和之前的系统有区别。区别在于计算window的原点坐标(x,y)，iOS10是(0,0,width,height)，iOS9的x和y需要这样计算：CGFloat keyBoardWindowXY = (viewSize.height - viewSize.width) / 2&lt;/p&gt;
&lt;p&gt;      具体的推荐大家看这篇：&lt;a href=&quot;https://www.jianshu.com/p/42bc210f574b&quot; target=&quot;_blank&quot;&gt;[iOS]终极横竖屏切换解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      这篇文章能解决大部分大家的需求。包括一些webView的屏幕旋转等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三：ARC和非ARC混编&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      有维护一个以前的Cocos-lua的游戏，这份代码也是比较的老了，是非ARC的环境，在维护中有给这个游戏当中添加其他第三方的框架进去，但现在的iOS的框架几乎没有非ARC环境的，就会有各种各样的错误，这时候你就的进行他们的混编了，其实单纯混编这一点设置很简单，关键的其实是我们得有这样的一个清晰的认知，知道这里需要ARC的环境，而不是你拉进去其他的三方之后看到报错，就一个劲的纠结在哪个错误上！！这才是我这里说这一点的最重要的东西，设置的的很简单，我直接截一张图给大家，相信都能看明白！&lt;/p&gt;
&lt;p&gt;      下面是你给游戏中添加了MJ之后，你把MJ设置成ARC环境:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/739006/201801/739006-20180119110347443-336018095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四：无线真机测试&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      在iOS中我们经常会进行真机测试的，不知道小伙伴们是不是都找一根数据线然后连接上测试机之后测试的，有时候可能还得用自己的手机，一夸张一插就是一整天，谁都知道这样对手机电池不好....&lt;/p&gt;
&lt;p&gt;      其实我们是可以可以无线真机测试的，我估计也应该有很多小伙伴是知道的，按下面步骤就可以进行测试，很简单的，两张图搞定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739006/201811/739006-20181114111850939-2006385592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       接下来如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739006/201811/739006-20181114111917868-725295948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      是不是OK了。是的，要是手机已经设置了密码就OK了。要是测试的手机没有设置手机密码这时候就会提醒你  Passcode Required 那你就乖乖设置一个手机密码就可以啦！&lt;/p&gt;

&lt;p&gt; 五&lt;strong&gt;：JS 和 Swift  WKWebView 的最基本交互&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      这个点要是往大了说。可以写一篇原生和JS交互的文章，但以前我写过这样的文章，就不想在做重复的工作了，这里我们就提一下JS 和 Swift WK的交互，也是刚有一点点需求写了，就记录一下吧，代码具体的看下面，需要注意的地方我都写在代码里面了：&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;Swift 代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:swift;gutter:true;&quot;&gt;
 //MARK: JS Swift 交互
func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
                
      let Url = message.body
      //MARK: 唤起浏览器
      if message.name == &quot;Model&quot; {
                        
              let url = URL.init(string: Url as! String)
              //根据iOS系统版本，分别处理
              if #available(iOS 10, *) {
                      UIApplication.shared.open(url!, options: [:],
                                                completionHandler:nil)
              }else{
                      UIApplication.shared.openURL(url!)
              }
      }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       NOTE:   需要注意的是记得在初始化WK的时候给WKWebViewConfiguration 添加交互的信息,不然会调用不成功的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:swift;gutter:true;&quot;&gt;
let webConfiguration = WKWebViewConfiguration()
// 给webview与swift交互起名字，webview给swift发消息的时候会用到
webConfiguration.userContentController.add(self, name: &quot;Model&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;JS 端的代码就简简单单的一句：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 window.webkit.messageHandlers.Model.postMessage(&quot;https://www.baidu.com&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        NOTE:  这个Model其实就是一个你和前端相约好的一个identify，这样容易理解，不管是有些文章说的方法名也好还是要传值的对象也好，其实起的作用就是一个identify的作用！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六：AppDelegate 怎么弹出  UIAlertController 提示&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739006/201901/739006-20190108143721682-422712520.jpg&quot; alt=&quot;&quot; width=&quot;255&quot; height=&quot;552&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        不知道一些朋友会不会有这样的需求产生，需要你在&lt;strong&gt;AppDelegate&lt;/strong&gt;中提示一些信息，可能许多人都会想到这句代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:swift;gutter:true;&quot;&gt;
self.window?.rootViewController?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        首先可以肯定的是肯定和这句是有关系的，这个无可争议！但关键点可能还不是在这里，你要直接添加我相信你log中会有这么一句：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;   Warning: Attempt to present &amp;lt;UIAlertController: 0x10684d200&amp;gt; on &amp;lt;PCDD.ViewController: 0x106014100&amp;gt; whose view is not in the window hierarchy!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;这句话我们说的直白点的意思就是你要present UIAlertController的ViewController还不在当中&lt;/p&gt;
&lt;p&gt;        解决这个问题在stackoverflow有这样的答案    &lt;a href=&quot;https://stackoverflow.com/questions/26952061/present-uialertcontroller-from-appdelegate&quot; target=&quot;_blank&quot;&gt;stackoverflow解答&lt;/a&gt;  最后我们直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:swift;gutter:true;&quot;&gt;
DispatchQueue.global().async {
         DispatchQueue.main.async {
                let alertCtr = UIAlertController(title: &quot;连接错误&quot;, message: &quot;请检查网络或者请求配置是否正确&quot;, preferredStyle: .alert);
                alertCtr.addAction(UIAlertAction(title: &quot;确定&quot;, style: .default, handler: { (action) in
                  
                }))
                self.window?.rootViewController?.present(alertCtr, animated: true, completion: nil)
         }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;七：禁止某一个控制器侧滑&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      其实你不用写太多代码的，你获取一下导航栏测滑动target,然后你把它action置一下nil就可以了 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
    // 禁止侧滑返回
    id traget = self.navigationController.interactivePopGestureRecognizer.delegate;
    UIPanGestureRecognizer * pan = [[UIPanGestureRecognizer alloc]initWithTarget:traget action:nil];
    [self.view addGestureRecognizer:pan];
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;八：XCode 10 CocoaPods 升级 bad response Not Found 404 问题&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      我们在升级了Xcode10之后使用&lt;strong&gt;CocoaPods，&lt;/strong&gt;在执行了pod install 之后就出了问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
RuntimeError - [!] Xcodeproj doesn't know about the following attributes {&quot;inputFileListPaths&quot;=&amp;gt;[], &quot;outputFileListPaths&quot;=&amp;gt;[]} for the 'PBXShellScriptBuildPhase' isa.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       因为 &lt;code&gt;inputFileListPaths&lt;/code&gt; 和 &lt;code&gt;outputFileListPaths&lt;/code&gt; 是 Xcode 10 中新增的属性, 因此旧版本的 CocoaPods 无法解析，所以我们升级CocoaPods,结果一般 gem 源是 ruby 中国都会出现这个问题，以为它换域名了：&lt;/p&gt;
&lt;p&gt;      它重新提供 .com 代替 .org 的域名，其他一切不变！所以我们换一下域名就OK了。终端中执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
gem sources --add https://gems.ruby-china.com --remove https://gems.ruby-china.org
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      要是又出现没有写入的权限提示，You don't have write permissions for the /usr/bin directory. &lt;code&gt;这是在说/usr/bin&lt;/code&gt; 没有写权限, 这是由于 macOS 10.11 之后增加了 rootless 机制, 导致即使在 root 权限下依然无法修改文件. 解决办法,即修改 CocoaPods 安装目录:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
 gem install cocoapods --pre -n /usr/local/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      最后你可以查看一下自己pod版本是否升级成功： pod -- version&lt;/p&gt;

</description>
<pubDate>Fri, 29 Mar 2019 07:02:00 +0000</pubDate>
<dc:creator>Zxiao..旭</dc:creator>
<og:description>前言 前面刚发了这个技巧总结系列的第四篇文章，这篇文章总结的一些日常开发中的技巧或更偏向于Cocos2d方向，因为最近在游戏中有原生的一个客服系统需要加进来，就涉及到一个游戏和原生界面的交互以及各种各</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxiaoxu/p/8297280.html</dc:identifier>
</item>
<item>
<title>「Continuous_integration, CI」为什么要持续集成? - 勋爵</title>
<link>http://www.cnblogs.com/X-knight/p/10621250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-knight/p/10621250.html</guid>
<description>&lt;h3&gt;前言  &lt;/h3&gt;
&lt;p&gt;什么是持续集成，为什么要持续集成？本文对持续集成前后两种开发实践做了对比分析，从而直观的感受到持续集成的好处。&lt;/p&gt;
&lt;p&gt;在说持续集成之前，先说一下传统的开发模式：&lt;/p&gt;
&lt;h3&gt;传统模式：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;传统模式过程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762938/201903/762938-20190329141428074-1231089742.png&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的开发模式存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Bug总是在最后才出现。&lt;/p&gt;
&lt;p&gt;2.越到项目后期，问题越难解决。&lt;/p&gt;
&lt;p&gt;3.软件交付时机无法保障。&lt;/p&gt;
&lt;p&gt;4.程序经常需要变更。&lt;br/&gt;某些项目中，程序会经常需要变更，特别是敏捷开发实践者。&lt;/p&gt;
&lt;p&gt;5.无效的等待变多。&lt;br/&gt;开发在等待集成其他人的模块，测试人员在等待开发修复Bug，产品经理在等待新版本上线给客户做演示，项目经理在等待其他人提交代码。&lt;/p&gt;
&lt;p&gt;6.用户的满足度低。&lt;/p&gt;
&lt;h3&gt;持续集成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是持续集成？ &lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;在软件工程中，持续集成（CI）是指将所有开发者的工作副本每天多次合并到主干的做法。Grady Booch 在1991年的 Booch method 中首次命名并提出了 CI 的概念，尽管在当时他并不主张每天多次集成。而 XP（Extreme programming，极限编程）采用了 CI 的概念，并提倡每天不止一次集成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续集成服务器：&lt;/strong&gt;&lt;br/&gt;持续集成服务器就是能够采用自动化的手段，来解放人的双手，实现项目持续集成的工具。与之配套的软件有TeamCity、Jenkins、Go等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续集成的工作模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/762938/201903/762938-20190329142006935-2147074704.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续集成的好处：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.解放了重复性劳动。&lt;br/&gt;自动化部署工作可以解放集成、测试、部署等重复性劳动，而机器集成的频率明显比手工高很多。&lt;/p&gt;
&lt;p&gt;2.更快地修复问题。&lt;br/&gt;持续集成更早的获取变更，更早的进入测试，更早的发现问题，解决问题的成本显著下降。&lt;/p&gt;
&lt;p&gt;3.更快的交付成果。&lt;br/&gt;更早发现错误减少解决错误所需的工作量。集成服务器在构建环节发现错误可以及时通知开发人员修复。集成服务器在部署环节发现错误可以回退到上一版本，服务器始终有一个可用的版本。&lt;/p&gt;
&lt;p&gt;4.减少手工的错误。&lt;br/&gt;在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。&lt;/p&gt;
&lt;p&gt;5.减少了等待时间。&lt;br/&gt;缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时机。持续集成，意味着开发、集成、测试、部署也得以持续。&lt;/p&gt;
&lt;p&gt;6.更高的产品质量。&lt;br/&gt;集成服务器往往提供代码质量检测等功能，对不规范或有错误的地方会进行标致，也可以设置邮件和短信等进行警告。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;持续集成的最佳实践：&lt;/strong&gt;&lt;br/&gt;1.频繁检出代码。&lt;br/&gt;有时候代码冲突无可避免，频繁检出代码，可以让本地的副本和代码库中的版本最小差异化。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2.频繁提交代码。&lt;br/&gt;与1的原理类似，频繁提交代码，可以让其他人检出副本和代码库中的版本最小差异化。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;3.减少分支，回归主干。&lt;br/&gt;多个分支并行应及早将变更集成到主干中，避免同时维护软件的多个版本。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;4.使用自动化构建。&lt;br/&gt;可以使用Maven、Ant等来实现自动化构建，可以在构建过程中实现自动化测试。前提是有写单元测试用例。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;5.提交测试。&lt;br/&gt;在提交工作之前，每个程序员必须本地集成所有代码，做一个完整的构建和运行，并通过所有的单元测试，这样能减少集成测试在集成服务器上构建失败的风险。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;6.当前状态对每个人都可见。&lt;br/&gt;集成服务器在持续集成过程中发现问题应及时发送警告给相关的干系人。&lt;/p&gt;

</description>
<pubDate>Fri, 29 Mar 2019 06:53:00 +0000</pubDate>
<dc:creator>勋爵</dc:creator>
<og:description>前言 什么是持续集成，为什么要持续集成？本文对持续集成前后两种开发实践做了对比分析，从而直观的感受到持续集成的好处。 在说持续集成之前，先说一下传统的开发模式： 传统模式： 传统模式过程如下： 传统的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-knight/p/10621250.html</dc:identifier>
</item>
</channel>
</rss>