<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>操作系统和并发的爱恨纠葛 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13450201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13450201.html</guid>
<description>&lt;p&gt;我一直没有急于写并发的原因是我参不透&lt;code&gt;操作系统&lt;/code&gt;，如今，我已经把操作系统刷了一遍，这次试着写一些并发，看看能不能写清楚，卑微小编在线求鼓励...... 我打算采取操作系统和并发同时结合讲起来的方式。&lt;/p&gt;
&lt;h2 id=&quot;并发历史&quot;&gt;并发历史&lt;/h2&gt;
&lt;p&gt;在计算机最早期的时候，没有操作系统，执行程序只需要一个过程，那就是从头到尾依次执行。任何资源都会为这个程序服务，这必然就会存在 &lt;code&gt;浪费资源&lt;/code&gt; 的情况。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里说的浪费资源指的是资源空闲，没有充分使用的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作系统为我们的程序带来了 &lt;code&gt;并发性&lt;/code&gt;，操作系统使我们的程序同时运行多个程序，一个程序就是一个进程，也就相当于同时运行了多个进程。&lt;/p&gt;
&lt;p&gt;操作系统是一个&lt;code&gt;并发系统&lt;/code&gt;，并发性是操作系统非常重要的特征，操作系统具有同时处理和调度多个程序的能力，比如多个 I/O 设备同时在输入输出；设备 I/O 和 CPU 计算同时进行；内存中同时有多个系统和用户程序被启动交替、穿插地执行。操作系统在协调和分配进程的同时，操作系统也会为不同进程分配不同的资源。&lt;/p&gt;
&lt;p&gt;操作系统实现多个程序同时运行解决了单个程序无法做到的问题，主要有下面三点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;资源利用率&lt;/code&gt;，我们上面说到，单个进程存在资源浪费的情况，举个例子，当你在为某个文件夹赋予权限的时候，输入程序无法接受外部的输入字符，只能等到权限赋予完毕后才能接受外部输入。综合来讲，就是在等待程序时无法执行其他工作。如果在等待程序的同时可以运行另一个程序，那么将会大大提高资源的利用率。（资源并不会觉得累）因为它不会划水～&lt;/li&gt;
&lt;li&gt;&lt;code&gt;公平性&lt;/code&gt;，不同的用户和程序对于计算机上的资源有着同样的使用权。一种高效的运行方式是为不同的程序划分时间片使用资源，但是有一点需要注意，操作系统可以决定不同进程的优先级，虽然每个进程都有能够公平享有资源的权利，但是每次前一个进程释放资源后的同时有一个优先级更高的进程抢夺资源，就会造成优先级低的进程无法获得资源，久而久之会导致进程饥饿。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;便利性&lt;/code&gt;，单个进程是无法通信的，通信这一点我认为其实是一种&lt;code&gt;避雷针&lt;/code&gt;策略，通信的本质就是&lt;code&gt;信息交换&lt;/code&gt;，及时进行信息交换能够避免&lt;code&gt;信息孤岛&lt;/code&gt;，做重复性的工作；任何并发能做的事情，顺序编程也能够实现，只不过这种方式效率很低，它是一种 &lt;code&gt;阻塞式&lt;/code&gt; 的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，顺序编程（也称为&lt;code&gt;串行编程&lt;/code&gt;）也不是&lt;code&gt;一无是处&lt;/code&gt;的，串行编程的优势在于其&lt;strong&gt;直观性和简单性&lt;/strong&gt;，客观来讲，串行编程更适合我们人脑的思考方式，但是我们并不会满足于顺序编程，&lt;strong&gt;we want it more!!!&lt;/strong&gt; 。资源利用率、公平性和便利性促使着进程出现的同时也促使着&lt;code&gt;线程&lt;/code&gt;的出现。&lt;/p&gt;
&lt;p&gt;如果你还不是很理解进程和线程的区别的话，那么我就以我多年操作系统的经验（吹牛逼，实则半年）来为你解释一下：&lt;strong&gt;进程是一个应用程序，而线程是应用程序中的一条顺序流&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072747977-703884923.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072754717-1572121721.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;code&gt;阮一峰&lt;/code&gt;老师也给出了你通俗易懂的解释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072804200-1092853243.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072904351-476591221.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摘自 &lt;a href=&quot;https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html&quot;&gt;https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;线程会共享进程范围内的资源，例如内存和文件句柄，但是每个线程也有自己私有的内容，比如程序计数器、栈以及局部变量。下面汇总了进程和线程共享资源的区别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072913930-354459761.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程被描述为一种&lt;code&gt;轻量级&lt;/code&gt;的进程，轻量级体现在线程的创建和销毁要比进程的开销小很多。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：任何比较都是相对的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大多数现代操作系统中，都以线程为基本的调度单位，所以我们的视角着重放在对线程的探究。&lt;/p&gt;
&lt;h2 id=&quot;线程&quot;&gt;线程&lt;/h2&gt;
&lt;h3 id=&quot;优势和劣势&quot;&gt;优势和劣势&lt;/h3&gt;
&lt;p&gt;合理使用线程是一门艺术，合理编写一道准确无误的多线程程序更是一门艺术，如果线程使用得当，能够有效的降低程序的开发和维护成本。&lt;/p&gt;
&lt;p&gt;在 GUI 中，线程可以提高用户界面的响应灵敏度，在服务器应用程序中，并发可以提高资源利用率以及系统吞吐率。&lt;/p&gt;
&lt;p&gt;Java 很好的在用户空间实现了开发工具包，并在内核空间提供系统调用来支持多线程编程，Java 支持了丰富的类库 &lt;code&gt;java.util.concurrent&lt;/code&gt; 和跨平台的&lt;code&gt;内存模型&lt;/code&gt;，同时也提高了开发人员的门槛，并发一直以来是一个高阶的主题，但是现在，并发也成为了主流开发人员的必备素质。&lt;/p&gt;
&lt;p&gt;虽然线程带来的好处很多，但是编写正确的多线程（并发）程序是一件极困难的事情，并发程序的 Bug 往往会诡异地出现又诡异的消失，在当你认为没有问题的时候它就出现了，&lt;code&gt;难以定位&lt;/code&gt; 是并发程序的一个特征，所以在此基础上你需要有扎实的并发基本功。那么，并发为什么会出现呢？&lt;/p&gt;
&lt;h3 id=&quot;为什么是并发&quot;&gt;为什么是并发&lt;/h3&gt;
&lt;p&gt;计算机世界的快速发展离不开 CPU、内存和 I/O 设备的高速发展，但是这三者一直存在速度差异性问题，我们可以从存储器的层次结构可以看出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072922769-1545252138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CPU 内部是寄存器的构造，寄存器的访问速度要高于&lt;code&gt;高速缓存&lt;/code&gt;，高速缓存的访问速度要高于内存，最慢的是磁盘访问。&lt;/p&gt;
&lt;p&gt;程序是在内存中执行的，程序里大部分语句都要访问内存，有些还需要访问 I/O 设备，根据漏桶理论来说，程序整体的性能取决于最慢的操作也就是磁盘访问速度。&lt;/p&gt;
&lt;p&gt;因为 CPU 速度太快了，所以为了发挥 CPU 的速度优势，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU 使用缓存来中和和内存的访问速度差异&lt;/li&gt;
&lt;li&gt;操作系统提供进程和线程调度，让 CPU 在执行指令的同时分时复用线程，让内存和磁盘不断交互，不同的 &lt;code&gt;CPU 时间片&lt;/code&gt; 能够执行不同的任务，从而均衡这三者的差异&lt;/li&gt;
&lt;li&gt;编译程序提供优化指令的执行顺序，让缓存能够合理的使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在享受这些便利的同时，多线程也为我们带来了挑战，下面我们就来探讨一下并发问题为什么会出现以及多线程的源头是什么&lt;/p&gt;
&lt;h3 id=&quot;线程带来的安全性问题&quot;&gt;线程带来的安全性问题&lt;/h3&gt;
&lt;p&gt;线程安全性是非常复杂的，在没有采用&lt;code&gt;同步机制&lt;/code&gt;的情况下，多个线程中的执行操作往往是不可预测的，这也是多线程带来的挑战之一，下面我们给出一段代码，来看看安全性问题体现在哪&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TSynchronized implements Runnable{

    static int i = 0;

    public void increase(){
        i++;
    }


    @Override
    public void run() {
        for(int i = 0;i &amp;lt; 1000;i++) {
            increase();
        }
    }

    public static void main(String[] args) throws InterruptedException {

        TSynchronized tSynchronized = new TSynchronized();
        Thread aThread = new Thread(tSynchronized);
        Thread bThread = new Thread(tSynchronized);
        aThread.start();
        bThread.start();
        System.out.println(&quot;i = &quot; + i);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段程序输出后会发现，i 的值每次都不一样，这不符合我们的预测，那么为什么会出现这种情况呢？我们先来分析一下程序的运行过程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TSynchronized&lt;/code&gt; 实现了 Runnable 接口，并定义了一个静态变量 &lt;code&gt;i&lt;/code&gt;，然后在 &lt;code&gt;increase&lt;/code&gt; 方法中每次都增加 i 的值，在其实现的 run 方法中进行循环调用，共执行 1000 次。&lt;/p&gt;
&lt;h4 id=&quot;可见性问题&quot;&gt;可见性问题&lt;/h4&gt;
&lt;p&gt;在单核 CPU 时代，所有的线程共用一个 CPU，CPU 缓存和内存的一致性问题容易解决，CPU 和 内存之间&lt;/p&gt;
&lt;p&gt;如果用图来表示的话我想会是下面这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072934972-975858020.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在多核时代，因为有多核的存在，每个核都能够独立的运行一个线程，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072944095-514390573.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 i 是静态变量，没有经过任何线程安全措施的保护，多个线程会并发修改 i 的值，所以我们认为 i 不是线程安全的，导致这种结果的出现是由于 aThread 和 bThread 中读取的 i 值彼此不可见，所以这是由于 &lt;code&gt;可见性&lt;/code&gt; 导致的线程安全问题。&lt;/p&gt;
&lt;h4 id=&quot;原子性问题&quot;&gt;原子性问题&lt;/h4&gt;
&lt;p&gt;看起来很普通的一段程序却因为两个线程 &lt;code&gt;aThread&lt;/code&gt; 和 &lt;code&gt;bThread&lt;/code&gt; 交替执行产生了不同的结果。但是根源不是因为创建了两个线程导致的，多线程只是产生线程安全性的必要条件，最终的根源出现在 &lt;code&gt;i++&lt;/code&gt; 这个操作上。&lt;/p&gt;
&lt;p&gt;这个操作怎么了？这不就是一个给 i 递增的操作吗？也就是 &lt;strong&gt;i++ =&amp;gt; i = i + 1&lt;/strong&gt;，这怎么就会产生问题了？&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;i++&lt;/code&gt; 不是一个 &lt;code&gt;原子性&lt;/code&gt; 操作，仔细想一下，i++ 其实有三个步骤，读取 i 的值，执行 i + 1 操作，然后把 i + 1 得出的值重新赋给 i（将结果写入内存）。&lt;/p&gt;
&lt;p&gt;当两个线程开始运行后，每个线程都会把 i 的值读入到 CPU 缓存中，然后执行 + 1 操作，再把 + 1 之后的值写入内存。因为线程间都有各自的虚拟机栈和程序计数器，他们彼此之间没有数据交换，所以当 aThread 执行 + 1 操作后，会把数据写入到内存，同时 bThread 执行 + 1 操作后，也会把数据写入到内存，因为 CPU 时间片的执行周期是不确定的，所以会出现当 aThread 还没有把数据写入内存时，bThread 就会读取内存中的数据，然后执行 + 1操作，再写回内存，从而覆盖 i 的值，导致 aThread 所做的努力白费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807072955340-1373383266.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么上面的线程切换会出现问题呢？&lt;/p&gt;
&lt;p&gt;我们先来考虑一下正常情况下（即不会出现线程安全性问题的情况下）两条线程的执行顺序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807073003010-1244933600.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当 aThread 在执行完整个 i++ 的操作后，操作系统对线程进行切换，由 aThread -&amp;gt; bThread，这是最理想的操作，一旦操作系统在任意 &lt;code&gt;读取/增加/写入&lt;/code&gt; 阶段产生线程切换，都会产生线程安全问题。例如如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807073049627-895943339.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最开始的时候，内存中 i = 0，aThread 读取内存中的值并把它读取到自己的寄存器中，执行 +1 操作，此时发生线程切换，bThread 开始执行，读取内存中的值并把它读取到自己的寄存器中，此时发生线程切换，线程切换至 aThread 开始运行，aThread 把自己寄存器的值写回到内存中，此时又发生线程切换，由 aThread -&amp;gt; bThread，线程 bThread 把自己寄存器的值 +1 然后写回内存，写完后内存中的值不是 2 ，而是 1， 内存中的 i 值被覆盖了。&lt;/p&gt;
&lt;p&gt;我们上面提到 &lt;code&gt;原子性&lt;/code&gt; 这个概念，那么什么是原子性呢？&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;并发编程的原子性操作是完全独立于任何其他进程运行的操作，原子操作多用于现代操作系统和并行处理系统中。&lt;/p&gt;
&lt;p&gt;原子操作通常在内核中使用，因为内核是操作系统的主要组件。但是，大多数计算机硬件，编译器和库也提供原子性操作。&lt;/p&gt;
&lt;p&gt;在加载和存储中，计算机硬件对存储器字进行读取和写入。为了对值进行匹配、增加或者减小操作，一般通过原子操作进行。在原子操作期间，处理器可以在同一数据传输期间完成读取和写入。 这样，其他输入/输出机制或处理器无法执行存储器读取或写入任务，直到原子操作完成为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来讲，就是&lt;strong&gt;原子操作要么全部执行，要么全部不执行&lt;/strong&gt;。数据库事务的原子性也是基于这个概念演进的。&lt;/p&gt;
&lt;h4 id=&quot;有序性问题&quot;&gt;有序性问题&lt;/h4&gt;
&lt;p&gt;在并发编程中还有带来让人非常头疼的 &lt;code&gt;有序性&lt;/code&gt; 问题，有序性顾名思义就是顺序性，在计算机中指的就是指令的先后执行顺序。一个非常显而易见的例子就是 JVM 中的&lt;code&gt;类加载&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807073107116-1963999932.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个 JVM 加载类的过程图，也称为类的生命周期，类从加载到 JVM 到卸载一共会经历五个阶段 &lt;strong&gt;加载、连接、初始化、使用、卸载&lt;/strong&gt;。这五个过程的执行顺序是一定的，但是在连接阶段，也会分为三个过程，即 &lt;strong&gt;验证、准备、解析&lt;/strong&gt; 阶段，这三个阶段的执行顺序不是确定的，通常交叉进行，在一个阶段的执行过程中会激活另一个阶段。&lt;/p&gt;
&lt;p&gt;有序性问题一般是编译器带来的，编译器有的时候确实是 &lt;strong&gt;好心办坏事&lt;/strong&gt;，它为了优化系统性能，往往更换指令的执行顺序。&lt;/p&gt;
&lt;h4 id=&quot;活跃性问题&quot;&gt;活跃性问题&lt;/h4&gt;
&lt;p&gt;多线程还会带来&lt;code&gt;活跃性&lt;/code&gt;问题，如何定义活跃性问题呢？活跃性问题关注的是 &lt;strong&gt;某件事情是否会发生&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果一组线程中的每个线程都在等待一个事件，而这个事件只能由该组中的另一个线程触发，这种情况会导致死锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单一点来表述一下，就是每个线程都在等待其他线程释放资源，而其他资源也在等待每个线程释放资源，这样没有线程抢先释放自己的资源，这种情况会产生死锁，所有线程都会无限的等待下去。&lt;/p&gt;
&lt;p&gt;换句话说，死锁线程集合中的每个线程都在等待另一个死锁线程占有的资源。但是由于所有线程都不能运行，它们之中任何一个资源都无法释放资源，所以没有一个线程可以被唤醒。&lt;/p&gt;
&lt;p&gt;如果说死锁很&lt;code&gt;痴情&lt;/code&gt;的话，那么&lt;code&gt;活锁&lt;/code&gt;用一则成语来表示就是 &lt;code&gt;弄巧成拙&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;某些情况下，当线程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。&lt;/p&gt;
&lt;p&gt;现在假想有一对并行的线程用到了两个资源。它们分别尝试获取另一个锁失败后，两个线程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有线程阻塞，但是线程仍然不会向下执行，这种状况我们称之为 &lt;code&gt;活锁(livelock)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果我们期望的事情一直不会发生，就会产生活跃性问题，比如单线程中的无限循环&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;while(true){...}

for(;;){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在多线程中，比如 aThread 和 bThread 都需要某种资源，aThread 一直占用资源不释放，bThread 一直得不到执行，就会造成活跃性问题，bThread 线程会产生&lt;code&gt;饥饿&lt;/code&gt;，我们后面会说。&lt;/p&gt;
&lt;h4 id=&quot;性能问题&quot;&gt;性能问题&lt;/h4&gt;
&lt;p&gt;与活跃性问题密切相关的是 &lt;code&gt;性能&lt;/code&gt; 问题，如果说活跃性问题关注的是最终的结果，那么性能问题关注的就是造成结果的过程，性能问题有很多方面：比如服务时间过长，吞吐率过低，资源消耗过高，在多线程中这样的问题同样存在。&lt;/p&gt;
&lt;p&gt;在多线程中，有一个非常重要的性能因素那就是我们上面提到的 &lt;code&gt;线程切换&lt;/code&gt;，也称为 &lt;code&gt;上下文切换(Context Switch)&lt;/code&gt;，这种操作开销很大。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在计算机世界中，老外都喜欢用 context 上下文这个词，这个词涵盖的内容很多，包括上下文切换的资源，寄存器的状态、程序计数器等。context switch 一般指的就是这些上下文切换的资源、寄存器状态、程序计数器的变化等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上下文切换中，会保存和恢复上下文，丢失局部性，把大量的时间消耗在线程切换上而不是线程运行上。&lt;/p&gt;
&lt;p&gt;为什么线程切换会开销如此之大呢？线程间的切换会涉及到以下几个步骤&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807073121131-1337969795.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将 CPU 从一个线程切换到另一线程涉及挂起当前线程，保存其状态，例如寄存器，然后恢复到要切换的线程的状态，加载新的程序计数器，此时线程切换实际上就已经完成了；此时，CPU 不在执行线程切换代码，进而执行新的和线程关联的代码。&lt;/p&gt;
&lt;h3 id=&quot;引起线程切换的几种方式&quot;&gt;引起线程切换的几种方式&lt;/h3&gt;
&lt;p&gt;线程间的切换一般是操作系统层面需要考虑的问题，那么引起线程上下文切换有哪几种方式呢？或者说线程切换有哪几种诱因呢？主要有下面几种引起上下文切换的方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前正在执行的任务完成，系统的 CPU 正常调度下一个需要运行的线程&lt;/li&gt;
&lt;li&gt;当前正在执行的任务遇到 I/O 等阻塞操作，线程调度器挂起此任务，继续调度下一个任务。&lt;/li&gt;
&lt;li&gt;多个任务并发抢占锁资源，当前任务没有获得锁资源，被线程调度器挂起，继续调度下一个任务。&lt;/li&gt;
&lt;li&gt;用户的代码挂起当前任务，比如线程执行 sleep 方法，让出CPU。&lt;/li&gt;
&lt;li&gt;使用硬件中断的方式引起上下文切换&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线程安全性&quot;&gt;线程安全性&lt;/h2&gt;
&lt;p&gt;在 Java 中，要实现线程安全性，必须要正确的使用线程和锁，但是这些只是满足线程安全的一种方式，要编写正确无误的线程安全的代码，其核心就是对状态访问操作进行管理。最重要的就是最 &lt;code&gt;共享(Shared)&lt;/code&gt;的 和 &lt;code&gt;可变(Mutable)&lt;/code&gt;的状态。只有共享和可变的变量才会出现问题，私有变量不会出现问题，参考&lt;code&gt;程序计数器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对象的状态可以理解为存储在实例变量或者静态变量中的数据，共享意味着某个变量可以被多个线程同时访问、可变意味着变量在生命周期内会发生变化。一个变量是否是线程安全的，取决于它是否被多个线程访问。要使变量能够被安全访问，必须通过同步机制来对变量进行修饰。&lt;/p&gt;
&lt;p&gt;如果不采用同步机制的话，那么就要避免多线程对共享变量的访问，主要有下面两种方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要在多线程之间共享变量&lt;/li&gt;
&lt;li&gt;将共享变量置为不可变的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们说了这么多次线程安全性，那么什么是线程安全性呢？&lt;/p&gt;
&lt;h3 id=&quot;什么是线程安全性&quot;&gt;什么是线程安全性&lt;/h3&gt;
&lt;p&gt;根据上面的探讨，我们可以得出一个简单的定义：&lt;strong&gt;当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;单线程就是一个线程数量为 1 的多线程，单线程一定是线程安全的。读取某个变量的值不会产生安全性问题，因为不管读取多少次，这个变量的值都不会被修改。&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;原子性&lt;/h3&gt;
&lt;p&gt;我们上面提到了原子性的概念，你可以把原子性操作想象成为一个&lt;code&gt;不可分割&lt;/code&gt; 的整体，它的结果只有两种，要么全部执行，要么全部回滚。你可以把原子性认为是 &lt;code&gt;婚姻关系&lt;/code&gt; 的一种，男人和女人只会产生两种结果，&lt;code&gt;好好的&lt;/code&gt; 和 &lt;code&gt;说散就散&lt;/code&gt;，一般男人的一生都可以把他看成是原子性的一种，当然我们不排除&lt;code&gt;时间管理(线程切换)&lt;/code&gt;的个例，我们知道线程切换必然会伴随着安全性问题，男人要出去浪也会造成两种结果，这两种结果分别对应安全性的两个结果：线程安全（好好的）和线程不安全（说散就散）。&lt;/p&gt;
&lt;h3 id=&quot;竞态条件&quot;&gt;竞态条件&lt;/h3&gt;
&lt;p&gt;有了上面的线程切换的功底，那么竞态条件也就好定义了，它指的就是&lt;strong&gt;两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)&lt;/strong&gt; ，线程切换是导致竞态条件出现的诱导因素，我们通过一个示例来说明，来看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RaceCondition {
  
  private Signleton single = null;
  public Signleton newSingleton(){
    if(single == null){
      single = new Signleton();
    }
    return single;
  }
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，涉及到一个竞态条件，那就是判断 &lt;code&gt;single&lt;/code&gt; 的时候，如果 single 判断为空，此时发生了线程切换，另外一个线程执行，判断 single 的时候，也是空，执行 new 操作，然后线程切换回之前的线程，再执行 new 操作，那么内存中就会有两个 Singleton 对象。&lt;/p&gt;
&lt;h3 id=&quot;加锁机制&quot;&gt;加锁机制&lt;/h3&gt;
&lt;p&gt;在 Java 中，有很多种方式来对共享和可变的资源进行加锁和保护。Java 提供一种内置的机制对资源进行保护：&lt;code&gt;synchronized&lt;/code&gt; 关键字，它有三种保护机制&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对方法进行加锁，确保多个线程中只有一个线程执行方法；&lt;/li&gt;
&lt;li&gt;对某个对象实例（在我们上面的探讨中，变量可以使用对象来替换）进行加锁，确保多个线程中只有一个线程对对象实例进行访问；&lt;/li&gt;
&lt;li&gt;对类对象进行加锁，确保多个线程只有一个线程能够访问类中的资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;synchronized 关键字对资源进行保护的代码块俗称 &lt;code&gt;同步代码块(Synchronized Block)&lt;/code&gt;，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;synchronized(lock){
  // 线程安全的代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为 &lt;code&gt;内置锁(Instrinsic Lock)&lt;/code&gt;或者 &lt;code&gt;监视器锁(Monitor Lock)&lt;/code&gt;。线程在进入同步代码之前会自动获得锁，并且在退出同步代码时自动释放锁，而无论是通过正常执行路径退出还是通过异常路径退出，获得内置锁的唯一途径就是进入这个由锁保护的同步代码块或方法。&lt;/p&gt;
&lt;p&gt;synchronized 的另一种隐含的语义就是 &lt;code&gt;互斥&lt;/code&gt;，互斥意味着&lt;code&gt;独占&lt;/code&gt;，最多只有一个线程持有锁，当线程 A 尝试获得一个由线程 B 持有的锁时，线程 A 必须等待或者阻塞，直到线程 B 释放这个锁，如果线程 B 不释放锁的话，那么线程 A 将会一直等待下去。&lt;/p&gt;
&lt;p&gt;线程 A 获得线程 B 持有的锁时，线程 A 必须等待或者阻塞，但是获取锁的线程 B 可以重入，重入的意思可以用一段代码表示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Retreent {
  
  public synchronized void doSomething(){
    doSomethingElse();
    System.out.println(&quot;doSomething......&quot;);
  }
  
  public synchronized void doSomethingElse(){
    System.out.println(&quot;doSomethingElse......&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取 doSomething() 方法锁的线程可以执行 doSomethingElse() 方法，执行完毕后可以重新执行 doSomething() 方法中的内容。锁重入也支持子类和父类之间的重入，具体的我们后面会进行介绍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 是一种轻量级的 &lt;code&gt;synchronized&lt;/code&gt;，也就是一种轻量级的加锁方式，volatile 通过保证共享变量的可见性来从侧面对对象进行加锁。可见性的意思就是当一个线程修改一个共享变量时，另外一个线程能够 &lt;code&gt;看见&lt;/code&gt; 这个修改的值。volatile 的执行成本要比 &lt;code&gt;synchronized&lt;/code&gt; 低很多，因为 volatile 不会引起线程的上下文切换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807073136379-431472882.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 volatile 的具体实现，我们后面会说。&lt;/p&gt;
&lt;p&gt;我们还可以使用&lt;code&gt;原子类&lt;/code&gt; 来保证线程安全，原子类其实就是 &lt;code&gt;rt.jar&lt;/code&gt; 下面以 &lt;code&gt;atomic&lt;/code&gt; 开头的类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200807073156325-841071922.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，我们还可以使用 &lt;code&gt;java.util.concurrent&lt;/code&gt; 工具包下的线程安全的集合类来确保线程安全，具体的实现类和其原理我们后面会说。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 23:33:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>我一直没有急于写并发的原因是我参不透操作系统，如今，我已经把操作系统刷了一遍，这次试着写一些并发，看看能不能写清楚，卑微小编在线求鼓励...... 我打算采取操作系统和并发同时结合讲起来的方式。 并发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13450201.html</dc:identifier>
</item>
<item>
<title>游戏开发中的人工智能 - 游子陈</title>
<link>http://www.cnblogs.com/cgw0827/p/13449933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgw0827/p/13449933.html</guid>
<description>&lt;p&gt;今天非常开心，观看cocos官方直播居然在几千人中中奖，可以买彩票了。&lt;br/&gt;言归正传，所谓的人工智能，也就是大家常说的AI（Artificial Intelligence）。一说到AI可能就会让人觉得比较深奥，其实也就是非玩家角色思考和行为的综合。比如，在什么样的条件下，触发什么样的行为。&lt;br/&gt;其实我们在游戏开发中的AI要比学术理论中的AI简单很多，甚至有些行为不需要AI也能体现。比如使用剧情对话体现非玩家角色的想法。&lt;br/&gt;那么AI 都涉及到哪些东西呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;控制器&lt;br/&gt;我理解的控制器，就是非玩家角色的大脑，是用来思考事情的。例如通过执行决策树，得到一个有效的行为。使用不一样的控制器就会有不一样的思考方式。比如玩家的控制器就是根据按键操作触发不同的行为。阿猫，阿狗的可能又不一样了。&lt;/li&gt;
&lt;li&gt;感知器&lt;br/&gt;获得周围环境的情况，不如距离谁有多远，自身生命值多少，玩家生命值多少，等等。&lt;/li&gt;
&lt;li&gt;反应&lt;br/&gt;也就是控制器执行决策树后产生的有效行为。比如跳跃，跑，各种攻击，防御等等。&lt;/li&gt;
&lt;li&gt;决策树&lt;br/&gt;我理解为思考时的思路，比如应该在什么样的条件下执行什么样的反应。比如当我的血量低于百分之30的时候我要逃跑。具体案例体现在我的游戏《星际迷航》的第一个boss身上。&lt;/li&gt;
&lt;li&gt;记忆&lt;br/&gt;就是非玩家角色可以通过存储数据，供控制器执行的时候使用，以提高非玩家角色的智商。&lt;/li&gt;
&lt;li&gt;学习&lt;br/&gt;这个能力太牛逼了。实现起来也比较复杂，需要大量的数据和计算量为依托，而且在游戏开发中也并不一定实用。因此我也没用过。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先还是要定义好行为枚举，通过状态机，不同的行为实现不同的逻辑。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001553232-226588810.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001553694-1880778163.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定义感知器特征&lt;br/&gt;不同的游戏感知的特征肯定是不一样的，根据游戏需求而定&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001554085-199469396.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现感知类&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001554597-517104133.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义决策树&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;export default class DecisionTree {

    private decisionData: XlsxData;
    private perception: Perception;

    constructor(data: XlsxData) {
        this.decisionData = data;
    }

    setPerception(perception: Perception) {
        this.perception = perception;
    }

    getPerception(obj, perceptionType: PerceptionType, value: number) {
        return this.perception.action(obj, perceptionType, value)
    }
    //开始思考
    action(obj: RoleView, decisionID: number) {

        let data = this.decisionData.getRowData(decisionID)
        let flag = false;
        if (data) {
            let perceptionType = data[Ai_dataEnum.condition];
            let type = 0;
            let id: number[] = null;
            flag = this.perception.action(obj, perceptionType, data[Ai_dataEnum.cParam])
            if (flag) {
                type = data[Ai_dataEnum.conditionYes]
                id = data[Ai_dataEnum.parm1]
            } else {
                type = data[Ai_dataEnum.conditionNo]
                id = data[Ai_dataEnum.parm2]
            }
            this.judge(obj, type, id)
        }else{
        }
        return flag;
    }
    //判定感知条件
    private judge(obj: RoleView, type: ThinkType, param: number[]) {
        if (type == ThinkType.ACTION) {
            this.doLogic(obj, param)
        } else {
            for (let index = 0; index &amp;lt; param.length; index++) {
                const element = param[index];
                if (this.action(obj, element)) {
                    break;//目前仅支持串行，不支持并行。如需支持并行，需要添加是否拦截字段。
                }
            }
        }
    }

    // 50 30 20 : 80  根据概率选择行为
    private doLogic(obj: RoleView, param: number[]) {
        if (param.length &amp;gt; 0) {
            let r = RandomHelper.random(0, 100);
            let count = param.length / 2
            for (let index = 0; index &amp;lt; count; index++) {
                let behaveType: number = param[index * 2]
                let random: number = param[index * 2 + 1]
                //
                if (r &amp;lt;= random) {
                    // 设置非玩家角色的行为。
                    obj.setBehaveType(behaveType)
                    return;
                }
            }
        }


    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;定义控制器&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;export default class EnemyController extends GameController {

    private perception: Perception = new Perception();
    private ai: DecisionTree;
    constructor() {
        super()
        let ai_data: XlsxData = GameDataManager.instance().get(DataName.ai_data)
        this.ai = new DecisionTree(ai_data)
        this.ai.setPerception(this.perception)
    }

    getPerception(obj, perceptionType: PerceptionType, value: number) {
        return this.perception.action(obj, perceptionType, value)
    }

    action(obj: RoleView, decisionID: number) {
        this.ai.action(obj, decisionID)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在非玩家角色中声明控制器和行为管理器&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001555059-1909583949.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义思考函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    think() {
        this.ai.action(this, this.model.getAI())
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;调用&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001555376-1177425.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在动作执行结束后，如果非玩家角色没有死亡，就会执行一次。然后再决策树中调用非玩家角色的设置行为的方法。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001555992-1586909774.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此 ，就执行了一次AI的完整流程。从代码中我们可以看到，控制器是通过配置表数据执行操作的，接下来我们看配置表部分。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001556466-72340252.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先数据表是二维的，我们要通过二维表模拟了树形结构。判定条件就是感知特征的枚举值，判定参数是留给感知器使用的参数，如果不需要可以不填，中文部分可以仅用于注释，并不会导出，判定条件成立或者不成立的时候都会用0和1来决定是继续判定还是处理行为选择。如果是0 后一列的数据会填写下一个节点的ID，也就是继续思考，如果是1，表示可以执行对应的处理。 此时，后边的列里边我是存放了行为枚举值和对应的概率。因为并不是所有行为都是百分之百执行的。将这个表导出之后提供给控制器使用就可以了。&lt;/li&gt;
&lt;li&gt;数据表的索引方式&lt;br/&gt;对于简单的ai，可以一个敌人对应一个决策树ID；对于复杂的AI，可以一个敌人的一个动作对应一个决策树AI。所以这里抛出了一个问题，就是手动填写这样的表，维护成本也比较高了，所以这里对于复杂的AI需求，建议自己开发个小工具，这样用起来不易出错，且容易维护。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上就是我个人对游戏开发中AI的理解，当然我是拜读了《游戏人工智能——计算机游戏中的人工智能》这本书的。好像此书已经绝版了。希望放出来对热衷于游戏开发的小伙伴们有所帮助。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202008/330473-20200807001556697-243570783.webp&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎扫码关注公众号《微笑游戏》，浏览更多内容。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 16:16:00 +0000</pubDate>
<dc:creator>游子陈</dc:creator>
<og:description>前言 今天非常开心，观看cocos官方直播居然在几千人中中奖，可以买彩票了。 言归正传，所谓的人工智能，也就是大家常说的AI（Artificial Intelligence）。一说到AI可能就会让人觉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cgw0827/p/13449933.html</dc:identifier>
</item>
<item>
<title>Canal v1.1.4版本避坑指南 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/13449920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/13449920.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;在忍耐了很久之后，忍不住爆发了，在掘金发了条沸点（下班时发的）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/f-u-c-k-c-a-n-a-l-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个&lt;strong&gt;令人悲伤的故事&lt;/strong&gt;，这条情感爆发的沸点好像被屏蔽了，另外小水渠（&lt;code&gt;Canal&lt;/code&gt;意为水道、管道）上线一段时间，不出坑的时候风平浪静，一旦出坑令人想屎。重点吐槽几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;目前最新的&lt;code&gt;RELEASE&lt;/code&gt;版本为&lt;code&gt;v1.1.4&lt;/code&gt;，发布于&lt;code&gt;2019-9-2&lt;/code&gt;，快一年没更新了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Issue&lt;/code&gt;里面堆积了十分多未处理或者没有回应的问题，有不少问题的年纪比较大。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;分支经常提交异常的代码，构建不友好，因为&lt;code&gt;v1.1.4&lt;/code&gt;比较多问题，也曾经想过用&lt;code&gt;master&lt;/code&gt;代码手动构建，导入项目之后决定放弃，谁试试谁知道，可以尝试对比导入和构建&lt;code&gt;MyBatis&lt;/code&gt;的源码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些都只是表象，下面聊聊踩过的坑。&lt;/p&gt;
&lt;h2 id=&quot;解析线程阻塞问题&quot;&gt;解析线程阻塞问题&lt;/h2&gt;
&lt;p&gt;这个基本是每个使用&lt;code&gt;Canal&lt;/code&gt;的开发者的必踩之坑。&lt;code&gt;$CANAL_HOME/conf/canal.properties&lt;/code&gt;配置文件中存在一行注释掉的配置：&lt;code&gt;canal.instance.parser.parallelThreadSize = 16&lt;/code&gt;。该配置用于指定解析器实例并发线程数，如果注释了会导致解析线程阻塞，得到的结果就是什么都不会发生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/f-u-c-k-c-a-n-a-l-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注释解除即可，建议使用默认值&lt;code&gt;16&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;表结构缓存异常阻塞问题&quot;&gt;表结构缓存异常阻塞问题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/f-u-c-k-c-a-n-a-l-4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是&lt;code&gt;Issue&lt;/code&gt;里面很大部分提问者提到但是久未解决的问题，也就是表结构元数据的存储问题（配置项里面使用了&lt;code&gt;tsdb&lt;/code&gt;也就是时序数据库的字眼，下面就称为&lt;code&gt;tsdb&lt;/code&gt;功能）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/f-u-c-k-c-a-n-a-l-3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认开启&lt;code&gt;tsdb&lt;/code&gt;功能，也就是会通过&lt;code&gt;h2&lt;/code&gt;数据库缓存解析的表结构，但是实际情况下，如果上游变更了表结构，&lt;code&gt;h2&lt;/code&gt;数据库对应的缓存是不会更新的，这个时候一般会出现神奇的解析异常，异常的信息一般如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Caused by: com.alibaba.otter.canal.parse.exception.CanalParseException: column size is not match for table:数据库名称.表名称,新表结构的字段数量 vs 缓存表结构的字段数量;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该异常还会导致一个可怕的后果：解析线程被阻塞，也就是&lt;code&gt;binlog&lt;/code&gt;事件不会再接收和解析。这个问题笔者也查看过很多&lt;code&gt;Issue&lt;/code&gt;，大家都认为是一个严重的&lt;code&gt;BUG&lt;/code&gt;，目前认为比较可行的解决方案是：禁用&lt;code&gt;tsdb&lt;/code&gt;功能（真的够粗暴），也就是&lt;code&gt;canal.instance.tsdb.enable&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;。如果不禁用&lt;code&gt;tsdb&lt;/code&gt;功能，一旦出现了该问题，必须要&lt;strong&gt;先停止&lt;/strong&gt;&lt;code&gt;Canal&lt;/code&gt;服务，接着&lt;strong&gt;删除&lt;/strong&gt;&lt;code&gt;$CANAL_HOME/conf/目标数据库实例标识/h2.mv.db&lt;/code&gt;文件，然后&lt;strong&gt;启动&lt;/strong&gt;&lt;code&gt;Canal&lt;/code&gt;服务。&lt;/p&gt;
&lt;p&gt;因为这个比较坑的问题，笔者在生产禁用了&lt;code&gt;tsdb&lt;/code&gt;功能，并且添加了&lt;code&gt;DDL&lt;/code&gt;语句的处理逻辑，直接打到钉钉预警上并且&lt;code&gt;@&lt;/code&gt;整个群的人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/f-u-c-k-c-a-n-a-l-5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次看到这个预警都心惊胆战。&lt;/p&gt;
&lt;h2 id=&quot;日志问题&quot;&gt;日志问题&lt;/h2&gt;
&lt;p&gt;如果刚好需要定位的&lt;code&gt;binlog&lt;/code&gt;位点处于比较靠后的文件，文件数量比较多，会疯狂打印寻位的日志。之前尝试过重启一下子打印了几&lt;code&gt;GB&lt;/code&gt;日志，超过&lt;code&gt;99%&lt;/code&gt;是定位&lt;code&gt;binlog&lt;/code&gt;文件和&lt;code&gt;position&lt;/code&gt;的日志行。可以考虑通过修改&lt;code&gt;$CANAL_HOME/conf/logback.xml&lt;/code&gt;（并不建议，不清楚源码容易造成其他新的问题）配置或者指定&lt;code&gt;$CANAL_HOME/conf/目标数据库实例标识/instance.properties&lt;/code&gt;的下面几个属性手动定位解析的起点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;canal.instance.master.journal.name=binlog的文件名
canal.instance.master.position=binlog的文件中的位点
canal.instance.master.timestamp=时间戳
canal.instance.master.gtid=gtid的值
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上的手动定位解析的起点的属性需要在下次重启Canal之前更新或者注释掉，否则会造成重新解析或者找不到文件的严重后果！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;反正每次重启&lt;code&gt;Canal&lt;/code&gt;服务都惊心动魄，没有一个开源软件可以让人有这种感觉&lt;/strong&gt;。因为生产的服务器磁盘不是很充足，选配的时候只买了100&lt;code&gt;GB&lt;/code&gt;，而且考虑到这些日志本质上没有太大意义，于是只能定期上去删日志，前期是手动删，后来觉得麻烦写了个&lt;code&gt;Shell&lt;/code&gt;脚本定时删除久远的日志文件。&lt;/p&gt;
&lt;h2 id=&quot;云rds-mysql的使用问题&quot;&gt;云RDS MySQL的使用问题&lt;/h2&gt;
&lt;p&gt;如果刚好使用了阿里云的&lt;code&gt;RDS MySQL&lt;/code&gt;，那么有可能会遭遇更大的坑。主要问题是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RDS MySQL&lt;/code&gt;有磁盘空间优化规则，触发了规则会把&lt;code&gt;binlog&lt;/code&gt;文件上传到&lt;code&gt;OSS&lt;/code&gt;，然后删除本地的&lt;code&gt;binlog&lt;/code&gt;文件。&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;Canal&lt;/code&gt;的文档来看，会自动拉取&lt;code&gt;OSS&lt;/code&gt;上的&lt;code&gt;binlog&lt;/code&gt;文件进行解析，让使用者无感知，但是此功能有&lt;code&gt;BUG&lt;/code&gt;，一直无法正常使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RDS MySQL&lt;/code&gt;是一个暗箱，出了问题只能通过&lt;code&gt;MySQL&lt;/code&gt;的相关查询去定位问题，没有办法进去服务器查看真实的现场。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/f-u-c-k-c-a-n-a-l-6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命中了这个问题，一般​出现的异常是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;.................. sqlstate = HY000 errmsg = Could not find first log file name in binary log index file
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以基本确认这个功能是存在缺陷的，例如这里有个&lt;a href=&quot;https://github.com/alibaba/canal/issues/2596&quot;&gt;Issue-2596&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/f-u-c-k-c-a-n-a-l-7.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前笔者的做法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完全弃用&lt;code&gt;Canal&lt;/code&gt;拉取&lt;code&gt;OSS&lt;/code&gt;上的&lt;code&gt;binlog&lt;/code&gt;文件的功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RDS MySQL&lt;/code&gt;尽可能扩容一下磁盘，调整策略让尽可能多的&lt;code&gt;binlog&lt;/code&gt;文件尽可能久地保留在本地，让它们被完全解析后再手动上传或者命中了过期规则后自动上传，这期间有很多东西需要额外收取费用，具体需要自行权衡。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;读取和解析OSS上的binlog文件在目前（2020-08-05）的master分支上依然有BUG，想手动构建master分支的伙伴建议放弃幻想。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题的严重后果是：&lt;strong&gt;有比较大的可能性导致某段&lt;code&gt;binlog&lt;/code&gt;文件解析完全缺失&lt;/strong&gt;，除非可以把&lt;code&gt;binlog&lt;/code&gt;文件重新塞回去&lt;code&gt;RDS MySQL&lt;/code&gt;里面，否则需要做上下游手动同步功能。&lt;/p&gt;
&lt;h2 id=&quot;to-be-continue&quot;&gt;to be continue&lt;/h2&gt;
&lt;p&gt;除此之外，要注意&lt;code&gt;Canal&lt;/code&gt;最好做主备部署，提交位点和集群管理建议使用&lt;code&gt;Zookeeper&lt;/code&gt;，而服务模式（&lt;code&gt;canal.serverMode&lt;/code&gt;，目前支持&lt;code&gt;tcp&lt;/code&gt;、&lt;code&gt;kafka&lt;/code&gt;和&lt;code&gt;rocketmq&lt;/code&gt;）建议选用&lt;code&gt;Kafka&lt;/code&gt;（&lt;code&gt;master&lt;/code&gt;分支上有&lt;code&gt;RabbitMQ&lt;/code&gt;的连接器支持，如果想尝鲜可以手动构建一下），并且每个节点的资源要求比较高，笔者生产上每个节点使用了&lt;code&gt;2C8G&lt;/code&gt;低主频的&lt;code&gt;ECS&lt;/code&gt;，感觉有点压不住，特别时重启实例的时候如果需要重新定位&lt;code&gt;binlog&lt;/code&gt;位点，&lt;code&gt;CPU&lt;/code&gt;在一段时间内使用率会飙高。&lt;/p&gt;
&lt;p&gt;笔者发现了阿里云的&lt;code&gt;DTS&lt;/code&gt;就是使用了&lt;code&gt;Canal&lt;/code&gt;作为基础中间件进行数据同步的，说明它有被投产到实际应用场景中，真不希望它最终演变成废弃的&lt;code&gt;KPI&lt;/code&gt;任务项目。不知道往后还会遇到多少问题，如果碰到了也会持续更新本避坑指南。&lt;/p&gt;
&lt;p&gt;（本文完 c-2-d e-a-20200805）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://public-1256189093.cos.ap-guangzhou.myqcloud.com/static/wechat-account-logo.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是公众号《Throwable》发布的原创文章，收录于专辑《架构与实战》。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 16:10:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 在忍耐了很久之后，忍不住爆发了，在掘金发了条沸点（下班时发的）： 这是一个令人悲伤的故事，这条情感爆发的沸点好像被屏蔽了，另外小水渠（Canal意为水道、管道）上线一段时间，不出坑的时候风平浪静</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/13449920.html</dc:identifier>
</item>
<item>
<title>基于OpenSIPS做注册服务下，场景A打B，一方发起BYE挂断后收到500，另一方无法挂断的问题 - 玉修</title>
<link>http://www.cnblogs.com/initialjiang/p/13449745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/initialjiang/p/13449745.html</guid>
<description>&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近在工作中遇到一个看似很奇怪，排除起来很费劲，但最后的解决方式又及其简单的问题，下面我们一起来看看具体发生了什么吧！&lt;/p&gt;

&lt;p&gt;一句话概括：那都是OpenSIPS  Dialog模块的default_timeout 惹的祸（学业不精，木办法呀……）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题现象：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;A打B，电话接通后，持续通过话5分钟后，任意一方挂断电话，另一方无法正常挂断，另一方电话始终显示正在通话中。&lt;/li&gt;
&lt;li&gt;如果通话时长在4分钟以内，任何一方挂断，则另一方都能正常结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;运行环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　CentOS           7.6&lt;/li&gt;
&lt;li&gt;    OpenSIPS       2.4.2&lt;/li&gt;
&lt;li&gt;    FreeSWITCH  1.6.20&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业务场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OpenSIPs为分机提供注册服务&lt;/li&gt;
&lt;li&gt;OpenSIPs为FreeSWITCH提供Load balance服务，将电话转接至相应FreeSWITCH&lt;/li&gt;
&lt;li&gt;OpenSIPs为FreeSWITCH提供Gateway服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    如下图所示，9001拨打9003(分机互打)，OpenSIPs先将INVITE发送至FS，FS 再将电话通过OpenSIPS呼叫到 9003，通过过程中媒体流通过FS中转。&lt;/p&gt;
&lt;div&gt;        &lt;img src=&quot;https://img2020.cnblogs.com/blog/773260/202008/773260-20200807084355248-1253038383.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;


&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;问题分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过抓包分析，发现主被叫任意一方挂断后，FS收到bye后，直接回给OpenSIPS 500 (Internal Server Error), 而导致OpenSIPS没能将bye信号发给另一方电话终端&lt;/li&gt;
&lt;li&gt;OpenSIPS 给FS和电话终端发OPTIONS检测会话状态只发4分钟后，就不再发了，并且主被双方可以继续通话&lt;/li&gt;
&lt;li&gt;如果OpenSIPS关闭掉对FS的dialog会话OPTIONS检测，FS收到BYE后，能转发到另一方电话终端，但终端会返回500，而没有无法返回200 OK&lt;/li&gt;
&lt;li&gt;电话呼叫四分钟之内正常挂断的BYE报文，跟超过4分钟无法挂断的BYE报文相比，构造形式完全相同（可排除BYE信令内容问题）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;      SIP信令时序图部分内容如下所示：&lt;/p&gt;
&lt;div&gt;           &lt;img src=&quot;https://img2020.cnblogs.com/blog/773260/202008/773260-20200806220317575-271592166.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;

&lt;p&gt;    下面是FreeSWITCH 收到 分机9003 发起的BYE之后的SIP报文情况：&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2e90830b-fb37-4557-94bb-403c3ccade09')&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_2e90830b-fb37-4557-94bb-403c3ccade09&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_2e90830b-fb37-4557-94bb-403c3ccade09&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2e90830b-fb37-4557-94bb-403c3ccade09&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; ------------------------------------------------------------------------
&lt;span&gt; 2&lt;/span&gt; recv &lt;span&gt;839&lt;/span&gt; bytes from udp/[&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.112&lt;/span&gt;]:&lt;span&gt;5060&lt;/span&gt; at &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;12.270989&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    ------------------------------------------------------------------------
&lt;span&gt; 4&lt;/span&gt;    BYE sip:&lt;span&gt;9001&lt;/span&gt;@&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.116&lt;/span&gt;:&lt;span&gt;5080&lt;/span&gt;;transport=udp SIP/&lt;span&gt;2.0&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;    Via: SIP/&lt;span&gt;2.0&lt;/span&gt;/UDP &lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.112&lt;/span&gt;:&lt;span&gt;5060&lt;/span&gt;;branch=z9hG4bK4a88.a1534783.&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;    Via: SIP/&lt;span&gt;2.0&lt;/span&gt;/UDP &lt;span&gt;10.32&lt;/span&gt;.&lt;span&gt;26.19&lt;/span&gt;:&lt;span&gt;1150&lt;/span&gt;;branch=z9hG4bK-d87543-eb259935be711165-&lt;span&gt;1&lt;/span&gt;--d87543-
&lt;span&gt; 7&lt;/span&gt;    Max-Forwards: &lt;span&gt;69&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;    Contact: &amp;lt;sip:&lt;span&gt;9003&lt;/span&gt;@&lt;span&gt;10.32&lt;/span&gt;.&lt;span&gt;26.19&lt;/span&gt;:&lt;span&gt;1150&lt;/span&gt;;transport=udp&amp;gt;
&lt;span&gt; 9&lt;/span&gt;    To: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;sip:&lt;span&gt;9001&lt;/span&gt;@&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.112&lt;/span&gt;&amp;gt;;tag=&lt;span&gt;p4v8FyNvv3S5D
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    From: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;sip:&lt;span&gt;9003&lt;/span&gt;@&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.112&lt;/span&gt;&amp;gt;;tag=&lt;span&gt;e7553b0b
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    Call-&lt;span&gt;ID: NzA5YjM0OGVlM2JmMDA4NTAyZDliZmNhZWE2NjhiMDA.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;    CSeq: &lt;span&gt;3&lt;/span&gt;&lt;span&gt; BYE
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    Proxy-Authorization: Digest username=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,realm=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10.2.32.112&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,nonce=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5f2bf37b000000d2afc1e61869246645da21b40ab086deaf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,uri=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sip:9001@10.2.32.116:5080;transport=udp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,response=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6a89ecdf3476a98ce0a89ee15ba29312&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,algorithm=&lt;span&gt;MD5
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    User-Agent: eyeBeam release 1011d stamp &lt;span&gt;40820&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    Reason: SIP;description=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User Hung Up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;    Content-Length: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;    ------------------------------------------------------------------------
&lt;span&gt;19&lt;/span&gt; send &lt;span&gt;375&lt;/span&gt; bytes to udp/[&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.112&lt;/span&gt;]:&lt;span&gt;5060&lt;/span&gt; at &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;12.271131&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;    ------------------------------------------------------------------------
&lt;span&gt;21&lt;/span&gt;    SIP/&lt;span&gt;2.0&lt;/span&gt; &lt;span&gt;500&lt;/span&gt;&lt;span&gt; Internal Server Error
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;    Via: SIP/&lt;span&gt;2.0&lt;/span&gt;/UDP &lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.112&lt;/span&gt;:&lt;span&gt;5060&lt;/span&gt;;branch=z9hG4bK4a88.a1534783.&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;    Via: SIP/&lt;span&gt;2.0&lt;/span&gt;/UDP &lt;span&gt;10.32&lt;/span&gt;.&lt;span&gt;26.19&lt;/span&gt;:&lt;span&gt;1150&lt;/span&gt;;branch=z9hG4bK-d87543-eb259935be711165-&lt;span&gt;1&lt;/span&gt;--d87543-
&lt;span&gt;24&lt;/span&gt;    From: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;sip:&lt;span&gt;9003&lt;/span&gt;@&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.112&lt;/span&gt;&amp;gt;;tag=&lt;span&gt;e7553b0b
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;    To: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;sip:&lt;span&gt;9001&lt;/span&gt;@&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;32.112&lt;/span&gt;&amp;gt;;tag=&lt;span&gt;p4v8FyNvv3S5D
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;    Call-&lt;span&gt;ID: NzA5YjM0OGVlM2JmMDA4NTAyZDliZmNhZWE2NjhiMDA.
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;    CSeq: &lt;span&gt;3&lt;/span&gt;&lt;span&gt; BYE
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;    Content-Length: &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;问题原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    通过上面分析，我们可以猜测这是由于OpenSIPS对dialog做OPTIONS探测引起的。仔细检测OpenSIPS的dialog 模块配置，我发现dialog模块的 default_timeout = 240 (秒)。&lt;/p&gt;
&lt;p&gt;    这就能充分解释上面‘问题分析’中的第2点了(只发4分钟OPTIONS)， 因为4分钟后dialog就过期了，OpenSIPS不再发送探测包。&lt;/p&gt;

&lt;p&gt;    FreeSWITCH 和 电话终端(如Yealink话机) 都遵循 SIP 协议规范，如果一通已建立的电话，在通话过程中，FS或电话终端有收到上游(如OpenSIPS)的OPTIONS探测，那么电话从接通到挂断，都必须收到周期性的进行OPTIONS探测，&lt;/p&gt;
&lt;p&gt;    如果超过周期时长了，FS或电话终端仍没有收到OPTIONS探测， 那么FS和电话终端就会认为通话存在错误，后面在收到BYE时，就会返回 500 (Internal Server Error)。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    将 OpenSIPS 的 default_timeout 值更具需要改大，如改成10800 (即3小时)，重启OpenSIPS即可解决问题。 &lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
loadmodule &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dialog.so&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
modparam(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dialog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;db_mode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
modparam(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dialog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dlg_match_mode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
####【正确配置】
&lt;span&gt;&lt;strong&gt;modparam(&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&quot;dialog&quot;, &quot;default_timeout&quot;, 10800)  # 3&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; hours timeout&lt;/strong&gt;&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;###【错误配置 ：如果使用了create_dialog(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;Pp&quot;)，当一通电话超过 default_timout +&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; options_pint_interval ，就会出现收到BYE的终端或FS返回500】&lt;/span&gt;
&lt;span&gt;#modparam(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;dialog&quot;, &quot;default_timeout&quot;, 240)  # 4&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; mins&lt;/span&gt; &lt;/strong&gt;            
modparam(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dialog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;profiles_with_value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;caller ; callee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;strong&gt;&lt;span&gt;modparam(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;dialog&quot;, &quot;options_ping_interval&quot;, 60) # 1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; mins&lt;/span&gt;&lt;/strong&gt;

route{
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (is_method(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INVITE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {&lt;br/&gt;&lt;strong&gt;&lt;span&gt;# 对OpenSIPS上进、出两个dialog（如主/被叫）都进行OPTIONS探测
      &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;if ( !create_dialog(&quot;Pp&quot;) ) { &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
         xlog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create_dialog error : Internal Server Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
         send_reply(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Internal Server Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
         exit();
      }
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;



</description>
<pubDate>Thu, 06 Aug 2020 15:22:00 +0000</pubDate>
<dc:creator>玉修</dc:creator>
<og:description>最近在工作中遇到一个看似很奇怪，排除起来很费劲，但最后的解决方式又及其简单的问题，下面我们一起来看看具体发生了什么吧！ 一句话概括：那都是OpenSIPS Dialog模块的default_timeo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/initialjiang/p/13449745.html</dc:identifier>
</item>
<item>
<title>企业权限管理系统 - 平酱</title>
<link>http://www.cnblogs.com/p1ng/p/13449731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/p1ng/p/13449731.html</guid>
<description>&lt;p&gt;此项目使用Spring+SpringMVC+MyBatis框架整合，用于企业后台权限管理。数据库使用MySQL，前端页面使用Jsp基于AdminLTE模板进行改写。&lt;/p&gt;
&lt;h2 id=&quot;功能介绍&quot;&gt;功能介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;商品查询
&lt;ul&gt;&lt;li&gt;基于SSM整合基础上完成商品查询，实现主页页面main.jsp以及商品显示页面product-list.jsp页面的创建。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;商品添加
&lt;ul&gt;&lt;li&gt;进一步巩固SSM整合，并完成商品添加功能。实现页面product-add.jsp的创建。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;订单查询
&lt;ul&gt;&lt;li&gt;订单的查询操作，它主要完成简单的多表查询操作，查询订单时，需要查询出与订单关联的其它表中信息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;订单分页查询
&lt;ul&gt;&lt;li&gt;订单分页查询，这里使用的是mybatis分页插件PageHelper。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;订单详情查询
&lt;ul&gt;&lt;li&gt;订单详情是用于查询某一个订单的详细信息，主要涉及复杂的多表查询操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring Security
&lt;ul&gt;&lt;li&gt;Spring Security是 Spring 项目组中用来提供安全认证服务的框架。此项目中只涉及Spring Security框架的配置及基本的认证与授权操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用户管理
&lt;ul&gt;&lt;li&gt;用户管理中实现了基于Spring Security的用户登录、退出操作，以及用户查询、添加、详情等操作，和订单模块类似。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;角色管理
&lt;ul&gt;&lt;li&gt;角色管理主要完成角色查询、角色添加。角色拥有对应的权限。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;资源权限管理
&lt;ul&gt;&lt;li&gt;资源权限管理主要完成查询、添加操作，它的操作与角色管理类似，角色管理以及资源权限管理都是对权限管理的&lt;br/&gt;补充。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;权限关联与控制
&lt;ul&gt;&lt;li&gt;完成用户角色关联、角色权限关联，这两个操作是为了后续完成授权操作的基础。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;AOP日志处理
&lt;ul&gt;&lt;li&gt;使用Spring AOP切面来完成系统级别的日志收集。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据库介绍&quot;&gt;数据库介绍&lt;/h2&gt;
&lt;p&gt;数据库使用MySQL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806230842274-1106578453.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806230857215-611095019.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806230904835-1434586729.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806230917706-983276465.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;订单旅客表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806230933037-753132960.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806230941960-203900848.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806230952965-829078913.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户角色表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由 userId 和 roleId 构成，分别为users表 以及 role表的外键，用来关联用户与角色的多对多关系&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;资源权限表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231016709-1128301838.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;权限角色表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由 perimissionId 和 roleId 构成，分别为permission表 以及 role表的外键，用来关联资源权限与角色的多对多关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231043505-1202837696.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231051015-556075985.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring环境搭建&quot;&gt;Spring环境搭建&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;编写Spring配置文件applicationContext.xml
&lt;ul&gt;&lt;li&gt;配置spring创建容器时要扫描的包，开启注解扫描，管理service和dao。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用注解配置业务层&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;spring-mvc环境搭建&quot;&gt;Spring MVC环境搭建&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;web.xml配置Spring MVC核心控制器
&lt;ul&gt;&lt;li&gt;配置初始化参数，用于读取springmvc的配置文件&lt;/li&gt;
&lt;li&gt;配置 servlet 的对象的创建时间点：应用加载时创建。取值只能是非 0 正整数，表示启动顺序&lt;/li&gt;
&lt;li&gt;配置SpringMVC编码过滤器等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;配置Spring MVC配置文件springmvc.xml
&lt;ul&gt;&lt;li&gt;配置扫描controller的注解&lt;/li&gt;
&lt;li&gt;配置视图解析器
&lt;ul&gt;&lt;li&gt;设置静态资源不过滤&lt;/li&gt;
&lt;li&gt;开启对SpringMVC注解的支持&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编写Controller&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;spring-与-spring-mvc-整合&quot;&gt;Spring 与 Spring MVC 整合&lt;/h2&gt;
&lt;p&gt;在 web.xml 中&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置加载类路径的配置文件，加载 applicationContext.xml 以及 用于权限认证的 spring-security.xml&lt;/li&gt;
&lt;li&gt;配置监听器&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;spring-与-mybatis-整合&quot;&gt;Spring 与 MyBatis 整合&lt;/h2&gt;
&lt;p&gt;整合思路：将mybatis配置文件（mybatis.xml）中内容配置到spring配置文件中。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring接管mybatis的Session工厂&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建 db.properties 存放数据库连接属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=root
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 applicationContext.xml 中配置连接池&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将 SqlSessionFactory 交给IOC管理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自动扫描所有Mapper接口和文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;扫描dao接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置Spring事务&lt;/p&gt;
&lt;p&gt;配置Spring的声明式事务管理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要包括查询所有产品以及添加产品两个功能，下面是两个功能的流程图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231131978-1630549065.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231152324-892398836.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;商品的状态属性数据库存放的为int数据 productStatus，0代表关闭1代表开启，实体类中多添加了一个String类型的变量为productStatusStr，在该变量的getter中对productStatus进行判断并处理成对应属性以放到页面中展示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;出发时间的属性通过 @DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm&quot;) 注解来转换格式，并编写了一个工具类data2String，将时间类转换成字符串用于页面展示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;springmvc参数类型转换三种方式&quot;&gt;springmvc参数类型转换三种方式&lt;/h2&gt;
&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;实体类中加日期格式化注解&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@DateTimeFormat(pattern=&quot;yyyy-MM-dd hh:MM&quot;)
private Date creationTime;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;属性编辑器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;spring3.1之前 在Controller类中通过@InitBinder完成&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       /**
     * 在controller层中加入一段数据绑定代码
     * @param webDataBinder
     */
    @InitBinder
    public void initBinder(WebDataBinder webDataBinder) throws Exception{
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm&quot;);
        simpleDateFormat.setLenient(false);
        webDataBinder.registerCustomEditor(Date.class , new CustomDateEditor(simpleDateFormat , true));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;**备注：自定义类型转换器必须实现PropertyEditor接口或者继承PropertyEditorSupport类 **&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;写一个类 extends propertyEditorSupport（implements PropertyEditor）{
     public void setAsText(String text){
         SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy -MM-dd hh:mm&quot;);
        Date date = simpleDateFormat.parse(text);
        this.setValue(date);
     }
     public String getAsTest(){
      Date date = (Date)this.getValue(); 
      return this.dateFormat.format(date);
     }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类型转换器Converter&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;(spring 3.0以前使用正常，以后的版本需要使用&lt;code&gt;&amp;lt; mvc:annotation-driven/&amp;gt;&lt;/code&gt;注册使用)使用xml配置实现类型转换(系统全局转换器)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)注册conversionservice&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 注册ConversionService--&amp;gt;
&amp;lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;converters&quot;&amp;gt;
        &amp;lt;set&amp;gt;
            &amp;lt;bean class=&quot;com.ezubo.global.portal.util.StringToDateConverter&quot;&amp;gt;
                        &amp;lt;constructor-arg index=&quot;0&quot; value=&quot;yyyy-MM-dd hh:mm&quot;/&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/set&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;StringToDateConverter.java的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StringToDateConverter implements Converter&amp;lt;String,Date&amp;gt; {

    private static final Logger logger = LoggerFactory.getLogger(StringToDateConverter.class);

    private String pattern;

    public StringToDateConverter(String pattern){
        this.pattern = pattern;
    }

    public Date convert(String s) {

        if(StringUtils.isBlank(s)){
            return null;
        }

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);
        simpleDateFormat.setLenient(false);
        try{
            return simpleDateFormat.parse(s);
        }catch(ParseException e){
            logger.error(&quot;转换日期异常：&quot;+e.getMessage() , e);
            throw new IllegalArgumentException(&quot;转换日期异常：&quot;+e.getMessage() , e);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2)使用 ConfigurableWebBindingInitializer 注册conversionService&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--使用 ConfigurableWebBindingInitializer 注册conversionService--&amp;gt;
&amp;lt;bean id=&quot;webBindingInitializer&quot; class=&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&amp;gt;
        &amp;lt;property name=&quot;conversionService&quot; ref=&quot;conversionService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3)注册ConfigurableWebBindingInitializer到RequestMappingHandlerAdapter&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 注册ConfigurableWebBindingInitializer 到RequestMappingHandlerAdapter--&amp;gt;
&amp;lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&amp;gt;
        &amp;lt;property name=&quot;webBindingInitializer&quot; ref=&quot;webBindingInitializer&quot;/&amp;gt;
        &amp;lt;!-- 线程安全的访问session--&amp;gt;
        &amp;lt;property name=&quot;synchronizeOnSession&quot; value=&quot;true&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（spring 3.2以后使用正常）使用&lt;code&gt;&amp;lt;mvc:annotation-driven/&amp;gt;&lt;/code&gt;注册conversionService&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)注册ConversionService&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 注册ConversionService--&amp;gt;
&amp;lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;converters&quot;&amp;gt;
                &amp;lt;set&amp;gt;
                        &amp;lt;bean class=&quot;com.ezubo.global.portal.util.StringToDateConverter&quot;&amp;gt;
                                &amp;lt;constructor-arg index=&quot;0&quot; value=&quot;yyyy-MM-dd hh:mm&quot;/&amp;gt;
                        &amp;lt;/bean&amp;gt;
                &amp;lt;/set&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2)需要修改springmvc.xml配置文件中的annotation-driven,增加属性conversion-service指向新增的 conversionService。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&amp;gt;
        &amp;lt;mvc:message-converters register-defaults=&quot;true&quot;&amp;gt;
                &amp;lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&amp;gt;
                        &amp;lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/html;charset=UTF-8&quot;/&amp;gt;
                        &amp;lt;!--转换时设置特性--&amp;gt;
                        &amp;lt;property name=&quot;features&quot;&amp;gt;
                                &amp;lt;array&amp;gt;
                    &amp;lt;!--避免默认的循环引用替换--&amp;gt;
                    &amp;lt;ref bean=&quot;DisableCircularReferenceDetect&quot;/&amp;gt;
                    &amp;lt;ref bean=&quot;WriteMapNullValue&quot;/&amp;gt;
                    &amp;lt;ref bean=&quot;WriteNullStringAsEmpty&quot;/&amp;gt;
                    &amp;lt;ref bean=&quot;WriteNullNumberAsZero&quot;/&amp;gt;
                &amp;lt;/array&amp;gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/mvc:message-converters&amp;gt;
&amp;lt;/mvc:annotation-driven&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此项目中使用的是第一种，比较简便。&lt;/p&gt;

&lt;p&gt;订单操作的相关功能介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231219418-1484156142.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231232320-75819715.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;订单的查询操作，它主要完成简单的多表查询操作，查询订单时，需要查询出与订单关联的其它表中信息。下图为订单表及其关联表关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231259998-308413275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图为查询所有订单流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231334397-1121427932.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图为查询订单详情流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231357676-1371854514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;pagehelper&quot;&gt;PageHelper&lt;/h2&gt;
&lt;p&gt;使用PageHelper进行分页查询，PageHelper是国内非常优秀的一款开源的mybatis分页插件，它支持基本主流与常用的数据库，例如mysql、oracle、mariaDB、DB2、SQLite、Hsqldb等。&lt;/p&gt;
&lt;p&gt;PageHelper使用起来非常简单，只需要导入依赖然后在spring配置文件中配置后即可使用。&lt;/p&gt;
&lt;p&gt;分页插件参数介绍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;helperDialect&lt;/code&gt; ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置&lt;br/&gt;helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：&lt;br/&gt;oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2 , sqlserver201&lt;br/&gt;2 , derby&lt;br/&gt;特别注意 ：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012 ，否则会使用 SqlServer2005 的&lt;br/&gt;方式进行分页。&lt;br/&gt;你也可以实现 AbstractHelperDialect ，然后配置该属性为实现类的全限定名称即可使用自定义的实现方&lt;br/&gt;法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offsetAsPageNum&lt;/code&gt; ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为&lt;br/&gt;true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分&lt;br/&gt;页。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rowBoundsWithCount&lt;/code&gt; ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置&lt;br/&gt;为 true 时，使用 RowBounds 分页会进行 count 查询。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pageSizeZero&lt;/code&gt; ：默认值为 false ，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit =&lt;br/&gt;0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reasonable&lt;/code&gt; ：分页合理化参数，默认值为 false 。当该参数设置为 true 时， pageNum&amp;lt;=0 时会查询第一&lt;br/&gt;页， pageNum&amp;gt;pages （超过总数时），会查询最后一页。默认 false 时，直接根据参数进行查询。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;params&lt;/code&gt; ：为了支持 startPage(Object params) 方法，增加了该参数来配置参数映射，用于从对象中根据属&lt;br/&gt;性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable ，不配置映射的用默认值， 默认&lt;br/&gt;值为&lt;code&gt;pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero&lt;/code&gt;&lt;br/&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;supportMethodsArguments&lt;/code&gt; ：支持通过 Mapper 接口参数来传递分页参数，默认值 false ，分页插件会从查&lt;br/&gt;询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法&lt;br/&gt;可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和&lt;br/&gt;ArgumentsObjTest 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;autoRuntimeDialect&lt;/code&gt; ：默认值为 false 。设置为 true 时，允许在运行时根据多数据源自动识别对应方言&lt;br/&gt;的分页 （不支持自动选择 sqlserver2012 ，只能使用 sqlserver ），用法和注意事项参考下面的场景五。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;closeConn&lt;/code&gt;：默认值为 true 。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类&lt;br/&gt;型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认 true 关闭，设置为&lt;br/&gt;false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基本使用有6种方式，最常用的有两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RowBounds方式的调用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;List&amp;lt;Country&amp;gt; list = sqlSession.selectList(&quot;x.y.selectIf&quot;, null, new RowBounds(1, 10));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用这种调用方式时，可以使用RowBounds参数进行分页，这种方式侵入性最小，通过RowBounds方式调用只是使用这个参数并没有增加其他任何内容。分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。&lt;/p&gt;
&lt;p&gt;关于这种方式的调用，有两个特殊的参数是针对 &lt;code&gt;RowBounds&lt;/code&gt; 的，具体参考上面的分页插件参数介绍。&lt;/p&gt;
&lt;p&gt;注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//这种情况下也会进行物理分页查询
List&amp;lt;Country&amp;gt; selectAll(RowBounds rowBounds);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意： 由于默认情况下的 &lt;code&gt;RowBounds&lt;/code&gt; 无法获取查询总数，分页插件提供了一个继承自 &lt;code&gt;RowBounds&lt;/code&gt; 的&lt;br/&gt;&lt;code&gt;PageRowBounds&lt;/code&gt; ，这个对象中增加了 &lt;code&gt;total&lt;/code&gt; 属性，执行分页查询后，可以从该属性得到查询总数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;PageHelper.startPage静态方法调用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种方式在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧&lt;br/&gt;跟在这个方法后的第一个MyBatis 查询方法会被进行分页。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//获取第1页，10条内容，默认查询总数count
PageHelper.startPage(1, 10);
//紧跟着的第一个select方法会被分页
List&amp;lt;Country&amp;gt; list = countryMapper.selectIf(1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用步骤总结如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231419859-285079615.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;主要涉及用户、角色、资源权限三个模块的功能，下图为三表的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231437813-264582077.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-security&quot;&gt;Spring Security&lt;/h2&gt;
&lt;p&gt;Spring Security 的前身是 Acegi Security ，是 Spring 项目组中用来提供安全认证服务的框架。&lt;/p&gt;
&lt;p&gt;Spring Security 为基于J2EE企业应用软件提供了全面安全服务。包括两个主要操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“认证”，是为用户建立一个他所声明的主体。主体一般式指用户，设备或可以在你系统中执行动作的其他系&lt;br/&gt;统。&lt;/li&gt;
&lt;li&gt;“授权”指的是一个用户能否在你的应用中执行某个操作，在到达授权判断之前，身份的主题已经由身份验证&lt;br/&gt;过程建立了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;快速入门步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231457010-186342801.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;用户管理&quot;&gt;用户管理&lt;/h2&gt;
&lt;h3 id=&quot;用户登录&quot;&gt;用户登录&lt;/h3&gt;
&lt;p&gt;使用数据库完成springSecurity用户登录流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231515803-861000985.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spring security的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;security:authentication-manager&amp;gt;
        &amp;lt;security:authentication-provider user-service-ref=&quot;userService&quot;&amp;gt;
                &amp;lt;!-- 配置加密的方式
                &amp;lt;security:password-encoder ref=&quot;passwordEncoder&quot;/&amp;gt;
                --&amp;gt;
        &amp;lt;/security:authentication-provider&amp;gt;
&amp;lt;/security:authentication-manager&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Service&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service(&quot;userService&quot;)
@Transactional
public class UserServiceImpl implements IUserService {
    
        @Autowired
        private IUserDao userDao;
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
                UserInfo userInfo = userDao.findByUsername(username);
        List&amp;lt;Role&amp;gt; roles = userInfo.getRoles();
        List&amp;lt;SimpleGrantedAuthority&amp;gt; authoritys = getAuthority(roles);
        User user = new User(userInfo.getUsername(), &quot;{noop}&quot; + userInfo.getPassword(),
        userInfo.getStatus() == 0 ? false : true, true, true, true, authoritys);
        return user;
    }
    private List&amp;lt;SimpleGrantedAuthority&amp;gt; getAuthority(List&amp;lt;Role&amp;gt; roles) {
        List&amp;lt;SimpleGrantedAuthority&amp;gt; authoritys = new ArrayList();
        for (Role role : roles) {
                authoritys.add(new SimpleGrantedAuthority(role.getRoleName()));
        }
        return authoritys;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里从userInfo中 getPassword 前面需要加上&quot;{noop}&quot;是因为数据库中的密码还未进行加密，后续在添加用户中进行加密处理后即可删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dao&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface IUserDao {
    @Select(&quot;select * from user where id=#{id}&quot;)
    public UserInfo findById(Long id) throws Exception;
    
    @Select(&quot;select * from user where username=#{username}&quot;)
    @Results({
        @Result(id = true, property = &quot;id&quot;, column = &quot;id&quot;),
        @Result(column = &quot;username&quot;, property = &quot;username&quot;),
        @Result(column = &quot;email&quot;, property = &quot;email&quot;),
        @Result(column = &quot;password&quot;, property = &quot;password&quot;),
        @Result(column = &quot;phoneNum&quot;, property = &quot;phoneNum&quot;),
        @Result(column = &quot;status&quot;, property = &quot;status&quot;),
        @Result(column = &quot;id&quot;, property = &quot;roles&quot;, javaType = List.class, many =
                @Many(select = &quot;com.itheima.ssm.dao.IRoleDao.findRoleByUserId&quot;)) })
    public UserInfo findByUsername(String username);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用户退出&quot;&gt;用户退出&lt;/h3&gt;
&lt;p&gt;使用spring security完成用户退出，非常简单&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;security:logout invalidate-session=&quot;true&quot; logout-url=&quot;/logout.do&quot; logout-success-
url=&quot;/login.jsp&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&quot;${pageContext.request.contextPath}/logout.do&quot;
                class=&quot;btn btn-default btn-flat&quot;&amp;gt;注销&amp;lt;/a&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用户查询&quot;&gt;用户查询&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231537437-961529444.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用户添加&quot;&gt;用户添加&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231550493-1237306778.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加完成后通过redirect 重定向跳转到查询所有用户。&lt;/li&gt;
&lt;li&gt;前期数据库存的用户密码没有加密，现在添加用户时，我们需要对用户密码进行加密。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 配置加密类 --&amp;gt;
&amp;lt;bean id=&quot;passwordEncoder&quot;
class=&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用户详情&quot;&gt;用户详情&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231608469-952223823.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Dao&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Select(&quot;select * from user where id=#{id}&quot;)
@Results({ @Result(id = true, property = &quot;id&quot;, column = &quot;id&quot;), @Result(column = &quot;username&quot;,
property = &quot;username&quot;),
                @Result(column = &quot;email&quot;, property = &quot;email&quot;), @Result(column =&quot;password&quot;, property = &quot;password&quot;),
                @Result(column = &quot;phoneNum&quot;, property = &quot;phoneNum&quot;), @Result(column =&quot;status&quot;, property = &quot;status&quot;),
                @Result(column = &quot;id&quot;, property = &quot;roles&quot;, javaType = List.class, many =
@Many(select = &quot;com.itheima.ssm.dao.IRoleDao.findRoleByUserId&quot;)) })
public UserInfo findById(Long id) throws Exception;

@Select(&quot;select * from role where id in( select roleId from user_role where userId=#{userId})&quot;)
@Results(
                        {
                                @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;),
                @Result(column=&quot;roleName&quot;,property=&quot;roleName&quot;),
                @Result(column=&quot;roleDesc&quot;,property=&quot;roleDesc&quot;),                                     @Result(column=&quot;id&quot;,property=&quot;permissions&quot;,javaType=List.class,many=@Many(select=&quot;com.itheima.ssm
                .dao.IPermissionDao.findByRoleId&quot;))
})
public List&amp;lt;Role&amp;gt; findRoleByUserId(Long userId);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要将用户的所有角色及权限查询出来所以需要调用IRoleDao中的findRoleByUserId,而在IRoleDao中需要调用IPermissionDao的findByRoleId&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Select(&quot;select * from permission where id in (select permissionId from role_permission where
roleId=#{roleId})&quot;)
public List&amp;lt;Permission&amp;gt; findByRoleId(Long roleId);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;角色管理&quot;&gt;角色管理&lt;/h2&gt;
&lt;h3 id=&quot;角色查询&quot;&gt;角色查询&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231629225-26264169.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;角色添加&quot;&gt;角色添加&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231645026-1134593151.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;资源权限管理&quot;&gt;资源权限管理&lt;/h2&gt;
&lt;p&gt;资源权限查询以及添加的流程和角色管理模块的一样（参考上图），只是针对的表不同。&lt;/p&gt;
&lt;h2 id=&quot;权限的关联与控制&quot;&gt;权限的关联与控制&lt;/h2&gt;
&lt;h3 id=&quot;用户角色关联&quot;&gt;用户角色关联&lt;/h3&gt;
&lt;p&gt;用户与角色之间是多对多关系，我们要建立它们之间的关系，只需要在中间表user_role插入数据即可。&lt;/p&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231704492-1961378300.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;角色权限关联&quot;&gt;角色权限关联&lt;/h3&gt;
&lt;p&gt;角色与权限之间是多对多关系，我们要建立它们之间的关系，只需要在中间表role_permission插入数据即可。&lt;/p&gt;
&lt;p&gt;流程和用户角色关联相同，参考上图。&lt;/p&gt;
&lt;h3 id=&quot;服务器端方法级权限控制&quot;&gt;服务器端方法级权限控制&lt;/h3&gt;
&lt;p&gt;在服务器端我们可以通过Spring security提供的注解对方法来进行权限控制。Spring Security在方法的权限控制上支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解，这三种注解默认都是没有启用的，需要单独通过global-method-security元素的对应属性进行启用。&lt;/p&gt;
&lt;h4 id=&quot;开启注解使用&quot;&gt;开启注解使用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;br/&gt;&amp;lt;security:global-method-security jsr250-annotations=&quot;enabled&quot;/&amp;gt;&lt;br/&gt;&amp;lt;security:global-method-security secured-annotations=&quot;enabled&quot;/&amp;gt;&lt;br/&gt;&amp;lt;security:global-method-security pre-post-annotations=&quot;disabled&quot;/&amp;gt;&lt;/li&gt;
&lt;li&gt;注解开启&lt;br/&gt;@EnableGlobalMethodSecurity ：Spring Security默认是禁用注解的，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为Bean。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;jsr-250注解&quot;&gt;JSR-250注解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;@RolesAllowed表示访问对应方法时所应该具有的角色&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;br/&gt;&lt;code&gt;@RolesAllowed({&quot;USER&quot;, &quot;ADMIN&quot;})&lt;/code&gt; 该方法只要具有&quot;USER&quot;, &quot;ADMIN&quot;任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@PermitAll表示允许所有的角色进行访问，也就是说不进行权限控制&lt;/li&gt;
&lt;li&gt;@DenyAll是和PermitAll相反的，表示无论什么角色都不能访问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231722410-679736679.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;支持表达式的注解&quot;&gt;支持表达式的注解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;@PreAuthorize 在方法调用之前,基于表达式的计算结果来限制对方法的访问&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;示例：
@PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;)
void changePassword(@P(&quot;userId&quot;) long userId ){ }
这里表示在changePassword方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一，就可以访问该方法。
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;@PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;示例：
@PostAuthorize
User getUser(&quot;returnObject.userId == authentication.principal.userId or
hasPermission(returnObject, 'ADMIN')&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果&lt;/li&gt;
&lt;li&gt;@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231739276-255290504.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;secured注解&quot;&gt;@Secured注解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;示例：
@Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;)
public Account readAccount(Long id);
@Secured(&quot;ROLE_TELLER&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231759411-1772362470.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;页面端标签控制权限&quot;&gt;页面端标签控制权限&lt;/h3&gt;
&lt;p&gt;在jsp页面中我们可以使用spring security提供的权限标签来进行权限控制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231815359-54017401.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导入：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;maven导入&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-security-taglibs&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;version&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;页面导入&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml-dtd&quot;&gt;&amp;lt;%@taglib uri=&quot;http://www.springframework.org/security/tags&quot; prefix=&quot;security&quot;%&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;常用标签&quot;&gt;常用标签&lt;/h4&gt;
&lt;p&gt;在jsp中我们可以使用以下三种标签，其中authentication代表的是当前认证对象，可以获取当前认证对象信息，例如用户名。其它两个标签我们可以用于权限控制&lt;/p&gt;
&lt;h5 id=&quot;authentication&quot;&gt;authentication&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;security:authentication property=&quot;&quot; htmlEscape=&quot;&quot; scope=&quot;&quot; var=&quot;&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;property： 只允许指定Authentication所拥有的属性，可以进行属性的级联获取，如“principle.username”，不允许直接通过方法进行调用&lt;/li&gt;
&lt;li&gt;htmlEscape：表示是否需要将html进行转义。默认为true&lt;/li&gt;
&lt;li&gt;scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥有的作用范围都进行进行指定&lt;/li&gt;
&lt;li&gt;var： 用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存放，默认是存放在pageConext中&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;authorize&quot;&gt;authorize&lt;/h5&gt;
&lt;p&gt;authorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;security:authorize access=&quot;&quot; method=&quot;&quot; url=&quot;&quot; var=&quot;&quot;&amp;gt;&amp;lt;/security:authorize&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限&lt;/li&gt;
&lt;li&gt;method：method属性是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，method的默认值为GET，可选值为http请求的7种方法&lt;/li&gt;
&lt;li&gt;url：url表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容&lt;/li&gt;
&lt;li&gt;var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;accesscontrollist&quot;&gt;accesscontrollist&lt;/h5&gt;
&lt;p&gt;accesscontrollist标签是用于鉴定ACL权限的。其一共定义了三个属性：hasPermission、domainObject和var，&lt;br/&gt;其中前两个是必须指定的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;security:accesscontrollist hasPermission=&quot;&quot; domainObject=&quot;&quot; var=&quot;&quot;&amp;gt;&amp;lt;/security:accesscontrollist&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;hasPermission：hasPermission属性用于指定以逗号分隔的权限列表&lt;/li&gt;
&lt;li&gt;domainObject：domainObject用于指定对应的域对象&lt;/li&gt;
&lt;li&gt;var：var则是用以将鉴定的结果以指定的属性名存入pageContext中，以供同一页面的其它地方使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于AOP来获取每一次操作的访问时间、操作者用户名、访问ip、访问资源url、执行市场以及访问方法存入到数据库日志表sysLog中，并展示到页面中。&lt;/p&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231849056-1217860352.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建切面类处理日志&quot;&gt;创建切面类处理日志&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@Aspect
public class LogAop {
    @Autowired
    private HttpServletRequest request;
    @Autowired
    private ISysLogService sysLogService;
    
    private Date startTime; // 访问时间
    private Class executionClass;// 访问的类
    private Method executionMethod; // 访问的方法
    // 主要获取访问时间、访问的类、访问的方法
    
    @Before(&quot;execution(* com.itheima.ssm.controller.*.*(..))&quot;)
    public void doBefore(JoinPoint jp) throws NoSuchMethodException, SecurityException {
        startTime = new Date(); // 访问时间
        // 获取访问的类
        executionClass = jp.getTarget().getClass();
        // 获取访问的方法
        String methodName = jp.getSignature().getName();// 获取访问的方法的名称
        Object[] args = jp.getArgs();// 获取访问的方法的参数
        if (args == null || args.length == 0) {// 无参数
                executionMethod = executionClass.getMethod(methodName); // 只能获取无参数方法
        } else {
                // 有参数，就将args中所有元素遍历，获取对应的Class,装入到一个Class[]
                Class[] classArgs = new Class[args.length];
            for (int i = 0; i &amp;lt; args.length; i++) {
                                classArgs[i] = args[i].getClass();
                        }
                        executionMethod = executionClass.getMethod(methodName, classArgs);// 获取有参数方法
                }
        }
    // 主要获取日志中其它信息，时长、ip、url...
    @After(&quot;execution(* com.itheima.ssm.controller.*.*(..))&quot;)
    public void doAfter(JoinPoint jp) throws Exception {
        // 获取类上的@RequestMapping对象
        if (executionClass != SysLogController.class) {
                RequestMapping classAnnotation = (RequestMapping)executionClass.getAnnotation(RequestMapping.class);
            if (classAnnotation != null) {
                // 获取方法上的@RequestMapping对象
                RequestMapping methodAnnotation = executionMethod.getAnnotation(RequestMapping.class);
                if (methodAnnotation != null) {
                    String url = &quot;&quot;; // 它的值应该是类上的@RequestMapping的value+方法上的@RequestMapping的value
                    url = classAnnotation.value()[0] + methodAnnotation.value()[0];
                    SysLog sysLog = new SysLog();
                    // 获取访问时长
                    Long executionTime = new Date().getTime() - startTime.getTime();
                    // 将sysLog对象属性封装
                    sysLog.setExecutionTime(executionTime);
                    sysLog.setUrl(url);
                    // 获取ip
                    String ip = request.getRemoteAddr();
                    sysLog.setIp(ip);
                    // 可以通过securityContext获取，也可以从request.getSession中获取
                    SecurityContext context = SecurityContextHolder.getContext(); //request.getSession().getAttribute(&quot;SPRING_SECURITY_CONTEXT&quot;)
                    String username = ((User)
                    (context.getAuthentication().getPrincipal())).getUsername();
                    sysLog.setUsername(username);
                    sysLog.setMethod(&quot;[类名]&quot; + executionClass.getName() + &quot;[方法名]&quot; +
                    executionMethod.getName());
                    sysLog.setVisitTime(startTime);
                    // 调用Service，调用dao将sysLog insert数据库
                    sysLogService.save(sysLog);
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在切面类中我们需要获取登录用户的username，还需要获取ip地址，我们怎么处理？&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;username获取&lt;/p&gt;
&lt;p&gt;SecurityContextHolder获取&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ip地址获取&lt;/p&gt;
&lt;p&gt;ip地址的获取我们可以通过request.getRemoteAddr()方法获取到。&lt;br/&gt;在Spring中可以通过RequestContextListener来获取request或session对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202008/1898410-20200806231906751-339308631.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;syslogcontroller&quot;&gt;SysLogController&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequestMapping(&quot;/sysLog&quot;)
@Controller
public class SysLogController {
    @Autowired
    private ISysLogService sysLogService;
    @RequestMapping(&quot;/findAll.do&quot;)
    public ModelAndView findAll() throws Exception {
        ModelAndView mv = new ModelAndView();
        List&amp;lt;SysLog&amp;gt; sysLogs = sysLogService.findAll();
        mv.addObject(&quot;sysLogs&quot;, sysLogs);
        mv.setViewName(&quot;syslog-list&quot;);
        return mv;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
@Transactional
public class SysLogServiceImpl implements ISysLogService {
    @Autowired
    private ISysLogDao sysLogDao;
    @Override
    public void save(SysLog log) throws Exception {
        sysLogDao.save(log);
    }
    @Override
    public List&amp;lt;SysLog&amp;gt; findAll() throws Exception {
        return sysLogDao.findAll();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dao&quot;&gt;Dao&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ISysLogDao {
    @Select(&quot;select * from syslog&quot;)
    @Results({
        @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;),
        @Result(column=&quot;visitTime&quot;,property=&quot;visitTime&quot;),
        @Result(column=&quot;ip&quot;,property=&quot;ip&quot;),
        @Result(column=&quot;url&quot;,property=&quot;url&quot;),
        @Result(column=&quot;executionTime&quot;,property=&quot;executionTime&quot;),
        @Result(column=&quot;method&quot;,property=&quot;method&quot;),
        @Result(column=&quot;username&quot;,property=&quot;username&quot;)
    })
        public List&amp;lt;SysLog&amp;gt; findAll() throws Exception;
        @Insert(&quot;insert into syslog(visitTime,username,ip,url,executionTime,method) values(#{visitTime},#{username},#{ip},#{url},#{executionTime},#{method})&quot;)
        public void save(SysLog log) throws Exception;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 06 Aug 2020 15:20:00 +0000</pubDate>
<dc:creator>平酱</dc:creator>
<og:description>简介 此项目使用Spring+SpringMVC+MyBatis框架整合，用于企业后台权限管理。数据库使用MySQL，前端页面使用Jsp基于AdminLTE模板进行改写。 功能介绍 商品查询 基于SS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/p1ng/p/13449731.html</dc:identifier>
</item>
<item>
<title>《Spanner: Google’s Globally-Distributed Database》论文总结 - BrianLeeLXT</title>
<link>http://www.cnblogs.com/brianleelxt/p/13449540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brianleelxt/p/13449540.html</guid>
<description>&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：本文为论文 &lt;strong&gt;《Spanner: Google’s Globally-Distributed Database》&lt;/strong&gt; 的个人理解，难免有理解不到位之处，欢迎交流与指正 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文地址&lt;/strong&gt;：&lt;a href=&quot;https://github.com/XutongLi/Learning-Notes/blob/master/Distributed_System/Paper_Reading/Spanner/spanner.pdf&quot;&gt;Spanner Paper&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;0-简介&quot;&gt;0. 简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spanner&lt;/strong&gt; 是由 &lt;em&gt;Google&lt;/em&gt; 设计和研发的一款分布式数据库。它将数据分布在全球范围内，并支持外部一致性的分布式事务。对于读写事务，它使用基于 &lt;em&gt;Paxos&lt;/em&gt; 复制容错的 &lt;em&gt;2PC&lt;/em&gt; ；对于只读事务，它不使用锁机制，且允许从本地副本执行读操作，从而提高了只读事务处理效率。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;1-结构&quot;&gt;1. 结构&lt;/h2&gt;
&lt;h3 id=&quot;11-spanner-服务器组织&quot;&gt;1.1 Spanner 服务器组织&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2035097/202008/2035097-20200806224139024-497058813.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个 &lt;strong&gt;Spanner&lt;/strong&gt; 部署称为一个 &lt;strong&gt;universe&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;Spanner&lt;/em&gt; 被组织成许多个 &lt;strong&gt;zone&lt;/strong&gt; 的集合&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;zone&lt;/strong&gt; 是管理部署的基本单元，当新的数据中心加入服务、或者老的数据中心被关闭时，&lt;em&gt;zone&lt;/em&gt; 可以被加入到一个运行的系统中，或从中移除。&lt;em&gt;zone&lt;/em&gt; 也是物理隔离的单元，在一个数据中心中可能有一个或多个 &lt;em&gt;zone&lt;/em&gt;（当属于不同应用的数据必须被分区存储到同一数据中心的不同服务器集合中时，一个数据中心就会有多个 &lt;em&gt;zone&lt;/em&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个 &lt;em&gt;zone&lt;/em&gt; 包含一个 &lt;strong&gt;zonemaster&lt;/strong&gt; 和多个 &lt;strong&gt;spanserver&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;zonemaster&lt;/strong&gt; 把数据分配给 &lt;strong&gt;spanserver&lt;/strong&gt; ，&lt;strong&gt;spanserver&lt;/strong&gt; 把数据提供给客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;客户端使用每个 &lt;em&gt;zone&lt;/em&gt; 上面的 &lt;strong&gt;location proxy&lt;/strong&gt; 来定位可以为自己提供数据的 &lt;strong&gt;spanserver&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;universemaster&lt;/strong&gt; 主要是一个控制台，它显示了关于 &lt;em&gt;zone&lt;/em&gt; 的各种状态信息，可用于相互之间的调试&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;placement driver&lt;/strong&gt; 会周期性地与 &lt;strong&gt;spanserver&lt;/strong&gt; 进行交互，来发现那些需要被转移的数据（或是为了满足新的副本约束条件、或是为了进行负载均衡）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;12-spanserver-构成&quot;&gt;1.2 SpanServer 构成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2035097/202008/2035097-20200806224146242-665703150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在底部，每个 &lt;strong&gt;spanserver&lt;/strong&gt; 负载管理100-1000个称为 &lt;strong&gt;tablet&lt;/strong&gt; 的数据结构的实例， &lt;em&gt;tablet&lt;/em&gt; 实现映射：&lt;code&gt;(key:string, timestamp:int64)-&amp;gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tablet&lt;/strong&gt; 的状态会被存储到 &lt;strong&gt;Colossus&lt;/strong&gt; 分布式文件系统中&lt;/li&gt;
&lt;li&gt;为了支持复制，每个 &lt;strong&gt;spanserver&lt;/strong&gt; 会在每个 &lt;strong&gt;tablet&lt;/strong&gt; 上面实现一个单个的 &lt;strong&gt;Paxos&lt;/strong&gt; 状态机，每个状态机都会在相应的 &lt;strong&gt;tablet&lt;/strong&gt; 中保存自己的元数据和日志&lt;/li&gt;
&lt;li&gt;副本的集合被称为 &lt;strong&gt;Paxos Group&lt;/strong&gt; ，即一个数据分片（&lt;strong&gt;shard&lt;/strong&gt;）对应一个 &lt;strong&gt;Paxos Group&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;写操作要从 &lt;strong&gt;Paxos leader&lt;/strong&gt; 开始执行，读操作可以从足够新的副本中直接执行&lt;/li&gt;
&lt;li&gt;对于每个是 &lt;em&gt;leader&lt;/em&gt; 的副本而言，每个 &lt;em&gt;spanserver&lt;/em&gt; 会实现一个 &lt;strong&gt;lock table&lt;/strong&gt; 来实现并发控制&lt;/li&gt;
&lt;li&gt;对于每个是 &lt;em&gt;ledaer&lt;/em&gt; 的副本而言，每个 &lt;em&gt;spanserver&lt;/em&gt; 会实现一个 &lt;strong&gt;transaction manager&lt;/strong&gt; 来支持分布式事务。&lt;em&gt;Paxos Group&lt;/em&gt; 中的 &lt;em&gt;leader&lt;/em&gt; 为 &lt;strong&gt;participant leader&lt;/strong&gt;，其他副本为 &lt;strong&gt;participant slave&lt;/strong&gt; ；如果一个事务包含了多个 &lt;em&gt;Paxos Group&lt;/em&gt; ，其中一个 &lt;em&gt;Paxos Group&lt;/em&gt; 会被选为 &lt;strong&gt;coordinator&lt;/strong&gt; ，该组 &lt;em&gt;leader&lt;/em&gt; 为 &lt;strong&gt;coordinator leader&lt;/strong&gt; ，该组其他副本为 &lt;strong&gt;coordinator slaves&lt;/strong&gt; （这些设置是为了支持 &lt;em&gt;two phase commit&lt;/em&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;13-目录&quot;&gt;1.3 目录&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Spanner&lt;/em&gt; 支持 &lt;strong&gt;目录&lt;/strong&gt;，它是包含公共前缀的连续键的集合。对目录的支持，可以让应用通过选择合适的键来控制数据的局部性。&lt;/p&gt;
&lt;p&gt;一个目录是数据放置的基本单元，属于一个目录的所有数据都具有相同的副本配置。当数据在不同的 &lt;em&gt;Paxos Group&lt;/em&gt; 之间移动时，会一个目录一个目录地转移。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2035097/202008/2035097-20200806224153875-492469942.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;2-分布式事务&quot;&gt;2. 分布式事务&lt;/h2&gt;
&lt;h3 id=&quot;21-读写事务&quot;&gt;2.1 读写事务&lt;/h3&gt;
&lt;p&gt;读写事务的提交，采用 &lt;strong&gt;基于Paxos的两阶段提交 (2PC)&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;以下述事务为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BEGIN:
        x = x + 1
        y = y - 1
END
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2035097/202008/2035097-20200806224202777-988561656.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中一个黄色矩形框为一个 &lt;em&gt;Data Shard&lt;/em&gt; 的 &lt;em&gt;Paxos Group&lt;/em&gt; ，每个绿圈为一个副本，存储在不同的 &lt;em&gt;Data Center&lt;/em&gt; 。黑色矩形框中的副本为各 &lt;em&gt;Paxos Group&lt;/em&gt; 中的 &lt;em&gt;leader&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;上述读写事务的执行过程为（过程与图中序号对应）：&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;&lt;li&gt;&lt;em&gt;client&lt;/em&gt; 为每个事务设置一个事务 &lt;em&gt;ID&lt;/em&gt; （&lt;em&gt;TID&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;client&lt;/em&gt; 发送读操作给到 &lt;em&gt;X&lt;/em&gt; 和 &lt;em&gt;Y&lt;/em&gt; 所在 &lt;em&gt;Paxos Group&lt;/em&gt; 的 &lt;em&gt;leader&lt;/em&gt;。读操作执行前要先获得对应记录的锁，锁由 &lt;em&gt;lock table&lt;/em&gt; 提供&lt;/li&gt;
&lt;li&gt;两个 &lt;em&gt;leader&lt;/em&gt; 返回 &lt;em&gt;X&lt;/em&gt; 和 &lt;em&gt;Y&lt;/em&gt; 的当前值给 &lt;em&gt;client&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;提交前，先选择一个 &lt;em&gt;Paxos Group&lt;/em&gt; 作为&lt;em&gt;2PC&lt;/em&gt; 的 &lt;em&gt;transaction coordinator (TC)&lt;/em&gt; （图中红框即为 &lt;em&gt;TC leader&lt;/em&gt;），其余 &lt;em&gt;Paxos Group&lt;/em&gt; 为 &lt;em&gt;transaction participant (TP)&lt;/em&gt;。接着，&lt;em&gt;client&lt;/em&gt; 发送写操作给两个 &lt;em&gt;Paxos Group&lt;/em&gt; 的 &lt;em&gt;leader&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;每个 &lt;em&gt;leader&lt;/em&gt; 获取对应记录的锁，通过 &lt;em&gt;Paxos&lt;/em&gt; 在 &lt;em&gt;Paxos Group&lt;/em&gt; 中记录 &lt;code&gt;PREPARE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果记录好&lt;code&gt;PREPARE&lt;/code&gt;，各 &lt;em&gt;leader&lt;/em&gt; 回复 &lt;em&gt;TC&lt;/em&gt; &lt;code&gt;YES&lt;/code&gt; ；若出现故障，恢复 &lt;em&gt;TC&lt;/em&gt; &lt;code&gt;NO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;TC&lt;/em&gt; 接收到所有 &lt;em&gt;TP leader&lt;/em&gt; 的回复之后，决定是提交还是中断。将决定通过 &lt;em&gt;Paxos&lt;/em&gt; 记录在本 &lt;em&gt;Paxos Group&lt;/em&gt; 的 &lt;em&gt;log&lt;/em&gt; 中，发送 &lt;code&gt;COMMIT&lt;/code&gt; 通知给所有 &lt;em&gt;TP leader&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;每个 &lt;em&gt;TP leader&lt;/em&gt; 通过 &lt;em&gt;Paxos&lt;/em&gt; 将 &lt;em&gt;TC&lt;/em&gt; 的决定记录在 &lt;em&gt;log&lt;/em&gt; 中，之后释放占用的锁&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;22-只读事务&quot;&gt;2.2 只读事务&lt;/h3&gt;
&lt;p&gt;只读事务可能包含多个读操作，读取数据可能位于多个 &lt;em&gt;Paxos Group&lt;/em&gt; ，但不包含写操作。&lt;/p&gt;
&lt;p&gt;因为只读事务占比比较大，所以希望只读操作执行更快。&lt;/p&gt;
&lt;p&gt;对于只读事务，&lt;em&gt;Spanner&lt;/em&gt; 进行了两个方面的优化：&lt;strong&gt;允许从本地副本读取&lt;/strong&gt; 和 &lt;strong&gt;不使用锁、2PC、事务管理器&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;221-允许从本地副本读取&quot;&gt;2.2.1 允许从本地副本读取&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Spanner&lt;/em&gt; 允许 &lt;em&gt;client&lt;/em&gt; 从本地副本读取数据，这样就避免了很多 &lt;em&gt;Paxos&lt;/em&gt; 以及 &lt;em&gt;data center&lt;/em&gt; 之间的通信，可以加快只读事务的处理速度。&lt;/p&gt;
&lt;p&gt;但是本地副本可能不是最新的（由于 &lt;em&gt;Paxos&lt;/em&gt; 的 &lt;em&gt;majority&lt;/em&gt; 机制），为解决这个问题，使用 &lt;strong&gt;safe time&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个副本都会跟踪记录一个值，称为 &lt;em&gt;safe time&lt;/em&gt; （&lt;span class=&quot;math inline&quot;&gt;\(t_{safe}\)&lt;/span&gt;），它是一个副本最近更新后的最大时间戳&lt;/li&gt;
&lt;li&gt;如果一个读操作的时间戳是 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; ，当满足 &lt;span class=&quot;math inline&quot;&gt;\(t&amp;lt;=t_{safe}\)&lt;/span&gt; 时，这个副本就可以被这个读操作读取&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;222-不使用锁、2pc和事务管理器&quot;&gt;2.2.2 不使用锁、2PC和事务管理器&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Spanner&lt;/em&gt; 支持不加锁的只读事务，这一特性同样避免了很多 &lt;em&gt;Paxos&lt;/em&gt; 以及 &lt;em&gt;data center&lt;/em&gt; 之间的通信，并且不会减慢读写事务的处理。&lt;/p&gt;
&lt;p&gt;对于不加锁的只读事务，为保证正确性，必须满足：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可序列化&lt;/strong&gt;：虽然多个事务会并发执行，但是执行结果等同于它们按照一定顺序逐一执行的结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外部一致性&lt;/strong&gt;：如果 &lt;em&gt;T1&lt;/em&gt; 在 &lt;em&gt;T2&lt;/em&gt; 开始前提交，则 &lt;em&gt;T2&lt;/em&gt; 必须看到 &lt;em&gt;T1&lt;/em&gt; 写操作的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;保证正确性的方法是采用 &lt;strong&gt;快照隔离 (Snapshot Isolation)&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先同步所有服务器的时钟&lt;/li&gt;
&lt;li&gt;为每一个事务设置一个时间戳
&lt;ul&gt;&lt;li&gt;读写事务：以提交开始时间作为时间戳&lt;/li&gt;
&lt;li&gt;只读事务：以事务开始时间作为时间戳&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;事务并发执行的效果与以时间戳顺序逐一执行的效果相同&lt;/li&gt;
&lt;li&gt;每个副本对于每条记录都存储多个时间戳版本，所有读写事务的写操作都是相同的时间戳&lt;/li&gt;
&lt;li&gt;只读事务能看到本事务时间戳之前的数据版本&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;3-truetime&quot;&gt;3. TrueTime&lt;/h2&gt;
&lt;p&gt;由上述内容可以看到，时间戳在 &lt;em&gt;Spanner&lt;/em&gt; 中起到了一个很重要的作用。但是如果不同服务器上的时钟不同步，则可能导致一些问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果一个只读事务的时间戳过大，会导致它的时间戳大于副本的 &lt;em&gt;safe time&lt;/em&gt; ，读操作就会阻塞&lt;/li&gt;
&lt;li&gt;如果一个只读事务的时间戳过小，会漏读一些在该事务准确时间戳之前提交的数据版本（即读到的数据是过期的），这样违背了外部一致性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为进行时间同步，&lt;em&gt;Spanner&lt;/em&gt; 在每个 &lt;em&gt;data center&lt;/em&gt; 设置一些 &lt;em&gt;time master server&lt;/em&gt; 。每个 &lt;em&gt;time master&lt;/em&gt; 含有一个 &lt;em&gt;GPS receiver&lt;/em&gt; 或一个 &lt;em&gt;atomic clock&lt;/em&gt; 。其他 &lt;em&gt;server&lt;/em&gt; 会从几个 &lt;em&gt;time master server&lt;/em&gt; 中收集投票，获得时间参考值，从而减少误差。但是由于网络延迟原因，得到的时间也会有一定幅度偏移（时间不确定性问题）。&lt;/p&gt;
&lt;p&gt;针对时间不确定性问题，&lt;em&gt;Spanner&lt;/em&gt; 提供了一个 &lt;strong&gt;TrueTime API&lt;/strong&gt; ，它将时间显示表达为 &lt;strong&gt;TTinterval&lt;/strong&gt; ，它是一个时间区间，具有有界限的时间不确定性，保证了当前准确时间在这个区间里。&lt;em&gt;TTinterval&lt;/em&gt; 的端点是 &lt;strong&gt;TTstamp&lt;/strong&gt; 类型。&lt;em&gt;API&lt;/em&gt; 提供了三个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2035097/202008/2035097-20200806224220518-1155951782.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为保证 &lt;strong&gt;外部一致性&lt;/strong&gt; ，&lt;em&gt;Spanner&lt;/em&gt; 设定了两条规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Start rule&lt;/strong&gt;：设事务时间戳为 &lt;code&gt;TT.now().lastest&lt;/code&gt;。对于读写事务，&lt;code&gt;TT&lt;/code&gt; 为开始提交的时间戳；对于只读事务，&lt;code&gt;TT&lt;/code&gt; 为事务开始时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commit wait&lt;/strong&gt;：对于读写事务，延迟到 &lt;code&gt;TS &amp;lt; TS.now().earliest&lt;/code&gt; 时再提交，保证事务时间戳&lt;code&gt;TS&lt;/code&gt; 已经完全过去。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;6-特点&quot;&gt;6. 特点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;数据分片存储在跨越全球的 &lt;em&gt;Paxos&lt;/em&gt; 状态机上，通过并发访问来提高吞吐量&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Spanner&lt;/em&gt; 提供了读和写操作的外部一致性，以及在一个时间标准下的全球一致性的读操作&lt;/li&gt;
&lt;li&gt;随着数据变化和服务器变化，&lt;em&gt;Spanner&lt;/em&gt; 可以自动对数据进行重新分片，以进行负载均衡和失败处理&lt;/li&gt;
&lt;li&gt;应用可以对数据的副本进行控制，如指定哪些数据中心包含哪些数据&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Spanner&lt;/em&gt; 可以为事务分配全球范围内有意义的提交时间戳，这些时间戳反映事务序列化的顺序，用以满足外部一致性的要求&lt;/li&gt;
&lt;li&gt;提出了 &lt;em&gt;TrueTime API&lt;/em&gt; ，&lt;em&gt;Spanner&lt;/em&gt; 时间戳的保证就是取决于这个 &lt;em&gt;API&lt;/em&gt; 的界限&lt;/li&gt;
&lt;li&gt;只读事务不采用锁机制，且可以从最新副本上直接读取数据。由于只读事务占比大，因此显著提升了事务处理效率&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2 id=&quot;5-和-aurora-的比较&quot;&gt;5. 和 Aurora 的比较&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;Spanner&lt;/th&gt;
&lt;th&gt;Aurora&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;架构&lt;/td&gt;
&lt;td&gt;Shared Nothing&lt;/td&gt;
&lt;td&gt;Shared Disk&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可用性&lt;/td&gt;
&lt;td&gt;Paxos-based&lt;/td&gt;
&lt;td&gt;Quorum-based&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;写扩展&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;分库分表透明性&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;分布式事务&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MySQL/Postgres兼容性&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Aurora&lt;/strong&gt;：主要用于云上业务，兼容 &lt;em&gt;MySQL/PostgresSQL&lt;/em&gt;。通过共享存储方案避免了二阶段提交、分布式事务等复杂的实现，因此开发周期较短。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spanner&lt;/strong&gt;：是一种重新设计的数据库，基于 &lt;em&gt;Paxos&lt;/em&gt; 的强同步、对分布式事务的支持以及利用 &lt;em&gt;TrueTime&lt;/em&gt; 机制实现的全局一致性读都是比较强大的功能。但是对 &lt;em&gt;SQL&lt;/em&gt; 的兼容性不够好。&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 06 Aug 2020 14:45:00 +0000</pubDate>
<dc:creator>BrianLeeLXT</dc:creator>
<og:description>Spanner 总结 说明：本文为论文 《Spanner: Google’s Globally-Distributed Database》 的个人理解，难免有理解不到位之处，欢迎交流与指正 。 论文地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/brianleelxt/p/13449540.html</dc:identifier>
</item>
<item>
<title>线程池略略观 - 流年的夏天</title>
<link>http://www.cnblogs.com/liuxia912/p/13449265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuxia912/p/13449265.html</guid>
<description>&lt;p&gt;&lt;span&gt;【为什么要使用线程池】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;传统线程创建方式的问题&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;反复创建线程系统开销比较大&lt;/span&gt;&lt;span&gt;，每个线程创建和销毁都需要时间，如果任务比较简单，那么就有可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;过多的线程会占用过多的内存等资源&lt;/span&gt;&lt;span&gt;，还会带来&lt;span&gt;&lt;span&gt;过多的上下文切换&lt;/span&gt;&lt;span&gt;，同时还会导致系统不稳定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;线程池的优点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;线程池可以解决线程生命周期的系统开销问题，同时因为线程复用，消除了创建线程的过程，可以&lt;span&gt;&lt;span&gt;加快响应速度&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;线程池会根据配置和任务数量灵活地控制线程数量，可以&lt;span&gt;统筹内存和&lt;/span&gt;&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;的使用&lt;/span&gt;&lt;span&gt;，避免资源使用不当。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;线程池可以&lt;span&gt;&lt;span&gt;统一管理资源&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【线程池参数】&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;corePoolSize&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;核心线程数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;maxPoolSize&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;最大线程数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;keepAliveTime+&lt;/span&gt;&lt;span&gt;时间单位&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;空闲线程的存活时间&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;TheadFactory&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;线程工厂，用于创建新线程&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;workQueue&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;线程队列（一般未阻塞队列）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;Handler&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;处理被拒绝的任务&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;------Spring&lt;/span&gt;&lt;span&gt;配置：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;bean id=&quot;threadPool&quot; class=&quot;org.springframework.scheduling.concurrent.&lt;span&gt;ThreadPoolTaskExecutor&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&lt;em&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;核心线程数 &lt;/span&gt; &lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&amp;lt;property name=&quot;&lt;span&gt;corePoolSize&lt;span&gt;&quot; value=&quot;20&quot; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&lt;em&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;最大线程数&lt;/span&gt; &lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&amp;lt;property name=&quot;&lt;span&gt;maxPoolSize&lt;span&gt;&quot; value=&quot;80&quot; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&lt;em&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;队列最大长度&lt;/span&gt; &lt;span&gt;&amp;gt;=mainExecutor.maxSize --&amp;gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&amp;lt;property name=&quot;&lt;span&gt;queueCapacity&lt;span&gt;&quot; value=&quot;5000&quot; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&lt;em&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;线程池维护线程所允许的空闲时间&lt;/span&gt; &lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&amp;lt;property name=&quot;&lt;span&gt;keepAliveSeconds&lt;span&gt;&quot; value=&quot;300&quot; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&lt;em&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;线程池对拒绝任务&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;无线程可用&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;的处理策略&lt;/span&gt; &lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&amp;lt;property name=&quot;&lt;span&gt;rejectedExecutionHandler&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           &lt;/span&gt; &lt;span&gt;&amp;lt;bean class=&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt; &lt;span&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;线程池基本工作流：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;应用初始化后，当前线程池线程数为&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;有任务被提交后，创建核心线程执行任务；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;当核心线程数达到上限后，任务添加到线程队列；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;当线程队列内任务数达到上限后，创建非核心线程执行任务；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;当线程池内总线程数达到最大线程数后，任务会被拒绝；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;当任务渐渐被执行完，队列为空，而且当前线程数大于核心线程数之后，线程池会检测线程的&lt;/span&gt;&lt;span&gt;&lt;span&gt;keepAliveSeconds&lt;/span&gt;&lt;span&gt;&lt;span&gt;，如果线程空闲时间大于这个时间，线程将会被销毁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;线程渐渐地被销毁，线程池内存活线程等于核心线程数之后，则不继续做处理，线程空转，等待新的任务到来。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;------ThreadFactory&lt;/span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程工厂，主要作用是生产线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以选择使用默认的线程工厂，创建的线程都会在同一个线程组，并拥有一样的优先级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以选择自己定制线程工厂，以方便给线程自定义命名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【拒绝策略】&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;6&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;AbortPolicy&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;拒绝任务时，会直接抛出一个类型为&lt;/span&gt; &lt;span&gt;RejectedExecutionException&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;RuntimeException&lt;/span&gt;&lt;span&gt;，可以感知到任务被拒绝了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;DiscardPolicy&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;当新任务被提交后直接被丢弃掉，有一定风险，可能会造成数据丢失&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;DiscardOldestPolicy&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;丢弃任务队列中的头结点，通常是存活时间最长的任务，同样有风险&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;CallerRunsPolicy&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务&lt;/span&gt;&lt;span&gt;&lt;br/&gt;1.&lt;/span&gt; &lt;span&gt;新提交的&lt;span&gt;任务不会被丢弃&lt;span&gt;，这样也就不会造成业务损失&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;2.&lt;/span&gt; &lt;span&gt;由于谁提交任务谁就要负责执行任务，&lt;span&gt;&lt;span&gt;这样提交任务的线程就得负责执行任务&lt;/span&gt;&lt;span&gt;，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就&lt;span&gt;不会再提交新的任务&lt;span&gt;，减缓了任务提交的速度，相当于是一个负反馈。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【六种常见的线程池】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------FixedThreadPool&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核心线程数和最大线程数一样，所以是&lt;span&gt;&lt;span&gt;固定线程数&lt;/span&gt;&lt;span&gt;的线程池。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------CachedThreadPool&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可缓存线程池，核心线程数为&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，最大线程数为&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&lt;span&gt;最大值&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;队列的容量为&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------ScheduledThreadPool&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持&lt;span&gt;&lt;span&gt;定时或周期性&lt;/span&gt;&lt;span&gt;执行任务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;12&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;service.schedule(new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Task(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;TimeUnit.SECONDS);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;表示延迟指定时间后执行一次任务&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;service.scheduleAtFixedRate(new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Task(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;TimeUnit.SECONDS);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;以固定的频率执行任务，它的第二个参数&lt;/span&gt; &lt;span&gt;initialDelay&lt;/span&gt; &lt;span&gt;表示第一次延时时间，第三个参数&lt;/span&gt; &lt;span&gt;period&lt;/span&gt; &lt;span&gt;表示周期，也就是第一次延时后每次延时多长时间执行一次任务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;service.scheduleWithFixedDelay(new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Task(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;TimeUnit.SECONDS);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;之前的&lt;/span&gt; &lt;span&gt;scheduleAtFixedRate&lt;/span&gt; &lt;span&gt;是以&lt;span&gt;任务开始的时间为时间起点&lt;span&gt;开始计时，时间到就开始执行第二次任务，而不管任务需要花多久执行；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;而&lt;/span&gt; &lt;span&gt;scheduleWithFixedDelay&lt;/span&gt; &lt;span&gt;方法以&lt;span&gt;任务结束的时间&lt;span&gt;为下一次循环的时间起点开始计时。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------SingleThreadExecutor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;span&gt;&lt;span&gt;唯一的线程去执行任务，可保证执行顺序&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------SingleThreadScheduledExecutor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和第三个类似，只不过&lt;span&gt;线程只有一个&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------ForkJoinPool&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;实现&lt;span&gt;&lt;span&gt;任务的分裂和汇总&lt;/span&gt;&lt;span&gt;，充分利用&lt;span&gt;&lt;strong&gt;多核&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;的计算能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【阻塞队列】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1628496/202008/1628496-20200806214749375-901728409.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;------LinkedBlockingQueue&lt;/span&gt; &lt;span&gt;    &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;无界队列&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;FixedThreadPool&lt;/span&gt; &lt;span&gt;&lt;span&gt;和&lt;/span&gt; &lt;span&gt;SingleThreadExector&lt;/span&gt;&lt;span&gt;使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;------SynchronousQueue&lt;/span&gt; &lt;span&gt;     &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SynchronousQueue&lt;/span&gt;&lt;span&gt;是一个&lt;span&gt;&lt;span&gt;没有数据缓冲&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;BlockingQueue&lt;/span&gt;&lt;span&gt;，生产者线程对其的插入操作&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;必须等待消费者的移除操作&lt;/span&gt;&lt;span&gt;take&lt;/span&gt;&lt;span&gt;，反过来也一样。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者和消费者互相等待对方，握手，然后一起离开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对应线程池&lt;/span&gt; &lt;span&gt;CachedThreadPool&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------DelayedWorkQueue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对应线程池&lt;/span&gt;&lt;span&gt;ScheduledThreadPool&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;SingleThreadScheduledExecutor&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;DelayedWorkQueue&lt;/span&gt; &lt;span&gt;的特点是内部元素&lt;span&gt;并不是按照放入的时间排序&lt;span&gt;，而是会&lt;span&gt;&lt;span&gt;按照延迟的时间长短对任务进行排序&lt;/span&gt;&lt;span&gt;，内部采用的是&quot;堆&quot;的数据结构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【关闭线程池】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------shutdown()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安全地关闭一个线程池。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;并不是立刻就被关闭，调用&lt;/span&gt; &lt;span&gt;shutdown()&lt;/span&gt; &lt;span&gt;方法后线程池会在&lt;span&gt;&lt;span&gt;执行完正在执行的任务和队列中等待的任务后&lt;/span&gt;&lt;span&gt;才彻底关闭。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------isShutdown()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以返回&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;或者&lt;/span&gt; &lt;span&gt;false&lt;/span&gt; &lt;span&gt;来判断线程池是否&lt;span&gt;&lt;span&gt;&lt;strong&gt;已经开始&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;了关闭工作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------isTerminated()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以检测线程池&lt;span&gt;&lt;span&gt;是否真正&quot;终结&quot;&lt;/span&gt;&lt;span&gt;了，这不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------awaitTermination()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;判断线程池状态&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;调用&lt;/span&gt; &lt;span&gt;awaitTermination&lt;/span&gt; &lt;span&gt;方法后当前线程&lt;span&gt;&lt;span&gt;会尝试等待&lt;/span&gt;&lt;span&gt;一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正&quot;终结&quot;了，那么方法就返回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;，否则超时返回&lt;/span&gt; &lt;span&gt;fasle&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------shutdownNow()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;会给所有线程池中的线程发送&lt;/span&gt; &lt;span&gt;interrupt&lt;/span&gt; &lt;span&gt;中断信号，&lt;span&gt;&lt;span&gt;尝试中断&lt;/span&gt;&lt;span&gt;这些任务的执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后会将任务队列中&lt;span&gt;正在等待的所有任务转移到一个&lt;/span&gt;&lt;/span&gt; &lt;span&gt;List&lt;/span&gt; &lt;span&gt;中并返回，我们可以根据返回的任务&lt;/span&gt; &lt;span&gt;List&lt;/span&gt; &lt;span&gt;来进行一些补救的操作，例如记录在案并在后期重试。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【线程复用原理】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在线程池中，同一个线程从&lt;/span&gt;&lt;span&gt;BlockingQueue&lt;/span&gt;&lt;span&gt;里面不断地提取任务；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;核心内容在于对&lt;/span&gt;&lt;span&gt;Tread&lt;/span&gt;&lt;span&gt;进行了封装，每个线程都会去执行一个循环任务；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这个循环任务会不停地检查队列里面是否有待执行的任务，如果有，则执行其&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;方法，这样，线程就被串联了起来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 13:49:00 +0000</pubDate>
<dc:creator>流年的夏天</dc:creator>
<og:description>【为什么要使用线程池】 传统线程创建方式的问题 反复创建线程系统开销比较大，每个线程创建和销毁都需要时间，如果任务比较简单，那么就有可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuxia912/p/13449265.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：了解i.MXRTxxx系列ROM API及其与i.MXRT1xxx系列的差异 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/13449256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/13449256.html</guid>
<description>&lt;p&gt;痞子衡之前写过两篇文章《利用i.MXRT1xxx系列ROM提供的FlexSPI driver API可轻松IAP》、《其实i.MXRT1050,1020,1015系列ROM也提供了FlexSPI driver API》基本把i.MXRT1xxx全系列的ROM API及其FlexSPI NOR驱动设计都讲清楚了，其实i.MXRTxxx系列的ROM API设计跟i.MXRT1xxx系列的设计思路差不多（其实本就是同一个恩智浦研发小组负责的），仅有一些微小区别，本文痞子衡主要就是点出那些区别。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;161.85911852139&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;i.MXRTxxx系列ROM API设计细节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　痞子衡之前写过两篇文章 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13202824.html&quot;&gt;《利用i.MXRT1xxx系列ROM提供的FlexSPI driver API可轻松IAP》&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13283334.html&quot;&gt;《其实i.MXRT1050,1020,1015系列ROM也提供了FlexSPI driver API》&lt;/a&gt; 基本把i.MXRT1xxx全系列的ROM API及其FlexSPI NOR驱动设计都讲清楚了，其实i.MXRTxxx系列的ROM API设计跟i.MXRT1xxx系列的设计思路差不多（其实本就是同一个恩智浦研发小组负责的），仅有一些微小区别，本文痞子衡主要就是点出那些区别。&lt;/p&gt;
&lt;h3 id=&quot;一、rom基址差异&quot;&gt;一、ROM基址差异&lt;/h3&gt;
&lt;p&gt;　　ROM API代码首先是在BootROM里，BootROM代码是出厂前固化在ROM区域的。因为架构设计的关系，i.MXRTxxx系列和i.MXRT1xxx系列的ROM区域在系统内存里的映射地址不同。&lt;/p&gt;
&lt;p&gt;　　下表是i.MXRTxxx系列代表型号i.MXRT500的部分系统内存映射，可以看到ROM区域起始地址是0x03000000（非安全域）。目前i.MXRTxxx都是Cortex-M33内核，支持TrustZone特性，所以0x13000000也是ROM起始地址（安全域），为了通用性，我们认0x03000000就可以了，这个地址在安全状态和非安全状态下都能被访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_BootROM_API_RT500_mem_map_v2.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下表是i.MXRT1xxx系列代表型号i.MXRT1060的部分系统内存映射，可以看到ROM区域起始地址是0x00200000。i.MXRT1xxx系列都是Cortex-M7内核，没有TrustZone特性，不存在i.MXRTxxx上那样的两种状态域下的地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_BootROM_API_RT1060_mem_map.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、api基址备份位置差异&quot;&gt;二、API基址备份位置差异&lt;/h3&gt;
&lt;p&gt;　　在i.MXRT1xxx系列ROM API介绍的文章里，痞子衡介绍过g_bootloaderTree地址值被复制了一份放在了BootROM中断向量表第8个向量的位置处（该向量为ARMv7-M架构下未定义的系统向量），因此读取0x0020001c处开始的4bytes便能找到i.MXRT1xxx系列的g_bootloaderTree。&lt;/p&gt;
&lt;p&gt;　　但是由于i.MXRTxxx是Cortex-M33内核，属于ARMv8-M架构，从下图中可以看出ARMv8-M架构下中断向量表第8个向量是SecureFault，已经被定义了，因此BootROM把g_bootloaderTree地址值放到了第9个向量的位置处（该向量为ARMv8-M架构下未定义的系统向量），故读取0x03000020处开始的4bytes才能找到i.MXRTxxx系列的g_bootloaderTree（这种方式在实际API调用中并不可取，至于原因嘛，先卖个关子）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_BootROM_API_CM_exception_type.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面是i.MXRT500 BootROM工程的startup文件（IAR版），g_bootloaderTree确实在第9个向量处：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;        MODULE  ?cstartup

        ;; Forward declaration of sections.
        SECTION CSTACK:DATA:NOROOT(3)
        SECTION .intvec:CODE:NOROOT(2)

        EXTERN  __iar_program_start
        EXTERN  g_bootloaderTree
        PUBLIC  __vector_table
        PUBLIC  __vector_table_0x1c

        DATA

__vector_table
        DCD     sfe(CSTACK)
        DCD     Reset_Handler
        DCD     DefaultISR
        DCD     HardFault_Handler
        DCD     DefaultISR
        DCD     DefaultISR
        DCD     UsageFault_Handler
__vector_table_0x1c
        DCD     SecureFault_Handler
        DCD     g_bootloaderTree
        DCD     0
        DCD     0
        DCD     SVC_Handler
        DCD     DefaultISR
        DCD     0
        DCD     DefaultISR
        DCD     SysTick_Handler
                ;; ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三、api原型定义差异&quot;&gt;三、API原型定义差异&lt;/h3&gt;
&lt;p&gt;　　下面是i.MXRTxxx系列ROM API原型定义及其实例（适用i.MXRT500/600），基本形式跟i.MXRT1xxx差不多，但是API功能更丰富，除了FlexSPI NOR驱动，还有iap api、USB low-level driver、otp driver等（我们知道，i.MXRTxxx与LPC系列同根同源，LPC系列ROM里一般都会集成很多经典SDK驱动，比如内部flash、low power驱动，有了这些稳定的驱动API，LPC系列的用户手册里甚至都会省去这些IP的寄存器介绍，直接就是API的介绍）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;typedef struct
{
    void (*runBootloader)(void *arg);
    uint32_t version;
    const char *copyright;
    const bootloader_context_t *runtimeContext;
    const kb_interface_t *kbApi;
    const usb_driver_interface_t *usbDriver;
    const USBD_API_T *lpcUsbDriver;
    const flexspi_nor_flash_driver_t *flexspiNorDriver;
    const ocotp_driver_t *otpDriver;
    const skboot_authenticate_interface_t *skbootAuthenticate;
} bootloader_api_entry_t;

//! @brief Static API tree.
__root const bootloader_api_entry_t g_bootloaderTree @&quot;.rom_api_tree_section&quot; = {
    .runBootloader = bootloader_user_entry,
    .version = MAKE_VERSION('K', 3, 0, 0),
    .copyright = &quot;Copyright 2019 NXP.&quot;,
    .runtimeContext = &amp;amp;g_bootloaderContext,
    .kbApi = &amp;amp;g_romApiInterface,
    .usbDriver = &amp;amp;g_usbDriverInterface,
    .flexspiNorDriver = &amp;amp;g_flexspiNorFlashDriverInterface,
    .otpDriver = &amp;amp;g_otpDriverInterface,
    .skbootAuthenticate = &amp;amp;g_skbootAuthenticateInterface,
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四、api实例链接差异&quot;&gt;四、API实例链接差异&lt;/h3&gt;
&lt;p&gt;　　i.MXRT1xxx系列ROM API实例g_bootloaderTree都是让链接器自由链接的，因此每个具体型号的实际ROM API链接地址没有一致的规律可循（这也是为什么要在中断向量表里固定位置统一保存一份），而这点在i.MXRTxxx上有了改进，i.MXRTxxx里将g_bootloaderTree放到了 .rom_api_tree_section 段里，在链接文件里将该段固定链接在ROM区域最后4KB处（BootROM代码没有把全部ROM空间用尽）。&lt;/p&gt;
&lt;p&gt;　　下面是i.MXRTxxx BootROM源文件中g_bootloaderTree的定义，加了段修饰。此外还有额外的k_romcrc，标示API实例区域的结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;__root const bootloader_api_entry_t g_bootloaderTree @&quot;.rom_api_tree_section&quot; = {
    .runBootloader = bootloader_user_entry,
    .version = MAKE_VERSION('K', 3, 0, 0),
    .copyright = &quot;Copyright 2019 NXP.&quot;,
    .runtimeContext = &amp;amp;g_bootloaderContext,
    // ...
};

__root const uint32_t k_romcrc @&quot;.romcrc&quot; = 0xdeadbeef;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　下面是i.MXRTxxx链接文件（IAR工程）中 .rom_api_tree_section 段的处理（i.MXRT500型号示例，ROM空间是192KB）。你可能好奇为啥ROM_API_TREE_xx等值是放在0x13000000开始的安全域ROM空间映射，BootROM属于上电启动第一级，负责芯片系统的安全和启动，当然是工作在安全状态下，可以访问安全域地址空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;define symbol __ICFEDIT_region_ROM_API_TREE_start__     = 0x1302f000;
define symbol __ICFEDIT_region_ROM_API_TREE_end__       = 0x1302f0ff;
define symbol __ICFEDIT_region_ROM_CRC_CHECKSUM_start__ = 0x1302fffc;
define symbol __ICFEDIT_region_ROM_CRC_CHECKSUM_end__   = 0x1302ffff;

define region ROM_API_TREE_region = mem:[from  __ICFEDIT_region_ROM_API_TREE_start__ to  __ICFEDIT_region_ROM_API_TREE_end__];
define region ROM_CRC_CHECKSUM = mem:[from  __ICFEDIT_region_ROM_CRC_CHECKSUM_start__ to  __ICFEDIT_region_ROM_CRC_CHECKSUM_end__];

place in ROM_API_TREE_region { section .rom_api_tree_section };
place in ROM_CRC_CHECKSUM { section .romcrc };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　基于上面的设计，你才会在i.MXRT500参考手册里Non-Secure Boot ROM章节看到如下ROM API地址及结构信息图（图中仅标了常用的API功能函数），实际ROM API调用时，App的执行其实都是经过ROM引导和认证的，App中既可以访问安全域地址（0x1302f000）来调用API，也可以访问非安全域地址（0x0302f000）来调用API。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_BootROM_API_RT500_tree_structure.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后再来回答前面卖的关子，为什么i.MXRTxxx系列通过BootROM中断向量表第9个向量值来访问ROM API这种方式并不可取？其实从BootROM煞费苦心地将g_bootloaderTree固定链接在ROM区域最后4KB处，你就能看出其用意。如果你挂上调试器直接访问i.MXRTxxx的ROM区域前20KB的空间，你会发现无法访问，在App里AHB方式读这个区域，也会直接产生HardFault，因为BootROM里做了特殊设计故意隐藏了前20KB空间，这个空间里存放了BootROM想要保护的数据和代码，至于内容是啥，纯属机密，恕不奉告，哈哈。&lt;/p&gt;
&lt;p&gt;　　至此，i.MXRTxxx系列ROM API设计细节痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 06 Aug 2020 13:47:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>痞子衡之前写过两篇文章《利用i.MXRT1xxx系列ROM提供的FlexSPI driver API可轻松IAP》、《其实i.MXRT1050,1020,1015系列ROM也提供了FlexSPI dr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/13449256.html</dc:identifier>
</item>
<item>
<title>JavaScript calss语法糖 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/13448087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/13448087.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;基础知识&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;严格意义上来讲，在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Js&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中是没有类这一概念的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们可以运用前面章节提到的构造函数来模拟出类这一概念，并且可以通过原型对象的继承来完美的实现实例对象方法复用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;但是这样十分的麻烦，我们需要将实例对象需要用到的公共方法来存放到构造函数的原型对象中，而使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;语法糖整个过程就变得非常简单。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;声明定义&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;来定义类，类中定义的函数称为方法，不需要用关键字&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;function&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;也不需要用逗号进行分割。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
    &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
    class User {
​
        f1() {
            console.log(&lt;/span&gt;&quot;运行了f1...&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不需要逗号分隔&lt;/span&gt;
&lt;span&gt;        f2() {
            console.log(&lt;/span&gt;&quot;运行了f2...&quot;&lt;span&gt;);
        }
​
    }
​
    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
​
    u1.f1();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法调用&lt;/span&gt;
    u1.f2();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法调用&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;构造函数&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;使用 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;constructor&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;构造函数传递参数，该函数会在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;时自动执行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
    &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
    class User {
​
        constructor(name, age, gender) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.gender =&lt;span&gt; gender;
        }
​
        show(){
            console.log(`姓名:${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name},年龄:${&lt;span&gt;this&lt;/span&gt;.age},性别:${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.gender}`);
        }
​
    }
​
    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;,18,&quot;男&quot;&lt;span&gt;);
​
    u1.show();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行方法&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;构造函数不是必须定义的，当没有定义构造函数时。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;它会自动去查找原型链，相当于如下代码所示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;constructor(...args) {
  super(...args);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;原理分析&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;不管是使用构造函数还是&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;语法糖，其原理都是一样的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;但是构造函数中的方法应该存放进原型对象，这一步需要我们手动去做，使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;语法糖的结构后则会自动将方法放入原型对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
    &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
    class U1 {
        constructor(name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }
        show() {
            console.log(&lt;/span&gt;&quot;U1 show&quot;&lt;span&gt;);
        }
    }
    
    console.log(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; U1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; function  class只是语法糖，内部还是函数。&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
    &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
    class U1 {
        constructor(name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }
        show() {
            console.log(&lt;/span&gt;&quot;U1 show&quot;&lt;span&gt;);
        }
    }
​
    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; U1(&quot;class语法糖&quot;&lt;span&gt;);
​
    console.dir(u1);
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ============  两种操作一模一样 class自动将方法写入原型对象中&lt;/span&gt;
&lt;span&gt;​
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; U2(name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
​
    U2.prototype.show &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;&quot;U2 show&quot;&lt;span&gt;);
    }
​
    let u2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; U2(&quot;构造函数&quot;&lt;span&gt;);
​
    console.dir(u2);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200806181536129-1487432364.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200806181536129-1487432364.png&quot; alt=&quot;image-20200806104822239&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;遍历差异&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;虽说&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;定义的类归根结底还是函数，但是与我们手动创建构造函数还是有一些优化措施的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;中定义的方法不能被遍历出来，而构造函数原型对象中的方法却可以被遍历出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
    &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
    class U1 {
        constructor(name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }
        show() {
            console.log(&lt;/span&gt;&quot;U1 show&quot;&lt;span&gt;);
        }
    }
​
    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; U1(&quot;class语法糖&quot;&lt;span&gt;);
​
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; u1) {
        console.log(key);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name  Ps：show不会被遍历出来&lt;/span&gt;
&lt;span&gt;    }
​
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ============  两种操作一模一样 class自动将方法写入原型对象中&lt;/span&gt;
&lt;span&gt;​
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; U2(name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
​
    U2.prototype.show &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;&quot;U2 show&quot;&lt;span&gt;);
    }
​
    let u2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; U2(&quot;构造函数&quot;&lt;span&gt;);
​
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; u2) {
        console.log(key);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name  show  &lt;/span&gt;
&lt;span&gt;    }
​
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;严格模式&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中， 默认使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;strict&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;严格模式执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;use strict&quot;;  取消严格模式&lt;/span&gt;
&lt;span&gt;​
    class U1 {
        constructor(name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }
        show() {
​
            (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; class中用严格模式执行代码，所以this指向为undefined&lt;/span&gt;
&lt;span&gt;            }())
​
        }
    }
​
    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; U1(&quot;class语法糖&quot;&lt;span&gt;);
​
    u1.show();
​
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ============  两种操作一模一样 class自动将方法写入原型对象中&lt;/span&gt;
&lt;span&gt;​
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; U2(name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
​
    U2.prototype.show &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
​
        (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数中方法中的函数this非严格模式下指向为window&lt;/span&gt;
&lt;span&gt;        }())
​
    }
​
    let u2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; U2(&quot;构造函数&quot;&lt;span&gt;);
​
    u2.show();
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;静态访问&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;静态属性&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;静态属性即为类自己单独设置属性，而不是为生成的对象设置，请使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;static&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;进行声明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
    &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
    class User {
​
        static username &lt;/span&gt;= &quot;用户类&quot;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不加 static，将会变成实例属性&lt;/span&gt;
&lt;span&gt;​
        constructor(username) {
​
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
        }
​
    }
​
    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);
​
​
    console.log(u1.username);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 云崖&lt;/span&gt;
    console.log(User.username);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户类&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;实现原理也非常简单。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; User(username) {

    
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;

    }

    User.username &lt;/span&gt;= &quot;用户类&quot;&lt;span&gt;;

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);


    console.log(u1.username);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 云崖&lt;/span&gt;
    console.log(User.username);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户类&lt;/span&gt;


&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;静态方法&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;静态方法即为类自己单独设置方法，而不是为生成的对象设置，请使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;static&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;进行声明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class User {

        static show(){
            console.log(&lt;/span&gt;&quot;类的方法...&quot;&lt;span&gt;);
        }

    }

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();

    User.show(); 

    u1.show();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抛出异常&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;实现原理也非常简单。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; User() { }  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数&lt;/span&gt;
&lt;span&gt;
    User.show &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt; () { console.log( &quot;类的方法...&quot;&lt;span&gt;); };

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();

    User.show();

    u1.show();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抛出异常&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;访问器&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;使用访问器可以对对象的属性进行访问控制，下面是使用访问器对私有属性进行管理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;语法介绍&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;使用访问器可以管控属性，有效的防止属性随意修改&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;访问器就是在函数前加上 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;get/set&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;修饰，操作属性时不需要加函数的扩号，直接用函数名&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class User {

        constructor(username){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
        }

        get name(){  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问name时返回username&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.username;
        }

        set name(value){  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置name其实是给username做设置&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; value;
        }

    }

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);
  
    console.log(u1.name);  

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;属性保护&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;当外部尝试修改某一属性时，可以使用访问器来进行验证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class User {

        constructor(username){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
        }

        get name(){  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问name时返回username&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.username;
        }

        set name(value){  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置name其实是给username做设置&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; value ==&lt;span&gt; String){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; value;
            }
            
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; Error(&quot;value type error,must string&quot;&lt;span&gt;);
        }

    }

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);

    u1.name &lt;/span&gt;= 18;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; value type error,must string&lt;/span&gt;
&lt;span&gt;
    console.log(u1.name);  

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;私有封装&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;私有封装是指内部可以任意调用，外部只能通过访问的接口才能进行调用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;public&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;public&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;指不受保护的属性，在类的内部与外部都可以访问到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class User {

        constructor(username){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
        }

        show(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.username; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部可以访问&lt;/span&gt;
&lt;span&gt;        }

    }

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);
  
    console.log(u1.username); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 外部也可以访问&lt;/span&gt;
&lt;span&gt;
    console.log(u1.show());  

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;protected&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;protected&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;是受保护的属性修释，不允许外部直接操作，但&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;可以继承后在类内部访问&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;，下面将介绍&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;protected&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;三种封装方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;命名保护&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;将属性定义为以 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;_&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;开始，来告诉使用者这是一个私有属性，请不要在外部使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;外部修改私有属性时可以使用访问器 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;setter&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;操作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;但这只是提示，就像吸烟时烟盒上的吸烟有害健康，但还是可以抽&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class User {

        constructor(username){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._username =&lt;span&gt; username;
        }

        show(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._username; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部可以访问&lt;/span&gt;
&lt;span&gt;        }

    }

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(u1._username); // 外部也可以访问，但是如果你是专业人员看到 _开头就知道不该在外部拿他。&lt;/span&gt;
&lt;span&gt;
    console.log(u1.show());  

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;Symbol&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　由于我们的代码都是在一个模块中进行封装的，所以使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Symbol()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;来进行私有封装非常方便。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;除非使用者打开源代码找到变量名&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，否则他只能通过提供的接口来拿到数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    let key &lt;/span&gt;=&lt;span&gt; Symbol();

    class User {

        constructor(username){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[key] =&lt;span&gt;{username};
        }

        show(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[key].username; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部可以访问&lt;/span&gt;
&lt;span&gt;        }

    }

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);
  
    console.log(u1);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  { Symbol(): {username: &quot;云崖&quot;}} 外部拿不到。只能通过接口来拿&lt;/span&gt;
&lt;span&gt;    console.log(u1.show());  

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;WeakMap&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;WeakMap&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;是一组键/值对的集，下面利用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;WeakMap&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类型特性定义私有属性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    let key &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WeakMap();

    class User {

        constructor(username) {
            key.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以当前对象作为键来存储。&lt;/span&gt;
&lt;span&gt;                username,
            })
        }

        show() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; key.get(&lt;span&gt;this&lt;/span&gt;).username; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部可以访问&lt;/span&gt;
&lt;span&gt;        }

    }

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);

    console.log(u1);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  {}  干干净净，啥都拿不到。&lt;/span&gt;
    console.log(u1.show());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 云崖&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;private&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;private&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;指绝对私有属性，只在当前类可以访问到，并且&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;不允许继承的子类使用&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;为属性或方法名前加 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;#&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;为声明为私有属性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;私有属性只能在声明的类中使用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;



    class User {

        #username;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于实例的私有属性来说，必须先定义一下。方法则不用。&lt;/span&gt;
&lt;span&gt;
        constructor(username) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.#check(username);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.#username =&lt;span&gt; username;
        }

        show() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.#username; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部可以访问&lt;/span&gt;
&lt;span&gt;        }

        #check &lt;/span&gt;= (username) =&amp;gt; {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 验证类的私有方法。 私有方法格式必须如此。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; username != &quot;string&quot;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; Error(&quot;type error,value type must string.&quot;&lt;span&gt;)
            }
        }

    }

    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;云崖&quot;&lt;span&gt;);
    
    console.log(u1);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {#username: &quot;云崖&quot;, #check: ƒ}&lt;/span&gt;
&lt;span&gt;
    console.log(u1.show());   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只能通过接口访问&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(u1.#check);  // 外部不能访问，抛出异常。&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(u1.#username); // 外部不可以访问，抛出异常 &lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;继承特性&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;内部也是采用原型继承，这与构造函数如出一辙。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;如果你不了解原型继承，那么可以看一下我前面的一篇文章，解释的非常清楚了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;这里就是介绍一些&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;语法糖如何使用继承。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;extends&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;以下示例将展示使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;extends&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;语法实现原型继承。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;需要注意的是，只要继承的子类中有构造函数，就一定要使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;super&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;没使用super引发异常&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class A {
        constructor(name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }
        show() {
            console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}运行A类的show...`);
        }
    }

    class B extends A {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承A的原型对象&lt;/span&gt;
&lt;span&gt;        constructor(name) {

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name; 

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught ReferenceError: &lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must call super constructor in derived &lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; class before accessing 'this' or returning from derived constructor&lt;/span&gt;
            
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 意思是必须用super&lt;/span&gt;
&lt;span&gt;
        }
    }

    let b1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; B(&quot;实例b1&quot;&lt;span&gt;);

    b1.show();

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;正确示范&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class A {
        constructor(name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }
        show() {
            console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}运行A类的show...`);
        }
    }

    class B extends A {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承A的原型对象&lt;/span&gt;
&lt;span&gt;        constructor(name) {

            super(name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须使用super，这里用父类的构造函数进行构造。&lt;/span&gt;
&lt;span&gt;
        }
    }

    let b1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; B(&quot;实例b1&quot;&lt;span&gt;);

    b1.show();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例b1运行A类的show...&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;原理如下&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; A(name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    A.prototype &lt;/span&gt;=&lt;span&gt; {

        constructor: A,

        show() {
            console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}运行A类的show...`);
        },
    };

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; B(name){
        A.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name);
    }

    Object.setPrototypeOf(B.prototype,A.prototype); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; B原型对象继承与A原型对象&lt;/span&gt;
&lt;span&gt;
    let b1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; B(&quot;实例b1&quot;&lt;span&gt;);

    b1.show();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例b1运行A类的show...&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;super&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;表示从当前原型中执行方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;super&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;一直指向当前对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;在构造函数中，&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;super&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;一定要放在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;声明的前面&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;super&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;只能在类或对象的方法中使用，而不能在函数中使用，换而言之，不要使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;function&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;来表示这是一个函数！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;正常调用构造函数示范&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class User {

        constructor(name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }
        
        show() {
            console.log(`姓名:${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name}，年龄:${&lt;span&gt;this&lt;/span&gt;.age}，性别:${&lt;span&gt;this&lt;/span&gt;.gender}`); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this指向始终为当前对象&lt;/span&gt;
&lt;span&gt;        }
    }

    class Admin extends User {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承User的原型对象&lt;/span&gt;
&lt;span&gt;
        constructor(name,age,gender) {

            super(name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用父类的构造函数进行构造name，其他参数由自身构造。必须放在this上面&lt;/span&gt;

            &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age; 
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.gender =&lt;span&gt; gender; 

        }

        func() {
            super.show(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用super调用的同时会将当前对象this进行传递。&lt;/span&gt;
&lt;span&gt;        }
    }

    let a1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Admin(&quot;云崖&quot;,18,&quot;男&quot;&lt;span&gt;);

    a1.func();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 姓名:云崖，年龄:18，性别:男&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;super调用其他方法的示范&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    let obj_1 &lt;/span&gt;=&lt;span&gt; {
        show(){
            console.log(&lt;/span&gt;&quot;执行了show...&quot;&lt;span&gt;); 
        },
    };

    let obj_2 &lt;/span&gt;=&lt;span&gt; {

        __proto__:obj_1,

        run(){
        
            super.show();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正常执行&lt;/span&gt;
&lt;span&gt;           
        },

    };

    obj_2.run(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行了show...&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;错误示范，不能用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;function&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;进行声明&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    let obj_1 &lt;/span&gt;=&lt;span&gt; {
        show() {
            console.log(&lt;/span&gt;&quot;执行了show...&quot;&lt;span&gt;);
        },
    };

    let obj_2 &lt;/span&gt;=&lt;span&gt; {

        __proto__: obj_1,

        run &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

            super.show();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'super' keyword unexpected here&lt;/span&gt;
&lt;span&gt;        
        },

    };

    obj_2.run(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常，super不能在function中执行&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;静态继承&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;类自身的属性以及方法都能被继承下来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class A {

        static description &lt;/span&gt;= &quot;类A&quot;&lt;span&gt;;

        static show(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&quot;类A的方法&quot;&lt;span&gt;);
        }

    }

    class B extends A {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承A的原型对象&lt;/span&gt;
&lt;span&gt;
    }

    console.log(B.description);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类A&lt;/span&gt;
    console.log(B.show());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类A的方法&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;方法覆写&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;当父类原型对象中有一个方法与子类原型对象中方法同名，子类的实例对象将调用子类的原型对象中的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;这是由原型链属性顺序查找引起的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class A {

        show() {
            console.log(&lt;/span&gt;&quot;A--&amp;gt;show&quot;&lt;span&gt;);
        }

    }

    class B extends A {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承A的原型对象&lt;/span&gt;
&lt;span&gt;
        show() {
            console.log(&lt;/span&gt;&quot;B--&amp;gt;show&quot;&lt;span&gt;);
        }

    }

    let b1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; B();

    b1.show()  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; B--&amp;gt;show&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;MixIn机制&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;由于&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Js&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;不支持多继承，所以想添加功能必须在某一个原型对象上不断的增加功能，这势必会让其本来的原型显得混乱不堪。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　这种时候就可以使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Mixin&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;机制来实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　注意：&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Minin&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类应该当做工具箱来使用，而不应该作为其他类的父类被继承下来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200805182507538-323155503.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200805182507538-323155503.png&quot; alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200805170347728-1855148932.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200805170347728-1855148932.png&quot; alt=&quot;image-20200805160602907&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d57b097d-db44-452b-9f4a-74200fcf2aef')&quot; readability=&quot;35.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_d57b097d-db44-452b-9f4a-74200fcf2aef&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_d57b097d-db44-452b-9f4a-74200fcf2aef&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d57b097d-db44-452b-9f4a-74200fcf2aef&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class Vehicle {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交通工具类&lt;/span&gt;
&lt;span&gt;        constructor(name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }

        whistle() {
            console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name}在鸣笛`);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公用方法放父类中&lt;/span&gt;
&lt;span&gt;        }
    }


    class Aircraft extends Vehicle {
        constructor(name) {
            super(name);
        }
    }

    class Car extends Vehicle {
        constructor(name) {
            super(name);
        }
    }


    let Flyable_Mixin &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 飞行器的功能&lt;/span&gt;
&lt;span&gt;        fly() {
            console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}在飞`);
        },
        outer() {
            console.log(&lt;/span&gt;&quot;其他功能...&quot;&lt;span&gt;);
        },
    };

    Object.assign(Aircraft.prototype, Flyable_Mixin); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给飞机添加上飞机Mixin的功能&lt;/span&gt;
&lt;span&gt;

    let Car_Mixin &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 汽车的功能&lt;/span&gt;
&lt;span&gt;
        reversing() {
            console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}正在倒车入库`);
        },
        outer() {
            console.log(&lt;/span&gt;&quot;其他功能...&quot;&lt;span&gt;);
        },
    };


    Object.assign(Car.prototype, Car_Mixin); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给汽车添加汽车Mixin的功能&lt;/span&gt;
&lt;span&gt;    

    let c1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Car(&quot;法拉利&quot;&lt;span&gt;);
    let a1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Aircraft(&quot;波音747&quot;&lt;span&gt;);


    c1.whistle();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  法拉利在鸣笛&lt;/span&gt;
    c1.reversing();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 法拉利正在倒车入库&lt;/span&gt;
&lt;span&gt;
    a1.whistle();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 波音747在鸣笛&lt;/span&gt;
    a1.fly();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 波音747在飞&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;代码示例&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;原型检测&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;检测方法&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;检测构造函数的 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;prototype&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;属性是否出现在某个实例对象的原型链上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;isPrototypeOf&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;检测一个对象是否是另一个对象的原型链中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

    &quot;use strict&quot;&lt;span&gt;;

    class User {

    } 


    let u1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();

    console.log(u1 &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt; User);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true  u1的原型链中包含User的原型对象吗？&lt;/span&gt;
&lt;span&gt;
    console.log(User.prototype.isPrototypeOf(u1)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true User的原型对象在u1的原型链中吗？&lt;/span&gt;

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;instanceof原理&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;递归不断向上检测原型对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkPrototype(obj, constructor) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!obj.__proto__) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj.__proto__ == constructor.prototype) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; checkPrototype(obj.__proto__, constructor);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 10:28:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>JavaScript calss语法糖 基础知识 严格意义上来讲，在Js中是没有类这一概念的。 我们可以运用前面章节提到的构造函数来模拟出类这一概念，并且可以通过原型对象的继承来完美的实现实例对象方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/13448087.html</dc:identifier>
</item>
<item>
<title>架构师必备的那些分布式事务解决方案！！ - 架构师修行之路</title>
<link>http://www.cnblogs.com/zhanlang/p/13448059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanlang/p/13448059.html</guid>
<description>&lt;p&gt;为了保证分布式环境下数据强一致性，需要引入分布式事务，而分布式事务由于网络环境的不确定性，天生就很难实现。具体可以见上一篇。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Fa9ybdcnvmaurdKSqumdrQ&quot;&gt;分布式下，我想要强一致性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了保证分布式事务的正确性，目前互联网领域有几种流行的解决方案，但是大部分都没有像XA事务一样形成标准的工业规范。但是这些方案在某些特定的行业或者业务场景下却得到了越来越多的开发者的认可。&lt;/p&gt;
&lt;h3 id=&quot;避免分布式事务&quot;&gt;避免分布式事务&lt;/h3&gt;
&lt;p&gt;此方案提倡尽量避免分布式事务，不仅仅是因为分布式事务的难度，更是因为实现分布式事务需要更多的高级人才。如果一个操作设计到事务操作，而这些事务操作可以利用单机事务来解决，推荐首选单机事务。&lt;/p&gt;
&lt;p&gt;当然，是否可以避免分布式事务还要看具体业务，在微服务盛行的当下，更多的还要看领域的划分标准，如果两个微服务可以合并成一个微服务，一定程度上在领域划分标准接受范围之内，可以考虑利用合并的方式来避免分布式服务。&lt;/p&gt;
&lt;p&gt;举一个很简单的栗子：一个用户基本信息服务和用户资产服务（比如：用户经验值），当用户修改资料的时候给用户加贡献值这个业务场景下，因为涉及到用户资料修改和加贡献值两个不同服务的操作，这个时候就可以考虑将两个服务合并为一个服务，用单机的数据库事务来代替分布式事务。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在可以避免分布式事务的情况下，首选避免分布式事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二阶段提交&quot;&gt;二阶段提交&lt;/h3&gt;
&lt;p&gt;二阶段（2PC）提交方案是基于X/OpenDTP标准规范的，最大的缺点在于它在第一阶段需要锁定资源，会大大降低系统的性能，大型的互联网应用并不推荐这种方案，那种对性能不敏感的企业级应用可以尝试使用。&lt;/p&gt;
&lt;p&gt;在asp.net中，微软已经提供了分布式事务的管理类型：TransactionScope，它依赖DTC（Distributed Transaction Coordinator）服务完成事务一致性。当它包裹的代码中如果设计到多个不同物理位置的数据库的时候，它会自动升级为分布式事务，使用起来非常方便。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using (TransactionScope ts = new TransactionScope())
            {
                数据库A操作();
                数据库B操作();
                数据库C操作();
                ts.Complete();
            }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;tcc&quot;&gt;TCC&lt;/h3&gt;
&lt;p&gt;TCC本质上是一种编程模型，它提倡的是补偿操作，所以一般情况下它会有重试机制，它约定参与事务的每个业务方都需要提供三个接口，具体情况请查看上一篇文章。由于TCC的接口重试特性，所以提供的提交和取消接口必须实现幂等性。&lt;/p&gt;
&lt;p&gt;2PC主要是针对数据库操作，而TCC主要是针对业务层面来进行操作，这在性能上比2PC要高很多，例如一个提交订单的场景，商品服务需要扣除库存，而订单系统需要创建订单，代码类似以下，请不要纠结命名和参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//订单服务
public interface IOrderService
{
     //创建一个不可见的订单，返回订单号
    Task&amp;lt;string&amp;gt; CreateOrder();
    //根据订单号提交订单，使订单可见
    Task&amp;lt;int&amp;gt; SubmitOrder(string orderNo);
    //根据订单号取消订单
    Task&amp;lt;int&amp;gt; CancleOrder(string orderNo);
} 
//商品服务
public interface IProductService
{
    //根据商品id，锁定库存,返回锁定的id
    Task&amp;lt;int&amp;gt; LockProductStock(int productId);
    //根据锁定的库存id，提交事务，扣除商品库存
    Task&amp;lt;int&amp;gt; SubmitLockStock(int lockId);
    //根据锁定的库存id，取消事务，商品库存回滚
    Task&amp;lt;int&amp;gt; CancleLockStock(int lockId);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实TCC实现过程中，还有很多细节。比如：当提交事务阶段，有一个节点由于网络原因或者down机提交失败，该怎么办呢？这个时候我们要在本地引入本地消息机制，或者叫做业务活动管理器，把每个业务参与分布式事务的每个操作都记录下来，当某个过程的某个节点操作失败，无论是自动发起重试，还是手动重试都可以达到最终数据的一致性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-267bc251082a5b5c9f6b3f7af714b72f_1440w.jpg?source=172ae18b&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基于消息的事务&quot;&gt;基于消息的事务&lt;/h3&gt;
&lt;p&gt;基于消息的分布式事务实现的是最终一致性，它是基于BASE理论的一个解决方案，最早由eBay提出并实施，它采用了消息队列来辅助实现事务控制流程，核心思想是将需要分布式处理的任务通过MQ分发给每个业务去异步执行，如果任务失败，则可以发起系统自动重试或者人工重试的纠正流程。&lt;/p&gt;
&lt;p&gt;还是以上边的创建订单和扣减库存为栗子：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先调用订单服务的创建订单接口创建订单，如果创建成功，则发送需要扣减库存的消息（也可以看做创建订单成功的消息）到MQ。&lt;/li&gt;
&lt;li&gt;商品服务监听扣减库存消息队列，如果收到扣减库存消息，则执行扣减库存操作，如果操作成功，则回复MQ删除该消息。如果没有操作成功，则准备接收同样消息的下次投递。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/553/5534532/202008/0ATYyEMu6_4OUB.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个流程看似很完美，其实有很多漏洞。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建订单是第一步操作，可以看做是单纯的单机操作，这个并没有问题，但是接着发送MQ消息这一步需要和创建订单保证事务性，因为会发生创建订单成功，发送mq消息失败的情况。如果不能用技术手段来保证这两步的事务，也可以采用引入本地消息的方案，在创建订单的时候，用订单数据库来保证订单创建成功和创建订单消息表的一致性。然后发送mq成功之后，修改订单消息表的状态为发送成功，如果发送mq消息失败，则启用另外一个线程或者进程进行重试。&lt;/li&gt;
&lt;li&gt;商品服务扣减库存类似，扣减库存这个操作和回复mq消息这两个操作也可以利用本地消息表的方式来解决一致性问题。当收到扣减库存消息的时候，扣减库存和添加消息成功处理记录可以利用数据库的事务来保证一致性，如果回复消息队列ack失败，就算是有重复消息，也可以根据本地的消费消息表来过滤重复消息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于消息的分布式解决方案还有一个劣势，如果一个事务的业务参与方非常多，消息的发送可能会非常复杂，需要非常谨慎的设计。比如以上订单的栗子，现在引入了优惠券服务，在订单创建成功，需要同时扣减库存和优惠券，如果优惠券扣减失败，需要同时回滚库存和取消订单，这也只是三个业务参与方，如果是四个，五个呢？当然这在业务中也许并不常见。&lt;/p&gt;
&lt;p&gt;基于消息的分布式事务解决方案，由于引入了重试机制，也需要接口在实现的时候支持幂等性。但从开发的角度，这种方案要比tcc以及2pc都要有优势，把每个系统之间的耦合度降到了最低，而且每个业务方的实现技术可以非常灵活，无论是采用java还是c#活着是golang都无所谓。&lt;/p&gt;
&lt;p&gt;当然市面上基于消息的分布式解决方案各式各样，但总体来说都属于最终一致性方案。如果引入消息通道MQ的不稳定性，那还需要在各个业务方引入查询机制来确保消息的ack机制。举个栗子：如果商品服务已经正常扣减库存，由于mq问题，始终不能正常ack。这个时候订单服务是否会主动查询商品服务是否已经正常扣库存？这个时候整个架构可能就非现在这个样子了，这个要是扯起来又是一篇文章了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/gQKStRKyHB_KOuDjyyodUw&quot;&gt;&lt;strong&gt;点击这里查看更多精彩内容&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 10:21:00 +0000</pubDate>
<dc:creator>架构师修行之路</dc:creator>
<og:description>为了保证分布式环境下数据强一致性，需要引入分布式事务，而分布式事务由于网络环境的不确定性，天生就很难实现。具体可以见上一篇。 分布式下，我想要强一致性 为了保证分布式事务的正确性，目前互联网领域有几种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanlang/p/13448059.html</dc:identifier>
</item>
</channel>
</rss>