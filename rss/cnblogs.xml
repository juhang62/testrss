<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>力扣142——环形链表 II - jianjianqq</title>
<link>http://www.cnblogs.com/death00/p/12147923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/death00/p/12147923.html</guid>
<description>&lt;h2 id=&quot;原题&quot;&gt;原题&lt;/h2&gt;
&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;说明：不允许修改给定的链表。&lt;/p&gt;

&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434259/202001/1434259-20200104080905018-1342812986.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434259/202001/1434259-20200104080905305-799976565.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434259/202001/1434259-20200104080905482-1824383539.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;p&gt;你是否可以不用额外空间解决此题？&lt;/p&gt;
&lt;p&gt;原题url：&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/linked-list-cycle-ii/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解题&quot;&gt;解题&lt;/h2&gt;
&lt;p&gt;在这里贴一下题目所提供的节点结构，这样下面的代码就不重复贴了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;利用集合&quot;&gt;利用集合&lt;/h3&gt;
&lt;p&gt;拿到题目的时候，一开始想到的就是利用集合，存储已经遍历过的节点，如果访问到 null，说明不是环；如果添加失败，说明已经添加过，那么一定是环，并且该节点就是环的入口；&lt;/p&gt;
&lt;p&gt;顺便说一句，我认为集合所占空间应该不是很大，因为它只是存储对象的应用地址，当然了，集合本身也是一个新的对象，也会占用额外的空间。&lt;/p&gt;
&lt;p&gt;让我们看看代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }

        ListNode current = head;
        Set&amp;lt;ListNode&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        while (current != null) {
            // 添加成功，则继续访问下一个节点
            if (set.add(current)) {
                current = current.next;
                continue;
            }

            // 添加不成功，说明重复
            return current;
        }

        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交OK，执行用时：&lt;code&gt;5 ms&lt;/code&gt;，内存消耗：&lt;code&gt;37.7 MB&lt;/code&gt;，但是提交用时只战胜了&lt;code&gt;30.99%&lt;/code&gt;的 java 提交记录，看来有必要优化一下。&lt;/p&gt;
&lt;h3 id=&quot;找规律&quot;&gt;找规律&lt;/h3&gt;
&lt;p&gt;以前我们判断链表是否有环，都是通过快慢指针最终是否相等。现在的话，因为环可能并不是首尾相连，所以只找一次可能不够了，需要继续寻找规律。&lt;/p&gt;
&lt;p&gt;我们假设一开始 slow 指针走过的路程为 x，那么 fast 指针走过的路程就为 2x，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s = x;
f = 2x;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 fast 指针最终为 null，那么说明不是环。&lt;/p&gt;
&lt;p&gt;如果 fast、slow 指针最终指向的节点相等，说明有环，并且， fast 指针比 flow 指针多走了 n 圈环的长度，那么我们假设环的长度为 b，那么可以得出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;f = x + nb;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以得出：&lt;code&gt;s = nb;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上就是最重要的结论了，slow 指针其实也已经走了 n 圈环的长度了。那么，我们再假设从 head 节点到环入口节点的长度为 a，那么从快慢指针相遇节点再走 a 步，最终会走到哪儿呢？&lt;/p&gt;
&lt;p&gt;最终也会走到环的入口节点，因为&lt;code&gt;(nb + a)&lt;/code&gt;可以理解为&lt;code&gt;(a + nb)&lt;/code&gt;，相当于从 head 节点出发，达到环的入口节点处，又绕环走了 n 圈，所以也会走到环的入口。所以此时我们也找到环的入口节点了。&lt;/p&gt;
&lt;p&gt;接下来让我们看看代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 先利用快慢指针，如果最终能相遇，说明有环
        ListNode slow = head;
        ListNode fast = head;
        while (true) {
            // 快指针为null，说明没有环
            if (fast == null || fast.next == null) {
                return null;
            }

            // 慢指针移动一步
            slow = slow.next;
            // 快指针移动两步
            fast = fast.next.next;
            // 快慢指针相等，说明相遇
            if (fast == slow) {
                break;
            }
        }

        // 再用两个指针，一个从头结点出发，一个从相遇点出发，两个指针每次移动1步，两个指针相遇的地方为环的入口
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }

        return slow;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交OK，执行用时：&lt;code&gt;1 ms&lt;/code&gt;，内存消耗：&lt;code&gt;37.8 MB&lt;/code&gt;，但是提交用时只战胜了&lt;code&gt;55.14%&lt;/code&gt;的 java 提交记录，难道还有更加高效的方法？&lt;/p&gt;
&lt;p&gt;我找了一个执行用时 0 ms 的代码，发现就是和我这个类似的，我将它的代码再次提交后，发现和我这个提交结果一样。看来那些比我们快的算法，可能是因为提交时间比较早，测试案例并不像现在那么多，所以不必担心了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目不仅要利用快慢指针，还要总结规律，最终也能解决，总的来说是一道很考验逻辑思维的题目。&lt;/p&gt;
&lt;p&gt;有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.death00.top/&quot; class=&quot;uri&quot;&gt;https://www.death00.top/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公众号：健程之道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434259/202001/1434259-20200104080905855-1797429283.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434259/202001/1434259-20200104080906159-1973999027.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Jan 2020 00:09:00 +0000</pubDate>
<dc:creator>jianjianqq</dc:creator>
<og:description>原题 给定一个链表，返回链表开始入环的第一个节点。&amp;#160;如果链表无环，则返回&amp;#160;null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/death00/p/12147923.html</dc:identifier>
</item>
<item>
<title>你是怎么变自律的？ - 启舰杂谈</title>
<link>http://www.cnblogs.com/harvic880925/p/12147907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harvic880925/p/12147907.html</guid>
<description>&lt;p&gt;很多小伙伴咨询我，&lt;/p&gt;
&lt;p&gt;“看别人坚持健身拥有好身材，我坚持不了咋办？”&lt;/p&gt;
&lt;p&gt;“我朋友天天早起看书，我都睡到自然醒，是不是要废了？”&lt;/p&gt;
&lt;p&gt;“我要向前辈看齐，每天7点起床，11点睡，每天坚持自学三小时”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;钟表式的生活方式就是自律？别人的时间表，真的就适合你？你真的需要这样吗？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;先写结论吧自律是假相你要能找到自己的驱动器而不是自律本身有些自律其实是没有任何意义的记得点赞呀&quot;&gt;先写结论吧：自律是假相，你要能找到自己的驱动器，而不是自律本身，有些自律，其实是没有任何意义的。记得点赞呀。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自律的假相&lt;/li&gt;
&lt;li&gt;找到自己的驱动器，你也行&lt;/li&gt;
&lt;li&gt;小以拆大，形成习惯&lt;/li&gt;
&lt;li&gt;一些建议&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;一自律的假相&quot;&gt;一、自律的假相&lt;/h3&gt;
&lt;p&gt;普遍认为，当我们能抵挡住诱惑并能够自我约束时，称之为自律，但当我们能够做到这些时，真的就是自律吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、固定角色&amp;gt;诱惑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有些人每天坚持做健身一小时，能一次性做200个俯卧撑、200个仰卧起坐，你觉得他自律吗？&lt;/p&gt;
&lt;p&gt;如果我告诉你，他是健身教练呢？&lt;/p&gt;
&lt;p&gt;有些人每天坚持读书5小时，你觉得他自律吗？&lt;/p&gt;
&lt;p&gt;如果我告诉，他是图书编辑呢？&lt;/p&gt;
&lt;p&gt;所以，当角色已经固定，他们不得已而为之的时候，这并不叫自律。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、七情六欲&amp;gt;诱惑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;七情六欲包括喜、怒、哀、惧、爱、恶、欲，当其中的任意一个大于诱惑时，人自然的就可以克服诱惑。&lt;/p&gt;
&lt;p&gt;比如惧，明星害怕变胖了没有粉丝，就不能多吃，你看那些节目中的名星，只吃几口或者干脆不吃， 她对身材的恐惧远大于美食的诱惑，所以，她可以做到自律。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104074657954-1880388547.webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如欲，在大学时代有个同学，每天只啃馒头，打零工，坚持了一个月，为的就是攒钱去见远方的女朋友，在欲望高于诱惑的时候，他也可以做到自律。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、看破红尘的自律&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大家都喜欢看武侠电影，但凡武功的最高境界就是无招胜有招。心中无招，出手却浑然天成，弹指拈花亦可杀人。此乃武学之最高境界。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104074706728-1437398769.webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当一个人到达这个境界时，他的眼界已足够宽阔，性情也足够成熟，自己能够控制自己的情绪，主宰自己的人生，自律又算什么呢？&lt;/p&gt;
&lt;p&gt;所以，不要老看人家几点起几点在干啥，东施效颦，终是无效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你要能看到表面下的真相，找到自己的驱动器，而不是自律本身。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二找到自己的驱动器你也行&quot;&gt;二、找到自己的驱动器，你也行&lt;/h3&gt;
&lt;p&gt;毕竟大家都是普通人，如果能做到大智大慧的话，也没必要看这篇文章了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于凡夫俗子而言，七情六俗人人有，只要找到自己想要的东西，向之努力即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特里·博纳姆在《本能》里写道：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;日常生活中，存在这么两条路。一条路诱惑我们只根据自己的冲动和直觉来生活。这条路可以称为「宠物之路」，因为所有的动物，包括家里养的宠物狗走的都是这条路。饿了就吃，吃完就算。只在得到回报时才会献出忠诚。感觉什么好，就再来；什么有害，就躲开。 而另一条路没什么明显的标志，是充满抗争的路。在这条路上，我们说了算，自己当家。除了激情，基因还赋予我们意志力和有意识控制自己行为的能力。拥有这些特殊的人类能力，我们就能超越自己的动物本能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二条路就是自律之路。&lt;/p&gt;
&lt;p&gt;比如，我刚毕业进阿里时，给自己定的目标：我要用两年的时候写本书。&lt;/p&gt;
&lt;p&gt;当时根本不知道怎么去实现，唯一与写书相似的，就是坚持写系列博客，持续地高质量产出。两年后，奇迹出现了，《Android自定义控件三部曲》深受大家欢迎，电子工业出版社、北大出版社、清华出版社先后约稿。定下目标的两年后，我真的出书了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要心存信念，通过持续的努力，所有的梦想终将实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而这个过程，只有信念与坚持，没有自律。如果你要完成你的目标，没有时间的话，你自然地会早起晚起，惜时如金。如果是知识不足的话，你自然地会竭尽所能地去汲取知识，地铁上，吃饭间，都会去搜资料。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梦想，关乎信念，而非自律本身，你所有看到的自律，都是假象，都是别人为了达到目标不得已的手段。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;像我，每天早起晚睡，你以为是自律？并不是！我要写书，我要写文章，我要做公众号，我有太多的事情等着完成，我只是在挤时间。&lt;/p&gt;
&lt;p&gt;为了每周产出一篇知乎文章，走路时思考、吃饭时思考、开会时思考，抓住一切时间，在想文章怎么架构、怎么才能更突出观点、拿什么东西佐证，力求在我有机会坐在电脑前打字时，已经胸有成竹、下笔成章。&lt;/p&gt;
&lt;p&gt;如果你单纯为了早起而早起，可能你坐在电脑前半小时，都在思考，我要做点啥呢？&lt;/p&gt;
&lt;p&gt;有些小伙伴说，你这么努力，生活还好吗？其实，我生活的很好，我紧的只是自己的时间，陪伴老婆孩子的时间，一点不会动。周末休息，我什么都不会做，就是陪家人。当孩子去洗澡睡觉了，我才开始我的写作，只要你有目标，处处皆是时间。&lt;/p&gt;
&lt;p&gt;这就是你看着别人能坚持几年，而你一个月都坚持不了原因。画虎画皮难画骨，画人画面难画心，就是这个道理。&lt;/p&gt;
&lt;p&gt;有些人根本不需要自律，因为他的目标，在工作中就能完成。我有个阿里的架构师朋友，他的工作就是钻研新技术以应用于项目中。他很喜欢这个工作，因为他的目标就是每年自己造一个轮子，很庆幸，这些东西，他在工作中就可以实现，还需要什么早起晚睡？不存在的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个人想要的都不一样，找到自己的驱动器，撕开这些伪装，他们说的自律，你也能做到。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104074707077-1829871292.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三以小拆大形成习惯&quot;&gt;三、以小拆大，形成习惯&lt;/h3&gt;
&lt;p&gt;当你决定一个宏大梦想后，这个梦想可能需要几年的时间才能完成。如何持续地坚持下去呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、按年为单位，初拆梦想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，你定的目标是三年后毕业进大公司。那你这上目标的年限就三年，你需要把它拆成今年做什么，明年做什么，后年做什么。&lt;/p&gt;
&lt;p&gt;假如，你是应届生，看过我的文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/84350029&quot;&gt;《启舰：对计算机专业来说学历真的重要吗？》&lt;/a&gt;的话，你应该看过我对应届生和社招生的建议部分。&lt;/p&gt;
&lt;p&gt;大厂最关注的几点：学校、竞赛、项目经验、实习经历&lt;/p&gt;
&lt;p&gt;学校是我们没有办法改变的，但竞赛、项目经验、实习经历是可以自己努力去做的。这时，你的目标就来了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一年：找到方向，编程入门，参加两个竞赛&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二年：仿三个实战项目，参加实习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四年：参加校招&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、按月为单位，细拆梦想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在是第一年，今年的目标是找到方向，编程入门，参加两场竞赛。&lt;/p&gt;
&lt;p&gt;初步的计划就有了：第一个月找到方向和资料，十月份前完全入门，后两个月复习。其中参加6月份和11月都有两个国家级竞赛要参加。再根据你找到资料进行细分到每月应该学习几章，这样，每月的计划就出来了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、制作每日计划表，形成习惯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在每个月的计划，细分到每周要完成哪些内容，细分到每天，在每周的最后一天规整这周哪些完成了，哪些没完成，下周要做什么，同样细分到每天。&lt;/p&gt;
&lt;p&gt;当然这些计划都不是一程不变的，比如这周你有急事没完成，没关系，调整一下周计划，月度目标完成即可。如果这个月目标没完成，没关系，调整下月度安排，年度计划完成就可。&lt;/p&gt;
&lt;p&gt;但建议大家小粒度调整，尽量不要做月度目标调整，经常调整会造成我们所有的计划都不用按时完成的错觉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实，一旦你年度目标没有完成，那你来年的目标也肯定不会完成！人就是这样，对自己心软了一次，下次就会变得理所当然。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里仅仅以在校生为例来讲述了梦想拆分法，其它亦然。&lt;/p&gt;
&lt;p&gt;无论对于校招，还是社招，如果你的梦想是提升技术，那可以采用相同的套路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找到学习资源&lt;/li&gt;
&lt;li&gt;拆分到每月、每周为单位进行完成&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;我精心整理了计算机各个方向的从入门、进阶、实战的视频课程和电子书，都是技术学习路上必备的经验，跟着视频学习是进步最快的，而且所有课程都有源码，直接跟着去学！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要关注微信公众号【启舰杂谈】后回复你所需方向的关键字即可，&lt;/strong&gt;比如『Android』、『java』、『ReactNative』、『H5』、『javaweb』、『面试』、『机器学习』、『web前端』、『设计模式』等关键字获取对应资料。（所有资料免费送，转发宣传靠大家自愿）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频内容非常多，总共2184G、一千六百多册电子书，九百多套视频教程，涉及43个方向。我整理了很长时间，有些资料是靠买的，希望大家能最快的提升自己。记得帮我点赞哦。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90965179&quot;&gt;启舰：全网2184G计算机各方向视频教程/电子书汇总（持续更新中）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只要有目标，并把它拆解，你会发现，别人能做到的，你也能行！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104074707786-1275875082.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四一些建议&quot;&gt;四、一些建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、如何克服早起&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的情况跟我一样，时间不够，那你早起晚睡是少不了的，早起是每天最困难的事了。&lt;/p&gt;
&lt;p&gt;有个诀窍，我是屡试不爽。&lt;/p&gt;
&lt;p&gt;（1）、前一天晚上提前想好，明天早上要做的事情，比如我要把需要的资料搜集完。&lt;/p&gt;
&lt;p&gt;（2）、早上想想自己的「人生大计」和今天早上要做的事，在心里默数五下，1、2、3、4、5。在默数时，好好享受这五秒的悠闲时光，然后，开工吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、提高效率，远离手机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你要考研，那只要保持联系畅通即可。在教室看出时，手机换成非智能机，绝对能解决你的问题。只有吃饭时，才简单看看微信消息有没有要处理的问题即可。&lt;/p&gt;
&lt;p&gt;另外，也可以利用APP帮你锁住手机，比如Forest&lt;/p&gt;
&lt;p&gt;它的激励机制是「种树」，每专注 25 分钟就会种下一棵树。&lt;/p&gt;
&lt;p&gt;一旦你打开其他 APP，树就会立马死掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104074708228-1066555481.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、尽量减少外界干扰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有人说，人的脑子里有只猴子，总是上蹿下跳，让你无法专注。&lt;/p&gt;
&lt;p&gt;比如，我在写文章，经常会蹦出来个念头：&lt;/p&gt;
&lt;p&gt;“昨天XXX说给我发邮件，怎么还没收到？不行，我得问问。”&lt;/p&gt;
&lt;p&gt;“我的公众号，又涨了几个粉？知乎上是不是又有人留言了？”&lt;/p&gt;
&lt;p&gt;解决方法是，把手机放一边，给自己定好规矩，早上八点前不看手机，在文章写完前，不看手机。靠理性压制邪念，大脑是可以管得住大脑的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、学会写日记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我很喜欢写日记，但并不是每天写。隔三差五想到了什么，就写写这几天发生的人和事、心得体会。自己给自己加油打气。&lt;/p&gt;
&lt;p&gt;把痛苦和不甘留给日记，把信念和毅力留给自己。&lt;/p&gt;
&lt;p&gt;现在，日记是只属于我的港湾，生活上、工作上遇到了困难，发泄两句，骂骂娘。觉得自己的目标完不成了，在日记上自己给自己说话，鼓励自己是能行的，让自己相信自己是可以的，就这样一次又一次的鼓励自己，让日记上的自己跟自己说，你可以的，直到，你相信你是可以的。关闭文档，再一次地充满能量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;祝大家都能找到自己的驱动器，并坚持下去，终有一日，你将不同，加油。记得帮我点赞哦。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;爆文推荐&quot;&gt;爆文推荐：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91535354&quot;&gt;启舰：计算机考研，这样选学校才是正解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90396934&quot;&gt;启舰：计算机专业有必要考研吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/87648096&quot;&gt;启舰：在中国程序员是青春饭吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/86227216&quot;&gt;启舰：如何在计算机面试中牵着面试官鼻子走？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/85861940&quot;&gt;启舰：有哪些让程序员受益终生的建议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/93527421&quot;&gt;启舰：你是怎么变自律的？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;更多启舰原创文章&quot;&gt;更多启舰原创文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/98002434&quot;&gt;启舰精品文章列表&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;资源下载&quot;&gt;资源下载：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82625140&quot;&gt;启舰：全网2184G计算机各方向视频教程/电子书汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90965179&quot;&gt;启舰：452G计算机考研初试/复试资料汇总（初试辅导视频+各大高校复试资料，全免费！！！）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83835790&quot;&gt;启舰：最新！2016-2019计算机历年校招真题、面经、复习资料总结（11G/2284份文件）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104074708815-1387052726.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;本人所有文章皆为原创都与版权保护平台有合作著作权归启舰所有未经授权转载必究&quot;&gt;本人所有文章皆为原创，都与版权保护平台有合作，著作权归启舰所有，未经授权，转载必究！&lt;/h3&gt;
</description>
<pubDate>Fri, 03 Jan 2020 23:47:00 +0000</pubDate>
<dc:creator>启舰杂谈</dc:creator>
<og:description>很多小伙伴咨询我， “看别人坚持健身拥有好身材，我坚持不了咋办？” “我朋友天天早起看书，我都睡到自然醒，是不是要废了？” “我要向前辈看齐，每天7点起床，11点睡，每天坚持自学三小时” 钟表式的生活</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/harvic880925/p/12147907.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合Thymeleaf-基于SpringBoot2.X版本 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/12128324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/12128324.html</guid>
<description>&lt;p&gt;熊dei们，别着急，我们先来谈谈为啥开始用Thymeleaf模板引擎，先照顾照顾下我们这些可爱的小白童鞋....&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为啥开始用Thymeleaf模板引擎？jsp她不香嘛？&lt;/strong&gt;&lt;br/&gt;首先前端交给我们的页面，是html页面，如果是我们之前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。jsp支持非常强大的功能，包括能写Java代码.......是的先给jsp一顿夸。&lt;/p&gt;
&lt;p&gt;但是呢，SpringBoot项目是以jar的方式，不是war方式，而且SpringBoot用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的.......是的然后给jsp反手一嘴巴子。&lt;/p&gt;
&lt;p&gt;那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢，SpringBoot推荐使用模板引擎。模板引擎有很多种，比如&lt;code&gt;Thymeleaf&lt;/code&gt;、&lt;code&gt;Velocity&lt;/code&gt;、&lt;code&gt;FreeMarker&lt;/code&gt;，不过思想都是一致的，这个就不必担心，springboot推荐使用&lt;code&gt;Thymeleaf&lt;/code&gt;，当然基本上程序员用的都是Thymeleaf模板引擎，在业界Thymeleaf模板引擎是业界的一致好评。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在不都前后端分离了么？Vue她不香嘛？&lt;/strong&gt;&lt;br/&gt;虽然现在慢慢在流行前后端分离开发，但是还是有一些&lt;code&gt;“灵玩不灵”&lt;/code&gt;的公司依旧在做前后端不分的开发，而在前后端不分的开发中，我们就会需要后端页面模板引擎【实际上，即使前后端分离，也会在一些场景下需要使用页面模板，举个典型的栗子：&lt;code&gt;邮件发送模板&lt;/code&gt;】。&lt;/p&gt;

&lt;p&gt;随着科技的发展，社会在进步，企业在奔跑，程序员在咆哮。醒醒吧年轻人，现在都2020年，在之前难免会听到或者看到网上的文章什么的说第一步要导入Thymeleaf模板依赖包，说啥在以往的版本中默认是Thymeleaf 是2.1.6x , 开发要基于3.x，然后又要在pom.xml的properties标签中写下以下两句代码&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;thymeleaf.version&amp;gt;3.0.9.RELEASE&amp;lt;/thymeleaf.version&amp;gt;        
&amp;lt;thymeleaf-layout-dialect.version&amp;gt;2.2.2&amp;lt;/thymeleaf-layout-dialect.version&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说是布局功能的支持程序需要 thymeleaf3主程序、 layout2以上版本，也就是说手动把3.x的thymeleaf覆盖掉依赖中的2.x。&lt;/p&gt;
&lt;p&gt;说了一大堆，我只想说一句：现在的版本基本默认都是thymeleaf3.x，现在2020年了，就算是学生仔学习基本都是SpringBoot2.X版本了。如果你还在用SpringBoot1.X，那我们不合适，你是个好人。&lt;/p&gt;
&lt;p&gt;如果还是不确定，你大可进行如下操作，检查检查thymeleaf版本：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229203239244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;得，说（扯）了一大堆，不如来整：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191231090448609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;想上面，可能不同的idea版本会出现选择SpringBoot版本不同的情况，这很正常，人生建议：不管啥都不要追求最新版，你用起来好像很牛皮很高端，同时一根烟一行bug改一天的样子也是非常潇洒~狼狈~的，这里我就不多概述了。&lt;/p&gt;
&lt;p&gt;勾选Thymeleaf之后，创建完成后，pom.xml 依赖会默认如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，以及导入Thymeleaf依赖了，不需要再导了。到这里基本上可以说是整合完成了，接下来讲讲Thymeleaf的强大功能。&lt;/p&gt;

&lt;p&gt;Thymeleaf渲染规则，可以找到它的自动配置文件即可查看它的使用规则，如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019123109291370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;关键代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)
public class ThymeleafProperties {
        private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;
        public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
        public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
        private boolean checkTemplate = true;
        private boolean checkTemplateLocation = true;
        private String prefix = DEFAULT_PREFIX;
        private String suffix = DEFAULT_SUFFIX;
        private String mode = &quot;HTML&quot;;
        private Charset encoding = DEFAULT_ENCODING;
        private boolean cache = true;
        //...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析源码，过程如下：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;1、首先通过 &lt;strong&gt;@ConfigurationProperties&lt;/strong&gt; 注解，将 &lt;strong&gt;application.properties&lt;/strong&gt; 前缀为 &lt;strong&gt;spring.thymeleaf&lt;/strong&gt; 的配置和这个类中的属性绑定。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;2、前三个 &lt;strong&gt;static&lt;/strong&gt; 变量，定义了默认的编码格式、视图解析器的前缀、后缀等。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;3、根据前三行配置，可以看出，&lt;strong&gt;Thymeleaf&lt;/strong&gt; 模板的默认位置在 &lt;strong&gt;resources/templates&lt;/strong&gt; 目录&amp;gt;下，默认的后缀是 &lt;strong&gt;html&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;注意：这些配置，如果开发者不自己提供，则使用 默认的，如果自己提供，则在 &lt;strong&gt;application.properties&lt;/strong&gt; 中以 &lt;strong&gt;spring.thymeleaf&lt;/strong&gt; 开始相关的配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是的，简单来说默认规则如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;默认前缀&lt;/strong&gt;：&lt;code&gt;DEFAULT_PREFIX = &quot;classpath:/templates/&quot;&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;默认后缀&lt;/strong&gt;：&lt;code&gt;DEFAULT_SUFFIX = &quot;.html&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完全类似 Spring MVC 的映射，当然如果要修改这些配置只需要在全局配置文件中覆盖修改即可，我们一般不覆盖，除非特殊需求。&lt;/p&gt;
&lt;p&gt;还需要提及一点的是&lt;span&gt;&lt;strong&gt;Spring Boot 为 Thymeleaf 提供的自动化配置类&lt;/strong&gt;&lt;/span&gt; &lt;code&gt;org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration&lt;/code&gt; ，其中部分关键源码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Configuration
@EnableConfigurationProperties(ThymeleafProperties.class)
@ConditionalOnClass({ TemplateMode.class, SpringTemplateEngine.class })
@AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })
public class ThymeleafAutoConfiguration {
   //....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从源码中可以看到，这个自动化配置类中，首先&lt;code&gt;@EnableConfigurationProperties&lt;/code&gt;导入 ThymeleafProperties ，然后 &lt;code&gt;@ConditionalOnClass&lt;/code&gt; 注解表示当前系统中存在 TemplateMode 和 SpringTemplateEngine 类时，当前的自动化配置类才会生效，即只要项目中引入了 Thymeleaf 相关的依赖，这个配置就会生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些默认的配置我们几乎不需要做任何更改就可以直接使用了。如果有特殊需求，则可以在 &lt;code&gt;application.properties&lt;/code&gt; 中配置以 &lt;code&gt;spring.thymeleaf&lt;/code&gt; 开头的属性就可以自己量身定制了，当然我是不可能有这种需求的，除非有人要打我，否则想不想要想我会有这种需求癖好。如果非要改建议参考&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/#howto-reload-thymeleaf-content&quot;&gt;SpringBoot官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;是的，以上步骤谁都会，只有测试整合Thymeleaf成功之后才算是整合完成了，也就是这个阶段各种原因的错误就出来了。&lt;/p&gt;
&lt;h4 id=&quot;controller代码&quot;&gt;Controller代码&lt;/h4&gt;
&lt;p&gt;首先编写Controller代码，咱也不写的那么复杂，demo怎么简单怎么来&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Controller
public class HelloController {
    @GetMapping(&quot;/su&quot;)  
    public String success(){
        return &quot;success&quot;;    //  相当于访问 classpath:/templates/success.html
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;html页面代码&quot;&gt;html页面代码&lt;/h4&gt;
&lt;p&gt;编写页面代码，千万注意这个页面代码要在&lt;code&gt;classpath:/templates/&lt;/code&gt;目录下&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191231103234845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;  
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;整合Thymeleaf已经success哈哈哈哈&amp;lt;/h1&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;访问测试&quot;&gt;访问测试&lt;/h4&gt;
&lt;p&gt;访问&lt;code&gt;http://localhost:8080/su&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191231102947483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;如上效果则说明整合成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191231103848132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种异常很常见具体的还得看异常的信息，比如上面说是页面路由出现了环，等同于循环引用了，可能是自己的访问路径名和HTML文件重名了，不妨改个请求路径试试。&lt;/p&gt;
&lt;p&gt;再比如，下面总的来说具体看打印信息&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191231110146549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里归纳一下异常原因并解决：&lt;/p&gt;
&lt;p&gt;1、Application启动类的位置不对：要将Application类放在最外侧，即包含所有子包 ，spring-boot会自动加载启动类所在包下及其子包下的所有组件。如果启动类没有放在最外侧就会报错，正确位置如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191231110733473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;2、springboot的配置文件有误：关于&lt;code&gt;application.yml&lt;/code&gt;或&lt;code&gt;application.properties&lt;/code&gt;文件中视图解析器的配置问题。在&lt;code&gt;pom&lt;/code&gt;文件下的&lt;code&gt;spring-boot-starter-paren&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;版本较高时使用配置：spring.mvc.view.prefix/spring.mvc.view.suffix&lt;br/&gt;版本较低时使用配置：spring.view.prefix/spring.view.suffix&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、控制器的url访问路径与注解@XXXMapping（&quot;/xxxx&quot;）不匹配，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191231111026663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;4、最后这个原因就特别坑了喔，你会发现上面你都符合了但是依旧还是报错，这就很神奇了，其实我就是这个原因被坑了一上午————&lt;span&gt;&lt;strong&gt;版本太高了&lt;/strong&gt;&lt;/span&gt; 。可能你会说idea默认选择的时候都是2.1.X往上，基本没有自己想要的版本，其实这都不是很大的问题，其实可以在pom.xml中修改即可，如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191231111809616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;如果这过程还有异常发生，让你参生恐惧，记住，战胜恐惧的最好办法就是面对恐惧，醒醒吧年轻人，一giao我哩giaogiao嗷..嗷嗷嗷..嗷嗷嗷嗷..嗷嗷嗷嗷嗷............................奥利给！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，里面有一些java学习资料和一大波java电子书籍，比如说周志明老师的深入java虚拟机、java编程思想、核心技术卷、大话设计模式、java并发编程实战.....都是java的圣经，不说了快上Tomcat车，咋们走！最主要的是一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;参考：&lt;/p&gt;
&lt;p&gt;SpringBoot官方文档：https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/&lt;/p&gt;
&lt;p&gt;http://www.imooc.com/article/293021&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qushaming/article/details/94593675&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jan 2020 23:36:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>1、为啥要用Thymeleaf模板引擎？现在不都前后端分离了么？ 熊dei们，别着急，我们先来谈谈为啥开始用Thymeleaf模板引擎，先照顾照顾下我们这些可爱的小白童鞋.... 为啥开始用Thyme</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/12128324.html</dc:identifier>
</item>
<item>
<title>如何系统地学习计算机编程？自学还是培训？怎么选？ - 启舰杂谈</title>
<link>http://www.cnblogs.com/harvic880925/p/12147896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harvic880925/p/12147896.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;前言：生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。 ——莫泊桑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在校生要找到好工作，主要靠几个光环，学校光环、竞赛光环、项目光环、实习光环。其中项目经验尤为重要。有些同学就有疑问了：&lt;/p&gt;
&lt;p&gt;“我校招没offer，没有项目经验，是不是要报个培训班？”&lt;/p&gt;
&lt;p&gt;“我转行计算机，是不是应该报个班？”&lt;/p&gt;
&lt;p&gt;“我也想自学，可怎么学啊，选哪个方向啊？”&lt;/p&gt;
&lt;p&gt;对于有些同学，当我还在想办法劝他自学时，给我贴出了培训班的广告词，&lt;strong&gt;真可谓，人有多大胆，口号就有多不要脸：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“0基础入学，三个月包就业”&lt;/p&gt;
&lt;p&gt;“毕业月入不过万，不收学费”&lt;/p&gt;
&lt;p&gt;“从前是你找工作，接下来是工作找你”&lt;/p&gt;
&lt;p&gt;当我推荐某些同学去培训时，又给咔咔咔亮出了几个帖子，说培训出来的受歧视啊、有些同学培训出来还是找不到工作啊，等等。&lt;/p&gt;
&lt;h3 id=&quot;其实选择自学还是培训是看自身情况而定无论选择自学还是培训都只是入门的一种手段各有优劣势本文就详细说说自学培训怎么选选择以后怎么办记得帮我点赞哦&quot;&gt;其实，选择自学还是培训是看自身情况而定，无论选择自学还是培训，都只是入门的一种手段，各有优劣势，本文就详细说说自学/培训怎么选，选择以后怎么办，记得帮我点赞哦。&lt;/h3&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自学还是培训，怎么选？&lt;/li&gt;
&lt;li&gt;自学怎么学？&lt;/li&gt;
&lt;li&gt;培训班到底在培训什么？&lt;/li&gt;
&lt;li&gt;有些企业歧视培训班学员，培训班的问题到底出在哪？&lt;/li&gt;
&lt;li&gt;一些建议&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;一自学还是培训怎么选&quot;&gt;一、自学还是培训，怎么选？&lt;/h3&gt;
&lt;p&gt;无论你是什么学历、有没有计算机基础，这些都不是决定你适合自学的条件，具备如下三个条件的人都可以选择自学：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）、时间充足&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果说从零基础靠自学达到找工作的水平，需要多久呢？我觉得至少一年，有的人可能需要两年。所以，如果你是大一、大二、大三的学生，你还有时间，可以选择自学。如果你是已经工作的，想转行计算机，可以边工作边学习，这个过程会比较辛苦，但也不是绝对不可行。&lt;/p&gt;
&lt;p&gt;对于大四的同学，以就业为导向，建议你去培训。不可否认，培训是最快入门的方式，对于时间不足的同学而言，培训是最优解。同样地，如果你是已工作的，不存在财务压力，我同样建议你去培训，工作后的时间很珍贵，比不上在校期间有大把时间可以浪费，如果做好了必转的决心，以最快速度转行才是最优解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）、自控力强&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能管得住自己，自己定的目标能想尽一切办法实现的同学，真不多，能占人群中1/4已经不错了。&lt;/p&gt;
&lt;p&gt;有些人学了半小时就会累，休息一会，就成这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072449675-332508754.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我见过太多的半途而废的同学，也见过太多自己安慰自己式的学习方式，&lt;strong&gt;但就业就是一个试金石，你这段时间的努力有没有回报，去找工作的时候，就水落石出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在自律这方面不太行的话，可以看下这篇文章，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/93527421&quot;&gt;《启舰：你是怎么变自律的？》&lt;/a&gt;，找到自已的驱动器，完成自己的梦想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）、具备高中以上学历&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机本身是数学家发明的，或多或少会用到一些基本的数学知识、经常用到的很多算法都是数学知识的延伸，没有基本的数学功底，自学确实很难。&lt;/p&gt;
&lt;p&gt;至于英语阅读能力还好说，只要会用有道词典，不会的去搜去看，总会读懂的，而且入门级的文献和视频中文版的资料已足够你入门，英语应该不是太大的问题。&lt;/p&gt;
&lt;p&gt;如果你这三点都满足，恭喜你，你具有了自学的基础，可以选择自学。&lt;/p&gt;
&lt;h3 id=&quot;二自学怎么学&quot;&gt;二、自学怎么学？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、选定一个方向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，我们选择方向的目的是什么？&lt;/strong&gt;不就是为了找份工作吗？那直接到招聘类网站去搜下相关的岗位数量及要求不就好了，哪个数量多，自己也喜欢，那就选这个即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次，如果是大三、大四即将毕业的同学，想知道最近哪个岗位好找工作的话。&lt;/strong&gt;还可以看看很多培训机构的培训内容，现在很多培训机构都声称保就业，真的以为，培训几个月能培训出朵花来吗？不可能的，编程是个需要长期训练的活，几个月的培训，仅是入门而已，入门的水平能保证找份工作，就靠的是这个岗位门槛低，需求大，好找工作。&lt;/p&gt;
&lt;p&gt;如果实在不知道选什么，我帮你找几个方向：python、java后端、Html5就业岗位都挺多，就业门槛低，相对好就业，如果也有其它方向推荐，大家可以留言。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、找到几套视频教材&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在入门时强烈不建议跟着书学&lt;/p&gt;
&lt;p&gt;第一，不一定能看得懂&lt;/p&gt;
&lt;p&gt;第二，书本的知识不成体系，入门有入门的书，进阶有进阶的书，实战有实战的书，需要自己去选择，本身就不是一件易事。&lt;/p&gt;
&lt;p&gt;第三，视频可以看到老师的操作，而书本全靠自己摸&lt;/p&gt;
&lt;p&gt;现在某某培训班的入门、进阶、实战的系列视频不要太好找，找到这么两套视频，对比着看，或者跟着一套视频深入看，来得更容易。人家培训班安排好的路线跟着学，不懂的自己搜，就已经排除了自已给自己安排路线的难点，况且人家本身就是面向就业的，培训出来的同学能保就业，只要你能跟着学通学会，自然找到工作也不是问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我精心整理了计算机各个方向的从入门、进阶、实战的视频课程和电子书，都是技术学习路上必备的经验，跟着视频学习是进步最快的，而且所有课程都有源码，直接跟着去学！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要关注微信公众号【启舰杂谈】后回复你所需方向的关键字即可&lt;/strong&gt;，比如『Android』、『java』、『ReactNative』、『H5』、『javaweb』、『面试』、『机器学习』、『web前端』、『设计模式』等关键字获取对应资料。（所有资料免费送，转发宣传靠大家自愿）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视频内容非常多，总共2184G、一千六百多册电子书，九百多套视频教程，涉及43个方向。我整理了很长时间，有些资料是靠买的，希望大家能最快的提升自己。帮我点个赞吧。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82625140&quot;&gt;全网2184G计算机各方向视频教程/电子书汇总（持续更新中）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、自学，除了知识，你还能学到什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自学的缺点很明显：&lt;/p&gt;
&lt;p&gt;第一：速度慢，所有进度完全靠自己把控，没有氛围&lt;/p&gt;
&lt;p&gt;第二：遇到问题需要自己解决，无人请教&lt;/p&gt;
&lt;p&gt;那优点恰恰是从这些缺点中磨练出来的，进度靠自己把握，完全磨练了你的意志力。而所有问题靠自己解决，恰恰培养了你的解决问题的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而这些能力都是培训班教不出来的、无法速成的。而这些能力却是真正的开发高手所必备的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题定义、分析与设计阶段，这是最需要智商、创造力和经验的阶段，真正的开发高手，就是在这一阶段体现出远超普通人的水平，而在这一阶段所需要的能力，对不起，培训班教不出来，也无法速成，只能靠人自己的努力，慢慢地培养和增强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、自学建议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）、多做笔记、多复习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚开始学习时，很难，真的很难。很多东西听不懂，很多东西需要自己搜，自己定的进度很可能完不成。&lt;/p&gt;
&lt;p&gt;没关系，坚持下去，都是这么过来的。我刚开始自学的时候，也是无数次想死的冲动……&lt;/p&gt;
&lt;p&gt;学会做笔记，把自己学到的东西及时记下来，形成目录，在后面用到的时候，根据笔记再去看一遍，刚开始经常会出现，听得懂，跟着学会，自己弄就不会的现象。这都是正常的，技术本就是个熟能生巧的过程。&lt;/p&gt;
&lt;p&gt;多动手，多总结，就慢慢熟练了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）、多写代码！听得懂、看得懂，并没什么用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;入门级知识，本就是语法和框架的熟悉过程，说到底就是工具的使用方法熟悉的过程。既然是工具，那就必然要多用。熟能生巧，指的是用的熟。很多同学看的懂，听的会，自己一下手就问题百出，就是练的少！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）、听不懂，搜一下，再不懂就放过&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚学的时候很多概念听不懂，没关系，自己搜一下，能理解了就理解，理解不了就算。听一遍就行，学到后面的时候，你就懂些了回头，再看看那些知识，基本上你都懂了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）、多写注释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚开始的时候，很多逻辑弄不懂，没关系，自己把代码拆解，并对其加以注释，这样，你在反过来再看这些代码时，能很快弄懂它的逻辑。你要知道，你后面学习时还是会碰到这些知识的，而在只看一遍的情况下是不可能记得住的，到时候，你还是会返回来复习这些知识的。&lt;/p&gt;
&lt;p&gt;增加注释，看起来浪费时间，其实是整理代码逻辑的过程。浑浑噩噩敲出来的代码，自己都不明白什么意思的话，其实相当于没有真正学会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072450173-1636968297.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三培训班到底在培训什么&quot;&gt;三、培训班到底在培训什么？&lt;/h3&gt;
&lt;p&gt;去培训的主要原因，说到底还是因为自己啥都不会。但不会与不会间是有区别的。&lt;/p&gt;
&lt;p&gt;对于科班出身的，上学又好好学了的同学，虽然他们没有系统的编程知识，没有项目经验，但他们有计算机基础，他懂得操作系统原理、数据结构与算法等原理性知识。&lt;/p&gt;
&lt;p&gt;而对于跨专业和在玩了四年的同学而言，那才是真正的零基础。&lt;/p&gt;
&lt;p&gt;而对于培训机构而言，它的责任就是让你实现从0到1的入门过程，而有经验的老鸟都知道，编程入门仅仅是知识的堆积，并没有什么技巧性可言。所有的语法和框架运用，简单来说，就是学会编程套路，学习工具使用。&lt;/p&gt;
&lt;p&gt;而培训机构的责任，就是把这些套路教给你。只要你不太笨，经过几个月的强化训练，大部分人都能学得会。&lt;/p&gt;
&lt;p&gt;所以，培训班教你的就是工具的使用，目的，就是以最快的速度塞给你，助你找到工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072450484-36085167.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四有些企业歧视培训班学员培训班的问题到底出在哪&quot;&gt;四、有些企业歧视培训班学员，培训班的问题到底出在哪？&lt;/h3&gt;
&lt;p&gt;培训机构有着熟练的授课体系，老师手把手答疑，让你在学习路上没有一丁点的思考时间，为的就是以最快的速度让你达标，好结课，开始下一波培训。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、问题就出在速度上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;认知科学的研究成果表明，知识的消化与吸收，职业技能的学习与精通，本质上是在大脑神经元之间建立连接，重塑大脑结构的过程，这个过程的时间可以缩短，但不能无限地缩短。另外，不同的人，拥有不同的背景和基础，在学习与掌握相同的知识与职业技能时，所花的时间是不一样的。&lt;/p&gt;
&lt;p&gt;而培训机构才不管这些，他的目的就是挣钱，以最快的速度挣钱，能在三天内把所有内容塞给你绝不用四天，只要最终能糊弄住面试官，让学员找到一份工作就可以了。&lt;/p&gt;
&lt;p&gt;所以，必然会出现下面的现象：&lt;/p&gt;
&lt;p&gt;对于原来有一些基础的，学习能力较强的同学，在学习之前已经有较扎实的基础，所以在培训期间能够自己构建成技术体系，知识吸收相对较好：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072450755-222197493.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而另一些学员，则会出现消化不良的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072451006-1955665454.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、培训后遗症&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于软件开发而言，所有的软件开发都大致分为两个阶段：&lt;/p&gt;
&lt;p&gt;1、分析、定义、设计阶段。这个阶段是需要有解决问题、分析问题的能力。而这个能力培训班培训不出来，只能是慢慢增强。&lt;/p&gt;
&lt;p&gt;2、语法、工具的使用，将设计的内容实现出来。这一块就比较机械了，工具嘛，学一学都能会，培训班在这一块的效率是很高效的，它们多半能在较短的时间内，教会学员特定编程语言（比如Python）特定工具（比如Git）与特定技术的使用（比如Spring MVC），并且传授给他们一些开发的“套路”（比如分层架构与设计模式），从而将学员成功地培养成为一个能够“搬砖”的软件工人，即初级程序员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;培训班一般都会选择门槛低、就业岗位多的方向进行培训，对于这类岗位，人才缺口大，只要能直接上手写代码的初级程序员，都很容易找到一份工作。这也就是为什么培训班多半会收学生五位数的学费，而学生也愿意支付的根本原因。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）、解决问题能力差，动不动就得人教&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过几个月饭来张口、衣来伸手的填鸭式集训，有些人在工作后，却依然认为，当他遇到问题时，从来不想着自己搜搜资料解决，而是依赖同事帮他答疑！&lt;/p&gt;
&lt;p&gt;自学能力差、解决问题能力差，是很多人找到了工作，过不了试用期的根本原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）、培训效果立竿见影，却又很快遗忘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何的知识都是一样，短时间内填鸭式学到的知识，在一段时间不用后，就会遗忘。这就是有些同学刚从培训班出来时，能找到份工作，当学到的东西在工作中几个月用不到时，就很快忘记，总觉得自己还是啥都不会的原因。&lt;/p&gt;
&lt;p&gt;** 永远要记住：学历不行靠实力，实力不行靠态度！！！**&lt;/p&gt;
&lt;p&gt;当我们初入职场，尽心尽责地把自己的工作做完做好的同时，千万不要忘记像海绵一样，以最快的速度给自己充水。&lt;/p&gt;
&lt;p&gt;像培训完的同学，在校期间已经做了很多的笔记，工作之余，多复习，重新练，利用时间将它理解，真正内化为自己的本领。&lt;/p&gt;
&lt;p&gt;对于自学的同学，多找进阶性书籍和视频去看，以最快的速度提升自己。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末我整理了计算机各个方向的从入门、进阶、实战的视频课程和电子书，都是技术学习路上必备的经验，跟着视频学习是进步最快的，而且所有课程都有源码，直接跟着去学！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072451367-505338743.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;五一些建议&quot;&gt;五、一些建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、非科班同学建议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于非科班转行计算机的同学，有太多的知识需要补足，如果你靠的是自学，需要强有力的自律能力，只要时间还够，是可以靠自学的，在跟着视频学的时候，哪里听不懂及时去搜相关的资料去补足。&lt;/p&gt;
&lt;p&gt;刚开始自学时，即便是科班出身也是有想死的冲动的，大家都一样。我也是靠自学过来的，很多的东西不会，很多的东西听不懂。没关系，多做笔试，多搜资料，把不会的弄会，你会发现，学习起来越来越容易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有的困难只不过是纸老虎，坚持过去就成功了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你是通过培训找到了一份工作，你需要比别人更努力补充计算机知识，基础知识的缺乏，会使你很难在这条路上走很远，所有的大神，都是自学能力很强的人，你想，你也可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、所有开发方向都必须从C++开始？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经常会有要校生问我：我要做H5开发，是不是要先学C++?&lt;/p&gt;
&lt;p&gt;其实，各个语言之间是没有任何关联的，完全都是有各自的语法体系和开发工具的，简单来讲，他们都是不同类型的工具。&lt;/p&gt;
&lt;p&gt;你学会一种工具，只会对另一种类似的工具更容易上手，而不是完全不用学。所以，想学哪个方向，直接去学就行了，没必须先从C++入手迂回一下，纯属浪费时间。&lt;/p&gt;
&lt;p&gt;但，如果你还在上学，现在正在学C++，那我还是建议你好好学，必须C语言语法更接近低层编译器原理，学会了它，对理解低层分配、释放、编译机制都是很有用的，但就以工作为导向而言，如果你不从事C++相关工作，是没必要学的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072451684-723751473.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、培训出来人人工资过万？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有个男生非常沮丧的找我，自己是专科毕业，培训完，小公司不想进，大点的公司进不去，给的工资也不高，问我怎么办？&lt;/p&gt;
&lt;p&gt;上面我们已经讲到，对于不同程度的同学，在培训出来的结果是不一样的，你要分清，你培训完的情况是属于这种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072451889-1674461637.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是这种？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072452162-1217158588.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于没有名校光环的同学，建议以先就业为主。&lt;/p&gt;
&lt;p&gt;别看培训班招你的时候给你洗脑，培训完人人过万，但能不能过万，最终靠的是自己，而不是培训班。&lt;/p&gt;
&lt;p&gt;认请自己的情况，可以先就业，再优化自己履历，而进步步高升。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、建议不要暴露自己的培训经历&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你百度、知乎搜一下，遍地的培训歧视，很多公司根本不要培训出来的同学.&lt;/p&gt;
&lt;p&gt;业界对培训有偏见，因为写代码是一个逐渐学习、熟练的过程，经过几个月集中的培训，虽然看起来什么都接触到了，但真正能内化为自己知识的部分其实不多。在工作中并不能熟练运用，仅是入门水平而已。&lt;/p&gt;
&lt;p&gt;而且大家普遍认为参加培训的主要原因是因为，大学中没好好学，临近毕业了，催熟一把。不然，谁会花这几万块钱呢？对普通家庭而言，其实也并不是个小数目了。&lt;/p&gt;
&lt;p&gt;有一个外包公司的朋友，技术总监，招人时培训公司出来都不要，原因就是干活能力不行。当然这仅代表个例，&lt;strong&gt;但大家需要注意的是，业界并不认为培训是一件光彩的事，千万不要搞错了！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、培训班防骗三十六计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在太多的培训机构，一个个把自己吹的天花乱坠，我也建议过小伙伴去培训，但小孩子交完钱培训一个月就退费了，深感自己好心做了坏事，这里建议大家培训市场，鱼龙混杂，一定要提前做好防骗准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谎言之所以真实是因为年青的心太不甘寂寞，太急于求成！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从网上找了，培训班防骗三十六计，供大家参考：&lt;/p&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;“借刀杀人”：&lt;/strong&gt;培训班间竞争激烈，彼此勾心斗角，正好为我所用。去培训班甲问乙如何，到培训班乙打听甲。Ha.Ha..，狗咬狗开始了，一时间内幕迭报：乙设备不全，很多实验不能做；甲的那个号称CCIE的老师只过了笔试，没过实验室，假的！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;“声东击西”：&lt;/strong&gt;与甲约好星期六考察学校，结果星期Ｘ跑去(１=&amp;lt; X &amp;lt;= 5)。&lt;br/&gt;　　“你怎么来了？”&lt;br/&gt;　　“我星期六有事，所以提前来看看……”&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;“抛砖引玉”：&lt;/strong&gt;有时候，拿不定注意或者培训班在外地，实地考察有难度，何不到论坛发个帖子征求意见，要是能得到已经培训过的前辈的释疑，那你绝对是不虚此帖了！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;“假痴不癫”：&lt;/strong&gt;有时候你可能偶然拥有一些内幕消息，不如试试他们的诚实度。&lt;br/&gt;　　“听说你们的教师是CCIE！”&lt;br/&gt;　　“那当然，技术首屈一指，……”&lt;br/&gt;　　此时此刻，看着乙那得意样样的小样，不知是好笑，还是可气。不过记住：一个没有诚信的公司是什么都干的出来的！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;“反间计”：&lt;/strong&gt;一个卑鄙的培训班后面一般都有一个卑鄙的流氓大亨，他不仅千方百计的从学员那里榨取钱财，对自己的手下也不会心慈手软，本着人们内部矛盾的原则发展一个或多个间谍。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;“走为上计”：&lt;/strong&gt;经过一番打探，知道他们都不是东西，还犹豫什么？宁缺毋滥，走人！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最后，如论怎么选，自终也只是入门阶段，为了找到一份工作。对于初入职场的你们，给一条最终建议：学校不行靠实力，实力不行靠态度。记得帮我点赞哦。&lt;br/&gt;关注公众号【启舰杂谈】回复『Android』、『java』、『ReactNative』、『H5』、『javaweb』、『面试』、『机器学习』、『web前端』、『设计模式』、『考研』、『产品经理』、『运营』等关键字获取对应资料，共2184G，涉及43个开发方向，入门/进阶/实战都有，一千多册电子书和九百多套视频教程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;公众号【启舰杂谈】，作者启舰，出过书、创过业，呆过阿里、现在VIVO，啥都会点的安卓开发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82625140&quot;&gt;启舰：全网2184G计算机各方向视频教程/电子书汇总（持续更新中）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90965179&quot;&gt;452G计算机考研初试/复试资料汇总（初试辅导视频+各大高校复试资料，全免费！！！）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;爆文推荐&quot;&gt;爆文推荐：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91535354&quot;&gt;启舰：计算机考研，这样选学校才是正解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90396934&quot;&gt;启舰：计算机专业有必要考研吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/87648096&quot;&gt;启舰：在中国程序员是青春饭吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/86227216&quot;&gt;启舰：如何在计算机面试中牵着面试官鼻子走？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/85861940&quot;&gt;启舰：有哪些让程序员受益终生的建议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/93527421&quot;&gt;启舰：你是怎么变自律的？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;更多启舰原创文章&quot;&gt;更多启舰原创文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/98002434&quot;&gt;启舰精品文章列表&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;资源下载&quot;&gt;资源下载：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82625140&quot;&gt;启舰：全网2184G计算机各方向视频教程/电子书汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90965179&quot;&gt;启舰：452G计算机考研初试/复试资料汇总（初试辅导视频+各大高校复试资料，全免费！！！）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83835790&quot;&gt;启舰：最新！2016-2019计算机历年校招真题、面经、复习资料总结（11G/2284份文件）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/693404/202001/693404-20200104072452515-514901086.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jan 2020 23:25:00 +0000</pubDate>
<dc:creator>启舰杂谈</dc:creator>
<og:description>前言：生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。 ——莫泊桑 在校生要找到好工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/harvic880925/p/12147896.html</dc:identifier>
</item>
<item>
<title>【一起学源码-微服务】Nexflix Eureka 源码十三：Eureka源码解读完结撒花篇~！ - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12147889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12147889.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;h4 id=&quot;想说的话&quot;&gt;想说的话&lt;/h4&gt;
&lt;p&gt;【一起学源码-微服务-Netflix Eureka】专栏到这里就已经全部结束了。&lt;/p&gt;
&lt;p&gt;实话实说，从最开始Eureka Server和Eureka Client初始化的流程还是一脸闷逼，到现在Eureka各种操作都了然于心了。&lt;/p&gt;
&lt;p&gt;本专栏从12.17开始写，一直到今天12.30(文章在平台是延后发布的)，这将近半个月的时间确实收获很多。每天都会保持一定的时间学习，只要肯下功夫，没有学不会的东西。&lt;/p&gt;
&lt;p&gt;2020年将继续保持学习的节奏，自己定的目标是把spring cloud几个重要的组件都学一遍，然后是分布式架构的几个常用组件，例如分布式事务、分布式锁、Netty等。&lt;/p&gt;
&lt;p&gt;希望自己能够坚持下去吧，放弃不难，但坚持一定很酷。&lt;/p&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;原创不易，如若转载 请标明来源！&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;一枝花算不算浪漫&lt;/a&gt;&lt;br/&gt;微信公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;首先看一下整体的Eureka架构图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200104063201630-143273808.png&quot; alt=&quot;13_Eureka整体架构设计.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结的思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200104063205750-263272955.png&quot; alt=&quot;思维导图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Eureka Rest operation:&lt;br/&gt;更多可以查看：&lt;a href=&quot;https://github.com/Netflix/eureka/wiki/Eureka-REST-operations&quot; class=&quot;uri&quot;&gt;https://github.com/Netflix/eureka/wiki/Eureka-REST-operations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200104063207039-2132787860.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附录几个对spring cloud netflix eureka分析比较好的博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/rickiyang/p/11802413.html&quot;&gt;Spring Cloud Eureka源码分析---服务注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/rickiyang/p/11802434.html&quot;&gt;Spring Cloud Eureka源码分析 --- client 注册流程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/rickiyang/p/11802441.html&quot;&gt;Spring Cloud Eureka配置文件详解&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一起学源码-微服务-netflix-eureka文章链接&quot;&gt;【一起学源码-微服务-Netflix Eureka】文章链接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12081910.html&quot;&gt;【一起学源码-微服务】Netflix Eureka 源码一：Netflix Eureka 源码初探，我们为什么要读源码？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12089911.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码二：EurekaServer启动之配置文件加载以及面向接口的配置项读取&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12095165.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码三：EurekaServer启动之EurekaServer上下文EurekaClient创建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12100532.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码四：EurekaServer启动之完成上下文构建及EurekaServer总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12106321.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码五：EurekaClient启动要经历哪些艰难险阻？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12111342.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码六：在眼花缭乱的代码中，EurekaClient是如何注册的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12116408.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码七：通过单元测试来Debug Eureka注册过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12118203.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码八：EurekaClient注册表抓取 精妙设计分析！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12122968.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码九：服务续约源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12128368.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码十：服务下线及实例摘除，一个client下线到底多久才会被其他实例感知？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12131465.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码十一：EurekaServer自我保护机制竟然有这么多Bug？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12143004.html&quot;&gt;【一起学源码-微服务】Nexflix Eureka 源码十二：EurekaServer集群模式源码分析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;申明&quot;&gt;申明&lt;/h3&gt;
&lt;p&gt;本文章首发自本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;https://www.cnblogs.com/wang-meng&lt;/a&gt; 和公众号：&lt;strong&gt;壹枝花算不算浪漫&lt;/strong&gt;，如若转载请标明来源!&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200104063207411-573069738.jpg&quot; alt=&quot;22.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jan 2020 22:32:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 想说的话 【一起学源码 微服务 Netflix Eureka】专栏到这里就已经全部结束了。 实话实说，从最开始Eureka Server和Eureka Client初始化的流程还是一脸闷逼，到现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12147889.html</dc:identifier>
</item>
<item>
<title>[译文] 应用领域驱动设计, 第〇章 - 需求和建模 - 心千</title>
<link>http://www.cnblogs.com/xixixiao/p/applied-domain-driven-design-ddd-part-0.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xixixiao/p/applied-domain-driven-design-ddd-part-0.html</guid>
<description>&lt;p&gt;原文: &lt;a href=&quot;http://www.zankavtaskin.com/2014/12/applied-domain-driven-design-ddd-part-0.html&quot;&gt;Applied Domain-Driven Design (DDD), Part 0 - Requirements and Modelling&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.4962962962963&quot;&gt;
&lt;p&gt;About a year ago I have written a series of articles about Domain-driven design, you can find the &lt;a href=&quot;http://www.zankavtaskin.com/2013/09/applied-domain-driven-design-ddd-part-1.html&quot;&gt;main article here&lt;/a&gt;. Looking back I've realised that I've committed the most typical mistake and started to code my business domain without requirements or any draft designs!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大约在一年前 (本文作者写于 2014 年 12 月), 我写过一系列有关领域驱动设计的文章 (这个系列将陆续翻译出), 你可以在这里找到它的&lt;a href=&quot;http://www.zankavtaskin.com/2013/09/applied-domain-driven-design-ddd-part-1.html&quot;&gt;开篇章节&lt;/a&gt;. 回顾过去, 我意识到自己犯了最典型的错误, 最开始, 在没有需求设计和任何设计草案的情况下, 就对我的业务领域开始写代码了!&lt;/p&gt;
&lt;h2 id=&quot;为此-我打算尝试修复这个问题-以下是我准备要做的-i-am-going-to-try-and-fix-this-this-is-what-i-am-going-to-do&quot;&gt;为此, 我打算尝试修复这个问题, 以下是我准备要做的 (I am going to try and fix this, this is what I am going to do)&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;识别用户故事 (Identify User Stories)&lt;/li&gt;
&lt;li&gt;识别用户故事的名词 (Identify the Nouns in the user stories)&lt;/li&gt;
&lt;li&gt;识别用户故事的动词 (Identify the Verbs in the user stories)&lt;/li&gt;
&lt;li&gt;组合对象交互关系图 (Put together object interaction diagram)&lt;/li&gt;
&lt;li&gt;组合对象职责关系图 (Put together object responsibilities diagram)&lt;/li&gt;
&lt;li&gt;组合类的 UML 图, &lt;em&gt;仅仅显示有趣的交互&lt;/em&gt;. (Put together class digram UML &lt;em&gt;showing only interesting interactions&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;这是我虚构的一些用户故事-so-here-are-made-up-user-stories&quot;&gt;这是我虚构的一些用户故事 (So here are made up user stories)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to be able to put products that I want to purchase in to the shopping cart so that I can check out quickly later on&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望能够将想要购买的产品放进购物车, 以便以后可以快速结账.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to see the total cost all for all of the items that are in my cart so that I see if I can afford to buy everything&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望知道购物车里 &lt;strong&gt;所有&lt;/strong&gt; 商品的总费用, 以便知道是否有能力购买所有的商品.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to see the total cost of each item in the shopping cart so that I can re-check the price for items&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望知道购物车里 &lt;strong&gt;每件&lt;/strong&gt; 商品的总费用, 以便我重新检查商品的价格.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to see the total cost for all of the items in the shopping cart with total tax&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望看见购物车里所有商品的总费用和总税额.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to be able to specify the address of where all of the products are going to be sent to&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望能够指定所有商品将要发货的收货地址.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to be able to add a note to the delivery address so that I can provide special instructions to the postman&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望能够为交付地址添加备注, 以便于我能提给邮递员供特殊说明.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to be able to specify my credit card information during check out so that I can pay for the items&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望能够在结账的时候指定我的信用卡资料, 以便于我可以支付商品.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want system to tell me how many items are in stock so that I know how many items I can purchase&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望系统能够告诉我库存数量, 这样我就知道可以购买多少个商品了.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want shopping cart to check that items are still available for purchase during a check out so that I can still purchase items that are in the cart&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望购物车能够在结账时检查商品是否仍旧可以购买, 以便我仍然购买购物车里的商品了.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to receive order confirmation email with order number so that I have proof of purchase&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望能够接收到带有带单号的订单确认邮件, 以便于我获得购物证明.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;As a customer I want to specify invoice address for the order so that I can receive invoice for the order&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作为客户, 我希望能够指定订单的发票地址, 便于我能接收到订单的发票.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Now I am going extract nouns and verbs from the stories above. I am looking for the nouns that will become my main objects and not the attributes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在, 我将开始从上述故事中提取名字和动词了. 我在寻找那些将成为主要对象非是属性的名词.&lt;/p&gt;
&lt;h2 id=&quot;名词-nouns&quot;&gt;名词 (Nouns)&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;客户 (Customer)&lt;/li&gt;
&lt;li&gt;商品 (Item)&lt;/li&gt;
&lt;li&gt;订单 (Order)&lt;/li&gt;
&lt;li&gt;购物车 (Shopping Cart)&lt;/li&gt;
&lt;li&gt;收货地址 (Address)&lt;/li&gt;
&lt;li&gt;发货单 (Invoice)&lt;/li&gt;
&lt;li&gt;交付 (Delivery)&lt;/li&gt;
&lt;li&gt;税费 (Tax)&lt;/li&gt;
&lt;li&gt;信用卡资料 (Credit Card Information)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;*Note: I've removed duplicates for better, more official names, for example Item = Product, Order = Purchase, etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*注意: 为了更好, 更正式的名称; 我把重复的名词已经删除了, 比如 商品 (Item) = 产品 (Product), 订单 (Order) = 采购 (Purchase), 等等.&lt;/p&gt;
&lt;h2 id=&quot;动词-verbs&quot;&gt;动词 (Verbs)&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;将产品添加到购物车. (Put products in to the shopping cart)&lt;/li&gt;
&lt;li&gt;查看所有商品的总费用. (See total cost for all of the items)&lt;/li&gt;
&lt;li&gt;查看每个商品的总费用. (See total cost for each item)&lt;/li&gt;
&lt;li&gt;查看在自己国家的总税金. (See total tax for my country)&lt;/li&gt;
&lt;li&gt;设定交付地址. (Specify delivery address)&lt;/li&gt;
&lt;li&gt;为送货地址添加发货单. (Specify delivery note for delivery address)&lt;/li&gt;
&lt;li&gt;设定发票地址. (Specify invoice address)&lt;/li&gt;
&lt;li&gt;接收订单的发票. (Receive invoice for the order)&lt;/li&gt;
&lt;li&gt;发送发票. (Sent invoice)&lt;/li&gt;
&lt;li&gt;设定信用卡资料. (Specify credit card information)&lt;/li&gt;
&lt;li&gt;为商品付款. (Pay for the items)&lt;/li&gt;
&lt;li&gt;告诉我商品有多少商品. (Tell me how many items are in stock)&lt;/li&gt;
&lt;li&gt;在结账的时候检查商品是否可用. (Check that items are still available during check out)&lt;/li&gt;
&lt;li&gt;接收订单的确认邮件. (Receive order confirmation email)d&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;By using above nouns and verbs we can put together a diagram such as this:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过使用以上的名词和动词, 我们能够组合出像下面这样的一个关系图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714921/202001/1714921-20200104030809166-667424528.jpg&quot; alt=&quot;(Figure 1) Object Interaction Diagram&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图一: 对象交互图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Once we have object interaction diagram we can start thinking about object responsibilities. One of the most common mistakes is to push responsibilities on to the actor object i.e. Customer. We need to remember that objects must take care of themselves and objects need to be closed for direct communication and that you need go through the functions to communicate with them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一旦我们有了对象交互关系图, 我们就能够开始思考对象职责了. 最常见的错误之一是将职责推给参与者即客户. 我们应该牢记, 对象必须自己照顾自己, 对象需要对直接通信进行封闭, 而是通过函数与他们通信.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;So let's follow above approach and assign responsibilities:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们遵循上面的方式来分配职责:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714921/202001/1714921-20200104030831285-585869031.jpg&quot; alt=&quot;(Figure 2) Object Responsibilities Diagram&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图二 对象职责图&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Now that we have object interaction and responsibilities diagram in place we can start thinking about lower level UML class diagram:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在已经有了对象交互图和职责图, 我们可以开始考虑更低级别的 UML 类图了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714921/202001/1714921-20200104030856539-1731927368.jpg&quot; alt=&quot;(Figure 3) UML Diagram&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图三&lt;/em&gt; UML 类图&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;Figure 3 shows methods, class names, dependencies, interfaces and composition. I've took a bit of time and reflected only on the most complex / interesting parts of the model. I will worry about attributes and other details later on, detail will naturally emerge when I start coding. Figure 3 is suppose to be a rough sketch, that is all, teams can whiteboard Figure 3 during a meeting, take a picture and distribute it to everyone in the team and get on with the actual coding. After a week or so picture will be forgotten and the parts of the above model (that have been useful) will live and breath in the actual code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;图三展示了方法, 类名, 依赖项, 接口和组合. 我花了一些时间, 只考虑了模型中最复杂最有趣的部分. 稍后我将考虑属性和其它细节. 当我开始编码时, 细节会自然而然地浮现. 假设图三是个粗略的草图, 也就是说, 团队可以在会议期间, 在白板上画出图三, 拍照并分发给团队中的每个人, 然后开始实际编码. 大约一周后, 图片就会被遗忘, 并且上面模型的部分 (有用的部分) 就会在实际的代码中起到作用.&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Now my made up user stories can be modelled in my many different ways and Figure 3 is just my interpretation of it. Key thing is to think about what you are building first, don't just jump in and start coding and don't get carried away with detail either (attributes, constructors, etc) &lt;em&gt;focus on interesting and complex parts first&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在, 我可以用多种不同的方式对虚构的用户故事进行建模, 图三就是我对它的解释. 事情的关键是, 首先你要思考将要构建什么, 不要一头扎进去就开始写代码, 更不要被属性, 构造方法等细节所迷惑, &lt;strong&gt;先关注复杂且有趣的部分&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;总结-summary&quot;&gt;总结 (Summary)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Don't start doing anything until you have requirements, if you don't have a BA in the company that's fine, you will have to do BA's job and identify requirements first.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在有需求之前, 不要开始做任何事. 如果你在公司不是 BA (Business Analyst) 也没关系, 你先做好 BA 的工作, 再明确需求.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Don't just jump in to the code soon as you have requirements, put together object interaction and responsibilities diagrams first.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;切勿一有需求就直接扎进代码里, 先把对象交互和职责图放在一起.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;When you have identified your objects, interactions and responsibilities use UML class diagrams to put together a draft model (whiteboard sketch will do).&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;当你已经确定了你的对象, 交互和职责; 就可以使用 UML 类图来组合一个模型草稿(白板草图就可以了)。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Don't try to model the reality of the world, model the reality of your organisation. Different companies will have different objects, in one company &quot;address&quot; might be an object and you might have &quot;address type&quot; coming of it (invoice, shipping, etc), in another company there will be &quot;invoice address&quot;, &quot;shipping address&quot; and &quot;seller address&quot; object, that company might need these objects as these objects will inherit from the base &quot;address&quot; object. &lt;em&gt;Remember it is all about your business domain and not the actual &quot;reality&quot;&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;不要试图模拟现实世界, 而是要根据组织去建模. 不同的公司具有不同的对象, 一家公司 &quot;地址&quot; 可能是一个对象, 而你可能会有 &quot;地址类型&quot; (发票, 运费等). 在另一个公司会有 &quot;发票地址&quot;, &quot;送货地址&quot; 和 &quot;卖方地址&quot; 对象, 此公司可能需要这些对象, 因为这些对象将从基本的 &quot;地址&quot; 对象继承, &lt;strong&gt;请记住, 这全都与业务领域有关, 而不是实际的 &quot;现实&quot;&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一些有用链接-useful-links&quot;&gt;一些有用链接 (Useful links)&lt;/h2&gt;
&lt;h2 id=&quot;备注&quot;&gt;备注&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[1] BA, 业务分析师. 在 IT 公司里, BA 的角色就是PM (产品经理), 叫 BA 是因为这类 PM 要承接某个很具体的业务或者领域.&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 03 Jan 2020 19:12:00 +0000</pubDate>
<dc:creator>心千</dc:creator>
<og:description>大约在一年前 (本文作者写于 2014 年 12 月), 我写过一系列有关领域驱动设计的文章 (这个系列将陆续翻译出), 你可以在这里找到它的开篇章节. 回顾过去, 我意识到自己犯了最典型的错误, 最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xixixiao/p/applied-domain-driven-design-ddd-part-0.html</dc:identifier>
</item>
<item>
<title>Java入门(三)——集合概讲 - 奔跑的瓜牛</title>
<link>http://www.cnblogs.com/chenwenhao/p/12147862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenwenhao/p/12147862.html</guid>
<description>&lt;p&gt;集合（或者叫容器）是Java的核心知识点，它有着很深的深度。我们这里不会设计多深，仅仅作为了解入门，深入了解请移步各种集合源码文章。好的，下面正是开始介绍...&lt;/p&gt;
&lt;h3 id=&quot;java集合为何而生&quot;&gt;Java集合为何而生&lt;/h3&gt;
&lt;p&gt;我们知道，Java是一门面向对象编程语言，这也就意味着程序中存在着大量的对象。这个时候问题就来了，我们如何很好的存放和操作对象呢？如果你能明白这个问题，那么你就知道了“集合为何而生”这个问题的答案。&lt;/p&gt;
&lt;p&gt;总结一句： &lt;strong&gt;Java给我们提供了工具（集合）方便我们去存放和操作多个Java对象&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;java集合入门学习&quot;&gt;Java集合入门学习&lt;/h3&gt;
&lt;p&gt;Java集合的目的是方便操作多个对象，同时，它提供一系列的API来供我们操作。因此，在初学Java集合的时候我们更多的是&lt;strong&gt;学习这些API的用法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对Java集合的API使用有一定了解之后，我们就应该从&lt;strong&gt;面向对象&lt;/strong&gt;的角度去理解它。为什么会抽象出多个接口，以及每个接口有什么特征。&lt;/p&gt;
&lt;p&gt;我们可以总结出几个常用的实现类，这几个常用的实现类我们必须知道它的数据结构是什么，什么时候使用这个类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwh2407606301/picBed/master/img/Collection.png&quot; alt=&quot;从面向对象去理解&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时，你还需要学习和了解数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/cwh2407606301/picBed/blob/master/img/shujujiegou.png?raw=true&quot; alt=&quot;数据结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;学完上面的内容后，我们基本掌握了常用集合的数据结构，也就知道了如何选择合适的集合容器去存储我们的对象。总之，&lt;strong&gt;学完常见实现类的数据结构之后，对它们的使用场景也有了更加清晰的认识&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;java集合类简介&quot;&gt;Java集合类简介&lt;/h3&gt;
&lt;p&gt;Java集合是一个很庞大的知识点，话不多说，上图感受下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwh2407606301/picBed/master/img/2243690-9cd9c896e0d512ed.png&quot; alt=&quot;Java集合&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Java集合的&lt;strong&gt;根接口是Collection&lt;/strong&gt;，它又继承了迭代接口Iterable&lt;/li&gt;
&lt;li&gt;List接口和Set接口继承了Collection接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map接口是独立的接口，并没有继承Collection接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;List接口常用的实现类有：ArrayList、LinkedList、Vector&lt;/li&gt;
&lt;li&gt;Set接口常用的实现类有：HashSet、LinkedHashSet、TreeSet&lt;/li&gt;
&lt;li&gt;Map接口常用的实现类有：HashMap、HashTable、TreeMap&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Java容器可分为两大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Collection
&lt;ul&gt;&lt;li&gt;List
&lt;ul&gt;&lt;li&gt;ArrayList&lt;/li&gt;
&lt;li&gt;LinkedList&lt;/li&gt;
&lt;li&gt;Vector(了解，已过时)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Set
&lt;ul&gt;&lt;li&gt;HashSet
&lt;ul&gt;&lt;li&gt;LinkedHashSet&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TreeSet&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Map
&lt;ul&gt;&lt;li&gt;HashMap
&lt;ul&gt;&lt;li&gt;LinkedHashMap&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TreeMap&lt;/li&gt;
&lt;li&gt;ConcurrentHashMap&lt;/li&gt;
&lt;li&gt;Hashtable(了解，，已过时)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;iterator迭代器&quot;&gt;Iterator迭代器&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以发现一个特点，上述所有的集合类，除了Map系列的集合，Collection集合都实现了Iterator接口。我们可以在源码中追溯到集合的顶层接口，比如Collection接口，可以看到它继承的是类Iterable。&lt;/p&gt;
&lt;p&gt;它是Java集合的顶层接口（不包括Map系列的集合，Map接口是Map系列集合的顶层接口）&lt;/p&gt;
&lt;p&gt;所以除了Map系列的集合，我么都能通过迭代器来对集合中的元素进行遍历。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Map集合的子类可以用keyset()方法转换成Set集合遍历&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Iterable迭代器一共4个方法：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;hasNext()：判断下个迭代器是否还有下一个元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;next()：返回下一个元素的值，并且把自身offset移动下一位&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;remove()：这个可以删除用这个迭代器集合中的元素（注意如果删除之后还是前面获得的迭代器，你会发现原来的迭代器还是没变，得重新获得删除元素之后的迭代器）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;forEachRemaining：1.8的新方法 可以直接遍历迭代器剩下的元素，如果从最开始的话就是遍历所有的迭代器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;补充： 还有一个ListIterator接口，它继承了Iterator接口，但只能用于List集合。它是Iterator接口的升级版，里面除了Iterator含有的功能外，还具有一些其他的功能。Iterator遍历集合元素时，只能单向遍历，而ListIterator可以&lt;strong&gt;双向进行遍历、添加元素、设置元素&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当使用Iterator对集合元素进行迭代时，&lt;strong&gt;Iterator并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量&lt;/strong&gt;（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量），所以修改迭代变量的值对集合元素本身没有任何影响。&lt;br/&gt;下面的程序演示了这一点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class IteratorExample {
    public static void main(String[] args){
        List&amp;lt;String&amp;gt; list =Arrays.asList(&quot;java语言&quot;,&quot;C语言&quot;,&quot;C++语言&quot;);
        Iterator&amp;lt;String&amp;gt; iterator = list.iterator();
        while(iterator.hasNext()){
            String next = iterator.next();//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址
            next =&quot;修改后的&quot;;
            System.out.println(next);
        }
        System.out.println(list);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;修改后的
修改后的
修改后的
[java语言, C语言, C++语言]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;collection接口&quot;&gt;Collection接口&lt;/h4&gt;
&lt;p&gt;Collection的作用就是规定了一个集合有哪些基本的操作。 这里主要是插入数据，清空数据，是否包含，是否相等，集合里的数据个数和转化成熟组这几种操作。&lt;/p&gt;
&lt;p&gt;接口中定义的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwh2407606301/picBed/master/img/20200104021841.png&quot; alt=&quot;Collection接口方法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Collection接口是Set、List、Queue的父接口。下面逐一介绍：&lt;/p&gt;
&lt;h4 id=&quot;set集合&quot;&gt;Set集合&lt;/h4&gt;
&lt;p&gt;Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。&lt;br/&gt;&lt;strong&gt;Set集合不允许包含相同的元素&lt;/strong&gt;，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。&lt;/p&gt;
&lt;h4 id=&quot;list集合&quot;&gt;List集合&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;List集合代表一个元素有序、可重复的集合&lt;/strong&gt;，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为0，第二个添加的元素索引为1......&lt;br/&gt;List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;void add(int index, Object element):&lt;/strong&gt; 在列表的指定位置插入指定元素（可选操作）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;boolean addAll(int index, Collection c) :&lt;/strong&gt; 将集合c 中的所有元素都插入到列表中的指定位置index处&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object get(index):&lt;/strong&gt;返回列表中指定位置的元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int indexOf(Object o):&lt;/strong&gt; 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int lastIndexOf(Object o):&lt;/strong&gt;返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object remove(int index):&lt;/strong&gt; 移除列表中指定位置的元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object set(int index, Object element):&lt;/strong&gt;用指定元素替换列表中指定位置的元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;List subList(int fromIndex, int toIndex):&lt;/strong&gt; 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object[] toArray():&lt;/strong&gt; 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，Java 8还为List接口添加了如下两个默认方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;void replaceAll(UnaryOperator operator):&lt;/strong&gt;根据operator指定的计算规则重新设置List集合的所有元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;void sort(Comparator c):&lt;/strong&gt;根据Comparator参数对List集合的元素排序&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;queue集合&quot;&gt;Queue集合&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Queue用户模拟队列这种数据结构&lt;/strong&gt;，队列通常是指“&lt;strong&gt;先进先出&lt;/strong&gt;”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。&lt;/p&gt;
&lt;p&gt;接口中定义的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwh2407606301/picBed/master/img/20200104022716.png&quot; alt=&quot;Queue接口方法&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;map集合&quot;&gt;Map集合&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Map用户保存具有映射关系的数据&lt;/strong&gt;，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。&lt;strong&gt;Map的key不允许重复&lt;/strong&gt;，即同一个Map对象的任何两个key通过equals方法比较总是返回false。&lt;br/&gt;如下图所描述，key和value之间存在单向一对一关系，即通过指定的key,总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwh2407606301/picBed/master/img/20200104015649.png&quot; alt=&quot;Map模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Map集合包括Map接口以及Map接口的所有实现类。Map集合具有以下特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Map接口并没有继承Collection接口&lt;/strong&gt;，提供的是key到value的映射&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map中不能包含相同的key&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Map接口常用的实现类有：HashMap、HashTable、TreeMap。&lt;/p&gt;
&lt;p&gt;我们先看下如下示例了解下Map集合的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package collection;

import java.util.*;

public class Muster {
    public static void main(String[] args) {
        Map&amp;lt;Integer, String&amp;gt; platformMap = new HashMap&amp;lt;&amp;gt;();
        platformMap.put(1, &quot;博客园&quot;);
        platformMap.put(2, &quot;掘金&quot;);
        platformMap.put(3, &quot;微信公众号&quot;);
        platformMap.put(4, &quot;个人博客&quot;);

        // 尝试添加重复Map
        platformMap.put(4, &quot;个人博客&quot;);

        // 获取所有的key
        Set&amp;lt;Integer&amp;gt; keys = platformMap.keySet();
        for (Integer integer : keys) {
            System.out.println(&quot;Key:&quot; + integer + &quot;,Value:&quot; + platformMap.get(integer));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码的输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Key:1,Value:博客园
Key:2,Value:掘金
Key:3,Value:微信公众号
Key:4,Value:个人博客&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志可以看出，当我们尝试重加重复Map时，并没有添加成功。&lt;/p&gt;
&lt;p&gt;关于Map集合的详细用法，HashMap、HashTable、TreeMap的区别（这里是重点，面试可能问的比较多，这里不展开说明）&lt;/p&gt;
&lt;h5 id=&quot;map集合与set集合list集合的关系&quot;&gt;Map集合与Set集合、List集合的关系&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 与Set集合的关系&lt;/strong&gt;&lt;br/&gt;如果把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个&lt;code&gt;keySet()&lt;/code&gt;方法，用户返回Map里所有key组成的Set集合。&lt;br/&gt;&lt;strong&gt;2. 与List集合的关系&lt;/strong&gt;&lt;br/&gt;如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。&lt;/p&gt;
&lt;p&gt;接口中定义的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwh2407606301/picBed/master/img/20200104020122.png&quot; alt=&quot;Map接口方法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwh2407606301/picBed/master/img/20200104020243.png&quot; alt=&quot;Entry方法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Map集合最典型的用法就是成对地添加、删除key-value对，然后就是判断该Map中是否包含指定key，是否包含指定value，也可以通过Map提供的&lt;code&gt;keySet()&lt;/code&gt;方法获取所有key组成的集合，然后使用&lt;code&gt;foreach&lt;/code&gt;循环来遍历Map的所有key，根据key即可遍历所有的value。下面程序代码示范Map的一些基本功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MapTest {
    public static void main(String[] args){
        Day day1 = new Day(1, 2, 3);
        Day day2 = new Day(2, 3, 4);
        Map&amp;lt;String,Day&amp;gt; map = new HashMap&amp;lt;String,Day&amp;gt;();
        //成对放入key-value对
        map.put(&quot;第一个&quot;, day1);
        map.put(&quot;第二个&quot;, day2);
        //判断是否包含指定的key
        System.out.println(map.containsKey(&quot;第一个&quot;));
        //判断是否包含指定的value
        System.out.println(map.containsValue(day1));
        //循环遍历
        //1.获得Map中所有key组成的set集合
        Set&amp;lt;String&amp;gt; keySet = map.keySet();
        //2.使用foreach进行遍历
        for (String key : keySet) {
            //根据key获得指定的value
            System.out.println(map.get(key));
        }
        //根据key来移除key-value对
        map.remove(&quot;第一个&quot;);
        System.out.println(map);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true
true
Day [hour=2, minute=3, second=4]
Day [hour=1, minute=2, second=3]
{第二个=Day [hour=2, minute=3, second=4]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5de8958f518825127b61a1ea&quot;&gt;【新手向】如何学习Java集合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zhangqunshuai/article/details/80660974&quot;&gt;Java集合中List,Set以及Map等集合体系详解(史上最全)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/entry/59055078b123db3ee47c6281&quot;&gt;由浅入深理解 java 集合——集合框架 Collction、Map&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jan 2020 19:00:00 +0000</pubDate>
<dc:creator>奔跑的瓜牛</dc:creator>
<og:description>集合（或者叫容器）是Java的核心知识点，它有着很深的深度。我们这里不会设计多深，仅仅作为了解入门，深入了解请移步各种集合源码文章。好的，下面正是开始介绍... Java集合为何而生 我们知道，Jav</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenwenhao/p/12147862.html</dc:identifier>
</item>
<item>
<title>Java学习网站推荐 - 我是阿喵酱</title>
<link>http://www.cnblogs.com/amiaojiang/p/12147737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amiaojiang/p/12147737.html</guid>
<description>[unable to retrieve full-text content]1. &quot;HOW2J&quot; 2. &quot;慕课网&quot; 3. &quot;MOOC&quot; 4. &quot;学堂在线&quot; 5. &quot;华文慕课&quot; 6. &quot;优达学城&quot; 7. &quot;博学谷&quot; 8. &quot;计蒜客&quot; 9. &quot;黑马&quot; 10. &quot;千峰&quot; 11. &quot;尚学堂&quot; 12. &quot;速学堂&quot; 13. &quot;尚硅谷&quot; 14. &quot;动力节点&quot; 15. &quot;网易云课堂&quot; 16</description>
<pubDate>Fri, 03 Jan 2020 17:21:00 +0000</pubDate>
<dc:creator>我是阿喵酱</dc:creator>
<og:description>Java开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/amiaojiang/p/12147737.html</dc:identifier>
</item>
<item>
<title>【程序人生】2018与2019年终总结——悟已往之不谏，知来者之可追 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/12147716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/12147716.html</guid>
<description>&lt;p&gt;       春秋代序、寒暑易节，眨眼间就到了年终了。而年终又是一个总结的时节，也是给来年做计划的时节。这里，我也趁这个时机，给过往做一个总结吧。&lt;/p&gt;
&lt;p&gt;       实际上我本应该在元旦前夕来做总结的，这样似乎更有仪式感些，元旦那几天我又正好回老家看儿子，琐事很多，也没有条件写，就拖到今天了。以后要写这种年度总结，会尽量放在元旦或者元旦前，这里先立一个flag。&lt;/p&gt;
&lt;p&gt;       其实，这是第一次写年终总结，一方面是看了不少博客大佬每年都会做总结，记录这一年做了些什么，来年有什么样的计划，井井有条，这无形当中在鞭策着我。另外一方面，深感时间过得很快，很多事情过去就过去了，应该写点什么，让这些发生的重要事情留下一些轨迹，同时对未来多一些计划，这样或许能让生活更充实一些。&lt;/p&gt;
&lt;p&gt;      我的2018年和2019年更像是一个整体，所以我打算主要从2018年年初开始写起，也不讲究什么写作技巧了，就记一记流水账，记录一些稍微重要的事情，以及个人的感想，然后对明年最一些初步的计划。&lt;/p&gt;
&lt;p&gt;       2018年春节，结婚了，娶了一位漂亮的老婆。这时整好30岁整，从此开启了一段新的人生。&lt;/p&gt;
&lt;p&gt;       二月底到3月初，上了不到半个月的班，公司开始裁员了。其实年前就陆陆续续分批开始裁了，这个时候裁员，也是意料中的事情，这一批裁掉了90%的员工，几百人的研发团队，每个业务也就留了一两个人（一个月后，这些留下的人也给裁了）。公司说按照法定要求赔偿，所以很顺利签字离职了。没想到，后来这家公司食言了，连哄带骗把员工骗走后，一直拖欠部分工资及赔偿金不给。这是一家上市公司，刚上市的时候，股票被很多证券股票公司看好，股价一度大幅上涨。我2017年初进的这家公司，当时董事长身价200多亿。尽管深圳有钱人多，但200多亿也绝对算得上大富豪了。但2017年公司陡转直下，下半年股票连续跌停，已经破了A股跌停的吉尼斯纪录了，外界称它为第二个乐视。公司经过各种折腾，回天乏术，董事长跑路了，卷走77亿去了国外。然后就有了这一波接着一波的裁员，公司口口声称承认欠我们的钱，但就是不给钱。我们几百人到公司示威过，到深圳市政府办公楼拉横幅过，在深南大道游行过，在信访局跟市领导长谈过，到法院仲裁过，被大批经常围堵过，被大巴警车遣送过......这持续了2018年这一年时间，仍然没有结果，这2019年都结束了，也一样没有结果。一家上市公司赖皮到这个地步，事情闹得这么大，政府都拿它没办法（或者政府就是在保它），第一次深切体会到这水有多深，我等小屁民是何等的渺小。这一笔，我损失了5万6千元，我还算顺利，拖欠10万以上的大有人在，更有甚者当初被董事长忽悠贷款或者抵押房子买了公司股票，在那里工作几年后，负载累累......其实我很想单独写一篇文章来记录这件事，一方面想提醒广大网友在职场要小心，避免踩坑，另一方面也想提醒自己以后要多学会保护自己。&lt;/p&gt;
&lt;p&gt;      三月中旬，顺利考完科目三和科目四，拿到了驾照。说实话，深圳考驾照比其它小地方要难一些，也严格一些。我和我老婆同时报名，报的VP班，一个教练就带我俩，报名费花了14000RMB。所幸都一次考过了，比较顺利。后来发现，在周围的众多朋友中，能凭借自己能力顺利考过的，居然寥寥无几，为此我俩还收到不少称赞。&lt;/p&gt;
&lt;p&gt;     三月底，和老婆去北京旅游了一周，算是度蜜月。凌晨到天安门广场看了升国旗，爬了长城，逛了故宫，拍了鸟巢和水立方，还有四合院、颐和园、圆明园、明十三陵、清华北大......北京真的是一座非常有历史底蕴的城市！！！&lt;/p&gt;
&lt;p&gt;     四月底，拿到了努比亚（中兴移动）的offer，以及通过了IBM的面试。IBM的面试真是够长的，3月中旬猎头找我开始面试，后来每隔一段时间来一轮面试，经过若干轮面试以及沟通后，在4月中旬HR通知我面试的所有流程都走完了，开始offer审批了，说是很快就能审批下来。很不幸，刚说走审批流程了，没几天就传来中美贸易战，美国制裁中兴的新闻。不知道是不是贸易战的原因，一直到一个月后，也就是5月，IBM才通知我，offer通过了审核，如果我接受这份工作，就安排我7月初入职！！！这流程真是让我惊呆了，不知道是贸易战的影响，还是这类公司流程本身就是这么长（不过，他们的待遇和福利确实不错）。当然，我没有去IBM，而是去了努比亚。努比亚前身就是中兴移动，没想到作为中兴系的公司，面试效率这么高。我是下午去面试的，第一轮技术面，三个面试官同时面试，面试效果不错，马上就是部长来面试，面试完差不错就是平时的下班时间，前后应该不到3个小时。面完回到家一会儿，HR就发offer给我了，谈定好薪资，并确定好入职事项。实际上IBM面试完和努比亚面试完，几乎就是前后两天而已，IBM通知我offer通过审核时，我在努比亚已经上手做事情有一段时间了，所以就直接告诉IBM的HR说不打算去了，当然有一部分原因是当时中美贸易战爆发，有点厌恶美国以及美国公司。去努比亚后也是付出了一些代价，我拿到offer后两天就看到有文章说美国制裁中兴，我预感可能会影响到入职，我也不希望继续找工作，于是跟HR说要求马上入职。所幸我反应快，提前入职了，后来我发现本该跟我同一批入职的同事，因为这个贸易战的原因，延迟了大半个月才入职。我们知道这次制裁，中兴一次被罚了14亿美元，还有股票大跌，芯片断供......一系列问题导致努比亚也损失惨重，再加上其它原因，到2019年初，本该有的年终奖基本泡汤了，季度奖也没了，这一笔我又至少损失了6万。这一次，我又深刻体会到，一次贸易战，对我这么一个小小的平民百姓，而且还只是一个小小程序员，居然产生了这么大的影响。“倾巢之下无完卵”，那些曾经我一度认为和我很遥远的事情，突然离我这么近。&lt;/p&gt;
&lt;p&gt;      五月份，在深圳把房子给买了。在深圳最中心的地带，靠近深圳大学、科技园、软件基地等各个重要地方，尽管是二手的。均价6万多，有压力，也有动力，有那么一点小成就感吧，因为在30岁的时候，能够在深圳这样的一线城市买下房子的人真的不多，而且还是在关内，还有基本上都是靠着我和老婆的努力得来的，说句不要脸的话，这事确实感觉格外的有面子！！！&lt;/p&gt;
&lt;p&gt;       六月份，我正式开始写博客了。契机就是努比亚对代码质量还是有较高要求的，很多知识尽管我用了很多年了，但总是被评审代码的同事挑出各种问题，这让我羞愧难当。于是正式开始写博客，总结并深入学习以前那些似懂非懂的技能和知识。到目前为止，陆陆续续写了80多篇了，基本上都是非常用心的。这一年多写博客的经历，个人感觉提升还是非常大的。以前基本上只关注功能的实现，而写博客的过程中，渐渐开始总结、整理、归纳和比较，同时开始深入探究机制及阅读源码。写博客的同时，梳理思路，碰到不懂的问题继续再探索，这样滚雪球似的发展下来，明显感觉做开发时已经不再向以前那样浮躁了。当然，对于写博客这件事，我也在不断地思考和定位，我写的目的主要是为了提升自己的实际开发技能，以及记录一些个人的人生经历，而不是取悦别人，更不是为了做公众号赚钱。所以，我后续写博客也应该从这点出发，而不是为了凑数而写，为了完成任而写，为了写而写。谨记：提升自己的实际开发水平，才是我写博客最根本的出发点，至少目前是！！！&lt;/p&gt;
&lt;p&gt;       七月份，紧张地加班，以及装修房子。&lt;/p&gt;
&lt;p&gt;       八月二十五日，搬进了自己的房子。从此以后，真正是有了自己的家，在深圳这个地方有了自己的一块根据地。&lt;/p&gt;
&lt;p&gt;       九月和十月，我和老婆都接了家里的人来深圳玩，我妈和我妹都是第一次来深圳。老婆她侄女、老婆、丈母娘、老婆的外婆，四世同堂一起在深圳各个景点游玩，很开心！&lt;/p&gt;
&lt;p&gt;       十二月一开始，领证一周年纪念日，去爬了南山。与此同时，老婆怀孕了！大喜！后面就是忙着做各种好吃的，好好陪老婆，照顾老婆！&lt;/p&gt;
&lt;p&gt;       春节前的这两个多月，看完了《谷园讲通鉴》最近三年的视频，个人比较喜欢看点历史。&lt;/p&gt;
&lt;p&gt;       2019年过完春节后，三四月的样子，公司来了一波裁员，整个公司裁了近一半，领导层也大换血，同时公司搞了一些恶心的制度恶心走了一些人。所幸我们研发部分裁得很少，我算是躲过了这一劫。&lt;/p&gt;
&lt;p&gt;       五月，写了10多篇专利，眼睛都快写瞎了。公司鼓励员工写专利，我通过了12篇的样子，每篇奖励800元，挣了差不多一万。&lt;/p&gt;
&lt;p&gt;       六月，公司发年终奖了，微乎其微，前面也说了，我又损失了一笔。我拿着这点钱，带着老婆，以及她的朋友去吃了一顿火锅。然后，公司又走了一拨人。&lt;/p&gt;
&lt;p&gt;       八月，老婆生了，生了个儿子，大喜！然后公司搬家了，挺远的，从出门到公司得一个小时。这以后。每天最痛苦的事情就是上下班了，两个小时花在了路上或者地铁上。&lt;/p&gt;
&lt;p&gt;       十月，送老婆会娘家休产假，后续差不多每三个星期回去一次，直到现在。后面，公司就是各种项目计划，各种加班，将会持续到春节放假。&lt;/p&gt;
&lt;p&gt;       十一月，了解了一下深圳的房价，全国都在下跌的情况下，深圳却还在涨。说是因为香港暴乱，深圳房子又炒了一拨，买房一年多下来，我们这套房子涨了100万以上，均价超过了8万一平。不知道应该高兴，还是担忧，不过还是很庆幸去年赶紧买了。房子这事真的很难说，年年都在说要涨到头了，可是还是年年再涨。这容易让我联想到一件事，人人都在说程序员到35岁就很麻烦，年纪越大越有危机，可是放眼望去，那些35岁以上的技术人员，好像也一直过得好好的在。真心希望我们程序员在进入中年危机后，不至于传说中的那么窘迫。&lt;/p&gt;
&lt;p&gt;       从2018年入职到现在，除了春节及这次元旦，几乎每个法定假期都在加班。加班有加班费，两年下来加班费差不多给了两万吧。&lt;/p&gt;
&lt;p&gt;       2019年，读了几本技术或者程序员相关的书籍，其它方面的书没怎么读。其它工作之余的时间，写博客或者照顾老婆去了。辜负了我的书架，哈哈！&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/202001/472002-20200104001612182-263486383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       这两年就这样过去了，对于工作而言总感觉有些遗憾。对于程序员这份工作，我总是觉得我做得比较平庸，每每看到不少畅销的技术书籍或者知名的博客大佬，不少作者的年龄跟我差不多，甚至可能比我还小，而和他们相比差距却这么大。而且连续两份工作，让我损失了10万以上的收入，我老婆都时常笑话我，说我漏财。所以，这份压力是可想而知的。以上就是这两年发生的一些重要的事，以及我个人的得与失。&lt;/p&gt;
&lt;p&gt;       人生在世，总不能甘于平庸吧，2020年的计划，工作上我想做如下几件重要的事：&lt;/p&gt;
&lt;p&gt;       1、系统学习算法。算法是程序的灵魂，以前提到算法就害怕和回避，所以2020年一定要克服。先看程杰的《大话数据结构》、《算法图解》，然后再研究一些常见的算法面试题。LeeCode网站刷题，《剑指offer》看起来。&lt;/p&gt;
&lt;p&gt;       2、多投简历，碰到合适的岗位就多试试，IT圈知名的企业都是我的目标。现在上有老下有小，去更好的平台提升自己，多赚钱才是我最直接的目标，现实一点。&lt;/p&gt;
&lt;p&gt;       3、掌握kotlin。做Android开发，kotlin是大势所趋了，这个是必须得掌握的。跟着《疯狂Kotlin讲义》把重要知识点掌握，能看懂kotlin项目，并能自己写kotlin项目。&lt;/p&gt;
&lt;p&gt;       4、开始了解一些架构方面的知识。     &lt;/p&gt;
&lt;p&gt;       5、一定要注重实践。自己写博客是为了提升实际的开发水平，都是为实践服务的，而不是教育别人。工作当中一定要尽量把理论知识运用到实际工作中，这一点我个人感觉还有点欠缺。      &lt;/p&gt;
&lt;p&gt;       生活上，就是照顾好一家人；如果摇到号可能要买车，我个人对车没太大的欲望，也感觉没太大这方面的需求，这个不做特别的要求。&lt;/p&gt;
&lt;p&gt;       感觉做计划的能力，貌似也差了点，这些计划看起来似乎笼统了点，似乎计划就应该具体一点且操作性强一点会比较好，但我比较担心计划赶不上变化，不敢定得太具体。定计划也是一门技能，后续对这份计划进一步完善和细化！&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jan 2020 17:07:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>春秋代序、寒暑易节，眨眼间就到了年终了。而年终又是一个总结的时节，也是给来年做计划的时节。这里，我也趁这个时机，给过往做一个总结吧。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/12147716.html</dc:identifier>
</item>
<item>
<title>d3.js制作条形时间范围选择器 - eagle1098</title>
<link>http://www.cnblogs.com/eagle1098/p/12146688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eagle1098/p/12146688.html</guid>
<description>&lt;p&gt;此文章为原创文章，原文地址：&lt;a href=&quot;https://www.cnblogs.com/eagle1098/p/12146688.html&quot;&gt;https://www.cnblogs.com/eagle1098/p/12146688.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1706628/202001/1706628-20200103203248801-1748029485.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果如上图所示。&lt;/p&gt;
&lt;p&gt;本项目使用主要d3.js v4制作，可以用来选择两年的时间范围，两端按钮切换年，在时间轴上标注可以选择的时间范围和关键时间点。时间数据可以在前端配置，也可以从后端请求。&lt;/p&gt;
&lt;p&gt;此程序相对比较简单，主要涉及d3的比例尺和拖动处理。&lt;/p&gt;
&lt;p&gt;1）d3的比例尺其实就是把一个范围的数据映射到另一个范围的数据上&lt;/p&gt;
&lt;p&gt;此处，我们使用线性比例尺：d3.scaleLinear()&lt;/p&gt;
&lt;p&gt;它可以把一段连续的值域映射到另一段连续的值域，比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; scale =&lt;span&gt; d3.scaleLinear()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    .domain([0, 730&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; startPos是时间横条的开始x坐标，endPos是结束x坐标&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;    .range([startPos, endPos]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们想知道两年中的具体某天在时间横条上对应点的x坐标，就可以把天数作为参数传给scale()，返回值就是对应的x坐标。&lt;/p&gt;
&lt;p&gt;当然，d3.js中还有很多其他比例尺，详细信息可以查询API文档：&lt;a href=&quot;https://github.com/d3/d3-scale#scaleLinear&quot;&gt;https://github.com/d3/d3-scale#scaleLinear&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;此文章为原创文章，原文地址：&lt;a href=&quot;https://www.cnblogs.com/eagle1098/p/12146688.html&quot;&gt;https://www.cnblogs.com/eagle1098/p/12146688.html&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;2）我们这里的拖动主要分两部分，首先是单独拖动滑块，然后是两个滑块一起拖动。&lt;/p&gt;
&lt;p&gt;单独拖动滑块的逻辑：&lt;/p&gt;
&lt;p&gt;a.如果两个滑块被同时拖动过，则移除两个滑块间的黄线。&lt;/p&gt;
&lt;p&gt;b.使用class名称来判断拖动的是哪个滑块。&lt;/p&gt;
&lt;p&gt;c.计算鼠标x坐标，然后用比例尺反向求出对应的天数位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; xPos为x轴坐标&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; index = scale().invert(xPos);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;d.移动对应滑块到鼠标位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; dragFun = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除拖拽连线元素&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stickDragLine) {
        stickDragLine.remove();
        stickDragLine &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得被点击元素class&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; className = d3.select(&lt;span&gt;this&lt;/span&gt;).attr('class'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算鼠标x坐标，要减去滑块宽度的二分之一&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; pos = d3.event.x - slipBlockWidth / 2&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算鼠标index，&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; index =&lt;span&gt; getIndex(pos);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; blockIndex;

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前块位置，可以配置默认位置，也可从后端请求&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (className === 'slip-left'&lt;span&gt;) {
        blockIndex &lt;/span&gt;=&lt;span&gt; splitBlockIndex.left;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (className === 'slip-right'&lt;span&gt;) {
        blockIndex &lt;/span&gt;=&lt;span&gt; splitBlockIndex.right;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滑块只能在0到maxIndex之间滑动，即上层横条内&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (blockIndex &amp;gt;= 0 &amp;amp;&amp;amp; blockIndex &amp;lt;=&lt;span&gt; maxIndex) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (className === 'slip-left'&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动左滑块和相关背景和文字到鼠标位置&lt;/span&gt;
&lt;span&gt;            changeLeftBlock(index);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (className === 'slip-right'&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动左滑块和相关背景和文字到鼠标位置&lt;/span&gt;
&lt;span&gt;            changeRightBlock(index);
        }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滑块拖动&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; slipBlockDrag =&lt;span&gt; d3.drag()
      .on(&lt;/span&gt;'drag'&lt;span&gt;, dragFun);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滑块元素调用拖拽方法&lt;/span&gt;
&lt;span&gt;slipBlockLeft.call(slipBlockDrag);
slipBlockRight.call(slipBlockDrag);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个滑块一起拖动则在它们中间增加1个黄色连线。最后使用时间条元素调用拖拽方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 主横条上处理两个滑块一起拖动事件&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; stickDrag =&lt;span&gt; d3.drag()
      .on(&lt;/span&gt;'drag', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算移动前两个滑块位置&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; leftEventX =&lt;span&gt; scale(splitBlockIndex.left),
          rightEventX &lt;/span&gt;=&lt;span&gt; scale(splitBlockIndex.right);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (d3.event.x &amp;gt; rightEventX || d3.event.x &amp;lt;&lt;span&gt; leftEventX) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加拖动线条&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;stickDragLine) {
          stickDragLine &lt;/span&gt;= _stickG.append('line'&lt;span&gt;)
            .attr(&lt;/span&gt;'x1', leftEventX + 2&lt;span&gt;)
            .attr(&lt;/span&gt;'y1', stickTop + stickHeight / 2&lt;span&gt;)
            .attr(&lt;/span&gt;'x2', rightEventX + 2&lt;span&gt;)
            .attr(&lt;/span&gt;'y2', stickTop + stickHeight / 2&lt;span&gt;)
            .attr(&lt;/span&gt;'stroke-width', 1&lt;span&gt;)
            .attr(&lt;/span&gt;'stroke', 'yellow'&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动后的x&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; leftAfterX = leftEventX +&lt;span&gt; d3.event.dx,
          rightAfterX &lt;/span&gt;= rightEventX +&lt;span&gt; d3.event.dx,
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动后的index&lt;/span&gt;
          leftIndex =&lt;span&gt; Math.floor(scale().invert(leftAfterX)),
          rightIndex &lt;/span&gt;=&lt;span&gt; Math.floor(scale().invert(rightAfterX));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((leftIndex &amp;gt;= 0 &amp;amp;&amp;amp; rightIndex &amp;lt; maxIndex) &amp;amp;&amp;amp;&lt;span&gt;
          (rightIndex &lt;/span&gt;&amp;gt;= 0 &amp;amp;&amp;amp; leftIndex &amp;lt;&lt;span&gt; maxIndex)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存移动后的index&lt;/span&gt;
          splitBlockIndex.left =&lt;span&gt; leftIndex;
          splitBlockIndex.right &lt;/span&gt;=&lt;span&gt; rightIndex;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动各元素&lt;/span&gt;
&lt;span&gt;          changeLeftBlock(leftAfterX, splitBlockIndex.left);
          changeRightBlock(rightAfterX, splitBlockIndex.right);
          stickDragLine
            .attr(&lt;/span&gt;'x1', leftAfterX + 2&lt;span&gt;)
            .attr(&lt;/span&gt;'x2', rightAfterX + 2&lt;span&gt;);
        }        
      });
    _stickG.call(stickDrag);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文中代码用来说明逻辑结构，具体功能函数实现起来很容易，所以没有给出。&lt;/p&gt;
&lt;h4&gt;此文章为原创文章，原文地址：&lt;a href=&quot;https://www.cnblogs.com/eagle1098/p/12146688.html&quot;&gt;https://www.cnblogs.com/eagle1098/p/12146688.html&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Fri, 03 Jan 2020 17:01:00 +0000</pubDate>
<dc:creator>eagle1098</dc:creator>
<og:description>此文章为原创文章，原文地址：https://www.cnblogs.com/eagle1098/p/12146688.html 效果如上图所示。 本项目使用主要d3.js v4制作，可以用来选择两年的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/eagle1098/p/12146688.html</dc:identifier>
</item>
</channel>
</rss>