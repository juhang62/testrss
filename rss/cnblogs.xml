<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Node程序debug小记 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/10280277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/10280277.html</guid>
<description>&lt;p&gt;有时候，所见并不是所得，有些包，你需要去翻他的源码才知道为什么会这样。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;今天调试一个程序，用到了一个很久之前的NPM包，名为&lt;a href=&quot;https://www.npmjs.com/package/formstream&quot;&gt;formstream&lt;/a&gt;，用来将&lt;code&gt;form&lt;/code&gt;表单数据转换为流的形式进行接口调用时的数据传递。&lt;/p&gt;
&lt;p&gt;这是一个几年前的项目，所以使用的是&lt;code&gt;Generator&lt;/code&gt;+&lt;code&gt;co&lt;/code&gt;实现的异步流程。&lt;/p&gt;
&lt;p&gt;其中有这样一个功能，从某处获取一些图片&lt;code&gt;URL&lt;/code&gt;，并将&lt;code&gt;URL&lt;/code&gt;以及一些其他的常规参数组装到一起，调用另外的一个服务，将数据发送过去。&lt;/p&gt;
&lt;p&gt;大致是这样的代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const co         = require('co')
const moment     = require('moment')
const urllib     = require('urllib')
const Formstream = require('formstream')

function * main () {
  const imageUrlList = [
    'img1',
    'img2',
    'img3',
  ]

  // 实例化 form 表单对象
  const form = new Formstream()

  // 常规参数
  form.field('timestamp', moment().unix())

  // 将图片 URL 拼接到 form 表单中
  imageUrlList.forEach(imgUrl =&amp;gt; {
    form.field('image', imgUrl)
  })

  const options = {
    method: 'POST',
    // 生成对应的 headers 参数
    headers: form.headers(),
    // 告诉 urllib，我们通过流的方式进行传递数据，并指定流对象
    stream: form
  }

  // 发送请求
  const result = yield urllib.request(url, options)

  // 输出结果
  console.log(result)
}

co(main)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也算是一个比较清晰的逻辑，这样的代码也正常运行了一段时间。&lt;/p&gt;
&lt;p&gt;如果没有什么意外，这段代码可能还会在这里安静的躺很多年。&lt;br/&gt;但是，现实总是残酷的，因为一些不可抗拒因素，必须要去调整这个逻辑。&lt;br/&gt;之前调用接口传递的是图片&lt;code&gt;URL&lt;/code&gt;地址，现在要改为直接上传二进制数据。&lt;/p&gt;
&lt;p&gt;所以需求很简单，就是将之前的&lt;code&gt;URL&lt;/code&gt;下载，拿到&lt;code&gt;buffer&lt;/code&gt;，然后将&lt;code&gt;buffer&lt;/code&gt;传到&lt;code&gt;formstream&lt;/code&gt;实例中即可。&lt;br/&gt;大致是这样的操作：&lt;/p&gt;
&lt;pre class=&quot;diff&quot;&gt;
&lt;code&gt;-  imageUrlList.forEach(imgUrl =&amp;gt; {
-    form.field('image', imgUrl)
-  })

+  let imageUrlResults = yield Promise.all(imageUrlList.map(imgUrl =&amp;gt; 
+    urllib.request(url)
+  ))
+  
+  imageUrlResults = imageUrlResults.filter(img =&amp;gt; img &amp;amp;&amp;amp; img.status === 200).map(img =&amp;gt; img.data)
+
+  imageUrlResults.forEach(imgBuffer =&amp;gt; {
+    form.buffer('image', imgBuffer)
+  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载图片 -&amp;gt; 过滤空数据 -&amp;gt; 拼接到&lt;code&gt;form&lt;/code&gt;中去，代码看起来毫无问题。&lt;/p&gt;
&lt;p&gt;不过在执行的时候，却出现了一个令人头大的问题。&lt;br/&gt;最终调用&lt;code&gt;yield urllib.request(url, options)&lt;/code&gt;的时候，提示接口超时了，起初还以为是网络问题，于是多执行了几次，发现还是这样，开始意识到，应该是刚才的代码改动引发的&lt;code&gt;bug&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;开始-debug&quot;&gt;开始 debug&lt;/h2&gt;
&lt;h3 id=&quot;定位引发-bug-的代码&quot;&gt;定位引发 bug 的代码&lt;/h3&gt;
&lt;p&gt;我习惯的调试方式，是先用最原始的方式，&lt;strong&gt;眼&lt;/strong&gt;，看有哪些代码修改。&lt;br/&gt;因为代码都有版本控制，所以大多数编辑器都可以很直观的看到有什么代码修改，即使编辑器中无法看到，也可以在命令行中通过&lt;code&gt;git diff&lt;/code&gt;来查看修改。&lt;/p&gt;
&lt;p&gt;这次的改动就是新增的一个批量下载逻辑，以及&lt;code&gt;URL&lt;/code&gt;改为&lt;code&gt;Buffer&lt;/code&gt;。&lt;br/&gt;先用最简单粗暴的方式来确认是这些代码影响的，&lt;strong&gt;注释掉新增的代码，还原老代码&lt;/strong&gt;。&lt;br/&gt;结果果然是可以正常执行了，那么我们就可以断定&lt;code&gt;bug&lt;/code&gt;就是由这些代码所导致的。&lt;/p&gt;
&lt;h3 id=&quot;逐步还原错误代码&quot;&gt;逐步还原错误代码&lt;/h3&gt;
&lt;p&gt;上边那个方式只是一个&lt;code&gt;rollback&lt;/code&gt;，帮助确定了大致的范围。&lt;br/&gt;接下来就是要缩小错误代码的范围。&lt;br/&gt;一般代码改动大的时候，会有多个函数的声明，那么就按照顺序逐个解开注释，来查看运行的效果。&lt;br/&gt;这次因为是比较小的逻辑调整，所以直接在一个函数中实现。&lt;br/&gt;那么很简单的，在保证程序正常运行的前提下，我们就按照代码语句一行行的释放。&lt;/p&gt;
&lt;p&gt;很幸运，在第一行代码的注释被打开后就复现了&lt;code&gt;bug&lt;/code&gt;，也就是那一行&lt;code&gt;yield Promsie.all(XXX)&lt;/code&gt;。&lt;br/&gt;但是这个语句实际上也可以继续进行拆分，为了排除是&lt;code&gt;urllib&lt;/code&gt;的问题，我将该行代码换为一个最基础的&lt;code&gt;Promise&lt;/code&gt;对象：&lt;code&gt;yield Promise.resolve(1)&lt;/code&gt;。&lt;br/&gt;结果令我很吃惊，这么一个简单的&lt;code&gt;Promise&lt;/code&gt;执行也会导致下边的请求超时。&lt;/p&gt;
&lt;p&gt;当前的部分代码状态：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const form = new Formstream()

form.field('timestamp', moment().unix())

yield Promise.resolve(1)

const options = {
 method: 'POST',
 headers: form.headers(),
 stream: form
}

// 超时
const result = yield urllib.request(url, options)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再缩小了范围以后，进一步进行排查。&lt;br/&gt;目前所剩下的代码已经不错了，唯一可能会导致请求超时的情况，可能就是发请求时的那些&lt;code&gt;options&lt;/code&gt;参数了。&lt;br/&gt;所以将&lt;code&gt;options&lt;/code&gt;中的&lt;code&gt;headers&lt;/code&gt;和&lt;code&gt;stream&lt;/code&gt;都注释掉，再次执行程序后，果然可以正常访问接口（虽说会提示出错，因为必选的参数没有传递）。&lt;/p&gt;
&lt;p&gt;那么目前我们可以得到一个结论：&lt;code&gt;formstream&lt;/code&gt;实例+&lt;code&gt;Promise&lt;/code&gt;调用会导致这个问题。&lt;/p&gt;
&lt;h3 id=&quot;冷静忏悔&quot;&gt;冷静、忏悔&lt;/h3&gt;
&lt;p&gt;接下来要做的就是深呼吸，冷静，让心率恢复平稳再进行下一步的工作。&lt;br/&gt;在我得到上边的结论之后，第一时间是崩溃的，因为导致这个&lt;code&gt;bug&lt;/code&gt;的环境还是有些复杂的，涉及到了三个第三方包，&lt;code&gt;co&lt;/code&gt;、&lt;code&gt;formstream&lt;/code&gt;和&lt;code&gt;urllib&lt;/code&gt;。&lt;br/&gt;而直观的去看代码，自己写的逻辑其实是很少的，所以难免会在心中开始抱怨，觉得是第三方包在搞我。&lt;br/&gt;但这时候要切记「程序员修炼之道」中的一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&quot;Select&quot; Isn't Broken&lt;br/&gt;“Select” 没有问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以一定要在内心告诉自己：“你所用的包都是经过了N久时间的洗礼，一定是一个很稳健的包，这个&lt;code&gt;bug&lt;/code&gt;一定是你的问题”。&lt;/p&gt;
&lt;h3 id=&quot;分析问题&quot;&gt;分析问题&lt;/h3&gt;
&lt;p&gt;当我们达成这个共识以后，就要开始进行问题的分析了。&lt;br/&gt;首先你要了解你所使用的这几个包的作用是什么，如果能知道他们是怎么实现的那就更好了。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;co&lt;/code&gt;，就是一个利用&lt;code&gt;yield&lt;/code&gt;语法特性将&lt;code&gt;Promise&lt;/code&gt;转换为更直观的写法罢了，没有什么额外的逻辑。&lt;br/&gt;而&lt;code&gt;urllib&lt;/code&gt;也会在每次调用&lt;code&gt;request&lt;/code&gt;时创建一个新的&lt;code&gt;client&lt;/code&gt;（刚开始有想过会不会是因为多次调用&lt;code&gt;urllib&lt;/code&gt;导致的，不过用简单的&lt;code&gt;Promise.resolve&lt;/code&gt;代替之后，这个念头也打消了）&lt;/p&gt;
&lt;p&gt;那么矛头就指向了&lt;code&gt;formstream&lt;/code&gt;，现在要进一步的了解它，不过通过官方文档进行查阅，并不能得到太多的有效信息。&lt;/p&gt;
&lt;h3 id=&quot;源码阅读&quot;&gt;源码阅读&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/node-modules/formstream/blob/master/lib/formstream.js&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以为了解决问题，我们需要去阅读它的源码，从你在代码中调用的那些 API 入手：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/node-modules/formstream/blob/master/lib/formstream.js#L38&quot;&gt;构造函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/node-modules/formstream/blob/master/lib/formstream.js#L133&quot;&gt;field&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/node-modules/formstream/blob/master/lib/formstream.js#L88&quot;&gt;headers&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;构造函数营养并不多，就是一些简单的属性定义，并且看到了它继承自&lt;code&gt;Stream&lt;/code&gt;，这也是为什么能够在&lt;code&gt;urllib&lt;/code&gt;的&lt;code&gt;options&lt;/code&gt;中直接填写它的原因，因为是一个&lt;code&gt;Stream&lt;/code&gt;的子类。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;util.inherits(FormStream, Stream);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就要看&lt;code&gt;field&lt;/code&gt;函数的实现了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;FormStream.prototype.field = function (name, value) {
  if (!Buffer.isBuffer(value)) {
    // field(String, Number)
    // https://github.com/qiniu/nodejs-sdk/issues/123
    if (typeof value === 'number') {
      value = String(value);
    }
    value = new Buffer(value);
  }
  return this.buffer(name, value);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码的实现看，&lt;code&gt;field&lt;/code&gt;也只是一个&lt;code&gt;Buffer&lt;/code&gt;的封装处理，最终还是调用了&lt;code&gt;.buffer&lt;/code&gt;函数。&lt;br/&gt;那么我们就顺藤摸瓜，继续查看&lt;a href=&quot;https://github.com/node-modules/formstream/blob/master/lib/formstream.js#L181&quot;&gt;buffer&lt;/a&gt;函数的实现。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;FormStream.prototype.buffer = function (name, buffer, filename, mimeType) {
  if (filename &amp;amp;&amp;amp; !mimeType) {
    mimeType = mime.lookup(filename);
  }

  var disposition = { name: name };
  if (filename) {
    disposition.filename = filename;
  }

  var leading = this._leading(disposition, mimeType);

  this._buffers.push([leading, buffer]);

  // plus buffer length to total content-length
  this._contentLength += leading.length;
  this._contentLength += buffer.length;
  this._contentLength += NEW_LINE_BUFFER.length;

  process.nextTick(this.resume.bind(this));

  return this;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码不算少，不过大多都不是这次需要关心的，大致的逻辑就是将&lt;code&gt;Buffer&lt;/code&gt;拼接到数组中去暂存，在最后结尾的地方，发现了这样的一句代码：&lt;code&gt;process.nextTick(this.resume.bind(this))&lt;/code&gt;。&lt;br/&gt;顿时眼前一亮，重点的是那个&lt;code&gt;process.nextTick&lt;/code&gt;，大家应该都知道，这个是在&lt;code&gt;Node&lt;/code&gt;中实现微任务的其中一个方式，而另一种实现微任务的方式，就是用&lt;code&gt;Promise&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;修改代码验证猜想&quot;&gt;修改代码验证猜想&lt;/h3&gt;
&lt;p&gt;拿到这样的结果以后，我觉得仿佛找到了突破口，于是尝试性的将前边的代码改为这样：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const form = new Formstream()

form.field('timestamp', moment().unix())

yield Promise.resolve(1)

const options = {
 method: 'POST',
 headers: form.headers(),
 stream: form
}

process.nextTick(() =&amp;gt; {
  urllib.request(url, options)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;发现，果然超时了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从这里就能大致推断出问题的原因了。&lt;br/&gt;因为看代码可以很清晰的看出，&lt;code&gt;field&lt;/code&gt;函数在调用后，会注册一个微任务，而我们使用的&lt;code&gt;yield&lt;/code&gt;或者&lt;code&gt;process.nextTick&lt;/code&gt;也会注册一个微任务，但是&lt;code&gt;field&lt;/code&gt;的先注册，所以它的一定会先执行。&lt;br/&gt;那么很显而易见，问题就出现在这个&lt;code&gt;resume&lt;/code&gt;函数中，因为&lt;code&gt;resume&lt;/code&gt;的执行早于&lt;code&gt;urllib.request&lt;/code&gt;，所以导致其超时。&lt;br/&gt;这时候也可以同步的想一下造成&lt;code&gt;request&lt;/code&gt;超时的情况会是什么。&lt;br/&gt;只有一种可能性是比较高的，因为我们使用的是&lt;code&gt;stream&lt;/code&gt;，而这个流的读取是需要事件来触发的，&lt;code&gt;stream.on('data')&lt;/code&gt;、&lt;code&gt;stream.on('end')&lt;/code&gt;，那么超时很有可能是因为程序没有正确接收到&lt;code&gt;stream&lt;/code&gt;的事件导致的。&lt;/p&gt;
&lt;p&gt;当然了，「程序员修炼之道」还讲过：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Don't Assume it - Prove It&lt;br/&gt;不要假定，要证明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以为了证实猜测，需要继续阅读&lt;code&gt;formstream&lt;/code&gt;的源码，查看&lt;code&gt;resume&lt;/code&gt;函数究竟做了什么。&lt;br/&gt;&lt;code&gt;resume&lt;/code&gt;函数是一个很简单的一次性函数，在第一次被触发时调用&lt;code&gt;drain&lt;/code&gt;函数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;FormStream.prototype.resume = function () {
  this.paused = false;

  if (!this._draining) {
    this._draining = true;
    this.drain();
  }

  return this;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么继续查看&lt;code&gt;drain&lt;/code&gt;函数做的是什么事情。&lt;br/&gt;因为上述使用的是&lt;code&gt;field&lt;/code&gt;，而非&lt;code&gt;stream&lt;/code&gt;，所以在获取&lt;code&gt;item&lt;/code&gt;的时候，肯定为空，那么这就意味着会继续调用&lt;code&gt;_emitEnd&lt;/code&gt;函数。&lt;br/&gt;而&lt;code&gt;_emitEnd&lt;/code&gt;函数只有简单的两行代码&lt;code&gt;emit('data')&lt;/code&gt;和&lt;code&gt;emit('end')&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;FormStream.prototype.drain = function () {
  console.log('start drain')
  this._emitBuffers();

  var item = this._streams.shift();
  if (item) {
    this._emitStream(item);
  } else {
    this._emitEnd();
  }

  return this;
};

FormStream.prototype._emitEnd = function () {
  this.emit('data', this._endData);
  this.emit('end');
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这两行代码，终于可以证实了我们的猜想，因为&lt;code&gt;stream&lt;/code&gt;是一个流，接收流的数据需要通过事件传递，而&lt;code&gt;emit&lt;/code&gt;就是触发事件所使用的函数。&lt;br/&gt;这也就意味着，&lt;code&gt;resume&lt;/code&gt;函数的执行，就代表着&lt;code&gt;stream&lt;/code&gt;发送数据的动作，在发送完毕数据后，会执行&lt;code&gt;end&lt;/code&gt;，也就是关闭流的操作。&lt;/p&gt;
&lt;h3 id=&quot;得出结论&quot;&gt;得出结论&lt;/h3&gt;
&lt;p&gt;到了这里，终于可以得出完整的结论：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;formstream&lt;/code&gt;在调用&lt;code&gt;field&lt;/code&gt;之类的函数后会注册一个微任务&lt;br/&gt;微任务执行时会使用流开始发送数据，数据发送完毕后关闭流&lt;br/&gt;因为在调用&lt;code&gt;urllib&lt;/code&gt;之前还注册了一个微任务，导致&lt;code&gt;urllib.request&lt;/code&gt;实际上是在这个微任务内部执行的&lt;br/&gt;也就是说在&lt;code&gt;request&lt;/code&gt;执行的时候，流已经关闭了，一直拿不到数据，所以就抛出异常，提示接口超时。&lt;/p&gt;
&lt;p&gt;那么根据以上的结论，现在就知道该如何修改对应的代码。&lt;br/&gt;在调用&lt;code&gt;field&lt;/code&gt;方法之前进行下载图片资源，保证&lt;code&gt;formstream.field&lt;/code&gt;与&lt;code&gt;urllib.request&lt;/code&gt;之间的代码都是同步的。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let imageUrlResults = yield Promise.all(imageUrlList.map(imgUrl =&amp;gt; 
  urllib.request(url)
))

const form = new Formstream()

form.field('timestamp', moment().unix())

imageUrlResults = imageUrlResults.filter(img =&amp;gt; img &amp;amp;&amp;amp; img.status === 200).map(img =&amp;gt; img.data)
imageUrlResults.forEach(imgBuffer =&amp;gt; {
  form.buffer('image', imgBuffer)
})

const options = {
 method: 'POST',
 headers: form.headers(),
 stream: form
}

yield urllib.request(url, options)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这并不是一个有各种高大上名字、方法论的一个调试方式。&lt;br/&gt;不过我个人觉得，它是一个非常有效的方式，而且是一个收获会非常大的调试方式。&lt;br/&gt;因为在调试的过程中，你会去认真的了解你所使用的工具究竟是如何实现的，他们是否真的就像文档中所描述的那样运行。&lt;/p&gt;
&lt;p&gt;关于上边这点，顺便吐槽一下这个包：&lt;a href=&quot;https://www.npmjs.com/package/thenify-all&quot;&gt;thenify-all&lt;/a&gt;。&lt;br/&gt;是一个不错的包，用来将普通的&lt;code&gt;Error-first-callback&lt;/code&gt;函数转换为&lt;code&gt;thenalbe&lt;/code&gt;函数，但是在涉及到&lt;code&gt;callback&lt;/code&gt;会接收多个返回值的时候，该包会将所有的返回值拼接为一个数组并放入&lt;code&gt;resolve&lt;/code&gt;中。&lt;br/&gt;实际上这是很令人困惑的一点，因为根据&lt;code&gt;callback&lt;/code&gt;返回参数的数量来区别编写代码。&lt;br/&gt;而且&lt;code&gt;thenable&lt;/code&gt;约定的规则就是返回&lt;code&gt;callback&lt;/code&gt;中的除了&lt;code&gt;error&lt;/code&gt;以外的第一个参数。&lt;/p&gt;
&lt;p&gt;但是这个在文档中并没有体现，而是简单的使用&lt;code&gt;readFile&lt;/code&gt;来举例，很容易对使用者产生误导。&lt;br/&gt;一个最近的例子，就是我使用&lt;code&gt;util.promisify&lt;/code&gt;来替换掉&lt;code&gt;thenify-all&lt;/code&gt;的时候，发现之前的&lt;code&gt;mysql.query&lt;/code&gt;调用莫名其妙的报错了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 之前的写法
const [res] = await mysqlClient.query(`SELECT XXX`)

// 现在的写法
const res = await mysqlClient.query(`SELECT XXX`)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为在&lt;a href=&quot;https://github.com/mysqljs/mysql#introduction&quot;&gt;mysql&lt;/a&gt;文档中明确定义了，&lt;code&gt;SELECT&lt;/code&gt;语句之类的会传递两个参数，第一个是查询的结果集，而第二个是字段的描述信息。&lt;br/&gt;所以&lt;code&gt;thenify-all&lt;/code&gt;就将两个参数拼接为了数组进行&lt;code&gt;resolve&lt;/code&gt;，而在切换到了官方的实现后，就造成了使用数组解构拿到的只是结果集中的第一条数据。&lt;/p&gt;
&lt;p&gt;最后，再简单的总结一下套路，希望能够帮到其他人：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;屏蔽异常代码，确定稳定复现（还原修改）&lt;/li&gt;
&lt;li&gt;逐步释放，缩小范围（一行行的删除注释）&lt;/li&gt;
&lt;li&gt;确定问题，利用基础&lt;code&gt;demo&lt;/code&gt;来屏蔽噪音（类似前边的&lt;code&gt;yield Promise.resolve(1)&lt;/code&gt;操作）&lt;/li&gt;
&lt;li&gt;分析原因，看文档，啃源码（了解这些代码为什么会出错）&lt;/li&gt;
&lt;li&gt;通过简单的实验来验证猜想（这时候你就能知道怎样才能避免类似的错误）&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 16 Jan 2019 17:46:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<og:description>有时候，所见并不是所得，有些包，你需要去翻他的源码才知道为什么会这样。 &lt;! more 背景 今天调试一个程序，用到了一个很久之前的NPM包，名为 'formstream' ，用来将 表单数据转换为流</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/10280277.html</dc:identifier>
</item>
<item>
<title>安卓之必须了解的实时通信 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10280104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10280104.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Socket：&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有服务器和客户端之分，其是对TCP/IP的封装，使用IP地址加端口，确定一个唯一的点。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。值得注意的是用户使用的端口最好大于1024，因为小于1024的大部分端口都是被系统占用的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;安卓的线程基本机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个程序就是一个进程，一个进程里可以有多个线程，每个进程必须有一个主线程。对应安卓一个应用程序就是一个进程，其主线程就是平常所说的安卓主UI线程。安卓实现多线程编程，其有一个重要的原则就是更新UI必须在主线程，但耗时操作必须在子线程中，如果耗时操作在主线程编写（如网络访问）当阻塞时间达到一定时，应用就会强制退出，那网络访问就面临着一个不可避免的问题：子线程更新UI操作如何实现。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Handler&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Handler主要用于异步消息的处理： 有点类似辅助类，封装了消息投递、消息处理等接口。当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗时比较长的操作。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Message&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Handler接收与处理的消息对象，其中消息类型有&lt;/p&gt;
&lt;p&gt;public int arg1和public int arg2：存放简单的整数类型消息&lt;/p&gt;
&lt;p&gt;public Object obj：发送给接收器的任意对象，不管是整数，字符串，某个类对象均可&lt;/p&gt;
&lt;p&gt;public int what：用户自定义的消息代码，这样接受者可以了解这个消息的信息，每个handler各自包含自己的消息代码，所以不用担心自定义的消息跟其他handlers有冲突。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 安卓端实现效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在同一网络下的一个设备开启一个端口的监听，做为socket服务器，并获取到服务器设备的IP地址和端口号，将其格式化为 “IP：端口” 进行输入，如 “193.169.44.198:8081” ,点击连接即可。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201901/1485202-20190116234251225-1090337978.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;492&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;编程实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;获取网络访问权限:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实现socket编程，必须开启网络访问权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.INTERNET&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;编写Handler消息处理类：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;handler消息处理类是MainActivity类的内部类，当消息队列不为空时将自动进入，获取到消息值并分析其中内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Handler mainhandler=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleMessage(Message msg) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到命令，进行命令分支&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; handi=&lt;span&gt;msg.arg1;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (handi){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 String ormsg=&lt;span&gt;(String)msg.obj;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 disSocket();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;断开网络&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;发生错误=&amp;gt;：&quot;+&lt;span&gt;ormsg,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;连接成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;收到数据&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 String str1=&lt;span&gt;(String)msg.obj;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                main_rx.setText(str1);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;:&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;连接按钮监听：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当连接按钮按下时，将会立即获取输入框的内容并进行字符串分隔，得到IP地址和端口号，开启线程进行网络连接 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接按钮监听&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; main_conn.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;           String strip=&lt;span&gt;main_ip.getText().toString().trim();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt;(strip.indexOf(&quot;:&quot;)&amp;gt;=0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;              
&lt;span&gt; 8&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始启动连接线程&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;               &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket_thread(strip).start();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;发送数据按钮监听：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当发送数据按钮按下时，将会立即获取到发送输入框的内容，分别可以调用字符串发送函数和十六进制发送函数进行数据发送&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送按钮监听&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; main_send.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到输入框内容&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;final&lt;/span&gt; String senddata=&lt;span&gt;main_tx.getText().toString().trim();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!senddata.equals(&quot;&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送因为使用的是线程，所以先后顺序不一定
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送字符串数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            sendStrSocket(senddata);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送十六进制数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             sendByteSocket(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[]{0x01,0x02,0x03&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;            }&lt;span&gt;else&lt;/span&gt; Toast.makeText(MainActivity.&lt;span&gt;this&lt;/span&gt;,&quot;输入不可为空&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;开始网络连接线程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该类为MainActivity类的内部类，实现线程连接socket服务器，并获取输入输出流，并开启接收线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Socket_thread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String IP=&quot;&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ip地址&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PORT=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口号&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Socket_thread(String strip){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法需要传递服务器的IP地址和端口号
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如: 192.168.43.222:8099
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行字符串分隔，得到服务器IP地址和端口号&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         String[] stripx= strip.split(&quot;:&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.IP=stripx[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.PORT=Integer.parseInt(stripx[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             disSocket();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;断开上次连接&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(sock !=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                outx.close();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                inx.close();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 sock.close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 sock=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始连接服务器，此处会一直处于阻塞，直到连接成功&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             sock=&lt;span&gt;new&lt;/span&gt; Socket(&lt;span&gt;this&lt;/span&gt;.IP,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PORT);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞停止，表示连接成功，发送连接成功消息&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             Message message=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             message.arg1=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            mainhandler.sendMessage(message);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;          }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Message message=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             message.arg1=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             message.obj=&quot;连接服务器时异常&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            mainhandler.sendMessage(message);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;             System.out.println(&quot;建立失败////////////////////////////////////////////&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到输入输出流&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;             outx=&lt;span&gt;sock.getOutputStream();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             inx=&lt;span&gt;sock.getInputStream();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送连接失败异常&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;             Message message=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             message.arg1=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             message.obj=&quot;获取输入输出流异常&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            mainhandler.sendMessage(message);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;             System.out.println(&quot;流获取失败////////////////////////////////////////////&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; new Outx().start();&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inx().start();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;关闭socket函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关闭socket之前将先关闭输入输出流，这样才能更加安全的关闭socket &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; disSocket(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不为空，则断开socket&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(sock !=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            outx.close();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            inx.close();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             sock.close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             sock = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送连接失败异常&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             Message message=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             message.arg1=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             message.obj=&quot;断开连接时发生错误&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            mainhandler.sendMessage(message);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据接收线程实现：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接收线程将实现数据的接收，并把接收到的数据通过消息发送给处理类，特别注意的是 inx.read(bu) 返回如果是 -1 则表示服务器断开了连接或者其它非主动调用关闭socket方法断开造成的错误&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环接收数据&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Inx &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] bu=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到-1表示服务器断开&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;           &lt;span&gt;int&lt;/span&gt; conut=inx.read(bu);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备重启，异常 将会一直停留在这&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(conut==-1&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送连接失败异常&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 Message message=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 message.arg1=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 message.obj=&quot;服务器断开&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                mainhandler.sendMessage(message);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 disSocket();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;断开连接&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 System.out.println(&quot;**********服务器异常*********:&quot;+&lt;span&gt;conut);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须去掉前后空字符，不然有这个会有1024个字符每次&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;           strread=&lt;span&gt;new&lt;/span&gt; String(bu,&quot;GBK&quot;&lt;span&gt;).trim();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送出收到的数据&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;           Message message=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;           message.arg1=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;           message.obj=&lt;span&gt;strread;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;          mainhandler.sendMessage(message);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;           } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;              System.out.println(e);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;  } }}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;发送字符串函数：&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络编程的最终发送的内容是字节，所以发送字符串需要通过getBytes进行编码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送字符串&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendStrSocket(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String senddata){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以经过编码发送字符串&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;          outx.write(senddata.getBytes(&quot;gbk&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;       } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送连接失败异常&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;          Message message=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;          message.arg1=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;          message.obj=&quot;数据发送异常&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         mainhandler.sendMessage(message);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;   }).start();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;发送十六进制函数：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过字节数组，可以实现多个十六进制数据的发送&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送十六进制&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendByteSocket(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] senddata){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送十六进制&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            outx.write(senddata);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送连接失败异常&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;              Message message=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;              message.arg1=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;              message.obj=&quot;数据发送异常&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;             mainhandler.sendMessage(message);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }).start();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;&lt;p&gt; 参考：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/rabbit_in_android/article/details/50585156&lt;/p&gt;
&lt;p&gt;https://www.imooc.com/article/25134?block_id=tuijian_wz&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 17:11:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>Socket： 有服务器和客户端之分，其是对TCP/IP的封装，使用IP地址加端口，确定一个唯一的点。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10280104.html</dc:identifier>
</item>
<item>
<title>Java运行时环境---ClassLoader类加载机制 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10269844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10269844.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;：听说ClassLoader类加载机制是进入BAT的必经之路。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ClassLoader总述&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      普通的Java开发其实用到ClassLoader的地方并不多，但是理解透彻ClassLoader类的加载机制，无论是对我们编写更高效的代码还是进BAT都大有裨益；而从“黄埔军校”出来的我对ClassLoader的理解都是借鉴了很多书籍和博客，站在了各大博主的肩膀上，感谢你们！上菜，Classloader最主要的作用就是将Java字节码文件(后缀为.class)加载到JVM中，JVM在启动时不会一次性加载所有的class文件，而是根据需要动态加载class文件，毕竟一次性加载太多jar包的class文件JVM吃不消；下面主要研究Bootstrap ClassLoader、Extention ClassLoader和AppClassLoader这三种类加载器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  谈到ClassLoader就想到我们安装JDK的时候都会在控制台输入java、javac验证是否安装成功，而这个javac就是Java ClassLoader，测试是否能把Java源文件正确编译成Java字节码文件，下面的截图就是个javac的小例子，javac之后加载器把Java源文件编译成TestClassLoader.class字节码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190115003123942-39533827.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于下面要讲到ClassLoader的加载路径，这里顺便把Java的环境变量也复习一遍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;JAVA_HOME&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指的是安装JDK的位置，如：JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home&quot; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PATH&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置PATH(程序的路径)的作用将就是能够在命令行窗口直接键入程序的名字了，而不再需要键入它的全路径，比如上面代码中我用的到&lt;code&gt;javac&lt;/code&gt;和&lt;code&gt;java&lt;/code&gt;两个命令。如：PATH=&quot;.$PATH:$JAVA_HOME/bin&quot; ；就是在&lt;span&gt;JAVA_HOME&lt;/span&gt;路径上添加了JDK下的bin目录即可。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CLASSPATH&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CLASSPATH就是指向jar包的路径，如：PATH=&quot;.$PATH:$JAVA_HOME/bin&quot; ；&quot;&lt;strong&gt;&lt;span&gt;.&lt;/span&gt;&lt;/strong&gt;&quot;表示当前目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ClassLoader类加载流程&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三个Class Loader的执行顺序是：&lt;span&gt;Bootstrap CLassloder -&amp;gt; &lt;span&gt;Extention ClassLoader &lt;/span&gt; -&amp;gt; &lt;span&gt;AppClassLoader；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、&lt;span&gt;&lt;span&gt;Bootstrap CLassloder是最顶层的加载类，主要是加载核心类库，也就是&lt;span&gt;%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等&lt;/span&gt;资源；并且，可以通过启动JVM时指定-&lt;span&gt;Xbootclasspath&lt;/span&gt;和路径来改变&lt;span&gt;Bootstrap ClassLoader&lt;/span&gt;的加载目录，下面有个小荔子。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、&lt;span&gt;Extention ClassLoader是扩展的类加载器，其&lt;span&gt;加载的是目录%JRE_HOME%\lib\ext目录下的jar包和class文件；它同样也可以&lt;span&gt;加载-D java.ext.dirs选项指定的目录&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、&lt;span&gt;Appclass Loader是用于加载当前应用的classpath的所有类，其&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;也称为SystemAppClass&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外有兴趣的还可以看下&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;Launcher&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;类的源码，源码中规定了三个加载器的环境属性分别为&lt;code&gt;B:sun.boot.class.path、E:java.ext.dirs和A:java.class.path;下面通过代码来简单测试写，如图：&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190115232300121-1314416609.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;BootstrapClassLoade&lt;/strong&gt;r:&lt;br/&gt;        /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/resources.jar:&lt;br/&gt;            /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/rt.jar:&lt;br/&gt;                /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/sunrsasign.jar:&lt;br/&gt;                    /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jsse.jar:&lt;br/&gt;                        /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jce.jar:&lt;br/&gt;                            /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/charsets.jar:&lt;br/&gt;                                /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfr.jar:&lt;br/&gt;                                    /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/classes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ExtClassLoader&lt;/strong&gt;:&lt;br/&gt;        /Users/apple/Library/Java/Extensions:&lt;br/&gt;            /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext:&lt;br/&gt;                /Library/Java/Extensions:/Network/Library/Java/Extensions:&lt;br/&gt;                    /System/Library/Java/Extensions:/usr/lib/java&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;AppClassLoader&lt;/strong&gt;:&lt;br/&gt;        /TJT/Eclipse/workspace/tjt/bin:&lt;br/&gt;            /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/rt.jar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了更好的理解三者之间加载的关系，我们来测试一个类的加载器和它的父类加载以及一些不是我们创建的类如String、Double、int等基础类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190115235913715-310910736.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图中可用看出，自己编写的类Test2.class文件&lt;span&gt;是由AppClassLoader加载的，并且&lt;span&gt;&lt;span&gt;AppClassLoader&lt;/span&gt;&lt;/span&gt;有父加载器ExtClassLoader，但&lt;span&gt;&lt;span&gt;ExtClassLoader&lt;/span&gt;&lt;/span&gt;的父加载器为null；Double.class这个Java基础类的加载器为null，其父加载也为空且程序还会报空指针异常错误；其实呢，Double.class是有Bootstrap CLassLoader加载的，也并不是每个加载器都有父加载器；总的来说就是&lt;span&gt;&lt;span&gt;JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件&lt;/span&gt;&lt;/span&gt;，诸如一些&lt;span&gt;&lt;span&gt;int.class，String.class都是由它加载；&lt;span&gt;&lt;span&gt;JVM初始化sun.misc.Launcher并创建Extension ClassLoader和AppClassLoader实例，且将ExtClassLoader设置为AppClassLoader的父加载器；而&lt;span&gt;&lt;span&gt;Bootstrap虽然没有父加载器，但是它却可以作为一个ClassLoader的父加载器&lt;/span&gt;&lt;/span&gt;；另外，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;双亲委托&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先会判断这个class是不是已经加载成功，如果没有加载的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后是由自身去查找这些对象；这种机制就叫做双亲委托。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190117002255328-577091310.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从上图可用看出ClassLoader的加载序列，委托是从下往上，查找过程则是从上向下的，以下有几个注意事项：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、一个AppClassLoader查找资源时，首先会查看缓存是否有，若有则从缓存中获取，否则委托给父加载器；&lt;br/&gt;2.、重复第一步的递归操作，查询类是否已被加载；&lt;br/&gt;3.、如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader加载，它首先也会查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径，找到就返回，找不到就让子加载器自己去找。&lt;br/&gt;4.、Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs路径中去查找，查找成功就返回，查找不成功则再向下让子加载器找。&lt;br/&gt;5.、若是ExtClassLoader查找不成功，则由ppClassLoader在java.class.path路径下自己查找查找，找到就返回，如果没有找到就让子类找，如果没有子类则会抛出各种异常。&lt;br/&gt;&lt;strong&gt;自定义CLassLoader&lt;/strong&gt;：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在ClassLoader中有四个很重要实用的方法loadClass()、findLoadedClass()、findClass()、defineClass()，可以用来创建属于自己的类的加载方式；比如我们需要动态加载一些东西，或者从C盘某个特定的文件夹加载一个class文件，又或者从网络上下载class主内容然后再进行加载等。分三步搞定：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、编写一个类继承ClassLoader抽象类；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、重写findClass()方法；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、在findClass()方法中调用defineClass()方法即可实现自定义ClassLoader；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;需求：自定义一个classloader其默认加载路径为&quot;/TJT/Code&quot;下的jar包和资源。首先创建一个Test.java，然后javac编译并把生成的Test.class文件放到&quot;/TJT/Code&quot;路径下，然后再编写一个&lt;code class=&quot;hljs java has-numbering&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;DiskClassLoader继承ClassLoader，最后通过&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;FindClassLoader的测试类，调用再Test.class里面的一个find()方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package www.baidu;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import java.io.ByteArrayOutputStream;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import java.io.File;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import java.io.IOException;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DiskClassLoader extends ClassLoader{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义classLoader能将class二进制内容转换成Class对象&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String myPath;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DiskClassLoader(String path) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         myPath =&lt;span&gt; path;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;findClass()方法中定义了查找class的方法&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; findClass(String name) throws ClassNotFoundException{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         String fileName =&lt;span&gt; getFileName(name);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         File file = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(myPath,fileName);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             FileInputStream &lt;span&gt;is&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             ByteArrayOutputStream bos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; len = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;((len = &lt;span&gt;is&lt;/span&gt;.read()) != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    bos.write(len);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] data =&lt;span&gt; bos.toByteArray();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;is&lt;/span&gt;&lt;span&gt;.close();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            bos.close();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据通过defineClass()生成了Class对象&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; defineClass(name, data,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,data.length );
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; super.findClass(name);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getFileName(String name) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; lastIndexOf = name.lastIndexOf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (lastIndexOf == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; name.substring(lastIndexOf + &lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试结果如下：找到了自定义的加载路径并且调用了类中的find()方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190117000027980-1441265017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; www.baidu;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FindClassLoader {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建自定义classloader对象&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         DiskClassLoader diskL = &lt;span&gt;new&lt;/span&gt; DiskClassLoader(&quot;/TJT/Code&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;classloader is: &quot;+&lt;span&gt;diskL);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载class文件&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             Class clazz = diskL.loadClass(&quot;www.baidu.Test&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (clazz != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Object object =&lt;span&gt; clazz.newInstance();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 Method declaredMethod = clazz.getDeclaredMethod(&quot;find&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过反射调用Test类的find()方法&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 declaredMethod.invoke(object, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        } 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外，&lt;span&gt;ClassLoader还可以进行程序加密(比如你写了比较骚的jar包)，这样我们就可以在程序中加载特定了类，并且这个类只能被我们自定义的加载器进行加载，提高了程序的安全性，但是用的不多；反正我们在项目上是不允许用&lt;span&gt;&lt;span&gt;ClassLoader&lt;/span&gt;&lt;/span&gt;加密，宁愿裸奔，了解一下。另外就是tomcat的类加载机制也是遵循双亲委派机制的，并且大部分的加载机制和JVM类加载机制一样，理解了&lt;span&gt;Bootstrap ClassLoader、Extention ClassLoader和AppClassLoader&lt;/span&gt;这三种加载器后再看tomcat类的加载就可以横着走了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





</description>
<pubDate>Wed, 16 Jan 2019 16:12:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>背景：听说ClassLoader类加载机制是进入BAT的必经之路。 ClassLoader总述： 普通的Java开发其实用到ClassLoader的地方并不多，但是理解透彻ClassLoader类的加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taojietaoge/p/10269844.html</dc:identifier>
</item>
<item>
<title>EF6学习笔记十二：Update操作、批量数据操作 - 张四海</title>
<link>http://www.cnblogs.com/jinshan-go/p/10280066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinshan-go/p/10280066.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;要专业系统地学习EF前往《你必须掌握的Entity Framework 6.x与Core 2.0》这本书的作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/CreateMyself/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据操作CRUD，我们只说Update,因为在EF中Update有点复杂  后面我们说批量数据更新&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Update操作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上下文没有提供Update方法，所以我们要更新操作一般都是讲数据查询出来，修改实体属性的值，然后SaveChanges()就OK了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;眼熟一下平时的Update&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_141b674d-20a0-4b0d-96c3-b793a4b4c59b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_141b674d-20a0-4b0d-96c3-b793a4b4c59b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_141b674d-20a0-4b0d-96c3-b793a4b4c59b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  一般的修改&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro =&lt;span&gt; ctx.Products.FirstOrDefault();
Console.WriteLine(JsonConvert.SerializeObject(pro));
Console.WriteLine(ctx.Entry(pro).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Unchanged
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{&quot;Order&quot;:null,&quot;Name&quot;:&quot;牙刷&quot;,&quot;Price&quot;:14.00,&quot;Unit&quot;:&quot;只&quot;,&quot;FK_Order_Id&quot;:&quot;82903023-a7a6-4839-9caa-153ee9d00e65&quot;,&quot;Id&quot;:&quot;1b25351c-3008-4d27-a9de-6749ec1d0845&quot;,&quot;AddTime&quot;:&quot;2019-01-15T10:35:03.947&quot;}&lt;/span&gt;
pro.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;牙刷2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Console.WriteLine(ctx.Entry(pro).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Modified&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.SaveChanges();
Console.WriteLine(res);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  result:1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查询出来没做修改的实体，状态为Unchange,修改了属性值，状态变为Modified&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现在要是我凭空new一个Product对象，id设置为数据库中某一个产品的Id,然后让上下文对这个新对象追踪，最后再修改实体状态为Modified,看看能不能修改&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_c69209d0-a2a4-47ca-91b1-e418997bfb31&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c69209d0-a2a4-47ca-91b1-e418997bfb31&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c69209d0-a2a4-47ca-91b1-e418997bfb31&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  数据库中存在的某一条数据的Id&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b0465c73-a7ab-4135-9bf8-4ec85ac6b1e2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Product p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
{
    Id &lt;/span&gt;=&lt;span&gt; id,
    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;娃哈哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    AddTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
    Price &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    Unit &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;瓶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
Console.WriteLine(ctx.Entry(p).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Detached&lt;/span&gt;
ctx.Products.Attach(p);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  这里报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;失败，在我对它进行追踪时就报错了。因为不能跟踪多个相同键的实体，就和数据库中主键重复冲突一样&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.InvalidOperationException: Attaching an entity of type '_2019011402.Entity.Product' failed because another entity of the same type already has the same primary key value. This can happen when using the 'Attach' method or setting the state of an entity to 'Unchanged' or 'Modified' if any entities in the graph have conflicting key values. This may be because some entities are new and have not yet received database-generated key values. In this case use the 'Add' method or the 'Added' entity state to track the graph and then set the state of non-new entities to 'Unchanged' or 'Modified' as appropriate.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;解决办法就是，去掉一个追踪，那么我们把该条数据查询出来，对它取消追踪，这个再跟踪这个新对象就可以了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_6cca0bda-9e4e-4db1-98b6-e1e2467283df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6cca0bda-9e4e-4db1-98b6-e1e2467283df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6cca0bda-9e4e-4db1-98b6-e1e2467283df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  全部属性更新  &lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro = ctx.Products.AsNoTracking().FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id));
Console.WriteLine(ctx.Entry(pro).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Detached&lt;/span&gt;
Product p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
{
    Id &lt;/span&gt;=&lt;span&gt; id,
    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;娃哈哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    AddTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
    Price &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    Unit &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;瓶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    FK_Order_Id &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;469b82be-8139-4e67-b566-5b2b5f6d838d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
ctx.Products.Attach(p);
ctx.Entry(p).State &lt;/span&gt;=&lt;span&gt; System.Data.Entity.EntityState.Modified;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.SaveChanges();
Console.WriteLine(res);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; result:1  ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后我贴一段代码，和主题没什么关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_a52f47d2-ecb3-4d91-afa6-00dfd00fa230&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a52f47d2-ecb3-4d91-afa6-00dfd00fa230&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a52f47d2-ecb3-4d91-afa6-00dfd00fa230&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我来声明两个变量查询数据库中的同一条记录，引用相等&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro2 = ctx.Products.FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id)); 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pro3 = ctx.Products.FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id));
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pro2_state:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ctx.Entry(pro2).State);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Unchanged&lt;/span&gt;
Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pro3_state:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ctx.Entry(pro3).State);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Unchanged&lt;/span&gt;
&lt;span&gt;
Console.WriteLine(ReferenceEquals(pro2, pro3));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  True&lt;/span&gt;
Test t1 = &lt;span&gt;new&lt;/span&gt; Test { Id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
Test t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Test { Id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
Console.WriteLine(ReferenceEquals(t1, t2));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接着看Update操作，如果我们只更新一个实体的部分属性呢?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_13d712c8-f886-4f08-8d43-ae11635f667c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_13d712c8-f886-4f08-8d43-ae11635f667c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_13d712c8-f886-4f08-8d43-ae11635f667c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  部分属性更新,少了name,unit&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro = ctx.Products.AsNoTracking().FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id));
Console.WriteLine(ctx.Entry(pro).State);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Detached&lt;/span&gt;
Product p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
{
    Id &lt;/span&gt;=&lt;span&gt; id,
    AddTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
    Price &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    FK_Order_Id &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;469b82be-8139-4e67-b566-5b2b5f6d838d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
ctx.Products.Attach(p);
ctx.Entry(p).State &lt;/span&gt;=&lt;span&gt; System.Data.Entity.EntityState.Modified;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.SaveChanges();
Console.WriteLine(res);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; result:1  ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;看看数据库中的情况&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116224626991-1358639965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的情况说明Modified是全部更新，不能部分更新&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;部分更新&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;那么怎么部分更新？书中给了两种办法&lt;/p&gt;
&lt;p&gt;1.手动指定更新属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_ce5938b0-5a1e-4059-906c-6e264424d02d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce5938b0-5a1e-4059-906c-6e264424d02d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce5938b0-5a1e-4059-906c-6e264424d02d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
ctx.Entry(p).Property(x =&amp;gt; x.Name).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
ctx.Entry(p).Property(x &lt;/span&gt;=&amp;gt; x.Unit).IsModified = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.用Entry().CurrentValues.SetValues() 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_52022cb0-62aa-495c-b603-0a1d24284c98&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_52022cb0-62aa-495c-b603-0a1d24284c98&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_52022cb0-62aa-495c-b603-0a1d24284c98&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  使用 Entry()..CurrentValues.SetValues()  方式&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pro = ctx.Products.FirstOrDefault(x =&amp;gt;&lt;span&gt; x.Id.Contains(id));
Product p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
{
    Id &lt;/span&gt;=&lt;span&gt; id,
    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;盆子2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;AddTime = new DateTime(1999, 2, 2),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Price = 3,&lt;/span&gt;
    Unit = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    FK_Order_Id &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;469b82be-8139-4e67-b566-5b2b5f6d838d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
ctx.Entry(pro).CurrentValues.SetValues(p);
ctx.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;但是我使用了之后，觉得不太好，也不知道是不是用错了，我遇到的问题是这样的，无法部分更新&lt;/p&gt;
&lt;p&gt;比如数据库中存在这么一条数据{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:25,&quot;FK_AddressId&quot;:&quot;234&quot;}，那么我现在只想更新Name,我就传递这个对象{&quot;name&quot;:&quot;赵四&quot;}，但是它还是全部更新&lt;/p&gt;
&lt;p&gt;比如我没有指定age属性，那么修改为默认值“0”，外键在数据库中不能为空，报错&lt;/p&gt;
&lt;p&gt;各位可以去弄一下&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;批量更新操作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;平时做批量更新，那就是遍历修改呗&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_080e1523-e74b-41c7-99a2-6c96ae168889&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_080e1523-e74b-41c7-99a2-6c96ae168889&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_080e1523-e74b-41c7-99a2-6c96ae168889&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; products =&lt;span&gt; ctx.Products.ToList();
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; products)
{
    item.Name &lt;/span&gt;= item.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}
ctx.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;看看EF生成并执行的SQL语句&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116231049592-2113789165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他会先把要更新的数据查询出来，然后逐条更新，如果你创建了存储过程，那么他会自动调用存储过程进行更新，这个性能会好一点&lt;/p&gt;
&lt;p&gt;我这里有一个存储过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116231318476-1484952878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后真正的SQL执行是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116231422865-767982373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他首先会将要更新的数据查询出来，然后调用多次存储过程&lt;/p&gt;
&lt;p&gt;还是觉得不太理想？那么作者告诉了我们一个更好的方案，使用第三方库：EntityFrameWork.Extended&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116231633407-439051367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引入命名空间：using EntityFramework.Extensions; 然后调用该Update方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_42045fa3-a038-4cd9-a5cc-e209ffb431df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_42045fa3-a038-4cd9-a5cc-e209ffb431df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_42045fa3-a038-4cd9-a5cc-e209ffb431df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; products = ctx.Products.Update(x =&amp;gt; &lt;span&gt;new&lt;/span&gt; Product { Name = x.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
ctx.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;捕获到SQL语句是这样的，很奇怪用ctx.Database.Log = Console.WriteLine;捕获不到，我用的SQL Profiler,这应该是这个Extended库是第三方的原因，不是EF团队弄的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0dda3db0-704a-446b-93c8-d01702311852&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0dda3db0-704a-446b-93c8-d01702311852&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0dda3db0-704a-446b-93c8-d01702311852&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tb_Products&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; 
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;CASE&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; (&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;) &lt;span&gt;THEN&lt;/span&gt; N&lt;span&gt;''&lt;/span&gt; &lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;END&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  
&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tb_Products&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; j0 &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; 
    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;C1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;, 
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Extent1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tb_Products&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Extent1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
) &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt; j1 &lt;span&gt;ON&lt;/span&gt; (j0.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; j1.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;看看数据库里面&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190116232343591-2146469794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;唉，也难怪别人都说EF性能不好，还有很多东西要学啊。&lt;/p&gt;

</description>
<pubDate>Wed, 16 Jan 2019 15:28:00 +0000</pubDate>
<dc:creator>张四海</dc:creator>
<og:description>要专业系统地学习EF前往《你必须掌握的Entity Framework 6.x与Core 2.0》这本书的作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/Creat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinshan-go/p/10280066.html</dc:identifier>
</item>
<item>
<title>redis - Sentinel 和 cluster - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10280009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10280009.html</guid>
<description>

&lt;h2&gt;引入&lt;/h2&gt;
&lt;p&gt;上回说到redis主从同步时，master（主库）如果宕机了怎么解决...&lt;/p&gt;
&lt;p&gt;我给出了一个手动解决的办法！&lt;/p&gt;
&lt;p&gt;但实际上，如果你配置了Sentinel，它能自动发现master宕机并且进行自动切换slave（从库）变master 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sentinel（哨兵）主要功能如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不时的监控redis是否良好运行，如果节点不可达就会对节点进行下线标识&lt;/li&gt;
&lt;li&gt;如果被标识的是主节点，sentinel就会和其他的sentinel节点“协商”，如果其他节点也人为主节点不可达，就会选举一个sentinel节点来完成自动故障转义&lt;/li&gt;
&lt;li&gt;在master-slave进行切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;安装配置&lt;/h2&gt;
&lt;p&gt;实验环境：CentOS7虚拟机一台&lt;/p&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;p&gt;　　一主（6379）两从（6380，6381）&lt;/p&gt;
&lt;p&gt;　　三个 sentinel 检测主节点（26379，26380，26381）&lt;/p&gt;
&lt;p&gt;存放位置自定义，运行程序时切换到改文件即可。&lt;/p&gt;
&lt;p&gt;在正式环境中，需按照公司需求，安装配置在不同的linux上。&lt;/p&gt;
&lt;p&gt;具体步骤请参考&lt;a href=&quot;https://www.cnblogs.com/peng104/p/10274857.html&quot; target=&quot;_blank&quot;&gt;上一篇博客&lt;/a&gt; 本篇博客不做详细讲解~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，先准备三个redis实例，&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c8a2fbdb-2e12-4c1b-8415-225a601c789c')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_c8a2fbdb-2e12-4c1b-8415-225a601c789c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c8a2fbdb-2e12-4c1b-8415-225a601c789c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c8a2fbdb-2e12-4c1b-8415-225a601c789c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c8a2fbdb-2e12-4c1b-8415-225a601c789c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
port 6379&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6379.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump-6379.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/redis/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-6379.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1d29c9de-de0d-46b8-913e-2c22f7578ed4')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_1d29c9de-de0d-46b8-913e-2c22f7578ed4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1d29c9de-de0d-46b8-913e-2c22f7578ed4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1d29c9de-de0d-46b8-913e-2c22f7578ed4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1d29c9de-de0d-46b8-913e-2c22f7578ed4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
port 6380&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6380.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump-6380.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/redis/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
slaveof &lt;/span&gt;127.0.0.1 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-6380.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('06477485-6432-4665-825b-7277c9b879a0')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_06477485-6432-4665-825b-7277c9b879a0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_06477485-6432-4665-825b-7277c9b879a0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('06477485-6432-4665-825b-7277c9b879a0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_06477485-6432-4665-825b-7277c9b879a0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
port 6381&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6381.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump-6381.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/redis/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
slaveof &lt;/span&gt;127.0.0.1 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-6381.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('999794df-05d4-4c5e-9a8a-db335c07f69b')&quot; readability=&quot;47&quot;&gt;&lt;img id=&quot;code_img_closed_999794df-05d4-4c5e-9a8a-db335c07f69b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_999794df-05d4-4c5e-9a8a-db335c07f69b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('999794df-05d4-4c5e-9a8a-db335c07f69b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_999794df-05d4-4c5e-9a8a-db335c07f69b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis 配置文件&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当配置中需要配置内存大小时，可以使用 1k, 5GB, 4M 等类似的格式，其转换方式如下(不区分大小写)&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 1k =&amp;gt; 1000 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1kb =&amp;gt; 1024 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1m =&amp;gt; 1000000 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1mb =&amp;gt; 1024*1024 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1g =&amp;gt; 1000000000 bytes&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1gb =&amp;gt; 1024*1024*1024 bytes&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 内存配置大小写是一样的.比如 1gb 1Gb 1GB 1gB&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; daemonize no 默认情况下，redis不是在后台运行的，如果需要在后台运行，把该项的值更改为yes&lt;/span&gt;
&lt;span&gt;daemonize yes

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当redis在后台运行的时候，Redis默认会把pid文件放在/var/run/redis.pid，你可以配置到其他地址。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当运行多个redis服务时，需要指定不同的pid文件和端口&lt;/span&gt;
pidfile /var/run/&lt;span&gt;redis.pid

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定redis运行的端口，默认是6379&lt;/span&gt;
port 6379

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定redis只接收来自于该IP地址的请求，如果不进行设置，那么将处理所有请求，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在生产环境中最好设置该项&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; bind 127.0.0.1&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Specify the path for the unix socket that will be used to listen for&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; incoming connections. There is no default, so Redis will not listen&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; on a unix socket when not specified.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; unixsocket /tmp/redis.sock&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; unixsocketperm 755&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 0是关闭此设置&lt;/span&gt;
&lt;span&gt;timeout 0

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定日志记录级别&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; debug    记录很多信息，用于开发和测试&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; varbose    有用的信息，不像debug会记录那么多&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; notice    普通的verbose，常用于生产环境&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; warning    只有非常重要或者严重的信息会记录到日志&lt;/span&gt;
&lt;span&gt;loglevel debug

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置log文件地址&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 默认值为stdout，标准输出，若后台模式会输出到/dev/null&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;logfile stdout&lt;/span&gt;
logfile /var/log/redis/&lt;span&gt;redis.log

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; To enable logging to the system logger, just set 'syslog-enabled' to yes,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; and optionally update the other syslog parameters to suit your needs.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; syslog-enabled no&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Specify the syslog identity.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; syslog-ident redis&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; syslog-facility local0&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可用数据库数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 默认值为16，默认数据库为0，数据库范围在0-（database-1）之间&lt;/span&gt;
databases 16

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################### 快照 #################################&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 保存数据到磁盘，格式如下:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 指出在多长时间内，有多少次更新操作，就将数据同步到数据文件rdb。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 相当于条件触发抓取快照，这个可以多个条件配合&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 比如默认配置文件中的设置，就设置了三个条件&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; save 900 1 900秒内至少有1个key被改变&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; save 300 10 300秒内至少有300个key被改变&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; save 60 10000 60秒内至少有10000个key被改变&lt;/span&gt;
&lt;span&gt;
save &lt;/span&gt;900 1&lt;span&gt;
save &lt;/span&gt;300 10&lt;span&gt;
save &lt;/span&gt;60 10000

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储至本地数据库时（持久化到rdb文件）是否压缩数据，默认为yes&lt;/span&gt;
&lt;span&gt;rdbcompression yes

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 本地持久化数据库文件名，默认值为dump.rdb&lt;/span&gt;
&lt;span&gt;dbfilename dump.rdb

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 工作目录&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 数据库镜像备份的文件放置的路径。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 这里的路径跟文件名要分开配置是因为redis在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成时，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; AOF文件也会存放在这个目录下面&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 注意这里必须制定一个目录而不是文件&lt;/span&gt;
dir ./

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################ 复制 #################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主从复制. 设置该数据库为其他数据库的从数据库. &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当master服务设置了密码保护时(用requirepass制定的密码)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; slav服务连接master的密码&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; masterauth &amp;lt;master-password&amp;gt;&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续相应客户端的请求&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2) 如果slave-serve-stale-data是指为no，出去INFO和SLAVOF命令之外的任何请求都会返回一个&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 错误&quot;SYNC with master in progress&quot;&lt;/span&gt;&lt;span&gt;
#
&lt;/span&gt;slave-serve-stale-&lt;span&gt;data yes

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从库会按照一个时间间隔向主库发送PINGs.可以通过repl-ping-slave-period设置这个时间间隔，默认是10秒&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; repl-ping-slave-period 10&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; repl-timeout 设置主库批量数据传输时间或者ping回复时间间隔，默认值是60秒&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 一定要确保repl-timeout大于repl-ping-slave-period&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; repl-timeout 60&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################# 安全 ###################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置客户端连接后进行任何其他指定前需要使用的密码。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 警告：因为redis速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150K次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; requirepass foobared&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 命令重命名.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 在一个共享环境下可以重命名相对危险的命令。比如把CONFIG重名为一个不容易猜测的字符。&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 举例:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 如果想删除一个命令，直接把它重命名为一个空字符&quot;&quot;即可，如下：&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; rename-command CONFIG &quot;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################## 约束 ####################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果设置 maxclients 0，表示不作限制。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; maxclients 128&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis同时也会移除空的list对象&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 注意：Redis新的vm机制，会把Key存放内存，Value会存放在swap区&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; maxmemory的设置比较适合于把redis当作于类似memcached的缓存来使用，而不适合当做一个真实的DB。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当把Redis当做一个真实的数据库使用的时候，内存使用将是一个很大的开销&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; maxmemory &amp;lt;bytes&amp;gt;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当内存达到最大值的时候Redis会选择删除哪些数据？有五种方式可供选择&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-lru -&amp;gt; 利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; allkeys-lru -&amp;gt; 利用LRU算法移除任何key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-random -&amp;gt; 移除设置过过期时间的随机key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; allkeys-&amp;gt;random -&amp;gt; remove a random key, any key &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-ttl -&amp;gt; 移除即将过期的key(minor TTL)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; noeviction -&amp;gt; 不移除任何可以，只是返回一个写错误&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 注意：对于上面的策略，如果没有合适的key可以移除，当写的时候Redis会返回一个错误&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 写命令包括: set setnx setex append&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; getset mset msetnx exec sort&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 默认是:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; maxmemory-policy volatile-lru&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)，随意你可以选择样本大小进行检测。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis默认的灰选择3个样本进行检测，你可以通过maxmemory-samples进行设置&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; maxmemory-samples 3&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################# AOF ###############################&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认情况下，redis会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 所以redis提供了另外一种更加高效的数据库备份及灾难恢复方式。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 开启append only模式之后，redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 但是这样会造成appendonly.aof文件过大，所以redis还支持了BGREWRITEAOF指令，对appendonly.aof 进行重新整理。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 你可以同时开启asynchronous dumps 和 AOF&lt;/span&gt;
&lt;span&gt;
appendonly no

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; AOF文件名称 (默认: &quot;appendonly.aof&quot;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; appendfilename appendonly.aof&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis支持三种同步AOF文件的策略:&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; no: 不进行同步，系统去操作 . Faster.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; always: always表示每次有写操作都进行同步. Slow, Safest.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; everysec: 表示对写操作进行累积，每秒同步一次. Compromise.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 默认是&quot;everysec&quot;，按照速度和安全折中这是最好的。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果想让Redis能更高效的运行，你也可以设置为&quot;no&quot;，让操作系统决定什么时候去执行&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 或者相反想让数据更安全你也可以设置为&quot;always&quot;&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 如果不确定就用 &quot;everysec&quot;.&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; appendfsync always&lt;/span&gt;
&lt;span&gt;appendfsync everysec
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; appendfsync no&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; AOF策略设置为always或者everysec时，后台处理进程(后台保存或者AOF日志重写)会执行大量的I/O操作&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在某些Linux配置中会阻止过长的fsync()请求。注意现在没有任何修复，即使fsync在另外一个线程进行处理&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 为了减缓这个问题，可以设置下面这个参数no-appendfsync-on-rewrite&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; This means that while another child is saving the durability of Redis is&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; the same as &quot;appendfsync none&quot;, that in pratical terms means that it is&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; possible to lost up to 30 seconds of log in the worst scenario (with the&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; default Linux settings).&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; &quot;no&quot; that is the safest pick from the point of view of durability.&lt;/span&gt;
no-appendfsync-on-&lt;span&gt;rewrite no

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Automatic rewrite of the append only file.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; AOF 自动重写&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当AOF文件增长到一定大小的时候Redis能够调用 BGREWRITEAOF 对日志文件进行重写 &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 它是这样工作的：Redis会记住上次进行些日志后文件的大小(如果从开机以来还没进行过重写，那日子大小在开机的时候确定)&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 同时需要指定一个最小大小用于AOF重写，这个用于阻止即使文件很小但是增长幅度很大也去重写AOF文件的情况&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 设置 percentage 为0就关闭这个特性&lt;/span&gt;
&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-percentage 100&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-min-&lt;span&gt;size 64mb

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################# SLOW LOG ###################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis Slow Log 记录超过特定执行时间的命令。执行时间不包括I/O计算比如连接客户端，返回结果等，只是命令执行时间&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 可以通过两个参数设置slow log：一个是告诉Redis执行超过多少时间被记录的参数slowlog-log-slower-than(微妙)，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 另一个是slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面的时间以微妙微单位，因此1000000代表一分钟。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 注意制定一个负数将关闭慢日志，而设置为0将强制每个命令都会记录&lt;/span&gt;
slowlog-log-slower-than 10000

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对日志长度没有限制，只是要注意它会消耗内存&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 可以通过 SLOWLOG RESET 回收被慢日志消耗的内存&lt;/span&gt;
slowlog-max-len 1024

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################### VM ###############################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## WARNING! Virtual Memory is deprecated in Redis 2.4&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;## The use of Virtual Memory is strongly discouraged.&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Virtual Memory allows Redis to work with datasets bigger than the actual&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; amount of RAM needed to hold the whole dataset in memory.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; In order to do so very used keys are taken in memory while the other keys&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; are swapped into a swap file, similarly to what operating systems do&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; with memory pages.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; To enable VM just set 'vm-enabled' to yes, and set the following three&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; VM parameters accordingly to your needs.&lt;/span&gt;
&lt;span&gt;
vm&lt;/span&gt;-&lt;span&gt;enabled no
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vm-enabled yes&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; This is the path of the Redis swap file. As you can guess, swap files&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; can't be shared by different Redis instances, so make sure to use a swap&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; file for every redis process you are running. Redis will complain if the&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; swap file is already in use.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; The best kind of storage for the Redis swap file (that's accessed at random) &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; is a Solid State Disk (SSD).&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; *** WARNING *** if you are using a shared hosting the default of putting&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; the swap file under /tmp is not secure. Create a dir with access granted&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; only to Redis user and configure Redis to create the swap file there.&lt;/span&gt;
vm-swap-file /tmp/&lt;span&gt;redis.swap

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; vm-max-memory configures the VM to use at max the specified amount of&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; RAM. Everything that deos not fit will be swapped on disk *if* possible, that&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; is, if there is still enough contiguous space in the swap file.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; With vm-max-memory 0 the system will swap everything it can. Not a good&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; default, just specify the max amount of RAM you can in bytes, but it's&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; better to leave some margin. For instance specify an amount of RAM&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; that's more or less between 60 and 80% of your free RAM.&lt;/span&gt;
vm-max-&lt;span&gt;memory 0

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis swap files is split into pages. An object can be saved using multiple&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; contiguous pages, but pages can't be shared between different objects.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; So if your page is too big, small objects swapped out on disk will waste&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; a lot of space. If you page is too small, there is less space in the swap&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; file (assuming you configured the same number of total swap file pages).&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; If you use a lot of small objects, use a page size of 64 or 32 bytes.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; If you use a lot of big objects, use a bigger page size.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; If unsure, use the default :)&lt;/span&gt;
vm-page-size 32

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Number of total memory pages in the swap file.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Given that the page table (a bitmap of free/used pages) is taken in memory,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; every 8 pages on disk will consume 1 byte of RAM.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; The total swap size is vm-page-size * vm-pages&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; With the default of 32-bytes memory pages and 134217728 pages Redis will&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; use a 4 GB swap file, that will use 16 MB of RAM for the page table.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; It's better to use the smallest acceptable value for your application,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; but the default is large in order to work in most conditions.&lt;/span&gt;
vm-pages 134217728

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Max number of VM I/O threads running at the same time.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; This threads are used to read/write data from/to swap file, since they&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; also encode and decode objects from disk to memory or the reverse, a bigger&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; number of threads can help with big objects even if they can't help with&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; I/O itself as the physical device may not be able to couple with many&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; reads/writes operations at the same time.&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; The special value of 0 turn off threaded I/O and enables the blocking&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Virtual Memory implementation.&lt;/span&gt;
vm-max-threads 4

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################## ADVANCED CONFIG ###############################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当hash中包含超过指定元素个数并且最大的元素没有超过临界时，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; hash将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。&lt;/span&gt;
hash-max-zipmap-entries 512&lt;span&gt;
hash&lt;/span&gt;-max-zipmap-value 64

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; list数据类型多少节点以下会采用去指针的紧凑存储格式。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; list数据类型节点值大小小于多少字节会采用紧凑存储格式。&lt;/span&gt;
list-max-ziplist-entries 512&lt;span&gt;
list&lt;/span&gt;-max-ziplist-value 64

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; set数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。&lt;/span&gt;
set-max-intset-entries 512

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; zsort数据类型多少节点以下会采用去指针的紧凑存储格式。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; zsort数据类型节点值大小小于多少字节会采用紧凑存储格式。&lt;/span&gt;
zset-max-ziplist-entries 128&lt;span&gt;
zset&lt;/span&gt;-max-ziplist-value 64

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; 如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存&lt;/span&gt;
&lt;span&gt;activerehashing yes

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################# INCLUDES ###################################&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; include /path/to/local.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; include /path/to/other.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;附：redis.conf详解&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，启动三个数据库实例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-server  redis-6379.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server  redis-6380.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server  redis-6381.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，准备三个哨兵文件，监控主从架构&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('46dae53b-5078-4945-85a0-7e93cf446dfd')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_46dae53b-5078-4945-85a0-7e93cf446dfd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_46dae53b-5078-4945-85a0-7e93cf446dfd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('46dae53b-5078-4945-85a0-7e93cf446dfd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_46dae53b-5078-4945-85a0-7e93cf446dfd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
//&lt;span&gt; Sentinel节点的端口
port &lt;/span&gt;26379&lt;span&gt;  
dir &lt;/span&gt;/var/redis/data/&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;26379.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

// 当前Sentinel节点监控 127.0.0.1:6379&lt;span&gt; 这个主节点
&lt;/span&gt;//&lt;span&gt; 2代表判断主节点失败至少需要2个Sentinel节点节点同意
&lt;/span&gt;//&lt;span&gt; mymaster是主节点的别名
sentinel monitor qsmaster  &lt;/span&gt;127.0.0.1 6379 2

//&lt;span&gt;每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒30s且没有回复，则判定不可达
sentinel down&lt;/span&gt;-after-milliseconds qsmaster 30000

//&lt;span&gt;当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，
原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1
sentinel parallel&lt;/span&gt;-syncs qsmaster 1

//&lt;span&gt;故障转移超时时间为180000毫秒
sentinel failover&lt;/span&gt;-timeout qsmaster 180000

//&lt;span&gt;后台运行服务端
daemonize yes &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-26379.conf&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;注意：避免冲突，复制前删除注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3c282f37-2668-4057-83d8-82e81dee81b2')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3c282f37-2668-4057-83d8-82e81dee81b2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3c282f37-2668-4057-83d8-82e81dee81b2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3c282f37-2668-4057-83d8-82e81dee81b2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3c282f37-2668-4057-83d8-82e81dee81b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
port 26380&lt;span&gt;  
dir &lt;/span&gt;/var/redis/data/&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;26380.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
sentinel monitor qsmaster  &lt;/span&gt;127.0.0.1 6379 2&lt;span&gt;
sentinel down&lt;/span&gt;-after-milliseconds qsmaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs qsmaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout qsmaster 180000&lt;span&gt;
daemonize yes &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-26380.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('93062297-d2d2-47f6-aa03-dadd9dfbf7bf')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_93062297-d2d2-47f6-aa03-dadd9dfbf7bf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_93062297-d2d2-47f6-aa03-dadd9dfbf7bf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('93062297-d2d2-47f6-aa03-dadd9dfbf7bf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_93062297-d2d2-47f6-aa03-dadd9dfbf7bf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
port 26381&lt;span&gt;  
dir &lt;/span&gt;/var/redis/data/&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;26381.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
sentinel monitor qsmaster  &lt;/span&gt;127.0.0.1 6379 2&lt;span&gt;
sentinel down&lt;/span&gt;-after-milliseconds qsmaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs qsmaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout qsmaster 180000&lt;span&gt;
daemonize yes &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;redis-26381.conf&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4，分别启动三个哨兵实例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-sentinel redis-26379.conf &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-sentinel redis-26380.conf &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-sentinel redis-26381.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意: 如果发现不成功，需要删掉所有的哨兵配置文件，从新来过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5，检查哨兵状态是否正常，&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-cli -p 26379 info sentinel  # 查看配置&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置如下表示正常&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Sentinel&lt;/span&gt;
sentinel_masters:1&lt;span&gt;
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name&lt;/span&gt;=qsmaster,status=ok,address=127.0.0.1:6380,slaves=2,sentinels=3
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 哨兵主节点名字叫做mymaster，状态ok，监控地址是127.0.0.1:6379，有两个从节点，3个哨兵&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;故障实验&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;大致思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;杀掉主节点的redis进程6379端口，观察从节点是否会进行新的master选举，进行切换&lt;/li&gt;
&lt;li&gt;重新恢复旧的“master”节点，查看此时的redis身份&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1，首先查看三个redis的进程状态&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ps -ef|grep redis
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，干掉master ， 然后等待其他俩个节点是否自动被哨兵切换主从身份&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kill 进程pid  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;干掉master进程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190116222632999-1652781929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，再查看另外两个slave的状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　发现其中一个节点变为主节点（随机的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，然后再开启主节点6379，检查三个节点的复制身份状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　此时，6379状态已经变成 slave 了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_d831fd75-340e-41e1-9ef4-ccc794561907&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;第一个&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_e174f213-672a-49f2-b7e5-e587ee731933&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;第二个&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_7d0eac2b-17e7-461d-822a-1b4dc2e69fa7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;第三个&lt;/span&gt;&lt;/div&gt;


&lt;h2&gt;引入&lt;/h2&gt;
&lt;p&gt;　　1，redis官方生成可以达到 10万/每秒,每秒执行10万条命令。&lt;/p&gt;
&lt;p&gt;　　　　假如业务需要每秒100万的命令执行呢？&lt;/p&gt;
&lt;p&gt;　　1，一台服务器内存正常是16~256G。&lt;/p&gt;
&lt;p&gt;　　　　假如你的业务需要500G内存，那怎么办？&lt;/p&gt;
&lt;p&gt;正确的应该是考虑分布式，加机器，把数据分到不同的位置，分摊集中式的压力，&lt;strong&gt;一堆机器做一件事&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;cluster实例及配置&lt;/h2&gt;
&lt;p&gt;使用方式： 官方提供通过ruby语言的脚本一键安装&lt;/p&gt;
&lt;h3&gt;1，环境配置&lt;/h3&gt;
&lt;p&gt;redis支持多实例的功能，我们在单机演示集群搭建，需要6个实例，三个是主节点，三个是从节点，数量为6个节点才能保证高可用的集群。&lt;/p&gt;
&lt;p&gt;通过配置，开启redis-cluster&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port 7000&lt;span&gt;
daemonize yes
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/redis/data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7000.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump-7000.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
cluster&lt;/span&gt;-enabled yes   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开启集群模式&lt;/span&gt;
cluster-config-file nodes-7000.conf　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集群内部的配置文件&lt;/span&gt;
cluster-require-full-coverage no　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis cluster需要16384个slot都正常的时候才能对外提供服务，换句话说，只要任何一个slot异常那么整个cluster不对外提供服务。 因此生产环境一般为no&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;每个节点仅仅是端口运行的不同！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost /opt/redis/config 17:12:30]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;
redis-7000.conf  redis-7002.conf  redis-7004&lt;span&gt;.conf
redis&lt;/span&gt;-7001.conf  redis-7003.conf  redis-7005&lt;span&gt;.conf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;确保每个配置文件中的端口修改！！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2，分别运行redis实例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-server redis-7000.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7001.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7002.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7003.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7004.conf&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; redis-server redis-7005.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：此时集群还不可用&lt;/p&gt;
&lt;h3&gt;3，准备ruby的编程环境&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.下载ruby的源码包&lt;/span&gt;
wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1&lt;span&gt;.tar.gz

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.解压缩ruby源码&lt;/span&gt;
tar -xvf ruby-2.3.1&lt;span&gt;.tar.gz

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.进入ruby源码包，配置安装位置&lt;/span&gt;
./configure --prefix=/opt/ruby/

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.开始编译且编译安装&lt;/span&gt;
make &amp;amp;&amp;amp;&lt;span&gt; make install

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.配置ruby的环境变量&lt;/span&gt;
vim /etc/&lt;span&gt;profile 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入如下配置&lt;/span&gt;
PATH=$PATH:/opt/ruby/&lt;span&gt;bin 
      &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4，安装ruby操作redis的模块&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.下载ruby操作redis的模块&lt;/span&gt;
wget http://rubygems.org/downloads/redis-3.3&lt;span&gt;.0.gem

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.安装&lt;/span&gt;
gem install -l redis-3.3&lt;span&gt;.0.gem

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.搜索创建redis集群的命令&lt;/span&gt;
find /opt  -name  redis-&lt;span&gt;trib.rb
&lt;/span&gt;/opt/redis-4.0.10/src/redis-trib.rb  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索结果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5，一键创建redis集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; replicas 1 --代表每个主节点，有一个从节点&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集群自动分配主从关系，默认：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 7000，7001，7001 为主库&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;  7003，7004，7005 为从库&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6，查看集群状态&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
redis-cli -p 7000&lt;span&gt; cluster info  

redis&lt;/span&gt;-cli -p 7000 cluster nodes  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等同于查看nodes-7000.conf文件节点信息&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集群主节点状态&lt;/span&gt;
redis-cli -p 7000 cluster nodes |&lt;span&gt; grep master
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 集群从节点状态&lt;/span&gt;
redis-cli -p 7000 cluster nodes | grep slave
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6，开启集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-cli -p 7000  -&lt;span&gt;c  
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -p  指定数据库端口&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -c  指定开启集群模式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7，测试写入集群数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
127.0.0.1:7000&amp;gt;&lt;span&gt; set name peng     
&lt;/span&gt;-&amp;gt; Redirected to slot [5798] located at 127.0.0.1:7001&lt;span&gt;       
OK
&lt;/span&gt;127.0.0.1:7001&amp;gt;&lt;span&gt; exit
[root@yugo &lt;/span&gt;/opt/redis/src 18:46:07]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;redis-cli -c -p 7000&lt;/span&gt;
127.0.0.1:7000&amp;gt;&lt;span&gt; ping
PONG
&lt;/span&gt;127.0.0.1:7000&amp;gt; keys *&lt;span&gt;
(empty list &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt; set)
&lt;/span&gt;127.0.0.1:7000&amp;gt;&lt;span&gt; get name
&lt;/span&gt;-&amp;gt; Redirected to slot [5798] located at 127.0.0.1:7001
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;peng&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;集群已经搭建完毕啦！！！&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:14:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>redis哨兵集群 引入 上回说到redis主从同步时，master（主库）如果宕机了怎么解决... 我给出了一个手动解决的办法！ 但实际上，如果你配置了Sentinel，它能自动发现master宕机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10280009.html</dc:identifier>
</item>
<item>
<title>03 Java 虚拟机是如何加载 Java 类的 - 黑_子</title>
<link>http://www.cnblogs.com/yuepenglei/p/10279996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuepenglei/p/10279996.html</guid>
<description>&lt;h4 id=&quot;java-引用类型&quot;&gt;Java 引用类型&lt;/h4&gt;
&lt;p&gt;Java 中的引用类型细分为四种：类，接口，数组类和泛型参数。&lt;/p&gt;
&lt;p&gt;因为泛型参数会在编译过程中被擦除，所以 Java 虚拟机实际上只有前三种。数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。&lt;/p&gt;
&lt;p&gt;无论是数组类还是其他两种类型，Java 虚拟机都需要对其进行链接和初始化。&lt;/p&gt;
&lt;h4 id=&quot;加载&quot;&gt;加载&lt;/h4&gt;
&lt;p&gt;加载就是查找字节流，然后据此创建类的过程。数组类由 Java 虚拟机直接生成，其他类则需要 Java 虚拟机借助类加载器来完成查找字节流的过程。&lt;/p&gt;
&lt;p&gt;类加载器有很多种，除了启动类加载器以外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器都需要先由其他类加载器比如说启动类加载器加载到 Java 虚拟机中，方能执行类加载。&lt;/p&gt;
&lt;p&gt;双亲委派机制：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。如果父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。&lt;/p&gt;
&lt;p&gt;在 Java 9 之前，启动类加载器负责加载最基础最重要的类。除了启动类加载器之外，还有扩展类加载器和应用类加载器，均由 Java 核心类库提供。&lt;/p&gt;
&lt;p&gt;扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要但通用的类。&lt;/p&gt;
&lt;p&gt;应用类加载器的父类加载器是扩展类加载器。它负责加载应用程序路径下的类。&lt;/p&gt;
&lt;p&gt;Java 9 中扩展类加载器被改名为平台类加载器。Java SE 中除了少数几个关键模块是由启动类加载器加载之外，其他模块均由平台类加载器所加载。&lt;/p&gt;
&lt;p&gt;在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。&lt;/p&gt;
&lt;h4 id=&quot;链接&quot;&gt;链接&lt;/h4&gt;
&lt;p&gt;链接是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可以分为：验证，准备和解析三个阶段。&lt;/p&gt;
&lt;p&gt;验证阶段：确保加载类能够满足 Java 虚拟机的约束条件。通常情况下，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。（除了字节码注入）&lt;/p&gt;
&lt;p&gt;准备阶段：为被加载类的静态字段分配内存，初始化则会在初始化阶段进行。部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。&lt;/p&gt;
&lt;p&gt;在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类以及其方法和字段所对应的具体地址，甚至不知道自己方法和字段的地址。当需要引用这些成员时，Java 编译器会生成一个符号引用，在运行阶段这些符号引用会定位到具体目标上。&lt;/p&gt;
&lt;p&gt;解析阶段就是将这些符号引用解析成为实际引用。&lt;/p&gt;
&lt;p&gt;Java 虚拟机规定：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。也就是说，在链接过程中不要求一定解析完成。&lt;/p&gt;
&lt;h4 id=&quot;初始化&quot;&gt;初始化&lt;/h4&gt;
&lt;p&gt;在 Java 代码中，初始化一个静态字段，可以声明时赋值，也可以在静态代码块中赋值。&lt;/p&gt;
&lt;p&gt;如果被赋值的静态字段被 final 修饰，并且它是基本类型或者字符串时，那么该字段便会被 Java 编译器标记成常量值，其初始化直接由 Java 虚拟机完成。除此之外的直接复制操作每一集静态代码块中的代码，都会被 Java 编译器置于同一方法中，命名为&lt;/p&gt;
&lt;p&gt;类的初始化，就是为标记常量的字段赋值，以及执行&lt;/p&gt;
&lt;p&gt;举例一下情况会触发类的初始化：&lt;br/&gt;1：虚拟机启动时，初始化用户指定的主类。&lt;br/&gt;2：遇到 new 指令时，初始化 new 指令的目标类。&lt;br/&gt;3：当遇到调用静态方法的指令时，初始化该静态方法所在的类。&lt;br/&gt;4：当遇到访问静态字段的指令时，初始化该静态方法所在的类。&lt;br/&gt;5：子类的初始化会触发父类的初始化。&lt;br/&gt;6：如果一个接口定义了 default 方法，那么实现该接口的类初始化时，会触发接口的初始化。&lt;br/&gt;7：使用反射 API 对某个类进行反射调用时，初始化该类。&lt;/p&gt;
&lt;h4 id=&quot;问答&quot;&gt;问答&lt;/h4&gt;
&lt;h6 id=&quot;q新建类和新建类的数组初始化过程&quot;&gt;Q：新建类，和新建类的数组，初始化过程&lt;/h6&gt;
&lt;p&gt;新建类的时候，需要加载，链接和初始化。新建类的数组的时候，由于并没有使用类，所以只需要加载该类。如果需要使用该类了，在执行类的链接和初始化。&lt;/p&gt;
&lt;h6 id=&quot;q类的初始化和实例的初始化区别初始化后的类存储在什么地方&quot;&gt;Q：类的初始化和实例的初始化区别，初始化后的类存储在什么地方&lt;/h6&gt;
&lt;p&gt;类的初始化只有一次，通过类的加载链接生成对应的数据结构，存储在元空间。实例的初始化可以有多次。&lt;/p&gt;
&lt;h6 id=&quot;q类中的静态字段如果没有被-jvm-标记为常量那么如何分配内存&quot;&gt;Q：类中的静态字段，如果没有被 JVM 标记为常量，那么如何分配内存&lt;/h6&gt;
&lt;p&gt;加载类的过程，都会分配内存，只是初始化的时候不一样：一个是在 JVM 中直接复制，一个是在 clinit 方法中复制。&lt;/p&gt;
&lt;h6 id=&quot;q-clinit-执行时的锁是什么锁跟-synchronized-一样吗&quot;&gt;Q clinit 执行时的锁，是什么锁，跟 synchronized 一样吗&lt;/h6&gt;
&lt;p&gt;clinit 执行时的锁是虚拟机内部锁，和 synchronized 不一样。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文创作灵感来源于 极客时间 郑雨迪老师的《深入拆解 Java 虚拟机》课程，通过课后反思以及借鉴各位学友的发言总结，现整理出自己的知识架构，以便日后温故知新，查漏补缺。&lt;/p&gt;
&lt;h4 id=&quot;关注本人公众号第一时间获取最新文章发布每日更新一篇技术文章&quot;&gt;关注本人公众号，第一时间获取最新文章发布，每日更新一篇技术文章。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562380/201901/1562380-20190113225450069-1906096752.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>黑_子</dc:creator>
<og:description>Java 引用类型 Java 中的引用类型细分为四种：类，接口，数组类和泛型参数。 因为泛型参数会在编译过程中被擦除，所以 Java 虚拟机实际上只有前三种。数组类是由 Java 虚拟机直接生成的，其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuepenglei/p/10279996.html</dc:identifier>
</item>
<item>
<title>浅谈c#垃圾回收机制（GC） - micDavid</title>
<link>http://www.cnblogs.com/wangqiang3311/p/10280000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangqiang3311/p/10280000.html</guid>
<description>&lt;p&gt;写了一个window服务，循环更新sqlite记录，内存一点点稳步增长。三天后，内存溢出。于是，我从自己的代码入手，查找到底哪儿占用内存释放不掉，最终明确是调用servicestack.ormlite更新sqlite数据库造成的。至于是不是框架问题，可能性不大，因为本地模拟执行的代码没有任何问题。我觉得应该是orm在执行数据库更新后，对象还在被引用造成的。这里，我贴出一个伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放对象的一个列表&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; List&amp;lt;Record&amp;gt; data=&lt;span&gt;new&lt;/span&gt; List&amp;lt;Record&amp;gt;(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
    
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; models =  ReadDB(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
   data.AddRange(models);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新model对象的字段&lt;/span&gt;&lt;span&gt;
   Dbhelp.UpdateAll(models);&lt;br/&gt;data.Clear();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的猜测到底对不对呢？现在还不知道。不过在探寻答案的时候，对GC的相关机制详细地了解了一遍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110779/201901/110779-20190116215435177-1156444218.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、什么是GC？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官网中有这么一句话：&lt;/p&gt;
&lt;p&gt;The garbage collector is a common language runtime component that controls the allocation and release of managed memory。&lt;/p&gt;
&lt;p&gt;原来GC是CLR的一个组件，它控制内存的分配与释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、托管堆和CLR堆管理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道c#中的引用类型，分配在堆上。所谓的堆，就是一大块连续的内存地址。CLR堆管理器负责内存的分配、释放。堆又分为小对象堆和大对象堆。它的内存分配流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110779/201901/110779-20190116221303847-920638576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                  图片来源《.NET高级调试》pdf&lt;/p&gt;
&lt;p&gt;CLR加载时，就会分配堆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 三、GC的工作机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;GC有三个假设：&lt;/p&gt;
&lt;p&gt;1、如果没有特别声明，所有的对象都是垃圾（通过引用追踪对象是否为垃圾）&lt;/p&gt;
&lt;p&gt;2、假设托管堆上所有的对象的活跃时间都是短暂的（相对于长久活跃的对象来说，GC将更频繁地收集短暂活跃的对象）&lt;/p&gt;
&lt;p&gt;3、通过代跟踪对象的持续时间&lt;/p&gt;
&lt;p&gt;以下是官方文档给出的和这三个假设一致&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;The garbage collector in the common language runtime supports object aging using generations&lt;/p&gt;
&lt;p&gt;Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle. &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Objects in the most recent generation are in generation 0. This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;每代都有自己的堆，假如0代的堆满了，就会触发GC，然后把依然有引用的对象升级，放到1代对象。最后压缩堆，把剩余的堆空间合并到一块。1代对象也是如此操作。但到了2代，就处理不同了。2代的堆可能是大对象堆，它的压缩代价过于高昂，所以只是合并相邻的空间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110779/201901/110779-20190116223741347-863532123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                                                    图片来源博客园&lt;strong&gt;c#技术漫谈之垃圾回收（GC）&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; GC发生的时机，就是相应的堆达到了阈值，因为堆也有大小限制，并不是无限的。尽管2代堆或者大对象堆满的时候，通过增加新的内存段来满足内存分配，如果没有可用的内存，这时就会报内存溢出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、GC不能释放非托管资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种情况，第一种：托管代码引用了非托管资源，比如文件操作、数据库连接、网络连接等。这时候必须手动释放，或实现&lt;strong&gt; &lt;/strong&gt;dispose模式，或实现对象终结&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;In most cases, finalizers are implemented by overriding the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.finalize?view=netframework-4.7.2&quot;&gt;Object.Finalize&lt;/a&gt; method; however, types written in C# or C++ implement &lt;strong&gt;destructors&lt;/strong&gt;, which compilers turn into an override of &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.finalize?view=netframework-4.7.2&quot;&gt;Object.Finalize&lt;/a&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;必须注意的一点是，实现对象终结器，GC会在释放对象之前自动调用。其实这是一个代价非常高昂的备用机制。所以能自己释放非托管资源的，就自己释放。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果一个对象中包含有终结器，那么在new的时候放入到终结者队列。当GC会把这个对象标为垃圾时，放入到另一个队列F-Reachable中。这个队列包含了所有带有终结器并且将被作为垃圾收集的对象，这些对象的终结器都将被执行。在垃圾收集的过程总并不会执行终结器代码。而是由.NET 进程的终结线程调用。因此，此时的垃圾回收滞后一段时间，目的在于等待终结器代码执行的完成。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;五、dispose模式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseClass : IDisposable
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Flag: Has Dispose already been called?&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; disposed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Public implementation of Dispose pattern callable by consumers.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       Dispose(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       GC.SuppressFinalize(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);           
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Protected implementation of Dispose pattern.&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; disposing)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposed)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       
&lt;span&gt;21&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposing) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Free any other managed objects here.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       
&lt;span&gt;26&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Free any unmanaged objects here.
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       disposed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;    ~&lt;span&gt;BaseClass()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;       Dispose(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Win32.SafeHandles;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.InteropServices;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DerivedClass : BaseClass
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Flag: Has Dispose already been called?&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; disposed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate a SafeHandle instance.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;    SafeHandle handle = &lt;span&gt;new&lt;/span&gt; SafeFileHandle(IntPtr.Zero, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Protected implementation of Dispose pattern.&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; disposing)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposed)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       
&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposing) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         handle.Dispose();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Free any other managed objects here.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;          &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       
&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Free any unmanaged objects here.
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;       disposed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Call base class implementation.&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;       &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.Dispose(disposing);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是基类和子类的dispose模式，来源于官网。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>micDavid</dc:creator>
<og:description>写了一个window服务，循环更新sqlite记录，内存一点点稳步增长。三天后，内存溢出。于是，我从自己的代码入手，查找到底哪儿占用内存释放不掉，最终明确是调用servicestack.ormlite</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangqiang3311/p/10280000.html</dc:identifier>
</item>
<item>
<title>我的2018前端踩坑集锦 - ChessZhang</title>
<link>http://www.cnblogs.com/yugege/p/10279990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yugege/p/10279990.html</guid>
<description>&lt;p&gt;某著名小白说过 ：世上本来到处都是坑，只要走的人多了，也就把坑都给埋了。该小白还说过：坑本身并不可怕，可怕的是踩了一次之后，还第二、第三次踩到了相同的坑。&lt;/p&gt;
&lt;p&gt;所谓&quot;坑&quot;，主要是由于我们对某些知识点理解不够透彻，导致在应用的时出现了一些奇怪的问题。因为我们每个人，对于某个知识点的理解程度不一样，所以，有些坑我觉得真的很坑，但是你可能觉得一点都不坑，因为你早就对它了如指掌了。&lt;/p&gt;
&lt;p&gt;这里列举的一些坑，都是我过去一年在项目中所遇到过的，并当时在笔记中记录下来的，现在稍加整理就形成了这篇博客，以供日后查阅。&lt;/p&gt;
&lt;p&gt;不知不觉，开头又bb了这么多，还是赶紧进入正题哈。&lt;/p&gt;
&lt;h3 id=&quot;设置透明度opacity引起的惨案&quot;&gt;1. 设置透明度（opacity）引起的惨案&lt;/h3&gt;
&lt;p&gt;之前做炉石盒子的天梯环境页面，地址是 &lt;a href=&quot;https://hs.gameyw.netease.com/box_statistics.html&quot;&gt;炉石天梯环境&lt;/a&gt; ，就在项目做得差不多的时候，准备上线了， QA 突然发现了如下的一个 bug:&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685713e774598ee?w=107&amp;amp;h=190&amp;amp;f=png&amp;amp;s=29846&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一个选择排序方式的下拉菜单，它的定位是 &lt;code&gt;position: absolute&lt;/code&gt;，正常来说，它应该会覆盖在其他元素之上的，可是为什么 &lt;code&gt;0.14%&lt;/code&gt; 反而会覆盖在它上面呢？ 在代码中找了好久，那个 &lt;code&gt;0.14%&lt;/code&gt; 并没有设置 &lt;code&gt;z-index&lt;/code&gt;属性，也没有 &lt;code&gt;position： absolute&lt;/code&gt; 这样的东西，真是好郁闷哦。后来到 mdn 查文档才发现，原来是 &lt;code&gt;opacity&lt;/code&gt;属性引起 的： &lt;code&gt;opacity 属性值小于 1 的元素会创建新的层叠上下文&lt;/code&gt; 。因为当时我有个偷懒的做法，字体继承的颜色是 &lt;code&gt;#666&lt;/code&gt;, 我想让 &lt;code&gt;0.14%&lt;/code&gt; （天梯比率）颜色变浅一些，直接加了个 &lt;code&gt;opacity: 0.6&lt;/code&gt; ，导致了创建了新的层叠上下文，层级比下拉菜单高了，所以就覆盖在了上面。具体什么是层叠上下文，以及哪些属性会创建新的层叠上下文，这里也不介绍了有需要的可以参考一下 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context&quot;&gt;层叠上下文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然上面描述得已经很详细了，但是可能由于我的表达能力不太好，有些朋友还不是很明白我的意思，可以看一下这里的 demo 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;menu&quot;&amp;gt;
  &amp;lt;div class=&quot;title&quot;&amp;gt;下拉菜单&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;menu-list&quot;&amp;gt;
    &amp;lt;div class=&quot;item&quot;&amp;gt;菜单1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;item&quot;&amp;gt;菜单2&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;item&quot;&amp;gt;菜单3&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;content&quot;&amp;gt;
  我是半透明的文字，可以覆盖在下拉菜单之上哦~
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
  .menu {
    position: relative;
  }
  .menu-list {
    display: none;
    position: absolute;
    background: #ccc;
  }
  .menu:hover .menu-list {
    display: block;
  }
  .content {
    opacity: 0.6;
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将鼠标移动到下拉菜单上，就会发现文字会发生重叠了：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685715a85978e8a?w=385&amp;amp;h=121&amp;amp;f=png&amp;amp;s=8914&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那这个坑有什么解决办法呢？最简单的就是下拉菜单添加个属性 &lt;code&gt;z-index： 1&lt;/code&gt; 。另外，这里再啰嗦一下，就是&lt;code&gt;z-index&lt;/code&gt;的值不要乱设置。以前刚刚接触前端时，会经常看一些视频教程，看到里面讲师动不动就设置个 &lt;code&gt;z-index: 999&lt;/code&gt; 之类的特别大的数值。这是一个不好的习惯。张鑫旭老师在《CSS世界》一书中，提到了 &lt;code&gt;不三原则&lt;/code&gt;，就是说一般情况下，&lt;code&gt;z-index&lt;/code&gt;的值不要超过3，基本能满足大多数的需求了。&lt;/p&gt;
&lt;h3 id=&quot;flex布局子项溢出后无法查看全部内容&quot;&gt;2. flex布局：子项溢出后无法查看全部内容&lt;/h3&gt;
&lt;p&gt;之前做漫画阅读器，因为漫画可能有长图片，也可能有短图片。长图片可以滚动查看，短图片就居中显示。所以，很自然会想到用 &lt;code&gt;flex&lt;/code&gt; 布局来实现。简单的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;app&quot;&amp;gt;
  &amp;lt;img src=&quot;https://m.tuniucdn.com/fb2/t1/G1/M00/F1/51/Cii9EFkAaZ-IRgGNAATB18ldk0UAAJzuQN-p1cABMHv15.jpeg&quot; alt=&quot;&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;

  html,
  body {
    height: 100%;
  }

  .app {
    display: flex;
    height: 100%;
    justify-content: center;
    align-items: center;
  }

  img {
    width: 100%;
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们的&lt;code&gt;.app&lt;/code&gt; 容器里面这里有一张很长的图片。当我们运行上面的代码，如果你仔细观察原图和页面显示的图片，就会发现图片的顶部和底部的一些内容看不到了，滚动条到了一定位置就无法滚动了。正常来说，我们应该可以通过滚动条的上下滑动看到图片的全部内容才对的。当时我想了很久也没有想出来原因，最后到 stackoverflow 找到了答案 &lt;a href=&quot;https://stackoverflow.com/questions/33454533/cant-scroll-to-top-of-flex-item-that-is-overflowing-container&quot;&gt;Can't scroll to top of flex item that is overflowing container&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;答案中有提到，可以设置子项的 &lt;code&gt;margin: auto&lt;/code&gt; 来实现内容溢出时也自动居中（包括水平和垂直的）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/168571653642b293?w=700&amp;amp;h=369&amp;amp;f=png&amp;amp;s=30848&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改后的 CSS 代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .app {
    display: flex;
    height: 100%;
  }

  img {
    width: 100%;
    margin: auto;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，以后如果在使用 &lt;code&gt;flex&lt;/code&gt; 布局实现居中，如果子项的内容会溢出 &lt;code&gt;flex容器&lt;/code&gt; ，可以将子项设置为 &lt;code&gt;margin: auto&lt;/code&gt;试试。&lt;/p&gt;
&lt;h3 id=&quot;transfrom-和-fixed-不能在一起&quot;&gt;3. transfrom 和 fixed 不能在一起！&lt;/h3&gt;
&lt;p&gt;CSS3 的 &lt;code&gt;transform&lt;/code&gt; 属性也算是比较常用的，特别是做一些动画效果的时候，用它来移动元素的位置，性能会比设置 &lt;code&gt;top&lt;/code&gt; 或 &lt;code&gt;left&lt;/code&gt; 要高一些。但是，如果一个元素设置了 &lt;code&gt;transform&lt;/code&gt; 属性，而它的子元素又设置 &lt;code&gt;fixed&lt;/code&gt; 定位，那么这个 &lt;code&gt;fixed&lt;/code&gt; 定位的子元素表现会有些奇怪，如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;app&quot;&amp;gt;
  &amp;lt;button onclick=&quot;layer.style.display='block'&quot;&amp;gt;弹出蒙层&amp;lt;/button&amp;gt;
  &amp;lt;div class=&quot;layer&quot; id=&quot;layer&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;style&amp;gt;
  .app {
    position: relative;
    width: 100px;
    height: 100px;
    background: #ccc;
    /* 使用transform让元素向下偏移20px */
    transform: translate(0, 20px);
  }

  .layer {
    display: none;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background: rgba(0, 0, 0, 0.7);
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开页面，效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/168571f923e087bd?w=398&amp;amp;h=212&amp;amp;f=png&amp;amp;s=7923&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们希望点击“弹出蒙层”按钮后，就显示个覆盖整个窗口的蒙层。但是结果却出乎意料。如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/168571fe8aee2212?w=396&amp;amp;h=264&amp;amp;f=png&amp;amp;s=8408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;蒙层只是遮住了小正方形，这不是我们想要的结果，因为我们知道，&lt;code&gt;fixed&lt;/code&gt; 定位是相对于屏幕视口（&lt;code&gt;viewport&lt;/code&gt;）定位的, 但是,本例却相对于它的父亲元素。这是为什么呢？如果认真查阅 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/position&quot;&gt;mdn文档&lt;/a&gt; ，就会找到答案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/16857204a74f0e8c?w=732&amp;amp;h=144&amp;amp;f=png&amp;amp;s=27038&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，问题的原因在于，我们只是记住了fixed是相对于 &lt;code&gt;viewport&lt;/code&gt; 定位，但是也有特殊情况: &lt;code&gt;当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先&lt;/code&gt; 。所以，这并不是bug，是因为我基础不扎实导致的。事实上， 除了 &lt;code&gt;transform&lt;/code&gt; 会改变 &lt;code&gt;fixed&lt;/code&gt; 的定位元素之外，还有其他属性也会改变，ChokCoco大佬有一篇文章做了详细的讲解，想要了解更多的请点击 &lt;a href=&quot;https://www.cnblogs.com/coco1s/p/7358830.html&quot;&gt;不受控制的 position:fixed&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那遇到这种情况怎么办呢？比较好的办法就是把 &lt;code&gt;fixed&lt;/code&gt; 元素移到外面去，不要放到有 &lt;code&gt;transform&lt;/code&gt; 属性的元素里面。但是，有时候我们没有办法移到外面怎么办呢？比如，这是它是一个子组件，它的某个父亲组件就是用了 &lt;code&gt;transform&lt;/code&gt;，那怎么办呢？我也不知道怎么办，欢迎大家探讨一下哈哈哈~&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fixed&lt;/code&gt; 定位还具有其他的坑，这里也不展开了，有兴趣的可看看github上有大佬整理好的这篇文章 &lt;a href=&quot;https://github.com/maxzhang/maxzhang.github.com/issues/2&quot;&gt;移动端web页面使用position:fixed问题总结&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安卓微信视频播放器的层级问题&quot;&gt;4. 安卓微信视频播放器的层级问题&lt;/h3&gt;
&lt;p&gt;我们都知道， &lt;code&gt;video&lt;/code&gt; 标签设置了 &lt;code&gt;playsinline&lt;/code&gt; 就可以内联播放视频，而不是全屏播放。（注意：前提是客户端的 &lt;code&gt;Webview&lt;/code&gt; 配置了允许内联播放，所以有时候虽然设置了 &lt;code&gt;playsinline&lt;/code&gt;，但在某些app里面打开依然是全屏播放，这不是前端的锅哦）。最近有一个需求，类似下面这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685710261db834a?w=485&amp;amp;h=239&amp;amp;f=png&amp;amp;s=80794&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面上有一个视频，视频播下面有一个按钮，点击按钮就弹出一个图片，该图片要覆盖整个屏幕，比如是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685710a4826b327?w=376&amp;amp;h=439&amp;amp;f=png&amp;amp;s=309640&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;video id=&quot;video&quot; controls=&quot;&quot; playsinline=&quot;&quot; src=&quot;https://vod.cc.163.com/file/5bcbe1ae9efdc0608bb6d06b.mp4&quot;&amp;gt;&amp;lt;/video&amp;gt;
&amp;lt;img id=&quot;image&quot; src=&quot;https://ds.163.com/2018/mrzh/appointment/static/img/bg-body.cdef1ec.jpg&quot; alt=&quot;&quot;&amp;gt;
&amp;lt;button id=&quot;button&quot;&amp;gt;弹出图片&amp;lt;/button&amp;gt;
&amp;lt;style&amp;gt;
  video,
  img {
    width: 100%;
  }

  img {
    display: none;
    position: absolute;
    top: 0;
  }
&amp;lt;/style&amp;gt;

&amp;lt;script&amp;gt;
  var video = document.getElementById('video');
  var image = document.getElementById('image');
  var button = document.getElementById('button');
  button.onclick = function() {
    image.style.display='block';
  }
  image.onclick = function() {
    this.style.display='none';
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，在安卓上却发现一个问题，开始播放视频后（注意，只有播放视频后才可以复现），点击“弹出图片”按钮，显示如下所示：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/16857122e41d2edc?w=503&amp;amp;h=538&amp;amp;f=png&amp;amp;s=404373&quot;/&gt;&lt;br/&gt;图片无法覆盖在视频播放器上面。然后，我设置了 &lt;code&gt;z-index&lt;/code&gt; 或者 &lt;code&gt;transform&lt;/code&gt; ，都没有任何效果。最后， 剩下的可能原因就是: 安卓微信视频播放器实际上用的是原生组件。为了验证这一猜想，我们可以启用开发者选项的绘图模式（开发者选项 --&amp;gt; 绘图 --&amp;gt; 显示布局边界，不同机型不一样，找不到的请百度找一下哈），结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/16/1685713414f1835e?w=679&amp;amp;h=539&amp;amp;f=png&amp;amp;s=427662&quot;/&gt;&lt;br/&gt;看到没有，视频是一个完整的有边框的东西，证明他是一个独立于 &lt;code&gt;Webview&lt;/code&gt; 的原生组件。&lt;/p&gt;
&lt;p&gt;那怎么办呢？只能上网找答案呀！我们都知道，微信 &lt;code&gt;webview&lt;/code&gt; 使用的是 &lt;code&gt;X5&lt;/code&gt; 内核，所以我也希望能从它的开发者文档上找到一些有用的信息，好不容易找到了一篇叫做 &lt;a href=&quot;https://x5.tencent.com/tbs/guide/video.html&quot;&gt;H5同层播放器接入规范&lt;/a&gt; 。它说可以可以在 &lt;code&gt;video&lt;/code&gt; 标签添加一个属性 &lt;code&gt;x5-video-player-type&lt;/code&gt; ，并且给出的例子是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;video src=&quot;http://xxx.mp4&quot; x5-video-player-type=&quot;h5&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我当时很高兴，以为问题就这样解决了，然并卵，添加了 &lt;code&gt;x5-video-layer-type&lt;/code&gt; 属性之后，&lt;code&gt;playsinlie&lt;/code&gt; 属性就失效了，无法内联播放了，只能全屏播放，所以，不能添加这个属性。&lt;/p&gt;
&lt;p&gt;然后我就想，既然无法覆盖这个视频，那在弹出图片的时候能不能把视频给隐藏掉？然后关闭图片的时候再把视频显示回来呢？于是就把 JS 代码改成下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  button.onclick = function() {
    image.style.display='block';
    video.style.display = 'none';
  }
  image.onclick = function() {
    this.style.display='none';
    video.style.display = 'block';
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，这样就可以了。因为我在网上找不到更好的办法，如果大家遇到这个问题可以参考这种做法。当然，如果你们找到了有更好的办法，欢迎评论分享出来哈~&lt;/p&gt;
&lt;p&gt;关于安卓微信视频播放器的坑就先讲到这里啦。&lt;/p&gt;
&lt;p&gt;等等，一讲到原生组件，这里还得再补充一下微信小程序相关的东西，当然，我自己还没有过小程序的开发的经验, 这是之前的一次内部交流会，一位同事的分享：小程序在渲染的时候，大多数组件都是渲染成 &lt;code&gt;HTML&lt;/code&gt; 组件，但是有少部分比如 &lt;code&gt;canvas&lt;/code&gt;、 &lt;code&gt;video&lt;/code&gt;、 &lt;code&gt;input&lt;/code&gt;、 &lt;code&gt;map&lt;/code&gt; 等会渲染成原生组件的。所以，如果你在写小程序时，想用一段文字覆盖在一个 &lt;code&gt;canvas&lt;/code&gt; 上，发现怎么设置都无法实现，那是因为 &lt;code&gt;canvas&lt;/code&gt; 渲染后是原生组件，而文字是 &lt;code&gt;html&lt;/code&gt; 组件，所以无法覆盖上去的 。那有什么办法呢？可以考虑把文字放到　&lt;code&gt;cover-view&lt;/code&gt; 上，　它也是一种原生组件，可以覆盖在　&lt;code&gt;canvas&lt;/code&gt; 上的。具体的可以参考小程序官方文档 &lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html&quot;&gt;原生组件说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于2018踩的坑就写到这里了，当然还有一些其他的，暂时没有时间整理，下次如果整理后，再写一篇补充一下。&lt;/p&gt;
&lt;p&gt;如果大家有什么问题，或者过去踩到过了哪些坑，欢迎在评论区讨论哈。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:10:00 +0000</pubDate>
<dc:creator>ChessZhang</dc:creator>
<og:description>某著名小白说过 ：世上本来到处都是坑，只要走的人多了，也就把坑都给埋了。该小白还说过：坑本身并不可怕，可怕的是踩了一次之后，还第二、第三次踩到了相同的坑。 所谓'坑'，主要是由于我们对某些知识点理解不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yugege/p/10279990.html</dc:identifier>
</item>
<item>
<title>万物互联之~RPC专栏 - 毒逆天</title>
<link>http://www.cnblogs.com/dunitian/p/10279946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dunitian/p/10279946.html</guid>
<description>&lt;h2 id=&quot;rpc引入&quot;&gt;3.RPC引入&lt;/h2&gt;
&lt;p&gt;上篇回顾：&lt;a href=&quot;https://mp.weixin.qq.com/s/KbiAz3Z3yyyKRHws1WW6vg&quot;&gt;万物互联之~深入篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Code：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/python/6.net/6.rpc/&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/python/6.net/6.rpc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他专栏最新篇：&lt;a href=&quot;https://mp.weixin.qq.com/s/Alv0Ds9LDvWbWSNgOgG43A&quot;&gt;协程加强之~兼容答疑篇&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/9887708.html&quot;&gt;聊聊数据库~SQL环境篇&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;3.1.概念&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RPC&lt;/code&gt;(&lt;code&gt;Remote Procedure Call&lt;/code&gt;)：分布式系统常见的一种通信方法（&lt;strong&gt;远程过程调用&lt;/strong&gt;），通俗讲：&lt;strong&gt;可以一台计算机的程序调用另一台计算机的子程序&lt;/strong&gt;（可以把它看成之前我们说的进程间通信，只不过这一次的进程不在同一台PC上了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;code&gt;RPC&lt;/code&gt;的设计思想是力图使远程调用中的通讯细节对于使用者透明，调用双方无需关心网络通讯的具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引用一张网上的图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116092121587-579261271.png&quot; alt=&quot;1.rpc.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;HTTP&lt;/code&gt;有点相似，你可以这样理解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;老版本的&lt;code&gt;HTTP/1.0&lt;/code&gt;是短链接，而&lt;code&gt;RPC&lt;/code&gt;是长连接进行通信
&lt;ul&gt;&lt;li&gt;HTTP协议（header、body），RPC可以采取HTTP协议，也可以自定义二进制格式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;后来&lt;code&gt;HTTP/1.1&lt;/code&gt;支持了长连接(&lt;code&gt;Connection:keep-alive&lt;/code&gt;)，基本上和&lt;code&gt;RPC&lt;/code&gt;差不多了
&lt;ul&gt;&lt;li&gt;但&lt;strong&gt;&lt;code&gt;keep-alive&lt;/code&gt;一般都限制有最长时间，或者最多处理的请求数，而&lt;code&gt;RPC&lt;/code&gt;是基于长连接的，基本上没有这个限制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;后来谷歌直接基于&lt;code&gt;HTTP/2.0&lt;/code&gt;建立了&lt;code&gt;gRPC&lt;/code&gt;，它们之间的基本上也就差不多了
&lt;ul&gt;&lt;li&gt;如果硬是要区分就是：&lt;strong&gt;&lt;code&gt;HTTP-普通话&lt;/code&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;code&gt;RPC-方言&lt;/code&gt;&lt;/strong&gt;的区别了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RPC高效而小众，HTTP效率没RPC高，但更通用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PS：&lt;strong&gt;&lt;code&gt;RPC&lt;/code&gt;和&lt;code&gt;HTTP&lt;/code&gt;调用不用经过中间件，而是端到端的直接数据交互&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;网络交互可以理解为基于&lt;code&gt;Socket&lt;/code&gt;实现的（&lt;code&gt;RPC&lt;/code&gt;、&lt;code&gt;HTTP&lt;/code&gt;都是&lt;code&gt;Socket&lt;/code&gt;的读写操作）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单概括一下&lt;code&gt;RPC&lt;/code&gt;的优缺点就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;优点：
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;效率更高&lt;/strong&gt;（可以自定义二进制格式）&lt;/li&gt;
&lt;li&gt;发起RPC调用的一方，在编写代码时可忽略RPC的具体实现（&lt;strong&gt;跟编写本地函数调用一般&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通用性不如HTTP&lt;/strong&gt;（方言普及程度肯定不如普通话），如果传输协议不是HTTP协议格式，调用双方就需要专门实现通信库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PS：HTTP更多是&lt;code&gt;Client&lt;/code&gt;与&lt;code&gt;Server&lt;/code&gt;的通讯;&lt;code&gt;RPC&lt;/code&gt;更多是内部服务器间的通讯&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;引入&quot;&gt;3.2.引入&lt;/h3&gt;
&lt;p&gt;上面说这么多，可能还没有来个案例实在，我们看个案例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地调用&lt;code&gt;sum()&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;def sum(a, b):
    &quot;&quot;&quot;return a+b&quot;&quot;&quot;
    return a + b

def main():
    result = sum(1, 2)
    print(f&quot;1+2={result}&quot;)

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：（这个大家都知道）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;xmlrpc案例&quot;&gt;1.xmlrpc案例&lt;/h4&gt;
&lt;p&gt;官方文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://docs.python.org/3/library/xmlrpc.client.html
https://docs.python.org/3/library/xmlrpc.server.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都说&lt;code&gt;RPC&lt;/code&gt;用起来就像本地调用一样，那么用起来啥样呢？看个案例：&lt;/p&gt;
&lt;p&gt;服务端：(&lt;strong&gt;CentOS7：&lt;code&gt;192.168.36.123:50051&lt;/code&gt;&lt;/strong&gt;)&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from xmlrpc.server import SimpleXMLRPCServer

def sum(a, b):
    &quot;&quot;&quot;return a+b&quot;&quot;&quot;
    return a + b

# PS：50051是gRPC默认端口
server = SimpleXMLRPCServer(('', 50051))
# 把函数注册到RPC服务器中
server.register_function(sum)
print(&quot;Server启动ing，Port：50051&quot;)
server.serve_forever()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端：（&lt;strong&gt;Win10：&lt;code&gt;192.168.36.144&lt;/code&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from xmlrpc.client import ServerProxy

stub = ServerProxy(&quot;http://192.168.36.123:50051&quot;)
result = stub.sum(1, 2)
print(f&quot;1+2={result}&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：（&lt;code&gt;Client&lt;/code&gt;用起来是不是和本地差不多？就是通过代理访问了下&lt;code&gt;RPCServer&lt;/code&gt;而已）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116103749140-1803787161.png&quot; alt=&quot;2.server.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;CentOS&lt;/code&gt;服务器不是你绑定个端口就一定能访问的，如果不能记让&lt;strong&gt;防火墙开放对应的端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个之前在说&lt;code&gt;MariaDB&lt;/code&gt;环境的时候有详细说：&lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/9887708.html#_map4&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dotnetcrazy/p/9887708.html#_map4&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 添加 --permanent永久生效(没有此参数重启后失效)
firewall-cmd --zone=public --add-port=80/tcp --permanent&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zerorpc案例&quot;&gt;2.ZeroRPC案例：&lt;/h4&gt;
&lt;p&gt;zeroRPC用起来和这个差不多，也简单举个例子吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把服务的某个方法注册到&lt;code&gt;RPCServer&lt;/code&gt;中，供外部服务调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import zerorpc

class Test(object):
    def say_hi(self, name):
        return f&quot;Hi，My Name is{name}&quot;


# 注册一个Test的实例
server = zerorpc.Server(Test())
server.bind(&quot;tcp://0.0.0.0:50051&quot;)
server.run()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;调用服务端代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import zerorpc

client = zerorpc.Client(&quot;tcp://192.168.36.123:50051&quot;)
result = client.say_hi(&quot;RPC&quot;)
print(result)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;简单版自定义rpc&quot;&gt;3.3.简单版自定义RPC&lt;/h3&gt;
&lt;p&gt;看了上面的引入案例，是不是感觉&lt;code&gt;RPC&lt;/code&gt;不过如此？NoNoNo，要是真这么简单也就谈不上&lt;code&gt;RPC架构&lt;/code&gt;了，上面两个是最简单的RPC服务了，可以这么说：生产环境基本上用不到，只能当案例练习罢了，对Python来说，最常用的RPC就两个&lt;strong&gt;&lt;code&gt;gRPC&lt;/code&gt; and &lt;code&gt;Thrift&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS：国产最出名的是&lt;strong&gt;&lt;code&gt;Dubbo&lt;/code&gt; and &lt;code&gt;Tars&lt;/code&gt;&lt;/strong&gt;，Net最常用的是&lt;code&gt;gRPC&lt;/code&gt;、&lt;code&gt;Thrift&lt;/code&gt;、&lt;code&gt;Surging&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;rpc服务的流程&quot;&gt;1.RPC服务的流程&lt;/h4&gt;
&lt;p&gt;要自己实现一个&lt;code&gt;RPC Server&lt;/code&gt;那么就得了解整个流程了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;（调用者）以本地调用的方式发起调用&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;RPC&lt;/code&gt;服务进行&lt;strong&gt;远程过程调用&lt;/strong&gt;（RPC的目标就是要把这些步骤都封装起来，让使用者感觉不到这个过程）
&lt;ol&gt;&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件收到调用后，负责&lt;strong&gt;将被调用的&lt;code&gt;方法名、参数&lt;/code&gt;等打包编码成自定义的协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件在打包完成后通过网络把数据包发送给&lt;code&gt;RPC Server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件把通过网络接收到的数据包按照相应格式进行&lt;strong&gt;&lt;code&gt;拆包解码&lt;/code&gt;，获取方法名和参数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件&lt;strong&gt;根据方法名和参数进行本地调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;RPC Server&lt;/code&gt;&lt;/strong&gt;（被调用者）本地执行后将结果返回给服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件将返回值打包编码成自定义的协议数据包，并通过网络发送给客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件&lt;/li&gt;
&lt;li&gt;客户端的&lt;code&gt;RPC Proxy&lt;/code&gt;组件收到数据包后，进行拆包解码，把数据返回给&lt;code&gt;Client&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;（调用者）得到本次&lt;code&gt;RPC&lt;/code&gt;调用的返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用一张时序图来描述下整个过程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116224934398-1277123948.png&quot; alt=&quot;4.时序图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;RPC Proxy&lt;/code&gt;有时候也叫&lt;code&gt;Stub&lt;/code&gt;（存根）：(Client Stub，Server Stub)&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;为屏蔽客户调用远程主机上的对象，必须提供某种方式来模拟本地对象,这种本地对象称为存根(stub),存根负责接收本地方法调用,并将它们委派给各自的具体实现对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PRC服务实现的过程中其实就两核心点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息协议：客户端调用的参数和服务端的返回值这些在网络上传输的数据以何种方式打包编码和拆包解码
&lt;ul&gt;&lt;li&gt;经典代表：&lt;strong&gt;&lt;code&gt;Protocol Buffers&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;传输控制：在网络中数据的收发传输控制具体如何实现（&lt;code&gt;TCP/UDP/HTTP&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;手写rpc&quot;&gt;2.手写RPC&lt;/h4&gt;
&lt;p&gt;下面我们就根据上面的流程来手写一个简单的RPC：&lt;/p&gt;
&lt;p&gt;1.Client调用：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# client.py
from client_stub import ClientStub

def main():
    stub = ClientStub((&quot;192.168.36.144&quot;, 50051))

    result = stub.get(&quot;sum&quot;, (1, 2))
    print(f&quot;1+2={result}&quot;)

    result = stub.get(&quot;sum&quot;, (1.1, 2))
    print(f&quot;1.1+2={result}&quot;)

    time_str = stub.get(&quot;get_time&quot;)
    print(time_str)

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1+2=3
1.1+2=3.1
Wed Jan 16 22&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.Client Stub，客户端存根：(主要有&lt;code&gt;打包&lt;/code&gt;、&lt;code&gt;解包&lt;/code&gt;、和&lt;code&gt;RPC服务器通信&lt;/code&gt;的方法)&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# client_stub.py
import socket

class ClientStub(object):
    def __init__(self, address):
        &quot;&quot;&quot;address ==&amp;gt; (ip,port)&quot;&quot;&quot;
        self.socket = socket.socket()
        self.socket.connect(address)

    def convert(self, obj):
        &quot;&quot;&quot;根据类型转换成对应的类型编号&quot;&quot;&quot;
        if isinstance(obj, int):
            return 1
        if isinstance(obj, float):
            return 2
        if isinstance(obj, str):
            return 3

    def pack(self, func, args):
        &quot;&quot;&quot;打包：把方法和参数拼接成自定义的协议
        格式：func:函数名@params:类型-参数,类型2-参数2...
        &quot;&quot;&quot;
        result = f&quot;func:{func}&quot;
        if args:
            params = &quot;&quot;
            # params:类型-参数,类型2-参数2...
            for item in args:
                params += f&quot;{self.convert(item)}-{item},&quot;
            # 去除最后一个,
            result += f&quot;@params:{params[:-1]}&quot;
        # print(result)  # log 输出
        return result.encode(&quot;utf-8&quot;)

    def unpack(self, data):
        &quot;&quot;&quot;解包：获取返回结果&quot;&quot;&quot;
        msg = data.decode(&quot;utf-8&quot;)
        # 格式应该是&quot;data:xxxx&quot;
        params = msg.split(&quot;:&quot;)
        if len(params) &amp;gt; 1:
            return params[1]
        return None

    def get(self, func, args=None):
        &quot;&quot;&quot;1.客户端的RPC Proxy组件收到调用后，负责将被调用的方法名、参数等打包编码成自定义的协议&quot;&quot;&quot;
        data = self.pack(func, args)
        # 2.客户端的RPC Proxy组件在打包完成后通过网络把数据包发送给RPC Server
        self.socket.send(data)
        # 等待服务端返回结果
        data = self.socket.recv(2048)
        if data:
            return self.unpack(data)
        return None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简要说明下：（我根据流程在Code里面标注了，看起来应该很轻松）&lt;/p&gt;
&lt;p&gt;之前有说到核心其实就是&lt;code&gt;消息协议&lt;/code&gt;and&lt;code&gt;传输控制&lt;/code&gt;，我&lt;code&gt;客户端存根&lt;/code&gt;的消息协议是自定义的格式（后面会说简化方案）：&lt;strong&gt;&lt;code&gt;func:函数名@params:类型-参数,类型2-参数2...&lt;/code&gt;&lt;/strong&gt;，传输我是基于TCP进行了简单的封装&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;3.Server端：（实现很简单）&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# server.py
import socket
from server_stub import ServerStub

class RPCServer(object):
    def __init__(self, address, mycode):
        self.mycode = mycode
        # 服务端存根（RPC Proxy）
        self.server_stub = ServerStub(mycode)
        # TCP Socket
        self.socket = socket.socket()
        # 端口复用
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # 绑定端口
        self.socket.bind(address)

    def run(self):
        self.socket.listen()
        while True:
            # 等待客户端连接
            client_socket, client_addr = self.socket.accept()
            print(f&quot;来自{client_addr}的请求：\n&quot;)
            # 交给服务端存根（Server Proxy）处理
            self.server_stub.handle(client_socket, client_addr)

if __name__ == &quot;__main__&quot;:
    from server_code import MyCode
    server = RPCServer(('', 50051), MyCode())
    print(&quot;Server启动ing，Port：50051&quot;)
    server.run()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了简洁，服务端代码我单独放在了&lt;code&gt;server_code.py&lt;/code&gt;中：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 5.RPC Server（被调用者）本地执行后将结果返回给服务端的RPC Proxy
class MyCode(object):
    def sum(self, a, b):
        return a + b

    def get_time(self):
        import time
        return time.ctime()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.然后再看看重头戏&lt;code&gt;Server Stub&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# server_stub.py
import socket

class ServerStub(object):
    def __init__(self, mycode):
        self.mycode = mycode

    def convert(self, num, obj):
        &quot;&quot;&quot;根据类型编号转换类型&quot;&quot;&quot;
        if num == &quot;1&quot;:
            obj = int(obj)
        if num == &quot;2&quot;:
            obj = float(obj)
        if num == &quot;3&quot;:
            obj = str(obj)
        return obj

    def unpack(self, data):
        &quot;&quot;&quot;3.服务端的RPC Proxy组件把通过网络接收到的数据包按照相应格式进行拆包解码，获取方法名和参数&quot;&quot;&quot;
        msg = data.decode(&quot;utf-8&quot;)
        # 格式应该是&quot;格式：func:函数名@params:类型编号-参数,类型编号2-参数2...&quot;
        array = msg.split(&quot;@&quot;)
        func = array[0].split(&quot;:&quot;)[1]
        if len(array) &amp;gt; 1:
            args = list()
            for item in array[1].split(&quot;:&quot;)[1].split(&quot;,&quot;):
                temps = item.split(&quot;-&quot;)
                # 类型转换
                args.append(self.convert(temps[0], temps[1]))
            return (func, tuple(args))  # (func,args)
        return (func, )

    def pack(self, result):
        &quot;&quot;&quot;打包：把方法和参数拼接成自定义的协议&quot;&quot;&quot;
        # 格式：&quot;data:返回值&quot;
        return f&quot;data:{result}&quot;.encode(&quot;utf-8&quot;)

    def exec(self, func, args=None):
        &quot;&quot;&quot;4.服务端的RPC Proxy组件根据方法名和参数进行本地调用&quot;&quot;&quot;
        # 如果没有这个方法则返回None
        func = getattr(self.mycode, func, None)
        if args:
            return func(*args)  # 解包
        else:
            return func()  # 无参函数

    def handle(self, client_socket, client_addr):
        while True:
            # 获取客户端发送的数据包
            data = client_socket.recv(2048)
            if data:
                try:
                    data = self.unpack(data)  # 解包
                    if len(data) == 1:
                        data = self.exec(data[0])  # 执行无参函数
                    elif len(data) &amp;gt; 1:
                        data = self.exec(data[0], data[1])  # 执行带参函数
                    else:
                        data = &quot;RPC Server Error Code:500&quot;
                except Exception as ex:
                    data = &quot;RPC Server Function Error&quot;
                    print(ex)
                # 6.服务端的RPC Proxy组件将返回值打包编码成自定义的协议数据包，并通过网络发送给客户端的RPC Proxy组件
                data = self.pack(data)  # 把函数执行结果按指定协议打包
                # 把处理过的数据发送给客户端
                client_socket.send(data)
            else:
                print(f&quot;客户端：{client_addr}已断开\n&quot;)
                break&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再简要说明一下：&lt;strong&gt;里面方法其实主要就是&lt;code&gt;解包&lt;/code&gt;、&lt;code&gt;执行函数&lt;/code&gt;、&lt;code&gt;返回值打包&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出图示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116223931438-2073811968.png&quot; alt=&quot;3.div.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再贴一下上面的时序图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201901/1127869-20190116224934398-1277123948.png&quot; alt=&quot;4.时序图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;课外拓展：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP1.0、HTTP1.1 和 HTTP2.0 的区别
https://www.cnblogs.com/heluan/p/8620312.html

简述分布式RPC框架
https://blog.csdn.net/jamebing/article/details/79610994

分布式基础—RPC
http://www.dataguru.cn/article-14244-1.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下节预估：&lt;strong&gt;RPC服务进一步简化与演变&lt;/strong&gt;、&lt;strong&gt;手写一个简单的REST接口&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 15:00:00 +0000</pubDate>
<dc:creator>毒逆天</dc:creator>
<og:description>3.RPC引入 上篇回顾：万物互联之~深入篇 Code： 其他专栏最新篇：协程加强之~兼容答疑篇 | 聊聊数据库~SQL环境篇 3.1.概念 (`Remote Procedure Call`)：分布式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dunitian/p/10279946.html</dc:identifier>
</item>
<item>
<title>探索ASP.NET Core中的IStartupFilter - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10279874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10279874.html</guid>
<description>&lt;blockquote readability=&quot;2.1348314606742&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://andrewlock.net/exploring-istartupfilter-in-asp-net-core/&quot;&gt;Exploring IStartupFilter in ASP.NET Core&lt;/a&gt;&lt;br/&gt;作者：&lt;a href=&quot;https://andrewlock.net/&quot;&gt;Andrew Lock&lt;/a&gt;&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在本篇博客中，我将介绍一下&lt;code&gt;IStartupFilter&lt;/code&gt;, 以及如何在ASP.NET Core中使用它。在下一篇博客中，我将介绍一下如何在外部中间件中使用&lt;code&gt;IStartupFilter&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IStartupFilter&lt;/code&gt;接口存在于&lt;em&gt;Microsoft.AspNetCore.Hosting.Abstractions&lt;/em&gt;程序集中，它非常简单，仅定义了一个接口方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;namespace Microsoft.AspNetCore.Hosting
{
    public interface IStartupFilter
    {
        Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;Configure&lt;/code&gt;方法返回了一个变量&lt;code&gt;Action&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当创建一个ASP.NET Core应用程序的时候，&lt;code&gt;IApplicationBuilder&lt;/code&gt;负责配置ASP.NET Core的中间件管道。例如你可以在&lt;code&gt;Startup.cs&lt;/code&gt;文件的&lt;code&gt;Configure&lt;/code&gt;方法中，看到以下类似的代码。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app)
{
    app.UseStaticFiles();

    app.UseMvc(routes =&amp;gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法中，你可以直接使用方法提供的&lt;code&gt;IApplicationBuilder&lt;/code&gt;参数，并且可以向其中添加各种中间件。使用&lt;code&gt;IStartupFilter&lt;/code&gt;, 你可以指定并返回一个&lt;code&gt;Action&lt;/code&gt;类型的泛型委托，这意味你除了可以使用方法提供的泛型委托配置&lt;code&gt;IApplicationBuilder&lt;/code&gt;对象， 还需要返回一个泛型委托。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IStartupFilter&lt;/code&gt;方法可以接受一个配置&lt;code&gt;IApplicationBuilder&lt;/code&gt;的方法，换而言之&lt;code&gt;IStartupFilter.Configure&lt;/code&gt;方法可以使用&lt;code&gt;Startup.Configure&lt;/code&gt;方法作为参数。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Startup _startup = new Startup();
Action&amp;lt;IApplicationBuilder&amp;gt; startupConfigure = _startup.Configure;

//后续会补充StartupFilter1类的代码
IStartupFilter filter1 = new StartupFilter1(); 

Action&amp;lt;IApplicationBuilder&amp;gt; filter1Configure = filter1.Configure(startupConfigure)

//后续会补充StartupFilter2类的代码
IStartupFilter filter2 = new StartupFilter2(); 

Action&amp;lt;IApplicationBuilder&amp;gt; filter2Configure = filter2.Configure(filter1Configure)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果之前你学习过ASP.NET Core的中间件管道，对于这个代码，你可能会感觉很熟悉。这里我们正在建立另一条管道， 它是一个Configure方法的管道，而不是中间件管道。 这就是&lt;code&gt;IStartupFilter&lt;/code&gt;的目的，允许在应用程序中创建&lt;code&gt;Configure&lt;/code&gt;方法的管道。&lt;/p&gt;

&lt;p&gt;现在我们对&lt;code&gt;IStartupFilter&lt;/code&gt;的签名有了更进一步的理解，接下来我们可以看看它在ASP.NET Core框架中的用法。&lt;/p&gt;
&lt;p&gt;要查看&lt;code&gt;IStartupFilter&lt;/code&gt;是如果被调用的，你可以在查看&lt;em&gt;Microsoft.AspNetCore.Hosting&lt;/em&gt;程序集中的&lt;code&gt;WebHost&lt;/code&gt;类。 当你在&lt;code&gt;WebHostBuilder&lt;/code&gt;对象上调用&lt;code&gt;Build&lt;/code&gt;方法时，实现&lt;code&gt;IStartupFilter&lt;/code&gt;接口对象会被调用。 这个代码通常出现在&lt;code&gt;Program.cs&lt;/code&gt;文件中，例如：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Program
{
    public static void Main(string[] args)
    {
        var host = new WebHostBuilder()
            .UseKestrel()    
            .UseContentRoot(Directory.GetCurrentDirectory())
            .UseStartup&amp;lt;Startup&amp;gt;()
            .Build();  // 这个会调用BuildApplication方法

        host.Run(); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是&lt;code&gt;BuildApplication&lt;/code&gt;方法的部分代码，你可以看到这个方法负责初始化中间件管道。方法的返回值&lt;code&gt;RequestDelegate&lt;/code&gt;表示了一个完整的管道，当请求到达的时候，Kestral服务器可以调用它。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private RequestDelegate BuildApplication()
{
    ..
    IApplicationBuilder builder = builderFactory.CreateBuilder(Server.Features);
    builder.ApplicationServices = _applicationServices;

    var startupFilters = _applicationServices.GetService&amp;lt;IEnumerable&amp;lt;IStartupFilter&amp;gt;&amp;gt;();
    Action&amp;lt;IApplicationBuilder&amp;gt; configure = _startup.Configure;
    foreach (var filter in startupFilters.Reverse())
    {
        configure = filter.Configure(configure);
    }

    configure(builder);

    return builder.Build();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，此方法创建&lt;code&gt;IApplicationBuilder&lt;/code&gt;的实例，该实例将用于构建中间件管道，并将&lt;code&gt;ApplicationServices&lt;/code&gt;设置为已配置的DI容器。&lt;/p&gt;
&lt;p&gt;接下来的代码块很意思。首先，从DI容器中获取了一个集合&lt;code&gt;IEnumerable&amp;lt;IStartupFilter&lt;/code&gt;。正如我前面说的那样，我们可以配置多个&lt;code&gt;IStartupFilter&lt;/code&gt;来形成一个管道，所以这个方法只是从容器中取出它们。此外，&lt;code&gt;Startup.Configure&lt;/code&gt;方法被保存到局部变量&lt;code&gt;configure&lt;/code&gt;中, 这就是通常在&lt;code&gt;Startup&lt;/code&gt;类中编写的&lt;code&gt;Configure&lt;/code&gt;方法，用于配置中间件管道。&lt;/p&gt;
&lt;p&gt;现在我们通过循环遍历每个&lt;code&gt;IStartupFilter&lt;/code&gt;（以相反的顺序），传入&lt;code&gt;Startup.Configure&lt;/code&gt;方法，然后更新局部变量&lt;code&gt;configure&lt;/code&gt;来创建Configure方法的管道。这种方式实现了一种嵌套管道的效果。例如，如果我们有三个&lt;code&gt;IStartupFilter&lt;/code&gt;实例，你最终会得到类似这样的东西，其中内部&lt;code&gt;Configure&lt;/code&gt;方法在参数中传递给外部方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190116224044765-1894606762.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;局部变量&lt;code&gt;configure&lt;/code&gt;的最终值会被&lt;code&gt;IApplicationBuilder&lt;/code&gt;调用来执行实际的中间件管道配置。 调用&lt;code&gt;builder.Build&lt;/code&gt;方法之后会生成处理HTTP请求所需的&lt;code&gt;RequestDelegate&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;前面我虽然描述了&lt;code&gt;IStartupFilter&lt;/code&gt;的用途，但是可能查看一些现成的实现会更容易理解一些。 默认情况下，&lt;code&gt;WebHostBuilder&lt;/code&gt;在初始化时会注册一个&lt;code&gt;IStartupFilter&lt;/code&gt; - &lt;code&gt;AutoRequestServicesStartupFilter&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AutoRequestServicesStartupFilter : IStartupFilter
{
    public Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next)
    {
        return builder =&amp;gt;
        {
            builder.UseMiddleware&amp;lt;RequestServicesContainerMiddleware&amp;gt;();
            next(builder);
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本质上，它在中间件管道的开头添加了一个额外的中间件，即&lt;code&gt;RequestServicesContainerMiddleware&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这是唯一一个默认注册的&lt;code&gt;IStartupFilter&lt;/code&gt;，因此在这种情况下，参数&lt;code&gt;next&lt;/code&gt;将是&lt;code&gt;Startup&lt;/code&gt;类的&lt;code&gt;Configure&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;这基本上就是&lt;code&gt;IStartupFilter&lt;/code&gt;的全部内容 - 它是一种在配置的管道的开头或结尾添加额外中间件（或其他配置）的方法。&lt;/p&gt;

&lt;p&gt;注册&lt;code&gt;IStartupFilter&lt;/code&gt;很简单，只需像往常一样在你的ConfigureServices方法中注册它。 默认情况下，在&lt;code&gt;WebHostBuilder&lt;/code&gt;中已经注册了&lt;code&gt;AutoRequestServicesStartupFilter&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private IServiceCollection BuildHostingServices()
{
    ...
    services.AddTransient&amp;lt;IStartupFilter, AutoRequestServicesStartupFilter&amp;gt;();
    ...
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;以下是&lt;code&gt;RequestServicesContainerMiddleware&lt;/code&gt;的部分代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class RequestServicesContainerMiddleware
{
    private readonly RequestDelegate _next;
    private IServiceScopeFactory _scopeFactory;

    public RequestServicesContainerMiddleware(RequestDelegate next, IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
        _next = next;
    }

    public async Task Invoke(HttpContext httpContext)
    {
        var existingFeature = httpContext.Features.Get&amp;lt;IServiceProvidersFeature&amp;gt;();

        if (existingFeature?.RequestServices != null)
        {
            await _next.Invoke(httpContext);
            return;
        }

        using (var feature = new RequestServicesFeature(_scopeFactory))
        {
            try
            {
                httpContext.Features.Set&amp;lt;IServiceProvidersFeature&amp;gt;(feature);
                await _next.Invoke(httpContext);
            }
            finally
            {
                httpContext.Features.Set(existingFeature);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该中间件负责设置&lt;code&gt;IServiceProvidersFeature&lt;/code&gt;。 创建时，&lt;code&gt;RequestServicesFeature&lt;/code&gt;为请求创建新的&lt;code&gt;IServiceScope&lt;/code&gt;和&lt;code&gt;IServiceProvider&lt;/code&gt;。 它将负责使用Scoped生命周期添加到DI容器的依赖项的创建和处理。&lt;/p&gt;

&lt;p&gt;一般来说，我不认为在用户的应用程序中需要使用&lt;code&gt;IStartupFilter&lt;/code&gt;。 就其本质而言，用户可以在&lt;code&gt;Configure&lt;/code&gt;方法中定义中间件管道，因此&lt;code&gt;IStartupFilter&lt;/code&gt;是不必要的。&lt;/p&gt;
&lt;p&gt;我能想到以下几种需要使用&lt;code&gt;IStartupFilter&lt;/code&gt;的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你自己创建了一个库，你需要确保你的中间件在中间件管道的开头（或结尾）运行。&lt;/li&gt;
&lt;li&gt;你正在使用一个使用&lt;code&gt;IStartupFilter&lt;/code&gt;的库，您需要确保您的中间件在它之前运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇博文中，我讲解了&lt;code&gt;IStartupFilter&lt;/code&gt;以及&lt;code&gt;WebHost&lt;/code&gt;如何使用它在构建中间件管道。 在下一篇文章中，我将探讨&lt;code&gt;IStartupFilter&lt;/code&gt;的具体用法。&lt;/p&gt;

&lt;p&gt;本篇是作者早期的一篇博文，个人觉着对&lt;code&gt;IStartupFilter&lt;/code&gt;讲解的比较清楚，就翻译了一下。在作者的后期博文中，作者提供了许多&lt;code&gt;IStartupFilter&lt;/code&gt;的使用场景，例如&lt;/p&gt;
&lt;p&gt;有兴趣的同学可以自己阅读一下，后续我会选择一些有意思的文章翻译一下。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Jan 2019 14:41:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>在本篇博客中，我将介绍一下IStartupFilter, 以及如何在ASP.NET Core中使用它。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10279874.html</dc:identifier>
</item>
</channel>
</rss>