<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>javascript的ES6学习总结(第三部分) - 消逝的风i</title>
<link>http://www.cnblogs.com/abc-x/p/10799583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abc-x/p/10799583.html</guid>
<description>&lt;h3&gt;1.ES6中的面向对象的类&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;1.1、定义类&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在ES5中，我们写一个类，通常是这么写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * es5中的模拟面向对象的类的方法 写法1
Person.prototype.showName = function(){
    return &quot;名字为：&quot;+this.name;
}
Person.prototype.showAge = function(){
    return &quot;年龄为：&quot;+this.age;
}&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * es5中的模拟面向对象的类的方法 写法2
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Object.assign(Person.prototype,{
    showName(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;名字为：&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    },
    showAge(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;年龄为：&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }
});
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; Person('tom',18&lt;span&gt;);
console.log(p1.showName());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名字为：tom&lt;/span&gt;
console.log(p1.showAge());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;年龄为：18&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ES6中，我们可以这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ES6中的类(类名大小写都可以，推荐使用规范按照首字母大写)&lt;/span&gt;
&lt;span&gt;class Person{
    constructor(name,age){&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法(函数)，每new一个新对象，自动执行&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(`构造函数执行了,${name},${age}`);//构造函数执行了,Lucy,18&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    showName(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `名字为：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`;
    }
    showAge(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `年龄为：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age}`;
    }
}
let p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person('Lucy',18&lt;span&gt;);
console.log(p1.showName(),p1.showAge());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名字为：Lucy 年龄为：18&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ES6中的类(赋给一个变量或常量，类名大小写都可以，推荐使用规范首字母大写)&lt;/span&gt;
const Person =&lt;span&gt;  class{
    constructor(name,age){&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法(函数)，每new一个新对象，自动执行&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(`构造函数执行了,${name},${age}`);//构造函数执行了,Lucy,18&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    showName(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `名字为：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`;
    }
    showAge(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `年龄为：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age}`;
    }
}
let p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person('Lucy',18&lt;span&gt;);
console.log(p1.showName(),p1.showAge());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名字为：Lucy 年龄为：18&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;1）.ES6里面Class没有提升(例如ES5中的函数有提升到顶部的作用)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;2）.ES6中的this，首先来看一下ES5中矫正this的几个方法&lt;/p&gt;
&lt;p&gt;(2.1) fn.call(this指向谁,args1,args2...);&lt;/p&gt;
&lt;p&gt;(2.2) fn.apply(this指向谁,[args1,args2...]);&lt;/p&gt;
&lt;p&gt;(2.3) fn.bind();(React中经常会用到)&lt;/p&gt;
&lt;p&gt;其中，(2.1) fn.call和(2.2) fn.apply都会在矫正this的时候，方法(函数)会调用一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person{
    constructor(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = 'jason'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.showName = &lt;span&gt;this&lt;/span&gt;.showName.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);&lt;span&gt;//&lt;span&gt;矫正this&lt;/span&gt;&lt;/span&gt;
    }
    showName(){
        console.log(&lt;/span&gt;'this:',&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this: Person {name: &quot;jason&quot;, showName: function}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; `名字为：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`;
    }
}
let p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
let {showName} &lt;/span&gt;=&lt;span&gt; p1;
console.log(showName());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名字为：jason&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;1.2、类里面的取值函数(getter)和存值函数(setter)：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person{
    constructor(name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    get aaa(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `获取aaa的名字,值为${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`;
    }
    set aaa(val){
        console.log(`设置aaa的名字，值为${val}`);
    }
}
let p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person('jack'&lt;span&gt;);
console.log(p1.aaa);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取aaa的名字,值为jack&lt;/span&gt;
p1.aaa = 'luke';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置aaa的名字，值为luke&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;1.3、类里面的静态方法(就是类身上的方法)&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person{
    constructor(){

    }
    showName(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '这是showName方法'&lt;span&gt;;
    }
    static aaa(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '这是静态方法'&lt;span&gt;;
    }
}
let p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
console.log(p1.showName());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是showName方法&lt;/span&gt;
console.log(Person.aaa());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是静态方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.4、类里面的继承&lt;/h4&gt;
&lt;p&gt;先来回顾一下ES6之前的继承写法&lt;/p&gt;
&lt;p&gt;1.原型链继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父类&lt;/span&gt;
Animal.prototype.eat = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(food) {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name + '正在吃' +&lt;span&gt; food);            
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Animal(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color = ['green','red','blue'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = name || 'animal'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sleep = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name + &quot;正在睡觉&quot;&lt;span&gt;)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;原型链继承核心: 将父类的实例作为子类的原型。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Cat(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color = ['green','red','blue'];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用类型值，，所有实例会共享这个属性。&lt;/span&gt;
&lt;span&gt;}
Cat.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Animal();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat = &lt;span&gt;new&lt;/span&gt; Cat('cat'&lt;span&gt;);
console.log(cat.name);
console.log(cat.eat(&lt;/span&gt;'fish'&lt;span&gt;));
console.log(cat &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Animal);
console.log(cat.sleep());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，&lt;span&gt;原型链式继承并没有实现代码的复用&lt;/span&gt;，一些共同的属性：如name，在子类中还是得重新写一遍（即同一套代码还是得重新写）。&lt;/p&gt;
&lt;p&gt;再者，cat继承了Animal实例的所有属性和方法，这些方法并不都是我们需要的，也就是过多的继承了没有用的属性。且如果原型中包含&lt;span&gt;引用类型值&lt;/span&gt;，那么所有的实例会共享这个属性。&lt;/p&gt;
&lt;p&gt;2.构造函数继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age,sex){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Student(name,age,sex){
    Person.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name,age,sex);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.grade =&lt;span&gt; grade;
}
let student &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Student;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造函数模式继承实现了代码的复用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不能继承借用的构造函数的原型，只能借用构造函数本身的属性和方法&lt;/li&gt;
&lt;li&gt;每次构造函数都要多走一个函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.组合继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
}
Person.prototype.showName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `名字是：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Student(name,age){
    Person.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承属性,在创建实例时第二次调用Person&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
}
Student.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承方法,第一次调用Person&lt;/span&gt;
Student.prototype.constructor =&lt;span&gt; Student;&lt;span&gt;//矫正constructor&lt;/span&gt;
Student.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '年龄是：'+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; stu1 = &lt;span&gt;new&lt;/span&gt; Student('jack',20&lt;span&gt;);
console.log(stu1.name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;
console.log(stu1.showName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;function (){return `名字是：${this.name}`}&lt;/span&gt;
console.log(stu1.showName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名字是：jack&lt;/span&gt;
console.log(stu1.sayName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;年龄是：20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父类构造函数被调用2次，子类实例的属性存在两份,一份在原型上，一份在实例属性上。造成内存的浪费。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4.寄生组合式继承&lt;/p&gt;
&lt;p&gt;寄生组合式继承是对组合继承的进一步优化。我们先看一下为什么要写这个语句。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SubType.prototype = new SuperType();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们无非是想让SubType继承SuperType的原型。但是我们为什么不直接写成这样呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SubType.prototype = SuperType.prototype
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写确实可以实现子类对象对父类对象原型的继承。但是这样写的话：所有&lt;span&gt;继承该父类的子类对象的原型都指向同一个&lt;/span&gt;了。也就是说SubType不能有自己的原型了。这显然不是我们想要的。&lt;/p&gt;
&lt;p&gt;既然不能直接继承，那可不可以间接继承SuperType.prototype呢。这就是最终的解决方案：&lt;strong&gt;寄生组合式继承&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们让一个函数去指向SuperType.prototype，然后让SubType.prototype指向这个函数产生的对象不就可以了嘛。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; inherit(Target,Origin) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现寄生组合式继承的核心函数&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F() {};
    F.prototype &lt;/span&gt;= Origin.prototype; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;F()的原型指向的是Origin&lt;/span&gt;
    Target.prototype = &lt;span&gt;new&lt;/span&gt; F(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Target的原型指向的是F()&lt;/span&gt;
    Target.prototype.constructor =&lt;span&gt; Target; 
    SubType.prototype.__proto__ &lt;/span&gt;==&lt;span&gt; SuperType.prototype
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.colors = ['red','blue','pink'&lt;span&gt;];
}
SuperType.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(name,age) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承属性&lt;/span&gt;
    SuperType.call(&lt;span&gt;this&lt;/span&gt;,name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在创建实例时第二次调用SuperType&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
}

inherit(SubType,SuperType);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现寄生组合式继承&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再来看一下实现寄生组合式继承的核心函数。F函数其实是通用的，我们没必要每次进入inherit函数时都声明一遍。所以我们可以用闭包的形式来写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; inherit = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; F = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {};
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (Target , Origin) {
            F.prototype &lt;/span&gt;= Origin.prototype;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;F()的原型指向的是Origin&lt;/span&gt;
            Target.prototype = &lt;span&gt;new&lt;/span&gt; F();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Target的原型指向的是F()&lt;/span&gt;
            Target.prototype.constructor =&lt;span&gt; Target;
            Target.prototype.uber &lt;/span&gt;=&lt;span&gt; Origin.prototype;
            SubType.prototype.__proto__ &lt;/span&gt;==&lt;span&gt; SuperType.prototype
        }
    })()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看ES6继承的写法，相比前面就优雅了许多，代码量也会少很多！！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ES6继承 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类&lt;/span&gt;
&lt;span&gt;class Person{
    constructor(name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    showName(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `名字为：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类&lt;/span&gt;
&lt;span&gt;class Student extends Person{

}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; stu1 = &lt;span&gt;new&lt;/span&gt; Student('jack'&lt;span&gt;);
console.log(stu1.showName());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名字为：jack&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子类在自己的身上加方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ES6继承 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类&lt;/span&gt;
&lt;span&gt;class Person{
    constructor(name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    showName(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `名字为：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类&lt;/span&gt;
&lt;span&gt;class Student extends Person{
    constructor(name,skill){
        super(name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类的构造函数必须有super(),相当于执行一次父级的构造函数&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.skill =&lt;span&gt; skill;
    }
    showSkill(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `他的名字是${&lt;span&gt;this&lt;/span&gt;.name},他的特长是${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.skill}`;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; stu1 = &lt;span&gt;new&lt;/span&gt; Student('jack','跳舞'&lt;span&gt;);
console.log(stu1.showSkill());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;他的名字是jack,他的特长是跳舞&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果子类的方法和父类的方法同名，然后想调用父类的方法，自己子类的方法也要执行，可以这么写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ES6继承 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类&lt;/span&gt;
&lt;span&gt;class Person{
    constructor(name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    showName(){
        console.log(&lt;/span&gt;'父类的showName'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `名字为：${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类&lt;/span&gt;
&lt;span&gt;class Student extends Person{
    constructor(name,skill){
        super(name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类的构造函数必须有super(),相当于执行一次父级的构造函数&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.skill =&lt;span&gt; skill;
    }
    showName(){
        super.showName();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行父类的方法&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里写子类自己的要做的事 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        console.log(&lt;/span&gt;'子类的showName'&lt;span&gt;);
    }
    showSkill(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `他的名字是${&lt;span&gt;this&lt;/span&gt;.name},他的特长是${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.skill}`;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; stu1 = &lt;span&gt;new&lt;/span&gt; Student('jack','跳舞'&lt;span&gt;);
console.log(stu1.showName());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父类的showName  子类的showName&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.Symbol和Generator&lt;/h3&gt;
&lt;h4&gt;2.1Symbol：ES6新增的一种数据类型&lt;/h4&gt;
&lt;p&gt;定义方法：let Symbol = Symbol('aaa');&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)Symbol不能当new来使用&lt;/p&gt;
&lt;p&gt;(2)Symbol()返回是一个唯一值&lt;/p&gt;
&lt;p&gt;(3)Symbol是一个单独数据类型，就叫symbol的基本类型&lt;/p&gt;
&lt;p&gt;(4)如果Symbol作为key，用for in循环，出不来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let symbol = Symbol('Jack'&lt;span&gt;);
let json &lt;/span&gt;=&lt;span&gt; {
    a:&lt;/span&gt;'apple'&lt;span&gt;,
    b:&lt;/span&gt;'banana'&lt;span&gt;,
    [symbol]:&lt;/span&gt;'aaa'&lt;span&gt;
}
console.log(json[symbol]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 遍历json&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;(let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json){
    console.log(key);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a b&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2Generator生成器函数：解决异步，深度嵌套的问题&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; show(){

}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;*&lt;span&gt; show(){

}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;show(){

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义&amp;amp;调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; * gen(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在函数名前面使用*号定义一个&lt;/span&gt;
    yield 'hello'&lt;span&gt;;
    yield &lt;/span&gt;'javascript'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'generator函数'&lt;span&gt;;
}
let g1 &lt;/span&gt;=&lt;span&gt; gen();
console.log(g1.next());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object {value: &quot;hello&quot;, done: false}&lt;/span&gt;
console.log(g1.next());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object {value: &quot;javascript&quot;, done: false}&lt;/span&gt;
console.log(g1.next());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object {value: &quot;generator函数&quot;, done: true}&lt;/span&gt;
console.log(g1.next());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遍历generator函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; * gen(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在函数名前面使用*号定义一个&lt;/span&gt;
    yield 'hello'&lt;span&gt;;
    yield &lt;/span&gt;'javascript'&lt;span&gt;;
    yield &lt;/span&gt;'world'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'generator函数'&lt;span&gt;;
}
let g1 &lt;/span&gt;=&lt;span&gt; gen();
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;遍历generator函数(注意：return的东西不会被遍历出来)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.用for...of遍历&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let val of g1){
    console.log(val);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hello javascript world&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.使用解构&lt;/span&gt;
let [a,b,c,d] =&lt;span&gt; gen();
console.log(a,b,c,d);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hello javascript world undefined&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 3.使用扩展(三个点)运算符&lt;/span&gt;
let [f,...g] =&lt;span&gt; gen();
console.log(f,g);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hello [&quot;javascript&quot;, &quot;world&quot;]&lt;/span&gt;
&lt;span&gt;
let [...newArr] &lt;/span&gt;=&lt;span&gt; gen();
console.log(newArr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;hello&quot;, &quot;javascript&quot;, &quot;world&quot;]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;4.使用Array.from函数&lt;/span&gt;
console.log(Array.from(gen()));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;hello&quot;, &quot;javascript&quot;, &quot;world&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于异步的解决方案：&lt;/p&gt;
&lt;p&gt;(1)回调函数&lt;/p&gt;
&lt;p&gt;(2)事件监听&lt;/p&gt;
&lt;p&gt;(3)发布/订阅&lt;/p&gt;
&lt;p&gt;(4)Promise对象&lt;/p&gt;
&lt;p&gt;(5)Generator函数&lt;/p&gt;
&lt;p&gt;(6)Async/Await&lt;/p&gt;
&lt;h3&gt;3.async、await函数：解决异步问题&lt;/h3&gt;
&lt;p&gt;定义：在函数前面加async，函数内部加await，后面的代码会等待前面的代码先执行&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt; fn(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示异步，这个函数里面有异步的任务&lt;/span&gt;
    let result=await;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示后面结果需要等待   &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用(例如读取文件)：&lt;/p&gt;
&lt;p&gt;(1)promise写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const fs = require('fs'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用fs封装一个promise&lt;/span&gt;
const readFile = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fileName){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve,reject)=&amp;gt;&lt;span&gt;{
        fs.readFile(fileName,(err,data)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err) reject(err);
            resolve(data);
        })
    })
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; promise&lt;/span&gt;
readFile('data/1.txt').then(res=&amp;gt;&lt;span&gt;{
    console.log(res.toString());
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; readFile('data/2.txt'&lt;span&gt;);
}).then(res&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(res.toString());
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)generator写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const fs = require('fs'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用fs封装一个promise&lt;/span&gt;
const readFile = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fileName){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve,reject)=&amp;gt;&lt;span&gt;{
        fs.readFile(fileName,(err,data)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err) reject(err);
            resolve(data);
        })
    })
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; generator&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; gen(){
    yield readFile(&lt;/span&gt;'data/1.txt'&lt;span&gt;);
    yield readFile(&lt;/span&gt;'data/2.txt'&lt;span&gt;);
}
let g1 &lt;/span&gt;=&lt;span&gt; gen();
g1.next().value.then(res&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(res.toString());
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; g1.next().value;
}).then(res&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(res.toString());
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; g1.next().value;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)async、await写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用async、await做一个文件读取&lt;/span&gt;
const fs = require('fs'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用fs封装一个promise&lt;/span&gt;
const readFile = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fileName){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve,reject)=&amp;gt;&lt;span&gt;{
        fs.readFile(fileName,(err,data)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err) reject(err);
            resolve(data);
        })
    })
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; async&lt;/span&gt;
async &lt;span&gt;function&lt;/span&gt; fn(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示异步，函数内有异步任务&lt;/span&gt;
    let f1 = await readFile('data/1.txt');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示后面的结果需要等待&lt;/span&gt;
&lt;span&gt;    console.log(f1.toString());
    let f2 &lt;/span&gt;= await readFile('data/2.txt'&lt;span&gt;);
    console.log(f2.toString());
}
fn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;async、await特点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.await只能放在async函数中&lt;/p&gt;
&lt;p&gt;2.相比generator语法更强&lt;/p&gt;
&lt;p&gt;3.await后面可以是promise对象，也可以是数字、字符串、布尔类型&lt;/p&gt;
&lt;p&gt;4.async函数返回的是一个promise对象&lt;/p&gt;
&lt;p&gt;5.只要await语句后面Promise状态变为reject，那么整个async函数会中断执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决async函数中抛出错误，影响后续代码执行？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.使用try{}catch(e){}语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        await Promise.reject(&lt;/span&gt;'出现问题了'&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){

    }
    let a &lt;/span&gt;= await Promise.resolve('successs'&lt;span&gt;);
    console.log(a);
}
fn().then(res&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(res);
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err=&amp;gt;&lt;span&gt;{
    console.log(err);
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结果&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; success undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.promise本身的catch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    let [a,b] &lt;/span&gt;=&lt;span&gt; await Promise.all([
        readFile(&lt;/span&gt;'data/1.txt'&lt;span&gt;),
        readFile(&lt;/span&gt;'data/2.txt'&lt;span&gt;)
    ]);
    console.log(a.toString());
    console.log(b.toString());
}
fn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.Set和WeakSet&lt;/h3&gt;
&lt;h4&gt;4.1、Set数据结构：类似数组，但里面不能有&lt;span&gt;重复值。&lt;span&gt;new Set([]),存储数组&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set数据结构&lt;/span&gt;
let setArr = &lt;span&gt;new&lt;/span&gt; Set(['a','b','a'&lt;span&gt;]);
console.log(setArr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set(2) {&quot;a&quot;, &quot;b&quot;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;p&gt;(1)add()方法：向Set数据结构中添加元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set数据结构--add()方法：向数组中添加元素&lt;/span&gt;
let setArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
setArr.add(&lt;/span&gt;'aaa'&lt;span&gt;);
setArr.add(&lt;/span&gt;'bbb'&lt;span&gt;);
setArr.add(&lt;/span&gt;'aaa'&lt;span&gt;);
console.log(setArr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set(2) {&quot;aaa&quot;, &quot;bbb&quot;}&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; add()方法链式添加&lt;/span&gt;
let setArr = &lt;span&gt;new&lt;/span&gt; Set().add('aaa').add('bbb').add('aaa'&lt;span&gt;);
console.log(setArr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set(2) {&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)delete()方法：删除Set数据结构中的某一项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let setArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
setArr.add(&lt;/span&gt;'aaa'&lt;span&gt;);
setArr.add(&lt;/span&gt;'bbb'&lt;span&gt;);
setArr.add(&lt;/span&gt;'ccc'&lt;span&gt;);
console.log(setArr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set(2) {&quot;aaa&quot;, &quot;bbb&quot;,&quot;ccc&quot;}&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Set数据结构--delete()方法：删除Set数据结构中的某一项&lt;/span&gt;
setArr.&lt;span&gt;delete&lt;/span&gt;('bbb'&lt;span&gt;);
console.log(setArr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set(2) {&quot;aaa&quot;, &quot;ccc&quot;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)clear()方法：删除Set数据结构中的所有项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set数据结构--add()方法：向Set数据结构中添加元素&lt;/span&gt;
let setArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
setArr.add(&lt;/span&gt;'aaa'&lt;span&gt;);
setArr.add(&lt;/span&gt;'bbb'&lt;span&gt;);
setArr.add(&lt;/span&gt;'ccc'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set数据结构--clear()方法：删除Set数据结构中的所有项&lt;/span&gt;
&lt;span&gt;setArr.clear();
console.log(setArr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set(0) {}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(4)has()方法：检测Set数据结构中的是否某一项,返回布尔值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let setArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
setArr.add(&lt;/span&gt;'aaa'&lt;span&gt;);
setArr.add(&lt;/span&gt;'bbb'&lt;span&gt;);
setArr.add(&lt;/span&gt;'ccc'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set数据结构--has()方法：检测Set数据结构中的是否某一项,返回布尔值&lt;/span&gt;
console.log(setArr.has('bbba'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5)size属性：查看Set数据结构有多少个元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let setArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
setArr.add(&lt;/span&gt;'aaa'&lt;span&gt;);
setArr.add(&lt;/span&gt;'bbb'&lt;span&gt;);
setArr.add(&lt;/span&gt;'ccc'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set数据结构--size属性：查看Set数据结构有多少个元素&lt;/span&gt;
console.log(setArr.size);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(6)循环Set数据结构(注：&lt;span&gt;Set数据结构的key和value是相同的&lt;/span&gt;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(let val of setArr){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认循环的是values()&lt;/span&gt;
    console.log(val);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa bbb ccc&lt;/span&gt;
&lt;span&gt;}
console.log(&lt;/span&gt;'-------'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let val of setArr.keys()){
    console.log(val);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa bbb ccc&lt;/span&gt;
&lt;span&gt;}
console.log(&lt;/span&gt;'-------'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let val of setArr.values()){
    console.log(val);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa bbb ccc&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let item of setArr.entries()){
    console.log(item);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;aaa&quot;, &quot;aaa&quot;] [&quot;bbb&quot;, &quot;bbb&quot;] [&quot;ccc&quot;, &quot;ccc&quot;]&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [k,v] of setArr.entries()){
    console.log(k,v);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa aaa bbb bbb ccc ccc&lt;/span&gt;
&lt;span&gt;}
setArr.forEach((val,index)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(val,index);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa aaa bbb bbb ccc ccc&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用Set做数组的去重：&lt;/p&gt;
&lt;p&gt;方法1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
let arr = [1,2,3,4,5,6,3,4,5,3,2&lt;span&gt;];
let newArr &lt;/span&gt;= [...&lt;span&gt;new&lt;/span&gt; Set(arr)];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里数组去重返回的是一个数组的浅拷贝&lt;/span&gt;
arr.push(9,8,7,7,8&lt;span&gt;);
console.log(arr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3, 4, 5, 6, 3, 4, 5, 3, 2, 9, 8, 7, 7, 8]&lt;/span&gt;
console.log(newArr);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3, 4, 5, 6]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
let arr2 = [1,2,3,4,5,6,3,4,5,3,2&lt;span&gt;];
let newArr2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
arr2.map(x&lt;/span&gt;=&amp;gt;&lt;span&gt;newArr2.add(x));
let resArr2 &lt;/span&gt;=&lt;span&gt; [...newArr2];
console.log(resArr2);[&lt;/span&gt;1, 2, 3, 4, 5, 6]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2、WeakSet数据结构：类似数组对象，但里面不能有&lt;span&gt;重复值&lt;/span&gt;。new WeakSet({}),存储对象&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.WeakSet初始化定义时，不能在里面存值。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.WeakSet里面的add()方法只能存json对象，如果存字符串、数字等会报错！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let set = &lt;span&gt;new&lt;/span&gt; WeakSet();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WeakSet初始化定义时，不能在里面存值。&lt;/span&gt;
let json =&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    b:&lt;/span&gt;2&lt;span&gt;
};
let json2 &lt;/span&gt;=&lt;span&gt; {
    a:&lt;/span&gt;'asp'&lt;span&gt;,
    b:&lt;/span&gt;2&lt;span&gt;
};
set.add(json);
set.add(json2);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;add()方法只能存json对象，如果存字符串、数字等会报错！&lt;/span&gt;
&lt;span&gt;//set.add(true);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Invalid value used in weak set&lt;/span&gt;
console.log(set);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WeakSet {Object {a: &quot;asp&quot;, b: 2}, Object {a: 1, b: 2}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法：Set数据结构提供的方法除了size属性和clear()方法没有，别的都有。(例如：add()、has()、delete())&lt;/p&gt;
&lt;h3&gt;5.Map和WeakMap&lt;/h3&gt;
&lt;h4&gt;5.1Map数据结构：类似json，但是json的键(key)只能是字符串，而map的key可以是任意类型&lt;/h4&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Map使用&lt;/span&gt;
let map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
map.set(key,value);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Map使用&lt;/span&gt;
let map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
let json &lt;/span&gt;=&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    b:&lt;/span&gt;2&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; map.set(key,value);//设置一个值&lt;/span&gt;
&lt;span&gt;
map.set(&lt;/span&gt;'abc','123'&lt;span&gt;);
map.set(json,&lt;/span&gt;'aaa'&lt;span&gt;);
map.set(&lt;/span&gt;'a'&lt;span&gt;,json);
console.log(map);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Map(3) {&quot;abc&quot; =&amp;gt; &quot;123&quot;, Object {a: 1, b: 2} =&amp;gt; &quot;aaa&quot;, &quot;a&quot; =&amp;gt; Object {a: 1, b: 2}}&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; map.get(key);//获取一个值&lt;/span&gt;
&lt;span&gt;
console.log(map.get(json));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;
console.log(map.get('a'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object {a: 1, b: 2}&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; map.delete(key);//删除某一项&lt;/span&gt;
&lt;span&gt;
map.&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;('abc'&lt;span&gt;);
console.log(map);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Map(2) { Object {a: 1, b: 2} =&amp;gt; &quot;aaa&quot;, &quot;a&quot; =&amp;gt; Object {a: 1, b: 2}}&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; map.has(key);//查找某一项,返回布尔值&lt;/span&gt;
&lt;span&gt;
console.log(map.has(&lt;/span&gt;'abc'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; map.clear();//删除所有项&lt;/span&gt;
&lt;span&gt;
map.clear();
console.log(map);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Map(0) {}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;循环map数据结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
let map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
let json &lt;/span&gt;=&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    b:&lt;/span&gt;2&lt;span&gt;
}
map.set(&lt;/span&gt;'abc','123'&lt;span&gt;);
map.set(json,&lt;/span&gt;'aaa'&lt;span&gt;);
map.set(&lt;/span&gt;'a'&lt;span&gt;,json);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环map&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;(let [key,value] of map){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认entries&lt;/span&gt;
&lt;span&gt;    console.log(key,value);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;abc 123
    Object {a: 1, b: 2} &quot;aaa&quot;
    Object {a: 1, b: 2}&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let key of map.keys()){}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let value of map.values()){}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [key,value] of map.entries()){}
map.forEach((value,key)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(key,value);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;abc 123
    Object {a: 1, b: 2} &quot;aaa&quot;
    Object {a: 1, b: 2}&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5.1WeakMap数据结构：类似json，但是json的键(key)只能是字符串，而WeakMap的key只能是对象&lt;/h4&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; WeakMap使用&lt;/span&gt;
let wmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WeakMap();
let json &lt;/span&gt;=&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    b:&lt;/span&gt;2&lt;span&gt;
}
wmap.set(json,&lt;/span&gt;'123'&lt;span&gt;);
console.log(wmap);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WeakMap {Object {a: 1, b: 2} =&amp;gt; &quot;123&quot;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Set  里面是数组，不能重复，没有key(下标)，没有get方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Map 对json功能增强，key可以是任意类型值&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;6.数字变化和Math新增的东西&lt;/h3&gt;
&lt;h4&gt;6.1数字变化(数值变化)&lt;/h4&gt;
&lt;p&gt;1.进制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二进制：(binary)&lt;/span&gt;
let a =&lt;span&gt; 0b010101;
console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 八进制：(Octal)&lt;/span&gt;
let b =&lt;span&gt; 0o652;
console.log(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;426&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 十六进制：(Hexadecimal)&lt;/span&gt;
let c = 0xabc&lt;span&gt;;
console.log(c);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2748&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.数值判断&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数字变化&lt;/span&gt;
let a = 12&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Number.isNaN：判断是否为NaN&lt;/span&gt;
console.log(Number.isNaN(a));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Number.isFinite：判断是否是数字&lt;/span&gt;
let b = 'aaa'&lt;span&gt;;
console.log(Number.isFinite(b));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fasle&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Number.isInteger：判断是否是整数&lt;/span&gt;
let c = 12.12&lt;span&gt;;
console.log(Number.isInteger(c));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(Number.isInteger(a));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Number.parseInt()：将一个数据转换成整数&lt;/span&gt;
console.log(Number.parseInt(2.5&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Number.parseFloat()：将一个数据转换成浮点数&lt;/span&gt;
console.log(Number.parseFloat(&quot;13.5526&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;13.5526&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Number.isSafeInteger()：判断是否是安全整数&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; 安全整数：-(2^53-1)到(2^53-1) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
console.log(Number.isSafeInteger(&lt;/span&gt;-(2**53)));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(Number.isSafeInteger(-(2**53-1)));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
console.log(Number.isSafeInteger((2**53)));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(Number.isSafeInteger((2**53-1)));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Number.MAX_SAFE_INTEGER：最大安全整数&lt;/span&gt;
console.log(Number.MAX_SAFE_INTEGER);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9007199254740991&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Number.MIN_SAFE_INTEGER：最小安全整数&lt;/span&gt;
console.log(Number.MIN_SAFE_INTEGER);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-9007199254740991&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6.2Math新增的东西&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Math新增的东西&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Math.trunc()：截取数字整数部分&lt;/span&gt;
console.log(Math.trunc(4.6));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Math.sign()：判断一个数是正数、负数、0&lt;/span&gt;
console.log(Math.sign(-5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;
console.log(Math.sign(5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
console.log(Math.sign(0));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
console.log(Math.sign(-0));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-0&lt;/span&gt;
console.log(Math.sign('abc'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NaN&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Math.cbrt()：计算一个数的立方根&lt;/span&gt;
console.log(Math.cbrt(27));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ...等等&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7.ES2018(ES9)新增的东西&lt;/h3&gt;
&lt;h4&gt;7.1命名捕获(用于正则匹配)&lt;/h4&gt;
&lt;p&gt;语法：(?&amp;lt;名字&amp;gt;)&lt;/p&gt;
&lt;p&gt;以前写正则，要把捕获到的数据赋给变量，都是这么写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let today = &quot;2019-05-03&quot;&lt;span&gt;;
let reg &lt;/span&gt;= /(\d{4})-(\d{2})-(\d{2})/&lt;span&gt;;
let dateArr &lt;/span&gt;=&lt;span&gt; today.match(reg);
let [full,year,month,day,...more] &lt;/span&gt;=&lt;span&gt; dateArr;
console.log(year,month,day);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2019 05 03&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，我们可以这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
let today = &quot;2019-05-03&quot;&lt;span&gt;;
let reg &lt;/span&gt;= /(?&amp;lt;year&amp;gt;\d{4})-(?&amp;lt;month&amp;gt;\d{2})-(?&amp;lt;day&amp;gt;\d{2})/;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建议在Chrome浏览器下测试，别的浏览器可能会报错。&lt;/span&gt;
let {year,month,day} =&lt;span&gt; today.match(reg).groups;
console.log(year,month,day);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2019 05 03&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;7.2反向引用命名捕获&lt;/h4&gt;
&lt;p&gt;1.反向引用以前写法：&lt;/p&gt;
&lt;p&gt;(1)\1 \2(字符串写法)    (2)$1 $2(str.replace()方法写法)&lt;/p&gt;
&lt;p&gt;语法：\k&amp;lt;名字&amp;gt;&lt;/p&gt;
&lt;p&gt;如果要匹配和前面组相同的多个，可以这么写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配：&quot;monday-monday&quot;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; let reg = /^(?&amp;lt;m&amp;gt;monday)-\k&amp;lt;m&amp;gt;$/;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; let str = 'a-a';&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; let str2 = 'm-m';&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; let str3 = 'monday-monday';&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; console.log(reg.test(str));//false&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; console.log(reg.test(str2));//false&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; console.log(reg.test(str3));//true&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配：&quot;monday-monday-monday&quot;&lt;/span&gt;
let reg = /^(?&amp;lt;m&amp;gt;monday)-\k&amp;lt;m&amp;gt;-\1$/;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者let reg = /^(?&amp;lt;m&amp;gt;monday)-\k&amp;lt;m&amp;gt;-\k&amp;lt;m&amp;gt;$/;&lt;/span&gt;
let str = 'a-a'&lt;span&gt;;
let str2 &lt;/span&gt;= 'm-m'&lt;span&gt;;
let str3 &lt;/span&gt;= 'monday-monday'&lt;span&gt;;
let str4 &lt;/span&gt;= 'monday-monday-monday'&lt;span&gt;;
console.log(reg.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(reg.test(str2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(reg.test(str3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(reg.test(str4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.替换：$&amp;lt;名字&amp;gt;&lt;/p&gt;
&lt;p&gt;例如：正则转换日期格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let str = '2019-05-03'&lt;span&gt;;
let reg &lt;/span&gt;= /(?&amp;lt;year&amp;gt;\d{4})-(?&amp;lt;month&amp;gt;\d{2})-(?&amp;lt;day&amp;gt;\d{2})/&lt;span&gt;;

let str1 &lt;/span&gt;= str.replace(reg,'$&amp;lt;day&amp;gt;/$&amp;lt;month&amp;gt;/$&amp;lt;year&amp;gt;'&lt;span&gt;);
console.log(str);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2019-05-03&lt;/span&gt;
console.log(str1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;03/05/2019&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合回调函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let str = '2019-05-03'&lt;span&gt;;
let reg &lt;/span&gt;= /(?&amp;lt;year&amp;gt;\d{4})-(?&amp;lt;month&amp;gt;\d{2})-(?&amp;lt;day&amp;gt;\d{2})/&lt;span&gt;;

let str1 &lt;/span&gt;= str.replace(reg,(...args)=&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(args);&lt;/span&gt;
    let {year,month,day} = args[args.length-1&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `${day}/${month}/&lt;span&gt;${year}`;
});
console.log(str1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;03/05/2019&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;7.3dotAll模式(用s)来表示：匹配任意东西&lt;/h4&gt;
&lt;p&gt;之前，如果用正则匹配任意东西，用‘.’来匹配，但不包括\n，所以之前如果匹配\n之类的东西，是这么写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let reg = /^\w+.\w+$/m;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注：在结尾处加m表示多行模式&lt;/span&gt;
let str = 'turn-\noff'&lt;span&gt;;
console.log(reg.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是如果匹配一些别的文字，比如换行符’\n‘，会匹配失败&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let reg = /^\w+.\w+$/&lt;span&gt;m;
let str &lt;/span&gt;= 'turn\noff'&lt;span&gt;;
console.log(reg.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以用dotAll模式来匹配(结尾处加s即可)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let reg = /^\w+.\w+$/s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加s表示为dotAll模式&lt;/span&gt;
let str = 'turn\noff'&lt;span&gt;;
console.log(reg.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;7.3标签函数&lt;/h4&gt;
&lt;p&gt;定义：和定义普通函数一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fn();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样调用就是普通函数&lt;/span&gt;
fn`aaa`;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标签函数的调用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(args){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; args[0].toUpperCase();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将第一个参数转为大写&lt;/span&gt;
&lt;span&gt;}
console.log(fn`panda`);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用标签函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;7.4Proxy代理(扩展或增强对象的一些功能)&lt;/h4&gt;
&lt;p&gt;作用：比如vue中的拦截，预警、上报、扩展功能、统计、增强对象等等；proxy是设计模式的一种，叫做代理模式。&lt;/p&gt;
&lt;p&gt;语法：new Proxy(target,handler)，target为被代理的对象，handler对代理的对象做什么操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
let obj = {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此对象不暴露给外部&lt;/span&gt;
    name:'jack'&lt;span&gt;
};
let newObj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Proxy(obj,{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此对象是暴露给外部的obj&lt;/span&gt;
&lt;span&gt;    get(target,property){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(target,property);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在访问属性之前做一些操作&lt;/span&gt;
&lt;span&gt;        console.log(`您访问了${property}属性`);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target[property];
    }
}
);
console.log(newObj.name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;您访问了name属性 jack&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;proxy对象的get(target,property)：&lt;/strong&gt;简单封装创建DOM元素的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 使用proxy对象简单封装创建DOM元素的方法 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const DOM &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Proxy({},{
    get(target,property){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(target,property);&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;(attr=&lt;span&gt;{},...children){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(attr,children);&lt;/span&gt;
            let el =&lt;span&gt; document.createElement(property);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(key of Object.keys(attr)){
                el.setAttribute(key,attr[key]);
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(child of Object.values(children)){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; child == 'string'&lt;span&gt;){
                    child &lt;/span&gt;=&lt;span&gt; document.createTextNode(child);
                }
                el.appendChild(child);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; el;
        }
    }
});
let oDiv &lt;/span&gt;=&lt;span&gt; DOM.div(
    {id:&lt;/span&gt;'div1'},'我是div','哈哈哈'&lt;span&gt;,
    DOM.a({href:&lt;/span&gt;'http://www.baidu.com'},'访问百度'&lt;span&gt;),
    DOM.ul({},
        DOM.li({},&lt;/span&gt;'1111'&lt;span&gt;),
        DOM.li({},&lt;/span&gt;'2222'&lt;span&gt;),
        DOM.li({},&lt;/span&gt;'3333'&lt;span&gt;),
        DOM.li({},&lt;/span&gt;'4444'&lt;span&gt;)
    )
);
window.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    document.body.appendChild(oDiv);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;proxy对象的set(target,prop,value)：检测设置年龄是否达到要求&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Proxy({},{
    set(target,prop,value){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(target,prop,value);&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(prop == 'age'&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;Number.isInteger(value)){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TypeError('年龄必须为整数'&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(value&amp;gt;200&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RangeError('年龄超标了，必须小于200岁'&lt;span&gt;);
            }
        }
        target[prop]&lt;/span&gt;=&lt;span&gt;value;
    }
});
obj.a &lt;/span&gt;= 123&lt;span&gt;;
obj.name &lt;/span&gt;= 'pilot'&lt;span&gt;;
console.log(obj);
obj.age &lt;/span&gt;= 201;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;proxy对象的deleteProperty(target,property)：删除对象属性之前，显示提示信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let json =&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    b:&lt;/span&gt;2&lt;span&gt;
}
let newJson &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Proxy(json,{
    deleteProperty(target,property){
        console.log(`您要删除${property}属性`);
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; target[property];
    }
});
&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; newJson.a;
console.log(newJson);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;proxy对象的has(target,property)：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let json =&lt;span&gt; {
    a:&lt;/span&gt;1&lt;span&gt;,
    b:&lt;/span&gt;2&lt;span&gt;
}
let newJson &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Proxy(json,{
    has(target,property){
        console.log(`判断是否存在调用has方法`);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; property &lt;span&gt;in&lt;/span&gt;&lt;span&gt; target;
    }
});
console.log(&lt;/span&gt;'a' &lt;span&gt;in&lt;/span&gt; newJson);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
console.log(newJson);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;proxy对象的apply()：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '我是一个函数'&lt;span&gt;;
}
let newFn &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Proxy(fn,{
    apply(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '函数么?'&lt;span&gt;;
    }
});
console.log(newFn());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;apply结合reflect()来使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum(a,b){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;
}
let newSum &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Proxy(sum,{
    apply(target,context,args){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(target,context,args);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(...arguments);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; return Reflect.apply(...arguments);//8&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; Reflect.apply(...arguments)**2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;
&lt;span&gt;    }
});
console.log(newSum(&lt;/span&gt;3,5));
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;7.5Reflect反射：&lt;strong&gt;类似fn.call()、fn.apply()&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;定义：Reflect.apply(调用的函数,this指向,参数数组)&lt;/p&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(Math.ceil(5.2));//6&lt;/span&gt;
let res = Reflect.apply(Math.ceil,&lt;span&gt;null&lt;/span&gt;,[6.8&lt;span&gt;]);
console.log(res);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检测对象的某一项属性是否存在：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(Reflect.has(Object,'assign'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除对象的某一项属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let json = {a:1,b:2&lt;span&gt;};
Reflect.deleteProperty(json,&lt;/span&gt;'a'&lt;span&gt;);
console.log(json);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{b: 2}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;---------------------END---------------------&lt;/p&gt;
&lt;p&gt;到这也就全部都完了，ES6以及ESNext的一些东西，感谢观看！&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 17:28:00 +0000</pubDate>
<dc:creator>消逝的风i</dc:creator>
<og:description>1.ES6中的面向对象的类 1.1、定义类 在ES5中，我们写一个类，通常是这么写的 在ES6中，我们可以这样写 注意： （1）.ES6里面Class没有提升(例如ES5中的函数有提升到顶部的作用)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abc-x/p/10799583.html</dc:identifier>
</item>
<item>
<title>使用高性能Pipelines构建.NET通讯程序 - 波多尔斯基</title>
<link>http://www.cnblogs.com/podolski/p/10807204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/podolski/p/10807204.html</guid>
<description>&lt;p&gt;.NET Standard支持一组新的API，System.Span, System.Memory，还有System.IO.Pipelines。这几个新的API极大了提升了.NET程序的效能，将来.NET很多基础API都会使用它们进行重写。&lt;/p&gt;
&lt;p&gt;Pipelines旨在解决.NET编写Socket通信程序时的很多&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/&quot;&gt;困难&lt;/a&gt;，相信读者也对此不胜其烦，使用stream模型进行编程，就算能够解决，也是实在麻烦。&lt;/p&gt;
&lt;p&gt;System.IO.Pipelines使用简单的内存片段来管理数据，可以极大的简化编写程序的过程。关于Pipelines的详细介绍，可以看看&lt;a href=&quot;http://www.cnblogs.com/xxfy1/p/9290235.html&quot;&gt;这里&lt;/a&gt;。现在ASP.NET Core中使用的Kestrel已经在使用这个API。（话说这个东西貌似就是Kestrel团队搞出来的。）&lt;/p&gt;
&lt;p&gt;可能是直接需要用Socket场景有限（物联网用的还挺多的），Pipelines相关的资料感觉不是很多。官方给出的示例是基于ASCII协议的，有固定结尾的协议，这里我以物联网设备常用的BINARY二进制自定义协议为例，讲解基于Pipelines的程序套路。&lt;/p&gt;

&lt;p&gt;与基于Stream的方式不同，pipelines提供一个pipe，用于存储数据，pipe中间存储的数据有点链表的感觉，可以基于&lt;code&gt;SequencePosition&lt;/code&gt;进行slice操作，这样就能得到一个&lt;code&gt;ReadOnlySequence&amp;lt;T&amp;gt;&lt;/code&gt;对象。reader可以进行自定义操作，并在操作完成之后告诉pipe已经处理了多少数据，整个过程是不需要进行内存复制操作的，因此性能得到了提升，还少了很多麻烦。可以简单理解作为服务器端，流程：&lt;/p&gt;
&lt;p&gt;接受数据循环：接到数据-&amp;gt;放pipe里面-&amp;gt;告诉pipe放了多少数据&lt;br/&gt;处理数据循环：在pipe里面找一条完整数据-&amp;gt;交给处理流程-&amp;gt;告诉pipe处理了多少数据&lt;/p&gt;

&lt;p&gt;有一款设备，binary协议，数据包开头0x75, 0xbd, 0x7e, 0x97一共4个字节，随后跟数据包长度2个字节（固定2400字节，不固定长度也可以参照），随后是数据区。在设备连接成功之后，数据主动从设备发送到PC。&lt;/p&gt;

&lt;p&gt;虽然是.NET Core平台的，但是.NET FRAMEWORK 4.6.1上面也可以nuget安装，直接&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;install-package system.io.pipelines&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进行安装就可以了。Socket相关处理的代码不再写了，只列关键的。&lt;/p&gt;
&lt;p&gt;代码第一步是声明pipe。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private async void InitPipe(Socket socket)
{
    Pipe pipe = new Pipe();
    Task writing = FillPipeAsync(socket, pipe.Writer);
    Task reading = ReadPipeAsync(socket, pipe.Reader);

    await Task.WhenAll(reading, writing);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pipe有reader还有一个writer，reader负责读取pipe数据，主要用在数据处理循环，writer负责将数据写入pipe，主要用在数据接受循环。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//写入循环
private async Task FillPipeAsync(Socket socket, PipeWriter writer)
{
    //数据流量比较大，用1M字节作为buffer
    const int minimumBufferSize = 1024 * 1024;

    while (running)
    {
        try
        {
            //从writer中，获得一段不少于指定大小的内存空间
            Memory&amp;lt;byte&amp;gt; memory = writer.GetMemory(minimumBufferSize);

            //将内存空间变成ArraySegment，提供给socket使用
            if (!MemoryMarshal.TryGetArray((ReadOnlyMemory&amp;lt;byte&amp;gt;)memory, out ArraySegment&amp;lt;byte&amp;gt; arraySegment))
            {
                throw new InvalidOperationException(&quot;Buffer backed by array was expected&quot;);
            }
            //接受数据
            int bytesRead = await SocketTaskExtensions.ReceiveAsync(socket, arraySegment, SocketFlags.None);
            if (bytesRead == 0)
            {
                break;
            }

            //一次接受完毕，数据已经在pipe中，告诉pipe已经给它写了多少数据。
            writer.Advance(bytesRead);
        }
        catch
        {
            break;
        }

        // 提示reader可以进行读取数据，reader可以继续执行readAsync()方法
        FlushResult result = await writer.FlushAsync();

        if (result.IsCompleted)
        {
            break;
        }
    }

    // 告诉pipe完事了
    writer.Complete();
}

//读取循环
private async Task ReadPipeAsync(Socket socket, PipeReader reader)
{
    while (running)
    {
        //等待writer写数据
        ReadResult result = await reader.ReadAsync();
        //获得内存区域
        ReadOnlySequence&amp;lt;byte&amp;gt; buffer = result.Buffer;
        SequencePosition? position = null;

        do
        {
            //寻找head的第一个字节所在的位置
            position = buffer.PositionOf((byte)0x75);
            if (position != null)
            {
                //由于是连续四个字节作为head，需要进行比对，我这里直接使用了ToArray方法，还是有了内存拷贝动作，不是很理想，但是写起来很方便。
                //对性能有更高要求的场景，可以进行slice操作后的单独比对，这样不需要内存拷贝动作
                var headtoCheck = buffer.Slice(position.Value, 4).ToArray();
                //SequenceEqual需要引用System.Linq
                if (headtoCheck.SequenceEqual(new byte[] { 0x75, 0xbd, 0x7e, 0x97 }))
                {
                    //到这里，认为找到包开头了（从position.value开始），接下来需要从开头处截取整包的长度，需要先判断长度是否足够
                    if (buffer.Slice(position.Value).Length &amp;gt;= 2400)
                    {
                        //长度足够，那么取出ReadOnlySequence，进行操作
                        var mes = buffer.Slice(position.Value, 2400);
                        //这里是数据处理的函数，可以参考官方文档对ReadOnlySequence进行操作，文档里面使用了span，那样性能会好一些。我这里简单实用ToArray()操作，这样也有了内存拷贝的问题，但是处理的直接是byte数组了。
                        await ProcessMessage(mes.ToArray());
                        //这一段就算是完成了，从开头位置，一整个包的长度就算完成了
                        var next = buffer.GetPosition(2400, position.Value);
                        //将buffer处理过的舍弃，替换为剩余的buffer引用
                        buffer = buffer.Slice(next);
                    }
                    else
                    {
                        //长度不够，说明数据包不完整，等下一波数据进来再拼接，跳出循环。
                        break;
                    }
                }
                else
                {
                    //第一个是0x75但是后面不匹配，可能有数据传输问题，那么需要舍弃第一个，0x75后面的字节开始再重新找0x75
                    var next = buffer.GetPosition(1, position.Value);
                    buffer = buffer.Slice(next);
                }
            }
        }
        while (position != null);

        //数据处理完毕，告诉pipe还剩下多少数据没有处理（数据包不完整的数据，找不到head）
        reader.AdvanceTo(buffer.Start, buffer.End);

        if (result.IsCompleted)
        {
            break;
        }
    }

    reader.Complete();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码基本解决了以下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据接收不完整，找不到开头结尾，导致数据大量丢弃，或者自己维护一个queue的代码复杂性&lt;/li&gt;
&lt;li&gt;数据接收与处理的同步问题&lt;/li&gt;
&lt;li&gt;一次性收到多条数据的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文只是解释了pipeline处理的模式，对于茫茫多的ToArray方法，可以使用基于Span的操作进行优化（有时间就来填坑）。另外，如果在&lt;code&gt;await ProcessMessage(mes.ToArray());&lt;/code&gt;这里，直接使用&lt;code&gt;Task.Run(()=&amp;gt;ProcessMessage(mes);&lt;/code&gt;代替的话，实测会出现莫名其妙的问题，很有可能是pipe运行快，在系统调度Task之前，已经将内存释放导致的，如果需要优化这一块的话，需要格外注意。&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 16:26:00 +0000</pubDate>
<dc:creator>波多尔斯基</dc:creator>
<og:description>.NET Standard支持一组新的API，System.Span, System.Memory，还有System.IO.Pipelines。这几个新的API极大了提升了.NET程序的效能，将来.N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/podolski/p/10807204.html</dc:identifier>
</item>
<item>
<title>SpringBoot profles配置多环境 - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/10807200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10807200.html</guid>
<description>&lt;p&gt;SpringBoot profles配置多环境&lt;br/&gt;23/100&lt;br/&gt;发布文章&lt;br/&gt;u014427391&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件环境简介&lt;/strong&gt;&lt;br/&gt;这里介绍一下SpringBoot提供的profiles属性加上maven配置一下多环境，在实践生产中，正规一点的可能有开发环境、测试环境、预发布环境、生产环境等等，而这些环境的参数肯定都不一样，换环境的时候，经常需要修改参数，参数一多，维护起来很麻烦，所以SpringBoot提供了通过profiles配置来达到多环境配置，不需要项目一上生产环境还是预发布就改一堆配置文件。&lt;/p&gt;
&lt;p&gt;软件环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;application-dev（开发环境）&lt;/li&gt;
&lt;li&gt;application-test（测试环境）&lt;/li&gt;
&lt;li&gt;application-uat（预发布）&lt;/li&gt;
&lt;li&gt;application-prod（生产环境）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置文件格式可以为preperties或者yml，因为yml写起来比较简介，所以本博客介绍一yml的配置文件，介绍一下配置方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yml配置profiles&lt;/strong&gt;&lt;br/&gt;先介绍一下通过SpringBoot配置文件的这种方式，这里需要新建如图yml配置文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190503223512823.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;application-dev.yml（开发环境）&lt;/li&gt;
&lt;li&gt;application-test.yml（测试环境）&lt;/li&gt;
&lt;li&gt;application-uat.yml（预发布）&lt;/li&gt;
&lt;li&gt;application-prod.yml（生产环境）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置比较容易，需要在application.yml配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  profiles:
    active: dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给出我的application.yml配置，可以参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  context-path: /jeeplatform
  error:
    whitelabel:
      enabled: true

spring:
  profiles:
    active: dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开发环境apprlication-dev.yml配置，根据自己需要配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8080

spring:

  datasource:

    # 主数据源
    shop:
      url: jdbc:mysql://127.0.0.1:3306/jeeplatform?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;characterSetResults=utf8&amp;amp;useSSL=false
      username: root
      password: root

    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    # 连接池设置
    druid:
      initial-size: 5
      min-idle: 5
      max-active: 20
      # 配置获取连接等待超时的时间
      max-wait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
      time-between-eviction-runs-millis: 60000
      # 配置一个连接在池中最小生存的时间，单位是毫秒
      min-evictable-idle-time-millis: 300000
      # Oracle请使用select 1 from dual
      validation-query: SELECT 'x'
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      # 打开PSCache，并且指定每个连接上PSCache的大小
      pool-prepared-statements: true
      max-pool-prepared-statement-per-connection-size: 20
      # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
      filters: stat,wall,slf4j
      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
      connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
      # 合并多个DruidDataSource的监控数据
      use-global-data-source-stat: true

  # JPA配置
  jpa:
    database: mysql
    hibernate:
      show_sql: true
      format_sql: true
      ddl-auto: none
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

  # MVC配置
  mvc:
    view:
      prefix: /WEB-INF/jsp/
      suffix: .jsp

  #Jedis配置
  jedis :
    pool :
      host : 127.0.0.1
      port : 6379
      password : redispassword
      timeout : 0
      config :
        maxTotal : 100
        maxIdle : 10
        maxWaitMillis : 100000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试环境、预发布环境、生产环境的配置类似，根据需要配置&lt;/p&gt;
&lt;p&gt;如果是jar，可以直接运行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -jar [jar名称].jar --spring.profiles.active=[环境参数(dev|test|uat|prod)]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -jar myproject.jar --spring.profiles.active = dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;拓展，配置maven&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是另外的拓展，其实也是基于前面的配置，配置多环境信息在maven的pom文件里，主要目的是maven打包的时候，可以通过传环境参数对应package&lt;/p&gt;
&lt;p&gt;配置，需要在maven的pom文件添加配置信息，这里设置默认开发环境，设置&lt;code&gt;&amp;lt;activeByDefault&amp;gt;&lt;/code&gt;为true&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;profiles&amp;gt;
        &amp;lt;profile&amp;gt;
            &amp;lt;id&amp;gt;dev&amp;lt;/id&amp;gt;
            &amp;lt;properties&amp;gt;
                &amp;lt;activatedProperties&amp;gt;dev&amp;lt;/activatedProperties&amp;gt;
                &amp;lt;project.packaging&amp;gt;jar&amp;lt;/project.packaging&amp;gt;
            &amp;lt;/properties&amp;gt;
            &amp;lt;activation&amp;gt;
                &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
            &amp;lt;/activation&amp;gt;
        &amp;lt;/profile&amp;gt;
        &amp;lt;profile&amp;gt;
            &amp;lt;id&amp;gt;test&amp;lt;/id&amp;gt;
            &amp;lt;properties&amp;gt;
                &amp;lt;activatedProperties&amp;gt;test&amp;lt;/activatedProperties&amp;gt;
                &amp;lt;project.packaging&amp;gt;jar&amp;lt;/project.packaging&amp;gt;
            &amp;lt;/properties&amp;gt;
        &amp;lt;/profile&amp;gt;
        &amp;lt;profile&amp;gt;
            &amp;lt;id&amp;gt;uat&amp;lt;/id&amp;gt;
            &amp;lt;properties&amp;gt;
                &amp;lt;activatedProperties&amp;gt;uat&amp;lt;/activatedProperties&amp;gt;
                &amp;lt;project.packaging&amp;gt;jar&amp;lt;/project.packaging&amp;gt;
            &amp;lt;/properties&amp;gt;
        &amp;lt;/profile&amp;gt;
        &amp;lt;profile&amp;gt;
            &amp;lt;id&amp;gt;prod&amp;lt;/id&amp;gt;
            &amp;lt;properties&amp;gt;
                &amp;lt;activatedProperties&amp;gt;prod&amp;lt;/activatedProperties&amp;gt;
                &amp;lt;project.packaging&amp;gt;jar&amp;lt;/project.packaging&amp;gt;
            &amp;lt;/properties&amp;gt;
        &amp;lt;/profile&amp;gt;
    &amp;lt;/profiles&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以修改一下application.yml：直接读maven配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  context-path: /jeeplatform
  error:
    whitelabel:
      enabled: true

spring:
  profiles:
    active: @activatedProperties@
  application:
    name: @project.name@_${spring.profiles.active}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;maven根据环境package&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;maven clean package -Pdev | -Ptest | -Puat | -Pprod&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg：直接package开发环境的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;maven clean package -Pdev &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;软件环境简介&lt;br/&gt;这里介绍一下SpringBoot提供的profiles属性加上maven配置一下多环境，在实践生产中，正规一点的可能有开发环境、测试环境、预发布环境、生产环境等等，而这些环境的参数肯定都不一样，换环境的时候，经常需要修改参数，参数一多，维护起来很麻烦，所以SpringBoot提供了通过profiles配置来达到多环境配置，不需要项目一上生产环境还是预发布就改一堆配置文件。&lt;/p&gt;
&lt;p&gt;软件环境：&lt;/p&gt;
&lt;p&gt;application-dev（开发环境）&lt;br/&gt;application-test（测试环境）&lt;br/&gt;application-uat（预发布）&lt;br/&gt;application-prod（生产环境）&lt;br/&gt;配置文件格式可以为preperties或者yml，因为yml写起来比较简介，所以本博客介绍一yml的配置文件，介绍一下配置方式：&lt;/p&gt;
&lt;p&gt;yml配置profiles&lt;br/&gt;先介绍一下通过SpringBoot配置文件的这种方式，这里需要新建如图yml配置文件：&lt;/p&gt;
&lt;p&gt;在这里插入图片描述&lt;/p&gt;
&lt;p&gt;application-dev.yml（开发环境）&lt;br/&gt;application-test.yml（测试环境）&lt;br/&gt;application-uat.yml（预发布）&lt;br/&gt;application-prod.yml（生产环境）&lt;br/&gt;配置比较容易，需要在application.yml配置：&lt;/p&gt;
&lt;p&gt;spring:&lt;br/&gt;profiles:&lt;br/&gt;active: dev&lt;/p&gt;
&lt;p&gt;给出我的application.yml配置，可以参考：&lt;/p&gt;
&lt;p&gt;server:&lt;br/&gt;context-path: /jeeplatform&lt;br/&gt;error:&lt;br/&gt;whitelabel:&lt;br/&gt;enabled: true&lt;/p&gt;
&lt;p&gt;spring:&lt;br/&gt;profiles:&lt;br/&gt;active: dev&lt;/p&gt;
&lt;p&gt;开发环境apprlication-dev.yml配置，根据自己需要配置：&lt;/p&gt;
&lt;p&gt;server:&lt;br/&gt;port: 8080&lt;/p&gt;
&lt;p&gt;spring:&lt;/p&gt;
&lt;p&gt;datasource:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 主数据源
shop:
  url: jdbc:mysql://127.0.0.1:3306/jeeplatform?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;characterSetResults=utf8&amp;amp;useSSL=false
  username: root
  password: root

driver-class-name: com.mysql.jdbc.Driver
type: com.alibaba.druid.pool.DruidDataSource

# 连接池设置
druid:
  initial-size: 5
  min-idle: 5
  max-active: 20
  # 配置获取连接等待超时的时间
  max-wait: 60000
  # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
  time-between-eviction-runs-millis: 60000
  # 配置一个连接在池中最小生存的时间，单位是毫秒
  min-evictable-idle-time-millis: 300000
  # Oracle请使用select 1 from dual
  validation-query: SELECT 'x'
  test-while-idle: true
  test-on-borrow: false
  test-on-return: false
  # 打开PSCache，并且指定每个连接上PSCache的大小
  pool-prepared-statements: true
  max-pool-prepared-statement-per-connection-size: 20
  # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
  filters: stat,wall,slf4j
  # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
  connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
  # 合并多个DruidDataSource的监控数据
  use-global-data-source-stat: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;# JPA配置&lt;br/&gt;jpa:&lt;br/&gt;database: mysql&lt;br/&gt;hibernate:&lt;br/&gt;show_sql: true&lt;br/&gt;format_sql: true&lt;br/&gt;ddl-auto: none&lt;br/&gt;naming:&lt;br/&gt;physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl&lt;/p&gt;
&lt;p&gt;# MVC配置&lt;br/&gt;mvc:&lt;br/&gt;view:&lt;br/&gt;prefix: /WEB-INF/jsp/&lt;br/&gt;suffix: .jsp&lt;/p&gt;
&lt;p&gt;#Jedis配置&lt;br/&gt;jedis :&lt;br/&gt;pool :&lt;br/&gt;host : 127.0.0.1&lt;br/&gt;port : 6379&lt;br/&gt;password : redispassword&lt;br/&gt;timeout : 0&lt;br/&gt;config :&lt;br/&gt;maxTotal : 100&lt;br/&gt;maxIdle : 10&lt;br/&gt;maxWaitMillis : 100000&lt;br/&gt;测试环境、预发布环境、生产环境的配置类似，根据需要配置&lt;/p&gt;
&lt;p&gt;如果是jar，可以直接运行命令：&lt;/p&gt;
&lt;p&gt;java -jar [jar名称].jar --spring.profiles.active=[环境参数(dev|test|uat|prod)]&lt;br/&gt;eg：&lt;/p&gt;
&lt;p&gt;java -jar myproject.jar --spring.profiles.active = dev&lt;br/&gt;拓展，配置maven&lt;/p&gt;
&lt;p&gt;这是另外的拓展，其实也是基于前面的配置，配置多环境信息在maven的pom文件里，主要目的是maven打包的时候，可以通过传环境参数对应package&lt;/p&gt;
&lt;p&gt;配置，需要在maven的pom文件添加配置信息，这里设置默认开发环境，设置&lt;/p&gt;
&lt;p&gt;可以修改一下application.yml：直接读maven配置文件：&lt;/p&gt;
&lt;p&gt;server:&lt;br/&gt;context-path: /jeeplatform&lt;br/&gt;error:&lt;br/&gt;whitelabel:&lt;br/&gt;enabled: true&lt;/p&gt;
&lt;p&gt;spring:&lt;br/&gt;profiles:&lt;br/&gt;active: @activatedProperties@&lt;br/&gt;application:&lt;br/&gt;name: @project.name@_${spring.profiles.active}&lt;br/&gt;maven根据环境package&lt;/p&gt;
&lt;p&gt;maven clean package -Pdev | -Ptest | -Puat | -Pprod&lt;br/&gt;eg：直接package开发环境的&lt;/p&gt;
&lt;p&gt;maven clean package -Pdev&lt;br/&gt;Markdown 已选中 3409 字数 200 行数 当前行 200, 当前列 0 HTML 3270 字数 145 段落&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 16:22:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>SpringBoot profles配置多环境 23/100 发布文章 u014427391 软件环境简介 这里介绍一下SpringBoot提供的profiles属性加上maven配置一下多环境，在实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10807200.html</dc:identifier>
</item>
<item>
<title>设计模式--桥模式 - SkyMelody</title>
<link>http://www.cnblogs.com/David-Lin/p/10807168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/David-Lin/p/10807168.html</guid>
<description>&lt;p&gt;考虑要设计一个Messager模块，这个模块要实现如下功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登录&lt;/li&gt;
&lt;li&gt;发送消息&lt;/li&gt;
&lt;li&gt;播放声音(登录或者播放的时候播放声音)&lt;/li&gt;
&lt;li&gt;画图(登录的时候显示的图片)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么最直观的设计如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Messager {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Login(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt; password) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SendMessage(&lt;span&gt;string&lt;/span&gt; message) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
　　
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PlaySound() = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawShape() = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;Message() {}
};&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后呢，我们这个Messager要实现跨平台的功能，要在PC平台和手机平台都能适用。然而对于PC和Mobile来说，唯一有区别的地方只有播放声音和画图这些与平台相关的函数不同，而登录、发送消息这些业务功能是相同的，所以你可能会设计出如下的两个类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; PCMessagerBase : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Messager {
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PlaySound() { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawShape() { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MobileMessagerBase : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Messager {
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PlaySound() { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawShape() { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
};&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;/&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来继续考虑在同一个平台要推出两个不同版本的Messager，一个是精简版，一个是完美版。比如说精简版的在登录的时候不会播放声音和显示图片，而完美版的则支持这两个功能。其设计可能如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; PCMessagerLite : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PCMessagerBase {
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Login(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt; password) { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SendMessage() { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; PCMessagerPerfect : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PCMessagerBase {
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Login(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; password) {
　　　　PCMessageBase::PlaySound();
　　　　PCMessageBase::DrawShape();
　　}
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SendMessage() {
　　　　PCMessageBase::PlaySound();
　　　　PCMessageBase::DrawShape();
　　}
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MobileMessagerLite : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MobileMessagerBase {
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Login(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt; password) { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SendMessage() { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MobileMessagerPerfect : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MobileMessagerBase {
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Login(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; password) {
　　　　MobileMessageBase::PlaySound();
　　　　MobileMessageBase::DrawShape();
　　}
　　&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SendMessage() {
　　　　MobileMessageBase::PlaySound();
　　　　MobileMessageBase::DrawShape();
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么到目前为止，类的结构图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1253756/201905/1253756-20190503232825227-865522443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这么设计有什么缺点呢？缺点是代码重复性太大了。这种重复是一种结构性的重复。你仔细观察观察MobileMessagerPerfect和PCMessagerPeferct这两个类中Login和SendMessage的实现，会发现他们的流程是一模一样的，都是播放声音，显示登录画面，登录。不同的只是因为平台导致的播放声音和登录画面的实现不同。&lt;/p&gt;

&lt;p&gt;那么有什么改进的方法呢？ 你可以发现在Perfect类的Login中的PlaySound和DrawShape可以追溯到同一个虚函数调用。如果你知道装饰者模式的话，那么你很快的可以想到改进的方法是将PCMobildBase作为一个类的字段去组合它，而不是去继承它&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
class PCMessagePerfect {&lt;br/&gt;private:&lt;br/&gt;　　PCMessageBase* message;&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过message-&amp;gt;PlaySound()来调用。同理MobildMessagePerfect中设计一个MobileMessageBase*字段。但是如果都申明为一个具体平台的Base字段的话，程序又写的太死了，所以你又发现可以将这个类的字段申明为Message*，然后在将来要构造Perfect对象的时候传进去一个具体的Base对象。但是现在问题又来了，现在*Base对象是个抽象类，是无法new出对象的。(Login, SendMessage等方法没有实现)&lt;/p&gt;
&lt;p&gt;那么问题的根源是什么？原因在是Message类中，你把业务逻辑(Login, SendMessage)和平台实现(PlaySound, DrawShap)混合到一起了，这样做是很不合适的，应该将他们拆分开。&lt;/p&gt;
&lt;p&gt;最终的类设计应该如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
class Message { Login, SendMessage }  // 业务功能部分&lt;br/&gt;class MessageImp { PlaySound, DrawShap } // 平台实现部分&lt;br/&gt;class PCMessageBase : MessageImp {} // 具体的平台实现&lt;br/&gt;class PCMessagePerfect : Message {　　// 继承Message的业务功能部分&lt;br/&gt;　　MessageImp* messageImp;　　　　　　// 组合得到Message的平台功能部分&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 03 May 2019 16:06:00 +0000</pubDate>
<dc:creator>SkyMelody</dc:creator>
<og:description>考虑要设计一个Messager模块，这个模块要实现如下功能 登录 发送消息 播放声音(登录或者播放的时候播放声音) 画图(登录的时候显示的图片) 那么最直观的设计如下 然后呢，我们这个Messager</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/David-Lin/p/10807168.html</dc:identifier>
</item>
<item>
<title>回顾下自己都写了什么 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10807130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10807130.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;注册博客园以来已经8年多了，一开始在CSDN 和博客园之间选择是也做过一些纠结。&lt;br/&gt;但最终还是选择了在博客园记录我的一些学习心得与技术笔记。主要的原因还是因为博客园非常简单，没有太功利性的东西(比如铺天盖地的广告)，同时也有大量的业界牛人在使用这个平台，从谷歌上搜索到的许多高质量的技术博客都来自于这里。&lt;br/&gt;可惜的自己是在过去的大多数时间里，基本都在忙着做项目..，一次次笃定下心来写博客的计划总是被不停打断而告终。&lt;/p&gt;
&lt;p&gt;大约在2018下半年开始，决定写一些系列性的文章，包括 &lt;strong&gt;springboot 补习系列&lt;/strong&gt;、&lt;strong&gt;MongoDB 系列&lt;/strong&gt;等等。&lt;br/&gt;趁着工作十年之际，也赶紧把&lt;strong&gt;十年老兵的职场笔录&lt;/strong&gt; 给写了，省的后面想写又写不出来..&lt;/p&gt;
&lt;p&gt;另外就是配合着自己工作的情况，把更新节奏维持在一周一篇左右(不快也不慢)，渐渐的也看到了一些产出，在这里自己是感到有点欣慰的！&lt;br/&gt;当然，期间也有一些编辑朋友来咨询约稿，这也至少能说明自己写的东西还不算很烂。&lt;/p&gt;
&lt;p&gt;在博客之外，也开启了&lt;strong&gt;自己的一个公众号&quot;美码师&quot;&lt;/strong&gt;，因为平时都是在朋友圈内发一发文章，所以关注的人不多，也大多是认识的朋友。&lt;br/&gt;尽管如此，到现在我仍然觉得公众号是一种&lt;strong&gt;自我成长的很好的方式&lt;/strong&gt;，它至少能驱动你去做一件持续的事情而且还能提高自己的一些思考能力。&lt;br/&gt;当然，也&lt;strong&gt;非常欢迎关注、与我留言或交流&lt;/strong&gt;，这一定能给我增加写作的一些动力。&lt;/p&gt;
&lt;p&gt;下面大概整理了下之前一些文章的索引，希望能尽量看起来美观些。&lt;/p&gt;
&lt;h2 id=&quot;springboot-补习系列&quot;&gt;SpringBoot 补习系列&lt;/h2&gt;
&lt;h2 id=&quot;java-技术相关&quot;&gt;Java 技术相关&lt;/h2&gt;
&lt;h2 id=&quot;web-安全技术&quot;&gt;Web 安全技术&lt;/h2&gt;
&lt;h2 id=&quot;数据库中间件&quot;&gt;数据库中间件&lt;/h2&gt;
&lt;h2 id=&quot;杂谈其他&quot;&gt;杂谈&amp;amp;其他&lt;/h2&gt;
</description>
<pubDate>Fri, 03 May 2019 15:47:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 前言 注册博客园以来已经8年多了，一开始在CSDN 和博客园之间选择是也做过一些纠结。 但最终还是选择了在博客园记录我的一些学习心得与技术笔记。主要的原因还是因为博客园非常简单，没有太功利</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10807130.html</dc:identifier>
</item>
<item>
<title>WPS Office 2019 for Linux来了 - chenxiaopang</title>
<link>http://www.cnblogs.com/pandachen/p/10807089.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pandachen/p/10807089.html</guid>
<description>&lt;p&gt;&lt;span&gt;难得啊，焕然一新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685303/201905/685303-20190503231705271-558403741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685303/201905/685303-20190503231738931-2054450531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;log_main&quot;&gt;
&lt;h2 class=&quot;log_title&quot;&gt;WPS Office 2019 For Linux更新说明&lt;/h2&gt;
&lt;h3 class=&quot;log_h3&quot;&gt;11.1.0.8392 版本主要更新：&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;修复wpsoffice进程存在时不能关机的问题&lt;/li&gt;
&lt;li&gt;修复WPS文字模块web版式下拖动自选图形，WPS崩溃的问题&lt;/li&gt;
&lt;li&gt;修复文档标签tooltip重影的问题&lt;/li&gt;
&lt;li&gt;优化黑色主题下，部分对话框内容显示不清晰的问题&lt;/li&gt;
&lt;li&gt;安装包去除垃圾资源&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;log_h3&quot;&gt;11.1.0.8372 版本主要更新：&lt;/h3&gt;
&lt;h3&gt;WPS公共&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;全新的皮肤风格、图标、控点等，支持高分辨率屏幕、自定义外观&lt;/li&gt;
&lt;li&gt;全新的新建页面，整合最近打开文档、本地模板、公文模板、在线模板等&lt;/li&gt;
&lt;li&gt;设置字体字号时，文档区域支持预览效果&lt;/li&gt;
&lt;li&gt;新增内置浏览器&lt;/li&gt;
&lt;li&gt;支持首页，集合文档搜索、常用位置、云文档等入口&lt;/li&gt;
&lt;li&gt;支持个人中心，展示账号详细资料，可修改账号信息&lt;/li&gt;
&lt;li&gt;支持插入SVG格式图片&lt;/li&gt;
&lt;li&gt;支持插入二维码、条形码&lt;/li&gt;
&lt;li&gt;支持多窗口、多标签自由拆分和组合，以及自由管理标签&lt;/li&gt;
&lt;li&gt;支持为图表中的日期/时间设置区域&lt;/li&gt;
&lt;li&gt;支持维吾尔语排版&lt;/li&gt;
&lt;li&gt;优化皮肤和外观设置，支持自定义外观&lt;/li&gt;
&lt;li&gt;优化功能区布局，调整在窗口比较小时的压缩规则，支持调整快速访问工具栏的宽度&lt;/li&gt;
&lt;li&gt;修复云文档上传失败的问题&lt;/li&gt;
&lt;li&gt;修复文本自动色跟随主题的问题&lt;/li&gt;
&lt;li&gt;修复黑色主题下，WPS表格背景色为黑色的问题&lt;/li&gt;
&lt;li&gt;修改字体匹配规则&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;log_h3&quot;&gt;WPS文字&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;新增导航窗格，支持目录导航、页面导航、书签导航的功能&lt;/li&gt;
&lt;li&gt;新增阅读版式，支持以图书的分栏样式显示文档内容&lt;/li&gt;
&lt;li&gt;新增字体替换功能&lt;/li&gt;
&lt;li&gt;新增中文拼写检查入口&lt;/li&gt;
&lt;li&gt;新增调整表格行高和列宽的入口&lt;/li&gt;
&lt;li&gt;新增对自动编号调整缩进的入口&lt;/li&gt;
&lt;li&gt;新增quote域，引用其他域的计算结果作为参数做二次解析&lt;/li&gt;
&lt;li&gt;支持更新手动目录&lt;/li&gt;
&lt;li&gt;支持页眉页脚的HTML写盘&lt;/li&gt;
&lt;li&gt;支持插入超链接时，可链接到文档中的某个书签&lt;/li&gt;
&lt;li&gt;提供插入方框、打勾方框、打叉方框，自动识别文档中的方框，支持打勾或取消打勾操作&lt;/li&gt;
&lt;li&gt;对于大部分命令支持按F4，重复上一次的操作&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;log_h3&quot;&gt;WPS表格&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;支持粘贴时跳过筛选隐藏的单元格，只粘贴到可见单元格&lt;/li&gt;
&lt;li&gt;支持筛选时检查区域下方数据并扩展筛选区域&lt;/li&gt;
&lt;li&gt;支持智能填充&lt;/li&gt;
&lt;li&gt;支持显示表格筛选标题&lt;/li&gt;
&lt;li&gt;支持多工作表数据合并&lt;/li&gt;
&lt;li&gt;支持列的筛选、筛选条件设置&lt;/li&gt;
&lt;li&gt;支持在右键菜单中设置筛选条件&lt;/li&gt;
&lt;li&gt;支持提取或标记数据中重复值、唯一值&lt;/li&gt;
&lt;li&gt;支持在常用公式中，2019.01.01后所得税的计算&lt;/li&gt;
&lt;li&gt;支持打开HTML文件或粘贴为HTML时，显示进度条&lt;/li&gt;
&lt;li&gt;支持在数字格式对话框中，设置万元、正负号格式&lt;/li&gt;
&lt;li&gt;支持对单元格前后有空字符串进行错误检查&lt;/li&gt;
&lt;li&gt;支持冻结窗格下，区选单元格区域时实现滚动减速&lt;/li&gt;
&lt;li&gt;数字格式中，区域为日本时，新增日历类型“日本年号”&lt;/li&gt;
&lt;li&gt;修复保存工作簿至共享路径时提示共享冲突的问题&lt;/li&gt;
&lt;li&gt;修复Fedora平台下，设置屏幕缩放为200%后，输入字体重叠的问题&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;log_h3&quot;&gt;WPS演示&lt;/h3&gt;
&lt;ol class=&quot;log_ul&quot;&gt;&lt;li&gt;智能图形支持了97种图形的插入和编辑，37种图形仅支持读写&lt;/li&gt;
&lt;li&gt;拆分幻灯片切换和动画选项卡，提升动画易用性&lt;/li&gt;
&lt;li&gt;新增字体缺失提醒功能，可实现幻灯片中缺失字体的检查和替换&lt;/li&gt;
&lt;li&gt;修复输出PDF时，文字加粗的问题&lt;/li&gt;
&lt;li&gt;修复项目符号、制表位排版和占位符跟随的兼容问题&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 03 May 2019 15:32:00 +0000</pubDate>
<dc:creator>chenxiaopang</dc:creator>
<og:description>难得啊，焕然一新。 WPS Office 2019 For Linux更新说明 11.1.0.8392 版本主要更新： 修复wpsoffice进程存在时不能关机的问题 修复WPS文字模块web版式下拖</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pandachen/p/10807089.html</dc:identifier>
</item>
<item>
<title>详解Supervisor进程守护监控 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/supervisor.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/supervisor.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;31.683417085427&quot;&gt;
&lt;blockquote readability=&quot;7.7989949748744&quot;&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://supervisord.org/&quot; target=&quot;_blank&quot;&gt;Supervisor&lt;/a&gt;在百度百科上给的定义是超级用户，监管员。Supervisor是一个进程管理工具，当进程中断的时候Supervisor能自动重新启动它。可以运行在各种类unix的机器上，supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;介绍Supervisor&lt;/h2&gt;
&lt;p&gt;- supervisord&lt;/p&gt;
&lt;p&gt;运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。&lt;/p&gt;
&lt;p&gt;- supervisorctl&lt;/p&gt;
&lt;p&gt;是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。&lt;/p&gt;
&lt;p&gt;supervisor是所有进程的父进程，管理着启动的子进展，supervisor以子进程的PID来管理子进程，当子进程异常退出时supervisor可以收到相应的信号量。&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;安装Supervisor&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;♛ 安装方法1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.0.0 安装python&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum install python-setuptools&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173109582-612972030.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.0.1 安装Supervisor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;easy_install supervisor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173117841-734879689.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;♛ 安装方法2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wget https://pypi.python.org/packages/source/s/supervisor/supervisor-3.1.3&lt;span&gt;.tar.gz
tar zxvf supervisor&lt;/span&gt;-3.1.3&lt;span&gt;.tar.gz
cd supervisor&lt;/span&gt;-3.1.3&lt;span&gt;
python setup.py install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我就是用的安装方法2安装的、&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2 查看安装是否成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;echo_supervisord_conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173125041-1217247343.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;配置Supervisor&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;2.0 创建目录，初始化配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir /usr/&lt;span&gt;supervisor
echo_supervisord_conf &lt;/span&gt;&amp;gt; /usr/supervisor/supervisord.conf
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;strong&gt;echo_supervisord_conf详解：&lt;br/&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5')&quot; readability=&quot;46&quot;&gt;&lt;img id=&quot;code_img_closed_3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;img id=&quot;code_img_opened_3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3e5f23ef-7e18-4bf4-a37d-49a10ed02ad5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
[root@centos-011 ~ 07:50:00]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;cat /etc/supervisord.conf.bak&lt;/span&gt;
&lt;span&gt;; Sample supervisor config file.
 
[unix_http_server]
file&lt;/span&gt;=/var/run/supervisor/&lt;span&gt;supervisor.sock   ; socket 路径
 
;chmod&lt;/span&gt;=0700&lt;span&gt;                 ; socket 文件的权限
;chown&lt;/span&gt;=&lt;span&gt;nobody:nogroup       ; socket 所属用户及组
;username&lt;/span&gt;=&lt;span&gt;user              ; 用户名
;password&lt;/span&gt;=123&lt;span&gt;               ; 密码
 
;[inet_http_server]         ; 是否启用服务，默认是关闭的（启用的话可以看到supervisor 管理的服务状态）
;port&lt;/span&gt;=127.0.0.1:9001&lt;span&gt;        ; 监听的IP及端口
;username&lt;/span&gt;=&lt;span&gt;user              ; 用户名
;password&lt;/span&gt;=123&lt;span&gt;               ; 密码
 
[supervisord]               ; supervisord 全局配置
logfile&lt;/span&gt;=/var/log/supervisor/&lt;span&gt;supervisord.log  ; supervisor 日志路径
logfile_maxbytes&lt;/span&gt;=&lt;span&gt;50MB       ; 单个日志文件最大数
logfile_backups&lt;/span&gt;=10&lt;span&gt;          ; 保留多少个日志文件（默认10个）
loglevel&lt;/span&gt;=&lt;span&gt;info               ; (log level;default info; others: debug,warn,trace)
pidfile&lt;/span&gt;=/var/run/&lt;span&gt;supervisord.pid ; pid 文件路径
nodaemon&lt;/span&gt;=&lt;span&gt;false              ; 启动是否丢到前台，设置为false ，表示以daemon 的方式启动
minfds&lt;/span&gt;=1024&lt;span&gt;                 ; 最小文件打开数，对应系统limit.conf 中的nofile ,默认最小为1024，最大为4096
minprocs&lt;/span&gt;=200&lt;span&gt;                ; 最小的进程打开数，对应系统的limit.conf 中的nproc,默认为200
;umask&lt;/span&gt;=022                  ; (process file creation umask;default 022&lt;span&gt;)
;user&lt;/span&gt;=&lt;span&gt;chrism                 ; 启动supervisord 服务的用户，默认为root
;identifier&lt;/span&gt;=supervisor       ; (supervisord identifier, default &lt;span&gt;is&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;supervisor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
;directory&lt;/span&gt;=/&lt;span&gt;tmp              ; 这里的目录指的是服务的工作目录
;nocleanup&lt;/span&gt;=true              ; (don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t clean up tempfiles at start;default false)&lt;/span&gt;
;childlogdir=/tmp            ; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AUTO&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; child log dir, default $TEMP)
;environment&lt;/span&gt;=KEY=&lt;span&gt;value       ; (key value pairs to add to environment)
;strip_ansi&lt;/span&gt;=false            ; (strip ansi escape codes &lt;span&gt;in&lt;/span&gt; logs; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;. false)
 
; the below section must remain &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the config file &lt;span&gt;for&lt;/span&gt;&lt;span&gt; RPC
; (supervisorctl&lt;/span&gt;/&lt;span&gt;web interface) to work, additional interfaces may be
; added by defining them &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory &lt;/span&gt;=&lt;span&gt; supervisor.rpcinterface:make_main_rpcinterface
 
[supervisorctl]
serverurl&lt;/span&gt;=unix:///var/run/supervisor/supervisor.sock ; use a unix:// URL  &lt;span&gt;for&lt;/span&gt;&lt;span&gt; a unix socket
;serverurl&lt;/span&gt;=http://127.0.0.1:9001 ; use an http://&lt;span&gt; url to specify an inet socket
;username&lt;/span&gt;=chris              ; should be same as http_username &lt;span&gt;if&lt;/span&gt;&lt;span&gt; set
;password&lt;/span&gt;=123                ; should be same as http_password &lt;span&gt;if&lt;/span&gt;&lt;span&gt; set
;prompt&lt;/span&gt;=mysupervisor         ; cmd line prompt (default &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supervisor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
;history_file&lt;/span&gt;=~/.sc_history  ; use readline history &lt;span&gt;if&lt;/span&gt;&lt;span&gt; available
 
; The below sample program section shows all possible program subsection values,
; create one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more &lt;span&gt;'&lt;/span&gt;&lt;span&gt;real&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; program: sections to be able to control them under
; supervisor.
 
;[program:theprogramname]      ; 定义一个守护进程 ，比如下面的elasticsearch 
;command&lt;/span&gt;=/bin/&lt;span&gt;cat              ; 启动程序使用的命令，可以是绝对路径或者相对路径
;process_name&lt;/span&gt;=%(program_name)s ; 一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%&lt;span&gt;(program_name)s
;numprocs&lt;/span&gt;=1                    ; Supervisor启动这个程序的多个实例，如果numprocs&amp;gt;1，则process_name的表达式必须包含%&lt;span&gt;(process_num)s，默认是1
;directory&lt;/span&gt;=/&lt;span&gt;tmp                ; supervisord在生成子进程的时候会切换到该目录
;umask&lt;/span&gt;=022                     ; umask &lt;span&gt;for&lt;/span&gt;&lt;span&gt; process (default None)
;priority&lt;/span&gt;=999&lt;span&gt;                  ; 权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999
;autostart&lt;/span&gt;=&lt;span&gt;true                ; 如果设置为true，当supervisord启动的时候，进程会自动启动
;autorestart&lt;/span&gt;=&lt;span&gt;true              ; 设置为随 supervisord 重启而重启，值可以是false、true、unexpected。false：进程不会自动重启
;startsecs&lt;/span&gt;=10&lt;span&gt;                  ; 程序启动后等待多长时间后才认为程序启动成功，默认是10秒
;startretries&lt;/span&gt;=3&lt;span&gt;                ; supervisord尝试启动一个程序时尝试的次数。默认是3
;exitcodes&lt;/span&gt;=0,2                 ; 一个预期的退出返回码，默认是0,2&lt;span&gt;。
;stopsignal&lt;/span&gt;=QUIT               ; 当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, &lt;span&gt;or&lt;/span&gt;&lt;span&gt; USR2
;stopwaitsecs&lt;/span&gt;=10&lt;span&gt;               ; 在操作系统给supervisord发送SIGCHILD信号时等待的时间
;user&lt;/span&gt;=&lt;span&gt;chrism                   ; 如果supervisord以root运行，则会使用这个设置用户启动子程序
;redirect_stderr&lt;/span&gt;=&lt;span&gt;true          ; 如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符
;stdout_logfile&lt;/span&gt;=/a/&lt;span&gt;path        ; 把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置
;stdout_logfile_maxbytes&lt;/span&gt;=&lt;span&gt;1MB   ; 标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小
;stdout_logfile_backups&lt;/span&gt;=10&lt;span&gt;     ; 标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份
;stdout_capture_maxbytes&lt;/span&gt;=&lt;span&gt;1MB   ; 当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB
;stdout_events_enabled&lt;/span&gt;=&lt;span&gt;false   ; 如果设置为true，当进程在写它的stderr
;stderr_logfile&lt;/span&gt;=/a/&lt;span&gt;path        ; 把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true
;stderr_logfile_maxbytes&lt;/span&gt;=&lt;span&gt;1MB   ; 错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小
;stderr_logfile_backups&lt;/span&gt;=10&lt;span&gt;     ; 错误日志轮转备份的数量，默认是10，如果设置为0，则不备份
;stderr_capture_maxbytes&lt;/span&gt;=&lt;span&gt;1MB   ; 当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB
;stderr_events_enabled&lt;/span&gt;=&lt;span&gt;false   ; 如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发
;environment&lt;/span&gt;=A=1,B=2           ; 一个k/&lt;span&gt;v对的list列表
;serverurl&lt;/span&gt;=&lt;span&gt;AUTO                ; 是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url
 
; The below sample eventlistener section shows all possible
; eventlistener subsection values, create one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more &lt;span&gt;'&lt;/span&gt;&lt;span&gt;real&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
; eventlistener: sections to be able to handle event notifications
; sent by supervisor.
 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个地方是自定义一个守护进程&lt;/span&gt;
&lt;span&gt;[program:elasticsearch]                       ; 定义一个守护进程 elasticsearch
environment&lt;/span&gt;=ES_HOME=/usr/local/&lt;span&gt;elasticsearch  ; 设置ES_HOME 环境变量
user&lt;/span&gt;=&lt;span&gt;elk                                      ; 启动elasticsearch 的用户
directory&lt;/span&gt;=/usr/local/&lt;span&gt;elasticsearch            ; 进入到这个目录中
command&lt;/span&gt;=/usr/local/elasticsearch/bin/&lt;span&gt;elasticsearch ; 执行启动命令
numprocs&lt;/span&gt;=1                                    ; Supervisor启动这个程序的多个实例，如果numprocs&amp;gt;1，则process_name的表达式必须包含%&lt;span&gt;(process_num)s，默认是1
autostart&lt;/span&gt;=&lt;span&gt;true                                ; 设置为随 supervisord 启动而启动
autorestart&lt;/span&gt;=&lt;span&gt;true                              ; 设置为随 supervisord 重启而重启
startretries&lt;/span&gt;=3&lt;span&gt;                                ; 设置elasticsearch 重启的重试次数
priority&lt;/span&gt;=1&lt;span&gt;                                    ; 权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999  
 
;[eventlistener:theeventlistenername]
;command&lt;/span&gt;=/bin/&lt;span&gt;eventlistener    ; the program (relative uses PATH, can take args)
;process_name&lt;/span&gt;=%(program_name)s ; process_name expr (default %&lt;span&gt;(program_name)s)
;numprocs&lt;/span&gt;=1                    ; number of processes copies to start (&lt;span&gt;def&lt;/span&gt; 1&lt;span&gt;)
;events&lt;/span&gt;=EVENT                  ; event notif. types to subscribe to (req&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d)&lt;/span&gt;
;buffer_size=10                ; event buffer queue size (default 10&lt;span&gt;)
;directory&lt;/span&gt;=/tmp                ; directory to cwd to before &lt;span&gt;exec&lt;/span&gt; (&lt;span&gt;def&lt;/span&gt;&lt;span&gt; no cwd)
;umask&lt;/span&gt;=022                     ; umask &lt;span&gt;for&lt;/span&gt;&lt;span&gt; process (default None)
;priority&lt;/span&gt;=-1                   ; the relative start priority (default -1&lt;span&gt;)
;autostart&lt;/span&gt;=&lt;span&gt;true                ; start at supervisord start (default: true)
;autorestart&lt;/span&gt;=&lt;span&gt;unexpected        ; restart at unexpected quit (default: unexpected)
;startsecs&lt;/span&gt;=10                  ; number of secs prog must stay running (&lt;span&gt;def&lt;/span&gt;. 1&lt;span&gt;)
;startretries&lt;/span&gt;=3                ; max &lt;span&gt;#&lt;/span&gt;&lt;span&gt; of serial start failures (default 3)&lt;/span&gt;
;exitcodes=0,2                 ; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;expected&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; exit codes &lt;span&gt;for&lt;/span&gt; process (default 0,2&lt;span&gt;)
;stopsignal&lt;/span&gt;=&lt;span&gt;QUIT               ; signal used to kill process (default TERM)
;stopwaitsecs&lt;/span&gt;=10               ; max num secs to wait b4 SIGKILL (default 10&lt;span&gt;)
;user&lt;/span&gt;=&lt;span&gt;chrism                   ; setuid to this UNIX account to run the program
;redirect_stderr&lt;/span&gt;=&lt;span&gt;true          ; redirect proc stderr to stdout (default false)
;stdout_logfile&lt;/span&gt;=/a/path        ; stdout log path, NONE &lt;span&gt;for&lt;/span&gt;&lt;span&gt; none; default AUTO
;stdout_logfile_maxbytes&lt;/span&gt;=1MB   ; max &lt;span&gt;#&lt;/span&gt;&lt;span&gt; logfile bytes b4 rotation (default 50MB)&lt;/span&gt;
;stdout_logfile_backups=10     ; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; of stdout logfile backups (default 10)&lt;/span&gt;
;stdout_events_enabled=&lt;span&gt;false   ; emit events on stdout writes (default false)
;stderr_logfile&lt;/span&gt;=/a/path        ; stderr log path, NONE &lt;span&gt;for&lt;/span&gt;&lt;span&gt; none; default AUTO
;stderr_logfile_maxbytes&lt;/span&gt;=1MB   ; max &lt;span&gt;#&lt;/span&gt;&lt;span&gt; logfile bytes b4 rotation (default 50MB)&lt;/span&gt;
;stderr_logfile_backups        ; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; of stderr logfile backups (default 10)&lt;/span&gt;
;stderr_events_enabled=&lt;span&gt;false   ; emit events on stderr writes (default false)
;environment&lt;/span&gt;=A=1,B=2&lt;span&gt;           ; process environment additions
;serverurl&lt;/span&gt;=&lt;span&gt;AUTO                ; override serverurl computation (childutils)
 
; The below sample group section shows all possible group values,
; create one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more &lt;span&gt;'&lt;/span&gt;&lt;span&gt;real&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; group: sections to create &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;heterogeneous&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
; process groups.
 
;[group:thegroupname]          ; 服务组管理，可以将多个服务名写到这里管理(组名自定义）
;programs&lt;/span&gt;=&lt;span&gt;progname1,progname2  ; 上面配置好的服务名，比如elasticsearch,kibana,logstash
;priority&lt;/span&gt;=999                  ; the relative start priority (default 999&lt;span&gt;)
 
; The [include] section can just contain the &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;files&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; setting.  This
; setting can list multiple files (separated by whitespace &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt;
; newlines).  It can also contain wildcards.  The filenames are
; interpreted as relative to this file.  Included files &lt;/span&gt;*cannot*&lt;span&gt;
; include files themselves.
 
[include]
files &lt;/span&gt;= supervisord.d/*.ini
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2.1 为了不将所有新增配置信息全写在一个配置文件里，这里新建一个文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkdir /usr/supervisor/supervisord.d/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2 修改系统配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim /usr/supervisor/supervisord.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.3 include 2.1中新建的supervisord.d文件夹下所有的conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[include]
files &lt;/span&gt;= /usr/supervisor/supervisord.d/*.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.4 若需要web查看进程，则去掉[inet_http_server]的注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[inet_http_server]
port&lt;/span&gt;=127.0.0.1:9001&lt;span&gt;   ;IP按需配置     
username&lt;/span&gt;=&lt;span&gt;user              
password&lt;/span&gt;=123
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;运行Supervisor&lt;/h2&gt;
&lt;p&gt;3.0 启动supervisord&lt;/p&gt;
&lt;p&gt;&lt;code&gt;supervisord -c /usr/supervisor/supervisord.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.1 查看监听&lt;/p&gt;
&lt;p&gt;lsof -i:9001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173142248-709724422.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这一步，就可以通过 http://ip:9001/ 查看supervisor的web界面了，只不过目前还没有加入任何监控程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173156352-210925464.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2 增加一个配置文件，以便supervisor用来监控程序&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat &amp;gt; /usr/supervisor/supervisord.d/supervisor_test_one.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在新建的supervisor_test_one.conf文件中添加以下配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[program:test_one]
command&lt;/span&gt;=java -jar /data/smallvideo/supervisor/taskApp-&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;.jar TaskTestOne  ; 被监控的进程路径
priority&lt;/span&gt;=1&lt;span&gt;                    ; 数字越高，优先级越高
numprocs&lt;/span&gt;=1&lt;span&gt;                    ; 启动几个进程
autostart&lt;/span&gt;=&lt;span&gt;true                ; 随着supervisord的启动而启动
autorestart&lt;/span&gt;=&lt;span&gt;true              ; 自动重启
startretries&lt;/span&gt;=10&lt;span&gt;               ; 启动失败时的最多重试次数
exitcodes&lt;/span&gt;=&lt;span&gt;0                   ; 正常退出代码
stopsignal&lt;/span&gt;=&lt;span&gt;KILL               ; 用来杀死进程的信号
stopwaitsecs&lt;/span&gt;=10&lt;span&gt;               ; 发送SIGKILL前的等待时间
redirect_stderr&lt;/span&gt;=&lt;span&gt;true          ; 重定向stderr到stdout

[program:test_two]
command&lt;/span&gt;=java -jar /data/smallvideo/supervisor/taskApp-&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;.jar TaskTestTwo   ; 被监控的进程路径
priority&lt;/span&gt;=1&lt;span&gt;                    ; 数字越高，优先级越高
numprocs&lt;/span&gt;=1&lt;span&gt;                    ; 启动几个进程
autostart&lt;/span&gt;=&lt;span&gt;true                ; 随着supervisord的启动而启动
autorestart&lt;/span&gt;=&lt;span&gt;true              ; 自动重启
startretries&lt;/span&gt;=10&lt;span&gt;               ; 启动失败时的最多重试次数
exitcodes&lt;/span&gt;=&lt;span&gt;0                   ; 正常退出代码
stopsignal&lt;/span&gt;=&lt;span&gt;KILL               ; 用来杀死进程的信号
stopwaitsecs&lt;/span&gt;=10&lt;span&gt;               ; 发送SIGKILL前的等待时间
redirect_stderr&lt;/span&gt;=true          ; 重定向stderr到stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3 supervisor配置文件详解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;img id=&quot;code_img_opened_06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_06c16ae4-b1cb-4bcb-8723-4bae9b5b27b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
-&lt;span&gt; command：启动程序使用的命令，可以是绝对路径或者相对路径
&lt;/span&gt;- process_name：一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%&lt;span&gt;(program_name)s
&lt;/span&gt;- numprocs：Supervisor启动这个程序的多个实例，如果numprocs&amp;gt;1，则process_name的表达式必须包含%&lt;span&gt;(process_num)s，默认是1
&lt;/span&gt;-&lt;span&gt; numprocs_start：一个int偏移值，当启动实例的时候用来计算numprocs的值
&lt;/span&gt;-&lt;span&gt; priority：权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999
&lt;/span&gt;-&lt;span&gt; autostart：如果设置为true，当supervisord启动的时候，进程会自动重启。
&lt;/span&gt;-&lt;span&gt; autorestart：值可以是false、true、unexpected。false：进程不会自动重启，unexpected：当程序退出时的退出码不是exitcodes中定义的时，进程会重启，true：进程会无条件重启当退出的时候。
&lt;/span&gt;-&lt;span&gt; startsecs：程序启动后等待多长时间后才认为程序启动成功
&lt;/span&gt;-&lt;span&gt; startretries：supervisord尝试启动一个程序时尝试的次数。默认是3
&lt;/span&gt;- exitcodes：一个预期的退出返回码，默认是0,2&lt;span&gt;。
&lt;/span&gt;- stopsignal：当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, &lt;span&gt;or&lt;/span&gt;&lt;span&gt; USR2。
&lt;/span&gt;-&lt;span&gt; stopwaitsecs：在操作系统给supervisord发送SIGCHILD信号时等待的时间
&lt;/span&gt;-&lt;span&gt; stopasgroup：如果设置为true，则会使supervisor发送停止信号到整个进程组
&lt;/span&gt;-&lt;span&gt; killasgroup：如果设置为true，则在给程序发送SIGKILL信号的时候，会发送到整个进程组，它的子进程也会受到影响。
&lt;/span&gt;-&lt;span&gt; user：如果supervisord以root运行，则会使用这个设置用户启动子程序
&lt;/span&gt;-&lt;span&gt; redirect_stderr：如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符。
&lt;/span&gt;-&lt;span&gt; stdout_logfile：把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置。
&lt;/span&gt;-&lt;span&gt; stdout_logfile_maxbytes：标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小
&lt;/span&gt;-&lt;span&gt; stdout_logfile_backups：标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份
&lt;/span&gt;-&lt;span&gt; stdout_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB
&lt;/span&gt;-&lt;span&gt; stdout_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发
&lt;/span&gt;-&lt;span&gt; stderr_logfile：把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true
&lt;/span&gt;-&lt;span&gt; stderr_logfile_maxbytes：错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小
&lt;/span&gt;-&lt;span&gt; stderr_logfile_backups：错误日志轮转备份的数量，默认是10，如果设置为0，则不备份
&lt;/span&gt;-&lt;span&gt; stderr_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB
&lt;/span&gt;-&lt;span&gt; stderr_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发
&lt;/span&gt;- environment：一个k/&lt;span&gt;v对的list列表
&lt;/span&gt;-&lt;span&gt; directory：supervisord在生成子进程的时候会切换到该目录
&lt;/span&gt;-&lt;span&gt; umask：设置进程的umask
&lt;/span&gt;- serverurl：是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;监控demotest程序示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[program:demotest]
command&lt;/span&gt;=python demotest.py 10000&lt;span&gt;  ; 被监控的进程启动命令
directory&lt;/span&gt;=/root/&lt;span&gt;                ; 执行前要不要先cd到目录去，一般不用
priority&lt;/span&gt;=1&lt;span&gt;                    ;数字越高，优先级越高
numprocs&lt;/span&gt;=1&lt;span&gt;                    ; 启动几个进程
autostart&lt;/span&gt;=&lt;span&gt;true                ; 随着supervisord的启动而启动
autorestart&lt;/span&gt;=&lt;span&gt;true              ; 自动重启。。当然要选上了
startretries&lt;/span&gt;=10&lt;span&gt;               ; 启动失败时的最多重试次数
exitcodes&lt;/span&gt;=&lt;span&gt;0                   ; 正常退出代码（是说退出代码是这个时就不再重启了吗？待确定）
stopsignal&lt;/span&gt;=&lt;span&gt;KILL               ; 用来杀死进程的信号
stopwaitsecs&lt;/span&gt;=10&lt;span&gt;               ; 发送SIGKILL前的等待时间
redirect_stderr&lt;/span&gt;=true          ; 重定向stderr到stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.4 重启supervisor&lt;/p&gt;
&lt;p&gt;&lt;code&gt;supervisorctl -c /usr/supervisor/supervisord.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173202998-1323054934.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就可以在http://ip:9001/中访问test_one的程序了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190419173208594-120360123.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.5 supervisor开机自动启动&lt;/p&gt;
&lt;p&gt;3.5.1 在目录/usr/lib/systemd/system/ 新建文件supervisord.service,并添加配置内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Unit]
Description&lt;/span&gt;=Process Monitoring &lt;span&gt;and&lt;/span&gt;&lt;span&gt; Control Daemon
After&lt;/span&gt;=rc-local.service nss-user-&lt;span&gt;lookup.target

[Service]
Type&lt;/span&gt;=&lt;span&gt;forking
ExecStart&lt;/span&gt;=/usr/bin/supervisord -c /usr/supervisor/&lt;span&gt;supervisord.conf ;开机启动时执行
ExecStop&lt;/span&gt;=/usr/bin/&lt;span&gt;supervisord shutdown
ExecReload&lt;/span&gt;=/usr/bin/&lt;span&gt;supervisord reload
killMode&lt;/span&gt;=&lt;span&gt;process
Restart&lt;/span&gt;=on-&lt;span&gt;failure
RestartSec&lt;/span&gt;=&lt;span&gt;42s

[Install]
WantedBy&lt;/span&gt;=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.5.2 启动服务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl enable supervisord&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.5.3 验证一下是否为开机启动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl is-enabled supervisord&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;Supervisor周边&lt;/h2&gt;
&lt;p&gt;4.1 supervisor常用命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 查看supervisorctl支持的命令&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; supervisorctl help    &lt;/span&gt;
default commands (type help &amp;lt;topic&amp;gt;&lt;span&gt;):
&lt;/span&gt;=====================================&lt;span&gt;
add    exit      open  reload  restart   start   tail   
avail  fg        pid   remove  shutdown  status  update 
clear  maintail  quit  reread  signal    stop    version

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 查看当前运行的进程列表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; supervisorctl status&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;update 更新新的配置到supervisord（不会重启原来已运行的程序）&lt;/p&gt;
&lt;p&gt;reload，载入所有配置文件，并按新的配置启动、管理所有进程（会重启原来已运行的程序）&lt;/p&gt;
&lt;p&gt;start xxx: 启动某个进程&lt;/p&gt;
&lt;p&gt;restart xxx: 重启某个进程&lt;/p&gt;
&lt;p&gt;stop xxx: 停止某一个进程(xxx)，xxx为[program:theprogramname]里配置的值&lt;/p&gt;
&lt;p&gt;stop groupworker: 重启所有属于名为groupworker这个分组的进程(start,restart同理)&lt;/p&gt;
&lt;p&gt;stop all，停止全部进程，注：start、restart、stop都不会载入最新的配置文&lt;/p&gt;
&lt;p&gt;reread，当一个服务由自动启动修改为手动启动时执行一下就ok&lt;/p&gt;
&lt;p&gt;ps:有些版本并不支持supervisorctl ,可以通过&lt;code&gt;supervisorctl -c /usr/supervisor/supervisord.conf&lt;/code&gt;唤起命令，格式如上，实际效果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201904/506684-20190422155733101-1728503182.png&quot; alt=&quot;详解Supervisor进程守护监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.2 如果supervisorCPU和内存占用率特别高，导致机器卡死。&lt;/p&gt;
&lt;p&gt;尝试注释掉2.4中的web。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/Supervisor/supervisor/issues/581&quot; target=&quot;_blank&quot;&gt;https://github.com/Supervisor/supervisor/issues/581&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.3 Unlinking stale socket /tmp/supervisor.sock&lt;/p&gt;
&lt;p&gt;解决方案，执行&lt;code&gt;unlink /tmp/supervisor.sock&lt;/code&gt;&lt;/p&gt;

&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 03 May 2019 14:53:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>Supervisor在百度百科上给的定义是超级用户，监管员。Supervisor是一个进程管理工具，当进程中断的时候Supervisor能自动重新启动它。可以运行在各种类unix的机器上，superv</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/supervisor.html</dc:identifier>
</item>
<item>
<title>用例图之间的几种关系 - SSS翱翔万里</title>
<link>http://www.cnblogs.com/SSSzhanglingzhi/p/10806875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SSSzhanglingzhi/p/10806875.html</guid>
<description>&lt;p&gt;&lt;span&gt;用例图之间的几种关系&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;A.解释&lt;/h2&gt;
&lt;p&gt;执行者与执行者之间只有一种关系即继承(也叫泛化)。其意义与面向对象过程中的继承关系类似,但它主要强调子类执行者对父类执行者与用例之间的交互行为的继承。&lt;/p&gt;
&lt;h2&gt;B.表示形式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221355470-1339915234.jpg&quot; alt=&quot;&quot;/&gt;(从子类指向父类)&lt;/p&gt;
&lt;h2&gt;C.核心&lt;/h2&gt;
&lt;p&gt;两个或两个以上执行者之间有共性,共性单独设为一个执行者。&lt;/p&gt;
&lt;h2&gt;D.例子&lt;/h2&gt;
&lt;p&gt;在教务管理系统中,老师、学生、用户之间的关系&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221155715-529854610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解:老师和学生都是用户的子类,所以继承了用户身份验证和注册操作&lt;/p&gt;
&lt;h2&gt;E.有什么用？&lt;/h2&gt;
&lt;p&gt;1.减少代码的冗余量&lt;/p&gt;
&lt;p&gt;2.易于修改&lt;/p&gt;

&lt;h2&gt;A.解释&lt;/h2&gt;
&lt;p&gt;通常来讲,执行者与用例之间的关系都是用无向边表示的(可理解为双向传递信息)&lt;/p&gt;
&lt;h2&gt;B.表现形式&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221409665-596358918.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;C.核心&lt;/h2&gt;
&lt;p&gt;对号入座&lt;/p&gt;
&lt;h2&gt;D.例子&lt;/h2&gt;
&lt;p&gt;管理员与用户身份验证的关系&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221437651-662951712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但也有特殊情况,如下所述&lt;/p&gt;
&lt;p&gt;1．当多个执行者与用例相连时,为了强调某个执行者是主要执行者,就在执行者到用例之间加上一条边。&lt;/p&gt;
&lt;p&gt;2.被动执行者仅从用例获取信息,而不提供信息给用例,那么此时用例到执行者之间就可以连一条有向边。&lt;/p&gt;
&lt;h2&gt;E.有什么用&lt;/h2&gt;
&lt;p&gt;1.使程序整洁了,避免混乱&lt;/p&gt;
&lt;p&gt;2.使软件开发符合要求,难出现缺斤少两的现象。&lt;/p&gt;

&lt;h2&gt;3.1 包含(include)&lt;/h2&gt;
&lt;h3&gt;A.解释&lt;/h3&gt;
&lt;p&gt;A.1一个用例所需要完成的功能是多个互不联系的用例的功能之和,那么它们之间就具备着包含关系。&lt;/p&gt;
&lt;p&gt;A,2多个用例之间具有共性,就需要把共性提取出来作为一个新的用例,此时新用例与原来的多个用例之间就具备了包含关系。&lt;/p&gt;
&lt;h3&gt;B.表现形式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221603760-335141163.jpg&quot; alt=&quot;&quot;/&gt;(指向包含的用例)&lt;/p&gt;
&lt;h3&gt;C.核心&lt;/h3&gt;
&lt;p&gt;对于不同用例而言,提取公共子函数,在登录教务管理系统中,老师和学生都包含着身份信息验证这个用例。&lt;/p&gt;
&lt;p&gt;对于某一个用例而言,可以采用拆分法,不断拆分成小的用例。如管理图书信息这个用例&lt;/p&gt;
&lt;h3&gt;D.例子&lt;/h3&gt;
&lt;p&gt;图书管理系统中,管理图书信息这个用例就包含增加图书信息,删除图书信息,修改图书信息,查询图书信息四个子用例&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221624196-598855885.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;E.有什么用?&lt;/h3&gt;
&lt;p&gt;1.方便软件开发人员开发出软件需的功能&lt;/p&gt;
&lt;p&gt;2.能使客户更好的表达自己的观点(错则改正)。&lt;/p&gt;
&lt;h2&gt;3.2 扩展(extend)&lt;/h2&gt;
&lt;h3&gt;A,解释&lt;/h3&gt;
&lt;p&gt;通俗点来说就是倒霉到家了,碰到了千万分之一概率的异常情况,如火车晚点3小时。&lt;/p&gt;
&lt;h3&gt;B.表现形式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221657106-648103675.jpg&quot; alt=&quot;&quot;/&gt;（指向被扩展的用例）&lt;/p&gt;
&lt;h3&gt;C.核心&lt;/h3&gt;
&lt;p&gt;异常情况&lt;/p&gt;
&lt;h3&gt;D.例子&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;在用户身份验证这一用例中,只要输入账户和密码就可以登录这个网站了。但有一种特殊情况是用户忘记了密码,此时就需找回密码,而找回密码很显然可以作为一个单独的用例。那么它就相当于在用户身份验证这个用例下的一种异常情况，所以用户身份验证与找回密码是扩展关系&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221710380-347525290.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;E.有什么用&lt;/h3&gt;
&lt;p&gt;1.提高程序的安全性&lt;/p&gt;
&lt;p&gt;2.减少程序的维护成本(因为不怕异常)&lt;/p&gt;
&lt;h2&gt;3.3 继承&lt;/h2&gt;
&lt;h3&gt;A.解释&lt;/h3&gt;
&lt;p&gt;同执行者与执行者之间的关系类似,只需把执行者变成用例就可以得到其解释。&lt;/p&gt;
&lt;h3&gt;B.表现形式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221722225-418186682.jpg&quot; alt=&quot;&quot;/&gt;（指向父类）&lt;/p&gt;
&lt;h3&gt;C.核心&lt;/h3&gt;
&lt;p&gt;子类继承了父类的所有非私有属性和方法,但与父类不同的是它在自己的基础上增加了一些新的东西.&lt;/p&gt;
&lt;h3&gt;D.例子&lt;/h3&gt;
&lt;p&gt;蒙牛公司下的产品——特仑苏是继承蒙牛的草场和资金,但他新的地方在于广告效应深远和牛奶的质量好&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611931/201905/1611931-20190503221857446-387013836.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;E.有什么用?&lt;/h3&gt;
&lt;p&gt;同执行者与执行者之间的关系(泛化)。&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 14:33:00 +0000</pubDate>
<dc:creator>SSS翱翔万里</dc:creator>
<og:description>用例图之间的几种关系 1. 执行者与执行者之间的唯一关系(继承) A.解释 执行者与执行者之间只有一种关系即继承(也叫泛化)。其意义与面向对象过程中的继承关系类似,但它主要强调子类执行者对父类执行者与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SSSzhanglingzhi/p/10806875.html</dc:identifier>
</item>
<item>
<title>RabbitMQ Node.js 示例 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/rabbitmq_nodejs_example.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/rabbitmq_nodejs_example.html</guid>
<description>&lt;p&gt;RabbitQM 处理和管理消息队列的中间人（broker）。可简单理解为邮局，你在程序中写好消息，指定好收件人，剩下的事件就是 RabbitMQ 的工作了，它会保证收件人正确收到邮件。&lt;/p&gt;
&lt;p&gt;任何发送邮件的程序都是 &lt;code&gt;Producer&lt;/code&gt;，消息队列可理解为邮筒，新件将堆积在此处。所有待处理的消息都以队列形式存储，总体上看来就是一个巨大的消息 buffer，至于存储量与设置的内存及硬件有关。任何应用都可以向队列添加消息，也可以多个消费者都在从队列中获取消息。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;consumer&lt;/code&gt; 即是消息队列中消息的应用，其处于等待接收来自 RabbitMQ 发送来的消息。&lt;/p&gt;
&lt;p&gt;消息生产者，消费者及 RabbitMQ 这个中间人三者不必同时存在于同一机器上，实际运用时也确实大部分不会部署在同一机器上，比如有专门的机器作为 RabbitMQ 实体，而应用程序会部署在其他的集群。应用程序可以是同时负责生产消息的，也同时是消费者。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/45330b63e7453cfb9017628fc29745c89073b097/68747470733a2f2f7777772e7261626269746d712e636f6d2f696d672f7475746f7269616c732f707974686f6e2d6f6e652e706e67&quot;&gt;&lt;img alt=&quot;来自官方文档中关于 RabbitMQ 消息列队的示意图&quot; src=&quot;https://camo.githubusercontent.com/45330b63e7453cfb9017628fc29745c89073b097/68747470733a2f2f7777772e7261626269746d712e636f6d2f696d672f7475746f7269616c732f707974686f6e2d6f6e652e706e67&quot; data-canonical-src=&quot;https://www.rabbitmq.com/img/tutorials/python-one.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;来自官方文档中关于 RabbitMQ 消息列队的示意图&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;通过&lt;a href=&quot;https://www.rabbitmq.com/download.html&quot; rel=&quot;nofollow&quot;&gt;官网提供的地址&lt;/a&gt;下载相应平台的程序进行安装，Mac 可通过 &lt;a href=&quot;https://www.rabbitmq.com/install-homebrew.html&quot; rel=&quot;nofollow&quot;&gt;Homebrew 进行安装&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ brew update &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; brew install rabbitmq
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;启动&lt;/h2&gt;
&lt;p&gt;如果使用 Homebrew 安装，可通过 &lt;code&gt;brew services start rabbitmq&lt;/code&gt; 命令来启动 RabbitMQ 服务。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ brew services start rabbitmq
==&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; Successfully started &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;rabbitmq&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; (label: homebrew.mxcl.rabbitmq)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或直接运行 &lt;code&gt;/usr/local/sbin/rabbitmq-server&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;启动后，会有一个可视化的管理后台，可通过 &lt;a rel=&quot;nofollow&quot; href=&quot;http://localhost:15672/&quot;&gt;http://localhost:15672/&lt;/a&gt; 访问，用户名密码皆为 &lt;code&gt;guest&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;基于 Node.js 的 Hello World 示例&lt;/h2&gt;
&lt;p&gt;通过 &lt;a href=&quot;https://github.com/squaremo/amqp.node&quot;&gt;amqp.node&lt;/a&gt; 展示 RabbitMQ 在 Node.js 中应用的一个示例。&lt;/p&gt;
&lt;p&gt;RabbmitMQ 支持多种协议进行通信，amqp.node 使用的是 AMQP 0-9-1 这一开源协议，后者专门为处理消息而设计。作为客户端消费消息，使用的是 &lt;a href=&quot;http://www.squaremobius.net/amqp.node/&quot; rel=&quot;nofollow&quot;&gt;amqp.node client&lt;/a&gt; 模块，但 RabbitMQ 本身是支持多种&lt;a href=&quot;http://rabbitmq.com/devtools.html&quot; rel=&quot;nofollow&quot;&gt;客户端&lt;/a&gt;的。&lt;/p&gt;
&lt;p&gt;初始化一个 Node,js 项目然后通过以下命令安装 amqp.node 模块：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mkdir rabbitmq-demo &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; yarn init -y
$ yarn add amqplib
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;发送消息&lt;/h3&gt;
&lt;p&gt;创建 &lt;code&gt;send.js&lt;/code&gt; 文件，在其中编写发送消息的逻辑，它将连接到 RabbitMQ 发送消息然后退出。&lt;/p&gt;
&lt;p&gt;首先建立到 RabbitMQ 服务的连接，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;#!/usr/bin/env node&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; amqp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqplib/callback_api&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连接建立成功后，创建一个通道（channel），具体的发送将会在这个通道中进行。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
  }
  &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {});
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送消息前，需要先声明一个队列，然后将消息发送到该队列：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
  }
  &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error1) {
      &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error1;
    }
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; msg &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Hello world&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

    &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assertQueue&lt;/span&gt;(queue, {
      durable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
    });

    &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;sendToQueue&lt;/span&gt;(queue, &lt;span class=&quot;pl-smi&quot;&gt;Buffer&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;from&lt;/span&gt;(msg));
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [x] Sent %s&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, msg);
  });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;队列的创建是一个&lt;a href=&quot;https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation&quot; rel=&quot;nofollow&quot;&gt;幂等操作&lt;/a&gt;，只该队列不存在的情况才会新建。&lt;/p&gt;
&lt;p&gt;最后关闭连接并退出。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;close&lt;/span&gt;();
    &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);
}, &lt;span class=&quot;pl-c1&quot;&gt;500&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;details readability=&quot;6&quot;&gt;完整的 send.js
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;#!/usr/bin/env node&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; amqp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqplib/callback_api&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
        &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
    }
    &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error1) {
            &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error1;
        }

        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;
        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; msg &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Hello World!&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

        &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assertQueue&lt;/span&gt;(queue, {
            durable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
        });
        &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;sendToQueue&lt;/span&gt;(queue, &lt;span class=&quot;pl-smi&quot;&gt;Buffer&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;from&lt;/span&gt;(msg));

        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [x] Sent %s&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, msg);
    });
    &lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
        &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);
    }, &lt;span class=&quot;pl-c1&quot;&gt;500&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;h3&gt;接收消息&lt;/h3&gt;
&lt;p&gt;下面开始编写消费者，消费者做的事情是监听来自 RabbitMQ 的消息并处理。&lt;/p&gt;
&lt;p&gt;创建 &lt;code&gt;receive.js&lt;/code&gt;，引入 amqp.node 模块，流程和发送者一样，也是先创建连接，然后创建通道，在通道中声明需要监听的队列：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;#!/usr/bin/env node&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; amqp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqplib/callback_api&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
  }
  &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error1) {
      &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error1;
    }
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

    &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assertQueue&lt;/span&gt;(queue, {
      durable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
    });
  });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的队列声明不会与发送者那边的冲突，因为上面提到过，队列只在不存在的情况下才会重新生成。这里再次声明可以保证监听前队列已经存在。并且实际场景下，消费者有可能是在发送者之前启动的。&lt;/p&gt;
&lt;p&gt;然后添加监听的逻辑：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
 &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [*] Waiting for messages in %s. To exit press CTRL+C&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, queue);

&lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;consume&lt;/span&gt;(queue, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;msg&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [x] Received %s&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;msg&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;content&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toString&lt;/span&gt;());
}, {
    noAck&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;details readability=&quot;6.5&quot;&gt;完整的 receive.js
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
#&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;pl-sr&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;/&lt;/span&gt;usr&lt;span class=&quot;pl-pds&quot;&gt;/&lt;/span&gt;&lt;/span&gt;bin&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;env node

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; amqp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqplib/callback_api&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;amqp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;amqp://localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error0&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error0) {
        &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error0;
    }
    &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createChannel&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error1&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error1) {
            &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error1;
        }

        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

        &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assertQueue&lt;/span&gt;(queue, {
            durable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
        });

        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [*] Waiting for messages in %s. To exit press CTRL+C&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, queue);

        &lt;span class=&quot;pl-smi&quot;&gt;channel&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;consume&lt;/span&gt;(queue, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;msg&lt;/span&gt;) {
            &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; [x] Received %s&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;msg&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;content&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toString&lt;/span&gt;());
        }, {
            noAck&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
        });
    });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;h3&gt;运行&lt;/h3&gt;
&lt;p&gt;分别在命令行启动上面两个程序，查看打印的信息。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ node send.js
 [x] Sent Hello World&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;

$ node receive.js
 [&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;] Waiting &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;messages&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; hello. To &lt;span class=&quot;pl-c1&quot;&gt;exit&lt;/span&gt; press CTRL+C
 [x] Received Hello World&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，可通过 &lt;code&gt;sudo rabbitmqctl list_queues&lt;/code&gt; 手动查看 RabbitMQ 中的消息。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ /usr/local/sbin/rabbitmqctl list_queues
Timeout: 60.0 seconds ...
Listing queues &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; vhost / ...
name    messages
hello   0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果发现 &lt;code&gt;rabbitmqctl&lt;/code&gt; 命令不可用，需要添加 &lt;code&gt;/usr/local/sbin&lt;/code&gt; 到环境变量中，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; PATH=/usr/local/sbin:&lt;span class=&quot;pl-smi&quot;&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 fish shell 通过添加如下命令到 fish 的配置文件即可：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; -gx PATH /usr/local/sbin &lt;span class=&quot;pl-smi&quot;&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Fri, 03 May 2019 14:33:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>RabbitQM 处理和管理消息队列的中间人（broker）。可简单理解为邮局，你在程序中写好消息，指定好收件人，剩下的事件就是 RabbitMQ 的工作了，它会保证收件人正确收到邮件。 任何发送邮件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/rabbitmq_nodejs_example.html</dc:identifier>
</item>
<item>
<title>订阅发布模式和观察者模式真的不一样 - 一像素</title>
<link>http://www.cnblogs.com/onepixel/p/10806891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onepixel/p/10806891.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;1、观察者模式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。&lt;/p&gt;
&lt;p&gt;观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、订阅-发布模式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;其实24种基本的设计模式中并没有发布订阅模式，上面也说了，他只是观察者模式的一个别称。&lt;/p&gt;
&lt;p&gt;但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。&lt;/p&gt;
&lt;p&gt;在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。&lt;/p&gt;
&lt;p&gt;举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、两种模式的区别&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们先来看下这两个模式的实现结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/849589/201904/849589-20190424122505055-2083728728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，发布订阅模式相比观察者模式多了个事件通道，事件通道作为调度中心，管理事件的订阅和发布工作，彻底隔绝了订阅者和发布者的依赖关系。即订阅者在订阅事件的时候，只关注事件本身，而不关心谁会发布这个事件；发布者在发布事件的时候，只关注事件本身，而不关心谁订阅了这个事件。&lt;/p&gt;
&lt;p&gt;观察者模式有两个重要的角色，即目标和观察者。在目标和观察者之间是没有事件通道的。一方面，观察者要想订阅目标事件，由于没有事件通道，因此必须将自己添加到目标(Subject) 中进行管理；另一方面，目标在触发事件的时候，也无法将通知操作(notify) 委托给事件通道，因此只能亲自去通知所有的观察者。&lt;/p&gt;
&lt;p&gt;我们再来看一下这两个模式的代码实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;订阅-发布模式&lt;/strong&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class PubSub {
    constructor() {
        this.subscribers = [];
    }
    
    subscribe(topic, callback) {
        let callbacks = this.subscribers[topic];
        if (!callbacks) {
            this.subscribers[topic] = [callback];
        } else {
            callbacks.push(callback);
        }
    }
    
    publish(topic, ...args) {
        let callbacks = this.subscribers[topic] || [];
        callbacks.forEach(callback =&amp;gt; callback(...args));
    }
}

// 创建事件调度中心，为订阅者和发布者提供调度服务
let pubSub = new PubSub();
// A订阅了SMS事件（A只关注SMS本身，而不关心谁发布这个事件）
pubSub.subscribe('SMS', console.log);
// B订阅了SMS事件
pubSub.subscribe('SMS', console.log);
// C发布了SMS事件（C只关注SMS本身，不关心谁订阅了这个事件）
pubSub.publish('SMS', 'I published `SMS` event');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Subject {
    constructor() {
        this.observers = [];
    }

    add(observer) {
        this.observers.push(observer);
    }

    notify(...args) {
        this.observers.forEach(observer =&amp;gt; observer.update(...args));
    }
}

class Observer {
    update(...args) {
        console.log(...args);
    }
}

// 创建观察者ob1
let ob1 = new Observer();
// 创建观察者ob2
let ob2 = new Observer();
// 创建目标sub
let sub = new Subject();
// 目标sub添加观察者ob1 （目标和观察者建立了依赖关系）
sub.add(ob1);
// 目标sub添加观察者ob2
sub.add(ob2);
// 目标sub触发SMS事件（目标主动通知观察者）
sub.notify('I fired `SMS` event');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码实现可以看出，发布-订阅模式是面向调度中心编程的，而观察者模式则是面向目标和观察者编程的。前者用于解耦发布者和订阅者，后者用于耦合目标和观察者，不可同日而语也~&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;[1]  &lt;a href=&quot;https://blog.csdn.net/hf872914334/article/details/88899326&quot; target=&quot;_blank&quot;&gt;发布订阅模式与观察者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]  &lt;a href=&quot;https://www.jianshu.com/p/f0f22398d25d&quot; target=&quot;_blank&quot;&gt;重学JS（九）—— 观察者模式和发布/订阅模式真不一样&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 May 2019 14:28:00 +0000</pubDate>
<dc:creator>一像素</dc:creator>
<og:description>1、观察者模式 观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onepixel/p/10806891.html</dc:identifier>
</item>
</channel>
</rss>