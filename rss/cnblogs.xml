<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis启用密码认证的疑问 - hexiaohui003</title>
<link>http://www.cnblogs.com/hexiaohui003/p/10885928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hexiaohui003/p/10885928.html</guid>
<description>&lt;p&gt;首先，Redis主从和clsuter是支持密码认证的。&lt;/p&gt;
&lt;p&gt;其次，关于启用redis密码认证的涉及的几个问题：&lt;/p&gt;
&lt;p&gt;1、是否只设置requirepass就可以？masterauth是否需要同步设置？&lt;/p&gt;
&lt;p&gt;答案：redis启用密码认证一定要requirepass和masterauth同时设置。&lt;/p&gt;
&lt;p&gt;如果主节点设置了requirepass登录验证，在主从切换，slave在和master做数据同步的时候首先需要发送一个ping的消息给主节点判断主节点是否存活，再监听主节点的端口是否联通，发送数据同步等都会用到master的登录密码，否则无法登录，log会出现响应的报错。也就是说slave的masterauth和master的requirepass是对应的，所以建议redis启用密码时将各个节点的masterauth和requirepass设置为相同的密码，降低运维成本。当然设置为不同也是可以的，注意slave节点masterauth和master节点requirepass的对应关系就行。&lt;/p&gt;
&lt;p&gt;2、requreipass和master的作用？&lt;/p&gt;
&lt;p&gt;masterauth作用：主要是针对master对应的slave节点设置的，在slave节点数据同步的时候用到。&lt;/p&gt;
&lt;p&gt;requirepass作用：对登录权限做限制，redis每个节点的requirepass可以是独立、不同的。&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 07:32:00 +0000</pubDate>
<dc:creator>hexiaohui003</dc:creator>
<og:description>首先，Redis主从和clsuter是支持密码认证的。 其次，关于启用redis密码认证的涉及的几个问题： 1、是否只设置requirepass就可以？masterauth是否需要同步设置？ 答案：r</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hexiaohui003/p/10885928.html</dc:identifier>
</item>
<item>
<title>用Vue构建一个github“可视化大数据平台”-GitDataV，设计开发分享 - 懂天明</title>
<link>http://www.cnblogs.com/xinlangboke/p/10885829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinlangboke/p/10885829.html</guid>
<description>&lt;div readability=&quot;10&quot;&gt;
&lt;h2 data-id=&quot;heading-0&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;    GitDataV，是一个github“大数据可视化平台”，通过它你可以更直观的看到你在github里的一些数据，（之所以打双引号，是因为我觉得这个还没到大数据可视化的程度）。其实我在 上篇文章 分享的时候已经提到了这个想法，通过github提供的接口，做一个自己的“大数据分析页面”，所以我就花了几天晚上的时间，把这想法从设计到开发构建出来了，那么下面我就我个人的账号测试看看效果如下gif图&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/24/1656c59629551995?imageslim&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/24/1656c59629551995?imageslim&quot; data-width=&quot;1280&quot; data-height=&quot;611&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您感兴趣可以点击这里访问简单的：GitDataV网站(目前打包后有些小bug，但不影响正常使用) ，看看你的github“大数据分析”详情。&lt;br/&gt;   &lt;br/&gt;     很多初学者，对大数据的概念都是模糊不清的，大数据是什么，能做什么，学的时候，该按照什么线路去学习，学完往哪方面发展，想深入了解，想学习的同学欢迎加入大数据学习qq群：410391744，有大量干货（零基础以及进阶的经典实战）分享给大家，并且有清华大学毕业的资深大数据讲师给大家免费授课，给大家分享目前国内最完整的大数据高端实战实用学习流程体系。&lt;/p&gt;
&lt;p&gt;推荐把&lt;strong&gt;GitDataV（github源码）&lt;/strong&gt;项目下载下来，在本机运行项目，在本机浏览器打开网页，生成自己的“大数据分析”详情。&lt;/p&gt;
&lt;p&gt;通过它你将看到你在github里的这些数据：个人信息(✔)，仓库stars情况(✔)，仓库语言分类(✔)仓库公开数量(✔)、粉丝数量(✔)、跟随数量(✔)、仓库数据(✔)、最近你的操作(✔)、最近的粉丝(✔)、最近的跟随(✔)、最新信息(✔)，左上角箭头小彩蛋： 全屏(✔)、 国际化语言切换（开发中...）、皮肤切换（开发中..）&lt;/p&gt;
&lt;p&gt;看着还不错吧（没有设计师，自己作为前端设计，审美[chou]就这样），有点小感（la）觉（ji）。下面步入正题，我将从下面几点：&lt;strong&gt;需求分析、开发准备、功能设计和代码实现&lt;/strong&gt;，对我独立从设计到开发构建这个“可视化大数据平台”小玩意做个分享：&lt;/p&gt;
&lt;h2 data-id=&quot;heading-1&quot;&gt;需求分析&lt;/h2&gt;
&lt;p&gt;信息数据时代，每个人对数据都是敏感的，对于你在github的数据，你除了看到github官方网站给你的数据之外，其实你还可以看到更多的数据。我当时的初心就是通过用户输入自己的github账号，可以获取自己在github里有用的数据。在上次做门户网站在前端页面交互应用和小技巧的时候偶然发现原来github提供了开发者API，地址传送门：(https://developer.github.com/v3/)&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/24/1656c7193a75aacb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/24/1656c7193a75aacb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;766&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点进一看发现新大陆，欣喜若狂的我感觉有了一个心血来潮，自己的想法还是自己实现吧，开搞！&lt;/p&gt;

&lt;h2 data-id=&quot;heading-2&quot;&gt;开发准备&lt;/h2&gt;
&lt;h3 data-id=&quot;heading-3&quot;&gt;一、了解GitHub开发者文档&lt;/h3&gt;
&lt;p&gt;v3版API的文档链接、v3版API的官方教程&lt;/p&gt;
&lt;p&gt; 先看看github接口都能获取什么数据吧，先做个简单的测试我通过我自己的账号（hongqingcao）去请求/users接口（https://api.github.com/users/hongqingcao）得到下面的数据，哇哇。从上往下看，真全面，连我都忘记自己GitHub注册时间，这里都有&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/24/1656c77c1ae161c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/24/1656c77c1ae161c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;797&quot; data-height=&quot;598&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然你如果懒得去学习官方文档，网上一搜还真有人总结了Github API调用，传送门《一篇文章搞定Github API 调用 (v3）》&lt;/p&gt;

&lt;h3 data-id=&quot;heading-4&quot;&gt;二、了解可视化相关的设计&lt;/h3&gt;
&lt;p&gt;首先进入百度了解了一哈，乍一眼看，基本上都是偏深蓝色调，当然不仅仅如此《大数据数据可视化的设计原则》，我也是有看的，具体资料有兴趣的同学可以自行研究。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656cea6b2d7b58d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656cea6b2d7b58d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;659&quot;/&gt;&lt;/p&gt;
&lt;p&gt;阿里的DataV数据可视化是比较6的，自信到百度查出来的都是“双十一大屏展示”卖点啊（多次提到百度，阿里，哈哈）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656cf08f8abcffe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656cf08f8abcffe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;846&quot; data-height=&quot;360&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完这些，说实话心里对数据可视化的设计就有个谱了，没有设计师，前端一样可以好好玩耍。在这里&lt;strong&gt;声明一哈&lt;/strong&gt;：整个项目背景图来自17素材网等网上平台（不用于商业用途）。&lt;/p&gt;

&lt;h3 data-id=&quot;heading-5&quot;&gt;三、技术选型、知识准备&lt;/h3&gt;
&lt;p&gt;既然上篇文章被各路“扛精”，那我就继续用Vue来搞事情，这里想了一哈整个项目（回忆了功能），梳理列了下面几项技术栈和知识点：&lt;/p&gt;
&lt;p&gt;1、vue（vue项目构建、指令的灵活运用、组件封装、组件之间通信）&lt;/p&gt;
&lt;p&gt;2、vue-router(路由预备知识：hash和history区别、动态路由、路由切换传参)&lt;/p&gt;
&lt;p&gt;3、网络请求axios(自己封装axios、跨域代理配置)&lt;/p&gt;
&lt;p&gt;4、可视化工具echarts、v-charts处理图形（控制大小、布局、颜色、接受数据格式）&lt;/p&gt;
&lt;p&gt;5、es6（基础语法，比如在梳理数据过程中用到map遍历数组、对象和数组转换等等）&lt;/p&gt;
&lt;p&gt;6、scss(配置、语法)&lt;/p&gt;
&lt;p&gt;7、bootstrap、iconfont（用于没有设计师，作为前端设计能力有限，所以引用这两个）&lt;/p&gt;
&lt;p&gt;8、打包上线（一些小坑）&lt;/p&gt;
&lt;p&gt;好的列完了以上开发准备，装备好以上技能，系好安全带，开始上路了&lt;/p&gt;

&lt;h2 data-id=&quot;heading-6&quot;&gt;功能设计和代码实现&lt;/h2&gt;
&lt;h3 data-id=&quot;heading-7&quot;&gt;一、构建项目&lt;/h3&gt;
&lt;p&gt;直接用脚手架构建，把需要的axios、echarts、v-charts、scss、bootstrap，安装配置好，具体操作略，axios跨域代理配置可以在网上找到相关资源，主要看看我规划的src文件结构，这块其实我封装了很多公共组件，这里就不细讲了&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;├── src                   源码目录  
│  ├── main.js            入口js文件
│  ├── app.vue            根组件
│  ├── components         公共组件目录
│  │  └── index.js       把全部组件遍历出来
│  ├── assets             资源目录，这里的资源会被wabpack构建
│  │  └── css             css基础重置
│  │  └── data            可视化界面需要的图片
│  │  └── iconfont        字体图标
│  │    └── bg.png
│  ├── routes             前端路由
│  │  └── index.js
│  └── pages             页面目录
│    ├── app             入口文件
│    └── data             可视化文件
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-id=&quot;heading-8&quot;&gt;二、入口首页设计&lt;/h3&gt;
&lt;p&gt;先看看效果图（没有设计师，一个前端的审美）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d58e2c471be3?imageslim&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d58e2c471be3?imageslim&quot; data-width=&quot;400&quot; data-height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要功能：&lt;/p&gt;
&lt;p&gt;1、服务条款弹框，这里弹框我封装了一个首页的组件，有用bootstrap样式，这里有一个父子组件通讯，首先点击服务条款，父组件告诉子组件要显示了，子组件显示之后，点击“x”或者“知道了”，告诉父组件需要让子组件不显示了&lt;/p&gt;
&lt;p&gt;首页（父组件）引用“服务条款弹框”组件&lt;/p&gt;
&lt;p&gt; &lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;&amp;lt;pmodal :isShow=&lt;span class=&quot;hljs-string&quot;&gt;&quot;isShow&quot; @sayhidden=&lt;span class=&quot;hljs-string&quot;&gt;&quot;sayhidden&quot; v-if=&lt;span class=&quot;hljs-string&quot;&gt;&quot;isShow&quot;/&amp;gt;&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首页（父组件）控制弹框的 methods&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;showpm(){
        this.isShow = &lt;span class=&quot;hljs-literal&quot;&gt;true
    },
    sayhidden(sayhidden){
        this.isShow = sayhidden
    }&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;“服务条款弹框”组件，接收首页的是否显示弹框的命令，然后通过$emit点击关闭向首页传递“关闭”状态 &lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;export default {
  name: &lt;span class=&quot;hljs-string&quot;&gt;'pmodal',
  props: {
    isShow: null,
  },
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;data () {
      &lt;span class=&quot;hljs-built_in&quot;&gt;return {
        sayhidden: &lt;span class=&quot;hljs-literal&quot;&gt;false
      }
  },
  methods:{
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;closebtn(){
                this.&lt;span class=&quot;hljs-variable&quot;&gt;$emit(&lt;span class=&quot;hljs-string&quot;&gt;'sayhidden', this.sayhidden)
        }
  }
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、输入框表单验证，这里主要是两个判断，当输入框为空时候点“生成”按钮，提示不能为空，当用户输入的时候，提示消失、点击提交的时候，请求接口然后把信息反馈回来，如果用户有误，提示重新输入，如果正确，就带着参数跳到&quot;大数据可视化&quot;页面&lt;/p&gt;
&lt;p&gt;主要代码：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;  generate(username){
        &lt;span class=&quot;hljs-built_in&quot;&gt;let name = this.username
        &lt;span class=&quot;hljs-built_in&quot;&gt;let self = this
        &lt;span class=&quot;hljs-keyword&quot;&gt;if(name.length &amp;lt;= 0){
                this.namelg = &lt;span class=&quot;hljs-literal&quot;&gt;true
                &lt;span class=&quot;hljs-built_in&quot;&gt;return
        }&lt;span class=&quot;hljs-keyword&quot;&gt;else{
                this.&lt;span class=&quot;hljs-variable&quot;&gt;$axios.get(&lt;span class=&quot;hljs-string&quot;&gt;'/api/users/'+ name).then((response)=&amp;gt;{
                    &lt;span class=&quot;hljs-built_in&quot;&gt;let res = JSON.parse(JSON.stringify(response))
                    &lt;span class=&quot;hljs-keyword&quot;&gt;if(res.status === 200){
                        this.&lt;span class=&quot;hljs-variable&quot;&gt;$router.push({ 
                                name: &lt;span class=&quot;hljs-string&quot;&gt;'data',
                                params: { user: name }
                        })
                              }   
                              &lt;span class=&quot;hljs-built_in&quot;&gt;return
                        }).catch(err =&amp;gt; {
                                this.nousename = &lt;span class=&quot;hljs-literal&quot;&gt;true
                        this.errname = name
                                  console.log(err.message);
                                })
            }
        
    }
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;3、首页背景和粒子动效（已经在前面一篇文章有讲）这里略&lt;/p&gt;

&lt;h3 data-id=&quot;heading-9&quot;&gt;二、大数据页设计和开发&lt;/h3&gt;
&lt;p&gt;先看看效果图（没有设计师，一个前端的审美），这里我用的尤雨溪大大账号进行查询的数据实例（向Vue作者致敬），尤大大的各项数据杠杠的，膜拜脸.img&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656ce11a6e2af6b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656ce11a6e2af6b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;637&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，通过我这个设计可以划分上、中（左中右）三个部分内容为：&lt;/p&gt;
&lt;p&gt;【1】上面基本上一个标题，左上角有一个“彩蛋”（后头讲作用）&lt;/p&gt;
&lt;p&gt;【2】中-左部分：个人信息，仓库stars情况，仓库语言分类&lt;/p&gt;
&lt;p&gt;【3】中-中部分：仓库公开数量、粉丝数量、跟随数量、仓库数据、最近你的操作&lt;/p&gt;
&lt;p&gt;【4】中-右：最近的粉丝、最近的跟随、最新信息&lt;/p&gt;
&lt;p&gt;值得一说的是我这边每个功能都是一个模块组件，首先带边框的是一个组件盒子、图表都是一个组件盒子、数量数据模块也是一个组件盒子、粉丝和跟随一个组件盒子&lt;/p&gt;
&lt;p&gt;下面我按功能模块讲：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、个人信息、仓库公开数量、粉丝数量、跟随数量&lt;/strong&gt;：个人头像、用户名、加入时间。这些都是可以通过接口(https://api.github.com/users)直接获取，然后直接放上去就OK了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、仓库stars情况，仓库语言分类&lt;/strong&gt;，我这里用的是一个接口（https://api.github.com/users/用户名/repos）例如，我这边用自己账号测的第一条数据&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d09383a0aa88?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d09383a0aa88?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;990&quot; data-height=&quot;868&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你会发现这个数据一条都有93行数据，看的你&lt;strong&gt;头皮发麻&lt;/strong&gt;，其实这里你只需要，仓库名和获取的star数量和语言类型，这几个数据。&lt;/p&gt;
&lt;p&gt;这个时候你就得研究一下v-charts官网了（对于有经验的同学直接跳过），看看它要接受什么样类型的对象数据，然后你就按照他的要求去拼装成它能识别的数据格式，这样才能生成想要的可视化图表，看了一下，数据格式基本上就是这个样子，看到片这里，你可以顺便了解一下怎么设置v-charts 的外观和大小之类的设置，其中我总结这几个属性legend、grid、series用到的概率比较高。&lt;/p&gt;

&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;&amp;lt;script&amp;gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;export default {
    data: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;function () {
      &lt;span class=&quot;hljs-built_in&quot;&gt;return {
        chartData: {
          columns: [&lt;span class=&quot;hljs-string&quot;&gt;'日期', &lt;span class=&quot;hljs-string&quot;&gt;'访问用户', &lt;span class=&quot;hljs-string&quot;&gt;'下单用户', &lt;span class=&quot;hljs-string&quot;&gt;'下单率'],
          rows: [
            { &lt;span class=&quot;hljs-string&quot;&gt;'日期': &lt;span class=&quot;hljs-string&quot;&gt;'1/1', &lt;span class=&quot;hljs-string&quot;&gt;'访问用户': 1393, &lt;span class=&quot;hljs-string&quot;&gt;'下单用户': 1093, &lt;span class=&quot;hljs-string&quot;&gt;'下单率': 0.32 },
            { &lt;span class=&quot;hljs-string&quot;&gt;'日期': &lt;span class=&quot;hljs-string&quot;&gt;'1/2', &lt;span class=&quot;hljs-string&quot;&gt;'访问用户': 3530, &lt;span class=&quot;hljs-string&quot;&gt;'下单用户': 3230, &lt;span class=&quot;hljs-string&quot;&gt;'下单率': 0.26 },
            { &lt;span class=&quot;hljs-string&quot;&gt;'日期': &lt;span class=&quot;hljs-string&quot;&gt;'1/3', &lt;span class=&quot;hljs-string&quot;&gt;'访问用户': 2923, &lt;span class=&quot;hljs-string&quot;&gt;'下单用户': 2623, &lt;span class=&quot;hljs-string&quot;&gt;'下单率': 0.76 },
            { &lt;span class=&quot;hljs-string&quot;&gt;'日期': &lt;span class=&quot;hljs-string&quot;&gt;'1/4', &lt;span class=&quot;hljs-string&quot;&gt;'访问用户': 1723, &lt;span class=&quot;hljs-string&quot;&gt;'下单用户': 1423, &lt;span class=&quot;hljs-string&quot;&gt;'下单率': 0.49 },
            { &lt;span class=&quot;hljs-string&quot;&gt;'日期': &lt;span class=&quot;hljs-string&quot;&gt;'1/5', &lt;span class=&quot;hljs-string&quot;&gt;'访问用户': 3792, &lt;span class=&quot;hljs-string&quot;&gt;'下单用户': 3492, &lt;span class=&quot;hljs-string&quot;&gt;'下单率': 0.323 },
            { &lt;span class=&quot;hljs-string&quot;&gt;'日期': &lt;span class=&quot;hljs-string&quot;&gt;'1/6', &lt;span class=&quot;hljs-string&quot;&gt;'访问用户': 4593, &lt;span class=&quot;hljs-string&quot;&gt;'下单用户': 4293, &lt;span class=&quot;hljs-string&quot;&gt;'下单率': 0.78 }
          ]
        }
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;所以你就一起抽离一下&lt;/p&gt;

&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;data () {
         this.extend = {
        legend:{
                 textStyle: {color: &lt;span class=&quot;hljs-string&quot;&gt;'#fff'},
        },
        grid: {
            textStyle: {
                color: &lt;span class=&quot;hljs-string&quot;&gt;&quot;#fff&quot;
            }
          },
          series:{
                radius:[&lt;span class=&quot;hljs-string&quot;&gt;'0',&lt;span class=&quot;hljs-string&quot;&gt;'40%'],
                center: [&lt;span class=&quot;hljs-string&quot;&gt;'50%', &lt;span class=&quot;hljs-string&quot;&gt;'50%']
          }
    }
    &lt;span class=&quot;hljs-built_in&quot;&gt;return {
      personalD:{},
      starData:{
                  columns: [&lt;span class=&quot;hljs-string&quot;&gt;'reposName', &lt;span class=&quot;hljs-string&quot;&gt;'getStars'],
                  rows: [
                  ]
                },
      noStarData:&lt;span class=&quot;hljs-literal&quot;&gt;false,
      languageData:{
                  columns: [&lt;span class=&quot;hljs-string&quot;&gt;'lang', &lt;span class=&quot;hljs-string&quot;&gt;'number'],
                  rows: [
                  ]
                },
      nolanguageData:&lt;span class=&quot;hljs-literal&quot;&gt;false
    }
  }
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;说明：starData、languageData,分别是仓库stars情况，仓库语言分类初始化数据对象&lt;/p&gt;
&lt;p&gt;这里是请求数据和梳理仓库名和获取的star数量和语言类型的代码&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;getData(username){
        &lt;span class=&quot;hljs-built_in&quot;&gt;let comUrl = &lt;span class=&quot;hljs-string&quot;&gt;&quot;https://api.github.com/users/&quot;
        axios.get(comUrl + username + &lt;span class=&quot;hljs-string&quot;&gt;'/repos').then((response)=&amp;gt;{
            &lt;span class=&quot;hljs-built_in&quot;&gt;let data = JSON.parse(JSON.stringify(response.data))
            &lt;span class=&quot;hljs-keyword&quot;&gt;if(data.length&amp;lt;1){
                        this.noStarData = &lt;span class=&quot;hljs-literal&quot;&gt;true
                }&lt;span class=&quot;hljs-keyword&quot;&gt;else{
                        &lt;span class=&quot;hljs-built_in&quot;&gt;let rowdata = []
                        &lt;span class=&quot;hljs-built_in&quot;&gt;let languages = {}
                        &lt;span class=&quot;hljs-keyword&quot;&gt;for(var i=0;i&amp;lt;data.length;i++){   
                                // 仓库和仓库star
                                &lt;span class=&quot;hljs-built_in&quot;&gt;let reposName = data[i].name
                                &lt;span class=&quot;hljs-built_in&quot;&gt;let getStars = data[i].stargazers_count
                                &lt;span class=&quot;hljs-built_in&quot;&gt;let obj = {
                            reposName:reposName,
                            getStars:getStars
                       }
                    rowdata.push(obj)
                    
                    //梳理语言，计算语言类型和各个语言的数量
                    &lt;span class=&quot;hljs-built_in&quot;&gt;let langData =data[i].language
                    &lt;span class=&quot;hljs-keyword&quot;&gt;if (langData) {
                                    &lt;span class=&quot;hljs-keyword&quot;&gt;if (langData &lt;span class=&quot;hljs-keyword&quot;&gt;in languages) {
                                        languages[langData]++;
                                    }&lt;span class=&quot;hljs-keyword&quot;&gt;else {
                                        languages[langData] = 1;
                                    }
                                }
                        }
                        //把值附到starData.rows
                        this.starData.rows = rowdata
                        //console.log(this.starData.rows)
                 
                 //重新组装语言封成对象
                        &lt;span class=&quot;hljs-built_in&quot;&gt;let objL = JSON.parse(JSON.stringify(languages))
                        &lt;span class=&quot;hljs-built_in&quot;&gt;let dataL =[]
                        &lt;span class=&quot;hljs-keyword&quot;&gt;for(var key &lt;span class=&quot;hljs-keyword&quot;&gt;in objL){
                                dataL.push({&lt;span class=&quot;hljs-string&quot;&gt;&quot;lang&quot;:key,&lt;span class=&quot;hljs-string&quot;&gt;&quot;number&quot;:objL[key]}) 
                         }
                       this.languageData.rows = dataL
                        //console.log(objL)  
                        //console.log(this.languageData.rows)
                }  
                    &lt;span class=&quot;hljs-built_in&quot;&gt;return
                    
                    
                }).catch(err =&amp;gt; {
                           console.log(err.message);
                        })
           }
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里的代码不够优雅（别问我为什么不用map函数），比如我计算具体语言的仓库的语言类型，每个仓库都有可能有几种语言，每条仓库的语言都不一样，我要统计全部仓库的各个语言的个数，然后再封装成&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fv-charts.js.org%2F%23%2F&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;v-charts&lt;/a&gt;可以识别的数据类型，所以分两步做了，首先把遍历出来的语言都放在一个对象里，如下&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;1、{&lt;span class=&quot;hljs-string&quot;&gt;&quot;JavaScript&quot;:2,&lt;span class=&quot;hljs-string&quot;&gt;&quot;CSS&quot;:2,&lt;span class=&quot;hljs-string&quot;&gt;&quot;less&quot;:2}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;然后把这个数据转换成v-charts可以识别的数据类型，如下&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;[
{&lt;span class=&quot;hljs-string&quot;&gt;&quot;lang&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;JavaScript&quot;,
 &lt;span class=&quot;hljs-string&quot;&gt;&quot;number&quot;:2
}
{&lt;span class=&quot;hljs-string&quot;&gt;&quot;lang&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;CSS&quot;,
 &lt;span class=&quot;hljs-string&quot;&gt;&quot;number&quot;:2
}
] 
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3、仓库数据、最近你的操作、&lt;/strong&gt;&lt;strong&gt;最近的粉丝、最近的跟随 这个数据直接可以获取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、最新信息，&lt;/strong&gt;这里也是都做了，一个新闻滚动效果，具体实现可以移步我写的这篇文章这里&lt;/p&gt;

&lt;h3 data-id=&quot;heading-10&quot;&gt;三、优化和体验交互的一些处理&lt;/h3&gt;
&lt;p&gt;1、在加载数据的时候会有一个遮罩层设计，数据加载出来了这个遮罩层消失、展现数据，实现原理就是v-if控制显示隐藏&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d26dc0b88fe6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d26dc0b88fe6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;699&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、当用户尴尬到，没有查找无数据的会有对应的提示没有数据选项&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d2a6d2372074?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d2a6d2372074?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;403&quot; data-height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、当用户在地址栏输入不存在的用户的查询会有个判断，然后弹框提示，点击关闭都会跳转到首页入口页面&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d2c270dd3dcd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d2c270dd3dcd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;674&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;h2 data-id=&quot;heading-11&quot;&gt;四、小彩蛋&lt;/h2&gt;
&lt;p&gt;说是小彩蛋，其实，就是大概讲一下作为作者，我后面GitDataV后面的一些小展望吧，之前说的左上角左箭头图标，其实这里是做一个拓展功能，目前&lt;strong&gt;点击全屏&lt;/strong&gt;已经实现，后面还会继续添加&lt;strong&gt;国际化处理&lt;/strong&gt;、&lt;strong&gt;切换皮肤&lt;/strong&gt;等功能。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d3583bc926df?imageslim&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/1656d3583bc926df?imageslim&quot; data-width=&quot;590&quot; data-height=&quot;333&quot;/&gt;&lt;/p&gt;

&lt;h2 data-id=&quot;heading-12&quot;&gt;最后：&lt;/h2&gt;
&lt;p&gt;到这里，GitDataV，Vue构建的github“可视化大数据平台”设计、开发分享到这里就告一段落，希望对初中级前端同学有所帮助。github提供了开发者API，能获取的数据远不止这些，如果要更全面的梳理数据，需要比较长的路要走，数据分析可以做的更好，目前这些功能和数据梳理在性能上和实用性上没有做过多的测试，包括文章写的仓促，描述有误之处，谢谢大家指正。&lt;/p&gt;
&lt;p&gt;目前打包后的项目放在github通过网站访问有些Bug待解决，但不影响正常使用，推荐把&lt;strong&gt;GitDataV（github源码仓库）&lt;/strong&gt;项目下载下来，在本机运行项目，然后通过自己的账号生成自己的github“可视化大数据平台”。（感觉还不错的话，老铁们是不是来github里赏个&lt;strong&gt;★&lt;/strong&gt;Star鼓励一哈）&lt;/p&gt;
&lt;p&gt;后续会持续更新和优化，分享一些新的功能在github仓库，也会发布更新在这篇文章和上，也期待大家的交流....&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 18 May 2019 07:07:00 +0000</pubDate>
<dc:creator>懂天明</dc:creator>
<og:description>写在前面 GitDataV，是一个github“大数据可视化平台”，通过它你可以更直观的看到你在github里的一些数据，（之所以打双引号，是因为我觉得这个还没到大数据可视化的程度）。其实我在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinlangboke/p/10885829.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core MVC 视图 - 雪飞鸿</title>
<link>http://www.cnblogs.com/Cwj-XFH/p/10885745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cwj-XFH/p/10885745.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ASP.NET Core MVC中视图的知识和ASP.NET MVC有很多相似之处，学习难度较低。以下内容主要体现了编程中&lt;span&gt;&lt;strong&gt;模块化&lt;/strong&gt;&lt;span&gt;的思想，模块化才应是我们关注的重点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;布局用于提供各个页面所需的公共部分，如：菜单、页头、页尾等。在ASP.NET Core中默认的布局文件是位于/Views/Shared文件夹下的&lt;span&gt;&lt;code&gt;_Layout.cshtml&lt;/code&gt;&lt;span&gt;文件：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201905/784150-20190518144227422-475930389.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/imgs/_Layout_Default_Location.jpg&quot;&gt;&lt;img src=&quot;file://c/Users/WenJun/Desktop/博客草稿/imgs/_Layout_Default_Location.jpg?lastModify=1558161482&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们通常在&lt;span&gt;&lt;code&gt;_Layout.cshtml&lt;/code&gt;&lt;span&gt;中引入公共资源，如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;~/css/reset.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;~/css/index.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/js/common/net/ajaxHandler.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;=&quot;Development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/js/lib/vue/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;=&quot;Production&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/js/lib/vue/vue.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;指定布局文件&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可以在&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-2.2&quot;&gt;&lt;span&gt;Razor&lt;/span&gt;&lt;/a&gt;&lt;span&gt;视图(即，cshtml文件)中使用&lt;span&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;span&gt;属性来指定使用哪个布局文件：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    Layout&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Layout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ASP.NET Core MVC搜索布局文件的方式与局部视图一样，下文中会详细说明。默认情况下，在布局文件中必须调用&lt;span&gt;&lt;code&gt;RenderBody&lt;/code&gt;&lt;span&gt;方法。还可以使用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/layout?view=aspnetcore-2.2#sections&quot;&gt;&lt;span&gt;RenderSection&lt;/span&gt;&lt;/a&gt;&lt;span&gt;方法来引入&lt;span&gt;&lt;code&gt;section&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可以在&lt;span&gt;&lt;code&gt;_ViewImport.cshtm&lt;/code&gt;&lt;span&gt;文件中添加命名空间或者Tag Helper以供其它视图中使用，如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using Microsoft.AspNetCore.Identity
@addTagHelper &lt;/span&gt;*, Microsoft.AspNetCore.Mvc.TagHelpers
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在&lt;span&gt;&lt;code&gt;_ViewImport.cshtm&lt;/code&gt;&lt;span&gt;文件可以使用以下指令：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@addTagHelper&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@removeTagHelper&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@tagHelperPrefix&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@using&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@model&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@inherits&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@inject&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;_ViewImport.cshtm&lt;/code&gt;&lt;span&gt;文件不支持Razor文件的其它特性，如：function、section等。对于多个&lt;span&gt;&lt;code&gt;_ViewImports.cshtml&lt;/code&gt;&lt;span&gt;的情况，指令运行结果遵循如下规则：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@addTagHelper&lt;/code&gt;&lt;span&gt;, &lt;span&gt;&lt;code&gt;@removeTagHelper&lt;/code&gt;&lt;span&gt;: 按照先后顺序执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@tagHelperPrefix&lt;/code&gt;&lt;span&gt;: 后执行的结果覆盖先执行的结果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@model&lt;/code&gt;&lt;span&gt;: 后执行的结果覆盖先执行的结果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@inherits&lt;/code&gt;&lt;span&gt;: 后执行的结果覆盖先执行的结果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@using&lt;/code&gt;&lt;span&gt;: 引入所指定的所有命名空间，但忽略重复引用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@inject&lt;/code&gt;&lt;span&gt;: 后注入覆盖先注入的同名属性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;_ViewStart.cshtml&lt;/code&gt;&lt;span&gt;文件中的代码会在所有完整视图(full view,not layout,not partial view)文件被渲染之前执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;默认情况下，&lt;span&gt;&lt;code&gt;ViewImports.cshtml&lt;/code&gt;&lt;span&gt;和&lt;span&gt;&lt;code&gt;ViewStart.cshtml&lt;/code&gt;&lt;span&gt;文件直接位于Views文件夹下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201905/784150-20190518144253147-193861814.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:/Users/WenJun/Desktop/%E5%8D%9A%E5%AE%A2%E8%8D%89%E7%A8%BF/imgs/ViewImport&amp;amp;ViewStart_Default_Location.png&quot;&gt;&lt;img src=&quot;file://c/Users/WenJun/Desktop/博客草稿/imgs/ViewImport&amp;amp;ViewStart_Default_Location.png?lastModify=1558161482&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;相比其它位置的其它位置&lt;span&gt;&lt;code&gt;ViewImports.cshtml&lt;/code&gt;&lt;span&gt;和&lt;span&gt;&lt;code&gt;ViewStart.cshtml&lt;/code&gt;&lt;span&gt;，直接位于Views文件夹中的&lt;span&gt;&lt;code&gt;ViewImports.cshtml&lt;/code&gt;&lt;span&gt;和&lt;span&gt;&lt;code&gt;ViewStart.cshtml&lt;/code&gt;&lt;span&gt;文件会优先执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;后执行的&lt;span&gt;&lt;code&gt;ViewImports.cshtml&lt;/code&gt;&lt;span&gt;文件中的内容有可能会覆盖先执行&lt;span&gt;&lt;code&gt;ViewImports.cshtml&lt;/code&gt;&lt;span&gt;文件中的内容&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;ViewImports.cshtml&lt;/code&gt;&lt;span&gt;和&lt;span&gt;&lt;code&gt;ViewStart.cshtml&lt;/code&gt;&lt;span&gt;文件的作用域是当前目录及子目录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Tag Helper可以让服务器端代码参与到在Razor文件中创建和渲染HTML元素的工作中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;自定义Tag Helper：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; XfhTagHelper : TagHelper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        output.TagName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        output.Attributes.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.google.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        output.Content.SetContent(Content);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用Tag Helper：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@addTagHelper *,Web
​
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xfh &lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;=&quot;haha&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;customer tag helper&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xfh&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Tag Helper与HTML Helper有些相似，二者不同之处可参考：&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-2.2#tag-helpers-compared-to-html-helpers&quot;&gt;&lt;span&gt;Tag Helpers compared to HTML Helpers&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Tag Helper具有以下优点：&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;Tag Helper 作用域&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@addTagHelper&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@addTagHelper&lt;/code&gt;&lt;span&gt;的第一个参数表示要加载哪些Tag Helper，使用&quot;*&quot;表示加载所有的Tag Helper；第二个参数表示从哪个程序集中加载Tag Helper。示例如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@* 需指明TagHelper的完全限定名 *&lt;span&gt;@
@addTagHelper Web.TagHelpers.XfhTagHelper,Web&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@removeTagHelper&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;@removeTagHelper&lt;/code&gt;&lt;span&gt;也有两个参数，含义同&lt;span&gt;&lt;code&gt;@addTagHelper&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@tagHelperPrefix&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;给Tag Helper加上前缀标识，示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@addTagHelper *,Web
@tagHelperPrefix th:
​
@* 不会被当作Tag Helper处理 *@
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xfh &lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;=&quot;haha&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;customer tag helper&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xfh&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th:xfh &lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;=&quot;tagHelperPrefix&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th:xfh&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Partial view，局部视图是一个Razor文件，它通常嵌套在另一个Razor文件中&lt;/strong&gt;&lt;span&gt;。局部视图主要用于拆分大的Razor文件及代码复用。但请注意：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot; readability=&quot;2.8455882352941&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1.8372093023256&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;局部视图不应用来维护公共布局中的内容，考虑使用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/layout?view=aspnetcore-2.2&quot;&gt;&lt;span&gt;_Layout.cshtml&lt;/span&gt;&lt;/a&gt;&lt;span&gt;来维护公共布局&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Partial views shouldn't be used to maintain common layout elements.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;3.8490566037736&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;尽量不要在局部视图中使用复杂的渲染逻辑，或者需要执行一些代码片段才能获取到视图元素。这种情况考虑使用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/view-components?view=aspnetcore-2.2&quot;&gt;&lt;span&gt;view component&lt;/span&gt;&lt;/a&gt;&lt;span&gt;来替代局部视图。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Don't use a partial view where complex rendering logic or code execution is required to render the markup.If you need to execute code, use a view component instead of a partial view.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;声明局部视图&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;局部视图名通常以下划线&lt;span&gt;&lt;code&gt;_&lt;/code&gt;&lt;span&gt;开头，下划线主要用于易于辨识局部视图文件。注意一点，&lt;span&gt;&lt;strong&gt;&lt;span&gt;在渲染局部视图时，不会执行&lt;span&gt;&lt;code&gt;_ViewStart.cshtml&lt;/code&gt;&lt;span&gt;文件中的代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。其余与普通视图一样。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-emoji&quot; data-content=&quot;warning&quot;&gt;⚠️&lt;span&gt;局部视图中定义的&lt;span&gt;&lt;code&gt;section&lt;/code&gt;&lt;span&gt;只对当前局部视图可见&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;使用局部视图&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;引用局部视图文件而&lt;span&gt;&lt;strong&gt;不带扩展名&lt;/strong&gt;&lt;span&gt;&lt;code&gt;cshtml&lt;/code&gt;&lt;span&gt;时，在MVC框架中，会从以下路径中加载局部视图文件，优先级从上而下依次降低：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;/Areas/&amp;lt;Area-Name&amp;gt;/Views/&amp;lt;Controller-Name&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;/Areas/&amp;lt;Area-Name&amp;gt;/Views/Shared&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;/Views/Shared&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;/Pages/Shared&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当引用局部文件&lt;span&gt;&lt;strong&gt;带上扩展名&lt;/strong&gt;&lt;span&gt;时，局部视图文件必须和引用方位于相同目录下。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可使用以下方式引入局部视图：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;partial &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partial.cshtml&quot;&lt;/span&gt;&lt;span&gt; model&lt;/span&gt;&lt;span&gt;=&quot;Model&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
  @* 局部视图文件后缀可以省略，如： *@
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;partial &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partial&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
  @* 也可以使用局部视图文件全名，如： *@
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;partial &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;~/Views/Shared/_PartialName.cshtml&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;HTML Helper&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@await Html.PartialAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_PartialName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;也可以使用 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.rendering.htmlhelperpartialextensions.renderpartialasync&quot;&gt;&lt;span&gt;RenderPartialAsync&lt;/span&gt;&lt;/a&gt;&lt;span&gt;方法来渲染局部视图，该方法直接将渲染结果写入到response中，而不是返回 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.html.ihtmlcontent&quot;&gt;&lt;span&gt;IHtmlContent&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，所以只能在Razor代码块中调用该方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Html.RenderPartialAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_PartialName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;相比于&lt;span&gt;&lt;code&gt;PartialAsync&lt;/code&gt;&lt;span&gt;，&lt;span&gt;&lt;code&gt;RenderParatialAsync&lt;/code&gt;&lt;span&gt;有着更好的性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;View component，视图组件和局部视图类似，但它更强大。一个视图组件包含两部分：&lt;span&gt;&lt;code&gt;ViewComponent&lt;/code&gt;&lt;span&gt;类和一个视图。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;视图组件不使用模型绑定，视图组件中所用的数据有调用者提供。视图组件有以下特点：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;渲染数据块而非整个响应&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关注点分离、易于测试&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可以有参数和业务逻辑&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;MVC本身就提倡关注点分离，所以，视图组件中应尽可能只包含与渲染视图相关的逻辑&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通常在层中调用&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;自定义视图组件&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;创建视图组件类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FirstViewComponent : ViewComponent
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法名InvokeAsync是基于约定的，同步方法名为Invoke&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IViewComponentResult&amp;gt; InvokeAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; descript)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(descript);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-emoji&quot; data-content=&quot;warning&quot;&gt;⚠️ &lt;span&gt;视图组件类中可以使用依赖注入。需注意：视图组件不会参与到Controller的生命周期中，所以filter对它无效。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;创建视图文件：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;视图组件默认视图名为：&lt;span&gt;&lt;code&gt;Default&lt;/code&gt;&lt;span&gt;，简单定义视图内容如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    @Model
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在运行时按照以下顺序搜索视图文件：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;/Views/{Controller Name}/Components/{View Component Name}/{View Name}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;/Views/Shared/Components/{View Component Name}/{View Name}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;/Pages/Shared/Components/{View Component Name}/{View Name}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-emoji&quot; data-content=&quot;ok&quot;&gt;🆗 &lt;span&gt;推荐使用Default作为视图组件的视图文件名，且视图文件存放路径为：&lt;span&gt;&lt;em&gt;Views/Shared/Components/{View Component Name}/{View Name}&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可以使用如下两种方式来调用视图组件：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Component.InvokeAsync&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Tag Helper&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@addTagHelper *,Web
​
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;text-center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    @await Component.InvokeAsync(&quot;First&quot;, new { descript = &quot;invoking view component&quot; })
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    @* Tag Helper方式调用ViewComponent，需以vc:作为前缀 *@
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;vc:first &lt;/span&gt;&lt;span&gt;descript&lt;/span&gt;&lt;span&gt;=&quot;tag helper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;vc:first&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-emoji&quot; data-content=&quot;warning&quot;&gt;⚠️ &lt;span&gt;注意，使用Tag Helper形式调用视图组件时，组件名和组件的方法参数使用 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11273282/whats-the-name-for-dash-separated-case/12273101&quot;&gt;&lt;span&gt;kebab case&lt;/span&gt;&lt;/a&gt;&lt;span&gt;方式，即，组件&lt;span&gt;&lt;code&gt;PriorityList&lt;/code&gt;&lt;span&gt;有参数&lt;span&gt;&lt;code&gt;maxPriority&lt;/code&gt;&lt;span&gt;，则调用方式如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;vc:priority-list &lt;/span&gt;&lt;span&gt;max-priority&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;vc:priority-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;除此之外，还可以在Controller中调用视图组件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult InvokeVC()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，视图组件名称大小写敏感&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; ViewComponent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;First&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { Descript = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;});
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;View component methods&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;抄录一段微软官网上对于&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/view-components?view=aspnetcore-2.2#view-component-methods&quot;&gt;&lt;span&gt;View component methods&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的总结，人太懒，就不翻译了&lt;span class=&quot;md-emoji&quot; data-content=&quot;joy&quot;&gt;😂&lt;span&gt;，留意加粗部分：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;A view component defines its logic in an &lt;span&gt;&lt;code&gt;InvokeAsync&lt;/code&gt; &lt;span&gt;method that returns a &lt;span&gt;&lt;code&gt;Task&amp;lt;IViewComponentResult&amp;gt;&lt;/code&gt; &lt;span&gt;or in a synchronous &lt;span&gt;&lt;code&gt;Invoke&lt;/code&gt; &lt;span&gt;method that returns an &lt;span&gt;&lt;code&gt;IViewComponentResult&lt;/code&gt;&lt;span&gt;. Parameters come directly from invocation of the view component, not from model binding. &lt;span&gt;&lt;strong&gt;&lt;span&gt;A view component never directly handles a request. Typically, a view component initializes a model and passes it to a view by calling the &lt;span&gt;&lt;code&gt;View&lt;/code&gt; &lt;span&gt;method&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;. In summary, view component methods:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Define an &lt;span&gt;&lt;code&gt;InvokeAsync&lt;/code&gt; &lt;span&gt;method that returns a &lt;span&gt;&lt;code&gt;Task&amp;lt;IViewComponentResult&amp;gt;&lt;/code&gt; &lt;span&gt;or a synchronous &lt;span&gt;&lt;code&gt;Invoke&lt;/code&gt;&lt;span&gt;method that returns an &lt;span&gt;&lt;code&gt;IViewComponentResult&lt;/code&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Typically initializes a model and passes it to a view by calling the &lt;span&gt;&lt;code&gt;ViewComponent&lt;/code&gt; &lt;span&gt;&lt;span&gt;&lt;code&gt;View&lt;/code&gt; &lt;span&gt;method.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Parameters come from the calling method, not HTTP. There's no model binding.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Are not reachable directly as an HTTP endpoint. They're invoked from your code (usually in a view). A view component never handles a request.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Are overloaded on the signature rather than any details from the current HTTP request.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;本文主要对ASP.NET Core中的视图部分做了简要概述，相比于文中的各种概念，我们应该把注意力放到模块化设计上。&lt;span&gt;&lt;strong&gt;模块化、抽象思维&lt;/strong&gt;&lt;span&gt;是程序员应该掌握的两种能力。他们可以让我们写出高内聚、低耦合的代码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;a href=&quot;https://files.cnblogs.com/files/Cwj-XFH/ASP.NET_Core_%E8%A7%86%E5%9B%BE.rar&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;点击下载Demo源码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-2.2&quot;&gt;&lt;span&gt;Tag Helpers in ASP.NET Core&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/view-components?view=aspnetcore-2.2#view-components&quot;&gt;&lt;span&gt;View components in ASP.NET Core&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/areas?view=aspnetcore-2.2&quot;&gt;&lt;span&gt;Areas in ASP.NET Core&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 06:51:00 +0000</pubDate>
<dc:creator>雪飞鸿</dc:creator>
<og:description>ASP.NET Core MVC中视图的知识和ASP.NET MVC有很多相似之处，学习难度较低。以下内容主要体现了编程中模块化的思想，模块化才应是我们关注的重点。 Layout 布局用于提供各个页面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cwj-XFH/p/10885745.html</dc:identifier>
</item>
<item>
<title>设计模式之命令模式（三） - 小酒窝</title>
<link>http://www.cnblogs.com/dimple91/p/10885586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dimple91/p/10885586.html</guid>
<description>&lt;p&gt;我回来啦！今天是周六，一看命令模式还有一个总结未完成，赶紧爬起来做做好。&lt;/p&gt;
&lt;p&gt;就如上一篇所说的，如果拥有了一个遥控器，却无法光凭按下一个按你，就同时能弄暗灯光、打开音响和电视、设置到DVD，并让热水器开始加温，那么我要这个遥控器还有什么意义呢？&lt;/p&gt;
&lt;h4 id=&quot;使用宏命令&quot;&gt;使用宏命令&lt;/h4&gt;
&lt;p&gt;根据比较高级的想法来看，就是我们需要制造一种新的命令，用来执行其他一堆命令，而不只是执行一个命令，这样就是一个不错的想法了吧。这就是我们将要说的宏命令。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MacroCommand implements Command {
    // 在宏命令中，用命令数组存储一大堆命令
    Command[] commands;
 
    public MacroCommand(Command[] commands) {
        this.commands = commands;
    }
 
    public void execute() {
        for (int i = 0; i &amp;lt; commands.length; i++) {
        // 当这个宏命令被遥控器执行时，就一次性执行数组里的每个命令
            commands[i].execute();
        }
    }
 
    /**
     * NOTE:  these commands have to be done backwards to ensure 
     * proper undo functionality
     */
    public void undo() {
        for (int i = commands.length -1; i &amp;gt;= 0; i--) {
            commands[i].undo();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们来看下如何使用宏命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先创建想要进入宏的命令集合&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Light light = new Light(&quot;Living Room&quot;);
TV tv = new TV(&quot;Living Room&quot;);
Stereo stereo = new Stereo(&quot;Living Room&quot;);
Hottub hottub = new Hottub();
 
LightOnCommand lightOn = new LightOnCommand(light);
StereoOnCommand stereoOn = new StereoOnCommand(stereo);
TVOnCommand tvOn = new TVOnCommand(tv);
HottubOnCommand hottubOn = new HottubOnCommand(hottub);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;接下来创建两个数组，其中一个用来记录开启命令，另一个用来记录关闭命令，并在数组内放入对应的命令&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Command[] partyOn = { lightOn, stereoOn, tvOn, hottubOn};
Command[] partyOff = { lightOff, stereoOff, tvOff, hottubOff};
  
MacroCommand partyOnMacro = new MacroCommand(partyOn);
MacroCommand partyOffMacro = new MacroCommand(partyOff);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;然后将宏命令指定给我们所希望的按钮：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;remoteControl.setCommand(0, partyOnMacro, partyOffMacro);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;最后，只需按下一些按钮，测试是否正常工作&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;System.out.println(remoteControl);
System.out.println(&quot;--- Pushing Macro On---&quot;);
remoteControl.onButtonWasPushed(0);
System.out.println(&quot;--- Pushing Macro Off---&quot;);
remoteControl.offButtonWasPushed(0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不会忘记我们的撤销功能&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void undo() {
    for (int i = commands.length -1; i &amp;gt;= 0; i--) {
        commands[i].undo();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;命令模式的更多用途队列请求&quot;&gt;命令模式的更多用途：队列请求&lt;/h4&gt;
&lt;p&gt;命令可以将运算块打包（一个接收者和一组动作），然后将它传来传去，就像是一般的对象一样。现在，即使在命令被创建许久之后，运算依然可以被调用。事实上，它甚至可以在不同的线程中被调用。我们可以利用这样的特性衍生一些应用，例如：日程安排、线程池、工作队列等。&lt;/p&gt;
&lt;p&gt;想象一个工作队列：你再某一端添加命令，然后另一端则是线程。线程进行下面的动作：从队列中取出一个命令，调用它的execute()方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令。。。&lt;/p&gt;
&lt;p&gt;请注意，工作队列类和进行计算的对象之间完全是解耦的。此刻线程可能在进行财务运算，下一刻却在读取网络数据。工作队列对象不在乎到底做些什么，他们只知道取出命令对象，然后调用其execute()方法。&lt;/p&gt;
&lt;h4 id=&quot;命令模式的更多用途日志请求&quot;&gt;命令模式的更多用途：日志请求&lt;/h4&gt;
&lt;p&gt;某些应用需要我们将所有的动作都记录在日志中，并能在系统死机之后，重新调用这些动作恢复到之前的状态。命令模式能够支持这一点。&lt;/p&gt;
&lt;p&gt;当我们执行命令的时候，将历史记录存储在磁盘中，一旦系统死机，我们就可以将命令对象重新加载，并成批地依次调用这些对象的execute()方法。&lt;/p&gt;
&lt;p&gt;比如有许多调用大型数据结构的应用无法在每次改变发生时被快速地存储。通过使用记录日志，我们可以将上次检查点之后的所有操作记录下来，如果系统出状况，从检查点开始应用这些操作。比如说，对于电子表格应用，我们可能想要实现的错误回复方式是将电子表格的操作记录在日志中，而不是每次电子表格一有变化就记录整个电子表格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于更高级的应用而言，这些技巧可以被扩展应用到事务处理中，也就是说，一整群操作必须全部进行完成，或者没有进行任何的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;设计箱内的工具&quot;&gt;设计箱内的工具&lt;/h4&gt;
&lt;p&gt;还是按照之前的套路，总结下工具箱内新增的工具吧&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;OO基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象、封装、继承、多态&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;OO原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;封装变化&lt;/p&gt;
&lt;p&gt;多用组合，少用继承&lt;/p&gt;
&lt;p&gt;针对接口编程，不针对实现编程&lt;/p&gt;
&lt;p&gt;为交互对象之间的松耦合设计而努力&lt;/p&gt;
&lt;p&gt;依赖抽象，不要依赖具体类&lt;/p&gt;
&lt;p&gt;类应该对扩展开放，对修改关闭&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;OO模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;『策略模式』、『观察者模式』、『装饰者模式』、『抽象工厂模式』、『工厂方法模式』、『单例模式』&lt;/p&gt;
&lt;p&gt;『&lt;strong&gt;命令模式&lt;/strong&gt;』将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们学习命令模式，就是一个循序渐进的过程，先从简单的开关开始，然后再到复杂的开启状态，进而想到队列，想到记录日志这种事务操作。学习也是一个循序渐进的过程，我们通过简单的Demo学习，然后到项目实践，再到后面独立设计框架，我相信大家都能悟出这个道理来。&lt;/p&gt;
&lt;p&gt;持续学习，精进学习，我们会一起加油。下一次，我们将学习&lt;strong&gt;适配器模式与外观模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;爱生活，爱学习，爱感悟，爱挨踢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/mw690/62b02411ly1g1h6i45avyj207607674r.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 06:17:00 +0000</pubDate>
<dc:creator>小酒窝</dc:creator>
<og:description>我回来啦！今天是周六，一看命令模式还有一个总结未完成，赶紧爬起来做做好。 就如上一篇所说的，如果拥有了一个遥控器，却无法光凭按下一个按你，就同时能弄暗灯光、打开音响和电视、设置到DVD，并让热水器开始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dimple91/p/10885586.html</dc:identifier>
</item>
<item>
<title>MySQL数据库基础详解 - 故事爱人</title>
<link>http://www.cnblogs.com/WUXIAOCHANG/p/10885361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WUXIAOCHANG/p/10885361.html</guid>
<description>&lt;h2&gt;文章大纲&lt;/h2&gt;
&lt;p&gt;一、数据库简介&lt;br data-filtered=&quot;filtered&quot;/&gt;
二、Mysql数据库简介&lt;br data-filtered=&quot;filtered&quot;/&gt;
三、Mysql安装与服务启动（Windows版本）&lt;br data-filtered=&quot;filtered&quot;/&gt;
四、Mysql图形化工具&lt;br data-filtered=&quot;filtered&quot;/&gt;
五、Mysql存储引擎精讲&lt;br data-filtered=&quot;filtered&quot;/&gt;
六、Mysql数据类型介绍&lt;br data-filtered=&quot;filtered&quot;/&gt;
七、Mysql主要专业名称介绍&lt;br data-filtered=&quot;filtered&quot;/&gt;
八、Mysql常见sql语句&lt;br data-filtered=&quot;filtered&quot;/&gt;
九、Mysql设计与语句优化&lt;br data-filtered=&quot;filtered&quot;/&gt;
十、事务介绍&lt;br data-filtered=&quot;filtered&quot;/&gt;
十一、Mysql数据库备份与恢复&lt;br data-filtered=&quot;filtered&quot;/&gt;
十二、Mysql分库分表&lt;br data-filtered=&quot;filtered&quot;/&gt;
十三、Mysql权限管理&lt;br data-filtered=&quot;filtered&quot;/&gt;
十四、Mysql数据库之阿里云&lt;br data-filtered=&quot;filtered&quot;/&gt;
十五、资料下载&lt;br data-filtered=&quot;filtered&quot;/&gt;
十六、参考文章&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;953&quot; data-height=&quot;789&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-dc36c908e69118ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/953/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-dc36c908e69118ad.png&quot; data-original-width=&quot;953&quot; data-original-height=&quot;789&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;132192&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;一、数据库简介&lt;/h2&gt;
&lt;h3&gt;1. 数据库是什么&lt;/h3&gt;
&lt;p&gt;  数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  数据是数据库中存储的基本对象，是按一定顺序排列组合的物理符号。数据有多种表现形式，可以是数字、文字、图像，甚至是音频或视频，它们都可以经过数字化后存入计算机。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  数据库是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  在日常生活中，人们可以直接用中文、英文等自然语言描述客观事物。在计算机中，则要抽象出对这些事物感兴趣的特征，并组成一个记录来描述。&lt;/p&gt;
&lt;h3&gt;2. 数据库在开发中的作用&lt;/h3&gt;
&lt;p&gt;  从数据库系统应用角度来看，数据库系统常见的运行与应用结构有：客户端/服务器结构、浏览器/服务器结构。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  在客户端/服务器（Client/Server，C/S）结构中，数据库的使用者（如 DBA、程序设计者）通过命令行客户端、图形化界面管理工具或应用程序等连接到数据库管理系统，可以通过数据库管理系统查询和处理存储在底层数据库中的各种数据。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  数据库使用者与命令行客户端、图形化界面管理工具或应用程序等直接交互，而不与数据库管理系统直接联系。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  在这种结构中，命令行客户端、图形化界面管理工具或应用程序等称为“客户端”或“前台”，主要完成与数据库使用者的交互任务；而数据库管理系统则称为“服务器”或“后台”，主要负责数据管理。这种结构经常被称为“C/S”结构。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  在客户端/服务器模式中，客户端和服务器可以同时工作在同一台计算机上，这种工作方式称为“单机方式”；也可以“网络方式”运行，即服务器被安装和部署在网络中某一台或多台主机上。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  对于客户端应用程序的开发，目前常用的语言工具主要有 Visual &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fcplus%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;C++&lt;/a&gt;、Delphi、.NET 框架、Visual Basic、&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fpython%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Python&lt;/a&gt; 等。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  数据库能有效存储数据，读取数据、查找数据更是方便，其实那些管理软件就是通过软件的界面向内部的数据库进行数据的增、删、改、查操作。&lt;/p&gt;
&lt;h3&gt;3.常见数据库比较&lt;/h3&gt;
&lt;p&gt;3.1 MySQL数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
定位&lt;br data-filtered=&quot;filtered&quot;/&gt;
开源、多平台、关系型数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
目前使用最广泛、流行度最高的的开源数据库。&lt;/p&gt;
&lt;p&gt;功能&lt;br data-filtered=&quot;filtered&quot;/&gt;
支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据，有插件式存储引擎，支持多种存储引擎格式&lt;/p&gt;
&lt;p&gt;部署&lt;br data-filtered=&quot;filtered&quot;/&gt;
用编译安装的方式，或者二进制包的方式，按照“安装软件-创建实例-库表用户初始化”，可以很快完成数据库部署&lt;/p&gt;
&lt;p&gt;使用&lt;br data-filtered=&quot;filtered&quot;/&gt;
使用标准的SQL语句进行数据库管理，简单SQL语句的并发和性能较好，对视图、存储过程、函数、触发器等支持的不是太好&lt;/p&gt;
&lt;p&gt;监控&lt;br data-filtered=&quot;filtered&quot;/&gt;
在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有比较多的开源监控工具来监控和记录数据库的状态，比如zabbix，nagios，cacti，lepus等&lt;/p&gt;
&lt;p&gt;备份&lt;br data-filtered=&quot;filtered&quot;/&gt;
逻辑备份 mysqldump/mysqldumper ，物理备份 用xtrabackup等工具进行备份；&lt;/p&gt;
&lt;p&gt;高可用&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL高可用有多种方案，官方有基础的master-slave主从复制，新版本的innodb cluster，第三方的有MHA等高可用方案；&lt;/p&gt;
&lt;p&gt;扩展&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL水平拆分，可以通过水平拆分proxy中间进行逻辑映射和拆分，扩大MySQL数据库的并发能力和吞吐量。&lt;/p&gt;
&lt;p&gt;适用场景&lt;br data-filtered=&quot;filtered&quot;/&gt;
默认的innodb存储引擎，支持高并发，简单的绝大部分OLTP场景；&lt;br data-filtered=&quot;filtered&quot;/&gt;
Tokudb存储引擎，使用高并发insert的场景；&lt;br data-filtered=&quot;filtered&quot;/&gt;
Inforbright存储引擎，可以进行列压缩和OLAP统计查询场景；&lt;/p&gt;
&lt;p&gt;选择注意&lt;br data-filtered=&quot;filtered&quot;/&gt;
使用MySQL进行OLTP业务时，需要注意数据量级，如果数据量级过大，需要进行水平拆分；&lt;br data-filtered=&quot;filtered&quot;/&gt;
如果有OLAP需求，可以结合其他架构综合考虑。&lt;/p&gt;
&lt;p&gt;3.2 SQL Server数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
定位&lt;br data-filtered=&quot;filtered&quot;/&gt;
商业、Windows平台、关系型数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
最早接触、与微软体系结合紧密的的商业数据库，属于“微软技术体系”&lt;/p&gt;
&lt;p&gt;功能&lt;br data-filtered=&quot;filtered&quot;/&gt;
支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据&lt;/p&gt;
&lt;p&gt;部署&lt;br data-filtered=&quot;filtered&quot;/&gt;
在Windows平台，用图形界面进行软件安装；&lt;/p&gt;
&lt;p&gt;使用&lt;br data-filtered=&quot;filtered&quot;/&gt;
在Windows平台，使用SQL Server Mangement Studio图形界面进行安装；&lt;/p&gt;
&lt;p&gt;监控&lt;br data-filtered=&quot;filtered&quot;/&gt;
一般通过Windows资源管理和SQL server图形工具进行系统和数据库性能显示；&lt;/p&gt;
&lt;p&gt;备份&lt;br data-filtered=&quot;filtered&quot;/&gt;
通常用第三方备份恢复软件进行备份恢复；&lt;/p&gt;
&lt;p&gt;高可用&lt;br data-filtered=&quot;filtered&quot;/&gt;
通过共享存储和双机热备的方式，可以实现SQL Server数据库的高可用；&lt;/p&gt;
&lt;p&gt;扩展&lt;br data-filtered=&quot;filtered&quot;/&gt;
SQL Server数据库集群采用共存存储的方式，通过硬件垂直升级来对数据库集群进行扩展；&lt;/p&gt;
&lt;p&gt;适用场景&lt;br data-filtered=&quot;filtered&quot;/&gt;
大多数OLTP场景（与微软体系配合）&lt;/p&gt;
&lt;p&gt;选择注意&lt;br data-filtered=&quot;filtered&quot;/&gt;
SQL Server与微软技术体系结合比较紧密，绝大多数工作，都是通过图形界面完成，对于习惯使用命令行的DBA可能会有不习惯；&lt;br data-filtered=&quot;filtered&quot;/&gt;
SQL server对双引号，大小写，元信息的管理和处理方式，与其他数据库很不相同，需要注意；&lt;br data-filtered=&quot;filtered&quot;/&gt;
使用SQL Server满足OLTP业务，会有比较好的效果，但对于大数据量的OLAP业务，最好还是选用专门的OLAP架构，不要在同一个SQL Server实例上混用OLTP和OLAP业务；&lt;br data-filtered=&quot;filtered&quot;/&gt;
SQL server属于商业软件，需要注意版权和licence授权费用；&lt;/p&gt;
&lt;p&gt;3.3 Oracle数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
定位&lt;br data-filtered=&quot;filtered&quot;/&gt;
商业、多平台、关系型数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
功能最强大、最复杂、市场占比最高的商业数据库&lt;/p&gt;
&lt;p&gt;功能&lt;br data-filtered=&quot;filtered&quot;/&gt;
支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据&lt;/p&gt;
&lt;p&gt;部署&lt;br data-filtered=&quot;filtered&quot;/&gt;
Oracle单实例数据库部署相对容易，但Oracle RAC集群环境，部署的步骤和依赖条件都比较多；&lt;/p&gt;
&lt;p&gt;使用&lt;br data-filtered=&quot;filtered&quot;/&gt;
通常使用命令行工具，进行各种数据库的管理，通常也可以用shell脚本和python脚本提高Oracle数据库管理效率；各种管理功能，都比较强大；&lt;/p&gt;
&lt;p&gt;监控&lt;br data-filtered=&quot;filtered&quot;/&gt;
Oracle官方有比较全面的监控工具，常用的第三方监控平台，如zabbix,cacti,lepus等都有对Oracle数据库的各项指标的完善监控；&lt;/p&gt;
&lt;p&gt;备份&lt;br data-filtered=&quot;filtered&quot;/&gt;
支持冷备份和热备份，可以用 exp/imp , expdp/impdp等进行逻辑备份和恢复，可以使用强大的RMAN工具进行专业的物理热备份和恢复；&lt;/p&gt;
&lt;p&gt;高可用&lt;br data-filtered=&quot;filtered&quot;/&gt;
Oracle数据库的高可用架构，可以用第三方双机热备软件，结合Oracle单实例实现；可以使用Oracle Dataguard，实现master和standby的备份；可以使用 Oracle RAC集群实现实例级别的高可用和负载均衡，使用ASM实现存储级别的高可用；&lt;/p&gt;
&lt;p&gt;扩展&lt;br data-filtered=&quot;filtered&quot;/&gt;
由于Oracle集群采用共享存储的方式，一般只能通过垂直硬件升级进行升级；&lt;/p&gt;
&lt;p&gt;适用场景&lt;br data-filtered=&quot;filtered&quot;/&gt;
绝大多数OLTP场景，部分OLAP&lt;/p&gt;
&lt;p&gt;选择注意&lt;br data-filtered=&quot;filtered&quot;/&gt;
Oracle从架构到运维，可以说是最难的数据库，学习和使用难度较高。&lt;/p&gt;
&lt;p&gt;3.4 Hbase数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
定位&lt;br data-filtered=&quot;filtered&quot;/&gt;
开源、Linux平台、列存储nosql数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
可用于海量数据存储、与Hadoop生态圈结合、定位于“大”的列存储nosql数据库&lt;/p&gt;
&lt;p&gt;功能&lt;br data-filtered=&quot;filtered&quot;/&gt;
命令执行速度非常看，读写性能可达10万/秒；数据结构是key-value类似字典的功能，可以键过期-缓存，发布订阅-消息系统，简单的事物功能；&lt;/p&gt;
&lt;p&gt;部署&lt;br data-filtered=&quot;filtered&quot;/&gt;
相对其他数据库，hbase的部署比较复杂，依赖Hadoop，zookeeper等组件，Hbase集群包括一个mater节点，多个regionServer，zookeeper管理所有regionServer，需要依次部署Hadoop、zookeeper之后，再部署HBASE集群；&lt;/p&gt;
&lt;p&gt;使用&lt;br data-filtered=&quot;filtered&quot;/&gt;
用redis-cli客户端连接，一般用简单的 set ,get,del 进行数据管理； 在单实例redis的基础上，进行可以数据持久化，主从复制，高可用和分布式等功能；&lt;/p&gt;
&lt;p&gt;监控&lt;br data-filtered=&quot;filtered&quot;/&gt;
在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有开源监控工具来监控和记录数据库的状态，比如cachecloud；&lt;/p&gt;
&lt;p&gt;备份&lt;br data-filtered=&quot;filtered&quot;/&gt;
Hbase一般用作海量数据的仓库，本身通过多层副本来保证数据安全性，不用进行专门的备份&lt;/p&gt;
&lt;p&gt;高可用&lt;br data-filtered=&quot;filtered&quot;/&gt;
HBASE集群基于Hadoop，需要依次部署Hadoop单机模式、集群模式、HA模式，通过Hadoop HA实现高可用；&lt;/p&gt;
&lt;p&gt;扩展&lt;br data-filtered=&quot;filtered&quot;/&gt;
HBASE以集群形式，依次是单机模式，伪分布模式，完全分布模式，底层基于HDFS，zookeeper可以很好地进行扩展；&lt;/p&gt;
&lt;p&gt;适用场景&lt;br data-filtered=&quot;filtered&quot;/&gt;
两大用途：&lt;br data-filtered=&quot;filtered&quot;/&gt;
用于简单数据写入和海量、结构简单数据查询的业务场景；&lt;br data-filtered=&quot;filtered&quot;/&gt;
用于成为其他数据库备份和下沉的数据库；&lt;/p&gt;
&lt;p&gt;选择注意&lt;br data-filtered=&quot;filtered&quot;/&gt;
Hbase不适合的场景：对数据分析需求高，需要能够用sql或者简单的MapReduce实现分析需求的业务场景，不适合用Hbase；&lt;br data-filtered=&quot;filtered&quot;/&gt;
单表数据量，不超过千万时，使用Hbase，体现不出Hbase的优势，而且会比较慢，不适合用Hbase。&lt;br data-filtered=&quot;filtered&quot;/&gt;
通过对上面数据库“七种”武器的描述，也可以看到目前常用数据库的使用脉络和选择顺序，对应一个业务，可以优先选择最流行的开源数据库——MySQL；如果出于稳定和商业版考虑，可以选择Oracle数据库，或者SQL Server数据库（与Windows体系结合）；如果想用开源，有想要有足够的功能来应对各种场景，可以使用 postgresql数据库。这四种数据库，都是关系型数据库，可以很好地满足大多数业务场景，解决通用性问题。&lt;br data-filtered=&quot;filtered&quot;/&gt;
对于一些特殊性问题，尤其是想要在扩展性方面有比较高的要求，可以考虑nosql数据库。Mongodb数据库，介于关系型数据库和非关系型数据库之间，兼具两者的特点，是非常流行的文档型nosql数据库；redis定位于内存型键值nosql数据库；hbase是海量文件存储的列式nosql数据库。根据合适的业务场景，选择适合的nosql数据库，可以对某一类，或某几类业务问题有很好的解决，可以作为关系型数据库的一种补充。&lt;br data-filtered=&quot;filtered&quot;/&gt;
换个角度，MySQL，Oracle，SQL Server，Postgresql，mongodb这五种数据库，也是DB-Engines排行榜上最流行的排名前五的五种数据库，从使用量和受欢迎程度，也可以看出这些数据库使用的广泛性。&lt;/p&gt;
&lt;h3&gt;4. 数据库常见功能&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1851&quot; data-height=&quot;6317&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-7ebe9d6f825737fc.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-7ebe9d6f825737fc.gif&quot; data-original-width=&quot;1851&quot; data-original-height=&quot;6317&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;399873&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;二、Mysql数据库简介&lt;/h2&gt;
&lt;h3&gt;1. MySQL的优势&lt;/h3&gt;
&lt;p&gt;  MySQL 使用的 SQL 语言是用于访问数据库的最常用的标准化语言。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  由于 MySQL 数据库体积小、速度快、总体拥有成本低、开放源代码，其有着广泛的应用，一般中小型网站的开发都选择 MySQL 作为网站数据库。由于其社区版的性能卓越，因此搭配 PHP 和 Apache 服务器可组成良好的开发环境。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  MySQL 数据库管理系统具有以下系统特性：&lt;br data-filtered=&quot;filtered&quot;/&gt;
（1） 使用 C 和 &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fcplus%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;C++&lt;/a&gt; 编写，并使用多种编译器进行测试，保证源代码的可移植性。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）支持 AIX、FreeBSD、HP-UX、&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Flinux_tutorial%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Linux&lt;/a&gt;、Mac OS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris、Windows 等多种操作系统。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）为多种编程语言提供了 API。这些编程语言包括 C、C++、&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fpython%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Python&lt;/a&gt;、&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fjava%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Java&lt;/a&gt;、Perl、PHP、Eiffel、Ruby 和 Tcl 等。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（4）支持多线程，充分利用 CPU 资源。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（5）优化的 SQL 查询算法，有效地提高查询速度。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（6）既能够作为一个单独的应用程序应用在客户端服务器网络环境中，也能够作为一个库而嵌入其他的软件中。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（7）提供多语言支持，常见的编码如中文的 GB 2312、BIG 5，日文的 Shift_JIS 等都可以用作数据表名和数据列名。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（8）提供 TCP/IP、ODBC 和 JDBC 等多种数据库连接途径。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（9）提供用于管理、检查、优化数据库操作的管理工具。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（10）支持大型的数据库。可以处理拥有上千万条记录的大型数据库。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（11）支持多种存储引擎。&lt;/p&gt;
&lt;h3&gt;2. MySQL的版本以及版本号&lt;/h3&gt;
&lt;p&gt;针对不同的用户，&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 分为两个版本：&lt;br data-filtered=&quot;filtered&quot;/&gt;
（1）MySQL Community Server（社区版）：该版本完全免费，但是官方不提供技术支持。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）MySQL Enterprise Server（企业版）：该版本能够以很高的性价比为企业提供数据仓库应用，支持 ACID 事物处理，提供完整的提交、回滚、崩溃恢复和行级锁定功能，但是该版本需要付费使用，官方提供电话技术支持。&lt;br data-filtered=&quot;filtered&quot;/&gt;
温馨提示：MySQL Cluster 主要用于架设群服务器，需要在社区服务或企业版的基础上使用。&lt;/p&gt;
&lt;p&gt;MySQL 的命名机制由 3 个数字和 1 个后缀组成，例如 mysql-5.7.20：&lt;br data-filtered=&quot;filtered&quot;/&gt;
第 1 个数字“5”是主版本号，用于描述文件的格式，所有版本 5 的发行版都有相同的文件夹格式。&lt;br data-filtered=&quot;filtered&quot;/&gt;
第 2 个数字“7”是发行级别，主版本号和发行级别组合在一起便构成了发行序列号。&lt;br data-filtered=&quot;filtered&quot;/&gt;
第 3 个数字“20”是在此发行系列的版本号，随每次新发行的版本递增。通常选择已经发行的最新版本。&lt;/p&gt;
&lt;p&gt;在 MySQL 开发过程中，同时存在多个发布系列，每个发布系列的成熟度处在不同阶段。&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.7 是最新开发的稳定（GA）发布系列，是将执行新功能的系列，目前已经可以正常使用。&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.6 是比较稳定的（GA）发布系列，只针对漏洞修复重新发布，不增加会影响稳定性的新功能。&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.1 是一个稳定的（产品质量）发布系列，只针对严重漏洞修复和安全修复重新发布，不增加影响该系列稳定性的重要功能。&lt;br data-filtered=&quot;filtered&quot;/&gt;
对于 MySQL 4.1 等低于 5.0 的老版本，官方将不再提供支持&lt;/p&gt;
&lt;h3&gt;3. MySQL 5.7的新特性&lt;/h3&gt;
&lt;p&gt;与 &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 5.6 相比，MySQL 5.7 具有以下几个方面的新功能。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（1）随机 root 密码&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.7 数据库初始化完成后，会自动生成一个 root@localhost 用户，root 用户的密码不为空，而是随机产生一个密码。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）自定义 test 数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.7 默认安装完成后没有 test 数据库。用户可以自行创建 test 数据库并对其进行权限控制。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）默认 SSL 加密&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.7 采用了更加简单的 SSL 安全访问机制，默认连接使用 SSL 的加密方式。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（4）密码过期策略&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.7 支持用户设置密码过期策略，要求用户在一定时间过后必须修改密码。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（5）用户锁&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.7 为管理员提供了暂时禁用某个用户的功能，使被锁定的用户无法访问和使用数据库。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（6）全面支持JSON&lt;br data-filtered=&quot;filtered&quot;/&gt;
MySQL 5.7在服务器端提供了一组便于操作 JSON 的函数。存储的方法是将 JSON 编码成 BLOB 后再由存储引擎进行处理。这样，MySQL 就同时拥有了关系型数据库和非关系型数据库的优点，并且可以提供完整的事务支持。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（7）支持两类生成列（generated column）&lt;br data-filtered=&quot;filtered&quot;/&gt;
生成列是通过数据库中的其他列计算得到的一列。当为生成列创建索引时，可以便捷地加快查询速度。MySQL 5.7 支持虚拟生成列和存储生成列。虚拟生成列仅将数据保存在表的元数据中，作为缺省的生成列类型；存储生成列则是将数据永久保存在磁盘上，需要更多的磁盘空间。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（8）引入系统库（sys schema）&lt;br data-filtered=&quot;filtered&quot;/&gt;
系统库中包含一系列视图、函数和存储过程，通过多线程、多进程、组合事务提交和基于行的优化方式将复制功能提高 5 倍以上，用户向外扩充其跨商品系统的工作负载时，得以大幅提升复制的效能和效率。&lt;br data-filtered=&quot;filtered&quot;/&gt;
与 &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 5.6 相比，MySQL 5.7 具有以下几个方面的新功能。&lt;/p&gt;
&lt;h2&gt;三、Mysql安装与服务启动（Windows版本）&lt;/h2&gt;
&lt;h3&gt;1. 下载&lt;/h3&gt;
&lt;p&gt;用户可以根据自身的操作系统类型，从 &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 官方下载页面免费下载相应的服务器安装包。本书以 MySQL 5.7.20 为例介绍其在 Windows 10 操作系统下的安装和配置过程。&lt;/p&gt;
&lt;p&gt;用户下载 Windows 图形化安装包的步骤如下。&lt;/p&gt;
&lt;p&gt;步骤 1)：打开 MySQL 官方网站（&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.mysql.com%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.mysql.com&lt;/a&gt;），单击 DOWNLOAD，进入 MySQL 产品的下载界面，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;907&quot; data-height=&quot;405&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-e44aad6a309612e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/907/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-e44aad6a309612e0.png&quot; data-original-width=&quot;907&quot; data-original-height=&quot;405&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;153412&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;步骤 2)：在 MySQL 产品分类中选择 Community 菜单，在下载列表中选择 MySQL Community Server，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;907&quot; data-height=&quot;456&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-8b41266fc6b6fc26.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/907/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-8b41266fc6b6fc26.gif&quot; data-original-width=&quot;907&quot; data-original-height=&quot;456&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;60259&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;步骤3)：在下载页面中，操作系统选择 Microsoft Windows，下载的安装文件为 mysql-installer-community-5.7.20.0.msi，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;907&quot; data-height=&quot;322&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-83496667d4b4c776.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/907/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-83496667d4b4c776.gif&quot; data-original-width=&quot;907&quot; data-original-height=&quot;322&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;48527&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2. 安装教程&lt;/h3&gt;
&lt;p&gt;Windows 平台下提供两种安装 MySQL 的方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL 二进制分发版（.msi 安装文件）。&lt;/li&gt;
&lt;li&gt;免安装版（.zip 压缩文件）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用户使用图形化安装包安装 MySQL 的步骤如下：&lt;/p&gt;
&lt;p&gt;步骤 1)：双击下载的 MySQL 安装文件，进入 MySQL 安装界面，首先进入“License Agreement（用户许可证协议）”窗口，选中“I accept the license terms（我接受系统协议）”复选框，单击“Next（下一步）”按钮，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;956&quot; data-height=&quot;714&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-7fb5c38cb47e1866.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/956/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-7fb5c38cb47e1866.gif&quot; data-original-width=&quot;956&quot; data-original-height=&quot;714&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;134286&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;进入MySQL安装界面并接受系统协议&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;步骤 2)：进入“Choosing a Setup Type（安装类型选择）”窗口，根据右侧的安装类型描述文件选择适合自己的安装类型，这里选择默认的安装类型，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;951&quot; data-height=&quot;714&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-481ca9ffc8b599e1.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-481ca9ffc8b599e1.gif&quot; data-original-width=&quot;951&quot; data-original-height=&quot;714&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;113903&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;选择默认的安装类型&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：Developer Default：默认安装类型；Server only：仅作为服务；Client only：仅作为客户端；Full：完全安装；Custom：自定义安装类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;步骤 3)：根据所选择的安装类型安装 Windows 系统框架（framework），单击 Execute 按钮，安装程序会自动完成框架的安装，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;964&quot; data-height=&quot;717&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-f306df63005a992c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/964/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-f306df63005a992c.gif&quot; data-original-width=&quot;964&quot; data-original-height=&quot;717&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;114569&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;检查并生成安装所需要的框架列表&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当弹出安装程序窗口时，勾选“我同意许可条款和条件”复选框，然后单击“安装”按钮，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;574&quot; data-height=&quot;335&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-084f141c8c6257ad.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/574/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-084f141c8c6257ad.gif&quot; data-original-width=&quot;574&quot; data-original-height=&quot;335&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;58388&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;同意安装框架的许可条件&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;弹出“设置成功”的界面，表示该框架已经安装完成，单击“关闭”按钮即可。所有的框架安装均可参考本操作，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;572&quot; data-height=&quot;335&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-f43082598e931454.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/572/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-f43082598e931454.gif&quot; data-original-width=&quot;572&quot; data-original-height=&quot;335&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;30129&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;安装框架成功&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;步骤 4)：所需框架均安装成功后，单击 “Next（下一步）”按钮，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;951&quot; data-height=&quot;714&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-55628f5e0bddec86.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-55628f5e0bddec86.gif&quot; data-original-width=&quot;951&quot; data-original-height=&quot;714&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;113077&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;所有框架安装完成&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;步骤 5)：进入安装确认窗口，单击 “Execute（执行）”按钮，开始 MySQL 各个组件的安装，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;964&quot; data-height=&quot;710&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-bb439639564dcc96.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/964/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-bb439639564dcc96.gif&quot; data-original-width=&quot;964&quot; data-original-height=&quot;710&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;110414&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;准备安装MySQL各个组件&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;步骤 6)：开始安装 MySQL 文件，安装完成后在 “Status（状态）”列表下显示 “Complete（安装成功）”，如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1030&quot; data-height=&quot;769&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-cd2e35da796a69de.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-cd2e35da796a69de.gif&quot; data-original-width=&quot;1030&quot; data-original-height=&quot;769&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;118567&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;MySQL各个组件安装成功&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;3. 判断是否安装成功&lt;/h3&gt;
&lt;p&gt;3.1 启动与关闭服务&lt;br data-filtered=&quot;filtered&quot;/&gt;
net start mysql为启动服务，net stop mysql为关闭命令&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;551&quot; data-height=&quot;359&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-909a3b8eb5a5e25a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-909a3b8eb5a5e25a.png&quot; data-original-width=&quot;551&quot; data-original-height=&quot;359&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;88014&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.2 登录数据库&lt;br data-filtered=&quot;filtered&quot;/&gt;
cmd进入数据库的bin文件夹中&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;994&quot; data-height=&quot;103&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-a00832164694e63f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/994/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-a00832164694e63f.png&quot; data-original-width=&quot;994&quot; data-original-height=&quot;103&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;10346&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;输入mysql -u root -p命令，再输入登录密码，出现以下结果代表登录成功&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;736&quot; data-height=&quot;287&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-198044eac3d7ceb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/736/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-198044eac3d7ceb9.png&quot; data-original-width=&quot;736&quot; data-original-height=&quot;287&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;16514&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.3 查看数据库名称&lt;br data-filtered=&quot;filtered&quot;/&gt;
登录完成后，输入show databases&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;416&quot; data-height=&quot;272&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-a3aa41974710b561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/416/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-a3aa41974710b561.png&quot; data-original-width=&quot;416&quot; data-original-height=&quot;272&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;7641&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;四、Mysql图形化工具&lt;/h2&gt;
&lt;p&gt;（1）Navicat（重点推荐）&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;625&quot; data-height=&quot;342&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-a2d4db86a9e0391c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-a2d4db86a9e0391c.png&quot; data-original-width=&quot;625&quot; data-original-height=&quot;342&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;114686&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Navicat是MySQL和MariaDB数据库管理与开发理想的解决方案。它可同时在一个应用程序上连接MySQL和MariaDB数据库。这种兼容前端为数据库提供了一个直观而强大的图形界面管理、开发和维护功能，为初级MySQL和MariaDB开发人员和专业开发人员都提供了一组全面的开发工具。&lt;/p&gt;
&lt;p&gt;（2）Induction&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;625&quot; data-height=&quot;342&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-476f9e8260e620ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-476f9e8260e620ed.png&quot; data-original-width=&quot;625&quot; data-original-height=&quot;342&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;248325&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Induction是一款用于理解数据关系的开源管理工具，它可用来探索行/列，运行查询和数据可视化等方面。该工具支持多种数据库，包括PostgreSQL，MySQL，SQLite，Redis以及MongoDB。此外，Induction还可以通过编写添加其他新的适配器。&lt;/p&gt;
&lt;p&gt;（3）SqlWave&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;625&quot; data-height=&quot;342&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-56992a1118051722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-56992a1118051722.png&quot; data-original-width=&quot;625&quot; data-original-height=&quot;342&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;117623&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;SQLWave是一种简单、快速且易用的MySQL客户端。用户可通过该工具轻松地连接到远程主机。SqlWave支持所有MySQL的最新版本，包括它用来管理数据库结构的所有最新功能，如工作表、视图、存储过程、函数、事件、外键和触发器等。&lt;/p&gt;
&lt;h2&gt;五、Mysql存储引擎精讲&lt;/h2&gt;
&lt;h3&gt;1. 存储引擎分类&lt;/h3&gt;
&lt;p&gt;  数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。&lt;/p&gt;
&lt;h3&gt;2. MySQL 5.7 支持的存储引擎&lt;/h3&gt;
&lt;p&gt;  MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;226&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-24b44ebaf965618f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-24b44ebaf965618f.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;226&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;123344&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;3. MySQL 默认存储引擎&lt;/h3&gt;
&lt;p&gt;InnoDB 是系统的默认引擎，支持可靠的事务处理。&lt;br data-filtered=&quot;filtered&quot;/&gt;
使用下面的语句可以修改数据库临时的默认存储引擎&lt;br data-filtered=&quot;filtered&quot;/&gt;
SET default_storage_engine=&amp;lt; 存储引擎名 &amp;gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;
例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;305&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-ec744584750f9190.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-ec744584750f9190.gif&quot; data-original-width=&quot;800&quot; data-original-height=&quot;305&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;68493&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。&lt;/p&gt;
&lt;h2&gt;六、Mysql数据类型介绍&lt;/h2&gt;
&lt;h3&gt;1. 基本介绍&lt;/h3&gt;
&lt;p&gt;在 MySQL 中常见的数据类型如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整数类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型 FLOAT 和 DOUBLE，定点数类型 DECIMAL。&lt;/li&gt;
&lt;li&gt;日期/时间类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。&lt;/li&gt;
&lt;li&gt;字符串类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。&lt;/li&gt;
&lt;li&gt;二进制类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;2. 整数类型&lt;/h3&gt;
&lt;p&gt;  &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的数值类型。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;292&quot; data-height=&quot;217&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-ba724fab9e43339e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/292/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-ba724fab9e43339e.png&quot; data-original-width=&quot;292&quot; data-original-height=&quot;217&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;15679&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。&lt;/p&gt;
&lt;p&gt;根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;661&quot; data-height=&quot;212&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-b8f51ba066ab5aee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/661/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-b8f51ba066ab5aee.png&quot; data-original-width=&quot;661&quot; data-original-height=&quot;212&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;20180&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。&lt;/p&gt;
&lt;h3&gt;3. 小数类型&lt;/h3&gt;
&lt;p&gt;  &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 中使用浮点数和定点数来表示小数。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  浮点类型和定点类型都可以用&lt;code&gt;(M, D)&lt;/code&gt;来表示，其中&lt;code&gt;M&lt;/code&gt;称为精度，表示总共的位数；&lt;code&gt;D&lt;/code&gt;称为标度，表示小数的位数。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  下表中列出了 MySQL 中的小数类型和存储需求。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;420&quot; data-height=&quot;150&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-a98ac7d5eacc757b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/420/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-a98ac7d5eacc757b.png&quot; data-original-width=&quot;420&quot; data-original-height=&quot;150&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;13071&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;FLOAT 类型的取值范围如下：&lt;br data-filtered=&quot;filtered&quot;/&gt;
有符号的取值范围：-3.402823466E+38～-1.175494351E-38。&lt;br data-filtered=&quot;filtered&quot;/&gt;
无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。&lt;/p&gt;
&lt;p&gt;DOUBLE 类型的取值范围如下：&lt;br data-filtered=&quot;filtered&quot;/&gt;
有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。&lt;br data-filtered=&quot;filtered&quot;/&gt;
无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。&lt;br data-filtered=&quot;filtered&quot;/&gt;
FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。&lt;/p&gt;
&lt;p&gt;浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。&lt;/p&gt;
&lt;p&gt;最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。&lt;/p&gt;
&lt;h3&gt;4. 日期和时间类型&lt;/h3&gt;
&lt;p&gt;  &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  下表中列出了 MySQL 中的日期与时间类型。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;737&quot; data-height=&quot;211&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-5c17b71f6dcf057e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/737/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-5c17b71f6dcf057e.png&quot; data-original-width=&quot;737&quot; data-original-height=&quot;211&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;24076&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;YEAR 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示：&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 '1901'～'2155'。输入格式为 'YYYY' 或者 YYYY，例如，输入 '2010' 或 2010，插入数据库的值均为 2010。&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 2 位字符串格式表示的 YEAR，范围为 '00' 到 '99'。'00'～'69' 和 '70'～'99' 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。'0' 与 '00' 的作用相同。插入超过取值范围的值将被转换为 2000。&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 '0' 或 '00'，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。&lt;/p&gt;
&lt;p&gt;TIME 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。&lt;/p&gt;
&lt;p&gt;TIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。&lt;/p&gt;
&lt;p&gt;可以使用各种格式指定 TIME 值，如下所示。&lt;br data-filtered=&quot;filtered&quot;/&gt;
'D HH：MM：SS' 格式的字符串。还可以使用这些“非严格”的语法：'HH：MM：SS'、'HH：MM'、'D HH' 或 'SS'。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。&lt;br data-filtered=&quot;filtered&quot;/&gt;
'HHMMSS' 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，'101112' 被理解为'10：11：12'，但是 '106112' 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：为 TIME 列分配简写值时应注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 '1112' 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 '12' 和 12 被解释为00：00：12。相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，'11：12' 表示 11：12：00，而不是 00：11：12。&lt;/p&gt;
&lt;p&gt;DATE 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 'YYYY-MM-DD'，其中 YYYY 表示年，MM 表示月，DD 表示日。&lt;/p&gt;
&lt;p&gt;在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示：&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 'YYYY-MM-DD' 或者 'YYYYMMDD' 字符中格式表示的日期，取值范围为 '1000-01-01'～'9999-12-3'。例如，输入 '2015-12-31' 或者 '20151231'，插入数据库的日期为2015-12-31。&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 'YY-MM-DD' 或者 'YYMMDD' 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：'00～69' 范围的年值转换为 '20002069'，'7099' 范围的年值转换为 '1970～1999'。例如，输入 '15-12-31'，插入数据库的日期为 2015-12-31；输入 '991231'，插入数据库的日期为 1999-12-31。&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。&lt;br data-filtered=&quot;filtered&quot;/&gt;
使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：MySQL 允许“不严格”语法：任何标点符号都可以用作日期部分之间的间隔符。例如，'98-11-31'、'98.11.31'、'98/11/31'和'98@11@31' 是等价的，这些值也可以正确地插入数据库。&lt;/p&gt;
&lt;p&gt;DATETIME 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 'YYYY-MM-DD HH：MM：SS'，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。&lt;/p&gt;
&lt;p&gt;在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 'YYYY-MM-DD HH：MM：SS' 或者 'YYYYMMDDHHMMSS' 字符串格式表示的日期，取值范围为 '1000-01-01 00：00：00'～'9999-12-3 23：59：59'。例如，输入 '2014-12-31 05：05：05' 或者 '20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 'YY-MM-DD HH：MM：SS' 或者 'YYMMDDHHMMSS' 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，'00～79' 范围的年值转换为 '2000～2079'，'80～99' 范围的年值转换为 '1980～1999'。例如，输入 '14-12-31 05：05：05'，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。&lt;br data-filtered=&quot;filtered&quot;/&gt;
以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：MySQL 允许“不严格”语法：任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，'98-12-31 11：30：45'、'98.12.31 11+30+35'、'98/12/31 11&lt;em&gt;30&lt;/em&gt;45' 和 '98@12@31 113045' 是等价的，这些值都可以正确地插入数据库。&lt;/p&gt;
&lt;p&gt;TIMESTAMP 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 '1970-01-01 00：00：01'UTC～'2038-01-19 03：14：07'UTC。在插入数据时，要保证在合法的取值范围内。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。&lt;/p&gt;
&lt;p&gt;TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是：&lt;br data-filtered=&quot;filtered&quot;/&gt;
DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；&lt;br data-filtered=&quot;filtered&quot;/&gt;
而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 '00：00：00'，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。&lt;/p&gt;
&lt;h3&gt;5. 字符串类型&lt;/h3&gt;
&lt;p&gt;  字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  下表中列出了 MySQL 中的字符串数据类型，括号中的&lt;code&gt;M&lt;/code&gt;表示可以为其指定长度。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;857&quot; data-height=&quot;315&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-a0690bd038b95d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/857/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-a0690bd038b95d99.png&quot; data-original-width=&quot;857&quot; data-original-height=&quot;315&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;43733&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。&lt;/p&gt;
&lt;p&gt;例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。&lt;/p&gt;
&lt;p&gt;CHAR 和 VARCHAR 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。&lt;/p&gt;
&lt;p&gt;例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。&lt;/p&gt;
&lt;p&gt;VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。&lt;/p&gt;
&lt;p&gt;例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。&lt;/p&gt;
&lt;p&gt;【实例】下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。&lt;/p&gt;
&lt;p&gt;插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求&lt;br data-filtered=&quot;filtered&quot;/&gt;
' ' ' ' 4字节 '' 1字节&lt;br data-filtered=&quot;filtered&quot;/&gt;
'ab' 'ab ' 4字节 'ab' 3字节&lt;br data-filtered=&quot;filtered&quot;/&gt;
'abc' 'abc ' 4字节 'abc' 4字节&lt;br data-filtered=&quot;filtered&quot;/&gt;
'abcd' 'abcd' 4字节 'abcd' 5字节&lt;br data-filtered=&quot;filtered&quot;/&gt;
'abcdef' 'abcd' 4字节 'abcd' 5字节&lt;br data-filtered=&quot;filtered&quot;/&gt;
对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。&lt;br data-filtered=&quot;filtered&quot;/&gt;
TEXT 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。&lt;/p&gt;
&lt;p&gt;TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。&lt;br data-filtered=&quot;filtered&quot;/&gt;
TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。&lt;br data-filtered=&quot;filtered&quot;/&gt;
TEXT 表示长度为 65535（216-1）字符的 TEXT 列。&lt;br data-filtered=&quot;filtered&quot;/&gt;
MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。&lt;br data-filtered=&quot;filtered&quot;/&gt;
LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。&lt;/p&gt;
&lt;p&gt;ENUM 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：&lt;br data-filtered=&quot;filtered&quot;/&gt;
&amp;lt;字段名&amp;gt; ENUM( '值1', '值1', …, '值n' )&lt;br data-filtered=&quot;filtered&quot;/&gt;
字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。&lt;/p&gt;
&lt;p&gt;ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。&lt;/p&gt;
&lt;p&gt;ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。&lt;/p&gt;
&lt;p&gt;例如，定义 ENUM 类型的列（'first'，'second'，'third'），该列可以取的值和每个值的索引如下表所示。&lt;/p&gt;
&lt;p&gt;值 索引&lt;br data-filtered=&quot;filtered&quot;/&gt;
NULL NULL&lt;br data-filtered=&quot;filtered&quot;/&gt;
'' 0&lt;br data-filtered=&quot;filtered&quot;/&gt;
’first 1&lt;br data-filtered=&quot;filtered&quot;/&gt;
second 2&lt;br data-filtered=&quot;filtered&quot;/&gt;
third 3&lt;br data-filtered=&quot;filtered&quot;/&gt;
ENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。&lt;/p&gt;
&lt;p&gt;SET 类型&lt;br data-filtered=&quot;filtered&quot;/&gt;
SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：&lt;br data-filtered=&quot;filtered&quot;/&gt;
SET( '值1', '值2', …, '值n' )&lt;br data-filtered=&quot;filtered&quot;/&gt;
与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。&lt;/p&gt;
&lt;p&gt;但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。&lt;br data-filtered=&quot;filtered&quot;/&gt;
提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。&lt;/p&gt;
&lt;h2&gt;七、Mysql主要专业名称介绍&lt;/h2&gt;
&lt;h3&gt;1. 主键&lt;/h3&gt;
&lt;p&gt;1.1 什么是主键&lt;br data-filtered=&quot;filtered&quot;/&gt;
“主键（PRIMARY KEY）”的完整称呼是“主键约束”。&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。&lt;/p&gt;
&lt;p&gt;1.2 选取设置主键约束的字段&lt;br data-filtered=&quot;filtered&quot;/&gt;
主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。主键应该遵守下面的规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个表只能定义一个主键。&lt;/li&gt;
&lt;li&gt;主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是唯一性原则。&lt;/li&gt;
&lt;li&gt;一个列名只能在复合主键列表中出现一次。&lt;/li&gt;
&lt;li&gt;复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.3 创建主键&lt;br data-filtered=&quot;filtered&quot;/&gt;
语法规则：&amp;lt;字段名&amp;gt; &amp;lt;数据类型&amp;gt; PRIMARY KEY [默认值]&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;829&quot; data-height=&quot;470&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-11ccfaca4083a897.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/829/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-11ccfaca4083a897.png&quot; data-original-width=&quot;829&quot; data-original-height=&quot;470&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;24636&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2. 外键约束&lt;/h3&gt;
&lt;p&gt;2.1 什么是外键约束&lt;br data-filtered=&quot;filtered&quot;/&gt;
  &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。&lt;/li&gt;
&lt;li&gt;从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.2 选取设置 MySQL 外键约束的字段&lt;br data-filtered=&quot;filtered&quot;/&gt;
定义一个外键时，需要遵守下列规则：&lt;br data-filtered=&quot;filtered&quot;/&gt;
（1）父表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则父表与子表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）必须为父表定义主键。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（4）在父表的表名后面指定列名或列名的组合。这个列或列的组合必须是父表的主键或候选键。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（5）外键中列的数目必须和父表的主键中列的数目相同。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（6）外键中列的数据类型必须和父表主键中对应列的数据类型相同。&lt;/p&gt;
&lt;p&gt;2.3 在创建表时设置外键约束&lt;br data-filtered=&quot;filtered&quot;/&gt;
在数据表中创建外键使用 FOREIGN KEY 关键字，具体的语法规则如下：&lt;br data-filtered=&quot;filtered&quot;/&gt;
[CONSTRAINT &amp;lt;外键名&amp;gt;] FOREIGN KEY 字段名 [，字段名2，…]&lt;br data-filtered=&quot;filtered&quot;/&gt;
REFERENCES &amp;lt;主表名&amp;gt; 主键列1 [，主键列2，…]&lt;/p&gt;
&lt;p&gt;其中：外键名为定义的外键约束的名称，一个表中不能有相同名称的外键；字段名表示子表需要添加外健约束的字段列；主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或者列组合。&lt;/p&gt;
&lt;h3&gt;3. 唯一约束&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt;唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。&lt;/p&gt;
&lt;h3&gt;4. 默认值&lt;/h3&gt;
&lt;p&gt;4.1 什么是默认值&lt;br data-filtered=&quot;filtered&quot;/&gt;
  “默认值（Default）”的完整称呼是“默认值约束（Default Constraint）”。&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 默认值约束用来指定某列的默认值。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  例如女性同学较多，性别就可以默认为“女”。如果插入一条新的记录时没有为这个字段赋值，那么系统会自动为这个字段赋值为“女”。&lt;/p&gt;
&lt;p&gt;4.2 在创建表时设置默认值约束&lt;br data-filtered=&quot;filtered&quot;/&gt;
创建表时可以使用 DEFAULT 关键字设置默认值约束，具体的语法规则如下：&lt;br data-filtered=&quot;filtered&quot;/&gt;
&amp;lt;字段名&amp;gt; &amp;lt;数据类型&amp;gt; DEFAULT &amp;lt;默认值&amp;gt;;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;975&quot; data-height=&quot;439&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-d39e0afdc8ecae7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/975/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-d39e0afdc8ecae7a.png&quot; data-original-width=&quot;975&quot; data-original-height=&quot;439&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;34789&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;5. 非空约束&lt;/h3&gt;
&lt;p&gt;5.1 什么是非空约束&lt;br data-filtered=&quot;filtered&quot;/&gt;
  &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fc.biancheng.net%2Fmysql%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; 非空约束（NOT NULL）可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。&lt;/p&gt;
&lt;p&gt;5.2 在创建表时设置非空约束&lt;br data-filtered=&quot;filtered&quot;/&gt;
创建表时可以使用 NOT NULL 关键字设置非空约束，具体的语法规则如下：&lt;br data-filtered=&quot;filtered&quot;/&gt;
&amp;lt;字段名&amp;gt; &amp;lt;数据类型&amp;gt; NOT NULL;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;807&quot; data-height=&quot;413&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-ae3bc2a137021dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/807/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-ae3bc2a137021dbc.png&quot; data-original-width=&quot;807&quot; data-original-height=&quot;413&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;22848&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;6. 触发器&lt;/h3&gt;
&lt;p&gt;触发器（TRIGGER）是由事件来触发某个操作。这些事件包括INSERT语句、UPDATE语句和DELETE语句。当数据库系统执行这些事件时，会激活促发其执行相应的操作。&lt;/p&gt;
&lt;h3&gt;7. DML&lt;/h3&gt;
&lt;p&gt;DML（data manipulation language）数据操纵语言：&lt;br data-filtered=&quot;filtered&quot;/&gt;
　　　　就是我们最经常用到的 SELECT、UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;SELECT 列名称 FROM 表名称
UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
&lt;span class=&quot;hljs-function&quot;&gt;INSERT INTO &lt;span class=&quot;hljs-title&quot;&gt;table_name &lt;span class=&quot;hljs-params&quot;&gt;(列&lt;span class=&quot;hljs-number&quot;&gt;1, 列&lt;span class=&quot;hljs-number&quot;&gt;2,...) &lt;span class=&quot;hljs-title&quot;&gt;VALUES &lt;span class=&quot;hljs-params&quot;&gt;(值&lt;span class=&quot;hljs-number&quot;&gt;1, 值&lt;span class=&quot;hljs-number&quot;&gt;2,....)
DELETE FROM 表名称 WHERE 列名称 = 值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;8. DDL&lt;/h3&gt;
&lt;p&gt;DDL（data definition language）数据库定义语言：其实就是我们在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上&lt;/p&gt;
&lt;pre class=&quot;hljs undefined&quot;&gt;
&lt;code&gt;CREATE TABLE 表名称
(
列名称1 数据类型,
列名称2 数据类型,
列名称3 数据类型,
....
)

ALTER TABLE table_name
ALTER COLUMN column_name datatype

DROP TABLE 表名称
DROP DATABASE 数据库名称
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;9. DCL&lt;/h3&gt;
&lt;p&gt;DCL（Data Control Language）数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。在公司呢一般情况下我们用到的是DDL、DML这两种。&lt;/p&gt;
&lt;h2&gt;八、Mysql常见sql语句&lt;/h2&gt;
&lt;h3&gt;1. select语句&lt;/h3&gt;
&lt;p&gt;请在资料下载中进行学习&lt;/p&gt;
&lt;h3&gt;2. 函数&lt;/h3&gt;
&lt;p&gt;请在资料下载中进行学习&lt;/p&gt;
&lt;h3&gt;3. 多表查询&lt;/h3&gt;
&lt;p&gt;请在资料下载中进行学习&lt;/p&gt;
&lt;h3&gt;4. 表的内连与外连‘&lt;/h3&gt;
&lt;p&gt;请在资料下载中进行学习’&lt;/p&gt;
&lt;h2&gt;九、Mysql设计与语句优化&lt;/h2&gt;
&lt;h3&gt;1. 数据库创建优化&lt;/h3&gt;
&lt;p&gt;请在资料下载中进行学习&lt;/p&gt;
&lt;h3&gt;2. sql语句优化&lt;/h3&gt;
&lt;p&gt;请在资料下载中进行学习&lt;/p&gt;
&lt;h2&gt;十、事务介绍&lt;/h2&gt;
&lt;h3&gt;1. 事务概述&lt;/h3&gt;
&lt;p&gt;事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。&lt;/p&gt;
&lt;p&gt;严格上来说，事务必须同时满足4个特性，即通常所说事务的ACID特性。虽然理论上定义了严格的事务要求，但是数据库厂商出于各种目的并没有严格满足事务的ACID标准。例如，对于MYSQL的NDB Cluster引擎，虽然支持事务，但是不满足D的要求，即持久性的要求。对于Oracle数据库来说，其默认的事务隔离级别为READ COMMITTED，不满足I的要求，即隔离性的要求。对于InnoDB存储引擎而言，默认的事务隔离级别是READ REPRATABLE，完全遵循和满足事务的ACID特性。&lt;/p&gt;
&lt;p&gt;A（atomicity），原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功。事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到事务前的状态。&lt;/p&gt;
&lt;p&gt;C（consistency），一致性。一致性是指事务将数据库从一种状态转变为另一种状态。在事务的开始之前和事务结束以后，数据库的完整性约束没有被破坏。&lt;/p&gt;
&lt;p&gt;I（isolation），隔离性。隔离性还有其他的称呼，如并发控制、可串行化、锁。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能互相分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。数据库系统中提供了一种粒度锁的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。（如果是全表锁，事务之间基本就无法实现并发，但是如果只锁住表中处理的行，可以提高事务的并发度）&lt;/p&gt;
&lt;p&gt;D（durability），持久性。事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。需要注意的是，持久性只能从事务本身的角度来保证结果的永久性，如事务提交后，所有的变化都是永久的，即使当数据库由于崩溃而需要恢复时，也能保证恢复后提交的数据都不会丢失。&lt;/p&gt;
&lt;p&gt;事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。&lt;/p&gt;
&lt;h3&gt;2. 事务分类&lt;/h3&gt;
&lt;p&gt;（1）扁平事务，最简单，使用最频繁的事务。在扁平事务中，所有的操作都处于一个层次，其有BEGIN WORK开始，有COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么全部执行，要么全部回滚。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）带有保存点的扁平事务，除了扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能有些事务在执行过程中出现的错误并不会对有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）链事务可视为保存点模式的一个变种。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（4）嵌套事务是一个层次结构框架。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（5）分布式事务&lt;/p&gt;
&lt;h3&gt;3. 事务控制语句&lt;/h3&gt;
&lt;p&gt;在MYSQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行COMMIT操作。因此要显示的开启一个事务必须使用命令BEGIN和START TRANSACTION，或者执行命令SET AUTOCOMMIT = 0，以禁用当前会话的自动提交。事务控制语句如下：&lt;/p&gt;
&lt;p&gt;START TRANSACTION | BEGIN：显示的开启一个事务。在存储过程中，MYSQL数据库的分析器会自动将BEGIN识别为BEGIN...END，因此在存储过程中只能使用START TRANSACTION语句来开启一个事务。&lt;br data-filtered=&quot;filtered&quot;/&gt;
COMMIT：要想使用这个语句的最简形式，只需发出COMMIT。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的。COMMIT和COMMIT WORK语句基本上是一致的，都是用来提交事务。不同的是COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE的。如果是CHAIN方式，那么事务就变成了链事务。用户可以通过参数completion_type来进行控制，默认该参数是0，表示没有任何操作。在这种设置下，COMMIT和COMMIT WORK是完全等价的。当参数值为1时，COMMIT WORK等价于COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务。当参数值为1时，COMMIT WORK等价于COMMIT AND RELEASE。当提交事务后会自动断开与服务器连接。&lt;br data-filtered=&quot;filtered&quot;/&gt;
ROLLBACK：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。&lt;br data-filtered=&quot;filtered&quot;/&gt;
SAVEPOINT identifiter：SAVEPOINT允许用户在事务中创建一个保存点，一个事务可以有很多个保存点。&lt;br data-filtered=&quot;filtered&quot;/&gt;
RELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这语句时，会抛出一个异常。&lt;br data-filtered=&quot;filtered&quot;/&gt;
ROLLBACK to [SAVEPOINT] identifier：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚到此标记点之前的任何工作。注意：虽然有ROLLBACK，但是它并没有真正的结束一个事务，因此即使执行了ROLLBACK TO SAVEPOINT，之后也需要显示的运行COMMIT或ROLLBACK命令。&lt;br data-filtered=&quot;filtered&quot;/&gt;
SET TRANSACTION：这个语句用来设置事务的隔离级别。InnoDB存储引擎提供的事务隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。&lt;/p&gt;
&lt;h3&gt;4. 事务的隔离级别&lt;/h3&gt;
&lt;p&gt;ANSI SQL标准定义的四个隔离级别为：&lt;/p&gt;
&lt;p&gt;READ UNCOMMITTED（未提交读），事务中的修改，即使没有提交，在其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。&lt;br data-filtered=&quot;filtered&quot;/&gt;
READ COMMITTED（提交读），一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行相同的查询，可能会得到不一样的结果。因为在这2次读之间可能有其他事务更改这个数据，每次读到的数据都是已经提交的。&lt;br data-filtered=&quot;filtered&quot;/&gt;
REPEATABLE READ（可重复读），解决了脏读，也保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重读读隔离级别还是无法解决另外一个幻读的问题，指的是当某个事务在读取某个范围内的记录时，另外一个事务也在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。&lt;br data-filtered=&quot;filtered&quot;/&gt;
SERIALIZABLE（可串行化），它通过强制事务串行执行，避免了前面说的幻读的问题。&lt;br data-filtered=&quot;filtered&quot;/&gt;
1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。&lt;/p&gt;
&lt;p&gt;2、不可重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。&lt;/p&gt;
&lt;p&gt;3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。&lt;/p&gt;
&lt;p&gt;InnoDB采用MVCC来支持高并发，并实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影的插入。&lt;/p&gt;
&lt;p&gt;隔离级别越低，事务请求的锁越少或保持锁的时间就越短。所以很多数据库系统默认的事务隔离级别是READ COMMITTED。质疑SERIALIZABLE隔离级别的性能，但是InnoDB存储引擎认为两者的开销是一样的，所以默认隔离级别使用REPEATABLE READ。&lt;/p&gt;
&lt;p&gt;用命令设置当前会话或全局会话的事务隔离级别。&lt;/p&gt;
&lt;p&gt;SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL&lt;br data-filtered=&quot;filtered&quot;/&gt;
{&lt;br data-filtered=&quot;filtered&quot;/&gt;
READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&lt;br data-filtered=&quot;filtered&quot;/&gt;
}&lt;br data-filtered=&quot;filtered&quot;/&gt;
如果想启动时就设置事务的默认隔离级别，修改MYSQL的配置文件，在[mysqld]中添加如下行：&lt;/p&gt;
&lt;p&gt;[mysqld]&lt;br data-filtered=&quot;filtered&quot;/&gt;
transaction-isolation = READ-COMMITTED&lt;/p&gt;
&lt;h2&gt;十一、Mysql数据库备份与恢复&lt;/h2&gt;
&lt;h3&gt;1. 数据库备份&lt;/h3&gt;
&lt;p&gt;数据库备份是指通过导出数据或者复制表文件的方式来制作数据库的副本。当数据库出现故障或遭到破坏时，将备份的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。&lt;/p&gt;
&lt;p&gt;可以使用 SELECT INTO OUTFILE 语句把表数据导出到一个文本文件中进行备份。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：这种方法只能导出或导入数据的内容，而不包括表的结构。若表的结构文件损坏，则必须先设法恢复原来表的结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;【实例】将数据库 test_db 的表 tb_students_info 的全部数据备份到 C 盘的数据备份目录下文件名为 file.txt 的文件中，要求每个字段用逗号分开，并且字符用双引号标注，每行以问号结束。&lt;/p&gt;
&lt;p&gt;输入的SQL语句和执行结果如下所示。&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;mysql&amp;gt; SELECT * FROM test_db.tb_students_info
    -&amp;gt; INTO OUTFILE &lt;span class=&quot;hljs-string&quot;&gt;'C:/ProgramData/MySQL/MySQL Server 5.7/Uploads/file.txt'
    -&amp;gt; FIELDS TERMINATED BY &lt;span class=&quot;hljs-string&quot;&gt;'&quot;'
    -&amp;gt; LINES TERMINATED BY &lt;span class=&quot;hljs-string&quot;&gt;'?';
Query OK, 10 rows affected (0.06 sec)&amp;lt;/pre&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用记事本查看 MySQL 备份文件夹下的 file.txt 文件，内容如下图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;500&quot; data-height=&quot;135&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-5fa1c9b6a2b456b1.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-5fa1c9b6a2b456b1.gif&quot; data-original-width=&quot;500&quot; data-original-height=&quot;135&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;19136&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2. MySQL数据库恢复&lt;/h3&gt;
&lt;p&gt;数据库恢复是指以备份为基础，与备份相对应的系统维护和管理操作。&lt;/p&gt;
&lt;p&gt;系统进行恢复操作时，先执行一些系统安全性的检查，包括检查所要恢复的数据库是否存在、数据库是否变化及数据库文件是否兼容等，然后根据所采用的数据库备份类型采取相应的恢复措施。&lt;/p&gt;
&lt;p&gt;数据库恢复机制设计的两个关键问题是：第一，如何建立冗余数据；第二，如何利用这些冗余数据实施数据库恢复。&lt;/p&gt;
&lt;p&gt;建立冗余数据最常用的技术是数据转储和登录日志文件。通常在一个数据库系统中，这两种方法是一起使用的。&lt;/p&gt;
&lt;p&gt;数据转储是 DBA 定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的版本成为后备副本或后援副本。&lt;/p&gt;
&lt;p&gt;可使用 LOAD DATA…INFILE 语句来恢复先前备份的数据。&lt;/p&gt;
&lt;p&gt;【实例】将之前导出的数据备份文件 file.txt 导入数据库 test_db 的表 tb_students_copy 中，其中 tb_students_copy 的表结构和 tb_students_info 相同。&lt;/p&gt;
&lt;p&gt;首先创建表 tb_students_copy，输入的 SQL 语句和执行结果如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;CREATE &lt;span class=&quot;hljs-selector-tag&quot;&gt;TABLE &lt;span class=&quot;hljs-selector-tag&quot;&gt;tb_students_copy
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;-&amp;gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;LIKE &lt;span class=&quot;hljs-selector-tag&quot;&gt;tb_students_info;
&lt;span class=&quot;hljs-selector-tag&quot;&gt;Query &lt;span class=&quot;hljs-selector-tag&quot;&gt;OK, 0 &lt;span class=&quot;hljs-selector-tag&quot;&gt;rows &lt;span class=&quot;hljs-selector-tag&quot;&gt;affected (0&lt;span class=&quot;hljs-selector-class&quot;&gt;.52 &lt;span class=&quot;hljs-selector-tag&quot;&gt;sec)
&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;SELECT * &lt;span class=&quot;hljs-selector-tag&quot;&gt;FROM &lt;span class=&quot;hljs-selector-tag&quot;&gt;tb_students_copy;
&lt;span class=&quot;hljs-selector-tag&quot;&gt;Empty &lt;span class=&quot;hljs-selector-tag&quot;&gt;set (0&lt;span class=&quot;hljs-selector-class&quot;&gt;.00 &lt;span class=&quot;hljs-selector-tag&quot;&gt;sec)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入数据与查询表 tb_students_copy 的过程如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;mysql&amp;gt; LOAD DATA INFILE &lt;span class=&quot;hljs-string&quot;&gt;'C:/ProgramData/[MySQL](http://c.biancheng.net/mysql/)/MySQL Server 5.7/
Uploads/file.txt'
    -&amp;gt; INTO TABLE test_db.tb_students_copy
    -&amp;gt; FIELDS TERMINATED BY &lt;span class=&quot;hljs-string&quot;&gt;','
    -&amp;gt; OPTIONALLY ENCLOSED BY &lt;span class=&quot;hljs-string&quot;&gt;'&quot;'
    -&amp;gt; LINES TERMINATED BY &lt;span class=&quot;hljs-string&quot;&gt;'?';
Query OK, 10 rows affected (0.14 sec)
Records: 10  Deleted: 0  Skipped: 0  Warnings: 0
mysql&amp;gt; SELECT * FROM test_db.tb_students_copy;
+----+--------+---------+------+------+--------+------------+
| id | name   | dept_id | age  | sex  | height | login_date |
+----+--------+---------+------+------+--------+------------+
|  1 | Dany   |       1 |   25 | F    |    160 | 2015-09-10 |
|  2 | Green  |       3 |   23 | F    |    158 | 2016-10-22 |
|  3 | Henry  |       2 |   23 | M    |    185 | 2015-05-31 |
|  4 | Jane   |       1 |   22 | F    |    162 | 2016-12-20 |
|  5 | Jim    |       1 |   24 | M    |    175 | 2016-01-15 |
|  6 | John   |       2 |   21 | M    |    172 | 2015-11-11 |
|  7 | Lily   |       6 |   22 | F    |    165 | 2016-02-26 |
|  8 | Susan  |       4 |   23 | F    |    170 | 2015-10-01 |
|  9 | Thomas |       3 |   22 | M    |    178 | 2016-06-07 |
| 10 | Tom    |       4 |   23 | M    |    165 | 2016-08-05 |
+----+--------+---------+------+------+--------+------------+
10 rows &lt;span class=&quot;hljs-keyword&quot;&gt;in &lt;span class=&quot;hljs-built_in&quot;&gt;set (0.00 sec)&amp;lt;/pre&amp;gt;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;十二、Mysql分库分表&lt;/h2&gt;
&lt;h3&gt;1. 分库分表原则&lt;/h3&gt;
&lt;p&gt;  关系型数据库本身比较容易成为系统性能瓶颈，单机存储容量、连接数、处理能力等都很有限，数据库本身的“有状态性”导致了它并不像Web和应用服务器那么容易扩展。在互联网行业海量数据和高并发访问的考验下，聪明的技术人员提出了分库分表技术（有些地方也称为Sharding、分片）。同时，流行的分布式系统中间件（例如MongoDB、ElasticSearch等）均自身友好支持Sharding，其原理和思想都是大同小异的。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  目前针对海量数据的优化，其分库分表是MySQL永远的话题，一般情况下认为MySQL是个简单的数据库，在数据量大到一定程度之后处理查询的效率降低，如果需要继续保持高性能运转的话，必须分库或者分表了。关于数据量达到多少大是个极限这个事儿，本文先不讨论，研究源码的同学已经证实MySQL或者Innodb内部的锁粒度太大的问题大大限制了MySQL提供QPS的能力或者处理大规模数据的能力。在这点上，一般的使用者只好坐等官方不断推出的优化版本了。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  在一般运维的角度来看，我们什么情况下需要考虑分库分表？&lt;br data-filtered=&quot;filtered&quot;/&gt;
  首先说明，这里所说的分库分表是指把数据库数据的物理拆分到多个实例或者多台机器上去，而不是类似分区表的原地切分。&lt;/p&gt;
&lt;p&gt;1.1 能不分就不分&lt;br data-filtered=&quot;filtered&quot;/&gt;
  MySQL 是关系数据库，数据库表之间的关系从一定的角度上映射了业务逻辑。任何分库分表的行为都会在某种程度上提升业务逻辑的复杂度，数据库除了承载数据的存储和访问外，协助业务更好的实现需求和逻辑也是其重要工作之一。分库分表会带来数据的合并，查询或者更新条件的分离，事务的分离等等多种后果，业务实现的复杂程度往往会翻倍或者指数级上升。所以，在分库分表之前，不要为分而分，去做其他力所能及的事情吧，例如升级硬件，升级，升级网络，升级数据库版本，读写分离，负载均衡等等。所有分库分表的前提是，这些你已经尽力了。&lt;/p&gt;
&lt;p&gt;1.2 数据量太大，正常的运维影响正常业务访问&lt;br data-filtered=&quot;filtered&quot;/&gt;
这里说的运维，例如：&lt;br data-filtered=&quot;filtered&quot;/&gt;
（1）对数据库的备份。如果单表或者单个实例太大，在做备份的时候需要大量的磁盘IO或者网络IO资源。例如1T的数据，网络传输占用50MB的时候，需要20000秒才能传输完毕，在此整个过程中的维护风险都是高于平时的。我们在Qunar的做法是给所有的数据库机器添加第二块网卡，用来做备份，或者SST，Group Communication等等各种内部的数据传输。1T的数据的备份，也会占用大量的磁盘IO，如果是SSD还好，当然这里忽略某些厂商的产品在集中IO的时候会出一些BUG的问题。如果是普通的物理磁盘，则在不限流的情况下去执行xtrabackup，该实例基本不可用。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）对数据表的修改。如果某个表过大，对此表做DDL的时候，MySQL会锁住全表，这个时间可能很长，在这段时间业务不能访问此表，影响甚大。解决的办法有类似腾讯游戏DBA自己改造的可以在线秒改表，不过他们目前也只是能添加字段而已，对别的DDL还是无效；或者使用pt-online-schema-change，当然在使用过程中，它需要建立触发器和影子表，同时也需要很长很长的时间，在此操作过程中的所有时间，都可以看做是风险时间。把数据表切分，总量减小，有助于改善这种风险。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）整个表热点，数据访问和更新频繁，经常有锁等待，你又没有能力去修改源码，降低锁的粒度，那么只会把其中的数据物理拆开，用空间换时间，变相降低访问压力。&lt;/p&gt;
&lt;p&gt;1.3 某些数据表出现了无穷增长&lt;br data-filtered=&quot;filtered&quot;/&gt;
  例子很好举，各种的评论，消息，日志记录。这个增长不是跟人口成比例的，而是不可控的，例如微博的feed的广播，我发一条消息，会扩散给很多很多人。虽然主体可能只存一份，但不排除一些索引或者路由有这种存储需求。这个时候，增加存储，提升机器配置已经苍白无力了，水平切分是最佳实践。拆分的标准很多，按用户的，按时间的，按用途的，不在一一举例。&lt;/p&gt;
&lt;p&gt;1.4 安全性和可用性的考虑&lt;br data-filtered=&quot;filtered&quot;/&gt;
  这个很容易理解，鸡蛋不要放在一个篮子里，我不希望我的数据库出问题，但我希望在出问题的时候不要影响到100%的用户，这个影响的比例越少越好，那么，水平切分可以解决这个问题，把用户，库存，订单等等本来同统一的资源切分掉，每个小的数据库实例承担一小部分业务，这样整体的可用性就会提升。这对Qunar这样的业务还是比较合适的，人与人之间，某些库存与库存之间，关联不太大，可以做一些这样的切分。&lt;/p&gt;
&lt;p&gt;1.5 业务耦合性考虑&lt;br data-filtered=&quot;filtered&quot;/&gt;
  这个跟上面有点类似，主要是站在业务的层面上，我们的火车票业务和烤羊腿业务是完全无关的业务，虽然每个业务的数据量可能不太大，放在一个MySQL实例中完全没问题，但是很可能烤羊腿业务的DBA 或者开发人员水平很差，动不动给你出一些幺蛾子，直接把数据库搞挂。这个时候，火车票业务的人员虽然技术很优秀，工作也很努力，照样被老板打屁股。解决的办法很简单:惹不起，躲得起。&lt;/p&gt;
&lt;h3&gt;2. 分库分表方案&lt;/h3&gt;
&lt;p&gt;2.1 垂直拆分（垂直分表）&lt;br data-filtered=&quot;filtered&quot;/&gt;
垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;410&quot; data-height=&quot;197&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-0dd3e74ec22a728d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/410/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-0dd3e74ec22a728d.png&quot; data-original-width=&quot;410&quot; data-original-height=&quot;197&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8940&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.2 垂直拆分（垂直分库）&lt;br data-filtered=&quot;filtered&quot;/&gt;
垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;275&quot; data-height=&quot;283&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-c4b4d64347e2e149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/275/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-c4b4d64347e2e149.png&quot; data-original-width=&quot;275&quot; data-original-height=&quot;283&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;46084&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;小结：&lt;br data-filtered=&quot;filtered&quot;/&gt;
系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。&lt;br data-filtered=&quot;filtered&quot;/&gt;
众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。&lt;br data-filtered=&quot;filtered&quot;/&gt;
然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。&lt;br data-filtered=&quot;filtered&quot;/&gt;
优势：降低高并发情况下，对于表的锁定。&lt;br data-filtered=&quot;filtered&quot;/&gt;
不足：对于单表来说，随着数据库的记录增多，读写压力将进一步增大。&lt;/p&gt;
&lt;p&gt;2.3 水平拆分（水平分表）&lt;br data-filtered=&quot;filtered&quot;/&gt;
水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。如下图所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;476&quot; data-height=&quot;236&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-48bf2c3fe04031e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/476/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-48bf2c3fe04031e1.png&quot; data-original-width=&quot;476&quot; data-original-height=&quot;236&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;12272&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果单表的IO压力大，可以考虑用水平分割，其原理就是通过hash算法，将一张表分为N多页，并通过一个新的表（总表），记录着每个页的的位置。假如一个门户网站，它的数据库表已经达到了1000万条记录，那么此时如果通过select去查询，必定会效率低下（不做索引的前提下）。为了降低单表的读写IO压力，通过水平分割，将这个表分成10个页，同时生成一个总表，记录各个页的信息，那么假如我查询一条id=100的记录，它不再需要全表扫描，而是通过总表找到该记录在哪个对应的页上，然后再去相应的页做检索，这样就降低了IO压力。&lt;/p&gt;
&lt;p&gt;当下分表有静态分表和动态分表两种：&lt;br data-filtered=&quot;filtered&quot;/&gt;
静态分表：事先估算出表能达到的量，然后根据每一个表需要存多少数据直接算出需要创建表的数量。如：1亿数据每一个表100W条数据那就要建100张表，然后通过一定的hash算法计算每一条数据存放在那张表。其实就有点像是使用partition table一样。静态分表有一个毙命就是当分的那么多表还不满足时，需要再扩展难度和成本就会很高。&lt;br data-filtered=&quot;filtered&quot;/&gt;
动态分表：同样也是对大数据量的表进行拆分，他可以避免静态分表带来的后遗症。当然也需要在设计上多一些东西（这往往是我们能接受的）。&lt;br data-filtered=&quot;filtered&quot;/&gt;
某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）&lt;/p&gt;
&lt;h3&gt;3. 分库分表难点&lt;/h3&gt;
&lt;p&gt;3.1 跨库join的问题&lt;br data-filtered=&quot;filtered&quot;/&gt;
在拆分之前，系统中很多列表和详情页所需的数据是可以通过sql join来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，下面笔者将结合以往的实际经验，总结几种常见的解决思路，并分析其适用场景。&lt;br data-filtered=&quot;filtered&quot;/&gt;
跨库Join的几种解决思路：&lt;br data-filtered=&quot;filtered&quot;/&gt;
全局表&lt;br data-filtered=&quot;filtered&quot;/&gt;
所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。&lt;br data-filtered=&quot;filtered&quot;/&gt;
字段冗余&lt;br data-filtered=&quot;filtered&quot;/&gt;
这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免join查询。&lt;br data-filtered=&quot;filtered&quot;/&gt;
举个电商业务中很简单的场景：&lt;br data-filtered=&quot;filtered&quot;/&gt;
“订单表”中保存“卖家Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。&lt;br data-filtered=&quot;filtered&quot;/&gt;
字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证。当然，也需要结合实际业务场景来看一致性的要求。就像上面例子，如果卖家修改了Name之后，是否需要在订单信息中同步更新呢？&lt;br data-filtered=&quot;filtered&quot;/&gt;
数据同步&lt;br data-filtered=&quot;filtered&quot;/&gt;
定时A库中的tab_a表和B库中tbl_b有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。笔者曾经在项目中是通过ETL工具来实施的。&lt;br data-filtered=&quot;filtered&quot;/&gt;
系统层组装&lt;br data-filtered=&quot;filtered&quot;/&gt;
在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。具体情况通常会比较复杂。&lt;/p&gt;
&lt;p&gt;3.2 跨库事务（分布式事务）的问题&lt;br data-filtered=&quot;filtered&quot;/&gt;
按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。想要了解分布式事务，就需要了解“XA接口”和“两阶段提交”。值得提到的是，MySQL5.5x和5.6x中的xa支持是存在问题的，会导致主从数据不一致。直到5.7x版本中才得到修复。Java应用程序可以采用Atomikos框架来实现XA事务（J2EE中JTA）。感兴趣的读者可以自行参考《分布式事务一致性解决方案》，链接地址：&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fsolution-of-distributed-system-transaction-consistency&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&amp;lt;u&amp;gt;http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency&amp;lt;/u&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据系统架构和公司实际情况来，如果你们的系统还是个简单的单体应用，并且没有什么访问量和数据量，那就别着急折腾“垂直分库”了，否则没有任何收益，也很难有好结果。&lt;br data-filtered=&quot;filtered&quot;/&gt;
切记，“过度设计”和“过早优化”是很多架构师和技术人员常犯的毛病。&lt;/p&gt;
&lt;h2&gt;十三、Mysql权限管理&lt;/h2&gt;
&lt;h3&gt;1. MySQL权限简介&lt;/h3&gt;
&lt;p&gt;  关于mysql的权限简单的理解就是mysql允许你做你全力以内的事情，不可以越界。比如只允许你执行select操作，那么你就不能执行update操作。只允许你从某台机器上连接mysql，那么你就不能从除那台机器以外的其他机器连接mysql。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  那么Mysql的权限是如何实现的呢？这就要说到mysql的两阶段验证，下面详细介绍：第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、某个IP、某个IP段、以及任何地方等，只允许你从配置的指定地方登陆。第二阶段：如果你能连接，Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。比如你要更新某个表、或者查询某个表，Mysql会查看你对哪个表或者某个列是否有权限。再比如，你要运行某个存储过程，Mysql会检查你对存储过程是否有执行权限等。&lt;/p&gt;
&lt;h3&gt;2. Mysql权限种类&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;583&quot; data-height=&quot;602&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-abdf6b7911f161e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-abdf6b7911f161e4.png&quot; data-original-width=&quot;583&quot; data-original-height=&quot;602&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;22130&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;526&quot; data-height=&quot;830&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-7d6fc88f6cc9efb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/526/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-7d6fc88f6cc9efb5.png&quot; data-original-width=&quot;526&quot; data-original-height=&quot;830&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;30867&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;523&quot; data-height=&quot;205&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-6543fc34beeb7765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/523/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-6543fc34beeb7765.png&quot; data-original-width=&quot;523&quot; data-original-height=&quot;205&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8426&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;534&quot; data-height=&quot;343&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-0444101ebdb651ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/534/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-0444101ebdb651ed.png&quot; data-original-width=&quot;534&quot; data-original-height=&quot;343&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;14880&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;3. MySQL权限经验原则&lt;/h3&gt;
&lt;p&gt;权限控制主要是出于安全因素，因此需要遵循一下几个经验原则：&lt;br data-filtered=&quot;filtered&quot;/&gt;
（1）只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）初始化数据库的时候删除没有密码的用户。安装完数据库的时候会自动创建一些用户，这些用户默认没有密码。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（4）为每个用户设置满足密码复杂度的密码。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（5）定期清理不需要的用户。回收权限或者删除用户。&lt;/p&gt;
&lt;h2&gt;十四、Mysql数据库之阿里云&lt;/h2&gt;
&lt;h3&gt;1. 简介&lt;/h3&gt;
&lt;p&gt;  经过上面的学习，大家已经对mysql数据库的知识有了很深的了解，我们也知道，一个数据库在实际生产环境中，会面临许多的问题，比如Sql语句审计、sql读写分离、sql备份与恢复、数据库的权限管理、数据库的高可用等等，对于创业公司来讲，数据库是非常重要的，但是花费了很多人力物力去满足这个事情，那么还不如直接使用成熟的第三方平台，比如阿里云的mysql数据库产品。&lt;/p&gt;
&lt;h3&gt;2. 阿里云数据库产品功能&lt;/h3&gt;
&lt;p&gt;2.1 数据库创建&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1831&quot; data-height=&quot;130&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-97a267cf1ca1c8a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-97a267cf1ca1c8a3.png&quot; data-original-width=&quot;1831&quot; data-original-height=&quot;130&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;25314&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.2 连接管理与读写分离&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1866&quot; data-height=&quot;206&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-4e9183939245c2a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-4e9183939245c2a3.png&quot; data-original-width=&quot;1866&quot; data-original-height=&quot;206&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;32795&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;845&quot; data-height=&quot;231&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-9aeabe5249528cad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/845/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-9aeabe5249528cad.png&quot; data-original-width=&quot;845&quot; data-original-height=&quot;231&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;29421&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.3 监控与报警&lt;/p&gt;
&lt;p&gt;我们可以在线监控到CPU、内存、磁盘、IOPS、网络流量等的使用情况，并设置报警规则&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1854&quot; data-height=&quot;751&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-abaa3a711ff34a20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-abaa3a711ff34a20.png&quot; data-original-width=&quot;1854&quot; data-original-height=&quot;751&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;99383&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.4 白名单&lt;/p&gt;
&lt;p&gt;我们可以设置允许连接数据库的IP白名单，以保障数据库连接安全&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1894&quot; data-height=&quot;182&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-13fc083a9e63e947.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-13fc083a9e63e947.png&quot; data-original-width=&quot;1894&quot; data-original-height=&quot;182&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;36525&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.5 服务可用性&lt;br data-filtered=&quot;filtered&quot;/&gt;
阿里云的数据库可包含高可用，主备切换、主从备份等&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1682&quot; data-height=&quot;556&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-d3603dd5faa56bfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-d3603dd5faa56bfa.png&quot; data-original-width=&quot;1682&quot; data-original-height=&quot;556&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;56128&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.6 日志管理&lt;br data-filtered=&quot;filtered&quot;/&gt;
日志管理包括订阅同步、错误日志、慢日志分析、主备切换日志&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1049&quot; data-height=&quot;137&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-b30ce84a5283ea37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-b30ce84a5283ea37.png&quot; data-original-width=&quot;1049&quot; data-original-height=&quot;137&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;10508&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.7 SQL洞察&lt;br data-filtered=&quot;filtered&quot;/&gt;
对sql语句的操作进行记录，包括操作的数据库名、数据库语句、操作时间、客户端IP等信息&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1654&quot; data-height=&quot;179&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-2eedc63a3c8df9b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-2eedc63a3c8df9b8.png&quot; data-original-width=&quot;1654&quot; data-original-height=&quot;179&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;16604&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.8 性能优化&lt;br data-filtered=&quot;filtered&quot;/&gt;
阿里云提供诊断报告、资源分析、SQL分析等服务&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1449&quot; data-height=&quot;488&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-0db6accae49c58bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-0db6accae49c58bc.png&quot; data-original-width=&quot;1449&quot; data-original-height=&quot;488&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;37317&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.9 备份恢复&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1703&quot; data-height=&quot;182&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-25a33fd9763ceea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-25a33fd9763ceea1.png&quot; data-original-width=&quot;1703&quot; data-original-height=&quot;182&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;22419&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;十五、资料下载&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1yvDw2ptCQ4K4x9IhebNo6g&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1yvDw2ptCQ4K4x9IhebNo6g&lt;/a&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;
提取码：4aoo&lt;/p&gt;
&lt;h2&gt;十六、参考文章&lt;/h2&gt;

</description>
<pubDate>Sat, 18 May 2019 04:33:00 +0000</pubDate>
<dc:creator>故事爱人</dc:creator>
<og:description>文章大纲 一、数据库简介二、Mysql数据库简介三、Mysql安装与服务启动（Windows版本）四、Mysql图形化工具五、Mysql存储引擎精讲六、Mysql数据类型介绍七、Mysql主要专业名称</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WUXIAOCHANG/p/10885361.html</dc:identifier>
</item>
<item>
<title>【问题总结】万万没想到，竟然栽在了List手里 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/10885211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/10885211.html</guid>
<description>&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;昨天同事开发的时候遇到了一个奇怪的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/18/5cdf7e9f2047e23793.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Guava做缓存，往里面存一个List，为了方便描述，称它为列表A，在另一个地方取出来，再跟列表B中的元素进行差集处理，简单来说，就像是下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ArrayListTest {
    // 方便起见，这里用HashMap来做缓存
    private Map&amp;lt;String, List&amp;lt;Long&amp;gt;&amp;gt; cache = new HashMap&amp;lt;&amp;gt;();
    
    private void save(){
        List&amp;lt;Long&amp;gt; listA = createListA();
        cache.put(&quot;listA&quot;, listA);
    }
    
    private void get(){
        List&amp;lt;Long&amp;gt; listB = createListB();
        List&amp;lt;Long&amp;gt; listA = cache.get(&quot;listA&quot;);
        listA.removeAll(listB);
    }
    
    private List&amp;lt;Long&amp;gt; createListA(){
        ···
    }

    private List&amp;lt;Long&amp;gt; createListB(){
        ···
    }

    public static void main(String[] args){
        ArrayListTest test = new ArrayListTest();
        test.save();
        test.get();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先调用save方法，然后调用get方法，然后就抛出了异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/18/5cdf7ec98fddd17705.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
    at java.util.AbstractList.remove(AbstractList.java:161)
    at java.util.AbstractList$Itr.remove(AbstractList.java:374)
    at java.util.AbstractCollection.removeAll(AbstractCollection.java:376)
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题探索&quot;&gt;问题探索&lt;/h2&gt;
&lt;p&gt;究竟是人性的泯灭还是道德的沦丧，一个小小的List竟然也玩不转了，面对突如其来的打击，我跟同事都开始反思，复制粘贴一时爽，debug火葬场。&lt;/p&gt;
&lt;p&gt;但作为一名优秀的程序猿，怎么能被这点困难所难倒呢？于是开始了问题排查之旅。&lt;/p&gt;
&lt;p&gt;先来验证一下自己对ArrayList是否有什么误解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testArrayList() {
    List&amp;lt;Long&amp;gt; listA = new ArrayList&amp;lt;&amp;gt;();
    listA.add(1L);
    listA.add(2L);
    List&amp;lt;Long&amp;gt; listB = new ArrayList&amp;lt;&amp;gt;();
    listB.add(2L);
    listB.add(3L);
    listA.removeAll(listB);
    System.out.println(JSON.toJSONString(listA));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嗯，看来并没有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/18/5cdf7f0e86fbc84596.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再回过头看看，抛出的异常是 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 异常，而且是在 &lt;code&gt;AbstractList&lt;/code&gt; 里抛出的，于是打开了 &lt;code&gt;AbstractList&lt;/code&gt;的源码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E remove(int index) {
    throw new UnsupportedOperationException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AbstractList&lt;/code&gt; 类对remove方法的默认实现就是直接抛出一个异常，所以如果子类并没有覆盖该方法，就会出现上面的问题。&lt;/p&gt;
&lt;p&gt;那么问题应该就出在列表A的创建方式上。&lt;/p&gt;
&lt;p&gt;结果一找，发现列表A是通过 &lt;code&gt;Arrays.asList()&lt;/code&gt; 创建的，再跟进代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; asList(T... a) {
    return new ArrayList&amp;lt;&amp;gt;(a);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感觉好像也没哪里不对，这里也是创建一个 &lt;code&gt;ArrayList&lt;/code&gt; ，讲道理的话，应该没问题才对，不过等等，&lt;code&gt;ArrayList&lt;/code&gt; 好像没有能传入可变长参数的构造函数吧，于是朝着这个&lt;code&gt;ArrayList&lt;/code&gt;小手一点，终于发现了问题所在。&lt;/p&gt;
&lt;p&gt;原来通过 &lt;code&gt;Arrays.asList()&lt;/code&gt; 创建的 &lt;code&gt;List&lt;/code&gt; 对象是通过实例化 &lt;code&gt;Arrays&lt;/code&gt; 内部类 &lt;code&gt;ArrayList&lt;/code&gt; 来创建的，所以这个 &lt;code&gt;ArrayList&lt;/code&gt; 并不是我们常用的那个 &lt;code&gt;ArrayList&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/18/5cdf6a655276187010.png&quot; alt=&quot;20190518101356.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/18/5cdf6a292b1d070453.png&quot; alt=&quot;20190518101255.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个内部类并没有覆盖父类 &lt;code&gt;AbstractList&lt;/code&gt; 的 &lt;code&gt;remove&lt;/code&gt; 方法，所以调用的时候就会直接调用父类的 &lt;code&gt;remove&lt;/code&gt; 方法，于是便发生了上面的异常。&lt;/p&gt;
&lt;h2 id=&quot;arrays.aslist的正确打开方式&quot;&gt;Arrays.asList的正确打开方式&lt;/h2&gt;
&lt;p&gt;为了更好的使用这里方法，我们先来看看它的注释说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
* Returns a fixed-size list backed by the specified array.  (Changes to
* the returned list &quot;write through&quot; to the array.)  This method acts
* as bridge between array-based and collection-based APIs, in
* combination with {@link Collection#toArray}.  The returned list is
* serializable and implements {@link RandomAccess}.
*
* &amp;lt;p&amp;gt;This method also provides a convenient way to create a fixed-size
* list initialized to contain several elements:
* &amp;lt;pre&amp;gt;
*     List&amp;amp;lt;String&amp;amp;gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);
* &amp;lt;/pre&amp;gt;
*
* @param &amp;lt;T&amp;gt; the class of the objects in the array
* @param a the array by which the list will be backed
* @return a list view of the specified array
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从说明可以发现，有这么几点需要注意：&lt;/p&gt;
&lt;p&gt;1、该方法返回的是一个固定长度的列表&lt;/p&gt;
&lt;p&gt;所以它的长度是不能被改变的，也就不能对它进行添加和删除元素的操作，从它的内部类ArrayList的方法列表也可以看出，并没有覆盖add和remove方法，因此对这两个方法的调用都会导致抛出异常。&lt;/p&gt;
&lt;p&gt;虽然不能改变列表的长度，但是可以改变列表中的元素，以及元素的位置。比如通过set方法来重新设值，通过replaceAll方法来批量替换，通过sort方法来排序等等。&lt;/p&gt;
&lt;p&gt;2、任何对列表的改动都会回写到原来是数组&lt;/p&gt;
&lt;p&gt;也就是说对返回的列表进行的任何修改操作，都会导致原数组的改变。可以通过一个Test来测试一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testArrays() {
    Long[] longs = {1L,2L,4L,3L};
    List&amp;lt;Long&amp;gt; longList = Arrays.asList(longs);
    System.out.println(&quot;longList:&quot; + JSON.toJSONString(longList) + &quot;longs:&quot; + JSON.toJSONString(longs));

    longList.set(1, 5L);
    System.out.println(&quot;longList:&quot; + JSON.toJSONString(longList) + &quot;longs:&quot; + JSON.toJSONString(longs));

    longList.replaceAll(a -&amp;gt; a + 1L);
    System.out.println(&quot;longList:&quot; + JSON.toJSONString(longList) + &quot;longs:&quot; + JSON.toJSONString(longs));

    longList.sort(Long::compareTo);
    System.out.println(&quot;longList:&quot; + JSON.toJSONString(longList) + &quot;longs:&quot; + JSON.toJSONString(longs));

    longs[2] = 7L;
    System.out.println(&quot;longList:&quot; + JSON.toJSONString(longList) + &quot;longs:&quot; + JSON.toJSONString(longs));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;longList:[1,2,4,3]longs:[1,2,4,3]
longList:[1,5,4,3]longs:[1,5,4,3]
longList:[2,6,5,4]longs:[2,6,5,4]
longList:[2,4,5,6]longs:[2,4,5,6]
longList:[2,4,7,6]longs:[2,4,7,6]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意最后一个输出，我们修改原数组的元素，也会导致列表元素的改变，究其原因，当然是因为列表只是将数组封装了起来而已，最终指向的都是同一个内存地址，因此修改自然也是同步的。&lt;/p&gt;
&lt;p&gt;3、不能使用基本数据类型数组来作为参数&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testArrays2() {
    int[] ints = { 1, 2, 3 };
    List list = Arrays.asList(ints);
    System.out.println(list.size());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里并不会报错，而是会输出&lt;code&gt;1&lt;/code&gt;。为什么呢？&lt;/p&gt;
&lt;p&gt;再回过头去看下说明：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@param &amp;lt;T&amp;gt; the class of the objects in the array&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数的类型T指的是数组中的元素类型，如果数组中元素类型是基本类型，就会把整个数组当成一个元素，我们把上面的栗子稍微修改一下就清楚了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testArrays2() {
    int[] ints = { 1, 2, 3 };
    System.out.println(ints.getClass());
    List list = Arrays.asList(ints);
    System.out.println(JSON.toJSONString(list));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class [I
[[1,2,3]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意第二行的输出是一个二维数组。变长参数本质上就是一个对象数组，所以如果传入一个Integer数组，就能正常接收：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testArrays2() {
    Integer[] ints = { 1, 2, 3 };
    System.out.println(ints.getClass());
    List list = Arrays.asList(ints);
    System.out.println(list.size());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;class [Ljava.lang.Integer;
3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，关于 &lt;code&gt;Arrays.asList()&lt;/code&gt; 的探索之旅就结束了，遇到问题一般跟一跟源码就差不多能解决了，但对于常用的类，如果对其内部的运行机制不熟悉的话，代码就会容易出现一些不符合预期的行为，报错的异常并不可怕，因为可以根据异常很快定位，最怕的就是不报错，能正常运行，但是数据处理却是错误的，等到真正发现的时候，可能已经造成了难以挽回的损失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/18/5cdf7f4a7282234332.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看来主动阅读源码还是相当有必要的，其实&lt;code&gt;Arrays.asList()&lt;/code&gt;并不难使用，推而广之，就像Guava、fastjson这些模块，或者spring、redis、dubbo之类，学习使用并不难，但如果不熟悉内部运行机制，仅仅当成一个黑盒的话，无法探索内部的精妙设计，遇到问题也比较难处理，如果只是把功能框定在其设定的能力范围之内，就没有办法进行定制化的改造。&lt;/p&gt;
&lt;p&gt;嗯，看来我的历练路程还很长啊。最后用荀子的一句话来共勉吧。&lt;/p&gt;
&lt;p&gt;“路虽弥，不行不至，&lt;/p&gt;
&lt;p&gt;事虽小，不做不成。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/18/5cdf7daf74e9241031.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 03:46:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>说明 昨天同事开发的时候遇到了一个奇怪的问题。 使用Guava做缓存，往里面存一个List，为了方便描述，称它为列表A，在另一个地方取出来，再跟列表B中的元素进行差集处理，简单来说，就像是下面这样：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/10885211.html</dc:identifier>
</item>
<item>
<title>图的最小生成树 - 智者侬哥</title>
<link>http://www.cnblogs.com/wuxiangnong/p/10885129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuxiangnong/p/10885129.html</guid>
<description>&lt;p&gt;对于一张图，我们有一个定理：n个点用n-1条边连接，形成的图形只可能是树。我们可以这样理解：树的每一个结点都有一个唯一的父亲，也就是至少有n条边，但是根节点要除外，所以就是n-1条边。还有一种理解：树里不存在环，那么既要连接n个点又不能形成环，只能用n-1条边。&lt;/p&gt;
&lt;p&gt;那么，对于一张n个点带权图，它的生成树就是用其中的n-1条边来连接这n个点，那么最小生成树就是n-1条边的边权之和最小的一种方案，简单的理解，就是用让这张图只剩下n-1条边，同时这n-1条边的边权总和最小。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/14/5cdad32e92a1d82050.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红边即为此图的最小生成树，注意我们目前只讨论无向图的最小生成树。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;求最小生成树的过程，我们可以理解为建一棵树。要使边权总和最小，我们不难想到可以用贪心的思想：让最小生成树里的每一条边都尽可能小，那么我们有两种思路，分别对应着两种算法：&lt;/p&gt;
&lt;h3 id=&quot;kruskal&quot;&gt;(1)Kruskal：&lt;/h3&gt;
&lt;p&gt;我们不难想到一种贪心的策略：每一条边的边权都是小的，那这些边连接起来的边权总和一定也是小的。所以，我们不难想到可以先挑选最小的，再挑选次小的、第三小的......直到我们挑了n-1条边。因此，我们可以将这些边按照边权排序，然后开始挑选边。为什么是挑选边呢？不是越小的边越好吗，为什么还要挑？&lt;/p&gt;
&lt;p&gt;边权小固然好，但是不要忘记我们有一个大前提：我们要建的是树，它里面不能存在环。也就是说，假如我看到一条边，但是这条边连着的两个点在我建的树里已经连通了，那这条边还需要再加进来吗？很显然不用。这样说可能有点无法理解，我们拿一张图来具体操作一下：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/16/5cdd654bb16d684085.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的边排序后从小到大依次为(结点 结点 边权)：&lt;/p&gt;
&lt;p&gt;①1 2 1②1 3 1③4 6 3④5 6 4⑤2 3 6⑥4 5 7⑦3 4 9⑧2 4 11⑨3 5 13&lt;/p&gt;
&lt;p&gt;要建的最小生成树一开始长这样：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/16/5cdd6601b4ce911626.png&quot;/&gt;&lt;br/&gt;我们的操作就是往这棵树里加边，其操作过程如下图所示：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/16/5cdd6728eb8e129868.png&quot;/&gt;&lt;br/&gt;直到目前为止，一切都很顺利。轮到我们的第五条边2 3 6了。我们发现，2和3已经连通，通过1作为中转，这时候我们就不能将2 3 6这条边加入到我们的树中了。同理，下一条⑥号边同样也要跳过，因为4和5已经连通了。接下来，我们加入3 4 9这条边，如图所示：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/16/5cdd684b0e59212213.png&quot;/&gt;&lt;br/&gt;我们发现我们建的树里每个结点都已经连接了，刚好用了5条边，也就是我们说的n-1条边，算法结束。&lt;/p&gt;
&lt;p&gt;算法的实现并不难，最为难的是如何判断两点是否已经连通。我们可以用深搜或广搜来解决，但显然效率极低，因此，我们需要借助一种强大的数据结构：并查集。并查集的最强大的功能就是可以快速地判断两个元素是否在同一集合内（祖先是否相同）,所以我们借助它来判断两点是否连通。&lt;/p&gt;
&lt;p&gt;主要代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct edge
{
    int u,v,w;
}a[100001];
//边集数组 
int boss[10001];//并查集，boss[i]表示i的祖先 
int find(int x)
{
    if(boss[x]==x)return x;//找到祖先
    else
    {
        boss[x]=find(boss[x]);//路径压缩 
        return boss[x]; 
    } 
}
void Kurscal()
{
    int i;
    for(i=1;i&amp;lt;=n;i++)boss[i]=i;//初始化
//n个结点，每个结点的祖先默认为它自己，也就是每个结点自己一个集合
    stable_sort(a+1,a+1+m,cmp);//m条边，将边按照边权从小到大排序
    int cnt=0;//当前最小生成树里边的数量 
    int len=0;//当前最小生成树边权总和 
    for(i=1;i&amp;lt;=m;i++)
    {);
        int x=find(a[i].u),y=find(a[i].v
        //x表示a[i].u的祖先，y表示a[i].v的祖先
        if(x!=y)
        //说明两点不在同一集合内，即这两点不连通
        {
            boss[x]=y;//标记祖先 
            cnt++;//边数增加 
            len+=a[i].w;//边权和增加 
        } 
        if(cnt==n-1)break;
        //如果已经选了n-1条边，那最小生成树就建好了 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;prim&quot;&gt;(2)prim：&lt;/h3&gt;
&lt;p&gt;除了通过加入边来建树，我们还有没有其它的方法了呢？Kurscal中，我们加入边，是在我们固定了结点的情况下完成的。也就是，我们这时候不在乎这些结点，我们只在乎连接它们的边。那，我们可以不可以在乎一下这些结点呢（&lt;del&gt;雨露均沾&lt;/del&gt;）？这时候，我们建树的过程就不是添加边了，而是添加点。那一开始，我们的树就应该长这样(有点尴尬)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/16/5cdd70fd3f3da22292.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们一开始应该先找一个根结点，这个根结点可以是任何一个结点，因为最后每一个结点都会两两连通，哪一个作为根就无所谓了。那么，每一次我们都要选一个点加入我们的最小生成树，这个点必须满足什么条件呢？它距离当前树上的与它最近的结点的距离必须是每一个结点距离树上离它们各自最近的结点的距离中最小的,实际上说的就是每一次要找到一个距离“最小生成树”最近的结点。我们仍旧以上面的例子来模拟：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/16/5cdd732a6410b14670.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，1号点为根，这时候距离这棵树（1号点）最近的是2号点，我们将2号点加入树：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/16/5cdd7433a3ae496866.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，距离这棵树最近的结点是3号点，我们将3号点加入树：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/16/5cdd748a4ad0e64974.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来的操作请读者自己手动模拟，算法只有手动模拟了才能身临其境的感受其思想的真谛（&lt;del&gt;跑题了&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;加入点的顺序应该是：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6。注意我们每次选点的时候要选的是树以外的结点，否则一开始就会出现一种非常尴尬的局面：第一轮，找结点，发现根结点到根结点距离为0，选择根结点；第二轮，发现根结点到根结点距离为0，又选根结点......这就陷入了死循环。对于已经在树里的结点，我们是没有必要再去动它了，因为我们的目的就是将所有点插入到树里，那你已经在树里的我还管你干什么？所以我们需要有一个数组来记录结点是否已经在树里。&lt;/p&gt;
&lt;p&gt;在选点的过程中，我们需要按照上面说的一大串话那样，比较树外的每一个结点到树上的每一个结点的距离吗？我们在那下面说了：“实际上说的就是每一次要找到一个距离“最小生成树”最近的结点。”我们有没有办法来记录每一个结点到最小生成树的距离呢？当然有！我们可以开一个数组dis，有没有发现，和我们的最短路算法中的Dijkstra算法有异曲同工之妙？不懂得可以看一下&lt;a href=&quot;https://www.cnblogs.com/wuxiangnong/p/10780494.html&quot;&gt;最短路算法分析&lt;/a&gt;。这两种算法都是不断加入点进行拓展，从而得出整张图的最短路或最小生成树。Dijkstra中dis表示的是结点到源点的距离，这里就是把源点扩大成了一棵树，其思想并没有任何改变，我们仍旧可以把那棵树当作一个点来看待。那么，在加入点后，我们需要用这个点来刷新一下其它非树结点（不在树上的结点）到树的距离，这和Dijkstra的松弛是一模一样的！令人赞叹的是，这两种算法解决的问题不同，它们的过程竟然完全一样！&lt;/p&gt;
&lt;p&gt;主要代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct edge
{
    int last,to,len;
}a[100001];
int first[10001],len=0;
//邻接表 
bool f[10001];//记录是否在树上
int dis[10001];//记录结点到树的距离 
void add......//存边
void prim()
{
    int i;
   for(i=1;i&amp;lt;=n;i++)dis[i]=999999;//初始化
    int cnt=0;//树内点的数量
    int sum=0;//树内边权总和 
    dis[1]=0;
    f[1]=1;
    cnt=1;
    //先确定根结点，一般以1作为根结点
    while(cnt&amp;lt;n)//直到n个结点均在树上 
    {
        int id,minn=1000001;
        //id记录找到的结点的编号，minn是它到树的距离 
        for(i=1;i&amp;lt;=n;i++)
            if(f[i]==0&amp;amp;&amp;amp;dis[i]&amp;lt;minn)
            {
                id=i;
                minn=dis[i];
            }
        f[id]=1;
        cnt++;
        //将这个点加入树
        sum+=dis[id];
        //刷新边权总和 
        for(i=first[id];i;i=a[i].last)
        //刷新结点到树的距离 
            if(f[a[i].to]==0&amp;amp;&amp;amp;a[i].len&amp;lt;dis[a[i].to])
                dis[a[i].to]=a[i].len;
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下两种算法：Kurscal算法是将森林里的树逐渐合并，prim算法是在根结点的基础上建起一棵树。&lt;/p&gt;
&lt;p&gt;可能有的同学会误解：dis代表结点到树的距离，那这个距离一定只包含一条边吗？在这里，距离只能有一条边。为什么呢？我们每一次是要往树里加一个点的，那如果这个距离经过了不止一条边，那就不满足我们的需求了。这一点要和Dijkstra区别开，Dijkstra是单纯的距离，而prim是只经过一条边的距离。这样的话，即使在存在负边权，求得的dis不是真正意义上的最短距离，也不会影响我们最终的结果。&lt;/p&gt;
&lt;p&gt;我们的过程实际上是每一次添加一个点，然后逐渐建起一棵树，我们并不是真的希望这个点到我们的树是最近的，我们只希望这个点加入我们的最小生成树后可以满足我们贪心的要求：局部最优导致整体最优，这个局部指的是我们最小生成树的边权，而并不是真正意义上的距离。这一点一定要好好理解！&lt;/p&gt;
&lt;p&gt;同样，prim算法也可以堆优化，那么堆里存的就是结点的编号和它到树的距离，和Dijkstra的堆优化基本一样，希望读者自己尝试去实现。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;因为Kurscal涉及大量对边的操作，所以它适用于稀疏图；普通的prim算法适用于稠密图，但堆优化的prim算法更适用于稀疏图，因为其时间复杂度是由边的数量决定的。&lt;/p&gt;
&lt;h2 id=&quot;by-wxn&quot;&gt;By wxn&lt;/h2&gt;
</description>
<pubDate>Sat, 18 May 2019 03:26:00 +0000</pubDate>
<dc:creator>智者侬哥</dc:creator>
<og:description>图的最小生成树 对于一张图，我们有一个定理：n个点用n 1条边连接，形成的图形只可能是树。我们可以这样理解：树的每一个结点都有一个唯一的父亲，也就是至少有n条边，但是根节点要除外，所以就是n 1条边。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuxiangnong/p/10885129.html</dc:identifier>
</item>
<item>
<title>Vee-validate 父组件获取子组件表单校验结果 - givebest</title>
<link>http://www.cnblogs.com/givebest/p/10885099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/givebest/p/10885099.html</guid>
<description>&lt;p&gt;&lt;code&gt;vee-validate&lt;/code&gt; 是为 Vue.js 量身打造的表单校验框架，允许您校验输入的内容并显示对应的错误提示信息。它内置了很多常见的校验规则，可以组合使用多种校验规则，大部分场景只需要配置就能实现开箱即用，还支持自定义正则表达式。而且支持 40 多种语言，对本地化、多语言支持非常友好。&lt;/p&gt;
&lt;p&gt;国内饿了么团队开源项目 &lt;code&gt;Element UI&lt;/code&gt; 就用到了 &lt;code&gt;vee-validate&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;vee-validate&lt;/code&gt;官网：https://baianat.github.io/vee-validate/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;可查看官网文档（&lt;a href=&quot;https://baianat.github.io/vee-validate/&quot; class=&quot;uri&quot;&gt;https://baianat.github.io/vee-validate/&lt;/a&gt;）或者查看这一篇文章（&lt;a href=&quot;https://blog.givebest.cn/javascript/2019/04/20/vue.js-nuxt.js-use-vee-validate.html&quot; class=&quot;uri&quot;&gt;https://blog.givebest.cn/javascript/2019/04/20/vue.js-nuxt.js-use-vee-validate.html&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;组件内使用-vee-validate&quot;&gt;组件内使用 Vee-validate&lt;/h2&gt;
&lt;h3 id=&quot;子组件&quot;&gt;子组件&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;input
      placeholder=&quot;请输入姓名&quot;
      v-model=&quot;username&quot;
      name=&quot;username&quot;
      v-validate=&quot;'required'&quot;
      :error-message=&quot;errors.first('username')&quot;
    /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name: &quot;Username&quot;,
  data() {
    return {
      username: ''
    }
  },
  methods: {
    // 表单校验
    validateForm() {
      return this.$validator.validateAll();
    },
  }
};
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;父组件&quot;&gt;父组件&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;Username ref=&quot;usernameComponent&quot; /&amp;gt;
    &amp;lt;Password ref=&quot;passwordComponent&quot; /&amp;gt;

    &amp;lt;div&amp;gt;
      &amp;lt;button @click=&quot;onSubmit&quot;&amp;gt;提交校验&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import Username from &quot;~/components/username.vue&quot;
import Password from &quot;~/components/password.vue&quot;

export default {
  components: {
    Username,
    Password
  },
  data() {
    return {}
  },
  methods: {
    onSubmit (e) {
      e.preventDefault()  // 阻止默认事件

      // 父组件触发子组件校验，并通过 Promise 返回值
      let vf1 = this.$refs.usernameComponent.validateForm()
      let vf2 = this.$refs.passwordComponent.validateForm()

      // 提交表单前，校验所有子组件，全部通过才允许下面操作
      Promise.all([vf1, vf2]).then(result =&amp;gt; {
        // 有一个组件未通过，就提示错误信息
        if (result.indexOf(false) &amp;gt; -1) {
          console.log(&quot;全部校验未通过&quot;)
          return
        }

        // 校验全部通过处理
        console.log(&quot;全部校验通过&quot;)
      })
    },
  }
};
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;其实组件内使用 Vee-validate 校验很方便，主要问题可能是父组件怎么触发子组件内的校验，并获取校验结果。这里用到 Vue.js 里的 &lt;a href=&quot;https://cn.vuejs.org/v2/api/#ref&quot;&gt;ref&lt;/a&gt; 特性，给子组件赋值一个 ID 引用，然后就可以使用 &lt;code&gt;this.$refs.childComponent&lt;/code&gt; 获得子组件实例引用，再分别调起子组件写好的校验方法，如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
父组件触发子组件校验，并通过 Promise 返回值
*/
let vf1 = this.$refs.usernameComponent.validateForm() // 父组件调用 usernameComponent 组件里的 validateForm 方法
let vf2 = this.$refs.passwordComponent.validateForm() // 父组件调用 passwordComponent 组件里的 validateForm 方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;Promise.all&lt;/a&gt; 获取全部子组件校验结果后，再根据结果来判断，是否全部通过，分别做出不同处理。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 提交表单前，校验所有子组件，全部通过才允许下面操作
Promise.all([vf1, vf2]).then(result =&amp;gt; {
  // 有一个组件未通过，就提示错误信息
  if (result.indexOf(false) &amp;gt; -1) {
    console.log(&quot;全部校验未通过&quot;)
    return
  }

  // 校验全部通过处理
  console.log(&quot;全部校验通过&quot;)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;转载请注明出处-httpsblog.givebest.cnjavascript20190518vee-validate-get-subcomponent-verification-results.html&quot;&gt;转载请注明出处： &lt;a href=&quot;https://blog.givebest.cn/javascript/2019/05/18/vee-validate-get-subcomponent-verification-results.html&quot; class=&quot;uri&quot;&gt;https://blog.givebest.cn/javascript/2019/05/18/vee-validate-get-subcomponent-verification-results.html&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Sat, 18 May 2019 03:21:00 +0000</pubDate>
<dc:creator>givebest</dc:creator>
<og:description>介绍 vee-validate 在子组件内使用过程中，如何通过父组件校验子组件，并获取校验信息。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/givebest/p/10885099.html</dc:identifier>
</item>
<item>
<title>HTML前端入门归纳——控件 - 舞狼</title>
<link>http://www.cnblogs.com/chenchaochao034/p/10885017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenchaochao034/p/10885017.html</guid>
<description>&lt;p&gt;　　本人一直在从事.net的开发，界面都是采用的WPF，近期花了一个多月进行HTML前端的学习，在这里呢进行学习总结和归纳。&lt;br/&gt;　　本系列将主要分为4个模块：&lt;/p&gt;
&lt;p&gt;　　　　控件&lt;/p&gt;
&lt;p&gt;　　　　样式&lt;/p&gt;
&lt;p&gt;　　　　布局&lt;/p&gt;
&lt;p&gt;　　　　JavaScript&lt;/p&gt;
&lt;p&gt;　　根据多年WPF的开发经验，界面就是控件及样式与布局的组合，再加上代码来控制交互逻辑，本期先对HTML常用的控件进行归纳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　div : 区块&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;***&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　div的概念与WPF中的Border类似，一般作为一个局部控件的容器，可通过css来设置它的各个属性，比如宽、高、背景色&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;div {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    height: 160px;  
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    width:200px;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    background-color: #fff;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过上面的css即可得到如下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518103737403-62700482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们也可以将div的背景色改为图片，只需在css中加如下一句即可&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　　　background-image:url(图片路径&lt;span lang=&quot;EN-US&quot;&gt;);&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;　　　　　　&lt;span lang=&quot;EN-US&quot;&gt;background-repeat:no-repeat; 注：如果不加这句图片会通过重复来进行填充&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518104235112-1781770089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因为div经常被当作局部控件的容器，所以我们可以在它的内部添加其他控件，&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;叫爸爸&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518104405183-1980518147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;input : 用户输入区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　该控件可以通过设置type属性来实现多种用户交互，主要的用法如下：　　　　　　&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　　　　　&lt;span&gt;&amp;lt;input type=&quot;***&quot; value=&quot;***&quot; name=&quot;***&quot;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　常用的几种type效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518104737893-1184040656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有关input的更多信息，建议参考另外一篇博客，他会给你更全面的讲解：&lt;a title=&quot;HTML input&quot; href=&quot;http://www.w3school.com.cn/tags/tag_input.asp&quot; target=&quot;_blank&quot;&gt;HTML input&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;select : 选择框&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　select通常需要与选项option一起出现，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value &lt;/span&gt;&lt;span&gt;=&quot;volvo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Volvo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value &lt;/span&gt;&lt;span&gt;=&quot;saab&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Saab&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;opel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Opel&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;audi&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Audi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成的效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518105405794-1191030121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过在select外嵌套一个div，再添加一个css样式，即可得到一个相对美观的选择框。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;div&lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  background&lt;/span&gt;:&lt;span&gt; url('https://raw.githubusercontent.com/ourjs/static/gh-pages/2015/arrow.png') right center no-repeat&lt;/span&gt;;
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; the width and the height of your image &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  height&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  border&lt;/span&gt;:&lt;span&gt; solid 1px #ccc&lt;/span&gt;;
&lt;span&gt; 8&lt;/span&gt; }
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; select &lt;/span&gt;{
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    -webkit-appearance&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    -moz-appearance&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    appearance&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    background&lt;/span&gt;:&lt;span&gt; transparent&lt;/span&gt;;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    border&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    padding-left&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
&lt;span&gt;19&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518105624812-1242417882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 　　img ：图片&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　　　&amp;lt;img src=&quot;url&quot; alt=&quot;some_text&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&amp;lt;img src=&quot;https://gss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3611826739,2799706291&amp;amp;fm=173&amp;amp;app=49&amp;amp;f=JPEG?w=218&amp;amp;h=146&amp;amp;s=50F111C4BEE9241596FD489703004087&quot; alt=&quot;美国国务卿&quot; /&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518105747821-673941396.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; 　　ul : 列表&lt;/p&gt;
&lt;p&gt;　　ul通常会与li列表项一起出现，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Coffee&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Tea&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Milk&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518110004340-1707345181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果给它加上一点样式，就能得到一个不一样的列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;ul
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    list-style-type&lt;/span&gt;:&lt;span&gt;none&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    padding&lt;/span&gt;:&lt;span&gt;0px&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    margin&lt;/span&gt;:&lt;span&gt;0px&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; }
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;ul li
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; {
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    background-image&lt;/span&gt;:&lt;span&gt;url(sqpurple.gif)&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    background-repeat&lt;/span&gt;:&lt;span&gt;no-repeat&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    background-position&lt;/span&gt;:&lt;span&gt;0px 5px&lt;/span&gt;; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    padding-left&lt;/span&gt;:&lt;span&gt;14px&lt;/span&gt;;
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518110114112-1079404006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　table : 表格&lt;/p&gt;
&lt;p&gt;　　table通常需要与表格行tr/表格头内容th/表格行内容td一起使用，例如如下示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Month&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Savings&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;January&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;$100&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/621961/201905/621961-20190518110408493-1800842986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　HTML常用的几种控件这里就介绍完毕了，近期将进行样式方面的归纳，敬请期待。&lt;/p&gt;

</description>
<pubDate>Sat, 18 May 2019 03:07:00 +0000</pubDate>
<dc:creator>舞狼</dc:creator>
<og:description>本人一直在从事.net的开发，界面都是采用的WPF，近期花了一个多月进行HTML前端的学习，在这里呢进行学习总结和归纳。 本系列将主要分为4个模块： 控件 样式 布局 JavaScript 根据多年W</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenchaochao034/p/10885017.html</dc:identifier>
</item>
<item>
<title>MySQL8.0.16新特性：The Communication Protocol In Group Replication - Paddy_Duck</title>
<link>http://www.cnblogs.com/SQLServer2012/p/10884909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SQLServer2012/p/10884909.html</guid>
<description>&lt;p&gt;　　传统的升级手段之一，5.7 MGR集群与8.0 MGR集群进行数据传输，程序切换新集群后测试是否正常，如果不正常，要么将新集群的新增数据同步回旧集群，要么就舍弃掉这部分数据，一般看来这种回滚都是繁琐的，繁琐的操作一般都会相应的增加风险。&lt;/p&gt;

&lt;p&gt;　　8.0.16的发布也带来一个新的功能-MGR通信协议的支持，可以让我们更轻松地切换到8.0，或者轻松地再切换回5.7。那么什么是MGR通信协议呢？ &lt;/p&gt;

&lt;p&gt;  从MySQL 8.0.16中，MGR有一个通信协议的概念。可以直接管理MGR通信协议版本，并将其设置为适应你希望MGR成员支持的哪个MySQL服务器版本。&lt;/p&gt;

&lt;p&gt;  从而实现同一个MGR可用组中可以由不同MySQL服务器版本的成员组成。&lt;/p&gt;

&lt;p&gt;  是的你没有看错，也就是说：&lt;/p&gt;


&lt;p&gt;  如果组的通信协议版本小于或等于X，则版本X的MySQL服务器只能在复制组中加入并达到ONLINE状态。当新成员加入复制组时，它会检查通告的通信协议版本。&lt;/p&gt;

&lt;p&gt;  该小组的现有成员。 如果加入成员支持该版本，则它加入该组并使用该组已宣布的通信协议，即使该成员支持其他通信功能。 如果加入成员不支持通信协议版本，则将其从组中驱逐出去。&lt;/p&gt;

&lt;p&gt;  如果两个成员尝试加入相同的MGR集群，则只有两个成员的通信协议版本已与该MGR已有成员的通信协议版本兼容时，它们才能加入。 来自该组的具有不同通信协议版本的成员必须单独加入。 &lt;/p&gt;
&lt;p&gt;     例如：&lt;/p&gt;
&lt;div class=&quot;wiz-table-container&quot;&gt;
&lt;div class=&quot;wiz-table-body&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1个MySQL Server &lt;span&gt;8.0&lt;/span&gt;.16实例可以成功加入使用通信协议版本为5.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;.22的组。
1个MySQL Server &lt;/span&gt;&lt;span&gt;5.7&lt;/span&gt;.22实例无法加入使用通信协议版本为8.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.16的组。
2个MySQL Server &lt;/span&gt;&lt;span&gt;8.0&lt;/span&gt;.16实例无法同时加入使用通信协议版本为5.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;.22的组。
2个MySQL Server &lt;/span&gt;&lt;span&gt;8.0&lt;/span&gt;.16实例可以同时加入使用通信协议版本8.&lt;span&gt;0&lt;/span&gt;.16的组
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;1.    group_replication_get_communication_protocol&lt;/h2&gt;
&lt;p&gt;　　用于获取该MGR成员中最早的MySQL版本的通信协议&lt;/p&gt;


&lt;div readability=&quot;5.7615384615385&quot;&gt;　　需要更改MGR的通信协议版本以便早期版本的成员可以加入，需要具有&lt;a class=&quot;link&quot; href=&quot;https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin&quot;&gt;&lt;code class=&quot;literal&quot;&gt;GROUP_REPLICATION_ADMIN&lt;/code&gt;&lt;/a&gt; 权限哦&lt;/div&gt;


&lt;h2&gt;环境：&lt;/h2&gt;




</description>
<pubDate>Sat, 18 May 2019 02:37:00 +0000</pubDate>
<dc:creator>Paddy_Duck</dc:creator>
<og:description>MGR优雅升级到MySQL8.0.16 传统的升级手段之一，5.7 MGR集群与8.0 MGR集群进行数据传输，程序切换新集群后测试是否正常，如果不正常，要么将新集群的新增数据同步回旧集群，要么就舍弃</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SQLServer2012/p/10884909.html</dc:identifier>
</item>
</channel>
</rss>