<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>复盘 2019 ，展望 2020 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/12122661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/12122661.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191231084440869-250754547.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;告诉大家一个悲惨的事情，再过 4 天，第一批 90 后就正式进入 30 大关。&lt;/p&gt;
&lt;p&gt;emmmmmmmmm，以上内容与小编无关，小编距 30 还有 1、 2、 3、 4 等等好多年呢。&lt;/p&gt;
&lt;p&gt;马上就是元旦了，本来计划这篇文章元旦再写，正好今天有点空，就先做个全年总结吧。&lt;/p&gt;
&lt;p&gt;写这篇文章的主要目的就是跟大家吹吹牛逼，讲大实话感觉要掉粉啊。。。。&lt;/p&gt;
&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;p&gt;2019 上半年忙忙碌碌的也不知道自己在忙点啥，好像做了很多事情，好像又啥也没做，直到有一天，有一位面试的小朋友给了小编灵魂一击：你这么厉害，一定有自己的博客吧~~&lt;/p&gt;
&lt;p&gt;WTF ，这个还真没有，这是被鄙视了么，就这么样，做内容输出这件事情就被提上了议事日程。&lt;/p&gt;
&lt;p&gt;但是，当头脑冷静下来以后，就会发现这件事情的本身是有问题的。一件事情如果单纯的只是靠一时的兴趣，是必然无法长久的。等时间久了，前面火热的激情过去了，自然这件事情优先级就会被降低，慢慢就会被遗忘在记忆深处。&lt;/p&gt;
&lt;p&gt;后来一些侧面的了解中，小编了解到，这个做公众号能来 Money 。&lt;/p&gt;
&lt;p&gt;哇，两眼放光好嘛。&lt;/p&gt;
&lt;p&gt;“天下熙熙，皆为利来；天下攘攘，皆为利往。”&lt;/p&gt;
&lt;p&gt;小编也是俗人，自然不能免俗，有利益的事情可以做，而且因为有利可图，这件事情是一个可以长久发展的事情。&lt;/p&gt;
&lt;p&gt;老讲大实话，估计真的会掉粉，小编已经预测到这篇文章推出去后掉粉的盛况了。&lt;/p&gt;
&lt;p&gt;接下来自然就是各种注册，搞定了自己经常逛的技术博客的账号。&lt;/p&gt;
&lt;p&gt;小编看了下自己的博客发布时间，这个日期选择的蛮好算的， 7 月 1 号发布了第一篇博客，不过那个时候还没有在公众号上同步。&lt;/p&gt;
&lt;p&gt;那个时间主要写的是小编在工作中用到的一些内容，都是和 Java 相关的，写过 SpringCloud 系列，写过 SpringBoot 系列。&lt;/p&gt;
&lt;h2 id=&quot;约稿&quot;&gt;约稿&lt;/h2&gt;
&lt;p&gt;小编第一次写 SpringCloud 系列的时候，当时记得还是在博客园，被清华社的王老师看上了，王老师多次向小编伸出了橄榄枝，当时还是非常激动的，小编第一次写的内容的时候就已经有出版社约稿了。&lt;/p&gt;
&lt;p&gt;这里也十分感谢王老师的看重，让小编沉下心来静静的写了三个月的书稿。&lt;/p&gt;
&lt;p&gt;从 7 月份开始一直到 10 月份，其实空余的时间一直都在写稿子，包括每个周末，每个晚上，那段时间小编现在想起来都觉得蛮鸡血的。&lt;/p&gt;
&lt;p&gt;当然，小编也会从稿子中抽出来一部分感觉写的还不错的内容发到博客上去。&lt;/p&gt;
&lt;p&gt;就这么静静的写了三个月的书稿，还是和一个同事一起写的。&lt;/p&gt;
&lt;p&gt;在这三个月中，小编是真的感觉学到了很多知识，很多以前一知半解的内容，因为要写书，书里面的内容是不能有错、不能语句模糊的，小编每天都要查阅大量的资料，尽量的确保每句话的正确性，在这期间，官方的文档不知道被翻了多少遍，也不知道熬过多少次夜。&lt;/p&gt;
&lt;p&gt;三个月的时间是充实而又漫长的。&lt;/p&gt;
&lt;p&gt;写书这件事情并不建议大家去尝试，当一开始的激情消退以后，这件事情可能会成为一种煎熬。&lt;/p&gt;
&lt;p&gt;刚开始两个月的时候，小编其实是很兴奋的，每天都和打满了鸡血一样，奋笔疾书。当全书进入后半段的时候，小编整个人都疲下来了，不过因为是承诺了别人，小编还是咬着牙把第一版写完了。&lt;/p&gt;
&lt;p&gt;其实现在讲起来这件事情小编也是蛮惭愧的，这件事情虽然小编交了第一个版本，最后还是放弃了。&lt;/p&gt;
&lt;p&gt;至于原因后面再说。&lt;/p&gt;
&lt;p&gt;总归这份书稿不能白写，小编明年会整理一下开源在博客站上，就当送给各位同学的福利了。&lt;/p&gt;
&lt;p&gt;因为整本书没有经过审校，可能会有各种各样的错误，请各位同学多多担待。&lt;/p&gt;
&lt;h2 id=&quot;公众号&quot;&gt;公众号&lt;/h2&gt;
&lt;p&gt;小编的公众号从 7 月份开始运营以来，截止目前，一共原创 103 篇，很多 7 、 8 、9 月份的博客都没同步在公众号上，这三个月推的文章内容并不多。&lt;/p&gt;
&lt;p&gt;当然，小编为了公众号的增粉，也是使用了一些小心机。在个人博客站上增加了强制关注，希望各位同学不要介意。&lt;/p&gt;
&lt;p&gt;小编可以讲讲为什么要这么做，前面提到过做内容是可以来 Money 的，这个来源就是公众号。&lt;/p&gt;
&lt;p&gt;只有有了粉丝，有了流量，很多事情才能做，才能赚到一部分的钞票。&lt;/p&gt;
&lt;p&gt;小编现在看市面上大多数的技术类的的公众号来源一般都是推一些广告，这些广告是有费用的。&lt;/p&gt;
&lt;p&gt;其实讲白了，这笔钱说多，那也是金字塔顶端的那一小撮号比较多，下面大多数的号都不会特别多，能补贴个家用就算不错了，还有更多的号是连毛都见不着，这些号慢慢的会消亡掉，毕竟靠爱靠兴趣发电，不长久。&lt;/p&gt;
&lt;p&gt;顺便说一下，小编的公众号截止目前，已经赚了两杯奶茶了。&lt;/p&gt;
&lt;p&gt;好像和投入不成比例嘛，不过小编是这么看这件事情的，首先，对大多数普通人来讲，一件事情需要先做到正向循环，这是第一道门槛，如果连正向循环都做不到，那么这件事情必然是以失败告终。&lt;/p&gt;
&lt;p&gt;内容分享者也是需要恰饭的，他们也是人，不是雷锋。&lt;/p&gt;
&lt;p&gt;如果一件事情长期无法获得回报的话，很少有人能坚持做下去，当然如果能坚持做下去的，要么是撞南墙，要么就是一飞冲天。&lt;/p&gt;
&lt;p&gt;现实中，这么赌的人要么成为了公众所熟知的人物，要么连个水花都没溅起来。&lt;/p&gt;
&lt;p&gt;说一个小事儿，就因为这个小事儿，差点小编就夭折在了正向循环之前。小编在做这个公众号的前三个月的时间中，差点就放弃了，7、8、9 三个月，累计粉丝数量从 0 到了 128 人。&lt;/p&gt;
&lt;p&gt;还好小编坚持下来了，后面慢慢的有了起色，总感觉是因为博客站上加上了骚操作。&lt;/p&gt;
&lt;p&gt;哎。。。老说实话。。。&lt;/p&gt;
&lt;p&gt;还有一件事情可以和大家炫耀一下，自从 12 月份以来，小编一直的公众号一直坚持连续更新，至今尚未断更。&lt;/p&gt;
&lt;p&gt;不过马上就要断了，昨天已经把存稿都发完了，但是，容小编在断更前把这个牛逼先吹出来。&lt;/p&gt;
&lt;p&gt;12 月份其实小编的事情非常多，工作上的，生活上的（这个就不透露了），很多文章都是写到凌晨，具体几点就不写了，免得某些人看到又要来教育小编了。&lt;/p&gt;
&lt;p&gt;同样也是在 12 月份，小编决定了放弃前面的讲的那本书的改稿。每天的时间都已经被填充的满满的，已经抽不出来时间再去看之前的书稿了。&lt;/p&gt;
&lt;p&gt;给自己的放弃找了个不错的理由。后面找机会再和王老师合作吧。毕竟这件事情是小编自己先放弃了，总感觉有点辜负了王老师的期望。&lt;/p&gt;
&lt;h2 id=&quot;博客&quot;&gt;博客&lt;/h2&gt;
&lt;p&gt;小编打开自己的个人博客，数了下文章数量，共计 120 篇文章，这里面大多数都是在今年的第四季度写的。&lt;/p&gt;
&lt;p&gt;看着这个数字还是成就感满满，一篇文章多的不敢说， 3 小时左右，其实很多文章远超过这个数字。&lt;/p&gt;
&lt;p&gt;120 篇文章就是 360 个小时。在最近的半年时间里，平均到每天都要有两个小时在写内容。&lt;/p&gt;
&lt;p&gt;这还没有计算小编在前面耗费了大量的时间写的那本书。&lt;/p&gt;
&lt;p&gt;因为是技术类的文章，基本上每篇文章都会有对应的代码，小编把每天的稿子和代码都提交到 Github 上做备份了，可以给大家看下小编今年的 Github 的提交记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191231084441361-708074482.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在写博客的过程中，小编有幸加入了 CSDN 的作者群，认识一群非常优秀的人。&lt;/p&gt;
&lt;p&gt;他们其中很多人都比小编更加努力，比如现在在读博的杨秀章老师，每天的时间都已经安排的很满了，还总是能每周抽出来时间，写 3 ~ 4 篇的长篇深度分享。&lt;/p&gt;
&lt;p&gt;可能这就是普通人和有天赋选手的区别吧。。。&lt;/p&gt;
&lt;p&gt;再分享一件事情，其实在 10 月份的时候，当小编结束掉 SpringBoot 的系列文章的时候，小编已经黔驴技穷了，不知道该写什么了，感觉把自己之前用到的熟悉的内容已经全写了一遍了。&lt;/p&gt;
&lt;p&gt;这时，小编脑子里冒出来一个骚操作，之前一直想空了研究下 Python ，那不如一边学一边分享，这也就有了后来小白学 Python 系列。&lt;/p&gt;
&lt;p&gt;起这个名字完全是因为小编在 Python 这一块也真的是一位小白，虽然你们可能都不信：）&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;2020&lt;/h2&gt;
&lt;p&gt;前面絮絮叨叨了这么多，能看到这里的绝对是真爱了。&lt;/p&gt;
&lt;p&gt;既然题目中有一个展望俩字，那就接着吹牛逼嘛。&lt;/p&gt;
&lt;p&gt;首先，肯定是在 2020 年中继续分享技术相关的内容，这也是小编做这件事情的初心。&lt;/p&gt;
&lt;p&gt;能提高一些自己的写作水平，就比如这一篇，写的确实挺烂的。&lt;/p&gt;
&lt;p&gt;更多的去分享一些自己对某些事情的看法，很多文章的素材的来源都是来自于和各位同学的聊天。&lt;/p&gt;
&lt;p&gt;毕竟也在这一行混了不少年头了，希望后来者看到了能少走一些弯路。&lt;/p&gt;
&lt;p&gt;其实弯路也少走不了，避开了这个总会遇上另一个，不过能避开一个算一个。&lt;/p&gt;
&lt;p&gt;同时希望自己公众号的粉丝数能突破 2w ，完成近百分之四百的增长。&lt;/p&gt;
&lt;p&gt;这个牛逼吹得有点大，感觉挺困难，其实换成突破 1w 是一件比较靠谱的事儿，不过吹牛逼嘛，要是不吹大点总感觉这个牛逼吹得特没劲。&lt;/p&gt;
&lt;p&gt;事在人为，人不一定能胜天，挑战一下自己还是很有意思的一件事儿。&lt;/p&gt;
&lt;p&gt;希望明年全年的博客原创数量能达到 250+ 。这就意味着小编明年一年都还挺忙的。&lt;/p&gt;
&lt;p&gt;如果达不到各位同学表骂我。&lt;/p&gt;
&lt;p&gt;希望明年 Github 能出现一个破百 star 以上的项目，这个感觉最难。&lt;/p&gt;
&lt;p&gt;希望明年 CSDN 能成为博客专家，感觉这个可能是最简单的一件事儿了。&lt;/p&gt;
&lt;p&gt;感觉写成许愿池了，满脸尴尬。&lt;/p&gt;
&lt;p&gt;就这样吧，2020 ，小编和各位一起期待。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Dec 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>告诉大家一个悲惨的事情，再过 4 天，第一批 90 后就正式进入 30 大关。 emmmmmmmmm，以上内容与小编无关，小编距 30 还有 1、 2、 3、 4 等等好多年呢。 马上就是元旦了，本来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/12122661.html</dc:identifier>
</item>
<item>
<title>多线程之美8一 AbstractQueuedSynchronizer源码分析 - 夕阳下飞奔的猪</title>
<link>http://www.cnblogs.com/flydashpig/p/12122167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydashpig/p/12122167.html</guid>
<description>&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230230247625-1939714617.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AQS的源码分析 &amp;lt;二&amp;gt;&lt;/p&gt;
&lt;p&gt;该篇主要分析AQS的ConditionObject，是AQS的内部类，实现等待通知机制。&lt;/p&gt;

&lt;p&gt;条件队列与AQS中的同步队列有所不同，结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230230309146-1155115184.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两者区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、链表结构不同，条件队列是单向链表，同步队列是双向链表。&lt;/li&gt;
&lt;li&gt;2、两个队列中等待条件不同，条件队列中线程是已经获取到锁，主动调用await方法释放锁，挂起当前线程，等待某个条件（如IO,mq消息等），同步队列中的线程是等待获取锁，在获取锁失败后挂起等待锁可用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;两者联系：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当等待的某个条件完成，其他线程调用signal方法，通知挂起在条件队列中的线程，会将条件队列中该node移出，加入到同步队列中，node的ws状态由Node.CONDITION改为0 ，开始等待锁。&lt;/p&gt;

&lt;p&gt;ConditionObject 和 Node一样，都是AQS的内部类, ConditionObject实现Condition接口，主要实现线程调用 await和signal ，实现线程条件阻塞和通知机制，Condition对象通过 Lock子类调用newConditon方法获取，以&lt;/p&gt;
&lt;p&gt;ReentrantLock为例，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ReentrantLock lock  = new ReentrantLock();
Condition condition =  lock.newCondition();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见排他锁的newCondition方法返回的是ConditionObject对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final ConditionObject newCondition() {
    return new ConditionObject();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单生产者消费示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package AQS;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
/**
 * @author zdd
 * 2019/12/30 下午
 * Description: 利用ReentrantLock和Condition实现生产者消费者
 */
public class ConditionTest {
   static ReentrantLock lock  = new ReentrantLock();
   static Condition condition =  lock.newCondition();
    public static void main(String[] args) {
       //资源类
        Apple apple = new Apple();
     //1.开启生产者线程
        new Thread(()-&amp;gt; {
            for (;;) {
                lock.lock();
                try {
                    //苹果没有被消费，吃完通知我，我再生产哦
                    if (apple.getNumber() &amp;gt; 0) {
                        condition.await();
                    }
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println(&quot;生产一个苹果&quot;);
                    apple.addNumber();
                    //通知消费线程消费
                    condition.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        },&quot;producer&quot;).start();
      //2.开启消费者线程
        new Thread(()-&amp;gt; {
            for (;;) {
                lock.lock();
                try {
                    //苹果数量为0，挂起等待生产苹果，有苹果了会通知
                    if(apple.getNumber() == 0) {
                        condition.await();
                    }
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println(&quot;消费一个苹果&quot;);
                    apple.decreNumber();
                    //通知生产线程生产
                    condition.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        },&quot;consumer&quot;).start();

    }
  //定义苹果内部类 
   static class Apple {
        //记录苹果数量
        private Integer number =0;
        public void addNumber() {
            number++;
            System.out.println(Thread.currentThread().getName() +&quot;当前苹果数量：&quot;+number );
        }
        public void decreNumber() {
            number--;
            System.out.println(Thread.currentThread().getName() +&quot;当前苹果数量：&quot;+number);
        }
        public Integer getNumber() {
            return number;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230230334322-1069565226.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;await-方法&quot;&gt;2.1、 await() 方法&lt;/h2&gt;
&lt;p&gt;当前线程是在已经获取锁的情况下，调用await方法主动释放锁，挂起当前线程，等待某个条件（IO,mq消息等）唤醒，再去竞争获取锁的过程。该方法会将当前线程封装到node节点中，添加到Condition条件队列中，释放锁资源，并挂起当前线程。&lt;/p&gt;
&lt;p&gt;具体执行步骤如下：&lt;/p&gt;
&lt;p&gt;1、线程封装到node中，并添加到Condition条件队列中，&lt;strong&gt;ws =-2&lt;/strong&gt; 即为Node.CONDITION。&lt;/p&gt;
&lt;p&gt;2、释放锁。&lt;/p&gt;
&lt;p&gt;3、将自己阻塞挂起，如果线程被唤醒，首先检查自己是被中断唤醒的不。如果是被中断唤醒，跳出while循环；如果是被其他线程signal唤醒，则判断当前线程所在node是否被加入到同步等待队列，已在同步队列中也跳出while循环，否则继续挂起，signal唤醒逻辑会将condition条件队列node 移出，加入到同步队列中，去等待获取锁。&lt;/p&gt;
&lt;p&gt;4，线程被唤醒，执行acquireQueued方法，线程会尝试获取锁，若失败则在同步队列中找到安全位置阻塞，成功则从调用await()方法处继续向下执行，返回值表示当前线程是否被中断过。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            Node node = addConditionWaiter();
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            while (!isOnSyncQueue(node)) {
               //挂起当前线程
                LockSupport.park(this);
              // 被唤醒： 1,被其他线程唤醒，2，中断唤醒，
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
           //1,如果被signal正常唤醒执行acquireQueued,返回false,如果获取到锁就继续执行调用await后面的代码了，未获取到锁就在同步队列中继续挂起等待锁执行了
           //2,如果被中断唤醒的，acquireQueued 返回true
            if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
               //线程在被signal后，再被中断的
                interruptMode = REINTERRUPT;
         //  后面代码处理的是被中断唤醒的情况
            if (node.nextWaiter != null) // clean up if cancelled
              //如果nextWaiter!=null,则表示还在条件队列中，清理一下所有被取消node
              //什么情况下会进入该if判断中，如果是正常被signal的，会将该node从条件队列移出加入到同步队列中的， nextWaiter 一定为null,那就是被异常中断情况，
                unlinkCancelledWaiters();
            if (interruptMode != 0)
               //响应中断模式
                reportInterruptAfterWait(interruptMode);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第1步，执行addConditionWaiter方法，主要逻辑是将线程封装为Node,并添加到条件队列中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        private Node addConditionWaiter() {
          //1.获取队列中最后一个节点
            Node t = lastWaiter;
            //2.如果最后一个节点被取消，清除出队
            if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
            //3. t 指向最新有效的节点，也可能条件队列为空，t==null
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第2步，完全释放锁 fullyRelease，将同步状态state 设置为初始值0，这里考虑到有多次重入获取锁情况，state &amp;gt;1，这时需完全释放锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            int savedState = getState();
            //1,释放锁
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            if (failed)
            //2,释放锁失败，将条件队列中的节点标记为取消
                node.waitStatus = Node.CANCELLED;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;isOnSyncQueue 判断node是否在同步队列中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; final boolean isOnSyncQueue(Node node) {
       //1,这2种情况肯定没有在同步队列中
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        if (node.next != null) // If has successor, it must be on queue
            return true;
       //3.从同步队列尾节点开始对比，看是否在同步队列中
        return findNodeFromTail(node);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;findNodeFromTail 从后向前寻找&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  private boolean findNodeFromTail(Node node) {
        Node t = tail;
        for (;;) {
            if (t == node)
                return true;
            if (t == null)
                return false;
            t = t.prev;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在线程被唤醒后，检查挂起期间是否被中断&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private int checkInterruptWhileWaiting(Node node) {
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果线程被中断了，那就需要将在条件队列中等待的该节点执行 transferAfterCancelledWait&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; final boolean transferAfterCancelledWait(Node node) {
       // 判断是否是被signal通知唤醒的,会更新为0，更新成功，执行入队操作（加入同步队列）
        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
            enq(node);
            return true;
        }
        while (!isOnSyncQueue(node))
          //未在同步队列中，让出处理器，线程回到就绪态，等待下一次分配cpu调度
            Thread.yield();
        return false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后根据不同的中断值做出相应处理&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void reportInterruptAfterWait(int interruptMode)
    throws InterruptedException {
    if (interruptMode == THROW_IE)
        //1,直接抛出中断异常
        throw new InterruptedException();
    else if (interruptMode == REINTERRUPT)
        //2,中断标志
        selfInterrupt();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;signal方法&quot;&gt;2.2、signal方法&lt;/h2&gt;
&lt;p&gt;就是将条件队列中的node移出，加入到同步队列等待获取锁的过程。&lt;/p&gt;
&lt;p&gt;流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230230400596-38393636.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                doSignal(first);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   private void doSignal(Node first) {
            do {
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
              // 1、将first节点执行出队操作
                first.nextWaiter = null;
            } while (!transferForSignal(first) &amp;amp;&amp;amp;
                     (first = firstWaiter) != null);
             //2,如果条件队列中有ws =-2的节点，肯定会移出一个到同步队列中
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final boolean transferForSignal(Node node) {
       //1,将node ws更新为0 ,如果node 状态不等于CONDITION，一定是被取消了
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;
       //2,加入到同步队列中，返回的p是node的pre 
        Node p = enq(node);
        int ws = p.waitStatus;
       //3,如果前置节点被取消，或者更新p的 ws =-1 失败，直接唤醒线程，否则等待前置节点唤醒自己
        if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
           //唤醒线程
            LockSupport.unpark(node.thread);
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;1、Condition提供的阻塞通知机制与Object类两者对比：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法不同，Condition提供方法有 await(), signal(),signalAll(), Object类提供的是wait(),notify() , notifyAll()&lt;/li&gt;
&lt;li&gt;配合使用对象不同，Condition条件需要和Lock配合使用，Object类需和Synchronized关键字配合。&lt;/li&gt;
&lt;li&gt;多条件， Condition可实现多个条件，即创建多个Condition对象，可以每个Condition对象对应一种条件，从而有选择的实现唤醒通知，Object类的要唤醒一个阻塞线程，只能在一个条件队列中，唤醒是随机的，没有Condition使用灵活。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、注意区别Condition条件队列与同步队列两者的区别，2个队列中线程等待条件不同&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 23:57:00 +0000</pubDate>
<dc:creator>夕阳下飞奔的猪</dc:creator>
<og:description>AQS实现阻塞通知机制，作为Object类的wait,notify,notifyAll条件通知的另一个补充方案，可以让开发更加灵活易用！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydashpig/p/12122167.html</dc:identifier>
</item>
<item>
<title>MySQL基础篇(03)：系统和自定义函数总结，触发器使用详解 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12122604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12122604.html</guid>
<description>&lt;blockquote readability=&quot;1.8269230769231&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/mysql-data-base&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://github.com/cicadasmile/mysql-data-base&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MySQL 有很多内置的函数，可以快速解决开发中的一些业务需求，大概包括流程控制函数，数值型函数、字符串型函数、日期时间函数、聚合函数等。以下列出了这些分类中常用的函数。&lt;/p&gt;
&lt;h2 id=&quot;控制流程函数&quot;&gt;1、控制流程函数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;case...when&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据值判断返回值，类比编程中的IF-ELSE判断。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- DEMO 01
SELECT CASE DATE_FORMAT(NOW(),'%Y-%m-%d') 
    WHEN '2019-12-29' THEN 'today' 
    WHEN '2019-12-28' THEN 'yesterday' 
    WHEN '2019-12-30' THEN 'tommor' 
    ELSE 'Unknow' END;
-- DEMO 02
SELECT (CASE WHEN 1&amp;gt;0 THEN 'true' ELSE 'false' END) AS result;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;if(expr1,expr2,expr3)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果表达式 expr1 是TRUE，则 IF()的返回值为expr2; 否则返回值则为 expr3。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT IF(1&amp;gt;2,'1&amp;gt;2','1&amp;lt;2') AS result ; 
SELECT IF(1&amp;lt;2,'yes ','no') AS result ;
SELECT IF(STRCMP('test','test'),'no','yes');&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ifnull(expr1,expr2)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果表达式 expr1不为NULL，则返回值为expr1;否则返回值为 expr2。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT IFNULL(NULL,'cicada');
SELECT IFNULL(1/1,'no');&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常用字符串函数&quot;&gt;2、常用字符串函数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;CHAR_LENGTH()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;返回值为字符串的长度 。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT CHAR_LENGTH(' c i c ') ;-- 包含空格
SELECT LENGTH(' S q l ') ;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CONCAT(str1...)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;拼接串联字符串。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT CONCAT('My', 'S', 'ql');
SELECT CONCAT('My', NULL, 'QL'); -- 包含Null 则返回Null
SELECT CONCAT(&quot;%&quot;, &quot;Java&quot;, &quot;%&quot;); -- mybatis中拼接模糊查询&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ELT(N,str1,str2,...)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若N = 1，则返回值为 str1 ，若N = 2，则返回值为 str2 ，以此类推，可以用来转换返回页面的状态。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT ELT(1,'提交','审核中','规则通过') ;
SELECT ELT(2,'提交','审核中','规则通过') ;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;FORMAT(X,D)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;格式化数字类型。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT FORMAT(3.1455,2) ; -- 四舍五入保留两位
SELECT TRUNCATE(3.1455,2) ; -- 直接截取两位&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清空字符串空格。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT LTRIM('  hel l o ') ;-- 清空左边
SELECT RTRIM('  hel l o ') ;-- 清空右边
SELECT TRIM('  hel l o ') ; -- 清空两边
SELECT REPLACE('M y S Q L',' ','') ; -- 替换掉全部空格&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数值函数&quot;&gt;3、数值函数&lt;/h2&gt;
&lt;p&gt;返回不大于X的最大整数值 。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT FLOOR(1.23); -- 1
SELECT FLOOR(-1.23); -- -2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模操作。返回N 被 M除后的余数。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT MOD(29,9); -- 2
SELECT 29 MOD 9; -- 2&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;RAND() RAND(N)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;返回一个随机浮点值，范围在0到1之间。若已指定一个整数参数 N ，则它被用作种子值，用来产生重复序列。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT RAND(); -- 0.923
SELECT RAND(20) = RAND(20) ; -- TRUE&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;时间日期函数&quot;&gt;4、时间日期函数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ADDDATE(date,INTERVAL expr type)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;给指定日期，以指定类型进行运算。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT DATE_ADD('2019-12-29', INTERVAL 3 DAY); -- 2020-01-01&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将当前日期按照'YYYY-MM-DD' 或YYYYMMDD 格式的值返回，具体格式根据函数用在字符串或是数字语境中而定。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT CURDATE(); -- '2019-12-29' 字符串
SELECT CURDATE() + 0; -- 20180725 数字&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;DATE(expr)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;提取日期或时间日期表达式expr中的日期部分。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT DATE('2019-12-31 01:02:03'); -- '2019-12-31'
SELECT DATE('2019-12-31 01:02:03')+0; -- 20191231&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;DATE_FORMAT(date,format)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据format 字符串进行 date 值的格式化。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT DATE_FORMAT(NOW(), '%Y-%m-%d'); -- 2019-12-29
SELECT DATE_FORMAT(NOW(), '%Y年%m月%d日'); -- 2019年12月29日&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;聚合函数&quot;&gt;5、聚合函数&lt;/h2&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;AVG([distinct] expr)  求平均值
COUNT({*|[distinct] } expr)  统计行的数量
MAX([distinct] expr)  求最大值
MIN([distinct] expr)  求最小值
SUM([distinct] expr)  求累加和&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;概念简介&quot;&gt;1、概念简介&lt;/h2&gt;
&lt;p&gt;函数存储着一系列sql语句，调用函数就是一次性执行这些语句。所以函数可以降低语句重复。函数注重返回值，而触发器注重执行过程，所以一些语句无法执行。所以函数并不是单纯的sql语句集合。&lt;/p&gt;
&lt;h2 id=&quot;使用方式&quot;&gt;2、使用方式&lt;/h2&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create function 函数名([参数列表]) returns 数据类型
begin
 sql语句;
 return 值;
end;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数列表的格式是： 变量名 数据类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无参案例&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE FUNCTION mysum1 () RETURNS INT RETURN (2+3)*2;
SELECT mysum1 () ;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;有参函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;表结构&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE t01_user (
    id int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY  COMMENT '主键ID',
  user_name varchar(20) DEFAULT NULL COMMENT '用户名称'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '用户表';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;函数用法&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create function get_name(p_id INT) returns VARCHAR(20)
begin 
    declare userName varchar(20);
    select user_name from t01_user where id=p_id into userName;
    return userName;
end;

SELECT get_name(1) ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数查看&quot;&gt;3、函数查看&lt;/h2&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;show create function get_name ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除函数&quot;&gt;4、删除函数&lt;/h2&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;drop function get_name ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数注意事项&quot;&gt;5、函数注意事项&lt;/h2&gt;
&lt;p&gt;函数是事先经过编译，才能在服务器环境调用，所以MySQL集群环境需要同步编译；MySQL是多线程环境，所以要保证函数也是线程安全 。&lt;/p&gt;

&lt;h2 id=&quot;触发器简介&quot;&gt;1、触发器简介&lt;/h2&gt;
&lt;p&gt;触发器是特殊的存储过程，不同的是存储过程要用CALL来调用，而触发器不需要使用CALL。也不需要手工启动，只要当一个预定义的事件发生的时候，就会被MYSQL自动触发调用。&lt;/p&gt;
&lt;h2 id=&quot;创建触发器&quot;&gt;2、创建触发器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;触发器语法&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TRIGGER trigger_name trigger_time trigger_event 
ON tbl_name FOR EACH ROW trigger_stmt&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;trigger_name：触发器命名 ;&lt;/li&gt;
&lt;li&gt;trigger_time: 触发动作的时间 ;&lt;/li&gt;
&lt;li&gt;trigger_event: 激活触发器的语句类型 ;&lt;/li&gt;
&lt;li&gt;tbl_name: 触发器作用的表明，非临时表 ;&lt;/li&gt;
&lt;li&gt;trigger_stmt：触发程序执行的语句 ;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;表数据同步&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当向用户表 &lt;code&gt;t01_user&lt;/code&gt; 写入数据时，同时向 &lt;code&gt;t02_back&lt;/code&gt; 表写入一份备份数据。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 用户备份表
CREATE TABLE t02_back (
    id int(11) NOT NULL PRIMARY KEY COMMENT '主键ID',
  user_name varchar(20) DEFAULT NULL COMMENT '用户名称'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '用户备份';

-- 触发器程序
DROP TRIGGER IF EXISTS user_back_trigger ;
CREATE TRIGGER user_back_trigger AFTER INSERT ON t01_user FOR EACH ROW
BEGIN
    INSERT INTO t02_back (id,user_name)
VALUES (new.id,new.user_name);
END ;

-- 测试案例
INSERT INTO t01_user (user_name) VALUES ('smile'),('mysql') ;
SELECT * FROM t02_back ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看触发器&quot;&gt;3、查看触发器&lt;/h2&gt;
&lt;p&gt;查看触发器是指数据库中已存在的触发器的定义、状态、语法信息等。可以在TRIGGERS表中查看触发器信息。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT * FROM `information_schema`.`TRIGGERS` 
WHERE `TRIGGER_NAME`='user_back_trigger';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除触发器&quot;&gt;4、删除触发器&lt;/h2&gt;
&lt;p&gt;DROP TRIGGER语句可以删除MYSQL中已经定义的触发器，删除触发器的基本语法。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DROP TRIGGER [schema_name.]trigger_name&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;触发器注意事项&quot;&gt;5、触发器注意事项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;触发事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于相同的表，相同的事件只能创建一个触发器，比如对表t01_user创建两次AFTER INSERT触发器，就会报错。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行效率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;触发器可以减少应用端和数据库的通信次数和业务逻辑，但是基于行触发的逻辑，如果数据集非常大，效率会降低。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事务问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;触发器执行和原表的执行语句是否在同一个事务中，取决于触发表的存储引擎是否支持事务。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/mysql-data-base
GitEE·地址
https://gitee.com/cicadasmile/mysql-data-base&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 23:56:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、系统封装函数 MySQL 有很多内置的函数，可以快速解决开发中的一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12122604.html</dc:identifier>
</item>
<item>
<title>Linux里DNS服务器的主从搭建以及mariadb编译安装实现 - qiuhom</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12111497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12111497.html</guid>
<description>&lt;p data-reactid=&quot;.0.1.0.1.3.0:$2.$2&quot;&gt;　　DNS（Domain Name Service）它是应用层协议，C/S架构，默认工作在TCP和UDP的53号端口，服务器软件bind是由美国伯克利大学研发，它的主要作用是把互联网域名解析成对应的ip地址，从而实现访问远端主机的需求。以访问www.baidu.com为例来说说DNS的工作流程；首先浏览器访问www.baidu.com，它会先去本机的/etc/hosts文件中查看有没有www.baidu.com记录，如果有，它就会拿着对应的ip去访问，如没有那么它就会去问我们主机上配置的DNS服务器（比如小区DNS服务器，各个网络运营上的DNS服务器），如果在主机指定的DNS服务器上能够查到对应的ip，DNS服务器会把对应的ip告诉浏览器，从而浏览器拿着给定这个ip去访问；如果指定的DNS服务器上没有对应的ip记录，那么指定的DNS会去根服务器问，说根服务器，我要访问www.baidu.com这台主机，请问你那里有它的ip记录吗？根查看了数据库文件后告诉来查的DNS服务说 我这里没有，但是com是我的子域我有com域的ip地址，你去问下com这个域吧，接着我们指定的那个DNS服务器又会拿着根给的com域的ip去问com，说com呀，我要访问www.baidu.com这台主机，请问你那里有它的ip记录吗？com查了下自己的数据库文件说，我这里没有，但是baidu这个域是我的子域，我把baidu这个域的地址给你，你去问下它吧；我们指定的DNS服务器又拿着com给的baidu.com的ip地址，去问baidu.com这个域，说我要访问www.baidu.com，请问你那里有它的ip记录吗？baidu.com一听，www.baidu.com不就是我本域的主机吗，它立马就告诉我们指定的DNS服务器说，我这里有www.baidu.com主机的地址，然后baidu.com就把对应的ip地址给了我们指定的DNS服务器，这时DNS服务器就把自己最后得到的ip地址在本机上缓存一份，然后把地址告诉我们浏览器，浏览器拿着这个地址直接去访问，这时浏览器拿到IP地址后就可以正常的访问到www.baidu.com这台主机后台的web服务。这就是DNS工作的大概流程，简单讲就是我们要去访问某台主机（非ip地址访问），首先会去/etc/hosts文件中查询是否有对应的ip记录，如果有，就拿着这个地址去访问，如果没有就会去找我们指定的DNS服务器问，如果指定的DNS服务器没有，它会帮着我们去根上问，去对应子域上问，问上一圈，如果还是没有，那么我们指定的DNS服务器就会告诉我们说没有你要访问的地址，如果有就告诉我们。&lt;/p&gt;&lt;p&gt;　　说明：从上面查出来的信息看，大概可以了解bind的配置文件是/etc/named.conf&lt;/p&gt;&lt;div data-reactid=&quot;.0.1.0.1.3.0:$3&quot; readability=&quot;257.5&quot;&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$3.$0&quot;&gt; 　　3)修改配置文件，修改 listen-on port 53 { 127.0.0.1; };为listen-on port 53 { localhost; }; 和修改allow-query     { localhost; }; 为allow-query     { any; };&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#grep -v &quot;^\//&quot; /etc/named.conf

options {
        listen-on port 53 { localhost; };
        listen-on-v6 port 53 { ::1; };
        directory       &quot;/var/named&quot;;
        dump-file       &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
        recursing-file  &quot;/var/named/data/named.recursing&quot;;
        secroots-file   &quot;/var/named/data/named.secroots&quot;;
        allow-query     { any; };

        /* 
         - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
         - If you are building a RECURSIVE (caching) DNS server, you need to enable 
           recursion. 
         - If your recursive DNS server has a public IP address, you MUST enable access 
           control to limit queries to your legitimate users. Failing to do so will
           cause your server to become part of large scale DNS amplification 
           attacks. Implementing BCP38 within your network would greatly
           reduce such attack surface 
        */
        recursion yes;

        dnssec-enable yes;
        dnssec-validation yes;

        /* Path to ISC DLV key */
        bindkeys-file &quot;/etc/named.root.key&quot;;

        managed-keys-directory &quot;/var/named/dynamic&quot;;

        pid-file &quot;/run/named/named.pid&quot;;
        session-keyfile &quot;/run/named/session.key&quot;;
};

logging {
        channel default_debug {
                file &quot;data/named.run&quot;;
                severity dynamic;
        };
};

zone &quot;.&quot; IN {
        type hint;
        file &quot;named.ca&quot;;
};

include &quot;/etc/named.rfc1912.zones&quot;;
include &quot;/etc/named.root.key&quot;;

[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：也可以选择注释listen-on port 53 { 127.0.0.1; };和allow-query     { localhost; }; 这两行，这个配置文件的注释同C语言注释一样，用&quot;//&quot;来注释 &lt;/p&gt;
&lt;p&gt;　　4）增加区域数据库文件的配置，从上面的配置文件中我们主要到最后两个include 的指令，其中include &quot;/etc/named.rfc1912.zones&quot;; 就是定义区域数据库文件的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat &amp;gt;&amp;gt; /etc/named.rfc1912.zones &amp;lt;&amp;lt; EOF
&amp;gt; zone &quot;test.com&quot; IN {
&amp;gt;         type master;
&amp;gt;         file &quot;test.com.zone&quot;;                                                                                                               
&amp;gt;     
&amp;gt; };
&amp;gt; EOF
[root@test ~]#tail -5 /etc/named.rfc1912.zones 
zone &quot;test.com&quot; IN {
        type master;
        file &quot;test.com.zone&quot;;                                                                                                               
    
};
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：以上配置是定义一个test.com的区域，其类型为master（主） ，区域数据库文件名为 “test.com.zone” ,这里需要注意这个文件名是相对域/var/named这个目录的，也就说区域数据库文件必须存放在/var/named这个目录下。这个工作目录的定义可从主配置文件中的directory 这个选项来指定或更改&lt;/p&gt;
&lt;p&gt;　　5）创建区域数据库文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /var/named/test.com.zone
$TTL 1D
@ IN SOA dns1 admin ( 0 1D 1H 1W 3H );
     NS  dns1
dns1 A   192.168.0.99
www  A   1.1.1.1
blog A   2.2.2.2
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：区域数据库文件的格式是name [TTL] IN rr_type value其中TTL可从全局继承，@可用于引用当前区域的名字，同一个名字可以通过多条记录定义多个不同的值；此时DNS服务器会以轮询方式响应。同一个值也可能有多个不同的定义名字；通过多个不同的名字指向同一个值进行定义；此仅表示通过多个不同的名字可以找到同一个主机；name: 当前区域的名字，例如“test.com”; value: 有多部分组成,1、 当前区域的主DNS服务器的FQDN，也可以使用当前区域的名字；2、当前区域管理员的邮箱地址；但地址中不能使用@符号，一般用.替换，例如admin.test.com.  3、主从服务区域传输相关定义以及否定的答案的统一的TTL;第一个数字表示序列号，第二个表示刷新时间，第三个表示主从服务器同步失败重试的时间间隔，第四个表示，从服务器同步失败后，多久数据文件内容过期，第五个表示缓存否定答案的TTL值。以上还需要注意的是名字没有以.结尾，默认会补上本域的名称&lt;/p&gt;
&lt;p&gt;　　6）检查主配置文件和区域数据库文件是否正确，然后在启动服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#named-checkconf 
[root@test ~]#named-checkzone test.com /var/named/test.com.zone 
zone test.com/IN: loaded serial 0
OK
[root@test ~]#systemctl start named
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7）测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#dig www.test.com @192.168.0.99

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.test.com @192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 14227
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;www.test.com.                  IN      A

;; ANSWER SECTION:
www.test.com.           86400   IN      A       1.1.1.1

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: 日 12月 29 23:29:46 CST 2019
;; MSG SIZE  rcvd: 92

[root@test ~]#dig blog.test.com @192.168.0.99    

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; blog.test.com @192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 62941
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;blog.test.com.                 IN      A

;; ANSWER SECTION:
blog.test.com.          86400   IN      A       2.2.2.2

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: 日 12月 29 23:29:57 CST 2019
;; MSG SIZE  rcvd: 93

[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：dig工具来自bind-utils这个包，这个包主要是测试工具，包括host工具，dig工具，nslookup工具等测试工具。从上面的测试数据看，正向主DNS服务是搭建成功的。&lt;/p&gt;
&lt;p&gt;　　8）在/etc/named.rfc1912.zones文件中添加反向区域文件的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#tail -4 /etc/named.rfc1912.zones
zone &quot;0.168.192.in-addr.arpa&quot; {
        type master;
        file &quot;192.168.0.zone&quot;;
};
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：反向DNS的区域必须将IP地址倒着写，且后面必须是.in-addr.arpa结尾  里面的文件名称可任意填写，这里的文件名称也是必须放在/var/named这个目录下，同正向区域数据文件放在一个目录&lt;/p&gt;
&lt;p&gt;　　9）创建反向区域数据文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /var/named/192.168.0.zone
$TTL 1D
@ IN SOA dns1 admin (0 3H 10M 1D 1H );
     NS  dns1
dns1 A   192.168.0.99
99   PTR dns1.test.com.
100  PTR www.test.com.
101  PTR blog.test.com.
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：反向区域数据库文件同正向区域数据库文件格式相同，反向记录必须是PTR 类型其他同正向区域数据库文件类似，这里还需要注意一点的是，PTR后面的域名必须以.结尾，否则它会默认给你补本域的信息上去。&lt;/p&gt;
&lt;p&gt;　　10）检查区域文件，重新读取配置文件，时期反向区域数据库文件生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#named-checkzone 192.168.0.zone /var/named/192.168.0.zone 
zone 192.168.0.zone/IN: loaded serial 0
OK
[root@test ~]#rndc reload
server reload successful
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　11)测试反向解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#dig -x 192.168.0.99 @192.168.0.99

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -x 192.168.0.99 @192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 61308
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;99.0.168.192.in-addr.arpa.     IN      PTR

;; ANSWER SECTION:
99.0.168.192.in-addr.arpa. 86400 IN     PTR     dns1.test.com.

;; AUTHORITY SECTION:
0.168.192.in-addr.arpa. 86400   IN      NS      dns1.0.168.192.in-addr.arpa.

;; ADDITIONAL SECTION:
dns1.0.168.192.in-addr.arpa. 86400 IN   A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: 日 12月 29 23:58:39 CST 2019
;; MSG SIZE  rcvd: 116

[root@test ~]#dig -x 192.168.0.100 @192.168.0.99

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -x 192.168.0.100 @192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 23462
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;100.0.168.192.in-addr.arpa.    IN      PTR

;; ANSWER SECTION:
100.0.168.192.in-addr.arpa. 86400 IN    PTR     www.test.com.

;; AUTHORITY SECTION:
0.168.192.in-addr.arpa. 86400   IN      NS      dns1.0.168.192.in-addr.arpa.

;; ADDITIONAL SECTION:
dns1.0.168.192.in-addr.arpa. 86400 IN   A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: 日 12月 29 23:58:50 CST 2019
;; MSG SIZE  rcvd: 116

[root@test ~]#dig -x 192.168.0.101 @192.168.0.99

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -x 192.168.0.101 @192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 17401
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;101.0.168.192.in-addr.arpa.    IN      PTR

;; ANSWER SECTION:
101.0.168.192.in-addr.arpa. 86400 IN    PTR     blog.test.com.

;; AUTHORITY SECTION:
0.168.192.in-addr.arpa. 86400   IN      NS      dns1.0.168.192.in-addr.arpa.

;; ADDITIONAL SECTION:
dns1.0.168.192.in-addr.arpa. 86400 IN   A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: 日 12月 29 23:58:58 CST 2019
;; MSG SIZE  rcvd: 117

[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到我们分别把192.168.0.99、100、101这三个主机对应的主机名给解析出来了，这里不要同前面的正向区域数据库中的数据混淆，这个反向解析可把不同的ip解析成相同的名字，这个和正向解析本质上没有联系。它相当于是两个不同的域，互不干扰。&lt;/p&gt;
&lt;p&gt;　　到此dns主服务器就搭建完毕，接下来实现DNS从服务器&lt;/p&gt;
&lt;p&gt;　　1）在上面的实验上把主服务器上的配置文件中添加 allow_transfer { 192.168.0.151;};,并且在其数据库文件中添加从服务器的NS记录 以及A记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#grep &quot;transfer&quot; /etc/named.conf
        allow-transfer  { 192.168.0.151; };
[root@test ~]#cat /var/named/test.com.zone 
$TTL 1D
@ IN SOA dns1 admin ( 0 1D 1H 1W 3H );
     NS  dns1
     NS  dns2
dns1 A   192.168.0.99
dns2 A   192.168.0.151
www  A   1.1.1.1
blog A   2.2.2.2
[root@test ~]#cat /var/named/192.168.0.zone
$TTL 1D
@ IN SOA dns1 admin (0 3H 10M 1D 1H );
     NS  dns1
     NS  dns2
dns1 A   192.168.0.99
dns2 A   192.168.0.151
99   PTR dns1.test.com.
100  PTR www.test.com.
101  PTR blog.test.com.
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）在从服务器上安装bind包，并在其配置文件中配置 allow-transfer {none;}; 并注释listen-on port 53 { 127.0.0.1; };和allow-query     { localhost; };&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#yum install -y bind
[root@test-node1 ~]#cat /etc/named.conf
……省略部分内容
options {
//      listen-on port 53 { 127.0.0.1; };
        listen-on-v6 port 53 { ::1; };
        directory       &quot;/var/named&quot;;
        dump-file       &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
//      allow-query     { localhost; };
        allow-transfer { none; };
        recursion yes;
……省略部分内容
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）在/etc/named.rfc1912.zonesz中配置区域数据文件信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#cat &amp;gt;&amp;gt; /etc/named.rfc1912.zones &amp;lt;&amp;lt; EOF
&amp;gt; zone &quot;test.com&quot; {
&amp;gt;     type slave;
&amp;gt;     masters {192.168.0.99;};
&amp;gt;     file &quot;slaves/test.com.zone&quot;;
&amp;gt; };
&amp;gt; EOF
[root@test-node1 ~]#cat &amp;gt;&amp;gt; /etc/named.rfc1912.zones &amp;lt;&amp;lt; EOF
&amp;gt; zone &quot;0.168.192.in-addr.arpa&quot; {
&amp;gt;     type slave;
&amp;gt;     masters { 192.168.0.99; }; 
&amp;gt;     file &quot;slaves/192.168.0.zone&quot;;
&amp;gt; };
&amp;gt; EOF
[root@test-node1 ~]#
[root@test-node1 ~]#tail /etc/named.rfc1912.zones
zone &quot;test.com&quot; {
    type slave;
    masters {192.168.0.99;};
    file &quot;slaves/test.com.zone&quot;;
};
zone &quot;0.168.192.in-addr.arpa&quot; {
    type slave;
    masters { 192.168.0.99; };
    file &quot;slaves/192.168.0.zone&quot;;
};
[root@test-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：在从服务器上需要写明区域的名称，类型配成slave，并指明masters ，后面的files 是同步文件的存放地，这个存放地需要named这个账号有写的权限，否则将无法完成同步&lt;/p&gt;
&lt;p&gt;　　4）在从服务器上检查配置文件，并启动服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#ll /var/named/slaves/
total 0
[root@test-node1 ~]#named-checkconf 
[root@test-node1 ~]#/etc/init.d/named start
Generating /etc/rndc.key:                                  [  OK  ]
Starting named:                                            [  OK  ]
[root@test-node1 ~]#ll /var/named/slaves/
total 8
-rw-r--r-- 1 named named 449 Dec 30 00:35 192.168.0.zone
-rw-r--r-- 1 named named 336 Dec 30 00:35 test.com.zone
[root@test-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：启动服务后可看到/var/named/slaves/目录下把我们需要的区域数据库文件给同步过来了，接下来测试，在另一台主机上把DNS1设置成主DNS服务器地址，DNS2设置成从DNS服务器地址，然后在主挂掉的情况下，看下从DNS是否可工作&lt;/p&gt;
&lt;p&gt;　　5）测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@ansible_centos6 ~]# cat /etc/resolv.conf 
# Generated by NetworkManager
nameserver 192.168.0.99
nameserver 192.168.0.151
[root@ansible_centos6 ~]# dig www.test.com

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.2rc1-RedHat-9.8.2-0.62.rc1.el6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.test.com
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 22293
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1

;; QUESTION SECTION:
;www.test.com.                  IN      A

;; ANSWER SECTION:
www.test.com.           86400   IN      A       1.1.1.1

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 4 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: Mon Dec 30 00:46:46 2019
;; MSG SIZE  rcvd: 81

[root@ansible_centos6 ~]# dig -x 192.168.0.99

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.2rc1-RedHat-9.8.2-0.62.rc1.el6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -x 192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 48024
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1

;; QUESTION SECTION:
;99.0.168.192.in-addr.arpa.     IN      PTR

;; ANSWER SECTION:
99.0.168.192.in-addr.arpa. 86400 IN     PTR     dns1.test.com.

;; AUTHORITY SECTION:
0.168.192.in-addr.arpa. 86400   IN      NS      dns1.0.168.192.in-addr.arpa.

;; ADDITIONAL SECTION:
dns1.0.168.192.in-addr.arpa. 86400 IN   A       192.168.0.99

;; Query time: 3 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: Mon Dec 30 00:47:00 2019
;; MSG SIZE  rcvd: 105

[root@ansible_centos6 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这是主DNS存活情况下的测试是可以正常解析&lt;/p&gt;
&lt;p&gt;　　主DNS挂掉的情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@ansible_centos6 ~]# dig www.test.com

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.2rc1-RedHat-9.8.2-0.62.rc1.el6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.test.com
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 21730
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1

;; QUESTION SECTION:
;www.test.com.                  IN      A

;; ANSWER SECTION:
www.test.com.           86400   IN      A       1.1.1.1

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 1 msec
;; SERVER: 192.168.0.151#53(192.168.0.151)
;; WHEN: Mon Dec 30 00:50:43 2019
;; MSG SIZE  rcvd: 81

[root@ansible_centos6 ~]# dig -x 192.168.0.99

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.2rc1-RedHat-9.8.2-0.62.rc1.el6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -x 192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 63933
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1

;; QUESTION SECTION:
;99.0.168.192.in-addr.arpa.     IN      PTR

;; ANSWER SECTION:
99.0.168.192.in-addr.arpa. 86400 IN     PTR     dns1.test.com.

;; AUTHORITY SECTION:
0.168.192.in-addr.arpa. 86400   IN      NS      dns1.0.168.192.in-addr.arpa.

;; ADDITIONAL SECTION:
dns1.0.168.192.in-addr.arpa. 86400 IN   A       192.168.0.99

;; Query time: 1 msec
;; SERVER: 192.168.0.151#53(192.168.0.151)
;; WHEN: Mon Dec 30 00:50:55 2019
;; MSG SIZE  rcvd: 105

[root@ansible_centos6 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到主DNS服务器挂掉，从服务器是可以提供服务的，况且查询的内容同主的一模一样&lt;/p&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$3.$1&quot;&gt;2、搭建并实现智能DNS。&lt;/p&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$3.$2&quot;&gt; 　  1）在上面的实验环境中，更改配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /etc/named.conf
//
// named.conf
//
// Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
// server as a caching only nameserver (as a localhost DNS resolver only).
//
// See /usr/share/doc/bind*/sample/ for example named configuration files.
//
// See the BIND Administrator's Reference Manual (ARM) for details about the
// configuration located in /usr/share/doc/bind-{version}/Bv9ARM.html
acl cdnet {
        192.168.0.0/24;
};
acl bjnet {
        172.16.1.0/24;
};
acl shnet {
        any;
};
options {
        listen-on port 53 { localhost; };
        listen-on-v6 port 53 { ::1; };
        directory       &quot;/var/named&quot;;
        dump-file       &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
        recursing-file  &quot;/var/named/data/named.recursing&quot;;
        secroots-file   &quot;/var/named/data/named.secroots&quot;;
        allow-query     { any; };
        allow-transfer  { 192.168.0.151; };
        /* 
         - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
         - If you are building a RECURSIVE (caching) DNS server, you need to enable 
           recursion. 
         - If your recursive DNS server has a public IP address, you MUST enable access 
           control to limit queries to your legitimate users. Failing to do so will
           cause your server to become part of large scale DNS amplification 
           attacks. Implementing BCP38 within your network would greatly
           reduce such attack surface 
        */
        recursion yes;

        dnssec-enable yes;
        dnssec-validation yes;

        /* Path to ISC DLV key */
        bindkeys-file &quot;/etc/named.root.key&quot;;

        managed-keys-directory &quot;/var/named/dynamic&quot;;

        pid-file &quot;/run/named/named.pid&quot;;
        session-keyfile &quot;/run/named/session.key&quot;;
};

logging {
        channel default_debug {
                file &quot;data/named.run&quot;;
                severity dynamic;
        };
};


include &quot;/etc/named.root.key&quot;;
view  view_cd {
        match-clients {cdnet;};
        include &quot;/etc/named.zone.cd&quot;;
        include &quot;/etc/named.rfc1912.zones&quot;;
};
view view_bj {
        match-clients { bjnet; };
        include &quot;/etc/named.zone.bj&quot;;
        include &quot;/etc/named.rfc1912.zones&quot;;
};
view view_sh {
        match-clients { shnet; };
        include &quot;/etc/named.zone.sh&quot;；
        include &quot;/etc/named.rfc1912.zones&quot;;
};
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这个是主配置文件，主要添加了 3段acl和3段view 这里需要注意一点的是，一旦配置了view，所有的区域配置必须写在view中，所有我们还需要把根区域的配置文件到/etc/named.rfc1912.zones里 ，然后在view 里用include 把区域配置文件导入即可，借鉴上面的思想，我们也可以把不同地区的区域配置文件也用不同的文件给存起来，实现方便管理，然后也用include 指定导入到各自的view，这样就实现了 不同的网络客户端，访问不同的区域文件。最后我们还需要建立各自的区域数据库文件。&lt;/p&gt;
&lt;p&gt;　　2）把根区域配置文件放入到/etc/named.rfc1912.zones&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /etc/named.rfc1912.zones
// named.rfc1912.zones:
//
// Provided by Red Hat caching-nameserver package 
//
// ISC BIND named zone configuration for zones recommended by
// RFC 1912 section 4.1 : localhost TLDs and address zones
// and http://www.ietf.org/internet-drafts/draft-ietf-dnsop-default-local-zones-02.txt
// (c)2007 R W Franks
// 
// See /usr/share/doc/bind*/sample/ for example named configuration files.
//
zone &quot;.&quot; IN {
        type hint;
        file &quot;named.ca&quot;;
};
zone &quot;localhost.localdomain&quot; IN {
        type master;
        file &quot;named.localhost&quot;;
        allow-update { none; };
};

zone &quot;localhost&quot; IN {
        type master;
        file &quot;named.localhost&quot;;
        allow-update { none; };
};



zone &quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa&quot; IN {
        type master;
        file &quot;named.loopback&quot;;
        allow-update { none; };
};

zone &quot;1.0.0.127.in-addr.arpa&quot; IN {
        type master;
        file &quot;named.loopback&quot;;
        allow-update { none; };
};

zone &quot;0.in-addr.arpa&quot; IN {
        type master;
        file &quot;named.empty&quot;;
        allow-update { none; };
};


zone &quot;0.168.192.in-addr.arpa&quot; {
        type master;
        file &quot;192.168.0.zone&quot;;
};
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）创建各自的区域配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat &amp;gt;&amp;gt; /etc/named.zone.cd &amp;lt;&amp;lt; EOF
&amp;gt; zone &quot;test.com&quot; IN {
&amp;gt;     type master;
&amp;gt;     file &quot;test.com.zone.cd&quot;;
&amp;gt; };
&amp;gt; EOF
[root@test ~]#cat &amp;gt;&amp;gt; /etc/named.zone.bj &amp;lt;&amp;lt; EOF
&amp;gt; zone &quot;test.com&quot; IN {
&amp;gt;     type master;
&amp;gt;     file &quot;test.com.zone.bj&quot;;
&amp;gt; };
&amp;gt; EOF
[root@test ~]#cat &amp;gt;&amp;gt; /etc/named.zone.sh &amp;lt;&amp;lt; EOF
&amp;gt; zone &quot;test.com&quot; IN {
&amp;gt;     type master;
&amp;gt;     file &quot;test.com.zone.sh&quot;;
&amp;gt; };
&amp;gt; EOF
[root@test ~]#cat /etc/named.zone.cd 
zone &quot;test.com&quot; IN {
    type master;
    file &quot;test.com.zone.cd&quot;;
};
[root@test ~]#cat /etc/named.zone.bj
zone &quot;test.com&quot; IN {
    type master;
    file &quot;test.com.zone.bj&quot;;
};
[root@test ~]#cat /etc/named.zone.sh
zone &quot;test.com&quot; IN {
    type master;
    file &quot;test.com.zone.sh&quot;;
};
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）准备各自区域的数据库文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat /var/named/test.com.zone.cd 
$TTL 1D
@ IN SOA dns1 admin ( 0 2D 1H 3D 1D )
     NS  dns1
dns1  A  192.168.0.99
www   A  3.3.3.3
blog  A  4.4.4.4
[root@test ~]#cat /var/named/test.com.zone.bj
$TTL 1D
@ IN SOA dns1 admin ( 0 2D 1H 3D 1D )
     NS  dns1
dns1 A   192.168.0.99
www  A   5.5.5.5
blog A   6.6.6.6
[root@test ~]#cat /var/named/test.com.zone.sh
$TTL 1D
@  IN SOA dns1 admin ( 0 2D 1H 3D 1D )
      NS  dns1
dns1  A   192.168.0.99
www   A   7.7.7.7
blog  A   8.8.8.8
[root@test ~]#
[root@test ~]#ll /var/named/
总用量 36
-rw-r--r-- 1 root  root   188 12月 30 00:28 192.168.0.zone
drwxrwx--- 2 named named   23 12月 29 23:23 data
drwxrwx--- 2 named named   60 12月 30 01:01 dynamic
-rw-r----- 1 root  named 2253 4月   5 2018 named.ca
-rw-r----- 1 root  named  152 12月 15 2009 named.empty
-rw-r----- 1 root  named  152 6月  21 2007 named.localhost
-rw-r----- 1 root  named  168 12月 15 2009 named.loopback
drwxrwx--- 2 named named    6 8月   8 20:16 slaves
-rw-r--r-- 1 root  root   154 12月 30 00:10 test.com.zone
-rw-r--r-- 1 root  root   112 12月 30 21:33 test.com.zone.bj
-rw-r--r-- 1 root  root   112 12月 30 21:31 test.com.zone.cd
-rw-r--r-- 1 root  root   117 12月 30 21:35 test.com.zone.sh
[root@test ~]#find /var/named/ -name &quot;test.com.zone*&quot;
/var/named/test.com.zone
/var/named/test.com.zone.cd
/var/named/test.com.zone.bj
/var/named/test.com.zone.sh
[root@test ~]#find /var/named/ -name &quot;test.com.zone*&quot;|xargs chown root.named 
[root@test ~]#ll /var/named/
总用量 36
-rw-r--r-- 1 root  root   188 12月 30 00:28 192.168.0.zone
drwxrwx--- 2 named named   23 12月 29 23:23 data
drwxrwx--- 2 named named   60 12月 30 01:01 dynamic
-rw-r----- 1 root  named 2253 4月   5 2018 named.ca
-rw-r----- 1 root  named  152 12月 15 2009 named.empty
-rw-r----- 1 root  named  152 6月  21 2007 named.localhost
-rw-r----- 1 root  named  168 12月 15 2009 named.loopback
drwxrwx--- 2 named named    6 8月   8 20:16 slaves
-rw-r--r-- 1 root  named  154 12月 30 00:10 test.com.zone
-rw-r--r-- 1 root  named  112 12月 30 21:33 test.com.zone.bj
-rw-r--r-- 1 root  named  112 12月 30 21:31 test.com.zone.cd
-rw-r--r-- 1 root  named  117 12月 30 21:35 test.com.zone.sh
[root@test ~]#
[root@test ~]#find /var/named/ -name &quot;test.com.zone*&quot;|xargs chmod o-r
[root@test ~]#ll /var/named/
总用量 36
-rw-r--r-- 1 root  root   188 12月 30 00:28 192.168.0.zone
drwxrwx--- 2 named named   23 12月 29 23:23 data
drwxrwx--- 2 named named   60 12月 30 01:01 dynamic
-rw-r----- 1 root  named 2253 4月   5 2018 named.ca
-rw-r----- 1 root  named  152 12月 15 2009 named.empty
-rw-r----- 1 root  named  152 6月  21 2007 named.localhost
-rw-r----- 1 root  named  168 12月 15 2009 named.loopback
drwxrwx--- 2 named named    6 8月   8 20:16 slaves
-rw-r----- 1 root  named  154 12月 30 00:10 test.com.zone
-rw-r----- 1 root  named  112 12月 30 21:33 test.com.zone.bj
-rw-r----- 1 root  named  112 12月 30 21:31 test.com.zone.cd
-rw-r----- 1 root  named  117 12月 30 21:35 test.com.zone.sh
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：通过上面的配置后，我们最终希望各自的地区的用户访问各自区域的数据文件，从而实现了不同区域的用户，获取不同ip地址信息。这里还是建议把新建的权限属组给改成named,虽然不改是可以的，但是权限比较大，应该只允许named有读权限就好了。&lt;/p&gt;
&lt;p&gt;　　5）检查配置文件，重启服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#named-checkconf 
[root@test ~]#named-checkzone test.com /var/named/test.com.zone.cd
zone test.com/IN: loaded serial 0
OK
[root@test ~]#named-checkzone test.com /var/named/test.com.zone.bj
zone test.com/IN: loaded serial 0
OK
[root@test ~]#named-checkzone test.com /var/named/test.com.zone.sh
zone test.com/IN: loaded serial 0
OK
[root@test ~]#rndc reload
server reload successful
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6）测试&lt;/p&gt;
&lt;p&gt;模拟成都的用户访问DNS&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[qiuhom@test-node1 ~]$ip a l
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:24:81:68:ce:45 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.151/24 brd 192.168.0.255 scope global eth0
    inet6 fe80::224:81ff:fe68:ce45/64 scope link 
       valid_lft forever preferred_lft forever
[qiuhom@test-node1 ~]$
[qiuhom@test-node1 ~]$dig www.test.com @192.168.0.99

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6_10.3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.test.com @192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 51022
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1

;; QUESTION SECTION:
;www.test.com.                  IN      A

;; ANSWER SECTION:
www.test.com.           86400   IN      A       3.3.3.3

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 2 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: Mon Dec 30 22:20:02 2019
;; MSG SIZE  rcvd: 81

[qiuhom@test-node1 ~]$dig blog.test.com @192.168.0.99   

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6_10.3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; blog.test.com @192.168.0.99
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 4979
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1

;; QUESTION SECTION:
;blog.test.com.                 IN      A

;; ANSWER SECTION:
blog.test.com.          86400   IN      A       4.4.4.4

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 1 msec
;; SERVER: 192.168.0.99#53(192.168.0.99)
;; WHEN: Mon Dec 30 22:20:12 2019
;; MSG SIZE  rcvd: 82

[qiuhom@test-node1 ~]$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明:通过192.168.0.0/24主机访问的结果是指定view里指定的数据库文件的内容.&lt;/p&gt;
&lt;p&gt;　　模拟北京的用户访问DNS&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#ip a l
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp2s0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:30:18:51:af:3c brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.99/24 brd 192.168.0.255 scope global noprefixroute enp2s0
       valid_lft forever preferred_lft forever
    inet 172.16.1.2/16 brd 172.16.255.255 scope global noprefixroute enp2s0:0
       valid_lft forever preferred_lft forever
    inet6 fe80::230:18ff:fe51:af3c/64 scope link 
       valid_lft forever preferred_lft forever
3: enp3s0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
    link/ether 00:30:18:51:af:3d brd ff:ff:ff:ff:ff:ff
4: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:d6:07:f1:b0 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
[root@test ~]#dig www.test.com @172.16.1.2

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.test.com @172.16.1.2
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 33773
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;www.test.com.                  IN      A

;; ANSWER SECTION:
www.test.com.           86400   IN      A       5.5.5.5

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 172.16.1.2#53(172.16.1.2)
;; WHEN: 一 12月 30 22:24:07 CST 2019
;; MSG SIZE  rcvd: 92

[root@test ~]#dig blog.test.com @172.16.1.2   

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; blog.test.com @172.16.1.2
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 8001
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;blog.test.com.                 IN      A

;; ANSWER SECTION:
blog.test.com.          86400   IN      A       6.6.6.6

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 172.16.1.2#53(172.16.1.2)
;; WHEN: 一 12月 30 22:24:18 CST 2019
;; MSG SIZE  rcvd: 93

[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　模拟上海的用户访问DNS&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#dig www.test.com @127.0.0.1

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.test.com @127.0.0.1
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 50994
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;www.test.com.                  IN      A

;; ANSWER SECTION:
www.test.com.           86400   IN      A       7.7.7.7

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 127.0.0.1#53(127.0.0.1)
;; WHEN: 一 12月 30 22:25:52 CST 2019
;; MSG SIZE  rcvd: 92

[root@test ~]#dig blog.test.com @127.0.0.1   

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; blog.test.com @127.0.0.1
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 10062
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;blog.test.com.                 IN      A

;; ANSWER SECTION:
blog.test.com.          86400   IN      A       8.8.8.8

;; AUTHORITY SECTION:
test.com.               86400   IN      NS      dns1.test.com.

;; ADDITIONAL SECTION:
dns1.test.com.          86400   IN      A       192.168.0.99

;; Query time: 0 msec
;; SERVER: 127.0.0.1#53(127.0.0.1)
;; WHEN: 一 12月 30 22:25:58 CST 2019
;; MSG SIZE  rcvd: 93

[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：在本机使用127.0.0.1 去查，named会走回环地址去访问DNS，这个时候acl就会匹配到shnet ，从而访问view_sh说指定的区域数据库文件内容。这里要注意一点就是acl它默认是从上往下匹配，若匹配到就不往下匹配，所以127.0.0.1 既不属于192.168.0.0/24 这个网络，也不属于172.16.1.0/24这个网络，所以它会被any匹配到。&lt;/p&gt;
&lt;p&gt;　　到此智能DNS的搭建就完成了，事实上智能DNS的主要作用就是智能的区分不同来源的用户访问不同的区域文件，从而实现用户访问到的DNS是离自己最近的服务器，在互联网中的应用有CDN（内容分发网络），它的背后实现就是智能DNS。把不同的区域的用户通过智能DNS分别分向不同地区的DNS服务器上去，从而实现了用户访问网站的服务器是离自己最近的服务器，CDN实现了加快用户的访问同时还减轻了网站主服务器的压力和带宽。&lt;/p&gt;
&lt;/div&gt;&lt;div data-reactid=&quot;.0.1.0.1.3.0:$4&quot; readability=&quot;81.5&quot;&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$4.$1&quot;&gt;3、编译安装Mariadb，并启动后可以正常登录&lt;/p&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$4.$1&quot;&gt;　　1）准备源码包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%   70172 KB 23390 KB/s 00:00:03       0 Errors..

[root@test ~]#ls mariadb-10.2.19.tar.gz 
mariadb-10.2.19.tar.gz
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）安装依赖环境包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# yum install bison bison-devel zlib-devel libcurl-devel libarchive-devel boost-devel gcc gcc-c++ cmake ncurses-devel gnutls-devel libxml2-devel openssl-devel libevent-devel libaio-devel -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）创建系统账号，并解压源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# useradd -r -s /sbin/nologin -d /app/mysql/ mysql
[root@test ~]# getent passwd mysql
mariadb:x:989:983::/app/mysql/:/sbin/nologin
[root@test ~]# tar xf mariadb-10.2.19.tar.gz 
[root@test ~]# cd mariadb-10.2.19/
[root@test mariadb-10.2.19]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）cmake 编译并指定编译选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cmake . \
-DCMAKE_INSTALL_PREFIX=/app/mysql \
-DMYSQL_DATADIR=/data/mysql/ \
-DSYSCONFDIR=/etc/mysql \
-DMYSQL_USER=mysql \
-DWITH_INNOBASE_STORAGE_ENGINE=1 \
-DWITH_ARCHIVE_STORAGE_ENGINE=1 \
-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \
-DWITH_PARTITION_STORAGE_ENGINE=1 \
-DWITHOUT_MROONGA_STORAGE_ENGINE=1 \
-DWITH_DEBUG=0 \
-DWITH_READLINE=1 \
-DWITH_SSL=system \
-DWITH_ZLIB=system \
-DWITH_LIBWRAP=0 \
-DENABLED_LOCAL_INFILE=1 \
-DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock \
-DDEFAULT_CHARSET=utf8 \
-DDEFAULT_COLLATION=utf8_general_ci
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：如果出错需要删除 CMakeCache.txt 然后重新在用cmake指定编译选项生成makefile文件，在编译&lt;/p&gt;
&lt;p&gt;　　5）上面cmake没有错误的情况下，在执行make &amp;amp;&amp;amp; make install &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
……省略部分内容
-- Looking for krb5_free_unparsed_name
-- Looking for krb5_free_unparsed_name - found
-- Looking for event.h
-- Looking for event.h - found
-- Configuring done
-- Generating done
-- Build files have been written to: /root/mariadb-10.2.19
[root@test mariadb-10.2.19]#  make -j 4 &amp;amp;&amp;amp; make install 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：make -j 表示指定多少线程来编译，-j 4 表示用4个线程同时来编译，这是一种多线程的编译方式&lt;/p&gt;
&lt;p&gt;　　6）准备path环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# echo 'PATH=/app/mysql/bin:$PATH' &amp;gt; /etc/profile.d/mysql.sh
[root@test ~]# cat /etc/profile.d/mysql.sh
PATH=/app/mysql/bin:$PATH
[root@test ~]# . /etc/profile.d/mysql.sh
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7）生成数据库文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# cd /app/mysql/
[root@test mysql]# scripts/mysql_install_db --datadir=/data/mysql/ --user=mysql
Installing MariaDB/MySQL system tables in '/data/mysql/' ...
OK

To start mysqld at boot time you have to copy
support-files/mysql.server to the right place for your system


PLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !
To do so, start the server, then issue the following commands:

'./bin/mysqladmin' -u root password 'new-password'
'./bin/mysqladmin' -u root -h test password 'new-password'

Alternatively you can run:
'./bin/mysql_secure_installation'

which will also give you the option of removing the test
databases and anonymous user created by default.  This is
strongly recommended for production servers.

See the MariaDB Knowledgebase at http://mariadb.com/kb or the
MySQL manual for more instructions.

You can start the MariaDB daemon with:
cd '.' ; ./bin/mysqld_safe --datadir='/data/mysql/'

You can test the MariaDB daemon with mysql-test-run.pl
cd './mysql-test' ; perl mysql-test-run.pl

Please report any problems at http://mariadb.org/jira

The latest information about MariaDB is available at http://mariadb.org/.
You can find additional information about the MySQL part at:
http://dev.mysql.com
Consider joining MariaDB's strong and vibrant community:
https://mariadb.org/get-involved/

[root@test mysql]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8）准备配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test mysql]# cp /app/mysql/support-files/my-huge.cnf /etc/my.cnf
[root@test mysql]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　9）准备启动脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test mysql]# cp /app/mysql/support-files/mysql.server /etc/init.d/mysqld
[root@test mysql]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　10）启动服务 ，登录数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test mysql]# chkconfig --list

Note: This output shows SysV services only and does not include native
      systemd services. SysV configuration data might be overridden by native
      systemd configuration.

      If you want to list systemd services use 'systemctl list-unit-files'.
      To see services enabled on particular target use
      'systemctl list-dependencies [target]'.

netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off
network         0:off   1:off   2:on    3:on    4:on    5:on    6:off
[root@test mysql]# chkconfig --add mysqld
[root@test mysql]# chkconfig --list

Note: This output shows SysV services only and does not include native
      systemd services. SysV configuration data might be overridden by native
      systemd configuration.

      If you want to list systemd services use 'systemctl list-unit-files'.
      To see services enabled on particular target use
      'systemctl list-dependencies [target]'.

mysqld          0:off   1:off   2:on    3:on    4:on    5:on    6:off
netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off
network         0:off   1:off   2:on    3:on    4:on    5:on    6:off
[root@test mysql]# service mysqld start
Starting mysqld (via systemctl):                           [  OK  ]
[root@test mysql]# ss -ntl
State       Recv-Q Send-Q                    Local Address:Port                                   Peer Address:Port              
LISTEN      0      128                                   *:22                                                *:*                  
LISTEN      0      100                           127.0.0.1:25                                                *:*                  
LISTEN      0      128                                  :::22                                               :::*                  
LISTEN      0      100                                 ::1:25                                               :::*                  
LISTEN      0      80                                   :::3306                                             :::*                  
[root@test mysql]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 10
Server version: 10.2.19-MariaDB-log Source distribution

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
4 rows in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到此编译安装mariadb数据库就完成了。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 30 Dec 2019 18:03:00 +0000</pubDate>
<dc:creator>qiuhom</dc:creator>
<og:description>1、简述DNS服务器原理，并搭建主-辅服务器。 DNS服务器的工作原理 DNS（Domain Name Service）它是应用层协议，C/S架构，默认工作在TCP和UDP的53号端口，服务器软件bi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12111497.html</dc:identifier>
</item>
<item>
<title>数据库中间件分片算法之hash - BuddyYuan</title>
<link>http://www.cnblogs.com/buddy-yuan/p/12122482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buddy-yuan/p/12122482.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;夜深人静的时候，打开&lt;code&gt;云音乐&lt;/code&gt;，点上一曲&lt;code&gt;攀登&lt;/code&gt;，带上真无线蓝牙耳机，瞬间燃到爆，键盘打字如飞倦意全无。&lt;/p&gt;
&lt;h3 id=&quot;分片规则&quot;&gt;分片规则&lt;/h3&gt;
&lt;p&gt;这几天有人问我，dble和MyCat到底有什么不同。其实dble作为MyCAT的同门，吸收了MyCat的精华，同时也相应的做了一些减法。只支持MySQL显得更加的纯粹。所以选择对比学习两者我觉得挺好。&lt;/p&gt;
&lt;p&gt;前面我们学习了schema.xml文件的配置，我们能独立的把&lt;code&gt;逻辑库&lt;/code&gt;和&lt;code&gt;逻辑表&lt;/code&gt;搭建起来，让数据表跟随我们的定义规则(取模)进行分布。今天我们介绍具体的分片算法。&lt;code&gt;dble&lt;/code&gt;相对于&lt;code&gt;mycat&lt;/code&gt;来说，是做了一些减法的。比如一致hash算法就没有,而是使用了&lt;code&gt;jumpstringhash&lt;/code&gt;代替了一致性hash。具体原因可以参考文章&lt;code&gt;dble 沿用 jumpstringhash,移除 Mycat 一致性 hash 原因&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;hash分区算法&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stringhash分区算法&lt;/li&gt;
&lt;li&gt;enum分区算法&lt;/li&gt;
&lt;li&gt;numberrange分区算法&lt;/li&gt;
&lt;li&gt;patternrange分区算法&lt;/li&gt;
&lt;li&gt;date分区算法&lt;/li&gt;
&lt;li&gt;jumpstringhash算法&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hash分区算法&quot;&gt;HASH分区算法&lt;/h3&gt;
&lt;p&gt;Hash分区算法是一种比较典型而且常用的算法。要使用HASH分区算法需要在rule.xml中定义两个部分。&lt;/p&gt;
&lt;h4 id=&quot;分区规则定义&quot;&gt;分区规则定义&lt;/h4&gt;
&lt;p&gt;如下所示，使用&lt;code&gt;tableRule&lt;/code&gt;标签定义，name对应的是规则的名字，而&lt;code&gt;rule&lt;/code&gt;标签中的&lt;code&gt;columns&lt;/code&gt;则对应的分片字段，这个字段必须和表中的字段一致。&lt;code&gt;algorithm&lt;/code&gt;则代表了执行分片函数的名字。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;tableRule name=&quot;auto-sharding-long&quot;&amp;gt;
&amp;lt;rule&amp;gt;
&amp;lt;columns&amp;gt;id&amp;lt;/columns&amp;gt;
&amp;lt;algorithm&amp;gt;rang-long&amp;lt;/algorithm&amp;gt;
&amp;lt;/rule&amp;gt;
&amp;lt;/tableRule&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分区算法定义&quot;&gt;分区算法定义&lt;/h4&gt;
&lt;p&gt;如下所示，使用&lt;code&gt;function&lt;/code&gt;标签定义分区算法，name代表算法的名字，算法的名字要和上面的tableRule中的标签相对应。&lt;code&gt;class&lt;/code&gt;：指定分区算法实现类。&lt;code&gt;property&lt;/code&gt;指定了对应分区算法的参数。不同的算法参数不同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;function name=&quot;rang-long&quot; class=&quot;com.actiontech.dble.route.function.AutoPartitionByLong&quot;&amp;gt;
&amp;lt;property name=&quot;mapFile&quot;&amp;gt;auto-sharding-long.txt&amp;lt;/property&amp;gt;
...
&amp;lt;/function&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;partitionCount&lt;/code&gt;:指定分区的区间数，具体为 C1 +C2 + ... + Cn&lt;/li&gt;
&lt;li&gt;&lt;code&gt;partitionLength&lt;/code&gt;:指定各区间长度，具体区间划分为 [0, L1), [L1, 2L1), ..., [(C1-1)L1, C1L1), [C1L1, C1L1+L2), [C1L1+L2, C1L1+2L2), ... 其中，每一个区间对应一个数据节点。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;测试hash分区算法&quot;&gt;测试Hash分区算法&lt;/h3&gt;
&lt;h4 id=&quot;在启动的时候两个数组点乘做运算得到取模数&quot;&gt;1.在启动的时候，两个数组点乘做运算，得到取模数。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/6228430/hepkdo7ggq.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;两个数组进行叉乘得出物理分区表&quot;&gt;2.两个数组进行叉乘，得出物理分区表。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/6228430/i61dpz9ng1.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;根据where条件的值来落入实际分片&quot;&gt;3.根据where条件的值来落入实际分片&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;select * from shareding_key = 999;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先根据分片键取出999，按照公式1的计算结果除取模，然后得到的值落到2计算出来的分片中。&lt;/p&gt;
&lt;h4 id=&quot;举个简单的例子&quot;&gt;4.举个简单的例子:&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;property name=&quot;partitionCount&quot;&amp;gt;2,3&amp;lt;/property&amp;gt;
&amp;lt;property name=&quot;partitionLength&quot;&amp;gt;100,50&amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据公式1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/6228430/znen1gge1i.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是传进来的值需要对350取模。&lt;/p&gt;
&lt;p&gt;根据公式2,物理分区为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/6228430/fncy1hznj1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;999对350取模，正好是299。落在250-300这个区间里面。也就是第4个区间。&lt;/p&gt;
&lt;p&gt;接下来我们实际来测试一下，我们在rule.xml中设置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;tableRule name=&quot;rule_hash&quot;&amp;gt;
    &amp;lt;rule&amp;gt;
        &amp;lt;columns&amp;gt;id&amp;lt;/columns&amp;gt;
        &amp;lt;algorithm&amp;gt;func_hash_test&amp;lt;/algorithm&amp;gt;
    &amp;lt;/rule&amp;gt;
&amp;lt;/tableRule&amp;gt;

&amp;lt;function name=&quot;func_hash_test&quot; class=&quot;Hash&quot;&amp;gt;
    &amp;lt;property name=&quot;partitionCount&quot;&amp;gt;2,3&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;partitionLength&quot;&amp;gt;100,50&amp;lt;/property&amp;gt;
&amp;lt;/function&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过公式2算出有5个分片。所以在schema.xml中设置table属性如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;table name=&quot;hash_test&quot; primaryKey=&quot;id&quot; rule=&quot;rule_hash&quot; dataNode=&quot;dn1,dn2,dn3,dn4,dn5&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建表测试&quot;&gt;5.创建表测试&lt;/h4&gt;
&lt;p&gt;我们先使用shell创建1000行数据，在创建表，通过load data语法将我们shell产生的文件进行导入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for i in  {1..1000}
do
echo  $i'|name'$[i]'' &amp;gt;&amp;gt;a1.txt 
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/6228430/5szjyr7hy2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请原谅我作为一个GEEK，把桌面和终端完美结合成二次元是标配。&lt;/p&gt;
&lt;p&gt;这里可以看到我们查询999这个数据，会自动到dn4这个分片上进行查询。再比如我们查500,500对350取模是150，150是落在第二个分区里面的。&lt;/p&gt;
&lt;h4 id=&quot;另一个例子&quot;&gt;6.另一个例子&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;property name=&quot;partitionCount&quot;&amp;gt;2&amp;lt;/property&amp;gt;
&amp;lt;property name=&quot;partitionLength&quot;&amp;gt;1000&amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时C _L=2_1000=2000,将对2000进行取模。&lt;/p&gt;
&lt;p&gt;同时将划分如下的分区：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/6228430/gigl106ckl.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意事项&quot;&gt;注意事项&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;M不能大于2880。2880的原因是这样的:2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 30, 32, 36, 40, 45, 48, 60, 64, 72, 80, 90, 96, 120, 144, 160, 180, 192, 240, 288, 320, 360, 480, 576, 720, 960, 1440是2880的约数,这样预分片扩容方便。&lt;/li&gt;
&lt;li&gt;N必须要等于schema.xml中使用该分区算法的逻辑表的dataNode属性指定的DataNode数量之和，比如我们上面这个算法是5个分区，但是如果你在逻辑表的dataNode属性中设置分区个数小于5，dataNode=&quot;dn1,dn2,dn3,dn4&quot;，则dble就会报错。&lt;br/&gt;&lt;code&gt;partition size : 5 &amp;gt; table datanode size : 4 please make sure table datanode size = function partition size&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;$C_n$和$L_n$的个数必须相等。&lt;/li&gt;
&lt;li&gt;分区字段必须为整型字段，如果是其他类型，要求值可转化为数字。&lt;/li&gt;
&lt;li&gt;当partitionLength为1时，hash分区算法退化为求模算法，M及N均为partitionCount的值。&lt;/li&gt;
&lt;li&gt;NULL作为分片列的值的时候数据的结果恒落在0号节点(第一个节点上)，建议最好不要让这种情况出现，强制设置分片键为not null。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;今天学习了分片算法Hash。后续将继续分享其他的算法。谢谢支持！&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 17:31:00 +0000</pubDate>
<dc:creator>BuddyYuan</dc:creator>
<og:description>前言 夜深人静的时候，打开 ，点上一曲 ，带上真无线蓝牙耳机，瞬间燃到爆，键盘打字如飞倦意全无。 分片规则 这几天有人问我，dble和MyCat到底有什么不同。其实dble作为MyCAT的同门，吸收了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buddy-yuan/p/12122482.html</dc:identifier>
</item>
<item>
<title>实现 WebApi 自托管服务宿主于 WinForms 及其交互 - 心千</title>
<link>http://www.cnblogs.com/xixixiao/p/run-self-hosting-owin-web-api-inside-winforms.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xixixiao/p/run-self-hosting-owin-web-api-inside-winforms.html</guid>
<description>&lt;p&gt;在 Windows 平台 Web 服务一般托管于 IIS. 在开发中, 会遇到 WinForms 或 WPF 服务端程序需要提供对外 API 作为服务. 在本文详细介绍 WebApi 自托管于 WinForms 中, WPF 或 Console 程序实现类似.&lt;/p&gt;
&lt;h2 id=&quot;完整示例演示&quot;&gt;0. 完整示例演示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714921/201912/1714921-20191231001321458-1550438944.gif&quot; alt=&quot;示例演示&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建解决方案以及-winforms-工程&quot;&gt;1. 新建解决方案以及 WinForms 工程&lt;/h2&gt;
&lt;h3 id=&quot;新建解决方案及工程&quot;&gt;1.1 新建解决方案及工程&lt;/h3&gt;
&lt;p&gt;如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714921/201912/1714921-20191231001347828-171429829.png&quot; alt=&quot;解决方案结构&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;拖拽控件&quot;&gt;1.2 拖拽控件&lt;/h3&gt;
&lt;p&gt;绘制必要控件, 布局如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714921/201912/1714921-20191231001415006-245128803.png&quot; alt=&quot;窗体布局&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备注: 绘制一个 NumericUpDown 和两个 Button 控件.&lt;/p&gt;
&lt;h2 id=&quot;开发-http-服务类&quot;&gt;2. 开发 HTTP 服务类&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// HTTP service.
/// &amp;lt;/summary&amp;gt;
public class HttpService
{
    /// &amp;lt;summary&amp;gt;
    /// HTTP self hosting.
    /// &amp;lt;/summary&amp;gt;
    private HttpSelfHostServer _server;

    #region HTTP Service

    /// &amp;lt;summary&amp;gt;
    /// start HTTP server.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;port&quot;&amp;gt;the port of the http server&amp;lt;/param&amp;gt;
    public void StartHttpServer(string port)
    {
        var config = new HttpSelfHostConfiguration($&quot;http://0.0.0.0:{port}&quot;);

        config.MapHttpAttributeRoutes();
        config.Routes.MapHttpRoute(&quot;DefaultApi&quot;, &quot;api/{controller}/{action}&quot;);

        this._server = new HttpSelfHostServer(config);
        this._server.OpenAsync().Wait();
    }

    /// &amp;lt;summary&amp;gt;
    /// Close HTTP server.
    /// &amp;lt;/summary&amp;gt;
    public void CloseHttpServer()
    {
        this._server.CloseAsync().Wait();
        this._server.Dispose();
    }

    #endregion
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WebApi 自托管服务主要由 &lt;code&gt;HttpSelfHostServer&lt;/code&gt; 实现.&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;config.MapHttpAttributeRoutes();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在 &lt;code&gt;Controller&lt;/code&gt; 中使用路由特性.&lt;/p&gt;
&lt;h2 id=&quot;调用-http-服务&quot;&gt;3. 调用 HTTP 服务&lt;/h2&gt;
&lt;p&gt;在 MainForm 窗体程序中引用 HTTP 服务:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
public class MainForm:Form
{
    /// &amp;lt;summary&amp;gt;
    /// Http service.
    /// &amp;lt;/summary&amp;gt;
    private readonly HttpService _http;

    public MainForm()
    {
        /**
         * initialize http service.
         */
        _http = new HttpService();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写开启-http-服务代码&quot;&gt;3.1 编写开启 HTTP 服务代码&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// start the http server.
/// &amp;lt;/summary&amp;gt;
private void StartButton_Click(object sender, EventArgs e)
{
    /**
     * start.
     */
    try
    {
        var port = this.PortNum.Value;

        _http.StartHttpServer($&quot;{port}&quot;);
    }
    catch (Exception exception)
    {
        MessageBox.Show($&quot;{exception.Message}&quot;, &quot;Error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写关闭-http-服务代码&quot;&gt;3.2 编写关闭 HTTP 服务代码&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// close the http server.
/// &amp;lt;/summary&amp;gt;
private void CloseButton_Click(object sender, EventArgs e)
{
    /**
     * close.
     */
    try
    {
        _http.CloseHttpServer();

    }
    catch (Exception exception)
    {
        MessageBox.Show($&quot;{exception.Message}&quot;, &quot;Error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开发控制器&quot;&gt;4. 开发控制器&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Home controller.
/// &amp;lt;/summary&amp;gt;
[RoutePrefix(&quot;api/home&quot;)]
public class HomeController : ApiController
{
    /// &amp;lt;summary&amp;gt;
    /// Print the greetings
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;name&quot;&amp;gt;visitor&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;greetings&amp;lt;/returns&amp;gt;
    [Route(&quot;echo&quot;)]
    [HttpGet]
    public IHttpActionResult Echo(string name)
    {
        return Json(new {Name = name, Message = $&quot;Hello, {name}&quot;});
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;合在一起&quot;&gt;5. 合在一起&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714921/201912/1714921-20191231001438372-1882996356.png&quot; alt=&quot;解决方案完整结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xixixixixiao/xiao-blog/tree/master/solutions/SelfHostingDemo&quot;&gt;下载完整示例代码 (GitHub)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 16:18:00 +0000</pubDate>
<dc:creator>心千</dc:creator>
<og:description>在 Windows 平台 Web 服务一般托管于 IIS. 在开发中, 会遇到 WinForms 或 WPF 服务端程序需要提供对外 API 作为服务. 在本文详细介绍 WebApi 自托管于 Win</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xixixiao/p/run-self-hosting-owin-web-api-inside-winforms.html</dc:identifier>
</item>
<item>
<title>使用spring boot中的JPA操作数据库 - 久曲健</title>
<link>http://www.cnblogs.com/longronglang/p/12122220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longronglang/p/12122220.html</guid>
<description>&lt;div readability=&quot;9&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;Spring boot中的JPA 使用的同学都会感觉到他的强大，简直就是神器一般，通俗的说，根本不需要你写sql，这就帮你节省了很多时间，那么下面我们来一起来体验下这款神器吧。&lt;/p&gt;
&lt;h3&gt;一、在pom中添加依赖&lt;/h3&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-jpa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.0.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二、项目配置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201912/718867-20191230220440775-208564949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在application.yml中填写数据库及JPA相关配置信息（这样在dev和prod两个环境是可以共用的），示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 多环境配置
spring:
  profiles:
    active: prod

# 通用数据源配置
  datasource:
    driver&lt;/span&gt;-class-&lt;span&gt;name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3306/student_info?serverTimezone=GMT%2B8&lt;/span&gt;
&lt;span&gt;    username: root
    password: root
    hikari:
      maximum&lt;/span&gt;-pool-size: &lt;span&gt;20&lt;/span&gt;&lt;span&gt;
      minimum&lt;/span&gt;-idle: &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
  # JPA相关配置
  jpa:
    hibernate:
      ddl&lt;/span&gt;-&lt;span&gt;auto: create
    show&lt;/span&gt;-sql: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;说明：接口调试时，jpa中的ddl-auto:要改为update，否则每次运行都会清空数据哦！&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;编写好项目配置后，这里我们可以启动项目，会报错如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201912/718867-20191230220843882-1648715238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 这是因为我没创建这个库引起的，那么我们先把这个库创建起来，接着我们重新启动项目就不会报错了，还帮我们显示出了创建sql语句，是不是很赞呢，哈哈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201912/718867-20191230221158840-1402129094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;三、 数据库的操作&lt;/h3&gt;
&lt;p&gt;前面的项目基本搭建完成，下面我们通过增删改查的一系列操作，来完成数据库的操作。&lt;/p&gt;
&lt;h4&gt;1、创建一个实体&lt;/h4&gt;
&lt;p&gt;创建一个名为Student的类，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.rongrong.springboot.demo.student;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; rongrong
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 * @description:
 * @date 2019/12/30 21:24
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Entity
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主键ID&lt;/span&gt;
&lt;span&gt;    @Id
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自增型&lt;/span&gt;
&lt;span&gt;    @GeneratedValue
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String email;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2、数据库操作逻辑编写&lt;/h4&gt;


&lt;p&gt; 创建一个名为StudentResponstory的接口，继承JPAResponstory，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.rongrong.springboot.demo.student;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.jpa.repository.JpaRepository;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; rongrong
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 * @description:
 * @date 2019/12/30 22:20
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; StudentResponstory &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;Student,Integer&amp;gt;&lt;span&gt; {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个名为StudentController的类，通过增删改查操作，来实现库的操作逻辑，具体示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.rongrong.springboot.demo.student;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.web.bind.annotation.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; rongrong
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 * @description:
 * @date 2019/12/30 20:40
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentController {

    @Autowired
    StudentResponstory studentResponstory;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有学生列表
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/students&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Student&amp;gt;&lt;span&gt; sudentFindAll() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; studentResponstory.findAll();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 新增一个学生
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; age
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sex
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; email
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @PostMapping(&lt;/span&gt;&quot;/studentAdd&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Student sudentAdd(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;age&quot;&lt;span&gt;) Integer age,
                             @RequestParam(&lt;/span&gt;&quot;sex&quot;) String sex, @RequestParam(&quot;email&quot;&lt;span&gt;) String email) {
        Student student &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
        student.setName(name);
        student.setAge(age);
        student.setSex(sex);
        student.setEmail(email);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存和更新都用该方法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; studentResponstory.save(student);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过iD查找一个学生
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/sudentFindOne/{id}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Student sudentFindOne(@PathVariable(&quot;id&quot;&lt;span&gt;) Integer id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; studentResponstory.findOne(id);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过ID更新一个学生信息
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; age
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sex
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; email
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @PutMapping(&lt;/span&gt;&quot;/sudentUpdate/{id}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Student sudentUpdate(@PathVariable(&quot;id&quot;) Integer id, @RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;age&quot;&lt;span&gt;) Integer age,
                                @RequestParam(&lt;/span&gt;&quot;sex&quot;) String sex, @RequestParam(&quot;email&quot;&lt;span&gt;) String email) {
        Student student &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
        student.setId(id);
        student.setName(name);
        student.setAge(age);
        student.setSex(sex);
        student.setEmail(email);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存和更新都用该方法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; studentResponstory.save(student);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过ID删除一个学生
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @DeleteMapping(&lt;/span&gt;&quot;/sudentDelete/{id}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sudentDelete(@PathVariable(&quot;id&quot;&lt;span&gt;) Integer id) {
        studentResponstory.delete(id);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过年龄查询学生
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; age
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/sudentFindByAge/{age}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Student&amp;gt; sudentFindByAge(@PathVariable(&quot;age&quot;&lt;span&gt;) Integer age) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; studentResponstory.findByAge(age);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过年龄查询学生查询时，需要在接口中添加如下方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.rongrong.springboot.demo.student;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.jpa.repository.JpaRepository;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; rongrong
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 * @description:
 * @date 2019/12/30 22:20
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; StudentResponstory &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;Student,Integer&amp;gt;&lt;span&gt; {
    List&lt;/span&gt;&amp;lt;Student&amp;gt;&lt;span&gt; findByAge(Integer age);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次启动项目，通过postman进行逐一测试，即可。&lt;/p&gt;
&lt;h4&gt;项目启动效果图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201912/718867-20191230232712908-2072877175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;&lt;span&gt;postman效果图&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201912/718867-20191230232609843-1426204445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，spring boot中jpa的使用介绍完，有兴趣的同学可以自行尝试。&lt;/p&gt;

</description>
<pubDate>Mon, 30 Dec 2019 15:28:00 +0000</pubDate>
<dc:creator>久曲健</dc:creator>
<og:description>前言 Spring boot中的JPA 使用的同学都会感觉到他的强大，简直就是神器一般，通俗的说，根本不需要你写sql，这就帮你节省了很多时间，那么下面我们来一起来体验下这款神器吧。 一、在pom中添</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/longronglang/p/12122220.html</dc:identifier>
</item>
<item>
<title>.NET Core开发的iNeuOS工业互联平台，升级四大特性：配置数据接口、图元绑定数据、预警配置和自定义菜单 - 唯笑志在-ineuos.net</title>
<link>http://www.cnblogs.com/lsjwq/p/12122083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/12122083.html</guid>
<description>&lt;p class=&quot;a&quot;&gt;&lt;span&gt;目       录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.      概述... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.      演示信息... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.      iNeuView（Web组态）配置数据接口... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.      iNeuView（Web组态）图元绑定数据... 4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.      iNeuView（Web组态）图元和文本框配置预警... 5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.      iNeuView（Web组态）图元和文本框自定义右键菜单... 6&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;1.   概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        2019年即将结束，我们从2018年到现在，打了两年的基础，2020年是我们的发展元年，目标是带动群友5-10名人员一同发展。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        此次升级主要针对iNeuView的Web组态，进一步完善产品体系，包括：&lt;span&gt;&lt;strong&gt;每个组态页面可以配置数据接口、图元可以绑定数据点、图元和文本框根据绑定的数据点配置预警方案、图元和文本框可以自定义菜单项等&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      在线演示：&lt;a href=&quot;http://demo.ineuos.net&quot;&gt;http://demo.ineuos.net&lt;/a&gt;  （注：服务器比较慢，请耐心等待。自已注册用户，体验系统功能）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      视频演示：&lt;a href=&quot;http://www.ineuos.net/video/iNeuOS%20and%20app.mp4&quot;&gt;http://www.ineuos.net/video/iNeuOS%20and%20app.mp4&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      驱动开发：&lt;a href=&quot;http://www.ineuos.net/index.php/products/ineukernel-15.html&quot;&gt;http://www.ineuos.net/index.php/products/ineukernel-15.html&lt;/a&gt; （v2.1版本）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      手机APP：&lt;a href=&quot;http://demo.ineuos.net/app/ineuos_app.apk&quot;&gt;http://demo.ineuos.net/app/ineuos_app.apk&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      现在可以通过3种方式与iNeuView（Web组态）对接和应用：（1）通过iNeuKernel设备容器采集数据，与iNeuView（Web组态）一起应用。（2）通过Http API接口主动推送数据到平台，参见：《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/11415419.html&quot;&gt;第三方数据导入接口&lt;/a&gt;》第三方导入接口部分。（3）在iNeuView开发页面配置接口，主动读取数据。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230222757125-751355904.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;      需要配置三类数据接口：最新数据接口、历史数据接口和数据点接口。最新数据接口主要用于实时读取数据进行监测和预警；历史数据接口主要用于右键单击图元或文本框选择【查看趋势】；数据点接口主要用于选择【数据源】时显示数据点树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      历史数据接口对应的应用，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230222851559-1331218186.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;      数据点接口对应的应用，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230222924113-1813456939.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;      单击蓝色最新数据接口、历史数据接口和数据点接口文字，会显示帮助文档，规定的请求参数和返回的数据结构。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230222954360-1801335736.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;     不仅文本框可以绑定数据源，任意图元也可以绑定数据源。根据绑定的数据源获得实时数据值，根据数据值进一步判断当前状态，最终改变图元的颜色状态信息和显示效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在组态画布上选择一个图元，在右边的属性框里选择【数据源】，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230223043495-1127635341.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;    在弹出来的窗体选择相应的数据点，这个数据点树是在iNeuKernel设备容器里配置，根据配置信息后台服务会实时与“设备”进行交互，采集的数据会实时与iNeuView开发页面绑定的数据点进行实时交互，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230223109288-568162584.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;     图元和文本框可以配置预警方案，根据绑定的数据点的实时数据值自定义判断预警逻辑，进一步对报警运作、级别、报警颜色进行响应。选择页面上的任意图元，选择右边属性里的【报警配置】，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230223248341-1194676058.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     针对一个数据点可以配置多个预警方案，根据不同的判断逻辑做出不同的响应方式。对判断条件，可以自定义脚本进行二次开发。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230223323767-1975711796.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;     针对图元和文本框可以自定义右键菜单，主要面向两个方面的应用场景：1.把开发好的组态页面的分享链接挂载成右键菜单的应用；2.把其他系统的相关业务应用功能挂载成右键菜单的应用，Web组态与业务结合应用。选择任意图元和文本框，选择右边事件中的【右键菜单】，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230223356685-1251886799.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;    新建一个菜单项目，可以配置菜单名称、事件类型（现在只支持打开链接）、打开方式、高度和宽度等。下面的链接就是开发好的组态页面链接，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230223424070-1939221333.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;     正在运行的组态界面，右键单击编辑好的图元或文本框，可以显示刚刚编辑好的菜单项，单击后以窗体的形式打开配置好链接应用，与整个系统融为一体，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230223702002-1875156477.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;     以窗体的形式打开链接应用，如果挂载其他系统的应用链接，最好支持跨域访问，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201912/279374-20191230223807099-1199490159.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;文章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/11986460.html&quot;&gt;.NET Core开发的iNeuOS工业互联网平台，发布 iNeuDA 数据分析展示组件，快捷开发图形报表和数据大屏&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/11878753.html&quot;&gt;[视频演示].NET Core开发的iNeuOS物联网平台，实现从设备&amp;amp;PLC、云平台、移动APP数据链路闭环&lt;/a&gt; 》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/11716909.html&quot;&gt;.NET Core开发的iNeuOS物联网平台部署树霉派（raspbian），从网关到云端整体解决方案&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/11655093.html&quot;&gt;.NET Core开发的iNeuOS物联网平台部署在Ubuntu操作系统，无缝跨平台&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/11415419.html&quot;&gt;iNeuOS 物联网云操作系统2.0发布，集成设备容器、视图建模、机器学习三大模块&lt;/a&gt; 》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/10928843.html&quot;&gt;iNeuOS云操作系统，.NET Core全系打造&lt;/a&gt; 》&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;物联网&amp;amp;大数据技术 QQ群：&lt;span&gt;54256083 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;物联网&amp;amp;大数据合作 QQ群：727664080&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网站：&lt;a href=&quot;http://www.ineuos.net&quot; target=&quot;_blank&quot;&gt;http://www.ineuos.net&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;联系QQ：504547114&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合作微信：wxzz0151&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 14:40:00 +0000</pubDate>
<dc:creator>唯笑志在-ineuos.net</dc:creator>
<og:description>目 录 1. 概述... 2 2. 演示信息... 2 3. iNeuView（Web组态）配置数据接口... 2 4. iNeuView（Web组态）图元绑定数据... 4 5. iNeuView（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lsjwq/p/12122083.html</dc:identifier>
</item>
<item>
<title>阿里面试官让我讲讲Unicode，我讲了3秒说没了，面试官说你可真菜 - 程序员乔戈里</title>
<link>http://www.cnblogs.com/qiaogeli/p/12122025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaogeli/p/12122025.html</guid>
<description>&lt;p&gt;本文首发于微信公众号：程序员乔戈里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221835518-27769688.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221835985-828021181.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221837015-1461853128.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221837687-84260874.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;乔哥：首先说说什么是Unicode、码点吧~要想搞懂，这些概念必须清楚&lt;/p&gt;

&lt;p&gt;下图来自&lt;a href=&quot;http://www.unicode.org/standard/WhatIsUnicode.html&quot; class=&quot;uri&quot;&gt;http://www.unicode.org/standard/WhatIsUnicode.html&lt;/a&gt;中的截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221838119-1887552874.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看的字符比如ABC，汉字等）的数字表示，而且Unicode还兼容了很多老版本的编码规范，例如你熟悉的 ASCII码。&lt;/p&gt;

&lt;p&gt;我们国家的每一个人都对应唯一的一个身份证号，而Unicode也为了每个字符发了一张身份证，这张“身份证”上有一串唯一的数字ID确定了这个字符。&lt;/p&gt;
&lt;p&gt;这串数字在整个计算机的世界具有唯一性，Unicode给这串数字ID起了个名字叫［码点］。&lt;/p&gt;

&lt;p&gt;先来说一声码点是如何表示的：&lt;/p&gt;
&lt;p&gt;U+XXXXXX 是码点的表示形式，X 代表一个十六制数字，可以有 4-6 位，不足 4 位前补 0 补足 4 位，超过则按是几位就是几位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221838633-585917504.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221839238-1702540706.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字符A的ASCII码是众所周知是65吧，将65转换成16进制就是41（16×4+（16^0)×1 = 65）,按照规则前面补0，那么字符A的码点表示就是U+0041，依次类推B的码点表示就是U+0042...等等，汉字&quot;你&quot;的字符表示是“U+4F60”...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221839910-1718757774.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221840967-1402958489.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个网址就是神器~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.fileformat.info/info/unicode/char/search.htm?q=%E4%BD%A0&amp;amp;preview=entity&quot;&gt;http://www.fileformat.info/info/unicode/char/search.htm?q=%E4%BD%A0&amp;amp;preview=entity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221842770-1313775034.png&quot;/&gt;&lt;br/&gt;在输入框1中进行搜索，在出来的结果2中就是这个字符的unicode码点表示，不仅如此，结果2还可以继续进行点击查看更多详情！&lt;/p&gt;
&lt;p&gt;我点一下结果2给你看看：&lt;/p&gt;
&lt;p&gt;对于网址：&lt;br/&gt;&lt;a href=&quot;http://www.fileformat.info/info/unicode/char/4f60/index.htm&quot; class=&quot;uri&quot;&gt;http://www.fileformat.info/info/unicode/char/4f60/index.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221843381-1873221196.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221843765-1203966875.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到很详细的 字符 &lt;a href=&quot;https://xiaogd.net/&quot;&gt;详情&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221844762-1017485177.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221845407-1307001196.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221846400-1167509420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;乔哥：比如我把这个网址中的unicode码点替换为dc00,看看它会出现什么&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.fileformat.info/info/unicode/char/dc00/index.htm&quot; class=&quot;uri&quot;&gt;http://www.fileformat.info/info/unicode/char/dc00/index.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221847403-648900309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你看这个它就没有任何的码点表示，而是提示这个“Non Private Use High Surrogate, First”，Surrogate翻译过来是代理的意思，这个码点对应的是代理区了，这个就涉及到unicode的三种编码方式了（换句话就是码点如何转换为utf-8或者utf-16或者utf-32），utf-16中用到了代理区这个概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221848165-2052498489.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221848810-1275805885.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;码点的取值范围目前是 U+0000 ~ U+10FFFF，理论大小为 10FFFF+1=110000（为啥+1，因为从0开始嘛~）。&lt;/p&gt;
&lt;p&gt;16机制嘛~后一个 1代表是 65536（16的4次方），因为是 16 进制，所以前一个 1 是后一个 1 的 16 倍，所以总共有1×16+1=17 个的 65536 的大小，粗略估算为 17×6万=102 万，所以这是一个百万级别的数。&lt;/p&gt;
&lt;p&gt;为了更好分类管理如此庞大的码点数，把每 65536 个码点作为一个&lt;strong&gt;平面&lt;/strong&gt;，总共 17 个平面。&lt;/p&gt;
&lt;p&gt;而我们说的代理区就在平面里面，而平面又有很多讲究。为了帮你搞懂代理区，先来聊一聊这平面的事&lt;/p&gt;
&lt;h2 id=&quot;平面bmpsp&quot;&gt;平面，BMP，SP&lt;/h2&gt;
&lt;h3 id=&quot;什么是平面&quot;&gt;什么是平面？&lt;/h3&gt;
&lt;p&gt;由前面可知，码点的全部范围可以均分成 17 个 65536 大小的部分，这里面的每一个部分就是一个&lt;strong&gt;平面（Plane）&lt;/strong&gt;。编号从 0 开始，第一个平面称为 Plane 0。&lt;/p&gt;
&lt;p&gt;下图来自&lt;a href=&quot;http://rishida.net/docs/unicode-tutorial/part2&quot; class=&quot;uri&quot;&gt;http://rishida.net/docs/unicode-tutorial/part2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221849913-1796115053.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是-bmp&quot;&gt;什么是 BMP？&lt;/h3&gt;
&lt;p&gt;第一个平面即是 &lt;strong&gt;BMP（Basic Multilingual Plane 基本多语言平面）&lt;/strong&gt;，也叫 Plane 0，它的码点范围是 U+0000 ~ U+FFFF。这也是我们最常用的平面，日常用到的字符绝大多数都落在这个平面内。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上图中第一个花花绿绿的平面就是 BMP。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UTF-16 只需要用两字节编码此平面内的字符。&lt;/p&gt;
&lt;p&gt;最常用的 BMP，它的码点空间也有 6 万多，如果把这些字符都放到一张图片上，会是什么情况呢？GNU Unifont 就制作了一张这样的图片。见&lt;a href=&quot;http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp&quot; class=&quot;uri&quot;&gt;http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下图是它的一个缩略版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221851504-673277683.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是增补平面&quot;&gt;什么是增补平面？&lt;/h3&gt;
&lt;p&gt;后续的 16 个平面称为 &lt;strong&gt;SP（Supplementary Planes）&lt;/strong&gt;。显然，这些码点已经是超过 U+FFFF 的了，所以已经超过了 16 位空间的理论上限，对于这些平面内的字符，UTF-16 采用了四字节编码。&lt;/p&gt;
&lt;h3 id=&quot;代理区&quot;&gt;代理区&lt;/h3&gt;
&lt;p&gt;你可能还注意到前面的 BMP 缩略图中有一片空白，这白花花一片亮瞎了我们的猿眼的是啥呢？这就是所谓的&lt;strong&gt;代理区（Surrogate Area）&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221851858-1271238875.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这段空白从 D8~DF。其中前面的红色部分 D800–DBFF 属于高代理区（High Surrogate Area），后面的蓝色部分 DC00–DFFF 属于低代理区（Low Surrogate Area），各自的大小均为 4×256=1024。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221852529-302708277.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221853509-1877625745.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小萌：unicode码点替换为dc00的字符详情：“Non Private Use High Surrogate, First”，说明是高代理的意思，而 DC00 刚好就在 D800–DBFF这个高代理区里面，嘿嘿~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221854254-1146470556.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221855274-1620419256.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;utf-16如何用代理区编码&quot;&gt;UTF-16如何用代理区编码？&lt;/h3&gt;
&lt;p&gt;UTF-16 是一种变长的 2 或 4 字节编码模式。对于 BMP 内的字符使用 2 字节编码，其它的则使用 4 字节组成所谓的代理对来编码。&lt;/p&gt;
&lt;p&gt;在前面的鸟瞰图中，我们看到了一片空白的区域，这就是所谓的&lt;strong&gt;代理区（Surrogate Area）&lt;/strong&gt;了，代理区是 UTF-16 为了编码增补平面中的字符而保留的，总共有 2048 个位置，均分为&lt;strong&gt;高代理区&lt;/strong&gt;（D800–DBFF）和&lt;strong&gt;低代理区&lt;/strong&gt;（DC00–DFFF）两部分，各1024，这两个区组成一个二维的表格，共有1024×1024=2&lt;sup&gt;10&lt;/sup&gt;×2&lt;sup&gt;10&lt;/sup&gt;=2&lt;sup&gt;4&lt;/sup&gt;×2&lt;sup&gt;16&lt;/sup&gt;=16×65536，所以它恰好可以表示增补的 16 个平面中的所有字符。&lt;/p&gt;
&lt;p&gt;下面的图片来自 wiki&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221855480-855659980.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是代理对&quot;&gt;什么是代理对？&lt;/h4&gt;
&lt;p&gt;一个高代理区（即上图中的Lead（头），行）的加一个低代理区（即上图中的Trail（尾），列）的编码组成一对即是一个&lt;strong&gt;代理对（Surrogate Pair）&lt;/strong&gt;，必须是这种先高后低的顺序，如果出现两个高，两个低，或者先低后高，都是非法的。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在图中可以看到一些转换的例子，如&lt;/p&gt;
&lt;p&gt;（D8 00 DC 00）—&amp;gt;U+10000，左上角，第一个增补字符&lt;/p&gt;
&lt;p&gt;（DB FF DF FF）—&amp;gt;U+10FFFF，右下角，最后一个增补字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;那utf-16为何要采用代理对&quot;&gt;那UTF-16为何要采用代理对？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221855970-636738949.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221856679-1758781778.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最开始是采用定长二字节方案，但是无法满足容量增长，因为两个字节也就2&lt;sup&gt;16&lt;/sup&gt; = 65536个而已，我们天朝的汉字就比这65536还多，那怎么办？扩呗~&lt;/p&gt;
&lt;p&gt;于是转向定长四字节，但是转到4个字节虽然解决了容量的问题，又会引发了效率危机，比如一个字符A用一个字节就够存了，你非要用4个字节存，之前1G的·文件现在可能要4G去存，这不费钱吗~&lt;/p&gt;
&lt;p&gt;那这咋办？于是各路大牛开天辟地，建立自己的编码方案，力图在效率和容量上取到一个平衡，其中一位大牛建立了UTF-16的编码方案！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221857451-1183431247.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221858252-1757526899.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看下面这个图，可以看到编码不是递增的，70-89的编码没有与之对应的字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14850956-08092f48f38fa64a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里挖出 70-89 间的码位，形成横竖 10×10 的编码空间，使得能&lt;strong&gt;再扩展 100 个编码空间&lt;/strong&gt;。原来 2 位 100 个空间损失了 20，为啥这么说，因为70-89是20个，这部分不参与编码，那不就是少了20个吗&lt;/p&gt;
&lt;p&gt;但是这20个编码通过形成 &lt;strong&gt;代理对&lt;/strong&gt; 的方式又新增了100个代码空间，一来一回多了 80。这样一种变长方式也就是 UTF-16 所采用的。&lt;/p&gt;
&lt;p&gt;小萌：哦，懂了~&lt;br/&gt;小萌：UTF-16相当于牺牲了&lt;strong&gt;高代理区&lt;/strong&gt;（D800–DBFF）和&lt;strong&gt;低代理区&lt;/strong&gt;（DC00–DFFF）两部分空间，但是确新增了1024&lt;em&gt;1024=16&lt;/em&gt;65536的空间。依次来实现了扩容！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221858792-210714443.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221859616-835091191.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;码点到-utf-16-如何转换&quot;&gt;码点到 UTF-16 如何转换？&lt;/h4&gt;
&lt;p&gt;乔哥：继续上个例子。转换分成两部分：&lt;/p&gt;
&lt;p&gt;1. BMP 中直接对应，无须做任何转换，也就是如果U&amp;lt;0x10000，U的UTF-16编码就是U对应的16位无符号整数；&lt;/p&gt;
&lt;p&gt;2. 增补平面 SP 中，则需要做相应的计算。也就是如果U≥0x10000的情况&lt;/p&gt;
&lt;p&gt;我们先计算U'=U-0x10000，然后将U'写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。&lt;/p&gt;
&lt;p&gt;Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到：1101100001000011 1101110000110000，转换为16进制即0xD843 0xDC30。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：以上计算方式仅用于说明转换原理，不代表实际采用的计算方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221900613-1275534817.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221901400-367871695.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;utf-32&quot;&gt;UTF-32&lt;/h3&gt;
&lt;p&gt;我们说码点最大的 10FFFF 也就 21 位，而 UTF-32 采用的定长四字节则是 32 位，所以它表示所有的码点不但毫无压力，反而绰绰有余，所以只要把码点的表示形式以前补 0 的形式补够 32 位即可。这种表示的最大缺点是占用空间太大。&lt;/p&gt;
&lt;p&gt;再来看稍复杂一点的 UTF-8。&lt;/p&gt;
&lt;h3 id=&quot;utf-8&quot;&gt;UTF-8&lt;/h3&gt;
&lt;h3 id=&quot;utf-8的好处&quot;&gt;UTF-8的好处&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221902124-787406897.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221904734-1609468894.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小萌：按照数字递增进行编码，例如下图中,虽然简单，但起码也是一种编码，哈哈~。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221905549-2124623949.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你的方案的想法很美好，它试图跟随编号来自然增长，它还是可以编码的，但在解码时则遇到了困难。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221905824-1122708484.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，由于低位的码位被“榨干”了，导致单个位与多位间无法区分，所以你的方案是行不通的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221906754-1779191511.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图中的编码方案2是我的改进方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221907187-1760038621.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我的第二种编码方案，既然之前的无法区分，那我就把低位空间腾出来，5 及以上的就不使用了5,6,7...到49这些编码都不使用了，直接跳到50。然后引入一条变长解码规则：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从左向右扫描，读到 5 以下数字按单个位解码；读到 5 或以上数字时，把当前数字及下一个数字&lt;strong&gt;两位一起&lt;/strong&gt;读上来解码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看个实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14850956-a1f5a77b8bd1d7ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; title=&quot;image&quot;/&gt;&lt;br/&gt;0和1是5以下的（5 以下数字按单个位解码），所以解码出来he,而当读取到了5（读到 5 或以上数字时，把当前数字及下一个数字&lt;strong&gt;两位一起&lt;/strong&gt;读上来解码。），那么5和3连接起来就是53，查一下编码表53就是 “你”，这种方案避免了歧义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221909286-1428608665.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;乔哥：这还是非常粗糙的设计，如果我们想在这串字符中搜索“o”这个字符，它的编码是 3，&lt;br/&gt;首先会找到3和53，这样在匹配时也会匹配上 53 中的 3，这种设计会让我们在实现匹配算法时不好实现啊。,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221911647-568801001.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221913873-963561402.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221918503-1922124857.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实关键就在于用高位保留位来做区分，缺点就是有效编码空间少了&lt;/p&gt;
&lt;p&gt;UTF-8 是变长的编码方案，可以有 1，2，3，4 四种字节组合。UTF-8 采用了高位保留方式来区别不同变长，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14850956-c7a8c020e176d3ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，由于最高位不同，多字节中不会包含一字节的模式。对于 UTF-8 而言，二字节的模式也不会包含在三字节模式中，也不会在四字节中；三字节模式也不会在四字节模式中，这样就解决上面所说的搜索匹配难题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14850956-8132950510ea5d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; title=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，由于固定位上的 0 和 1 的差别，使得二字节既不会与三字节的前两字节相同，也不会它的后两字节相同。&lt;/p&gt;
&lt;p&gt;这也每当进行搜索的时候，每个二字节和三字节的编码没有重叠，因为最高位不同呀~所以不会出现搜索同一个出现两个的结果。不过就是有效编码空间少了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221919609-1071899646.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221921184-2112755252.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;utf-8如何与码点进行转换&quot;&gt;UTF-8如何与码点进行转换&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;000000-00007F&lt;/td&gt;
&lt;td&gt;0xxxxxxx&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;000080-0007FF&lt;/td&gt;
&lt;td&gt;110xxxxx 10xxxxxx&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;000800-00FFFF&lt;/td&gt;
&lt;td&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;010000-10FFFF&lt;/td&gt;
&lt;td&gt;11110xxx10xxxxxx10xxxxxx10xxxxxx&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对于Unicode的编码首先确定它的范围，找到它是对应的&lt;a href=&quot;https://baike.baidu.com/item/Unicode/750500?fr=aladdin&quot;&gt;几字节&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于0x00-0x7F之间的字符，UTF-8编码与[ASCII编码]完全相同。&lt;/p&gt;
&lt;p&gt;“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：&lt;strong&gt;1110&lt;/strong&gt;0110 &lt;strong&gt;10&lt;/strong&gt;110001 &lt;strong&gt;10&lt;/strong&gt;001001，即E6 B1 89。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221922545-356292769.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221922736-1577399743.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221924938-375474803.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221926658-88789564.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221927641-839408805.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文首发于微信公众号：程序员乔戈里&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果是头条用户，可以在我的头条号&lt;strong&gt;程序员乔戈里&lt;/strong&gt;后台回复 资源获取价值59998元的编程和考研资料&lt;br/&gt;觉得文章不错的欢迎关注我的WX公众号：&lt;strong&gt;程序员乔戈里&lt;/strong&gt;&lt;br/&gt;我是BAT大厂后台开发工程师，，专注分享技术干货/编程资源/求职面试/成长感悟等,关注送5000G编程资源和自己整理的一份帮助不少人拿下java的offer的面经附答案，免费下载CSDN资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529030/201912/1529030-20191230221928189-552585466.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 14:19:00 +0000</pubDate>
<dc:creator>程序员乔戈里</dc:creator>
<og:description>本文首发于微信公众号：程序员乔戈里 乔哥：首先说说什么是Unicode、码点吧~要想搞懂，这些概念必须清楚 什么是Unicode？ 下图来自 &amp;quot;http://www.unicode.org/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiaogeli/p/12122025.html</dc:identifier>
</item>
<item>
<title>多线程之美7一ReentrantReadWriteLock源码分析 - 夕阳下飞奔的猪</title>
<link>http://www.cnblogs.com/flydashpig/p/12121953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydashpig/p/12121953.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230214732885-2061205415.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在多线程环境下，为了保证线程安全， 我们通常会对共享资源加锁操作，我们常用Synchronized关键字或者ReentrantLock 来实现，这两者加锁方式都是排他锁，即同一时刻最多允许一个线程操作，然而大多数场景中对共享资源读多于写，那么存在线程安全问题的是写操作（修改，添加，删除），我们是否应该考虑将读和写两个分开，只要运用合理，并发性能是不是可以提高，吞吐量增大呢？ ReentrantReadWriteLock已经为我们实现了这种机制，我们一起来看它是怎样实现的吧！&lt;/p&gt;

&lt;p&gt;在查看可重入读写锁的源码前，有几个概念需要先知道，对于后面理解源码很有帮助。&lt;/p&gt;
&lt;p&gt;1、ReentrantReadWriteLock 内部 Sync类依然是继承AQS实现的，因此同步状态字段 state，依然表示对锁资源的占用情况。那么如何实现一个 int类型的state 同时来表示读写锁两种状态的占用情况呢? 这里实现非常巧妙，将4个字节的int类型, 32位拆分为2部分，高16位表示读锁的占用情况，低16位表示写锁的占用情况，这样读写锁互不影响，相互独立；也因此读写锁的最大值是2^16-1 = 65535，不能超过16位，下面源码有体现。&lt;/p&gt;
&lt;p&gt;state值表示如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230213748925-1007034451.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、读锁是共享锁，只要不超过最大值，可多个线程同时获取; 写锁是排他锁，同一时刻最多允许一个线程获取。&lt;/p&gt;
&lt;p&gt;写锁与其他锁都互斥，含写写互斥，写读互斥，读写互斥。&lt;/p&gt;
&lt;p&gt;3、state可同时表示读写锁的状态，state的高16位表示获取读锁的线程数，读锁支持可重入，即一个线程也可多次获取读锁，怎么维护每个读锁线程的重入次数的？ 每个线程有一个计数器 HoldCounter，用ThreadLocal来存放每个线程的计数器；state的低16位表示写锁的同步状态，因为写锁是排他锁，这里就不能表示获取写锁的线程数了，只能表示写锁的重入次数，获取写锁的线程可多次重复获取写锁（支持重入）。&lt;/p&gt;
&lt;p&gt;读锁的计数器的实现原理如下：&lt;/p&gt;
&lt;p&gt;可见ThreadLocalHoldCounter继承 ThreadLocal，每个获取读锁的线程是通过其本地变量来存储自己的计数器，来统计获取读锁的重入次数。&lt;a href=&quot;https://www.cnblogs.com/flydashpig/p/11922609.html&quot;&gt;ThreadLocal原理解析&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static final class ThreadLocalHoldCounter
            extends ThreadLocal&amp;lt;HoldCounter&amp;gt; {
          //重写了ThreadLocal的initialValue方法
            public HoldCounter initialValue() {
                return new HoldCounter();
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、state的高16位需要记录获取读锁的线程数，每增加一个线程获取读锁，在state的高16执行加1操作，即state+2^16，写锁增加重入次数，直接 state+1即可。&lt;/p&gt;
&lt;p&gt;5、锁降级：获取写锁的线程，可以再次获取到读锁，即写锁降级为读锁。&lt;/p&gt;
&lt;p&gt;​ 读锁可以升级为写锁吗？ 不可以，因为存在线程安全问题，试想获取读锁的线程有多个，其中一个线程升级为写锁，对临界区资源进行操作，比如修改了某个值，对其他已经获取读锁的线程不可见，出现线程安全问题。&lt;/p&gt;
&lt;p&gt;代码演示：&lt;/p&gt;
&lt;p&gt;1、读写状态&lt;/p&gt;
&lt;p&gt;AQS（AbstractQueuedSynchronizer的简称）中同步状态字段 private volatile int state, int类型，4个字节，32位，拆分为高16位表示读状态，低16位表示写状态，如下定义了一些常量，实现获取读写锁的数量。&lt;/p&gt;
&lt;p&gt;ReentrantReadWriteLock部分代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   //分隔位数，16位 
     static final int SHARED_SHIFT   = 16;
   //读锁加1的数量，1左位移16位， （16）0x10000  = (2)1000000000000000= (10) 65536
        static final int SHARED_UNIT    = (1 &amp;lt;&amp;lt; SHARED_SHIFT);
  //读写锁的最大数量， (16)0xFFFFFFFF =(2)1111111111111111 =(10)65535 
        static final int MAX_COUNT      = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1;
  //写锁的掩码，用于计算写锁重入次数时，将state的高16全部置为0, 等于(2)1111111111111111
        static final int EXCLUSIVE_MASK = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1;
   //获取读锁数，表示当前有多少个线程获取到读锁
   static int sharedCount(int c)    { return c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }
  //获取写锁重入次数（不等于0表示有线程持有独占锁，大于1,表示写锁有重入）
        static int exclusiveCount(int c) { return c &amp;amp; EXCLUSIVE_MASK; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别看一下获取读写锁数量的方法。&lt;/p&gt;
&lt;p&gt;获取占用读锁的线程数，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; static int sharedCount(int c)    { return c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传入的c为 state，state 无符号右移16位，抹去低16位值，左边补0&lt;/p&gt;
&lt;p&gt;示例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230213824880-1744457489.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取写锁的值的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  static int exclusiveCount(int c) { return c &amp;amp; EXCLUSIVE_MASK; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与运算，将高16全部置为0，低16值代表写锁的值,&amp;amp;运算，相同为1，不同为0，得到低16位写锁值。&lt;/p&gt;
&lt;p&gt;示例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230213847149-656561091.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、三个锁概念&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;int c =getState() ,获取state的值，代表同步锁状态，该值包含读写两个锁的同步状态&lt;/li&gt;
&lt;li&gt;int w = exclusiveCount(c); w代表写锁的同步状态，通过c获取到写锁的状态值&lt;/li&gt;
&lt;li&gt;int r = sharedCount(c); r 代表读锁的同步状态，通过c获取到读锁的状态值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下分析三种情况下state，r, w 的值及代表的含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、一个线程获取到写锁：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;state =1, w =1, r =0&lt;/p&gt;
&lt;p&gt;获取写锁加1操作就比较简单了，因为写锁是独占锁，与正常的ReentrantLock获取锁实现一样，占用state的低16位表示，不用看state的高16，左边补16位0。获取写锁一次，直接 c+1;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2、一个线程获取到读锁：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;state =65536, w= 0, r=1&lt;/p&gt;
&lt;p&gt;c初始为0 ,获取读锁，则读锁数量+1,执行 c + SHARED_UNIT, SHARED_UNIT = (2)1000000000000000 = （10）65536，括号内表示进制，SHARED_UNIT是每次读锁加1的数值。&lt;/p&gt;
&lt;p&gt;如下图所示: 在获取读锁数量 r时，将state的低16位抹去，r=1，而state此时的值= 2^16 =65536，state的实际值可能会很大，但其实分别拆分读写锁的值不一定大，只是读锁值表示在高位，会造成state值很大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230213906449-1829540144.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3、一个线程获取到写锁，又获取到读锁情况（锁降级):&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;state = 65537,w=1, r=1&lt;/p&gt;
&lt;p&gt;state二进制表示： 00000000 00000001 00000000 00000001&lt;/p&gt;
&lt;p&gt;锁降级代码演示如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package readwritelock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
/**
 * @author zdd
 * 2019/12/30  上午
 * Description: 锁降级测试
 */
public class ReadWriteLockTest {
    static Integer shareVar = 0;
    public static void main(String[] args) {
        ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
        //1，首先获取写锁
        rw.writeLock().lock();
        //2.修改共享变量值
        shareVar = 10 ;
        //3.再获取读锁
        rw.readLock().lock();
        System.out.println(&quot;读取变量值 shareVar：&quot;+ shareVar);
        //4.释放写锁
        rw.writeLock().unlock();
        //5.释放读锁
        rw.readLock().unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;ReentrantReadWriteLock 类中有ReadLock和WriteLock,分别对应读锁和写锁，而读写锁又分为公平方式和非公平方式获取锁。&lt;/p&gt;
&lt;p&gt;简略类图结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230213924988-744314010.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构造方法如下：根据传入参数设置公平或者非公平获取锁方式，默认是非公平方式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于写锁是独占锁，由于写锁是独占锁，获取写锁的方式在AQS中已经说过了，详见&lt;a href=&quot;https://www.cnblogs.com/flydashpig/p/12076475.html&quot;&gt;AQS源代码分析&lt;/a&gt;, 只是每个子类的尝试获取锁方式不同，所以ReentrantReadWriteLock类获取写锁过程就看一下尝试获取锁方法的源码。&lt;/p&gt;
&lt;h2 id=&quot;尝试获取锁&quot;&gt;3.1、尝试获取锁&lt;/h2&gt;
&lt;p&gt;tryAcquire（int acquires),获取锁失败则加入同步队列中等待获取锁，源代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; protected final boolean tryAcquire(int acquires) {
            Thread current = Thread.currentThread();
           //1,获取同步状态state的值，注意该值可表示读写锁的同步状态
            int c = getState();
          //2,获取写锁状态，低16位的值
            int w = exclusiveCount(c);
          //3,如果同步锁状态不为0，有线程已经获取到了锁 
            if (c != 0) {
        //4,w==0则表示写锁为0，那么一定有线程获取了读锁，需要等待，读写互斥
 //current != getExclusiveOwnerThread() 当前线程不等于已经获取到写锁的线程，则也需等待其释放，写写互斥
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
       //5，此时再次获取锁，判断锁重入次数是否超过最大限定次数
                if (w + exclusiveCount(acquires) &amp;gt; MAX_COUNT)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                //更新写锁重入次数
                setState(c + acquires);
                return true;
            }
      //6,代码执行这，一定是c==0,同步锁空闲情况
     //writerShouldBlock该方法是基于公平锁和非公平锁2种方式的体现
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
       //获取到锁,设置独占锁为当前写锁线程
            setExclusiveOwnerThread(current);
            return true;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写锁是否应该阻塞等待&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、 非公平锁方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  final boolean writerShouldBlock() {
          //直接返回false
            return false; // writers can always barge
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2、公平锁方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要判断同步队列中是否还有其他线程在挂起等待，如存在应该按照入队顺序获取锁&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  final boolean writerShouldBlock() {
            return hasQueuedPredecessors();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public final boolean hasQueuedPredecessors() {
   //1.获取同步队列头，尾节点
        Node t = tail; 
        Node h = head;
        Node s;
  // h !=t 同步队列不为空
  // 队列中还有其他线程在等待锁，则返回true
        return h != t &amp;amp;&amp;amp;
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;释放写锁&quot;&gt;3.2、释放写锁&lt;/h2&gt;
&lt;p&gt;unlock方法释放锁&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void unlock() {
    sync.release(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，调用内部类Sync的release方法，Sync继承AQS&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final boolean release(int arg) {
    if (tryRelease(arg)) {
       //1,释放锁成功
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
        //2.唤醒同步队列中等待线程
            unparkSuccessor(h);
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心在尝试释放锁方法上，看看写锁的释放锁方法tryRelease&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   protected final boolean tryRelease(int releases) {
           //1,判断当前线程是否持有当前锁
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            //2,同步状态 - 需要释放的写锁同步值
            int nextc = getState() - releases;
            boolean free = exclusiveCount(nextc) == 0;
            if (free)
              //3,free ==true,完全释放写锁，将当前获取独占锁线程置空
                setExclusiveOwnerThread(null);
           //4,更新state值
            setState(nextc);
            return free;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 在释放写锁占用次数时, state的高16的读锁有值也不影响，减去releases，首先减去的state低位的数，而且在释放写锁时，state的低16位的值一定&amp;gt;=1，不存在减少读锁的值情况。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   int nextc = getState() - releases;
   boolean free = exclusiveCount(nextc) == 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可改写为如下面代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//1,获取state值
int c = getState();
//2,获取写锁的值
int w= exclusiveCount(c);
int remain = w- releases;
boolean free = remain== 0;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;获取读锁&quot;&gt;4.1、获取读锁&lt;/h2&gt;
&lt;p&gt;读锁调用lock方法加锁，实际调用Sync的acquireShared方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public void lock() {
            sync.acquireShared(1);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;走进acquireShared，获取共享锁方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) &amp;lt; 0)
            doAcquireShared(arg);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尝试获取锁tryAcquireShared，如果返回值&amp;lt;0, 表示获取读锁失败&lt;/p&gt;
&lt;p&gt;主要执行步骤：&lt;/p&gt;
&lt;p&gt;1、首先判断是否存在其他线程在占用写锁，有需要挂起等待；&lt;/p&gt;
&lt;p&gt;2、在不用阻塞等待，且读锁值没有超过最大值，cas更新成功了state的值，可以获取到读锁，还会做以下事：&lt;/p&gt;
&lt;p&gt;​ a. 第一个获取读锁的，直接记录线程对象和其重入获取读锁的次数&lt;/p&gt;
&lt;p&gt;​ b. 非第一个获取读锁的，则获取缓存计数器（cachedHoldCounter），其记录上一次获取读锁的线程，如果是同一个线程，则直接更新其计数器的重入次数，如果缓存计数器为空或缓存计数器的线程不是当前获取读锁的线程，则从当前线程本地变量中获取自己的计数器，更新计数器的值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  protected final int tryAcquireShared(int unused) {
          //1,获取当前线程对象
            Thread current = Thread.currentThread();
          //2,获取同步锁的值
            int c = getState();
         /*3,exclusiveCount(c) != 0 计算写锁的同步状态，不等于0，说明有写锁已经获取到同步锁，
          *需要判断当前线程是否等于获取写锁线程，
          *是，可以允许再次获取读锁，这里涉及到锁降级问题，写锁可以降为读锁
          *否则不让获取，写读互斥
         */
            if (exclusiveCount(c) != 0 &amp;amp;&amp;amp;
                getExclusiveOwnerThread() != current)
                return -1;
       //4,获取读锁同步状态
            int r = sharedCount(c);
    /**
      *此处3个判断条件
      * 1.是否应该阻塞等待，这里也是基于公平锁和非公平获取锁实现 
      * 2.读锁同步状态值是超过最大值,即限制获取读锁的最大线程数
      * 3.cas更新读锁同步状态是否成功
      */
      if (!readerShouldBlock() &amp;amp;&amp;amp;
                r &amp;lt; MAX_COUNT &amp;amp;&amp;amp;
                compareAndSetState(c, c + SHARED_UNIT)) {
        //可以获取到读锁
         //r==0表示是第一个获取读锁的线程
                if (r == 0) {
                    firstReader = current;
                   //记录第一个线程读锁的重入次数
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                  //是第一个获取读锁线程，锁重入，锁重入次数+1
                    firstReaderHoldCount++;
                } else {
               // 已有其他线程获取到读锁 
        /*
         *1,获取缓存记录的计数器，计数器是用来统计每一个获取读锁线程的重入次数的，
         *由每个线程的ThreadLocal,即线程内的副本存储，相互独立；
         *此处也不是放入缓存，在有多个线程同时获取读锁情况，
         *用一个变量记录上一个获取读锁的线程的计数器，可能考虑多次获取读锁线程大概率是同一个线程情况，
         *这样做是可提高执行效率
          */
                    HoldCounter rh = cachedHoldCounter;
          // rh==null,第一个获取读锁，rh没有值
   // 或者计数器存储的上一次线程的id与当前线程不等， 即不是相同一个线程，
  //那么就获取当前线程内部的计数器，并赋值给cachedHoldCounter变量，这样可以让下一次获取读锁线程获取比较了
       if (rh == null || rh.tid != getThreadId(current))
              cachedHoldCounter = rh = readHolds.get();
         else if (rh.count == 0)
  /*进入该条件，我理解是在线程获取读锁再释放后，同一线程再次获取读锁情况，
   * 缓存计数器会记录上一个线程计数器，因为线程释放读锁后，count=0，
   * 这里重新将计数器放入线程内部中，
   * 因为线程在使用完线程内部变量后会防止内存泄漏，会执行remove,释放本地存储的计数器。
   */
                readHolds.set(rh);
        //计数器+1 
         rh.count++;
              }
                return 1;
            }
       //上面3个条件没有同时满足，没有成功获取到读锁，开始无限循环尝试去获取读锁
            return fullTryAcquireShared(current);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无限循环尝试获取共享锁 fullTryAcquireShared方法&lt;/p&gt;
&lt;p&gt;主要执行步骤：&lt;/p&gt;
&lt;p&gt;1、 如果有其他线程获取到了写锁，写读互斥，应该去挂起等待；&lt;/p&gt;
&lt;p&gt;2、如果可以获取读锁，判断是否应该阻塞等待，在公平获取锁方式中，同步队列中有其他线程在等待，则应该去排队按照FIFO顺序获取锁，非公平获取锁方式，可以直接去竞争获取锁。&lt;/p&gt;
&lt;p&gt;3、可以获取锁，则尝试cas更新state的值，更新成功，获取到锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  final int fullTryAcquireShared(Thread current){
            HoldCounter rh = null;
        //无限循环
            for (;;) {
              //获取同步锁状态
                int c = getState();
               //判断写锁值不为0，且不是当前线程，不可获取读锁
                if (exclusiveCount(c) != 0) {
                    if (getExclusiveOwnerThread() != current)
                        return -1;
                } else if (readerShouldBlock()) {
               //没有线程获取到写锁情况，公平获取锁情况，
               //同步队列中有其他线程等待锁，该方法主要是在需要排队等待，计数器重入次数==0情况，清除计数器
                    if (firstReader == current) {
               //此处firstReader !=null, 则第1个获取读锁的线程还没释放锁，可允许该线程继续重入获取锁
               //计数器count一定&amp;gt;0
                    } else {
                        if (rh == null) {
                            rh = cachedHoldCounter;
                            if (rh == null || rh.tid != getThreadId(current)) {
                                rh = readHolds.get();
                                if (rh.count == 0)
                                  //清除计数器
                                    readHolds.remove();
                            }
                        }
              // 为什么rh.count == 0就不让线程获取到锁了，基于公平获取锁方式，去同步队列中等待
                        if (rh.count == 0)
                            return -1;
                    }
                }
                //获取读锁线程超过最大限制值 65535
                if (sharedCount(c) == MAX_COUNT)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
               // cas执行读锁值+1
                if (compareAndSetState(c, c + SHARED_UNIT)) {
                    if (sharedCount(c) == 0) {
                      //1,第一个获取读锁
                        firstReader = current;
                        firstReaderHoldCount = 1;
                    } else if (firstReader == current) {
                      //2,第一个获取读锁重入
                        firstReaderHoldCount++;
                    } else {
                      //3,非第一个线程获取读锁，存在多个线程获取读锁
                        if (rh == null)
                            rh = cachedHoldCounter;
                        if (rh == null || rh.tid != getThreadId(current))
                            rh = readHolds.get();
                        else if (rh.count == 0)
                            readHolds.set(rh);
                        rh.count++;
                      //缓存计数器变量记录此次获取读锁线程的计数器
                        cachedHoldCounter = rh; // cache for release
                    }
                    return 1;
                }
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tryAcquireShared 返回&amp;lt; 0, 获取锁失败，执行 doAcquireShared&lt;/p&gt;
&lt;p&gt;在获取读锁失败后，执行以下步骤：&lt;/p&gt;
&lt;p&gt;1、将节点加入同步队列中&lt;/p&gt;
&lt;p&gt;2、如果前置节点是头节点，将再次尝试获取锁，如果成功，设置当前节点为head节点，并根据tryAcquireShared方法的返回值r判断是否需要继续唤醒后继节点，如果 r大于0，需要继续唤醒后继节点，r=0不需要唤醒后继节点。&lt;/p&gt;
&lt;p&gt;3、如果前置节点不是头节点，则在队列中找到安全位置，设置前置节点 ws=SIGNAL, 挂起等待。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                   //如果前继节点是头节点，再次尝试获取共享锁
                    int r = tryAcquireShared(arg);
                   //r&amp;gt;=0,表示获取到锁, 
                   //r=0,表示不需要唤醒后继节点
                   //r&amp;gt;0,需要继续唤醒后继节点
                    if (r &amp;gt;= 0) {
                       //该方法实现2个步骤
                       //1,设置当前节点为头节点
                       //2,r&amp;gt;0情况会继续唤醒后继节点
                        setHeadAndPropagate(node, r);
                      //旧的头节点移出队列
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;setHeadAndPropagate 该方法是与独占锁获取锁的区别之处，获取到锁后，设置为头结点还需要继续传播下去。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void setHeadAndPropagate(Node node, int propagate) {
   //记录是的旧的头节点
   Node h = head; // Record old head for check 
   //设置当前获取到锁节点为头节点
    setHead(node);
   //propagate &amp;gt;0,表示还需要继续唤醒后继节点
   //旧的头节点和新头节点为空，或者ws&amp;lt;0,满足条件之一，尝试去唤醒后继节点
    if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
        (h = head) == null || h.waitStatus &amp;lt; 0) {
        Node s = node.next;
       //后继节点为空或者是共享节点（获取读锁的线程）
        if (s == null || s.isShared())
            doReleaseShared();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;doReleaseShared 方法较难理解，在释放锁中也有调用，留着后面一起分析。&lt;/p&gt;
&lt;h2 id=&quot;释放读锁&quot;&gt;4.2、释放读锁&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void unlock() {
    sync.releaseShared(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AQS中释放共锁方法releaseShared&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下读写锁具体实现tryReleaseShared 的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected final boolean tryReleaseShared(int unused) {
    Thread current = Thread.currentThread();
  //1,更新或者移出线程内部计数器的值
    if (firstReader == current) {
        //当前线程是第一个获取读锁的线程
        if (firstReaderHoldCount == 1)
          //直接置空
            firstReader = null;
        else
          //该线程获取读锁重入多次，计数器-1
            firstReaderHoldCount--;
    } else {
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != getThreadId(current))
            rh = readHolds.get();
        int count = rh.count;
        if (count &amp;lt;= 1) {
          //非第一个获取读锁线程，避免ThreadLocal内存泄漏，移出计数器
            readHolds.remove();
            if (count &amp;lt;= 0)
             //此处是调用释放锁次数比获取锁次数还多情况，直接抛异常
                throw unmatchedUnlockException();
        }
        --rh.count;
    }
   //2,循环cas更新同步锁的值
    for (;;) {
        int c = getState();
        //读锁同步状态-1
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            // Releasing the read lock has no effect on readers,
            // but it may allow waiting writers to proceed if
            // both read and write locks are now free.
          //返回完全释放读锁，读锁值是否==0,完全释放，等待写锁线程可获取
            return nextc == 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tryReleaseShared 返回true情况，表示完全释放读锁，执行doReleaseShared，那就需要唤醒同步队列中等待的其他线程&lt;/p&gt;
&lt;p&gt;在读写锁中存在几种情况&lt;/p&gt;
&lt;p&gt;情况一、如果当前获取锁的线程占用的是写锁，则后来无论是获取读锁还写锁的线程都会被阻塞在同步队列中，&lt;/p&gt;
&lt;p&gt;同步队列是FIFO队列，在占用写锁的释放后，node1获取读锁，因读锁是共享的，继续唤醒后一个共享节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458219/201912/1458219-20191230214024235-998774168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，在node1获取到读锁时，会调用doReleaseShared方法，继续唤醒下一个共享节点node2,可以持续将唤醒动作传递下去，如果node2后面还存在几个等待获取读锁的线程，这些线程是由谁唤醒的？是其前置节点，还是第一个获取读锁的节点？ 应该是第1个获取锁的节点，这里即node1, 由下代码可见，在无限循环中，只有头节点没有变化时，即再没其他节点获取到锁后，才会跳出循环。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void doReleaseShared() {
    for (;;) {
      //获取同步队列中头节点
        Node h = head;
      //同步队列中节点不为空，且节点数至少2个
        if (h != null &amp;amp;&amp;amp; h != tail) {
            int ws = h.waitStatus;
            //1,表示后继节点需要被唤醒
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
               //唤醒后继节点 
                unparkSuccessor(h);
            }
           //2,后继节点暂时不需要唤醒，设置节点 ws = -3, 确保后面可以继续传递下去
            else if (ws == 0 &amp;amp;&amp;amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        //如果头节点发生变化，表示已经有其他线程获取到锁了，需要重新循环，确保可以将唤醒动作传递下去。
        if (h == head)                   // loop if head changed
            break;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;1、在非公平获取锁方式下，是否存在等待获取写锁的线程始终获取不到锁，每次都被后来获取读锁的线程抢先，造成饥饿现象？&lt;/p&gt;
&lt;p&gt;存在这种情况，从获取读锁源码中看出，如果第一个线程获取到读锁正在执行情况下，第二个等待获取写锁的线程在同步队列中挂起等待，在第一个线程没有释放读锁情况下，又陆续来了线程获取读锁，因为读锁是共享的，线程都可以获取到读锁，始终是在读锁没有释放完毕加入获取读锁的线程，那么等待获取写锁的线程是始终拿不到写锁，导致饥饿。为什么默认还是非公平模式？因为减少线程的上下文切换，保证更大的吞吐量。&lt;/p&gt;

&lt;p&gt;1、读写锁可支持公平和非公平两种方式获取锁。&lt;/p&gt;
&lt;p&gt;2、支持锁降级，写锁可降级为读锁，但读锁不可升级为写锁。&lt;/p&gt;
&lt;p&gt;3、大多数场景是读多于写的，所以ReentrantReadWriteLock 比 ReentrantLock（排他锁）有更好的并发性能和吞吐量。&lt;/p&gt;
&lt;p&gt;4、读写锁中读锁和写锁都支持锁重入。&lt;/p&gt;
&lt;p&gt;5、在获取Condition对象实现阻塞唤醒机制,ReentrantReadWriteLock.WriteLock 重写了 newCondition方法，ReadLock不支持，即读锁不支持与Condition配合使用，使用阻塞唤醒机制。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 14:07:00 +0000</pubDate>
<dc:creator>夕阳下飞奔的猪</dc:creator>
<og:description>ReentrantReadWriteLock分别实现读锁和写锁，在大多数并发场景下读多于写，是比ReentrantLock 排他锁的并发性能好，吞吐量高，合理运用，可以使我们程序运行更有效率！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydashpig/p/12121953.html</dc:identifier>
</item>
</channel>
</rss>