<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>决策树 - platycoden</title>
<link>http://www.cnblogs.com/platycoden/p/10456659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/platycoden/p/10456659.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;1. 什么是决策树/判定树（decision tree)?&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　判定树是一个类似于流程图的树结构：其中，每个内部结点表示在一个属性上的测试，每个分支代表一个属性输出，而每个树叶结点代表类或类分布。树的最顶层是根结点。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892404/201903/892404-20190301145539421-495695303.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.  机器学习中分类方法中的一个重要算法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.  构造决策树的基本算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892404/201903/892404-20190301145942823-470884379.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892404/201903/892404-20190301150044377-969802795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 3.1 熵（entropy）概念：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　信息和抽象，如何度量？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1948年，香农提出了 ”信息熵(entropy)“的概念：一条信息的信息量大小和它的不确定性有直接的关系，要搞清楚一件非常非常不确定的事情，或者是我们一无所知的事情，需要了解大量信息==&amp;gt;信息量的度量就等于不确定性的多少。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　例子：猜世界杯冠军，假如一无所知，猜多少次？（每个队夺冠的几率不是相等的）比如说，有32支队伍，问题是在不在1-16中？在不在1-8中？在不在1-4中？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　比特(bit)来衡量信息的多少：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/892404/201903/892404-20190301150219294-1083953188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　变量的不确定性越大，熵也就越大。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.2 决策树归纳算法 （ID3）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1970-1980， J.Ross. Quinlan, ID3算法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　选择属性判断结点&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　信息增益(Information Gain)：Gain(A) = Info(D) - Infor_A(D)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Gain(A)表示：通过A来作为节点分类获取了多少信息&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　举例：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/892404/201903/892404-20190301150537242-13666639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/892404/201903/892404-20190301150608405-1396443993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　类似，Gain(income) = 0.029, Gain(student) = 0.151, Gain(credit_rating)=0.048&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　所以，选择age作为第一个根节点&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/892404/201903/892404-20190301150828721-1413673773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;树以代表训练样本的单个结点开始（步骤1）。&lt;/li&gt;
&lt;li&gt;如果样本都在同一个类，则该结点成为树叶，并用该类标号（步骤2 和3）。&lt;/li&gt;
&lt;li&gt;否则，算法使用称为信息增益的基于熵的度量作为启发信息，选择能够最好地将样本分类的属性（步骤6）。该属性成为该结点的“测试”或“判定”属性（步骤7）。在算法的该版本中，&lt;/li&gt;
&lt;li&gt;所有的属性都是分类的，即离散值。连续属性必须离散化。&lt;/li&gt;
&lt;li&gt;对测试属性的每个已知的值，创建一个分枝，并据此划分样本（步骤8-10）。&lt;/li&gt;
&lt;li&gt;算法使用同样的过程，递归地形成每个划分上的样本判定树。一旦一个属性出现在一个结点上，就不必该结点的任何后代上考虑它（步骤13）。&lt;/li&gt;
&lt;li&gt;递归划分步骤仅当下列条件之一成立停止：&lt;/li&gt;
&lt;li&gt;(a) 给定结点的所有样本属于同一类（步骤2 和3）。&lt;/li&gt;
&lt;li&gt;(b) 没有剩余属性可以用来进一步划分样本（步骤4）。在此情况下，使用多数表决（步骤5）。&lt;/li&gt;
&lt;li&gt;这涉及将给定的结点转换成树叶，并用样本中的多数所在的类标记它。替换地，可以存放结&lt;/li&gt;
&lt;li&gt;点样本的类分布。&lt;/li&gt;
&lt;li&gt;(c) 分枝&lt;/li&gt;
&lt;li&gt;test_attribute = a i 没有样本（步骤11）。在这种情况下，以 samples 中的多数类&lt;/li&gt;
&lt;li&gt;创建一个树叶（步骤12）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.3 其他算法：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　C4.5:  Quinlan&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Classification and Regression Trees (CART): (L. Breiman, J. Friedman, R. Olshen, C. Stone)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　共同点：都是贪心算法，自上而下(Top-down approach)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　区别：属性选择度量方法不同： C4.5 （gain ratio), CART(gini index), ID3 (Information Gain)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　如何处理连续性变量的属性？ 离散化！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4 树剪枝叶 （避免overfitting)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　一个假设在训练数据上能够获得比其他假设更好的拟合，但是在训练数据外的数据集上却不能很好的拟合数据。此时我们就叫这个假设出现了overfitting的现象。出现这种现象的主要原因是训练数据中存在噪音或者训练数据太少。而解决overfit的方法主要有两种：提前停止树的增长或者对已经生成的树按照一定的规则进行后剪枝。一般来说，有前剪枝和后剪枝两种策略。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5 决策树优缺点&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　优点：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　直观，便于理解，小规模数据集有效&lt;/p&gt;
&lt;p&gt;　　缺点：&lt;/p&gt;
&lt;p&gt;　　　　处理连续变量不好&lt;/p&gt;
&lt;p&gt;　　　　类别较多时，错误增加的比较快&lt;/p&gt;
&lt;p&gt;　　　　可规模性一般&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;　　　　&lt;/p&gt;

</description>
<pubDate>Fri, 01 Mar 2019 07:28:00 +0000</pubDate>
<dc:creator>platycoden</dc:creator>
<og:description>1. 什么是决策树/判定树（decision tree)? 判定树是一个类似于流程图的树结构：其中，每个内部结点表示在一个属性上的测试，每个分支代表一个属性输出，而每个树叶结点代表类或类分布。树的最顶</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/platycoden/p/10456659.html</dc:identifier>
</item>
<item>
<title>double转换为int以及浮点型相加损失精度问题 - 陈灬大灬海</title>
<link>http://www.cnblogs.com/c-h-y/p/10456651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-h-y/p/10456651.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近在做支付相关模块的业务，数据库字段却使用的是double类型，其实也行，只要计算不在sql语句中进行，也是没有问题的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;预先的类属性设置的是Double类型，自己算的时候发现小数相加会出现损失精度的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下情形&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDouble(){
        Double [] arr &lt;/span&gt;= {39.9d,50d,198d,39.9d&lt;span&gt;};
        Double verify &lt;/span&gt;=&lt;span&gt; 0d;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Double aDouble : arr) {
            verify &lt;/span&gt;+=&lt;span&gt; aDouble ;
        }
        System.out.println(verify);
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出的结果是：327.79999999999995  理应为：328&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;待着疑惑试了下js&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201903/1158451-20190301150122010-1216722504.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一看是一个效果，精度都会缺失。百度了下，解释如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;产生原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    计算机并不能识别除了二进制数据以外的任何数据，&lt;span&gt;无论我们使用何种编程语言，在何种编译环境下工作，都要先把源程序翻译成二进制的机器码后才能被计算机识别。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    而在存储浮点型数据时，会分为三部分进行存储：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;        &lt;span&gt;符号位&lt;/span&gt;(Sign): 0代表正，1代表为负&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;        &lt;span&gt;指数位&lt;/span&gt;(Exponent):用于存储科学计数法中的指数数据，并且采用移位存储&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;        &lt;span&gt;尾数部分&lt;/span&gt;(Mantissa)：尾数部分&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;307C2A4D88FB4F0F82CBE5C61D4ED817&quot; data-attr-org-img-file=&quot;file:///C:/Users/Zhaoxuepeng/AppData/Local/YNote/data/qq136E28C866B138CFA81DC27A1ED3DB07/72bb2494e4cc4c07af89dd34850e6dd9/001%255b3%255d_2.gif&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    其中前两位分别为实数符号位和指数符号位，于是存储结构实际为如下：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1082671/201711/1082671-20171101211944607-1345467456.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       &lt;strong&gt;             31                  30            29----23        22----0         &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;               实数符号位    指数符号位    指数位      有效数位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       但是，在将十进制浮点数转换为二进制浮点数时，小数的二进制有时也是不可能精确的，就如同十进制不能准确表示1/3，二进制也无法准确表示1/10，而double类型存储尾数部分最多只能存储52位，于是，计算机在存储该浮点型数据时，便出现了精度丢失。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如，11.9的内存存储大约为：1011&lt;strong&gt;.&lt;/strong&gt; 1110011001100110011001100...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       而在进行浮点类数据计算的时候，浮点参与计算，会左移或右移n位，直到小数点移动到第一个有效数字的右边。于是11.9在转化为二进制后 小数点左移3位，就得到1&lt;strong&gt;.&lt;/strong&gt; 011 11100110011001100110（精度丢失2）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       于是最终浮点型运算出现了精度丢失误差。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 解决方式，java中可以使用 &lt;span&gt;BigDecimal&lt;/span&gt; 来解决&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        System.out.println(&lt;/span&gt;0.11+2001299.32);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非精确的输出&lt;/span&gt;
        BigDecimal bigDecimal1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(0.11&lt;span&gt;));
        BigDecimal bigDecimal2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(2001299.32&lt;span&gt;));
        System.out.println(bigDecimal1.add(bigDecimal2));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;精确的输出&lt;/span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这种方式可以解决，并且很完美，但是还有一种方式比较容易些，毕竟是金额，小数位只有两位，可以先将其扩大100倍，再进行计算，计算完毕之后再除100，也可以解决(&lt;span&gt;这么不要脸的方式也只有我这么low的程序员使用了&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在计算的过程总遇到double转int的情况，总结了下实现的方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    Double d = 1.7d&lt;span&gt;;

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样会报错，因为double转换为字符串之后有.&lt;/span&gt;
&lt;span&gt;        System.out.println(Integer.parseInt(d.toString()));
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2_1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; double 类型可以直接转为int类型&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; dd = 1.1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ddd = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)dd;
        System.out.println(ddd);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2_2(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以通过强转进行转换，Double是包装类，不能直接进行强转，可以拆箱之后再次强转。&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; aa = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)(Double.parseDouble(d.toString()));
        System.out.println(aa);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这种方式最为简单&lt;/span&gt;
&lt;span&gt;        System.out.println(d.intValue());
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test4(){&lt;/span&gt;
        DecimalFormat format1 = &lt;span&gt;new&lt;/span&gt; DecimalFormat(&quot;#&quot;&lt;span&gt;);
        String s &lt;/span&gt;=&lt;span&gt; format1.format(d);
        System.out.println(s);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5(){
        DecimalFormat format1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DecimalFormat(&quot;#.#&quot;&lt;span&gt;);
        String s &lt;/span&gt;= format1.format(1.35&lt;span&gt;);
        System.out.println(s);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test6(){
        DecimalFormat format1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DecimalFormat(&quot;0.000&quot;&lt;span&gt;);
        String s &lt;/span&gt;= format1.format(1.35&lt;span&gt;);
        System.out.println(s);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;DecimalFormat 要四舍五入需要加上&lt;/span&gt; &lt;span&gt;setRoundingMode(RoundingMode.HALF_UP); &lt;span&gt;网上是这么说的，但是自己测试默认就会四舍五入&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;特殊字符说明&lt;/span&gt;&lt;br/&gt;“0” 指定位置不存在数字则显示为0 123.123 -&amp;gt;0000.0000 -&amp;gt;0123.1230&lt;br/&gt;“#” 指定位置不存在数字则不显示 123.123 -&amp;gt; ####.#### -&amp;gt;123.123&lt;br/&gt;“.” 小数点&lt;br/&gt;“%” 会将结果数字乘以100 后面再加上% 123.123 -&amp;gt;#.00-&amp;gt;1.3212%&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 嗯，就这么个坑了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Mar 2019 07:27:00 +0000</pubDate>
<dc:creator>陈灬大灬海</dc:creator>
<og:description>最近在做支付相关模块的业务，数据库字段却使用的是double类型，其实也行，只要计算不在sql语句中进行，也是没有问题的。 预先的类属性设置的是Double类型，自己算的时候发现小数相加会出现损失精度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-h-y/p/10456651.html</dc:identifier>
</item>
<item>
<title>OS开发（2）：自定义tabbar | 导航条 | 突显中间按钮 - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10456250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10456250.html</guid>
<description>&lt;p&gt;tabbar是放在APP底部的控件，也叫navigationbar或导航条。常见的APP都使用tabbar来进行功能分类的管理，比如微信、QQ等等。&lt;/p&gt;
&lt;p&gt;需求是这样的，需要一个特殊一点的tabbar，要求突显中间的那个按钮，让中间按钮特别显眼，从而引导用户去点击。所以，让中间按钮大于两边的按钮，是一个基本的要求。&lt;/p&gt;
&lt;p&gt;使用常规的UITabBar跟UITabBarController不能满足这个需求，但扩展它们，自定一下，就可以解决这个问题。另外，uitabbar是一个uiview，最终由uitabbarcontroller来管理，而uitabbarcontroller是一个uiviewcontroller。&lt;/p&gt;
&lt;h4 id=&quot;uitabbar&quot;&gt;（1）uitabbar&lt;/h4&gt;
&lt;p&gt;这是一个uiview，上面放一个按钮，这个按钮最终作为tabbar的中间按钮。&lt;/p&gt;
&lt;p&gt;实现代码是这样的：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/ios/%E8%87%AA%E5%AE%9A%E4%B9%89tabbar/uitabbar%E7%9A%84head%E6%96%87%E4%BB%B6.jpg&quot; alt=&quot;uitabbar的h文件&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/ios/%E8%87%AA%E5%AE%9A%E4%B9%89tabbar/uitabbar%E7%9A%84m%E6%96%87%E4%BB%B6.jpg&quot; alt=&quot;uitabbar的m文件&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;uitabbarcontroller&quot;&gt;（2）uitabbarcontroller&lt;/h4&gt;
&lt;p&gt;这是一个uiviewcontroller，用来管理tabbar上的所有tab的viewcontroller，以及中间按钮。&lt;/p&gt;
&lt;p&gt;实现代码是这样的：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/ios/%E8%87%AA%E5%AE%9A%E4%B9%89tabbar/uitabbarcontroller%E7%9A%84head%E6%96%87%E4%BB%B6.jpg&quot; alt=&quot;uitabbarcontroller的h文件&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/ios/%E8%87%AA%E5%AE%9A%E4%B9%89tabbar/uitabbarcontroller%E7%9A%84m%E6%96%87%E4%BB%B6.jpg&quot; alt=&quot;uitabbarcontroller的m文件&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/ios/%E8%87%AA%E5%AE%9A%E4%B9%89tabbar/uitabbarcontroller%E7%9A%84m%E6%96%87%E4%BB%B62.jpg&quot; alt=&quot;uitabbarcontroller的m文件2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的代码可以知道，每一个tab都是一个vc（可以设置文字与图片），这些vc都会add到uitabbarcontroller中。另外，关键点，用kvc的办法（setValue:forKeyPath）替换了原来的tabbar。&lt;/p&gt;
&lt;h4 id=&quot;使用自定义的uitabbarcontroller&quot;&gt;（3）使用自定义的uitabbarcontroller&lt;/h4&gt;
&lt;p&gt;使用的代码如下：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/ios/%E8%87%AA%E5%AE%9A%E4%B9%89tabbar/%E4%BD%BF%E7%94%A8uitabbarcontroller.jpg&quot; alt=&quot;使用uitabbarcontroller的代码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需要在APP的didFinishLaunchingWithOptions中，设置self.window.rootViewController为tabbarcontroller即可。&lt;/p&gt;
&lt;p&gt;最终执行的界面效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/ios/%E8%87%AA%E5%AE%9A%E4%B9%89tabbar/%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C.jpg&quot; alt=&quot;自定义tabbar运行效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上的实现，参考了这篇文章：&lt;a href=&quot;https://blog.csdn.net/c_calary/article/details/78834278&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/c_calary/article/details/78834278&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Mar 2019 06:34:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>tabbar是放在APP底部的控件，也叫navigationbar或导航条。常见的APP都使用tabbar来进行功能分类的管理，比如微信、QQ等等。 需求是这样的，需要一个特殊一点的tabbar，要求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeself/p/10456250.html</dc:identifier>
</item>
<item>
<title>Webpack 4教程：为什么要优化代码 - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/10456234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/10456234.html</guid>
<description>&lt;blockquote readability=&quot;6.5696721311475&quot;&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;br/&gt;原文出处：https://wanago.io/2018/07/30/webpack-4-course-part-five-built-in-optimization-for-production/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;left&quot;&gt;在本次Wepack 4教程，我们会聚焦通过压缩输出内容，来提升你应用的用户体验。这意味着，生产环境需要一套不同的做法。今天，我们将通过&lt;strong&gt;mode&lt;/strong&gt;参数来讲述Webpack内置的优化功能。开始吧！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;首先，让我们来回答究竟为什么要优化代码。如果你遵循良好的代码实践，你可能会致力于将代码写得容易阅读，所以你会添加很多空白符（tab、空格和空行）和注释。它让代码更好读，但也让文件变大了。另一方面，为了用户体验而牺牲可阅读性，这是不可取的。要在生产环境手动删除无用代码是非常繁琐的事情。因此，对这个问题已有了现成的解决方案，你可以在项目中拿来就用。&lt;/p&gt;
&lt;div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;生产环境模式&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;mode&lt;/strong&gt;是Webpack 4引入的一个参数。自此，就需要在配置中设置它。如果不配置它，会得到一个警告，并应用上默认值production。如果使用了mode: &quot;produnction&quot;，Webpack会为你设置一些相关配置。因此，你的打包输出会更好地用于生产环境。我们会一步步学习它具体为我们做了什么事。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;UglifyJsPlugin&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;把&lt;strong&gt;mode&lt;/strong&gt;设置为produnction会为我们的配置添加&lt;strong&gt;UglifyJsPlugin&lt;/strong&gt;插件。它通过压缩代码让其更小和更快。从简单的任务，比如缩减你的变量名或者删除多余的空白，到删除冗余代码，它都能做到。默认情况下，它会解析每一个 &lt;strong&gt;.js&lt;/strong&gt; 文件。我们会在本文介绍&lt;strong&gt;UglifyJsPlugin&lt;/strong&gt;最基本的配置。虽然Webpack 4根据选择的&lt;strong&gt;mode&lt;/strong&gt;为你做了优化，但你仍然可以通过&lt;strong&gt;optimization&lt;/strong&gt;属性配置它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// webpack.config.js
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');

module.exports = {
  mode: &quot;production&quot;,
  // 使用 mode: &quot;production&quot; 后会添加下面的配置：
  optimization: {
    minimize: true,
      minimizer: [
        new UglifyJsPlugin()
      ]
    },
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;你能传给&lt;strong&gt;UglifyJsPlugin&lt;/strong&gt;的最重要的属性叫做uglifyOptions。它有许多默认的配置。其中一个最值得注意的部分是&lt;strong&gt;compress&lt;/strong&gt;属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// webpack.config.js
new UglifyJsPlugin({
  uglifyOptions: {
    compress: {
      /*(...)*/
    }
  } 
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;它负责配置&lt;strong&gt;UglifyJsPlugin&lt;/strong&gt;所做的许多重量级工作，以让你的代码更精简。你可以在&lt;span&gt;&lt;a href=&quot;https://github.com/mishoo/UglifyJS2/tree/harmony#compress-options&quot; target=&quot;_blank&quot;&gt;官方列表&lt;/a&gt;&lt;/span&gt;查看完整的可用配置。它也有一些默认值。&lt;/p&gt;
&lt;p&gt;另一个UglifyJsPlugin配置的重要属性是&lt;strong&gt;output&lt;/strong&gt;　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
new UglifyJsPlugin({
  uglifyOptions: {
    compress: {
      /*(...)*/
    },
    output: {
      /*(...)*/
    }
  }
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;默认情况下，输出的代码会尽可能的简短。你可以配置&lt;strong&gt;output&lt;/strong&gt;来改变这种行为。你可能不会想要修改大部分的默认配置，但是有一个值得考虑的属性是&lt;strong&gt;drop_console&lt;/strong&gt;，它默认设置为false。把它改为true将会去除所有的console.log调用。若想了解更多关于&lt;strong&gt;output&lt;/strong&gt;的配置，请查看&lt;span&gt;&lt;a href=&quot;https://github.com/mishoo/UglifyJS2/tree/harmony#user-content-output-options&quot; target=&quot;_blank&quot;&gt;完整列表&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;UglifyJsPlugin有很多可选配置。你可以在&lt;span&gt;&lt;a href=&quot;https://github.com/webpack-contrib/uglifyjs-webpack-plugin&quot; target=&quot;_blank&quot;&gt;Github上的文档&lt;/a&gt;&lt;/span&gt;里看到所有这些。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;DefinePlugin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个插件允许你在&lt;strong&gt;编译时&lt;/strong&gt;创建全局常量。如果你使用mode: &quot;produnction&quot;，Webpack会默认设置上： &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;produnction&quot;)。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// webpack.config.js
module.exports = {
  mode: &quot;production&quot;,
  // 使用 mode: &quot;production&quot; 会添加以下内容：
  plugins: [
    new webpack.DefinePlugin({
      &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;)
    }),
  ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;注意，由于是纯文本的替换，传给此属性的值必须用引号括起来。它可以通过JSON.stringify(&quot;produnction&quot;)或者'&quot;produnction&quot;'实现。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;编译时&lt;/strong&gt;解析它，意味着如果你在代码中使用了process.env.NODE_ENV，它将会被替换为&quot;produnction&quot;。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
console.log(process.env.NODE_ENV);
if(process.env.NODE_ENV === 'production') {
  console.log('this is production!');
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;请记住，process.env.NODE_ENV的值在编译之后不会被保留。使用Webpack处理上面的代码，会得到：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
console.log(&quot;production&quot;);
if(true) {
  console.log(&quot;this is production!&quot;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;在经过UglifyJsPlugin的最小化处理之后，它得到简化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
console.log(&quot;production&quot;);
console.log(&quot;this is production!&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;NoEmitOnErrorsPlugin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个插件会帮你处理编译时的错误。例如，你可能会尝试导入Webpack不能解析的某个文件。在这种情况下，Webpack会为应用创建一个包含错误信息的版本。使用&lt;strong&gt;NoEmitOnErrorsPlugin&lt;/strong&gt;插件后，这个错误信息版本根本就不会被创建。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// webpack.config.js
const webpack = require('webpack');

module.exports = {
  mode: &quot;produnction&quot;,
  // 使用mode: produnction，会添加如下的配置
  plugins: [
    new webpack.NoEmitOnErrorsPlugin()
  ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;ModuleConcatenationPlugin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Webpack创建单独的闭包来包含每个模块。这个包裹函数会轻微地减缓你代码的运行速度。请看这个例子：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// one.js
const dog = 'Fluffy';
export const one = 1;
// two.js
const dog = 'Fluffy';
export const two = 2;
// index.js
import { one } from './one';
import { two } from './two';
const dog = 'Fluffy';

console.log(one, two);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果没有ModuleConcatenationPlugin，输出的包看起来像这样：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// main.js
(function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _one__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _two__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);

const dog = 'Fluffy';

console.log(_one__WEBPACK_IMPORTED_MODULE_0__[&quot;one&quot;], _two__WEBPACK_IMPORTED_MODULE_1__[&quot;two&quot;]);

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;one&quot;, function() { return one; });
const dog = 'Fluffy';
const one = 1;


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;two&quot;, function() { return two; });
const dog = 'Fluffy';
const two = 2;

/***/ })
/******/ ]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;当你把&lt;strong&gt;mode&lt;/strong&gt;设为&lt;strong&gt;production&lt;/strong&gt;，此插件就开始工作了。这样一来，输出的包现在都在一个scope里了。更少的函数意味着更少的运行时开销。&lt;/p&gt;
&lt;p&gt;注意，我在这个例子中没有使用任何优化配置。由于优化器其实已经知道模块之间的内部依赖，它能更好地完成任务。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// main.js
(function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;

// 串起来的模块: ./src/one.js
const dog = 'Fluffy';
const one = 1;

// 串起来的模块: ./src/two.js
const two_dog = 'Fluffy';
const two = 2;
// 串起来的模块: ./src/index.js

const src_dog = 'Fluffy';

console.log(one, two);
/***/ })
/******/ ]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;如果你觉得感兴趣，可查看&lt;span&gt;&lt;a href=&quot;https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5&quot; target=&quot;_blank&quot;&gt;webpack博客上的这篇文章&lt;/a&gt;&lt;/span&gt;，它对此给出了更多信息。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;今天我们学习了Webpack能通过设置mode: &quot;produnction&quot;做的内置优化。这能使你的应用加载更快，性能更好。它通过配置一系列打包流程，以满足你生产环境的要求。本教程的下一部分，我们将介绍&lt;strong&gt;mode&lt;/strong&gt;的&lt;strong&gt;development&lt;/strong&gt;配置。敬请期待！&lt;/p&gt;

</description>
<pubDate>Fri, 01 Mar 2019 06:31:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>在本次Wepack 4教程，我们会聚焦通过压缩输出内容，来提升你应用的用户体验。这意味着，生产环境需要一套不同的做法。今天，我们将通过mode参数来讲述Webpack内置的优化功能。开始吧！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powertoolsteam/p/10456234.html</dc:identifier>
</item>
<item>
<title>tomcat 配置文件server.xml 详解 Connector Engine Host Context - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/10453678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/10453678.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/2019-03-01_152304.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-server.xml&quot;&gt;一 server.xml&lt;/h2&gt;
&lt;p&gt;server.xml 是tomcat 的核心配置文件，位于./conf/ 下.具有server,connector&lt;br/&gt;Hosts 等元素模块。接下来我们看看吧。(导游介绍词)。本文内容&lt;strong&gt;基于tomcat 8.5&lt;/strong&gt; 不同版本配置或有差异性。&lt;br/&gt;tomcat 8.5是基于Servlet 3.1和JavaServer Pages 2.3。&lt;/p&gt;
&lt;p&gt;tomcat 测试war包下载路径 &lt;a href=&quot;http://tomcat.apache.org/tomcat-8.5-doc/appdev/sample/sample.war&quot;&gt;测试war包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;server.xml 结构图(还有些其他元素没有加入)&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/tomcat-server_xml.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;server-配置&quot;&gt;1.1 server 配置&lt;/h3&gt;
&lt;p&gt;server 是server.xml 的最外层元素，常用的属性有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;className&lt;/td&gt;
&lt;td&gt;要使用的java 类名&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;address&lt;/td&gt;
&lt;td&gt;服务器等待接收shutdown 命令的地址,默认localhost&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;接收shutdown命令的端口，设置为-1 为禁用关闭端口，也就是你不能通过这种方式来关闭了,这样就会影响你使用脚本(catalina.sh 或者是shutdown.sh)来stop了，默认绑定8005端口&lt;/td&gt;
&lt;td&gt;port=&quot;8005&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;shutdown&lt;/td&gt;
&lt;td&gt;指定shutdown 命令的别名,默认值SHUTDOWN&lt;/td&gt;
&lt;td&gt;shutdown=&quot;SHUTDOWN&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;service-配置&quot;&gt;1.2 service 配置&lt;/h3&gt;
&lt;p&gt;service 是 server 的内层。可以将一个多个service 放在server 层里，&lt;br/&gt;一个service 里面可以有多个 Connector 和一个Engine .&lt;/p&gt;
&lt;p&gt;service 的属性&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;className&lt;/td&gt;
&lt;td&gt;要使用的java类名，未指定的话就使用标准的实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;service显示的名称&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;executor&quot;&gt;1.3 Executor&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://tomcat.apache.org/tomcat-8.5-doc/config/executor.html&quot;&gt;官方文档链接&lt;/a&gt;&lt;br/&gt;这个元素我们在平时配置的过程中用得比较少，它主要用于在多个connector 之间进行共享线程池。它的位置应该在 connector 之前，这样才能生效。&lt;/p&gt;
&lt;p&gt;Executor 的属性 ：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;className&lt;/td&gt;
&lt;td&gt;要使用的java类名&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;用于在server.xml中的其他位置引用此池的名称。该名称是必需的，必须是唯一的。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;threadPriority&lt;/td&gt;
&lt;td&gt;执行程序中线程的优先级 ，默认为5&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;daemon&lt;/td&gt;
&lt;td&gt;线程是否为守护线程，默认为 True&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;namePrefix&lt;/td&gt;
&lt;td&gt;每个线程的名称的前缀，单个线程的名称=namePrefix+threadNumber&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;maxThreads&lt;/td&gt;
&lt;td&gt;该线程池中最大的线程数，默认为200&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;minSpareThreads&lt;/td&gt;
&lt;td&gt;最小线程数，就是在空闲时保持的最少线程数 ，默认为25&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;maxIdleTime&lt;/td&gt;
&lt;td&gt;空闲线程关闭之前等待的时间，单位毫秒，默认是6000毫秒也就是一分钟&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;maxQueueSize&lt;/td&gt;
&lt;td&gt;最大任务等待的数量，默认值是Integer.MAX_VALUE，也就是2147483647(java int整数的最大值)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;prestartminSpareThreads&lt;/td&gt;
&lt;td&gt;是否应该在启动Executor时启动minSpareThreads，默认值为 false&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;connector-配置&quot;&gt;1.4 Connector 配置&lt;/h3&gt;
&lt;p&gt;关于 Connector &lt;a href=&quot;http://tomcat.apache.org/tomcat-8.5-doc/config/http.html&quot;&gt;官网链接&lt;/a&gt;&lt;br/&gt;当前以下所有的说明是针对 tomcat 8.5版本来说的，其他版本详情见官方文档。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;40.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;绑定的端口,如果设置为0，tomcat则随机获取一个空闲端口&lt;/td&gt;
&lt;td&gt;默认 port=&quot;8080&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;protocol&lt;/td&gt;
&lt;td&gt;传输协议和版本&lt;/td&gt;
&lt;td&gt;默认 protocol = &quot;HTTP/1.1&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;connectionTimeout&lt;/td&gt;
&lt;td&gt;连接超时时间，单位毫秒&lt;/td&gt;
&lt;td&gt;默认 connectionTimeout=&quot;20000&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;redirectPort&lt;/td&gt;
&lt;td&gt;接收到的ssl请求后重定向的端口&lt;/td&gt;
&lt;td&gt;默认 redirectPort=&quot;8443&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;maxThreads&lt;/td&gt;
&lt;td&gt;tomcat能创建来处理请求的最大线程数，也为最大并发数 超过则放入请求队列中进行排队，默认值为200；需要根据业务和系统性能进行调整&lt;/td&gt;
&lt;td&gt;maxThreads=&quot;1000&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;URIEncoding&lt;/td&gt;
&lt;td&gt;url的字符编码，在tomcat8.5版本中，该值默认为UTF-8,除非在org.apache.catalina.STRICT_SERVLET_COMPLIANCE 将system property 设置为true才会使用ISO-8859-1&lt;/td&gt;
&lt;td&gt;URIEncoding=&quot;UTF-8&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;minProcessors&lt;/td&gt;
&lt;td&gt;启动时创建的线程数（最小线程数）&lt;/td&gt;
&lt;td&gt;minProcessors=&quot;50&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;acceptCount&lt;/td&gt;
&lt;td&gt;指定当所有可以使用的处理请求的线程数都被使用时，可以放到队列中的请求数，就是被排队的请求数，超过这个数的请求将拒绝连接 默认值为100&lt;/td&gt;
&lt;td&gt;acceptcount=&quot;500&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;acceptorThreadCount&lt;/td&gt;
&lt;td&gt;可以用于接受连接的进程数，默认为1，但是在一些多核的的服务器上，我们会将它的值设置为2或者更大的数，来应对一些不活跃的连接。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;minSpareThreads&lt;/td&gt;
&lt;td&gt;最小空闲线程数，任何情况都会存活的线程数，即便超过了最大空闲时间，也不会被回收，默认值10;&lt;/td&gt;
&lt;td&gt;minSpareThreads=&quot;25&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;maxSpareThreads&lt;/td&gt;
&lt;td&gt;最大空闲线程数，在最大空闲时间（maxIdleTime）内活跃过，此时空闲，当空闲时间大于maxIdleTime则被回收，小则继续存活，等待被调度，默认值50；&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;enableLookups&lt;/td&gt;
&lt;td&gt;调用request、getRemoteHost()执行DNS查询，以返回远程主机的主机名，如果设置为false，则直接返回IP地址 默认是禁用的，在请求过滤中的根据远程主机名过滤，需要将该参数设置为true&lt;/td&gt;
&lt;td&gt;enableLookups=&quot;false&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;maxIdleTime&lt;/td&gt;
&lt;td&gt;最大空闲时间，超过这个空闲时间，且线程数大于minSpareThreads的，都会被回收，默认值1分钟（60000ms)&lt;/td&gt;
&lt;td&gt;maxPostSize&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;address&lt;/td&gt;
&lt;td&gt;对于一些具有多个ip的服务器，我们可以通过该参数指定绑定的ip，默认情况下监听所有的地址&lt;/td&gt;
&lt;td&gt;address=&quot;192.168.1.110&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;compressibleMimeType&lt;/td&gt;
&lt;td&gt;该值用来指定哪些文件类型的文件可以进行压缩，默认值为：text/html,text/xml,text/plain,text/css,text/javascript,application/javascript&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;compression&lt;/td&gt;
&lt;td&gt;开启gzip 压缩，可以接受的值是 &quot;off&quot;(禁用压缩),&quot;on&quot;(开启压缩),&quot;force(强制压缩)&quot;，&quot;1-9&quot;(等效于开启压缩，并且设定压缩等级),开启了压缩，也就意味着要占用更多的cpu资源&lt;/td&gt;
&lt;td&gt;compression&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;compressionMinSize&lt;/td&gt;
&lt;td&gt;在compression 参数指定为on后，该参数用来指定压缩的阈值，只有大于该阈值才会被压缩，默认为 2048&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;keepAliveTimeout&lt;/td&gt;
&lt;td&gt;指connector两个HTTP请求直接的等待时间，超过该时间没有接收到第二个HTTP请求就关闭连接，默认是使用connectionTimeout 的值，单位为毫秒&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;maxConnections&lt;/td&gt;
&lt;td&gt;在一定时间内可以接受和处理的最大连接数，达到限制后，服务器接受但不处理该链接，但可以存放到acceptCount，该默认值因连接器类型而异。对于NIO和NIO2，默认值为10000。对于APR / native，默认为8192。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;maxCookieCount&lt;/td&gt;
&lt;td&gt;请求允许的最大cookie 数，值小于0表示无限制，默认值为 200&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;disableUploadTimeout&lt;/td&gt;
&lt;td&gt;默认是true ，禁用数据上传超时&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;connectionUploadTimeout&lt;/td&gt;
&lt;td&gt;设定数据上传的超时时间，只有在disableUploadTimeout设置为false才生效，单位毫秒&lt;/td&gt;
&lt;td&gt;connectionUploadTimeout=&quot;50000&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;processorCache&lt;/td&gt;
&lt;td&gt;进程缓冲器，默认值是maxThreads的值,使用好该值可以提升并发请求。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;示例配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot; 
               acceptCount=&quot;300&quot; &amp;lt;!--默认值为100--&amp;gt;
               acceptorThreadCount=&quot;2&quot; &amp;lt;!--默认值为1,在多核的情况下可设置该值--&amp;gt;
               compression=&quot;on&quot; &amp;lt;!-- 开启对响应数据的压缩传输--&amp;gt;
               keepAliveTimeout=&quot;25000&quot; &amp;lt;!-- 等待请求时间 默认值是使用为connectionTimeout属性设置的值 --&amp;gt;
               maxConnections=&quot;5000&quot; &amp;lt;!-- 服务器在给定时间接受和处理的最大连接数，对于NIO和NIO2，默认值为10000。对于APR / native，默认为8192。--&amp;gt;
               maxThreads=&quot;400&quot; &amp;lt;!-- 最大并发数,默认为200--&amp;gt;
               minSpareThreads=&quot;25&quot; &amp;lt;!-- 始终保持运行的最小连接数，默认值为10--&amp;gt;
               /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;maxThreads 配置说明(网上盗图，不提倡啊，哈哈)&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/tomcat_maxthreads.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;engine&quot;&gt;1.5 Engine&lt;/h3&gt;
&lt;p&gt;Engine 结构示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/Engine.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Engine 的属性&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;className&lt;/td&gt;
&lt;td&gt;要使用的实现的Java类名。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;defaultHost&lt;/td&gt;
&lt;td&gt;默认的主机名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;Engine 的名称，在一个server 中使用多个service元素时，必须给每个Engine分配一个唯一的名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;startStopThreads&lt;/td&gt;
&lt;td&gt;启动Host 的线程数，默认为1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Engine 必须嵌套在service 中。&lt;/p&gt;
&lt;h4 id=&quot;host官网文档链接&quot;&gt;Host(&lt;a href=&quot;http://tomcat.apache.org/tomcat-8.5-doc/config/host.html&quot;&gt;官网文档链接&lt;/a&gt;)&lt;/h4&gt;
&lt;p&gt;host 元素表示一个虚拟主机，我们常将一个主机与一个应用程序相连接&lt;br/&gt;host 元素嵌套在Engine 元素里面。我们可以将Context 元素嵌套在Host元素里面。&lt;br/&gt;Host 的属性&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;域名名称，tomcat会将其全部转化为小写，如果你设置的是*.baidu.com,那么你将匹配www.baidu.com admin.baidu.com 等等以baidu.com 结尾的域名。那么只有是符合该域名的条件的请求才能接受。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;appBase&lt;/td&gt;
&lt;td&gt;指的是虚拟主机的应用程序目录，可以是绝对路径，也可以是相对tomcat目录的相对路径，如果未指定将使用默认值&quot;webapps&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;unpackWARs&lt;/td&gt;
&lt;td&gt;默认为true,如果设置为true 表示将web应用程序war包解压，false表示直接从war文件运行。注意点1：如果设置为true,tomcat解压了该应该程序的包，会向该解压缩的包里面添加一个文件(/META-INF/war-tracker),用于在tomcat未运行时检测war文件(注意是war文件而不是解压目录里面的文件)是否更改。如果war文件更改了，则会重新加载。是针对未启动的时候啊，如果是tomcat正常启动的话更改war包的话是会自动重新加载发布的。注意点2： 如果该属性设置为false的话将导致性能下降&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;autoDeploy&lt;/td&gt;
&lt;td&gt;指tomcat在运行时是否要定期检查有没有新的应用程序，如果true,tomcat会定期检查appBase 和xmlBase 目录，如果找到了会自动部署的web应用程序，默认为true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;xmlBase&lt;/td&gt;
&lt;td&gt;指包含该Host部署的应用程序的Context的xml文件路径。可以是绝对路径也可以是相对tomcat目录的相对路径。如果未指定将使用&quot;conf//&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;createDirs&lt;/td&gt;
&lt;td&gt;指在tomcat启动的时候将创建appBase和xmlBase定义的目录，默认为true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;className&lt;/td&gt;
&lt;td&gt;要使用的实现的Java类名，如果没有指定，将使用标准值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;deployIgnore&lt;/td&gt;
&lt;td&gt;这个属性是相对appBase的，foo只能匹配文件或者目录foo，而不能匹配foo.war&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;deployOnStartup&lt;/td&gt;
&lt;td&gt;指tomcat在启动时是否应该自动部署来自该Host的web应用程序，默认为true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;startStopThreads&lt;/td&gt;
&lt;td&gt;指Host用于启动Context的线程数，默认值为1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;undeployOldVersions&lt;/td&gt;
&lt;td&gt;在自动部署的情况下，tomcat是否检查旧的未使用的web应用程序，如果找到，将其删除，在autoDeploy为true且本属性为true才生效，默认值为false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;deployXML&lt;/td&gt;
&lt;td&gt;如果你不想使用web应用程序的/META-INF/context.xml,你可以将该值设置为false,线上环境也建议设置为false,&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;copyXML&lt;/td&gt;
&lt;td&gt;该属性的值如果设置为true,会在程序启动时(且xmlBase无该应用程序对应的xml文件)将位于应用程序的/META-INF/context.xml 的文件，复制到xmlBase下，如果有的话是不会复制的，后续是会以xmlBase里的xml的配置为主的，即使应用程序的/META-INF/context.xml更新了，也是不会生效的。默认为false. copyXML的属性要生效的话前提得deployXML 属性为true，否则不生效。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;workDir&lt;/td&gt;
&lt;td&gt;指该Host 应用程序要使用的临时目录的路径名，如果在Context中也指定了workDir将替换掉这里的配置，如果未指定，默认为$CATALINA_BASE/work。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当autoDeploy 为true 时，tomcat 在启动后会监控部署的web应用程序的文件是否改变，根据具体的改变，web应用程序将重新加载或重新部署。重新部署的不会保留用户会话，重新加载的则会保留。&lt;/p&gt;
&lt;p&gt;Context 中的docBase 的路径应该在appBase(Host)之外，否则可能会导致部署两次，属性deployIgnore可以避免这种情况。&lt;br/&gt;如果在server.xml 中定义了Context 属性，则应该关闭deployIgnore,和自动部署应用程序。&lt;/p&gt;
&lt;h4 id=&quot;日志记录官网链接&quot;&gt;日志记录(&lt;a href=&quot;http://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Access_Logging&quot;&gt;官网链接&lt;/a&gt;)&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;buffered&lt;/td&gt;
&lt;td&gt;是否缓冲日志记录，默认为True,如果设置为false,则在每次请求后将写入访问日志记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;className&lt;/td&gt;
&lt;td&gt;要使用的实现的java类名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;directory&lt;/td&gt;
&lt;td&gt;存放日志文件的目录的相对路径或者绝对路径，默认值为$ CATALINA_BASE/logs&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;encoding&lt;/td&gt;
&lt;td&gt;用于写日志文件的字符集。空字符串表示使用系统默认字符集。默认值：使用系统默认字符集。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;fileDateFormat&lt;/td&gt;
&lt;td&gt;设定访问日志文件切割时间，默认值为.yyyy-MM-dd，也就是每天切割一次，如果你希望每小时切割一次则设置为.yyyy-MM-dd.HH&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;maxDays&lt;/td&gt;
&lt;td&gt;保留日志的最大天数，如果未指定的话，默认值为-1，意味着将永远不会删除旧文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;maxLogMessageBufferSize&lt;/td&gt;
&lt;td&gt;日志消息缓冲区大小,默认大小为256bytes，该值应该设置为大于常规日志的消息大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;prefix&lt;/td&gt;
&lt;td&gt;日志前缀，为每个日志文件名称的开头，如果未指定，则默认值为&quot;access_log&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;renameOnRotate&lt;/td&gt;
&lt;td&gt;设置为true 时，当天的日志是不会带有时间戳的，过往日志是会带有的，设置为false当天的日志也带有时间戳的，默认为false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;rotatable&lt;/td&gt;
&lt;td&gt;用于设置日志是否切割的标准，默认为true,如果设置为false的话，则该文件永远不会被切割，且忽略参数fileDateFormat&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;suffix&lt;/td&gt;
&lt;td&gt;日志文件的后缀名称，默认为&quot;&quot;,表示不添加后缀&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;pattern&lt;/td&gt;
&lt;td&gt;是指日志格式，也就是我们日志输出的内容和格式具体配置见下文&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;pattern&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;％a - 远程IP地址
％A - 本地IP地址
％b - 发送的字节数，不包括HTTP标头，如果为零则为“ - ”
％B - 发送的字节数，不包括HTTP标头
％h - 远程主机名（如果enableLookups连接器为false，则为IP地址 ）
％H - 请求协议
％l - 来自identd的远程逻辑用户名（始终返回' - '）
％m - 请求方法（GET，POST等）
％p - 收到此请求的本地端口。
％q - 查询字符串（前缀为'？'，如果存在）
％r - 请求首行（方法和请求URI）
％s - 响应的HTTP状态代码
％S - 用户会话ID
％t - 日期和时间，采用通用日志格式
％u - 经过身份验证的远程用户（如果有），否则为“ - ”
％U - 请求的URL路径
％v - 本地服务器名称
％D - 处理请求所用的时间(以毫秒为单位)
％T - 处理请求所用的时间，以秒为单位
％F - 提交响应所用的时间，以毫秒为单位
％I - 当前请求线程名称
％X - 响应完成时的连接状态：
    X =连接在响应完成之前中止。
    + =发送响应后，连接可以保持活动状态。
    - =发送响应后将关闭连接。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pattern=&quot;common&quot; 对应于'％h％l％u％t“％r”％s％b'定义的通用日志格式 。&lt;br/&gt;pattern=&quot;combined&quot; 将 每个双引号中的Referer和User-Agent标题的值附加到common模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认访问日志配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
               pattern=&quot;%h %l %u %t &amp;amp;quot;%r&amp;amp;quot; %s %b&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;请求过滤器基于请求ip-官网链接&quot;&gt;请求过滤器(基于请求ip &lt;a href=&quot;http://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Remote_Address_Filter&quot;&gt;官网链接&lt;/a&gt;)&lt;/h4&gt;
&lt;p&gt;基于ip地址对请求进行过滤处理。限制条件可以使用正则表达式，但是它和普通的正则语法有所不同，它采用的是java.util.regex 包。可以用&quot;;&quot; 来分割端口限制。&lt;br/&gt;拒绝请求时的行为可以更改为不拒绝，而是设置无效的authentication 标头。这与context属性 preemptiveAuthentication=&quot;true&quot; 结合使用。&lt;/p&gt;
&lt;p&gt;在过滤带有ipv6地址的请求的时候，需要注意过滤器匹配的ip地址格式，详细见官网。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;className&lt;/td&gt;
&lt;td&gt;要使用的实现的Java类名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;allow&lt;/td&gt;
&lt;td&gt;ip地址，多个以逗号分隔如果指定了此属性，则远程地址必须匹配此请求才能被接受。如果未指定此属性，则将接受所有请求，除非远程IP与deny属性中的网络掩码匹配。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;deny&lt;/td&gt;
&lt;td&gt;ip地址，多个以逗号分隔如果指定了此属性，如果指定了此属性，则远程地址必须不匹配才能接受此请求。如果未指定此属性，则请求接受仅受accept 属性控制。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;denyStatus&lt;/td&gt;
&lt;td&gt;拒绝请求时使用的HTTP响应状态代码。默认值为403。例如，它可以设置为值404。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;addConnectorPort&lt;/td&gt;
&lt;td&gt;匹配请求的主机名和端口，设置为true 的话ip（deny的值）和端口(connector 端口)都符合要求的话才能接受请求，默认为false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;invalidAuthenticationWhenDeny&lt;/td&gt;
&lt;td&gt;当请求要被拒绝时，不要直接拒绝，采用设置无效的authentication标头，来拒绝，这是在context设置 preemptiveAuthentication=&quot;true&quot;时才可以设置的&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;仅允许从localhost 连接&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;
   allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;仅允许允许从localhost 连接，但其它客户端连接到8443的不受限制&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;
   addConnectorPort=&quot;true&quot;
   allow=&quot;127\.\d+\.\d+\.\d+;\d*|::1;\d*|0:0:0:0:0:0:0:1;\d*|.*;8443&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.允许任何客户端请求访问8009端口，其它端口要触发身份验证&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Context&amp;gt;
  ...
  &amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;
         addConnectorPort=&quot;true&quot;
         invalidAuthenticationWhenDeny=&quot;true&quot;
         allow=&quot;.*;8009&quot;/&amp;gt;
  &amp;lt;Valve className=&quot;org.apache.catalina.authenticator.BasicAuthenticator&quot; /&amp;gt;
  ...
&amp;lt;/Context&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;请求过滤器基于请求主机名-官网链接&quot;&gt;请求过滤器（基于请求主机名 &lt;a href=&quot;http://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Remote_Host_Filter&quot;&gt;官网链接&lt;/a&gt;）&lt;/h4&gt;
&lt;p&gt;用于限制不符合条件的客户端，接收符合条件的客户端。&lt;br/&gt;限制条件可以使用正则表达式，但是它和普通的正则语法有所不同，它采用的是java.util.regex 包。&lt;/p&gt;
&lt;p&gt;拒绝请求时的行为可以更改为不拒绝，而是设置无效的authentication 标头。这与context属性 preemptiveAuthentication=&quot;true&quot; 结合使用。&lt;/p&gt;
&lt;p&gt;注意：此过滤器返回的值获取方法ServletRequest.getRemoteHost()需要获取正确的主机名。要允许该方法返回正确的主机名，您必须在 connector 上启用 enableLookups 参数。（因为该过滤器是基于主机名过滤，所以要开启获取主机名才能获取到主机名的值）&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;className&lt;/td&gt;
&lt;td&gt;要使用的实现的java类名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;allow&lt;/td&gt;
&lt;td&gt;请求的主机名和正则表达式进行比较，如果指定了该属性，必须要满足条件才能接受请求，如果未指定此属性，则除非请求主机名与deny 模式匹配，否则将接受所有请求。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;deny&lt;/td&gt;
&lt;td&gt;满足该条件的请求被拒绝，如果未指定此属性，则请求接受仅受allow属性控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;denyStatus&lt;/td&gt;
&lt;td&gt;拒绝请求时使用的HTTP响应状态代码。默认值为403。例如，它可以设置为值404。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;addConnectorPort&lt;/td&gt;
&lt;td&gt;匹配请求的主机名和端口，设置为true 的话 ip（deny的值）和端口(connector 端口)都符合要求的话才能接受请求，默认为false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;invalidAuthenticationWhenDeny&lt;/td&gt;
&lt;td&gt;当请求要被拒绝时，不要直接拒绝，采用设置无效的authentication标头，来拒绝，这是在context设置 preemptiveAuthentication=&quot;true&quot;时才可以设置的&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;context-配置-官网链接&quot;&gt;context 配置 (&lt;a href=&quot;http://tomcat.apache.org/tomcat-8.5-doc/config/context.html&quot;&gt;官网链接&lt;/a&gt;)&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;It is NOT recommended to place &amp;lt;Context&amp;gt; elements directly in the server.xml file.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议我们不要将context 直接放在server.xml 文件里面，因为这样不太安全。放在conf/server.xml 下的话，如果不重新启动tomcat的话是无法加载里面的配置的。如果我们在其他位置也配置了context的话，是会覆盖server.xml 的配置的。如果我们仍要以server.xml 的文件为主的话，那么我们需要将context 的override 参数设置为true .&lt;br/&gt;但我实际测试的话，发现不设置override为true ,在server.xml 和conf/Catalina/localhost/djx.xml 配置相同的path 名称，不同的war包最后还是server.xml 生效了。&lt;/p&gt;
&lt;p&gt;context 元素定义的三种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;conf/server.xml (不建议)&lt;br/&gt;示例&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;Context  path=&quot;/djx&quot;  docBase=&quot;/tmp/svnadmin.war&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;webapps/appname/META-INF/context.xml，&lt;br/&gt;示例： manager/META-INF/context.xml&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the &quot;License&quot;); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--&amp;gt;
&amp;lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &amp;gt;
  &amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;
         allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&amp;gt;
  &amp;lt;Manager sessionAttributeValueClassNameFilter=&quot;java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap&quot;/&amp;gt;
&amp;lt;/Context&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;conf/Catalina/localhost/djx.xml ，文件名为访问路径，示例：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;Context docBase=&quot;/tmp/sample.war&quot; reloadable=&quot;false&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;br/&gt;除了server.xml 外，任何定义Context的文件只能定义一个context 元素&lt;/p&gt;
&lt;p&gt;context 的属性&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;docBase&lt;/td&gt;
&lt;td&gt;web应用程序的路径，如果使用了符号链接的话，那么更改了链接的话需要重新启动tomcat才能生效&lt;/td&gt;
&lt;td&gt;docBase=&quot;/tmp/svnadmin.war&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;override&lt;/td&gt;
&lt;td&gt;设置为true，则忽略全局中的设置，以现有的来覆盖之前的，默认为false&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;path&lt;/td&gt;
&lt;td&gt;匹配对应的web应用，与请求的url的开头匹配，如果指定为&quot;&quot;的话，该应用接收未匹配的所有请求&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;reloadable&lt;/td&gt;
&lt;td&gt;设置为true表示Catalina将监视 /WEB-INF/classes/和/WEB-INF/lib的文件，一旦发生更改将自动重新加载Web应用程序。它可以在在开发的时候使用，但需要消耗更多资源，官方文档写到不建议在生产环境上使用，所以它的默认值是false.&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;workDir&lt;/td&gt;
&lt;td&gt;设置临时文件和目录的路径，如果未指定，默认临时目录在在$CATALINA_BASE/work&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;preemptiveAuthentication&lt;/td&gt;
&lt;td&gt;默认为false，当设置为true，用户为不受安全约束保护的资源提供凭据，如果身份验证器支持抢占式身份验证，那么将处理用户的凭据，该参数和过滤请求中的属性invalidAuthenticationWhenDeny关联&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Context 路径命名示例&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/tomcatxml%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E7%A4%BA%E4%BE%8B.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WatchedResource 属性，用于监控war包后的解压文件，如果更改则自动重新加载&lt;br/&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;WatchedResource&amp;gt;WEB-INF/web.xml&amp;lt;/WatchedResource&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是server.xml 的一些元素和属性，还有一些我们没有列举的，我们可以去官网文档查看。&lt;/p&gt;
&lt;h3 id=&quot;其他tocmat-文章&quot;&gt;其他tocmat 文章&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10021645.html&quot;&gt;tomcat 安装部署&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10021645.html#%E5%8D%81-jenkins%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2tomcat&quot;&gt;jenkins 自动部署到tomcat 插件&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10021645.html#%E5%8D%81%E4%B8%80-tomcat-%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A1%A5%E5%85%85&quot;&gt;tomcat-部署项目的三种方法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/9680040.html&quot;&gt;tomcat 日志详解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10455491.html&quot;&gt;针对tomcat 的自问自答与总结&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10455491.html#tomcat-%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E5%90%AF%E5%8A%A8%E5%90%8E%E6%9B%B4%E6%96%B0%E6%98%AF%E5%90%A6%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD&quot;&gt;tomcat 的重复部署加载问题解决办法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10455491.html#tomcat-%E7%9A%84context.xml-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%A6%86%E7%9B%96%E5%8E%9F%E5%88%99&quot;&gt;tomcat 读取context 顺序&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/operationhome/p/10455491.html#%E9%81%BF%E5%85%8D%E4%BA%8C%E6%AC%A1%E9%83%A8%E7%BD%B2%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;tomcat 更新部署的多种情况&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Mar 2019 06:30:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>[TOC] 一 server.xml server.xml 是tomcat 的核心配置文件，位于./conf/ 下.具有server,connector Hosts 等元素模块。接下来我们看看吧。(导</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/operationhome/p/10453678.html</dc:identifier>
</item>
<item>
<title>java基础(十六)----- equals()与hashCode()方法详解 —— 面试必问 - chen_hao</title>
<link>http://www.cnblogs.com/java-chen-hao/p/10448978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-chen-hao/p/10448978.html</guid>
<description>&lt;p&gt;本文将详解 equals()与hashCode()方法&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;java.lang.Object类中有两个非常重要的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hashCode()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Object类是类继承结构的基础，所以是每一个类的父类。所有的对象，包括数组，都实现了在Object类中定义的方法。&lt;/p&gt;
&lt;h2&gt;equals()方法详解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt;方法是用来判断其他的对象是否和该对象相等.&lt;/p&gt;
&lt;p&gt;equals()方法在object类中定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj);  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们知道，&lt;strong&gt;String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如在String类中如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object anObject) {  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; anObject) {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
    }  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (anObject &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {  
        String anotherString &lt;/span&gt;=&lt;span&gt; (String)anObject;  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; count;  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n ==&lt;span&gt; anotherString.count) {  
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; v1[] =&lt;span&gt; value;  
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; v2[] =&lt;span&gt; anotherString.value;  
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; offset;  
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; anotherString.offset;  
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (n– != 0&lt;span&gt;) {  
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v1[i++] != v2[j++&lt;span&gt;])  
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
            }  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
        }  
    }  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显，这是进行的内容比较，而已经不再是地址的比较。依次类推Math、Integer、Double等这些类都是重写了equals()方法的，从而进行的是内容的比较。当然，基本类型是进行值的比较。&lt;/p&gt;
&lt;p&gt;需要注意的是当equals()方法被override时，hashCode()也要被override。按照一般hashCode()方法的实现来说，相等的对象，它们的hash code一定相等。&lt;/p&gt;
&lt;h2&gt;hashcode() 方法详解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;hashCode()&lt;/code&gt;方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。&lt;/p&gt;
&lt;p&gt;它的性质是：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用&lt;code&gt;hashCode()&lt;/code&gt;方法，该方法必须始终如一返回同一个integer。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的&lt;code&gt;hashCode()&lt;/code&gt;方法必须产生同一个integer结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;并不要求根据&lt;code&gt;equals(java.lang.Object)&lt;/code&gt;方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大量的实践表明，由&lt;code&gt;Object&lt;/code&gt;类定义的&lt;code&gt;hashCode()&lt;/code&gt;方法对于不同的对象返回不同的integer。&lt;/p&gt;
&lt;p&gt;在object类中，hashCode定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hashCode();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法，比如String、Integer、Double等这些类都是覆盖了hashcode()方法的。例如在String类中定义的hashcode()方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; hash;  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h == 0&lt;span&gt;) {  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; off =&lt;span&gt; offset;  
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; val[] =&lt;span&gt; value;  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; count;  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; len; i++&lt;span&gt;) {  
            h &lt;/span&gt;= 31 * h + val[off++&lt;span&gt;];  
        }  
        hash &lt;/span&gt;=&lt;span&gt; h;  
    }  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; h;  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;想要弄明白hashCode的作用，必须要先知道Java中的集合。　　&lt;br/&gt;总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。这里就引出一个问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？&lt;br/&gt;这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。   &lt;br/&gt;      于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上，初学者可以简单理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。  &lt;br/&gt;      这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java对象的eqauls方法和hashCode方法是这样规定的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、如果两个对象的hashCode相同，它们并不一定相同。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？&lt;/h3&gt;
&lt;p&gt;想象一下，假如两个Java对象A和B，A和B相等（eqauls结果为true），但A和B的哈希码不同，则A和B存入HashMap时的哈希码计算得到的HashMap内部数组位置索引可能不同，那么A和B很有可能允许同时存入HashMap，显然相等/相同的元素是不允许同时存入HashMap，HashMap不允许存放重复元素。&lt;/p&gt;
&lt;h3&gt;关于第二点，两个对象的hashCode相同，它们并不一定相同&lt;/h3&gt;
&lt;p&gt;也就是说，不同对象的hashCode可能相同；假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。&lt;/p&gt;
&lt;p&gt;所以，Java对于eqauls方法和hashCode方法是这样规定的：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1.如果两个对象相同，那么它们的hashCode值一定要相同；&lt;br/&gt;2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。  &lt;br/&gt;如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。&lt;br/&gt;3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。&lt;br/&gt;换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在object类中，hashcode()方法是本地方法，返回的是对象的地址值，而object类中的equals()方法比较的也是两个对象的地址值，如果equals()相等，说明两个对象地址值也相等，当然hashcode()也就相等了；&lt;strong&gt;在String类中，equals()返回的是两个对象内容的比较&lt;/strong&gt;，当两个对象内容相等时，Hashcode()方法根据String类的重写代码的分析，也可知道hashcode()返回结果也会相等。以此类推，可以知道Integer、Double等封装类中经过重写的equals()和hashcode()方法也同样适合于这个原则。当然没有经过重写的类，在继承了object类的equals()和hashcode()方法后，也会遵守这个原则。&lt;/p&gt;
&lt;h2&gt;推荐博客&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chen-haozi/p/10227797.html&quot; target=&quot;_blank&quot;&gt;程序员写代码之外，如何再赚一份工资？&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Hashset、Hashmap、Hashtable与hashcode()和equals()的密切关系&lt;/h2&gt;
&lt;p&gt;Hashset是继承Set接口，Set接口又实现Collection接口，这是层次关系。那么Hashset、Hashmap、Hashtable中的存储操作是根据什么原理来存取对象的呢？&lt;/p&gt;
&lt;p&gt;下面以HashSet为例进行分析，我们都知道：在hashset中不允许出现重复对象，元素的位置也是不确定的。在hashset中又是怎样判定元素是否重复的呢？在java的集合中，判断两个对象是否相等的规则是：&lt;br/&gt;        1.判断两个对象的hashCode是否相等&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果不相等，认为两个对象也不相等，完毕&lt;br/&gt;如果相等，转入2&lt;br/&gt;      （这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2.判断两个对象用equals运算是否相等&lt;br/&gt;       如果不相等，认为两个对象也不相等&lt;br/&gt;       如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例1：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bijian.study;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HashSetTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        String s1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;aaa&quot;&lt;span&gt;);
        String s2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;aaa&quot;&lt;span&gt;);
        System.out.println(s1 &lt;/span&gt;==&lt;span&gt; s2);
        System.out.println(s1.equals(s2));
        System.out.println(s1.hashCode());
        System.out.println(s2.hashCode());
        Set hashset &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashSet();
        hashset.add(s1);
        hashset.add(s2);
        Iterator it &lt;/span&gt;=&lt;span&gt; hashset.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;运行结果：
&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;true&lt;/span&gt;
96321
96321&lt;span&gt;
aaa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是因为String类已经重写了equals()方法和hashcode()方法，所以hashset认为它们是相等的对象，进行了重复添加。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例2：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bijian.study;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HashSetTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        HashSet hs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashSet();
        hs.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(1, &quot;zhangsan&quot;&lt;span&gt;));
        hs.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(2, &quot;lisi&quot;&lt;span&gt;));
        hs.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(3, &quot;wangwu&quot;&lt;span&gt;));
        hs.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(1, &quot;zhangsan&quot;&lt;span&gt;));
        Iterator it &lt;/span&gt;=&lt;span&gt; hs.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
    String name;
    Student(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num, String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num =&lt;span&gt; num;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num + &quot;:&quot; +&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;运行结果：
&lt;/span&gt;1&lt;span&gt;:zhangsan  
&lt;/span&gt;3&lt;span&gt;:wangwu  
&lt;/span&gt;2&lt;span&gt;:lisi  
&lt;/span&gt;1:zhangsan
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么hashset添加了相等的元素呢，这是不是和hashset的原则违背了呢？回答是：没有。因为在根据hashcode()对两次建立的new Student(1,“zhangsan”)对象进行比较时，生成的是不同的哈希码值，所以hashset把他当作不同的对象对待了，当然此时的equals()方法返回的值也不等。&lt;/p&gt;
&lt;p&gt;为什么会生成不同的哈希码值呢？上面我们在比较s1和s2的时候不是生成了同样的哈希码吗？原因就在于我们自己写的Student类并没有重新自己的hashcode()和equals()方法，所以在比较时，是继承的object类中的hashcode()方法，而object类中的hashcode()方法是一个本地方法，比较的是对象的地址（引用地址），使用new方法创建对象，两次生成的当然是不同的对象了，造成的结果就是两个对象的hashcode()返回的值不一样，所以Hashset会把它们当作不同的对象对待。&lt;/p&gt;
&lt;p&gt;怎么解决这个问题呢？答案是：在Student类中重新hashcode()和equals()方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
    String name;
    Student(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num, String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num =&lt;span&gt; num;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num *&lt;span&gt; name.hashCode();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
        Student s &lt;/span&gt;=&lt;span&gt; (Student) o;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num == s.num &amp;amp;&amp;amp;&lt;span&gt; name.equals(s.name);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num + &quot;:&quot; +&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;运行结果：
&lt;/span&gt;1&lt;span&gt;:zhangsan  
&lt;/span&gt;3&lt;span&gt;:wangwu  
&lt;/span&gt;2:lisi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到重复元素的问题已经消除，根据重写的方法，即便两次调用了new Student(1,&quot;zhangsan&quot;)，我们在获得对象的哈希码时，根据重写的方法hashcode()，获得的哈希码肯定是一样的，当然根据equals()方法我们也可判断是相同的，所以在向hashset集合中添加时把它们当作重复元素看待了。&lt;/p&gt;

</description>
<pubDate>Fri, 01 Mar 2019 06:14:00 +0000</pubDate>
<dc:creator>chen_hao</dc:creator>
<og:description>本文将详解 equals()与hashCode()方法 概述 java.lang.Object类中有两个非常重要的方法： Object类是类继承结构的基础，所以是每一个类的父类。所有的对象，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-chen-hao/p/10448978.html</dc:identifier>
</item>
<item>
<title>快速搭建react项目骨架（按需加载、redux、axios、项目级目录等等） - Mr.聂</title>
<link>http://www.cnblogs.com/pengfei-nie/p/10443310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengfei-nie/p/10443310.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;最近整理了一下项目骨架，顺便自定义了一个脚手架，方便日后使用。我会从头开始，步骤一步步写明白，如果还有不清楚的可以评论区留言。先大致介绍一下这个骨架，我们采用 &lt;/span&gt;&lt;span&gt;create-react-app 搭建基础骨架，修改一些基础配置； 使用webpack的import模块实现按需加载(俗称切片打包)； 引入 react-redux； 引入axios； 规划好项目的目录结构。&lt;/span&gt;&lt;span&gt;我们大致就&lt;/span&gt;&lt;span&gt;做这些事，大家可以根据自己项目需要，添加ui包等其他插件。博客的代码只是说明大致的流程，建议先拉代码，对比代码看博客。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、目录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/pengfei-nie/p/10443310.html#a1&quot;&gt;&lt;span&gt;1、安装 create-react-app 脚手架并创建APP&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/pengfei-nie/p/10443310.html#a2&quot;&gt;&lt;span&gt;2、按照上线项目标准完善目录结构&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/pengfei-nie/p/10443310.html#a3&quot;&gt;&lt;span&gt;3、配置按需加载(俗称切片打包)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/pengfei-nie/p/10443310.html#a4&quot;&gt;&lt;span&gt;4、配置react-redux及redux-sagas(sagas是我个人习惯，挺好用的，不喜欢的可以不装)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/pengfei-nie/p/10443310.html#a5&quot;&gt;&lt;span&gt;5、配置axios统一请求(cookie、拦截、统一报错等)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/pengfei-nie/p/10443310.html#a6&quot;&gt;&lt;span&gt;6、代码地址 （如果觉得有用，记得给我 github 点个赞奥）&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;  &lt;span&gt;ps: 说不定博主还会开放几个私有仓库  ☺&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span id=&quot;a1&quot;&gt;三、安装 create-react-app 脚手架并创建APP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      npm install -g create-react-app   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地全局安装 react 脚手架&lt;/span&gt;
      create-react-app webapp           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过脚手架指令 创建 react webapp,  注意名字不能有大写字母，现在就可以直接跑了&lt;/span&gt;
      npm run eject                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新版本的脚手架把配置文件等都以依赖的形式放到 node_modules 中了， eject 一下，把配置信息释放出来&lt;/span&gt;
      scripts/start.js                  //修改一下端口号，默认是3000，改成你想要的
      npm i                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;装一下依赖&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　  我们直接用react的官方脚手架搭建最基础的骨架，通过 create-react-app 新建 react的webAPP。然后我们的项目就可以直接跑了，看一下package.json&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文件，里面有关于项目启动、打包、测试的指令。执行 npm run start 就可以运行我们的项目了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         然后我们修改一下这个项目，因为现在 create-react-app 脚手架会把配置文件都以依赖的形式放到node_modelus里面，执行 npm run eject 把配置文件释放出来，然&lt;/span&gt;&lt;span&gt;后执行 npm i，装一下依赖(好像不用装，我们没添加什么，笑哭~~)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         我们看一下现在的目录结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113254/201902/1113254-20190227140941275-1552462935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;a2&quot;&gt;&lt;strong&gt; 四、按照上线项目标准完善目录结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         目前为止这个项目只有一个默认页面，放在src录下。我们按照上线项目大致会用到的东西，先完善一下目录结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;          assets            静态资源，存放 字体、图片、css hack 等
          components        建立公共组件文件夹，这是放公共组件的
          layouts           建立布局文件夹  确定好你的项目布局样式
          constants         全局常亮文件夹  存放全局常亮
          helpers           公共函数文件夹  存放公共函数、一些插件的启动配置函数
          modules           我们具体的功能模块  存放我们项目的实际页面
          services          接口文件夹  存放所有请求
          store             装redux的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;          我们在src目录下新建上述文件夹，具体功能都已标明了。出于规范化、模块化考虑我们暂时将文件如此分类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          然后我们新建几个简单的页面，内容自定义，可参考下述代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import React, { PureComponent } from 'react'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class Register extends PureComponent {
  state &lt;/span&gt;=&lt;span&gt; {}

  componentDidMount () {}

  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;div className=&quot;g-default&quot;&amp;gt;&lt;span&gt;
        默认页
      &lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;span&gt;    )
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　 这样我们新建几个页面 登录、注册、默认页等等，这个随意啦。然后我们看一下现在的目录结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1113254/201902/1113254-20190227142215475-730484874.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;3&quot;&gt;&lt;strong&gt;五、配置按需加载(俗称切片打包)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       现在我们已经有了几个最基础的页面了，我们开始做路由按需加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       为什么要按需加载？ 因为 单页应用，只有一个html，一个主要的css、js。传统打包方式是将整个项目的js、css都打包成一个文件引入。用户浏览我们的页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时就需要将整个项目拉下来才行(动不动就是几M甚至几十M)，非常不友好。按需加载，按照路由切割js、css，用户看哪个，就加载哪个页面代码。首次加载体验非常好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       按需加载方法有很多，我们介绍一种目前配置简单、效率也高的一种。我们采用 webpack 的 import 模块来实现按需加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       首先，封装一个异步加载模块的组件，然后用这个组件去引入要加载的模块。代码如下： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//这是异步加载组件的代码&lt;/span&gt;&lt;br/&gt;&lt;span readability=&quot;1&quot;&gt;import {PureComponent} from 'react'&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class Bundle extends PureComponent {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
      mod: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    };
  }

  componentWillMount() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.load(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props)
  }
  componentWillReceiveProps(nextProps) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nextProps.load !== &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.load) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.load(nextProps)
    }
  }
  load(props) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
      mod: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    });
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这里，使用Promise对象; mod.default导出默认&lt;/span&gt;
    props.load().then((mod) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
        mod: mod.&lt;/span&gt;&lt;span&gt;default&lt;/span&gt; ? mod.&lt;span&gt;default&lt;/span&gt;&lt;span&gt; : mod
      });
    });
  }

  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.state.mod ? &lt;span&gt;this&lt;/span&gt;.props.children(&lt;span&gt;this&lt;/span&gt;.state.mod) : &lt;span&gt;null&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;;
  }
}&lt;br/&gt;..............&lt;p&gt;//这是他的使用，新建Router.js文件，配置路由&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;19&quot;&gt;
&lt;span&gt;import React from 'react';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import {BrowserRouter, Route, Switch} from 'react-router-dom';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import Bundle from './Bundle';&lt;/span&gt;&lt;p&gt;&lt;span&gt;const Login = (props) =&amp;gt; (&amp;lt;Bundle load={() =&amp;gt; import('./modules/login')}&amp;gt;{(Login) =&amp;gt; &amp;lt;Login {...props}/&amp;gt;}&amp;lt;/Bundle&amp;gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const Register = (props) =&amp;gt; (&amp;lt;Bundle load={() =&amp;gt; import('./modules/register')}&amp;gt;{(Register) =&amp;gt; &amp;lt;Register {...props}/&amp;gt;}&amp;lt;/Bundle&amp;gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const Default = (props) =&amp;gt; (&amp;lt;Bundle load={() =&amp;gt; import('./modules/default')}&amp;gt;{(Default) =&amp;gt; &amp;lt;Default {...props}/&amp;gt;}&amp;lt;/Bundle&amp;gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const Blog = (props) =&amp;gt; (&amp;lt;Bundle load={() =&amp;gt; import('./modules/blog')}&amp;gt;{(Blog) =&amp;gt; &amp;lt;Blog {...props}/&amp;gt;}&amp;lt;/Bundle&amp;gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const User = (props) =&amp;gt; (&amp;lt;Bundle load={() =&amp;gt; import('./modules/user')}&amp;gt;{(User) =&amp;gt; &amp;lt;User {...props}/&amp;gt;}&amp;lt;/Bundle&amp;gt;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;const BasicRoute = () =&amp;gt; (&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &amp;lt;BrowserRouter&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;Switch&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &amp;lt;Route exact path=&quot;/login&quot; component={Login}/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &amp;lt;Route exact path=&quot;/register&quot; component={Register}/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &amp;lt;Route exact path=&quot;/default&quot; component={Default}/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &amp;lt;Route exact path=&quot;/blog&quot; component={Blog}/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &amp;lt;Route exact path=&quot;/user&quot; component={User}/&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &amp;lt;Route exact path=&quot;/&quot; component={Login}/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &amp;lt;Route exact&lt;/span&gt;&lt;br/&gt;&lt;span&gt;             component={Login}/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;/Switch&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &amp;lt;/BrowserRouter&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;export default BasicRoute;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;.............&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//这是对index文件的修改&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;span&gt;import React from 'react';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import ReactDOM from 'react-dom';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import './index.css';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import BasicRoute from './Router';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import * as serviceWorker from './serviceWorker';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import store from './store'&lt;/span&gt;&lt;p&gt;&lt;span&gt;ReactDOM.render( &amp;lt;BasicRoute /&amp;gt;, document.getElementById('root'));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// If you want your app to work offline and load faster, you can change&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// unregister() to register() below. Note this comes with some pitfalls.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Learn more about service workers: http://bit.ly/CRA-PWA&lt;/span&gt;&lt;br/&gt;&lt;span&gt;serviceWorker.unregister();&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　注意，我把之前的App.js文件删掉了，我们用不上。然后新建了一个Router.js，这个文件就是我们所有模块的路由配置。然后修改src/index.js 文件，引入我们的路由文件。&lt;/span&gt;&lt;span&gt;现在我们的路由以及路由的按需加载就都OK了。我们可以多建几个文件加上内部路由跳转试一下。执行 npm run build 看我们build文件夹, build/static/js 可以看到我们已经实现切片打包了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;a4&quot;&gt;&lt;strong&gt;六、 配置react-redux及redux-sagas(sagas是我个人习惯，挺好用的不喜欢的可以不装)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         为什么要装redux？ 因为react单页应用，我们会涉及大量的数据，像用户信息等数据会在很多地方用到，这会导致组件间的数据传输很麻烦，所以我们使用redux，将变量统一管理，中心思想很简单。和我们定义一个命名空间，里面放很多变量，然后写一些方法指定性读取、修改这些变量一样，大致可以这么理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 然后，我们安装&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      npm install --&lt;span&gt;save redux        安装redux
      npm install &lt;/span&gt;--save react-&lt;span&gt;redux  安装react的绑定库
      npm install &lt;/span&gt;--save redux-saga   安装sagas， Redux-saga是Redux的一个中间件，主要集中处理react架构中的异步处理工作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        我习惯用sagas，不喜欢的可以不装哈。但是后序代码我都会用它来写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　装好了依赖，接下来是如何使用。大致步骤是这样的，建立reducer和sagas，然后用redux的Provider组件包裹项目，注入redux，然后就可以在组建中使用了，我们贴一下代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// src/index.js  引入redux，并注入数据&lt;/span&gt;&lt;br/&gt;&lt;span readability=&quot;7.5&quot;&gt;import React from 'react'&lt;span&gt;;
import ReactDOM from &lt;/span&gt;'react-dom'&lt;span&gt;;
import { Provider } from &lt;/span&gt;'react-redux'&lt;span&gt;
import &lt;/span&gt;'./index.css'&lt;span&gt;;
import BasicRoute from &lt;/span&gt;'./Router'&lt;span&gt;;
import &lt;/span&gt;* as serviceWorker from './serviceWorker'&lt;span&gt;;
import store from &lt;/span&gt;'./store'&lt;span&gt;
ReactDOM.render( &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt; &amp;lt;BasicRoute /&amp;gt; &amp;lt;/Provider&amp;gt;, document.getElementById('root'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If you want your app to work offline and load faster, you can change&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; unregister() to register() below. Note this comes with some pitfalls.&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Learn more about service workers: http://bit.ly/CRA-PWA&lt;/span&gt;
&lt;span readability=&quot;4&quot;&gt;serviceWorker.unregister();

&lt;p&gt;// src/store/index.js 配置redux和sagas，并引入我们的reducer和sagas  
import { createStore, applyMiddleware } from &lt;/p&gt;&lt;/span&gt;'redux'&lt;span&gt;
import createSagaMiddleware from &lt;/span&gt;'redux-saga'&lt;span&gt;
import rootReducer, { createReducer } from &lt;/span&gt;'./reducers'&lt;span&gt;
import rootSaga from &lt;/span&gt;'./sagas'&lt;span&gt;
const sagaMiddleware &lt;/span&gt;=&lt;span&gt; createSagaMiddleware()
const middlewares &lt;/span&gt;=&lt;span&gt; [sagaMiddleware]&lt;/span&gt;&lt;span&gt;
const configureStore &lt;/span&gt;= (initialState = {}) =&amp;gt;&lt;span&gt; {
  const store &lt;/span&gt;=&lt;span&gt; createStore(
    rootReducer,
    initialState,
    applyMiddleware(...middlewares),
  )
  sagaMiddleware.run(rootSaga)&lt;/span&gt;&lt;span&gt;
  store.runSaga &lt;/span&gt;=&lt;span&gt; sagaMiddleware.run
  store.asyncReducers &lt;/span&gt;= store.asyncReducers ||&lt;span&gt; {}
  store.asyncSagas &lt;/span&gt;= store.asyncSagas ||&lt;span&gt; []
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; store
}
export const injectAsyncReducer &lt;/span&gt;= ({ name, asyncReducer, store }) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( store.asyncReducers[name] ) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
  store.asyncReducers[name] &lt;/span&gt;=&lt;span&gt; asyncReducer
  store.replaceReducer(createReducer(store.asyncReducers))
}
export const injectAsyncSagas &lt;/span&gt;= ({ name, sagas, store }) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;store.asyncSagas.includes(name) ) {
    sagas.forEach(store.runSaga)
    store.asyncSagas.push(name)
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt; configureStore({})

&lt;p&gt;// 配置reducer入口文件
import { combineReducers } from &lt;/p&gt;&lt;/span&gt;'redux'&lt;span&gt;
import user from &lt;/span&gt;'./user'&lt;span&gt;
const rootReducer &lt;/span&gt;=&lt;span&gt; {
  user,
}
export const createReducer &lt;/span&gt;= asyncReducers =&amp;gt;&lt;span&gt; combineReducers({
  ...rootReducer,
  ...asyncReducers,
})
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; combineReducers(rootReducer)



// user模块的 reducer
const initState &lt;/span&gt;=&lt;span&gt; {
  loading: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
  dataSource: {
    list: [],
    pagination: {
      pageSize: &lt;/span&gt;10&lt;span&gt;,
      current: &lt;/span&gt;1&lt;span&gt;,
    },
  },
}
const reducer &lt;/span&gt;= (state = initState, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'saveAssetsLoading'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        ...state,
        loading: action.payload,
      }
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        ...state,
      }
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt; reducer

&lt;p&gt;// sagas 的入口文件
import { all } from &lt;/p&gt;&lt;/span&gt;'redux-saga/effects'&lt;span&gt;
import userSagas from &lt;/span&gt;'./user'&lt;span&gt;
const run &lt;/span&gt;= sagas =&amp;gt; sagas.map(saga =&amp;gt;&lt;span&gt; saga())
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;*&lt;span readability=&quot;4&quot;&gt; rootSaga() {
  yield all([
    ...run([
      ...userSagas,
    ]),
  ])
}

&lt;p&gt;// user模块的sagas
import { put, call, takeEvery } from &lt;/p&gt;&lt;/span&gt;'redux-saga/effects'&lt;span&gt;
import { login1, login2} from &lt;/span&gt;'../../services/user'&lt;span&gt;
const sagas &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;*&lt;span&gt; login1({ payload, callback }) {
    const result &lt;/span&gt;=&lt;span&gt; yield call(login1, payload)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (callback) callback(result)
  },
  &lt;/span&gt;*&lt;span&gt; login2({ payload, callback }) {
    const result &lt;/span&gt;=&lt;span&gt; yield call(login2, payload)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (callback) callback(result)
  },&lt;/span&gt;&lt;span&gt;
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Object.keys(sagas).map(item =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; *&lt;span&gt; s() {
    yield takeEvery(item, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;(args) {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        yield sagas[item](args)
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span readability=&quot;3&quot;&gt; (e) {
        console.log(e)
      }
    })
  }
})

&lt;p&gt;// 在user组件中使用
import React, { PureComponent } from &lt;/p&gt;&lt;/span&gt;'react'&lt;span&gt;;
import { Link } from &lt;/span&gt;'react-router-dom'&lt;span&gt;
import { connect } from &lt;/span&gt;'react-redux'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;
@connect(state &lt;/span&gt;=&amp;gt;&lt;span&gt; ({
  user: state.user
}))
class User extends PureComponent {
  state &lt;/span&gt;=&lt;span&gt; {
  }
  componentDidMount () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this.fetch()&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fetch2()
  }
  fetch &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    const params &lt;/span&gt;=&lt;span&gt; {
      test: &lt;/span&gt;'web'&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.dispatch({
      type: &lt;/span&gt;'login1'&lt;span&gt;,
      payload: params,
      callback: result &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(result)
      }
    })
  }&lt;/span&gt;&lt;span&gt;
  render() {&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;div className=&quot;g-login&quot;&amp;gt;&lt;span&gt;
        测试2
        &lt;/span&gt;&amp;lt;br /&amp;gt;
        &amp;lt;Link to={`/default`}&amp;gt;
&lt;span&gt;          登录
        &lt;/span&gt;&amp;lt;/Link&amp;gt;
      &amp;lt;/div&amp;gt;
&lt;span&gt;    )
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     使用redux大致就是这样，先引入redux，然后做具体的文件配置，最后直接组件中使用即可。注意： sagas这里，我没有做作用域处理，sagas方法名不能重复。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;5&quot;&gt;&lt;strong&gt;七、配置axios统一请求(cookie、拦截、统一报错等)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为什么封装axios？ 首先，我们使用axios作为请求方式，各方面性能吧都不错。其次，在单页应用中，涉及到的请求会非常多，对于请求拦截、响应拦截、错误统一处理&lt;/span&gt;&lt;span&gt;等常规操作，我们把axios进行二次封装会节省大量的代码，好处不用我多说了。下边是封装axios的流程，以及使用sagas调用的方式，直接贴代码了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// src/constants/index.js  设定请求的ip，这个根据个人情况来&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export const ORIGIN = {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  production: window.location.origin,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  development: `http://${window.location.hostname}:3009`,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  test: window.location.origin,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  // dev: 'http://localhost:3009',&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}[process.env.NODE_ENV || 'development'];&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;// 对axios的封装&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import axios from 'axios'&lt;span&gt;
import { ORIGIN } from &lt;/span&gt;'../constants'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一个请求拦截器&lt;/span&gt;
axios.interceptors.request.use(config =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; config    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂时没啥好写的，我们只是个骨架&lt;/span&gt;
}, error =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Promise.reject(error);
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一个响应拦截器&lt;/span&gt;
axios.interceptors.response.use(response =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; response.data     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他的不要了，只拿data就好&lt;/span&gt;
}, error =&amp;gt;&lt;span&gt; {
  console.log(error.response)
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (error.response.status === 401&lt;span&gt;) {
    window.location.pathname &lt;/span&gt;= '/login'&lt;span&gt;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ......在做别的统一处理&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Promise.reject(error);
});
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; request(url, options =&lt;span&gt; {}) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; axios({
    url: &lt;/span&gt;/^http/.test(url) ?&lt;span&gt; url : `${ORIGIN}${url}`,
    method: &lt;/span&gt;'get'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 携带cookie信息&lt;/span&gt;
    withCredentials: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    ...options,
    data: options.body,
  })
}


// 添加具体的请求函数，供前端使用
import request from &lt;/span&gt;'../helpers/request'&lt;span&gt;
import { stringify } from &lt;/span&gt;'querystring'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试1&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; login1(params) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; request(`/xxx/xxx1?&lt;span&gt;${stringify(params)}`)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试2&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; login2(data) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; request(`/xxx/&lt;span&gt;xxx2`, {
    method: &lt;/span&gt;'post'&lt;span&gt;,
    body: data,
  })
}&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这个代码里面都有注释，这里简单说明一下，这个地址常亮，大家根据自己实际情况来改。关于请求的封装，这里主要写了加cookie，未登录401报错直接跳到登录页，&lt;/span&gt;&lt;span&gt;至于其他错误处理，大家根据自己项目错误码来就好。项目中涉及到一些node.js的小功能函数，大家一百度就知道了，比如说 stringify。封装好的请求要么直接用，要么在sagas里面用。大致就是这样。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;a6&quot;&gt;&lt;strong&gt;八、代码地址 （如果觉得有用，记得给我 github 点个赞奥。）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　https://github.com/Aaron-China/react-cli&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这是代码地址，觉得不错，您别吝啬，  地址右上方start点一下，谢谢。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　至此，一个精简的react骨架就出来了，没有做太多的配置，以免影响灵活度。这几项几乎都是项目中必须的东西。所以，就写到这。后期看看反应吧，把ui框架加上去，&lt;/span&gt;&lt;span&gt;再做上菜单、权限的配置，再敲几个常用的页面。如果做的话，我会在git上开一个分支，不会影响这个基本骨架。如果博客中哪里写的有问题，欢迎评论区留言。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;ps： 有点懒，好久没写博客了，将持续放点干货，希望能帮到你。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Mar 2019 06:13:00 +0000</pubDate>
<dc:creator>Mr.聂</dc:creator>
<og:description>一、前言 最近整理了一下项目骨架，顺便自定义了一个脚手架，方便日后使用。我会从头开始，步骤一步步写明白，如果还有不清楚的可以评论区留言。先大致介绍一下这个骨架，我们采用 create-rea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pengfei-nie/p/10443310.html</dc:identifier>
</item>
<item>
<title>根因分析初探：一种报警聚类算法在业务系统的落地实施 - 美团技术团队</title>
<link>http://www.cnblogs.com/meituantech/p/10456024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meituantech/p/10456024.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;众所周知，日志是记录应用程序运行状态的一种重要工具，在业务服务中，日志更是十分重要。通常情况下，日志主要是记录关键执行点、程序执行错误时的现场信息等。系统出现故障时，运维人员一般先查看错误日志，定位故障原因。当业务流量小、逻辑复杂度低时，应用出现故障时错误日志一般较少，运维人员一般能够根据错误日志迅速定位到问题。但是，随着业务逻辑的迭代，系统接入的依赖服务不断增多，引入的组件不断增多，当系统出现故障时（如Bug被触发、依赖服务超时等等），错误日志的量级会急剧增加。极端情况下甚至出现“疯狂报错”的现象，这时候错误日志的内容会存在相互掩埋、相互影响的问题，运维人员面对报错一时难以理清逻辑，有时甚至顾此失彼，没能第一时间解决最核心的问题。&lt;/p&gt;
&lt;p&gt;错误日志是系统报警的一种，实际生产中，运维人员能够收到的报警信息多种多样。如果在报警流出现的时候，通过处理程序，将报警进行聚类，整理出一段时间内的报警摘要，那么运维人员就可以在摘要信息的帮助下，先对当前的故障有一个大致的轮廓，再结合技术知识与业务知识定位故障的根本原因。&lt;/p&gt;
&lt;p&gt;围绕上面描述的问题，以及对于报警聚类处理的分析假设，本文主要做了以下事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选定聚类算法，简单描述了算法的基本原理，并给出了针对报警日志聚类的一种具体的实现方案。&lt;/li&gt;
&lt;li&gt;在分布式业务服务的系统下构造了三种不同实验场景，验证了算法的效果，并且对算法的不足进行分析阐述。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;p&gt;对一段时间内的报警进行聚类处理，将具有相同根因的报警归纳为能够涵盖报警内容的泛化报警（Generalized Alarms），最终形成仅有几条泛化报警的报警摘要。如下图1所示意。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/travelcube/0405c8ee9e4e3ea813eedf46c803101122272.png&quot; alt=&quot;图1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1&lt;/p&gt;
&lt;p&gt;我们希望这些泛化报警既要具有很强的概括性，同时尽可能地保留细节。这样运维人员在收到报警时，便能快速定位到故障的大致方向，从而提高故障排查的效率。&lt;/p&gt;
&lt;h2 id=&quot;设计&quot;&gt;设计&lt;/h2&gt;
&lt;p&gt;如图2所示，异常报警根因分析的设计大致分为四个部分：收集报警信息、提取报警信息的关键特征、聚类处理、展示报警摘要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/travelcube/4f35cf0a3c1b6a69d40639f7cec2dd0a35988.png&quot; alt=&quot;图2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2&lt;/p&gt;
&lt;h3 id=&quot;算法选择&quot;&gt;算法选择&lt;/h3&gt;
&lt;p&gt;聚类算法采用论文“Clustering Intrusion Detection Alarms to Support Root Cause Analysis [KLAUS JULISCH, 2002]”中描述的根因分析算法。该算法基于一个假设：将报警日志集群经过泛化，得到的泛化报警能够表示报警集群的主要特征。以下面的例子来说明，有如下的几条报警日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash hljs&quot;&gt;server_room_a-biz_tag-online02 Thrift get deal ProductType deal error.
server_room_b-biz_tag-offline01 Pigeon query deal info error.
server_room_a-biz_tag-offline01 Http query deal info error.
server_room_a-biz_tag-online01 Thrift query deal info error.
server_room_b-biz_tag-offline02 Thrift get deal ProductType deal error.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以将这几条报警抽象为：“全部服务器 网络调用 故障”，该泛化报警包含的范围较广；也可以抽象为：“server_room_a服务器 网络调用 产品信息获取失败”和“server_room_b服务器 RPC 获取产品类型信息失败”，此时包含的范围较小。当然也可以用其他层次的抽象来表达这个报警集群。&lt;/p&gt;
&lt;p&gt;我们可以观察到，抽象层次越高，细节越少，但是它能包含的范围就越大；反之，抽象层次越低，则可能无用信息越多，包含的范围就越小。&lt;/p&gt;
&lt;p&gt;这种抽象的层次关系可以用一些有向无环图（DAG）来表达，如图3所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/travelcube/498863264a2d68efbe4e39ba055a06d261831.png&quot; alt=&quot;图3 泛化层次结构示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3 泛化层次结构示例&lt;/p&gt;
&lt;p&gt;为了确定报警聚类泛化的程度，我们需要先了解一些定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性（Attribute）：构成报警日志的某一类信息，如机器、环境、时间等，文中用Ai表示。&lt;/li&gt;
&lt;li&gt;值域（Domain）：属性Ai的域（即取值范围），文中用Dom(Ai)表示。&lt;/li&gt;
&lt;li&gt;泛化层次结构（Generalization Hierarchy）：对于每个Ai都有一个对应的泛化层次结构，文中用Gi表示。&lt;/li&gt;
&lt;li&gt;不相似度（Dissimilarity）：定义为d(a1, a2)。它接受两个报警a1、a2作为输入，并返回一个数值量，表示这两个报警不相似的程度。与相似度相反，当d(a1, a2)较小时，表示报警a1和报警a2相似。为了计算不相似度，需要用户定义泛化层次结构。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了计算d(a1, a2)，我们先定义两个属性的不相似度。令x1、x2为某个属性Ai的两个不同的值，那么x1、x2的不相似度为：在泛化层次结构Gi中，通过一个公共点父节点p连接x1、x2的最短路径长度。即d(x1, x2) := min{d(x1, p) + d(x2, p) | p ∈ Gi, x1 ⊴ p, x2 ⊴ p}。例如在图3的泛化层次结构中，d(“Thrift”, “Pigeon”) = d(“RPC”, “Thrift”) + d(“RPC”, “Pigeon”) = 1 + 1 = 2。&lt;/p&gt;
&lt;p&gt;对于两个报警a1、a2，其计算方式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/travelcube/a14786f687bb0dd1950c9654545be78d42398.png&quot; alt=&quot;公式1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公式1&lt;/p&gt;
&lt;p&gt;例如：a1 = (“server_room_b-biz_tag-offline02”, “Thrift”), a2 = (“server_room_a-biz_tag-online01”, “Pigeon”), 则d(a1, a2) = d(“server_room_b-biz_tag-offline02”, “server_room_a-biz_tag-online01”) + d((“Thrift”, “Pigeon”) = d(“server_room_b-biz_tag-offline02”, “服务器”) + d(“server_room_a-biz_tag-online01”, “服务器”) + d(“RPC”, “Thrift”) + d(“RPC”, “Pigeon”) = 2 + 2 + 1 + 1 = 6。&lt;/p&gt;
&lt;p&gt;我们用C表示报警集合，g是C的一个泛化表示，即满足∀ a ∈ C, a ⊴ g。以报警集合{“dx-trip-package-api02 Thrift get deal list error.”, “dx-trip-package-api01 Thrift get deal list error.”}为例，“dx服务器 thrift调用 获取产品信息失败”是一个泛化表示，“服务器 网络调用 获取产品信息失败”也是一个泛化表示。对于某个报警聚类来说，我们希望获得既能够涵盖它的集合又有最具象化的表达的泛化表示。为了解决这个问题，定义以下两个指标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/travelcube/ee6fa61ac27d4282e6588fffaf29ef3334378.png&quot; alt=&quot;公式2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公式2&lt;/p&gt;
&lt;p&gt;H©值最小时对应的g，就是我们要找的最适合的泛化表示，我们称g为C的“覆盖”(Cover)。&lt;/p&gt;
&lt;p&gt;基于以上的概念，将报警日志聚类问题定义为：定义L为一个日志集合，min_size为一个预设的常量，Gi(i = 1, 2, 3……n) 为属性Ai的泛化层次结构，目标是找到一个L的子集C，满足 |C| &amp;gt;= min_size，且H©值最小。min_size是用来控制抽象程度的，极端情况下如果min_size与L集合的大小一样，那么我们只能使用终极抽象了，而如果min_size = 1，则每个报警日志是它自己的抽象。找到一个聚类之后，我们可以去除这些元素，然后在L剩下的集合里找其他的聚类。&lt;/p&gt;
&lt;p&gt;不幸的是，这是个NP完全问题，因此论文提出了一种启发式算法，该算法满足|C| &amp;gt;= min_size，使H©值尽量小。&lt;/p&gt;
&lt;h3 id=&quot;算法描述&quot;&gt;算法描述&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;算法假设所有的泛化层次结构Gi都是树，这样每个报警集群都有一个唯一的、最顶层的泛化结果。&lt;/li&gt;
&lt;li&gt;将L定义为一个原始的报警日志集合，算法选择一个属性Ai，将L中所有报警的Ai值替换为Gi中Ai的父值，通过这一操作不断对报警进行泛化。&lt;/li&gt;
&lt;li&gt;持续步骤2的操作，直到找到一个覆盖报警数量大于min_size的泛化报警为止。&lt;/li&gt;
&lt;li&gt;输出步骤3中找到的报警。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;算法伪代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-pseudocode&quot;&gt;输入：报警日志集合L，min_size，每个属性的泛化层次结构G1,......,Gn
输出：所有符合条件的泛化报警
T := L;              // 将报警日志集合保存至表T
for all alarms a in T do
    a[count] := 1;   // &quot;count&quot;属性用于记录a当前覆盖的报警数量
while ∀a ∈ T : a[count] &amp;lt; min_size do {
    使用启发算法选择一个属性Ai;
    for all alarms a in T do
        a[Ai] := parent of a[Ai] in Gi;
        while identical alarms a, a' exist do
            Set a[count] := a[count] + a'[count];
            delete a' from T;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第7行的启发算法为:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-pseudocode&quot;&gt;首先计算Ai对应的Fi
fi(v) := SELECT sum(count) FROM T WHERE Ai = v   // 统计在Ai属性上值为v的报警的数量
Fi := max{fi(v) | v ∈ Dom(Ai)}
选择Fi值最小的属性Ai
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的逻辑是：如果有一个报警a满足 a[count]&amp;gt;= min_size，那么对于所有属性Ai , 均能满足Fi &amp;gt;= fi(a[Ai]) &amp;gt;= min_size。反过来说，如果有一个属性Ai的Fi值小于min_size，那么a[count]就不可能大于min_size。所以选择Fi值最小的属性Ai进行泛化，有助于尽快达到聚类的条件。&lt;/p&gt;
&lt;p&gt;此外，关于min_size的选择，如果选择了一个过大的min_size，那么会迫使算法合并具有不同根源的报警。另一方面，如果过小，那么聚类可能会提前结束，具有相同根源的报警可能会出现在不同的聚类中。&lt;/p&gt;
&lt;p&gt;因此，设置一个初始值，可以记作ms0。定义一个较小的值 ℇ(0 &amp;lt; ℇ &amp;lt; 1)，当min_size取值为ms0、ms0 * (1 - ℇ)、ms0 * (1 + ℇ)时的聚类结果相同时，我们就说此时聚类是ℇ-鲁棒的。如果不相同，则使ms1 = ms0 * (1 - ℇ)，重复这个测试，直到找到一个鲁棒的最小值。&lt;/p&gt;
&lt;p&gt;需要注意的是，ℇ-鲁棒性与特定的报警日志相关。因此，给定的最小值，可能相对于一个报警日志来说是鲁棒的，而对于另一个报警日志来说是不鲁棒的。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;h3 id=&quot;1-提取报警特征&quot;&gt;1. 提取报警特征&lt;/h3&gt;
&lt;p&gt;根据线上问题排查的经验，运维人员通常关注的指标包括时间、机器（机房、环境）、异常来源、报警日志文本提示、故障所在位置（代码行数、接口、类）、Case相关的特殊ID（订单号、产品编号、用户ID等等）等。&lt;/p&gt;
&lt;p&gt;但是，我们的实际应用场景都是线上准实时场景，时间间隔比较短，因此我们不需要关注时间。同时，Case相关的特殊ID不符合我们希望获得一个抽象描述的要求，因此也无需关注此项指标。&lt;/p&gt;
&lt;p&gt;综上，我们选择的特征包括：机房、环境、异常来源、报警日志文本关键内容、故障所在位置（接口、类）共5个。&lt;/p&gt;
&lt;h3 id=&quot;2-算法实现&quot;&gt;2. 算法实现&lt;/h3&gt;
&lt;h4 id=&quot;1-提取关键特征&quot;&gt;(1) 提取关键特征&lt;/h4&gt;
&lt;p&gt;我们的数据来源是日志中心已经格式化过的报警日志信息，这些信息主要包含：报警日志产生的时间、服务标记、在代码中的位置、日志内容等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;故障所在位置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优先查找是否有异常堆栈，如存在则查找第一个本地代码的位置；如果不存在，则取日志打印位置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异常来源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;获得故障所在位置后，优先使用此信息确定异常报警的来源（需要预先定义词典支持）；如不能获取，则在日志内容中根据关键字匹配（需要预先定义词典支持）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;报警日志文本关键内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优先查找是否有异常堆栈，如存在，则查找最后一个异常（通常为真正的故障原因）；如不能获取，则在日志中查找是否存在“code=……,message=……” 这样形式的错误提示；如不能获取，则取日志内容的第一行内容（以换行符为界），并去除其中可能存在的Case相关的提示信息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提取“机房和环境”这两个指标比较简单，在此不做赘述。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;2-聚类算法&quot;&gt;(2) 聚类算法&lt;/h4&gt;
&lt;p&gt;算法的执行，我们以图4来表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/travelcube/42a0e8e7d6ea32e1adddfc7a5a2d1831149869.png&quot; alt=&quot;图4 报警日志聚类流程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4 报警日志聚类流程图&lt;/p&gt;
&lt;h4 id=&quot;3-min-size-选择&quot;&gt;(3) min_size 选择&lt;/h4&gt;
&lt;p&gt;考虑到日志数据中可能包含种类极多，且根据小规模数据实验表明，min_size = 1⁄5 * 报警日志数量时，算法已经有较好的表现，再高会增加过度聚合的风险，因此我们取min_size = 1⁄5 * 报警日志数量，ℇ参考论文中的实验，取0.05。&lt;/p&gt;
&lt;h4 id=&quot;4-聚类停止条件&quot;&gt;(4) 聚类停止条件&lt;/h4&gt;
&lt;p&gt;考虑到部分场景下，报警日志可能较少，因此min_size的值也较少，此时聚类已无太大意义，因此设定聚类停止条件为：聚类结果的报警摘要数量小于等于20或已经存在某个类别的count值达到min_size的阈值，即停止聚类。&lt;/p&gt;
&lt;h3 id=&quot;3-泛化层次结构&quot;&gt;3. 泛化层次结构&lt;/h3&gt;
&lt;p&gt;泛化层次结构，用于记录属性的泛化关系，是泛化时向上抽象的依据，需要预先定义。&lt;/p&gt;
&lt;p&gt;根据实验所用项目的实际使用环境，我们定义的泛化层次结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/travelcube/68d6d7761130ee07e2203413db397cc931392.png&quot; alt=&quot;图5 机房泛化层次结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5 机房泛化层次结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/travelcube/3430242676928adf971d9e65e0213f2635586.png&quot; alt=&quot;图6 环境泛化层次结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6 环境泛化层次结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/travelcube/48c6e5c04b8ab2673d1ce8dc02c66493120473.png&quot; alt=&quot;图7 错误来源泛化层次结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图7 错误来源泛化层次结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/travelcube/ff9b4db00dec445e9e46922459d21a8d36457.png&quot; alt=&quot;图8 日志文本摘要泛化层次结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图8 日志文本摘要泛化层次结构&lt;/p&gt;
&lt;p&gt;“故障所在位置”此属性无需泛化层次结构，每次泛化时直接按照包路径向上层截断，直到系统包名。&lt;/p&gt;
&lt;h2 id=&quot;实验&quot;&gt;实验&lt;/h2&gt;
&lt;p&gt;以下三个实验均使用C端API系统。&lt;/p&gt;
&lt;h3 id=&quot;1-单依赖故障&quot;&gt;1. 单依赖故障&lt;/h3&gt;
&lt;p&gt;实验材料来自于线上某业务系统真实故障时所产生的大量报警日志。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;环境：线上&lt;/li&gt;
&lt;li&gt;故障原因：产品中心线上单机故障&lt;/li&gt;
&lt;li&gt;报警日志数量：939条&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;部分原始报警日志如图9所示，初次观察时，很难理出头绪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/travelcube/e2615c33f819e45412e1b1d336befc5b2002459.png&quot; alt=&quot;图9 单依赖故障报警日志节选&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图9 单依赖故障报警日志节选 &lt;/p&gt;
&lt;p&gt;经过聚类后的报警摘要如表1所示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;ID&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Server Room&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Error Source&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Environment&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Position （为保证数据安全，类路径已做处理）&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Summary （为保证数据安全，部分类路径已做处理）&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Count&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.CommonProductQueryClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: commonQueryClient.getProductType execution timeout after waiting for 150ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;249&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;业务插件&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.PluginRegistry.lambda&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;java.lang.IllegalArgumentException: 未找到业务插件:所有产品类型&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;240&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.TrProductQueryClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: TrQueryClient.listTrByDids2C execution timeout after waiting for 1000ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;145&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td align=&quot;left&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;对外接口(猜喜/货架/目的地)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.RemoteDealServiceImpl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: ScenicDealList.listDealsByScenic execution timeout after waiting for 300ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;89&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.CommonProductQueryClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: commonQueryClient.listTrByDids2C execution timeout after waiting for 1000ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;29&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.ActivityQueryClientImpl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: commonQueryClient.getBusinessLicense execution timeout after waiting for 100ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;21&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.CommonProductQueryClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: commonQueryClient.getBusinessLicense execution timeout after waiting for 100ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;21&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td align=&quot;left&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;对外接口(猜喜/货架/目的地)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.RemoteDealServiceImpl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: HotelDealList.hotelShelf execution timeout after waiting for 500ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;17&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.TrProductQueryClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Caused by: java.lang.InterruptedException&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;16&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Prod&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.TrProductQueryClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Caused by: java.lang.InterruptedException&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;13&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们可以看到前三条报警摘要的Count远超其他报警摘要，并且它们指明了故障主要发生在产品中心的接口。&lt;/p&gt;
&lt;h3 id=&quot;2-无相关的多依赖同时故障&quot;&gt;2. 无相关的多依赖同时故障&lt;/h3&gt;
&lt;p&gt;实验材料为利用故障注入工具，在Staging环境模拟运营置顶服务和A/B测试服务同时产生故障的场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;环境：Staging（使用线上录制流量和压测平台模拟线上正常流量环境）&lt;/li&gt;
&lt;li&gt;模拟故障原因：置顶与A/B测试接口大量超时&lt;/li&gt;
&lt;li&gt;报警日志数量：527条&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;部分原始报警日志如图10所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/travelcube/41b255f1d20d9b2ae23662f21a05070a1748251.png&quot; alt=&quot;图10 无相关的多依赖同时故障报警日志节选&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图10 无相关的多依赖同时故障报警日志节选&lt;/p&gt;
&lt;p&gt;经过聚类后的报警摘要如表2所示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;ID&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Server Room&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Error Source&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Environment&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Position （为保证数据安全，类路径已做处理）&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Summary （为保证数据安全，部分类路径已做处理）&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Count&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;21&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;运营活动&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.ActivityQueryClientImpl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;[hystrix]置顶失败, circuit short is open&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;291&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;A/B测试&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.AbExperimentClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;[hystrix] tripExperiment error, circuit short is open&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;105&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;缓存&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.CacheClientFacade&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: c-cache-rpc.common_deal_base.rpc execution timeout after waiting for 1000ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;15&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品信息&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.queryDealModel&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Caused by: com.meituan.service.mobile.mtthrift.netty.exception.RequestTimeoutException: request timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;14&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.CommonProductQueryClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: commonQueryClient.getBusinessLicense execution timeout after waiting for 100ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.getOrderForm&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;java.lang.IllegalArgumentException: 产品无库存&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;left&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;弹性工程&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.PreSaleChatClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;com.netflix.hystrix.exception.HystrixTimeoutException: CustomerService.PreSaleChat execution timeout after waiting for 50ms.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;缓存&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.SpringCacheManager&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Caused by: java.net.SocketTimeoutException: Read timed out&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品信息&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.queryDetailUrlVO&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;java.lang.IllegalArgumentException: 未知的产品类型&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品信息&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.queryDetailUrlVO&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;java.lang.IllegalArgumentException: 无法获取链接地址&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从上表可以看到，前两条报警摘要符合本次试验的预期，定位到了故障发生的原因。说明在多故障的情况下，算法也有较好的效果。&lt;/p&gt;
&lt;h3 id=&quot;3-中间件与相关依赖同时故障&quot;&gt;3. 中间件与相关依赖同时故障&lt;/h3&gt;
&lt;p&gt;实验材料为利用故障注入工具，在Staging环境模拟产品中心服务和缓存服务同时产生超时故障的场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;环境：Staging（使用线上录制流量和压测平台模拟线上正常流量环境）&lt;/li&gt;
&lt;li&gt;模拟故障原因：产品中心所有接口超时，所有缓存服务超时&lt;/li&gt;
&lt;li&gt;报警日志数量：2165&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;部分原始报警日志如图11所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/travelcube/463289b6597c90caf018f17bcf2b12491867556.png&quot; alt=&quot;图11 中间件与相关依赖同时故障报警日志节选&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图11 中间件与相关依赖同时故障报警日志节选&lt;/p&gt;

&lt;p&gt;经过聚类后的报警摘要如表3所示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;ID&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Server Room&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Error Source&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Environment&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Position （为保证数据安全，类路径已做处理）&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Summary （为保证数据安全，部分类路径已做处理）&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Count&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Squirrel&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.cache&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;491&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Cellar&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.cache&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;285&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Squirrel&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.TdcServiceImpl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Other Exception&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;149&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;评论&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.cache&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;147&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Cellar&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.TdcServiceImpl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Other Exception&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;143&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Squirrel&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.PoiManagerImpl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;熔断&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;112&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.CommonProductQueryClient&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Other Exception&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;89&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;评论&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.TrDealProcessor&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Other Exception&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;83&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;评论&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.poi.PoiInfoImpl&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Other Exception&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;82&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有机房&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;产品中心&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Staging&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;com.*.*.*.client&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;74&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从上表可以看到，缓存（Squirrel和Cellar双缓存）超时最多，产品中心的超时相对较少，这是因为我们系统针对产品中心的部分接口做了兜底处理，当超时发生时后先查缓存，如果缓存查不到会穿透调用一个离线信息缓存系统，因此产品中心超时总体较少。&lt;/p&gt;
&lt;p&gt;综合上述三个实验得出结果，算法对于报警日志的泛化是具有一定效果。在所进行实验的三个场景中，均能够定位到关键问题。但是依然存在一些不足，报警摘要中，有的经过泛化的信息过于笼统（比如Other Exception）。&lt;/p&gt;
&lt;p&gt;经过分析，我们发现主要的原因有：其一，对于错误信息中关键字段的提取，在一定程度上决定了向上泛化的准确度。其二，系统本身日志设计存在一定的局限性。&lt;/p&gt;
&lt;p&gt;同时，在利用这个泛化后的报警摘要进行分析时，需要使用者具备相应领域的知识。&lt;/p&gt;
&lt;h2 id=&quot;未来规划&quot;&gt;未来规划&lt;/h2&gt;
&lt;p&gt;本文所关注的工作，主要在于验证聚类算法效果，还有一些方向可以继续完善和优化：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;日志内容的深度分析。本文仅对报警日志做了简单的关键字提取和人工标记，未涉及太多文本分析的内容。我们可以通过使用文本分类、文本特征向量相似度等，提高日志内容分析的准确度，提升泛化效果。&lt;/li&gt;
&lt;li&gt;多种聚类算法综合使用。本文仅探讨了处理系统错误日志时表现较好的聚类算法，针对系统中多种不同类型的报警，未来也可以配合其他聚类算法（如K-Means）共同对报警进行处理，优化聚合效果。&lt;/li&gt;
&lt;li&gt;自适应报警阈值。除了对报警聚类，我们还可以通过对监控指标的时序分析，动态管理报警阈值，提高告警的质量和及时性，减少误报和漏告数量。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Julisch, Klaus. “Clustering intrusion detection alarms to support root cause analysis.” ACM transactions on information and system security (TISSEC) 6.4 (2003): 443-471.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cluster_analysis&quot;&gt;https://en.wikipedia.org/wiki/Cluster_analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;作者简介&quot;&gt;作者简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;刘玚，美团点评后端工程师。2017 年加入美团点评，负责美团点评境内度假的业务开发。&lt;/li&gt;
&lt;li&gt;千钊，美团点评后端工程师。2017 年加入美团点评，负责美团点评境内度假的业务开发。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 01 Mar 2019 05:56:00 +0000</pubDate>
<dc:creator>美团技术团队</dc:creator>
<og:description>本文分析了后端服务运维中大量报警出现时相互淹没的问题，选定了一种基于类聚的根因分析算法，并且针对业务报警日志进行了设计与实现，最后构造实验对算法的效果进行了验证与定性分析。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meituantech/p/10456024.html</dc:identifier>
</item>
<item>
<title>Java枚举：小小enum，优雅而干净 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10455969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10455969.html</guid>
<description>&lt;p&gt;《Java编程思想》中有这么一句话：“有时恰恰因为它，你才能够‘优雅而干净’地解决问题”——这句话说的是谁呢？就是本篇的主角——枚举（Enum）——大家鼓掌了。&lt;/p&gt;
&lt;p&gt;在之前很长时间一段时间里，我都不怎么用枚举，因为总感觉它没什么用处——这其实就是“自我认知”的短见。&lt;strong&gt;当一个人一直蹲在自己的深井里而不敢跳出来的话，那他真的只能看到井口那么大点的天空&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;随着时间的推移，我做的项目越来越多，和枚举见面的机会也越来越多，于是我就渐渐地对它越来越有兴趣，研究得多了，才发现原来枚举如此的优秀。&lt;/p&gt;
&lt;h3 id=&quot;h1&quot;&gt;1）枚举的常规用法&lt;/h3&gt;
&lt;p&gt;一个精简的枚举非常的干净优雅，见下例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;enum Chenmo {&lt;br/&gt;WANGER, WANGSAN, WANGSI&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们为沉默枚举创建了三个值，分别是王二、王三、王四。这段代码实际上调用了3次&lt;code&gt;Enum(String name, int ordinal)&lt;/code&gt;（ordinal单词的意思为顺序），也就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new Enum&amp;lt;Chenmo&amp;gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;WANGER&quot;, &lt;span class=&quot;hljs-number&quot;&gt;0);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new Enum&amp;lt;Chenmo&amp;gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;WANGSAN&quot;, &lt;span class=&quot;hljs-number&quot;&gt;1);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new Enum&amp;lt;Chenmo&amp;gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;WANGSI&quot;, &lt;span class=&quot;hljs-number&quot;&gt;2);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来遍历输出一下枚举：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (Chenmo e : Chenmo.values()) {&lt;br/&gt;System.out.println(e);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h2switch&quot;&gt;2）作为switch的判断条件&lt;/h3&gt;
&lt;p&gt;使用枚举作为switch语句判断条件能让我们的代码可读性更强，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Chenmo key = Chenmo.WANGER;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;switch (key) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case WANGSI:&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;今天我送出一个CSDN大鼠标垫&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case WANGSAN:&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;今天我被坑一个CSDN学院年卡&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;default:&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;今天我一边高兴，一边失落&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在通过case关键字判断的时候，可以直接使用枚举值，非常简洁。另外，在编译期间限定类型，可以有效的避免越界的情况——字符串常量类型在作为switch判断条件的时候很容易因为误写而发生越界问题。&lt;/p&gt;
&lt;h3 id=&quot;h3&quot;&gt;3）枚举实现单例&lt;/h3&gt;
&lt;p&gt;《Effective Java》一书中对使用枚举实现单例的方式推崇备至：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我觉得“虽然还没有广泛采用”几个字可以去掉了，时至今日，大家应该都知道：使用枚举实现单例是一种非常好的方式。&lt;/p&gt;
&lt;p&gt;先来看“双重校验锁”实现的单例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;2&quot;&gt;class &lt;span class=&quot;hljs-title&quot; readability=&quot;4&quot;&gt;SingleTon2 {&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;volatile SingleTon2 singleTon = &lt;span class=&quot;hljs-keyword&quot;&gt;null;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static SingleTon2 &lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看枚举实现的单例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;1&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot; readability=&quot;2&quot;&gt;enum SingleTon {&lt;p&gt;INSTANCE;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;method&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;我很快乐！&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不比不知道，一比吓一跳啊！枚举方式的单例简单到爆——为了不至于看起来太过精简，我还加了一个输出“我很快乐”的方法。&lt;/p&gt;
&lt;p&gt;枚举实现的单例可轻松地解决两个问题：&lt;/p&gt;
&lt;p&gt;①、线程安全问题。因为Java虚拟机在加载枚举类的时候，会使用ClassLoader的loadClass方法，这个方法使用了同步代码块来保证线程安全。&lt;/p&gt;
&lt;p&gt;②、避免反序列化破坏单例。因为枚举的反序列化并不通过反射实现。&lt;/p&gt;
&lt;h3 id=&quot;h4&quot;&gt;4）枚举可与数据库交互&lt;/h3&gt;
&lt;p&gt;我们可以配合Mybatis将数据库字段转换为枚举类型。现在假设有一个数据库字段check_type的类型如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;`check_type` int(1) DEFAULT NULL &lt;span class=&quot;hljs-keyword&quot;&gt;COMMENT &lt;span class=&quot;hljs-string&quot;&gt;'检查类型（1：未通过、2：通过）',&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它对应的枚举类型为CheckType，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;enum CheckType {&lt;br/&gt;NO_PASS(&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-string&quot;&gt;&quot;未通过&quot;), PASS(&lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-string&quot;&gt;&quot;通过&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;8&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot; readability=&quot;16&quot;&gt;int key;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private String text;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-title&quot;&gt;CheckType&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int key, String text) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.key = key;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.text = text;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;getKey&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return key;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getText&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return text;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static HashMap&amp;lt;Integer,CheckType&amp;gt; map = &lt;span class=&quot;hljs-keyword&quot;&gt;new HashMap&amp;lt;Integer,CheckType&amp;gt;();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for(CheckType d : CheckType.values()){&lt;br/&gt;map.put(d.key, d);&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static CheckType &lt;span class=&quot;hljs-title&quot;&gt;parse&lt;span class=&quot;hljs-params&quot;&gt;(Integer index) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if(map.containsKey(index)){&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return map.get(index);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;null;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CheckType枚举类比我们刚开始见到的那个Chenmo枚举类要复杂一些。&lt;/p&gt;
&lt;p&gt;第一，CheckType新添加了构造方法，还有两个字段，key为int型，text为String型。&lt;/p&gt;
&lt;p&gt;第二，CheckType中有一个&lt;code&gt;public static CheckType parse(Integer index)&lt;/code&gt;方法，可将一个Integer通过key的匹配转化为枚举类型。&lt;/p&gt;
&lt;p&gt;那么现在，我们可以在Mybatis的配置文件中使用&lt;code&gt;typeHandler&lt;/code&gt;将数据库字段转化为枚举类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;resultMap &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;CheckLog&quot; &lt;span class=&quot;hljs-attr&quot;&gt;type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.entity.CheckLog&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;id &lt;span class=&quot;hljs-attr&quot;&gt;property=&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot; &lt;span class=&quot;hljs-attr&quot;&gt;column=&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;/&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;result &lt;span class=&quot;hljs-attr&quot;&gt;property=&lt;span class=&quot;hljs-string&quot;&gt;&quot;checkType&quot; &lt;span class=&quot;hljs-attr&quot;&gt;column=&lt;span class=&quot;hljs-string&quot;&gt;&quot;check_type&quot; &lt;span class=&quot;hljs-attr&quot;&gt;typeHandler=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.CheckTypeHandler&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;result&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;resultMap&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中checkType字段对应的类如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;CheckLog &lt;span class=&quot;hljs-keyword&quot; readability=&quot;5&quot;&gt;implements &lt;span class=&quot;hljs-title&quot; readability=&quot;10&quot;&gt;Serializable {&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private String id;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private CheckType checkType;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getId&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return id;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setId&lt;span class=&quot;hljs-params&quot;&gt;(String id) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.id = id;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public CheckType &lt;span class=&quot;hljs-title&quot;&gt;getCheckType&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return checkType;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setCheckType&lt;span class=&quot;hljs-params&quot;&gt;(CheckType checkType) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.checkType = checkType;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CheckTypeHandler转换器的类源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;CheckTypeHandler &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot; readability=&quot;9.5&quot;&gt;BaseTypeHandler&amp;lt;&lt;span class=&quot;hljs-title&quot; readability=&quot;19&quot;&gt;CheckType&amp;gt; {&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public CheckType &lt;span class=&quot;hljs-title&quot;&gt;getNullableResult&lt;span class=&quot;hljs-params&quot;&gt;(ResultSet rs, String index) &lt;span class=&quot;hljs-keyword&quot;&gt;throws SQLException {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return CheckType.parse(rs.getInt(index));&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public CheckType &lt;span class=&quot;hljs-title&quot;&gt;getNullableResult&lt;span class=&quot;hljs-params&quot;&gt;(ResultSet rs, &lt;span class=&quot;hljs-keyword&quot;&gt;int index) &lt;span class=&quot;hljs-keyword&quot;&gt;throws SQLException {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return CheckType.parse(rs.getInt(index));&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public CheckType &lt;span class=&quot;hljs-title&quot;&gt;getNullableResult&lt;span class=&quot;hljs-params&quot;&gt;(CallableStatement cs, &lt;span class=&quot;hljs-keyword&quot;&gt;int index) &lt;span class=&quot;hljs-keyword&quot;&gt;throws SQLException {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return CheckType.parse(cs.getInt(index));&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setNonNullParameter&lt;span class=&quot;hljs-params&quot;&gt;(PreparedStatement ps, &lt;span class=&quot;hljs-keyword&quot;&gt;int index, CheckType val, JdbcType arg3) &lt;span class=&quot;hljs-keyword&quot;&gt;throws SQLException {&lt;br/&gt;ps.setInt(index, val.getKey());&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CheckTypeHandler 的核心功能就是调用CheckType枚举类的&lt;code&gt;parse()&lt;/code&gt;方法对数据库字段进行转换。&lt;/p&gt;
&lt;h3 id=&quot;h5&quot;&gt;5）枚举会比静态常量更消耗内存吗？&lt;/h3&gt;
&lt;p&gt;说完枚举最常用的4个知识点后，我们来讨论一下“枚举会比静态常量更消耗内存吗？”这个话题——知乎上有人问这样的问题，还有很多人参与回答。&lt;/p&gt;
&lt;p&gt;按我的理解，问这个问题的人就好像是在问“0.000,001”比“0.000,000,99”大吗？你说是吗？&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.qingmiaokeji.cn/article/29&quot;&gt;“挑三拣四”地学一学Java I/O&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.qingmiaokeji.cn/article/27&quot;&gt;张嘴，深入浅出一下Java的HashMap&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Mar 2019 05:46:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>《Java编程思想》中有这么一句话：“有时恰恰因为它，你才能够‘优雅而干净’地解决问题”——这句话说的是谁呢？就是本篇的主角——枚举（Enum）——大家鼓掌了。 在之前很长时间一段时间里，我都不怎么用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10455969.html</dc:identifier>
</item>
<item>
<title>CUBA Studio 8.0 发布，企业级应用开发平台 - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/cuba-update.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/cuba-update.html</guid>
<description>
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190301122805805-907287288.png&quot; alt=&quot;&quot; width=&quot;243&quot; height=&quot;334&quot;/&gt;　 &lt;/p&gt;

&lt;p&gt;　　CUBA Platform 是一款开源且免费的企业级应用开发框架，已有将近10年的发展历史，由俄罗斯的 Haulmont  公司开发，CUBA Platform 近期将正式登陆中国，将提供中文网站、中文社区、中文开发文档以及本地化的技术支持。&lt;/p&gt;
&lt;p&gt;　　CUBA Studio 是基于CUBA Platform 的企业级应用的集成开发环境。关于 CUBA Platform 的详细信息可参阅&lt;a href=&quot;https://my.oschina.net/u/3900929&quot;&gt;&lt;span&gt;&lt;span&gt;系列文章&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　二月的最后一天&lt;/span&gt; CUBA Studio 8.0 发布，这个版本主要的功能改进：&lt;/p&gt;
&lt;p&gt;　　l 首次打开项目时会使用导入向导。有关详细信息，请参阅&lt;a href=&quot;https://doc.cuba-platform.com/studio/open_project.html&quot;&gt;&lt;span&gt;&lt;span&gt;打开现有项目&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;项目模型现在存储在&lt;/span&gt; .idea 文件夹内的文件中，因此现在不会在每次打开项目时都启动 Gradle 同步。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;现在在&lt;/span&gt; IDE 的&lt;strong&gt; Run/Debug&lt;/strong&gt; &lt;span&gt;配置中可以为应用程序服务选择&lt;/span&gt; JDK ，默认使用JAVA_HOME  环境变量指定的 JDK。&lt;/p&gt;
&lt;p&gt;　　l 现在可以通过标准的&lt;strong&gt; Refactor &amp;gt; Rename&lt;/strong&gt; &lt;span&gt;操作重命名视图。这个操作可在以下位置调用：&lt;/span&gt; CUBA 项目树中的视图元素上、views.xml 文件中的视图定义、界面 XML 描述中对视图的引用。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;可从界面&lt;/span&gt; XML 描述中的数据容器的 view 字段直接调用视图设计器。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;在界面&lt;/span&gt; XML  描述中的 &amp;lt;fragment&amp;gt; 元素的 screen 属性上可以使用自动完成，也能查出这个元素对 fragment 的引用。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;菜单标题现在支持本地化消息编辑器。在&lt;/span&gt; CUBA 项目树中点击&lt;strong&gt; Generic UI &amp;gt; Web &lt;/strong&gt;&lt;strong&gt;Menu&lt;/strong&gt; ，切换到&lt;strong&gt; Structure&lt;/strong&gt; &lt;span&gt;标签页，选择一个菜单项，然后点击&lt;/span&gt; &lt;strong&gt;Caption&lt;/strong&gt; &lt;span&gt;字段中的&lt;/span&gt; &lt;strong&gt;edit&lt;/strong&gt; &lt;span&gt;按钮。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　l 对于没有本地化标题的枚举值提供警告信息。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;配置接口中定义的应用程序属性名现在支持自动完成。比如在&lt;/span&gt; app.properties 或 web-app.properties 文件中定义属性可按 Ctrl+Space  来快速插入已定义的属性。&lt;/p&gt;
&lt;p&gt;　　另外，这个版本包含&lt;span&gt;了其它两百多项&lt;/span&gt;Bug修复或改进。详细内容请参阅：&lt;a href=&quot;https://doc.cuba-platform.com/studio/release_notes.html?_ga=2.148109623.1091471090.1551055180-952816468.1486173136&quot;&gt;&lt;span&gt;Release Notes&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Mar 2019 05:42:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<og:description>CUBA Platform 是一款开源且免费的企业级应用开发框架，已有将近10年的发展历史，由俄罗斯的 Haulmont 公司开发，CUBA Platform 近期将正式登陆中国，将提供中文网站、中文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/cuba-update.html</dc:identifier>
</item>
</channel>
</rss>