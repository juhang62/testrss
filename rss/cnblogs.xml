<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式之-工厂模式 - 谁主沉浮oo7</title>
<link>http://www.cnblogs.com/feifuzeng/p/13674134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feifuzeng/p/13674134.html</guid>
<description>&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br/&gt;在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;意图&lt;/strong&gt;：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：主要解决接口选择的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：我们明确地计划不同条件下创建不同实例时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：让其子类实现工厂接口，返回的也是一个抽象的产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：创建过程在其子类执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用实例&lt;/strong&gt;： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，&quot;POP3&quot;、&quot;IMAP&quot;、&quot;HTTP&quot;，可以把这三个作为产品类，共同实现一个接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。&lt;br/&gt;FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。&lt;br/&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/08/factory_pattern_uml_diagram.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;步骤 1&lt;br/&gt;创建一个接口:&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;Shape.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Shape {
   void draw();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;步骤 2&lt;br/&gt;创建实现接口的实体类。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;Rectangle.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Square.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Circle.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;步骤 3&lt;br/&gt;创建一个工厂，生成基于给定信息的实体类的对象。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;ShapeFactory.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){
         return new Square();
      }
      return null;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;步骤 4&lt;br/&gt;使用该工厂，通过传递类型信息来获取实体类的对象。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;FactoryPatternDemo.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;步骤 5&lt;br/&gt;执行程序，输出结果：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;欢迎关注微信公众号『码仔zonE』，专注于分享Java、云计算相关内容，包括SpringBoot、SpringCloud、微服务、Docker、Kubernetes、Python等领域相关技术干货，期待与您相遇！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/908629/202008/908629-20200819141402537-1758432824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Sep 2020 00:51:00 +0000</pubDate>
<dc:creator>谁主沉浮oo7</dc:creator>
<og:description>基本概念 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feifuzeng/p/13674134.html</dc:identifier>
</item>
<item>
<title>Java 15 正式发布， 14 个新特性，刷新你的认知！！ - Java技术栈</title>
<link>http://www.cnblogs.com/javastack/p/13683220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javastack/p/13683220.html</guid>
<description>&lt;p&gt;JDK 15 2020/09/15 如期而至！&lt;/p&gt;
&lt;p&gt;这个时间牛逼啊，和苹果发布会同天？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218593/202009/1218593-20200917085028303-927709450.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OracleJDK 15 发布地址：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/java/technologies/javase/15all-relnotes.html&quot;&gt;https://www.oracle.com/java/technologies/javase/15all-relnotes.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenJDK 15 发布地址：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://openjdk.java.net/projects/jdk/15/&quot;&gt;https://openjdk.java.net/projects/jdk/15/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OracleJDK 和 OpenJDK 两者的区别这里不撰述了，不清楚的请点击&lt;a href=&quot;https://mp.weixin.qq.com/s/FvGwskeFzSyB1n0aPVggAQ&quot;&gt;这里&lt;/a&gt;进行查看。&lt;/p&gt;
&lt;p&gt;现在的 JDK 真变成了“版本帝”，无力吐槽啊，版本发到 15，大部分人却都还在用着 JDK 7/8，甚至 6。不过没关系，多了解一下，多掌握一点新东西，对你来说没有坏处。&lt;/p&gt;
&lt;h2 id=&quot;新特性&quot;&gt;新特性&lt;/h2&gt;
&lt;p&gt;JDK 15 新特性一览表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;JEP&lt;/th&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;339&lt;/td&gt;
&lt;td&gt;Edwards-Curve Digital Signature Algorithm (EdDSA)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;360&lt;/td&gt;
&lt;td&gt;Sealed Classes (Preview)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;371&lt;/td&gt;
&lt;td&gt;Hidden Classes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;372&lt;/td&gt;
&lt;td&gt;Remove the Nashorn JavaScript Engine&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;373&lt;/td&gt;
&lt;td&gt;Reimplement the Legacy DatagramSocket API&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;374&lt;/td&gt;
&lt;td&gt;Disable and Deprecate Biased Locking&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;375&lt;/td&gt;
&lt;td&gt;Pattern Matching for instanceof (Second Preview)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;377&lt;/td&gt;
&lt;td&gt;ZGC: A Scalable Low-Latency Garbage Collector&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;378&lt;/td&gt;
&lt;td&gt;Text Blocks&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;379&lt;/td&gt;
&lt;td&gt;Shenandoah: A Low-Pause-Time Garbage Collector&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;381&lt;/td&gt;
&lt;td&gt;Remove the Solaris and SPARC Ports&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;383&lt;/td&gt;
&lt;td&gt;Foreign-Memory Access API (Second Incubator)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;384&lt;/td&gt;
&lt;td&gt;Records (Second Preview)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;385&lt;/td&gt;
&lt;td&gt;Deprecate RMI Activation for Removal&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;JDK 15 一次发布了 14 个新特性，下面栈长带大家来解读下这些新特性！&lt;/p&gt;
&lt;h4 id=&quot;339edwards-curve-digital-signature-algorithm-eddsa&quot;&gt;339:Edwards-Curve Digital Signature Algorithm (EdDSA)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Edwards-Curve&lt;/code&gt; 数据签名算法（EdDSA），一种根据 &lt;code&gt;RFC 8032&lt;/code&gt; 规范所描述的 &lt;code&gt;Edwards-Curve&lt;/code&gt; 数字签名算法（EdDSA）实现加密签名，实现了一种 &lt;code&gt;RFC 8032&lt;/code&gt; 标准化方案，但它不能代替 ECDSA。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;EdDSA 是一种现代的椭圆曲线签名方案，与 JDK 中现有的签名方案相比，它有很多优势。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;360sealed-classes-preview&quot;&gt;360:Sealed Classes (Preview)&lt;/h4&gt;
&lt;p&gt;封闭类（预览特性），可以是封闭类和或者封闭接口，用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。&lt;/p&gt;
&lt;p&gt;这个牛逼啊，有了这个特性，意味着以后不是你想继承就继承，想实现就实现了，你得经过允许才行。&lt;/p&gt;
&lt;p&gt;来看这个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract sealed class Student
    permits ZhangSan, LiSi, ZhaoLiu {
    ...
        
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类 Student 被 &lt;code&gt;sealed&lt;/code&gt; 修饰，说明它是一个封闭类，并且只允许指定的 3 个子类继承。&lt;/p&gt;
&lt;h4 id=&quot;371hidden-classes&quot;&gt;371:Hidden Classes&lt;/h4&gt;
&lt;p&gt;隐藏类，这一看也是个很有意思的特性。&lt;/p&gt;
&lt;p&gt;隐藏类是为框架（frameworks）所设计的，隐藏类不能直接被其他类的字节码使用，只能在运行时生成类并通过反射间接使用它们。&lt;/p&gt;
&lt;h4 id=&quot;372remove-the-nashorn-javascript-engine&quot;&gt;372:Remove the Nashorn JavaScript Engine&lt;/h4&gt;
&lt;p&gt;移除了 &lt;code&gt;Nashorn&lt;/code&gt; JavaScript 脚本引擎、APIs，以及 &lt;code&gt;jjs&lt;/code&gt; 工具。这些早在 JDK 11 中就已经被标记为 &lt;code&gt;deprecated&lt;/code&gt; 了，JDK 15 被移除就很正常了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Nashorn 是 JDK 1.8 引入的一个 JavaScript 脚本引擎，用来取代 Rhino 脚本引擎。Nashorn 是 &lt;code&gt;ECMAScript-262 5.1&lt;/code&gt; 的完整实现，增强了 Java 和 JavaScript 的兼容性，并且大大提升了性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么要移除？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方的描述是，随着 &lt;code&gt;ECMAScript&lt;/code&gt; 脚本语言的结构、API 的改编速度越来越快，维护 &lt;code&gt;Nashorn&lt;/code&gt; 太有挑战性了，所以……。&lt;/p&gt;
&lt;h4 id=&quot;373reimplement-the-legacy-datagramsocket-api&quot;&gt;373:Reimplement the Legacy DatagramSocket API&lt;/h4&gt;
&lt;p&gt;重新实现了老的 &lt;code&gt;DatagramSocket&lt;/code&gt; API 接口，更改了 &lt;code&gt;java.net.DatagramSocket&lt;/code&gt; 和 &lt;code&gt;java.net.MulticastSocket&lt;/code&gt; 为更加简单、现代化的底层实现，更易于维护和调试。&lt;/p&gt;
&lt;p&gt;新的底层实现将很容易使用虚拟线程，目前正在 &lt;code&gt;Loom&lt;/code&gt; 项目中进行探索。这也是 &lt;code&gt;JEP 353&lt;/code&gt; 的后续更新版本，&lt;code&gt;JEP 353&lt;/code&gt; 已经重新实现了 Socket API。&lt;/p&gt;
&lt;h4 id=&quot;374disable-and-deprecate-biased-locking&quot;&gt;374:Disable and Deprecate Biased Locking&lt;/h4&gt;
&lt;p&gt;准备禁用和废除偏向锁，在 JDK 15 中，默认情况下禁用偏向锁，并弃用所有相关的命令行选项。&lt;/p&gt;
&lt;p&gt;后面再确定是否需要继续支持偏向锁，国为维护这种锁同步优化的成本太高了。&lt;/p&gt;
&lt;h4 id=&quot;375pattern-matching-for-instanceof-second-preview&quot;&gt;375:Pattern Matching for instanceof (Second Preview)&lt;/h4&gt;
&lt;p&gt;模式匹配（第二次预览），第一次预览是 JDK 14 中提出来的，点击&lt;a href=&quot;https://mp.weixin.qq.com/s/Qfni7MQOicfhCOtCMEpaog&quot;&gt;这里&lt;/a&gt;查看栈长之前写的详细教程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 14 之前：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (object instanceof Kid) {
    Kid kid = (Kid) object;
    // ...
} else if (object instanceof Kiddle) {
    Kid kid = (Kid) object;
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java 14+：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (object instanceof Kid kid) {
    // ...
} else if (object instanceof Kiddle kiddle) {
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 15 并没有对此特性进行调整，继续预览特性，只是为了收集更多的用户反馈，可能还不成熟吧。&lt;/p&gt;
&lt;h4 id=&quot;377zgc-a-scalable-low-latency-garbage-collector&quot;&gt;377:ZGC: A Scalable Low-Latency Garbage Collector&lt;/h4&gt;
&lt;p&gt;ZGC：一个可伸缩、低延迟的垃圾回收器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ZGC&lt;/code&gt; 最早是在 JDK 11 中集成进来的，JDK 15 只是将 &lt;code&gt;ZGC&lt;/code&gt; 垃圾收集器从预览特性变更为正式特性而已，没错，转正了。&lt;/p&gt;
&lt;p&gt;这个 &lt;code&gt;JEP&lt;/code&gt; 不会更改默认的 GC，默认仍然是 &lt;code&gt;G1&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;378text-blocks&quot;&gt;378:Text Blocks&lt;/h4&gt;
&lt;p&gt;文本块，是一个多行字符串，它可以避免使用大多数转义符号，自动以可预测的方式格式化字符串，并让开发人员在需要时可以控制格式。&lt;/p&gt;
&lt;p&gt;文本块最早准备在 JDK 12 添加的，但最终撤消了，然后在 JDK 13 中作为预览特性进行了添加，然后又在 JDK 14 中再次预览，在 JDK 15 中，文本块终于转正，暂不再做进一步的更改。&lt;/p&gt;
&lt;p&gt;来看下这个示例你就懂了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 13 之前：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String html = &quot;&amp;lt;html&amp;gt;\n&quot; +
              &quot;    &amp;lt;body&amp;gt;\n&quot; +
              &quot;        &amp;lt;p&amp;gt;Hi, Java技术栈&amp;lt;/p&amp;gt;\n&quot; +
              &quot;        &amp;lt;p&amp;gt;欢迎关注，分享更多干货&amp;lt;/p&amp;gt;\n&quot; +
              &quot;    &amp;lt;/body&amp;gt;\n&quot; +
              &quot;&amp;lt;/html&amp;gt;\n&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java 13+：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String html = &quot;&quot;&quot;
              &amp;lt;html&amp;gt;
                  &amp;lt;body&amp;gt;
                      &amp;lt;p&amp;gt;Hi, Java技术栈&amp;lt;/p&amp;gt;
                      &amp;lt;p&amp;gt;欢迎关注，分享更多干货&amp;lt;/p&amp;gt;
                  &amp;lt;/body&amp;gt;
              &amp;lt;/html&amp;gt;
              &quot;&quot;&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去掉那些无用的换行和拼接，是不是太爽了。。这个详细教程计划再出一篇，关注公众号Java技术栈第一时间推送。&lt;/p&gt;
&lt;h4 id=&quot;379shenandoah-a-low-pause-time-garbage-collector&quot;&gt;379:Shenandoah: A Low-Pause-Time Garbage Collector&lt;/h4&gt;
&lt;p&gt;Shenandoah：一个低停顿时间的垃圾回收器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Shenandoah&lt;/code&gt; 最早是在 JDK 12 中集成进来的，JDK 15 只是将 &lt;code&gt;Shenandoah&lt;/code&gt; 垃圾收集器从预览特性变更为正式特性而已，没错，又是转正了。&lt;/p&gt;
&lt;h4 id=&quot;381remove-the-solaris-and-sparc-ports&quot;&gt;381:Remove the Solaris and SPARC Ports&lt;/h4&gt;
&lt;p&gt;移除了 &lt;code&gt;Solaris&lt;/code&gt; 和 &lt;code&gt;SPARC&lt;/code&gt; 端口。&lt;/p&gt;
&lt;p&gt;移除了 &lt;code&gt;Solaris/SPARC&lt;/code&gt;、&lt;code&gt;Solaris/x64&lt;/code&gt; 和 &lt;code&gt;Linux/SPARC&lt;/code&gt; 端口的源代码及构建支持。这些端口在 JDK 14 中就已经被标记为 &lt;code&gt;deprecated&lt;/code&gt; 了，JDK 15 被移除也不奇怪。&lt;/p&gt;
&lt;h4 id=&quot;383foreign-memory-access-api-second-incubator&quot;&gt;383:Foreign-Memory Access API (Second Incubator)&lt;/h4&gt;
&lt;p&gt;外存访问 API（二次孵化），可以允许 Java 应用程序安全有效地访问 Java 堆之外的外部内存。&lt;/p&gt;
&lt;p&gt;这个最早在 JDK 14 中成为孵化特性，JDK 15 继续二次孵化并对其 API 有了一些更新。&lt;/p&gt;
&lt;h4 id=&quot;384records-second-preview&quot;&gt;384:Records (Second Preview)&lt;/h4&gt;
&lt;p&gt;Records 最早在 JDK 14 中成为预览特性，JDK 15 继续二次预览。&lt;/p&gt;
&lt;p&gt;Records 在某些场合可以干掉 &lt;code&gt;Lombok&lt;/code&gt; 的存在，能自动生成了类构造器、toString()、hashCode()、equals()，以及类似 getter 的变量访问方法。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public record Student(String name, int id, int age) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际生成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218593/202009/1218593-20200917085028556-1834355223.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完是不是有点 Lombok 的感觉？具体可以点击&lt;a href=&quot;https://mp.weixin.qq.com/s/d5dX1ldc-Wse2PT7ODR9xA&quot;&gt;这里&lt;/a&gt;查看栈长之前写的详细教程。&lt;/p&gt;
&lt;h4 id=&quot;385deprecate-rmi-activation-for-removal&quot;&gt;385:Deprecate RMI Activation for Removal&lt;/h4&gt;
&lt;p&gt;废除 RMI 激活，以便在将来进行删除。&lt;/p&gt;
&lt;p&gt;需要说明的是，RMI 激活是 RMI 中一个过时的组件，自 Java 8 以来一直是可选的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了 JDK/Java 15 的 14 个新特性，后面栈长有时间也会继续出一些 JDK 15 详细教程，关注公众号Java技术栈第一时间推送哦。如果你想看历史 Java 8 - 14 新特性教程，也可以在公众号菜单中进行阅读。&lt;/p&gt;
&lt;p&gt;最后，来看下 Oracle Java 支持路线图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1218593/202009/1218593-20200917085028750-1514345051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JDK 15 并不是一个长期支持的版本，只支持 6 个月到 2021 年 3 月，上一个长期支持版本还是 JDK 11，所以千万不要把非长期支持版本用在生产。&lt;/p&gt;
&lt;p&gt;JDK 15 下载地址：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/java/technologies/javase-downloads.html&quot;&gt;https://www.oracle.com/java/technologies/javase-downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有兴趣的可以下载尝鲜了！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写了大半天，点个在看、转发支持下哦，分享给你的更多朋友们~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关注Java技术栈，持续分享最新、最主流的Java技术~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;近期热文推荐：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;a href=&quot;http://www.javastack.cn/article/2020/intellij-idea-by-open-source-project/&quot;&gt;终于靠开源项目弄到 IntelliJ IDEA 激活码了，真香！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://www.javastack.cn/article/2020/java-8-optional-map-do-you-know/&quot;&gt;我用 Java 8 写了一段逻辑，同事直呼看不懂，你试试看。。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href=&quot;http://www.javastack.cn/article/2020/undertow-introduce-with-spring-boot/&quot;&gt;吊打 Tomcat ，Undertow 性能很炸！！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href=&quot;http://www.javastack.cn/article/2020/another-redis-desktop-manager/&quot;&gt;国人开源了一款超好用的 Redis 客户端，真香！！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;a href=&quot;http://www.javastack.cn/article/2020/alibaba-release-java-develop-rules-songshan/&quot;&gt;《Java开发手册（嵩山版）》最新发布，速速下载！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;觉得不错，别忘了随手点赞+转发哦！&lt;/p&gt;
</description>
<pubDate>Thu, 17 Sep 2020 00:50:00 +0000</pubDate>
<dc:creator>Java技术栈</dc:creator>
<og:description>JDK 15 2020/09/15 如期而至！ 这个时间牛逼啊，和苹果发布会同天？ OracleJDK 15 发布地址： https://www.oracle.com/java/technologie</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javastack/p/13683220.html</dc:identifier>
</item>
<item>
<title>JSON数据处理框架Jackson精解第一篇-序列化与反序列化核心用法 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13683167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13683167.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200917075812877-1999033792.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Jackson是Spring Boot默认的JSON数据处理框架，但是其并不依赖于任何的Spring 库。有的小伙伴以为Jackson只能在Spring框架内使用，其实不是的，没有这种限制。它提供了很多的JSON数据处理方法、注解，也包括&lt;strong&gt;流式API、树模型、数据绑定&lt;/strong&gt;，以及复杂数据类型转换等功能。它虽然简单易用，但绝对不是小玩具，本节为大家介绍Jackson的基础核心用法，&lt;strong&gt;更多的内容我会写成一个系列，5-10篇文章，请您继续关注我。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、基础准备&quot;&gt;一、基础准备&lt;/h2&gt;
&lt;p&gt;在任意项目中引入下面的jar就可以使用jackson进行JSON的数据序列化与反序列化的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.9.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写一个PlayerStar的实体类，实体类主要体现篮球明星的名字、年龄、业余爱好、朋友、年收入等信息，为了尽可能地演示Jackson的序列化与反序列化功能，将数组、List、Map都融合到这个类里面。并通过getInstance初始化篮球明星Jordan这个对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
public class PlayerStar {

  private String name;
  private Integer age;
  private String[] hobbies;    //业余爱好,数组
  private List&amp;lt;String&amp;gt; friends;   //  朋友
  private Map&amp;lt;String, BigDecimal&amp;gt; salary; //年收入 Map


  //初始化一个对象用于测试
  public static PlayerStar getInstance(){
    PlayerStar playerStar = new PlayerStar();

    playerStar.setName(&quot;乔丹&quot;);
    playerStar.setAge(45);
    playerStar.setHobbies(new String[]{&quot;高尔夫球&quot;, &quot;棒球&quot;});
    Map&amp;lt;String, BigDecimal&amp;gt; salary = new HashMap&amp;lt;String, BigDecimal&amp;gt;() {{
      put(&quot;2000&quot;, new BigDecimal(10000000));
      put(&quot;2010&quot;, new BigDecimal(62000000));
      put(&quot;2020&quot;, new BigDecimal(112400000));
    }};
    playerStar.setSalary(salary);
    playerStar.setFriends(Arrays.asList(&quot;kobe&quot;, &quot;curry&quot;, &quot;james&quot;));

    return playerStar;
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、序列化方法&quot;&gt;二、序列化方法&lt;/h2&gt;
&lt;p&gt;下面代码演示了如何将PlayerStar对象序列化为JSON字符串。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;writeValue可以接收File作为参数，将JSON序列化结果保存到文件中&lt;/li&gt;
&lt;li&gt;writeValueAsString将JSON序列化结果以String形式返回&lt;/li&gt;
&lt;li&gt;writerWithDefaultPrettyPrinter方法可以将JSON序列化结果进行格式化，更好的显示结构，易于查看&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Test
void testObject2JSON() throws IOException {
  //获取对象实例
  PlayerStar player = PlayerStar.getInstance();

  //ObjectMapper作为Jackson的API工具类存在
  ObjectMapper mapper = new ObjectMapper();
  //将player对象以JSON格式进行序列化，并将序列化结果写入文件
  mapper.writeValue(new File(&quot;d:\\data\\jackson\\player.json&quot;), player);

  //将player对象以JSON格式进行序列化为String对象
  String jsonString = mapper.writeValueAsString(player);
  System.out.println(jsonString);

  //将player对象以JSON格式进行序列化为String对象(格式美化)
  String jsonInString2 = mapper.writerWithDefaultPrettyPrinter()
          .writeValueAsString(player);
  System.out.println(jsonInString2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jsonString的控制台打印输出结果，也是d:\data\jackson\player.json文件的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
{&quot;name&quot;:&quot;乔丹&quot;,&quot;age&quot;:45,&quot;hobbies&quot;:[&quot;高尔夫球&quot;,&quot;棒球&quot;],&quot;friends&quot;:[&quot;kobe&quot;,&quot;curry&quot;,&quot;james&quot;],&quot;salary&quot;:{&quot;2000&quot;:10000000,&quot;2010&quot;:62000000,&quot;2020&quot;:112400000}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jsonString2的控制台打印输出，格式进行了美化，因为使用了writerWithDefaultPrettyPrinter()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;name&quot; : &quot;乔丹&quot;,
  &quot;age&quot; : 45,
  &quot;hobbies&quot; : [ &quot;高尔夫球&quot;, &quot;棒球&quot; ],
  &quot;friends&quot; : [ &quot;kobe&quot;, &quot;curry&quot;, &quot;james&quot; ],
  &quot;salary&quot; : {
    &quot;2000&quot; : 10000000,
    &quot;2010&quot; : 62000000,
    &quot;2020&quot; : 112400000
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、反序列化方法&quot;&gt;三、反序列化方法&lt;/h2&gt;
&lt;p&gt;下面代码演示了如何将JSON字符串反序列化为Java对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testJSON2Object() throws IOException {
  ObjectMapper mapper = new ObjectMapper();
  //从文件中读取JSON字符串，反序列化为java对象
  PlayerStar player = mapper.readValue(new File(&quot;d:\\data\\jackson\\player.json&quot;), PlayerStar.class);
  System.out.println(player);

  //将JSON字符串反序列化为java对象
  String jsonInString = &quot;{\&quot;name\&quot;:\&quot;乔丹\&quot;,\&quot;age\&quot;:45,\&quot;hobbies\&quot;:[\&quot;高尔夫球\&quot;,\&quot;棒球\&quot;]}&quot;;
  PlayerStar jordan = mapper.readValue(jsonInString, PlayerStar.class);

  System.out.println(jordan);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PlayerStar对象控制台输出结果如下(&lt;strong&gt;注意这里的输出不是JSON格式，而是java对象的toString()方法值&lt;/strong&gt;)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PlayerStar(name=乔丹, age=45, hobbies=[高尔夫球, 棒球], friends=[kobe, curry, james], salary={2000=10000000, 2010=62000000, 2020=112400000})
PlayerStar(name=乔丹, age=45, hobbies=[高尔夫球, 棒球], friends=null, salary=null)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、字段重命名-jsonproperty&quot;&gt;四、字段重命名 &lt;code&gt;@JsonProperty&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;可以使用 @JsonProperty来影响序列化和反序列化对象属性的重命名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
public class PlayerStar {

  @JsonProperty(&quot;playerName&quot;)
  private String name;  //将属性name序列化为playerName，同时影响反序列化
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用上面代码的注解之后，JSON序列化的结果name属性变成playerName属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;playerName&quot;:&quot;乔丹&quot;  ……
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时影响反序列化,下面的反序列化代码会报错，因为使用了name属性。应该使用playerName才可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String jsonInString = &quot;{\&quot;name\&quot;:\&quot;乔丹\&quot;,\&quot;age\&quot;:45,\&quot;hobbies\&quot;:[\&quot;高尔夫球\&quot;,\&quot;棒球\&quot;]}&quot;;
PlayerStar jordan = mapper.readValue(jsonInString, PlayerStar.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、忽略null字段的序列化jsoninclude&quot;&gt;五、忽略null字段的序列化&lt;code&gt;@JsonInclude&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;当我们不为对象的成员变量赋值的时候，默认情况下，Jackson的序列化结果是下面的这样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;age&quot; : 45,
  &quot;hobbies&quot; : null,
  &quot;friends&quot; : null,
  &quot;salary&quot; : null,
  &quot;playerName&quot; : &quot;乔丹&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们不希望将null值，体现在JSON序列化结果中，我们可以使用下面的方法。如果希望在某次序列化的全局范围内，忽略null成员变量，可以使用下面的API&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ObjectMapper mapper = new ObjectMapper();
mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者是在类名的上面加上如下注解。该注解将针对类里面的所有成员变量生效，只要成员变量为null，将不会被包含在序列化结果中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@JsonInclude(JsonInclude.Include.NON_NULL)
public class PlayerStar {
   ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们想针对PlayerStar类里面某些成员变量单独忽略null，可以在成员变量上面加注解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@JsonInclude(JsonInclude.Include.NON_NULL)
private String[] hobbies;    //业余爱好,数组
@JsonInclude(JsonInclude.Include.NON_NULL)
private List&amp;lt;String&amp;gt; friends;   //  朋友
@JsonInclude(JsonInclude.Include.NON_NULL)
private Map&amp;lt;String, BigDecimal&amp;gt; salary; //年收入 Map
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;忽略为null的成员变量后,JSON序列化结果是下面这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;age&quot; : 45,
  &quot;playerName&quot; : &quot;乔丹&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六、忽略指定的字段&quot;&gt;六、忽略指定的字段&lt;/h2&gt;
&lt;p&gt;默认情况下，jackson不会将static和transient的成员变量进行序列化与反序列化操作。我们还可以通过&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@JsonIgnore&lt;/code&gt;加在类成员变量上面，该成员变量将被排除在序列化和反序列化的过程之外&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonIgnoreProperties&lt;/code&gt;加在类声明上面，指定该类里面哪些字段被排除在序列化和反序列化的过程之外&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的两种注解选其一即可，下面的代码两种注解我都用了，功能是重复的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@JsonIgnoreProperties({&quot;hobbies&quot;, &quot;friends&quot;,&quot;salary&quot;})
public class PlayerStar {

  @JsonProperty(&quot;playerName&quot;)
  private String name;
  private Integer age;

  @JsonIgnore
  private String[] hobbies;    //业余爱好,数组
  @JsonIgnore
  private List&amp;lt;String&amp;gt; friends;   //  朋友
  @JsonIgnore
  private Map&amp;lt;String, BigDecimal&amp;gt; salary; //年收入 Map

......
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在类或成员变量上面加上注解之后，序列化结果如下，指定字段被忽略。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;age&quot; : 45,
  &quot;playerName&quot; : &quot;乔丹&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是这两个注解不只是影响序列化为JSON字符串的过程，也影响JSON字符串反序列化为java对象的过程。举例：如果JSON字符串包含了类中被JsonIgnore的属性值hobbies，不会被反序列化赋值给java对象的成员变量hobbies。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Sep 2020 23:58:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>Jackson是Spring Boot默认的JSON数据处理框架，但是其并不依赖于任何的Spring 库。有的小伙伴以为Jackson只能在Spring框架内使用，其实不是的，没有这种限制。它提供了很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13683167.html</dc:identifier>
</item>
<item>
<title>拓扑排序就这么回事 - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13683163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13683163.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;大家好，这里是《齐姐聊算法》系列之拓扑排序问题。&lt;/p&gt;
&lt;p&gt;Topological sort 又称 Topological order，这个名字有点迷惑性，因为拓扑排序并不是一个纯粹的排序算法，它只是针对&lt;strong&gt;某一类图&lt;/strong&gt;，找到一个可以执行的线性顺序。&lt;/p&gt;
&lt;p&gt;这个算法听起来高大上，如今的面试也很爱考，比如当时我在面我司时有整整一轮是基于拓扑排序的设计。&lt;/p&gt;
&lt;p&gt;但它其实是一个很好理解的算法，跟着我的思路，让你再也不会忘记她。&lt;/p&gt;
&lt;h2 id=&quot;有向无环图&quot;&gt;有向无环图&lt;/h2&gt;
&lt;p&gt;刚刚我们提到，拓扑排序只是针对特定的一类图，那么是针对哪类图的呢？&lt;/p&gt;
&lt;p&gt;答：Directed acyclic graph (DAG)，有向无环图。即：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个图的边必须是有方向的；&lt;/li&gt;
&lt;li&gt;图内无环。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么什么是方向呢？&lt;/p&gt;
&lt;p&gt;比如微信好友就是有向的，你加了他好友他可能把你删了你却不知道。。。那这个朋友关系就是单向的。。&lt;/p&gt;
&lt;p&gt;什么是环？环是和方向有关的，从一个点出发能回到自己，这是环。&lt;/p&gt;
&lt;p&gt;所以下图左边不是环，右边是。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075202768-37814335.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如果一个图里有环，比如右图，想执行 1 就要先执行 3，想执行 3 就要先执行 2，想执行 2 就要先执行 1，这成了个死循环，无法找到正确的打开方式，所以找不到它的一个拓扑序。&lt;/p&gt;
&lt;h3 id=&quot;总结：&quot;&gt;总结：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如果这个图不是 DAG，那么它是没有拓扑序的；&lt;/li&gt;
&lt;li&gt;如果是 DAG，那么它至少有一个拓扑序；&lt;/li&gt;
&lt;li&gt;反之，如果它存在一个拓扑序，那么这个图必定是 DGA.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;所以这是一个&lt;strong&gt;充分必要条件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075203336-662426373.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;拓扑排序&quot;&gt;拓扑排序&lt;/h2&gt;
&lt;p&gt;那么这么一个图的&lt;code&gt;「拓扑序」&lt;/code&gt;是什么意思呢？&lt;/p&gt;
&lt;p&gt;我们借用&lt;a href=&quot;https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&quot; title=&quot;百度百科-拓扑排序&quot;&gt;百度百科&lt;/a&gt;的这个课程表来说明。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;课程代号&lt;/th&gt;
&lt;th&gt;课程名称&lt;/th&gt;
&lt;th&gt;先修课程&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;C1&lt;/td&gt;
&lt;td&gt;高等数学&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C2&lt;/td&gt;
&lt;td&gt;程序设计基础&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C3&lt;/td&gt;
&lt;td&gt;离散数学&lt;/td&gt;
&lt;td&gt;C1, C2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C4&lt;/td&gt;
&lt;td&gt;数据结构&lt;/td&gt;
&lt;td&gt;C3, C5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C5&lt;/td&gt;
&lt;td&gt;算法语言&lt;/td&gt;
&lt;td&gt;C2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C6&lt;/td&gt;
&lt;td&gt;编译技术&lt;/td&gt;
&lt;td&gt;C4, C5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C7&lt;/td&gt;
&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;C4, C9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C8&lt;/td&gt;
&lt;td&gt;普通物理&lt;/td&gt;
&lt;td&gt;C1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C9&lt;/td&gt;
&lt;td&gt;计算机原理&lt;/td&gt;
&lt;td&gt;C8&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里有 9 门课程，有些课程是有先修课程的要求的，就是你要先学了「最右侧这一栏要求的这个课」才能再去选「高阶」的课程。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;那么这个例子中拓扑排序的意思就是：&lt;br/&gt;&lt;strong&gt;就是求解一种可行的顺序，能够让我把所有课都学了。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那怎么做呢？&lt;/p&gt;
&lt;p&gt;首先我们可以用&lt;code&gt;图&lt;/code&gt;来描述它，&lt;br/&gt;图的两个要素是&lt;code&gt;顶点和边&lt;/code&gt;，&lt;br/&gt;那么在这里：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;顶点：每门课&lt;/li&gt;
&lt;li&gt;边：起点的课程是终点的课程的先修课&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;画出来长这个样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075204074-692902574.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种图叫 &lt;strong&gt;AOV&lt;/strong&gt; (Activity On Vertex) 网络，在这种图里：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;顶点：表示活动；&lt;/li&gt;
&lt;li&gt;边：表示活动间的先后关系&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所以一个 AOV 网应该是一个 DAG，即有向无环图，否则某些活动会无法进行。&lt;br/&gt;&lt;span&gt;那么所有活动可以排成一个可行线性序列，这个序列就是&lt;code&gt;拓扑序列&lt;/code&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么这个序列的&lt;code&gt;实际意义&lt;/code&gt;是：&lt;br/&gt;&lt;strong&gt;按照这个顺序，在每个项目开始时，能够保证它的前驱活动都已完成，从而使整个工程顺利进行。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到我们这个例子中：&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;我们一眼可以看出来要先学 C1, C2，因为这两门课没有任何要求嘛，大一的时候就学呗；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;大二就可以学第二行的 C3, C5, C8 了，因为这三门课的先修课程就是 C1, C2，我们都学完了；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;大三可以学第三行的 C4, C9；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;最后一年选剩下的 C6, C7。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这样，我们就把所有课程学完了，也就得到了这个图的&lt;strong&gt;一个&lt;/strong&gt;&lt;code&gt;拓扑排序&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，有时候拓扑序并不是唯一的，比如在这个例子中，先学 C1 再学 C2，和先 C2 后 C1 都行，都是这个图的正确的拓扑序，但这是两个顺序了。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;所以面试的时候要问下面试官，是要求解任意解，还是列出所有解。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;我们总结一下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在这个图里的&lt;code&gt;边&lt;/code&gt;表示的是一种&lt;code&gt;依赖关系&lt;/code&gt;&lt;/strong&gt;，如果要修下一门课，就要先把前一门课修了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这和打游戏里一样一样的嘛，要拿到一个道具，就要先做 A 任务，再完成 B 任务，最终终于能到达目的地了。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法详解&quot;&gt;&lt;span&gt;算法详解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在上面的图里，大家很容易就看出来了它的拓扑序，但当工程越来越庞大时，依赖关系也会变得错综复杂，那就需要用一种系统性的方式方法来求解了。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;那么我们回想一下刚刚自己找拓扑序的过程，为什么我们先看上了 C1, C2?&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;因为它们没有依赖别人啊，&lt;br/&gt;也就是它的&lt;code&gt;入度为 0&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;入度&lt;/strong&gt;：顶点的入度是指「&lt;strong&gt;指向该顶点的边&lt;/strong&gt;」的数量；&lt;br/&gt;&lt;strong&gt;出度&lt;/strong&gt;：顶点的出度是指该顶点指向其他点的边的数量。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;所以我们先执行入度为 0 的那些点，&lt;br/&gt;那也就是要记录每个顶点的入度。&lt;br/&gt;因为&lt;strong&gt;只有当它的 &lt;code&gt;入度 = 0&lt;/code&gt; 的时候，我们才能执行它。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在刚才的例子里，最开始 C1, C2 的入度就是 0，所以我们可以先执行这两个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那在这个算法里第一步就是得到每个顶点的入度。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;step0-预处理得到每个点的入度&quot;&gt;&lt;span&gt;Step0: 预处理得到每个点的入度&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们可以用一个 HashMap 来存放这个信息，或者用一个&lt;code&gt;数组&lt;/code&gt;会更精巧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在文中为了方便展示，我就用表格了：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;C1&lt;/th&gt;
&lt;th&gt;C2&lt;/th&gt;
&lt;th&gt;C3&lt;/th&gt;
&lt;th&gt;C4&lt;/th&gt;
&lt;th&gt;C5&lt;/th&gt;
&lt;th&gt;C6&lt;/th&gt;
&lt;th&gt;C7&lt;/th&gt;
&lt;th&gt;C8&lt;/th&gt;
&lt;th&gt;C9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入度&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;step1&quot;&gt;&lt;span&gt;Step1&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;拿到了这个之后，就可以执行入度为 0 的这些点了，也就是 C1, C2.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那我们把可以被执行的这些点，放入一个&lt;code&gt;待执行的容器&lt;/code&gt;里，这样之后我们一个个的从这个容器里取顶点就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至于这个&lt;code&gt;容器&lt;/code&gt;究竟选哪种&lt;code&gt;数据结构&lt;/code&gt;，这取决于我们需要做哪些&lt;code&gt;操作&lt;/code&gt;，再看哪种数据结构可以为之服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么首先可以把&lt;code&gt;[C1, C2]&lt;/code&gt;放入&lt;code&gt;容器&lt;/code&gt;中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后想想我们需要哪些操作吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们最常做的操作无非就是&lt;code&gt;把点放进来&lt;/code&gt;，&lt;code&gt;把点拿出去&lt;/code&gt;执行了，也就是需要一个 &lt;code&gt;offer&lt;/code&gt; 和 &lt;code&gt;poll&lt;/code&gt; 操作比较高效的数据结构，那么 &lt;code&gt;queue&lt;/code&gt; 就够用了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（其他的也行，放进来这个容器里的顶点的地位都是一样的，都是可以执行的，和进来的顺序无关，但何必非得给自己找麻烦呢？一个常规顺序的简简单单的 queue 就够用了。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后就需要把某些点拿出去执行了。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;【划重点】当我们把 C1 拿出来执行，那这意味这什么？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;答：意味着「以 C1 为顶点」的「指向其他点」的「边」都消失了，也就是 C1 的出度变成了 0.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图，也就是这两条边可以消失了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075216167-1698446299.gif&quot; alt=&quot;step1&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么此时我们就可以更新 &lt;code&gt;C1 所指向的那些点&lt;/code&gt;也就是 &lt;code&gt;C3 和 C8&lt;/code&gt; 的 &lt;code&gt;入度&lt;/code&gt; 了，更新后的数组如下：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;C3&lt;/th&gt;
&lt;th&gt;C4&lt;/th&gt;
&lt;th&gt;C5&lt;/th&gt;
&lt;th&gt;C6&lt;/th&gt;
&lt;th&gt;C7&lt;/th&gt;
&lt;th&gt;C8&lt;/th&gt;
&lt;th&gt;C9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入度&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;那我们这里看到很关键的一步，C8 的入度变成了 0！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;也就意味着 C8 此时没有了任何依赖，可以放到我们的 queue 里等待执行了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时我们的 &lt;code&gt;queue&lt;/code&gt; 里就是：&lt;code&gt;[C2, C8]&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;step2&quot;&gt;&lt;span&gt;Step2&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;下一个我们再执行 C2，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075222451-376238312.gif&quot; alt=&quot;Step2&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么 &lt;code&gt;C2 所指向的&lt;/code&gt; &lt;code&gt;C3, C5&lt;/code&gt; 的 &lt;code&gt;入度-1&lt;/code&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更新表格：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;C3&lt;/th&gt;
&lt;th&gt;C4&lt;/th&gt;
&lt;th&gt;C5&lt;/th&gt;
&lt;th&gt;C6&lt;/th&gt;
&lt;th&gt;C7&lt;/th&gt;
&lt;th&gt;C9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;也就是 C3 和 C5 都没有了任何束缚，可以放进 queue 里执行了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;queue&lt;/code&gt; 此时变成：&lt;code&gt;[C8, C3, C5]&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;step3&quot;&gt;&lt;span&gt;Step3&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;那么下一步我们执行 C8，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075233679-399588267.gif&quot; alt=&quot;Step3&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相应的 C8 所指的 C9 的入度-1.&lt;br/&gt;更新表格：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;C4&lt;/th&gt;
&lt;th&gt;C6&lt;/th&gt;
&lt;th&gt;C7&lt;/th&gt;
&lt;th&gt;C9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入度&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;那么 C9 没有了任何要求，可以放进 queue 里执行了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;queue&lt;/code&gt; 此时变成：&lt;code&gt;[C3, C5, C9]&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;step4&quot;&gt;&lt;span&gt;Step4&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;接下来执行 C3，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075242624-934768042.gif&quot; alt=&quot;Step4&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相应的 C3 所指的 C4 的入度-1.&lt;br/&gt;更新表格：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;C4&lt;/th&gt;
&lt;th&gt;C6&lt;/th&gt;
&lt;th&gt;C7&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;但是 C4 的入度并没有变成 0，所以这一步没有任何点可以加入 queue.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;queue&lt;/code&gt; 此时变成 &lt;code&gt;[C5, C9]&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;step5&quot;&gt;&lt;span&gt;Step5&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;再执行 C5，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075249659-1197067434.gif&quot; alt=&quot;Step5&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么 C5 所指的 C4 和 C6 的入度- 1.&lt;br/&gt;更新表格：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;C4&lt;/th&gt;
&lt;th&gt;C6&lt;/th&gt;
&lt;th&gt;C7&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;这里 C4 的依赖全都消失啦，那么可以把 C4 放进 queue 里了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;queue&lt;/code&gt; = &lt;code&gt;[C9, C4]&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;step6&quot;&gt;&lt;span&gt;Step6&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;然后执行 C9，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075252240-479947825.gif&quot; alt=&quot;Step6&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么 C9 所指的 C7 的入度- 1.&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;C6&lt;/th&gt;
&lt;th&gt;C7&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;这里 C7 的入度并不为 0，还不能加入 queue，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时 &lt;code&gt;queue&lt;/code&gt; = &lt;code&gt;[C4]&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;step7&quot;&gt;&lt;span&gt;Step7&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;接着执行 C4，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075256032-705533189.gif&quot; alt=&quot;Step7&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以 C4 所指向的 C6 和 C7 的入度-1，&lt;br/&gt;更新表格：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;C6&lt;/th&gt;
&lt;th&gt;C7&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;C6 和 C7 的入度都变成 0 啦！！把它们放入 queue，继续执行到直到 queue 为空即可。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;好了，那我们梳理一下这个算法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据结构&lt;/span&gt;&lt;br/&gt;这里我们的入度表格可以用 map 来存放，关于 map 还有不清楚的同学可以看之前我写的 HashMap 的文章哦～&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Map: &amp;lt;key = Vertex, value = 入度&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;但实际代码中，我们用一个 &lt;strong&gt;int array&lt;/strong&gt; 来存储也就够了，graph node 可以用数组的 index 来表示，value 就用数组里的数值来表示，这样比 Map 更精巧。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;然后用了一个普通的 queue，用来存放可以被执行的那些 node.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;过程&lt;/span&gt;&lt;br/&gt;我们把入度为 0 的那些顶点放入 queue 中，然后通过每次执行 queue 中的顶点，就可以让依赖这个被执行的顶点的那些点的 &lt;code&gt;入度-1&lt;/code&gt;，如果有顶点的入度变成了 0，就可以放入 queue 了，直到 queue 为空。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;细节&lt;/span&gt;&lt;br/&gt;这里有几点实现上的细节：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们 check 是否有新的顶点的 入度 == 0 时，没必要过一遍整个 map 或者数组，只需要 check 刚刚改动过的就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一个是如果题目没有给这个图是 DAG 的条件的话，那么有可能是不存在可行解的，那怎么判断呢？很简单的一个方法就是比较一下最后结果中的顶点的个数和图中所有顶点的个数是否相等，或者加个计数器，如果不相等，说明就不存在有效解。所以这个算法也可以用来&lt;strong&gt;判断一个图是不是有向无环图&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多题目给的条件可能是给这个图的 &lt;code&gt;edge list&lt;/code&gt;，也是表示图的一种常用的方式。那么给的这个 &lt;code&gt;list&lt;/code&gt; 就是表示图中的&lt;code&gt;边&lt;/code&gt;。这里要注意审题哦，看清楚是谁 depends on 谁。其实图的题一般都不会直接给你这个图，而是给一个场景，需要你把它变回一个图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;时间复杂度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意 ⚠️：对于图的时间复杂度分析一定是两个参数，面试的时候很多同学张口就是 O(n)...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于有 v 个顶点和 e 条边的图来说，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步，预处理得到 map 或者 array，需要过一遍所有的边才行，所以是 O(e)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步，把 入度 == 0 的点入队出队的操作是 O(v)，如果是一个 DAG，那所有的点都需要入队出队一次；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步，每次执行一个顶点的时候，要把它指向的那条边消除了，这个总共执行 e 次；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总：O(v + e)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;空间复杂度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用了一个数组来存所有点的 indegree，之后的 queue 也是最多把所有的点放进去，所以是 O(v).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于这课程排序的问题，Leetcode 上有两道题，一道是 207，问你能否完成所有课程，也就是问拓扑排序是否存在；另一道是 210 题，是让你返回任意一个拓扑顺序，如果不能完成，那就返回一个空 array。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们以 210 这道题来写，更完整也更常考一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075256896-1040660685.jpg&quot; alt=&quot;Leetcode210&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里给的 input 就是我们刚刚说到的 &lt;code&gt;edge list&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Example 1.&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;Input: 2, [[1,0]]&lt;br/&gt;Output: [0,1]&lt;br/&gt;Explanation: 这里一共 2 门课，1 的先修课程是 0. 所以正确的选课顺序是[0, 1].&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;Example 2.&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;Input: 4, [[1,0],[2,0],[3,1],[3,2]]&lt;br/&gt;Output: [0,1,2,3] or [0,2,1,3]&lt;br/&gt;Explanation:这里这个例子画出来如下图&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202009/2000306-20200917075257323-1931499958.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Example 3.&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;Input: 2, [[1,0],[0,1]]&lt;br/&gt;Output: null&lt;br/&gt;Explanation: 这课没法上了&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] res = new int[numCourses];
        int[] indegree = new int[numCourses];

        // get the indegree for each course
        for(int[] pre : prerequisites) {
            indegree[pre[0]] ++;
        }

        // put courses with indegree == 0 to queue
        Queue&amp;lt;Integer&amp;gt; queue = new ArrayDeque&amp;lt;&amp;gt;();
        for(int i = 0; i &amp;lt; numCourses; i++) {
            if(indegree[i] == 0) {
                queue.offer(i);
            }
        }

        // execute the course
        int i = 0;
        while(!queue.isEmpty()) {
            Integer curr = queue.poll();
            res[i++] = curr;

            // remove the pre = curr
            for(int[] pre : prerequisites) {
                if(pre[1] == curr) {
                    indegree[pre[0]] --;
                    if(indegree[pre[0]] == 0) {
                        queue.offer(pre[0]);
                    }
                }
            }
        }

        return i == numCourses ? res : new int[]{};
    }
}

&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;另外，拓扑排序还可以用 &lt;code&gt;DFS - 深度优先搜索&lt;/code&gt; 来实现，限于篇幅就不在这里展开了，大家可以参考&lt;a href=&quot;https://www.geeksforgeeks.org/topological-sorting/&quot; title=&quot;GeeksforGeeks 拓扑排序DFS解法&quot;&gt;GeeksforGeeks&lt;/a&gt;的这个资料。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;实际应用&quot;&gt;&lt;span&gt;实际应用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们上文已经提到了它的一个 use case，就是选课系统，这也是最常考的题目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而拓扑排序最重要的应用就是&lt;code&gt;关键路径问题&lt;/code&gt;，这个问题对应的是 AOE (Activity on Edge) 网络。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;AOE 网络&lt;/strong&gt;：顶点表示事件，边表示活动，边上的权重来表示活动所需要的时间。&lt;br/&gt;&lt;strong&gt;AOV 网络&lt;/strong&gt;：顶点表示活动，边表示活动之间的依赖关系。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;在 AOE 网中，从起点到终点具有最大长度的路径称为关键路径，在关键路径上的活动称为关键活动。AOE 网络一般用来分析一个大项目的工序，分析至少需要花多少时间完成，以及每个活动能有多少机动时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体是怎么应用分析的，大家可以参考这个&lt;a href=&quot;https://www.youtube.com/watch?v=x3mm5a_CwRM&amp;amp;t=144s&quot; title=&quot;关键路径问题推荐视频讲解&quot;&gt;视频&lt;/a&gt; 的 14 分 46 秒，这个例子还是讲的很好的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实对于任何一个任务之间有依赖关系的图，都是适用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如 pom 依赖引入 jar 包时，大家有没有想过它是怎么导进来一些你并没有直接引入的 jar 包的？比如你并没有引入 aop 的 jar 包，但它自动出现了，这就是因为你导入的一些包是依赖于 aop 这个 jar 包的，那么 maven 就自动帮你导入了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他的实际应用，比如说：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;语音识别系统的预处理；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;管理目标文件之间的依赖关系，就像我刚刚说的 jar 包导入；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;深度学习中的网络结构处理。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如有其他补充，欢迎大家在评论区不吝赐教。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上就是本文的全部内容了，拓扑排序是非常重要也是非常爱考的一类算法，面试大厂前一定要熟练掌握。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你喜欢这篇文章，记得给我点赞留言哦～你们的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 9 点，云自习室里不见不散！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更多干货文章见我的 Github: &lt;a href=&quot;https://github.com/xiaoqi6666/NYCSDE&quot;&gt;https://github.com/xiaoqi6666/NYCSDE&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Sep 2020 23:53:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>前言 大家好，这里是《齐姐聊算法》系列之拓扑排序问题。 Topological sort 又称 Topological order，这个名字有点迷惑性，因为拓扑排序并不是一个纯粹的排序算法，它只是针对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13683163.html</dc:identifier>
</item>
<item>
<title>全局监听路由堆栈变化 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13683126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13683126.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200917071602199-1987970170.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;老孟导读&lt;/strong&gt;：很多时候我们需要监听路由堆栈的变化，这样可以自定义路由堆栈、方便分析异常日志等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;监听路由堆栈的变化使用 &lt;strong&gt;RouteObserver&lt;/strong&gt; ，首先在 &lt;strong&gt;MaterialApp&lt;/strong&gt; 组件中添加 &lt;code&gt;navigatorObservers&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;void main() {
  runApp(MyApp());
}

RouteObserver&amp;lt;PageRoute&amp;gt; routeObserver = RouteObserver&amp;lt;PageRoute&amp;gt;();

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      ...
      navigatorObservers: [routeObserver],
      home: HomePage(),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监听页面设置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class ARouteObserverDemo extends StatefulWidget {
  @override
  _RouteObserverDemoState createState() =&amp;gt; _RouteObserverDemoState();
}

class _RouteObserverDemoState extends State&amp;lt;ARouteObserverDemo&amp;gt; with RouteAware {

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    routeObserver.subscribe(this, ModalRoute.of(context));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        alignment: Alignment.center,
        child: RaisedButton(
          child: Text('A RouteObserver'),
          onPressed: () {
            Navigator.of(context).pushNamed('/BRouteObserver');
          },
        ),
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
    routeObserver.unsubscribe(this);
  }

  @override
  void didPush() {
    final route = ModalRoute.of(context).settings.name;
    print('A-didPush route: $route');
  }

  @override
  void didPopNext() {
    final route = ModalRoute.of(context).settings.name;
    print('A-didPopNext route: $route');
  }

  @override
  void didPushNext() {
    final route = ModalRoute.of(context).settings.name;
    print('A-didPushNext route: $route');
  }

  @override
  void didPop() {
    final route = ModalRoute.of(context).settings.name;
    print('A-didPop route: $route');
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 didPush、didPushNext、didPopNext、didPop 为路由堆栈变化的回调。&lt;/p&gt;
&lt;p&gt;从 A 页面跳转到 ARouteObserverDemo 页面，日志输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;flutter: A-didPush route: /ARouteObserver
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入此页面只调用了 didPush。&lt;/p&gt;
&lt;p&gt;从 ARouteObserverDemo 页面跳转到 BRouteObserverDemo 页面（同 ARouteObserverDemo 页面，设置了监听），日志输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;flutter: A-didPushNext route: /ARouteObserver
flutter: B-didPush route: /BRouteObserver
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先调用了 ARouteObserverDemo 页面的 didPushNext，然后调用了 BRouteObserverDemo 页面的 didPush。&lt;/p&gt;
&lt;p&gt;从 BRouteObserverDemo 页面执行 pop 返回 ARouteObserverDemo 页面，日志输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;flutter: A-didPopNext route: /ARouteObserver
flutter: B-didPop route: /BRouteObserver
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先调用了 ARouteObserverDemo 页面的 didPopNext，然后调用了 BRouteObserverDemo 页面的 didPop。&lt;/p&gt;
&lt;p&gt;上面的案例仅仅是页面级别的路由堆栈变化，如果想知道整个应用程序路由堆栈变化如何处理？&lt;/p&gt;
&lt;p&gt;一种方法是写一个监听路由堆栈的基类，所有页面继承此基类。此方法对源代码的侵入性非常高。&lt;/p&gt;
&lt;p&gt;还有一种方法是自定义 RouteObserver，继承RouteObserver并重写其中的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MyRouteObserver&amp;lt;R extends Route&amp;lt;dynamic&amp;gt;&amp;gt; extends RouteObserver&amp;lt;R&amp;gt; {
  @override
  void didPush(Route route, Route previousRoute) {
    super.didPush(route, previousRoute);
    print('didPush route: $route,previousRoute:$previousRoute');
  }

  @override
  void didPop(Route route, Route previousRoute) {
    super.didPop(route, previousRoute);
    print('didPop route: $route,previousRoute:$previousRoute');
  }

  @override
  void didReplace({Route newRoute, Route oldRoute}) {
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
    print('didReplace newRoute: $newRoute,oldRoute:$oldRoute');
  }

  @override
  void didRemove(Route route, Route previousRoute) {
    super.didRemove(route, previousRoute);
    print('didRemove route: $route,previousRoute:$previousRoute');
  }

  @override
  void didStartUserGesture(Route route, Route previousRoute) {
    super.didStartUserGesture(route, previousRoute);
    print('didStartUserGesture route: $route,previousRoute:$previousRoute');
  }

  @override
  void didStopUserGesture() {
    super.didStopUserGesture();
    print('didStopUserGesture');
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;void main() {
  runApp(MyApp());
}

MyRouteObserver&amp;lt;PageRoute&amp;gt; myRouteObserver = MyRouteObserver&amp;lt;PageRoute&amp;gt;();

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      navigatorObservers: [myRouteObserver],
      initialRoute: '/A',
      home: APage(),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时从 A 页面 跳转到 B 页面，日志输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;flutter: didPush route: MaterialPageRoute&amp;lt;dynamic&amp;gt;(RouteSettings(&quot;/B&quot;, 来自A), animation: AnimationController#6d429(▶ 0.000; for MaterialPageRoute&amp;lt;dynamic&amp;gt;(/B))),previousRoute:MaterialPageRoute&amp;lt;dynamic&amp;gt;(RouteSettings(&quot;/A&quot;, null), animation: AnimationController#e60f7(⏭ 1.000; paused; for MaterialPageRoute&amp;lt;dynamic&amp;gt;(/A)))

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;h2 id=&quot;交流-2&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客（330个控件用法+实战入门系列文章）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200917071602599-426684361.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200917071602858-134300423.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 16 Sep 2020 23:16:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：很多时候我们需要监听路由堆栈的变化，这样可以自定义路由堆栈、方便分析异常日志等。 监听路由堆栈的变化使用 RouteObserver ，首先在 MaterialApp 组件中添加 navig</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13683126.html</dc:identifier>
</item>
<item>
<title>Java 审计之SSRF篇 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/13682434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/13682434.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;本篇文章来记录一下Java SSRF的审计学习相关内容。&lt;/p&gt;
&lt;h2 id=&quot;0x01-ssrf漏洞详解&quot;&gt;0x01 SSRF漏洞详解&lt;/h2&gt;
&lt;h3 id=&quot;原理：&quot;&gt;原理：&lt;/h3&gt;
&lt;p&gt;服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。&lt;/p&gt;
&lt;p&gt;大部分的web服务器架构中，web服务器自身都可以访问互联网和服务器所在的内网。&lt;/p&gt;
&lt;h3 id=&quot;ssrf作用：&quot;&gt;ssrf作用：&lt;/h3&gt;
&lt;p&gt;对外网服务器所在的内网、本地进行端口扫描，获取一些服务的banner信息 。&lt;/p&gt;
&lt;p&gt;攻击运行在内网或者本地的应用程序。&lt;/p&gt;
&lt;p&gt;对内网web应用进行指纹识别，通过访问默认文件实现 。&lt;/p&gt;
&lt;p&gt;攻击内外网的web应用。sql注入、struct2、redis等。&lt;/p&gt;
&lt;p&gt;利用file协议读取本地文件等。&lt;/p&gt;
&lt;p&gt;php ssrf中的伪协议：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;file dict sftp ldap tftp gopher
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java ssrf 中的伪协议：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;file ftp mailto http https jar netdoc
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x02-ssrf产生过程&quot;&gt;0x02 SSRF产生过程&lt;/h2&gt;
&lt;p&gt;在java中ssrf会分比较多的场景，不像PHP中那样支持各种伪协议都可以去直接使用。&lt;/p&gt;
&lt;h3 id=&quot;ssrf中内网探测&quot;&gt;SSRF中内网探测&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/ssrfServlet&quot;)
public class ssrfServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String url = request.getParameter(&quot;url&quot;);   //接收url的传参
        String htmlContent;
        PrintWriter writer = response.getWriter();  //获取响应的打印流对象
        URL u = new URL(url);   //实例化url的对象
        try {
            URLConnection urlConnection = u.openConnection();//打开一个URL连接，并运行客户端访问资源。
            HttpURLConnection httpUrl = (HttpURLConnection) urlConnection;  //强转为HttpURLConnection
            BufferedReader base = new BufferedReader(new InputStreamReader(httpUrl.getInputStream(), &quot;UTF-8&quot;));  //获取url中的资源
            StringBuffer html = new StringBuffer();
            while ((htmlContent = base.readLine()) != null) {
                html.append(htmlContent);  //htmlContent添加到html里面
            }
            base.close();

            writer.println(html);//响应中输出读取的资源
            writer.flush();

        } catch (Exception e) {
            e.printStackTrace();
            writer.println(&quot;请求失败&quot;);
            writer.flush();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码中&lt;code&gt;HttpURLConnection httpUrl = (HttpURLConnection) urlConnection;&lt;/code&gt;，这个地方进行了强制转换，去某度搜索了一下具体用意。得出结论：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;URLConnection:可以走邮件、文件传输协议。
HttpURLConnection 只能走浏览器的HTTP协议
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说使用了强转为HttpURLConnection后，利用中只能使用http协议去探测该服务器内网的其他应用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/ssrfServlet?url=http://www.baidu.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917022022738-1675749797.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里用来百度来做一个演示，因为懒得自己再在内网中搭建一个环境了。&lt;/p&gt;
&lt;p&gt;在代码中，我们未对接收过来的url进行校验，校验其url是否是白名单的url就直接进行了创建url对象进行访问和读取资源，导致了ssrf的产生。&lt;/p&gt;
&lt;p&gt;尝试一下能不能读取文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917022038841-384278697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里会发现根本读取不了，因为这里只支持http和https的协议。&lt;/p&gt;
&lt;p&gt;下面来试试，在不强制转换成HttpURLConnection的情况下试试。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/ssrfServlet&quot;)
public class ssrfServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String url = request.getParameter(&quot;url&quot;);   //接收url的传参
        String htmlContent;
        PrintWriter writer = response.getWriter();  //获取响应的打印流对象
        URL u = new URL(url);   //实例化url的对象
        try {
            URLConnection urlConnection = u.openConnection();//打开一个URL连接，并运行客户端访问资源。
//            HttpURLConnection httpUrl = (HttpURLConnection) urlConnection;  //强转为HttpURLConnection
            BufferedReader base = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), &quot;UTF-8&quot;));  //获取url中的资源
            StringBuffer html = new StringBuffer();
            while ((htmlContent = base.readLine()) != null) {
                html.append(htmlContent);  //htmlContent添加到html里面
            }
            base.close();

            writer.println(html);//响应中输出读取的资源
            writer.flush();

        } catch (Exception e) {
            e.printStackTrace();
            writer.println(&quot;请求失败&quot;);
            writer.flush();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/ssrfServlet?url=file:///c:%5c%5cwindows%5c%5cwin.ini
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917022058593-1018630145.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以成功读取到c:\windows\win.ini的文件。&lt;/p&gt;
&lt;h3 id=&quot;ssrf中的读取文件&quot;&gt;SSRF中的读取文件&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/readfileServlet&quot;)
public class downloadServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {


        String url = request.getParameter(&quot;url&quot;);
        int len;
        OutputStream outputStream = response.getOutputStream();
            URL file = new URL(url);
            byte[] bytes = new byte[1024];
        InputStream inputStream = file.openStream();

            while ((len = inputStream.read(bytes)) &amp;gt; 0) {
                outputStream.write(bytes, 0, len);
            }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和上面的代码对比一下，发现其实都大致相同，唯一不同的地方是一个是用openStream方法获取对象，一个是用openConnection获取对象。两个方法类似。&lt;/p&gt;
&lt;p&gt;官方说明文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openConnection():返回一个实例，该实例表示与所引用的远程对象的连接。 返回类型： URLConnection
openStream():打开与此连接，并返回一个值以从该连接读取。                        返回类型：  InputStream 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openConnection:返回一个URLConnection对象，它表示到URL所引用的远程对象的连接。每次调用此URL的协议处理程序的openConnection方法都打开一个新的连接。如果URL的协议（例如，HTTP或JAR）存在属于以下包或其子包之一的公共、专用URLConnection子类：java.lang、java.io、java.util、java.net，返回的连接将为该子类的类型。例如，对于HTTP，将返回HttpURLConnection，对于JAR，将返回JarURLConnection。（返回到该URL的URLConnection！）

openStream():打开到此URL的连接并返回一个用于从该连接读入的InputStream。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里启动一下服务器，测试一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://127.0.0.1:8080//downloadServlet?url=file:///C:%5c%5c1.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这里是三个斜杆，并且反斜杠需要url编码 否则就会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917022113118-270391652.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;未经过url编码直接传入反斜杠&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917022124383-447765495.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ssrf中的文件下载&quot;&gt;SSRF中的文件下载&lt;/h3&gt;
&lt;p&gt;漏洞代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/downloadServlet&quot;)
public class downloadServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String filename = &quot;1.txt&quot;;

        String url = request.getParameter(&quot;url&quot;);
        response.setHeader(&quot;content-disposition&quot;, &quot;attachment;fileName=&quot; + filename);
        int len;
        OutputStream outputStream = response.getOutputStream();
            URL file = new URL(url);
            byte[] bytes = new byte[1024];
        InputStream inputStream = file.openStream();

            while ((len = inputStream.read(bytes)) &amp;gt; 0) {
                outputStream.write(bytes, 0, len);
            }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/downloadServlet?url=file:///c:%5c%5c1.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917022134259-1949746164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就把文件给下载下来了，ssrf中的文件下载和文件读取不同点在于响应头。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; response.setHeader(&quot;content-disposition&quot;, &quot;attachment;fileName=&quot; + filename);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码，设置mime类型为文件类型，访问浏览器的时候就会被下载下来。&lt;/p&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;https://xz.aliyun.com/t/2761#toc-1
https://xz.aliyun.com/t/206/
https://xz.aliyun.com/t/7186
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x03-结尾&quot;&gt;0x03 结尾&lt;/h2&gt;
&lt;p&gt;SSRF的一些产生也不止文章里面写到的这么一点，包括一些第三方的组件，如果在未经过验证的情况下发起一个远程请求，那么都有可能存在SSRF漏洞。&lt;/p&gt;
&lt;p&gt;后面打算找套源码专门审计一下SSRF。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Sep 2020 18:22:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java 审计之SSRF篇 0x00 前言 本篇文章来记录一下Java SSRF的审计学习相关内容。 0x01 SSRF漏洞详解 原理： 服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/13682434.html</dc:identifier>
</item>
<item>
<title>Kubernetes K8S之Service服务详解与示例 - 踏歌行666</title>
<link>http://www.cnblogs.com/zhanglianghhh/p/13682265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglianghhh/p/13682265.html</guid>
<description>&lt;p&gt;K8S之Service概述与代理说明，并详解所有的service服务类型与示例&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;294.00615348891&quot;&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;K8S之Service概述与代理说明，并详解所有的service服务类型与示例&lt;/p&gt;
&lt;/blockquote&gt;


&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务器名称(hostname)&lt;/th&gt;
&lt;th&gt;系统版本&lt;/th&gt;
&lt;th&gt;配置&lt;/th&gt;
&lt;th&gt;内网IP&lt;/th&gt;
&lt;th&gt;外网IP(模拟)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;k8s-master&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.110&lt;/td&gt;
&lt;td&gt;10.0.0.110&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;k8s-node01&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.111&lt;/td&gt;
&lt;td&gt;10.0.0.111&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;k8s-node02&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.112&lt;/td&gt;
&lt;td&gt;10.0.0.112&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;span&gt;Kubernetes Service定义了这样一种抽象：逻辑上的一组 Pod，一种可以访问它们的策略 —— 通常被称为微服务&lt;/span&gt;。这一组 Pod 能够被 Service 访问到，&lt;span&gt;通常是通过 selector实现&lt;/span&gt;的。&lt;/p&gt;
&lt;p&gt;举例：考虑一个图片处理 backend，它运行了3个副本。这些副本是可互换的 —— frontend 不需要关心它们调用了哪个 backend 副本。 然而组成这一组 backend 程序的 Pod 实际上可能会发生变化，frontend 客户端不应该也没必要知道，而且也不需要跟踪这一组 backend 的状态。Service 定义的抽象能够解耦这种关联。&lt;/p&gt;
&lt;p&gt;Service可以提供负载均衡的能力，但是使用上存在如下限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只能提供4层负载均衡能力，而没有7层功能。有时我们可能需要更多的匹配规则来转发请求，这点上4层负载均衡是不支持的、&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如web访问的service服务示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202009/1395193-20200917000523053-1405748770.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在 Kubernetes 集群中，每个 Node 运行一个 kube-proxy 进程。kube-proxy 负责为 Service 实现了一种 VIP（虚拟 IP）的形式，而不是 ExternalName 的形式。&lt;/p&gt;
&lt;p&gt;从Kubernetes v1.0开始，已经可以使用 userspace代理模式。Kubernetes v1.1添加了 iptables 代理模式，在 Kubernetes v1.2 中kube-proxy 的 iptables 模式成为默认设置。Kubernetes v1.8添加了 ipvs 代理模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不使用 DNS 轮询？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原因如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DNS 实现的历史由来已久，它不遵守记录 TTL，并且在名称查找到结果后会对其进行缓存。&lt;/li&gt;
&lt;li&gt;有些应用程序仅执行一次 DNS 查找，并无限期地缓存结果。&lt;/li&gt;
&lt;li&gt;即使应用和库进行了适当的重新解析，DNS 记录上的 TTL 值低或为零也可能会给 DNS 带来高负载，从而使管理变得困难。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;总之就是因为有缓存，因此不合适。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;userspace代理模式&quot;&gt;userspace代理模式&lt;/h2&gt;
&lt;p&gt;这种模式，kube-proxy 会监视 Kubernetes master 对 Service 对象和 Endpoints 对象的添加和移除。 对每个 Service，它会在本地 Node 上打开一个端口（随机选择）。 任何连接到“代理端口”的请求，都会被代理到 Service 的backend Pods 中的某个上面（如 Endpoints 所报告的一样）。 使用哪个 backend Pod，是 kube-proxy 基于 SessionAffinity 来确定的。&lt;/p&gt;
&lt;p&gt;最后，它配置 iptables 规则，捕获到达该 Service 的 clusterIP（是虚拟 IP）和 Port 的请求，并重定向到代理端口，代理端口再代理请求到 backend Pod。&lt;/p&gt;
&lt;p&gt;默认情况下，userspace模式下的kube-proxy通过循环算法选择后端。&lt;/p&gt;
&lt;p&gt;默认的策略是，通过 round-robin 算法来选择 backend Pod。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202009/1395193-20200917000552912-742898966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;iptables-代理模式&quot;&gt;iptables 代理模式&lt;/h2&gt;
&lt;p&gt;这种模式，kube-proxy 会监视 Kubernetes 控制节点对 Service 对象和 Endpoints 对象的添加和移除。 对每个 Service，它会配置 iptables 规则，从而捕获到达该 Service 的 clusterIP 和端口的请求，进而将请求重定向到 Service 的一组 backend 中的某个上面。对于每个 Endpoints 对象，它也会配置 iptables 规则，这个规则会选择一个 backend 组合。&lt;/p&gt;
&lt;p&gt;默认的策略是，kube-proxy 在 iptables 模式下随机选择一个 backend。&lt;/p&gt;
&lt;p&gt;使用 iptables 处理流量具有较低的系统开销，因为流量由 Linux netfilter 处理，而无需在用户空间和内核空间之间切换。 这种方法也可能更可靠。&lt;/p&gt;
&lt;p&gt;如果 kube-proxy 在 iptables模式下运行，并且所选的第一个 Pod 没有响应，则连接失败。 这与userspace模式不同：在这种情况下，kube-proxy 将检测到与第一个 Pod 的连接已失败，并会自动使用其他后端 Pod 重试。&lt;/p&gt;
&lt;p&gt;我们可以使用 Pod readiness 探测器 验证后端 Pod 是否可以正常工作，以便 iptables 模式下的 kube-proxy 仅看到测试正常的后端。这样做意味着可以避免将流量通过 kube-proxy 发送到已知已失败的Pod。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202009/1395193-20200917000609683-1386303374.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;IPVS-代理模式&quot;&gt;IPVS 代理模式&lt;/h2&gt;
&lt;p&gt;在 ipvs 模式下，kube-proxy监视Kubernetes服务(Service)和端点(Endpoints)，调用 netlink 接口相应地创建 IPVS 规则， 并定期将 IPVS 规则与 Kubernetes服务(Service)和端点(Endpoints)同步。该控制循环可确保 IPVS 状态与所需状态匹配。访问服务(Service)时，IPVS　将流量定向到后端Pod之一。&lt;/p&gt;
&lt;p&gt;IPVS代理模式基于类似于 iptables 模式的 netfilter 挂钩函数，但是使用哈希表作为基础数据结构，并且在内核空间中工作。 这意味着，与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。&lt;span&gt;与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;IPVS提供了更多选项来平衡后端Pod的流量。这些是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;rr: round-robin&lt;/li&gt;
&lt;li&gt;lc: least connection (smallest number of open connections)&lt;/li&gt;
&lt;li&gt;dh: destination hashing&lt;/li&gt;
&lt;li&gt;sh: source hashing&lt;/li&gt;
&lt;li&gt;sed: shortest expected delay&lt;/li&gt;
&lt;li&gt;nq: never queue&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意：要在 IPVS 模式下运行 kube-proxy，必须在启动 kube-proxy 之前使 IPVS Linux 在节点上可用。 当 kube-proxy 以 IPVS 代理模式启动时，它将验证 IPVS 内核模块是否可用。 如果未检测到 IPVS 内核模块，则 kube-proxy 将退回到以 iptables 代理模式运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202009/1395193-20200917000627912-624638194.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;Kubernetes 中Service有以下4中类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ClusterIP：&lt;span&gt;默认类型&lt;/span&gt;，自动分配一个仅Cluster内部可以访问的虚拟IP&lt;/li&gt;
&lt;li&gt;NodePort：通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。以ClusterIP为基础，NodePort 服务会路由到 ClusterIP 服务。通过请求 &lt;code&gt;&amp;lt;NodeIP&amp;gt;:&amp;lt;NodePort&amp;gt;&lt;/code&gt;，可以从集群的外部访问一个集群内部的 NodePort 服务。&lt;/li&gt;
&lt;li&gt;LoadBalancer：使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务。&lt;/li&gt;
&lt;li&gt;ExternalName：通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容（例如，foo.bar.example.com）。没有任何类型代理被创建。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;需要注意的是：Service 能够将一个接收 port 映射到任意的 targetPort。默认情况下，targetPort 将被设置为与 port 字段相同的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Service域名格式：&lt;code&gt;$(service name).$(namespace).svc.cluster.local&lt;/code&gt;，其中 cluster.local 为指定的集群的域名&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;Deployment的yaml信息&quot;&gt;Deployment的yaml信息&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;service
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;cat&lt;/span&gt; myapp-&lt;span&gt;deploy.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; apiVersion: apps/&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Deployment
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: myapp-&lt;span&gt;deploy
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   replicas: &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  selector:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    matchLabels:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      app: myapp
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;      release: v1
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  template:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    metadata:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      labels:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        app: myapp
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        release: v1
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;env&lt;/span&gt;&lt;span&gt;: test
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    spec:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      containers:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       -&lt;span&gt; name: myapp
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         image: registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        imagePullPolicy: IfNotPresent
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        ports:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         -&lt;span&gt; name: http
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;           containerPort: &lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动Deployment并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# kubectl apply -f myapp-&lt;span&gt;deploy.yaml 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; deployment.apps/myapp-&lt;span&gt;deploy created
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master service]# kubectl get deploy -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; NAME           READY   UP-TO-&lt;span&gt;DATE   AVAILABLE   AGE   CONTAINERS   IMAGES                                                      SELECTOR
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; myapp-deploy   &lt;span&gt;3&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt;            &lt;span&gt;3&lt;/span&gt;           31h   myapp        registry.cn-beijing.aliyuncs.com/google_registry/myapp:v1   app=myapp,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@k8s-master service]# kubectl get rs -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;NAME                      DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES                                                      SELECTOR
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; myapp-deploy-5695bb5658   &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;3&lt;/span&gt;       31h   myapp        registry.cn-beijing.aliyuncs.com/google_registry/myapp:v1   app=myapp,pod-template-hash=5695bb5658,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; [root@k8s-master service]# kubectl get pod -o wide --show-&lt;span&gt;labels
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;NAME                            READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES   LABELS
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; myapp-deploy-5695bb5658-2866m   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;2&lt;/span&gt;          31h   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; myapp-deploy-5695bb5658-dcfw7   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;2&lt;/span&gt;          31h   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; myapp-deploy-5695bb5658-n2b5w   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;2&lt;/span&gt;          31h   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=v1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;curl访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;2866m
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt; 9&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;dcfw7
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt;15&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; myapp-deploy-5695bb5658-n2b5w
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;ClusterIP类型示例&quot;&gt;ClusterIP类型示例&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;service
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;cat&lt;/span&gt; myapp-svc-&lt;span&gt;ClusterIP.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Service
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: myapp-&lt;span&gt;clusterip
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  type: ClusterIP  # 可以不写，为默认类型
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  selector:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    app: myapp
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    release: v1
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  ports:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   -&lt;span&gt; name: http
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     port: &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     targetPort: &lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动Service并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# kubectl apply -f myapp-svc-&lt;span&gt;ClusterIP.yaml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; service/myapp-&lt;span&gt;clusterip created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master service]# kubectl get svc -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; NAME              TYPE        CLUSTER-IP      EXTERNAL-&lt;span&gt;IP   PORT(S)   AGE   SELECTOR
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; kubernetes        ClusterIP   &lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;       &amp;lt;none&amp;gt;        &lt;span&gt;443&lt;/span&gt;/TCP   22d   &amp;lt;none&amp;gt;
&lt;span&gt;7&lt;/span&gt; myapp-clusterip   ClusterIP   &lt;span&gt;10.106&lt;/span&gt;.&lt;span&gt;66.120&lt;/span&gt;   &amp;lt;none&amp;gt;        &lt;span&gt;80&lt;/span&gt;/TCP    15s   app=myapp,release=v1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看pod信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# kubectl get pod -o wide --show-&lt;span&gt;labels
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;NAME                            READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES   LABELS
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; myapp-deploy-5695bb5658-2866m   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;2&lt;/span&gt;          31h   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; myapp-deploy-5695bb5658-dcfw7   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;2&lt;/span&gt;          31h   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; myapp-deploy-5695bb5658-n2b5w   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;2&lt;/span&gt;          31h   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            app=myapp,&lt;span&gt;env&lt;/span&gt;=test,pod-template-hash=5695bb5658,release=v1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看ipvs信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# ipvsadm -&lt;span&gt;Ln
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; IP Virtual Server version &lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; (size=&lt;span&gt;4096&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Prot LocalAddress:Port Scheduler Flags
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   -&amp;gt;&lt;span&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;……………… 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; TCP  &lt;span&gt;10.106&lt;/span&gt;.&lt;span&gt;66.120&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; rr
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;8&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;9&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;curl访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.106&lt;/span&gt;.&lt;span&gt;66.120&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.106&lt;/span&gt;.&lt;span&gt;66.120&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;2866m
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.106&lt;/span&gt;.&lt;span&gt;66.120&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;n2b5w
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.106&lt;/span&gt;.&lt;span&gt;66.120&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;dcfw7
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.106&lt;/span&gt;.&lt;span&gt;66.120&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; myapp-deploy-5695bb5658-2866m
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;备注：如果访问失败，请参考如下文章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;「&lt;a href=&quot;https://www.cnblogs.com/zhanglianghhh/p/13636007.html&quot; target=&quot;_blank&quot;&gt;Kubernetes K8S在IPVS代理模式下svc服务的ClusterIP类型访问失败处理&lt;/a&gt;」&lt;/p&gt;

&lt;h2 id=&quot;Headless-Services&quot;&gt;Headless Services&lt;/h2&gt;
&lt;p&gt;有时不需要或不想要负载均衡，以及单独的 Service IP。遇到这种情况，可以通过指定 Cluster IP（spec.clusterIP）的值为 “None” 来创建 Headless Service。&lt;/p&gt;
&lt;p&gt;这对headless Service 并不会分配 Cluster IP，kube-proxy 不会处理它们，而且平台也不会为它们进行负载均衡和路由。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种：自主选择权，有时候client想自己来决定使用哪个Real Server，可以通过查询DNS来获取Real Server的信息。&lt;/li&gt;
&lt;li&gt;第二种：Headless Services还有一个用处（PS：也就是我们需要的那个特性）。Headless Service对应的每一个Endpoints，即每一个Pod，都会有对应的DNS域名；这样Pod之间就可以互相访问。【&lt;span&gt;结合statefulset有状态服务使用，如Web、MySQL集群&lt;/span&gt;】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;service
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;cat&lt;/span&gt; myapp-svc-&lt;span&gt;headless.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Service
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: myapp-&lt;span&gt;headless
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  selector:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    app: myapp
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    release: v1
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   clusterIP: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  ports:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   - port: &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     targetPort: &lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动Service并查看状态和详情&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# kubectl apply -f myapp-svc-&lt;span&gt;headless.yaml 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; service/myapp-&lt;span&gt;headless created
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master service]# kubectl get svc -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; NAME             TYPE        CLUSTER-IP   EXTERNAL-&lt;span&gt;IP   PORT(S)   AGE   SELECTOR
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; kubernetes       ClusterIP   &lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;    &amp;lt;none&amp;gt;        &lt;span&gt;443&lt;/span&gt;/TCP   22d   &amp;lt;none&amp;gt;
&lt;span&gt; 7&lt;/span&gt; myapp-headless   ClusterIP   None         &amp;lt;none&amp;gt;        &lt;span&gt;80&lt;/span&gt;/TCP    6s    app=myapp,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; [root@k8s-master service]# kubectl describe svc/myapp-&lt;span&gt;headless
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; Name:              myapp-&lt;span&gt;headless
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;Namespace:         default
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; Labels:            &amp;lt;none&amp;gt;
&lt;span&gt;13&lt;/span&gt; Annotations:       kubectl.kubernetes.io/&lt;span&gt;last&lt;/span&gt;-applied-&lt;span&gt;configuration:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                      {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myapp-headless&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clusterIP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; Selector:          app=myapp,release=&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;Type:              ClusterIP
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;IP:                None
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; Port:              &amp;lt;unset&amp;gt;  &lt;span&gt;80&lt;/span&gt;/&lt;span&gt;TCP
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; TargetPort:        &lt;span&gt;80&lt;/span&gt;/&lt;span&gt;TCP
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; Endpoints:         &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;,&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;,&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;  # 后端的Pod信息
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;Session Affinity:  None
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; Events:            &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;service只要创建成功就会写入到coredns。我们得到coredns IP的命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# kubectl get pod -o wide -A | &lt;span&gt;grep&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;coredns&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; kube-system            coredns-6955765f44-c9zfh                     &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;29&lt;/span&gt;         22d    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.62&lt;/span&gt;    k8s-master   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;span&gt;3&lt;/span&gt; kube-system            coredns-6955765f44-lrz5q                     &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;29&lt;/span&gt;         22d    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;    k8s-master   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在宿主机安装nslookup、dig命令安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y bind-utils
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;coredns记录信息如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # 其中 &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;&lt;span&gt; 为 coredns IP
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; # myapp-&lt;span&gt;headless.default.svc.cluster.local 为Headless Service域名。格式为:$(service name).$(namespace).svc.cluster.local，其中 cluster.local 指定的集群的域名
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# nslookup myapp-headless.default.svc.cluster.local &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; Server:        &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; Address:    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; Name:    myapp-&lt;span&gt;headless.default.svc.cluster.local
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; Address: &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; Name:    myapp-&lt;span&gt;headless.default.svc.cluster.local
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; Address: &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; Name:    myapp-&lt;span&gt;headless.default.svc.cluster.local
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; Address: &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; [root@k8s-&lt;span&gt;master service]#
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;### 或使用如下命令
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; [root@k8s-master service]# dig -t A myapp-headless.default.svc.cluster.local. @&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG &lt;span&gt;9.11&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-P2-RedHat-&lt;span&gt;9.11&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;.P2.el7_8.&lt;span&gt;6&lt;/span&gt; &amp;lt;&amp;lt;&amp;gt;&amp;gt; -t A myapp-headless.default.svc.cluster.local. @&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; ;; global options: +&lt;span&gt;cmd
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;;; Got answer:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; ;; WARNING: .local is reserved &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Multicast DNS
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;;; You are currently testing what happens when an mDNS query is leaked to DNS
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; ;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;7089&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; ;; flags: qr aa rd; QUERY: &lt;span&gt;1&lt;/span&gt;, ANSWER: &lt;span&gt;3&lt;/span&gt;, AUTHORITY: &lt;span&gt;0&lt;/span&gt;, ADDITIONAL: &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;;; WARNING: recursion requested but not available
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;;; OPT PSEUDOSECTION:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; ; EDNS: version: &lt;span&gt;0&lt;/span&gt;, flags:; udp: &lt;span&gt;4096&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;;; QUESTION SECTION:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; ;myapp-&lt;span&gt;headless.default.svc.cluster.local. IN A
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;;; ANSWER SECTION:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; myapp-headless.default.svc.cluster.local. &lt;span&gt;14&lt;/span&gt; IN    A &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; myapp-headless.default.svc.cluster.local. &lt;span&gt;14&lt;/span&gt; IN    A &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; myapp-headless.default.svc.cluster.local. &lt;span&gt;14&lt;/span&gt; IN    A &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; ;; Query &lt;span&gt;time&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt; msec
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; ;; SERVER: &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;(&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; ;; WHEN: Wed Jun &lt;span&gt;03&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;:&lt;span&gt;46&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; ;; MSG SIZE  rcvd: &lt;span&gt;237&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;NodePort类型示例&quot;&gt;NodePort类型示例&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果将 type 字段设置为 NodePort，则 Kubernetes 控制层面将在 --service-node-port-range 标志指定的范围内分配端口（默认值：30000-32767）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;service
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;cat&lt;/span&gt; myapp-svc-&lt;span&gt;NodePort.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Service
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: myapp-&lt;span&gt;nodeport
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  type: NodePort
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  selector:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    app: myapp
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    release: v1
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  ports:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   -&lt;span&gt; name: http
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    # 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     port: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;         # Service对外提供服务端口
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     targetPort: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;   # 请求转发后端Pod使用的端口
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     nodePort: &lt;span&gt;31682&lt;/span&gt;  # 可选字段，默认情况下，为了方便起见，Kubernetes 控制层面会从某个范围内分配一个端口号（默认：&lt;span&gt;30000&lt;/span&gt;-&lt;span&gt;32767&lt;/span&gt;）
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动Service并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# kubectl apply -f myapp-svc-&lt;span&gt;NodePort.yaml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; service/myapp-&lt;span&gt;nodeport created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master service]# kubectl get svc -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; NAME             TYPE        CLUSTER-IP    EXTERNAL-&lt;span&gt;IP   PORT(S)        AGE   SELECTOR
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; kubernetes       ClusterIP   &lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;     &amp;lt;none&amp;gt;        &lt;span&gt;443&lt;/span&gt;/TCP        22d   &amp;lt;none&amp;gt;
&lt;span&gt;7&lt;/span&gt; myapp-nodeport   NodePort    &lt;span&gt;10.99&lt;/span&gt;.&lt;span&gt;50.81&lt;/span&gt;   &amp;lt;none&amp;gt;        &lt;span&gt;80&lt;/span&gt;:&lt;span&gt;31682&lt;/span&gt;/TCP   6s    app=myapp,release=v1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由上可见，类型变为了NodePort&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查看ipvs信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# ipvsadm -&lt;span&gt;Ln
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; IP Virtual Server version &lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; (size=&lt;span&gt;4096&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Prot LocalAddress:Port Scheduler Flags
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   -&amp;gt;&lt;span&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; TCP  &lt;span&gt;10.99&lt;/span&gt;.&lt;span&gt;50.81&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; rr
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;8&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;9&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;端口查看，可见在本地宿主机监听了相应的端口（备注：集群所有机器都监听了该端口）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;# 集群所有机器都可以执行查看
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; [root@k8s-master service]# netstat -lntp | &lt;span&gt;grep&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;31682&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; tcp6       &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; :::&lt;span&gt;31682&lt;/span&gt;                :::*                    LISTEN      &lt;span&gt;3961&lt;/span&gt;/kube-proxy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;curl通过ClusterIP访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 通过ClusterIP访问
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.99&lt;/span&gt;.&lt;span&gt;50.81&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt; 4&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.99&lt;/span&gt;.&lt;span&gt;50.81&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;2866m
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.99&lt;/span&gt;.&lt;span&gt;50.81&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;n2b5w
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.99&lt;/span&gt;.&lt;span&gt;50.81&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; myapp-deploy-5695bb5658-dcfw7
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;curl通过节点IP访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 通过集群节点IP访问
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.110&lt;/span&gt;:&lt;span&gt;31682&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt; 4&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.110&lt;/span&gt;:&lt;span&gt;31682&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;2866m
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.110&lt;/span&gt;:&lt;span&gt;31682&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;n2b5w
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.110&lt;/span&gt;:&lt;span&gt;31682&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;dcfw7
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# 访问集群其他节点。每台机器都有LVS，和相关调度
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.111&lt;/span&gt;:&lt;span&gt;31682&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;dcfw7
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.112&lt;/span&gt;:&lt;span&gt;31682&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; myapp-deploy-5695bb5658-dcfw7
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;访问日志查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl logs -f svc/myapp-nodeport
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;LoadBalancer类型示例&quot;&gt;LoadBalancer类型示例&lt;/h2&gt;
&lt;p&gt;需要相关云厂商服务支持，这里就不表述了。&lt;/p&gt;

&lt;h2 id=&quot;ExternalName类型示例&quot;&gt;ExternalName类型示例&lt;/h2&gt;
&lt;p&gt;这种类型的Service通过返回CNAME和它的值，&lt;span&gt;可以将服务映射到externalName字段的内容&lt;/span&gt;（例如：my.k8s.example.com；可以实现跨namespace名称空间访问）。ExternalName Service是Service的特例，&lt;span&gt;它没有selector&lt;/span&gt;，也没有定义任何的端口和Endpoint。相反的，对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式提供服务。&lt;/p&gt;
&lt;p&gt;具体使用参见：「&lt;a href=&quot;https://www.cnblogs.com/zhanglianghhh/p/13663476.html&quot; target=&quot;_blank&quot;&gt;Kubernetes K8S之Pod跨namespace名称空间访问Service服务&lt;/a&gt;」&lt;/p&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;service
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;cat&lt;/span&gt; myapp-svc-&lt;span&gt;ExternalName.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Service
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: myapp-&lt;span&gt;externalname
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  type: ExternalName
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   externalName: my.k8s.example.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动Service并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# kubectl apply -f myapp-svc-&lt;span&gt;ExternalName.yaml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; service/myapp-&lt;span&gt;externalname created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master service]# kubectl get svc -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; NAME                 TYPE           CLUSTER-IP   EXTERNAL-&lt;span&gt;IP          PORT(S)   AGE   SELECTOR
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; kubernetes           ClusterIP      &lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;    &amp;lt;none&amp;gt;               &lt;span&gt;443&lt;/span&gt;/TCP   21d   &amp;lt;none&amp;gt;
&lt;span&gt;7&lt;/span&gt; myapp-externalname   ExternalName   &amp;lt;none&amp;gt;       my.k8s.example.com   &amp;lt;none&amp;gt;    21s   &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由上可见，类型变为了ExternalName&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;宿主机dig命令安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y bind-utils
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;coredns记录信息如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # 其中 &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;&lt;span&gt; 为 coredns IP
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; # myapp-&lt;span&gt;externalname.default.svc.cluster.local 为Service域名。格式为:$(service name).$(namespace).svc.cluster.local，其中 cluster.local 指定的集群的域名
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;##### 通过 nslookup 访问
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master service]# nslookup myapp-externalname.default.svc.cluster.local &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; Server:        &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; Address:    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; myapp-externalname.default.svc.cluster.local    canonical name =&lt;span&gt; my.k8s.example.com.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; ** server can&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t find my.k8s.example.com: NXDOMAIN&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; [root@k8s-&lt;span&gt;master service]#
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;##### 通过 dig 访问
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; [root@k8s-master service]# dig -t A myapp-externalname.default.svc.cluster.local. @&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG &lt;span&gt;9.11&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-P2-RedHat-&lt;span&gt;9.11&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;.P2.el7_8.&lt;span&gt;6&lt;/span&gt; &amp;lt;&amp;lt;&amp;gt;&amp;gt; -t A myapp-externalname.default.svc.cluster.local. @&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; ;; global options: +&lt;span&gt;cmd
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;;; Got answer:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; ;; WARNING: .local is reserved &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Multicast DNS
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;;; You are currently testing what happens when an mDNS query is leaked to DNS
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; ;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;39541&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; ;; flags: qr aa rd; QUERY: &lt;span&gt;1&lt;/span&gt;, ANSWER: &lt;span&gt;1&lt;/span&gt;, AUTHORITY: &lt;span&gt;0&lt;/span&gt;, ADDITIONAL: &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;;; WARNING: recursion requested but not available
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;;; OPT PSEUDOSECTION:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; ; EDNS: version: &lt;span&gt;0&lt;/span&gt;, flags:; udp: &lt;span&gt;4096&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;;; QUESTION SECTION:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; ;myapp-&lt;span&gt;externalname.default.svc.cluster.local. IN A
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;;; ANSWER SECTION:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; myapp-externalname.default.svc.cluster.local. &lt;span&gt;30&lt;/span&gt;&lt;span&gt; IN CNAME my.k8s.example.com.
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; ;; Query &lt;span&gt;time&lt;/span&gt;: &lt;span&gt;2072&lt;/span&gt;&lt;span&gt; msec
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; ;; SERVER: &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;(&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.61&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; ;; WHEN: Wed Jun &lt;span&gt;03&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt;:&lt;span&gt;47&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; ;; MSG SIZE  rcvd: &lt;span&gt;149&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;ExternalIP示例&quot;&gt;ExternalIP示例&lt;/h2&gt;
&lt;p&gt;如果外部的 IP 路由到集群中一个或多个 Node 上，Kubernetes Service 会被暴露给这些 externalIPs。通过外部 IP（作为目的 IP 地址）进入到集群，打到 Service 端口上的流量，将会被路由到 Service 的 Endpoint 上。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;externalIPs 不会被 Kubernetes 管理，它属于集群管理员的职责范畴。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据 Service 的规定，externalIPs 可以&lt;span&gt;同任意的 ServiceType 来一起指定&lt;/span&gt;。在下面的例子中，my-service 可以在【模拟外网IP】“10.0.0.240”(externalIP:port) 上被客户端访问。&lt;/p&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;service
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master service]# &lt;span&gt;cat&lt;/span&gt;  myapp-svc-&lt;span&gt;externalIP.yaml
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Service
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: myapp-&lt;span&gt;externalip
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  selector:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    app: myapp
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    release: v1
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  ports:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   -&lt;span&gt; name: http
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     port: &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     targetPort: &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  externalIPs:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     - &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.240&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动Service并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master service]# kubectl apply -f myapp-svc-&lt;span&gt;externalIP.yaml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; service/myapp-&lt;span&gt;externalip created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master service]# kubectl get svc -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; NAME               TYPE        CLUSTER-IP       EXTERNAL-&lt;span&gt;IP   PORT(S)   AGE   SELECTOR
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; kubernetes         ClusterIP   &lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;        &amp;lt;none&amp;gt;        &lt;span&gt;443&lt;/span&gt;/TCP   22d   &amp;lt;none&amp;gt;
&lt;span&gt;7&lt;/span&gt; myapp-externalip   ClusterIP   &lt;span&gt;10.107&lt;/span&gt;.&lt;span&gt;186.167&lt;/span&gt;   &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.240&lt;/span&gt;    &lt;span&gt;80&lt;/span&gt;/TCP    8s    app=myapp,release=v1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看ipvs信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# ipvsadm -&lt;span&gt;Ln
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; IP Virtual Server version &lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; (size=&lt;span&gt;4096&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Prot LocalAddress:Port Scheduler Flags
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   -&amp;gt;&lt;span&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; TCP  &lt;span&gt;10.107&lt;/span&gt;.&lt;span&gt;186.167&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; rr
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; TCP  &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.240&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; rr
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.115&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.116&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;   -&amp;gt; &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.105&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              Masq    &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;curl访问，通过ClusterIP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.107&lt;/span&gt;.&lt;span&gt;186.167&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.107&lt;/span&gt;.&lt;span&gt;186.167&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;n2b5w
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.107&lt;/span&gt;.&lt;span&gt;186.167&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;2866m
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.107&lt;/span&gt;.&lt;span&gt;186.167&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; myapp-deploy-5695bb5658-dcfw7
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;curl访问，通过ExternalIP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.240&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Hello MyApp | Version: v1 | &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hostname.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Pod Name&amp;lt;/a&amp;gt;
&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.240&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;2866m
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.240&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; myapp-deploy-5695bb5658-&lt;span&gt;dcfw7
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; [root@k8s-&lt;span&gt;master service]# 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-master service]# curl &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.240&lt;/span&gt;/&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;.html
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; myapp-deploy-5695bb5658-n2b5w
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/zhanglianghhh/p/13636007.html&quot; target=&quot;_blank&quot;&gt;Kubernetes K8S在IPVS代理模式下svc服务的ClusterIP类型访问失败处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/zhanglianghhh/p/13663476.html&quot; target=&quot;_blank&quot;&gt;Kubernetes K8S之Pod跨namespace名称空间访问Service服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/chadiandianwenrou/p/11937041.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;kubernetes学习Service之headless和statefulSet结合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.linuxea.com/1969.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;linuxea:kubernetes Headless Service无头服务&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;———END———&lt;br/&gt;如果觉得不错就关注下呗 (-^O^-) ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202009/1395193-20200917001646643-1945606029.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Wed, 16 Sep 2020 16:18:00 +0000</pubDate>
<dc:creator>踏歌行666</dc:creator>
<og:description>K8S之Service概述与代理说明，并详解所有的service服务类型与示例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanglianghhh/p/13682265.html</dc:identifier>
</item>
<item>
<title>Gradle系列之Android Gradle基础配置 - 躬行之</title>
<link>http://www.cnblogs.com/jzmanu/p/13682259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jzmanu/p/13682259.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文发于微信公众号 jzman-blog，欢迎关注交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过前面几篇文章学习了 Gradle 基础知识以及 Gradle 插件相关的知识，关于 Gradle 及其插件相关知识请先阅读下面几篇文章：&lt;/p&gt;
&lt;p&gt;上篇文章了解了 Android Gradle 插件的一下配置方法，记得刚开始接触 Android 中的 build.gradle 配置文件也是一脸懵逼，不知道各个配置项的具体含义，这篇文章将对 Android 开发中一些最基本的配置进行介绍，如果你有这方面的疑惑，相信这篇文章对你有一定收获&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;默认配置&lt;/li&gt;
&lt;li&gt;配置签名信息&lt;/li&gt;
&lt;li&gt;构建应用类型&lt;/li&gt;
&lt;li&gt;使用混淆&lt;/li&gt;
&lt;li&gt;启用zipalign优化&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;默认配置&quot;&gt;默认配置&lt;/h4&gt;
&lt;p&gt;defaultConfig 是 Android Gradle 配置文件中的一个配置块，defaultConfig 的类型是 ProductFlavor，如果没有自定义 ProductFlavor，则使用默认的 ProductFlavor 来配置 Android 工程，下面对 defaultConfig 中的一下配置属性进行介绍：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//默认的ProductFlavor配置块
defaultConfig {
    //配置App的包名
    applicationId &quot;com.manu.base&quot;
    //配合App最低支持的Android系统版本，下面两种minSdkVersion的配置效果是一致的
    minSdkVersion 19
    &amp;lt;!--minSdkVersion 'KitKat'--&amp;gt;
    //配置App基于哪个Android SDK开发
    targetSdkVersion 26
    //配置App的内部版本号，一般用于版本升级
    versionCode 1
    //配置App外部版本号，该版本号供用户查看
    versionName &quot;1.0&quot;
    //配置单元测试时使用的Runner
    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    //配置测试App的包名
    testApplicationId &quot;com.manu.androidgradleproject.test&quot;
    //使用指定的签名文件配置
    signingConfig signingConfigs.release
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置签名信息&quot;&gt;配置签名信息&lt;/h4&gt;
&lt;p&gt;配置 App 签名信息的好处无非是防止 App 被恶意篡改，签名可保证 App 的唯一性且只有使用相同签名的后续升级包才能正常安装，在创建完签名文件之后，如果不做配置打包时每次都必须要指定签名文件的密码、别名等，一般 App 开发时在 denug 和 release 模式下时配置不同的签名文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;：创建签名证书文件,如下图所示填写相关信息:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：使用 signConfigs 配置块配置已创建签名证书文件的相关信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//签名文件配置
signingConfigs {
    release{
        //签名证书文件
        storeFile file(&quot;project.jks&quot;)
        //签名证书文件密码
        storePassword &quot;111111&quot;
        //签名证书密钥别名
        keyAlias &quot;project_jks&quot;
        //签名证书中密钥密码
        keyPassword &quot;111111&quot;
    }
    debug{
        //默认情况下，debug模式下的签名已配置为Android SDK自动生成的debug签名文件证书
        //默认签名文件位置：.android/debug.keystore
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：使用签名文件配置，在 android{} 下 defaultConfig{} 中使用上述配置，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;defaultConfig {
    //...
    //使用指定的签名文件配置
    signingConfig signingConfigs.release
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了在 defaultConfig{} 中配置，还可以在分别在 denbug 或者是 release 模式下配置不同的签名文件，可在 buildTypes{} 中单独配置配置，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;buildTypes {
    release {
        signingConfig signingConfigs.release
        //...
    }
    debug{
        signingConfig signingConfigs.debug
        //...
    }
    
    //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构建应用的类型&quot;&gt;构建应用的类型&lt;/h4&gt;
&lt;p&gt;Android Gradle 内置了两种构建类型 debug 和 release，两者区别是前者一般用在调试状态，后者一般用于正式发布状态，其他方面都一样，那么如何增加新的构建类型呢，可直接在 buildTypes{} 中添加要添加的类型即可，buildTypes 接收的参数是一个域对象，添加的构建类型都是 BuildType，所以可以通过 BuildType 的相关属性来配置构建类型，下面是 BuildType 的常见的一些配置属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;buildTypes {
    release {
        //...
    }
    debug{
        //配置签名
        signingConfig signingConfigs.debug
        //配置在当前构建类型下applicationId的后缀，构建生成Apk的包名会在applicationId的基础上添加后缀
        applicationIdSuffix '.debug'
        //配置是否生成一个可供调试的Apk
        denbuggable true
        //配置是否生成一个可供调试jni(c/c++)代码的Apk
        jniDebuggable true
        //是否启用proguard混淆
        minifyEnabled true
        //配置当程序中方法数超过65535个时，是否启用自动拆分多个dex的功能，
        multiDexEnabled true
        //配置proguard混淆使用的配置文件，可配置对个混淆文件
        proguardFiles getDefaultProguardFile('proguard-android.txt'),'proguard-rules.pro'
        //配置是否自动清理未使用的资源,默认为false
        shrinkResources true
        //开启zipalign优化(见下文)
        zipAlignEnabled true
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当在 buildTypes{} 中添加新的构建类型之后，Android Gradle 都会自动生成一个 SourceSet，构建 Apk 会从对应的 SourceSet 中进行构建，切记新构建类型的名称不能和已有的相同。且要在 src 目录下为新创建的构建类型添加源代码目录和资源文件等，在创建好构建类型的同时，Android Gradle 插件也会生成对应的 assemble 任务来用于构建该类型的项目，如 release 对应的是 assembleRelease，执行该任务会生成对应的 Apk.&lt;/p&gt;
&lt;h4 id=&quot;使用混淆&quot;&gt;使用混淆&lt;/h4&gt;
&lt;p&gt;代码混淆主要了增加反编译的难度，发布正式版 App 时一般都得进行代码混淆，实际上 Android SDK 下面已经提供了默认的混淆文件，具体位置在 Android SDK 下面的 tools/progrard 下面，里面的内容主要是一些最基本的不能混淆的内容，两个默认的混淆文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//没优化
proguard-android.txt 
//已优化
proguard-android-optimize.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如何使用混淆呢，在 buildTypes{} 中对应的构建类型下设置 minifyEnabled 为 true 开启混淆，然后配置具体的混淆文件，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;buildTypes {
    release {
        //开启混淆
        minifyEnabled false
        //配置混淆文件
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
   //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;启用-zipalign-优化&quot;&gt;启用 zipalign 优化&lt;/h4&gt;
&lt;p&gt;zipalign 是 Android 提供的一个整理优化 apk 文件的工具，可在一定程度上上提高系统和应用的运行效率，更快的读取 apk 中的资源，降低内存的使用，开启 zipalign 优化只需要在 buildTypes{} 中对应的构建类型下开启 zipalign 优化即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;buildTypes {
    release {
       //开启zipalign优化
       zipAlignEnabled true
       //''
    }
   //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这篇算介绍了 Android 开发中一些常见配置项的介绍。&lt;/p&gt;
&lt;p&gt;可以关注公众号：零点小筑（jzman-blog），一起交流学习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/758808/202009/758808-20200917001501316-315633814.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Sep 2020 16:16:00 +0000</pubDate>
<dc:creator>躬行之</dc:creator>
<og:description>原文发于微信公众号 jzman-blog，欢迎关注交流。 通过前面几篇文章学习了 Gradle 基础知识以及 Gradle 插件相关的知识，关于 Gradle 及其插件相关知识请先阅读下面几篇文章：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jzmanu/p/13682259.html</dc:identifier>
</item>
<item>
<title>分布式文件系统之MogileFS的安装使用 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13677279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13677279.html</guid>
<description>&lt;p&gt;　　一、简介&lt;/p&gt;
&lt;p&gt;　　MogileFS是一个开源的分布式文件存储系统，由LiveJournal旗下的Danga Interactive公司开发；它主要由三部分组成，第一部分是server端，server端主要包括mogilefsd和mogstored两个应用程序。mogilefsd实现的是tracker，它通过数据库来保存元数据信息，包括站点domain、class、host等；mogstored是存储节点(store node)，它其实是个WebDAV服务，默认监听在7500端口，接受客户端的文件存储请求。在MogileFS安装完后，要运行mogadm工具将所有的store node注册到mogilefsd的数据库里，mogilefsd会对这些节点进行管理和监控。第二部是mogilefs的utils,这部分主要是一些工具，比如mogadm、mogupload、mogfileinfo 等等；第三部分是客户端API，mogilefs支持众多编程语言的客户端API接口，使用对应的客户端API接口，我们可以编写mogilefs的客户端，从而实现来管理mogilefs上的文件；&lt;/p&gt;
&lt;p&gt;　　二、Mogilefs架构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916151007723-1233504028.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：tracker的主要作用是代理前端用户的请求到数据库查询相关文件的元信息，同时它还要监控注册到tracker的storagenode的健康状态，一旦后端storage挂掉，它会立刻把对应的storage节点上的device从集群的中删除，上线时在加入到集群；客户端通过向tracker发送请求文件的信息，tracker通过去数据库中找到对应的文件所在storage节点的ip地址、端口、设备id以及文件fid，然后通过http链接的形式从tracker返回给客户端，客户端拿到这tracker的返回的文件地址，然后在去对应的storage请求文件，从而在客户端就访问到对应的文件内容信息；客户端和tracker，storage之间通信都是http协议，从本质上讲storage就是一个web服务器；所以对于客户端我们可以使用web服务器的反向代理，也可以是调用mogilefsAPI写的客户端程序；&lt;/p&gt;
&lt;p&gt;　　三、Mogilefs安装部署&lt;/p&gt;
&lt;p&gt; 　　环境说明&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;角色&lt;/td&gt;
&lt;td&gt;ip地址&lt;/td&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node01&lt;/td&gt;
&lt;td&gt;tracker+mysql+storage&lt;/td&gt;
&lt;td&gt;192.168.0.41&lt;/td&gt;
&lt;td&gt;7001/7500/7501/3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node02&lt;/td&gt;
&lt;td&gt;tracker+storage&lt;/td&gt;
&lt;td&gt;192.168.0.42&lt;/td&gt;
&lt;td&gt;7001/7500/7501&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node03&lt;/td&gt;
&lt;td&gt;storage&lt;/td&gt;
&lt;td&gt;192.168.0.43&lt;/td&gt;
&lt;td&gt;7500/7501&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;p&gt;　　各server时间同步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916125553382-293461122.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果有必要，可以配置各节点用hosts文件解析；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916125653225-1003778604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装环境依赖包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum install perl-Net-Netmask perl-IO-stringy perl-Sys-Syslog perl-IO-AIO -y 
Loaded plugins: fastestmirror
base                                                                                                            | 3.6 kB  00:00:00     
epel                                                                                                            | 4.7 kB  00:00:00     
extras                                                                                                          | 2.9 kB  00:00:00     
updates                                                                                                         | 2.9 kB  00:00:00     
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package perl-IO-AIO.x86_64 0:4.20-1.el7 will be installed
--&amp;gt; Processing Dependency: perl(common::sense) for package: perl-IO-AIO-4.20-1.el7.x86_64
---&amp;gt; Package perl-IO-stringy.noarch 0:2.110-22.el7 will be installed
---&amp;gt; Package perl-Net-Netmask.noarch 0:1.9015-13.el7 will be installed
---&amp;gt; Package perl-Sys-Syslog.x86_64 0:0.33-3.el7 will be installed
--&amp;gt; Running transaction check
---&amp;gt; Package perl-common-sense.noarch 0:3.6-4.el7 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

=======================================================================================================================================
 Package                                Arch                        Version                            Repository                 Size
=======================================================================================================================================
Installing:
 perl-IO-AIO                            x86_64                      4.20-1.el7                         epel                      117 k
 perl-IO-stringy                        noarch                      2.110-22.el7                       base                       71 k
 perl-Net-Netmask                       noarch                      1.9015-13.el7                      epel                       25 k
 perl-Sys-Syslog                        x86_64                      0.33-3.el7                         base                       42 k
Installing for dependencies:
 perl-common-sense                      noarch                      3.6-4.el7                          epel                       28 k

Transaction Summary
=======================================================================================================================================
Install  4 Packages (+1 Dependent package)

Total download size: 283 k
Installed size: 636 k
Downloading packages:
(1/5): perl-Sys-Syslog-0.33-3.el7.x86_64.rpm                                                                    |  42 kB  00:00:00     
(2/5): perl-Net-Netmask-1.9015-13.el7.noarch.rpm                                                                |  25 kB  00:00:00     
(3/5): perl-IO-AIO-4.20-1.el7.x86_64.rpm                                                                        | 117 kB  00:00:00     
(4/5): perl-common-sense-3.6-4.el7.noarch.rpm                                                                   |  28 kB  00:00:00     
(5/5): perl-IO-stringy-2.110-22.el7.noarch.rpm                                                                  |  71 kB  00:00:00     
---------------------------------------------------------------------------------------------------------------------------------------
Total                                                                                                  642 kB/s | 283 kB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : perl-common-sense-3.6-4.el7.noarch                                                                                  1/5 
  Installing : perl-IO-AIO-4.20-1.el7.x86_64                                                                                       2/5 
  Installing : perl-Net-Netmask-1.9015-13.el7.noarch                                                                               3/5 
  Installing : perl-Sys-Syslog-0.33-3.el7.x86_64                                                                                   4/5 
  Installing : perl-IO-stringy-2.110-22.el7.noarch                                                                                 5/5 
  Verifying  : perl-IO-AIO-4.20-1.el7.x86_64                                                                                       1/5 
  Verifying  : perl-common-sense-3.6-4.el7.noarch                                                                                  2/5 
  Verifying  : perl-IO-stringy-2.110-22.el7.noarch                                                                                 3/5 
  Verifying  : perl-Sys-Syslog-0.33-3.el7.x86_64                                                                                   4/5 
  Verifying  : perl-Net-Netmask-1.9015-13.el7.noarch                                                                               5/5 

Installed:
  perl-IO-AIO.x86_64 0:4.20-1.el7           perl-IO-stringy.noarch 0:2.110-22.el7       perl-Net-Netmask.noarch 0:1.9015-13.el7      
  perl-Sys-Syslog.x86_64 0:0.33-3.el7      

Dependency Installed:
  perl-common-sense.noarch 0:3.6-4.el7                                                                                                 

Complete!
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：三个节点都需要安装环境依赖的包；&lt;/p&gt;
&lt;p&gt;　　上传rpm包到服务器并安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%       1 KB    1 KB/s 00:00:01       0 Errors.el7.centos.noarch.rpm...
  100%     173 KB  173 KB/s 00:00:01       0 Errorsentos.noarch.rpm...
  100%      26 KB   26 KB/s 00:00:01       0 Errorsentos.noarch.rpm...
  100%      75 KB   75 KB/s 00:00:01       0 Errorsh.rpm...
  100%      27 KB   27 KB/s 00:00:01       0 Errors.rpm...
  100%      29 KB   29 KB/s 00:00:01       0 Errors.noarch.rpm...
  100%     262 KB  262 KB/s 00:00:01       0 Errors

[root@node01 ~]# ls
MogileFS-Server-2.46-2.el7.centos.noarch.rpm            perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm
MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch.rpm  perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm
MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm  perl-Perlbal-1.78-1.el6.noarch.rpm
MogileFS-Utils-2.19-1.el7.centos.noarch.rpm
[root@node01 ~]# yum install ./*.rpm -y
Loaded plugins: fastestmirror
Examining ./MogileFS-Server-2.46-2.el7.centos.noarch.rpm: MogileFS-Server-2.46-2.el7.centos.noarch
Marking ./MogileFS-Server-2.46-2.el7.centos.noarch.rpm to be installed
Examining ./MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch.rpm: MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch
Marking ./MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch.rpm to be installed
Examining ./MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm: MogileFS-Server-mogstored-2.46-2.el7.centos.noarch
Marking ./MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm to be installed
Examining ./MogileFS-Utils-2.19-1.el7.centos.noarch.rpm: MogileFS-Utils-2.19-1.el7.centos.noarch
Marking ./MogileFS-Utils-2.19-1.el7.centos.noarch.rpm to be installed
Examining ./perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm: perl-Danga-Socket-1.61-1.el6.rf.noarch
Marking ./perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm to be installed
Examining ./perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm: perl-MogileFS-Client-1.14-1.el7.centos.noarch
Marking ./perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm to be installed
Examining ./perl-Perlbal-1.78-1.el6.noarch.rpm: perl-Perlbal-1.78-1.el6.noarch
Marking ./perl-Perlbal-1.78-1.el6.noarch.rpm to be installed
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package MogileFS-Server.noarch 0:2.46-2.el7.centos will be installed
---&amp;gt; Package MogileFS-Server-mogilefsd.noarch 0:2.46-2.el7.centos will be installed
--&amp;gt; Processing Dependency: perl(DBI) &amp;gt;= 1.44 for package: MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
--&amp;gt; Processing Dependency: perl(DBD::mysql) &amp;gt;= 3 for package: MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch
---&amp;gt; Package MogileFS-Server-mogstored.noarch 0:2.46-2.el7.centos will be installed
……省略部分内容……
Installed:
  MogileFS-Server.noarch 0:2.46-2.el7.centos                         MogileFS-Server-mogilefsd.noarch 0:2.46-2.el7.centos              
  MogileFS-Server-mogstored.noarch 0:2.46-2.el7.centos               MogileFS-Utils.noarch 0:2.19-1.el7.centos                         
  perl-Danga-Socket.noarch 0:1.61-1.el6.rf                           perl-MogileFS-Client.noarch 0:1.14-1.el7.centos                   
  perl-Perlbal.noarch 0:1.78-1.el6                                  

Dependency Installed:
  mailcap.noarch 0:2.1.41-2.el7                                  perl-BSD-Resource.x86_64 0:1.29.07-1.el7                             
  perl-Business-ISBN.noarch 0:2.06-2.el7                         perl-Business-ISBN-Data.noarch 0:20120719.001-2.el7                  
  perl-Compress-Raw-Bzip2.x86_64 0:2.061-3.el7                   perl-Compress-Raw-Zlib.x86_64 1:2.061-4.el7                          
  perl-DBD-MySQL.x86_64 0:4.023-6.el7                            perl-DBI.x86_64 0:1.627-4.el7                                        
  perl-Data-Dumper.x86_64 0:2.145-3.el7                          perl-Digest.noarch 0:1.17-245.el7                                    
  perl-Digest-MD5.x86_64 0:2.52-3.el7                            perl-Encode-Locale.noarch 0:1.03-5.el7                               
  perl-File-Listing.noarch 0:6.04-7.el7                          perl-HTML-Parser.x86_64 0:3.71-4.el7                                 
  perl-HTML-Tagset.noarch 0:3.20-15.el7                          perl-HTTP-Cookies.noarch 0:6.01-5.el7                                
  perl-HTTP-Daemon.noarch 0:6.01-8.el7                           perl-HTTP-Date.noarch 0:6.02-8.el7                                   
  perl-HTTP-Message.noarch 0:6.06-6.el7                          perl-HTTP-Negotiate.noarch 0:6.01-5.el7                              
  perl-IO-Compress.noarch 0:2.061-2.el7                          perl-IO-HTML.noarch 0:1.00-2.el7                                     
  perl-IO-Socket-IP.noarch 0:0.21-5.el7                          perl-IO-Socket-SSL.noarch 0:1.94-7.el7                               
  perl-LWP-MediaTypes.noarch 0:6.02-2.el7                        perl-Mozilla-CA.noarch 0:20130114-5.el7                              
  perl-Net-Daemon.noarch 0:0.48-5.el7                            perl-Net-HTTP.noarch 0:6.06-2.el7                                    
  perl-Net-LibIDN.x86_64 0:0.12-15.el7                           perl-Net-SSLeay.x86_64 0:1.55-6.el7                                  
  perl-PlRPC.noarch 0:0.2020-14.el7                              perl-Sys-Syscall.noarch 0:0.25-10.el7                                
  perl-TimeDate.noarch 1:2.30-2.el7                              perl-URI.noarch 0:1.60-9.el7                                         
  perl-WWW-RobotRules.noarch 0:6.02-5.el7                        perl-libwww-perl.noarch 0:6.05-2.el7                                 

Complete!
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：安装环境依赖和以上rpm包，首先要配置好epel源；因为有些依赖包，它来自epel源；相关包我已经上传至我的网盘&lt;a href=&quot;http://www.qiuhom.com/d/383f34f57cf847beb296/&quot; target=&quot;_blank&quot;&gt;http://www.qiuhom.com/d/383f34f57cf847beb296/&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　安装mariadb-server&lt;/p&gt;
&lt;p&gt;　　配置yum源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cat /etc/yum.repos.d/mairadb.repo 
[mariadb]
name=mariadb repo
baseurl=https://mirrors.tuna.tsinghua.edu.cn/mariadb//mariadb-10.1.46/yum/centos/7/x86_64/
gpgcheck=0
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装mariadb-server&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum install MariaDB-server -y
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package MariaDB-server.x86_64 0:10.1.46-1.el7.centos will be installed
--&amp;gt; Processing Dependency: MariaDB-client for package: MariaDB-server-10.1.46-1.el7.centos.x86_64
--&amp;gt; Processing Dependency: rsync for package: MariaDB-server-10.1.46-1.el7.centos.x86_64
--&amp;gt; Processing Dependency: MariaDB-common for package: MariaDB-server-10.1.46-1.el7.centos.x86_64
--&amp;gt; Processing Dependency: galera for package: MariaDB-server-10.1.46-1.el7.centos.x86_64
--&amp;gt; Processing Dependency: libjemalloc.so.1()(64bit) for package: MariaDB-server-10.1.46-1.el7.centos.x86_64
--&amp;gt; Running transaction check
……省略部分内容……

Installed:
  MariaDB-server.x86_64 0:10.1.46-1.el7.centos                       MariaDB-shared.x86_64 0:10.1.46-1.el7.centos                      

Dependency Installed:
  MariaDB-client.x86_64 0:10.1.46-1.el7.centos                       MariaDB-common.x86_64 0:10.1.46-1.el7.centos                      
  boost-program-options.x86_64 0:1.53.0-28.el7                       galera.x86_64 0:25.3.29-1.rhel7.el7.centos                        
  jemalloc.x86_64 0:3.6.0-1.el7                                      rsync.x86_64 0:3.1.2-10.el7                                       

Replaced:
  mariadb-libs.x86_64 1:5.5.56-2.el7                                                                                                   

Complete!
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：mariadb-server包名是大写的MariaDB-server；&lt;/p&gt;
&lt;p&gt;　　配置mariadb忽略名称解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916131529564-1738996705.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　设置mariadb开机自动启动，并启动mariadb&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916131823557-1660664747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加用于mogilefs访问数据库的账号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916132158312-1853306212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　初始化数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# mogdbsetup --help
Usage: mogdbsetup [opts]

Options:

                  Default      Description
                  ============ ===========================================
 --verbose        &amp;lt;off&amp;gt;        Be verbose about what's happening.

 --dbhost=        localhost    hostname or IP to database server.

 --dbport=        dbd default  port number to database server.

 --dbname=        mogilefs     database name to create/upgrade.

 --dbrootuser=    root         Database administrator username.  Only needed
                               for initial setup, not subsequent upgrades.

 --dbrootpass=    &amp;lt;blank&amp;gt;      Database administrator password.  Only needed
                               for initial setup, not subsequent upgrades.

 --dbuser=        mogile       Regular database user to create and/or use
                               for MogileFS database.  This is what the
                               mogilefsd trackers connect as.

 --dbpass=        &amp;lt;blank&amp;gt;      You should change this, especially if your
                               database servers are accessible to other users
                               on the network.  But they shouldn't be
                               if you're running MogileFS, because MogileFS
                               assumes your network is closed.

  --type=         MySQL        Which MogileFS::Store implementation to use.
                               Available: MySQL, Postgres

  --yes                        Run without questions.

[root@node01 ~]# mogdbsetup --dbhost=192.168.0.41 --dbport=3306 --dbname=mogilefs --dbrootpass=admin --dbuser=mogilefs --dbpass=mogilefs

This will attempt to setup or upgrade your MogileFS database.
It won't destroy existing data.
Run with --help for more information.  Run with --yes to shut up these prompts.

Continue? [N/y]: y

Create/Upgrade database name 'mogilefs'? [Y/n]: y

Grant all privileges to user 'mogilefs', connecting from anywhere, to the mogilefs database 'mogilefs'? [Y/n]: n
Stopped.
[root@node01 ~]# mogdbsetup --dbhost=192.168.0.41 --dbport=3306 --dbname=mogilefs --dbrootpass=admin --dbuser=mogilefs --dbpass=mogilefs

This will attempt to setup or upgrade your MogileFS database.
It won't destroy existing data.
Run with --help for more information.  Run with --yes to shut up these prompts.

Continue? [N/y]: y
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果不想让mogdbsetup在数据库中创建一个任何地址都可访问的mogilefs的用户，在最后的选项中使用n即可，然后在重复执行上述命令即可；如果不想交互式输入y，也可以直接在命令后面用--yes；&lt;/p&gt;
&lt;p&gt;　　验证：在数据库中查看对应的库是否都已创建，对应库中是否都有表？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 7
Server version: 10.1.46-MariaDB MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mogilefs           |
| mysql              |
| performance_schema |
| test               |
+--------------------+
5 rows in set (0.01 sec)

MariaDB [(none)]&amp;gt; use mogilefs
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MariaDB [mogilefs]&amp;gt; show tables;
+----------------------+
| Tables_in_mogilefs   |
+----------------------+
| checksum             |
| class                |
| device               |
| domain               |
| file                 |
| file_on              |
| file_on_corrupt      |
| file_to_delete       |
| file_to_delete2      |
| file_to_delete_later |
| file_to_queue        |
| file_to_replicate    |
| fsck_log             |
| host                 |
| server_settings      |
| tempfile             |
| unreachable_fids     |
+----------------------+
17 rows in set (0.00 sec)

MariaDB [mogilefs]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到此数据库就准备好了&lt;/p&gt;
&lt;p&gt;　　配置mogilefsd连接数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916132921576-421831670.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：我们只需要修改红框中的内容即可；db_dsn用于指定连接数据库的驱动，以及数据库库名和主机地址；db_user用于指定连接数据库所使用的用户，db_pass用于指定连接数据库的密码；listen用于指定mogilefsd监听的ip地址和端口；后面的配置就是和启动的进程数量的配置，这个可以根据业务的规模来设置；&lt;/p&gt;
&lt;p&gt;　　启动mogilefsd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916133331087-2008671733.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在centos7上启动mogilefsd时，会报错，我们可以不用管这个错误，实际上mogilefsd是启动成功的，只要看到对应的端口和进程起来，表示mogilefsd启动就没有问题；&lt;/p&gt;
&lt;p&gt;　　配置node01上的mogstored&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cat /etc/mogilefs/mogstored.conf
maxconns = 10000
httplisten = 0.0.0.0:7500
mgmtlisten = 0.0.0.0:7501
docroot = /data/mogilefs
[root@node01 ~]# mkdir /data/mogilefs/ -pv
mkdir: created directory ‘/data’
mkdir: created directory ‘/data/mogilefs/’
[root@node01 ~]# chown -R mogilefs.mogilefs /data/mogilefs/
[root@node01 ~]# ll -d /data/mogilefs/
drwxr-xr-x 2 mogilefs mogilefs 6 Sep 16 13:37 /data/mogilefs/
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动mogstored&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916133922340-1024619456.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在centos7上启动mogstored也会同启动mogilefsd一样报错，这个主要是因为systemd的缘故，在centos6不会报错；到此，node01上的mariadb、mogilefsd和mogstored都已经安装配置好了；&lt;/p&gt;
&lt;p&gt;　　复制安装包到node02和node03&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916134653126-61086528.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在node02上安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node02 ~]# yum install perl-Net-Netmask perl-IO-stringy perl-Sys-Syslog perl-IO-AIO ./*.rpm -y
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Package perl-Net-Netmask-1.9015-13.el7.noarch already installed and latest version
Package perl-IO-stringy-2.110-22.el7.noarch already installed and latest version
Package perl-Sys-Syslog-0.33-3.el7.x86_64 already installed and latest version
Package perl-IO-AIO-4.20-1.el7.x86_64 already installed and latest version
Examining ./MogileFS-Server-2.46-2.el7.centos.noarch.rpm: MogileFS-Server-2.46-2.el7.centos.noarch
Marking ./MogileFS-Server-2.46-2.el7.centos.noarch.rpm to be installed
Examining ./MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch.rpm: MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch
Marking ./MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch.rpm to be installed
Examining ./MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm: MogileFS-Server-mogstored-2.46-2.el7.centos.noarch
Marking ./MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm to be installed
Examining ./MogileFS-Utils-2.19-1.el7.centos.noarch.rpm: MogileFS-Utils-2.19-1.el7.centos.noarch
Marking ./MogileFS-Utils-2.19-1.el7.centos.noarch.rpm to be installed
Examining ./perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm: perl-Danga-Socket-1.61-1.el6.rf.noarch
Marking ./perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm to be installed
Examining ./perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm: perl-MogileFS-Client-1.14-1.el7.centos.noarch
Marking ./perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm to be installed
Examining ./perl-Perlbal-1.78-1.el6.noarch.rpm: perl-Perlbal-1.78-1.el6.noarch
Marking ./perl-Perlbal-1.78-1.el6.noarch.rpm to be installed
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package MogileFS-Server.noarch 0:2.46-2.el7.centos will be installed
---&amp;gt; Package MogileFS-Server-mogilefsd.noarch 0:2.46-2.el7.centos will be installed
--&amp;gt; Processing Dependency: perl(DBI) &amp;gt;= 1.44 for package: MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch
……省略部分内容……
Installed:
  MogileFS-Server.noarch 0:2.46-2.el7.centos                                                              
  MogileFS-Server-mogilefsd.noarch 0:2.46-2.el7.centos                                                    
  MogileFS-Server-mogstored.noarch 0:2.46-2.el7.centos                                                    
  MogileFS-Utils.noarch 0:2.19-1.el7.centos                                                               
  perl-Danga-Socket.noarch 0:1.61-1.el6.rf                                                                
  perl-MogileFS-Client.noarch 0:1.14-1.el7.centos                                                         
  perl-Perlbal.noarch 0:1.78-1.el6                                                                        

Dependency Installed:
  mailcap.noarch 0:2.1.41-2.el7                    perl-BSD-Resource.x86_64 0:1.29.07-1.el7               
  perl-Business-ISBN.noarch 0:2.06-2.el7           perl-Business-ISBN-Data.noarch 0:20120719.001-2.el7    
  perl-Compress-Raw-Bzip2.x86_64 0:2.061-3.el7     perl-Compress-Raw-Zlib.x86_64 1:2.061-4.el7            
  perl-DBD-MySQL.x86_64 0:4.023-6.el7              perl-DBI.x86_64 0:1.627-4.el7                          
  perl-Data-Dumper.x86_64 0:2.145-3.el7            perl-Digest.noarch 0:1.17-245.el7                      
  perl-Digest-MD5.x86_64 0:2.52-3.el7              perl-Encode-Locale.noarch 0:1.03-5.el7                 
  perl-File-Listing.noarch 0:6.04-7.el7            perl-HTML-Parser.x86_64 0:3.71-4.el7                   
  perl-HTML-Tagset.noarch 0:3.20-15.el7            perl-HTTP-Cookies.noarch 0:6.01-5.el7                  
  perl-HTTP-Daemon.noarch 0:6.01-8.el7             perl-HTTP-Date.noarch 0:6.02-8.el7                     
  perl-HTTP-Message.noarch 0:6.06-6.el7            perl-HTTP-Negotiate.noarch 0:6.01-5.el7                
  perl-IO-Compress.noarch 0:2.061-2.el7            perl-IO-HTML.noarch 0:1.00-2.el7                       
  perl-IO-Socket-IP.noarch 0:0.21-5.el7            perl-IO-Socket-SSL.noarch 0:1.94-7.el7                 
  perl-LWP-MediaTypes.noarch 0:6.02-2.el7          perl-Mozilla-CA.noarch 0:20130114-5.el7                
  perl-Net-Daemon.noarch 0:0.48-5.el7              perl-Net-HTTP.noarch 0:6.06-2.el7                      
  perl-Net-LibIDN.x86_64 0:0.12-15.el7             perl-Net-SSLeay.x86_64 0:1.55-6.el7                    
  perl-PlRPC.noarch 0:0.2020-14.el7                perl-Sys-Syscall.noarch 0:0.25-10.el7                  
  perl-TimeDate.noarch 1:2.30-2.el7                perl-URI.noarch 0:1.60-9.el7                           
  perl-WWW-RobotRules.noarch 0:6.02-5.el7          perl-libwww-perl.noarch 0:6.05-2.el7                   

Complete!
[root@node02 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　把node01上的mogilefsd的配置文件复制到node02上，然后启动mogilefsd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916135148118-538785820.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　把node01上的mogstored配置文件复制到node02上，然后在node02上创建对应的目录并修改属主和属组为mogilefs，然后启动mogstored&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916135453820-982582348.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此node02上的mogilefsd和mogstored就安装配置启动好了；&lt;/p&gt;
&lt;p&gt;　　在node03上安装配置mogstored&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# ls
MogileFS-Server-2.46-2.el7.centos.noarch.rpm            perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm
MogileFS-Server-mogilefsd-2.46-2.el7.centos.noarch.rpm  perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm
MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm  perl-Perlbal-1.78-1.el6.noarch.rpm
MogileFS-Utils-2.19-1.el7.centos.noarch.rpm
[root@node03 ~]# yum install ./MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm ./MogileFS-Utils-2.19-1.el7.centos.noarch.rpm ./perl-*.rpm perl-Net-Netmask perl-IO-stringy perl-Sys-Syslog perl-IO-AIO -y    
Loaded plugins: fastestmirror
Examining ./MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm: MogileFS-Server-mogstored-2.46-2.el7.centos.noarch
Marking ./MogileFS-Server-mogstored-2.46-2.el7.centos.noarch.rpm to be installed
Examining ./MogileFS-Utils-2.19-1.el7.centos.noarch.rpm: MogileFS-Utils-2.19-1.el7.centos.noarch
Marking ./MogileFS-Utils-2.19-1.el7.centos.noarch.rpm to be installed
Examining ./perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm: perl-Danga-Socket-1.61-1.el6.rf.noarch
Marking ./perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm to be installed
Examining ./perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm: perl-MogileFS-Client-1.14-1.el7.centos.noarch
Marking ./perl-MogileFS-Client-1.14-1.el7.centos.noarch.rpm to be installed
Examining ./perl-Perlbal-1.78-1.el6.noarch.rpm: perl-Perlbal-1.78-1.el6.noarch
Marking ./perl-Perlbal-1.78-1.el6.noarch.rpm to be installed
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Package perl-Net-Netmask-1.9015-13.el7.noarch already installed and latest version
Package perl-IO-stringy-2.110-22.el7.noarch already installed and latest version
Package perl-Sys-Syslog-0.33-3.el7.x86_64 already installed and latest version
Package perl-IO-AIO-4.20-1.el7.x86_64 already installed and latest version
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package MogileFS-Server-mogstored.noarch 0:2.46-2.el7.centos will be installed
---&amp;gt; Package MogileFS-Utils.noarch 0:2.19-1.el7.centos will be installed
--&amp;gt; Processing Dependency: perl(Compress::Zlib) for package: MogileFS-Utils-2.19-1.el7.centos.noarch
……省略部分内容……
Installed:
  MogileFS-Server-mogstored.noarch 0:2.46-2.el7.centos   MogileFS-Utils.noarch 0:2.19-1.el7.centos        
  perl-Danga-Socket.noarch 0:1.61-1.el6.rf               perl-MogileFS-Client.noarch 0:1.14-1.el7.centos  
  perl-Perlbal.noarch 0:1.78-1.el6                      

Dependency Installed:
  mailcap.noarch 0:2.1.41-2.el7                    perl-BSD-Resource.x86_64 0:1.29.07-1.el7               
  perl-Business-ISBN.noarch 0:2.06-2.el7           perl-Business-ISBN-Data.noarch 0:20120719.001-2.el7    
  perl-Compress-Raw-Bzip2.x86_64 0:2.061-3.el7     perl-Compress-Raw-Zlib.x86_64 1:2.061-4.el7            
  perl-Data-Dumper.x86_64 0:2.145-3.el7            perl-Digest.noarch 0:1.17-245.el7                      
  perl-Digest-MD5.x86_64 0:2.52-3.el7              perl-Encode-Locale.noarch 0:1.03-5.el7                 
  perl-File-Listing.noarch 0:6.04-7.el7            perl-HTML-Parser.x86_64 0:3.71-4.el7                   
  perl-HTML-Tagset.noarch 0:3.20-15.el7            perl-HTTP-Cookies.noarch 0:6.01-5.el7                  
  perl-HTTP-Daemon.noarch 0:6.01-8.el7             perl-HTTP-Date.noarch 0:6.02-8.el7                     
  perl-HTTP-Message.noarch 0:6.06-6.el7            perl-HTTP-Negotiate.noarch 0:6.01-5.el7                
  perl-IO-Compress.noarch 0:2.061-2.el7            perl-IO-HTML.noarch 0:1.00-2.el7                       
  perl-IO-Socket-IP.noarch 0:0.21-5.el7            perl-IO-Socket-SSL.noarch 0:1.94-7.el7                 
  perl-LWP-MediaTypes.noarch 0:6.02-2.el7          perl-Mozilla-CA.noarch 0:20130114-5.el7                
  perl-Net-HTTP.noarch 0:6.06-2.el7                perl-Net-LibIDN.x86_64 0:0.12-15.el7                   
  perl-Net-SSLeay.x86_64 0:1.55-6.el7              perl-Sys-Syscall.noarch 0:0.25-10.el7                  
  perl-TimeDate.noarch 1:2.30-2.el7                perl-URI.noarch 0:1.60-9.el7                           
  perl-WWW-RobotRules.noarch 0:6.02-5.el7          perl-libwww-perl.noarch 0:6.05-2.el7                   

Complete!
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　复制node01上的mogstored配置文件到node03上，然后在node03上创建对应的目录并修改属主和属组为mogilefs，然后启动mogstored&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916140654575-1604303635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在node03上没有安装mogilefs-server这个包，所以在对应系统上没有mogilefs这个账号，我们需要手动创建这个账号；&lt;/p&gt;
&lt;p&gt;　　启动mogstored&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916140815382-241495820.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此三个节点的环境配置，以及服务都已经正常启动了；&lt;/p&gt;
&lt;p&gt;　　四、使用mogadm管理mogilefs&lt;/p&gt;
&lt;p&gt;　　把三个storage节点注册到tracker上&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916203215734-621380336.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果集群各节点没有做hosts主机名解析,那么对应的的节点就需要写清楚ip地址即可，如果端口不是7500，我们还需要用--port去指定端口；&lt;/p&gt;
&lt;p&gt;　　检查集群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916204633428-111691666.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在tracker节点监听在本机所有地址的7001，执行上述命令不需要加--trackers选项来指明tracker是谁，它默认会去找本机的7001；否则执行上述命令需要加上--trackers来指定tracker的地址和端口；&lt;/p&gt;
&lt;p&gt;　　在非tracker节点执行检查集群的命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916204947970-1027319582.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建devices&lt;/p&gt;
&lt;p&gt;　　分别在3个mogstored节点的docroot说指定的目录下创建以dev+数字的目录，并将属主和属组修改成mogilefs&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# mkdir /data/mogilefs/dev3
[root@node03 ~]# chown -R mogilefs.mogilefs /data/mogilefs/dev3
[root@node03 ~]# ll -d /data/mogilefs/dev3
drwxr-xr-x 3 mogilefs mogilefs 37 Sep 16 21:02 /data/mogilefs/dev3
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　添加device&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916210054207-1589100088.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看device&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916210350646-1694286058.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果在指定节点的docroot所指定的目录下没有创建dev+设备编号的目录，上面是看不到对应设备的空间大小的；&lt;/p&gt;
&lt;p&gt;　　创建domain&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916210643536-528170328.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建class&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916210821638-418746856.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好了，到此我们就可以上传文件了&lt;/p&gt;
&lt;p&gt;　　上传文件，把/etc/passwd上传到files域中，使用html class&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916211456351-300057277.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：mogupload这个工具是mogilefs的一个上传文件的工具，其中--domain用于指定域，就是把文件放到那个名称空间中；--class用于指定使用那个class策略来同步文件，默认不指定使用default；--key用于指定客户端访问文件的路径；--file用于指定要上传的文件路径；&lt;/p&gt;
&lt;p&gt;　　查看上传文件的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916211613605-1927602790.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：查看上传文件的信息需要用mogfileinfo这个工具，我们只需要指定trancker，domain以及文件的key就可以看到，该文件的class，devcount,domain,fid,key,length,以及访问http地址；这里需要说明一下，我们刚才在创建files域中的html这个class 我们指定了mindevcount=3，表示只要使用这个class上传文件，文件至少有3个副本；而我们现在看到的只有一个，这是因为在centos7上，Sys-syscall这个包的版本过高，导致mogilefs异常；&lt;/p&gt;
&lt;p&gt;　　降级Sys-Syscall，解决centos7上安装mogilefs 后端mogstored 同步问题&lt;/p&gt;
&lt;p&gt;　　安装perl编译环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum -y install make gcc unzip perl-DBD-MySQL perl perl-CPAN perl-YAML perl-Time-HiRes
Loaded plugins: fastestmirror
base                                                                                           | 3.6 kB  00:00:00     
epel                                                                                           | 4.7 kB  00:00:00     
extras                                                                                         | 2.9 kB  00:00:00     
mariadb                                                                                        | 2.9 kB  00:00:00     
updates                                                                                        | 2.9 kB  00:00:00     
(1/2): epel/x86_64/updateinfo                                                                  | 1.0 MB  00:00:00     
(2/2): epel/x86_64/primary_db                                                                  | 6.9 MB  00:00:00     
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Package gcc-4.8.5-39.el7.x86_64 already installed and latest version
Package unzip-6.0-21.el7.x86_64 already installed and latest version
Package perl-DBD-MySQL-4.023-6.el7.x86_64 already installed and latest version
Package 4:perl-5.16.3-295.el7.x86_64 already installed and latest version
Package 4:perl-Time-HiRes-1.9725-3.el7.x86_64 already installed and latest version
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package make.x86_64 1:3.82-23.el7 will be updated
---&amp;gt; Package make.x86_64 1:3.82-24.el7 will be an update
---&amp;gt; Package perl-CPAN.noarch 0:1.9800-295.el7 will be installed
--&amp;gt; Processing Dependency: perl(local::lib) for package: perl-CPAN-1.9800-295.el7.noarch
……省略部分内容……
Installed:
  perl-CPAN.noarch 0:1.9800-295.el7                           perl-YAML.noarch 0:0.84-5.el7                          

Dependency Installed:
  gdbm-devel.x86_64 0:1.10-8.el7                            libdb-devel.x86_64 0:5.3.21-25.el7                        
  perl-Digest-SHA.x86_64 1:5.85-4.el7                       perl-ExtUtils-Install.noarch 0:1.58-295.el7               
  perl-ExtUtils-MakeMaker.noarch 0:6.68-3.el7               perl-ExtUtils-Manifest.noarch 0:1.61-244.el7              
  perl-ExtUtils-ParseXS.noarch 1:3.18-3.el7                 perl-Test-Harness.noarch 0:3.28-3.el7                     
  perl-devel.x86_64 4:5.16.3-295.el7                        perl-local-lib.noarch 0:1.008010-4.el7                    
  pyparsing.noarch 0:1.5.6-9.el7                            systemtap-sdt-devel.x86_64 0:4.0-11.el7                   

Updated:
  make.x86_64 1:3.82-24.el7                                                                                           

Dependency Updated:
  libdb.x86_64 0:5.3.21-25.el7                           libdb-utils.x86_64 0:5.3.21-25.el7                          

Complete!
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在mogstored节点上都要安装好perl环境依赖包；然后按照下面的步骤重新编译安装Sys-Syscall；然后重启mogstored即可生效；&lt;/p&gt;
&lt;p&gt;　　下载低版本的Sys-Syscall源码包，并解压，进入到源码目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916213049979-502310519.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　编译安装Sys-Syscall&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916213245042-329151397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　验证&lt;/p&gt;
&lt;p&gt;　　重启mogstored，mogilefsd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916215330231-652317826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：所有storage节点都有重新编译安装Sys-Syscall，然后重启mogstored；对应的tracker节点也需要重启mogilefsd；&lt;/p&gt;
&lt;p&gt;　　上传文件看看对应的副本数量是否还是只有一个？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916214833850-2034038038.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到对应的devcount和我们之前指定的class上的mindevcount就一样了；&lt;/p&gt;
&lt;p&gt;　　验证：访问指定上述任一一个地址，看看访问到的文件内容是否是我们上传到文件内容？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916215539648-1090630220.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们上传到文件内容在tracker给我们返回的地址上能够访问到，并且里面的内容也是一样的；&lt;/p&gt;
&lt;p&gt;　　验证：停掉node02上的mogstored，看看对应的tracker是否能够及时发现对应的storage不在线了呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200916215959149-743468419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当node02上的mogstored挂掉以后，在检查集群，tracker就能及时的发现对应的设备不在线了，这个有点类似nginx对后端web服务器做健康状态监测的感觉；也就说tracker在监视着注册在tracker上的storage节点；&lt;/p&gt;
&lt;p&gt;　　到此，mogilefs在centos7上的安装部署，以及使用mogadm工具管理集群就完成了，对于mogilefs通常我们上传文件是通过业务程序调用api实现，mogupload只是一个测试工具；对于查看文件，通常用户也不会使用mogfieinfo返回的链接去查看文件，通常会使用一个web反向代理（nginx）去代理用户的访问；比如用户要查看/images/test.jpg，而在tracker返回的对应资源的链接中，一定不是/images/test.jpg，这个时候我们就需要用到web反向代理，让其反向代理能够帮助我们去tracker取到对应uri的资源链接，从而帮助我们去storage节点获取到对应的文件，然后再返回给用户；最后还是建议，如果用到mogilefs，最好跑在centos6上，centos7系统环境较高，有些依赖可能成问题；在centos6上，我测试过，完全没有上述的问题；我们只需要安装perl-IO-AIO这一个依赖包就可以解决mogstored启动问题；centos6上需要用到的rpm包可以去我的网盘下载&lt;a href=&quot;http://www.qiuhom.com/d/47e8f7ac56a445f1bfc6/&quot; target=&quot;_blank&quot;&gt;http://www.qiuhom.com/d/47e8f7ac56a445f1bfc6/&lt;/a&gt;；&lt;/p&gt;
</description>
<pubDate>Wed, 16 Sep 2020 15:32:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>一、简介 MogileFS是一个开源的分布式文件存储系统，由LiveJournal旗下的Danga Interactive公司开发；它主要由三部分组成，第一部分是server端，server端主要包括</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13677279.html</dc:identifier>
</item>
<item>
<title>【译】Visual Studio 2019 的 Local Process with Kubernetes  - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/13678373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/13678373.html</guid>
<description>&lt;p&gt;　　今天，我们自豪地宣布 Local Process with Kubernetes 的预览版已加入到 Visual Studio 2019 16.7 Preview 2 中。 &lt;/p&gt;
&lt;p&gt;　　Local Process with Kubernetes 允许您在开发工作站上编写、测试和调试 .NET 微服务代码，同时与应用程序或服务的其余部分连接到 Kubernetes 群集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202009/270073-20200916121927859-1571251992.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　开发针对 Kubernetes 的微服务应用程序的典型开发人员工作流包括修改代码、构建容器映像并将该映像部署到 Kubernetes 群集。所有这些都是看到更改清单所必需的。此工作流每天多次的复杂性阻碍了开发人员执行内部循环任务核心的能力，但是，这个过程可以大大简化。    &lt;/p&gt;
&lt;p&gt;　　Kubernetes 的本地流程将 Kubernetes 外围扩展到您的开发工作站，使您能够避开构建和同步代码到群集以测试、调试和快速迭代的操作复杂性。   &lt;/p&gt;
&lt;p&gt;　　有了这个工作流，就不需要额外的资产，例如 Dockerfile 或 Kubernetes 清单。只需在连接到 Kubernetes 群集时，在开发工作站上以本机方式运行代码，即可在更大的应用程序的上下文中测试代码更改。 &lt;/p&gt;

&lt;p&gt;　　微服务应用程序是由许多服务组成,而且还经常彼此调用。 每个服务有自己的配置 和依赖，使本地运行应用程序费时而复杂。&lt;/p&gt;
&lt;p&gt;　　通过使用 Local Process with Kubernetes 连接你的开发工作站 Kubernetes 集群，消除需要手动 收集、配置和编译 外部依赖。&lt;/p&gt;
&lt;p&gt;　　此外，本地运行的微服务代码继承来自群集的环境变量、连接字符串和卷。&lt;/p&gt;

&lt;p&gt;　　作为附加的 Debug Profile 文件集成到 Visual Studio 开发环境中，Local Process with Kubernetes 创建到你的 Kubernetes 集群连接，从而允许轻松的 F5 调试体验。通过运行通常的添加群集配置的 Debug Profile 文件，您可以像往常一样调试代码，同时利用本地调试的速度和灵活性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202009/270073-20200916122109044-1950589775.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　使用 Local Process with Kubernetes 可在开发期间进行端到端测试。选择集群中的现有服务，以路由到在本地运行该服务的实例的开发计算机。&lt;/p&gt;
&lt;p&gt;　　在 Kubernetes 中运行的应用程序前端请求将在群集中运行的服务之间路由，直到调用您指定重定向的服务。&lt;/p&gt;

&lt;p&gt;　　我们很乐意听到您关于 Local Process with Kubernete 的体验，以及我们在哪里可以改进。问题或评论，请访问我们  GitHub 问题页面。  &lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://devblogs.microsoft.com/visualstudio/introducing-local-process-with-kubernetes-for-visual-studio%e2%80%af2019/?utm_source=vs_developer_news&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://devblogs.microsoft.com/visualstudio/introducing-local-process-with-kubernetes-for-visual-studio%e2%80%af2019/?utm_source=vs_developer_news&amp;amp;utm_medium=referral&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202009/270073-20200916122310076-1450109739.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 Sep 2020 15:29:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>今天，我们自豪地宣布 Local Process with Kubernetes 的预览版已加入到 Visual Studio 2019 16.7 Preview 2 中。 Local Process</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/13678373.html</dc:identifier>
</item>
</channel>
</rss>