<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>libuv工作队列 - sherlock_lin</title>
<link>http://www.cnblogs.com/sherlock-lin/p/14342906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sherlock-lin/p/14342906.html</guid>
<description>&lt;p&gt;libuv 提供了一个线程池，可用于运行用户代码，libuv 中的工作队列中的任务会在线程池中执行&lt;/p&gt;
&lt;p&gt;libuv 中的线程池在内部用于运行所有文件系统操作以及 &lt;em&gt;&lt;strong&gt;getaddrinfo()&lt;/strong&gt;&lt;/em&gt; 和 &lt;em&gt;&lt;strong&gt;getnameinfo()&lt;/strong&gt;&lt;/em&gt; 请求&lt;/p&gt;
&lt;p&gt;libuv 中的线程池的默认数量为4，可以在启动时修改环境变量 &lt;em&gt;&lt;strong&gt;UV_THREADPOOL_SIZE&lt;/strong&gt;&lt;/em&gt; 来修改，最大值为 1024（1.30.0版本之前是128）&lt;/p&gt;
&lt;p&gt;libuv 中的线程池是全局的，并在所有事件循环之间共享，当特定的函数利用 &lt;em&gt;&lt;strong&gt;uv_queue_work()&lt;/strong&gt;&lt;/em&gt; 方法使用工作队列时，libuv 会预分配线程池，以较小的内存开销（128个线程为1MB），来提高线程性能&lt;/p&gt;
&lt;p&gt;以下三种类型的操作会在全局线程池中进行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文件系统操作；&lt;/li&gt;
&lt;li&gt;DNS函数（getaddrinfo 和 getnameinfo）；&lt;/li&gt;
&lt;li&gt;使用 &lt;em&gt;&lt;strong&gt;uv_queue_work()&lt;/strong&gt;&lt;/em&gt; 调度的用户代码；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要注意的是，即使使用了线程池，libuv 的方法也不是线程安全的&lt;/p&gt;

&lt;h2 id=&quot;21、uv_queue_work&quot;&gt;2.1、uv_queue_work&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int uv_queue_work(uv_loop_t* loop, 
                  uv_work_t* req, 
                  uv_work_cb work_cb, 
                  uv_after_work_cb after_work_cb);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加一个任务到工作队列中，在主线程中调用&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;loop&lt;/strong&gt;&lt;/em&gt;： 事件循环&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;req&lt;/strong&gt;&lt;/em&gt;： 传入到任务的数据，一般使用 req.data 参数传递&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;work_cb&lt;/strong&gt;&lt;/em&gt;： 执行方法&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;after_work_cb&lt;/strong&gt;&lt;/em&gt;： 执行方法完成后执行&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;work_cb&lt;/strong&gt;&lt;/em&gt; 方法会在函数中执行，&lt;em&gt;&lt;strong&gt;after_work_cb&lt;/strong&gt;&lt;/em&gt; 方法在创建线程中执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void (*uv_work_cb)(uv_work_t* req);
void (*uv_after_work_cb)(uv_work_t* req, int status);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果调用 &lt;em&gt;&lt;strong&gt;uv_cancel&lt;/strong&gt;&lt;/em&gt; 方法取消了队列，则 &lt;em&gt;&lt;strong&gt;uv_after_work_cb&lt;/strong&gt;&lt;/em&gt; 的 &lt;em&gt;&lt;strong&gt;status&lt;/strong&gt;&lt;/em&gt; 为 &lt;em&gt;&lt;strong&gt;UV_ECANCELED&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;22、uv_cancel&quot;&gt;2.2、uv_cancel&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int uv_cancel(uv_req_t* req);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取消未执行的队列中的任务，在任务中调用&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;req&lt;/strong&gt;&lt;/em&gt; 为任务的参数&lt;/p&gt;
&lt;p&gt;如果调用此方法取消了任务，则 &lt;em&gt;&lt;strong&gt;after_work_cb&lt;/strong&gt;&lt;/em&gt; 回调函数的 &lt;em&gt;&lt;strong&gt;status&lt;/strong&gt;&lt;/em&gt; 的值为 &lt;em&gt;&lt;strong&gt;UV_ECANCELED&lt;/strong&gt;&lt;/em&gt;；&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;uv.h&amp;gt;

void print(uv_work_t *req)
{
    sleep(1);
    long num = (long)req-&amp;gt;data;
    printf(&quot;thread id is: %ld, num is: %d\n&quot;, uv_thread_self(), num);
}

void after_print(uv_work_t *req, int status)
{
    printf(&quot;after print, req data is %d, status is %d\n&quot;, req-&amp;gt;data, status);
}

int main()
{
    uv_loop_t *loop = uv_default_loop();
    uv_work_t req[5];

    for (int index = 0; index &amp;lt; 5; index++)
    {
        req[index].data = (void *)(long)index;
        uv_queue_work(loop, &amp;amp;req[index], print, after_print);
        sleep(1);
    }

    return uv_run(loop, UV_RUN_DEFAULT);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例中的代码，每次执行 &lt;em&gt;&lt;strong&gt;print()&lt;/strong&gt;&lt;/em&gt; 方法都是在不同线程中，&lt;em&gt;&lt;strong&gt;after_print()&lt;/strong&gt;&lt;/em&gt; 方法和 &lt;em&gt;&lt;strong&gt;main()&lt;/strong&gt;&lt;/em&gt; 方法在同一个线程中&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jan 2021 00:32:00 +0000</pubDate>
<dc:creator>sherlock_lin</dc:creator>
<og:description>1、说明 libuv 提供了一个线程池，可用于运行用户代码，libuv 中的工作队列中的任务会在线程池中执行 libuv 中的线程池在内部用于运行所有文件系统操作以及 getaddrinfo() 和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sherlock-lin/p/14342906.html</dc:identifier>
</item>
<item>
<title>【Soul网关探秘】http数据同步-Admin通知前处理 - 腾业</title>
<link>http://www.cnblogs.com/tengye93/p/14342900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tengye93/p/14342900.html</guid>
<description>&lt;p&gt;soul-admin 端在发起变更通知前究竟作何处理？ 我们一起来探秘&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;165.62325160441&quot;&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;本篇开始研究 Soul 网关 http 数据同步，将分为三篇进行分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《Admin通知前处理》&lt;/li&gt;
&lt;li&gt;《变更通知机制》&lt;/li&gt;
&lt;li&gt;《Bootstrap处理变更通知》&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;希望三篇完结后能对 Soul 的 http 数据同步策略有所收获。&lt;/p&gt;
&lt;p&gt;本篇旨在探究 &lt;code&gt;soul-admin&lt;/code&gt; 端在发起变更通知前所做的处理。&lt;/p&gt;
&lt;p&gt;不同数据变更的处理模式应当是一致的，故本篇以 selector 配置变更为切入点进行深入。&lt;/p&gt;
&lt;h2 id=&quot;一、配置变更入口&quot;&gt;一、配置变更入口&lt;/h2&gt;
&lt;p&gt;找到 SelectorController，这是 selector 配置变更的入口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/stephenshen/pic-bed/raw/master/img/20210129065312.png&quot; alt=&quot;image-20210129065312321&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其持有一个 SelectorService 引用，通过 SelectorService 实现 selector 配置变更。&lt;/p&gt;
&lt;h2 id=&quot;二、配置变更服务&quot;&gt;二、配置变更服务&lt;/h2&gt;
&lt;p&gt;再来看看 SelectorService，实现了配置变更的具体处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/stephenshen/pic-bed/raw/master/img/20210129065816.png&quot; alt=&quot;image-20210129065816692&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其内部持有5个 mapper、1个 eventPublisher和1个 upstreamCheckService，对外提供一系列对 selector 的crud方法&lt;/p&gt;
&lt;p&gt;注意 createOrUpdate 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int createOrUpdate(final SelectorDTO selectorDTO) {
    int selectorCount;
    SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);
    List&amp;lt;SelectorConditionDTO&amp;gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();
    // 数据落库
    if (StringUtils.isEmpty(selectorDTO.getId())) {
        selectorCount = selectorMapper.insertSelective(selectorDO);
        selectorConditionDTOs.forEach(selectorConditionDTO -&amp;gt; {
            selectorConditionDTO.setSelectorId(selectorDO.getId());
            selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));
        });
    } else {
        selectorCount = selectorMapper.updateSelective(selectorDO);
        //delete rule condition then add
        selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));
        selectorConditionDTOs.forEach(selectorConditionDTO -&amp;gt; {
            selectorConditionDTO.setSelectorId(selectorDO.getId());
            SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);
            selectorConditionMapper.insertSelective(selectorConditionDO);
        });
    }
    // 发布 spring 事件
    publishEvent(selectorDO, selectorConditionDTOs);
    // 更新 divide 上游服务
    updateDivideUpstream(selectorDO);
    return selectorCount;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理策略是先落库，再发布 spring 事件，最后更新 divide 上游服务&lt;/p&gt;
&lt;h2 id=&quot;三、spring-事件通知机制&quot;&gt;三、spring 事件通知机制&lt;/h2&gt;
&lt;p&gt;此处涉及 spring 的事件通知机制，在此简要说明：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;ApplicationContext通过ApplicationEvent类和ApplicationListener接口提供事件处理。&lt;/p&gt;
&lt;p&gt;如果一个bean实现ApplicationListener接口在容器中,每次一个ApplicationEvent被发布到ApplicationContext中,这类bean就会收到这些通知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现Spring事件机制主要有4个类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ApplicationEvent：事件，每个实现类表示一类事件，可携带数据。&lt;/li&gt;
&lt;li&gt;ApplicationListener：事件监听器，用于接收事件处理时间。&lt;/li&gt;
&lt;li&gt;ApplicationEventMulticaster：事件管理者，用于事件监听器的注册和事件的广播。&lt;/li&gt;
&lt;li&gt;ApplicationEventPublisher：事件发布者，委托ApplicationEventMulticaster完成事件发布。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、soul-实现事件通知&quot;&gt;四、soul 实现事件通知&lt;/h2&gt;
&lt;p&gt;下面我们看看 Soul 是如何使用 spring 的时间通知机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/stephenshen/pic-bed/raw/master/img/20210129072813.png&quot; alt=&quot;image-20210129072813542&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DataChangedEvent 继承 ApplicationEvent，提供了 DataChangedEvent(groupKey, type, source) 事件构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件监听器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/stephenshen/pic-bed/raw/master/img/20210129072918.png&quot; alt=&quot;image-20210129072918112&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DataChangedEventDispatcher 实现了 ApplicationListener接口，借助 onApplicationEvent 方法监听事件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void onApplicationEvent(final DataChangedEvent event) {
    for (DataChangedListener listener : listeners) {
        switch (event.getGroupKey()) {
            case APP_AUTH:
                listener.onAppAuthChanged((List&amp;lt;AppAuthData&amp;gt;) event.getSource(), event.getEventType());
                break;
            case PLUGIN:
                listener.onPluginChanged((List&amp;lt;PluginData&amp;gt;) event.getSource(), event.getEventType());
                break;
            case RULE:
                listener.onRuleChanged((List&amp;lt;RuleData&amp;gt;) event.getSource(), event.getEventType());
                break;
            case SELECTOR:
                listener.onSelectorChanged((List&amp;lt;SelectorData&amp;gt;) event.getSource(), event.getEventType());
                break;
            case META_DATA:
                listener.onMetaDataChanged((List&amp;lt;MetaData&amp;gt;) event.getSource(), event.getEventType());
                break;
            default:
                throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法内按事件类型分别处理，DataChangedEventDispatcher 同时实现了 InitializingBean 接口，在初始化后完成 listeners 的注入。&lt;/p&gt;
&lt;h2 id=&quot;五、响应数据变更事件&quot;&gt;五、响应数据变更事件&lt;/h2&gt;
&lt;p&gt;上面的事件监听处理用到 soul 的 DataChangedListener 接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/stephenshen/pic-bed/raw/master/img/20210129073522.png&quot; alt=&quot;image-20210129073522328&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DataChangedListener 实现了不同类型事件的事件响应方法用于响应 DataChangedEvent 事件。&lt;/p&gt;
&lt;p&gt;1）AbstractDataChangedListener 的 onSelectorChanged 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void onSelectorChanged(final List&amp;lt;SelectorData&amp;gt; changed, final DataEventTypeEnum eventType) {
    if (CollectionUtils.isEmpty(changed)) {
        return;
    }
    // 更新 selector 缓存
    this.updateSelectorCache();
    // selector 变更后处理，实现具体的变更通知
    this.afterSelectorChanged(changed, eventType);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 selector 变更处理是先更缓存后发通知。&lt;/p&gt;
&lt;p&gt;2）AbstractDataChangedListener 的 updateSelectorCache 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void updateSelectorCache() {
    this.updateCache(ConfigGroupEnum.SELECTOR, selectorService.listAll());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）AbstractDataChangedListener 的 updateCache 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected &amp;lt;T&amp;gt; void updateCache(final ConfigGroupEnum group, final List&amp;lt;T&amp;gt; data) {
    String json = GsonUtils.getInstance().toJson(data);
    ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());
    ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);
    log.info(&quot;update config cache[{}], old: {}, updated: {}&quot;, group, oldVal, newVal);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到最终是创建对应的 ConfigDataCache 存入 CACHE。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇梳理了 &lt;code&gt;soul-admin&lt;/code&gt; 在真正发出数据变更通知前的处理脉络，其策略是：先写库后更缓存，最后发出数据变更通知。&lt;/p&gt;
&lt;p&gt;先写库保证数据不丢，另外在集群部署时，其他 &lt;code&gt;soul-admin&lt;/code&gt; 节点也可通过浏览页面时查库保证数据一致。&lt;/p&gt;
&lt;p&gt;意外学到 spring 的事件通知机制，soul 中的设计果真小巧精妙。&lt;/p&gt;
&lt;p&gt;下篇，将探究 http 同步策略的变更通知机制，期待惊喜。&lt;/p&gt;
&lt;h2 id=&quot;个人知识库&quot;&gt;个人知识库&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/tengye/vtss9i&quot; target=&quot;_blank&quot;&gt;高性能微服务API网关-Soul&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 29 Jan 2021 00:26:00 +0000</pubDate>
<dc:creator>腾业</dc:creator>
<og:description>soul-admin 端在发起变更通知前究竟作何处理？ 我们一起来探秘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tengye93/p/14342900.html</dc:identifier>
</item>
<item>
<title>jackson学习之四：WRAP_ROOT_VALUE（root对象） - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14342897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14342897.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章汇总&quot;&gt;系列文章汇总&lt;/h3&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;本文是《jackson学习》系列的第四篇，前面学习了常用API，可以执行最基本的序列化和反序列化操作，接下来要学习的就是jackson强大的注解能力，本篇要学的是root对象特性，主要内容如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关于root对象&lt;/li&gt;
&lt;li&gt;测试用的POJO类&lt;/li&gt;
&lt;li&gt;序列化实战&lt;/li&gt;
&lt;li&gt;反序列化实战&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;关于root对象（wrap_root_value）&quot;&gt;关于root对象（WRAP_ROOT_VALUE）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;对于只有&lt;span&gt;id&lt;/span&gt;和&lt;span&gt;name&lt;/span&gt;两个字段的POJO实例来说，正常的序列化结果如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;id&quot; : 1,
  &quot;name&quot; : &quot;book&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;jackson在序列化时，可以在上述json外面再包裹一层，官方叫做&lt;span&gt;WRAP_ROOT_VALUE&lt;/span&gt;，本文中叫做&lt;span&gt;root对象&lt;/span&gt;，如下所示，整个json的只有一个键值对，key是&lt;span&gt;aaabbbccc&lt;/span&gt;，value内部才是POJO实例的id和name字段的值：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;aaabbbccc&quot; : {
    &quot;id&quot; : 2,
    &quot;name&quot; : &quot;food&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提前小结&quot;&gt;提前小结&lt;/h3&gt;
&lt;p&gt;root对象特性提前做个小结，这样如果您时间有限，仅看这一节即可：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先看序列化场景：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;执行下面代码，jackson在序列化时会增加root对象：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;root对象的key，默认是实例的类名，如果实例有JsonRootName注解，就是该注解的value值；&lt;/li&gt;
&lt;li&gt;root对象的value如下所示，相当于&lt;span&gt;不支持root对象时的序列化结果&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;id&quot; : 1,
  &quot;name&quot; : &quot;book&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;再看反序列化场景：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;执行下面代码，jackson在反序列化时会先解析root对象：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;root对象的key，默认是实例的类名，如果实例有JsonRootName注解，就是该注解的value值；&lt;/li&gt;
&lt;li&gt;root对象的value如下所示，相当于&lt;span&gt;不支持root对象时用来反序列化的json字符串&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;id&quot; : 1,
  &quot;name&quot; : &quot;book&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;准备两个pojo类&quot;&gt;准备两个POJO类&lt;/h3&gt;
&lt;p&gt;用对比的方式可以更清楚了解JsonRootName的作用，接下来的学习咱们准备两个POJO类，一个没有JsonRootName注解，另一个有JsonRootName注解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;名为&lt;span&gt;Order1.java&lt;/span&gt;的，没有JsonRootName注解：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Order1 {
    private int id;
    private String name;
        // 省去get、set、toString方法
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;名为&lt;span&gt;Order2.java&lt;/span&gt;的，有JsonRootName注解，value值为&lt;span&gt;aaabbbccc&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.fasterxml.jackson.annotation.JsonRootName;

@JsonRootName(value = &quot;aaabbbccc&quot;)
public class Order2 {
        private int id;
    private String name;
        // 省去get、set、toString方法
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可见Order1和Order2的代码是一致的，唯一的不同是Order2带有注解JsonRootName；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;序列化&quot;&gt;序列化&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;需要设置WRAP_ROOT_VALUE属性，jackson才会支持root对象，JsonRootName注解才会发挥作用，设置代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;写一段代码，在不开启WRAP_ROOT_VALUE属性的时候执行序列化，再开启WRAP_ROOT_VALUE属性执行序列化，对比试试：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) throws Exception {
        // 实例化Order1和Order2
        Order1 order1 = new Order1();
        order1. setId(1);
        order1.setName(&quot;book&quot;);

        Order2 order2 = new Order2();
        order2. setId(2);
        order2.setName(&quot;food&quot;);

        // 没有开启WRAP_ROOT_VALUE的时候
        logger.info(&quot;没有开启WRAP_ROOT_VALUE\n&quot;);
        ObjectMapper mapper1 = new ObjectMapper();
        // 美化输出
        mapper1.enable(SerializationFeature.INDENT_OUTPUT);

        logger.info(&quot;没有JsonRootName注解类，序列化结果：\n\n{}\n\n&quot;, mapper1.writeValueAsString(order1));
        logger.info(&quot;有JsonRootName注解的类，序列化结果：\n\n{}\n\n\n\n&quot;, mapper1.writeValueAsString(order2));

        // 开启了WRAP_ROOT_VALUE的时候
        logger.info(&quot;开启了WRAP_ROOT_VALUE\n&quot;);
        ObjectMapper mapper2 = new ObjectMapper();
        // 美化输出
        mapper2.enable(SerializationFeature.INDENT_OUTPUT);
        // 序列化的时候支持JsonRootName注解
        mapper2.enable(SerializationFeature.WRAP_ROOT_VALUE);

        logger.info(&quot;没有JsonRootName注解类，序列化结果：\n\n{}\n\n&quot;, mapper2.writeValueAsString(order1));
        logger.info(&quot;有JsonRootName注解的类，序列化结果：\n\n{}&quot;, mapper2.writeValueAsString(order2));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;执行结果如下，JsonRootName在序列化时的作用一目了然：指定了root对象的key：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210129082337150-1671165597.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;反序列化（默认设置）&quot;&gt;反序列化（默认设置）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在没有做任何设置的时候，下面这个字符串用来反序列化成Order2对象，会成功吗？&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;id&quot; : 2,
  &quot;name&quot; : &quot;food&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;试了下是可以的：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210129082338357-795860758.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 那下面这个字符串能反序列化成Order2对象吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;aaabbbccc&quot; : {
    &quot;id&quot; : 2,
    &quot;name&quot; : &quot;food&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;代码和结果如下图所示，反序列化时jackson并不认识&lt;span&gt;aaabbbccc&lt;/span&gt;这个key，因为jackson此时并不支持root对象：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210129082340518-1068299396.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小结：默认情况下，反序列化时json字符串不能有root对象；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;反序列化（开启unwrap_root_value属性）&quot;&gt;反序列化（开启UNWRAP_ROOT_VALUE属性）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果开启了UNWRAP_ROOT_VALUE属性，用于反序列化的json字符串就必须要有root对象了，开启UNWRAP_ROOT_VALUE属性的代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;代码和结果如下图，可见带有root对象的json字符串，可以反序列化成功，root对象的key就是JsonRootName注解的value属性：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210129082341274-1631839837.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 值得注意的是，上述json字符串中，root对象的key为&lt;span&gt;aaabbbccc&lt;/span&gt;，这和Order2的&lt;span&gt;JsonRootName&lt;/span&gt;注解的value值是一致的，&lt;span&gt;如果不一致就会反序列化失败&lt;/span&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210129082342206-68813967.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至此，jackson的WRAP_ROOT_VALUE特性就学习完成了，在web开发时这是个很常用的功能，用于在最外面包裹一层，以便整体上添加额外的内容，希望能给您带来参考；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 29 Jan 2021 00:24:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14342897.html</dc:identifier>
</item>
<item>
<title>时间类型和时间戳 - schaepher</title>
<link>http://www.cnblogs.com/schaepher/p/14342808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/schaepher/p/14342808.html</guid>
<description>&lt;h2 id=&quot;unix-时间戳以及日期表示方法&quot;&gt;Unix 时间戳以及日期表示方法&lt;/h2&gt;
&lt;p&gt;Unix 时间戳表示的是从世界标准时间（UTC，Coordinated Universal Time）的 1970 年 1 月 1 日 0 时 0 分 0 秒开始的偏移量。&lt;/p&gt;
&lt;p&gt;全球共有 24 个时区，分为东西各 12 时区。所有地区在使用同一个时间戳的基础上，根据当地时区调整时间的表示。&lt;/p&gt;
&lt;p&gt;现在比较常见的日期和时间的表示标准是 ISO8601，或者在其基础上更加标准化的 RFC3339。&lt;/p&gt;
&lt;p&gt;举个例子，北京时间 2021 年 1 月 28 日 0 时 0 分 0 秒用 RFC3339 表示为：&lt;code&gt;2021-01-28T00:00:00+08:00&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+08:00&lt;/code&gt; 表示东 8 区，&lt;code&gt;2021-01-28T00:00:00&lt;/code&gt; 表示这个时区的人所看到的时间。加号如果改为减号，则表示西时区。&lt;/p&gt;
&lt;p&gt;比较特殊的是 UTC 时区，可以表示为 &lt;code&gt;2006-01-02T15:04:05+00:00&lt;/code&gt;，但通常简化为 &lt;code&gt;2006-01-02T15:04:05Z&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在使用的时候，应当根据时区调整时间的展示。例如 &lt;code&gt;1611792000&lt;/code&gt; 可以表示为 &lt;code&gt;2021-01-28T00:00:00Z&lt;/code&gt; 或者 &lt;code&gt;2021-01-28T08:00:00+08:00&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;日期和时间的解析&quot;&gt;日期和时间的解析&lt;/h2&gt;
&lt;p&gt;不同的数据来源很可能使用不同的时间表示方法。根据是否可读分成两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用数字表示的时间戳&lt;/li&gt;
&lt;li&gt;用字符串表示的年月日时分秒&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数字类型就不详细说明。&lt;/p&gt;
&lt;p&gt;字符串又根据是否有时区分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;2021-01-28 00:00:00&lt;/code&gt; 没有包含时区信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2021-01-28T08:00:00+08:00&lt;/code&gt; 包含了时区信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在解析没有包含时区信息的字符串时，通常要由程序员指定时区，否则默认为 UTC 时区。如果附带时区，那就可以不用另外指定。&lt;/p&gt;
&lt;p&gt;例如 Golang 的时间库，就有两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parse(layout, value string)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ParseInLocation(layout, value string, loc *Location)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在解析的时候，会先根据年月日时分秒计算出一个整数。接着看 value 是否包含时区信息。&lt;/p&gt;
&lt;p&gt;如果 value 包含时区，那么就会给解析后的整数加一个偏移量，这个偏移量由时区与 UTC 时区之间的位置关系决定。&lt;/p&gt;
&lt;p&gt;如果 value 不包含时区信息，Parse 会将其设置为 UTC 时区，ParseInLocation 会根据传入的时区调整解析出来的整数，并将时区设置为传入的时区。&lt;/p&gt;
&lt;h2 id=&quot;日期和时间的存储&quot;&gt;日期和时间的存储&lt;/h2&gt;
&lt;p&gt;和解析时一样，保存日期和时间的方式有多种。&lt;/p&gt;
&lt;p&gt;例如 Golang 的 Time ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type Time struct {
        wall uint64
        ext  int64
        loc *Location  // 位置。用于调整时间的表示。
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Golang 存储的不是 Unix 时间戳，但是会根据情况将其转换为时间戳。对于 loc 的修改不会对 Unix 时间戳产生影响，只会影响时间的展示形式。&lt;/p&gt;
&lt;p&gt;MongoDB 使用的 bson.Date 使用 int64 存储从 1970 年 1 月 1 日以来的毫秒数。&lt;/p&gt;
&lt;p&gt;MySQL 使用 DATETIME 类型存储不包含时区的年月日时分秒，查询时以 &lt;code&gt;YYYY-MM-DD HH:MM:SS&lt;/code&gt; 的形式展示。也可以用四个字节的 TIMESTAMP 类型存储 Unix 时间戳。&lt;/p&gt;
&lt;h2 id=&quot;时间戳的问题&quot;&gt;时间戳的问题&lt;/h2&gt;
&lt;p&gt;以前在保存时间戳的时候，通常都使用四个字节，也就是 32 位的有符号整数存储。&lt;/p&gt;
&lt;p&gt;把二进制的 &lt;code&gt;01111111 11111111 11111111 11111111&lt;/code&gt; 转化为十进制后得到 &lt;code&gt;2147483647&lt;/code&gt;，再转化为北京时间得到 &lt;code&gt;2038-01-19 11:14:07&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这就表示 32 位整数最多只能存储到 2038 年的时间，因此被称为 “2038 年问题”。&lt;/p&gt;
&lt;p&gt;比较新的一些项目会通过各种方式解决这个问题，通常是使用 64 位整数来存储时间戳。但使用方式各有不同。&lt;/p&gt;
&lt;p&gt;例如 Golang 使用了两个 64 位整数来存储。其中无法符号整数 wall，第一位表示是否有单调时间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果为 1，则表示有单调时间。&lt;br/&gt;wall 的 2~34 位存储自 1885 年 1 月 1 日 0 时 0 分 0 秒以来的秒数，35~64 位存储纳秒数。&lt;br/&gt;有符号的 64 位整数 ext 存储从进程启动以来的纳秒数（单调时间）。&lt;/li&gt;
&lt;li&gt;如果为 0，则表示没有单调时间。&lt;br/&gt;wall 的 2~64 不存储时间。&lt;br/&gt;有符号的 64 位整数 ext 存储从 0001 年 1 月 1 日 0 时 0 分 0 秒以来的秒数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MongoDB 则是使用 int64 存储从 1970 年 1 月 1 日以来的 UTC 毫秒数。&lt;/p&gt;
&lt;p&gt;MySQL 没有解决 TIMESTAMP 类型的问题，它始终是四个字节。因此如果要解决这个问题，最好使用 DATETIME。但是 DATETIME 也有问题，它没法存储时区。不过大多数应用都无需考虑时区问题，无需担心。&lt;/p&gt;
&lt;h2 id=&quot;时间的展示&quot;&gt;时间的展示&lt;/h2&gt;
&lt;p&gt;数据库都默认使用 UTC。如果不加以处理，存储到数据库的时间就会展示为与本地实际展示的时间不一致的形式。&lt;/p&gt;
&lt;p&gt;例如 MongoDB 存储的是从 1970 年 1 月 1 日以来的 UTC 毫秒数，像 Navicat 这种工具，会用 UTC 的形式展示时间。这样其他时区的人看起来就会不习惯。&lt;/p&gt;
&lt;p&gt;而 MySQL 就更难处理了，DATETIME 不带时区。&lt;/p&gt;
&lt;p&gt;解决这个问题有三种思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改数据库配置，改成本地时区&lt;br/&gt;MongoDB 这样设置不会有影响，仍然存储的是毫秒数。只是在展示的时候会使用配置的时区格式化字符串。&lt;br/&gt;MySQL 这样设置后，会对 NOW() 这种函数的结果产生影响。不会对 SQL 语句中直接写 &lt;code&gt;0000-00-00 00:00:00&lt;/code&gt; 的情况产生影响。&lt;/li&gt;
&lt;li&gt;查询的时候将其重新转换为本地时区&lt;br/&gt;有三种：
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;为数据库连接会话设置时区。同上，只是在会话级别产生影响。&lt;br/&gt;MySQL 会有影响，如果不同地方的会话设置不同时区，又使用了 NOW()，得到的结果不一致。&lt;/li&gt;
&lt;li&gt;在代码上做一层包装，用于调整时区。&lt;br/&gt;MongoDB 没啥影响，毕竟存储的是毫秒数。只是展示的时候做个调整。&lt;br/&gt;MySQL 可以始终存储为 UTC 形式，然后要展示的时候，用代码把时间格式化为本地时区的形式。&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;为数据库表创建 view，在 view 里面处理时区&lt;br/&gt;例如 MongoDB：
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;db.createView(&quot;view_name&quot;,&quot;collection_name&quot;,[
    {
        $addFields: {
            date: {
                $dateToString: {
                    date: &quot;$date&quot;,
                    format: &quot;%Y-%m-%dT%H:%M:%S+08:00&quot;,
                    timezone: &quot;+08:00&quot;
                }
            }
        }
    }
]);
&lt;/code&gt;
&lt;/pre&gt;
addFields 会覆盖同名的字段。上面的语句会将原先的 date 字段的值以新的格式展示。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;存储的时候创建一个年月日时分秒和本地展示时间一致的 UTC 时间&lt;br/&gt;这会改变数据库存储的时间戳，使得时间戳与实际时间戳不一致。对 MongoDB 会产生影响。&lt;br/&gt;不过 MySQL 的 DATETIME 不是用时间戳，所以只要格式化到 SQL 语句的时间形式是本地时区的就行了。只是如果出现跨时区的用户、数据、开发人员，处理起来就比较麻烦。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;具体实例&quot;&gt;具体实例&lt;/h2&gt;
&lt;h4 id=&quot;golang-mongodb-库&quot;&gt;Golang MongoDB 库&lt;/h4&gt;
&lt;p&gt;MongoDB 的官方库在存储的时候，会使用 UTC 的时间戳。但在查询的时候，会判断是否设置了使用本地时间展示。如果没有设置按本地时间展示，则会将 Time 设置为 UTC 时区。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;if !tc.UseLocalTimeZone {
    timeVal = timeVal.UTC()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何事先配置好？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;builder := bsoncodec.NewRegistryBuilder()

// 注册默认的编码和解码器
bsoncodec.DefaultValueEncoders{}.RegisterDefaultEncoders(builder)
bsoncodec.DefaultValueDecoders{}.RegisterDefaultDecoders(builder)

// 注册时间解码器
tTime := reflect.TypeOf(time.Time{})
tCodec := bsoncodec.NewTimeCodec(bsonoptions.TimeCodec().SetUseLocalTimeZone(true))
registry := builder.RegisterTypeDecoder(tTime, tCodec).Build()

client, err := mongo.NewClient(options.Client().ApplyURI(uri), options.Client().SetRegistry(registry))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MongoDB 使用的 bson.Date 使用 int64 存储 1970 年 1 月 1 日以来的毫秒数。从 MongoDB 查出来的也是这个数据。&lt;/p&gt;
&lt;p&gt;如果 decode 的时候指定了存储结果的结构体的时间字段的类型，如 time.Time。则会将 int64 转化为 time.Time。如果不指定，则返回 int64。&lt;/p&gt;
&lt;p&gt;可见 MongoDB 官方库使用的是第二种思路。&lt;/p&gt;
&lt;h4 id=&quot;golang-mysql-驱动的实例&quot;&gt;Golang MySQL 驱动的实例&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/go-sql-driver/mysql#loc&quot; target=&quot;_blank&quot;&gt;https://github.com/go-sql-driver/mysql#loc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要在连接的时候设置。dsn 里面带上 loc 参数。&lt;/p&gt;
&lt;p&gt;在解析查询结果中的 DateTime 类型的时候，会将字节转换为字符串形式。这个字符串形式最长的情况是 &lt;code&gt;0000-00-00 00:00:00.0000000&lt;/code&gt;。驱动会根据实际长度解析。&lt;/p&gt;
&lt;p&gt;MySQL 驱动的做法是，如果 dsn 有带 loc 参数，那么在解析年月日时分秒和毫秒后，以这些数据和时区创建 time.Time。即 &lt;code&gt;time.Date(y, mo, d, h, mi, s, t.Nanosecond(), loc)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而在 insert 操作时，会将 time.Time 设置为指定的时区。&lt;code&gt;v.In(mc.cfg.Loc).AppendFormat(b, timeFormat)&lt;/code&gt;，这里的 v 就是我们 Insert 的类型为 time.Time 的值。&lt;/p&gt;
&lt;p&gt;可见 MySQL 驱动使用的是第三种思路。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jan 2021 18:21:00 +0000</pubDate>
<dc:creator>schaepher</dc:creator>
<og:description>Unix 时间戳以及日期表示方法 Unix 时间戳表示的是从世界标准时间（UTC，Coordinated Universal Time）的 1970 年 1 月 1 日 0 时 0 分 0 秒开始的偏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/schaepher/p/14342808.html</dc:identifier>
</item>
<item>
<title>FastAPI项目实战：SayHello(FastAPI + vue.js + axios + element ui 翻自Flask版的SayHello) - zy7y</title>
<link>http://www.cnblogs.com/zy7y/p/14342777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zy7y/p/14342777.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这次带来的是FastAPI + vue.js + axios + element ui (一个html文件里使用的) 实现的《Flask Web开发实战_入门、进阶与原理解析（李辉著 ）》 中的实战项目SayHello&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;本尊&lt;/strong&gt;&lt;a href=&quot;https://github.com/greyli/sayhello&quot; target=&quot;_blank&quot;&gt;sayhello- flask&lt;/a&gt; :: Demo- | &lt;a href=&quot;http://sayhello.helloflask.com/&quot; target=&quot;_blank&quot;&gt;http://sayhello.helloflask.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zy7y/blog_images/raw/master/img/20210129010618.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;俺的翻版&lt;a href=&quot;https://github.com/zy7y/sayhello.git&quot; target=&quot;_blank&quot;&gt;sayhello-fastapi&lt;/a&gt;:: Demo &lt;s&gt;暂时只上线了后端服务&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zy7y/blog_images/raw/master/img/20210129010849.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各位可以直接去github/gitee上下载源码 打开 static/message.html 中的baseURL如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;...
 &amp;lt;/div&amp;gt;

  &amp;lt;script&amp;gt;
    // axios 配置
    instance = axios.create({
      // baseURL: 'http://127.0.0.1:8000' // 本地运行使用这个地址
      baseURL: 'http://49.232.203.244:8000', // 先以上线的后端服务
      timeout: 5000,
    });

    let app = new Vue({
      el: &quot;#app&quot;,
      data: {
      ....
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;后面会将整套服务部署到云服务器上,所以可能会随时失效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zy7y/blog_images/raw/master/img/20210129011424.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&quot;https://github.com/zy7y/sayhello&quot; target=&quot;_blank&quot;&gt;https://github.com/zy7y/sayhello&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitee: &lt;a href=&quot;https://gitee.com/zy7y/sayhello&quot; target=&quot;_blank&quot;&gt;https://gitee.com/zy7y/sayhello&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原版Flask: 源码地址&lt;/strong&gt;: &lt;a href=&quot;https://github.com/greyli/sayhello&quot; target=&quot;_blank&quot;&gt;https://github.com/greyli/sayhello&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;这一下来 给我的感觉，前端真难顶~~&lt;/li&gt;
&lt;li&gt;之前的blog接口可能会大改，整体规范打算接着翻《Flask Web开发实战_入门、进阶与原理解析（李辉著 ）》中的 blueblog项目， flask源码：&lt;a href=&quot;https://github.com/greyli/bluelog&quot; target=&quot;_blank&quot;&gt;https://github.com/greyli/bluelog&lt;/a&gt; ， flask-Demo &lt;a href=&quot;http://bluelog.helloflask.com/&quot; target=&quot;_blank&quot;&gt;http://bluelog.helloflask.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;前端还得好好学学，冲哈&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 28 Jan 2021 17:23:00 +0000</pubDate>
<dc:creator>zy7y</dc:creator>
<og:description>简介 这次带来的是FastAPI + vue.js + axios + element ui (一个html文件里使用的) 实现的《Flask Web开发实战_入门、进阶与原理解析（李辉著 ）》 中的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zy7y/p/14342777.html</dc:identifier>
</item>
<item>
<title>.net core 和 WPF 开发升讯威在线客服与营销系统：使用 TCP协议 实现稳定的客服端 - sheng.chao</title>
<link>http://www.cnblogs.com/sheng_chao/p/14342731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng_chao/p/14342731.html</guid>
<description>&lt;p&gt;本系统文章详细介绍使用 .net core 和 WPF 开发升讯威在线客服与营销系统的过程。本篇简要介绍了如何使用 TCP 协议实现客服端通信。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;134.14177784922&quot;&gt;
&lt;p&gt;本系列文章详细介绍使用 .net core 和 WPF 开发 升讯威在线客服与营销系统 的过程。本产品已经成熟稳定并投入商用。&lt;br/&gt;在线演示环境：&lt;a href=&quot;https://kf.shengxunwei.com&quot; target=&quot;_blank&quot;&gt;https://kf.shengxunwei.com&lt;/a&gt; 注意：演示环境仅供演示交流与评估，不保证 7x24 小时可用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.shengxunwei.com/Home/Post/44a31a32-d4e1-4ddd-8526-8a2bcd2e22be&quot; target=&quot;_blank&quot;&gt;文章目录列表请点击这里&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;对于在线客服与营销系统，客服端指的是后台提供服务的客服或营销人员，他们使用客服程序在后台观察网站的被访情况，开展营销活动或提供客户服务。在本篇文章中，我将详细介绍如何在 .net core 环境下使用 TCP 通信技术实现稳定高效与安全的客服端程序。&lt;/p&gt;
&lt;p&gt;这里存在几个技术难点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要使客服端程序具备 24 小时不间断运行的能力，在处理网络通信时，必须100%的稳定。&lt;/li&gt;
&lt;li&gt;必须具备应对网络波动的能力，不能网络稍有波动就断线。即使出现了短暂的网络中断，客服程序也不能做掉线处理，而是要具备保持和自动重连的能力。&lt;/li&gt;
&lt;li&gt;要考虑安全性问题，服务端的端口监听，要能识别正常客服端连接，还是来自攻击者的连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;访客端实现的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-api.shengxunwei.com/StaticFiles/Upload/eff58aa5-8c86-4d8f-8f54-aca3caca06d1.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访客端在手机上的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-api.shengxunwei.com/StaticFiles/Upload/26425a7b-3e19-4af4-92c9-3b80c1ec5c36.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后台客服的实现效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-api.shengxunwei.com/StaticFiles/Upload/48026b95-5939-49cb-8175-5c0a33666924.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;在服务端上通过-tcplistener-监听客服连接&quot;&gt;在服务端上通过 TcpListener 监听客服连接&lt;/h3&gt;
&lt;p&gt;TcpListener类提供了简单的方法，这些方法在阻止同步模式下侦听和接受传入连接请求。 可以使用 TcpClient 或 Socket 来连接 TcpListener 。 TcpListener使用 IPEndPoint 、本地 IP 地址和端口号或仅端口号创建一个。 Any为本地 IP 地址指定，如果希望基础服务提供商为你分配这些值，则为0。 如果你选择执行此操作，则可以在 LocalEndpoint 套接字连接后使用属性来标识分配的信息。&lt;/p&gt;
&lt;p&gt;使用 Start 方法开始侦听传入连接请求。 Start将排队传入的连接，直到调用 Stop 方法或已将其排入队列 MaxConnections 。 使用 AcceptSocket 或 AcceptTcpClient 从传入连接请求队列请求连接。 这两种方法将会阻止。 如果要避免阻塞，可以 Pending 先使用方法来确定队列中是否有连接请求。&lt;br/&gt;调用 Stop 方法以关闭 TcpListener 。&lt;/p&gt;
&lt;p&gt;下面的代码示例创建一个 TcpListener 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;

class MyTcpListener
{
  public static void Main()
  {
    TcpListener server=null;
    try
    {
      // Set the TcpListener on port 13000.
      Int32 port = 13000;
      IPAddress localAddr = IPAddress.Parse(&quot;127.0.0.1&quot;);

      // TcpListener server = new TcpListener(port);
      server = new TcpListener(localAddr, port);

      // Start listening for client requests.
      server.Start();

      // Buffer for reading data
      Byte[] bytes = new Byte[256];
      String data = null;

      // Enter the listening loop.
      while(true)
      {
        Console.Write(&quot;Waiting for a connection... &quot;);

        // Perform a blocking call to accept requests.
        // You could also use server.AcceptSocket() here.
        TcpClient client = server.AcceptTcpClient();
        Console.WriteLine(&quot;Connected!&quot;);

        data = null;

        // Get a stream object for reading and writing
        NetworkStream stream = client.GetStream();

        int i;

        // Loop to receive all the data sent by the client.
        while((i = stream.Read(bytes, 0, bytes.Length))!=0)
        {
          // Translate data bytes to a ASCII string.
          data = System.Text.Encoding.ASCII.GetString(bytes, 0, i);
          Console.WriteLine(&quot;Received: {0}&quot;, data);

          // Process the data sent by the client.
          data = data.ToUpper();

          byte[] msg = System.Text.Encoding.ASCII.GetBytes(data);

          // Send back a response.
          stream.Write(msg, 0, msg.Length);
          Console.WriteLine(&quot;Sent: {0}&quot;, data);
        }

        // Shutdown and end connection
        client.Close();
      }
    }
    catch(SocketException e)
    {
      Console.WriteLine(&quot;SocketException: {0}&quot;, e);
    }
    finally
    {
       // Stop listening for new clients.
       server.Stop();
    }

    Console.WriteLine(&quot;\nHit enter to continue...&quot;);
    Console.Read();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在客服端使用-tcpclient-连接到服务器&quot;&gt;在客服端使用 TcpClient 连接到服务器&lt;/h3&gt;
&lt;p&gt;TcpClient 类提供了在同步阻止模式下通过网络连接、发送和接收流数据的简单方法。&lt;br/&gt;为了 TcpClient 连接和交换数据， TcpListener Socket 使用 TCP 创建的或 ProtocolType 必须侦听传入连接请求。 可以通过以下两种方式之一连接到此侦听器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个 TcpClient 并调用三个可用方法中的一个 Connect 。&lt;/li&gt;
&lt;li&gt;TcpClient使用远程主机的主机名和端口号创建一个。 此构造函数将自动尝试连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们使用下面的代码建立一个客服端连接程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static void Connect(String server, String message)
{
  try
  {
    // Create a TcpClient.
    // Note, for this client to work you need to have a TcpServer
    // connected to the same address as specified by the server, port
    // combination.
    Int32 port = 13000;
    TcpClient client = new TcpClient(server, port);

    // Translate the passed message into ASCII and store it as a Byte array.
    Byte[] data = System.Text.Encoding.ASCII.GetBytes(message);

    // Get a client stream for reading and writing.
   //  Stream stream = client.GetStream();

    NetworkStream stream = client.GetStream();

    // Send the message to the connected TcpServer.
    stream.Write(data, 0, data.Length);

    Console.WriteLine(&quot;Sent: {0}&quot;, message);

    // Receive the TcpServer.response.

    // Buffer to store the response bytes.
    data = new Byte[256];

    // String to store the response ASCII representation.
    String responseData = String.Empty;

    // Read the first batch of the TcpServer response bytes.
    Int32 bytes = stream.Read(data, 0, data.Length);
    responseData = System.Text.Encoding.ASCII.GetString(data, 0, bytes);
    Console.WriteLine(&quot;Received: {0}&quot;, responseData);

    // Close everything.
    stream.Close();
    client.Close();
  }
  catch (ArgumentNullException e)
  {
    Console.WriteLine(&quot;ArgumentNullException: {0}&quot;, e);
  }
  catch (SocketException e)
  {
    Console.WriteLine(&quot;SocketException: {0}&quot;, e);
  }

  Console.WriteLine(&quot;\n Press Enter to continue...&quot;);
  Console.Read();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;本文对使用 TCP 协议搭建客服端通信框架进行了简要的介绍，在接下来的文章中，我将具体解构服务端程序的结构和设计、客服端程序的结构和设计，敬请关注。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在线演示环境：&lt;a href=&quot;https://kf.shengxunwei.com&quot; target=&quot;_blank&quot;&gt;https://kf.shengxunwei.com&lt;/a&gt; 注意：演示环境仅供演示交流与评估，不保证 7x24 小时可用。&lt;/p&gt;
&lt;p&gt;联系QQ: 279060597&lt;br/&gt;联系E-mail：C5118@outlook.com&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 28 Jan 2021 16:48:00 +0000</pubDate>
<dc:creator>sheng.chao</dc:creator>
<og:description>本系统文章详细介绍使用 .net core 和 WPF 开发升讯威在线客服与营销系统的过程。本篇简要介绍了如何使用 TCP 协议实现客服端通信。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sheng_chao/p/14342731.html</dc:identifier>
</item>
<item>
<title>【Azure Developer】在Azure Resource Graph Explorer中查看当前订阅下的所有资源信息列表并导出（如VM的名称，IP地址内网/公网，OS,区域等) - 路边两盏灯</title>
<link>http://www.cnblogs.com/lulight/p/14342556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulight/p/14342556.html</guid>
<description>&lt;h2&gt;问题描述&lt;/h2&gt;
&lt;p&gt;通过Azure的&lt;a href=&quot;https://portal.azure.cn/#blade/HubsExtension/ArgQueryBlade&quot; target=&quot;_blank&quot;&gt;Resource Graph Explorer&lt;/a&gt;（&lt;a href=&quot;https://portal.azure.cn/#blade/HubsExtension/ArgQueryBlade&quot; target=&quot;_blank&quot;&gt;https://portal.azure.cn/#blade/HubsExtension/ArgQueryBlade&lt;/a&gt;），可以查看到当前列表中的各种资源并导出CSV格式，以便日常的管理或生成Power BI等报表的源数据。&lt;/p&gt;

&lt;p&gt;如查看&lt;strong&gt;虚拟机，MySQL，Redis，Application Gateway(应用程序网关)，VNET(虚拟网络)，公共IP&lt;/strong&gt;等资源信息。只要找到这些资源的类型(type)后就可以写类SQL语句(Kusto)。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202101/2127802-20210128224238967-492371227.png&quot; width=&quot;926&quot; height=&quot;520&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;查询语句&lt;/h2&gt;
&lt;p&gt;上图中的SQL语句非常的简单，只是根据类型列出部分信息。 查询语句内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;resources 
| where &lt;/span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.compute/virtualmachines&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.network/virtualnetworks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.network/publicipaddresses&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.cache/redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.network/applicationGateways&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.dbformysql/servers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
|project  id, name, &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;, sku
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;where&lt;/strong&gt; ： 指定查询的过滤条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;project&lt;/strong&gt; ：只输出后面列出的属性值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而如果需要非常与其他资源的信息关联查询，则需要使用到 &lt;span&gt;&lt;strong&gt;leftouter&lt;/strong&gt;&lt;/span&gt; 等。如在问题描述中提到的要查看VM的内网IP地址和公网IP地址，由于内网IP地址属于虚拟网络资源的信息，而公网IP地址也是属于publicipaddresses的资源信息，所以需要使用两次&lt;span&gt;&lt;strong&gt;leftouter&lt;/strong&gt; &lt;/span&gt;来关联VM信息查询。&lt;/p&gt;
&lt;p&gt;完整的类SQL语句为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Resources
| where &lt;/span&gt;&lt;span&gt;type&lt;/span&gt; =~ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.compute/virtualmachines&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
|project name, OS&lt;/span&gt;=&lt;span&gt;tostring&lt;/span&gt;&lt;span&gt;(properties.storageProfile.osDisk.osType), location, 
ipid &lt;/span&gt;= tolower(&lt;span&gt;tostring&lt;/span&gt;(properties.networkProfile.networkInterfaces[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].id))
&lt;span&gt;| join kind&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt;leftouter (&lt;/span&gt;
    Resources
    | where &lt;/span&gt;&lt;span&gt;type&lt;/span&gt; =~ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.network/networkinterfaces&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    | project ipid &lt;/span&gt;= tolower(id), elasticPoolName =&lt;span&gt; name, 
    privateIP &lt;/span&gt;= properties.ipConfigurations[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].properties.privateIPAddress, 
    publicIPid &lt;/span&gt;= properties.ipConfigurations[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].properties.publicIPAddress.id)
on ipid
| project&lt;/span&gt;-&lt;span&gt;away ipid
| project name, OS, location, privateIP, pubipid&lt;/span&gt;=tolower(&lt;span&gt;tostring&lt;/span&gt;&lt;span&gt;(publicIPid))
&lt;span&gt;| join kind&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt;leftouter (&lt;/span&gt;
    Resources
    | where &lt;/span&gt;&lt;span&gt;type&lt;/span&gt; =~ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.network/publicipaddresses&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    | project pubipid &lt;/span&gt;= tolower(id), publicIP =&lt;span&gt; properties.ipAddress)
on pubipid
| project&lt;/span&gt;-&lt;span&gt;away pubipid
| project name, privateIP,publicIP, OS, location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一次leftouter关联查询时候用的是私网IP地址资源的ID作为关联条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ipid = tolower(tostring(properties.networkProfile.networkInterfaces[0].id)) 为从VM资源中获取的私网IP资源ID&lt;/li&gt;
&lt;li&gt;ipid = tolower(id) 为类型'microsoft.network/networkinterfaces'的资源ID&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二次leftouter关联查询时候用的是公网IP地址资源的ID作为关联条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;publicIPid = properties.ipConfigurations[0].properties.publicIPAddress.id为从第一个leftouter表中获取到公网IP资源ID, 为了保持与第二个leftouter中的字段名一致，所以在project中转换列名pubipid=tolower(tostring(publicIPid))&lt;/li&gt;
&lt;li&gt;pubipid = tolower(id) 为类型'microsoft.network/networkinterfaces'的资源ID&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;主表数据和leftouter关联表数据使用的&lt;span&gt;&lt;strong&gt;on&lt;/strong&gt;&lt;/span&gt;关键字表示关联条件。&lt;/p&gt;
&lt;p&gt;　　| project-away pubipid ：表示在结果中移除pubipid字段显示。详见：&lt;span data-ttu-id=&quot;7ffc3-103&quot;&gt;project-away 运算符: &lt;a href=&quot;https://docs.microsoft.com/zh-cn/azure/data-explorer/kusto/query/projectawayoperator&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/azure/data-explorer/kusto/query/projectawayoperator&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;以上查询语句的结果如图：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202101/2127802-20210128231005080-2013884461.png&quot; width=&quot;1119&quot; height=&quot;520&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;查看MySQL数据库信息，显示数据库服务名，配置和资源所在区域信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;resources 
| where &lt;/span&gt;&lt;span&gt;type&lt;/span&gt; =~ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.dbformysql/servers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
| project  name, properties, location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看Redis数据库信息，显示服务名，配置和资源所在区域信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;resources 
| where &lt;/span&gt;&lt;span&gt;type&lt;/span&gt; =~ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.cache/redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
| project  name, properties, location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看虚拟网络(VNET)信息，显示网络名，配置的内网网段，资源所在区域信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;resources 
| where &lt;/span&gt;&lt;span&gt;type&lt;/span&gt; =~ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.network/virtualnetworks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
| project  name, addressPrefixes&lt;/span&gt;=&lt;span&gt;tostring&lt;/span&gt;(properties.addressSpace.addressPrefixes[&lt;span&gt;0&lt;/span&gt;]), location
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看Application Gateway(应用程序网关)信息，显示服务名称，配置和资源所在区域信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;resources 
| where &lt;/span&gt;&lt;span&gt;type&lt;/span&gt; =~ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;microsoft.network/applicationGateways&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
| project  name, properties, location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;配置信息从properties中查找，为JSON数据。可通过对象方式获取，如properties.addressSpace.addressPrefixes[0]。&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Kusto查询语句示例&lt;/strong&gt;：&lt;a href=&quot;https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.microsoft.com%2Fzh-cn%2Fazure%2Fdata-explorer%2Fkusto%2Fquery%2Fsamples%3Fpivots%3Dazuredataexplorer&amp;amp;data=04%7C01%7Cbulu%40microsoft.com%7C7cdedb96049f4f489e0e08d8c336596a%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637473985631344764%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C1000&amp;amp;sdata=0Je2Tgh%2B%2BeA%2FMXEWT1KbKGJPz5Oqx7k4FPqIZev2Puc%3D&amp;amp;reserved=0&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/azure/data-explorer/kusto/query/samples?pivots=azuredataexplorer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202101/2127802-20210128231853078-222233797.png&quot; width=&quot;730&quot; height=&quot;520&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 28 Jan 2021 15:20:00 +0000</pubDate>
<dc:creator>路边两盏灯</dc:creator>
<og:description>问题描述 通过Azure的Resource Graph Explorer（https://portal.azure.cn/#blade/HubsExtension/ArgQueryBlade），可以查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lulight/p/14342556.html</dc:identifier>
</item>
<item>
<title>join 查询优化 - 萌新J</title>
<link>http://www.cnblogs.com/mengxinJ/p/14290700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengxinJ/p/14290700.html</guid>
<description>&lt;p&gt;&lt;span&gt;在开发中往往会出现查询多表联查的情况，那么就会用到 join 查询。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Join查询种类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;为了方便说明，先定义一个统一的表，下面再做例子。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `t2` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `a` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `b` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; `a` (`a`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;表 t1、t2 结构相等，t2 1000条记录， t1 100 条记录，t1 的数据在 t2 上都有。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Index Nested-Loop Join（NLJ）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;关于 NLJ 可以从名字上直接看出，这是一个使用到索引的 join 查询，正因为使用到索引，所以不需要用到临时表。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;select * from t1 straight_join t2 on (t1.a=t2.a);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;straight_join&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;：相当于强制版的 inner join。因为在使用 inner join 或 join 连接时，优化器默认使用的都是小表作为驱动表，但是如果排序或筛选条件列是被驱动表，那么该列的索引就会用不到，比如 &lt;/span&gt;&lt;span&gt;select * from a inner join b where a.id=b.aid order by a.id，&lt;/span&gt;&lt;span&gt;&lt;span&gt;如果a的集合比b大，那么mysql就会以b为驱动表，这个时候如果a.id有索引的话，那么这个索引在 order by 排序时是不起效的（on 筛选时可以用到，&lt;span&gt;排序只能通过驱动表排序&lt;/span&gt;）&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;那么就需要额外排序，甚至用到临时表，非常消耗性能，而 straight_join 的作用就是强制让左表作为驱动表，当然使用前提是在事先知道优化器选择的驱动表效率较低，然后才可以考虑使用 straight_join 。这里就是为了防止优化器选择错误的驱动表，当然，这里使用 inner join 也是会以 t1 小表作为基础表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;执行过程&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、从表 t1 中读入一行数据 R；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、从数据行 R 中，取出 a 字段到表 t2 里去查找；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4、重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个过程步骤1 会遍历 t1 所有的行，所以一共会扫描100行。 而步骤2 因为会用到索引，所以每次扫描一次，一共扫描 100 行。最后拼接在一起，所以一共扫描 200 行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210118213520551-704000183.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;351&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;公式&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设被驱动表的行数是 M。每次在被驱动表查一行数据，要先搜索索引 a，再搜索主键索引。每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;假设驱动表的行数是 N，执行过程就要扫描驱动表 N 行，然后对于每一行，到被驱动表上匹配一次。因此整个执行过程，近似复杂度是 N + N*2*log2M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由此看来，不考虑其他因素的影响（比如上面straight_join 说到的情况），&lt;span&gt;&lt;strong&gt;NLJ 方式以小表作为驱动表的效率会更高&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;Simple Nested-Loop Join&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;没有用到索引。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;select * from t1 straight_join t2 on (t1.a=t2.b);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;执行过程&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先因为 straight_join 的作用，还是以 t1 为驱动表。执行时还是先从 t1 上取一条记录取 t2 上寻找对应的记录，但是因为 t2 的 b 列上没有索引，所以在 t2 上执行的是全表扫描。所以扫描行数为 100+100*1000。所以 Simple Nested-Loop Join 的效率很低，这种方式也是没有被 MySQL 采用。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;Block Nested-Loop Join（BNJ）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这种方式也是没有用到索引，但是和上面一种的区别是在内存中实现的。主要思路是将驱动表加载到一个内存空间 join_buffer 中，然后从被驱动表上每次拿出一条记录到 join_buffer 中找到符合条件的记录，然后返回。join_buffer 大小可由参数 join_buffer_size 设定，默认值是 256k。在 explain 中出现 Block Nested Loop 说明使用的是 BNJ 算法，BNJ 执行效率比较低，所以应该避免。 &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;select * from t1 straight_join t2 on (t1.a=t2.b);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;执行过程&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如果 join_buffer 空间足够存储 t1 所有记录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2）扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。需要注意的是，&lt;span&gt;因为 join_buffer 是无序数组，所以虽然 t1 的a 列有索引，在这一步寻找时也不会用到索引&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210118215919925-1284553747.png&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;423&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、如果 join_buffer 空间不能存储 t1 的所有记录。那么就会分批来处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）扫描表 t1，顺序读取数据行放入 join_buffer 中，放完第 88 行 join_buffer 满了，继续第 2 步；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2）扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　3）清空 join_buffer；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　4）继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210118220056888-994004075.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;465&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：以上这两种扫描的总行数都是一样的。 1、将 t1扫描进 join_buffer 100行；2、t2 每行去 joiin_buffer 上进行全表扫描 100*t2总行数1000。所以总行数为 100 +100*1000。和上面的 Simple Nested-Loop Join 方式扫描的行数一样，但是因为使用的 join_buffer 是在内存中的，所以执行的速度会比 Simple Nested-Loop Join 快得多。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公式&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设，驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。那么扫描行数就是 N+λ*N*M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由此可以看出，驱动表参与筛选的记录数越少，扫描的行数就越少，效率也就越高。也就是在不考虑其他因素的影响下，&lt;span&gt;以小表为驱动表可以提高 BNJ方式的执行效率&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;优化&lt;/h2&gt;
&lt;h3&gt;Index Nested-Loop Join（NLJ）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;NLJ 查询过程中会用到索引，所以查询的效率会很快，但是其还是有优化空间的，那就是 MySQL 5.6引入的 Batched Key Access(BKA) 算法。其原理就是通过 MRR 实现顺序读，因为之前的 NLJ 过程是每次拿一条记录去匹配，然后得到对应的一条记录，这样每次获取的记录主键很有可能不是按顺序去查询的，同时多次的查询使得执行效率比较低（每次都需要从 B+树的根节点开始查找匹配）。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;MRR&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;MRR 会先将要查询的记录主键添加到 read_rnd_buffer中（如果放不下就分多次进行），对 read_rnd_buffer 中的 id 进行递增排序，然后再依次按 id 去查询，经过 MRR 优化的执行就会走 B+ 树的叶子节点，所以查询效率提高。下面以 sql：select * from t1 where a&amp;gt;=1 and a&amp;lt;=100 为例，其中 a 列有索引，看一下开启 MRR 执行的流程图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210127223214338-53312856.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;349&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开启&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;设置：SET  @@optimizer_switch='mrr=on,mrr_cost_based=on';&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相关参数：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当mrr=on,mrr_cost_based=on，则表示cost base的方式还选择启用MRR优化,当发现优化后的代价过高时就会不使用该项优化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当mrr=on,mrr_cost_based=off（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用 MRR，把 mrr_cost_based 设置为 off，就是固定使用 MRR 了。），则表示总是开启MRR优化。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果查询使用了 MRR 优化，那么使用 explain 解析就会出现 Using MRR 的提示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210127225130496-247211756.png&quot; alt=&quot;&quot; width=&quot;690&quot; height=&quot;65&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;BKA&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;使用 BKA 的过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是以上面的 select * from t1 straight_join t2 on (t1.a=t2.b); 为例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210127222105749-210615613.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;359&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先将 t1 的筛选字段存入 join_buffer（如果存不下就分多次执行），然后将存储的字段值批量去 t2 上匹配，得到匹配的主键，然后进行主键排序，再去依次查询对应的记录返回。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;Block Nested-Loop Join（BNJ）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;BNJ 造成性能损失很高，主要原因有以下三个方面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、可能会多次扫描被驱动表，占用磁盘 IO 资源；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率&lt;span&gt;&lt;strong&gt;（影响严重）&lt;/strong&gt;&lt;/span&gt;。通过 &lt;a href=&quot;https://www.cnblogs.com/mengxinJ/p/14071262.html#_label1_1&quot; target=&quot;_blank&quot;&gt;InnoDB 中的缓冲池(Buffer Pool)&lt;/a&gt; 可以知道缓冲池是使用了 LRU 算法来对热点数据进行了优化的，但是在某些情况下还是会出现热点数据被挤掉的场景，使用 BNJ 进行多次的查询就是其中一种，因为 BNJ 操作如果涉及的表数据量比较大，那么用到的数据也很多，那么如果在使用到后面某一时刻某个会话也查询了某个冷门数据，那么因为之前 BNJ 也查询了，并且中间的时间间隔达到了最大老年时间，所以这个冷门数据就会进入老年代头部，挤掉其他热点数据。&lt;strong&gt;大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;优化思路1&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：减少 BNJ 的循环次数，上面说到，多次的扫描被驱动表会长时间占用磁盘 IO 资源，造成系统整体性能下降。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;span&gt;：增大 join_buffer_size 的值，减少对被驱动表的扫描次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;优化思路2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：将 BNJ 优化成 NLJ。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1&lt;/strong&gt;&lt;span&gt;：在筛选条件字段使用率比较高时，可以考虑为其创建一个索引，这样在执行时因为有索引就会变成 NLJ 了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法2&lt;/strong&gt;&lt;span&gt;：如果筛选字段使用率很低，为其创建索引会提高维护的成本，做到得不偿失，那么该如何优化？答案是可以使用临时表，从 &lt;a href=&quot;https://www.cnblogs.com/mengxinJ/p/14295708.html&quot; target=&quot;_blank&quot;&gt;MySQL 中的临时表&lt;/a&gt; 可以知道，临时表会随着会话的结束而自动销毁，省去了维护的成本；同时不同会话可以创建同名的临时表，不会产生冲突。这使得临时表成为优化筛选字段使用率低的 BNJ 查询的绝佳方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例：假设有表 t1、t2，&lt;/span&gt;&lt;span&gt;表 t1 里，插入了 1000 行数据， t2 中插入了 100 万行数据 。执行 select * from t1 join t2 on (t1.b=t2.b) where t2.b&amp;gt;=1 and t2.b&amp;lt;=2000; b 列使用率很低&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　未优化前执行&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、把表 t1 的所有字段取出来，存入 join_buffer 中。这个表只有 1000 行，join_buffer_size 默认值是 256k，可以完全存入。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2、扫描表 t2，取出每一行数据跟 join_buffer 中的数据进行对比，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　1）如果不满足 t1.b=t2.b，则跳过；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　2）如果满足 t1.b=t2.b, 再判断其他条件，也就是是否满足 t2.b 处于[1,2000]的条件，如果是，就作为结果集的一部分返回，否则跳过。整个筛选过程一共扫描了 1000*1000000 = 10亿行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　优化思路&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、把表 t2 中满足条件的数据放在临时表 tmp_t 中；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2、为了让 join 使用 BKA 算法，给临时表 tmp_t 的字段 b 加上索引；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　3、让表 t1 和 tmp_t 做 join 操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　实现&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;temporary&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; temp_t(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;, a &lt;span&gt;int&lt;/span&gt;, b &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;(b))engine&lt;span&gt;=&lt;/span&gt;&lt;span&gt;innodb;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; temp_t &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t2 &lt;span&gt;where&lt;/span&gt; b&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; b&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;join&lt;/span&gt; temp_t &lt;span&gt;on&lt;/span&gt; (t1.b&lt;span&gt;=&lt;/span&gt;temp_t.b);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　过程消耗：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、执行 insert 语句构造 temp_t 表并插入数据的过程中，对表 t2 做了全表扫描，这里扫描行数是 100 万。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2、之后的 join 语句，扫描表 t1，这里的扫描行数是 1000；join 比较过程中，做了 1000 次带索引的查询（因为t1 1000行，作为驱动表，t2作为被驱动表）。相比于优化前的 join 语句需要做 10 亿次条件判断来说，这个优化效果还是很明显的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;strong&gt;进一步优化&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　临时表又分为磁盘临时表和内存临时表，使用内存临时表效率比磁盘临时表高，上面的引擎是 innodb，也就是磁盘临时表，如果换成 Memory 引擎就是内存临时表。但是相对的内存临时表只能存储2000行数据，所以在数据量特别大时还是应该使用磁盘临时表。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;三张表优化&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;表结构：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `t1` (
 `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
 `a` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
 `b` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
 `c` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;InnoDB;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t2 &lt;span&gt;like&lt;/span&gt;&lt;span&gt; t1;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t3 &lt;span&gt;like&lt;/span&gt;&lt;span&gt; t2;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; ... &lt;span&gt;//&lt;/span&gt;初始化三张表的数据
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如何优化语句：&lt;/span&gt;&lt;span&gt;select * from t1 join t2 on(t1.a=t2.a) join t3 on (t2.b=t3.b) where t1.c&amp;gt;=X and t2.c&amp;gt;=Y and t3.c&amp;gt;=Z;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：首先根据where 三个条件来判断哪个表符合条件的返回的字段长度最小，将最小的作为驱动表。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、第一种情况，如果选出来是表 t1 或者 t3，那剩下的部分就固定了。（因为 join 顺序是 t1、t2、t3，确定小表直接向另一个方向驱动就可以了）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1）如果驱动表是 t1，则连接顺序是 t1-&amp;gt;t2-&amp;gt;t3，要在被驱动表字段创建上索引，也就是 t2.a 和 t3.b 上创建索引；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2）如果驱动表是 t3，则连接顺序是 t3-&amp;gt;t2-&amp;gt;t1，需要在 t2.b 和 t1.a 上创建索引。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同时，我们还需要在第一个驱动表的字段 c 上创建索引。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、第二种情况是，如果选出来的第一个驱动表是表 t2 的话，则需要评估另外两个条件的过滤效果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总之，整体的思路就是，尽量让每一次参与 join 的驱动表的数据集，越小越好，因为这样我们的驱动表就会越小。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;NLJ 原本是不需要用到 join_buffer 的，但是可以通过 BKA 优化使用 join_buffer ，&lt;strong&gt;此时方向是使用在 join_buffer 中的驱动表数据去被驱动表上匹配&lt;/strong&gt;，然后得到主键，排序、回表返回结果，如果 read_rnd_buffer 或者 join_buffer 空间不够就分多次进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BNL 原本没有用到索引，所以必须使用 join_buffer 来帮助查询，&lt;strong&gt;方向是被驱动表到 join_buffer 上的驱动表数据进行匹配&lt;/strong&gt;，优化后变成 BKA 算法的 NLJ，所以方向也就&lt;strong&gt;变成了使用在 join_buffer 中的驱动表数据去被驱动表上匹配&lt;/strong&gt;。所以在 BNL 优化前的思路就是减少被驱动表的遍历次数，也就是增大 join_buffer 的大小；而优化后就需要在被驱动表上创建索引，来优化查询。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;join 的 on 条件与 where 条件的关联&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;表结构：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; a(f1 &lt;span&gt;int&lt;/span&gt;, f2 &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;(f1))engine&lt;span&gt;=&lt;/span&gt;&lt;span&gt;innodb;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; b(f1 &lt;span&gt;int&lt;/span&gt;, f2 &lt;span&gt;int&lt;/span&gt;)engine&lt;span&gt;=&lt;/span&gt;&lt;span&gt;innodb;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; a &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;),(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;),(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;),(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;),(&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; b &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;),(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;),(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;),(&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;),(&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;),(&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;on 条件写在 where 中可能会使外连接失效&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;以上面的表结构，执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; a &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; b &lt;span&gt;on&lt;/span&gt;(a.f1&lt;span&gt;=&lt;/span&gt;b.f1) &lt;span&gt;and&lt;/span&gt; (a.f2&lt;span&gt;=&lt;/span&gt;b.f2); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Q1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; a &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; b &lt;span&gt;on&lt;/span&gt;(a.f1&lt;span&gt;=&lt;/span&gt;b.f1) &lt;span&gt;where&lt;/span&gt; (a.f2&lt;span&gt;=&lt;/span&gt;b.f2);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Q2&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210128110910015-2123256783.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;244&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;分析&lt;/span&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q1：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210128111110220-161117631.png&quot; alt=&quot;&quot; width=&quot;849&quot; height=&quot;79&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为是以 a 作为驱动表，而 a 的 f1有索引，f2没有索引，所以会用到临时表来筛选，也就出现 using join buffer（Block hested Loop）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、把表 a 的内容读入 join_buffer 中。因为是 select * ，所以字段 f1 和 f2 都被放入 join_buffer 了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、顺序扫描表 b，对于每一行数据，判断 join 条件（也就是 (a.f1=b.f1) and (a.f1=1)）是否满足，满足条件的记录, 作为结果集的一行返回。如果语句中有 where 子句，需要先判断 where 部分满足条件后，再返回。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、表 b 扫描完成后，对于没有被匹配的表 a 的行（在这个例子中就是 (1,1)、(2,2) 这两行），把剩余字段补上 NULL，再放入结果集中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210128114736517-1553813293.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;470&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;&lt;span&gt;Q2：&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210128115340558-936538219.png&quot; alt=&quot;&quot; width=&quot;742&quot; height=&quot;105&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么Q2执行会把 null 值部分过滤掉了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是因为在 where 条件中，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。这里包括， select NULL = NULL 的结果，也是返回 NULL。&lt;/span&gt;&lt;span&gt;所以在筛选时，先通过 on 判断带 null 的记录，但是因为 where 条件的作用，会筛掉其中为 null 的记录，导致 left join 失效，所以优化器在实际执行时会将这条语句优化成 inner join，并把筛选条件移到 where 条件后面。整个语句就会被优化成下面的语句执行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210128120315471-136159146.png&quot; alt=&quot;&quot; width=&quot;725&quot; height=&quot;110&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是 select a.f1, a.f2, b.f1, b.f2 from  a  join  b  where a.f1 = b.f1 and a.f2=b.f2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以过程就变成：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;顺序扫描表 b，每一行用 b.f1 到表 a 中去查，匹配到记录后判断 a.f2=b.f2 是否满足（索引下推），满足条件的话就作为结果集的一部分返回。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;所以，如果想要执行外连接查询，筛选条件就不能写在 where 中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;内连接可能会将on条件优化成 where 条件&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; a &lt;span&gt;join&lt;/span&gt; b &lt;span&gt;on&lt;/span&gt;(a.f1&lt;span&gt;=&lt;/span&gt;b.f1) &lt;span&gt;and&lt;/span&gt; (a.f2&lt;span&gt;=&lt;/span&gt;b.f2); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Q3&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; a &lt;span&gt;join&lt;/span&gt; b &lt;span&gt;on&lt;/span&gt;(a.f1&lt;span&gt;=&lt;/span&gt;b.f1) &lt;span&gt;where&lt;/span&gt; (a.f2&lt;span&gt;=&lt;/span&gt;b.f2);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Q4&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202101/2012006-20210128143500247-1979373338.png&quot; alt=&quot;&quot; width=&quot;753&quot; height=&quot;373&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到两条语句解析结果是一模一样的，并且执行语句也与这两条语句都不一样，都被优化成 select * from a join b where a.f1=b.f1 and a.f2=b.f2 。执行过程和上面的 Q2 一样。这是因为如果放在 on 中就会用到临时表，效率会低一些，所以优化器直接优化放在 where 中配合索引下推通过索引一并完成判断。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jan 2021 15:07:00 +0000</pubDate>
<dc:creator>萌新J</dc:creator>
<og:description>在开发中往往会出现查询多表联查的情况，那么就会用到 join&amp;#160;查询。 Join查询种类 为了方便说明，先定义一个统一的表，下面再做例子。 CREATE TABLE `t2` ( `id` i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengxinJ/p/14290700.html</dc:identifier>
</item>
<item>
<title>Shell从入门到精通 - 编程我的一切</title>
<link>http://www.cnblogs.com/qishun/p/14342483.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qishun/p/14342483.html</guid>
<description>&lt;p&gt;熟悉基本shell操作不仅是运维的基本功，对于开发来说也是多多益善，我在学习的过程中，总结了十个练手的小demo，并附上涉及的知识点，仅供娱乐。&lt;/p&gt;
&lt;hr id=&quot;hr-toc&quot;/&gt;&lt;h2 id=&quot;1.%20%E5%A4%9A%E7%BA%BF%E7%A8%8Bping%E7%9B%91%E6%8E%A7%EF%BC%8C%E6%A3%80%E6%9F%A5%E5%90%8C%E4%B8%80%E7%BD%91%E6%AE%B5%E7%9A%84IP%E6%98%AF%E5%90%A6%E8%BF%9E%E9%80%9A&quot;&gt;1. 多线程ping监控，检查同一网段的IP是否连通&lt;/h2&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;Linux 系统中有一个特殊的设备&lt;strong&gt;/dev/null&lt;/strong&gt;，这是一个黑洞。无论往该文件中写入多少数据，都会被系统吞噬、丢弃。如果有些输出信息是我们不再需要的， 则可以使用重定向将输出信息导入该设备文件中。注意：数据一旦导入黑洞将无法找回。&lt;/li&gt;
&lt;li&gt;重定向: &amp;gt; 是覆盖重定向, &amp;gt;&amp;gt; 是累加重定向&lt;/li&gt;
&lt;li&gt;$0 这个程式的执行名字&lt;br/&gt;$n 这个程式的第n个参数值，n=1..9&lt;br/&gt;$* 这个程式的所有参数,此选项参数可超过9个。&lt;br/&gt;$# 这个程式的参数个数&lt;br/&gt;$$ 这个程式的PID(脚本运行的当前进程ID号)&lt;br/&gt;$! 执行上一个背景指令的PID(后台运行的最后一个进程的进程ID号)&lt;br/&gt;$? 执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误)&lt;br/&gt;$- 显示shell使用的当前选项，与set命令功能相同&lt;br/&gt;$@ 跟$*类似，但是可以当作数组用&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&amp;amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;amp;&lt;br/&gt;&amp;amp;&amp;amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ &amp;amp;&amp;amp; echo '2'&lt;br/&gt;| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l&lt;br/&gt;|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo &quot;fail&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ping 命令语法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;ping [-dfnqrRv][-c&amp;lt;完成次数&amp;gt;][-i&amp;lt;间隔秒数&amp;gt;][-I&amp;lt;网络界面&amp;gt;][-l&amp;lt;前置载入&amp;gt;][-p&amp;lt;范本样式&amp;gt;][-s&amp;lt;数据包大小&amp;gt;][-t&amp;lt;存活数值&amp;gt;][主机名称或IP地址]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
#使用&amp;amp;开启后台进程
net=&quot;101.200.35&quot;

mult_ping() {
        ping -c2 -i0.2 -W1 $1 &amp;amp;&amp;gt;/dev/null
        if [ $? -eq 0 ];then
                echo &quot;$1 is up&quot;
        else
                echo &quot;$1 is down&quot;
        fi
}

for i in {0..255}
do
        mult_ping $net.$i &amp;amp;
done
wait
                              &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124221641141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODk1NzQ3,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;622&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2.%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%8A%9F%E8%83%BD%E6%98%BE%E7%A4%BA&quot;&gt;2.进度条功能显示&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;常见系统预设变量&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124210348976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODk1NzQ3,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;455&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash

trap 'kill $!' INT
# 定义宽度为50的进度条
# 输出完成后将/r光标切换到行首，准备下一次进度条显示
bar () {
        while :
                pound=&quot;&quot;
                for ((i = 47; i&amp;gt;=1; i-- ))
                do      
                        pound += #
                        printf &quot;|%s%${i}s|\r&quot; &quot;$pound&quot;
                        sleep 0.2
                done    
                
        }       
        
# 调用函数，显示进度符号，直到复制结束kill进度函数
bar &amp;amp;
cp -r $1 $2
kill $!
echo &quot;复制结束&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3.%20Linux%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F&quot;&gt;3. Linux创建进程的三种方式&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;fork&lt;br/&gt;通常情况下在系统中通过相对路径或绝对路径执行一个命令时，都会由父进程开启一个子进程，当子进程结束后再返回父进程，这种行为过程就叫作fork。&lt;strong&gt;当脚本中正常调用一个外部命令 1或其他脚本时，都会fork一个子Shell进程，我们的命令会运行在这个子Shell中。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;exec&lt;br/&gt;使用 exec 方式调用其他命令或脚本时，系统不会开启子进程，&lt;strong&gt;而是使用新的程序替换当前的 Shell 环境&lt;/strong&gt;，因为当前 Shell 环境被替换了，所以当 exec 调用的程序结束后，当前环境会被关闭。但是有一个特例，当 exec 后面的参数是&lt;strong&gt;文件重定向&lt;/strong&gt;时，不会替换当前 Shell 环境，脚本后续的其他命令也不会受到任何影响。&lt;/li&gt;
&lt;li&gt;source或 . （点）&lt;br/&gt;使用 source 命令或.（点）可以不开启子 Shell，而在当前 Shell 环境中将需要执行的命令加载进来，执行完加载的命令后，继续执行脚本中后续的指令。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;分析工具：pstree 进程树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124221353595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODk1NzQ3,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;831&quot; height=&quot;526&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.%20%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B%E6%95%B0%E9%87%8F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93&quot;&gt;4. 控制进程数量——文件描述符和命名管道&lt;/h2&gt;
&lt;h3 id=&quot;%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6&quot;&gt;文件描述符&lt;/h3&gt;
&lt;p&gt;文件描述符是一个非负整数，而内核需要通过这个文件描述符才可以访问文件。当我们在系统中打开已有的文件或新建文件时，内核每次都会给特定的进程返回一个文件描述符，当进程需要对文件进行读或写操作时，都要依赖这个文件描述符进行。&lt;strong&gt;文件描述符就像一本书的目录页数（也叫索引），通过这个索引可以找到需要的内容。&lt;/strong&gt;在 Linux 或类 UNIX系统中内核默认会为每个进程创建三个标准的文件描述符，分别是 0（标准输入）、 1（标准输出）和 2（标准错误）。通过查看/proc/PID 号/fd/目录下的文件，就可以查看每个进程拥有的所有文件描述符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建文件描述符：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec 文件描述符 &amp;lt;&amp;gt; 文件名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;调用文件描述符语法格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;文件描述符&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关闭文件描述符：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec 文件描述符&amp;lt;&amp;amp;-
exec 文件描述符&amp;gt;&amp;amp;-&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93&quot;&gt;命名管道&lt;/h3&gt;
&lt;p&gt;管道是进程间通信的一种方式，匿名管道，使用|符号就可以创建一个匿名管道，顾名思义，系统会自动创建一个可以读写数据的管道，但是这个管道并没有名称。一个程序往管道中写数据，另一个程序就可以从管道中读取数据。但是&lt;strong&gt;匿名管道仅可以实现父进程与子进程之间的数据交换&lt;/strong&gt;，能不能实现任意两个无关的进程之间的通信呢？答案是肯定的，使用命名管道，也叫FIFO1文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名管道的特征：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; FIFO 文件由命令创建（mknod 或 mkfifo 命令），可以在文件系统中直接看到。&lt;/li&gt;
&lt;li&gt;写入管道的数据一旦被读取后，就不可以再重复读取。&lt;/li&gt;
&lt;li&gt;进程往命名管道中写数据时，如果没有其他进程读取数据，则写进程会被阻塞。&lt;/li&gt;
&lt;li&gt;进程尝试从命名管道中读取数据时，如果管道中没有数据，则读进程会被阻塞。&lt;/li&gt;
&lt;li&gt;命名管道中的数据常驻内存，并不实际写入磁盘，读写效率会更高。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;5.%20%E5%8F%AF%E4%BB%BB%E6%84%8F%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8Bping&quot;&gt;5. 可任意控制进程数量的多线程ping&lt;/h2&gt;
&lt;p&gt;第一个demo中，通过 &amp;amp; 开启任意数量线程进行ping，但是这里的线程不可控。我们用上面的文件描述符和命名管道的知识，写一段可控的多线程ping。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
  
pipefile=/tmp/procs_$$.temp
num=10
net=&quot;101.200.35&quot;

multi_ping() {
        ping -c2 -i0.2 -W1 $1 &amp;amp;&amp;gt;/dev/null
        if [ $? -eq 0 ];then
                echo &quot;$1 is up&quot;
        else
                echo &quot;$1 is down&quot;
        fi
}
# 创建命名管道文件，创建其文件描述符，通过重定向将数据导入管道文件
mkfifo $pipefile
exec 12&amp;lt;&amp;gt;$pipefile
for i in `seq $num`
do
        echo &quot;&quot; &amp;gt;&amp;amp;12 &amp;amp;
done
# 成功读取命名管道中的数据后开启新的进程
# 所有内容读取完之后read被阻塞，无法再启动新的进程
# 等待前面启动的线程结束后，继续往管道文件中写入数据，释放阻塞，再次开启新的线程
for j in {1..254}
do
        read -u12
        {
                multi_ping $net.$j
                echo &quot;&quot; &amp;gt;&amp;amp;12
        } &amp;amp;
done
wait
rm -rf $pipfile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210125131929657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODk1NzQ3,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;695&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6.%20sed%E7%88%AC%E8%99%AB%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87&quot;&gt;6. sed爬虫批量下载美女图片&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;下载思路：用curl获取网站源代码+sed数据清洗获取图片地址+wget下载保存&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
# 爬取美女图片

# 定义要爬取的网站和保存的文件
page=&quot;https://tieba.baidu.com/p/4420470629&quot;
URL=&quot;beau.txt&quot;
# 将网站源代码保存到文件中
curl -s https://tieba.baidu.com/p/4420470629 &amp;gt; $URL
# 对源代码数据过滤清洗，获取种子的URL链接
echo -e &quot;\033[32m 正在获取种子 URL,请稍后...\033[0m&quot;
sed -i '/&amp;lt;img/!d' $URL #删除不包含&amp;lt;img 的行
sed -i 's/.*src=&quot;//' $URL #删除 src=&quot;及其前面的所有内容
sed -i 's/&quot;.*//' $URL #删除双引号及其后面的所有内容
echo

#利用循环批量下载所有图片数据
#wget 为下载工具,其参数选项描述如下：
# -P 指定将数据下载到特定目录(prefix)
# -c 支持断点续传(continue)
# -q 不显示下载过程(quiet)
echo -e &quot;\033[32m 正在批量下载种子数据,请稍后...\033[0m&quot;
for i in $(cat $URL)
do
        wget -P tempPhoto/ -c $i
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128110246445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODk1NzQ3,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;573&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128110229951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODk1NzQ3,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;663&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128110307664.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种知识最基本的爬虫，对于反爬虫的网站就嗝屁了，对于那种异步加载的也没办法，总之，就是比较弱。&lt;/p&gt;
&lt;h2 id=&quot;7.%20sed%E9%9A%8F%E6%9C%BA%E7%82%B9%E5%90%8D%E5%99%A8&quot;&gt;7. sed随机点名器&lt;/h2&gt;
&lt;p&gt;做一个互联网大佬的随机点名器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128172523482.gif&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
#按 Ctrl+C 组合键时:恢复光标,恢复终端属性,清屏,退出脚本
#防止程序意外中断导致的终端混乱
trap 'tput cnorm;stty $save_property;clear;exit' 2
#定义变量:人员列表文件名,文件的行数,屏幕的行数,屏幕的列数
name_file=&quot;name.txt&quot;
line_file=$(sed -n '$=' $name_file)
line_screen=`tput lines`
column_screen=`tput cols`
#设置终端属性
save_property=$(stty -g) #保存当前终端所有属性
tput civis #关闭光标
#随机抽取一个人名(随机点名)
while :
do
        tmp=$(sed -n &quot;$[RANDOM%line_file+1]p&quot; $name_file)
        #随机获取文件的某一行人名
        tput clear #清屏
        tput cup $[line_screen/4] $[column_screen/4]
        echo -e &quot;\033[3;5H 随机点名器(按 P 停止): &quot;
        echo -e &quot;\033[4;5H#############################&quot;
        echo -e &quot;\033[5;5H# #&quot;
        echo -e &quot;\033[6;5H#\t\t$tmp\t\t#&quot;
        echo -e &quot;\033[7;5H# #&quot;
        echo -e &quot;\033[8;5H#############################&quot;
        sleep 0.1
        stty -echo
        read -n1 -t0.1 input
        if [[ $input == &quot;p&quot; || $input == &quot;P&quot; ]];then
                break
        fi
done
tput cnorm #恢复光标
stty $save_property #恢复终端属性
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;8.%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E8%84%9A%E6%9C%AC&quot;&gt;8.系统性能监控脚本&lt;/h2&gt;

&lt;h2 id=&quot;9.%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81&quot;&gt;9.监控网络连接状态&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ss语法格式&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128221333627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODk1NzQ3,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;763&quot; height=&quot;335&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
# 监控网络连接状态
#所有 TCP 连接的个数
TCP_Total=$(ss -s | awk '$1==&quot;TCP&quot;{print $2}')
#所有 UDP 连接的个数
UDP_Total=$(ss -s | awk '$1==&quot;UDP&quot;{print $2}')
#所有 UNIX sockets 连接个数
Unix_sockets_Total=$(ss -ax | awk 'BEGIN{count=0} {count++} END{print
count}')
#所有处于 Listen 监听状态的 TCP 端口个数
TCP_Listen_Total=$(ss -antlpH | awk 'BEGIN{count=0} {count++} END{print
count}')
#所有处于 ESTABLISHED 状态的 TCP 连接个数
TCP_Estab_Total=$(ss -antpH | awk 'BEGIN{count=0} /^ESTAB/{count++}
END{print count}')
#所有处于 SYN-RECV 状态的 TCP 连接个数
TCP_SYN_RECV_Total=$(ss -antpH | awk 'BEGIN{count=0} /^SYN-RECV/{count++}
END{print count}')
#所有处于 TIME-WAIT 状态的 TCP 连接个数
TCP_TIME_WAIT_Total=$(ss -antpH | awk 'BEGIN{count=0} /^TIME-WAIT/{count++}
END{print count}')
#所有处于 TIME-WAIT1 状态的 TCP 连接个数
TCP_TIME_WAIT1_Total=$(ss -antpH | awk 'BEGIN{count=0}
/^TIME-WAIT1/{count++} END{print count}')
#所有处于 TIME-WAIT2 状态的 TCP 连接个数
TCP_TIME_WAIT2_Total=$(ss -antpH | awk 'BEGIN{count=0}
/^TIME-WAIT2/{count++} END{print count}')
#所有远程主机的 TCP 连接次数
TCP_Remote_Count=$(ss -antH | awk '$1!~/LISTEN/{IP[$5]++} END{ for(i in
IP){print IP[i],i} }' | sort -nr)
#每个端口被访问的次数
TCP_Port_Count=$(ss -antH | sed -r 's/ +/ /g' | awk -F&quot;[ :]&quot;
'$1!~/LISTEN/{port[$5]++} END{for(i in port){print port[i],i}}' | sort -nr)
#定义输出颜色
SUCCESS=&quot;echo -en \\033[1;32m&quot; #绿色
NORMAL=&quot;echo -en \\033[0;39m&quot; #黑色
#显示 TCP 连接总数
tcp_total(){
        echo -n &quot;TCP 连接总数: &quot;
        $SUCCESS
        echo &quot;$TCP_Total&quot;
        $NORMAL
} 
#显示处于 LISTEN 状态的 TCP 端口个数
tcp_listen(){
        echo -n &quot;处于 LISTEN 状态的 TCP 端口个数: &quot;
        $SUCCESS
        echo &quot;$TCP_Listen_Total&quot;
        $NORMAL
} 
#显示处于 ESTABLISHED 状态的 TCP 连接个数
tcp_estab(){
        echo -n &quot;处于 ESTAB 状态的 TCP 连接个数: &quot;
        $SUCCESS
        echo &quot;$TCP_Estab_Total&quot;
        $NORMAL
} 
#显示处于 SYN-RECV 状态的 TCP 连接个数
tcp_syn_recv(){
        echo -n &quot;处于 SYN-RECV 状态的 TCP 连接个数: &quot;
        $SUCCESS
        echo &quot;$TCP_SYN_RECV_Total&quot;
        $NORMAL
} 
#显示处于 TIME-WAIT 状态的 TCP 连接个数
tcp_time_wait(){
        echo -n &quot;处于 TIME-WAIT1 状态的 TCP 连接个数: &quot;
        $SUCCESS
        echo &quot;$TCP_TIME_WAIT1_Total&quot;
        $NORMAL
} 
#显示处于 TIME-WAIT2 状态的 TCP 连接个数
tcp_time_wait2(){
        echo -n &quot;处于 TIME-WAIT2 状态的 TCP 连接个数: &quot;
        $SUCCESS
        echo &quot;$TCP_TIME_WAIT2_Total&quot;
        $NORMAL
} 
#显示 UDP 连接总数
udp_total(){
        echo -n &quot;UDP 连接总数: &quot;
        $SUCCESS
        echo &quot;$UDP_Total&quot;
        $NORMAL
} 
#显示 UNIX sockets 连接总数
unix_total(){
        echo -n &quot;Unix sockets 连接总数: &quot;
        $SUCCESS
        echo &quot;$Unix_sockets_Total&quot;
        $NORMAL
} 
#显示每个远程主机的访问次数
remote_count(){
        echo &quot;每个远程主机与本机的并发连接数: &quot;
        $SUCCESS
        echo &quot;$TCP_Remote_Count&quot;
        $NORMAL
} 
#显示每个端口的并发连接数
port_count(){
        echo &quot;每个端口的并发连接数: &quot;
        $SUCCESS
        echo &quot;$TCP_Port_Count&quot;
        $NORMAL
}

print_info(){
        echo -e &quot;------------------------------------------------------&quot;
        $1
}
print_info tcp_total
print_info tcp_listen
print_info tcp_estab
print_info tcp_syn_recv
print_info tcp_time_wait
print_info tcp_time_wait1
print_info tcp_time_wait2
print_info udp_total
print_info unix_total
print_info remote_count
print_info port_count
echo -e &quot;------------------------------------------------------&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128222308382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODk1NzQ3,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;547&quot;/&gt;&lt;/p&gt;


&lt;blockquote&gt;
&lt;h2 id=&quot;%E5%8F%82%E8%80%83&quot;&gt;参考&lt;/h2&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 28 Jan 2021 15:00:00 +0000</pubDate>
<dc:creator>编程我的一切</dc:creator>
<og:description>熟悉基本shell操作不仅是运维的基本功，对于开发来说也是多多益善，我在学习的过程中，总结了十个练手的小demo，并附上涉及的知识点，仅供娱乐。 1. 多线程ping监控，检查同一网段的IP是否连通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qishun/p/14342483.html</dc:identifier>
</item>
<item>
<title>一篇文章带你初步了解—CSS特指度 - _Fatman</title>
<link>http://www.cnblogs.com/liujingjiu/p/14342387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liujingjiu/p/14342387.html</guid>
<description>&lt;p&gt;单个选择器的特指度按照 !important &amp;gt; id选择符 &amp;gt; class选择符、属性选择符和伪类 &amp;gt; 元素选择符和伪元素的规律排序，如果遇到组合选择器，则按其逻辑将其拆分为单个选择器后相加再进行判断。如果选择器中的声明包含了!important，则这条属性会覆盖同属性所有不包含了!important的声明，只有在同属性的声明也包含!important，并且同属性的声明位于的选择器的特指度大于先前的选择器，亦或两个选择器的特指度相当，但同属性的声明位于的选择器位于先前的选择器之后时，才会覆盖先前的选择器的加了!important的属性。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;271&quot;&gt;

&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这篇博客在在两台电脑上分别完成的，故而有些截图是Firefox，有些是Chrome，有些改动了浏览器的用户样式表，有些没改，但不会影响阅读，特此说明，勿怪。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;css选择器&quot;&gt;CSS选择器&lt;/h2&gt;
&lt;h3 id=&quot;单个css选择器&quot;&gt;单个CSS选择器&lt;/h3&gt;
&lt;p&gt;css选择器决定css样式能渲染到对应的元素上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元素选择器：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1604228/202101/1604228-20210128223039987-498312966.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class选择器：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1604228/202101/1604228-20210128223040955-1003484265.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;ID选择器：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1604228/202101/1604228-20210128223041306-583384313.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;多个css选择器&quot;&gt;多个CSS选择器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;浏览器在处理单独的id、class和元素选择器时如何渲染的问题很好理解，但要在两种甚至三种不同选择器同时作用于相同的元素的情况下，浏览器又该如何渲染呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如3个选择器作用在同一个元素身上的例子：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;charset&quot; content=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;ICE计算公式&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            #title {
                color : blue;
            }
            .red {
                color : red;
            }
            p {
                color : brown;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p id=&quot;title&quot; class=&quot;red&quot;&amp;gt;这是标题&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;得出结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1604228/202101/1604228-20210128223041682-1070040346.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;当3个不同的选择器(&lt;mark&gt;ID、Class、元素&lt;/mark&gt;)同时作用于同一元素上时，浏览器渲染时选择的样式为ID选择器声明的样式，这是因为ID选择器的特指度高于Class选择器，而Class选择器的特指度高于元素选择器......&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么应该怎么计算每个选择器特指度，要解决这个问题,不得不提到ICE计算公式:ID-Class-Element。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;ice计算公式&quot;&gt;ICE计算公式&lt;/h2&gt;
&lt;h3 id=&quot;关于ice计算公式错误的理解&quot;&gt;关于ICE计算公式错误的理解&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;注：我在过去很长一段时间都是按照这种错误的思想来理解ICE计算公式的，务必注意。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;关于ICE计算公式,经常看到这样的说法(&lt;mark&gt;这是错误的&lt;/mark&gt;)：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;!important&lt;/th&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;Class&lt;/th&gt;
&lt;th&gt;Element&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;特指度&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Element特指度为1，class特指度为10，ID特指度为100，!important为1000。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果按照这样理解，是不是可以说&lt;strong&gt;11个class的特指度为10 * 11 === 110&lt;/strong&gt;,它是肯定比&lt;strong&gt;1个Id的特指度&lt;/strong&gt;要大的，但在我实践后，我发现不能这样去理解,就比如下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;charset&quot; content=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;11个class是否比1个ID特指度大&amp;lt;/title&amp;gt; 
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            #id {
                color : green;
            }
            .class1.class2.class3.class4.class5.class6.class7.class8.class9.class10.class11 {
                color: red;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p id=&quot;id&quot; class=&quot;class1 class2 class3 class4 class5 class6 class7 class8 class9 class10 class11&quot;&amp;gt;p标签&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果按照class特指度为10、id为100的逻辑来理解，110 大于 100，最后p标签的color属性值应该为red，但是实际情况却是：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1604228/202101/1604228-20210128223042274-1355474264.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;标签的color属性值为green。造成这样结果的原因是因为不管有多少个class选择器，Id选择器的特指度就是比class选择器的特指度大。就好比奥运会排名，先比较金牌，金牌数量多者排前面，数量少者排后面,在出现金牌数量相同时才会以银牌的数量来比较。Id选择器就好比金牌，而class选择器就好比银牌。当Id选择器数量不一致时，后续操作压根就不会去比较class选择器,所以class选择器的数量再多，也是无效的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;不同选择器对应的特指度&quot;&gt;不同选择器对应的特指度&lt;/h3&gt;
&lt;p&gt;选择器共有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ID选择器&lt;/li&gt;
&lt;li&gt;Class选择器&lt;/li&gt;
&lt;li&gt;元素选择器&lt;/li&gt;
&lt;li&gt;属性选择器&lt;/li&gt;
&lt;li&gt;伪类选择器&lt;/li&gt;
&lt;li&gt;伪元素选择器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;ID选择器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (1, 0, 0)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;#title {
        color : blue;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Class选择器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 1, 0)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.red {
        color : red;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 0, 1)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;p {
        color : brown;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;属性选择器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 1, 0)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;[id=&quot;title&quot;] {
    color : black;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;伪类选择器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 1, 0)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：p:hover的特指度为 (0, 1, 1)，因为它包含了元素选择器和伪类选择器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;p:hover {
        color: #FF00FF
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;伪元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 0, 1)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：p::after的特指度为 (0, 0, 2)，因为它包含了元素选择器和伪元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;p::after {
    content: &quot;元&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;charset&quot; content=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;6种选择器的特指度&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            #title {
                color : blue;
            }
            .red {
                color : red;
            }
            p {
                color : brown;
            }
            [id=&quot;title&quot;] {
                color : black;
            }
            p:hover {
                color: yellow;
            }
            p::after {
                content: &quot;元&quot;;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p id=&quot;title&quot; class=&quot;red&quot;&amp;gt;100&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其余还有组合选择器、分组选择器、上下文选择器、子元素选择器、相邻兄弟选择器、后续兄弟选择器，但是这几种更像是选择器的组合，它们也都是由上述6种选择器 &lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{(ID选择器、Class选择器、元素选择器、属性选择器、伪类选择器、伪元素选择器)}\)&lt;/span&gt;组合而成，所以它们的特指度由组成它们的选择器的特指度相加即可获得。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合选择符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 2, 0)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：此处是对Class属性中同时含有red和indigo两个值的元素进行声明，它的特指度为(0, 2, 0)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.red.indigo {
    color : brown;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分组选择符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 0, 1)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：此处是对p、em、strong3个元素分别进行声明，而它们3个的特指度都为(0, 0, 1)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;p , em , strong {
    color : red;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上下文选择符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 0, 2)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：此处是对被包含在p元素中的em元素(&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{此时的em元素可以为p元素的子孙元素}\)&lt;/span&gt;)进行声明，它的特指度为(0, 0, 2)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;p em {
    color : red;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;子元素选择符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 0, 2)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：此处是对被包含在p元素中的em元素(&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{此时的em元素只能为p元素的子元素}\)&lt;/span&gt;)进行声明，它的特指度为(0, 0, 2)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;p &amp;gt; em {
    color : green;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相邻兄弟选择符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 0, 2)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：此处是对与p元素拥有相同父元素的em元素(&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{此时的em元素必须紧跟在p元素的后面}\)&lt;/span&gt;)进行声明，它的特指度为(0, 0, 2)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;p + em {
    color : red;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;一般兄弟选择符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{Selector Specificity: (0, 0, 2)}\)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：此处是对与p元素拥有相同父元素的em元素(&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{此时的em元素必须在p元素的后面，但不一定紧跟}\)&lt;/span&gt;)进行声明，它的特指度为(0, 0, 2)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;p ~ em {
    color : red;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;特殊情况&quot;&gt;特殊情况&lt;/h2&gt;
&lt;h3 id=&quot;没有特指度的继承样式&quot;&gt;没有特指度的继承样式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;继承样式不考虑特指度,由下面两个例子能说明:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;charset&quot; content=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;继承样式不考虑特指度&amp;lt;/title&amp;gt; 
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            .yellow {
                color : yellow;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;yellow&quot;&amp;gt;
            &amp;lt;p&amp;gt;p标签&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1604228/202101/1604228-20210128223042721-92298668.png&quot; alt=&quot;继承样式不考虑特指度-图1&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;上述例子中p元素的color属性值为red(来自用户样式表),继承自div元素的color属性值yellow被覆盖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(&lt;span class=&quot;math inline&quot;&gt;\(\color{#FF3030}{注：此浏览器的用户样式表被我修改，没有修改过的p元素的color属性的值应该是black。}\)&lt;/span&gt;)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;charset&quot; content=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;继承样式不考虑特指度&amp;lt;/title&amp;gt; 
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            .yellow {
                color : yellow;
            }
            p {
                color : green;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;yellow&quot;&amp;gt;
            &amp;lt;p&amp;gt;p标签&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1604228/202101/1604228-20210128223043151-1312125729.png&quot; alt=&quot;继承样式不考虑特指度-图2&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;上述例子中p元素的color属性值为green(来自元素选择器),继承自div元素的color属性值yellow被覆盖。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;超脱特指度的-！important&quot;&gt;超脱特指度的 ！important&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;!important是超脱特指度的存在&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;charset&quot; content=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;!important是超脱特指度的存在&amp;lt;/title&amp;gt; 
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            #id {
                color : green;
            }

            p {
                color : brown;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p id=&quot;id&quot;&amp;gt;p标签&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1604228/202101/1604228-20210128223043728-92712615.png&quot; alt=&quot;!important的特指度是最高的-图1&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;修改代码，给元素选择器中color属性加上!important后：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;charset&quot; content=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;!important是超脱特指度的存在/title&amp;gt; 
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            #id {
                color : green;
            }

            p {
                color : brown !important;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p id=&quot;id&quot;&amp;gt;p标签&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1604228/202101/1604228-20210128223044187-1331636860.png&quot; alt=&quot;!important的特指度是最高的-图2&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;元素选择器中加了!important的声明覆盖了ID选择器中没加!important的声明。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;特指度相当时-以-后声明的属性为准&quot;&gt;特指度相当时 以 后声明的属性为准&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当两个选择器的特指度相当时，特指度相当时 以 后声明的属性为准。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;charset&quot; content=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;特指度相当时 以 后声明的属性为准&amp;lt;/title&amp;gt; 
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            p {
                color : green;
            }
            p {
                color : brown;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p&amp;gt;p标签&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1604228/202101/1604228-20210128223044587-252695424.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;后声明的属性覆盖了先声明的属性。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;单个选择器的特指度按照 &lt;strong&gt;!important &amp;gt; id选择符 &amp;gt; class选择符、属性选择符和伪类 &amp;gt; 元素选择符和伪元素&lt;/strong&gt;的规律排序，如果遇到组合选择器，则按其逻辑将其拆分为单个选择器后相加再进行判断。如果选择器中的声明包含了!important，则这条属性会覆盖同属性所有不包含了!important的声明，只有在同属性的声明也包含!important，并且同属性的声明位于的选择器的特指度大于先前的选择器，亦或两个选择器的特指度相当，但同属性的声明位于的选择器位于先前的选择器之后时，才会覆盖先前的选择器的加了!important的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果上面的话很难理解，可以看这里的：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一条：比较各自所在的选择器的特指度，特指度越大的优先级越高；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第二条：加了!important的声明的属性优先级最高，在都加了!important的情况下按第一条为准；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第三条：在特指度相等的情况下，后声明的优先级大于先声明的；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第四条：优先级高的样式覆盖优先级低的样式。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 28 Jan 2021 14:33:00 +0000</pubDate>
<dc:creator>_Fatman</dc:creator>
<og:description>单个选择器的特指度按照 !important &gt; id选择符 &gt; class选择符、属性选择符和伪类 &gt; 元素选择符和伪元素的规律排序，如果遇到组合选择器，则按其逻辑将其拆分为单个选择器后相加再进行判</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liujingjiu/p/14342387.html</dc:identifier>
</item>
</channel>
</rss>