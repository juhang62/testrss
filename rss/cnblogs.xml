<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何快速融入团队并成为团队核心(二)？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12211007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12211007.html</guid>
<description>&lt;p&gt;title: 如何快速融入团队并成为团队核心(二)？&lt;/p&gt;

&lt;p&gt;事实上我们总是会认为那些所谓外向的人更容易融入集体，其实这是一个悖论。&lt;/p&gt;
&lt;p&gt;对于大多数人来说，其实都是一样的，当来到新集体时，总会感觉到莫名其妙的局促不安，这其中至少有50%的人内心的念头大概都有过这样的念头：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我TM到底能不能在这里干满试用期？这公司这样，我要不要把上家公司的离职报告拿回来？我该如何描述在这里的这几天工作呢？要不要写在简历上？听人说少于3个月的经历尽量不要写，那我还是不写吧。我从这里走了，还得继续找工作啊，要不要干脆在这里干下去，过了年再说吧，反正来都来了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中国人最善于安慰自己，所以一旦想到了“来都来了”这样的道理，那估计铁定一时半会是不会走了，然后就开始逐渐的被公司的体制一点点感化，最终彻底融入其中，成为公司必不可少的一部分。&lt;/p&gt;
&lt;p&gt;必须承认，当我们来到一家公司时，也是怀揣着梦想而来，并期待能在这里干一番大事业的，因此当来到公司的那么一瞬间，或许还激情澎湃，但是当遇到一些阻塞，例如要解决一些问题时，由于各方面的阻塞；有时想获得一些支持时，无人理睬，于是让我们或多或少产生了一些困扰。其实哪怕我们内心知道到每家公司往往都需要经历这样一番阶段，但实际上对于这些依然不太愿意接受，更有甚者会感觉有点迷茫，觉得这样的公司层级森严，沟通困难，迟早得倒闭。&lt;/p&gt;
&lt;p&gt;不过有时候得承认，这样的公司并不在少数，我们身边几乎每个人或许都经历过，有些人贸然来到这样的团体时，甚至会无法接受，然后突然就离开了，于是给公司的人留下了非常尴尬的印象。&lt;/p&gt;
&lt;p&gt;当然，有时候会与是否匹配相应的岗位、公司硬件条件有一定的关系，也有的时候，确实是主观上觉得无法适应这样的工作氛围，进而离开。&lt;/p&gt;

&lt;p&gt;在生物学中有一个概念叫做“协同进化”，讲的是相互作用的物种在进化过程中互相适应的进化，例如，看似是人类选择了养猫作为宠物，有没有感觉人类也在成为家猫的宠物？毕竟野生的猫肯定没有家猫挑剔，这不既然已经成为了宠物，那还不是得作弄主人，谁让你们觉得猫可爱呢。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202001/191302-20200119085227740-482908494.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实加入公司的每一位开发者，看似是在适应公司的环境，难道不也是在协同进化么。我们用自己的劳动力换取了自己的那份收入，同时也在用自己的某些特征在逐渐影响周围的人，甚至有时候会对公司层面更大范围的集体意识产生了影响，而有的特别具有优秀者气质的人，也自然而然在这个过程中实现了个人能力的极大提升，并为他们未来人生发展奠定了坚实的基础。&lt;/p&gt;
&lt;p&gt;曾经见到过许多人，他们年轻时是充满了斗志、意气风发、能力和才华都非常的引人瞩目，跟我一样，也寓居小城长沙，但是这样的小城市确实很难找到优秀的企业，于是迫于无奈或者是主动选择的加入了那些一些老态龙钟的企业，在开始还感觉挺不错的，但是后来也逐渐的被企业熏陶，然后被工作强奸。还有一些人却始终充满斗志，他们用自己的某些特质感染了周围许多人，并使得公司取得了辉煌的成就，自身也获得了很大的成果。&lt;/p&gt;
&lt;p&gt;是什么让他们或是沉沦，或是进取呢。&lt;/p&gt;
&lt;p&gt;大概是那三个关键性的东西在默默的发挥着关键的作用吧。&lt;/p&gt;

&lt;p&gt;有时候我们不愿意相信这些东西，以为这些东西是老板用于洗脑的鬼话，甚至有时候公司还会刻意请一些外来的咨询公司来进行所谓的企业文化培训，这些总是会让大家反感。大家都是经历过思想政治课教育出来的优秀人才，别跟我整这些花里胡哨的东西，我们就想搞点实在的。[图片](&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202001/191302-20200119085304383-1278025889.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;)&lt;/p&gt;
&lt;p&gt;但是有时候还真得承认，使命、愿景、价值观真的是让大家得以团聚，能把事情干好的必要条件啊。&lt;/p&gt;
&lt;p&gt;使命，通俗的理解就是公司正在做的事。我做的事情是否属于公司正在做的事、是否属于公司的主航道？有时候每当我们接到一个任务时，总是会产生这样或那样的疑惑。如果是符合公司使命的任务，我们干起来或许会斗志昂扬，而不属于公司使命的任务，难免会有点气氛消沉，甚至充满的负能量。&lt;/p&gt;
&lt;p&gt;愿景，就是公司想实现的目标。公司干这个事，是真的想做这件事，该不是玩票的吧？公司干这个事，想实现什么目标？我能从这个目标中获得哪些收获？愿景会让人对未来充满想象和希望，而一个人充满了希望，他就愿意为了实现目标付出更多的努力。&lt;/p&gt;
&lt;p&gt;价值观，是完成任务过程中会采取的方法论或指导原则。在《华为方法论》中提到，你可以不喝酒，但是不能喝假酒。讲的是有一个分公司的人，为了跟客户打成一片，就在餐桌上喝酒，但是他身体不好，不能喝那么多酒，所以他在酒里面掺了水，然后被人举报，公司严肃的批评了他这种行为，并指出“如果身体不好，要么就别喝酒，喝假酒就是错的”。具体而言，当我们要实现某个东西时，不同的人有不同的方法。&lt;/p&gt;
&lt;p&gt;例如要搞定某个客户，我们可以把方案做得特别炫、功能做得特别完美，我们也有人会选择采取特殊的手段（例如PY交易），这样会让那些不认同这种价值观的人反感。&lt;/p&gt;
&lt;p&gt;又例如，我们搭建了一个架构，费了很长的时间，然后突然有一个人空降过来，把所有的成绩都归功于自己的功劳，而且还升官发财，而其他人则累死累活，这样的价值观简直恶毒。如果这样的人最终留下来，也意味着所有与他价值观不符的人，要么接受他的价值观或甚至被带下水，要么选择离开。&lt;/p&gt;

&lt;p&gt;一群拥有相同的使命、愿景和价值观的人，一起为了一个共同的目标而奋斗，其所能产生的动力往往是最大的。在2020年的今天，要把事情干好，并不取决于你的技术水平或知识领域，而是取决于公司能否聚齐这一群人。&lt;/p&gt;
&lt;p&gt;同样，当你来到一个团队时，你得衡量的并不仅仅只是团队间的沟通形式，有时候融入团队确实需要时间，但一旦你能够真正融入其中，你将获得自身难以体会的宝贵财富。&lt;/p&gt;
&lt;p&gt;下一篇，我想跟大家探讨一下，基因、企业文化、江湖规矩。&lt;/p&gt;
</description>
<pubDate>Sun, 19 Jan 2020 00:54:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>title: 如何快速融入团队并成为团队核心(二)？ 一 引言 事实上我们总是会认为那些所谓外向的人更容易融入集体，其实这是一个悖论。 对于大多数人来说，其实都是一样的，当来到新集体时，总会感觉到莫名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12211007.html</dc:identifier>
</item>
<item>
<title>mysql安装忘记初始密码怎么办 - 小青年XQP</title>
<link>http://www.cnblogs.com/xiaoqingnianXQP/p/12211000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoqingnianXQP/p/12211000.html</guid>
<description>&lt;h2 id=&quot;mysql安装过程忘记初始密码最简单解决办法&quot;&gt;MySQL安装过程忘记初始密码最简单解决办法&lt;/h2&gt;
&lt;p&gt;​ 在安装MySQL的时候会给定一个初始的密码，而这个初始的密码特别恶心人一堆大小写特殊字符。记住是不可能的，如果之前没有过安装经历的小伙伴第一次自主安装十有八九不会去注意这个。&lt;/p&gt;
&lt;p&gt;​ 本次教程使用的MySQL版本是8.0.19版本。8版本的应该都可以使用这个方法，其他版本的不清楚，可以试一下。全程熟练的话两分钟搞定。&lt;/p&gt;
&lt;p&gt;首先上教程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接操作第六步吧，前面的发现都是废话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.先要确保my.ini文件里面的datadir的那个文件夹（data）不是手动创建的&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;restructuredtext&quot;&gt;
&lt;code&gt;[client]
#设置mysql客户端默认字符集
default-character-set=utf8

[mysqld]
#设置端口3306
port=3306
#设置mysql的安装目录
basedir=F:\\MYSQL\\mysql-8.0.19-winx64\\mysql-8.0.19-winx64
#设置mysql数据库的存放位置，8以下不需要设置
datadir=F:\\MYSQL\\mysql-8.0.19-winx64\\mysql-8.0.19-winx64\\data
#允许最大连接数
max_connections=20
#服务端使用的字符集默认为8比特编码的latinl字符集
character-set-server=utf8
#创建新表的时候使用的默认存储引擎
default-storage-engine=INNODB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 删除这个data文件夹&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. cmd用管理员模式打开，进入到MySQL的安装目录下，输入：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sc delete mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. 重新初始化数据库（把这一步生成的密码记下来，要不然还是忘）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqld --initialize --console&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. 重新安装MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqld install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来再试试看，是不是就可以启动了。&lt;/p&gt;
&lt;p&gt;结束了？没有接下来交你如何更改密码，这个网上一堆代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 在my.ini文件里的mysqld下面加上这样一行（登录的时候跳过密码验证？？？？哎呀，那么我上面哪些步骤不都。。。浪费了）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;skip-grant-tables&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7. 保存退出后，重新键入&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -uroot -p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8. 这个时候就已经进入到了mysql数据库，接下来几步也是我学别人的方法设置成功的，自己可以使用，依次键入：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flush privileges;
alter user 'root'@'localhost'IDENTIFIED BY '你要设置的新密码';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来新密码就可以生效了。&lt;/p&gt;
&lt;p&gt;但是要记住一点，记得把ini文件里添加的那行代码（&lt;em&gt;skip-grant-tables&lt;/em&gt;）去掉。&lt;/p&gt;
</description>
<pubDate>Sun, 19 Jan 2020 00:50:00 +0000</pubDate>
<dc:creator>小青年XQP</dc:creator>
<og:description>MySQL安装过程忘记初始密码最简单解决办法 ​	在安装MySQL的时候会给定一个初始的密码，而这个初始的密码特别恶心人一堆大小写特殊字符。记住是不可能的，如果之前没有过安装经历的小伙伴第一次自主安装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoqingnianXQP/p/12211000.html</dc:identifier>
</item>
<item>
<title>React躬行记（16）——React源码分析 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11950520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11950520.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://github.com/facebook/react&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;React&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;可大致分为三部分：Core、Reconciler和Renderer，在阅读源码之前，首先需要搭建测试环境，为了方便起见，本文直接采用了&lt;span&gt;&lt;a href=&quot;https://github.com/pws019/react-sourcecode-debug-env&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;网友搭建好的环境&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，React版本是16.8.6，与最新版本很接近。&lt;/p&gt;

&lt;p&gt;　　React采用了由&lt;span&gt;&lt;a href=&quot;https://lerna.js.org/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Lerna&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;维护monorepo方式进行代码管理，即用一个仓库管理多个模块（module）或包（package）。在React仓库的根目录中，包含三个目录：&lt;/p&gt;
&lt;p&gt;　　（1）fixtures，给源码贡献者准备的测试用例。&lt;/p&gt;
&lt;p&gt;　　（2）packages，React库提供的包的源码，包括核心代码、矢量图形库等，如下所列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
├── packages ------------------------------------&lt;span&gt; 源码目录
│   ├── react&lt;/span&gt;-art -------------------------------&lt;span&gt; 矢量图形渲染器
│   ├── react&lt;/span&gt;-dom -------------------------------&lt;span&gt; DOM渲染器
│   ├── react&lt;/span&gt;-native-renderer -------------------&lt;span&gt; Native渲染器（原生iOS和Android视图）
│   ├── react&lt;/span&gt;-test-renderer ---------------------&lt;span&gt; JSON树渲染器
│   ├── react&lt;/span&gt;-reconciler ------------------------ React调和器
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）scripts，相关的工具配置脚本，包括语法规则、Git钩子等。&lt;/p&gt;
&lt;p&gt;　　React使用的前端模块化打包工具是&lt;span&gt;&lt;a href=&quot;https://www.rollupjs.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Rollup&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，在源码中还引入了&lt;span&gt;&lt;a href=&quot;https://zhenyong.github.io/flowtype/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Flow&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，用于静态类型检查，在运行代码之前发现一些潜在的问题，其语法类似于TypeScript。&lt;/p&gt;

&lt;p&gt;　　在项目中引入React通常是像下面这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import React from 'react';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实引入的是核心入口文件“&lt;span&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/master/packages/react/index.js&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;packages/react/index.js&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;”中导出的对象，如下所示，其中React.default用于Jest测试，React用于Rollup。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const React = require('./src/React'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: decide on the top-level export form.&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; This is hacky but makes it work with both Rollup and Jest.&lt;/span&gt;
module.exports = React.&lt;span&gt;default&lt;/span&gt; || React;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　顺着require()语句可以找到&lt;span&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/master/packages/react/src/React.js&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;React.js&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中的React对象，代码省略了一大堆导入语句，其中__DEV__是个全局变量，用于管理开发环境中运行的代码块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
const React =&lt;span&gt; {
  Children: {
    map,
    forEach,
    count,
    toArray,
    only,
  },

  createRef,
  Component,
  PureComponent,

  createContext,
  forwardRef,
  lazy,
  memo,

  useCallback,
  useContext,
  useEffect,
  useImperativeHandle,
  useDebugValue,
  useLayoutEffect,
  useMemo,
  useReducer,
  useRef,
  useState,

  Fragment: REACT_FRAGMENT_TYPE,
  Profiler: REACT_PROFILER_TYPE,
  StrictMode: REACT_STRICT_MODE_TYPE,
  Suspense: REACT_SUSPENSE_TYPE,
  unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE,

  createElement: __DEV__ &lt;/span&gt;?&lt;span&gt; createElementWithValidation : createElement,
  cloneElement: __DEV__ &lt;/span&gt;?&lt;span&gt; cloneElementWithValidation : cloneElement,
  createFactory: __DEV__ &lt;/span&gt;?&lt;span&gt; createFactoryWithValidation : createFactory,
  isValidElement: isValidElement,

  version: ReactVersion,

  unstable_withSuspenseConfig: withSuspenseConfig,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,
};

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (enableFlareAPI) {
  React.unstable_useResponder &lt;/span&gt;=&lt;span&gt; useResponder;
  React.unstable_createResponder &lt;/span&gt;=&lt;span&gt; createResponder;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (enableFundamentalAPI) {
  React.unstable_createFundamental &lt;/span&gt;=&lt;span&gt; createFundamental;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (enableJSXTransformAPI) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (__DEV__) {
    React.jsxDEV &lt;/span&gt;=&lt;span&gt; jsxWithValidation;
    React.jsx &lt;/span&gt;=&lt;span&gt; jsxWithValidationDynamic;
    React.jsxs &lt;/span&gt;=&lt;span&gt; jsxWithValidationStatic;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    React.jsx &lt;/span&gt;=&lt;span&gt; jsx;
    React.jsxs &lt;/span&gt;=&lt;span&gt; jsx;
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; React;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在React对象中包含了开放的&lt;span&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/docs/react-api.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;核心API&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，例如React.Component、React.createRef()等，以及新引入的Hooks（内部的具体逻辑可转移到相关的包中），但渲染的逻辑已经剥离出来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）React.createElement()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　JSX中的元素称为&lt;span&gt;&lt;a href=&quot;https://www.kancloud.cn/pwstrick/fe-questions/1167731&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;React元素&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，分为两种类型：DOM元素和组件元素。用JSX描述的组件都会通过Babel编译器将它们转换成React.createElement()方法，它包含三个参数（如下所示），其中type是元素类型，也就是它的名称；props是一个由元素属性组成的对象；children是它的子元素（即内容），可以是文本也可以是其它元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
React.createElement(type, [props], [...children])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　方法的返回值是一个ReactElement，省略了开发环境中的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
const ReactElement = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(type, key, ref, self, source, owner, props) {
  const element &lt;/span&gt;=&lt;span&gt; {
    $$&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: ref,
    props: props,
    _owner: owner        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录创建该元素的组件&lt;/span&gt;
&lt;span&gt;  };
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（1）$$typeof标识该对象是一个ReactElement。&lt;/p&gt;
&lt;p&gt;　　（2）当ReactElement是DOM元素时，type是元素名称；当ReactElement是组件元素时，type是其构造函数。&lt;/p&gt;
&lt;p&gt;　　（3）&lt;span&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/docs/lists-and-keys.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;key&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;和&lt;span&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/docs/forwarding-refs.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ref&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是React组件中的两个特殊属性，前者用于标识身份，后者用于访问render()方法内生成的组件实例和DOM元素。&lt;/p&gt;
&lt;p&gt;　　（4）props是ReactElement中的属性，包括特殊的&lt;span&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/docs/glossary.html#propschildren&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;children属性&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　虽然React的DOM和Native两种渲染器内部实现的区别很大，但为了能共享自定义组件、State、生命周期等特性，做到跨平台，就需要共享一些逻辑，而这些逻辑由Reconciler统一处理，其中协调算法（Diffing算法）也要尽可能相似。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）Diffing算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当调用React的render()方法时，会创建一棵由React元素组成的树。在下一次State或Props更新时，相同的render()方法会返回一棵不同的树。React会应用Diffing算法来高效的比较两棵树，算法过程如下。&lt;/p&gt;
&lt;p&gt;　　（1）当根节点为不同类型的元素时，React会拆卸原有的树，销毁对应的DOM节点和关联的State、卸载子组件，最后再创建新的树。&lt;/p&gt;
&lt;p&gt;　　（2）当比对两个相同类型的DOM元素时，会保留DOM节点，仅比对变更的属性。&lt;/p&gt;
&lt;p&gt;　　（3）当比对两个相同类型的组件元素时，组件实例保持不变，更新该组件实例的Props。&lt;/p&gt;
&lt;p&gt;　　（4）当递归DOM节点的子元素时，React会同时遍历两个子元素的列表，比对相同位置的元素，性能比较低效。&lt;/p&gt;
&lt;p&gt;　　（5）在给子元素添加唯一标识的key属性后，就能只比对变更了key属性的元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）Fiber Reconciler&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　JavaScript与样式计算、界面布局等各种绘制，一起运行在浏览器的主线程中，当JavaScript运行时间过长时，将占用整个线程，阻塞其它任务。为了能在React渲染期间回到主线程执行其它任务，在React v16中提出了Fiber Reconciler，并将其设为默认的Reconciler，解决了过去Stack Reconciler中的固有问题和遗留的痛点，提高了动画、布局和手势等领域的性能。Fiber Reconciler的主要目标是：&lt;/p&gt;
&lt;p&gt;　　（1）暂停和切分渲染任务，并将分割的任务分布到各个帧中。&lt;/p&gt;
&lt;p&gt;　　（2）调整优先级，并重置或复用已完成的任务。&lt;/p&gt;
&lt;p&gt;　　（3）在父子元素之间交错处理，以支持React中的布局。&lt;/p&gt;
&lt;p&gt;　　（4）在render()方法中返回多个元素。&lt;/p&gt;
&lt;p&gt;　　（5）更好地支持错误边界。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）调度任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Fiber可以分解任务，根据优先级将任务调度到浏览器提供的两个全局函数中，如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;requestAnimationFrame&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;：在下一个动画帧上执行高优先级的任务。&lt;/p&gt;
&lt;p&gt;　　（2）&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;requestIdleCallback&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;：在线程空闲时执行低优先级的任务。&lt;/p&gt;
&lt;p&gt; 　　当网页保持在每秒60帧（1帧约为16ms）时，整体会变得很流畅。在每个帧中调用requestAnimationFrame()执行高优先级的任务；而在两个帧之间会有一小段空闲时间，此时可执行requestIdleCallback()中的任务，该函数包含一个deadline参数（截止时间），用于切分长任务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）Fiber数据结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在调和期间，从render()方法得到的每个React元素都需要升级为Fiber节点，并添加到Fiber节点树中。而与React元素不同，Fiber节点可复用，不会在每次渲染时重新创建。Fiber的数据结构大致如下，省略了部分属性，源码来自于&lt;span&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiber.js&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;packages/react-reconciler/src/ReactFiber.js&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
export type Fiber =&lt;span&gt; {
  tag: WorkTag,
  key: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt; | &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,
  elementType: any,
  type: any,
  stateNode: any,
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;: Fiber | &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  child: Fiber &lt;/span&gt;| &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  sibling: Fiber &lt;/span&gt;| &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; | (((handle: mixed) =&amp;gt; &lt;span&gt;void&lt;/span&gt;) &amp;amp; {_stringRef: ?&lt;span&gt;string&lt;/span&gt;}) |&lt;span&gt; RefObject,
  effectTag: SideEffectTag,
  nextEffect: Fiber &lt;/span&gt;| &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  firstEffect: Fiber &lt;/span&gt;| &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  lastEffect: Fiber &lt;/span&gt;| &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  expirationTime: ExpirationTime,
  alternate: Fiber &lt;/span&gt;| &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  ...
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　return、child和sibling三个属性分别表示父节点、第一个子节点和兄弟节点，通过它们使得Fiber节点能够基于链表连接在一起。假设有个ClickCounter组件，包含&amp;lt;button&amp;gt;和&amp;lt;span&amp;gt;两个元素，它们三者之间的关系如图12所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClickCounter extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [
      &lt;/span&gt;&amp;lt;button&amp;gt;Update counter&amp;lt;/button&amp;gt;&lt;span&gt;,
      &lt;/span&gt;&amp;lt;span&amp;gt;&lt;span&gt;10&lt;/span&gt;&amp;lt;/span&amp;gt;&lt;span&gt;
    ];
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201912/211606-20191202162140850-537461469.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 12 节点关系&lt;/p&gt;
&lt;p&gt;　　使用alternate属性双向连接当前Fiber和正在处理的Fiber（workInProgress），如下代码所示，当需要恢复时，可通过alternate属性直接回退。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let workInProgress =&lt;span&gt; current.alternate;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workInProgress === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
  workInProgress.alternate &lt;/span&gt;=&lt;span&gt; current;
  current.alternate &lt;/span&gt;=&lt;span&gt; workInProgress;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到期时间（ExpirationTime）是指完成此任务的时间，该时间越短，则优先级越高，需要尽早执行，具体逻辑在同目录的&lt;span&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberExpirationTime.js&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ReactFiberExpirationTime.js&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中。&lt;/p&gt;

&lt;p&gt;　　React在内部执行时会分为两个阶段：render和commit。&lt;/p&gt;
&lt;p&gt;　　在第一个render阶段（phase）中，React持有标记了副作用（side effect）的Fiber树并将其应用于实例，该阶段不会发生用户可见的更改，并且可异步执行，下面列出的是在render阶段执行的生命周期钩子方法&lt;/p&gt;
&lt;p&gt;　　（1）[UNSAFE_]componentWillMount（弃用）&lt;/p&gt;
&lt;p&gt;　　（2）[UNSAFE_]componentWillReceiveProps（弃用）&lt;/p&gt;
&lt;p&gt;　　（3）getDerivedStateFromProps&lt;/p&gt;
&lt;p&gt;　　（4）shouldComponentUpdate&lt;/p&gt;
&lt;p&gt;　　（5）[UNSAFE_]componentWillUpdate（弃用）&lt;/p&gt;
&lt;p&gt;　　（6）render&lt;/p&gt;
&lt;p&gt;　　标有UNSAFE的生命周期有可能被执行多次，并且经常被误解和滥用，例如在这些方法中执行副作用代码，可能出现渲染问题，或者任意操作DOM，可能引起回流（reflow）。于是官方推出了静态的getDerivedStateFromProps()方法，可限制状态更新以及DOM操作。&lt;/p&gt;
&lt;p&gt;　　在第二个commit阶段，任务都是同步执行的，下面列出的是commit阶段执行的生命周期钩子方法，这些方法都只执行一次，其中getSnapshotBeforeUpdate()是新增的，用于替换componentWillUpdate()。&lt;/p&gt;
&lt;p&gt;　　（1）getSnapshotBeforeUpdate&lt;/p&gt;
&lt;p&gt;　　（2）componentDidMount&lt;/p&gt;
&lt;p&gt;　　（3）componentDidUpdate&lt;/p&gt;
&lt;p&gt;　　（4）componentWillUnmount&lt;/p&gt;
&lt;p&gt;　　新的流程将变成图13这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201912/211606-20191202174625536-1116659477.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 13 新的流程&lt;/p&gt;

&lt;p&gt;【参考资料】&lt;br/&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/docs/codebase-overview.html&quot; target=&quot;_blank&quot;&gt;源码概览 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react/tree/master/fixtures/packaging&quot; target=&quot;_blank&quot;&gt;贡献者说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://react.jokcy.me/&quot; target=&quot;_blank&quot;&gt;React 源码解析系列（&lt;/a&gt;&lt;a href=&quot;https://react.jokcy.me/&quot; target=&quot;_blank&quot;&gt;jokcy&lt;/a&gt;&lt;a href=&quot;https://react.jokcy.me/&quot; target=&quot;_blank&quot;&gt;）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zxc0328.github.io/2018/05/01/react-source-reading-howto/&quot; target=&quot;_blank&quot;&gt;如何阅读大型前端开源项目的源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zhenhua-lee.github.io/react/react.html&quot; target=&quot;_blank&quot;&gt;React源码解析(逻辑图)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000020239791?utm_source=tag-newest&quot; target=&quot;_blank&quot;&gt;react源码学习环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jsonz1993/react-source-learn/issues/1&quot; target=&quot;_blank&quot;&gt;React源码系列(一): 总结看源码心得及方法感受&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://icepy.gitbooks.io/react/content/di_yi_zhang_ff1a_mu_lu_yi_ji_wen_jian_fen_xi.html&quot; target=&quot;_blank&quot;&gt;React源码分析系列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitissue.com/issues/5b44f7bb9906f66a9d9b23fe&quot; target=&quot;_blank&quot;&gt;react源码开始的那一步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sosout.com/2018/08/12/react-source-analysis.html&quot; target=&quot;_blank&quot;&gt;React 源码全方位剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51483167&quot; target=&quot;_blank&quot;&gt;「译」React Fiber 那些事: 深入解析新的协调算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5ddb722cf265da7e264736a0&quot; target=&quot;_blank&quot;&gt;【翻译】React Fiber 架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37095662&quot; target=&quot;_blank&quot;&gt;React Fiber架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37098539&quot; target=&quot;_blank&quot;&gt;为 Luy 实现 React Fiber 架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/docs/reconciliation.html&quot; target=&quot;_blank&quot;&gt;协调 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ayqy.net/blog/dive-into-react-fiber/&quot; target=&quot;_blank&quot;&gt;完全理解React Fiber&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Jan 2020 00:49:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>React可大致分为三部分：Core、Reconciler和Renderer，在阅读源码之前，首先需要搭建测试环境，为了方便起见，本文直接采用了网友搭建好的环境，React版本是16.8.6，与最新版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11950520.html</dc:identifier>
</item>
<item>
<title>云原生 - 体验Istio的完美入门之旅(一) - justmine</title>
<link>http://www.cnblogs.com/justmine/p/12210389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justmine/p/12210389.html</guid>
<description>&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;作者：justmine&lt;/p&gt;
&lt;p&gt;头条号：大数据达摩院&lt;/p&gt;
&lt;p&gt;微信公众号：大数据处理系统&lt;/p&gt;
&lt;p&gt;创作不易，在满足创作共用版权协议的基础上可以转载，但请以超链接形式注明出处。&lt;/p&gt;
&lt;p&gt;为了方便大家阅读，可以关注头条号或微信公众号，后续所有的文章将在移动端首发，想学习更多云原生知识，请关注我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;随着微服务架构的流行，服务网格技术获得了业界的广泛关注，作为实现云原生的重要积木，各大厂商也纷纷开始布局，Amazon在2019年4月份推出了App Mesh；Google、IBM、Lyft联合开发了Istio。&lt;/p&gt;
&lt;p&gt;Istio作为下一代服务网格的整体解决方案，得到了业界的普遍认可，站在kubernetes巨人的肩膀上，极大地提高了分布式应用的研发和运维效率。&lt;/p&gt;
&lt;p&gt;2020是云原生普及的一年，如何部署、使用、运维Istio又是必须要学习知识，本篇希望带给大家一个完美的入门体验。&lt;/p&gt;
&lt;h2 id=&quot;一安装环境&quot;&gt;一、安装环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本地环境：Linux ubuntu&lt;/li&gt;
&lt;li&gt;kubernetes版本：1.15.2&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二准备工作&quot;&gt;二、准备工作&lt;/h2&gt;
&lt;h3 id=&quot;下载最新版本&quot;&gt;1、下载最新版本&lt;/h3&gt;
&lt;p&gt;从Istio&lt;a href=&quot;https://github.com/istio/istio/releases&quot;&gt;最新发布列表&lt;/a&gt;下载最新发布版本1.4.3压缩包，及其命令行工具(Istioctl)，如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 创建工作目录
mkdir -p /root/service-mesh/istio &amp;amp;&amp;amp; cd /root/service-mesh/istio;
# 下载
wget https://github.com/istio/istio/releases/download/1.4.3/istioctl-1.4.3-linux.tar.gz;
## istio也可以演示的时候在下载
wget https://github.com/istio/istio/releases/download/1.4.3/istio-1.4.3-linux.tar.gz;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;话外音：请下载相同版本的Istioctl和Istio，避免无法预料的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装命令行工具&quot;&gt;2、安装命令行工具&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tar -vxzf istioctl-1.4.3-linux.tar.gz &amp;amp;&amp;amp; cp istioctl /usr/local/bin;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三安装istio&quot;&gt;三、安装Istio&lt;/h2&gt;
&lt;p&gt;为了满足不同的安装需求，Istio内置了一系列的安装配置文件，生产环境建议以&lt;code&gt;default&lt;/code&gt;安装配置文件为起点。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;话外音：可以使用&lt;code&gt;istioctl profile list&lt;/code&gt;命令查看内置配置文件列表，然后使用&lt;code&gt;istioctl profile dump [配置文件名称]&lt;/code&gt;打印配置文件内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 安装 default
# istioctl manifest apply --set profile=default
- Applying manifest for component Base...
✔ Finished applying manifest for component Base.
- Applying manifest for component Galley...
- Applying manifest for component IngressGateway...
- Applying manifest for component Citadel...
- Applying manifest for component Kiali...
- Applying manifest for component Prometheus...
- Applying manifest for component Policy...
- Applying manifest for component Pilot...
- Applying manifest for component Injector...
- Applying manifest for component Telemetry...
✔ Finished applying manifest for component IngressGateway.
✔ Finished applying manifest for component Citadel.
✔ Finished applying manifest for component Prometheus.
✔ Finished applying manifest for component Policy.
✔ Finished applying manifest for component Galley.
✔ Finished applying manifest for component Injector.
✔ Finished applying manifest for component Pilot.
- Finished applying manifest for component Kiali.
✔ Finished applying manifest for component Telemetry.
# 验证
# kubectl get pod -n istio-system
NAME                                      READY   STATUS    RESTARTS   AGE
istio-citadel-7c959c8d59-hssf4            1/1     Running   0          100m
istio-galley-5479df66b5-tr5hf             2/2     Running   0          100m
istio-ingressgateway-7c95796d59-s5sc2     1/1     Running   0          100m
istio-pilot-656556b575-7zzht              2/2     Running   0          100m
istio-policy-5b9b9f5cd9-788rg             2/2     Running   6          100m
istio-sidecar-injector-7dbcc9fc89-554vg   1/1     Running   0          100m
istio-telemetry-7d5b5947db-tgbmg          2/2     Running   6          100m
prometheus-685585888b-5f77l               1/1     Running   0          100m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待几分钟，当所有的组件状态都为Running时，表示安装成功。&lt;/p&gt;
&lt;h2 id=&quot;四安装kiali&quot;&gt;四、安装kiali&lt;/h2&gt;
&lt;p&gt;通过将基础设施转移到Istio，使得应用开发者无需重复建设基础设施，只需专注于业务逻辑。Istio负责管理整个应用服务集合，这些服务集合组成的网络拓扑就叫服务网格，Istio提供了kiali来可视化整个服务网格。&lt;/p&gt;
&lt;h4 id=&quot;创建登录凭证&quot;&gt;1、创建登录凭证&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# KIALI_USERNAME=$(read -p 'Kiali Username: ' uval &amp;amp;&amp;amp; echo -n $uval | base64);
Kiali Username: 用户名
# KIALI_PASSPHRASE=$(read -sp 'Kiali Passphrase: ' pval &amp;amp;&amp;amp; echo -n $pval | base64);
Kiali Passphrase: 密码
# cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: kiali
  namespace: istio-system
  labels:
    app: kiali
type: Opaque
data:
  username: $KIALI_USERNAME
  passphrase: $KIALI_PASSPHRASE
EOF&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用istioctl安装&quot;&gt;2、使用Istioctl安装&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# istioctl manifest apply --set values.kiali.enabled=true
[...]
✔ Finished applying manifest for component Kiali.
[...]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;联网&quot;&gt;3、联网&lt;/h4&gt;
&lt;p&gt;使用NodePort方式暴露kiali服务到互联网，如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;话外音：应该根据&lt;code&gt;k8s&lt;/code&gt;环境选择不同联网方式，生产环境建议暴露为&lt;code&gt;LoadLalancer&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# kubectl -n istio-system edit svc kiali
[...]
spec:
  ports:
  - name: http-kiali
    [...]
    nodePort: 9527
  type: NodePort
[...]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;访问&quot;&gt;4、访问&lt;/h4&gt;
&lt;p&gt;浏览器键入地址&lt;code&gt;http://[ip]:9527/kiali&lt;/code&gt;，键入上面创建的凭证，登录成功，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/202001/1082769-20200118150502352-634937415.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五演示&quot;&gt;五、演示&lt;/h2&gt;
&lt;p&gt;本节将部署一个多语言异构化的微服务示例(Bookinfo)，让大家对服务网格有一个清晰的认识。&lt;/p&gt;
&lt;h3 id=&quot;bookinfo---在线图书商店&quot;&gt;Bookinfo - 在线图书商店&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;productpage&lt;/code&gt;微服务&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;details&lt;/code&gt;和&lt;code&gt;reviews&lt;/code&gt;微服务，提供图书单品完整信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;details&lt;/code&gt;微服务&lt;/p&gt;
&lt;p&gt;提供图书详细信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;reviews&lt;/code&gt;微服务&lt;/p&gt;
&lt;p&gt;提供图书评论信息。&lt;/p&gt;
&lt;p&gt;一共有三个版本。v1版本不会调用&lt;code&gt;ratings&lt;/code&gt;微服务；v2版本调用&lt;code&gt;ratings&lt;/code&gt;服务，并将每个等级显示为1到5个&lt;strong&gt;黑色&lt;/strong&gt;星号；v3版本调用&lt;code&gt;ratings&lt;/code&gt;服务，并将每个等级显示为1到5个&lt;strong&gt;红色&lt;/strong&gt;星号。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ratings&lt;/code&gt;微服务&lt;/p&gt;
&lt;p&gt;提供图书排行榜信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一图胜千言，整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/202001/1082769-20200118151727764-961468381.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;部署bookinfo到istio&quot;&gt;部署Bookinfo到Istio&lt;/h3&gt;
&lt;p&gt;将Bookinfo部署到k8s默认命名空间，即default。&lt;/p&gt;
&lt;h4 id=&quot;启动边车自动注入&quot;&gt;1、启动边车自动注入&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;kubectl label namespace default istio-injection=enabled&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;部署到k8s&quot;&gt;2、部署到k8s&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 进入工作目录，解压刚刚下载的Istio
root@just: cd /root/service-mesh/istio &amp;amp;&amp;amp; tar -vxzf istio-1.4.3-linux.tar.gz 
# 使用kubectl部署到k8s
root@just: kubectl apply -f istio-1.4.3/samples/bookinfo/platform/kube/bookinfo.yaml
service/details created
serviceaccount/bookinfo-details created
deployment.apps/details-v1 created
service/ratings created
serviceaccount/bookinfo-ratings created
deployment.apps/ratings-v1 created
service/reviews created
serviceaccount/bookinfo-reviews created
deployment.apps/reviews-v1 created
deployment.apps/reviews-v2 created
deployment.apps/reviews-v3 created
service/productpage created
serviceaccount/bookinfo-productpage created
deployment.apps/productpage-v1 created&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;联网-1&quot;&gt;3、联网&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 为Bookinfo部署入口网关
root@just: kubectl apply -f istio-1.4.3/samples/bookinfo/networking/bookinfo-gateway.yaml
gateway.networking.istio.io/bookinfo-gateway created
virtualservice.networking.istio.io/bookinfo created
# 获取网关地址
root@just: export INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath='{.items[0].status.hostIP}'
root@just: export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;http2&quot;)].nodePort}')
root@just: export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT
# 获取图书单品页地址
echo http://${GATEWAY_URL}/productpage&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;访问-1&quot;&gt;4、访问&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/202001/1082769-20200118155933671-176836485.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;查看服务网格&quot;&gt;5、查看服务网格&lt;/h4&gt;
&lt;p&gt;不停地刷新图书单品页，kiali会实时地绘制服务网格，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/202001/1082769-20200118165907252-1391592517.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于权重流量的实时控制，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082769/202001/1082769-20200118170618419-1609921270.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于服务的可观察性，kiali还提供了很多其他的功能，这也是Istio相较于其他服务网格框架的优势，这里就不展示了。&lt;/p&gt;
&lt;h2 id=&quot;六总结&quot;&gt;六、总结&lt;/h2&gt;
&lt;p&gt;本篇使用Istioctl搭建了一套完整的Istio系统，先从战略上鸟瞰Istio，进一步从战术上学习Istio将更加容易，作为一个完整解决方案，后面系列将一步步学习如何运用Istio的连接、安全、控制、可观察性全面地治理分布式应用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;话外音：到目前为止，大家应该明白Istio是个什么东东了吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;七参考&quot;&gt;七、参考&lt;/h2&gt;
&lt;p&gt;https://github.com/istio/istio/releases&lt;/p&gt;
&lt;p&gt;https://istio.io/docs/setup/additional-setup/config-profiles&lt;/p&gt;
&lt;p&gt;https://istio.io/docs/setup/getting-started&lt;/p&gt;
&lt;p&gt;https://istio.io/docs/setup/install/istioctl/#customizing-the-configuration&lt;/p&gt;
&lt;p&gt;https://istio.io/docs/reference/commands/istioctl&lt;/p&gt;
&lt;p&gt;https://istio.io/docs/ops/diagnostic-tools/istioctl&lt;/p&gt;
&lt;p&gt;https://istio.io/news/releases/1.4.x/announcing-1.4.3&lt;/p&gt;
&lt;p&gt;https://istio.io/docs/examples/bookinfo&lt;/p&gt;
&lt;p&gt;https://istio.io/docs/tasks/traffic-management/ingress/ingress-control/#determining-the-ingress-ip-and-ports&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果有什么疑问和见解，欢迎评论区交流。&lt;/p&gt;
&lt;p&gt;如果你觉得本篇文章对您有帮助的话，感谢您的【&lt;strong&gt;推荐&lt;/strong&gt;】。&lt;/p&gt;
&lt;p&gt;如果你对&lt;strong&gt;云原生&lt;/strong&gt;感兴趣的话可以&lt;strong&gt;【关注我】&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 19 Jan 2020 00:46:00 +0000</pubDate>
<dc:creator>justmine</dc:creator>
<og:description>作者：justmine 头条号：大数据达摩院 微信公众号：大数据处理系统 创作不易，在满足创作共用版权协议的基础上可以转载，但请以超链接形式注明出处。 为了方便大家阅读，可以关注头条号或微信公众号，后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justmine/p/12210389.html</dc:identifier>
</item>
<item>
<title>Google搜索成最大入口，简单谈下个人博客的SEO - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/12210979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/12210979.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;个人静态博客SEO该考虑哪些问题呢？本篇文章给你答案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咖啡君在开始写文章时首选了微信公众号作为发布平台，但公众号在PC端的体验并不好，连最基本的文章列表都没有，所以就搭建了&lt;a href=&quot;https://ops-coffee.cn&quot;&gt;运维咖啡吧&lt;/a&gt;的网站，可以通过点击文章底部“阅读原文”访问网站体验&lt;/p&gt;
&lt;p&gt;为了方便管理及节约成本，选择了免费的Github Pages作为网站运行平台。用Django写了个管理后台来管理文章，管理后台跑在我的电脑上，它可以将markdown格式的内容生成静态页面并自动上传至Github，管理后台的介绍看这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/7g2wncQG1lIziOmtBxXwEw&quot;&gt;利用Django徒手写个静态页面生成工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于Github拒绝百度爬虫（这也是为什么在百度里搜索不到Github仓库的原因），且网站没有备案，所以针对百度的SEO优化就直接放弃了，把精力放在了Google搜索上，下图是当前访问网站的用户来源饼图，可以看出优化的效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20200107.1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前来自Google的搜索流量已经成了网站用户最大的来源，甚至超过了我的主动分享。达到这样的效果我都做了哪些事情呢？接着往下看&lt;/p&gt;
&lt;h2 id=&quot;收录&quot;&gt;收录&lt;/h2&gt;
&lt;p&gt;新部署的网站并不能在短时间内被Google自动收录，我们需要手动提交给Google，需要做的是：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为你的站点生成sitemap&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;登陆Google Search Console，提交你的sitemap&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20200107.2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sitemap内记录了整个网站哪些网页可以被搜索引擎所抓取，可以理解为网站所有url的集合，不同的搜索引擎支持不同的sitemap格式，最简单的可以像我一样将网站的所有url逐行记录进一个文本文件内&lt;/p&gt;
&lt;p&gt;sitemap提交后搜索引擎蜘蛛并不会立即去抓取，你可以通过上方的搜索框输入你的网页url搜索确认是否编入索引，如果没有则可以手动请求编入索引，这样收录更快速一点&lt;/p&gt;
&lt;p&gt;网站被收录之后，就需要考虑如何能尽可能多的展示给搜索的用户，网页能否被搜索引擎展示的最重要原因是网页是否对用户友好，所以所有的SEO都应该是围绕对用户友好展开的，主要包含以下几块的优化：内容、描述、性能、移动端兼容性&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;内容&lt;/h2&gt;
&lt;p&gt;内容一定是第一位的，原创的优质的内容能得到更多用户的青睐，同时对于搜索引擎来说也更喜欢，Google搜索出来的内容大多数情况下贴合度都比较高，所以考虑SEO的第一步就应该是内容足够好&lt;/p&gt;
&lt;p&gt;搜索引擎如何判定你的内容足够优秀呢？有两个数据很重要：跳出率和会话时长&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20200107.3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图来自与Google的分析工具Analytics（以下简称GA），建议给网站内添加GA检测代码，虽然国内不能访问Google，但是GA检测代码是不受影响的，添加之后可以关注一下这两个值，努力将跳出率降低以及提升用户会话时长&lt;/p&gt;
&lt;p&gt;为了降低跳出率和提升用户会话时长，我将博客内原本跳转到微信公众号的链接都给改成了博客内链接，这也是你点击知乎或者简书之类的平台外链时先跳转到本地地址询问你是否跳转站外的一个原因，就是为了降低跳出率，每篇文章底部的相关文章推荐阅读也能降低跳出率，当然这一切的前提是内容质量要够好，对用户有吸引力，对于会话时长也一样，好内容用户更有兴趣读下去，就会停留更长的时间&lt;/p&gt;
&lt;h2 id=&quot;描述&quot;&gt;描述&lt;/h2&gt;
&lt;p&gt;对于一个网页的描述，主要由以下几部分组成：URL，Title，Keywords，Description，应尽量使用清晰的、能准确说明网页内容的描述&lt;/p&gt;
&lt;p&gt;URL应尽量&lt;strong&gt;简短&lt;/strong&gt;且&lt;strong&gt;唯一&lt;/strong&gt;，最好&lt;strong&gt;可读性&lt;/strong&gt;强&lt;/p&gt;
&lt;p&gt;不同的页面要有不同的URL，不要使用同一URL去展示不同的内容，这里ajax异步请求替换页面内容是不推荐的，像vue之类的单页面应用也不推荐，这些对SEO都不友好，因为SEO在投放时实际上是按照页面维度进行投放的，如果你所有的内容都只有一个URL，那么你就只能投放一次，正常情况下肯定是投放的地址越多，被搜索到的概率也越大&lt;/p&gt;
&lt;p&gt;Title和Description非常重要，title告诉用户和搜索引擎特定的网页主题是什么，description则描述了网页大概的内容，这两个标记直接影响SEO的搜索词和搜索结果的展现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20200107.4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Google的搜索结果会展示Title、URL、Description信息，需要说明的是这里的Description可能跟你html里配置的不一致，这是因为Google觉得你的description描述不准确，会选择能更好的匹配用户查询的内容作为description信息展示给用户&lt;/p&gt;
&lt;p&gt;Title、Description和Keywords都应尽量&lt;strong&gt;清晰&lt;/strong&gt;、&lt;strong&gt;准确&lt;/strong&gt;的描述文章的内容，且要保持每个网页&lt;strong&gt;唯一&lt;/strong&gt;，不可重复&lt;/p&gt;
&lt;p&gt;准确描述网页的内容有利于蜘蛛更好的理解网页，从而更准确的推送给搜索的用户，带来更高的点击&lt;/p&gt;
&lt;h2 id=&quot;性能&quot;&gt;性能&lt;/h2&gt;
&lt;p&gt;网页打开速度快也是对用户友好很重要的一个指标，如果你的网页打开很慢很容易被用户关闭，对于搜索引擎的爬虫来说也一样，并且搜索引擎的爬虫对每个网站抓取配额是有限制的，网页打开越快，爬虫抓取效率越高，收录的网页数就会越多，被搜索到的概率就越大，所以应尽量让网页打开的快一点&lt;/p&gt;
&lt;p&gt;大多数的爬虫目前仍然是对网页源码进行抓取，并不做渲染，所以让主要内容直接显示在网页源码中非常重要，虽然Google蜘蛛已经能抓取解析简单的JS，但效率偏低，所以Google建议重要内容同步展示，这也是尽量不要用ajax异步加载内容的原因，个人博客因为是生成的静态html页面，所以没有这个问题&lt;/p&gt;
&lt;p&gt;由于博客网站数据都存储在github上，所以即便是再优化效果也可能不会太好，但还是有一些优化可以做的，网页本身已经是纯静态文件了，所以加载速度与页面加载的资源有很大的关系，尽量使页面简单，使加载的页面资源尽量少、尽量小，同时将图片等静态资源放在CDN上也可以一定程度上加快网页的加载速度&lt;/p&gt;
&lt;h2 id=&quot;移动端兼容&quot;&gt;移动端兼容&lt;/h2&gt;
&lt;p&gt;随着移动设备的普及，有很多用户会在移动端搜索内容，所以博客的移动端兼容性也非常重要，并且Google已经推出了以移动端网页作为主权重页面的移动网页索引，如果网页在PC端表现很好但对移动端不兼容，那么可能用户通过移动端搜索你的内容就会被过滤不展示&lt;/p&gt;
&lt;p&gt;个人感觉技术类的网站移动端流量应该不会很高，但事实是&lt;a href=&quot;https://ops-coffee.cn&quot;&gt;运维咖啡吧&lt;/a&gt;网站移动端的流量占比超过16%，并且这个数据还有上升的趋势，所以移动端兼容不可忽视&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20200107.5.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;很多小伙伴问咖啡君：既然有了网站，是否还有必要关注公众号呢？&lt;/p&gt;
&lt;p&gt;我觉得很有必要，公众号更新粉丝会收到消息通知，可以在上下班路上等碎片时间打开看看，看讲到的知识点，看解决方案，看处理思路，有个印象，这样在自己需要解决一样或相似问题时，即便是不知道准确的处理方法，也大概知道处理思路和关键点，再借助搜索引擎就能很快的搞定&lt;/p&gt;
&lt;p&gt;没有头绪可能就是一脸蒙蔽，连搜索都不知道搜什么，这也是为什么大家一样的百度谷歌，有的人能快速找到解决方案，有些人不行，很多时候就在这里，对于网站，可能会收藏，但你真的会主动打开查看吗？&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/wx.qrcode.png&quot; alt=&quot;扫码关注公众号查看更多实用文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关文章推荐阅读：&lt;/p&gt;
</description>
<pubDate>Sun, 19 Jan 2020 00:42:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>个人静态博客SEO该考虑哪些问题呢？本篇文章给你答案 咖啡君在开始写文章时首选了微信公众号作为发布平台，但公众号在PC端的体验并不好，连最基本的文章列表都没有，所以就搭建了 &amp;quot;运维咖啡吧&amp;q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/37Y37/p/12210979.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] Options[6]: 扩展与定制 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-06-06.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-06-06.html</guid>
<description>&lt;p&gt;由于Options模型涉及的核心对象最终都注册为相应的服务，所以从原则上讲这些对象都是可以定制的，下面提供几个这样的实例。由于Options模型提供了针对配置系统的集成，所以可以采用配置文件的形式来提供原始的Options数据，可以直接采用反序列化的方式将配置文件的内容转换成Options对象。&lt;/p&gt;

&lt;p&gt;在介绍IConfigureOptions扩展的实现之前，下面先演示如何在应用中使用它。首先在演示实例中定义一个Options类型。简单起见，我们沿用前面使用的包含两个成员的FoobarOptions类型，从而实现IEquatable&amp;lt;FoobarOptions&amp;gt;接口。最终绑定生成的是一个FakeOptions对象，为了演示针对复合类型、数组、集合和字典类型的绑定，可以为其定义相应的属性成员。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FakeOptions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarOptions Foobar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarOptions[] Array { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IList&amp;lt;FoobarOptions&amp;gt; List { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, FoobarOptions&amp;gt; Dictionary { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FoobarOptions : IEquatable&amp;lt;FoobarOptions&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Foo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Bar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FoobarOptions() { }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarOptions(&lt;span&gt;int&lt;/span&gt; foo, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bar)
    {
        Foo &lt;/span&gt;=&lt;span&gt; foo;
        Bar &lt;/span&gt;=&lt;span&gt; bar;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ToString() =&amp;gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo:{Foo}, Bar:{Bar}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Equals(FoobarOptions other) =&amp;gt; &lt;span&gt;this&lt;/span&gt;.Foo == other?.Foo &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.Bar == other?&lt;span&gt;.Bar;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在项目根目录添加一个JSON文件（命名为fakeoptions.json），如下所示的代码片段表示该文件的内容，可以看出文件的格式与FakeOptions类型的数据成员是兼容的，也就是说，这个文件的内容能够被反序列化成一个FakeOptions对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Array&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [{
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        },
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        },
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        }],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [{
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        },
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        },
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        }],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dictionary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面按照Options模式直接读取该配置文件，并将文件内容绑定为一个FakeOptions对象。如下面的代码片段所示，在调用IServiceCollection接口的AddOptions扩展方法之后，我们调用了另一个自定义的Configure&amp;lt;FakeOptions&amp;gt;扩展方法，该方法的参数表示承载原始Options数据的JSON文件的路径。这个演示程序提供的一系列调试断言表明：最终获取的FakeOptions对象与原始的JSON文件具有一致的内容。（S710）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar1 = &lt;span&gt;new&lt;/span&gt; FoobarOptions(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar2 = &lt;span&gt;new&lt;/span&gt; FoobarOptions(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar3 = &lt;span&gt;new&lt;/span&gt; FoobarOptions(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddOptions()
        &lt;/span&gt;&lt;span&gt;    .Configure&amp;lt;FakeOptions&amp;gt;(&quot;fakeoptions.json&quot;)&lt;/span&gt;&lt;span&gt;
            .BuildServiceProvider()
            .GetRequiredService&lt;/span&gt;&amp;lt;IOptions&amp;lt;FakeOptions&amp;gt;&amp;gt;&lt;span&gt;()
            .Value;

        Debug.Assert(options.Foobar.Equals(foobar1));

        Debug.Assert(options.Array[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Equals(foobar1));
        Debug.Assert(options.Array[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].Equals(foobar2));
        Debug.Assert(options.Array[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].Equals(foobar3));

        Debug.Assert(options.List[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Equals(foobar1));
        Debug.Assert(options.List[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].Equals(foobar2));
        Debug.Assert(options.List[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].Equals(foobar3));

        Debug.Assert(options.Dictionary[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Equals(foobar1));
        Debug.Assert(options.Dictionary[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Equals(foobar2));
        Debug.Assert(options.Dictionary[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Equals(foobar3));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Options模型中针对Options对象的初始化是通过&lt;span&gt;IConfigureOptions&amp;lt;TOptions&amp;gt;&lt;/span&gt;对象实现的，演示程序中调用的Configure&amp;lt;TOptions&amp;gt;方法实际上就是注册了这样一个服务。我们采用Newtonsoft.Json来完成针对JSON的序列化，并且使用基于物理文件系统的IFileProvider来读取文件。Configure&amp;lt;TOptions&amp;gt;方法注册的实际上就是如下这个JsonFileConfigureOptions&amp;lt;TOptions&amp;gt;类型。JsonFileConfigureOptions&amp;lt;TOptions&amp;gt;实现了IConfigureNamedOptions&amp;lt;TOptions&amp;gt;接口，在调用构造函数创建一个JsonFileConfigureOptions&amp;lt;TOptions&amp;gt;对象的时候，我们指定了Options名称、JSON文件的路径以及用于读取该文件的IFileProvider对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JsonFileConfigureOptions&amp;lt;TOptions&amp;gt; : IConfigureNamedOptions&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IFileProvider _fileProvider;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _path;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; JsonFileConfigureOptions(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; path, IFileProvider fileProvider)
    {
        _fileProvider &lt;/span&gt;=&lt;span&gt; fileProvider;
        _path &lt;/span&gt;=&lt;span&gt; path;
        _name &lt;/span&gt;=&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _name !=&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes;
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; stream =&lt;span&gt; _fileProvider.GetFileInfo(_path).CreateReadStream())
        {
            bytes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[stream.Length];
            stream.Read(bytes, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
        }

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; contents =&lt;span&gt; Encoding.Default.GetString(bytes);
        contents &lt;/span&gt;= contents.Substring(contents.IndexOf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newOptions = JsonConvert.DeserializeObject&amp;lt;TOptions&amp;gt;&lt;span&gt;(contents);
        Bind(newOptions, options);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(TOptions options) =&amp;gt;&lt;span&gt; Configure(Options.DefaultName, options);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Bind(&lt;span&gt;object&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; to)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type = &lt;span&gt;from&lt;/span&gt;&lt;span&gt;.GetType();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (type.IsDictionary())
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dest =&lt;span&gt; (IDictionary)to;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; src = (IDictionary)&lt;span&gt;from&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; src.Keys)
            {
                dest.Add(key, src[key]);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (type.IsCollection())
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dest =&lt;span&gt; (IList)to;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; src = (IList)&lt;span&gt;from&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; src)
            {
                dest.Add(item);
            }
        }

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; property &lt;span&gt;in&lt;/span&gt;&lt;span&gt; type.GetProperties())
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (property.IsSpecialName || property.GetMethod == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                property.Name &lt;/span&gt;== &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || property.DeclaringType !=&lt;span&gt; type)
            {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; src = property.GetValue(&lt;span&gt;from&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyType = src?.GetType() ??&lt;span&gt; property.PropertyType;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((propertyType.IsValueType || src &lt;span&gt;is&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; || src == &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; property.SetMethod != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                property.SetValue(to, src);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dest =&lt;span&gt; property.GetValue(to);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != dest &amp;amp;&amp;amp; !&lt;span&gt;propertyType.IsArray())
            {
                Bind(src, dest);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (property.SetMethod != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; destType =&lt;span&gt; propertyType.IsDictionary()
                    &lt;/span&gt;? &lt;span&gt;typeof&lt;/span&gt;(Dictionary&amp;lt;,&amp;gt;&lt;span&gt;).MakeGenericType(propertyType.GetGenericArguments())
                    : propertyType.IsArray()
                    &lt;/span&gt;? &lt;span&gt;typeof&lt;/span&gt;(List&amp;lt;&amp;gt;&lt;span&gt;).MakeGenericType(propertyType.GetElementType())
                    : propertyType.IsCollection()
                    &lt;/span&gt;? &lt;span&gt;typeof&lt;/span&gt;(List&amp;lt;&amp;gt;&lt;span&gt;).MakeGenericType(propertyType.GetGenericArguments())
                    : propertyType;

                dest &lt;/span&gt;=&lt;span&gt; Activator.CreateInstance(destType);
                Bind(src, dest);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (propertyType.IsArray())
                {
                    IList list &lt;/span&gt;=&lt;span&gt; (IList)dest;
                    dest &lt;/span&gt;=&lt;span&gt; Array.CreateInstance(propertyType.GetElementType(), list.Count);
                    list.CopyTo((Array)dest, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                }
                property.SetValue(to, src);
            }
        }
    }
}

&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Extensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsDictionary(&lt;span&gt;this&lt;/span&gt; Type type) =&amp;gt; type.IsGenericType &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt;(IDictionary).IsAssignableFrom(type) &amp;amp;&amp;amp; type.GetGenericArguments().Length == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsCollection(&lt;span&gt;this&lt;/span&gt; Type type) =&amp;gt; &lt;span&gt;typeof&lt;/span&gt;(IEnumerable).IsAssignableFrom(type) &amp;amp;&amp;amp; type != &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsArray(&lt;span&gt;this&lt;/span&gt; Type type) =&amp;gt; &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Array).IsAssignableFrom(type);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实现的Configure方法中，JsonFileConfigureOptions&amp;lt;TOptions&amp;gt;利用提供的IFileProvider对象读取了指定JSON文件的内容，并将其反序列化成一个新的Options对象。由于Options模型最终提供的总是IOptionsFactory&amp;lt;TOptions&amp;gt;对象最初创建的那个Options对象，所以针对Options的初始化只能针对这个Options对象。因此，不能使用新的Options对象替换现有的Options对象，&lt;span&gt;只能将新Options对象承载的数据绑定到现有的这个Options对象上&lt;/span&gt;，针对Options对象的绑定实现在上面提供的Bind方法中。如下所示的代码片段是注册JsonFileConfigureOptions&amp;lt;TOptions&amp;gt;对象的Configure&amp;lt;TOptions&amp;gt;扩展方法的定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt; filePath, &lt;span&gt;string&lt;/span&gt; basePath = &lt;span&gt;null&lt;/span&gt;)  &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
        &lt;/span&gt;=&amp;gt; services.Configure&amp;lt;TOptions&amp;gt;&lt;span&gt;(Options.DefaultName, filePath, basePath);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt; filePath,  &lt;span&gt;string&lt;/span&gt; basePath = &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileProvider = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(basePath)
            &lt;/span&gt;? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PhysicalFileProvider(Directory.GetCurrentDirectory())
            : &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PhysicalFileProvider(basePath);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddSingleton&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;( &lt;span&gt;new&lt;/span&gt; JsonFileConfigureOptions&amp;lt;TOptions&amp;gt;&lt;span&gt;(name, filePath, fileProvider));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过对IOptionsMonitor&amp;lt;Options&amp;gt;的介绍，可知它通过&lt;span&gt;IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;&lt;/span&gt;对象来感知Options数据的变化。到目前为止，我们尚未涉及针对这个服务的注册，下面演示如何通过注册该服务来实现定时刷新Options数据。对于如何同步Options数据，最理想的场景是在数据源发生变化的时候及时将通知“推送”给应用程序。如果采用本地文件，采用这种方案是很容易实现的。但是在很多情况下，实时监控数据变化的成本很高，消息推送在技术上也不一定可行，此时需要退而求其次，使应用定时获取并更新Options数据。这样的应用场景可以通过注册一个自定义的IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;实现类型来完成。&lt;/p&gt;
&lt;p&gt;在讲述自定义IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;类型的具体实现之前，先演示针对Options数据的定时刷新。我们依然沿用前面定义的FoobarOptions作为绑定的目标Options类型，而具体的演示程序则体现在如下所示的代码片段中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; optionsMonitor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddOptions()
            .Configure&lt;/span&gt;&amp;lt;FoobarOptions&amp;gt;(TimeSpan.FromSeconds(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
            .Configure&lt;/span&gt;&amp;lt;FoobarOptions&amp;gt;(foobar =&amp;gt;&lt;span&gt;
            {
                foobar.Foo &lt;/span&gt;= random.Next(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
                foobar.Bar &lt;/span&gt;= random.Next(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            })
            .BuildServiceProvider()
            .GetRequiredService&lt;/span&gt;&amp;lt;IOptionsMonitor&amp;lt;FoobarOptions&amp;gt;&amp;gt;&lt;span&gt;();

        optionsMonitor.OnChange(foobar  &lt;/span&gt;=&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{DateTime.Now}]{foobar}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        Console.Read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，针对自定义IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;对象的注册实现在我们为IServiceCollection接口定义的Configure&amp;lt;FoobarOptions&amp;gt;扩展方法中，该方法具有一个TimeSpan类型的参数表示定时刷新Options数据的时间间隔。在演示程序中，我们将这个时间间隔设置为1秒。为了模拟数据的实时变化，可以调用Configure&amp;lt;FoobarOptions&amp;gt;扩展方法注册一个Action&amp;lt;FoobarOptions&amp;gt;对象来更新Options对象的两个属性值。&lt;/p&gt;
&lt;p&gt;利用IServiceProvider对象得到IOptionsMonitor&amp;lt;FoobarOptions&amp;gt;对象，并调用其OnChange方法注册了一个Action&amp;lt;FoobarOptions&amp;gt;对象，从而将FoobarOptions承载的数据和当前时间打印出来。由于我们设置的自动刷新时间为1秒，所以程序会以这个频率定时将新的Options数据以下图所示的形式打印在控制台上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200119083553284-334355866.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;103&quot; title=&quot;7-11&quot; alt=&quot;7-11&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200119083553894-1478054271.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前面演示程序中的Configure&amp;lt;TOptions&amp;gt;扩展方法注册了一个&lt;span&gt;TimedRefreshTokenSource&amp;lt;TOptions&amp;gt;&lt;/span&gt;对象，下面的代码片段给出了该类型的完整定义。从给出的代码片段可以看出，实现的OptionsChangeToken方法返回的IChangeToken对象是通过字段_changeToken表示的OptionsChangeToken对象，它与第6章介绍的ConfigurationReloadToken类型具有完全一致的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TimedRefreshTokenSource&amp;lt;TOptions&amp;gt; : IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OptionsChangeToken _changeToken;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TimedRefreshTokenSource(TimeSpan interval, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name = name ??&lt;span&gt; Options.DefaultName;
        _changeToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OptionsChangeToken();
        ChangeToken.OnChange(() &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt; CancellationChangeToken(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource(interval).Token),
            () &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; previous = Interlocked.Exchange(&lt;span&gt;ref&lt;/span&gt; _changeToken, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OptionsChangeToken());
                previous.OnChange();
            });
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IChangeToken GetChangeToken() =&amp;gt;&lt;span&gt; _changeToken;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionsChangeToken : IChangeToken
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; CancellationTokenSource _tokenSource;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsChangeToken() =&amp;gt; _tokenSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasChanged =&amp;gt;&lt;span&gt; _tokenSource.Token.IsCancellationRequested;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ActiveChangeCallbacks =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDisposable RegisterChangeCallback(Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; callback, &lt;span&gt;object&lt;/span&gt; state) =&amp;gt;&lt;span&gt; _tokenSource.Token.Register(callback, state);
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnChange() =&amp;gt;&lt;span&gt; _tokenSource.Cancel();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过调用构造函数创建一个TimedRefreshTokenSource&amp;lt;TOptions&amp;gt;对象时，除了需要指定Options的名称，还需要提供一个TimeSpan对象来控制Options自动刷新的时间间隔。在构造函数中，可以通过调用ChangeToken的OnChange方法以这个间隔定期地创建新的OptionsChangeToken对象并赋值给_changeToken。与此同时，我们通过调用前一个OptionsChange&lt;br/&gt;Token对象的OnChange方法对外通知Options已经发生变化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TimeSpan refreshInterval)
        &lt;/span&gt;=&amp;gt; services.AddSingleton&amp;lt;IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;&amp;gt;( &lt;span&gt;new&lt;/span&gt; TimedRefreshTokenSource&amp;lt;TOptions&amp;gt;&lt;span&gt;(refreshInterval, name));
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;( &lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, TimeSpan refreshInterval)
        &lt;/span&gt;=&amp;gt; services.Configure&amp;lt;TOptions&amp;gt;&lt;span&gt;(Options.DefaultName, refreshInterval);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[1]: 配置选项的正确使用方式[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[2]: 配置选项的正确使用方式[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[3]: Options模型[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[4]: Options模型[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[5]: 依赖注入&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[6]: 扩展与定制&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[7]: 与配置系统的整合&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Jan 2020 00:36:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>由于Options模型涉及的核心对象最终都注册为相应的服务，所以从原则上讲这些对象都是可以定制的，下面提供几个这样的实例。由于Options模型提供了针对配置系统的集成，所以可以采用配置文件的形式来提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-06-06.html</dc:identifier>
</item>
<item>
<title>如何设计一个优雅的RESTFUL的接口 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/12210940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/12210940.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;show me the code and talk to me,做的出来更要说的明白&lt;br/&gt;我是布尔bl，你的支持是我分享的动力！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-引入&quot;&gt;一 、引入&lt;/h2&gt;
&lt;p&gt;设计接口是我们开发人员的日常操作。当我们把接口交给前端人员时，是否有种拔剑出鞘的错觉。毕竟交付接口，我们的开发工作就阶段性完成了。不过，如果我们没有一个接口设计规范的时候，结果会怎样呢？我们来张图感受一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20200118222541.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二rest&quot;&gt;二、REST&lt;/h2&gt;
&lt;p&gt;2000年，一个年轻小伙子（Roy Thomas Fielding）在他的博士论文提出了 REST。REST 是一种万维网软件架构风格。为什么说是风格不是标准呢？个人理解可能说标准就有点过分了。小伙子做不到。随后这种风格被推广开来，漂洋过海，被大众熟知。在 REST 的基础上，产生了 RESTFUL 。什么是 RESTFUL？简单的说，符合 REST 风格的接口就是 RESTFUL。&lt;/p&gt;
&lt;h2 id=&quot;三restful&quot;&gt;三、RESTFUL&lt;/h2&gt;
&lt;p&gt;接口各种各样。正如一千个人眼里有一千个鲁迅。RESTFUL 接口究竟长什么样子呢？&lt;/p&gt;
&lt;h3 id=&quot;http-的方法&quot;&gt;3.1 HTTP 的方法&lt;/h3&gt;
&lt;p&gt;HTTP 里面有几个基本的方法。我们利用这些约定一些规范。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;获取数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;插入数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;更新数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;DELECT&lt;/td&gt;
&lt;td&gt;删除数据&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从表中，如果我们可以清楚看到当我们的接口是关于获取数据，那么我们使用 GET 方法。&lt;br/&gt;如果我们可以清楚看到当我们的接口是关于插入数据，那么我们使用 POST 方法。&lt;br/&gt;如果我们可以清楚看到当我们的接口是关于更新数据，那么我们使用 PUT 方法。&lt;br/&gt;如果我们可以清楚看到当我们的接口是关于删除数据，那么我们使用 DELECT 方法。&lt;/p&gt;
&lt;h3 id=&quot;名词&quot;&gt;3.2 名词&lt;/h3&gt;
&lt;p&gt;在上面我们已经知道接口在什么时候需要什么方法，那么我们现在来进入到设计接口的第二步。&lt;/p&gt;
&lt;p&gt;我们看看线上网站的接口是怎么样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20200118232332.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中我们可以看到有个 v1 ，他代表的是版本号，所以我们在设计接口的时候可以在将版本号写上，用 v1、v2、v3 等表示。&lt;/p&gt;
&lt;p&gt;我们发现他的接口都是名词。所以我们知道 RESTFUL 接口使用的是名词。比如我们设计一个获取数据的接口，我们可这样设计&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/v1/list &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面接口是获取所有数据。&lt;/p&gt;
&lt;p&gt;当我们需要列表中的一条数据，我们可以这样设计&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/v1/list/1 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面接口表示获取是列表的1号数据，我们可以获取2号、3号数据等等，只要改变数字即可。&lt;/p&gt;
&lt;h3 id=&quot;组合&quot;&gt;3.3 组合&lt;/h3&gt;
&lt;p&gt;结合上面两步，我们就可以设计出增删改查的 restful 接口了。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;/v1/list&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;获取列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;/v1/list&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;增加列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;/v1/list&lt;/td&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;更新列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;/v1/list&lt;/td&gt;
&lt;td&gt;DELECT&lt;/td&gt;
&lt;td&gt;删除列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;应用&quot;&gt;3.4 应用&lt;/h3&gt;
&lt;p&gt;以下是源码的demo&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
@Slf4j
public class LsbRestfulApplication {

    public static void main(String[] args) {
        SpringApplication.run(LsbRestfulApplication.class, args);
    }

    /**
     * 得到所有列表
     * @return
     */
    @RequestMapping(value = &quot;/v1/list&quot;,method = RequestMethod.GET)
    public String getList(){
        log.info(&quot;得到列表&quot;);
        return &quot;得到列表&quot;;
    }

    /**
     * 得到列表中的一条
     * @param name
     * @return
     */
    @RequestMapping(value = &quot;/v1/list/{name}&quot;,method = RequestMethod.GET)
    public String getListone(@PathVariable(&quot;name&quot;) String name){
        log.info(&quot;得到列表&quot;+name);
        return &quot;得到列表&quot;+name;
    }

    /**
     * 往列表中的增加一条数据
     * @return
     */
    @RequestMapping(value = &quot;/v1/list&quot;,method = RequestMethod.POST)
    public String addList(){
        log.info(&quot;增加一个列表1&quot;);
        return &quot;增加一个列表1&quot;;
    }

    /**
     * 更新列表中的一条数据
     * @return
     */
    @RequestMapping(value = &quot;/v1/list/{name}&quot;,method = RequestMethod.PUT)
    public String updateListOne(@PathVariable(&quot;name&quot;) String name){
        log.info(&quot;更新列表&quot;+name);
        return &quot;更新列表&quot;+name;
    }
    
    /**
     * 删除所有列表
     * @return
     */
    @RequestMapping(value = &quot;/v1/list&quot;,method = RequestMethod.DELETE)
    public String delList(){
        log.info(&quot;删除一个列表&quot;);
        return &quot;删除一个列表&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四某同城交友网站&quot;&gt;四、某同城交友网站&lt;/h2&gt;
&lt;p&gt;https://github.com/buerbl&lt;/p&gt;
&lt;p&gt;暗号：荆轲刺秦王&lt;/p&gt;
</description>
<pubDate>Sun, 19 Jan 2020 00:05:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>show me the code and talk to me,做的出来更要说的明白 我是布尔bl，你的支持是我分享的动力！ 一 、引入 设计接口是我们开发人员的日常操作。当我们把接口交给前端人员时，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhuantou/p/12210940.html</dc:identifier>
</item>
<item>
<title>通过例子进阶学习C++（七）CMake项目通过模板库实现约瑟夫环 - siwei718</title>
<link>http://www.cnblogs.com/siweihz/p/12202811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/siweihz/p/12202811.html</guid>
<description>&lt;p&gt;本文是通过例子学习C++的第七篇，通过这个例子可以快速入门c++相关的语法。&lt;/p&gt;

&lt;p&gt;回顾一下约瑟夫环问题：&lt;strong&gt;n&lt;/strong&gt; 个人围坐在一个圆桌周围，现在从第 &lt;strong&gt;s&lt;/strong&gt; 个人开始报数，数到第 &lt;strong&gt;m&lt;/strong&gt; 个人，让他出局；然后从出局的下一个人重新开始报数，数到第 &lt;strong&gt;m&lt;/strong&gt; 个人，再让他出局......,如此反复直到所有人全部出局为止。&lt;/p&gt;
&lt;p&gt;上一篇我们通过数组、静态链表实现了约瑟夫环，具体参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/siweihz/p/12198744.html&quot; target=&quot;_blank&quot;&gt;通过例子进阶学习C++（六）你真的能写出约瑟夫环么&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文，我们进一步深入分析约瑟夫环问题，并通过c++模板库实现该问题求解，最后我们说明用模板库的优劣之处。&lt;/p&gt;

&lt;p&gt;本文我们用c++的模板库通过单向循环链表实现约瑟夫环问题，用c++模板库实现约瑟夫环。&lt;/p&gt;
&lt;p&gt;首先我们在Visual Studio中“文件”--“新建”--”CMake项目“：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200116205300099-1190578132.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“下一步”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200116205406444-516828091.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“创建”，即可生成一个CMake的C++项目。&lt;/p&gt;
&lt;p&gt;在解决方案上面，点击“右键”，“添加”--“新建文件夹”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200116205935587-1800352902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在文件夹中新建文件“circList.h”、“CMakeLists.txt”和“main.cpp”。&lt;/p&gt;
&lt;p&gt;然后在整个项目的“CMakeLists.txt&quot;中增加如下内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200116210324462-31466921.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用C++模板库实现约瑟夫环，主要包括这3个文件：“circList.h”、“CMakeLists.txt”和“main.cpp”。整个代码以《数据结构 用面向对象方法与c++语言描述》（第2版）上面的实现为基础。&lt;/p&gt;
&lt;p&gt;用书本上面的例子，是无法直接运行的，耗费了一定的时间才修改好。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;circList.h&lt;/code&gt;相关代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T&amp;gt;
struct CircLinkNode {
    T data;
    CircLinkNode&amp;lt;T&amp;gt;* link;
    CircLinkNode(CircLinkNode&amp;lt;T&amp;gt; *next = NULL):link(next){}
    CircLinkNode(T d, CircLinkNode&amp;lt;T&amp;gt; *next = NULL):data(d),link(next){}
};

template&amp;lt;class T&amp;gt;
class CircList {
public:
    CircList() {
        first = last = NULL;
    }
    CircList(const T&amp;amp; x) {
        first = new CircLinkNode&amp;lt;T&amp;gt;(x);
    }
    CircList(CircList&amp;lt;T&amp;gt;&amp;amp; L) {
        T value;
        CircLinkNode&amp;lt;T&amp;gt;* srcptr = L.getHead();
        CircLinkNode&amp;lt;T&amp;gt;* destptr = first = new CircLinkNode&amp;lt;T&amp;gt;;
        while (srcptr-&amp;gt;link != NULL) {
            value = srcptr-&amp;gt;link-&amp;gt;data;
            destptr-&amp;gt;link = new CircLinkNode&amp;lt;T&amp;gt;(value);
            destptr = destptr-&amp;gt;link;
            srcptr = srcptr-&amp;gt;link;
        }
        destptr-&amp;gt;link = NULL;
    }
    ~CircList() {
        //makeEmpty();
    }
    void makeEmpty() {
        CircLinkNode&amp;lt;T&amp;gt;* q;
        while (first!=NULL &amp;amp;&amp;amp; first-&amp;gt;link != first) {
            q = first-&amp;gt;link;
            first-&amp;gt;link = q-&amp;gt;link;
            delete q;
        }
    }
    int length() const {
        CircLinkNode&amp;lt;T&amp;gt;* p = first-&amp;gt;link;
        int count = 0;
        while (p != NULL) {
            count++;
            p = p-&amp;gt;link;
        }
        return count;
    }
    CircLinkNode&amp;lt;T&amp;gt;* getHead()const {
        return first;
    }
    void setHead(CircLinkNode&amp;lt;T&amp;gt;* p) {
        first = p;
    }
    CircLinkNode&amp;lt;T&amp;gt;* Search(T x) {
        CircLinkNode&amp;lt;T&amp;gt;* current = first-&amp;gt;link;
        while (current != first) {
            if (current-&amp;gt;data == x) break;
            else current = current-&amp;gt;link;
        }
        return current;
    }
    CircLinkNode&amp;lt;T&amp;gt;* Locate(int i) {
        if (i &amp;lt; 0) return NULL;
        CircLinkNode&amp;lt;T&amp;gt;* current = first;
        int k = 0;
        while (current-&amp;gt;link != first &amp;amp;&amp;amp; k &amp;lt; i) {
            current = current-&amp;gt;link;
            k++;
        }
        return current;
    }
    T* getData(int i) {
        if (i &amp;lt; 0) return NULL;
        CircLinkNode&amp;lt;T&amp;gt;* current = Locate(i);
        if (current == NULL) return NULL;
        else return &amp;amp;current-&amp;gt;data;
    }

    void setData(int i, T&amp;amp; x) {
        if (i &amp;lt; 0) return;
        CircLinkNode&amp;lt;T&amp;gt;* current = Locate(i);
        if (current == NULL) return;
        else current-&amp;gt;data = x;
    }

    bool Insert(int i, T&amp;amp; x) {
        CircLinkNode&amp;lt;T&amp;gt;* newNode = new CircLinkNode&amp;lt;T&amp;gt;(x);
        if (newNode == NULL) {
            cerr &amp;lt;&amp;lt; &quot;存储分配失败！&quot; &amp;lt;&amp;lt; endl;
            exit(1);
        }
        
        if (i == 1) {
            first = last = newNode;
            first-&amp;gt;link = newNode;
        }
        else {
            last-&amp;gt;link = newNode;
            last = newNode;
        }
        
        newNode-&amp;gt;link = first;  
        return true;
    }
    bool Remove(int i, CircLinkNode&amp;lt;T&amp;gt; * p, CircLinkNode&amp;lt;T&amp;gt;* pre) {
        if (first == p) {
            first = p-&amp;gt;link;
        }
        if (last == p) {
            last = pre;
        }
        delete p;
        return true;
    }
    void output() {
        CircLinkNode&amp;lt;T&amp;gt;* current = first-&amp;gt;link; 
        cout &amp;lt;&amp;lt; first-&amp;gt;data &amp;lt;&amp;lt; &quot;  &quot;;

        while (current != last-&amp;gt;link) {
            cout &amp;lt;&amp;lt; current-&amp;gt;data &amp;lt;&amp;lt;&quot;  &quot;;
            current = current-&amp;gt;link;
        }
        cout &amp;lt;&amp;lt; endl;
    }
private:
    CircLinkNode&amp;lt;T&amp;gt;* first, * last;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CMakeLists.txt&lt;/code&gt;相关代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# CMakeList.txt: DataStructure 的 CMake 项目，在此处包括源代码并定义
# 项目特定的逻辑。
#
cmake_minimum_required (VERSION 3.8)

# 将源代码添加到此项目的可执行文件。
add_executable (circList &quot;main.cpp&quot; &quot;circList.h&quot; )

# TODO: 如有需要，请添加测试并安装目标。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt;相关代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include &quot;circList.h&quot;

using namespace std;

template&amp;lt;class T&amp;gt;
void Josephus(CircList&amp;lt;T&amp;gt; &amp;amp;Js,int n,int m) {
    CircLinkNode&amp;lt;T&amp;gt;* p = Js.getHead();
    CircLinkNode&amp;lt;T&amp;gt;* pre = NULL;

    int i, j;
    for (i = 0; i &amp;lt; n - 1; i++) {
        for (j = 0; j &amp;lt; m-1; j++) {
            pre = p;
            p = p-&amp;gt;link;
        }
        
        cout &amp;lt;&amp;lt; &quot;出列的是：&quot; &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; endl;
        pre-&amp;gt;link = p-&amp;gt;link;

        Js.Remove(p-&amp;gt;data,p,pre);
        
        p = pre-&amp;gt;link;

        cout &amp;lt;&amp;lt; &quot;出列后的队列为：&quot; &amp;lt;&amp;lt; endl;
        Js.output();
        cout &amp;lt;&amp;lt; &quot;当前元素为：&quot; &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; endl;
    }
}

int main() {
    CircList&amp;lt;int&amp;gt; clist;
    int i, n, m;
    cout &amp;lt;&amp;lt; &quot;输入游戏者人数和报数间隔：&quot;&amp;lt;&amp;lt;endl;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (i = 1; i &amp;lt;= n; i++) {
        clist.Insert(i,i);
    }

    Josephus(clist, n, m);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行后效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200116211042117-1612024798.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本着&lt;code&gt;Talk is cheap. Show me the code&lt;/code&gt;原则，代码实现不做过多解释。&lt;/p&gt;
&lt;p&gt;通过该例子，可以学习：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Visual Studio中搭建CMake项目；&lt;/li&gt;
&lt;li&gt;在CMake项目中增加“可执行文件”；&lt;/li&gt;
&lt;li&gt;掌握struct定义；class定义；template class 、function定义；构造函数；析构函数；&lt;/li&gt;
&lt;li&gt;通过模板库实现约瑟夫环问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文从构思到完成，可谓是耗费了大量的心血。&lt;/p&gt;
&lt;p&gt;如果您阅读本文后哪怕有一丢丢收获，请不要吝啬你手中&lt;strong&gt;关注&lt;/strong&gt;和&lt;strong&gt;点赞&lt;/strong&gt;的权力，谢谢！&lt;/p&gt;
&lt;p&gt;另外，如果需要相关代码，请留言，&lt;strong&gt;可以提供完整源代码&lt;/strong&gt;！&lt;/p&gt;
</description>
<pubDate>Sat, 18 Jan 2020 23:37:00 +0000</pubDate>
<dc:creator>siwei718</dc:creator>
<og:description>本文是通过例子学习C++的第七篇，通过这个例子可以快速入门c++相关的语法。 1.问题描述 回顾一下约瑟夫环问题： n 个人围坐在一个圆桌周围，现在从第 s 个人开始报数，数到第 m 个人，让他出局；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/siweihz/p/12202811.html</dc:identifier>
</item>
<item>
<title>如果你热爱编码，就应该少写代码 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12210927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12210927.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;97.898269896194&quot;&gt;
&lt;p&gt;“如果你喜欢一个人，就应该尽量少说那些甜言蜜语。”不知道大家是否听过某些恋爱专家的肺腑之言。对于程序员来说，如果你热爱编码，那么我也劝你：“能少写一行代码就尽量少写一行。”&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/code-less-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;可能有些同学觉得这话听起来有点玄乎：“代码写得少，不就意味着缺乏实战经验吗？那我何年何月才能进一线大厂，成为真正的大神呢？”&lt;/p&gt;
&lt;p&gt;如果你要这么理解的话，我就必须要纠正你一下。我表达的意思是这样的，来通过两行简短的代码表情达意吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (str == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; || &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;.equals(str)) {}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (StringUtils.isEmpty()) {}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就上面这两行代码来说，我的第一选择是使用第二行代码来进行判空操作，因为它的代码量更少——简洁明了，也更不容易出错。&lt;/p&gt;
&lt;p&gt;如果我们程序员没有这种（写更少代码的）追求的话，那我们的编程技艺就只会原地踏步，长此以往的后果就是各种避免重复造轮子的第三方类库就不会出现。&lt;/p&gt;
&lt;p&gt;就判空操作来说，&lt;code&gt;str == null || &quot;&quot;.equals(str)&lt;/code&gt; 已经干得非常漂亮了（null 和空字符串都考虑在内了），但性能仍然有待优化，可以使用更高效的 &lt;code&gt;str == null || str.length() == 0&lt;/code&gt; 来替代。为什么这么说呢？&lt;/p&gt;
&lt;p&gt;因为 Sting 类的 &lt;code&gt;equals()&lt;/code&gt; &lt;a href=&quot;https://mp.weixin.qq.com/s/WyrRCUlelzOxyfVBrxAGUg&quot;&gt;方法&lt;/a&gt;本身是很沉重的，其源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object anObject)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; == anObject) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (anObject &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; String) {&lt;br/&gt;String aString = (String)anObject;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!COMPACT_STRINGS || &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.coder == aString.coder) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; StringLatin1.equals(value, aString.value);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 &lt;code&gt;str.length() == 0&lt;/code&gt; 则简单得多，无非就是两个数值“==”比较。孰优孰劣，高下立见。&lt;code&gt;StringUtils.isEmpty()&lt;/code&gt; 的内部就恰好使用的是 &lt;code&gt;str == null || str.length() == 0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于某些程序员来说，承认这个事实是痛苦的，因为他们是那么的热爱原生。他们争辩说：“那我宁愿使用 &lt;code&gt;str == null || str.length() == 0&lt;/code&gt; 也不使用第三方类库的 &lt;code&gt;StringUtils.isEmpty()&lt;/code&gt;，因为写原生更直接、更纯粹。”&lt;/p&gt;
&lt;p&gt;不，别这样，我耐着性子再劝一句，要理智啊。假如哪天需要把&quot; &quot;（n 个空格）这样的字符串也作为空字符串进行判断呢？难不成要在原生的判断条件中追加 n 个 &lt;code&gt;|| &quot; &quot;.equals(str)&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;还是追求简洁点好啊！因为我们可以把 &lt;code&gt;StringUtils.isEmpty()&lt;/code&gt; 换成 &lt;code&gt;StringUtils.isBlank()&lt;/code&gt;，该方法已经为我们考虑好了，来看一下源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;isBlank&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; CharSequence cs)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; strLen;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (cs == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; || (strLen = cs.length()) == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; strLen; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (Character.isWhitespace(cs.charAt(i)) == &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很周全吧？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为程序员，为我们编写的每一行代码负责任是理所应当的一件事&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;代码简洁度；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;功能的完整度；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行速度；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;编码所花费的时间；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;健壮性；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;灵活性。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这 6 项指标都值得我们去考量，尽管它们之间有些是对立的，比如说花了一个月的时间实现了一个健壮性非常良好、执行速度也非常快的程序，那可能“编码所花费的时间”（一个月）就有点长了。那怎么样做是值得的呢？&lt;/p&gt;
&lt;p&gt;答案只有一个：从简洁开始，再去达其他的标。&lt;/p&gt;
&lt;p&gt;代码会随着时间的推移慢慢增加（新的需求、bug 修复），你写的代码越多，bug 藏身的地方就越多，代码编译的速度就会越慢，维护代码的压力也会随之增加。&lt;/p&gt;
&lt;p&gt;这是不争的事实。&lt;/p&gt;
&lt;p&gt;就好像我们程序员一样，岁月这把杀猪刀不仅会给我们理个发（减少一下发量），还会增加我们的赘肉，如果不坚持锻炼的话，新陈代谢的减缓就会让我们胖成球。&lt;/p&gt;
&lt;p&gt;代码是我们程序员创造出来的，如果只在扩展功能的时候追加代码，不在重构的时候精简代码，那么堆叠如山的代码就会像苹果一样腐烂，一个传染俩。&lt;/p&gt;
&lt;p&gt;当然了，代码并不是我们的敌人，真正的敌人是谁呢？你往镜子前面一站就恍然大悟了。&lt;strong&gt;真正的敌人是我们自己，如果你还热爱编码，就要时刻提醒自己，能少写代码就少写&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;记得伟大的文学家马克吐温曾说过这样一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我没有时间写一封简短的信，所以我写了一封长的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写代码和写文字在本质上是一种事情，把代码写得少一点远比写得多一点更不容易，它需要耗费更多的脑力才能完成。&lt;/p&gt;
&lt;p&gt;Medium 上的一个作者 Elliot Chance 也曾表达过和我类似的观点，他说：“要分辨两个程序员的优劣，就是给他们一样的时间，越好的程序员写出来的代码越少（当然是可以运行的）。”&lt;/p&gt;
&lt;p&gt;越多的代码并不一定代表着认真，有可能代表的是懒惰，懒得去思考，才会写出臃肿的代码。那怎样才能写出更少的代码呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;首先，要多思考&lt;/strong&gt;，不要拿到需求就开始敲代码；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其次，多积累经验&lt;/strong&gt;，张三丰打架都是赤手空拳，武器招数都不要不要的，因为他真的是身经百战啊；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最后，基础扎实&lt;/strong&gt;，只有把编程语言的本质吃透，比如说上文中提到的 &lt;code&gt;str.length() == 0&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;.equals(str)&lt;/code&gt;，如果你没有研究过源码，你压根就不知道它们之间的性能优劣。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过，有一点我需要提醒大家，假如你的公司的绩效考核是按照代码的数量来评定的，那就当我什么皮也没放过。或者，要不你换一家注重代码质量的公司？&lt;/p&gt;
&lt;p&gt;好了各位读者朋友们，以上就是本文的全部内容了。能看到这里的都是最优秀的程序员，升职加薪就是你了👍。&lt;strong&gt;如果觉得这篇文章有点用的话，请不要吝啬你们手中点赞的权力&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/cmower_4.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 18 Jan 2020 22:34:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>“如果你喜欢一个人，就应该尽量少说那些甜言蜜语。”不知道大家是否听过某些恋爱专家的肺腑之言。对于程序员来说，如果你热爱编码，那么我也劝你：“能少写一行代码就尽量少写一行。” 可能有些同学觉得这话听起来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12210927.html</dc:identifier>
</item>
<item>
<title>Java 多线程安全问题简单切入详细解析 - LeeHua</title>
<link>http://www.cnblogs.com/liyihua/p/12210893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyihua/p/12210893.html</guid>
<description>&lt;p&gt;假如Java程序中有多个线程在同时运行，而这些线程可能会同时运行一部分的代码。如果说该Java程序每次运行的结果和单线程的运行结果是一样的，并且其他的变量值也都是和预期的结果是一样的，那么就可以说线程是安全的。&lt;/p&gt;


&lt;p&gt;假如有一个电影院上映《葫芦娃大战奥特曼》，售票100张（1-100号），分三种情况卖票：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1681961/202001/1681961-20200119004418775-756156060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;情况1&lt;/h2&gt;
&lt;p&gt;该电影院开设一个售票窗口，一个窗口卖一百张票，没有问题。就如同单线程程序不会出现安全问题一样。&lt;/p&gt;

&lt;h2&gt;情况2&lt;/h2&gt;
&lt;p&gt;该电影院开设n（n&amp;gt;1）个售票窗口，每个售票窗口售出指定号码的票，也不会出现问题。就如同多线程程序，没有访问共享数据，不会产生问题。&lt;/p&gt;

&lt;h2&gt;情况3&lt;/h2&gt;
&lt;p&gt;该电影院开设n（n&amp;gt;1）个售票窗口，每个售票窗口出售的票都是没有规定的（如：所有的窗口都可以出售1号票），这就会出现问题了，假如三个窗口同时在卖同一张票，或有的票已经售出，还有窗口还在出售。就如同多线程程序，访问了共享数据，会产生线程安全问题。&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MovieTicket01 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 电影票数量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ticketNumber = 100&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在实现类中重写Runnable接口的run方法，并设置此线程要执行的任务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置此线程要执行的任务&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (ticketNumber &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提高程序安全的概率，让程序睡眠10毫秒&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 电影票出售&lt;/span&gt;
            System.out.println(&quot;售票窗口（&quot; + Thread.currentThread().getName() + &quot;）正在出售：&quot; + MovieTicket01.ticketNumber + &quot;号电影票&quot;&lt;span&gt;);
            ticketNumber &lt;/span&gt;--&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo01MovieTicket {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个 Runnable接口的实现类对象。&lt;/span&gt;
        MovieTicket01 movieTicket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MovieTicket01();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Thread类对象，构造方法中传递Runnable接口的实现类对象(三个窗口)。&lt;/span&gt;
        Thread window0 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);
        Thread window1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);
        Thread window2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置一下窗口名字，方便输出确认&lt;/span&gt;
        window0.setName(&quot;window0&quot;&lt;span&gt;);
        window1.setName(&lt;/span&gt;&quot;window1&quot;&lt;span&gt;);
        window2.setName(&lt;/span&gt;&quot;window2&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Threads类中的start方法，开启新的线程执行run方法&lt;/span&gt;
&lt;span&gt;        window0.start();
        window1.start();
        window2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;控制台部分输出：
售票窗口（window0）正在出售：100号电影票
售票窗口（window2）正在出售：99号电影票
售票窗口（window1）正在出售：100号电影票
售票窗口（window0）正在出售：97号电影票
售票窗口（window2）正在出售：97号电影票
售票窗口（window1）正在出售：97号电影票
售票窗口（window1）正在出售：94号电影票
售票窗口（window2）正在出售：94号电影票
.
.
.
.
.
.
售票窗口（window0）正在出售：7号电影票
售票窗口（window2）正在出售：4号电影票
售票窗口（window0）正在出售：4号电影票
售票窗口（window1）正在出售：2号电影票
售票窗口（window1）正在出售：1号电影票
售票窗口（window2）正在出售：0号电影票
售票窗口（window0）正在出售：&lt;/span&gt;-1号电影票
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，三个窗口（线程）同时出售不指定号数的票（访问共享数据），出现了卖票重复，和出售了不存在的票号数（0、-1）&lt;/p&gt;

&lt;h2&gt;Java程序中为什么会出现这种情况&lt;/h2&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;在CPU线程的调度分类中，Java使用的是抢占式调度。&lt;/li&gt;
&lt;li&gt;我们开启了三个线程，3个线程一起在抢夺CPU的执行权，谁能抢到谁就可以被执行。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1681961/202001/1681961-20200119013032465-918200779.png&quot; alt=&quot;&quot;/&gt;

&lt;/li&gt;
&lt;li&gt;从输出结果可以知道，刚开始抢夺CPU执行权的时候，线程0（window0窗口）先抢到，再到线程1（window1窗口）抢到，最后线程2（window2窗口）才抢到。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1681961/202001/1681961-20200119013631868-767457259.png&quot; alt=&quot;&quot;/&gt;

&lt;/li&gt;
&lt;li&gt;那么为什么100号票已经在0号窗口出售了，在1号窗口还会出售呢？其实很简单，线程0先抢到CPU执行权，于是有了执行权后，他就开始嚣张了，作为第一个它通过while判断，很自豪的拿着ticketNumber = 100进入while里面开始执行。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1681961/202001/1681961-20200119014339532-1790625319.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;可线程0是万万没有想到，这时候的线程1，在拿到执行权后，在线程0刚刚实现print语句还没开始ticketNumber --的时候，线程1以ticketNumber = 100跑进了while里面。&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;线程2很遗憾，在线程0执行了ticketNumber --了才急匆匆的进入while里面，不过它也不甘落后，于是拼命追赶。终于，后来居上，在线程1还没开始print的时候，他就开始print了。于是便出现了控制台的前三条输出的情况。&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;售票窗口（window0）正在出售：100号电影票
售票窗口（window2）正在出售：99号电影票
售票窗口（window1）正在出售：100号电影票&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;window0、window1、window2分别对应线程0、线程1、线程2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;以此类推，直到最后程序执行完毕。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过线程的同步，来解决共享数据问题。有三种方式，分别是同步代码块、同步方法、锁机制。&lt;/p&gt;
&lt;h2&gt;同步代码块&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MovieTicket02 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 电影票数量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ticketNumber = 100&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建锁对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object object &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在实现类中重写Runnable接口的run方法，并设置此线程要执行的任务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置此线程要执行的任务&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (object) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把访问了共享数据的代码放到同步代码中&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (ticketNumber &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提高程序安全的概率，让程序睡眠10毫秒&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 电影票出售&lt;/span&gt;
                System.out.println(&quot;售票窗口（&quot; + Thread.currentThread().getName() + &quot;）正在出售：&quot; + MovieTicket02.ticketNumber + &quot;号电影票&quot;&lt;span&gt;);
                ticketNumber &lt;/span&gt;--&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行测试&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo02MovieTicket {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个 Runnable接口的实现类对象。&lt;/span&gt;
        MovieTicket02 movieTicket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MovieTicket02();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Thread类对象，构造方法中传递Runnable接口的实现类对象(三个窗口)。&lt;/span&gt;
        Thread window0 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);
        Thread window1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);
        Thread window2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置一下窗口名字，方便输出确认&lt;/span&gt;
        window0.setName(&quot;window0&quot;&lt;span&gt;);
        window1.setName(&lt;/span&gt;&quot;window1&quot;&lt;span&gt;);
        window2.setName(&lt;/span&gt;&quot;window2&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Threads类中的start方法，开启新的线程执行run方法&lt;/span&gt;
&lt;span&gt;        window0.start();
        window1.start();
        window2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;控制台输出：
售票窗口（window0）正在出售：100号电影票
售票窗口（window0）正在出售：99号电影票
售票窗口（window0）正在出售：98号电影票
售票窗口（window0）正在出售：97号电影票
售票窗口（window0）正在出售：96号电影票
.
.
.
.
.
.
售票窗口（window0）正在出售：5号电影票
售票窗口（window0）正在出售：4号电影票
售票窗口（window0）正在出售：3号电影票
售票窗口（window0）正在出售：2号电影票
售票窗口（window0）正在出售：1号电影票&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候，控制台不再出售不存在的电影号数以及重复的电影号数了。&lt;/p&gt;
&lt;p&gt;通过代码块中的锁对象，可以使用任意的对象。但是必须保证多个线程使用的锁对象是同一。锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行。&lt;/p&gt;
&lt;p&gt;总结：同步中的线程，没有执行完毕，不会释放锁，同步外的线程，没有锁，进不去同步。&lt;/p&gt;

&lt;h2&gt;同步方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MovieTicket03 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 电影票数量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ticketNumber = 100&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建锁对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object object &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在实现类中重写Runnable接口的run方法，并设置此线程要执行的任务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置此线程要执行的任务&lt;/span&gt;
&lt;span&gt;        ticket();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ticket() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把访问了共享数据的代码放到同步代码中&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (ticketNumber &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提高程序安全的概率，让程序睡眠10毫秒&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 电影票出售&lt;/span&gt;
            System.out.println(&quot;售票窗口（&quot; + Thread.currentThread().getName() + &quot;）正在出售：&quot; + MovieTicket03.ticketNumber + &quot;号电影票&quot;&lt;span&gt;);
            ticketNumber &lt;/span&gt;--&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试与同步代码块一样。&lt;/p&gt;


&lt;p&gt;在Java中，Lock锁机制又称为同步锁，加锁public void lock()，释放同步锁public void unlock()。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MovieTicket05 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 电影票数量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ticketNumber = 100&lt;span&gt;;

    Lock reentrantLock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在实现类中重写Runnable接口的run方法，并设置此线程要执行的任务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置此线程要执行的任务&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (ticketNumber &amp;gt; 0&lt;span&gt;) {
            reentrantLock.lock();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提高程序安全的概率，让程序睡眠10毫秒&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 电影票出售&lt;/span&gt;
                System.out.println(&quot;售票窗口（&quot; + Thread.currentThread().getName() + &quot;）正在出售：&quot; + MovieTicket05.ticketNumber + &quot;号电影票&quot;&lt;span&gt;);
                ticketNumber &lt;/span&gt;--&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                reentrantLock.unlock();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo05MovieTicket {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个 Runnable接口的实现类对象。&lt;/span&gt;
        MovieTicket05 movieTicket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MovieTicket05();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Thread类对象，构造方法中传递Runnable接口的实现类对象(三个窗口)。&lt;/span&gt;
        Thread window0 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);
        Thread window1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);
        Thread window2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(movieTicket);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置一下窗口名字，方便输出确认&lt;/span&gt;
        window0.setName(&quot;window0&quot;&lt;span&gt;);
        window1.setName(&lt;/span&gt;&quot;window1&quot;&lt;span&gt;);
        window2.setName(&lt;/span&gt;&quot;window2&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Threads类中的start方法，开启新的线程执行run方法&lt;/span&gt;
&lt;span&gt;        window0.start();
        window1.start();
        window2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;控制台部分输出：
售票窗口（window0）正在出售：100号电影票
售票窗口（window0）正在出售：99号电影票
售票窗口（window0）正在出售：98号电影票
售票窗口（window0）正在出售：97号电影票
售票窗口（window0）正在出售：96号电影票
.
.
.
.
.
.
售票窗口（window1）正在出售：7号电影票
售票窗口（window1）正在出售：6号电影票
售票窗口（window1）正在出售：5号电影票
售票窗口（window1）正在出售：4号电影票
售票窗口（window1）正在出售：3号电影票
售票窗口（window2）正在出售：2号电影票
售票窗口（window1）正在出售：1号电影票&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与前两种方式不同，前两种方式，只有线程0能够进入同步机制执行代码，Lock锁机制，三个线程都可以进行执行，通过Lock锁机制来解决共享数据问题。&lt;/p&gt;

&lt;p&gt;Java 多线程安全问题就到这里了，如果有什么不足、错误的地方，希望大佬们指正。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Jan 2020 19:10:00 +0000</pubDate>
<dc:creator>LeeHua</dc:creator>
<og:description>线程安全 假如Java程序中有多个线程在同时运行，而这些线程可能会同时运行一部分的代码。如果说该Java程序每次运行的结果和单线程的运行结果是一样的，并且其他的变量值也都是和预期的结果是一样的，那么就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liyihua/p/12210893.html</dc:identifier>
</item>
</channel>
</rss>